{
    "author": "alxhub",
    "message": "refactor(compiler-cli): remove the overrideComponentTemplate API (#40585)\n\nThe `TemplateTypeChecker.overrideComponentTemplate` operation was originally\nconceived as a \"fast path\" for the Language Service to react to a template\nchange without needing to go through a full incremental compilation step. It\nserved this purpose until the previous commit, which switches the LS to use\nthe new resource-only incremental change operation provided by `NgCompiler`.\n\n`overrideComponentTemplate` is now no longer utilized, and is known to have\nseveral hard-to-overcome issues that prevent it from being useful in any\nother situations. As such, this commit removes it entirely.\n\nPR Close #40585",
    "sha": "a3b08644280fb43d9dfd037927c4e6a48a2c9a46",
    "files": [
        {
            "sha": "84ba9b116818bd8dcd12e9acf84507c02d42239d",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/component.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/a3b08644280fb43d9dfd037927c4e6a48a2c9a46/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/a3b08644280fb43d9dfd037927c4e6a48a2c9a46/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts?ref=a3b08644280fb43d9dfd037927c4e6a48a2c9a46",
            "patch": "@@ -881,9 +881,6 @@ export class ComponentDecoratorHandler implements\n     //\n     // In order to guarantee the correctness of diagnostics, templates are parsed a second time\n     // with the above options set to preserve source mappings.\n-    //\n-    // Note: template parse options should be aligned with `template_target_spec.ts` and\n-    // `TemplateTypeCheckerImpl.overrideComponentTemplate`.\n \n     const {nodes: diagNodes} = parseTemplate(templateStr, template.sourceMapUrl, {\n       preserveWhitespaces: true,"
        },
        {
            "sha": "da1d0bb294a9637d4164bd120c0d4993b059473c",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/checker.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/a3b08644280fb43d9dfd037927c4e6a48a2c9a46/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/a3b08644280fb43d9dfd037927c4e6a48a2c9a46/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts?ref=a3b08644280fb43d9dfd037927c4e6a48a2c9a46",
            "patch": "@@ -29,29 +29,11 @@ import {DirectiveSymbol, ElementSymbol, ShimLocation, Symbol, TemplateSymbol} fr\n  * query, depending on the method either `null` will be returned or an error will be thrown.\n  */\n export interface TemplateTypeChecker {\n-  /**\n-   * Clear all overrides and return the template type-checker to the original input program state.\n-   */\n-  resetOverrides(): void;\n-\n   /**\n    * Retrieve the template in use for the given component.\n-   *\n-   * If the template has been overridden via `overrideComponentTemplate`, this will retrieve the\n-   * overridden template nodes.\n    */\n   getTemplate(component: ts.ClassDeclaration): TmplAstNode[]|null;\n \n-  /**\n-   * Provide a new template string that will be used in place of the user-defined template when\n-   * checking or operating on the given component.\n-   *\n-   * The compiler will parse this template for diagnostics, and will return any parsing errors if it\n-   * is not valid. If the template cannot be parsed correctly, no override will occur.\n-   */\n-  overrideComponentTemplate(component: ts.ClassDeclaration, template: string):\n-      {nodes: TmplAstNode[], errors: ParseError[]|null};\n-\n   /**\n    * Get all `ts.Diagnostic`s currently available for the given `ts.SourceFile`.\n    *"
        },
        {
            "sha": "2cbad7db17160609f28410da420cf0d15f17eadd",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 102,
            "changes": 110,
            "blob_url": "https://github.com/angular/angular/blob/a3b08644280fb43d9dfd037927c4e6a48a2c9a46/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/a3b08644280fb43d9dfd037927c4e6a48a2c9a46/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts?ref=a3b08644280fb43d9dfd037927c4e6a48a2c9a46",
            "patch": "@@ -20,7 +20,7 @@ import {DirectiveInScope, ElementSymbol, FullTemplateMapping, GlobalCompletion,\n import {TemplateDiagnostic} from '../diagnostics';\n \n import {CompletionEngine} from './completion';\n-import {InliningMode, ShimTypeCheckingData, TemplateData, TemplateOverride, TypeCheckContextImpl, TypeCheckingHost} from './context';\n+import {InliningMode, ShimTypeCheckingData, TemplateData, TypeCheckContextImpl, TypeCheckingHost} from './context';\n import {shouldReportDiagnostic, translateDiagnostic} from './diagnostics';\n import {TemplateSourceManager} from './source';\n import {findTypeCheckBlock, getTemplateMapping, TemplateSourceResolver} from './tcb_util';\n@@ -56,21 +56,19 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n   /**\n    * Stores directives and pipes that are in scope for each component.\n    *\n-   * Unlike other caches, the scope of a component is not affected by its template, so this\n-   * cache does not need to be invalidate if the template is overridden. It will be destroyed when\n-   * the `ts.Program` changes and the `TemplateTypeCheckerImpl` as a whole is destroyed and\n-   * replaced.\n+   * Unlike other caches, the scope of a component is not affected by its template. It will be\n+   * destroyed when the `ts.Program` changes and the `TemplateTypeCheckerImpl` as a whole is\n+   * destroyed and replaced.\n    */\n   private scopeCache = new Map<ts.ClassDeclaration, ScopeData>();\n \n   /**\n    * Stores potential element tags for each component (a union of DOM tags as well as directive\n    * tags).\n    *\n-   * Unlike other caches, the scope of a component is not affected by its template, so this\n-   * cache does not need to be invalidate if the template is overridden. It will be destroyed when\n-   * the `ts.Program` changes and the `TemplateTypeCheckerImpl` as a whole is destroyed and\n-   * replaced.\n+   * Unlike other caches, the scope of a component is not affected by its template. It will be\n+   * destroyed when the `ts.Program` changes and the `TemplateTypeCheckerImpl` as a whole is\n+   * destroyed and replaced.\n    */\n   private elementTagCache = new Map<ts.ClassDeclaration, Map<string, DirectiveInScope|null>>();\n \n@@ -86,22 +84,6 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n       private readonly componentScopeReader: ComponentScopeReader,\n       private readonly typeCheckScopeRegistry: TypeCheckScopeRegistry) {}\n \n-  resetOverrides(): void {\n-    for (const fileRecord of this.state.values()) {\n-      if (fileRecord.templateOverrides !== null) {\n-        fileRecord.templateOverrides = null;\n-        fileRecord.shimData.clear();\n-        fileRecord.isComplete = false;\n-      }\n-    }\n-\n-    // Ideally only those components with overridden templates would have their caches invalidated,\n-    // but the `TemplateTypeCheckerImpl` does not track the class for components with overrides. As\n-    // a quick workaround, clear the entire cache instead.\n-    this.completionCache.clear();\n-    this.symbolBuilderCache.clear();\n-  }\n-\n   getTemplate(component: ts.ClassDeclaration): TmplAstNode[]|null {\n     const {data} = this.getLatestComponentState(component);\n     if (data === null) {\n@@ -151,42 +133,6 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     return {data, tcb, shimPath};\n   }\n \n-  overrideComponentTemplate(component: ts.ClassDeclaration, template: string):\n-      {nodes: TmplAstNode[], errors: ParseError[]|null} {\n-    const {nodes, errors} = parseTemplate(template, 'override.html', {\n-      // Set `leadingTriviaChars` and `preserveWhitespaces` such that whitespace is not stripped\n-      // and fully accounted for in source spans. Without these flags the source spans can be\n-      // inaccurate.\n-      // Note: template parse options should be aligned with `template_target_spec.ts` and the\n-      // `diagNodes` in `ComponentDecoratorHandler._parseTemplate`.\n-      preserveWhitespaces: true,\n-      leadingTriviaChars: [],\n-    });\n-\n-    const filePath = absoluteFromSourceFile(component.getSourceFile());\n-\n-    const fileRecord = this.getFileData(filePath);\n-    const id = fileRecord.sourceManager.getTemplateId(component);\n-\n-    if (fileRecord.templateOverrides === null) {\n-      fileRecord.templateOverrides = new Map();\n-    }\n-\n-    fileRecord.templateOverrides.set(id, {nodes, errors});\n-\n-    // Clear data for the shim in question, so it'll be regenerated on the next request.\n-    const shimFile = this.typeCheckingStrategy.shimPathForComponent(component);\n-    fileRecord.shimData.delete(shimFile);\n-    fileRecord.isComplete = false;\n-    this.isComplete = false;\n-\n-    // Overriding a component's template invalidates its cached results.\n-    this.completionCache.delete(component);\n-    this.symbolBuilderCache.delete(component);\n-\n-    return {nodes, errors};\n-  }\n-\n   isTrackedTypeCheckFile(filePath: AbsoluteFsPath): boolean {\n     return this.getFileAndShimRecordsForPath(filePath) !== null;\n   }\n@@ -337,7 +283,6 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n \n     fileData.shimData.delete(shimPath);\n     fileData.isComplete = false;\n-    fileData.templateOverrides?.delete(templateId);\n \n     this.isComplete = false;\n   }\n@@ -361,10 +306,6 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     const sfPath = absoluteFromSourceFile(sf);\n     if (this.state.has(sfPath)) {\n       const existingResults = this.state.get(sfPath)!;\n-      if (existingResults.templateOverrides !== null) {\n-        // Cannot adopt prior results if template overrides have been requested.\n-        return;\n-      }\n \n       if (existingResults.isComplete) {\n         // All data for this file has already been generated, so no need to adopt anything.\n@@ -373,8 +314,7 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     }\n \n     const previousResults = this.priorBuild.priorTypeCheckingResultsFor(sf);\n-    if (previousResults === null || !previousResults.isComplete ||\n-        previousResults.templateOverrides !== null) {\n+    if (previousResults === null || !previousResults.isComplete) {\n       return;\n     }\n \n@@ -496,7 +436,6 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     if (!this.state.has(path)) {\n       this.state.set(path, {\n         hasInlines: false,\n-        templateOverrides: null,\n         sourceManager: new TemplateSourceManager(),\n         isComplete: false,\n         shimData: new Map(),\n@@ -679,11 +618,6 @@ export interface FileTypeCheckingData {\n    */\n   sourceManager: TemplateSourceManager;\n \n-  /**\n-   * Map of template overrides applied to any components in this input file.\n-   */\n-  templateOverrides: Map<TemplateId, TemplateOverride>|null;\n-\n   /**\n    * Data for each shim generated from this input file.\n    *\n@@ -716,20 +650,6 @@ class WholeProgramTypeCheckingHost implements TypeCheckingHost {\n     return !fileData.shimData.has(shimPath);\n   }\n \n-  getTemplateOverride(sfPath: AbsoluteFsPath, node: ts.ClassDeclaration): TemplateOverride|null {\n-    const fileData = this.impl.getFileData(sfPath);\n-    if (fileData.templateOverrides === null) {\n-      return null;\n-    }\n-\n-    const templateId = fileData.sourceManager.getTemplateId(node);\n-    if (fileData.templateOverrides.has(templateId)) {\n-      return fileData.templateOverrides.get(templateId)!;\n-    }\n-\n-    return null;\n-  }\n-\n   recordShimData(sfPath: AbsoluteFsPath, data: ShimTypeCheckingData): void {\n     const fileData = this.impl.getFileData(sfPath);\n     fileData.shimData.set(data.path, data);\n@@ -774,20 +694,6 @@ class SingleFileTypeCheckingHost implements TypeCheckingHost {\n     return !this.fileData.shimData.has(shimPath);\n   }\n \n-  getTemplateOverride(sfPath: AbsoluteFsPath, node: ts.ClassDeclaration): TemplateOverride|null {\n-    this.assertPath(sfPath);\n-    if (this.fileData.templateOverrides === null) {\n-      return null;\n-    }\n-\n-    const templateId = this.fileData.sourceManager.getTemplateId(node);\n-    if (this.fileData.templateOverrides.has(templateId)) {\n-      return this.fileData.templateOverrides.get(templateId)!;\n-    }\n-\n-    return null;\n-  }\n-\n   recordShimData(sfPath: AbsoluteFsPath, data: ShimTypeCheckingData): void {\n     this.assertPath(sfPath);\n "
        },
        {
            "sha": "e9729b1ff6491aa12a97eb177d22b87491dd4aa4",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/context.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/a3b08644280fb43d9dfd037927c4e6a48a2c9a46/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts",
            "raw_url": "https://github.com/angular/angular/raw/a3b08644280fb43d9dfd037927c4e6a48a2c9a46/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts?ref=a3b08644280fb43d9dfd037927c4e6a48a2c9a46",
            "patch": "@@ -51,11 +51,6 @@ export interface ShimTypeCheckingData {\n   templates: Map<TemplateId, TemplateData>;\n }\n \n-export interface TemplateOverride {\n-  nodes: TmplAstNode[];\n-  errors: ParseError[]|null;\n-}\n-\n /**\n  * Data tracked for each template processed by the template type-checking system.\n  */\n@@ -143,12 +138,6 @@ export interface TypeCheckingHost {\n    */\n   shouldCheckComponent(node: ts.ClassDeclaration): boolean;\n \n-  /**\n-   * Check if the given component has had its template overridden, and retrieve the new template\n-   * nodes if so.\n-   */\n-  getTemplateOverride(sfPath: AbsoluteFsPath, node: ts.ClassDeclaration): TemplateOverride|null;\n-\n   /**\n    * Report data from a shim generated from the given input file path.\n    */\n@@ -225,13 +214,6 @@ export class TypeCheckContextImpl implements TypeCheckContext {\n \n     const templateDiagnostics: TemplateDiagnostic[] = [];\n \n-    const sfPath = absoluteFromSourceFile(ref.node.getSourceFile());\n-    const overrideTemplate = this.host.getTemplateOverride(sfPath, ref.node);\n-    if (overrideTemplate !== null) {\n-      template = overrideTemplate.nodes;\n-      parseErrors = overrideTemplate.errors;\n-    }\n-\n     if (parseErrors !== null) {\n       templateDiagnostics.push(\n           ...this.getTemplateDiagnostics(parseErrors, templateId, sourceMapping));"
        },
        {
            "sha": "104b3ed279da63eef0830ec79aefecb14d73b4e0",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker__completion_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 26,
            "changes": 26,
            "blob_url": "https://github.com/angular/angular/blob/a3b08644280fb43d9dfd037927c4e6a48a2c9a46/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__completion_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a3b08644280fb43d9dfd037927c4e6a48a2c9a46/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__completion_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__completion_spec.ts?ref=a3b08644280fb43d9dfd037927c4e6a48a2c9a46",
            "patch": "@@ -71,32 +71,6 @@ runInEachFileSystem(() => {\n       expect(userAtTopLevel.kind).toBe(CompletionKind.Reference);\n       expect(userInNgFor.kind).toBe(CompletionKind.Variable);\n     });\n-\n-    it('should invalidate cached completions when overrides change', () => {\n-      // The template starts with a #foo local reference.\n-      const {completions: before, templateTypeChecker, component} =\n-          setupCompletions('<div #foo></div>');\n-      expect(Array.from(before.templateContext.keys())).toEqual(['foo']);\n-\n-      // Override the template and change the name of the local reference to #bar. This should\n-      // invalidate any cached completions.\n-      templateTypeChecker.overrideComponentTemplate(component, '<div #bar></div>');\n-\n-      // Fresh completions should include the #bar reference instead.\n-      const afterOverride =\n-          templateTypeChecker.getGlobalCompletions(/* root template */ null, component)!;\n-      expect(afterOverride).toBeDefined();\n-      expect(Array.from(afterOverride.templateContext.keys())).toEqual(['bar']);\n-\n-      // Reset the template to its original. This should also invalidate any cached completions.\n-      templateTypeChecker.resetOverrides();\n-\n-      // Fresh completions should include the original #foo now.\n-      const afterReset =\n-          templateTypeChecker.getGlobalCompletions(/* root template */ null, component)!;\n-      expect(afterReset).toBeDefined();\n-      expect(Array.from(afterReset.templateContext.keys())).toEqual(['foo']);\n-    });\n   });\n \n   describe('TemplateTypeChecker scopes', () => {"
        },
        {
            "sha": "1d4cb3d1b3b5fd15a6c2d7114795adda03012aa0",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker__get_symbol_of_template_node_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 27,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/a3b08644280fb43d9dfd037927c4e6a48a2c9a46/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a3b08644280fb43d9dfd037927c4e6a48a2c9a46/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts?ref=a3b08644280fb43d9dfd037927c4e6a48a2c9a46",
            "patch": "@@ -40,33 +40,6 @@ runInEachFileSystem(() => {\n       assertElementSymbol(symbol.host);\n     });\n \n-    it('should invalidate symbols when template overrides change', () => {\n-      const fileName = absoluteFrom('/main.ts');\n-      const templateString = `<div id=\"helloWorld\"></div>`;\n-      const {templateTypeChecker, program} = setup(\n-          [\n-            {\n-              fileName,\n-              templates: {'Cmp': templateString},\n-              source: `export class Cmp {}`,\n-            },\n-          ],\n-      );\n-      const sf = getSourceFileOrError(program, fileName);\n-      const cmp = getClass(sf, 'Cmp');\n-      const {attributes: beforeAttributes} = getAstElements(templateTypeChecker, cmp)[0];\n-      const beforeSymbol = templateTypeChecker.getSymbolOfNode(beforeAttributes[0], cmp)!;\n-\n-      // Replace the <div> with a <span>.\n-      templateTypeChecker.overrideComponentTemplate(cmp, '<span id=\"helloWorld\"></span>');\n-\n-      const {attributes: afterAttributes} = getAstElements(templateTypeChecker, cmp)[0];\n-      const afterSymbol = templateTypeChecker.getSymbolOfNode(afterAttributes[0], cmp)!;\n-\n-      // After the override, the symbol cache should have been invalidated.\n-      expect(beforeSymbol).not.toBe(afterSymbol);\n-    });\n-\n     describe('should get a symbol for text attributes corresponding with a directive input', () => {\n       let fileName: AbsoluteFsPath;\n       let targets: TypeCheckingTarget[];"
        },
        {
            "sha": "226840a4bc4089947bfbb2a733e74788162b47f2",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 155,
            "changes": 155,
            "blob_url": "https://github.com/angular/angular/blob/a3b08644280fb43d9dfd037927c4e6a48a2c9a46/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a3b08644280fb43d9dfd037927c4e6a48a2c9a46/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts?ref=a3b08644280fb43d9dfd037927c4e6a48a2c9a46",
            "patch": "@@ -211,143 +211,6 @@ runInEachFileSystem(() => {\n         expect(absoluteFromSourceFile(diags[0].relatedInformation![0].file!)).toBe(dirSf.fileName);\n       });\n     });\n-\n-    describe('template overrides', () => {\n-      it('should override a simple template', () => {\n-        const fileName = absoluteFrom('/main.ts');\n-        const {program, templateTypeChecker} = setup([{\n-          fileName,\n-          templates: {'Cmp': '<div>{{original}}</div>'},\n-        }]);\n-\n-        const sf = getSourceFileOrError(program, fileName);\n-        const cmp = getClass(sf, 'Cmp');\n-\n-        const tcbReal = templateTypeChecker.getTypeCheckBlock(cmp)!;\n-        expect(tcbReal.getText()).toContain('original');\n-\n-        templateTypeChecker.overrideComponentTemplate(cmp, '<div>{{override}}</div>');\n-        const tcbOverridden = templateTypeChecker.getTypeCheckBlock(cmp);\n-        expect(tcbOverridden).not.toBeNull();\n-        expect(tcbOverridden!.getText()).not.toContain('original');\n-        expect(tcbOverridden!.getText()).toContain('override');\n-      });\n-\n-      it('should clear overrides on request', () => {\n-        const fileName = absoluteFrom('/main.ts');\n-        const {program, templateTypeChecker} = setup([{\n-          fileName,\n-          templates: {'Cmp': '<div>{{original}}</div>'},\n-        }]);\n-\n-        const sf = getSourceFileOrError(program, fileName);\n-        const cmp = getClass(sf, 'Cmp');\n-\n-        templateTypeChecker.overrideComponentTemplate(cmp, '<div>{{override}}</div>');\n-        const tcbOverridden = templateTypeChecker.getTypeCheckBlock(cmp)!;\n-        expect(tcbOverridden.getText()).not.toContain('original');\n-        expect(tcbOverridden.getText()).toContain('override');\n-\n-        templateTypeChecker.resetOverrides();\n-\n-        // The template should be back to the original.\n-        const tcbReal = templateTypeChecker.getTypeCheckBlock(cmp)!;\n-        expect(tcbReal.getText()).toContain('original');\n-        expect(tcbReal.getText()).not.toContain('override');\n-      });\n-\n-      it('should override a template and make use of previously unused directives', () => {\n-        const fileName = absoluteFrom('/main.ts');\n-        const dirFile = absoluteFrom('/dir.ts');\n-        const {program, templateTypeChecker} = setup(\n-            [\n-              {\n-                fileName,\n-                source: `export class Cmp {}`,\n-                templates: {'Cmp': '<div></div>'},\n-                declarations: [{\n-                  name: 'TestDir',\n-                  selector: '[dir]',\n-                  file: dirFile,\n-                  type: 'directive',\n-                  inputs: {'input': 'input'},\n-                  isGeneric: true,\n-                }]\n-              },\n-              {\n-                fileName: dirFile,\n-                source: `export class TestDir<T> {}`,\n-                templates: {},\n-              }\n-            ],\n-            {inlining: false});\n-        const sf = getSourceFileOrError(program, fileName);\n-        const cmp = getClass(sf, 'Cmp');\n-\n-        // TestDir is initially unused. Note that this checks the entire text of the ngtypecheck\n-        // file, to ensure it captures not just the TCB function but also any inline type\n-        // constructors.\n-        const tcbReal = templateTypeChecker.getTypeCheckBlock(cmp)!;\n-        expect(tcbReal.getSourceFile().text).not.toContain('TestDir');\n-\n-        templateTypeChecker.overrideComponentTemplate(cmp, '<div dir [input]=\"value\"></div>');\n-\n-        const tcbOverridden = templateTypeChecker.getTypeCheckBlock(cmp);\n-        expect(tcbOverridden).not.toBeNull();\n-        expect(tcbOverridden!.getSourceFile().text).toContain('TestDir');\n-      });\n-\n-      it('should not invalidate other templates when an override is requested', () => {\n-        const file1 = absoluteFrom('/file1.ts');\n-        const file2 = absoluteFrom('/file2.ts');\n-        const {program, templateTypeChecker, programStrategy} = setup([\n-          {fileName: file1, templates: {'Cmp1': '<div></div>'}},\n-          {fileName: file2, templates: {'Cmp2': '<span></span>'}}\n-        ]);\n-\n-        const cmp1 = getClass(getSourceFileOrError(program, file1), 'Cmp1');\n-        const cmp2 = getClass(getSourceFileOrError(program, file2), 'Cmp2');\n-\n-        // To test this scenario, Cmp1's type check block will be captured, then Cmp2's template\n-        // will be overridden. Cmp1's type check block should not change as a result.\n-        const originalTcb = templateTypeChecker.getTypeCheckBlock(cmp1)!;\n-\n-        templateTypeChecker.overrideComponentTemplate(cmp2, '<p></p>');\n-\n-        // Trigger generation of the TCB for Cmp2.\n-        templateTypeChecker.getTypeCheckBlock(cmp2);\n-\n-        // Verify that Cmp1's TCB has not changed.\n-        const currentTcb = templateTypeChecker.getTypeCheckBlock(cmp1)!;\n-        expect(currentTcb).toBe(originalTcb);\n-      });\n-    });\n-\n-    it('should allow get diagnostics for a single component', () => {\n-      const fileName = absoluteFrom('/main.ts');\n-\n-      const {program, templateTypeChecker} = setup([{\n-        fileName,\n-        templates: {\n-          'Cmp1': '<invalid-element-a></invalid-element-a>',\n-          'Cmp2': '<invalid-element-b></invalid-element-b>'\n-        },\n-      }]);\n-      const sf = getSourceFileOrError(program, fileName);\n-      const cmp1 = getClass(sf, 'Cmp1');\n-      const cmp2 = getClass(sf, 'Cmp2');\n-\n-      const diags1 = templateTypeChecker.getDiagnosticsForComponent(cmp1);\n-      expect(diags1.length).toBe(1);\n-      expect(diags1[0].messageText).toContain('invalid-element-a');\n-      expect(diags1[0].messageText).not.toContain('invalid-element-b');\n-\n-      const diags2 = templateTypeChecker.getDiagnosticsForComponent(cmp2);\n-      expect(diags2.length).toBe(1);\n-      expect(diags2[0].messageText).toContain('invalid-element-b');\n-      expect(diags2[0].messageText).not.toContain('invalid-element-a');\n-    });\n-\n     describe('getTemplateOfComponent()', () => {\n       it('should provide access to a component\\'s real template', () => {\n         const fileName = absoluteFrom('/main.ts');\n@@ -363,24 +226,6 @@ runInEachFileSystem(() => {\n         expect(nodes).not.toBeNull();\n         expect(nodes[0].sourceSpan.start.file.content).toBe('<div>Template</div>');\n       });\n-\n-      it('should provide access to an overridden template', () => {\n-        const fileName = absoluteFrom('/main.ts');\n-        const {program, templateTypeChecker} = setup([{\n-          fileName,\n-          templates: {\n-            'Cmp': '<div>Template</div>',\n-          },\n-        }]);\n-        const cmp = getClass(getSourceFileOrError(program, fileName), 'Cmp');\n-\n-        templateTypeChecker.overrideComponentTemplate(cmp, '<div>Overridden</div>');\n-        templateTypeChecker.getDiagnosticsForComponent(cmp);\n-\n-        const nodes = templateTypeChecker.getTemplate(cmp)!;\n-        expect(nodes).not.toBeNull();\n-        expect(nodes[0].sourceSpan.start.file.content).toBe('<div>Overridden</div>');\n-      });\n     });\n   });\n });"
        },
        {
            "sha": "73457a9d2e6b0107052f1e693a2ec82c4fb4d561",
            "filename": "packages/language-service/ivy/test/legacy/template_target_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/a3b08644280fb43d9dfd037927c4e6a48a2c9a46/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a3b08644280fb43d9dfd037927c4e6a48a2c9a46/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts?ref=a3b08644280fb43d9dfd037927c4e6a48a2c9a46",
            "patch": "@@ -32,8 +32,7 @@ function parse(template: string): ParseResult {\n       // and fully accounted for in source spans. Without these flags the source spans can be\n       // inaccurate.\n       // Note: template parse options should be aligned with the `diagNodes` in\n-      // `ComponentDecoratorHandler._parseTemplate`. and\n-      // `TemplateTypeCheckerImpl.overrideComponentTemplate`.\n+      // `ComponentDecoratorHandler._parseTemplate`.\n       leadingTriviaChars: [],\n       preserveWhitespaces: true,\n     }),"
        }
    ],
    "stats": {
        "total": 360,
        "additions": 9,
        "deletions": 351
    }
}