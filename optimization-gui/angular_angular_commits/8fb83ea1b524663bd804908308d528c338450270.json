{
    "author": "sonukapoor",
    "message": "feat(forms): introduce min and max validators (#39063)\n\nThis commit adds the missing `min` and `max` validators.\n\nBREAKING CHANGE:\n\nPreviously `min` and `max` attributes defined on the `<input type=\"number\">`\nwere ignored by Forms module. Now presence of these attributes would\ntrigger min/max validation logic (in case `formControl`, `formControlName`\nor `ngModel` directives are also present on a given input) and\ncorresponding form control status would reflect that.\n\nFixes #16352\n\nPR Close #39063",
    "sha": "8fb83ea1b524663bd804908308d528c338450270",
    "files": [
        {
            "sha": "8116d8cec00bd8e0f4176338ac33c8f3b1bf0b3f",
            "filename": "goldens/public-api/forms/forms.d.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/8fb83ea1b524663bd804908308d528c338450270/goldens%2Fpublic-api%2Fforms%2Fforms.d.ts",
            "raw_url": "https://github.com/angular/angular/raw/8fb83ea1b524663bd804908308d528c338450270/goldens%2Fpublic-api%2Fforms%2Fforms.d.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fpublic-api%2Fforms%2Fforms.d.ts?ref=8fb83ea1b524663bd804908308d528c338450270",
            "patch": "@@ -337,13 +337,23 @@ export declare class MaxLengthValidator implements Validator, OnChanges {\n     validate(control: AbstractControl): ValidationErrors | null;\n }\n \n+export declare class MaxValidator extends AbstractValidatorDirective implements OnChanges {\n+    max: string | number;\n+    ngOnChanges(changes: SimpleChanges): void;\n+}\n+\n export declare class MinLengthValidator implements Validator, OnChanges {\n     minlength: string | number;\n     ngOnChanges(changes: SimpleChanges): void;\n     registerOnValidatorChange(fn: () => void): void;\n     validate(control: AbstractControl): ValidationErrors | null;\n }\n \n+export declare class MinValidator extends AbstractValidatorDirective implements OnChanges {\n+    min: string | number;\n+    ngOnChanges(changes: SimpleChanges): void;\n+}\n+\n export declare const NG_ASYNC_VALIDATORS: InjectionToken<(Function | Validator)[]>;\n \n export declare const NG_VALIDATORS: InjectionToken<(Function | Validator)[]>;"
        },
        {
            "sha": "2be224939fb2d5cc4f68a22b2c0b084485bcde38",
            "filename": "packages/forms/src/directives.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/8fb83ea1b524663bd804908308d528c338450270/packages%2Fforms%2Fsrc%2Fdirectives.ts",
            "raw_url": "https://github.com/angular/angular/raw/8fb83ea1b524663bd804908308d528c338450270/packages%2Fforms%2Fsrc%2Fdirectives.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Fsrc%2Fdirectives.ts?ref=8fb83ea1b524663bd804908308d528c338450270",
            "patch": "@@ -24,7 +24,7 @@ import {FormGroupDirective} from './directives/reactive_directives/form_group_di\n import {FormArrayName, FormGroupName} from './directives/reactive_directives/form_group_name';\n import {NgSelectOption, SelectControlValueAccessor} from './directives/select_control_value_accessor';\n import {NgSelectMultipleOption, SelectMultipleControlValueAccessor} from './directives/select_multiple_control_value_accessor';\n-import {CheckboxRequiredValidator, EmailValidator, MaxLengthValidator, MinLengthValidator, PatternValidator, RequiredValidator} from './directives/validators';\n+import {CheckboxRequiredValidator, EmailValidator, MaxLengthValidator, MaxValidator, MinLengthValidator, MinValidator, PatternValidator, RequiredValidator} from './directives/validators';\n \n export {CheckboxControlValueAccessor} from './directives/checkbox_value_accessor';\n export {ControlValueAccessor} from './directives/control_value_accessor';\n@@ -63,6 +63,8 @@ export const SHARED_FORM_DIRECTIVES: Type<any>[] = [\n   PatternValidator,\n   CheckboxRequiredValidator,\n   EmailValidator,\n+  MinValidator,\n+  MaxValidator,\n ];\n \n export const TEMPLATE_DRIVEN_DIRECTIVES: Type<any>[] = [NgModel, NgModelGroup, NgForm];"
        },
        {
            "sha": "8fc41b430f11654ad17d7a4ad9af60d23cd8e532",
            "filename": "packages/forms/src/directives/validators.ts",
            "status": "modified",
            "additions": 183,
            "deletions": 0,
            "changes": 183,
            "blob_url": "https://github.com/angular/angular/blob/8fb83ea1b524663bd804908308d528c338450270/packages%2Fforms%2Fsrc%2Fdirectives%2Fvalidators.ts",
            "raw_url": "https://github.com/angular/angular/raw/8fb83ea1b524663bd804908308d528c338450270/packages%2Fforms%2Fsrc%2Fdirectives%2Fvalidators.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Fsrc%2Fdirectives%2Fvalidators.ts?ref=8fb83ea1b524663bd804908308d528c338450270",
            "patch": "@@ -69,6 +69,189 @@ export interface Validator {\n   registerOnValidatorChange?(fn: () => void): void;\n }\n \n+/**\n+ * A base class for Validator-based Directives. The class contains common logic shared across such\n+ * Directives.\n+ *\n+ * For internal use only, this class is not intended for use outside of the Forms package.\n+ */\n+@Directive()\n+abstract class AbstractValidatorDirective implements Validator {\n+  private _validator: ValidatorFn = Validators.nullValidator;\n+  private _onChange!: () => void;\n+\n+  /**\n+   * Name of an input that matches directive selector attribute (e.g. `minlength` for\n+   * `MinLengthDirective`). An input with a given name might contain configuration information (like\n+   * `minlength='10'`) or a flag that indicates whether validator should be enabled (like\n+   * `[required]='false'`).\n+   *\n+   * @internal\n+   */\n+  abstract inputName: string;\n+\n+  /**\n+   * Creates an instance of a validator (specific to a directive that extends this base class).\n+   *\n+   * @internal\n+   */\n+  abstract createValidator(input: unknown): ValidatorFn;\n+\n+  /**\n+   * Performs the necessary input normalization based on a specific logic of a Directive.\n+   * For example, the function might be used to convert string-based representation of the\n+   * `minlength` input to an integer value that can later be used in the `Validators.minLength`\n+   * validator.\n+   *\n+   * @internal\n+   */\n+  abstract normalizeInput(input: unknown): unknown;\n+\n+  /**\n+   * Helper function invoked from child classes to process changes (from `ngOnChanges` hook).\n+   * @nodoc\n+   */\n+  handleChanges(changes: SimpleChanges): void {\n+    if (this.inputName in changes) {\n+      const input = this.normalizeInput(changes[this.inputName].currentValue);\n+      this._validator = this.createValidator(input);\n+      if (this._onChange) {\n+        this._onChange();\n+      }\n+    }\n+  }\n+\n+  /** @nodoc */\n+  validate(control: AbstractControl): ValidationErrors|null {\n+    return this._validator(control);\n+  }\n+\n+  /** @nodoc */\n+  registerOnValidatorChange(fn: () => void): void {\n+    this._onChange = fn;\n+  }\n+}\n+\n+/**\n+ * @description\n+ * Provider which adds `MaxValidator` to the `NG_VALIDATORS` multi-provider list.\n+ */\n+export const MAX_VALIDATOR: StaticProvider = {\n+  provide: NG_VALIDATORS,\n+  useExisting: forwardRef(() => MaxValidator),\n+  multi: true\n+};\n+\n+/**\n+ * A directive which installs the {@link MaxValidator} for any `formControlName`,\n+ * `formControl`, or control with `ngModel` that also has a `max` attribute.\n+ *\n+ * @see [Form Validation](guide/form-validation)\n+ *\n+ * @usageNotes\n+ *\n+ * ### Adding a max validator\n+ *\n+ * The following example shows how to add a max validator to an input attached to an\n+ * ngModel binding.\n+ *\n+ * ```html\n+ * <input type=\"number\" ngModel max=\"4\">\n+ * ```\n+ *\n+ * @ngModule ReactiveFormsModule\n+ * @ngModule FormsModule\n+ * @publicApi\n+ */\n+@Directive({\n+  selector:\n+      'input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]',\n+  providers: [MAX_VALIDATOR],\n+  host: {'[attr.max]': 'max ? max : null'}\n+})\n+export class MaxValidator extends AbstractValidatorDirective implements OnChanges {\n+  /**\n+   * @description\n+   * Tracks changes to the max bound to this directive.\n+   */\n+  @Input() max!: string|number;\n+  /** @internal */\n+  inputName = 'max';\n+  /** @internal */\n+  normalizeInput = (input: string): number => parseInt(input, 10);\n+  /** @internal */\n+  createValidator = (max: number): ValidatorFn => Validators.max(max);\n+  /**\n+   * Declare `ngOnChanges` lifecycle hook at the main directive level (vs keeping it in base class)\n+   * to avoid differences in handling inheritance of lifecycle hooks between Ivy and ViewEngine in\n+   * AOT mode. This could be refactored once ViewEngine is removed.\n+   * @nodoc\n+   */\n+  ngOnChanges(changes: SimpleChanges): void {\n+    this.handleChanges(changes);\n+  }\n+}\n+\n+/**\n+ * @description\n+ * Provider which adds `MinValidator` to the `NG_VALIDATORS` multi-provider list.\n+ */\n+export const MIN_VALIDATOR: StaticProvider = {\n+  provide: NG_VALIDATORS,\n+  useExisting: forwardRef(() => MinValidator),\n+  multi: true\n+};\n+\n+/**\n+ * A directive which installs the {@link MinValidator} for any `formControlName`,\n+ * `formControl`, or control with `ngModel` that also has a `min` attribute.\n+ *\n+ * @see [Form Validation](guide/form-validation)\n+ *\n+ * @usageNotes\n+ *\n+ * ### Adding a min validator\n+ *\n+ * The following example shows how to add a min validator to an input attached to an\n+ * ngModel binding.\n+ *\n+ * ```html\n+ * <input type=\"number\" ngModel min=\"4\">\n+ * ```\n+ *\n+ * @ngModule ReactiveFormsModule\n+ * @ngModule FormsModule\n+ * @publicApi\n+ */\n+@Directive({\n+  selector:\n+      'input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]',\n+  providers: [MIN_VALIDATOR],\n+  host: {'[attr.min]': 'min ? min : null'}\n+})\n+export class MinValidator extends AbstractValidatorDirective implements OnChanges {\n+  /**\n+   * @description\n+   * Tracks changes to the min bound to this directive.\n+   */\n+  @Input() min!: string|number;\n+  /** @internal */\n+  inputName = 'min';\n+  /** @internal */\n+  normalizeInput = (input: string): number => parseInt(input, 10);\n+  /** @internal */\n+  createValidator = (min: number): ValidatorFn => Validators.min(min);\n+  /**\n+   * Declare `ngOnChanges` lifecycle hook at the main directive level (vs keeping it in base class)\n+   * to avoid differences in handling inheritance of lifecycle hooks between Ivy and ViewEngine in\n+   * AOT mode. This could be refactored once ViewEngine is removed.\n+   * @nodoc\n+   */\n+  ngOnChanges(changes: SimpleChanges): void {\n+    this.handleChanges(changes);\n+  }\n+}\n+\n /**\n  * @description\n  * An interface implemented by classes that perform asynchronous validation."
        },
        {
            "sha": "248d07a0b67a9c5f263583d62645950cbcde5093",
            "filename": "packages/forms/src/forms.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/8fb83ea1b524663bd804908308d528c338450270/packages%2Fforms%2Fsrc%2Fforms.ts",
            "raw_url": "https://github.com/angular/angular/raw/8fb83ea1b524663bd804908308d528c338450270/packages%2Fforms%2Fsrc%2Fforms.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Fsrc%2Fforms.ts?ref=8fb83ea1b524663bd804908308d528c338450270",
            "patch": "@@ -43,7 +43,7 @@ export {FormGroupName} from './directives/reactive_directives/form_group_name';\n export {NgSelectOption, SelectControlValueAccessor} from './directives/select_control_value_accessor';\n export {SelectMultipleControlValueAccessor} from './directives/select_multiple_control_value_accessor';\n export {ɵNgSelectMultipleOption} from './directives/select_multiple_control_value_accessor';\n-export {AsyncValidator, AsyncValidatorFn, CheckboxRequiredValidator, EmailValidator, MaxLengthValidator, MinLengthValidator, PatternValidator, RequiredValidator, ValidationErrors, Validator, ValidatorFn} from './directives/validators';\n+export {AsyncValidator, AsyncValidatorFn, CheckboxRequiredValidator, EmailValidator, MaxLengthValidator, MaxValidator, MinLengthValidator, MinValidator, PatternValidator, RequiredValidator, ValidationErrors, Validator, ValidatorFn} from './directives/validators';\n export {FormBuilder} from './form_builder';\n export {AbstractControl, AbstractControlOptions, FormArray, FormControl, FormGroup} from './model';\n export {NG_ASYNC_VALIDATORS, NG_VALIDATORS, Validators} from './validators';"
        },
        {
            "sha": "63c1993b065fea09e55f8d2027972014eae7562c",
            "filename": "packages/forms/test/reactive_integration_spec.ts",
            "status": "modified",
            "additions": 234,
            "deletions": 1,
            "changes": 235,
            "blob_url": "https://github.com/angular/angular/blob/8fb83ea1b524663bd804908308d528c338450270/packages%2Fforms%2Ftest%2Freactive_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/8fb83ea1b524663bd804908308d528c338450270/packages%2Fforms%2Ftest%2Freactive_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Freactive_integration_spec.ts?ref=8fb83ea1b524663bd804908308d528c338450270",
            "patch": "@@ -10,7 +10,7 @@ import {ɵgetDOM as getDOM} from '@angular/common';\n import {Component, Directive, forwardRef, Input, NgModule, OnDestroy, Type} from '@angular/core';\n import {ComponentFixture, fakeAsync, TestBed, tick} from '@angular/core/testing';\n import {expect} from '@angular/core/testing/src/testing_internal';\n-import {AbstractControl, AsyncValidator, AsyncValidatorFn, COMPOSITION_BUFFER_MODE, ControlValueAccessor, DefaultValueAccessor, FormArray, FormControl, FormControlDirective, FormControlName, FormGroup, FormGroupDirective, FormsModule, NG_ASYNC_VALIDATORS, NG_VALIDATORS, NG_VALUE_ACCESSOR, ReactiveFormsModule, Validator, Validators} from '@angular/forms';\n+import {AbstractControl, AsyncValidator, AsyncValidatorFn, COMPOSITION_BUFFER_MODE, ControlValueAccessor, DefaultValueAccessor, FormArray, FormControl, FormControlDirective, FormControlName, FormGroup, FormGroupDirective, FormsModule, MaxValidator, MinValidator, NG_ASYNC_VALIDATORS, NG_VALIDATORS, NG_VALUE_ACCESSOR, ReactiveFormsModule, Validator, Validators} from '@angular/forms';\n import {By} from '@angular/platform-browser/src/dom/debug/by';\n import {dispatchEvent, sortedClassList} from '@angular/platform-browser/testing/src/browser_util';\n import {merge, NEVER, of, Subscription, timer} from 'rxjs';\n@@ -2346,6 +2346,211 @@ const ValueAccessorB = createControlValueAccessor('[cva-b]');\n            expect(resultArr.length)\n                .toEqual(2, `Expected original observable to be canceled on the next value change.`);\n          }));\n+\n+      describe('min and max validators', () => {\n+        function getComponent(dir: string): Type<MinMaxFormControlComp|MinMaxFormControlNameComp> {\n+          return dir === 'formControl' ? MinMaxFormControlComp : MinMaxFormControlNameComp;\n+        }\n+        // Run tests for both `FormControlName` and `FormControl` directives\n+        ['formControl', 'formControlName'].forEach((dir: string) => {\n+          it('should validate max', () => {\n+            const fixture = initTest(getComponent(dir));\n+            const control = new FormControl(5);\n+            fixture.componentInstance.control = control;\n+            fixture.componentInstance.form = new FormGroup({'pin': control});\n+            fixture.detectChanges();\n+\n+            const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+            const form = fixture.componentInstance.form;\n+\n+            expect(input.value).toEqual('5');\n+            expect(form.valid).toBeTruthy();\n+            expect(form.controls.pin.errors).toBeNull();\n+\n+            input.value = 2;\n+            dispatchEvent(input, 'input');\n+            expect(form.value).toEqual({pin: 2});\n+            expect(form.valid).toBeTruthy();\n+            expect(form.controls.pin.errors).toBeNull();\n+\n+            fixture.componentInstance.max = 1;\n+            fixture.detectChanges();\n+\n+            expect(form.valid).toBeFalse();\n+            expect(form.controls.pin.errors).toEqual({max: {max: 1, actual: 2}});\n+          });\n+\n+          it('should apply max validation when control value is defined as a string', () => {\n+            const fixture = initTest(getComponent(dir));\n+            const control = new FormControl('5');\n+            fixture.componentInstance.control = control;\n+            fixture.componentInstance.form = new FormGroup({'pin': control});\n+            fixture.detectChanges();\n+\n+            const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+            const form = fixture.componentInstance.form;\n+\n+            expect(input.value).toEqual('5');\n+            expect(form.valid).toBeTruthy();\n+            expect(form.controls.pin.errors).toBeNull();\n+\n+            input.value = '2';\n+            dispatchEvent(input, 'input');\n+            expect(form.value).toEqual({pin: 2});\n+            expect(form.valid).toBeTruthy();\n+            expect(form.controls.pin.errors).toBeNull();\n+\n+            fixture.componentInstance.max = 1;\n+            fixture.detectChanges();\n+            expect(form.valid).toBeFalse();\n+            expect(form.controls.pin.errors).toEqual({max: {max: 1, actual: 2}});\n+          });\n+\n+          it('should validate min', () => {\n+            const fixture = initTest(getComponent(dir));\n+            const control = new FormControl(5);\n+            fixture.componentInstance.control = control;\n+            fixture.componentInstance.form = new FormGroup({'pin': control});\n+            fixture.detectChanges();\n+\n+            const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+            const form = fixture.componentInstance.form;\n+\n+            expect(input.value).toEqual('5');\n+            expect(form.valid).toBeTruthy();\n+            expect(form.controls.pin.errors).toBeNull();\n+\n+            input.value = 2;\n+            dispatchEvent(input, 'input');\n+            expect(form.value).toEqual({pin: 2});\n+            expect(form.valid).toBeTruthy();\n+            expect(form.controls.pin.errors).toBeNull();\n+\n+            fixture.componentInstance.min = 5;\n+            fixture.detectChanges();\n+            expect(form.valid).toBeFalse();\n+            expect(form.controls.pin.errors).toEqual({min: {min: 5, actual: 2}});\n+          });\n+\n+          it('should apply min validation when control value is defined as a string', () => {\n+            const fixture = initTest(getComponent(dir));\n+            const control = new FormControl('5');\n+            fixture.componentInstance.control = control;\n+            fixture.componentInstance.form = new FormGroup({'pin': control});\n+            fixture.detectChanges();\n+\n+            const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+            const form = fixture.componentInstance.form;\n+\n+            expect(input.value).toEqual('5');\n+            expect(form.valid).toBeTruthy();\n+            expect(form.controls.pin.errors).toBeNull();\n+\n+            input.value = '2';\n+            dispatchEvent(input, 'input');\n+            expect(form.value).toEqual({pin: 2});\n+            expect(form.valid).toBeTruthy();\n+            expect(form.controls.pin.errors).toBeNull();\n+\n+            fixture.componentInstance.min = 5;\n+            fixture.detectChanges();\n+            expect(form.valid).toBeFalse();\n+            expect(form.controls.pin.errors).toEqual({min: {min: 5, actual: 2}});\n+          });\n+\n+          it('should run min/max validation for empty values', () => {\n+            const fixture = initTest(getComponent(dir));\n+            const minValidateFnSpy = spyOn(MinValidator.prototype, 'validate');\n+            const maxValidateFnSpy = spyOn(MaxValidator.prototype, 'validate');\n+\n+            const control = new FormControl();\n+            fixture.componentInstance.control = control;\n+            fixture.componentInstance.form = new FormGroup({'pin': control});\n+            fixture.detectChanges();\n+\n+            const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+            const form = fixture.componentInstance.form;\n+\n+            expect(input.value).toEqual('');\n+            expect(form.valid).toBeTruthy();\n+            expect(form.controls.pin.errors).toBeNull();\n+            expect(minValidateFnSpy).toHaveBeenCalled();\n+            expect(maxValidateFnSpy).toHaveBeenCalled();\n+          });\n+\n+          it('should run min/max validation when constraints are represented as strings', () => {\n+            const fixture = initTest(getComponent(dir));\n+            const control = new FormControl(5);\n+\n+            // Run tests when min and max are defined as strings.\n+            fixture.componentInstance.min = '1';\n+            fixture.componentInstance.max = '10';\n+\n+            fixture.componentInstance.control = control;\n+            fixture.componentInstance.form = new FormGroup({'pin': control});\n+            fixture.detectChanges();\n+\n+            const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+            const form = fixture.componentInstance.form;\n+\n+            expect(input.value).toEqual('5');\n+            expect(form.valid).toBeTruthy();\n+            expect(form.controls.pin.errors).toBeNull();\n+\n+            input.value = 2;  // inside [1, 10] range\n+            dispatchEvent(input, 'input');\n+            expect(form.value).toEqual({pin: 2});\n+            expect(form.valid).toBeTruthy();\n+            expect(form.controls.pin.errors).toBeNull();\n+\n+            input.value = -2;  // outside [1, 10] range\n+            dispatchEvent(input, 'input');\n+            expect(form.value).toEqual({pin: -2});\n+            expect(form.valid).toBeFalse();\n+            expect(form.controls.pin.errors).toEqual({min: {min: 1, actual: -2}});\n+\n+            input.value = 20;  // outside [1, 10] range\n+            dispatchEvent(input, 'input');\n+            expect(form.valid).toBeFalse();\n+            expect(form.controls.pin.errors).toEqual({max: {max: 10, actual: 20}});\n+          });\n+\n+          it('should run min/max validation for negative values', () => {\n+            const fixture = initTest(getComponent(dir));\n+            const control = new FormControl(-30);\n+            fixture.componentInstance.control = control;\n+            fixture.componentInstance.form = new FormGroup({'pin': control});\n+            fixture.componentInstance.min = -20;\n+            fixture.componentInstance.max = -10;\n+            fixture.detectChanges();\n+\n+            const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+            const form = fixture.componentInstance.form;\n+\n+            expect(input.value).toEqual('-30');\n+            expect(form.valid).toBeFalse();\n+            expect(form.controls.pin.errors).toEqual({min: {min: -20, actual: -30}});\n+\n+            input.value = -15;\n+            dispatchEvent(input, 'input');\n+            expect(form.value).toEqual({pin: -15});\n+            expect(form.valid).toBeTruthy();\n+            expect(form.controls.pin.errors).toBeNull();\n+\n+            input.value = -5;\n+            dispatchEvent(input, 'input');\n+            expect(form.value).toEqual({pin: -5});\n+            expect(form.valid).toBeFalse();\n+            expect(form.controls.pin.errors).toEqual({max: {max: -10, actual: -5}});\n+\n+            input.value = 0;\n+            dispatchEvent(input, 'input');\n+            expect(form.value).toEqual({pin: 0});\n+            expect(form.valid).toBeFalse();\n+            expect(form.controls.pin.errors).toEqual({max: {max: -10, actual: 0}});\n+          });\n+        });\n+      });\n     });\n \n     describe('errors', () => {\n@@ -4461,3 +4666,31 @@ class NgForFormControlWithValidators {\n   form = new FormGroup({login: new FormControl('a')});\n   logins = ['a', 'b', 'c'];\n }\n+\n+@Component({\n+  selector: 'min-max-form-control-name',\n+  template: `\n+    <div [formGroup]=\"form\">\n+      <input type=\"number\" formControlName=\"pin\" [max]=\"max\" [min]=\"min\">\n+   </div>`\n+})\n+class MinMaxFormControlNameComp {\n+  control!: FormControl;\n+  form!: FormGroup;\n+  min: number|string = 1;\n+  max: number|string = 10;\n+}\n+\n+@Component({\n+  selector: 'min-max-form-control',\n+  template: `\n+    <div [formGroup]=\"form\">\n+      <input type=\"number\" [formControl]=\"control\" [max]=\"max\" [min]=\"min\">\n+   </div>`\n+})\n+class MinMaxFormControlComp {\n+  control!: FormControl;\n+  form!: FormGroup;\n+  min: number|string = 1;\n+  max: number|string = 10;\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "8e441c27f9df9c0a2d309b496b27660afa15150b",
            "filename": "packages/forms/test/template_integration_spec.ts",
            "status": "modified",
            "additions": 505,
            "deletions": 2,
            "changes": 507,
            "blob_url": "https://github.com/angular/angular/blob/8fb83ea1b524663bd804908308d528c338450270/packages%2Fforms%2Ftest%2Ftemplate_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/8fb83ea1b524663bd804908308d528c338450270/packages%2Fforms%2Ftest%2Ftemplate_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Ftemplate_integration_spec.ts?ref=8fb83ea1b524663bd804908308d528c338450270",
            "patch": "@@ -7,9 +7,9 @@\n  */\n \n import {ɵgetDOM as getDOM} from '@angular/common';\n-import {Component, Directive, forwardRef, Type} from '@angular/core';\n+import {Component, Directive, forwardRef, Input, Type, ViewChild} from '@angular/core';\n import {ComponentFixture, fakeAsync, TestBed, tick, waitForAsync} from '@angular/core/testing';\n-import {AbstractControl, AsyncValidator, COMPOSITION_BUFFER_MODE, FormControl, FormsModule, NG_ASYNC_VALIDATORS, NgForm, NgModel} from '@angular/forms';\n+import {AbstractControl, AsyncValidator, COMPOSITION_BUFFER_MODE, ControlValueAccessor, FormControl, FormsModule, MaxValidator, MinValidator, NG_ASYNC_VALIDATORS, NG_VALIDATORS, NG_VALUE_ACCESSOR, NgForm, NgModel} from '@angular/forms';\n import {By} from '@angular/platform-browser/src/dom/debug/by';\n import {dispatchEvent, sortedClassList} from '@angular/platform-browser/testing/src/browser_util';\n import {merge} from 'rxjs';\n@@ -1511,6 +1511,462 @@ import {NgModelCustomComp, NgModelCustomWrapper} from './value_accessor_integrat\n            expect(onNgModelChange).toHaveBeenCalledTimes(2);\n            tick();\n          }));\n+\n+      it('should validate max', fakeAsync(() => {\n+           const fixture = initTest(NgModelMaxValidator);\n+           fixture.componentInstance.max = 10;\n+           fixture.detectChanges();\n+           tick();\n+\n+           const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+           const form = fixture.debugElement.children[0].injector.get(NgForm);\n+\n+           input.value = '';\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(true);\n+           expect(form.controls.max.errors).toBeNull();\n+\n+           input.value = 11;\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(false);\n+           expect(form.controls.max.errors).toEqual({max: {max: 10, actual: 11}});\n+\n+           input.value = 9;\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(true);\n+           expect(form.controls.max.errors).toBeNull();\n+         }));\n+\n+      it('should apply max validation when control value is defined as a string', fakeAsync(() => {\n+           const fixture = initTest(NgModelMaxValidator);\n+           fixture.componentInstance.max = 10;\n+           fixture.detectChanges();\n+           tick();\n+\n+           const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+           const form = fixture.debugElement.children[0].injector.get(NgForm);\n+\n+           input.value = '11';\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(false);\n+           expect(form.controls.max.errors).toEqual({max: {max: 10, actual: 11}});\n+\n+           input.value = '9';\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(true);\n+           expect(form.controls.max.errors).toBeNull();\n+         }));\n+\n+      it('should re-validate if max changes', fakeAsync(() => {\n+           const fixture = initTest(NgModelMaxValidator);\n+           fixture.componentInstance.max = 10;\n+           fixture.detectChanges();\n+           tick();\n+\n+           const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+           const form = fixture.debugElement.children[0].injector.get(NgForm);\n+\n+           input.value = 11;\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(false);\n+           expect(form.controls.max.errors).toEqual({max: {max: 10, actual: 11}});\n+\n+           input.value = 9;\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(true);\n+           expect(form.controls.max.errors).toBeNull();\n+\n+           fixture.componentInstance.max = 5;\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(false);\n+           expect(form.controls.max.errors).toEqual({max: {max: 5, actual: 9}});\n+         }));\n+\n+      it('should validate min', fakeAsync(() => {\n+           const fixture = initTest(NgModelMinValidator);\n+           fixture.componentInstance.min = 10;\n+           fixture.detectChanges();\n+           tick();\n+\n+           const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+           const form = fixture.debugElement.children[0].injector.get(NgForm);\n+\n+           input.value = '';\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(true);\n+           expect(form.controls.min.errors).toBeNull();\n+\n+           input.value = 11;\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(true);\n+           expect(form.controls.min.errors).toBeNull();\n+\n+           input.value = 9;\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(false);\n+           expect(form.controls.min.errors).toEqual({min: {min: 10, actual: 9}});\n+         }));\n+\n+      it('should apply min validation when control value is defined as a string', fakeAsync(() => {\n+           const fixture = initTest(NgModelMinValidator);\n+           fixture.componentInstance.min = 10;\n+           fixture.detectChanges();\n+           tick();\n+\n+           const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+           const form = fixture.debugElement.children[0].injector.get(NgForm);\n+\n+           input.value = '11';\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(true);\n+           expect(form.controls.min.errors).toBeNull();\n+\n+           input.value = '9';\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(false);\n+           expect(form.controls.min.errors).toEqual({min: {min: 10, actual: 9}});\n+         }));\n+\n+      it('should re-validate if min changes', fakeAsync(() => {\n+           const fixture = initTest(NgModelMinValidator);\n+           fixture.componentInstance.min = 10;\n+           fixture.detectChanges();\n+           tick();\n+\n+           const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+           const form = fixture.debugElement.children[0].injector.get(NgForm);\n+\n+           input.value = 11;\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(true);\n+           expect(form.controls.min.errors).toBeNull();\n+\n+           input.value = 9;\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(false);\n+           expect(form.controls.min.errors).toEqual({min: {min: 10, actual: 9}});\n+\n+           fixture.componentInstance.min = 9;\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(true);\n+           expect(form.controls.min.errors).toBeNull();\n+         }));\n+\n+      it('should not include the min and max validators when using another directive with the same properties',\n+         fakeAsync(() => {\n+           const fixture = initTest(NgModelNoMinMaxValidator);\n+           const validateFnSpy = spyOn(MaxValidator.prototype, 'validate');\n+\n+           fixture.componentInstance.min = 10;\n+           fixture.componentInstance.max = 20;\n+           fixture.detectChanges();\n+           tick();\n+\n+           const min = fixture.debugElement.query(By.directive(MinValidator));\n+           expect(min).toBeNull();\n+\n+           const max = fixture.debugElement.query(By.directive(MaxValidator));\n+           expect(max).toBeNull();\n+\n+           const cd = fixture.debugElement.query(By.directive(CustomDirective));\n+           expect(cd).toBeDefined();\n+\n+           expect(validateFnSpy).not.toHaveBeenCalled();\n+         }));\n+\n+      it('should not include the min and max validators when using a custom component with the same properties',\n+         fakeAsync(() => {\n+           @Directive({\n+             selector: 'my-custom-component',\n+             providers: [{\n+               provide: NG_VALUE_ACCESSOR,\n+               multi: true,\n+               useExisting: forwardRef(() => MyCustomComponentDirective),\n+             }]\n+           })\n+           class MyCustomComponentDirective implements ControlValueAccessor {\n+             @Input() min!: number;\n+             @Input() max!: number;\n+\n+             writeValue(obj: any): void {}\n+             registerOnChange(fn: any): void {}\n+             registerOnTouched(fn: any): void {}\n+           }\n+\n+           @Component({\n+             template: `\n+              <!-- no min/max validators should be matched on these elements -->\n+              <my-custom-component name=\"min\" ngModel [min]=\"min\"></my-custom-component>\n+              <my-custom-component name=\"max\" ngModel [max]=\"max\"></my-custom-component>\n+            `\n+           })\n+           class AppComponent {\n+           }\n+\n+           const fixture = initTest(AppComponent, MyCustomComponentDirective);\n+           const validateFnSpy = spyOn(MaxValidator.prototype, 'validate');\n+\n+           fixture.detectChanges();\n+           tick();\n+\n+           const mv = fixture.debugElement.query(By.directive(MaxValidator));\n+           expect(mv).toBeNull();\n+\n+           const cd = fixture.debugElement.query(By.directive(CustomDirective));\n+           expect(cd).toBeDefined();\n+\n+           expect(validateFnSpy).not.toHaveBeenCalled();\n+         }));\n+\n+      it('should not include the min and max validators for inputs with type range',\n+         fakeAsync(() => {\n+           @Component({template: '<input type=\"range\" min=\"10\" max=\"20\">'})\n+           class AppComponent {\n+           }\n+\n+           const fixture = initTest(AppComponent);\n+           const maxValidateFnSpy = spyOn(MaxValidator.prototype, 'validate');\n+           const minValidateFnSpy = spyOn(MinValidator.prototype, 'validate');\n+\n+           fixture.detectChanges();\n+           tick();\n+\n+           const maxValidator = fixture.debugElement.query(By.directive(MaxValidator));\n+           expect(maxValidator).toBeNull();\n+\n+           const minValidator = fixture.debugElement.query(By.directive(MinValidator));\n+           expect(minValidator).toBeNull();\n+\n+           expect(maxValidateFnSpy).not.toHaveBeenCalled();\n+           expect(minValidateFnSpy).not.toHaveBeenCalled();\n+         }));\n+\n+      ['number', 'string'].forEach((inputType: string) => {\n+        it(`should validate min and max when constraints are represented using a ${inputType}`,\n+           fakeAsync(() => {\n+             const fixture = initTest(NgModelMinMaxValidator);\n+\n+             fixture.componentInstance.min = inputType === 'string' ? '5' : 5;\n+             fixture.componentInstance.max = inputType === 'string' ? '10' : 10;\n+\n+             fixture.detectChanges();\n+             tick();\n+\n+             const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+             const form = fixture.debugElement.children[0].injector.get(NgForm);\n+\n+             input.value = '';\n+             dispatchEvent(input, 'input');\n+             fixture.detectChanges();\n+             expect(form.valid).toEqual(true);\n+             expect(form.controls.min_max.errors).toBeNull();\n+\n+             input.value = 11;\n+             dispatchEvent(input, 'input');\n+             fixture.detectChanges();\n+             expect(form.valid).toEqual(false);\n+             expect(form.controls.min_max.errors).toEqual({max: {max: 10, actual: 11}});\n+\n+             input.value = 4;\n+             dispatchEvent(input, 'input');\n+             fixture.detectChanges();\n+             expect(form.valid).toEqual(false);\n+             expect(form.controls.min_max.errors).toEqual({min: {min: 5, actual: 4}});\n+\n+             input.value = 9;\n+             dispatchEvent(input, 'input');\n+             fixture.detectChanges();\n+             expect(form.valid).toEqual(true);\n+             expect(form.controls.min_max.errors).toBeNull();\n+           }));\n+      });\n+      it('should validate min and max', fakeAsync(() => {\n+           const fixture = initTest(NgModelMinMaxValidator);\n+           fixture.componentInstance.min = 5;\n+           fixture.componentInstance.max = 10;\n+           fixture.detectChanges();\n+           tick();\n+\n+           const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+           const form = fixture.debugElement.children[0].injector.get(NgForm);\n+\n+           input.value = '';\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(true);\n+           expect(form.controls.min_max.errors).toBeNull();\n+\n+           input.value = 11;\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(false);\n+           expect(form.controls.min_max.errors).toEqual({max: {max: 10, actual: 11}});\n+\n+           input.value = 4;\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(false);\n+           expect(form.controls.min_max.errors).toEqual({min: {min: 5, actual: 4}});\n+\n+           input.value = 9;\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(true);\n+           expect(form.controls.min_max.errors).toBeNull();\n+         }));\n+\n+      it('should apply min and max validation when control value is defined as a string',\n+         fakeAsync(() => {\n+           const fixture = initTest(NgModelMinMaxValidator);\n+           fixture.componentInstance.min = 5;\n+           fixture.componentInstance.max = 10;\n+           fixture.detectChanges();\n+           tick();\n+\n+           const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+           const form = fixture.debugElement.children[0].injector.get(NgForm);\n+\n+           input.value = '';\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(true);\n+           expect(form.controls.min_max.errors).toBeNull();\n+\n+           input.value = '11';\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(false);\n+           expect(form.controls.min_max.errors).toEqual({max: {max: 10, actual: 11}});\n+\n+           input.value = '4';\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(false);\n+           expect(form.controls.min_max.errors).toEqual({min: {min: 5, actual: 4}});\n+\n+           input.value = '9';\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(true);\n+           expect(form.controls.min_max.errors).toBeNull();\n+         }));\n+\n+      it('should re-validate if min/max changes', fakeAsync(() => {\n+           const fixture = initTest(NgModelMinMaxValidator);\n+           fixture.componentInstance.min = 5;\n+           fixture.componentInstance.max = 10;\n+           fixture.detectChanges();\n+           tick();\n+\n+           const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+           const form = fixture.debugElement.children[0].injector.get(NgForm);\n+\n+           input.value = 10;\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(true);\n+           expect(form.controls.min_max.errors).toBeNull();\n+\n+           input.value = 12;\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(false);\n+           expect(form.controls.min_max.errors).toEqual({max: {max: 10, actual: 12}});\n+\n+           fixture.componentInstance.max = 12;\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(true);\n+           expect(form.controls.min_max.errors).toBeNull();\n+\n+           input.value = 5;\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(true);\n+           expect(form.controls.min_max.errors).toBeNull();\n+\n+           input.value = 0;\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(false);\n+           expect(form.controls.min_max.errors).toEqual({min: {min: 5, actual: 0}});\n+\n+           fixture.componentInstance.min = 0;\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(true);\n+           expect(form.controls.min_max.errors).toBeNull();\n+         }));\n+\n+      it('should run min/max validation for empty values ', fakeAsync(() => {\n+           const fixture = initTest(NgModelMinMaxValidator);\n+           fixture.componentInstance.min = 5;\n+           fixture.componentInstance.max = 10;\n+           fixture.detectChanges();\n+           tick();\n+\n+           const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+           const form = fixture.debugElement.children[0].injector.get(NgForm);\n+\n+           const maxValidateFnSpy = spyOn(MaxValidator.prototype, 'validate');\n+           const minValidateFnSpy = spyOn(MinValidator.prototype, 'validate');\n+\n+           input.value = '';\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toEqual(true);\n+           expect(form.controls.min_max.errors).toBeNull();\n+\n+           expect(maxValidateFnSpy).toHaveBeenCalled();\n+           expect(minValidateFnSpy).toHaveBeenCalled();\n+         }));\n+\n+      it('should run min/max validation for negative values', fakeAsync(() => {\n+           const fixture = initTest(NgModelMinMaxValidator);\n+           fixture.componentInstance.min = -20;\n+           fixture.componentInstance.max = -10;\n+           fixture.detectChanges();\n+           tick();\n+\n+           const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+           const form = fixture.debugElement.children[0].injector.get(NgForm);\n+\n+           input.value = '-30';\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toBeFalse();\n+           expect(form.controls.min_max.errors).toEqual({min: {min: -20, actual: -30}});\n+\n+           input.value = -15;\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toBeTruthy();\n+           expect(form.controls.min_max.errors).toBeNull();\n+\n+           input.value = -5;\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toBeFalse();\n+           expect(form.controls.min_max.errors).toEqual({max: {max: -10, actual: -5}});\n+\n+           input.value = 0;\n+           dispatchEvent(input, 'input');\n+           fixture.detectChanges();\n+           expect(form.valid).toBeFalse();\n+           expect(form.controls.min_max.errors).toEqual({max: {max: -10, actual: 0}});\n+         }));\n     });\n \n     describe('IME events', () => {\n@@ -1879,3 +2335,50 @@ class NgModelChangesForm {\n class NgModelChangeState {\n   onNgModelChange = () => {};\n }\n+\n+@Component({\n+  selector: 'ng-model-max',\n+  template: `<form><input name=\"max\" type=\"number\" ngModel [max]=\"max\"></form>`\n+})\n+class NgModelMaxValidator {\n+  max!: number;\n+}\n+\n+@Component({\n+  selector: 'ng-model-min',\n+  template: `<form><input name=\"min\" type=\"number\" ngModel [min]=\"min\"></form>`\n+})\n+class NgModelMinValidator {\n+  min!: number;\n+}\n+\n+@Component({\n+  selector: 'ng-model-min-max',\n+  template: `\n+    <form><input name=\"min_max\" type=\"number\" ngModel [min]=\"min\" [max]=\"max\"></form>`\n+})\n+class NgModelMinMaxValidator {\n+  min!: number|string;\n+  max!: number|string;\n+}\n+\n+@Directive({selector: '[myDir]'})\n+class CustomDirective {\n+  @Input() min!: number;\n+  @Input() max!: number;\n+}\n+\n+@Component({\n+  selector: 'ng-model-no-min-max',\n+  template: `\n+    <form>\n+      <input name=\"min\" type=\"text\" ngModel [min]=\"min\" myDir>\n+      <input name=\"max\" type=\"text\" ngModel [max]=\"max\" myDir>\n+    </form>\n+  `,\n+})\n+class NgModelNoMinMaxValidator {\n+  min!: number;\n+  max!: number;\n+  @ViewChild('myDir') myDir: any;\n+}"
        }
    ],
    "stats": {
        "total": 941,
        "additions": 936,
        "deletions": 5
    }
}