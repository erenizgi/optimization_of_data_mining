{
    "author": "zarend",
    "message": "feat(language-service): initial implementation for `findRenameLocations` (#40140)\n\nThis commit lays the groundwork for potentially providing rename\nlocations from the Ivy native LS. The approach is very similar to what\nwas done with the feature to find references. One difference, however,\nis that we did not require the references to be fully \"correct\". That\nis, the exact text spans did not matter so much, as long as we provide a\nlocation that logically includes the referenced item.\n\nAn example of a necessary difference between rename locations and references is\ndirectives. The entire element in the template is a \"reference\" of the\ndirective's class. However, it's not a valid location to be renamed. The\nsame goes for aliased inputs/outputs. The locations in the template\ndirectly map to the class property, which is correct for references, but\nwould not be correct for rename locations, which should instead map to\nthe string node fo the alias.\n\nAs an initial approach to address the aforementioned issues with rename\nlocations, we check that all the rename location nodes have the same text. If\n_any_ node has text that differs from the request, we do not return any\nrename locations. This works as a way to prevent renames that could\nbreak the the program by missing some required nodes in the rename action, but\nallowing other nodes to be renamed.\n\nPR Close #40140",
    "sha": "9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9",
    "files": [
        {
            "sha": "1557a1ac8d0dcf1a978550f9f0239fa7059289d5",
            "filename": "packages/language-service/ivy/language_service.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 3,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "raw_url": "https://github.com/angular/angular/raw/9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts?ref=9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9",
            "patch": "@@ -18,7 +18,7 @@ import {CompilerFactory} from './compiler_factory';\n import {CompletionBuilder, CompletionNodeContext} from './completions';\n import {DefinitionBuilder} from './definitions';\n import {QuickInfoBuilder} from './quick_info';\n-import {ReferenceBuilder} from './references';\n+import {ReferencesAndRenameBuilder} from './references';\n import {getTargetAtPosition, TargetContext, TargetNodeKind} from './template_target';\n import {getTemplateInfoAtPosition, isTypeScriptFile} from './utils';\n \n@@ -107,8 +107,16 @@ export class LanguageService {\n \n   getReferencesAtPosition(fileName: string, position: number): ts.ReferenceEntry[]|undefined {\n     const compiler = this.compilerFactory.getOrCreateWithChangedFile(fileName);\n-    const results =\n-        new ReferenceBuilder(this.strategy, this.tsLS, compiler).get(fileName, position);\n+    const results = new ReferencesAndRenameBuilder(this.strategy, this.tsLS, compiler)\n+                        .getReferencesAtPosition(fileName, position);\n+    this.compilerFactory.registerLastKnownProgram();\n+    return results;\n+  }\n+\n+  findRenameLocations(fileName: string, position: number): readonly ts.RenameLocation[]|undefined {\n+    const compiler = this.compilerFactory.getOrCreateWithChangedFile(fileName);\n+    const results = new ReferencesAndRenameBuilder(this.strategy, this.tsLS, compiler)\n+                        .findRenameLocations(fileName, position);\n     this.compilerFactory.registerLastKnownProgram();\n     return results;\n   }"
        },
        {
            "sha": "dfd76da857358f35cde1b1493c1f13cbace46a08",
            "filename": "packages/language-service/ivy/references.ts",
            "status": "modified",
            "additions": 256,
            "deletions": 72,
            "changes": 328,
            "blob_url": "https://github.com/angular/angular/blob/9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9/packages%2Flanguage-service%2Fivy%2Freferences.ts",
            "raw_url": "https://github.com/angular/angular/raw/9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9/packages%2Flanguage-service%2Fivy%2Freferences.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Freferences.ts?ref=9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9",
            "patch": "@@ -5,52 +5,213 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {TmplAstBoundAttribute, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n+import {AST, BindingPipe, LiteralPrimitive, MethodCall, PropertyRead, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstNode, TmplAstReference, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n import {absoluteFrom, absoluteFromSourceFile, AbsoluteFsPath} from '@angular/compiler-cli/src/ngtsc/file_system';\n-import {DirectiveSymbol, SymbolKind, TemplateTypeChecker, TypeCheckingProgramStrategy} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n+import {DirectiveSymbol, ShimLocation, SymbolKind, TemplateTypeChecker, TypeCheckingProgramStrategy} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import {ExpressionIdentifier, hasExpressionIdentifier} from '@angular/compiler-cli/src/ngtsc/typecheck/src/comments';\n import * as ts from 'typescript';\n \n import {getTargetAtPosition, TargetNodeKind} from './template_target';\n import {findTightestNode} from './ts_utils';\n-import {getDirectiveMatchesForAttribute, getDirectiveMatchesForElementTag, getTemplateInfoAtPosition, isWithin, TemplateInfo, toTextSpan} from './utils';\n+import {getDirectiveMatchesForAttribute, getDirectiveMatchesForElementTag, getTemplateInfoAtPosition, isTemplateNode, isWithin, TemplateInfo, toTextSpan} from './utils';\n \n-export class ReferenceBuilder {\n+interface FilePosition {\n+  fileName: string;\n+  position: number;\n+}\n+\n+function toFilePosition(shimLocation: ShimLocation): FilePosition {\n+  return {fileName: shimLocation.shimPath, position: shimLocation.positionInShimFile};\n+}\n+\n+enum RequestKind {\n+  Template,\n+  TypeScript,\n+}\n+\n+interface TemplateRequest {\n+  kind: RequestKind.Template;\n+  requestNode: TmplAstNode|AST;\n+  position: number;\n+}\n+\n+interface TypeScriptRequest {\n+  kind: RequestKind.TypeScript;\n+  requestNode: ts.Node;\n+}\n+\n+type RequestOrigin = TemplateRequest|TypeScriptRequest;\n+\n+interface TemplateLocationDetails {\n+  /**\n+   * A target node in a template.\n+   */\n+  templateTarget: TmplAstNode|AST;\n+\n+  /**\n+   * TypeScript locations which the template node maps to. A given template node might map to\n+   * several TS nodes. For example, a template node for an attribute might resolve to several\n+   * directives or a directive and one of its inputs.\n+   */\n+  typescriptLocations: FilePosition[];\n+}\n+\n+export class ReferencesAndRenameBuilder {\n   private readonly ttc = this.compiler.getTemplateTypeChecker();\n \n   constructor(\n       private readonly strategy: TypeCheckingProgramStrategy,\n       private readonly tsLS: ts.LanguageService, private readonly compiler: NgCompiler) {}\n \n-  get(filePath: string, position: number): ts.ReferenceEntry[]|undefined {\n+  findRenameLocations(filePath: string, position: number): readonly ts.RenameLocation[]|undefined {\n+    this.ttc.generateAllTypeCheckBlocks();\n+    const templateInfo = getTemplateInfoAtPosition(filePath, position, this.compiler);\n+    // We could not get a template at position so we assume the request is came from outside the\n+    // template.\n+    if (templateInfo === undefined) {\n+      const requestNode = this.getTsNodeAtPosition(filePath, position);\n+      if (requestNode === null) {\n+        return undefined;\n+      }\n+      const requestOrigin: TypeScriptRequest = {kind: RequestKind.TypeScript, requestNode};\n+      return this.findRenameLocationsAtTypescriptPosition(filePath, position, requestOrigin);\n+    }\n+\n+    return this.findRenameLocationsAtTemplatePosition(templateInfo, position);\n+  }\n+\n+  private findRenameLocationsAtTemplatePosition(templateInfo: TemplateInfo, position: number):\n+      readonly ts.RenameLocation[]|undefined {\n+    const allTargetDetails = this.getTargetDetailsAtTemplatePosition(templateInfo, position);\n+    if (allTargetDetails === null) {\n+      return undefined;\n+    }\n+\n+    const allRenameLocations: ts.RenameLocation[] = [];\n+    for (const targetDetails of allTargetDetails) {\n+      const requestOrigin: TemplateRequest = {\n+        kind: RequestKind.Template,\n+        requestNode: targetDetails.templateTarget,\n+        position,\n+      };\n+\n+      for (const location of targetDetails.typescriptLocations) {\n+        const locations = this.findRenameLocationsAtTypescriptPosition(\n+            location.fileName, location.position, requestOrigin);\n+        // If we couldn't find rename locations for _any_ result, we should not allow renaming to\n+        // proceed instead of having a partially complete rename.\n+        if (locations === undefined) {\n+          return undefined;\n+        }\n+        allRenameLocations.push(...locations);\n+      }\n+    }\n+    return allRenameLocations.length > 0 ? allRenameLocations : undefined;\n+  }\n+\n+  private getTsNodeAtPosition(filePath: string, position: number): ts.Node|null {\n+    const sf = this.strategy.getProgram().getSourceFile(filePath);\n+    if (!sf) {\n+      return null;\n+    }\n+    return findTightestNode(sf, position) ?? null;\n+  }\n+\n+  findRenameLocationsAtTypescriptPosition(\n+      filePath: string, position: number,\n+      requestOrigin: RequestOrigin): readonly ts.RenameLocation[]|undefined {\n+    let originalNodeText: string;\n+    if (requestOrigin.kind === RequestKind.TypeScript) {\n+      originalNodeText = requestOrigin.requestNode.getText();\n+    } else {\n+      const templateNodeText =\n+          getTemplateNodeRenameTextAtPosition(requestOrigin.requestNode, requestOrigin.position);\n+      if (templateNodeText === null) {\n+        return undefined;\n+      }\n+      originalNodeText = templateNodeText;\n+    }\n+\n+    const locations = this.tsLS.findRenameLocations(\n+        filePath, position, /*findInStrings*/ false, /*findInComments*/ false);\n+    if (locations === undefined) {\n+      return undefined;\n+    }\n+\n+    const entries: ts.RenameLocation[] = [];\n+    for (const location of locations) {\n+      // TODO(atscott): Determine if a file is a shim file in a more robust way and make the API\n+      // available in an appropriate location.\n+      if (this.ttc.isTrackedTypeCheckFile(absoluteFrom(location.fileName))) {\n+        const entry = this.convertToTemplateDocumentSpan(location, this.ttc, originalNodeText);\n+        // There is no template node whose text matches the original rename request. Bail on\n+        // renaming completely rather than providing incomplete results.\n+        if (entry === null) {\n+          return undefined;\n+        }\n+        entries.push(entry);\n+      } else {\n+        // Ensure we only allow renaming a TS result with matching text\n+        const refNode = this.getTsNodeAtPosition(location.fileName, location.textSpan.start);\n+        if (refNode === null || refNode.getText() !== originalNodeText) {\n+          return undefined;\n+        }\n+        entries.push(location);\n+      }\n+    }\n+    return entries;\n+  }\n+\n+  getReferencesAtPosition(filePath: string, position: number): ts.ReferenceEntry[]|undefined {\n     this.ttc.generateAllTypeCheckBlocks();\n     const templateInfo = getTemplateInfoAtPosition(filePath, position, this.compiler);\n-    return templateInfo !== undefined ?\n-        this.getReferencesAtTemplatePosition(templateInfo, position) :\n-        this.getReferencesAtTypescriptPosition(filePath, position);\n+    if (templateInfo === undefined) {\n+      return this.getReferencesAtTypescriptPosition(filePath, position);\n+    }\n+    return this.getReferencesAtTemplatePosition(templateInfo, position);\n   }\n \n-  private getReferencesAtTemplatePosition({template, component}: TemplateInfo, position: number):\n+  private getReferencesAtTemplatePosition(templateInfo: TemplateInfo, position: number):\n       ts.ReferenceEntry[]|undefined {\n+    const allTargetDetails = this.getTargetDetailsAtTemplatePosition(templateInfo, position);\n+    if (allTargetDetails === null) {\n+      return undefined;\n+    }\n+    const allReferences: ts.ReferenceEntry[] = [];\n+    for (const targetDetails of allTargetDetails) {\n+      for (const location of targetDetails.typescriptLocations) {\n+        const refs = this.getReferencesAtTypescriptPosition(location.fileName, location.position);\n+        if (refs !== undefined) {\n+          allReferences.push(...refs);\n+        }\n+      }\n+    }\n+    return allReferences.length > 0 ? allReferences : undefined;\n+  }\n+\n+  private getTargetDetailsAtTemplatePosition({template, component}: TemplateInfo, position: number):\n+      TemplateLocationDetails[]|null {\n     // Find the AST node in the template at the position.\n     const positionDetails = getTargetAtPosition(template, position);\n     if (positionDetails === null) {\n-      return undefined;\n+      return null;\n     }\n \n     const nodes = positionDetails.context.kind === TargetNodeKind.TwoWayBindingContext ?\n         positionDetails.context.nodes :\n         [positionDetails.context.node];\n \n-    const references: ts.ReferenceEntry[] = [];\n+    const details: TemplateLocationDetails[] = [];\n+\n     for (const node of nodes) {\n       // Get the information about the TCB at the template position.\n       const symbol = this.ttc.getSymbolOfNode(node, component);\n+      const templateTarget = node;\n+\n       if (symbol === null) {\n         continue;\n       }\n-\n       switch (symbol.kind) {\n         case SymbolKind.Directive:\n         case SymbolKind.Template:\n@@ -59,93 +220,86 @@ export class ReferenceBuilder {\n           break;\n         case SymbolKind.Element: {\n           const matches = getDirectiveMatchesForElementTag(symbol.templateNode, symbol.directives);\n-          references.push(...this.getReferencesForDirectives(matches) ?? []);\n+          details.push(\n+              {typescriptLocations: this.getPositionsForDirectives(matches), templateTarget});\n           break;\n         }\n         case SymbolKind.DomBinding: {\n           // Dom bindings aren't currently type-checked (see `checkTypeOfDomBindings`) so they don't\n           // have a shim location. This means we can't match dom bindings to their lib.dom\n           // reference, but we can still see if they match to a directive.\n           if (!(node instanceof TmplAstTextAttribute) && !(node instanceof TmplAstBoundAttribute)) {\n-            break;\n+            return null;\n           }\n           const directives = getDirectiveMatchesForAttribute(\n               node.name, symbol.host.templateNode, symbol.host.directives);\n-          references.push(...this.getReferencesForDirectives(directives) ?? []);\n+          details.push(\n+              {typescriptLocations: this.getPositionsForDirectives(directives), templateTarget});\n           break;\n         }\n         case SymbolKind.Reference: {\n-          const {shimPath, positionInShimFile} = symbol.referenceVarLocation;\n-          references.push(\n-              ...this.getReferencesAtTypescriptPosition(shimPath, positionInShimFile) ?? []);\n+          details.push(\n+              {typescriptLocations: [toFilePosition(symbol.referenceVarLocation)], templateTarget});\n           break;\n         }\n         case SymbolKind.Variable: {\n-          const {positionInShimFile: initializerPosition, shimPath} = symbol.initializerLocation;\n-          const localVarPosition = symbol.localVarLocation.positionInShimFile;\n-\n-          if ((node instanceof TmplAstVariable)) {\n-            if (node.valueSpan !== undefined && isWithin(position, node.valueSpan)) {\n+          if ((templateTarget instanceof TmplAstVariable)) {\n+            if (templateTarget.valueSpan !== undefined &&\n+                isWithin(position, templateTarget.valueSpan)) {\n               // In the valueSpan of the variable, we want to get the reference of the initializer.\n-              references.push(\n-                  ...this.getReferencesAtTypescriptPosition(shimPath, initializerPosition) ?? []);\n-            } else if (isWithin(position, node.keySpan)) {\n+              details.push({\n+                typescriptLocations: [toFilePosition(symbol.initializerLocation)],\n+                templateTarget,\n+              });\n+            } else if (isWithin(position, templateTarget.keySpan)) {\n               // In the keySpan of the variable, we want to get the reference of the local variable.\n-              references.push(\n-                  ...this.getReferencesAtTypescriptPosition(shimPath, localVarPosition) ?? []);\n+              details.push(\n+                  {typescriptLocations: [toFilePosition(symbol.localVarLocation)], templateTarget});\n             }\n           } else {\n-            // If the templateNode is not the `TmplAstVariable`, it must be a usage of the variable\n-            // somewhere in the template.\n-            references.push(\n-                ...this.getReferencesAtTypescriptPosition(shimPath, localVarPosition) ?? []);\n+            // If the templateNode is not the `TmplAstVariable`, it must be a usage of the\n+            // variable somewhere in the template.\n+            details.push(\n+                {typescriptLocations: [toFilePosition(symbol.localVarLocation)], templateTarget});\n           }\n-\n           break;\n         }\n         case SymbolKind.Input:\n         case SymbolKind.Output: {\n-          // TODO(atscott): Determine how to handle when the binding maps to several inputs/outputs\n-          const {shimPath, positionInShimFile} = symbol.bindings[0].shimLocation;\n-          references.push(\n-              ...this.getReferencesAtTypescriptPosition(shimPath, positionInShimFile) ?? []);\n+          details.push({\n+            typescriptLocations:\n+                symbol.bindings.map(binding => toFilePosition(binding.shimLocation)),\n+            templateTarget,\n+          });\n           break;\n         }\n         case SymbolKind.Pipe:\n         case SymbolKind.Expression: {\n-          const {shimPath, positionInShimFile} = symbol.shimLocation;\n-          references.push(\n-              ...this.getReferencesAtTypescriptPosition(shimPath, positionInShimFile) ?? []);\n+          details.push(\n+              {typescriptLocations: [toFilePosition(symbol.shimLocation)], templateTarget});\n           break;\n         }\n       }\n     }\n-    if (references.length === 0) {\n-      return undefined;\n-    }\n \n-    return references;\n+    return details.length > 0 ? details : null;\n   }\n \n-  private getReferencesForDirectives(directives: Set<DirectiveSymbol>):\n-      ts.ReferenceEntry[]|undefined {\n-    const allDirectiveRefs: ts.ReferenceEntry[] = [];\n+  private getPositionsForDirectives(directives: Set<DirectiveSymbol>): FilePosition[] {\n+    const allDirectives: FilePosition[] = [];\n     for (const dir of directives.values()) {\n       const dirClass = dir.tsSymbol.valueDeclaration;\n       if (dirClass === undefined || !ts.isClassDeclaration(dirClass) ||\n           dirClass.name === undefined) {\n         continue;\n       }\n \n-      const dirFile = dirClass.getSourceFile().fileName;\n-      const dirPosition = dirClass.name.getStart();\n-      const directiveRefs = this.getReferencesAtTypescriptPosition(dirFile, dirPosition);\n-      if (directiveRefs !== undefined) {\n-        allDirectiveRefs.push(...directiveRefs);\n-      }\n+      const {fileName} = dirClass.getSourceFile();\n+      const position = dirClass.name.getStart();\n+      allDirectives.push({fileName, position});\n     }\n \n-    return allDirectiveRefs.length > 0 ? allDirectiveRefs : undefined;\n+    return allDirectives;\n   }\n \n   private getReferencesAtTypescriptPosition(fileName: string, position: number):\n@@ -158,7 +312,7 @@ export class ReferenceBuilder {\n     const entries: ts.ReferenceEntry[] = [];\n     for (const ref of refs) {\n       if (this.ttc.isTrackedTypeCheckFile(absoluteFrom(ref.fileName))) {\n-        const entry = this.convertToTemplateReferenceEntry(ref, this.ttc);\n+        const entry = this.convertToTemplateDocumentSpan(ref, this.ttc);\n         if (entry !== null) {\n           entries.push(entry);\n         }\n@@ -169,27 +323,27 @@ export class ReferenceBuilder {\n     return entries;\n   }\n \n-  private convertToTemplateReferenceEntry(\n-      shimReferenceEntry: ts.ReferenceEntry,\n-      templateTypeChecker: TemplateTypeChecker): ts.ReferenceEntry|null {\n-    const sf = this.strategy.getProgram().getSourceFile(shimReferenceEntry.fileName);\n+  private convertToTemplateDocumentSpan<T extends ts.DocumentSpan>(\n+      shimDocumentSpan: T, templateTypeChecker: TemplateTypeChecker, requiredNodeText?: string): T\n+      |null {\n+    const sf = this.strategy.getProgram().getSourceFile(shimDocumentSpan.fileName);\n     if (sf === undefined) {\n       return null;\n     }\n-    const tcbNode = findTightestNode(sf, shimReferenceEntry.textSpan.start);\n+    const tcbNode = findTightestNode(sf, shimDocumentSpan.textSpan.start);\n     if (tcbNode === undefined ||\n         hasExpressionIdentifier(sf, tcbNode, ExpressionIdentifier.EVENT_PARAMETER)) {\n-      // If the reference result is the $event parameter in the subscribe/addEventListener function\n-      // in the TCB, we want to filter this result out of the references. We really only want to\n-      // return references to the parameter in the template itself.\n+      // If the reference result is the $event parameter in the subscribe/addEventListener\n+      // function in the TCB, we want to filter this result out of the references. We really only\n+      // want to return references to the parameter in the template itself.\n       return null;\n     }\n-\n-    // TODO(atscott): Determine how to consistently resolve paths. i.e. with the project serverHost\n-    // or LSParseConfigHost in the adapter. We should have a better defined way to normalize paths.\n+    // TODO(atscott): Determine how to consistently resolve paths. i.e. with the project\n+    // serverHost or LSParseConfigHost in the adapter. We should have a better defined way to\n+    // normalize paths.\n     const mapping = templateTypeChecker.getTemplateMappingAtShimLocation({\n-      shimPath: absoluteFrom(shimReferenceEntry.fileName),\n-      positionInShimFile: shimReferenceEntry.textSpan.start,\n+      shimPath: absoluteFrom(shimDocumentSpan.fileName),\n+      positionInShimFile: shimDocumentSpan.textSpan.start,\n     });\n     if (mapping === null) {\n       return null;\n@@ -202,16 +356,46 @@ export class ReferenceBuilder {\n     } else if (templateSourceMapping.type === 'external') {\n       templateUrl = absoluteFrom(templateSourceMapping.templateUrl);\n     } else {\n-      // This includes indirect mappings, which are difficult to map directly to the code location.\n-      // Diagnostics similarly return a synthetic template string for this case rather than a real\n-      // location.\n+      // This includes indirect mappings, which are difficult to map directly to the code\n+      // location. Diagnostics similarly return a synthetic template string for this case rather\n+      // than a real location.\n+      return null;\n+    }\n+\n+    if (requiredNodeText !== undefined && span.toString() !== requiredNodeText) {\n       return null;\n     }\n \n     return {\n-      ...shimReferenceEntry,\n+      ...shimDocumentSpan,\n       fileName: templateUrl,\n       textSpan: toTextSpan(span),\n     };\n   }\n }\n+\n+function getTemplateNodeRenameTextAtPosition(node: TmplAstNode|AST, position: number): string|null {\n+  if (node instanceof TmplAstBoundAttribute || node instanceof TmplAstTextAttribute ||\n+      node instanceof TmplAstBoundEvent) {\n+    return node.name;\n+  } else if (node instanceof TmplAstVariable || node instanceof TmplAstReference) {\n+    if (isWithin(position, node.keySpan)) {\n+      return node.keySpan.toString();\n+    } else if (node.valueSpan && isWithin(position, node.valueSpan)) {\n+      return node.valueSpan.toString();\n+    }\n+  }\n+\n+  if (node instanceof BindingPipe) {\n+    // TODO(atscott): Add support for renaming pipes\n+    return null;\n+  }\n+  if (node instanceof PropertyRead || node instanceof MethodCall || node instanceof PropertyWrite ||\n+      node instanceof SafePropertyRead || node instanceof SafeMethodCall) {\n+    return node.name;\n+  } else if (node instanceof LiteralPrimitive) {\n+    return node.value;\n+  }\n+\n+  return null;\n+}"
        },
        {
            "sha": "52f1f82983ab85dc0f52344b3fecef4b598c6568",
            "filename": "packages/language-service/ivy/test/definitions_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9/packages%2Flanguage-service%2Fivy%2Ftest%2Fdefinitions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9/packages%2Flanguage-service%2Fivy%2Ftest%2Fdefinitions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fdefinitions_spec.ts?ref=9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9",
            "patch": "@@ -10,7 +10,7 @@ import {absoluteFrom, AbsoluteFsPath} from '@angular/compiler-cli/src/ngtsc/file\n import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n \n import {extractCursorInfo, LanguageServiceTestEnvironment} from './env';\n-import {assertFileNames, createModuleWithDeclarations, humanizeDefinitionInfo} from './test_utils';\n+import {assertFileNames, createModuleWithDeclarations, humanizeDocumentSpanLike} from './test_utils';\n \n describe('definitions', () => {\n   it('returns the pipe class as definition when checkTypeOfPipes is false', () => {\n@@ -27,8 +27,8 @@ describe('definitions', () => {\n         export class AppCmp {}\n       `,\n     };\n-    const env = createModuleWithDeclarations([appFile], [templateFile]);\n     // checkTypeOfPipes is set to false when strict templates is false\n+    const env = createModuleWithDeclarations([appFile], [templateFile], {strictTemplates: false});\n     const {textSpan, definitions} =\n         getDefinitionsAndAssertBoundSpan(env, absoluteFrom('/app.html'), cursor);\n     expect(text.substr(textSpan.start, textSpan.length)).toEqual('date');\n@@ -143,6 +143,6 @@ describe('definitions', () => {\n     const definitionAndBoundSpan = env.ngLS.getDefinitionAndBoundSpan(fileName, cursor);\n     const {textSpan, definitions} = definitionAndBoundSpan!;\n     expect(definitions).toBeTruthy();\n-    return {textSpan, definitions: definitions!.map(d => humanizeDefinitionInfo(d, env.host))};\n+    return {textSpan, definitions: definitions!.map(d => humanizeDocumentSpanLike(d, env))};\n   }\n });"
        },
        {
            "sha": "715f27087c028152a64baff5a024927ff9343373",
            "filename": "packages/language-service/ivy/test/references_spec.ts",
            "status": "modified",
            "additions": 909,
            "deletions": 394,
            "changes": 1303,
            "blob_url": "https://github.com/angular/angular/blob/9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9/packages%2Flanguage-service%2Fivy%2Ftest%2Freferences_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9/packages%2Flanguage-service%2Fivy%2Ftest%2Freferences_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Freferences_spec.ts?ref=9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9",
            "patch": "@@ -8,235 +8,382 @@\n \n import {absoluteFrom, absoluteFrom as _} from '@angular/compiler-cli/src/ngtsc/file_system';\n import {initMockFileSystem, TestFile} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n-import * as ts from 'typescript/lib/tsserverlibrary';\n \n import {extractCursorInfo, LanguageServiceTestEnvironment} from './env';\n-import {assertFileNames, assertTextSpans, createModuleWithDeclarations, getText} from './test_utils';\n+import {assertFileNames, assertTextSpans, createModuleWithDeclarations, humanizeDocumentSpanLike} from './test_utils';\n \n-describe('find references', () => {\n+describe('find references and rename locations', () => {\n   let env: LanguageServiceTestEnvironment;\n \n   beforeEach(() => {\n     initMockFileSystem('Native');\n   });\n \n-  it('gets component member references from TS file', () => {\n-    const {text, cursor} = extractCursorInfo(`\n+  afterEach(() => {\n+    // Clear env so it's not accidentally carried over to the next test.\n+    env = undefined!;\n+  });\n+\n+  describe('cursor is on binding in component class', () => {\n+    let cursor: number;\n+\n+    beforeEach(() => {\n+      const cursorInfo = extractCursorInfo(`\n           import {Component} from '@angular/core';\n \n           @Component({templateUrl: './app.html'})\n           export class AppCmp {\n             myP¦rop!: string;\n           }`);\n-    const appFile = {name: _('/app.ts'), contents: text};\n-    const templateFile = {name: _('/app.html'), contents: '{{myProp}}'};\n-    env = createModuleWithDeclarations([appFile], [templateFile]);\n-    const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-    expect(refs.length).toBe(2);\n-    assertFileNames(refs, ['app.html', 'app.ts']);\n-    assertTextSpans(refs, ['myProp']);\n-  });\n+      cursor = cursorInfo.cursor;\n+      const appFile = {name: _('/app.ts'), contents: cursorInfo.text};\n+      const templateFile = {name: _('/app.html'), contents: '{{myProp}}'};\n+      env = createModuleWithDeclarations([appFile], [templateFile]);\n+    });\n \n-  it('gets component member references from TS file and inline template', () => {\n-    const {text, cursor} = extractCursorInfo(`\n-          import {Component} from '@angular/core';\n+    it('gets component member references from TS file and external template', () => {\n+      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      expect(refs.length).toBe(2);\n+      assertFileNames(refs, ['app.html', 'app.ts']);\n+      assertTextSpans(refs, ['myProp']);\n+    });\n \n-          @Component({template: '{{myProp}}'})\n-          export class AppCmp {\n-            myP¦rop!: string;\n-          }`);\n-    const appFile = {name: _('/app.ts'), contents: text};\n-    env = createModuleWithDeclarations([appFile]);\n-    const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-    expect(refs.length).toBe(2);\n-    assertFileNames(refs, ['app.ts']);\n-    assertTextSpans(refs, ['myProp']);\n+    it('gets rename locations from TS file and external template', () => {\n+      const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+      expect(renameLocations.length).toBe(2);\n+      assertFileNames(renameLocations, ['app.html', 'app.ts']);\n+      assertTextSpans(renameLocations, ['myProp']);\n+    });\n   });\n \n-  it('gets component member references from template', () => {\n-    const appFile = {\n-      name: _('/app.ts'),\n-      contents: `\n+  describe('when cursor is on binding in an external template', () => {\n+    let cursor: number;\n+\n+    beforeEach(() => {\n+      const appFile = {\n+        name: _('/app.ts'),\n+        contents: `\n           import {Component} from '@angular/core';\n \n           @Component({templateUrl: './app.html'})\n           export class AppCmp {\n             myProp = '';\n           }`,\n-    };\n-    const {text, cursor} = extractCursorInfo('{{myP¦rop}}');\n-    const templateFile = {name: _('/app.html'), contents: text};\n-    env = createModuleWithDeclarations([appFile], [templateFile]);\n-    const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n-    expect(refs.length).toBe(2);\n-    assertFileNames(refs, ['app.html', 'app.ts']);\n-    assertTextSpans(refs, ['myProp']);\n+      };\n+      const cursorInfo = extractCursorInfo('{{myP¦rop}}');\n+      cursor = cursorInfo.cursor;\n+      const templateFile = {name: _('/app.html'), contents: cursorInfo.text};\n+      env = createModuleWithDeclarations([appFile], [templateFile]);\n+    });\n+\n+    it('gets references', () => {\n+      const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n+      expect(refs.length).toBe(2);\n+      assertFileNames(refs, ['app.html', 'app.ts']);\n+      assertTextSpans(refs, ['myProp']);\n+    });\n+\n+    it('gets rename locations', () => {\n+      const renameLocations = getRenameLocationsAtPosition(_('/app.html'), cursor)!;\n+      expect(renameLocations.length).toBe(2);\n+      assertFileNames(renameLocations, ['app.html', 'app.ts']);\n+      assertTextSpans(renameLocations, ['myProp']);\n+    });\n   });\n \n-  it('should work for method calls', () => {\n-    const {text, cursor} = extractCursorInfo(`\n+  describe('when cursor is on function call in external template', () => {\n+    let cursor: number;\n+\n+    beforeEach(() => {\n+      const cursorInfo = extractCursorInfo(`\n           import {Component} from '@angular/core';\n \n           @Component({template: '<div (click)=\"set¦Title(2)\"></div>'})\n           export class AppCmp {\n             setTitle(s: number) {}\n           }`);\n-    const appFile = {name: _('/app.ts'), contents: text};\n-    env = createModuleWithDeclarations([appFile]);\n-    const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-    expect(refs.length).toBe(2);\n+      cursor = cursorInfo.cursor;\n+      const appFile = {name: _('/app.ts'), contents: cursorInfo.text};\n+      env = createModuleWithDeclarations([appFile]);\n+    });\n \n-    assertFileNames(refs, ['app.ts']);\n-    assertTextSpans(refs, ['setTitle']);\n+    it('gets component member reference in ts file', () => {\n+      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      expect(refs.length).toBe(2);\n+\n+      assertFileNames(refs, ['app.ts']);\n+      assertTextSpans(refs, ['setTitle']);\n+    });\n+\n+    it('gets rename location in ts file', () => {\n+      const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+      expect(renameLocations.length).toBe(2);\n+\n+      assertFileNames(renameLocations, ['app.ts']);\n+      assertTextSpans(renameLocations, ['setTitle']);\n+    });\n   });\n \n-  it('should work for method call arguments', () => {\n-    const {text, cursor} = extractCursorInfo(`\n+  describe('when cursor in on argument to a function call in an external template', () => {\n+    let cursor: number;\n+\n+    beforeEach(() => {\n+      const cursorInfo = extractCursorInfo(`\n           import {Component} from '@angular/core';\n \n           @Component({template: '<div (click)=\"setTitle(ti¦tle)\"></div>'})\n           export class AppCmp {\n             title = '';\n             setTitle(s: string) {}\n           }`);\n-    const appFile = {name: _('/app.ts'), contents: text};\n-    env = createModuleWithDeclarations([appFile]);\n-    const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-    expect(refs.length).toBe(2);\n+      cursor = cursorInfo.cursor;\n+      const appFile = {name: _('/app.ts'), contents: cursorInfo.text};\n+      env = createModuleWithDeclarations([appFile]);\n+    });\n+\n+    it('gets member reference in ts file', () => {\n+      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      expect(refs.length).toBe(2);\n+\n+      assertTextSpans(refs, ['title']);\n+    });\n+\n+    it('finds rename location in ts file', () => {\n+      const refs = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+      expect(refs.length).toBe(2);\n \n-    assertTextSpans(refs, ['title']);\n+      assertTextSpans(refs, ['title']);\n+    });\n   });\n \n-  it('should work for $event in method call arguments', () => {\n-    const {text, cursor} = extractCursorInfo(`\n-          import {Component} from '@angular/core';\n+  describe('when cursor is on $event in method call arguments', () => {\n+    let cursor: number;\n \n+    beforeEach(() => {\n+      const cursorInfo = extractCursorInfo(`\n+          import {Component} from '@angular/core';\n           @Component({template: '<div (click)=\"setTitle($even¦t)\"></div>'})\n           export class AppCmp {\n             setTitle(s: any) {}\n           }`);\n-    const appFile = {name: _('/app.ts'), contents: text};\n-    env = createModuleWithDeclarations([appFile]);\n-    const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-    expect(refs.length).toBe(1);\n+      cursor = cursorInfo.cursor;\n+      const appFile = {name: _('/app.ts'), contents: cursorInfo.text};\n+      env = createModuleWithDeclarations([appFile]);\n+    });\n+\n+    it('find references', () => {\n+      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      expect(refs.length).toBe(1);\n \n-    assertTextSpans(refs, ['$event']);\n+      assertTextSpans(refs, ['$event']);\n+    });\n+\n+    it('gets no rename locations', () => {\n+      const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+      expect(renameLocations).toBeUndefined();\n+    });\n   });\n \n-  it('should work for property writes', () => {\n-    const appFile = {\n-      name: _('/app.ts'),\n-      contents: `\n+  describe('when cursor in on LHS of property write in external template', () => {\n+    let cursor: number;\n+\n+    beforeEach(() => {\n+      const appFile = {\n+        name: _('/app.ts'),\n+        contents: `\n           import {Component} from '@angular/core';\n \n           @Component({templateUrl: './app.html' })\n           export class AppCmp {\n             title = '';\n           }`,\n-    };\n-    const templateFileWithCursor = `<div (click)=\"ti¦tle = 'newtitle'\"></div>`;\n-    const {text, cursor} = extractCursorInfo(templateFileWithCursor);\n-    const templateFile = {name: _('/app.html'), contents: text};\n-    env = createModuleWithDeclarations([appFile], [templateFile]);\n-    const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n-    expect(refs.length).toBe(2);\n-\n-    assertFileNames(refs, ['app.ts', 'app.html']);\n-    assertTextSpans(refs, ['title']);\n+      };\n+      const templateFileWithCursor = `<div (click)=\"ti¦tle = 'newtitle'\"></div>`;\n+      const cursorInfo = extractCursorInfo(templateFileWithCursor);\n+      cursor = cursorInfo.cursor;\n+      const templateFile = {name: _('/app.html'), contents: cursorInfo.text};\n+      env = createModuleWithDeclarations([appFile], [templateFile]);\n+    });\n+\n+    it('gets member reference in ts file', () => {\n+      const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n+      expect(refs.length).toBe(2);\n+\n+      assertFileNames(refs, ['app.ts', 'app.html']);\n+      assertTextSpans(refs, ['title']);\n+    });\n+\n+    it('gets rename location in ts file', () => {\n+      const renameLocations = getRenameLocationsAtPosition(_('/app.html'), cursor)!;\n+      expect(renameLocations.length).toBe(2);\n+\n+      assertFileNames(renameLocations, ['app.ts', 'app.html']);\n+      assertTextSpans(renameLocations, ['title']);\n+    });\n   });\n \n-  it('should work for RHS of property writes', () => {\n-    const {text, cursor} = extractCursorInfo(`\n+  describe('when cursor in on RHS of property write in external template', () => {\n+    let cursor: number;\n+\n+    beforeEach(() => {\n+      const cursorInfo = extractCursorInfo(`\n           import {Component} from '@angular/core';\n \n           @Component({template: '<div (click)=\"title = otherT¦itle\"></div>' })\n           export class AppCmp {\n             title = '';\n             otherTitle = '';\n           }`);\n-    const appFile = {\n-      name: _('/app.ts'),\n-      contents: text,\n-    };\n-    env = createModuleWithDeclarations([appFile]);\n-    const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-    expect(refs.length).toBe(2);\n+      cursor = cursorInfo.cursor;\n+      const appFile = {\n+        name: _('/app.ts'),\n+        contents: cursorInfo.text,\n+      };\n+      env = createModuleWithDeclarations([appFile]);\n+    });\n+\n+    it('get reference to member in ts file', () => {\n+      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      expect(refs.length).toBe(2);\n+\n+      assertFileNames(refs, ['app.ts']);\n+      assertTextSpans(refs, ['otherTitle']);\n+    });\n+\n+    it('finds rename location in ts file', () => {\n+      const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+      expect(renameLocations.length).toBe(2);\n \n-    assertFileNames(refs, ['app.ts']);\n-    assertTextSpans(refs, ['otherTitle']);\n+      assertFileNames(renameLocations, ['app.ts']);\n+      assertTextSpans(renameLocations, ['otherTitle']);\n+    });\n   });\n \n-  it('should work for keyed reads', () => {\n-    const {text, cursor} = extractCursorInfo(`\n+  describe('when cursor in on a keyed read', () => {\n+    let cursor: number;\n+\n+    beforeEach(() => {\n+      const cursorInfo = extractCursorInfo(`\n           import {Component} from '@angular/core';\n \n           @Component({template: '{{hero[\"na¦me\"]}}' })\n           export class AppCmp {\n             hero: {name: string} = {name: 'Superman'};\n           }`);\n-    const appFile = {\n-      name: _('/app.ts'),\n-      contents: text,\n-    };\n-    env = createModuleWithDeclarations([appFile]);\n-    const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-    // 3 references: the type definition, the value assignment, and the read in the template\n-    expect(refs.length).toBe(3);\n-\n-    assertFileNames(refs, ['app.ts']);\n-    // TODO(atscott): investigate if we can make the template keyed read be just the 'name' part.\n-    // The TypeScript implementation specifically adjusts the span to accommodate string literals:\n-    // https://sourcegraph.com/github.com/microsoft/TypeScript@d5779c75d3dd19565b60b9e2960b8aac36d4d635/-/blob/src/services/findAllReferences.ts#L508-512\n-    // One possible solution would be to extend `FullTemplateMapping` to include the matched TCB\n-    // node and then do the same thing that TS does: if the node is a string, adjust the span.\n-    assertTextSpans(refs, ['name', '\"name\"']);\n+      cursor = cursorInfo.cursor;\n+      const appFile = {\n+        name: _('/app.ts'),\n+        contents: cursorInfo.text,\n+      };\n+      env = createModuleWithDeclarations([appFile]);\n+    });\n+\n+    it('gets reference to member type definition and initialization in component class', () => {\n+      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+      // 3 references: the type definition, the value assignment, and the read in the template\n+      expect(refs.length).toBe(3);\n+\n+      assertFileNames(refs, ['app.ts']);\n+      // TODO(atscott): investigate if we can make the template keyed read be just the 'name' part.\n+      // The TypeScript implementation specifically adjusts the span to accommodate string literals:\n+      // https://sourcegraph.com/github.com/microsoft/TypeScript@d5779c75d3dd19565b60b9e2960b8aac36d4d635/-/blob/src/services/findAllReferences.ts#L508-512\n+      // One possible solution would be to extend `FullTemplateMapping` to include the matched TCB\n+      // node and then do the same thing that TS does: if the node is a string, adjust the span.\n+      assertTextSpans(refs, ['name', '\"name\"']);\n+    });\n+\n+    it('gets rename locations in component class', () => {\n+      const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+      expect(renameLocations).toBeUndefined();\n+\n+      // TODO(atscott): We should handle this case. The fix requires us to fix the result span as\n+      // described above.\n+      // 3 references: the type definition, the value assignment, and the read in the template\n+      // expect(renameLocations.length).toBe(3);\n+      //\n+      // assertFileNames(renameLocations, ['app.ts']);\n+      // assertTextSpans(renameLocations, ['name']);\n+    });\n   });\n \n-  it('should work for keyed writes', () => {\n-    const appFile = {\n-      name: _('/app.ts'),\n-      contents: `\n+  describe('when cursor in on RHS of keyed write in a template', () => {\n+    let cursor: number;\n+\n+    beforeEach(() => {\n+      const appFile = {\n+        name: _('/app.ts'),\n+        contents: `\n           import {Component} from '@angular/core';\n \n           @Component({templateUrl: './app.html' })\n           export class AppCmp {\n             hero: {name: string} = {name: 'Superman'};\n             batman = 'batman';\n           }`,\n-    };\n-    const templateFileWithCursor = `<div (click)=\"hero['name'] = bat¦man\"></div>`;\n-    const {text, cursor} = extractCursorInfo(templateFileWithCursor);\n-    const templateFile = {name: _('/app.html'), contents: text};\n-    env = createModuleWithDeclarations([appFile], [templateFile]);\n-    const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n-    expect(refs.length).toBe(2);\n-\n-    assertFileNames(refs, ['app.ts', 'app.html']);\n-    assertTextSpans(refs, ['batman']);\n+      };\n+      const templateFileWithCursor = `<div (click)=\"hero['name'] = bat¦man\"></div>`;\n+      const cursorInfo = extractCursorInfo(templateFileWithCursor);\n+      cursor = cursorInfo.cursor;\n+      const templateFile = {name: _('/app.html'), contents: cursorInfo.text};\n+      env = createModuleWithDeclarations([appFile], [templateFile]);\n+    });\n+\n+    it('get references in ts file', () => {\n+      const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n+      expect(refs.length).toBe(2);\n+\n+      assertFileNames(refs, ['app.ts', 'app.html']);\n+      assertTextSpans(refs, ['batman']);\n+    });\n+\n+    it('finds rename location in ts file', () => {\n+      const renameLocations = getRenameLocationsAtPosition(_('/app.html'), cursor)!;\n+      expect(renameLocations.length).toBe(2);\n+\n+      assertFileNames(renameLocations, ['app.ts', 'app.html']);\n+      assertTextSpans(renameLocations, ['batman']);\n+    });\n   });\n \n-  describe('references', () => {\n-    it('should work for element references', () => {\n-      const {text, cursor} = extractCursorInfo(`\n+  describe('when cursor in on an element reference', () => {\n+    let cursor: number;\n+\n+    beforeEach(() => {\n+      const cursorInfo = extractCursorInfo(`\n           import {Component} from '@angular/core';\n \n           @Component({template: '<input #myInput /> {{ myIn¦put.value }}'})\n           export class AppCmp {\n             title = '';\n           }`);\n-      const appFile = {name: _('/app.ts'), contents: text};\n+      cursor = cursorInfo.cursor;\n+      const appFile = {name: _('/app.ts'), contents: cursorInfo.text};\n       env = createModuleWithDeclarations([appFile]);\n+    });\n+\n+    it('get reference to declaration in template', () => {\n       const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+\n       expect(refs.length).toBe(2);\n       assertTextSpans(refs, ['myInput']);\n \n-      const originalRefs = env.ngLS.getReferencesAtPosition(_('/app.ts'), cursor)!;\n       // Get the declaration by finding the reference that appears first in the template\n-      originalRefs.sort((a, b) => a.textSpan.start - b.textSpan.start);\n-      expect(originalRefs[0].isDefinition).toBe(true);\n+      refs.sort((a, b) => a.textSpan.start - b.textSpan.start);\n+      expect(refs[0].isDefinition).toBe(true);\n+    });\n+\n+    it('finds rename location in template', () => {\n+      const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+\n+      expect(renameLocations.length).toBe(2);\n+      assertTextSpans(renameLocations, ['myInput']);\n     });\n+  });\n \n-    it('should work for template references', () => {\n+  describe('when cursor in on a template reference', () => {\n+    let cursor: number;\n+\n+    beforeEach(() => {\n       const templateWithCursor = `\n               <ng-template #myTemplate >bla</ng-template>\n               <ng-container [ngTemplateOutlet]=\"myTem¦plate\"></ng-container>`;\n@@ -250,21 +397,33 @@ describe('find references', () => {\n             title = '';\n           }`,\n       };\n-      const {text, cursor} = extractCursorInfo(templateWithCursor);\n-      const templateFile = {name: _('/app.html'), contents: text};\n+      const cursorInfo = extractCursorInfo(templateWithCursor);\n+      cursor = cursorInfo.cursor;\n+      const templateFile = {name: _('/app.html'), contents: cursorInfo.text};\n       env = createModuleWithDeclarations([appFile], [templateFile]);\n+    });\n+\n+    it('gets reference to declaration', () => {\n       const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n       expect(refs.length).toBe(2);\n       assertTextSpans(refs, ['myTemplate']);\n       assertFileNames(refs, ['app.html']);\n \n-      const originalRefs = env.ngLS.getReferencesAtPosition(_('/app.html'), cursor)!;\n       // Get the declaration by finding the reference that appears first in the template\n-      originalRefs.sort((a, b) => a.textSpan.start - b.textSpan.start);\n-      expect(originalRefs[0].isDefinition).toBe(true);\n+      refs.sort((a, b) => a.textSpan.start - b.textSpan.start);\n+      expect(refs[0].isDefinition).toBe(true);\n+    });\n+\n+    it('finds rename location in template', () => {\n+      const renameLocations = getRenameLocationsAtPosition(_('/app.html'), cursor)!;\n+      expect(renameLocations.length).toBe(2);\n+      assertTextSpans(renameLocations, ['myTemplate']);\n+      assertFileNames(renameLocations, ['app.html']);\n     });\n+  });\n \n-    describe('directive references', () => {\n+  describe('template references', () => {\n+    describe('directives', () => {\n       let appFile: TestFile;\n       let dirFile: TestFile;\n \n@@ -286,97 +445,185 @@ describe('find references', () => {\n         dirFile = {name: _('/dir.ts'), contents: dirFileContents};\n       });\n \n-      it('should work for usage of reference in template', () => {\n-        const templateWithCursor = '<div [dir] #dirRef=\"myDir\"></div> {{ dirR¦ef }}';\n-        const {text, cursor} = extractCursorInfo(templateWithCursor);\n-        const templateFile = {name: _('/app.html'), contents: text};\n-        env = createModuleWithDeclarations([appFile, dirFile], [templateFile]);\n-        const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n-        expect(refs.length).toBe(2);\n-        assertFileNames(refs, ['app.html']);\n-        assertTextSpans(refs, ['dirRef']);\n+      describe('when cursor is on usage of template reference', () => {\n+        let cursor: number;\n+        beforeEach(() => {\n+          const templateWithCursor = '<div [dir] #dirRef=\"myDir\"></div> {{ dirR¦ef }}';\n+          const cursorInfo = extractCursorInfo(templateWithCursor);\n+          cursor = cursorInfo.cursor;\n+          const templateFile = {name: _('/app.html'), contents: cursorInfo.text};\n+          env = createModuleWithDeclarations([appFile, dirFile], [templateFile]);\n+        });\n+\n+        it('should get references', () => {\n+          const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n+          expect(refs.length).toBe(2);\n+          assertFileNames(refs, ['app.html']);\n+          assertTextSpans(refs, ['dirRef']);\n+        });\n+\n+        it('should find rename locations', () => {\n+          const renameLocations = getRenameLocationsAtPosition(_('/app.html'), cursor)!;\n+          expect(renameLocations.length).toBe(2);\n+          assertFileNames(renameLocations, ['app.html']);\n+          assertTextSpans(renameLocations, ['dirRef']);\n+        });\n       });\n \n-      it('should work for prop reads of directive references', () => {\n-        const fileWithCursor = '<div [dir] #dirRef=\"myDir\"></div> {{ dirRef.dirV¦alue }}';\n-        const {text, cursor} = extractCursorInfo(fileWithCursor);\n-        const templateFile = {name: _('/app.html'), contents: text};\n-        env = createModuleWithDeclarations([appFile, dirFile], [templateFile]);\n-        const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n-        expect(refs.length).toBe(2);\n-        assertFileNames(refs, ['dir.ts', 'app.html']);\n-        assertTextSpans(refs, ['dirValue']);\n+      describe('when cursor is on a property read of directive reference', () => {\n+        let cursor: number;\n+        beforeEach(() => {\n+          const fileWithCursor = '<div [dir] #dirRef=\"myDir\"></div> {{ dirRef.dirV¦alue }}';\n+          const cursorInfo = extractCursorInfo(fileWithCursor);\n+          cursor = cursorInfo.cursor;\n+          const templateFile = {name: _('/app.html'), contents: cursorInfo.text};\n+          env = createModuleWithDeclarations([appFile, dirFile], [templateFile]);\n+        });\n+\n+        it('should get references', () => {\n+          const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n+          expect(refs.length).toBe(2);\n+          assertFileNames(refs, ['dir.ts', 'app.html']);\n+          assertTextSpans(refs, ['dirValue']);\n+        });\n+\n+        it('should find rename locations', () => {\n+          const renameLocations = getRenameLocationsAtPosition(_('/app.html'), cursor)!;\n+          expect(renameLocations.length).toBe(2);\n+          assertFileNames(renameLocations, ['dir.ts', 'app.html']);\n+          assertTextSpans(renameLocations, ['dirValue']);\n+        });\n       });\n \n-      it('should work for safe prop reads', () => {\n-        const fileWithCursor = '<div [dir] #dirRef=\"myDir\"></div> {{ dirRef?.dirV¦alue }}';\n-        const {text, cursor} = extractCursorInfo(fileWithCursor);\n-        const templateFile = {name: _('/app.html'), contents: text};\n-        env = createModuleWithDeclarations([appFile, dirFile], [templateFile]);\n-        const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n-        expect(refs.length).toBe(2);\n-        assertFileNames(refs, ['dir.ts', 'app.html']);\n-        assertTextSpans(refs, ['dirValue']);\n+      describe('when cursor is on a safe prop read', () => {\n+        let cursor: number;\n+        beforeEach(() => {\n+          const fileWithCursor = '<div [dir] #dirRef=\"myDir\"></div> {{ dirRef?.dirV¦alue }}';\n+          const cursorInfo = extractCursorInfo(fileWithCursor);\n+          cursor = cursorInfo.cursor;\n+          const templateFile = {name: _('/app.html'), contents: cursorInfo.text};\n+          env = createModuleWithDeclarations([appFile, dirFile], [templateFile]);\n+        });\n+\n+\n+        it('should get references', () => {\n+          const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n+          expect(refs.length).toBe(2);\n+          assertFileNames(refs, ['dir.ts', 'app.html']);\n+          assertTextSpans(refs, ['dirValue']);\n+        });\n+\n+        it('should find rename locations', () => {\n+          const renameLocations = getRenameLocationsAtPosition(_('/app.html'), cursor)!;\n+          expect(renameLocations.length).toBe(2);\n+          assertFileNames(renameLocations, ['dir.ts', 'app.html']);\n+          assertTextSpans(renameLocations, ['dirValue']);\n+        });\n       });\n \n-      it('should work for safe method calls', () => {\n-        const fileWithCursor = '<div [dir] #dirRef=\"myDir\"></div> {{ dirRef?.doSometh¦ing() }}';\n-        const {text, cursor} = extractCursorInfo(fileWithCursor);\n-        const templateFile = {name: _('/app.html'), contents: text};\n-        env = createModuleWithDeclarations([appFile, dirFile], [templateFile]);\n-        const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n-        expect(refs.length).toBe(2);\n-        assertFileNames(refs, ['dir.ts', 'app.html']);\n-        assertTextSpans(refs, ['doSomething']);\n+      describe('when cursor is on safe method call', () => {\n+        let cursor: number;\n+        beforeEach(() => {\n+          const fileWithCursor = '<div [dir] #dirRef=\"myDir\"></div> {{ dirRef?.doSometh¦ing() }}';\n+          const cursorInfo = extractCursorInfo(fileWithCursor);\n+          cursor = cursorInfo.cursor;\n+          const templateFile = {name: _('/app.html'), contents: cursorInfo.text};\n+          env = createModuleWithDeclarations([appFile, dirFile], [templateFile]);\n+        });\n+\n+\n+        it('should get references', () => {\n+          const refs = getReferencesAtPosition(_('/app.html'), cursor)!;\n+          expect(refs.length).toBe(2);\n+          assertFileNames(refs, ['dir.ts', 'app.html']);\n+          assertTextSpans(refs, ['doSomething']);\n+        });\n+\n+        it('should find rename locations', () => {\n+          const renameLocations = getRenameLocationsAtPosition(_('/app.html'), cursor)!;\n+          expect(renameLocations.length).toBe(2);\n+          assertFileNames(renameLocations, ['dir.ts', 'app.html']);\n+          assertTextSpans(renameLocations, ['doSomething']);\n+        });\n       });\n     });\n   });\n \n-  describe('variables', () => {\n-    it('should work for variable initialized implicitly', () => {\n-      const {text, cursor} = extractCursorInfo(`\n+  describe('template variables', () => {\n+    describe('when cursor is on variable which was initialized implicitly', () => {\n+      let cursor: number;\n+      beforeEach(() => {\n+        const cursorInfo = extractCursorInfo(`\n           import {Component} from '@angular/core';\n \n           @Component({template: '<div *ngFor=\"let hero of heroes\">{{her¦o}}</div>'})\n           export class AppCmp {\n             heroes: string[] = [];\n           }`);\n-      const appFile = {name: _('/app.ts'), contents: text};\n-      env = createModuleWithDeclarations([appFile]);\n-      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-      expect(refs.length).toBe(2);\n-      assertFileNames(refs, ['app.ts']);\n-      assertTextSpans(refs, ['hero']);\n+        cursor = cursorInfo.cursor;\n+        const appFile = {name: _('/app.ts'), contents: cursorInfo.text};\n+        env = createModuleWithDeclarations([appFile]);\n+      });\n \n-      const originalRefs = env.ngLS.getReferencesAtPosition(_('/app.ts'), cursor)!;\n-      // Get the declaration by finding the reference that appears first in the template\n-      originalRefs.sort((a, b) => a.textSpan.start - b.textSpan.start);\n-      expect(originalRefs[0].isDefinition).toBe(true);\n+      it('should find references', () => {\n+        const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+        expect(refs.length).toBe(2);\n+        assertFileNames(refs, ['app.ts']);\n+        assertTextSpans(refs, ['hero']);\n+\n+        const originalRefs = env.ngLS.getReferencesAtPosition(_('/app.ts'), cursor)!;\n+        // Get the declaration by finding the reference that appears first in the template\n+        originalRefs.sort((a, b) => a.textSpan.start - b.textSpan.start);\n+        expect(originalRefs[0].isDefinition).toBe(true);\n+      });\n+\n+      it('should find rename locations', () => {\n+        const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+        expect(renameLocations.length).toBe(2);\n+        assertFileNames(renameLocations, ['app.ts']);\n+        assertTextSpans(renameLocations, ['hero']);\n+      });\n     });\n \n-    it('should work for renamed variables', () => {\n-      const {text, cursor} = extractCursorInfo(`\n+    describe('when cursor is on renamed variable', () => {\n+      let cursor: number;\n+      beforeEach(() => {\n+        const cursorInfo = extractCursorInfo(`\n           import {Component} from '@angular/core';\n \n           @Component({template: '<div *ngFor=\"let hero of heroes; let iRef = index\">{{iR¦ef}}</div>'})\n           export class AppCmp {\n             heroes: string[] = [];\n           }`);\n-      const appFile = {name: _('/app.ts'), contents: text};\n-      env = createModuleWithDeclarations([appFile]);\n-      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-      expect(refs.length).toBe(2);\n-      assertFileNames(refs, ['app.ts']);\n-      assertTextSpans(refs, ['iRef']);\n+        cursor = cursorInfo.cursor;\n+        const appFile = {name: _('/app.ts'), contents: cursorInfo.text};\n+        env = createModuleWithDeclarations([appFile]);\n+      });\n \n-      const originalRefs = env.ngLS.getReferencesAtPosition(_('/app.ts'), cursor)!;\n-      // Get the declaration by finding the reference that appears first in the template\n-      originalRefs.sort((a, b) => a.textSpan.start - b.textSpan.start);\n-      expect(originalRefs[0].isDefinition).toBe(true);\n+      it('should find references', () => {\n+        const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+        expect(refs.length).toBe(2);\n+        assertFileNames(refs, ['app.ts']);\n+        assertTextSpans(refs, ['iRef']);\n+\n+        const originalRefs = env.ngLS.getReferencesAtPosition(_('/app.ts'), cursor)!;\n+        // Get the declaration by finding the reference that appears first in the template\n+        originalRefs.sort((a, b) => a.textSpan.start - b.textSpan.start);\n+        expect(originalRefs[0].isDefinition).toBe(true);\n+      });\n+\n+      it('should find rename locations', () => {\n+        const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+        expect(renameLocations.length).toBe(2);\n+        assertFileNames(renameLocations, ['app.ts']);\n+        assertTextSpans(renameLocations, ['iRef']);\n+      });\n     });\n \n-    it('should work for initializer of variable', () => {\n-      const dirFile = `\n+    describe('when cursor is on initializer of variable', () => {\n+      let cursor: number;\n+      beforeEach(() => {\n+        const dirFile = `\n         import {Directive, Input} from '@angular/core';\n \n         export class ExampleContext<T> {\n@@ -391,7 +638,7 @@ describe('find references', () => {\n             return true;\n           }\n         }`;\n-      const fileWithCursor = `\n+        const fileWithCursor = `\n         import {Component, NgModule} from '@angular/core';\n         import {ExampleDirective} from './example-directive';\n \n@@ -402,33 +649,59 @@ describe('find references', () => {\n \n         @NgModule({declarations: [AppCmp, ExampleDirective]})\n         export class AppModule {}`;\n-      const {text, cursor} = extractCursorInfo(fileWithCursor);\n-      env = LanguageServiceTestEnvironment.setup([\n-        {name: _('/app.ts'), contents: text, isRoot: true},\n-        {name: _('/example-directive.ts'), contents: dirFile},\n-      ]);\n-      env.expectNoSourceDiagnostics();\n-      env.expectNoTemplateDiagnostics(absoluteFrom('/app.ts'), 'AppCmp');\n-      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-      expect(refs.length).toBe(2);\n-      assertFileNames(refs, ['app.ts', 'example-directive.ts']);\n-      assertTextSpans(refs, ['identifier']);\n+        const cursorInfo = extractCursorInfo(fileWithCursor);\n+        cursor = cursorInfo.cursor;\n+        env = LanguageServiceTestEnvironment.setup([\n+          {name: _('/app.ts'), contents: cursorInfo.text, isRoot: true},\n+          {name: _('/example-directive.ts'), contents: dirFile},\n+        ]);\n+        env.expectNoSourceDiagnostics();\n+        env.expectNoTemplateDiagnostics(absoluteFrom('/app.ts'), 'AppCmp');\n+      });\n+\n+      it('should find references', () => {\n+        const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+        expect(refs.length).toBe(2);\n+        assertFileNames(refs, ['app.ts', 'example-directive.ts']);\n+        assertTextSpans(refs, ['identifier']);\n+      });\n+\n+      it('should find rename locations', () => {\n+        const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+        expect(renameLocations.length).toBe(2);\n+        assertFileNames(renameLocations, ['app.ts', 'example-directive.ts']);\n+        assertTextSpans(renameLocations, ['identifier']);\n+      });\n     });\n \n-    it('should work for prop reads of variables', () => {\n-      const {text, cursor} = extractCursorInfo(`\n+    describe('when cursor is on property read of variable', () => {\n+      let cursor: number;\n+      beforeEach(() => {\n+        const cursorInfo = extractCursorInfo(`\n             import {Component} from '@angular/core';\n \n             @Component({template: '<div *ngFor=\"let hero of heroes\">{{hero.na¦me}}</div>'})\n             export class AppCmp {\n               heroes: Array<{name: string}> = [];\n             }`);\n-      const appFile = {name: _('/app.ts'), contents: text};\n-      env = createModuleWithDeclarations([appFile]);\n-      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-      expect(refs.length).toBe(2);\n-      assertFileNames(refs, ['app.ts']);\n-      assertTextSpans(refs, ['name']);\n+        cursor = cursorInfo.cursor;\n+        const appFile = {name: _('/app.ts'), contents: cursorInfo.text};\n+        env = createModuleWithDeclarations([appFile]);\n+      });\n+\n+      it('should find references', () => {\n+        const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+        expect(refs.length).toBe(2);\n+        assertFileNames(refs, ['app.ts']);\n+        assertTextSpans(refs, ['name']);\n+      });\n+\n+      it('should find rename locations', () => {\n+        const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+        expect(renameLocations.length).toBe(2);\n+        assertFileNames(renameLocations, ['app.ts']);\n+        assertTextSpans(renameLocations, ['name']);\n+      });\n     });\n   });\n \n@@ -449,26 +722,45 @@ describe('find references', () => {\n       prefixPipeFile = {name: _('/prefix-pipe.ts'), contents: prefixPipe};\n     });\n \n-    it('should work for pipe names', () => {\n-      const appContentsWithCursor = `\n+    describe('when cursor is on pipe name', () => {\n+      let cursor: number;\n+      beforeEach(() => {\n+        const appContentsWithCursor = `\n         import {Component} from '@angular/core';\n \n         @Component({template: '{{birthday | prefi¦xPipe: \"MM/dd/yy\"}}'})\n         export class AppCmp {\n           birthday = '';\n         }\n       `;\n-      const {text, cursor} = extractCursorInfo(appContentsWithCursor);\n-      const appFile = {name: _('/app.ts'), contents: text};\n-      env = createModuleWithDeclarations([appFile, prefixPipeFile]);\n-      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-      expect(refs.length).toBe(5);\n-      assertFileNames(refs, ['index.d.ts', 'prefix-pipe.ts', 'app.ts']);\n-      assertTextSpans(refs, ['transform', 'prefixPipe']);\n+        const cursorInfo = extractCursorInfo(appContentsWithCursor);\n+        cursor = cursorInfo.cursor;\n+        const appFile = {name: _('/app.ts'), contents: cursorInfo.text};\n+        env = createModuleWithDeclarations([appFile, prefixPipeFile]);\n+      });\n+\n+      it('should find references', () => {\n+        const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+        expect(refs.length).toBe(5);\n+        assertFileNames(refs, ['index.d.ts', 'prefix-pipe.ts', 'app.ts']);\n+        assertTextSpans(refs, ['transform', 'prefixPipe']);\n+      });\n+\n+      it('should find rename locations', () => {\n+        const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+        expect(renameLocations).toBeUndefined();\n+\n+        // TODO(atscott): Add support for renaming the pipe 'name'\n+        // expect(renameLocations.length).toBe(2);\n+        // assertFileNames(renameLocations, ['prefix-pipe.ts', 'app.ts']);\n+        // assertTextSpans(renameLocations, ['prefixPipe']);\n+      });\n     });\n \n-    it('should work for pipe arguments', () => {\n-      const appContentsWithCursor = `\n+    describe('when cursor is on pipe argument', () => {\n+      let cursor: number;\n+      beforeEach(() => {\n+        const appContentsWithCursor = `\n         import {Component} from '@angular/core';\n \n         @Component({template: '{{birthday | prefixPipe: pr¦efix}}'})\n@@ -477,13 +769,25 @@ describe('find references', () => {\n           prefix = '';\n         }\n       `;\n-      const {text, cursor} = extractCursorInfo(appContentsWithCursor);\n-      const appFile = {name: _('/app.ts'), contents: text};\n-      env = createModuleWithDeclarations([appFile, prefixPipeFile]);\n-      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-      expect(refs.length).toBe(2);\n-      assertFileNames(refs, ['app.ts']);\n-      assertTextSpans(refs, ['prefix']);\n+        const cursorInfo = extractCursorInfo(appContentsWithCursor);\n+        cursor = cursorInfo.cursor;\n+        const appFile = {name: _('/app.ts'), contents: cursorInfo.text};\n+        env = createModuleWithDeclarations([appFile, prefixPipeFile]);\n+      });\n+\n+      it('should find references', () => {\n+        const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+        expect(refs.length).toBe(2);\n+        assertFileNames(refs, ['app.ts']);\n+        assertTextSpans(refs, ['prefix']);\n+      });\n+\n+      it('should find rename locations', () => {\n+        const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+        expect(renameLocations.length).toBe(2);\n+        assertFileNames(renameLocations, ['app.ts']);\n+        assertTextSpans(renameLocations, ['prefix']);\n+      });\n     });\n   });\n \n@@ -496,69 +800,162 @@ describe('find references', () => {\n           @Input() model!: string;\n           @Input('alias') aliasedModel!: string;\n         }`;\n-    it('should work from the template', () => {\n-      const stringModelTestFile = {name: _('/string-model.ts'), contents: dirFileContents};\n-      const {text, cursor} = extractCursorInfo(`\n+    describe('when cursor is on the input in the template', () => {\n+      let cursor: number;\n+      beforeEach(() => {\n+        const stringModelTestFile = {name: _('/string-model.ts'), contents: dirFileContents};\n+        const cursorInfo = extractCursorInfo(`\n         import {Component} from '@angular/core';\n \n         @Component({template: '<div string-model [mod¦el]=\"title\"></div>'})\n         export class AppCmp {\n           title = 'title';\n         }`);\n-      const appFile = {name: _('/app.ts'), contents: text};\n-      env = createModuleWithDeclarations([appFile, stringModelTestFile]);\n-      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-      expect(refs.length).toEqual(2);\n-      assertFileNames(refs, ['string-model.ts', 'app.ts']);\n-      assertTextSpans(refs, ['model']);\n+        cursor = cursorInfo.cursor;\n+        const appFile = {name: _('/app.ts'), contents: cursorInfo.text};\n+        env = createModuleWithDeclarations([appFile, stringModelTestFile]);\n+      });\n+\n+      it('should find references', () => {\n+        const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+        expect(refs.length).toEqual(2);\n+        assertFileNames(refs, ['string-model.ts', 'app.ts']);\n+        assertTextSpans(refs, ['model']);\n+      });\n+\n+      it('should find rename locations', () => {\n+        const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+        expect(renameLocations.length).toEqual(2);\n+        assertFileNames(renameLocations, ['string-model.ts', 'app.ts']);\n+        assertTextSpans(renameLocations, ['model']);\n+      });\n+    });\n+\n+    describe('when cursor is on an input that maps to multiple directives', () => {\n+      let cursor: number;\n+      beforeEach(() => {\n+        const otherDirFile = {\n+          name: _('/other-dir.ts'),\n+          contents: `\n+        import {Directive, Input} from '@angular/core';\n+\n+        @Directive({selector: '[string-model]'})\n+        export class OtherDir {\n+          @Input('model') model!: any;\n+        }\n+        `\n+        };\n+        const stringModelTestFile = {name: _('/string-model.ts'), contents: dirFileContents};\n+        const cursorInfo = extractCursorInfo(`\n+        import {Component} from '@angular/core';\n+\n+        @Component({template: '<div string-model [mod¦el]=\"title\"></div>'})\n+        export class AppCmp {\n+          title = 'title';\n+        }`);\n+        cursor = cursorInfo.cursor;\n+        const appFile = {name: _('/app.ts'), contents: cursorInfo.text};\n+        env = createModuleWithDeclarations([appFile, stringModelTestFile, otherDirFile]);\n+      });\n+\n+      // TODO(atscott): This test does not pass because the template symbol builder only returns one\n+      // binding.\n+      xit('should find references', () => {\n+        const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+        expect(refs.length).toEqual(3);\n+        assertFileNames(refs, ['string-model.ts', 'app.ts', 'other-dir']);\n+        assertTextSpans(refs, ['model', 'otherDirAliasedInput']);\n+      });\n+\n+      // TODO(atscott): This test fails because template symbol builder only returns one binding.\n+      // The result is that rather than returning `undefined` because we don't handle alias inputs,\n+      // we return the rename locations for the first binding.\n+      xit('should find rename locations', () => {\n+        const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+        expect(renameLocations).toBeUndefined();\n+        // TODO(atscott):\n+        // expect(renameLocations.length).toEqual(3);\n+        // assertFileNames(renameLocations, ['string-model.ts', 'app.ts', 'other-dir']);\n+        // assertTextSpans(renameLocations, ['model']);\n+      });\n     });\n \n-    it('should work for text attributes', () => {\n-      const stringModelTestFile = {name: _('/string-model.ts'), contents: dirFileContents};\n-      const {text, cursor} = extractCursorInfo(`\n+    describe('should work when cursor is on text attribute input', () => {\n+      let cursor: number;\n+      beforeEach(() => {\n+        const stringModelTestFile = {name: _('/string-model.ts'), contents: dirFileContents};\n+        const cursorInfo = extractCursorInfo(`\n         import {Component} from '@angular/core';\n \n         @Component({template: '<div string-model mod¦el=\"title\"></div>'})\n         export class AppCmp {\n           title = 'title';\n         }`);\n-      const appFile = {name: _('/app.ts'), contents: text};\n-      env = createModuleWithDeclarations([appFile, stringModelTestFile]);\n-      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-      expect(refs.length).toEqual(2);\n-      assertFileNames(refs, ['string-model.ts', 'app.ts']);\n-      assertTextSpans(refs, ['model']);\n+        cursor = cursorInfo.cursor;\n+        const appFile = {name: _('/app.ts'), contents: cursorInfo.text};\n+        env = createModuleWithDeclarations([appFile, stringModelTestFile]);\n+      });\n+\n+      it('should work for text attributes', () => {\n+        const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+        expect(refs.length).toEqual(2);\n+        assertFileNames(refs, ['string-model.ts', 'app.ts']);\n+        assertTextSpans(refs, ['model']);\n+      });\n+\n+      it('should find rename locations', () => {\n+        const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+        expect(renameLocations.length).toEqual(2);\n+        assertFileNames(renameLocations, ['string-model.ts', 'app.ts']);\n+        assertTextSpans(renameLocations, ['model']);\n+      });\n     });\n \n-    it('should work from the TS input declaration', () => {\n-      const dirFileWithCursor = `\n+    describe('when cursor is on the class member input', () => {\n+      let cursor: number;\n+      beforeEach(() => {\n+        const dirFileWithCursor = `\n         import {Directive, Input} from '@angular/core';\n \n         @Directive({selector: '[string-model]'})\n         export class StringModel {\n           @Input() mod¦el!: string;\n         }`;\n-      const {text, cursor} = extractCursorInfo(dirFileWithCursor);\n-      const stringModelTestFile = {name: _('/string-model.ts'), contents: text};\n-      const appFile = {\n-        name: _('/app.ts'),\n-        contents: `\n+        const cursorInfo = extractCursorInfo(dirFileWithCursor);\n+        cursor = cursorInfo.cursor;\n+        const stringModelTestFile = {name: _('/string-model.ts'), contents: cursorInfo.text};\n+        const appFile = {\n+          name: _('/app.ts'),\n+          contents: `\n         import {Component} from '@angular/core';\n \n         @Component({template: '<div string-model model=\"title\"></div>'})\n         export class AppCmp {\n           title = 'title';\n         }`,\n-      };\n-      env = createModuleWithDeclarations([appFile, stringModelTestFile]);\n-      const refs = getReferencesAtPosition(_('/string-model.ts'), cursor)!;\n-      expect(refs.length).toEqual(2);\n-      assertFileNames(refs, ['app.ts', 'string-model.ts']);\n-      assertTextSpans(refs, ['model']);\n+        };\n+        env = createModuleWithDeclarations([appFile, stringModelTestFile]);\n+      });\n+\n+      it('should work from the TS input declaration', () => {\n+        const refs = getReferencesAtPosition(_('/string-model.ts'), cursor)!;\n+        expect(refs.length).toEqual(2);\n+        assertFileNames(refs, ['app.ts', 'string-model.ts']);\n+        assertTextSpans(refs, ['model']);\n+      });\n+\n+      it('should find rename locations', () => {\n+        const renameLocations = getRenameLocationsAtPosition(_('/string-model.ts'), cursor)!;\n+        expect(renameLocations.length).toEqual(2);\n+        assertFileNames(renameLocations, ['app.ts', 'string-model.ts']);\n+        assertTextSpans(renameLocations, ['model']);\n+      });\n     });\n \n-    it('should work for inputs referenced from some other place', () => {\n-      const otherDirContents = `\n+    describe('when cursor is on input referenced somewhere in the class functions', () => {\n+      let cursor: number;\n+      beforeEach(() => {\n+        const otherDirContents = `\n         import {Directive, Input} from '@angular/core';\n         import {StringModel} from './string-model';\n \n@@ -570,50 +967,78 @@ describe('find references', () => {\n             console.log(this.stringModelRef.mod¦el);\n           }\n         }`;\n-      const {text, cursor} = extractCursorInfo(otherDirContents);\n-      const otherDirFile = {name: _('/other-dir.ts'), contents: text};\n-      const stringModelTestFile = {\n-        name: _('/string-model.ts'),\n-        contents: `\n+        const cursorInfo = extractCursorInfo(otherDirContents);\n+        cursor = cursorInfo.cursor;\n+        const otherDirFile = {name: _('/other-dir.ts'), contents: cursorInfo.text};\n+        const stringModelTestFile = {\n+          name: _('/string-model.ts'),\n+          contents: `\n         import {Directive, Input} from '@angular/core';\n \n         @Directive({selector: '[string-model]'})\n         export class StringModel {\n           @Input() model!: string;\n         }`,\n-      };\n-      const appFile = {\n-        name: _('/app.ts'),\n-        contents: `\n+        };\n+        const appFile = {\n+          name: _('/app.ts'),\n+          contents: `\n         import {Component} from '@angular/core';\n \n         @Component({template: '<div string-model other-dir model=\"title\"></div>'})\n         export class AppCmp {\n           title = 'title';\n         }`,\n-      };\n-      env = createModuleWithDeclarations([appFile, stringModelTestFile, otherDirFile]);\n-      const refs = getReferencesAtPosition(_('/other-dir.ts'), cursor)!;\n-      expect(refs.length).toEqual(3);\n-      assertFileNames(refs, ['app.ts', 'string-model.ts', 'other-dir.ts']);\n-      assertTextSpans(refs, ['model']);\n+        };\n+        env = createModuleWithDeclarations([appFile, stringModelTestFile, otherDirFile]);\n+      });\n+\n+      it('should find references', () => {\n+        const refs = getReferencesAtPosition(_('/other-dir.ts'), cursor)!;\n+        expect(refs.length).toEqual(3);\n+        assertFileNames(refs, ['app.ts', 'string-model.ts', 'other-dir.ts']);\n+        assertTextSpans(refs, ['model']);\n+      });\n+\n+      it('should find rename locations', () => {\n+        const renameLocations = getRenameLocationsAtPosition(_('/other-dir.ts'), cursor)!;\n+        expect(renameLocations.length).toEqual(3);\n+        assertFileNames(renameLocations, ['app.ts', 'string-model.ts', 'other-dir.ts']);\n+        assertTextSpans(renameLocations, ['model']);\n+      });\n     });\n \n-    it('should work with aliases', () => {\n-      const stringModelTestFile = {name: _('/string-model.ts'), contents: dirFileContents};\n-      const {text, cursor} = extractCursorInfo(`\n+    describe('when cursor is on an aliased input', () => {\n+      let cursor: number;\n+      beforeEach(() => {\n+        const stringModelTestFile = {name: _('/string-model.ts'), contents: dirFileContents};\n+        const cursorInfo = extractCursorInfo(`\n         import {Component} from '@angular/core';\n \n         @Component({template: '<div string-model [al¦ias]=\"title\"></div>'})\n         export class AppCmp {\n           title = 'title';\n         }`);\n-      const appFile = {name: _('/app.ts'), contents: text};\n-      env = createModuleWithDeclarations([appFile, stringModelTestFile]);\n-      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-      expect(refs.length).toEqual(2);\n-      assertFileNames(refs, ['string-model.ts', 'app.ts']);\n-      assertTextSpans(refs, ['aliasedModel', 'alias']);\n+        cursor = cursorInfo.cursor;\n+        const appFile = {name: _('/app.ts'), contents: cursorInfo.text};\n+        env = createModuleWithDeclarations([appFile, stringModelTestFile]);\n+      });\n+\n+      it('should find references', () => {\n+        const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+        expect(refs.length).toEqual(2);\n+        assertFileNames(refs, ['string-model.ts', 'app.ts']);\n+        assertTextSpans(refs, ['aliasedModel', 'alias']);\n+      });\n+\n+      it('should find rename locations', () => {\n+        const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+        expect(renameLocations).toBeUndefined();\n+        // TODO(atscott): add support for renaming alias outputs\n+        // expect(renameLocations.length).toEqual(2);\n+        // assertFileNames(renameLocations, ['string-model.ts', 'app.ts']);\n+        // assertTextSpans(renameLocations, ['alias']);\n+      });\n     });\n   });\n \n@@ -641,28 +1066,56 @@ describe('find references', () => {\n         export class AppModule {}`;\n     }\n \n-    it('should work', () => {\n-      const {text, cursor} = extractCursorInfo(\n-          generateAppFile(`<div string-model (mod¦elChange)=\"setTitle($event)\"></div>`));\n-      env = LanguageServiceTestEnvironment.setup([\n-        {name: _('/app.ts'), contents: text, isRoot: true},\n-        {name: _('/string-model.ts'), contents: dirFile},\n-      ]);\n-      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-      expect(refs.length).toEqual(2);\n-      assertTextSpans(refs, ['modelChange']);\n+    describe('when cursor is on output key in template', () => {\n+      let cursor: number;\n+      beforeEach(() => {\n+        const cursorInfo = extractCursorInfo(\n+            generateAppFile(`<div string-model (mod¦elChange)=\"setTitle($event)\"></div>`));\n+        cursor = cursorInfo.cursor;\n+        env = LanguageServiceTestEnvironment.setup([\n+          {name: _('/app.ts'), contents: cursorInfo.text, isRoot: true},\n+          {name: _('/string-model.ts'), contents: dirFile},\n+        ]);\n+      });\n+\n+      it('should find references', () => {\n+        const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+        expect(refs.length).toEqual(2);\n+        assertTextSpans(refs, ['modelChange']);\n+      });\n+\n+      it('should find rename locations', () => {\n+        const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+        expect(renameLocations.length).toEqual(2);\n+        assertTextSpans(renameLocations, ['modelChange']);\n+      });\n     });\n \n-    it('should work with aliases', () => {\n-      const {text, cursor} = extractCursorInfo(\n-          generateAppFile(`<div string-model (a¦lias)=\"setTitle($event)\"></div>`));\n-      env = LanguageServiceTestEnvironment.setup([\n-        {name: _('/app.ts'), contents: text, isRoot: true},\n-        {name: _('/string-model.ts'), contents: dirFile},\n-      ]);\n-      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-      expect(refs.length).toEqual(2);\n-      assertTextSpans(refs, ['aliasedModelChange', 'alias']);\n+    describe('when cursor is on alias output key', () => {\n+      let cursor: number;\n+      beforeEach(() => {\n+        const cursorInfo = extractCursorInfo(\n+            generateAppFile(`<div string-model (a¦lias)=\"setTitle($event)\"></div>`));\n+        cursor = cursorInfo.cursor;\n+        env = LanguageServiceTestEnvironment.setup([\n+          {name: _('/app.ts'), contents: cursorInfo.text, isRoot: true},\n+          {name: _('/string-model.ts'), contents: dirFile},\n+        ]);\n+      });\n+\n+      it('should find references', () => {\n+        const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+        expect(refs.length).toEqual(2);\n+        assertTextSpans(refs, ['aliasedModelChange', 'alias']);\n+      });\n+\n+      it('should find rename locations', () => {\n+        const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+        expect(renameLocations).toBeUndefined();\n+        // TODO(atscott): add support for renaming alias outputs\n+        // expect(renameLocations.length).toEqual(2);\n+        // assertTextSpans(renameLocations, ['alias']);\n+      });\n     });\n   });\n \n@@ -698,13 +1151,16 @@ describe('find references', () => {\n   });\n \n   describe('directives', () => {\n-    it('works for directive classes', () => {\n-      const {text, cursor} = extractCursorInfo(`\n+    describe('when cursor is on the directive class', () => {\n+      let cursor: number;\n+      beforeEach(() => {\n+        const cursorInfo = extractCursorInfo(`\n       import {Directive} from '@angular/core';\n \n       @Directive({selector: '[dir]'})\n       export class Di¦r {}`);\n-      const appFile = `\n+        cursor = cursorInfo.cursor;\n+        const appFile = `\n         import {Component, NgModule} from '@angular/core';\n         import {Dir} from './dir';\n \n@@ -715,30 +1171,45 @@ describe('find references', () => {\n         @NgModule({declarations: [AppCmp, Dir]})\n         export class AppModule {}\n       `;\n-      env = LanguageServiceTestEnvironment.setup([\n-        {name: _('/app.ts'), contents: appFile, isRoot: true},\n-        {name: _('/dir.ts'), contents: text},\n-      ]);\n-      const refs = getReferencesAtPosition(_('/dir.ts'), cursor)!;\n-      // 4 references are:  class declaration, template usage, app import and use in declarations\n-      // list.\n-      expect(refs.length).toBe(4);\n-      assertTextSpans(refs, ['<div dir>', 'Dir']);\n-      assertFileNames(refs, ['app.ts', 'dir.ts']);\n-    });\n-\n-    it('gets references to all matching directives when cursor is on an attribute', () => {\n-      const dirFile = `\n+        env = LanguageServiceTestEnvironment.setup([\n+          {name: _('/app.ts'), contents: appFile, isRoot: true},\n+          {name: _('/dir.ts'), contents: cursorInfo.text},\n+        ]);\n+      });\n+\n+      it('should find references', () => {\n+        const refs = getReferencesAtPosition(_('/dir.ts'), cursor)!;\n+        // 4 references are:  class declaration, template usage, app import and use in declarations\n+        // list.\n+        expect(refs.length).toBe(4);\n+        assertTextSpans(refs, ['<div dir>', 'Dir']);\n+        assertFileNames(refs, ['app.ts', 'dir.ts']);\n+      });\n+\n+      it('should find rename locations', () => {\n+        const renameLocations = getRenameLocationsAtPosition(_('/dir.ts'), cursor)!;\n+        expect(renameLocations).toBeUndefined();\n+        // TODO(atscott): We should handle this case, but exclude the template results\n+        // expect(renameLocations.length).toBe(3);\n+        // assertTextSpans(renameLocations, ['Dir']);\n+        // assertFileNames(renameLocations, ['app.ts', 'dir.ts']);\n+      });\n+    });\n+\n+    describe('when cursor is on an attribute', () => {\n+      let cursor: number;\n+      beforeEach(() => {\n+        const dirFile = `\n       import {Directive} from '@angular/core';\n \n       @Directive({selector: '[dir]'})\n       export class Dir {}`;\n-      const dirFile2 = `\n+        const dirFile2 = `\n       import {Directive} from '@angular/core';\n \n       @Directive({selector: '[dir]'})\n       export class Dir2 {}`;\n-      const {text, cursor} = extractCursorInfo(`\n+        const cursorInfo = extractCursorInfo(`\n         import {Component, NgModule} from '@angular/core';\n         import {Dir} from './dir';\n         import {Dir2} from './dir2';\n@@ -750,43 +1221,71 @@ describe('find references', () => {\n         @NgModule({declarations: [AppCmp, Dir, Dir2]})\n         export class AppModule {}\n       `);\n-      env = LanguageServiceTestEnvironment.setup([\n-        {name: _('/app.ts'), contents: text, isRoot: true},\n-        {name: _('/dir.ts'), contents: dirFile},\n-        {name: _('/dir2.ts'), contents: dirFile2},\n-      ]);\n-      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-      expect(refs.length).toBe(8);\n-      assertTextSpans(refs, ['<div dir>', 'Dir', 'Dir2']);\n-      assertFileNames(refs, ['app.ts', 'dir.ts', 'dir2.ts']);\n+        cursor = cursorInfo.cursor;\n+        env = LanguageServiceTestEnvironment.setup([\n+          {name: _('/app.ts'), contents: cursorInfo.text, isRoot: true},\n+          {name: _('/dir.ts'), contents: dirFile},\n+          {name: _('/dir2.ts'), contents: dirFile2},\n+        ]);\n+      });\n+\n+      it('gets references to all matching directives', () => {\n+        const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+        expect(refs.length).toBe(8);\n+        assertTextSpans(refs, ['<div dir>', 'Dir', 'Dir2']);\n+        assertFileNames(refs, ['app.ts', 'dir.ts', 'dir2.ts']);\n+      });\n+\n+      it('finds rename locations for all matching directives', () => {\n+        const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+        expect(renameLocations).toBeUndefined();\n+        // TODO(atscott): We could consider supporting rename for directive selectors in the future\n+        // expect(renameLocations.length).toBe(3);\n+        // assertTextSpans(renameLocations, ['dir']);\n+        // assertFileNames(renameLocations, ['app.ts', 'dir.ts', 'dir2.ts']);\n+      });\n     });\n \n-    it('should be able to request references for generic directives', () => {\n-      const {text, cursor} = extractCursorInfo(`\n+    describe('when cursor is on generic directive selector in template', () => {\n+      let cursor: number;\n+      beforeEach(() => {\n+        const cursorInfo = extractCursorInfo(`\n         import {Component, NgModule} from '@angular/core';\n \n         @Component({template: '<div *ngF¦or=\"let item of items\"></div>'})\n         export class AppCmp {\n           items = [];\n         }\n       `);\n-      const appFile = {name: _('/app.ts'), contents: text};\n-      env = createModuleWithDeclarations([appFile]);\n-      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-      expect(refs.length).toBe(6);\n-      assertTextSpans(refs, ['<div *ngFor=\"let item of items\"></div>', 'NgForOf']);\n-      assertFileNames(refs, ['index.d.ts', 'app.ts']);\n+        cursor = cursorInfo.cursor;\n+        const appFile = {name: _('/app.ts'), contents: cursorInfo.text};\n+        env = createModuleWithDeclarations([appFile]);\n+      });\n+\n+      it('should be able to request references', () => {\n+        const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+        expect(refs.length).toBe(6);\n+        assertTextSpans(refs, ['<div *ngFor=\"let item of items\"></div>', 'NgForOf']);\n+        assertFileNames(refs, ['index.d.ts', 'app.ts']);\n+      });\n+\n+      it('should not support rename if directive is in a dts file', () => {\n+        const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor);\n+        expect(renameLocations).toBeUndefined();\n+      });\n     });\n   });\n \n   describe('components', () => {\n-    it('works for component classes', () => {\n-      const {text, cursor} = extractCursorInfo(`\n+    describe('when cursor is on component class', () => {\n+      let cursor: number;\n+      beforeEach(() => {\n+        const cursorInfo = extractCursorInfo(`\n       import {Component} from '@angular/core';\n \n       @Component({selector: 'my-comp', template: ''})\n       export class MyCo¦mp {}`);\n-      const appFile = `\n+        const appFile = `\n         import {Component, NgModule} from '@angular/core';\n         import {MyComp} from './comp';\n \n@@ -797,25 +1296,42 @@ describe('find references', () => {\n         @NgModule({declarations: [AppCmp, MyComp]})\n         export class AppModule {}\n       `;\n-      env = LanguageServiceTestEnvironment.setup([\n-        {name: _('/app.ts'), contents: appFile, isRoot: true},\n-        {name: _('/comp.ts'), contents: text},\n-      ]);\n-      const refs = getReferencesAtPosition(_('/comp.ts'), cursor)!;\n-      // 4 references are:  class declaration, template usage, app import and use in declarations\n-      // list.\n-      expect(refs.length).toBe(4);\n-      assertTextSpans(refs, ['<my-comp>', 'MyComp']);\n-      assertFileNames(refs, ['app.ts', 'comp.ts']);\n-    });\n-\n-    it('gets works when cursor is on element tag', () => {\n-      const compFile = `\n+        cursor = cursorInfo.cursor;\n+        env = LanguageServiceTestEnvironment.setup([\n+          {name: _('/app.ts'), contents: appFile, isRoot: true},\n+          {name: _('/comp.ts'), contents: cursorInfo.text},\n+        ]);\n+      });\n+\n+      it('finds references', () => {\n+        const refs = getReferencesAtPosition(_('/comp.ts'), cursor)!;\n+        // 4 references are:  class declaration, template usage, app import and use in declarations\n+        // list.\n+        expect(refs.length).toBe(4);\n+        assertTextSpans(refs, ['<my-comp>', 'MyComp']);\n+        assertFileNames(refs, ['app.ts', 'comp.ts']);\n+      });\n+\n+      it('gets rename locations', () => {\n+        const renameLocations = getRenameLocationsAtPosition(_('/comp.ts'), cursor)!;\n+        expect(renameLocations).toBeUndefined();\n+        // TODO(atscott): If we register as an exclusive provider for TS, we may need to return\n+        // results here and should exclude the template results.\n+        // expect(renameLocations.length).toBe(3);\n+        // assertTextSpans(renameLocations, ['MyComp']);\n+        // assertFileNames(renameLocations, ['app.ts', 'comp.ts']);\n+      });\n+    });\n+\n+    describe('when cursor is on the element tag', () => {\n+      let cursor: number;\n+      beforeEach(() => {\n+        const compFile = `\n       import {Component} from '@angular/core';\n \n       @Component({selector: 'my-comp', template: ''})\n       export class MyComp {}`;\n-      const {text, cursor} = extractCursorInfo(`\n+        const cursorInfo = extractCursorInfo(`\n         import {Component, NgModule} from '@angular/core';\n         import {MyComp} from './comp';\n \n@@ -826,43 +1342,42 @@ describe('find references', () => {\n         @NgModule({declarations: [AppCmp, MyComp]})\n         export class AppModule {}\n       `);\n-      env = LanguageServiceTestEnvironment.setup([\n-        {name: _('/app.ts'), contents: text, isRoot: true},\n-        {name: _('/comp.ts'), contents: compFile},\n-      ]);\n-      const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n-      // 4 references are:  class declaration, template usage, app import and use in declarations\n-      // list.\n-      expect(refs.length).toBe(4);\n-      assertTextSpans(refs, ['<my-comp>', 'MyComp']);\n-      assertFileNames(refs, ['app.ts', 'comp.ts']);\n+        cursor = cursorInfo.cursor;\n+        env = LanguageServiceTestEnvironment.setup([\n+          {name: _('/app.ts'), contents: cursorInfo.text, isRoot: true},\n+          {name: _('/comp.ts'), contents: compFile},\n+        ]);\n+      });\n+\n+      it('gets references', () => {\n+        const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+        // 4 references are:  class declaration, template usage, app import and use in declarations\n+        // list.\n+        expect(refs.length).toBe(4);\n+        assertTextSpans(refs, ['<my-comp>', 'MyComp']);\n+        assertFileNames(refs, ['app.ts', 'comp.ts']);\n+      });\n+\n+      it('finds rename locations', () => {\n+        const renameLocations = getRenameLocationsAtPosition(_('/app.ts'), cursor)!;\n+        expect(renameLocations).toBeUndefined();\n+        // TODO(atscott): We may consider supporting rename of component selector in the future\n+        // expect(renameLocations.length).toBe(2);\n+        // assertTextSpans(renameLocations, ['my-comp']);\n+        // assertFileNames(renameLocations, ['app.ts', 'comp.ts']);\n+      });\n     });\n   });\n \n   function getReferencesAtPosition(fileName: string, position: number) {\n     env.expectNoSourceDiagnostics();\n     const result = env.ngLS.getReferencesAtPosition(fileName, position);\n-    return result?.map(humanizeReferenceEntry);\n+    return result?.map((item) => humanizeDocumentSpanLike(item, env));\n   }\n \n-  function humanizeReferenceEntry(entry: ts.ReferenceEntry): Stringy<ts.DocumentSpan>&\n-      Pick<ts.ReferenceEntry, 'isWriteAccess'|'isDefinition'|'isInString'> {\n-    const fileContents = env.host.readFile(entry.fileName);\n-    if (!fileContents) {\n-      throw new Error('Could not read file ${entry.fileName}');\n-    }\n-    return {\n-      ...entry,\n-      textSpan: getText(fileContents, entry.textSpan),\n-      contextSpan: entry.contextSpan ? getText(fileContents, entry.contextSpan) : undefined,\n-      originalTextSpan: entry.originalTextSpan ? getText(fileContents, entry.originalTextSpan) :\n-                                                 undefined,\n-      originalContextSpan:\n-          entry.originalContextSpan ? getText(fileContents, entry.originalContextSpan) : undefined,\n-    };\n+  function getRenameLocationsAtPosition(fileName: string, position: number) {\n+    env.expectNoSourceDiagnostics();\n+    const result = env.ngLS.findRenameLocations(fileName, position);\n+    return result?.map((item) => humanizeDocumentSpanLike(item, env));\n   }\n });\n-\n-type Stringy<T> = {\n-  [P in keyof T]: string;\n-};"
        },
        {
            "sha": "ccc0408862e77a5904398bbcf54c45ccd4911214",
            "filename": "packages/language-service/ivy/test/test_utils.ts",
            "status": "modified",
            "additions": 24,
            "deletions": 24,
            "changes": 48,
            "blob_url": "https://github.com/angular/angular/blob/9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9/packages%2Flanguage-service%2Fivy%2Ftest%2Ftest_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9/packages%2Flanguage-service%2Fivy%2Ftest%2Ftest_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Ftest_utils.ts?ref=9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9",
            "patch": "@@ -5,12 +5,11 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-\n import {absoluteFrom as _} from '@angular/compiler-cli/src/ngtsc/file_system';\n import {TestFile} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n-import {LanguageServiceTestEnvironment} from '@angular/language-service/ivy/test/env';\n+import {LanguageServiceTestEnvironment, TestableOptions} from '@angular/language-service/ivy/test/env';\n+import * as ts from 'typescript/lib/tsserverlibrary';\n \n-import {MockServerHost} from './mock_host';\n \n export function getText(contents: string, textSpan: ts.TextSpan) {\n   return contents.substr(textSpan.start, textSpan.length);\n@@ -29,8 +28,8 @@ function getFirstClassDeclaration(declaration: string) {\n }\n \n export function createModuleWithDeclarations(\n-    filesWithClassDeclarations: TestFile[],\n-    externalResourceFiles: TestFile[] = []): LanguageServiceTestEnvironment {\n+    filesWithClassDeclarations: TestFile[], externalResourceFiles: TestFile[] = [],\n+    options: TestableOptions = {}): LanguageServiceTestEnvironment {\n   const externalClasses =\n       filesWithClassDeclarations.map(file => getFirstClassDeclaration(file.contents));\n   const externalImports = filesWithClassDeclarations.map(file => {\n@@ -51,30 +50,31 @@ export function createModuleWithDeclarations(\n       `;\n   const moduleFile = {name: _('/app-module.ts'), contents, isRoot: true};\n   return LanguageServiceTestEnvironment.setup(\n-      [moduleFile, ...filesWithClassDeclarations, ...externalResourceFiles]);\n-}\n-\n-export interface HumanizedDefinitionInfo {\n-  fileName: string;\n-  textSpan: string;\n-  contextSpan: string|undefined;\n+      [moduleFile, ...filesWithClassDeclarations, ...externalResourceFiles], options);\n }\n \n-export function humanizeDefinitionInfo(\n-    def: ts.DefinitionInfo, host: MockServerHost,\n-    overrides: Map<string, string> = new Map()): HumanizedDefinitionInfo {\n-  const contents = (overrides.get(def.fileName) !== undefined ? overrides.get(def.fileName) :\n-                                                                host.readFile(def.fileName)) ??\n+export function humanizeDocumentSpanLike<T extends ts.DocumentSpan>(\n+    item: T, env: LanguageServiceTestEnvironment, overrides: Map<string, string> = new Map()): T&\n+    Stringy<ts.DocumentSpan> {\n+  const fileContents = (overrides.has(item.fileName) ? overrides.get(item.fileName) :\n+                                                       env.host.readFile(item.fileName)) ??\n       '';\n-\n+  if (!fileContents) {\n+    throw new Error('Could not read file ${entry.fileName}');\n+  }\n   return {\n-    fileName: def.fileName,\n-    textSpan: contents.substr(def.textSpan.start, def.textSpan.start + def.textSpan.length),\n-    contextSpan: def.contextSpan ?\n-        contents.substr(def.contextSpan.start, def.contextSpan.start + def.contextSpan.length) :\n-        undefined,\n+    ...item,\n+    textSpan: getText(fileContents, item.textSpan),\n+    contextSpan: item.contextSpan ? getText(fileContents, item.contextSpan) : undefined,\n+    originalTextSpan: item.originalTextSpan ? getText(fileContents, item.originalTextSpan) :\n+                                              undefined,\n+    originalContextSpan:\n+        item.originalContextSpan ? getText(fileContents, item.originalContextSpan) : undefined,\n   };\n }\n+type Stringy<T> = {\n+  [P in keyof T]: string;\n+};\n \n export function assertFileNames(refs: Array<{fileName: string}>, expectedFileNames: string[]) {\n   const actualPaths = refs.map(r => r.fileName);\n@@ -85,4 +85,4 @@ export function assertFileNames(refs: Array<{fileName: string}>, expectedFileNam\n export function assertTextSpans(items: Array<{textSpan: string}>, expectedTextSpans: string[]) {\n   const actualSpans = items.map(item => item.textSpan);\n   expect(new Set(actualSpans)).toEqual(new Set(expectedTextSpans));\n-}\n\\ No newline at end of file\n+}"
        },
        {
            "sha": "5822586745f44d4659e921ca3c39ce253a4791b0",
            "filename": "packages/language-service/ivy/test/type_definitions_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9/packages%2Flanguage-service%2Fivy%2Ftest%2Ftype_definitions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9/packages%2Flanguage-service%2Fivy%2Ftest%2Ftype_definitions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Ftype_definitions_spec.ts?ref=9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9",
            "patch": "@@ -10,7 +10,7 @@ import {absoluteFrom} from '@angular/compiler-cli/src/ngtsc/file_system';\n import {initMockFileSystem, TestFile} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n \n import {LanguageServiceTestEnvironment} from './env';\n-import {HumanizedDefinitionInfo, humanizeDefinitionInfo} from './test_utils';\n+import {humanizeDocumentSpanLike} from './test_utils';\n \n describe('type definitions', () => {\n   let env: LanguageServiceTestEnvironment;\n@@ -48,8 +48,7 @@ describe('type definitions', () => {\n     expect(def.contextSpan).toContain('DatePipe');\n   });\n \n-  function getTypeDefinitionsAndAssertBoundSpan({templateOverride}: {templateOverride: string}):\n-      HumanizedDefinitionInfo[] {\n+  function getTypeDefinitionsAndAssertBoundSpan({templateOverride}: {templateOverride: string}) {\n     const {cursor, text} =\n         env.overrideTemplateWithCursor(absoluteFrom('/app.ts'), 'AppCmp', templateOverride);\n     env.expectNoSourceDiagnostics();\n@@ -58,6 +57,6 @@ describe('type definitions', () => {\n     expect(defs).toBeTruthy();\n     const overrides = new Map<string, string>();\n     overrides.set(absoluteFrom('/app.html'), text);\n-    return defs!.map(d => humanizeDefinitionInfo(d, env.host, overrides));\n+    return defs!.map(d => humanizeDocumentSpanLike(d, env, overrides));\n   }\n });"
        },
        {
            "sha": "64a3b654b9a0b5b2dbc0d5b1621cb33b02547c82",
            "filename": "packages/language-service/ivy/ts_plugin.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9/packages%2Flanguage-service%2Fivy%2Fts_plugin.ts",
            "raw_url": "https://github.com/angular/angular/raw/9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9/packages%2Flanguage-service%2Fivy%2Fts_plugin.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fts_plugin.ts?ref=9a5ac47331faf0f6030bff75ad8ef8dab2f8d2d9",
            "patch": "@@ -64,8 +64,11 @@ export function create(info: ts.server.PluginCreateInfo): ts.LanguageService {\n   function findRenameLocations(\n       fileName: string, position: number, findInStrings: boolean, findInComments: boolean,\n       providePrefixAndSuffixTextForRename?: boolean): readonly ts.RenameLocation[]|undefined {\n-    // TODO(atscott): implement\n-    return undefined;\n+    // Most operations combine results from all extensions. However, rename locations are exclusive\n+    // (results from only one extension are used) so our rename locations are a superset of the TS\n+    // rename locations. As a result, we do not check the `angularOnly` flag here because we always\n+    // want to include results at TS locations as well as locations in templates.\n+    return ngLS.findRenameLocations(fileName, position);\n   }\n \n   function getCompletionsAtPosition("
        }
    ],
    "stats": {
        "total": 1713,
        "additions": 1211,
        "deletions": 502
    }
}