{
    "author": "atscott",
    "message": "refactor(language-service): Remove View Engine code from language service package (#44064)\n\nThis commit removes ViewEngine-specific code from the langauge service\npackage. This code is no longer used since VE is not supported in v13+.\n\nPR Close #44064",
    "sha": "4738569220b4e360aa77f8875ac866c6defd8f6c",
    "files": [
        {
            "sha": "fab27ad10574a5c8c01f2507baff2d1e66c2879c",
            "filename": "goldens/circular-deps/packages.json",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/4738569220b4e360aa77f8875ac866c6defd8f6c/goldens%2Fcircular-deps%2Fpackages.json",
            "raw_url": "https://github.com/angular/angular/raw/4738569220b4e360aa77f8875ac866c6defd8f6c/goldens%2Fcircular-deps%2Fpackages.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fcircular-deps%2Fpackages.json?ref=4738569220b4e360aa77f8875ac866c6defd8f6c",
            "patch": "@@ -341,10 +341,6 @@\n     \"packages/forms/src/directives/validators.ts\",\n     \"packages/forms/src/validators.ts\"\n   ],\n-  [\n-    \"packages/language-service/src/template.ts\",\n-    \"packages/language-service/src/typescript_host.ts\"\n-  ],\n   [\n     \"packages/router/src/config.ts\",\n     \"packages/router/src/router_state.ts\""
        },
        {
            "sha": "e506bbf2ad95cfee67464e6baabe191f76a64b2d",
            "filename": "packages/language-service/BUILD.bazel",
            "status": "modified",
            "additions": 0,
            "deletions": 30,
            "changes": 30,
            "blob_url": "https://github.com/angular/angular/blob/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2FBUILD.bazel?ref=4738569220b4e360aa77f8875ac866c6defd8f6c",
            "patch": "@@ -15,36 +15,6 @@ ts_library(\n     ],\n )\n \n-ts_library(\n-    name = \"language-service\",\n-    srcs = glob(\n-        [\n-            \"src/**/*.ts\",\n-        ],\n-        exclude = [\n-            \"src/ts_utils.ts\",\n-        ],\n-    ),\n-    deps = [\n-        \":api\",\n-        \":ts_utils\",\n-        \"//packages:types\",\n-        \"//packages/compiler\",\n-        \"//packages/compiler-cli\",\n-        \"//packages/core\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)\n-\n-ts_library(\n-    name = \"ts_utils\",\n-    srcs = [\"src/ts_utils.ts\"],\n-    deps = [\n-        \"@npm//typescript\",\n-    ],\n-)\n-\n pkg_npm(\n     name = \"npm_package\",\n     srcs = [\"package.json\"],"
        },
        {
            "sha": "a5ff4bcab6d513b463de085ed92a1c0fdd17b90b",
            "filename": "packages/language-service/ivy/test/legacy/BUILD.bazel",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2FBUILD.bazel?ref=4738569220b4e360aa77f8875ac866c6defd8f6c",
            "patch": "@@ -24,9 +24,15 @@ jasmine_node_test(\n         \"//packages/common\",\n         \"//packages/core\",\n         \"//packages/forms\",\n-        \"//packages/language-service/test:project\",\n+        \":project\",\n     ],\n     deps = [\n         \":legacy_lib\",\n     ],\n )\n+\n+filegroup(\n+    name = \"project\",\n+    srcs = glob([\"project/**/*\"]),\n+    visibility = [\"//packages/language-service:__subpackages__\"],\n+)\n\\ No newline at end of file"
        },
        {
            "sha": "87f1c9c1848d041248fe37a0f59964b62f726543",
            "filename": "packages/language-service/ivy/test/legacy/mock_host.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fmock_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fmock_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fmock_host.ts?ref=4738569220b4e360aa77f8875ac866c6defd8f6c",
            "patch": "@@ -32,8 +32,8 @@ const logger: ts.server.Logger = {\n };\n \n export const TEST_SRCDIR = process.env.TEST_SRCDIR!;\n-export const PROJECT_DIR =\n-    join(TEST_SRCDIR, 'angular', 'packages', 'language-service', 'test', 'project');\n+export const PROJECT_DIR = join(\n+    TEST_SRCDIR, 'angular', 'packages', 'language-service', 'ivy', 'test', 'legacy', 'project');\n export const TSCONFIG = join(PROJECT_DIR, 'tsconfig.json');\n export const APP_COMPONENT = join(PROJECT_DIR, 'app', 'app.component.ts');\n export const APP_MAIN = join(PROJECT_DIR, 'app', 'main.ts');\n@@ -141,7 +141,7 @@ function createHost(configFileFs: MockConfigFileFs): ts.server.ServerHost {\n \n /**\n  * Create a ConfiguredProject and an actual program for the test project located\n- * in packages/language-service/test/project. Project creation exercises the\n+ * in packages/language-service/ivy/test/legacy/project. Project creation exercises the\n  * actual code path, but a mock host is used for the filesystem to intercept\n  * and modify test files.\n  */"
        },
        {
            "sha": "e02f0cfc3bfb65fb8960014ec5b7ea0412f9ae78",
            "filename": "packages/language-service/ivy/test/legacy/mock_host_spec.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fmock_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fmock_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fmock_host_spec.ts?ref=4738569220b4e360aa77f8875ac866c6defd8f6c",
            "patch": "@@ -30,7 +30,7 @@ describe('mock host', () => {\n     expect(project).toBeInstanceOf(ts.server.ConfiguredProject);\n     const configPath = (project as ts.server.ConfiguredProject).getConfigFilePath();\n     expect(configPath.substring(TEST_SRCDIR.length))\n-        .toBe('/angular/packages/language-service/test/project/tsconfig.json');\n+        .toBe('/angular/packages/language-service/ivy/test/legacy/project/tsconfig.json');\n     const program = tsLS.getProgram();\n     expect(program).toBeDefined();\n     const sourceFiles = program!.getSourceFiles().map(sf => {\n@@ -46,9 +46,9 @@ describe('mock host', () => {\n       '/angular/packages/core/src/core.d.ts',\n       '/angular/packages/forms/src/forms.d.ts',\n       // This shows that project files are present\n-      '/angular/packages/language-service/test/project/app/app.component.ts',\n-      '/angular/packages/language-service/test/project/app/main.ts',\n-      '/angular/packages/language-service/test/project/app/parsing-cases.ts',\n+      '/angular/packages/language-service/ivy/test/legacy/project/app/app.component.ts',\n+      '/angular/packages/language-service/ivy/test/legacy/project/app/main.ts',\n+      '/angular/packages/language-service/ivy/test/legacy/project/app/parsing-cases.ts',\n     ]));\n   });\n "
        },
        {
            "sha": "59a256721bd807b98289e554ffae1d96915e6a4c",
            "filename": "packages/language-service/ivy/test/legacy/project/app/#inner/component.ts",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/angular/angular/blob/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2F%23inner%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2F%23inner%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2F%23inner%2Fcomponent.ts?ref=4738569220b4e360aa77f8875ac866c6defd8f6c",
            "previous_filename": "packages/language-service/test/project/app/#inner/component.ts"
        },
        {
            "sha": "0fd9beb678ff42799c9b21c12a254d8b3d51d802",
            "filename": "packages/language-service/ivy/test/legacy/project/app/#inner/inner.html",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/angular/angular/blob/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2F%23inner%2Finner.html",
            "raw_url": "https://github.com/angular/angular/raw/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2F%23inner%2Finner.html",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2F%23inner%2Finner.html?ref=4738569220b4e360aa77f8875ac866c6defd8f6c",
            "previous_filename": "packages/language-service/test/project/app/#inner/inner.html"
        },
        {
            "sha": "67a24e0da1031df790c18731a7385e1cde878daf",
            "filename": "packages/language-service/ivy/test/legacy/project/app/app.component.ts",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/angular/angular/blob/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2Fapp.component.ts",
            "raw_url": "https://github.com/angular/angular/raw/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2Fapp.component.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2Fapp.component.ts?ref=4738569220b4e360aa77f8875ac866c6defd8f6c",
            "previous_filename": "packages/language-service/test/project/app/app.component.ts"
        },
        {
            "sha": "0599c9a523c6ba59094087a48c4e29aa96d59400",
            "filename": "packages/language-service/ivy/test/legacy/project/app/main.ts",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/angular/angular/blob/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2Fmain.ts",
            "raw_url": "https://github.com/angular/angular/raw/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2Fmain.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2Fmain.ts?ref=4738569220b4e360aa77f8875ac866c6defd8f6c",
            "previous_filename": "packages/language-service/test/project/app/main.ts"
        },
        {
            "sha": "5f9bec3e7cd4dbe5f489bc0dbe9365a8e0e7e034",
            "filename": "packages/language-service/ivy/test/legacy/project/app/parsing-cases.ts",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/angular/angular/blob/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2Fparsing-cases.ts",
            "raw_url": "https://github.com/angular/angular/raw/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2Fparsing-cases.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2Fparsing-cases.ts?ref=4738569220b4e360aa77f8875ac866c6defd8f6c",
            "previous_filename": "packages/language-service/test/project/app/parsing-cases.ts"
        },
        {
            "sha": "6af55237a98058f9aa0405c71f4b68fddc26d33f",
            "filename": "packages/language-service/ivy/test/legacy/project/app/test.css",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/angular/angular/blob/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2Ftest.css",
            "raw_url": "https://github.com/angular/angular/raw/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2Ftest.css",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2Ftest.css?ref=4738569220b4e360aa77f8875ac866c6defd8f6c",
            "previous_filename": "packages/language-service/test/project/app/test.css"
        },
        {
            "sha": "ba6fb35be33d7726fab8fd9a66568ee23e01b676",
            "filename": "packages/language-service/ivy/test/legacy/project/app/test.ng",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/angular/angular/blob/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2Ftest.ng",
            "raw_url": "https://github.com/angular/angular/raw/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2Ftest.ng",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Fapp%2Ftest.ng?ref=4738569220b4e360aa77f8875ac866c6defd8f6c",
            "previous_filename": "packages/language-service/test/project/app/test.ng"
        },
        {
            "sha": "7c4520dc97e832ad134f342b8c9fae7f8b65074d",
            "filename": "packages/language-service/ivy/test/legacy/project/tsconfig.json",
            "status": "renamed",
            "additions": 9,
            "deletions": 4,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Ftsconfig.json",
            "raw_url": "https://github.com/angular/angular/raw/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Ftsconfig.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fproject%2Ftsconfig.json?ref=4738569220b4e360aa77f8875ac866c6defd8f6c",
            "patch": "@@ -1,18 +1,23 @@\n {\n   \"//00\": \"This file is used for both IDE and the actual Project creation in Ivy language service for testing purpose\",\n   \"compilerOptions\": {\n-    \"lib\": [\"es2015\", \"dom\"],\n+    \"lib\": [\n+      \"es2015\",\n+      \"dom\"\n+    ],\n     \"strict\": true,\n     \"experimentalDecorators\": true,\n     \"moduleResolution\": \"node\",\n     \"target\": \"es2015\",\n-    \"baseUrl\": \"../../../..\",\n+    \"baseUrl\": \"../../../../../../\",\n     \"paths\": {\n-      \"@angular/*\": [\"packages/*\"]\n+      \"@angular/*\": [\n+        \"packages/*\"\n+      ]\n     }\n   },\n   \"angularCompilerOptions\": {\n     \"strictTemplates\": true,\n     \"strictInjectionParameters\": true\n   }\n-}\n+}\n\\ No newline at end of file",
            "previous_filename": "packages/language-service/test/project/tsconfig.json"
        },
        {
            "sha": "0a581618c137244eb35d72ba8fa12ce847c2f035",
            "filename": "packages/language-service/src/binding_utils.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 69,
            "changes": 69,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fbinding_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fbinding_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Fbinding_utils.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,69 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-/**\n- * Matches an Angular attribute to a binding type. See `ATTR` for more details.\n- *\n- * This is adapted from packages/compiler/src/render3/r3_template_transform.ts\n- * to allow empty binding names and match template attributes.\n- */\n-const BIND_NAME_REGEXP =\n-    /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@)|(\\*))(.*))|\\[\\(([^\\)]*)\\)\\]|\\[([^\\]]*)\\]|\\(([^\\)]*)\\))$/;\n-/**\n- * Represents possible Angular attribute bindings, as indices on a match of `BIND_NAME_REGEXP`.\n- */\n-export enum ATTR {\n-  /** \"bind-\" */\n-  KW_BIND = 1,\n-  /** \"let-\" */\n-  KW_LET = 2,\n-  /** \"ref-/#\" */\n-  KW_REF = 3,\n-  /** \"on-\" */\n-  KW_ON = 4,\n-  /** \"bindon-\" */\n-  KW_BINDON = 5,\n-  /** \"@\" */\n-  KW_AT = 6,\n-  /**\n-   * \"*\"\n-   * Microsyntax template starts with '*'. See https://angular.io/api/core/TemplateRef\n-   */\n-  KW_MICROSYNTAX = 7,\n-  /** The identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\", \"@\", or \"*\" */\n-  IDENT_KW = 8,\n-  /** Identifier inside [()] */\n-  IDENT_BANANA_BOX = 9,\n-  /** Identifier inside [] */\n-  IDENT_PROPERTY = 10,\n-  /** Identifier inside () */\n-  IDENT_EVENT = 11,\n-}\n-\n-export interface BindingDescriptor {\n-  kind: ATTR;\n-  name: string;\n-}\n-/**\n- * Returns a descriptor for a given Angular attribute, or undefined if the attribute is\n- * not an Angular attribute.\n- */\n-export function getBindingDescriptor(attribute: string): BindingDescriptor|undefined {\n-  const bindParts = attribute.match(BIND_NAME_REGEXP);\n-  if (!bindParts) return;\n-  // The first match element is skipped because it matches the entire attribute text, including the\n-  // binding part.\n-  const kind = bindParts.findIndex((val, i) => i > 0 && val !== undefined);\n-  if (!(kind in ATTR)) {\n-    throw TypeError(`\"${kind}\" is not a valid Angular binding kind for \"${attribute}\"`);\n-  }\n-  return {\n-    kind,\n-    name: bindParts[ATTR.IDENT_KW],\n-  };\n-}"
        },
        {
            "sha": "378d204f7639a0b1c8cf17befeb13358b7e7a2a0",
            "filename": "packages/language-service/src/completions.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 642,
            "changes": 642,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fcompletions.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fcompletions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Fcompletions.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,642 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {AbsoluteSourceSpan, AST, AstPath, AttrAst, Attribute, BoundDirectivePropertyAst, BoundElementPropertyAst, BoundEventAst, BoundTextAst, Element, ElementAst, EmptyExpr, ExpressionBinding, getHtmlTagDefinition, HtmlAstPath, Node as HtmlAst, NullTemplateVisitor, ParseSpan, ReferenceAst, TagContentType, TemplateBinding, Text, VariableBinding, Visitor} from '@angular/compiler';\n-import {$$, $_, isAsciiLetter, isDigit} from '@angular/compiler/src/chars';\n-\n-import {ATTR, getBindingDescriptor} from './binding_utils';\n-import {getExpressionScope} from './expression_diagnostics';\n-import {getExpressionCompletions} from './expressions';\n-import {attributeNames, elementNames, eventNames, propertyNames} from './html_info';\n-import {InlineTemplate} from './template';\n-import * as ng from './types';\n-import {diagnosticInfoFromTemplateInfo, findTemplateAstAt, getPathToNodeAtPosition, getSelectors, inSpan, isStructuralDirective, spanOf} from './utils';\n-\n-const HIDDEN_HTML_ELEMENTS: ReadonlySet<string> =\n-    new Set(['html', 'script', 'noscript', 'base', 'body', 'title', 'head', 'link']);\n-const HTML_ELEMENTS: ReadonlyArray<ng.CompletionEntry> =\n-    elementNames().filter(name => !HIDDEN_HTML_ELEMENTS.has(name)).map(name => {\n-      return {\n-        name,\n-        kind: ng.CompletionKind.HTML_ELEMENT,\n-        sortText: name,\n-      };\n-    });\n-const ANGULAR_ELEMENTS: ReadonlyArray<ng.CompletionEntry> = [\n-  {\n-    name: 'ng-container',\n-    kind: ng.CompletionKind.ANGULAR_ELEMENT,\n-    sortText: 'ng-container',\n-  },\n-  {\n-    name: 'ng-content',\n-    kind: ng.CompletionKind.ANGULAR_ELEMENT,\n-    sortText: 'ng-content',\n-  },\n-  {\n-    name: 'ng-template',\n-    kind: ng.CompletionKind.ANGULAR_ELEMENT,\n-    sortText: 'ng-template',\n-  },\n-];\n-\n-function isIdentifierPart(code: number) {\n-  // Identifiers consist of alphanumeric characters, '_', or '$'.\n-  return isAsciiLetter(code) || isDigit(code) || code == $$ || code == $_;\n-}\n-\n-/**\n- * Gets the span of word in a template that surrounds `position`. If there is no word around\n- * `position`, nothing is returned.\n- */\n-function getBoundedWordSpan(\n-    templateInfo: ng.AstResult, position: number, ast: HtmlAst|undefined): ts.TextSpan|undefined {\n-  const {template} = templateInfo;\n-  const templateSrc = template.source;\n-\n-  if (!templateSrc) return;\n-\n-  if (ast instanceof Element) {\n-    // The HTML tag may include `-` (e.g. `app-root`),\n-    // so use the HtmlAst to get the span before ayazhafiz refactor the code.\n-    return {\n-      start: templateInfo.template.span.start + ast.startSourceSpan.start.offset + 1,\n-      length: ast.name.length\n-    };\n-  }\n-\n-  // TODO(ayazhafiz): A solution based on word expansion will always be expensive compared to one\n-  // based on ASTs. Whatever penalty we incur is probably manageable for small-length (i.e. the\n-  // majority of) identifiers, but the current solution involes a number of branchings and we can't\n-  // control potentially very long identifiers. Consider moving to an AST-based solution once\n-  // existing difficulties with AST spans are more clearly resolved (see #31898 for discussion of\n-  // known problems, and #33091 for how they affect text replacement).\n-  //\n-  // `templatePosition` represents the right-bound location of a cursor in the template.\n-  //    key.ent|ry\n-  //           ^---- cursor, at position `r` is at.\n-  // A cursor is not itself a character in the template; it has a left (lower) and right (upper)\n-  // index bound that hugs the cursor itself.\n-  let templatePosition = position - template.span.start;\n-  // To perform word expansion, we want to determine the left and right indices that hug the cursor.\n-  // There are three cases here.\n-  let left, right;\n-  if (templatePosition === 0) {\n-    // 1. Case like\n-    //      |rest of template\n-    //    the cursor is at the start of the template, hugged only by the right side (0-index).\n-    left = right = 0;\n-  } else if (templatePosition === templateSrc.length) {\n-    // 2. Case like\n-    //      rest of template|\n-    //    the cursor is at the end of the template, hugged only by the left side (last-index).\n-    left = right = templateSrc.length - 1;\n-  } else {\n-    // 3. Case like\n-    //      wo|rd\n-    //    there is a clear left and right index.\n-    left = templatePosition - 1;\n-    right = templatePosition;\n-  }\n-\n-  if (!isIdentifierPart(templateSrc.charCodeAt(left)) &&\n-      !isIdentifierPart(templateSrc.charCodeAt(right))) {\n-    // Case like\n-    //         .|.\n-    // left ---^ ^--- right\n-    // There is no word here.\n-    return;\n-  }\n-\n-  // Expand on the left and right side until a word boundary is hit. Back up one expansion on both\n-  // side to stay inside the word.\n-  while (left >= 0 && isIdentifierPart(templateSrc.charCodeAt(left))) --left;\n-  ++left;\n-  while (right < templateSrc.length && isIdentifierPart(templateSrc.charCodeAt(right))) ++right;\n-  --right;\n-\n-  const absoluteStartPosition = position - (templatePosition - left);\n-  const length = right - left + 1;\n-  return {start: absoluteStartPosition, length};\n-}\n-\n-export function getTemplateCompletions(\n-    templateInfo: ng.AstResult, position: number): ng.CompletionEntry[] {\n-  const {htmlAst, template} = templateInfo;\n-  // Calculate the position relative to the start of the template. This is needed\n-  // because spans in HTML AST are relative. Inline template has non-zero start position.\n-  const templatePosition = position - template.span.start;\n-  const htmlPath: HtmlAstPath = getPathToNodeAtPosition(htmlAst, templatePosition);\n-  const mostSpecific = htmlPath.tail;\n-  const visitor = new HtmlVisitor(templateInfo, htmlPath);\n-  const results: ng.CompletionEntry[] = mostSpecific ?\n-      mostSpecific.visit(visitor, null /* context */) :\n-      elementCompletions(templateInfo);\n-  const replacementSpan = getBoundedWordSpan(templateInfo, position, mostSpecific);\n-  return results.map(entry => {\n-    return {\n-      ...entry,\n-      replacementSpan,\n-    };\n-  });\n-}\n-\n-class HtmlVisitor implements Visitor {\n-  /**\n-   * Position relative to the start of the template.\n-   */\n-  private readonly relativePosition: number;\n-  constructor(private readonly templateInfo: ng.AstResult, private readonly htmlPath: HtmlAstPath) {\n-    this.relativePosition = htmlPath.position;\n-  }\n-  // Note that every visitor method must explicitly specify return type because\n-  // Visitor returns `any` for all methods.\n-  visitElement(ast: Element): ng.CompletionEntry[] {\n-    const startTagSpan = spanOf(ast.sourceSpan);\n-    const tagLen = ast.name.length;\n-    // + 1 for the opening angle bracket\n-    if (this.relativePosition <= startTagSpan.start + tagLen + 1) {\n-      // If we are in the tag then return the element completions.\n-      return elementCompletions(this.templateInfo);\n-    }\n-    if (this.relativePosition < startTagSpan.end) {\n-      // We are in the attribute section of the element (but not in an attribute).\n-      // Return the attribute completions.\n-      return attributeCompletionsForElement(this.templateInfo, ast.name);\n-    }\n-    return [];\n-  }\n-  visitAttribute(ast: Attribute): ng.CompletionEntry[] {\n-    // An attribute consists of two parts, LHS=\"RHS\".\n-    // Determine if completions are requested for LHS or RHS\n-    if (ast.valueSpan && inSpan(this.relativePosition, spanOf(ast.valueSpan))) {\n-      // RHS completion\n-      return attributeValueCompletions(this.templateInfo, this.htmlPath);\n-    }\n-    // LHS completion\n-    return attributeCompletions(this.templateInfo, this.htmlPath);\n-  }\n-  visitText(): ng.CompletionEntry[] {\n-    const templatePath = findTemplateAstAt(this.templateInfo.templateAst, this.relativePosition);\n-    if (templatePath.tail instanceof BoundTextAst) {\n-      // If we know that this is an interpolation then do not try other scenarios.\n-      const visitor = new ExpressionVisitor(\n-          this.templateInfo, this.relativePosition,\n-          () =>\n-              getExpressionScope(diagnosticInfoFromTemplateInfo(this.templateInfo), templatePath));\n-      templatePath.tail?.visit(visitor, null);\n-      return visitor.results;\n-    }\n-    // TODO(kyliau): Not sure if this check is really needed since we don't have\n-    // any test cases for it.\n-    const element = this.htmlPath.first(Element);\n-    if (element &&\n-        getHtmlTagDefinition(element.name).getContentType() !== TagContentType.PARSABLE_DATA) {\n-      return [];\n-    }\n-    // This is to account for cases like <h1> <a> text | </h1> where the\n-    // closest element has no closing tag and thus is considered plain text.\n-    const results = voidElementAttributeCompletions(this.templateInfo, this.htmlPath);\n-    if (results.length) {\n-      return results;\n-    }\n-    return elementCompletions(this.templateInfo);\n-  }\n-  visitComment(): ng.CompletionEntry[] {\n-    return [];\n-  }\n-  visitExpansion(): ng.CompletionEntry[] {\n-    return [];\n-  }\n-  visitExpansionCase(): ng.CompletionEntry[] {\n-    return [];\n-  }\n-}\n-\n-function attributeCompletions(info: ng.AstResult, path: AstPath<HtmlAst>): ng.CompletionEntry[] {\n-  const attr = path.tail;\n-  const elem = path.parentOf(attr);\n-  if (!(attr instanceof Attribute) || !(elem instanceof Element)) {\n-    return [];\n-  }\n-\n-  // TODO: Consider parsing the attrinute name to a proper AST instead of\n-  // matching using regex. This is because the regexp would incorrectly identify\n-  // bind parts for cases like [()|]\n-  //                              ^ cursor is here\n-  const binding = getBindingDescriptor(attr.name);\n-  if (!binding) {\n-    // This is a normal HTML attribute, not an Angular attribute.\n-    return attributeCompletionsForElement(info, elem.name);\n-  }\n-\n-  const results: string[] = [];\n-  const ngAttrs = angularAttributes(info, elem.name);\n-  switch (binding.kind) {\n-    case ATTR.KW_MICROSYNTAX:\n-      // template reference attribute: *attrName\n-      results.push(...ngAttrs.templateRefs);\n-      break;\n-\n-    case ATTR.KW_BIND:\n-    case ATTR.IDENT_PROPERTY:\n-      // property binding via bind- or []\n-      results.push(...propertyNames(elem.name), ...ngAttrs.inputs);\n-      break;\n-\n-    case ATTR.KW_ON:\n-    case ATTR.IDENT_EVENT:\n-      // event binding via on- or ()\n-      results.push(...eventNames(elem.name), ...ngAttrs.outputs);\n-      break;\n-\n-    case ATTR.KW_BINDON:\n-    case ATTR.IDENT_BANANA_BOX:\n-      // banana-in-a-box binding via bindon- or [()]\n-      results.push(...ngAttrs.bananas);\n-      break;\n-  }\n-\n-  return results.map(name => {\n-    return {\n-      name,\n-      kind: ng.CompletionKind.ATTRIBUTE,\n-      sortText: name,\n-    };\n-  });\n-}\n-\n-function attributeCompletionsForElement(\n-    info: ng.AstResult, elementName: string): ng.CompletionEntry[] {\n-  const results: ng.CompletionEntry[] = [];\n-\n-  if (info.template instanceof InlineTemplate) {\n-    // Provide HTML attributes completion only for inline templates\n-    for (const name of attributeNames(elementName)) {\n-      results.push({\n-        name,\n-        kind: ng.CompletionKind.HTML_ATTRIBUTE,\n-        sortText: name,\n-      });\n-    }\n-  }\n-\n-  // Add Angular attributes\n-  const ngAttrs = angularAttributes(info, elementName);\n-  for (const name of ngAttrs.others) {\n-    results.push({\n-      name,\n-      kind: ng.CompletionKind.ATTRIBUTE,\n-      sortText: name,\n-    });\n-  }\n-\n-  return results;\n-}\n-\n-/**\n- * Provide completions to the RHS of an attribute, which is of the form\n- * LHS=\"RHS\". The template path is computed from the specified `info` whereas\n- * the context is determined from the specified `htmlPath`.\n- * @param info Object that contains the template AST\n- * @param htmlPath Path to the HTML node\n- */\n-function attributeValueCompletions(\n-    info: ng.AstResult, htmlPath: HtmlAstPath): ng.CompletionEntry[] {\n-  // Find the corresponding Template AST path.\n-  const templatePath = findTemplateAstAt(info.templateAst, htmlPath.position);\n-  const visitor = new ExpressionVisitor(info, htmlPath.position, () => {\n-    const dinfo = diagnosticInfoFromTemplateInfo(info);\n-    return getExpressionScope(dinfo, templatePath);\n-  });\n-  if (templatePath.tail instanceof AttrAst ||\n-      templatePath.tail instanceof BoundElementPropertyAst ||\n-      templatePath.tail instanceof BoundEventAst) {\n-    templatePath.tail.visit(visitor, null);\n-    return visitor.results;\n-  }\n-  // In order to provide accurate attribute value completion, we need to know\n-  // what the LHS is, and construct the proper AST if it is missing.\n-  const htmlAttr = htmlPath.tail as Attribute;\n-  const binding = getBindingDescriptor(htmlAttr.name);\n-  if (binding && binding.kind === ATTR.KW_REF) {\n-    let refAst: ReferenceAst|undefined;\n-    let elemAst: ElementAst|undefined;\n-    if (templatePath.tail instanceof ReferenceAst) {\n-      refAst = templatePath.tail;\n-      const parent = templatePath.parentOf(refAst);\n-      if (parent instanceof ElementAst) {\n-        elemAst = parent;\n-      }\n-    } else if (templatePath.tail instanceof ElementAst) {\n-      refAst = new ReferenceAst(htmlAttr.name, null!, htmlAttr.value, htmlAttr.valueSpan!);\n-      elemAst = templatePath.tail;\n-    }\n-    if (refAst && elemAst) {\n-      refAst.visit(visitor, elemAst);\n-    }\n-  } else {\n-    // HtmlAst contains the `Attribute` node, however the corresponding `AttrAst`\n-    // node is missing from the TemplateAst.\n-    const attrAst = new AttrAst(htmlAttr.name, htmlAttr.value, htmlAttr.valueSpan!);\n-    attrAst.visit(visitor, null);\n-  }\n-  return visitor.results;\n-}\n-\n-function elementCompletions(info: ng.AstResult): ng.CompletionEntry[] {\n-  const results: ng.CompletionEntry[] = [...ANGULAR_ELEMENTS];\n-\n-  if (info.template instanceof InlineTemplate) {\n-    // Provide HTML elements completion only for inline templates\n-    results.push(...HTML_ELEMENTS);\n-  }\n-\n-  // Collect the elements referenced by the selectors\n-  const components = new Set<string>();\n-  for (const selector of getSelectors(info).selectors) {\n-    const name = selector.element;\n-    if (name && !components.has(name)) {\n-      components.add(name);\n-      results.push({\n-        name,\n-        kind: ng.CompletionKind.COMPONENT,\n-        sortText: name,\n-      });\n-    }\n-  }\n-\n-  return results;\n-}\n-\n-// There is a special case of HTML where text that contains a unclosed tag is treated as\n-// text. For exaple '<h1> Some <a text </h1>' produces a text nodes inside of the H1\n-// element \"Some <a text\". We, however, want to treat this as if the user was requesting\n-// the attributes of an \"a\" element, not requesting completion in the a text element. This\n-// code checks for this case and returns element completions if it is detected or undefined\n-// if it is not.\n-function voidElementAttributeCompletions(\n-    info: ng.AstResult, path: AstPath<HtmlAst>): ng.CompletionEntry[] {\n-  const tail = path.tail;\n-  if (tail instanceof Text) {\n-    const match = tail.value.match(/<(\\w(\\w|\\d|-)*:)?(\\w(\\w|\\d|-)*)\\s/);\n-    // The position must be after the match, otherwise we are still in a place where elements\n-    // are expected (such as `<|a` or `<a|`; we only want attributes for `<a |` or after).\n-    if (match &&\n-        path.position >= (match.index || 0) + match[0].length + tail.sourceSpan.start.offset) {\n-      return attributeCompletionsForElement(info, match[3]);\n-    }\n-  }\n-  return [];\n-}\n-\n-class ExpressionVisitor extends NullTemplateVisitor {\n-  private readonly completions = new Map<string, ng.CompletionEntry>();\n-\n-  constructor(\n-      private readonly info: ng.AstResult, private readonly position: number,\n-      private readonly getExpressionScope: () => ng.SymbolTable) {\n-    super();\n-  }\n-\n-  get results(): ng.CompletionEntry[] {\n-    return Array.from(this.completions.values());\n-  }\n-\n-  override visitDirectiveProperty(ast: BoundDirectivePropertyAst): void {\n-    this.processExpressionCompletions(ast.value);\n-  }\n-\n-  override visitElementProperty(ast: BoundElementPropertyAst): void {\n-    this.processExpressionCompletions(ast.value);\n-  }\n-\n-  override visitEvent(ast: BoundEventAst): void {\n-    this.processExpressionCompletions(ast.handler);\n-  }\n-\n-  override visitElement(): void {\n-    // no-op for now\n-  }\n-\n-  override visitAttr(ast: AttrAst) {\n-    const binding = getBindingDescriptor(ast.name);\n-    if (binding && binding.kind === ATTR.KW_MICROSYNTAX) {\n-      // This a template binding given by micro syntax expression.\n-      // First, verify the attribute consists of some binding we can give completions for.\n-      // The sourceSpan of AttrAst points to the RHS of the attribute\n-      const templateKey = binding.name;\n-      const templateValue = ast.sourceSpan.toString();\n-      const templateUrl = ast.sourceSpan.start.file.url;\n-      // TODO(kyliau): We are unable to determine the absolute offset of the key\n-      // but it is okay here, because we are only looking at the RHS of the attr\n-      const absKeyOffset = 0;\n-      const absValueOffset = ast.sourceSpan.start.offset;\n-      const {templateBindings} = this.info.expressionParser.parseTemplateBindings(\n-          templateKey, templateValue, templateUrl, absKeyOffset, absValueOffset);\n-      // Find the nearest template binding to the position.\n-      const lastBindingEnd = templateBindings.length > 0 &&\n-          templateBindings[templateBindings.length - 1].sourceSpan.end;\n-      const normalizedPositionToBinding =\n-          lastBindingEnd && this.position > lastBindingEnd ? lastBindingEnd : this.position;\n-      const templateBinding =\n-          templateBindings.find(b => inSpan(normalizedPositionToBinding, b.sourceSpan));\n-\n-      if (!templateBinding) {\n-        return;\n-      }\n-\n-      this.microSyntaxInAttributeValue(ast, templateBinding);\n-    } else {\n-      const expressionAst = this.info.expressionParser.parseBinding(\n-          ast.value, ast.sourceSpan.toString(), ast.sourceSpan.start.offset);\n-      this.processExpressionCompletions(expressionAst);\n-    }\n-  }\n-\n-  override visitReference(_ast: ReferenceAst, context: ElementAst) {\n-    context.directives.forEach(dir => {\n-      const {exportAs} = dir.directive;\n-      if (exportAs) {\n-        this.completions.set(\n-            exportAs, {name: exportAs, kind: ng.CompletionKind.REFERENCE, sortText: exportAs});\n-      }\n-    });\n-  }\n-\n-  override visitBoundText(ast: BoundTextAst) {\n-    if (inSpan(this.position, ast.value.sourceSpan)) {\n-      const completions = getExpressionCompletions(\n-          this.getExpressionScope(), ast.value, this.position, this.info.template);\n-      if (completions) {\n-        this.addSymbolsToCompletions(completions);\n-      }\n-    }\n-  }\n-\n-  private processExpressionCompletions(value: AST) {\n-    const symbols = getExpressionCompletions(\n-        this.getExpressionScope(), value, this.position, this.info.template);\n-    if (symbols) {\n-      this.addSymbolsToCompletions(symbols);\n-    }\n-  }\n-\n-  private addSymbolsToCompletions(symbols: ng.Symbol[]) {\n-    for (const s of symbols) {\n-      if (s.name.startsWith('__') || !s.public || this.completions.has(s.name)) {\n-        continue;\n-      }\n-\n-      // The pipe method should not include parentheses.\n-      // e.g. {{ value_expression | slice : start [ : end ] }}\n-      const shouldInsertParentheses = s.callable && s.kind !== ng.CompletionKind.PIPE;\n-      this.completions.set(s.name, {\n-        name: s.name,\n-        kind: s.kind as ng.CompletionKind,\n-        sortText: s.name,\n-        insertText: shouldInsertParentheses ? `${s.name}()` : s.name,\n-      });\n-    }\n-  }\n-\n-  /**\n-   * This method handles the completions of attribute values for directives that\n-   * support the microsyntax format. Examples are *ngFor and *ngIf.\n-   * These directives allows declaration of \"let\" variables, adds context-specific\n-   * symbols like $implicit, index, count, among other behaviors.\n-   * For a complete description of such format, see\n-   * https://angular.io/guide/structural-directives#asterisk\n-   *\n-   * @param attr descriptor for attribute name and value pair\n-   * @param binding template binding for the expression in the attribute\n-   */\n-  private microSyntaxInAttributeValue(attr: AttrAst, binding: TemplateBinding) {\n-    const key = attr.name.substring(1);  // remove leading asterisk\n-\n-    // Find the selector - eg ngFor, ngIf, etc\n-    const selectorInfo = getSelectors(this.info);\n-    const selector = selectorInfo.selectors.find(s => {\n-      // attributes are listed in (attribute, value) pairs\n-      for (let i = 0; i < s.attrs.length; i += 2) {\n-        if (s.attrs[i] === key) {\n-          return true;\n-        }\n-      }\n-    });\n-\n-    if (!selector) {\n-      return;\n-    }\n-\n-    const valueRelativePosition = this.position - attr.sourceSpan.start.offset;\n-\n-    if (binding instanceof VariableBinding) {\n-      // TODO(kyliau): With expression sourceSpan we shouldn't have to search\n-      // the attribute value string anymore. Just check if position is in the\n-      // expression source span.\n-      const equalLocation = attr.value.indexOf('=');\n-      if (equalLocation > 0 && valueRelativePosition > equalLocation) {\n-        // We are after the '=' in a let clause. The valid values here are the members of the\n-        // template reference's type parameter.\n-        const directiveMetadata = selectorInfo.map.get(selector);\n-        if (directiveMetadata) {\n-          const contextTable =\n-              this.info.template.query.getTemplateContext(directiveMetadata.type.reference);\n-          if (contextTable) {\n-            // This adds symbols like $implicit, index, count, etc.\n-            this.addSymbolsToCompletions(contextTable.values());\n-            return;\n-          }\n-        }\n-      }\n-    } else if (binding instanceof ExpressionBinding) {\n-      if (inSpan(this.position, binding.value?.ast.sourceSpan)) {\n-        this.processExpressionCompletions(binding.value!.ast);\n-        return;\n-      } else if (!binding.value && this.position > binding.key.span.end) {\n-        // No expression is defined for the value of the key expression binding, but the cursor is\n-        // in a location where the expression would be defined. This can happen in a case like\n-        //   let i of |\n-        //            ^-- cursor\n-        // In this case, backfill the value to be an empty expression and retrieve completions.\n-        this.processExpressionCompletions(new EmptyExpr(\n-            new ParseSpan(valueRelativePosition, valueRelativePosition),\n-            new AbsoluteSourceSpan(this.position, this.position)));\n-        return;\n-      }\n-    }\n-  }\n-}\n-\n-interface AngularAttributes {\n-  /**\n-   * Attributes that support the * syntax. See https://angular.io/api/core/TemplateRef\n-   */\n-  templateRefs: Set<string>;\n-  /**\n-   * Attributes with the @Input annotation.\n-   */\n-  inputs: Set<string>;\n-  /**\n-   * Attributes with the @Output annotation.\n-   */\n-  outputs: Set<string>;\n-  /**\n-   * Attributes that support the [()] or bindon- syntax.\n-   */\n-  bananas: Set<string>;\n-  /**\n-   * General attributes that match the specified element.\n-   */\n-  others: Set<string>;\n-}\n-\n-/**\n- * Return all Angular-specific attributes for the element with `elementName`.\n- * @param info\n- * @param elementName\n- */\n-function angularAttributes(info: ng.AstResult, elementName: string): AngularAttributes {\n-  const {selectors, map: selectorMap} = getSelectors(info);\n-  const templateRefs = new Set<string>();\n-  const inputs = new Set<string>();\n-  const outputs = new Set<string>();\n-  const bananas = new Set<string>();\n-  const others = new Set<string>();\n-  for (const selector of selectors) {\n-    if (selector.element && selector.element !== elementName) {\n-      continue;\n-    }\n-    const summary = selectorMap.get(selector)!;\n-    const hasTemplateRef = isStructuralDirective(summary.type);\n-    // attributes are listed in (attribute, value) pairs\n-    for (let i = 0; i < selector.attrs.length; i += 2) {\n-      const attr = selector.attrs[i];\n-      if (hasTemplateRef) {\n-        templateRefs.add(attr);\n-      } else {\n-        others.add(attr);\n-      }\n-    }\n-    for (const input of Object.values(summary.inputs)) {\n-      inputs.add(input);\n-    }\n-    for (const output of Object.values(summary.outputs)) {\n-      outputs.add(output);\n-    }\n-  }\n-  for (const name of inputs) {\n-    // Add banana-in-a-box syntax\n-    // https://angular.io/guide/template-syntax#two-way-binding-\n-    if (outputs.has(`${name}Change`)) {\n-      bananas.add(name);\n-    }\n-  }\n-  return {templateRefs, inputs, outputs, bananas, others};\n-}"
        },
        {
            "sha": "7e92bf32dabf9eaa2cb8fdb7da59e9e088aac1cf",
            "filename": "packages/language-service/src/definitions.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 164,
            "changes": 164,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fdefinitions.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fdefinitions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Fdefinitions.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,164 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript'; // used as value and is provided at runtime\n-\n-import {locateSymbols} from './locate_symbol';\n-import {findTightestNode, getClassDeclFromDecoratorProp, getPropertyAssignmentFromValue} from './ts_utils';\n-import {AstResult, Span} from './types';\n-import {extractAbsoluteFilePath} from './utils';\n-\n-/**\n- * Convert Angular Span to TypeScript TextSpan. Angular Span has 'start' and\n- * 'end' whereas TS TextSpan has 'start' and 'length'.\n- * @param span Angular Span\n- */\n-function ngSpanToTsTextSpan(span: Span): ts.TextSpan {\n-  return {\n-    start: span.start,\n-    length: span.end - span.start,\n-  };\n-}\n-/**\n- * Attempts to get the definition of a file whose URL is specified in a property assignment in a\n- * directive decorator.\n- * Currently applies to `templateUrl` and `styleUrls` properties.\n- */\n-function getUrlFromProperty(\n-    urlNode: ts.StringLiteralLike,\n-    tsLsHost: Readonly<ts.LanguageServiceHost>): ts.DefinitionInfoAndBoundSpan|undefined {\n-  // Get the property assignment node corresponding to the `templateUrl` or `styleUrls` assignment.\n-  // These assignments are specified differently; `templateUrl` is a string, and `styleUrls` is\n-  // an array of strings:\n-  //   {\n-  //        templateUrl: './template.ng.html',\n-  //        styleUrls: ['./style.css', './other-style.css']\n-  //   }\n-  // `templateUrl`'s property assignment can be found from the string literal node;\n-  // `styleUrls`'s property assignment can be found from the array (parent) node.\n-  //\n-  // First search for `templateUrl`.\n-  let asgn = getPropertyAssignmentFromValue(urlNode, 'templateUrl');\n-  if (!asgn) {\n-    // `templateUrl` assignment not found; search for `styleUrls` array assignment.\n-    asgn = getPropertyAssignmentFromValue(urlNode.parent, 'styleUrls');\n-    if (!asgn) {\n-      // Nothing found, bail.\n-      return;\n-    }\n-  }\n-\n-  // If the property assignment is not a property of a class decorator, don't generate definitions\n-  // for it.\n-  if (!getClassDeclFromDecoratorProp(asgn)) {\n-    return;\n-  }\n-\n-  // Extract url path specified by the url node, which is relative to the TypeScript source file\n-  // the url node is defined in.\n-  const url = extractAbsoluteFilePath(urlNode);\n-\n-  // If the file does not exist, bail. It is possible that the TypeScript language service host\n-  // does not have a `fileExists` method, in which case optimistically assume the file exists.\n-  if (tsLsHost.fileExists && !tsLsHost.fileExists(url)) return;\n-\n-  const templateDefinitions: ts.DefinitionInfo[] = [{\n-    kind: ts.ScriptElementKind.externalModuleName,\n-    name: url,\n-    containerKind: ts.ScriptElementKind.unknown,\n-    containerName: '',\n-    // Reading the template is expensive, so don't provide a preview.\n-    textSpan: {start: 0, length: 0},\n-    fileName: url,\n-  }];\n-\n-  return {\n-    definitions: templateDefinitions,\n-    textSpan: {\n-      // Exclude opening and closing quotes in the url span.\n-      start: urlNode.getStart() + 1,\n-      length: urlNode.getWidth() - 2,\n-    },\n-  };\n-}\n-\n-/**\n- * Traverse the template AST and look for the symbol located at `position`, then\n- * return its definition and span of bound text.\n- * @param info\n- * @param position\n- */\n-export function getDefinitionAndBoundSpan(\n-    info: AstResult, position: number): ts.DefinitionInfoAndBoundSpan|undefined {\n-  const symbols = locateSymbols(info, position);\n-  if (!symbols.length) {\n-    return;\n-  }\n-\n-  const seen = new Set<string>();\n-  const definitions: ts.DefinitionInfo[] = [];\n-  for (const symbolInfo of symbols) {\n-    const {symbol} = symbolInfo;\n-\n-    // symbol.definition is really the locations of the symbol. There could be\n-    // more than one. No meaningful info could be provided without any location.\n-    const {kind, name, container, definition: locations} = symbol;\n-    if (!locations || !locations.length) {\n-      continue;\n-    }\n-\n-    const containerKind =\n-        container ? container.kind as ts.ScriptElementKind : ts.ScriptElementKind.unknown;\n-    const containerName = container ? container.name : '';\n-\n-    for (const {fileName, span} of locations) {\n-      const textSpan = ngSpanToTsTextSpan(span);\n-      // In cases like two-way bindings, a request for the definitions of an expression may return\n-      // two of the same definition:\n-      //    [(ngModel)]=\"prop\"\n-      //                 ^^^^  -- one definition for the property binding, one for the event binding\n-      // To prune duplicate definitions, tag definitions with unique location signatures and ignore\n-      // definitions whose locations have already been seen.\n-      const signature = `${textSpan.start}:${textSpan.length}@${fileName}`;\n-      if (seen.has(signature)) continue;\n-\n-      definitions.push({\n-        kind: kind as ts.ScriptElementKind,\n-        name,\n-        containerKind,\n-        containerName,\n-        textSpan: ngSpanToTsTextSpan(span),\n-        fileName: fileName,\n-      });\n-      seen.add(signature);\n-    }\n-  }\n-\n-  return {\n-    definitions,\n-    textSpan: symbols[0].span,\n-  };\n-}\n-\n-/**\n- * Gets an Angular-specific definition in a TypeScript source file.\n- */\n-export function getTsDefinitionAndBoundSpan(\n-    sf: ts.SourceFile, position: number,\n-    tsLsHost: Readonly<ts.LanguageServiceHost>): ts.DefinitionInfoAndBoundSpan|undefined {\n-  const node = findTightestNode(sf, position);\n-  if (!node) return;\n-  switch (node.kind) {\n-    case ts.SyntaxKind.StringLiteral:\n-    case ts.SyntaxKind.NoSubstitutionTemplateLiteral:\n-      // Attempt to extract definition of a URL in a property assignment.\n-      return getUrlFromProperty(node as ts.StringLiteralLike, tsLsHost);\n-    default:\n-      return undefined;\n-  }\n-}"
        },
        {
            "sha": "48145cfe5b0ee7814373f2b741ba91fb87c9ede0",
            "filename": "packages/language-service/src/diagnostic_messages.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 162,
            "changes": 162,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fdiagnostic_messages.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fdiagnostic_messages.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Fdiagnostic_messages.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,162 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-import * as ng from './types';\n-\n-export interface DiagnosticMessage {\n-  message: string;\n-  kind: keyof typeof ts.DiagnosticCategory;\n-}\n-\n-type DiagnosticName = 'directive_not_in_module'|'missing_template_and_templateurl'|\n-    'both_template_and_templateurl'|'invalid_templateurl'|'template_context_missing_member'|\n-    'callable_expression_expected_method_call'|'call_target_not_callable'|\n-    'expression_might_be_null'|'expected_a_number_type'|'expected_a_string_or_number_type'|\n-    'expected_operands_of_comparable_types_or_any'|'unrecognized_operator'|'unrecognized_primitive'|\n-    'no_pipe_found'|'unable_to_resolve_compatible_call_signature'|'unable_to_resolve_signature'|\n-    'could_not_resolve_type'|'identifier_not_callable'|'identifier_possibly_undefined'|\n-    'identifier_not_defined_in_app_context'|'identifier_not_defined_on_receiver'|\n-    'identifier_is_private';\n-\n-export const Diagnostic: Record<DiagnosticName, DiagnosticMessage> = {\n-  directive_not_in_module: {\n-    message:\n-        `%1 '%2' is not included in a module and will not be available inside a template. Consider adding it to a NgModule declaration.`,\n-    kind: 'Suggestion',\n-  },\n-\n-  missing_template_and_templateurl: {\n-    message: `Component '%1' must have a template or templateUrl`,\n-    kind: 'Error',\n-  },\n-\n-  both_template_and_templateurl: {\n-    message: `Component '%1' must not have both template and templateUrl`,\n-    kind: 'Error',\n-  },\n-\n-  invalid_templateurl: {\n-    message: `URL does not point to a valid file`,\n-    kind: 'Error',\n-  },\n-\n-  template_context_missing_member: {\n-    message: `The template context of '%1' does not define %2.\\n` +\n-        `If the context type is a base type or 'any', consider refining it to a more specific type.`,\n-    kind: 'Suggestion',\n-  },\n-\n-  callable_expression_expected_method_call: {\n-    message: 'Unexpected callable expression. Expected a method call',\n-    kind: 'Warning',\n-  },\n-\n-  call_target_not_callable: {\n-    message: `Call target '%1' has non-callable type '%2'.`,\n-    kind: 'Error',\n-  },\n-\n-  expression_might_be_null: {\n-    message: 'The expression might be null',\n-    kind: 'Error',\n-  },\n-\n-  expected_a_number_type: {\n-    message: 'Expected a number type',\n-    kind: 'Error',\n-  },\n-\n-  expected_a_string_or_number_type: {\n-    message: 'Expected operands to be a string or number type',\n-    kind: 'Error',\n-  },\n-\n-  expected_operands_of_comparable_types_or_any: {\n-    message: 'Expected operands to be of comparable types or any',\n-    kind: 'Error',\n-  },\n-\n-  unrecognized_operator: {\n-    message: 'Unrecognized operator %1',\n-    kind: 'Error',\n-  },\n-\n-  unrecognized_primitive: {\n-    message: 'Unrecognized primitive %1',\n-    kind: 'Error',\n-  },\n-\n-  no_pipe_found: {\n-    message: 'No pipe of name %1 found',\n-    kind: 'Error',\n-  },\n-\n-  // TODO: Consider a better error message here.\n-  unable_to_resolve_compatible_call_signature: {\n-    message: 'Unable to resolve compatible call signature',\n-    kind: 'Error',\n-  },\n-\n-  unable_to_resolve_signature: {\n-    message: 'Unable to resolve signature for call of %1',\n-    kind: 'Error',\n-  },\n-\n-  could_not_resolve_type: {\n-    message: `Could not resolve the type of '%1'`,\n-    kind: 'Error',\n-  },\n-\n-  identifier_not_callable: {\n-    message: `'%1' is not callable`,\n-    kind: 'Error',\n-  },\n-\n-  identifier_possibly_undefined: {\n-    message:\n-        `'%1' is possibly undefined. Consider using the safe navigation operator (%2) or non-null assertion operator (%3).`,\n-    kind: 'Suggestion',\n-  },\n-\n-  identifier_not_defined_in_app_context: {\n-    message:\n-        `Identifier '%1' is not defined. The component declaration, template variable declarations, and element references do not contain such a member`,\n-    kind: 'Error',\n-  },\n-\n-  identifier_not_defined_on_receiver: {\n-    message: `Identifier '%1' is not defined. '%2' does not contain such a member`,\n-    kind: 'Error',\n-  },\n-\n-  identifier_is_private: {\n-    message: `Identifier '%1' refers to a private member of %2`,\n-    kind: 'Warning',\n-  },\n-};\n-\n-/**\n- * Creates a language service diagnostic.\n- * @param span location the diagnostic for\n- * @param dm diagnostic message\n- * @param formatArgs run-time arguments to format the diagnostic message with (see the messages in\n- *        the `Diagnostic` object for an example).\n- * @returns a created diagnostic\n- */\n-export function createDiagnostic(\n-    span: ng.Span, dm: DiagnosticMessage, ...formatArgs: string[]): ng.Diagnostic {\n-  // Formats \"%1 %2\" with formatArgs ['a', 'b'] as \"a b\"\n-  const formattedMessage =\n-      dm.message.replace(/%(\\d+)/g, (_, index: string) => formatArgs[+index - 1]);\n-  return {\n-    kind: ts.DiagnosticCategory[dm.kind],\n-    message: formattedMessage,\n-    span,\n-  };\n-}"
        },
        {
            "sha": "2b2fa50a68403c2270ef99eb81734c33c55a8fb0",
            "filename": "packages/language-service/src/diagnostics.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 203,
            "changes": 203,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fdiagnostics.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fdiagnostics.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Fdiagnostics.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,203 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {NgAnalyzedModules} from '@angular/compiler';\n-import ts from 'typescript';\n-\n-import {createDiagnostic, Diagnostic} from './diagnostic_messages';\n-import {getTemplateExpressionDiagnostics} from './expression_diagnostics';\n-import {findPropertyValueOfType, findTightestNode} from './ts_utils';\n-import * as ng from './types';\n-import {TypeScriptServiceHost} from './typescript_host';\n-import {extractAbsoluteFilePath, offsetSpan, spanOf} from './utils';\n-\n-/**\n- * Return diagnostic information for the parsed AST of the template.\n- * @param ast contains HTML and template AST\n- */\n-export function getTemplateDiagnostics(ast: ng.AstResult): ng.Diagnostic[] {\n-  const {parseErrors, templateAst, htmlAst, template} = ast;\n-  if (parseErrors && parseErrors.length) {\n-    return parseErrors.map(e => {\n-      return {\n-        kind: ts.DiagnosticCategory.Error,\n-        span: offsetSpan(spanOf(e.span), template.span.start),\n-        message: e.msg,\n-      };\n-    });\n-  }\n-  return getTemplateExpressionDiagnostics({\n-    templateAst: templateAst,\n-    htmlAst: htmlAst,\n-    offset: template.span.start,\n-    query: template.query,\n-    members: template.members,\n-    source: ast.template.source,\n-  });\n-}\n-\n-/**\n- * Performs a variety diagnostics on directive declarations.\n- *\n- * @param declarations Angular directive declarations\n- * @param modules NgModules in the project\n- * @param host TypeScript service host used to perform TypeScript queries\n- * @return diagnosed errors, if any\n- */\n-export function getDeclarationDiagnostics(\n-    declarations: ng.Declaration[], modules: NgAnalyzedModules,\n-    host: Readonly<TypeScriptServiceHost>): ng.Diagnostic[] {\n-  const directives = new Set<ng.StaticSymbol>();\n-  for (const ngModule of modules.ngModules) {\n-    for (const directive of ngModule.declaredDirectives) {\n-      directives.add(directive.reference);\n-    }\n-  }\n-\n-  const results: ng.Diagnostic[] = [];\n-\n-  for (const declaration of declarations) {\n-    const {errors, metadata, type, declarationSpan} = declaration;\n-\n-    const sf = host.getSourceFile(type.filePath);\n-    if (!sf) {\n-      host.error(`directive ${type.name} exists but has no source file`);\n-      return [];\n-    }\n-    // TypeScript identifier of the directive declaration annotation (e.g. \"Component\" or\n-    // \"Directive\") on a directive class.\n-    const directiveIdentifier = findTightestNode(sf, declarationSpan.start);\n-    if (!directiveIdentifier) {\n-      host.error(`directive ${type.name} exists but has no identifier`);\n-      return [];\n-    }\n-\n-    for (const error of errors) {\n-      results.push({\n-        kind: ts.DiagnosticCategory.Error,\n-        message: error.message,\n-        span: error.span,\n-      });\n-    }\n-\n-    if (!modules.ngModuleByPipeOrDirective.has(declaration.type)) {\n-      results.push(createDiagnostic(\n-          declarationSpan, Diagnostic.directive_not_in_module,\n-          metadata.isComponent ? 'Component' : 'Directive', type.name));\n-    }\n-\n-    if (metadata.isComponent) {\n-      const {template, templateUrl, styleUrls} = metadata.template !;\n-      if (template === null && !templateUrl) {\n-        results.push(createDiagnostic(\n-            declarationSpan, Diagnostic.missing_template_and_templateurl, type.name));\n-      } else if (templateUrl) {\n-        if (template) {\n-          results.push(createDiagnostic(\n-              declarationSpan, Diagnostic.both_template_and_templateurl, type.name));\n-        }\n-\n-        // Find templateUrl value from the directive call expression, which is the parent of the\n-        // directive identifier.\n-        //\n-        // TODO: We should create an enum of the various properties a directive can have to use\n-        // instead of string literals. We can then perform a mass migration of all literal usages.\n-        const templateUrlNode = findPropertyValueOfType(\n-            directiveIdentifier.parent, 'templateUrl', ts.isLiteralExpression);\n-        if (!templateUrlNode) {\n-          host.error(`templateUrl ${templateUrl} exists but its TypeScript node doesn't`);\n-          return [];\n-        }\n-\n-        results.push(...validateUrls([templateUrlNode], host.tsLsHost));\n-      }\n-\n-      if (styleUrls.length > 0) {\n-        // Find styleUrls value from the directive call expression, which is the parent of the\n-        // directive identifier.\n-        const styleUrlsNode = findPropertyValueOfType(\n-            directiveIdentifier.parent, 'styleUrls', ts.isArrayLiteralExpression);\n-        if (!styleUrlsNode) {\n-          host.error(`styleUrls property exists but its TypeScript node doesn't'`);\n-          return [];\n-        }\n-\n-        results.push(...validateUrls(styleUrlsNode.elements, host.tsLsHost));\n-      }\n-    }\n-  }\n-\n-  return results;\n-}\n-\n-/**\n- * Checks that URLs on a directive point to a valid file.\n- * Note that this diagnostic check may require a filesystem hit, and thus may be slower than other\n- * checks.\n- *\n- * @param urls urls to check for validity\n- * @param tsLsHost TS LS host used for querying filesystem information\n- * @return diagnosed url errors, if any\n- */\n-function validateUrls(\n-    urls: ArrayLike<ts.Expression>, tsLsHost: Readonly<ts.LanguageServiceHost>): ng.Diagnostic[] {\n-  if (!tsLsHost.fileExists) {\n-    return [];\n-  }\n-\n-  const allErrors: ng.Diagnostic[] = [];\n-  // TODO(ayazhafiz): most of this logic can be unified with the logic in\n-  // definitions.ts#getUrlFromProperty. Create a utility function to be used by both.\n-  for (let i = 0; i < urls.length; ++i) {\n-    const urlNode = urls[i];\n-    if (!ts.isStringLiteralLike(urlNode)) {\n-      // If a non-string value is assigned to a URL node (like `templateUrl`), a type error will be\n-      // picked up by the TS Language Server.\n-      continue;\n-    }\n-\n-    const url = extractAbsoluteFilePath(urlNode);\n-    if (tsLsHost.fileExists(url)) continue;\n-\n-    // Exclude opening and closing quotes in the url span.\n-    const urlSpan = {start: urlNode.getStart() + 1, end: urlNode.end - 1};\n-    allErrors.push(createDiagnostic(urlSpan, Diagnostic.invalid_templateurl));\n-  }\n-  return allErrors;\n-}\n-\n-/**\n- * Return a recursive data structure that chains diagnostic messages.\n- * @param chain\n- */\n-function chainDiagnostics(chain: ng.DiagnosticMessageChain): ts.DiagnosticMessageChain {\n-  return {\n-    messageText: chain.message,\n-    category: ts.DiagnosticCategory.Error,\n-    code: 0,\n-    next: chain.next ? chain.next.map(chainDiagnostics) : undefined\n-  };\n-}\n-\n-/**\n- * Convert ng.Diagnostic to ts.Diagnostic.\n- * @param d diagnostic\n- * @param file\n- */\n-export function ngDiagnosticToTsDiagnostic(\n-    d: ng.Diagnostic, file: ts.SourceFile|undefined): ts.Diagnostic {\n-  return {\n-    file,\n-    start: d.span.start,\n-    length: d.span.end - d.span.start,\n-    messageText: typeof d.message === 'string' ? d.message : chainDiagnostics(d.message),\n-    category: d.kind,\n-    code: 0,\n-    source: 'ng',\n-  };\n-}"
        },
        {
            "sha": "0327a7daa7af49163ce47ae759bf3e29d3e83f25",
            "filename": "packages/language-service/src/expression_diagnostics.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 377,
            "changes": 377,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fexpression_diagnostics.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fexpression_diagnostics.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Fexpression_diagnostics.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,377 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {AST, AstPath, Attribute, BoundDirectivePropertyAst, BoundElementPropertyAst, BoundEventAst, BoundTextAst, CompileDirectiveSummary, CompileTypeMetadata, DirectiveAst, ElementAst, EmbeddedTemplateAst, identifierName, ParseSourceSpan, RecursiveTemplateAstVisitor, ReferenceAst, TemplateAst, TemplateAstPath, templateVisitAll, tokenReference, VariableAst} from '@angular/compiler';\n-\n-import {createDiagnostic, Diagnostic} from './diagnostic_messages';\n-import {AstType} from './expression_type';\n-import {BuiltinType, Definition, Span, Symbol, SymbolDeclaration, SymbolQuery, SymbolTable} from './symbols';\n-import * as ng from './types';\n-import {findOutputBinding, getPathToNodeAtPosition} from './utils';\n-\n-export function getTemplateExpressionDiagnostics(info: ng.DiagnosticTemplateInfo): ng.Diagnostic[] {\n-  const visitor = new ExpressionDiagnosticsVisitor(\n-      info, (path: TemplateAstPath) => getExpressionScope(info, path));\n-  templateVisitAll(visitor, info.templateAst);\n-  return visitor.diagnostics;\n-}\n-\n-function getReferences(info: ng.DiagnosticTemplateInfo): SymbolDeclaration[] {\n-  const result: SymbolDeclaration[] = [];\n-\n-  function processReferences(references: ReferenceAst[]) {\n-    for (const reference of references) {\n-      let type: Symbol|undefined = undefined;\n-      if (reference.value) {\n-        type = info.query.getTypeSymbol(tokenReference(reference.value));\n-      }\n-      result.push({\n-        name: reference.name,\n-        kind: 'reference',\n-        type: type || info.query.getBuiltinType(BuiltinType.Any),\n-        get definition() {\n-          return getDefinitionOf(info, reference);\n-        }\n-      });\n-    }\n-  }\n-\n-  const visitor = new class extends RecursiveTemplateAstVisitor {\n-    override visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n-      super.visitEmbeddedTemplate(ast, context);\n-      processReferences(ast.references);\n-    }\n-    override visitElement(ast: ElementAst, context: any): any {\n-      super.visitElement(ast, context);\n-      processReferences(ast.references);\n-    }\n-  };\n-\n-  templateVisitAll(visitor, info.templateAst);\n-\n-  return result;\n-}\n-\n-function getDefinitionOf(info: ng.DiagnosticTemplateInfo, ast: TemplateAst): Definition|undefined {\n-  if (info.fileName) {\n-    const templateOffset = info.offset;\n-    return [{\n-      fileName: info.fileName,\n-      span: {\n-        start: ast.sourceSpan.start.offset + templateOffset,\n-        end: ast.sourceSpan.end.offset + templateOffset\n-      }\n-    }];\n-  }\n-}\n-\n-/**\n- * Resolve all variable declarations in a template by traversing the specified\n- * `path`.\n- * @param info\n- * @param path template AST path\n- */\n-function getVarDeclarations(\n-    info: ng.DiagnosticTemplateInfo, path: TemplateAstPath): SymbolDeclaration[] {\n-  const results: SymbolDeclaration[] = [];\n-  for (let current = path.head; current; current = path.childOf(current)) {\n-    if (!(current instanceof EmbeddedTemplateAst)) {\n-      continue;\n-    }\n-    for (const variable of current.variables) {\n-      let symbol = getVariableTypeFromDirectiveContext(variable.value, info.query, current);\n-\n-      const kind = info.query.getTypeKind(symbol);\n-      if (kind === BuiltinType.Any || kind === BuiltinType.Unbound) {\n-        // For special cases such as ngFor and ngIf, the any type is not very useful.\n-        // We can do better by resolving the binding value.\n-        const symbolsInScope = info.query.mergeSymbolTable([\n-          info.members,\n-          // Since we are traversing the AST path from head to tail, any variables\n-          // that have been declared so far are also in scope.\n-          info.query.createSymbolTable(results),\n-        ]);\n-        symbol = refinedVariableType(variable.value, symbolsInScope, info, current);\n-      }\n-      results.push({\n-        name: variable.name,\n-        kind: 'variable',\n-        type: symbol,\n-        get definition() {\n-          return getDefinitionOf(info, variable);\n-        },\n-      });\n-    }\n-  }\n-  return results;\n-}\n-\n-/**\n- * Resolve the type for the variable in `templateElement` by finding the structural\n- * directive which has the context member. Returns any when not found.\n- * @param value variable value name\n- * @param query type symbol query\n- * @param templateElement\n- */\n-function getVariableTypeFromDirectiveContext(\n-    value: string, query: SymbolQuery, templateElement: EmbeddedTemplateAst): Symbol {\n-  for (const {directive} of templateElement.directives) {\n-    const context = query.getTemplateContext(directive.type.reference);\n-    if (context) {\n-      const member = context.get(value);\n-      if (member && member.type) {\n-        return member.type;\n-      }\n-    }\n-  }\n-\n-  return query.getBuiltinType(BuiltinType.Any);\n-}\n-\n-/**\n- * Resolve a more specific type for the variable in `templateElement` by inspecting\n- * all variables that are in scope in the `mergedTable`. This function is a special\n- * case for `ngFor` and `ngIf`. If resolution fails, return the `any` type.\n- * @param value variable value name\n- * @param mergedTable symbol table for all variables in scope\n- * @param info available template information\n- * @param templateElement\n- */\n-function refinedVariableType(\n-    value: string, mergedTable: SymbolTable, info: ng.DiagnosticTemplateInfo,\n-    templateElement: EmbeddedTemplateAst): Symbol {\n-  if (value === '$implicit') {\n-    // Special case: ngFor directive\n-    const ngForDirective = templateElement.directives.find(d => {\n-      const name = identifierName(d.directive.type);\n-      return name == 'NgFor' || name == 'NgForOf';\n-    });\n-    if (ngForDirective) {\n-      const ngForOfBinding = ngForDirective.inputs.find(i => i.directiveName == 'ngForOf');\n-      if (ngForOfBinding) {\n-        // Check if there is a known type for the ngFor binding.\n-        const bindingType =\n-            new AstType(mergedTable, info.query, {}, info.source).getType(ngForOfBinding.value);\n-        if (bindingType) {\n-          const result = info.query.getElementType(bindingType);\n-          if (result) {\n-            return result;\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  if (value === 'ngIf' || value === '$implicit') {\n-    const ngIfDirective =\n-        templateElement.directives.find(d => identifierName(d.directive.type) === 'NgIf');\n-    if (ngIfDirective) {\n-      // Special case: ngIf directive. The NgIf structural directive owns a template context with\n-      // \"$implicit\" and \"ngIf\" members. These properties are typed as generics. Until the language\n-      // service uses an Ivy and TypecheckBlock backend, we cannot bind these values to a concrete\n-      // type without manual inference. To get the concrete type, look up the type of the \"ngIf\"\n-      // import on the NgIf directive bound to the template.\n-      //\n-      // See @angular/common/ng_if.ts for more information.\n-      const ngIfBinding = ngIfDirective.inputs.find(i => i.directiveName === 'ngIf');\n-      if (ngIfBinding) {\n-        // Check if there is a known type bound to the ngIf input.\n-        const bindingType =\n-            new AstType(mergedTable, info.query, {}, info.source).getType(ngIfBinding.value);\n-        if (bindingType) {\n-          return bindingType;\n-        }\n-      }\n-    }\n-  }\n-\n-  // We can't do better, return any\n-  return info.query.getBuiltinType(BuiltinType.Any);\n-}\n-\n-function getEventDeclaration(\n-    info: ng.DiagnosticTemplateInfo, path: TemplateAstPath): SymbolDeclaration|undefined {\n-  const event = path.tail;\n-  if (!(event instanceof BoundEventAst)) {\n-    // No event available in this context.\n-    return;\n-  }\n-\n-  const genericEvent: SymbolDeclaration = {\n-    name: '$event',\n-    kind: 'variable',\n-    type: info.query.getBuiltinType(BuiltinType.Any),\n-  };\n-\n-  const outputSymbol = findOutputBinding(event, path, info.query);\n-  if (!outputSymbol) {\n-    // The `$event` variable doesn't belong to an output, so its type can't be refined.\n-    // TODO: type `$event` variables in bindings to DOM events.\n-    return genericEvent;\n-  }\n-\n-  // The raw event type is wrapped in a generic, like EventEmitter<T> or Observable<T>.\n-  const ta = outputSymbol.typeArguments();\n-  if (!ta || ta.length !== 1) return genericEvent;\n-  const eventType = ta[0];\n-\n-  return {...genericEvent, type: eventType};\n-}\n-\n-/**\n- * Returns the symbols available in a particular scope of a template.\n- * @param info parsed template information\n- * @param path path of template nodes narrowing to the context the expression scope should be\n- * derived for.\n- */\n-export function getExpressionScope(\n-    info: ng.DiagnosticTemplateInfo, path: TemplateAstPath): SymbolTable {\n-  let result = info.members;\n-  const references = getReferences(info);\n-  const variables = getVarDeclarations(info, path);\n-  const event = getEventDeclaration(info, path);\n-  if (references.length || variables.length || event) {\n-    const referenceTable = info.query.createSymbolTable(references);\n-    const variableTable = info.query.createSymbolTable(variables);\n-    const eventsTable = info.query.createSymbolTable(event ? [event] : []);\n-    result = info.query.mergeSymbolTable([result, referenceTable, variableTable, eventsTable]);\n-  }\n-  return result;\n-}\n-\n-class ExpressionDiagnosticsVisitor extends RecursiveTemplateAstVisitor {\n-  private path: TemplateAstPath;\n-  private directiveSummary: CompileDirectiveSummary|undefined;\n-\n-  diagnostics: ng.Diagnostic[] = [];\n-\n-  constructor(\n-      private info: ng.DiagnosticTemplateInfo,\n-      private getExpressionScope: (path: TemplateAstPath, includeEvent: boolean) => SymbolTable) {\n-    super();\n-    this.path = new AstPath<TemplateAst>([]);\n-  }\n-\n-  override visitDirective(ast: DirectiveAst, context: any): any {\n-    // Override the default child visitor to ignore the host properties of a directive.\n-    if (ast.inputs && ast.inputs.length) {\n-      templateVisitAll(this, ast.inputs, context);\n-    }\n-  }\n-\n-  override visitBoundText(ast: BoundTextAst): void {\n-    this.push(ast);\n-    this.diagnoseExpression(ast.value, ast.sourceSpan.start.offset, false);\n-    this.pop();\n-  }\n-\n-  override visitDirectiveProperty(ast: BoundDirectivePropertyAst): void {\n-    this.push(ast);\n-    this.diagnoseExpression(ast.value, this.attributeValueLocation(ast), false);\n-    this.pop();\n-  }\n-\n-  override visitElementProperty(ast: BoundElementPropertyAst): void {\n-    this.push(ast);\n-    this.diagnoseExpression(ast.value, this.attributeValueLocation(ast), false);\n-    this.pop();\n-  }\n-\n-  override visitEvent(ast: BoundEventAst): void {\n-    this.push(ast);\n-    this.diagnoseExpression(ast.handler, this.attributeValueLocation(ast), true);\n-    this.pop();\n-  }\n-\n-  override visitVariable(ast: VariableAst): void {\n-    const directive = this.directiveSummary;\n-    if (directive && ast.value) {\n-      const context = this.info.query.getTemplateContext(directive.type.reference)!;\n-      if (context && !context.has(ast.value)) {\n-        const missingMember =\n-            ast.value === '$implicit' ? 'an implicit value' : `a member called '${ast.value}'`;\n-\n-        const span = this.absSpan(spanOf(ast.sourceSpan));\n-        this.diagnostics.push(createDiagnostic(\n-            span, Diagnostic.template_context_missing_member, directive.type.reference.name,\n-            missingMember));\n-      }\n-    }\n-  }\n-\n-  override visitElement(ast: ElementAst, context: any): void {\n-    this.push(ast);\n-    super.visitElement(ast, context);\n-    this.pop();\n-  }\n-\n-  override visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n-    const previousDirectiveSummary = this.directiveSummary;\n-\n-    this.push(ast);\n-\n-    // Find directive that references this template\n-    this.directiveSummary =\n-        ast.directives.map(d => d.directive).find(d => hasTemplateReference(d.type))!;\n-\n-    // Process children\n-    super.visitEmbeddedTemplate(ast, context);\n-\n-    this.pop();\n-\n-    this.directiveSummary = previousDirectiveSummary;\n-  }\n-\n-  private attributeValueLocation(ast: TemplateAst) {\n-    const path = getPathToNodeAtPosition(this.info.htmlAst, ast.sourceSpan.start.offset);\n-    const last = path.tail;\n-    if (last instanceof Attribute && last.valueSpan) {\n-      return last.valueSpan.start.offset;\n-    }\n-    return ast.sourceSpan.start.offset;\n-  }\n-\n-  private diagnoseExpression(ast: AST, offset: number, inEvent: boolean) {\n-    const scope = this.getExpressionScope(this.path, inEvent);\n-    const analyzer = new AstType(scope, this.info.query, {inEvent}, this.info.source);\n-    for (const diagnostic of analyzer.getDiagnostics(ast)) {\n-      diagnostic.span = this.absSpan(diagnostic.span, offset);\n-      this.diagnostics.push(diagnostic);\n-    }\n-  }\n-\n-  private push(ast: TemplateAst) {\n-    this.path.push(ast);\n-  }\n-\n-  private pop() {\n-    this.path.pop();\n-  }\n-\n-  private absSpan(span: Span, additionalOffset: number = 0): Span {\n-    return {\n-      start: span.start + this.info.offset + additionalOffset,\n-      end: span.end + this.info.offset + additionalOffset,\n-    };\n-  }\n-}\n-\n-function hasTemplateReference(type: CompileTypeMetadata): boolean {\n-  if (type.diDeps) {\n-    for (let diDep of type.diDeps) {\n-      if (diDep.token && diDep.token.identifier &&\n-          identifierName(diDep.token!.identifier!) == 'TemplateRef')\n-        return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-function spanOf(sourceSpan: ParseSourceSpan): Span {\n-  return {start: sourceSpan.start.offset, end: sourceSpan.end.offset};\n-}"
        },
        {
            "sha": "50421b9c8d93c5215318f29ad7c9f3eaf963a541",
            "filename": "packages/language-service/src/expression_type.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 491,
            "changes": 491,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fexpression_type.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fexpression_type.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Fexpression_type.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,491 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {AST, AstVisitor, ASTWithName, Binary, BindingPipe, Call, Chain, Conditional, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, NonNullAssert, PrefixNot, PropertyRead, PropertyWrite, Quote, SafeKeyedRead, SafePropertyRead, ThisReceiver, Unary} from '@angular/compiler';\n-\n-import {createDiagnostic, Diagnostic} from './diagnostic_messages';\n-import {BuiltinType, Signature, Symbol, SymbolQuery, SymbolTable} from './symbols';\n-import * as ng from './types';\n-import {offsetSpan} from './utils';\n-\n-interface ExpressionDiagnosticsContext {\n-  inEvent?: boolean;\n-}\n-\n-// AstType calculatetype of the ast given AST element.\n-export class AstType implements AstVisitor {\n-  private readonly diagnostics: ng.Diagnostic[] = [];\n-\n-  constructor(\n-      private scope: SymbolTable, private query: SymbolQuery,\n-      private context: ExpressionDiagnosticsContext, private source: string) {}\n-\n-  getType(ast: AST): Symbol {\n-    return ast.visit(this);\n-  }\n-\n-  getDiagnostics(ast: AST): ng.Diagnostic[] {\n-    const type: Symbol = ast.visit(this);\n-    if (this.context.inEvent && type.callable) {\n-      this.diagnostics.push(\n-          createDiagnostic(refinedSpan(ast), Diagnostic.callable_expression_expected_method_call));\n-    }\n-    return this.diagnostics;\n-  }\n-\n-  visitUnary(ast: Unary): Symbol {\n-    // Visit the child to produce diagnostics.\n-    ast.expr.visit(this);\n-\n-    // The unary plus and minus operator are always of type number.\n-    // https://github.com/Microsoft/TypeScript/blob/v1.8.10/doc/spec.md#4.18\n-    switch (ast.operator) {\n-      case '-':\n-      case '+':\n-        return this.query.getBuiltinType(BuiltinType.Number);\n-    }\n-\n-    this.diagnostics.push(\n-        createDiagnostic(refinedSpan(ast), Diagnostic.unrecognized_operator, ast.operator));\n-    return this.anyType;\n-  }\n-\n-  visitBinary(ast: Binary): Symbol {\n-    const getType = (ast: AST, operation: string): Symbol => {\n-      const type = this.getType(ast);\n-      if (type.nullable) {\n-        switch (operation) {\n-          case '&&':\n-          case '||':\n-          case '==':\n-          case '!=':\n-          case '===':\n-          case '!==':\n-            // Nullable allowed.\n-            break;\n-          default:\n-            this.diagnostics.push(\n-                createDiagnostic(refinedSpan(ast), Diagnostic.expression_might_be_null));\n-            break;\n-        }\n-      }\n-      return type;\n-    };\n-\n-    const leftType = getType(ast.left, ast.operation);\n-    const rightType = getType(ast.right, ast.operation);\n-    const leftKind = this.query.getTypeKind(leftType);\n-    const rightKind = this.query.getTypeKind(rightType);\n-\n-    // The following swtich implements operator typing similar to the\n-    // type production tables in the TypeScript specification.\n-    // https://github.com/Microsoft/TypeScript/blob/v1.8.10/doc/spec.md#4.19\n-    const operKind = leftKind << 8 | rightKind;\n-    switch (ast.operation) {\n-      case '*':\n-      case '/':\n-      case '%':\n-      case '-':\n-      case '<<':\n-      case '>>':\n-      case '>>>':\n-      case '&':\n-      case '^':\n-      case '|':\n-        switch (operKind) {\n-          case BuiltinType.Any << 8 | BuiltinType.Any:\n-          case BuiltinType.Number << 8 | BuiltinType.Any:\n-          case BuiltinType.Any << 8 | BuiltinType.Number:\n-          case BuiltinType.Number << 8 | BuiltinType.Number:\n-            return this.query.getBuiltinType(BuiltinType.Number);\n-          default:\n-            let errorAst = ast.left;\n-            switch (leftKind) {\n-              case BuiltinType.Any:\n-              case BuiltinType.Number:\n-                errorAst = ast.right;\n-                break;\n-            }\n-            this.diagnostics.push(\n-                createDiagnostic(errorAst.span, Diagnostic.expected_a_number_type));\n-            return this.anyType;\n-        }\n-      case '+':\n-        switch (operKind) {\n-          case BuiltinType.Any << 8 | BuiltinType.Any:\n-          case BuiltinType.Any << 8 | BuiltinType.Boolean:\n-          case BuiltinType.Any << 8 | BuiltinType.Number:\n-          case BuiltinType.Any << 8 | BuiltinType.Other:\n-          case BuiltinType.Boolean << 8 | BuiltinType.Any:\n-          case BuiltinType.Number << 8 | BuiltinType.Any:\n-          case BuiltinType.Other << 8 | BuiltinType.Any:\n-            return this.anyType;\n-          case BuiltinType.Any << 8 | BuiltinType.String:\n-          case BuiltinType.Boolean << 8 | BuiltinType.String:\n-          case BuiltinType.Number << 8 | BuiltinType.String:\n-          case BuiltinType.String << 8 | BuiltinType.Any:\n-          case BuiltinType.String << 8 | BuiltinType.Boolean:\n-          case BuiltinType.String << 8 | BuiltinType.Number:\n-          case BuiltinType.String << 8 | BuiltinType.String:\n-          case BuiltinType.String << 8 | BuiltinType.Other:\n-          case BuiltinType.Other << 8 | BuiltinType.String:\n-            return this.query.getBuiltinType(BuiltinType.String);\n-          case BuiltinType.Number << 8 | BuiltinType.Number:\n-            return this.query.getBuiltinType(BuiltinType.Number);\n-          case BuiltinType.Boolean << 8 | BuiltinType.Number:\n-          case BuiltinType.Other << 8 | BuiltinType.Number:\n-            this.diagnostics.push(\n-                createDiagnostic(ast.left.span, Diagnostic.expected_a_number_type));\n-            return this.anyType;\n-          case BuiltinType.Number << 8 | BuiltinType.Boolean:\n-          case BuiltinType.Number << 8 | BuiltinType.Other:\n-            this.diagnostics.push(\n-                createDiagnostic(ast.right.span, Diagnostic.expected_a_number_type));\n-            return this.anyType;\n-          default:\n-            this.diagnostics.push(\n-                createDiagnostic(refinedSpan(ast), Diagnostic.expected_a_string_or_number_type));\n-            return this.anyType;\n-        }\n-      case '>':\n-      case '<':\n-      case '<=':\n-      case '>=':\n-      case '==':\n-      case '!=':\n-      case '===':\n-      case '!==':\n-        if (!(leftKind & rightKind) &&\n-            !((leftKind | rightKind) & (BuiltinType.Null | BuiltinType.Undefined))) {\n-          // Two values are comparable only if\n-          //   - they have some type overlap, or\n-          //   - at least one is not defined\n-          this.diagnostics.push(createDiagnostic(\n-              refinedSpan(ast), Diagnostic.expected_operands_of_comparable_types_or_any));\n-        }\n-        return this.query.getBuiltinType(BuiltinType.Boolean);\n-      case '&&':\n-        return rightType;\n-      case '||':\n-        return this.query.getTypeUnion(leftType, rightType);\n-    }\n-\n-    this.diagnostics.push(\n-        createDiagnostic(refinedSpan(ast), Diagnostic.unrecognized_operator, ast.operation));\n-    return this.anyType;\n-  }\n-\n-  visitChain(ast: Chain) {\n-    // If we are producing diagnostics, visit the children\n-    for (const expr of ast.expressions) {\n-      expr.visit(this);\n-    }\n-    // The type of a chain is always undefined.\n-    return this.query.getBuiltinType(BuiltinType.Undefined);\n-  }\n-\n-  visitConditional(ast: Conditional) {\n-    // The type of a conditional is the union of the true and false conditions.\n-    ast.condition.visit(this);\n-    ast.trueExp.visit(this);\n-    ast.falseExp.visit(this);\n-    return this.query.getTypeUnion(this.getType(ast.trueExp), this.getType(ast.falseExp));\n-  }\n-\n-  visitImplicitReceiver(_ast: ImplicitReceiver): Symbol {\n-    const _this = this;\n-    // Return a pseudo-symbol for the implicit receiver.\n-    // The members of the implicit receiver are what is defined by the\n-    // scope passed into this class.\n-    return {\n-      name: '$implicit',\n-      kind: 'component',\n-      language: 'ng-template',\n-      type: undefined,\n-      container: undefined,\n-      callable: false,\n-      nullable: false,\n-      public: true,\n-      definition: undefined,\n-      documentation: [],\n-      members(): SymbolTable {\n-        return _this.scope;\n-      },\n-      signatures(): Signature[] {\n-        return [];\n-      },\n-      selectSignature(_types): Signature |\n-          undefined {\n-            return undefined;\n-          },\n-      indexed(_argument): Symbol |\n-          undefined {\n-            return undefined;\n-          },\n-      typeArguments(): Symbol[] |\n-          undefined {\n-            return undefined;\n-          },\n-    };\n-  }\n-\n-  visitThisReceiver(_ast: ThisReceiver): Symbol {\n-    return this.visitImplicitReceiver(_ast);\n-  }\n-\n-  visitInterpolation(ast: Interpolation): Symbol {\n-    // If we are producing diagnostics, visit the children.\n-    for (const expr of ast.expressions) {\n-      expr.visit(this);\n-    }\n-    return this.undefinedType;\n-  }\n-\n-  visitKeyedRead(ast: KeyedRead): Symbol {\n-    const targetType = this.getType(ast.receiver);\n-    const keyType = this.getType(ast.key);\n-    const result = targetType.indexed(\n-        keyType, ast.key instanceof LiteralPrimitive ? ast.key.value : undefined);\n-    return result || this.anyType;\n-  }\n-\n-  visitKeyedWrite(ast: KeyedWrite): Symbol {\n-    // The write of a type is the type of the value being written.\n-    return this.getType(ast.value);\n-  }\n-\n-  visitLiteralArray(ast: LiteralArray): Symbol {\n-    // A type literal is an array type of the union of the elements\n-    return this.query.getArrayType(\n-        this.query.getTypeUnion(...ast.expressions.map(element => this.getType(element))));\n-  }\n-\n-  visitLiteralMap(ast: LiteralMap): Symbol {\n-    // If we are producing diagnostics, visit the children\n-    for (const value of ast.values) {\n-      value.visit(this);\n-    }\n-    // TODO: Return a composite type.\n-    return this.anyType;\n-  }\n-\n-  visitLiteralPrimitive(ast: LiteralPrimitive) {\n-    // The type of a literal primitive depends on the value of the literal.\n-    switch (ast.value) {\n-      case true:\n-      case false:\n-        return this.query.getBuiltinType(BuiltinType.Boolean);\n-      case null:\n-        return this.query.getBuiltinType(BuiltinType.Null);\n-      case undefined:\n-        return this.query.getBuiltinType(BuiltinType.Undefined);\n-      default:\n-        switch (typeof ast.value) {\n-          case 'string':\n-            return this.query.getBuiltinType(BuiltinType.String);\n-          case 'number':\n-            return this.query.getBuiltinType(BuiltinType.Number);\n-          default:\n-            this.diagnostics.push(createDiagnostic(\n-                refinedSpan(ast), Diagnostic.unrecognized_primitive, typeof ast.value));\n-            return this.anyType;\n-        }\n-    }\n-  }\n-\n-  visitPipe(ast: BindingPipe) {\n-    // The type of a pipe node is the return type of the pipe's transform method. The table returned\n-    // by getPipes() is expected to contain symbols with the corresponding transform method type.\n-    const pipe = this.query.getPipes().get(ast.name);\n-    if (!pipe) {\n-      this.diagnostics.push(createDiagnostic(refinedSpan(ast), Diagnostic.no_pipe_found, ast.name));\n-      return this.anyType;\n-    }\n-    const expType = this.getType(ast.exp);\n-    const signature =\n-        pipe.selectSignature([expType].concat(ast.args.map(arg => this.getType(arg))));\n-    if (!signature) {\n-      this.diagnostics.push(\n-          createDiagnostic(refinedSpan(ast), Diagnostic.unable_to_resolve_signature, ast.name));\n-      return this.anyType;\n-    }\n-    return signature.result;\n-  }\n-\n-  visitPrefixNot(ast: PrefixNot) {\n-    // If we are producing diagnostics, visit the children\n-    ast.expression.visit(this);\n-    // The type of a prefix ! is always boolean.\n-    return this.query.getBuiltinType(BuiltinType.Boolean);\n-  }\n-\n-  visitNonNullAssert(ast: NonNullAssert) {\n-    const expressionType = this.getType(ast.expression);\n-    return this.query.getNonNullableType(expressionType);\n-  }\n-\n-  visitPropertyRead(ast: PropertyRead) {\n-    return this.resolvePropertyRead(this.getType(ast.receiver), ast);\n-  }\n-\n-  visitPropertyWrite(ast: PropertyWrite) {\n-    // The type of a write is the type of the value being written.\n-    return this.getType(ast.value);\n-  }\n-\n-  visitQuote(_ast: Quote) {\n-    // The type of a quoted expression is any.\n-    return this.query.getBuiltinType(BuiltinType.Any);\n-  }\n-\n-  visitSafePropertyRead(ast: SafePropertyRead) {\n-    return this.resolvePropertyRead(this.query.getNonNullableType(this.getType(ast.receiver)), ast);\n-  }\n-\n-  visitSafeKeyedRead(ast: SafeKeyedRead): Symbol {\n-    const targetType = this.query.getNonNullableType(this.getType(ast.receiver));\n-    const keyType = this.getType(ast.key);\n-    const result = targetType.indexed(\n-        keyType, ast.key instanceof LiteralPrimitive ? ast.key.value : undefined);\n-    return result || this.anyType;\n-  }\n-\n-  visitCall(ast: Call) {\n-    if (ast.receiver instanceof Call) {\n-      // The type of a function call is the return type of the selected signature.\n-      // The signature is selected based on the types of the arguments. Angular doesn't\n-      // support contextual typing of arguments so this is simpler than TypeScript's\n-      // version.\n-      const args = ast.args.map(arg => this.getType(arg));\n-      const target = this.getType(ast.receiver);\n-      if (!target || !target.callable) {\n-        this.diagnostics.push(createDiagnostic(\n-            refinedSpan(ast), Diagnostic.call_target_not_callable, this.sourceOf(ast.receiver),\n-            target.name));\n-        return this.anyType;\n-      }\n-      const signature = target.selectSignature(args);\n-      if (signature) {\n-        return signature.result;\n-      }\n-      // TODO: Consider a better error message here. See `typescript_symbols#selectSignature` for\n-      // more details.\n-      this.diagnostics.push(createDiagnostic(\n-          refinedSpan(ast), Diagnostic.unable_to_resolve_compatible_call_signature));\n-      return this.anyType;\n-    }\n-\n-    if (ast.receiver instanceof PropertyRead || ast.receiver instanceof SafePropertyRead) {\n-      const receiver = ast.receiver;\n-      const receiverType = receiver instanceof SafePropertyRead ?\n-          this.query.getNonNullableType(this.getType(receiver.receiver)) :\n-          this.getType(receiver.receiver);\n-\n-      if (this.isAny(receiverType)) {\n-        return this.anyType;\n-      }\n-      const methodType = this.resolvePropertyRead(receiverType, receiver);\n-      if (!methodType) {\n-        this.diagnostics.push(createDiagnostic(\n-            refinedSpan(receiver), Diagnostic.could_not_resolve_type, receiver.name));\n-        return this.anyType;\n-      }\n-      if (this.isAny(methodType)) {\n-        return this.anyType;\n-      }\n-      if (!methodType.callable) {\n-        this.diagnostics.push(createDiagnostic(\n-            refinedSpan(receiver), Diagnostic.identifier_not_callable, receiver.name));\n-        return this.anyType;\n-      }\n-      const signature = methodType.selectSignature(ast.args.map(arg => this.getType(arg)));\n-      if (!signature) {\n-        this.diagnostics.push(createDiagnostic(\n-            refinedSpan(receiver), Diagnostic.unable_to_resolve_signature, receiver.name));\n-        return this.anyType;\n-      }\n-      return signature.result;\n-    }\n-\n-    return this.anyType;\n-  }\n-\n-  /**\n-   * Gets the source of an expession AST.\n-   * The AST's sourceSpan is relative to the start of the template source code, which is contained\n-   * at this.source.\n-   */\n-  private sourceOf(ast: AST): string {\n-    return this.source.substring(ast.sourceSpan.start, ast.sourceSpan.end);\n-  }\n-\n-  private _anyType: Symbol|undefined;\n-  private get anyType(): Symbol {\n-    let result = this._anyType;\n-    if (!result) {\n-      result = this._anyType = this.query.getBuiltinType(BuiltinType.Any);\n-    }\n-    return result;\n-  }\n-\n-  private _undefinedType: Symbol|undefined;\n-  private get undefinedType(): Symbol {\n-    let result = this._undefinedType;\n-    if (!result) {\n-      result = this._undefinedType = this.query.getBuiltinType(BuiltinType.Undefined);\n-    }\n-    return result;\n-  }\n-\n-  private resolvePropertyRead(receiverType: Symbol, ast: SafePropertyRead|PropertyRead) {\n-    if (this.isAny(receiverType)) {\n-      return this.anyType;\n-    }\n-    // The type of a property read is the seelcted member's type.\n-    const member = receiverType.members().get(ast.name);\n-    if (!member) {\n-      if (receiverType.name === '$implicit') {\n-        this.diagnostics.push(createDiagnostic(\n-            refinedSpan(ast), Diagnostic.identifier_not_defined_in_app_context, ast.name));\n-      } else if (receiverType.nullable && ast.receiver instanceof PropertyRead) {\n-        const receiver = ast.receiver.name;\n-        this.diagnostics.push(createDiagnostic(\n-            refinedSpan(ast), Diagnostic.identifier_possibly_undefined, receiver,\n-            `${receiver}?.${ast.name}`, `${receiver}!.${ast.name}`));\n-      } else {\n-        this.diagnostics.push(createDiagnostic(\n-            refinedSpan(ast), Diagnostic.identifier_not_defined_on_receiver, ast.name,\n-            receiverType.name));\n-      }\n-      return this.anyType;\n-    }\n-    if (!member.public) {\n-      const container =\n-          receiverType.name === '$implicit' ? 'the component' : `'${receiverType.name}'`;\n-      this.diagnostics.push(createDiagnostic(\n-          refinedSpan(ast), Diagnostic.identifier_is_private, ast.name, container));\n-    }\n-    return member.type;\n-  }\n-\n-  private isAny(symbol: Symbol): boolean {\n-    return !symbol || this.query.getTypeKind(symbol) === BuiltinType.Any ||\n-        (!!symbol.type && this.isAny(symbol.type));\n-  }\n-}\n-\n-function refinedSpan(ast: AST): ng.Span {\n-  // nameSpan is an absolute span, but the spans returned by the expression visitor are expected to\n-  // be relative to the start of the expression.\n-  // TODO: migrate to only using absolute spans\n-  const absoluteOffset = ast.sourceSpan.start - ast.span.start;\n-  if (ast instanceof ASTWithName) {\n-    return offsetSpan(ast.nameSpan, -absoluteOffset);\n-  }\n-  return offsetSpan(ast.sourceSpan, -absoluteOffset);\n-}"
        },
        {
            "sha": "6cddeeb3c3dcac398663130287655678fb9e35be",
            "filename": "packages/language-service/src/expressions.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 203,
            "changes": 203,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fexpressions.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fexpressions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Fexpressions.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,203 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {AST, AstPath as AstPathBase, ASTWithName, ASTWithSource, Interpolation, RecursiveAstVisitor} from '@angular/compiler';\n-\n-import {AstType} from './expression_type';\n-import {BuiltinType, Span, Symbol, SymbolTable, TemplateSource} from './types';\n-import {inSpan, isNarrower} from './utils';\n-\n-type AstPath = AstPathBase<AST>;\n-\n-function findAstAt(ast: AST, position: number, excludeEmpty: boolean = false): AstPath {\n-  const path: AST[] = [];\n-  const visitor = new class extends RecursiveAstVisitor {\n-    override visit(ast: AST) {\n-      if ((!excludeEmpty || ast.sourceSpan.start < ast.sourceSpan.end) &&\n-          inSpan(position, ast.sourceSpan)) {\n-        const isNotNarrower = path.length && !isNarrower(ast.span, path[path.length - 1].span);\n-        if (!isNotNarrower) {\n-          path.push(ast);\n-        }\n-        ast.visit(this);\n-      }\n-    }\n-  };\n-\n-  // We never care about the ASTWithSource node and its visit() method calls its ast's visit so\n-  // the visit() method above would never see it.\n-  if (ast instanceof ASTWithSource) {\n-    ast = ast.ast;\n-  }\n-\n-  // `Interpolation` is useless here except the `expressions` of it.\n-  if (ast instanceof Interpolation) {\n-    ast = ast.expressions.filter((_ast: AST) => inSpan(position, _ast.sourceSpan))[0];\n-  }\n-\n-  if (ast) {\n-    visitor.visit(ast);\n-  }\n-\n-  return new AstPathBase<AST>(path, position);\n-}\n-\n-export function getExpressionCompletions(\n-    scope: SymbolTable, ast: AST, position: number, templateInfo: TemplateSource): Symbol[]|\n-    undefined {\n-  const path = findAstAt(ast, position);\n-  if (path.empty) return undefined;\n-  const tail = path.tail!;\n-  let result: SymbolTable|undefined = scope;\n-\n-  function getType(ast: AST): Symbol {\n-    return new AstType(scope, templateInfo.query, {}, templateInfo.source).getType(ast);\n-  }\n-\n-  // If the completion request is in a not in a pipe or property access then the global scope\n-  // (that is the scope of the implicit receiver) is the right scope as the user is typing the\n-  // beginning of an expression.\n-  tail.visit({\n-    visitUnary(_ast) {},\n-    visitBinary(_ast) {},\n-    visitChain(_ast) {},\n-    visitConditional(_ast) {},\n-    visitCall(_ast) {},\n-    visitImplicitReceiver(_ast) {},\n-    visitThisReceiver(_ast) {},\n-    visitInterpolation(_ast) {\n-      result = undefined;\n-    },\n-    visitKeyedRead(_ast) {},\n-    visitSafeKeyedRead(_ast) {},\n-    visitKeyedWrite(_ast) {},\n-    visitLiteralArray(_ast) {},\n-    visitLiteralMap(_ast) {},\n-    visitLiteralPrimitive(ast) {\n-      // The type `LiteralPrimitive` include the `ERROR`, and it's wrapped as `string`.\n-      // packages/compiler/src/template_parser/binding_parser.ts#L308\n-      // So exclude the `ERROR` here.\n-      if (typeof ast.value === 'string' &&\n-          ast.value ===\n-              templateInfo.source.slice(ast.sourceSpan.start + 1, ast.sourceSpan.end - 1)) {\n-        result = undefined;\n-      }\n-    },\n-    visitPipe(ast) {\n-      if (position >= ast.exp.span.end &&\n-          (!ast.args || !ast.args.length || position < (<AST>ast.args[0]).span.start)) {\n-        // We are in a position a pipe name is expected.\n-        result = templateInfo.query.getPipes();\n-      }\n-    },\n-    visitPrefixNot(_ast) {},\n-    visitNonNullAssert(_ast) {},\n-    visitPropertyRead(ast) {\n-      const receiverType = getType(ast.receiver);\n-      result = receiverType ? receiverType.members() : scope;\n-    },\n-    visitPropertyWrite(ast) {\n-      const receiverType = getType(ast.receiver);\n-      result = receiverType ? receiverType.members() : scope;\n-    },\n-    visitQuote(_ast) {\n-      // For a quote, return the members of any (if there are any).\n-      result = templateInfo.query.getBuiltinType(BuiltinType.Any).members();\n-    },\n-    visitSafePropertyRead(ast) {\n-      const receiverType = getType(ast.receiver);\n-      result = receiverType ? receiverType.members() : scope;\n-    },\n-  });\n-\n-  return result && result.values();\n-}\n-\n-/**\n- * Retrieves the expression symbol at a particular position in a template.\n- *\n- * @param scope symbols in scope of the template\n- * @param ast template AST\n- * @param position absolute location in template to retrieve symbol at\n- * @param query type symbol query for the template scope\n- */\n-export function getExpressionSymbol(\n-    scope: SymbolTable, ast: AST, position: number,\n-    templateInfo: TemplateSource): {symbol: Symbol, span: Span}|undefined {\n-  const path = findAstAt(ast, position, /* excludeEmpty */ true);\n-  if (path.empty) return undefined;\n-  const tail = path.tail!;\n-\n-  function getType(ast: AST): Symbol {\n-    return new AstType(scope, templateInfo.query, {}, templateInfo.source).getType(ast);\n-  }\n-\n-  function spanFromName(ast: ASTWithName): Span {\n-    // `nameSpan` is an absolute span, but the span expected by the result of this method is\n-    // relative to the start of the expression.\n-    // TODO(ayazhafiz): migrate to only using absolute spans\n-    const offset = ast.sourceSpan.start - ast.span.start;\n-    return {\n-      start: ast.nameSpan.start - offset,\n-      end: ast.nameSpan.end - offset,\n-    };\n-  }\n-\n-  let symbol: Symbol|undefined = undefined;\n-  let span: Span|undefined = undefined;\n-\n-  // If the completion request is in a not in a pipe or property access then the global scope\n-  // (that is the scope of the implicit receiver) is the right scope as the user is typing the\n-  // beginning of an expression.\n-  tail.visit({\n-    visitUnary(_ast) {},\n-    visitBinary(_ast) {},\n-    visitChain(_ast) {},\n-    visitConditional(_ast) {},\n-    visitCall(_ast) {},\n-    visitImplicitReceiver(_ast) {},\n-    visitThisReceiver(_ast) {},\n-    visitInterpolation(_ast) {},\n-    visitKeyedRead(_ast) {},\n-    visitSafeKeyedRead(_ast) {},\n-    visitKeyedWrite(_ast) {},\n-    visitLiteralArray(_ast) {},\n-    visitLiteralMap(_ast) {},\n-    visitLiteralPrimitive(_ast) {},\n-    visitPipe(ast) {\n-      if (inSpan(position, ast.nameSpan, /* exclusive */ true)) {\n-        // We are in a position a pipe name is expected.\n-        const pipes = templateInfo.query.getPipes();\n-        symbol = pipes.get(ast.name);\n-        span = spanFromName(ast);\n-      }\n-    },\n-    visitPrefixNot(_ast) {},\n-    visitNonNullAssert(_ast) {},\n-    visitPropertyRead(ast) {\n-      const receiverType = getType(ast.receiver);\n-      symbol = receiverType && receiverType.members().get(ast.name);\n-      span = spanFromName(ast);\n-    },\n-    visitPropertyWrite(ast) {\n-      const receiverType = getType(ast.receiver);\n-      symbol = receiverType && receiverType.members().get(ast.name);\n-      span = spanFromName(ast);\n-    },\n-    visitQuote(_ast) {},\n-    visitSafePropertyRead(ast) {\n-      const receiverType = getType(ast.receiver);\n-      symbol = receiverType && receiverType.members().get(ast.name);\n-      span = spanFromName(ast);\n-    },\n-  });\n-\n-  if (symbol && span) {\n-    return {symbol, span};\n-  }\n-}"
        },
        {
            "sha": "74f00af354392084391fbee8ce9b5daa12e44838",
            "filename": "packages/language-service/src/global_symbols.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 68,
            "changes": 68,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fglobal_symbols.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fglobal_symbols.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Fglobal_symbols.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,68 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as ng from '../src/types';\n-\n-export const EMPTY_SYMBOL_TABLE: Readonly<ng.SymbolTable> = {\n-  size: 0,\n-  get: () => undefined,\n-  has: () => false,\n-  values: () => [],\n-};\n-\n-/**\n- * A factory function that returns a symbol table that contains all global symbols\n- * available in an interpolation scope in a template.\n- * This function creates the table the first time it is called, and return a cached\n- * value for all subsequent calls.\n- */\n-export const createGlobalSymbolTable: (query: ng.SymbolQuery) => ng.SymbolTable = (function() {\n-  let GLOBAL_SYMBOL_TABLE: ng.SymbolTable|undefined;\n-  return function(query: ng.SymbolQuery) {\n-    if (GLOBAL_SYMBOL_TABLE) {\n-      return GLOBAL_SYMBOL_TABLE;\n-    }\n-    GLOBAL_SYMBOL_TABLE = query.createSymbolTable([\n-      // The `$any()` method casts the type of an expression to `any`.\n-      // https://angular.io/guide/template-syntax#the-any-type-cast-function\n-      {\n-        name: '$any',\n-        kind: 'method',\n-        type: {\n-          name: '$any',\n-          kind: 'method',\n-          type: undefined,\n-          language: 'typescript',\n-          container: undefined,\n-          public: true,\n-          callable: true,\n-          definition: undefined,\n-          nullable: false,\n-          documentation: [{\n-            kind: 'text',\n-            text: 'function to cast an expression to the `any` type',\n-          }],\n-          members: () => EMPTY_SYMBOL_TABLE,\n-          signatures: () => [],\n-          selectSignature(args: ng.Symbol[]) {\n-            if (args.length !== 1) {\n-              return;\n-            }\n-            return {\n-              arguments: EMPTY_SYMBOL_TABLE,  // not used\n-              result: query.getBuiltinType(ng.BuiltinType.Any),\n-            };\n-          },\n-          indexed: () => undefined,\n-          typeArguments: () => undefined,\n-        },\n-      },\n-    ]);\n-    return GLOBAL_SYMBOL_TABLE;\n-  };\n-})();"
        },
        {
            "sha": "e24db4be872c698b7d7106ed1c076aa70c2e71c6",
            "filename": "packages/language-service/src/hover.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 120,
            "changes": 120,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fhover.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fhover.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Fhover.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,120 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {NgAnalyzedModules} from '@angular/compiler';\n-import ts from 'typescript';\n-\n-import {locateSymbols} from './locate_symbol';\n-import * as ng from './types';\n-import {inSpan} from './utils';\n-\n-/**\n- * Traverse the template AST and look for the symbol located at `position`, then\n- * return the corresponding quick info.\n- * @param info template AST\n- * @param position location of the symbol\n- * @param analyzedModules all NgModules in the program.\n- */\n-export function getTemplateHover(\n-    info: ng.AstResult, position: number, analyzedModules: NgAnalyzedModules): ts.QuickInfo|\n-    undefined {\n-  const symbolInfo = locateSymbols(info, position)[0];\n-  if (!symbolInfo) {\n-    return;\n-  }\n-  const {symbol, span, staticSymbol} = symbolInfo;\n-\n-  // The container is either the symbol's container (for example, 'AppComponent'\n-  // is the container of the symbol 'title' in its template) or the NgModule\n-  // that the directive belongs to (the container of AppComponent is AppModule).\n-  let containerName: string|undefined = symbol.container?.name;\n-  if (!containerName && staticSymbol) {\n-    // If there is a static symbol then the target is a directive.\n-    const ngModule = analyzedModules.ngModuleByPipeOrDirective.get(staticSymbol);\n-    containerName = ngModule?.type.reference.name;\n-  }\n-\n-  return createQuickInfo(\n-      symbol.name, symbol.kind, span, containerName, symbol.type?.name, symbol.documentation);\n-}\n-\n-/**\n- * Get quick info for Angular semantic entities in TypeScript files, like Directives.\n- * @param position location of the symbol in the source file\n- * @param declarations All Directive-like declarations in the source file.\n- * @param analyzedModules all NgModules in the program.\n- */\n-export function getTsHover(\n-    position: number, declarations: ng.Declaration[],\n-    analyzedModules: NgAnalyzedModules): ts.QuickInfo|undefined {\n-  for (const {declarationSpan, metadata} of declarations) {\n-    if (inSpan(position, declarationSpan)) {\n-      const staticSymbol: ng.StaticSymbol = metadata.type.reference;\n-      const directiveName = staticSymbol.name;\n-      const kind = metadata.isComponent ? 'component' : 'directive';\n-      const textSpan = ts.createTextSpanFromBounds(declarationSpan.start, declarationSpan.end);\n-      const ngModule = analyzedModules.ngModuleByPipeOrDirective.get(staticSymbol);\n-      const moduleName = ngModule?.type.reference.name;\n-      return createQuickInfo(\n-          directiveName, kind, textSpan, moduleName, ts.ScriptElementKind.classElement);\n-    }\n-  }\n-}\n-\n-\n-\n-// Reverse mappings of enum would generate strings\n-const ALIAS_NAME = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.aliasName];\n-const SYMBOL_INTERFACE = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.interfaceName];\n-const SYMBOL_PUNC = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.punctuation];\n-const SYMBOL_SPACE = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.space];\n-const SYMBOL_TEXT = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.text];\n-\n-/**\n- * Construct a QuickInfo object taking into account its container and type.\n- * @param name Name of the QuickInfo target\n- * @param kind component, directive, pipe, etc.\n- * @param textSpan span of the target\n- * @param containerName either the Symbol's container or the NgModule that contains the directive\n- * @param type user-friendly name of the type\n- * @param documentation docstring or comment\n- */\n-function createQuickInfo(\n-    name: string, kind: string, textSpan: ts.TextSpan, containerName?: string, type?: string,\n-    documentation?: ts.SymbolDisplayPart[]): ts.QuickInfo {\n-  const containerDisplayParts = containerName ?\n-      [\n-        {text: containerName, kind: SYMBOL_INTERFACE},\n-        {text: '.', kind: SYMBOL_PUNC},\n-      ] :\n-      [];\n-\n-  const typeDisplayParts = type ?\n-      [\n-        {text: ':', kind: SYMBOL_PUNC},\n-        {text: ' ', kind: SYMBOL_SPACE},\n-        {text: type, kind: SYMBOL_INTERFACE},\n-      ] :\n-      [];\n-\n-  return {\n-    kind: kind as ts.ScriptElementKind,\n-    kindModifiers: ts.ScriptElementKindModifier.none,\n-    textSpan: textSpan,\n-    displayParts: [\n-      {text: '(', kind: SYMBOL_PUNC},\n-      {text: kind, kind: SYMBOL_TEXT},\n-      {text: ')', kind: SYMBOL_PUNC},\n-      {text: ' ', kind: SYMBOL_SPACE},\n-      ...containerDisplayParts,\n-      {text: name, kind: SYMBOL_INTERFACE},\n-      ...typeDisplayParts,\n-    ],\n-    documentation,\n-  };\n-}"
        },
        {
            "sha": "4ee1365cb41f7d964527d3a45e6afacab430f0fc",
            "filename": "packages/language-service/src/html_info.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 455,
            "changes": 455,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fhtml_info.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fhtml_info.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Fhtml_info.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,455 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-// Information about the HTML DOM elements\n-\n-// This section defines the HTML elements and attribute surface of HTML 4\n-// which is derived from https://www.w3.org/TR/html4/strict.dtd\n-type attrType = string|string[];\n-type hash<T> = {\n-  [name: string]: T\n-};\n-\n-const values: attrType[] = [\n-  'ID',\n-  'CDATA',\n-  'NAME',\n-  ['ltr', 'rtl'],\n-  ['rect', 'circle', 'poly', 'default'],\n-  'NUMBER',\n-  ['nohref'],\n-  ['ismap'],\n-  ['declare'],\n-  ['DATA', 'REF', 'OBJECT'],\n-  ['GET', 'POST'],\n-  'IDREF',\n-  ['TEXT', 'PASSWORD', 'CHECKBOX', 'RADIO', 'SUBMIT', 'RESET', 'FILE', 'HIDDEN', 'IMAGE', 'BUTTON'],\n-  ['checked'],\n-  ['disabled'],\n-  ['readonly'],\n-  ['multiple'],\n-  ['selected'],\n-  ['button', 'submit', 'reset'],\n-  ['void', 'above', 'below', 'hsides', 'lhs', 'rhs', 'vsides', 'box', 'border'],\n-  ['none', 'groups', 'rows', 'cols', 'all'],\n-  ['left', 'center', 'right', 'justify', 'char'],\n-  ['top', 'middle', 'bottom', 'baseline'],\n-  'IDREFS',\n-  ['row', 'col', 'rowgroup', 'colgroup'],\n-  ['defer']\n-];\n-\n-const groups: hash<number>[] = [\n-  {id: 0},\n-  {\n-    onclick: 1,\n-    ondblclick: 1,\n-    onmousedown: 1,\n-    onmouseup: 1,\n-    onmouseover: 1,\n-    onmousemove: 1,\n-    onmouseout: 1,\n-    onkeypress: 1,\n-    onkeydown: 1,\n-    onkeyup: 1\n-  },\n-  {lang: 2, dir: 3},\n-  {onload: 1, onunload: 1},\n-  {name: 1},\n-  {href: 1},\n-  {type: 1},\n-  {alt: 1},\n-  {tabindex: 5},\n-  {media: 1},\n-  {nohref: 6},\n-  {usemap: 1},\n-  {src: 1},\n-  {onfocus: 1, onblur: 1},\n-  {charset: 1},\n-  {declare: 8, classid: 1, codebase: 1, data: 1, codetype: 1, archive: 1, standby: 1},\n-  {title: 1},\n-  {value: 1},\n-  {cite: 1},\n-  {datetime: 1},\n-  {accept: 1},\n-  {shape: 4, coords: 1},\n-  { for: 11\n-  },\n-  {action: 1, method: 10, enctype: 1, onsubmit: 1, onreset: 1, 'accept-charset': 1},\n-  {valuetype: 9},\n-  {longdesc: 1},\n-  {width: 1},\n-  {disabled: 14},\n-  {readonly: 15, onselect: 1},\n-  {accesskey: 1},\n-  {size: 5, multiple: 16},\n-  {onchange: 1},\n-  {label: 1},\n-  {selected: 17},\n-  {type: 12, checked: 13, size: 1, maxlength: 5},\n-  {rows: 5, cols: 5},\n-  {type: 18},\n-  {height: 1},\n-  {summary: 1, border: 1, frame: 19, rules: 20, cellspacing: 1, cellpadding: 1, datapagesize: 1},\n-  {align: 21, char: 1, charoff: 1, valign: 22},\n-  {span: 5},\n-  {abbr: 1, axis: 1, headers: 23, scope: 24, rowspan: 5, colspan: 5},\n-  {profile: 1},\n-  {'http-equiv': 2, name: 2, content: 1, scheme: 1},\n-  {class: 1, style: 1},\n-  {hreflang: 2, rel: 1, rev: 1},\n-  {ismap: 7},\n-  {\n-    defer: 25, event: 1, for: 1\n-  }\n-];\n-\n-const elements: {[name: string]: number[]} = {\n-  TT: [0, 1, 2, 16, 44],\n-  I: [0, 1, 2, 16, 44],\n-  B: [0, 1, 2, 16, 44],\n-  BIG: [0, 1, 2, 16, 44],\n-  SMALL: [0, 1, 2, 16, 44],\n-  EM: [0, 1, 2, 16, 44],\n-  STRONG: [0, 1, 2, 16, 44],\n-  DFN: [0, 1, 2, 16, 44],\n-  CODE: [0, 1, 2, 16, 44],\n-  SAMP: [0, 1, 2, 16, 44],\n-  KBD: [0, 1, 2, 16, 44],\n-  VAR: [0, 1, 2, 16, 44],\n-  CITE: [0, 1, 2, 16, 44],\n-  ABBR: [0, 1, 2, 16, 44],\n-  ACRONYM: [0, 1, 2, 16, 44],\n-  SUB: [0, 1, 2, 16, 44],\n-  SUP: [0, 1, 2, 16, 44],\n-  SPAN: [0, 1, 2, 16, 44],\n-  BDO: [0, 2, 16, 44],\n-  BR: [0, 16, 44],\n-  BODY: [0, 1, 2, 3, 16, 44],\n-  ADDRESS: [0, 1, 2, 16, 44],\n-  DIV: [0, 1, 2, 16, 44],\n-  A: [0, 1, 2, 4, 5, 6, 8, 13, 14, 16, 21, 29, 44, 45],\n-  MAP: [0, 1, 2, 4, 16, 44],\n-  AREA: [0, 1, 2, 5, 7, 8, 10, 13, 16, 21, 29, 44],\n-  LINK: [0, 1, 2, 5, 6, 9, 14, 16, 44, 45],\n-  IMG: [0, 1, 2, 4, 7, 11, 12, 16, 25, 26, 37, 44, 46],\n-  OBJECT: [0, 1, 2, 4, 6, 8, 11, 15, 16, 26, 37, 44],\n-  PARAM: [0, 4, 6, 17, 24],\n-  HR: [0, 1, 2, 16, 44],\n-  P: [0, 1, 2, 16, 44],\n-  H1: [0, 1, 2, 16, 44],\n-  H2: [0, 1, 2, 16, 44],\n-  H3: [0, 1, 2, 16, 44],\n-  H4: [0, 1, 2, 16, 44],\n-  H5: [0, 1, 2, 16, 44],\n-  H6: [0, 1, 2, 16, 44],\n-  PRE: [0, 1, 2, 16, 44],\n-  Q: [0, 1, 2, 16, 18, 44],\n-  BLOCKQUOTE: [0, 1, 2, 16, 18, 44],\n-  INS: [0, 1, 2, 16, 18, 19, 44],\n-  DEL: [0, 1, 2, 16, 18, 19, 44],\n-  DL: [0, 1, 2, 16, 44],\n-  DT: [0, 1, 2, 16, 44],\n-  DD: [0, 1, 2, 16, 44],\n-  OL: [0, 1, 2, 16, 44],\n-  UL: [0, 1, 2, 16, 44],\n-  LI: [0, 1, 2, 16, 44],\n-  FORM: [0, 1, 2, 4, 16, 20, 23, 44],\n-  LABEL: [0, 1, 2, 13, 16, 22, 29, 44],\n-  INPUT: [0, 1, 2, 4, 7, 8, 11, 12, 13, 16, 17, 20, 27, 28, 29, 31, 34, 44, 46],\n-  SELECT: [0, 1, 2, 4, 8, 13, 16, 27, 30, 31, 44],\n-  OPTGROUP: [0, 1, 2, 16, 27, 32, 44],\n-  OPTION: [0, 1, 2, 16, 17, 27, 32, 33, 44],\n-  TEXTAREA: [0, 1, 2, 4, 8, 13, 16, 27, 28, 29, 31, 35, 44],\n-  FIELDSET: [0, 1, 2, 16, 44],\n-  LEGEND: [0, 1, 2, 16, 29, 44],\n-  BUTTON: [0, 1, 2, 4, 8, 13, 16, 17, 27, 29, 36, 44],\n-  TABLE: [0, 1, 2, 16, 26, 38, 44],\n-  CAPTION: [0, 1, 2, 16, 44],\n-  COLGROUP: [0, 1, 2, 16, 26, 39, 40, 44],\n-  COL: [0, 1, 2, 16, 26, 39, 40, 44],\n-  THEAD: [0, 1, 2, 16, 39, 44],\n-  TBODY: [0, 1, 2, 16, 39, 44],\n-  TFOOT: [0, 1, 2, 16, 39, 44],\n-  TR: [0, 1, 2, 16, 39, 44],\n-  TH: [0, 1, 2, 16, 39, 41, 44],\n-  TD: [0, 1, 2, 16, 39, 41, 44],\n-  HEAD: [2, 42],\n-  TITLE: [2],\n-  BASE: [5],\n-  META: [2, 43],\n-  STYLE: [2, 6, 9, 16],\n-  SCRIPT: [6, 12, 14, 47],\n-  NOSCRIPT: [0, 1, 2, 16, 44],\n-  HTML: [2]\n-};\n-\n-const defaultAttributes = [0, 1, 2, 4];\n-\n-export function elementNames(): string[] {\n-  return Object.keys(elements).sort().map(v => v.toLowerCase());\n-}\n-\n-function compose(indexes: number[]|undefined): hash<attrType> {\n-  const result: hash<attrType> = {};\n-  if (indexes) {\n-    for (let index of indexes) {\n-      const group = groups[index];\n-      for (let name in group)\n-        if (group.hasOwnProperty(name)) result[name] = values[group[name]];\n-    }\n-  }\n-  return result;\n-}\n-\n-export function attributeNames(element: string): string[] {\n-  return Object.keys(compose(elements[element.toUpperCase()] || defaultAttributes)).sort();\n-}\n-\n-export function attributeType(element: string, attribute: string): string|string[]|undefined {\n-  return compose(elements[element.toUpperCase()] || defaultAttributes)[attribute.toLowerCase()];\n-}\n-\n-// This section is describes the DOM property surface of a DOM element and is derivgulp formated\n-// from\n-// from the SCHEMA strings from the security context information. SCHEMA is copied here because\n-// it would be an unnecessary risk to allow this array to be imported from the security context\n-// schema registry.\n-const SCHEMA: string[] = [\n-  '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot' +\n-      /* added manually to avoid breaking changes */\n-      ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored',\n-  '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n-  'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n-  'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume',\n-  ':svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',\n-  ':svg:graphics^:svg:|',\n-  ':svg:animation^:svg:|*begin,*end,*repeat',\n-  ':svg:geometry^:svg:|',\n-  ':svg:componentTransferFunction^:svg:|',\n-  ':svg:gradient^:svg:|',\n-  ':svg:textContent^:svg:graphics|',\n-  ':svg:textPositioning^:svg:textContent|',\n-  'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',\n-  'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username',\n-  'audio^media|',\n-  'br^[HTMLElement]|clear',\n-  'base^[HTMLElement]|href,target',\n-  'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',\n-  'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',\n-  'canvas^[HTMLElement]|#height,#width',\n-  'content^[HTMLElement]|select',\n-  'dl^[HTMLElement]|!compact',\n-  'datalist^[HTMLElement]|',\n-  'details^[HTMLElement]|!open',\n-  'dialog^[HTMLElement]|!open,returnValue',\n-  'dir^[HTMLElement]|!compact',\n-  'div^[HTMLElement]|align',\n-  'embed^[HTMLElement]|align,height,name,src,type,width',\n-  'fieldset^[HTMLElement]|!disabled,name',\n-  'font^[HTMLElement]|color,face,size',\n-  'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',\n-  'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',\n-  'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',\n-  'hr^[HTMLElement]|align,color,!noShade,size,width',\n-  'head^[HTMLElement]|',\n-  'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',\n-  'html^[HTMLElement]|version',\n-  'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',\n-  'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',\n-  'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',\n-  'li^[HTMLElement]|type,#value',\n-  'label^[HTMLElement]|htmlFor',\n-  'legend^[HTMLElement]|align',\n-  'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type',\n-  'map^[HTMLElement]|name',\n-  'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',\n-  'menu^[HTMLElement]|!compact',\n-  'meta^[HTMLElement]|content,httpEquiv,name,scheme',\n-  'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',\n-  'ins,del^[HTMLElement]|cite,dateTime',\n-  'ol^[HTMLElement]|!compact,!reversed,#start,type',\n-  'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',\n-  'optgroup^[HTMLElement]|!disabled,label',\n-  'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',\n-  'output^[HTMLElement]|defaultValue,%htmlFor,name,value',\n-  'p^[HTMLElement]|align',\n-  'param^[HTMLElement]|name,type,value,valueType',\n-  'picture^[HTMLElement]|',\n-  'pre^[HTMLElement]|#width',\n-  'progress^[HTMLElement]|#max,#value',\n-  'q,blockquote,cite^[HTMLElement]|',\n-  'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',\n-  'select^[HTMLElement]|autocomplete,!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',\n-  'shadow^[HTMLElement]|',\n-  'slot^[HTMLElement]|name',\n-  'source^[HTMLElement]|media,sizes,src,srcset,type',\n-  'span^[HTMLElement]|',\n-  'style^[HTMLElement]|!disabled,media,type',\n-  'caption^[HTMLElement]|align',\n-  'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',\n-  'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',\n-  'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',\n-  'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',\n-  'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',\n-  'template^[HTMLElement]|',\n-  'textarea^[HTMLElement]|autocapitalize,autocomplete,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',\n-  'title^[HTMLElement]|text',\n-  'track^[HTMLElement]|!default,kind,label,src,srclang',\n-  'ul^[HTMLElement]|!compact,type',\n-  'unknown^[HTMLElement]|',\n-  'video^media|#height,poster,#width',\n-  ':svg:a^:svg:graphics|',\n-  ':svg:animate^:svg:animation|',\n-  ':svg:animateMotion^:svg:animation|',\n-  ':svg:animateTransform^:svg:animation|',\n-  ':svg:circle^:svg:geometry|',\n-  ':svg:clipPath^:svg:graphics|',\n-  ':svg:defs^:svg:graphics|',\n-  ':svg:desc^:svg:|',\n-  ':svg:discard^:svg:|',\n-  ':svg:ellipse^:svg:geometry|',\n-  ':svg:feBlend^:svg:|',\n-  ':svg:feColorMatrix^:svg:|',\n-  ':svg:feComponentTransfer^:svg:|',\n-  ':svg:feComposite^:svg:|',\n-  ':svg:feConvolveMatrix^:svg:|',\n-  ':svg:feDiffuseLighting^:svg:|',\n-  ':svg:feDisplacementMap^:svg:|',\n-  ':svg:feDistantLight^:svg:|',\n-  ':svg:feDropShadow^:svg:|',\n-  ':svg:feFlood^:svg:|',\n-  ':svg:feFuncA^:svg:componentTransferFunction|',\n-  ':svg:feFuncB^:svg:componentTransferFunction|',\n-  ':svg:feFuncG^:svg:componentTransferFunction|',\n-  ':svg:feFuncR^:svg:componentTransferFunction|',\n-  ':svg:feGaussianBlur^:svg:|',\n-  ':svg:feImage^:svg:|',\n-  ':svg:feMerge^:svg:|',\n-  ':svg:feMergeNode^:svg:|',\n-  ':svg:feMorphology^:svg:|',\n-  ':svg:feOffset^:svg:|',\n-  ':svg:fePointLight^:svg:|',\n-  ':svg:feSpecularLighting^:svg:|',\n-  ':svg:feSpotLight^:svg:|',\n-  ':svg:feTile^:svg:|',\n-  ':svg:feTurbulence^:svg:|',\n-  ':svg:filter^:svg:|',\n-  ':svg:foreignObject^:svg:graphics|',\n-  ':svg:g^:svg:graphics|',\n-  ':svg:image^:svg:graphics|',\n-  ':svg:line^:svg:geometry|',\n-  ':svg:linearGradient^:svg:gradient|',\n-  ':svg:mpath^:svg:|',\n-  ':svg:marker^:svg:|',\n-  ':svg:mask^:svg:|',\n-  ':svg:metadata^:svg:|',\n-  ':svg:path^:svg:geometry|',\n-  ':svg:pattern^:svg:|',\n-  ':svg:polygon^:svg:geometry|',\n-  ':svg:polyline^:svg:geometry|',\n-  ':svg:radialGradient^:svg:gradient|',\n-  ':svg:rect^:svg:geometry|',\n-  ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',\n-  ':svg:script^:svg:|type',\n-  ':svg:set^:svg:animation|',\n-  ':svg:stop^:svg:|',\n-  ':svg:style^:svg:|!disabled,media,title,type',\n-  ':svg:switch^:svg:graphics|',\n-  ':svg:symbol^:svg:|',\n-  ':svg:tspan^:svg:textPositioning|',\n-  ':svg:text^:svg:textPositioning|',\n-  ':svg:textPath^:svg:textContent|',\n-  ':svg:title^:svg:|',\n-  ':svg:use^:svg:graphics|',\n-  ':svg:view^:svg:|#zoomAndPan',\n-  'data^[HTMLElement]|value',\n-  'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name',\n-  'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',\n-  'summary^[HTMLElement]|',\n-  'time^[HTMLElement]|dateTime',\n-  ':svg:cursor^:svg:|',\n-];\n-\n-const EVENT = 'event';\n-const BOOLEAN = 'boolean';\n-const NUMBER = 'number';\n-const STRING = 'string';\n-const OBJECT = 'object';\n-\n-export class SchemaInformation {\n-  schema = <{[element: string]: {[property: string]: string}}>{};\n-\n-  constructor() {\n-    SCHEMA.forEach(encodedType => {\n-      const parts = encodedType.split('|');\n-      const properties = parts[1].split(',');\n-      const typeParts = (parts[0] + '^').split('^');\n-      const typeName = typeParts[0];\n-      const type = <{[property: string]: string}>{};\n-      typeName.split(',').forEach(tag => this.schema[tag.toLowerCase()] = type);\n-      const superName = typeParts[1];\n-      const superType = superName && this.schema[superName.toLowerCase()];\n-      if (superType) {\n-        for (const key in superType) {\n-          type[key] = superType[key];\n-        }\n-      }\n-      properties.forEach((property: string) => {\n-        if (property === '') {\n-        } else if (property.startsWith('*')) {\n-          type[property.substring(1)] = EVENT;\n-        } else if (property.startsWith('!')) {\n-          type[property.substring(1)] = BOOLEAN;\n-        } else if (property.startsWith('#')) {\n-          type[property.substring(1)] = NUMBER;\n-        } else if (property.startsWith('%')) {\n-          type[property.substring(1)] = OBJECT;\n-        } else {\n-          type[property] = STRING;\n-        }\n-      });\n-    });\n-  }\n-\n-  allKnownElements(): string[] {\n-    return Object.keys(this.schema);\n-  }\n-\n-  eventsOf(elementName: string): string[] {\n-    const elementType = this.schema[elementName.toLowerCase()] || {};\n-    return Object.keys(elementType).filter(property => elementType[property] === EVENT);\n-  }\n-\n-  propertiesOf(elementName: string): string[] {\n-    const elementType = this.schema[elementName.toLowerCase()] || {};\n-    return Object.keys(elementType).filter(property => elementType[property] !== EVENT);\n-  }\n-\n-  typeOf(elementName: string, property: string): string {\n-    return (this.schema[elementName.toLowerCase()] || {})[property];\n-  }\n-\n-  private static _instance: SchemaInformation;\n-\n-  static get instance(): SchemaInformation {\n-    let result = SchemaInformation._instance;\n-    if (!result) {\n-      result = SchemaInformation._instance = new SchemaInformation();\n-    }\n-    return result;\n-  }\n-}\n-\n-export function eventNames(elementName: string): string[] {\n-  return SchemaInformation.instance.eventsOf(elementName);\n-}\n-\n-export function propertyNames(elementName: string): string[] {\n-  return SchemaInformation.instance.propertiesOf(elementName);\n-}"
        },
        {
            "sha": "b26f4994715d7e4b15b59871061ba05413f1d9f4",
            "filename": "packages/language-service/src/language_service.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 113,
            "changes": 113,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Flanguage_service.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Flanguage_service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Flanguage_service.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,113 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as tss from 'typescript/lib/tsserverlibrary';\n-\n-import {getTemplateCompletions} from './completions';\n-import {getDefinitionAndBoundSpan, getTsDefinitionAndBoundSpan} from './definitions';\n-import {getDeclarationDiagnostics, getTemplateDiagnostics, ngDiagnosticToTsDiagnostic} from './diagnostics';\n-import {getTemplateHover, getTsHover} from './hover';\n-import * as ng from './types';\n-import {TypeScriptServiceHost} from './typescript_host';\n-\n-/**\n- * Create an instance of an Angular `LanguageService`.\n- *\n- * @publicApi\n- */\n-export function createLanguageService(host: TypeScriptServiceHost) {\n-  return new LanguageServiceImpl(host);\n-}\n-\n-class LanguageServiceImpl implements ng.LanguageService {\n-  constructor(private readonly host: TypeScriptServiceHost) {}\n-\n-  getSemanticDiagnostics(fileName: string): tss.Diagnostic[] {\n-    const analyzedModules = this.host.getAnalyzedModules();  // same role as 'synchronizeHostData'\n-    const ngDiagnostics: ng.Diagnostic[] = [];\n-\n-    const templates = this.host.getTemplates(fileName);\n-    for (const template of templates) {\n-      const ast = this.host.getTemplateAst(template);\n-      if (ast) {\n-        ngDiagnostics.push(...getTemplateDiagnostics(ast));\n-      }\n-    }\n-\n-    const declarations = this.host.getDeclarations(fileName);\n-    ngDiagnostics.push(...getDeclarationDiagnostics(declarations, analyzedModules, this.host));\n-\n-    const sourceFile = fileName.endsWith('.ts') ? this.host.getSourceFile(fileName) : undefined;\n-    const tsDiagnostics = ngDiagnostics.map(d => ngDiagnosticToTsDiagnostic(d, sourceFile));\n-    return [...tss.sortAndDeduplicateDiagnostics(tsDiagnostics)];\n-  }\n-\n-  getCompletionsAtPosition(\n-      fileName: string, position: number,\n-      _options?: tss.GetCompletionsAtPositionOptions): tss.CompletionInfo|undefined {\n-    this.host.getAnalyzedModules();  // same role as 'synchronizeHostData'\n-    const ast = this.host.getTemplateAstAtPosition(fileName, position);\n-    if (!ast) {\n-      return;\n-    }\n-    const results = getTemplateCompletions(ast, position);\n-    if (!results || !results.length) {\n-      return;\n-    }\n-    return {\n-      isGlobalCompletion: false,\n-      isMemberCompletion: false,\n-      isNewIdentifierLocation: false,\n-      // Cast CompletionEntry.kind from ng.CompletionKind to ts.ScriptElementKind\n-      entries: results as unknown as ts.CompletionEntry[],\n-    };\n-  }\n-\n-  getDefinitionAndBoundSpan(fileName: string, position: number): tss.DefinitionInfoAndBoundSpan\n-      |undefined {\n-    this.host.getAnalyzedModules();  // same role as 'synchronizeHostData'\n-    const templateInfo = this.host.getTemplateAstAtPosition(fileName, position);\n-    if (templateInfo) {\n-      return getDefinitionAndBoundSpan(templateInfo, position);\n-    }\n-    // Attempt to get Angular-specific definitions in a TypeScript file, like templates defined\n-    // in a `templateUrl` property.\n-    if (fileName.endsWith('.ts')) {\n-      const sf = this.host.getSourceFile(fileName);\n-      if (sf) {\n-        return getTsDefinitionAndBoundSpan(sf, position, this.host.tsLsHost);\n-      }\n-    }\n-  }\n-\n-  getQuickInfoAtPosition(fileName: string, position: number): tss.QuickInfo|undefined {\n-    const analyzedModules = this.host.getAnalyzedModules();  // same role as 'synchronizeHostData'\n-    const templateInfo = this.host.getTemplateAstAtPosition(fileName, position);\n-    if (templateInfo) {\n-      return getTemplateHover(templateInfo, position, analyzedModules);\n-    }\n-\n-    // Attempt to get Angular-specific hover information in a TypeScript file, the NgModule a\n-    // directive belongs to.\n-    const declarations = this.host.getDeclarations(fileName);\n-    return getTsHover(position, declarations, analyzedModules);\n-  }\n-\n-  getReferencesAtPosition(fileName: string, position: number): tss.ReferenceEntry[]|undefined {\n-    const defAndSpan = this.getDefinitionAndBoundSpan(fileName, position);\n-    if (!defAndSpan?.definitions) {\n-      return;\n-    }\n-    const {definitions} = defAndSpan;\n-    const tsDef = definitions.find(def => def.fileName.endsWith('.ts'));\n-    if (!tsDef) {\n-      return;\n-    }\n-    return this.host.tsLS.getReferencesAtPosition(tsDef.fileName, tsDef.textSpan.start);\n-  }\n-}"
        },
        {
            "sha": "aa4d308b24f4bd331b1355c58baec68303319ed4",
            "filename": "packages/language-service/src/locate_symbol.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 369,
            "changes": 369,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Flocate_symbol.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Flocate_symbol.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Flocate_symbol.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,369 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {AST, Attribute, BoundDirectivePropertyAst, CssSelector, DirectiveAst, ElementAst, EmbeddedTemplateAst, RecursiveTemplateAstVisitor, SelectorMatcher, StaticSymbol, TemplateAst, TemplateAstPath, templateVisitAll, tokenReference, VariableBinding} from '@angular/compiler';\n-import * as tss from 'typescript/lib/tsserverlibrary';\n-\n-import {getExpressionScope} from './expression_diagnostics';\n-import {getExpressionSymbol} from './expressions';\n-import {AstResult, Definition, DirectiveKind, Span, Symbol, SymbolInfo} from './types';\n-import {diagnosticInfoFromTemplateInfo, findOutputBinding, findTemplateAstAt, getPathToNodeAtPosition, inSpan, invertMap, isNarrower, offsetSpan, spanOf} from './utils';\n-\n-/**\n- * Traverses a template AST and locates symbol(s) at a specified position.\n- * @param info template AST information set\n- * @param position location to locate symbols at\n- */\n-export function locateSymbols(info: AstResult, position: number): SymbolInfo[] {\n-  const templatePosition = position - info.template.span.start;\n-  // TODO: update `findTemplateAstAt` to use absolute positions.\n-  const path = findTemplateAstAt(info.templateAst, templatePosition);\n-  const attribute = findAttribute(info, position);\n-\n-  if (!path.tail) return [];\n-\n-  const narrowest = spanOf(path.tail);\n-  const toVisit: TemplateAst[] = [];\n-  for (let node: TemplateAst|undefined = path.tail;\n-       node && isNarrower(spanOf(node.sourceSpan), narrowest); node = path.parentOf(node)) {\n-    toVisit.push(node);\n-  }\n-\n-  // For the structural directive, only care about the last template AST.\n-  if (attribute?.name.startsWith('*')) {\n-    toVisit.splice(0, toVisit.length - 1);\n-  }\n-\n-  return toVisit.map(ast => locateSymbol(ast, path, info))\n-      .filter((sym): sym is SymbolInfo => sym !== undefined);\n-}\n-\n-/**\n- * Visits a template node and locates the symbol in that node at a path position.\n- * @param ast template AST node to visit\n- * @param path non-empty set of narrowing AST nodes at a position\n- * @param info template AST information set\n- */\n-function locateSymbol(ast: TemplateAst, path: TemplateAstPath, info: AstResult): SymbolInfo|\n-    undefined {\n-  const templatePosition = path.position;\n-  const position = templatePosition + info.template.span.start;\n-  let symbol: Symbol|undefined;\n-  let span: Span|undefined;\n-  let staticSymbol: StaticSymbol|undefined;\n-  const attributeValueSymbol = (ast: AST): boolean => {\n-    const attribute = findAttribute(info, position);\n-    if (attribute) {\n-      if (inSpan(templatePosition, spanOf(attribute.valueSpan))) {\n-        let result: {symbol: Symbol, span: Span}|undefined;\n-        if (attribute.name.startsWith('*')) {\n-          result = getSymbolInMicrosyntax(info, path, attribute);\n-        } else {\n-          const dinfo = diagnosticInfoFromTemplateInfo(info);\n-          const scope = getExpressionScope(dinfo, path);\n-          result = getExpressionSymbol(scope, ast, templatePosition, info.template);\n-        }\n-        if (result) {\n-          symbol = result.symbol;\n-          span = offsetSpan(result.span, attribute.valueSpan!.start.offset);\n-        }\n-        return true;\n-      }\n-    }\n-    return false;\n-  };\n-  ast.visit(\n-      {\n-        visitNgContent(_ast) {},\n-        visitEmbeddedTemplate(_ast) {},\n-        visitElement(ast) {\n-          const component = ast.directives.find(d => d.directive.isComponent);\n-          if (component) {\n-            // Need to cast because 'reference' is typed as any\n-            staticSymbol = component.directive.type.reference as StaticSymbol;\n-            symbol = info.template.query.getTypeSymbol(staticSymbol);\n-            symbol = symbol && new OverrideKindSymbol(symbol, DirectiveKind.COMPONENT);\n-            span = spanOf(ast);\n-          } else {\n-            // Find a directive that matches the element name\n-            const directive = ast.directives.find(\n-                d => d.directive.selector != null && d.directive.selector.indexOf(ast.name) >= 0);\n-            if (directive) {\n-              // Need to cast because 'reference' is typed as any\n-              staticSymbol = directive.directive.type.reference as StaticSymbol;\n-              symbol = info.template.query.getTypeSymbol(staticSymbol);\n-              symbol = symbol && new OverrideKindSymbol(symbol, DirectiveKind.DIRECTIVE);\n-              span = spanOf(ast);\n-            }\n-          }\n-        },\n-        visitReference(ast) {\n-          symbol = ast.value && info.template.query.getTypeSymbol(tokenReference(ast.value));\n-          span = spanOf(ast);\n-        },\n-        visitVariable(_ast) {},\n-        visitEvent(ast) {\n-          if (!attributeValueSymbol(ast.handler)) {\n-            symbol = findOutputBinding(ast, path, info.template.query);\n-            symbol = symbol && new OverrideKindSymbol(symbol, DirectiveKind.EVENT);\n-            span = spanOf(ast);\n-          }\n-        },\n-        visitElementProperty(ast) {\n-          attributeValueSymbol(ast.value);\n-        },\n-        visitAttr(ast) {\n-          const element = path.first(ElementAst);\n-          if (!element) return;\n-          // Create a mapping of all directives applied to the element from their selectors.\n-          const matcher = new SelectorMatcher<DirectiveAst>();\n-          for (const dir of element.directives) {\n-            if (!dir.directive.selector) continue;\n-            matcher.addSelectables(CssSelector.parse(dir.directive.selector), dir);\n-          }\n-\n-          // See if this attribute matches the selector of any directive on the element.\n-          const attributeSelector = `[${ast.name}=${ast.value}]`;\n-          const parsedAttribute = CssSelector.parse(attributeSelector);\n-          if (!parsedAttribute.length) return;\n-          matcher.match(parsedAttribute[0], (_, {directive}) => {\n-            // Need to cast because 'reference' is typed as any\n-            staticSymbol = directive.type.reference as StaticSymbol;\n-            symbol = info.template.query.getTypeSymbol(staticSymbol);\n-            symbol = symbol && new OverrideKindSymbol(symbol, DirectiveKind.DIRECTIVE);\n-            span = spanOf(ast);\n-          });\n-        },\n-        visitBoundText(ast) {\n-          const expressionPosition = templatePosition - ast.sourceSpan.start.offset;\n-          if (inSpan(expressionPosition, ast.value.span)) {\n-            const dinfo = diagnosticInfoFromTemplateInfo(info);\n-            const scope = getExpressionScope(dinfo, path);\n-            const result = getExpressionSymbol(scope, ast.value, templatePosition, info.template);\n-            if (result) {\n-              symbol = result.symbol;\n-              span = offsetSpan(result.span, ast.sourceSpan.start.offset);\n-            }\n-          }\n-        },\n-        visitText(_ast) {},\n-        visitDirective(ast) {\n-          // Need to cast because 'reference' is typed as any\n-          staticSymbol = ast.directive.type.reference as StaticSymbol;\n-          symbol = info.template.query.getTypeSymbol(staticSymbol);\n-          span = spanOf(ast);\n-        },\n-        visitDirectiveProperty(ast) {\n-          if (!attributeValueSymbol(ast.value)) {\n-            const directive = findParentOfBinding(info.templateAst, ast, templatePosition);\n-            const attribute = findAttribute(info, position);\n-            if (directive && attribute) {\n-              if (attribute.name.startsWith('*')) {\n-                const compileTypeSummary = directive.directive;\n-                symbol = info.template.query.getTypeSymbol(compileTypeSummary.type.reference);\n-                symbol = symbol && new OverrideKindSymbol(symbol, DirectiveKind.DIRECTIVE);\n-                // Use 'attribute.sourceSpan' instead of the directive's,\n-                // because the span of the directive is the whole opening tag of an element.\n-                span = spanOf(attribute.sourceSpan);\n-              } else {\n-                symbol = findInputBinding(info, ast.templateName, directive);\n-                span = spanOf(ast);\n-              }\n-            }\n-          }\n-        }\n-      },\n-      null);\n-  if (symbol && span) {\n-    const {start, end} = offsetSpan(span, info.template.span.start);\n-    return {\n-      symbol,\n-      span: tss.createTextSpanFromBounds(start, end),\n-      staticSymbol,\n-    };\n-  }\n-}\n-\n-// Get the symbol in microsyntax at template position.\n-function getSymbolInMicrosyntax(info: AstResult, path: TemplateAstPath, attribute: Attribute):\n-    {symbol: Symbol, span: Span}|undefined {\n-  if (!attribute.valueSpan) {\n-    return;\n-  }\n-  const absValueOffset = attribute.valueSpan.start.offset;\n-  let result: {symbol: Symbol, span: Span}|undefined;\n-  const {templateBindings} = info.expressionParser.parseTemplateBindings(\n-      attribute.name, attribute.value, attribute.sourceSpan.toString(),\n-      attribute.sourceSpan.start.offset, attribute.valueSpan.start.offset);\n-\n-  // Find the symbol that contains the position.\n-  for (const tb of templateBindings) {\n-    if (tb instanceof VariableBinding) {\n-      // TODO(kyliau): if binding is variable we should still look for the value\n-      // of the key. For example, \"let i=index\" => \"index\" should point to\n-      // NgForOfContext.index\n-      continue;\n-    }\n-    if (inSpan(path.position, tb.value?.ast.sourceSpan)) {\n-      const dinfo = diagnosticInfoFromTemplateInfo(info);\n-      const scope = getExpressionScope(dinfo, path);\n-      result = getExpressionSymbol(scope, tb.value!, path.position, info.template);\n-    } else if (inSpan(path.position, tb.sourceSpan)) {\n-      const template = path.first(EmbeddedTemplateAst);\n-      if (template) {\n-        // One element can only have one template binding.\n-        const directiveAst = template.directives[0];\n-        if (directiveAst) {\n-          const symbol = findInputBinding(info, tb.key.source.substring(1), directiveAst);\n-          if (symbol) {\n-            result = {\n-              symbol,\n-              // the span here has to be relative to the start of the template\n-              // value so deduct the absolute offset.\n-              // TODO(kyliau): Use absolute source span throughout completions.\n-              span: offsetSpan(tb.key.span, -absValueOffset),\n-            };\n-          }\n-        }\n-      }\n-    }\n-  }\n-  return result;\n-}\n-\n-function findAttribute(info: AstResult, position: number): Attribute|undefined {\n-  const templatePosition = position - info.template.span.start;\n-  const path = getPathToNodeAtPosition(info.htmlAst, templatePosition);\n-  return path.first(Attribute);\n-}\n-\n-// TODO: remove this function after the path includes 'DirectiveAst'.\n-// Find the directive that corresponds to the specified 'binding'\n-// at the specified 'position' in the 'ast'.\n-function findParentOfBinding(\n-    ast: TemplateAst[], binding: BoundDirectivePropertyAst, position: number): DirectiveAst|\n-    undefined {\n-  let res: DirectiveAst|undefined;\n-  const visitor = new class extends RecursiveTemplateAstVisitor {\n-    visit(ast: TemplateAst): any {\n-      const span = spanOf(ast);\n-      if (!inSpan(position, span)) {\n-        // Returning a value here will result in the children being skipped.\n-        return true;\n-      }\n-    }\n-\n-    override visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n-      return this.visitChildren(context, visit => {\n-        visit(ast.directives);\n-        visit(ast.children);\n-      });\n-    }\n-\n-    override visitElement(ast: ElementAst, context: any): any {\n-      return this.visitChildren(context, visit => {\n-        visit(ast.directives);\n-        visit(ast.children);\n-      });\n-    }\n-\n-    override visitDirective(ast: DirectiveAst) {\n-      const result = this.visitChildren(ast, visit => {\n-        visit(ast.inputs);\n-      });\n-      return result;\n-    }\n-\n-    override visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: DirectiveAst) {\n-      if (ast === binding) {\n-        res = context;\n-      }\n-    }\n-  };\n-  templateVisitAll(visitor, ast);\n-  return res;\n-}\n-\n-// Find the symbol of input binding in 'directiveAst' by 'name'.\n-function findInputBinding(info: AstResult, name: string, directiveAst: DirectiveAst): Symbol|\n-    undefined {\n-  const invertedInput = invertMap(directiveAst.directive.inputs);\n-  const fieldName = invertedInput[name];\n-  if (fieldName) {\n-    const classSymbol = info.template.query.getTypeSymbol(directiveAst.directive.type.reference);\n-    if (classSymbol) {\n-      return classSymbol.members().get(fieldName);\n-    }\n-  }\n-}\n-\n-/**\n- * Wrap a symbol and change its kind to component.\n- */\n-class OverrideKindSymbol implements Symbol {\n-  public readonly kind: DirectiveKind;\n-  constructor(private sym: Symbol, kindOverride: DirectiveKind) {\n-    this.kind = kindOverride;\n-  }\n-\n-  get name(): string {\n-    return this.sym.name;\n-  }\n-\n-  get language(): string {\n-    return this.sym.language;\n-  }\n-\n-  get type(): Symbol|undefined {\n-    return this.sym.type;\n-  }\n-\n-  get container(): Symbol|undefined {\n-    return this.sym.container;\n-  }\n-\n-  get public(): boolean {\n-    return this.sym.public;\n-  }\n-\n-  get callable(): boolean {\n-    return this.sym.callable;\n-  }\n-\n-  get nullable(): boolean {\n-    return this.sym.nullable;\n-  }\n-\n-  get definition(): Definition {\n-    return this.sym.definition;\n-  }\n-\n-  get documentation(): ts.SymbolDisplayPart[] {\n-    return this.sym.documentation;\n-  }\n-\n-  members() {\n-    return this.sym.members();\n-  }\n-\n-  signatures() {\n-    return this.sym.signatures();\n-  }\n-\n-  selectSignature(types: Symbol[]) {\n-    return this.sym.selectSignature(types);\n-  }\n-\n-  indexed(argument: Symbol) {\n-    return this.sym.indexed(argument);\n-  }\n-\n-  typeArguments(): Symbol[]|undefined {\n-    return this.sym.typeArguments();\n-  }\n-}"
        },
        {
            "sha": "149824a1f743e4178190227b61e4b4972a8972da",
            "filename": "packages/language-service/src/reflector_host.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 126,
            "changes": 126,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Freflector_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Freflector_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Freflector_host.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,126 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {StaticSymbolResolverHost} from '@angular/compiler';\n-import {createMetadataReaderCache, MetadataCollector, MetadataReaderHost, readMetadata} from '@angular/compiler-cli/src/language_services';\n-import * as path from 'path';\n-import ts from 'typescript';\n-\n-class ReflectorModuleModuleResolutionHost implements ts.ModuleResolutionHost, MetadataReaderHost {\n-  private readonly metadataCollector = new MetadataCollector({\n-    // Note: verboseInvalidExpressions is important so that\n-    // the collector will collect errors instead of throwing\n-    verboseInvalidExpression: true,\n-  });\n-\n-  readonly directoryExists?: (directoryName: string) => boolean;\n-  // Resolve a symbolic link.\n-  realpath?: (path: string) => string;\n-\n-  constructor(\n-      private readonly tsLSHost: ts.LanguageServiceHost,\n-      private readonly getProgram: () => ts.Program) {\n-    if (tsLSHost.directoryExists) {\n-      this.directoryExists = directoryName => tsLSHost.directoryExists!(directoryName);\n-    }\n-    if (tsLSHost.realpath) {\n-      this.realpath = path => tsLSHost.realpath!(path);\n-    }\n-  }\n-\n-  fileExists(fileName: string): boolean {\n-    // TypeScript resolution logic walks through the following sequence in order:\n-    // package.json (read \"types\" field) -> .ts -> .tsx -> .d.ts\n-    // For more info, see\n-    // https://www.typescriptlang.org/docs/handbook/module-resolution.html\n-    // For Angular specifically, we can skip .tsx lookup\n-    if (fileName.endsWith('.tsx')) {\n-      return false;\n-    }\n-    if (this.tsLSHost.fileExists) {\n-      return this.tsLSHost.fileExists(fileName);\n-    }\n-    return !!this.tsLSHost.getScriptSnapshot(fileName);\n-  }\n-\n-  readFile(fileName: string): string {\n-    // readFile() is used by TypeScript to read package.json during module\n-    // resolution, and it's used by Angular to read metadata.json during\n-    // metadata resolution.\n-    if (this.tsLSHost.readFile) {\n-      return this.tsLSHost.readFile(fileName)!;\n-    }\n-    // As a fallback, read the JSON files from the editor snapshot.\n-    const snapshot = this.tsLSHost.getScriptSnapshot(fileName);\n-    if (!snapshot) {\n-      // MetadataReaderHost readFile() declaration should be\n-      // `readFile(fileName: string): string | undefined`\n-      return undefined!;\n-    }\n-    return snapshot.getText(0, snapshot.getLength());\n-  }\n-\n-  getSourceFileMetadata(fileName: string) {\n-    const sf = this.getProgram().getSourceFile(fileName);\n-    return sf ? this.metadataCollector.getMetadata(sf) : undefined;\n-  }\n-\n-  cacheMetadata(fileName: string) {\n-    // Don't cache the metadata for .ts files as they might change in the editor!\n-    return fileName.endsWith('.d.ts');\n-  }\n-}\n-\n-export class ReflectorHost implements StaticSymbolResolverHost {\n-  private readonly hostAdapter: ReflectorModuleModuleResolutionHost;\n-  private readonly metadataReaderCache = createMetadataReaderCache();\n-  private readonly moduleResolutionCache: ts.ModuleResolutionCache;\n-  private readonly fakeContainingPath: string;\n-\n-  constructor(getProgram: () => ts.Program, private readonly tsLSHost: ts.LanguageServiceHost) {\n-    // tsLSHost.getCurrentDirectory() returns the directory where tsconfig.json\n-    // is located. This is not the same as process.cwd() because the language\n-    // service host sets the \"project root path\" as its current directory.\n-    const currentDir = tsLSHost.getCurrentDirectory();\n-    this.fakeContainingPath = currentDir ? path.join(currentDir, 'fakeContainingFile.ts') : '';\n-    this.hostAdapter = new ReflectorModuleModuleResolutionHost(tsLSHost, getProgram);\n-    this.moduleResolutionCache = ts.createModuleResolutionCache(\n-        currentDir,\n-        s => s,  // getCanonicalFileName\n-        tsLSHost.getCompilationSettings());\n-  }\n-\n-  getMetadataFor(modulePath: string): {[key: string]: any}[]|undefined {\n-    return readMetadata(modulePath, this.hostAdapter, this.metadataReaderCache);\n-  }\n-\n-  moduleNameToFileName(moduleName: string, containingFile?: string): string|null {\n-    if (!containingFile) {\n-      if (moduleName.startsWith('.')) {\n-        throw new Error('Resolution of relative paths requires a containing file.');\n-      }\n-      if (!this.fakeContainingPath) {\n-        // If current directory is empty then the file must belong to an inferred\n-        // project (no tsconfig.json), in which case it's not possible to resolve\n-        // the module without the caller explicitly providing a containing file.\n-        throw new Error(`Could not resolve '${moduleName}' without a containing file.`);\n-      }\n-      containingFile = this.fakeContainingPath;\n-    }\n-    const compilerOptions = this.tsLSHost.getCompilationSettings();\n-    const resolved = ts.resolveModuleName(\n-                           moduleName, containingFile, compilerOptions, this.hostAdapter,\n-                           this.moduleResolutionCache)\n-                         .resolvedModule;\n-    return resolved ? resolved.resolvedFileName : null;\n-  }\n-\n-  getOutputName(filePath: string) {\n-    return filePath;\n-  }\n-}"
        },
        {
            "sha": "7d291d3c7b403bbb1be614f19817bf13eb396b07",
            "filename": "packages/language-service/src/symbols.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 372,
            "changes": 372,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fsymbols.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fsymbols.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Fsymbols.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,372 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {StaticSymbol} from '@angular/compiler';\n-import ts from 'typescript';\n-\n-\n-/**\n- * The range of a span of text in a source file.\n- *\n- * @publicApi\n- */\n-export interface Span {\n-  /**\n-   * The first code-point of the span as an offset relative to the beginning of the source assuming\n-   * a UTF-16 encoding.\n-   */\n-  start: number;\n-\n-  /**\n-   * The first code-point after the span as an offset relative to the beginning of the source\n-   * assuming a UTF-16 encoding.\n-   */\n-  end: number;\n-}\n-\n-/**\n- * A file and span.\n- */\n-export interface Location {\n-  fileName: string;\n-  span: Span;\n-}\n-\n-/**\n- * A defnition location(s).\n- */\n-export type Definition = Location[]|undefined;\n-\n-/**\n- * A symbol describing a language element that can be referenced by expressions\n- * in an Angular template.\n- *\n- * @publicApi\n- */\n-export interface Symbol {\n-  /**\n-   * The name of the symbol as it would be referenced in an Angular expression.\n-   */\n-  readonly name: string;\n-\n-  /**\n-   * The kind of completion this symbol should generate if included.\n-   */\n-  readonly kind: string;\n-\n-  /**\n-   * The language of the source that defines the symbol. (e.g. typescript for TypeScript,\n-   * ng-template for an Angular template, etc.)\n-   */\n-  readonly language: string;\n-\n-  /**\n-   * A symbol representing type of the symbol.\n-   */\n-  readonly type: Symbol|undefined;\n-\n-  /**\n-   * A symbol for the container of this symbol. For example, if this is a method, the container\n-   * is the class or interface of the method. If no container is appropriate, undefined is\n-   * returned.\n-   */\n-  readonly container: Symbol|undefined;\n-\n-  /**\n-   * The symbol is public in the container.\n-   */\n-  readonly public: boolean;\n-\n-  /**\n-   * `true` if the symbol can be the target of a call.\n-   */\n-  readonly callable: boolean;\n-\n-  /**\n-   * The location of the definition of the symbol\n-   */\n-  readonly definition: Definition|undefined;\n-\n-  /**\n-   * `true` if the symbol is a type that is nullable (can be null or undefined).\n-   */\n-  readonly nullable: boolean;\n-\n-  /**\n-   * Documentation comment on the Symbol, if any.\n-   */\n-  readonly documentation: ts.SymbolDisplayPart[];\n-\n-  /**\n-   * A table of the members of the symbol; that is, the members that can appear\n-   * after a `.` in an Angular expression.\n-   */\n-  members(): SymbolTable;\n-\n-  /**\n-   * The list of overloaded signatures that can be used if the symbol is the\n-   * target of a call.\n-   */\n-  signatures(): Signature[];\n-\n-  /**\n-   * Return which signature of returned by `signatures()` would be used selected\n-   * given the `types` supplied. If no signature would match, this method should\n-   * return `undefined`.\n-   */\n-  selectSignature(types: Symbol[]): Signature|undefined;\n-\n-  /**\n-   * Return the type of the expression if this symbol is indexed by `argument`.\n-   * Sometimes we need the key of arguments to get the type of the expression, for example\n-   * in the case of tuples (`type Example = [string, number]`).\n-   * [string, number]).\n-   * If the symbol cannot be indexed, this method should return `undefined`.\n-   */\n-  indexed(argument: Symbol, key?: any): Symbol|undefined;\n-\n-  /**\n-   * Returns the type arguments of a Symbol, if any.\n-   */\n-  typeArguments(): Symbol[]|undefined;\n-}\n-\n-/**\n- * A table of `Symbol`s accessible by name.\n- *\n- * @publicApi\n- */\n-export interface SymbolTable {\n-  /**\n-   * The number of symbols in the table.\n-   */\n-  readonly size: number;\n-\n-  /**\n-   * Get the symbol corresponding to `key` or `undefined` if there is no symbol in the\n-   * table by the name `key`.\n-   */\n-  get(key: string): Symbol|undefined;\n-\n-  /**\n-   * Returns `true` if the table contains a `Symbol` with the name `key`.\n-   */\n-  has(key: string): boolean;\n-\n-  /**\n-   * Returns all the `Symbol`s in the table. The order should be, but is not required to be,\n-   * in declaration order.\n-   */\n-  values(): Symbol[];\n-}\n-\n-/**\n- * A description of a function or method signature.\n- *\n- * @publicApi\n- */\n-export interface Signature {\n-  /**\n-   * The arguments of the signture. The order of `arguments.symbols()` must be in the order\n-   * of argument declaration.\n-   */\n-  readonly arguments: SymbolTable;\n-\n-  /**\n-   * The symbol of the signature result type.\n-   */\n-  readonly result: Symbol;\n-}\n-\n-/**\n- * An enumeration of basic types.\n- *\n- * @publicApi\n- */\n-export enum BuiltinType {\n-  /**\n-   * The type is a type that can hold any other type.\n-   */\n-  Any = -1,  // equivalent to b11..11 = String | Union | ...\n-\n-  /** Unknown types are functionally identical to any. */\n-  Unknown = -1,\n-\n-  /**\n-   * The type of a string literal.\n-   */\n-  String = 1 << 0,\n-\n-  /**\n-   * The type of a numeric literal.\n-   */\n-  Number = 1 << 1,\n-\n-  /**\n-   * The type of the `true` and `false` literals.\n-   */\n-  Boolean = 1 << 2,\n-\n-  /**\n-   * The type of the `undefined` literal.\n-   */\n-  Undefined = 1 << 3,\n-\n-  /**\n-   * the type of the `null` literal.\n-   */\n-  Null = 1 << 4,\n-\n-  /**\n-   * the type is an unbound type parameter.\n-   */\n-  Unbound = 1 << 5,\n-\n-  /**\n-   * Not a built-in type.\n-   */\n-  Other = 1 << 6,\n-\n-  Object = 1 << 7,\n-}\n-\n-/**\n- * The kinds of definition.\n- *\n- * @publicApi\n- */\n-export type DeclarationKind = 'attribute'|'html attribute'|'component'|'element'|'entity'|'key'|\n-    'method'|'pipe'|'property'|'type'|'reference'|'variable';\n-\n-/**\n- * Describes a symbol to type binding used to build a symbol table.\n- *\n- * @publicApi\n- */\n-export interface SymbolDeclaration {\n-  /**\n-   * The name of the symbol in table.\n-   */\n-  readonly name: string;\n-\n-  /**\n-   * The kind of symbol to declare.\n-   */\n-  readonly kind: DeclarationKind;\n-\n-  /**\n-   * Type of the symbol. The type symbol should refer to a symbol for a type.\n-   */\n-  readonly type: Symbol;\n-\n-  /**\n-   * The definion of the symbol if one exists.\n-   */\n-  readonly definition?: Definition;\n-}\n-\n-/**\n- * Information about the pipes that are available for use in a template.\n- *\n- * @publicApi\n- */\n-export interface PipeInfo {\n-  /**\n-   * The name of the pipe.\n-   */\n-  name: string;\n-\n-  /**\n-   * The static symbol for the pipe's constructor.\n-   */\n-  symbol: StaticSymbol;\n-}\n-\n-/**\n- * A sequence of pipe information.\n- *\n- * @publicApi\n- */\n-export type Pipes = PipeInfo[]|undefined;\n-\n-/**\n- * Describes the language context in which an Angular expression is evaluated.\n- *\n- * @publicApi\n- */\n-export interface SymbolQuery {\n-  /**\n-   * Return the built-in type this symbol represents or Other if it is not a built-in type.\n-   */\n-  getTypeKind(symbol: Symbol): BuiltinType;\n-\n-  /**\n-   * Return a symbol representing the given built-in type.\n-   */\n-  getBuiltinType(kind: BuiltinType): Symbol;\n-\n-  /**\n-   * Return the symbol for a type that represents the union of all the types given. Any value\n-   * of one of the types given should be assignable to the returned type. If no one type can\n-   * be constructed then this should be the Any type.\n-   */\n-  getTypeUnion(...types: Symbol[]): Symbol;\n-\n-  /**\n-   * Return a symbol for an array type that has the `type` as its element type.\n-   */\n-  getArrayType(type: Symbol): Symbol;\n-\n-  /**\n-   * Return element type symbol for an array type if the `type` is an array type. Otherwise return\n-   * undefined.\n-   */\n-  getElementType(type: Symbol): Symbol|undefined;\n-\n-  /**\n-   * Return a type that is the non-nullable version of the given type. If `type` is already\n-   * non-nullable, return `type`.\n-   */\n-  getNonNullableType(type: Symbol): Symbol;\n-\n-  /**\n-   * Return a symbol table for the pipes that are in scope.\n-   */\n-  getPipes(): SymbolTable;\n-\n-  /**\n-   * Return the type symbol for the given static symbol.\n-   */\n-  getTypeSymbol(type: StaticSymbol): Symbol|undefined;\n-\n-  /**\n-   * Return the members that are in the context of a type's template reference.\n-   */\n-  getTemplateContext(type: StaticSymbol): SymbolTable|undefined;\n-\n-  /**\n-   * Produce a symbol table with the given symbols. Used to produce a symbol table\n-   * for use with mergeSymbolTables().\n-   */\n-  createSymbolTable(symbols: SymbolDeclaration[]): SymbolTable;\n-\n-  /**\n-   * Produce a merged symbol table. If the symbol tables contain duplicate entries\n-   * the entries of the latter symbol tables will obscure the entries in the prior\n-   * symbol tables.\n-   *\n-   * The symbol tables passed to this routine MUST be produces by the same instance\n-   * of SymbolQuery that is being called.\n-   */\n-  mergeSymbolTable(symbolTables: SymbolTable[]): SymbolTable;\n-\n-  /**\n-   * Return the span of the narrowest non-token node at the given location.\n-   */\n-  getSpanAt(line: number, column: number): Span|undefined;\n-}"
        },
        {
            "sha": "076afcca20846638a9d6fd6f169ec9af5a237dc1",
            "filename": "packages/language-service/src/template.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 134,
            "changes": 134,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Ftemplate.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Ftemplate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Ftemplate.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,134 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {createGlobalSymbolTable} from './global_symbols';\n-import * as ng from './types';\n-import {TypeScriptServiceHost} from './typescript_host';\n-import {getClassMembersFromDeclaration, getPipesTable, getSymbolQuery} from './typescript_symbols';\n-\n-\n-/**\n- * A base class to represent a template and which component class it is\n- * associated with. A template source could answer basic questions about\n- * top-level declarations of its class through the members() and query()\n- * methods.\n- */\n-abstract class BaseTemplate implements ng.TemplateSource {\n-  private readonly program: ts.Program;\n-  private membersTable: ng.SymbolTable|undefined;\n-  private queryCache: ng.SymbolQuery|undefined;\n-\n-  constructor(\n-      private readonly host: TypeScriptServiceHost,\n-      private readonly classDeclNode: ts.ClassDeclaration,\n-      private readonly classSymbol: ng.StaticSymbol) {\n-    this.program = host.program;\n-  }\n-\n-  abstract get span(): ng.Span;\n-  abstract get fileName(): string;\n-  abstract get source(): string;\n-\n-  /**\n-   * Return the Angular StaticSymbol for the class that contains this template.\n-   */\n-  get type() {\n-    return this.classSymbol;\n-  }\n-\n-  /**\n-   * Return a Map-like data structure that allows users to retrieve some or all\n-   * top-level declarations in the associated component class.\n-   */\n-  get members() {\n-    if (!this.membersTable) {\n-      const typeChecker = this.program.getTypeChecker();\n-      const sourceFile = this.classDeclNode.getSourceFile();\n-      this.membersTable = this.query.mergeSymbolTable([\n-        createGlobalSymbolTable(this.query),\n-        getClassMembersFromDeclaration(this.program, typeChecker, sourceFile, this.classDeclNode),\n-      ]);\n-    }\n-    return this.membersTable;\n-  }\n-\n-  /**\n-   * Return an engine that provides more information about symbols in the\n-   * template.\n-   */\n-  get query() {\n-    if (!this.queryCache) {\n-      const program = this.program;\n-      const typeChecker = program.getTypeChecker();\n-      const sourceFile = this.classDeclNode.getSourceFile();\n-      this.queryCache = getSymbolQuery(program, typeChecker, sourceFile, () => {\n-        // Computing the ast is relatively expensive. Do it only when absolutely\n-        // necessary.\n-        // TODO: There is circular dependency here between TemplateSource and\n-        // TypeScriptHost. Consider refactoring the code to break this cycle.\n-        const ast = this.host.getTemplateAst(this);\n-        const pipes = (ast && ast.pipes) || [];\n-        return getPipesTable(sourceFile, program, typeChecker, pipes);\n-      });\n-    }\n-    return this.queryCache;\n-  }\n-}\n-\n-/**\n- * An InlineTemplate represents template defined in a TS file through the\n- * `template` attribute in the decorator.\n- */\n-export class InlineTemplate extends BaseTemplate {\n-  public override readonly fileName: string;\n-  public override readonly source: string;\n-  public override readonly span: ng.Span;\n-\n-  constructor(\n-      templateNode: ts.StringLiteralLike, classDeclNode: ts.ClassDeclaration,\n-      classSymbol: ng.StaticSymbol, host: TypeScriptServiceHost) {\n-    super(host, classDeclNode, classSymbol);\n-    const sourceFile = templateNode.getSourceFile();\n-    if (sourceFile !== classDeclNode.getSourceFile()) {\n-      throw new Error(`Inline template and component class should belong to the same source file`);\n-    }\n-    this.fileName = sourceFile.fileName;\n-    // node.text returns the TS internal representation of the normalized text,\n-    // and all CR characters are stripped. node.getText() returns the raw text.\n-    this.source = templateNode.getText().slice(1, -1);  // strip leading and trailing quotes\n-    this.span = {\n-      // TS string literal includes surrounding quotes in the start/end offsets.\n-      start: templateNode.getStart() + 1,\n-      end: templateNode.getEnd() - 1,\n-    };\n-  }\n-}\n-\n-/**\n- * An ExternalTemplate represents template defined in an external (most likely\n- * HTML, but not necessarily) file through the `templateUrl` attribute in the\n- * decorator.\n- * Note that there is no ts.Node associated with the template because it's not\n- * a TS file.\n- */\n-export class ExternalTemplate extends BaseTemplate {\n-  public override readonly span: ng.Span;\n-\n-  constructor(\n-      public readonly source: string, public readonly fileName: string,\n-      classDeclNode: ts.ClassDeclaration, classSymbol: ng.StaticSymbol,\n-      host: TypeScriptServiceHost) {\n-    super(host, classDeclNode, classSymbol);\n-    this.span = {\n-      start: 0,\n-      end: source.length,\n-    };\n-  }\n-}"
        },
        {
            "sha": "8c8123602944bd7dac691668776e01fbb855d00b",
            "filename": "packages/language-service/src/ts_plugin.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 150,
            "changes": 150,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fts_plugin.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fts_plugin.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Fts_plugin.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,150 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as tss from 'typescript/lib/tsserverlibrary';\n-import {NgLanguageService} from '../api';\n-\n-import {createLanguageService} from './language_service';\n-import {TypeScriptServiceHost} from './typescript_host';\n-\n-// Use a WeakMap to keep track of Project to Host mapping so that when Project\n-// is deleted Host could be garbage collected.\n-const PROJECT_MAP = new WeakMap<tss.server.Project, TypeScriptServiceHost>();\n-\n-/**\n- * This function is called by tsserver to retrieve the external (non-TS) files\n- * that should belong to the specified `project`. For Angular, these files are\n- * external templates. This is called once when the project is loaded, then\n- * every time when the program is updated.\n- * @param project Project for which external files should be retrieved.\n- */\n-export function getExternalFiles(project: tss.server.Project): string[] {\n-  if (!project.hasRoots()) {\n-    // During project initialization where there is no root files yet we should\n-    // not do any work.\n-    return [];\n-  }\n-  const ngLsHost = PROJECT_MAP.get(project);\n-  if (ngLsHost === undefined) {\n-    return [];\n-  }\n-  ngLsHost.getAnalyzedModules();\n-  return ngLsHost.getExternalTemplates().filter(fileName => {\n-    // TODO(kyliau): Remove this when the following PR lands on the version of\n-    // TypeScript used in this repo.\n-    // https://github.com/microsoft/TypeScript/pull/41737\n-    return project.fileExists(fileName);\n-  });\n-}\n-\n-export function create(info: tss.server.PluginCreateInfo): NgLanguageService {\n-  const {languageService: tsLS, languageServiceHost: tsLSHost, config, project} = info;\n-  // This plugin could operate under two different modes:\n-  // 1. TS + Angular\n-  //    Plugin augments TS language service to provide additional Angular\n-  //    information. This only works with inline templates and is meant to be\n-  //    used as a local plugin (configured via tsconfig.json)\n-  // 2. Angular only\n-  //    Plugin only provides information on Angular templates, no TS info at all.\n-  //    This effectively disables native TS features and is meant for internal\n-  //    use only.\n-  const angularOnly = config ? config.angularOnly === true : false;\n-  const ngLSHost = new TypeScriptServiceHost(tsLSHost, tsLS);\n-  const ngLS = createLanguageService(ngLSHost);\n-  PROJECT_MAP.set(project, ngLSHost);\n-\n-  function getCompletionsAtPosition(\n-      fileName: string, position: number, options: tss.GetCompletionsAtPositionOptions|undefined) {\n-    if (!angularOnly) {\n-      const results = tsLS.getCompletionsAtPosition(fileName, position, options);\n-      if (results && results.entries.length) {\n-        // If TS could answer the query, then return results immediately.\n-        return results;\n-      }\n-    }\n-    return ngLS.getCompletionsAtPosition(fileName, position, options);\n-  }\n-\n-  function getQuickInfoAtPosition(fileName: string, position: number): tss.QuickInfo|undefined {\n-    if (!angularOnly) {\n-      const result = tsLS.getQuickInfoAtPosition(fileName, position);\n-      if (result) {\n-        // If TS could answer the query, then return results immediately.\n-        return result;\n-      }\n-    }\n-    return ngLS.getQuickInfoAtPosition(fileName, position);\n-  }\n-\n-  function getSemanticDiagnostics(fileName: string): tss.Diagnostic[] {\n-    const results: tss.Diagnostic[] = [];\n-    if (!angularOnly) {\n-      results.push(...tsLS.getSemanticDiagnostics(fileName));\n-    }\n-    // For semantic diagnostics we need to combine both TS + Angular results\n-    results.push(...ngLS.getSemanticDiagnostics(fileName));\n-    return results;\n-  }\n-\n-  function getDefinitionAtPosition(\n-      fileName: string, position: number): ReadonlyArray<tss.DefinitionInfo>|undefined {\n-    if (!angularOnly) {\n-      const results = tsLS.getDefinitionAtPosition(fileName, position);\n-      if (results) {\n-        // If TS could answer the query, then return results immediately.\n-        return results;\n-      }\n-    }\n-    const result = ngLS.getDefinitionAndBoundSpan(fileName, position);\n-    if (!result || !result.definitions || !result.definitions.length) {\n-      return;\n-    }\n-    return result.definitions;\n-  }\n-\n-  function getDefinitionAndBoundSpan(\n-      fileName: string, position: number): tss.DefinitionInfoAndBoundSpan|undefined {\n-    if (!angularOnly) {\n-      const result = tsLS.getDefinitionAndBoundSpan(fileName, position);\n-      if (result) {\n-        // If TS could answer the query, then return results immediately.\n-        return result;\n-      }\n-    }\n-    return ngLS.getDefinitionAndBoundSpan(fileName, position);\n-  }\n-\n-  function getTcb(fileName: string, position: number) {\n-    // Not implemented in VE Language Service\n-    return undefined;\n-  }\n-\n-  function getTemplateLocationForComponent(fileName: string, position: number) {\n-    // Not implemented in VE Language Service\n-    return undefined;\n-  }\n-\n-  function getComponentLocationsForTemplate(fileName: string) {\n-    // Not implemented in VE Language Service\n-    return [];\n-  }\n-\n-  return {\n-    // First clone the original TS language service\n-    ...tsLS,\n-    // Then override the methods supported by Angular language service\n-    getCompletionsAtPosition,\n-    getQuickInfoAtPosition,\n-    getSemanticDiagnostics,\n-    getDefinitionAtPosition,\n-    getDefinitionAndBoundSpan,\n-    getTcb,\n-    getComponentLocationsForTemplate,\n-    getTemplateLocationForComponent,\n-  };\n-}"
        },
        {
            "sha": "ca740e43e6f0dfed530cfa5b3f32e69194b25bcf",
            "filename": "packages/language-service/src/ts_utils.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 148,
            "changes": 148,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fts_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Fts_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Fts_utils.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,148 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as ts from 'typescript/lib/tsserverlibrary';\n-\n-interface DirectiveClassLike {\n-  decoratorId: ts.Identifier;  // decorator identifier, like @Component\n-  classId: ts.Identifier;\n-}\n-\n-/**\n- * Return metadata about `node` if it looks like an Angular directive class.\n- * In this case, potential matches are `@NgModule`, `@Component`, `@Directive`,\n- * `@Pipe`, etc.\n- * These class declarations all share some common attributes, namely their\n- * decorator takes exactly one parameter and the parameter must be an object\n- * literal.\n- *\n- * For example,\n- *     v---------- `decoratorId`\n- * @NgModule({           <\n- *   declarations: [],   < classDecln-al\n- * })                    <\n- * class AppModule {}    <\n- *          ^----- `classId`\n- *\n- * @param node Potential node that represents an Angular directive.\n- */\n-export function getDirectiveClassLike(node: ts.Node): DirectiveClassLike|undefined {\n-  if (!ts.isClassDeclaration(node) || !node.name || !node.decorators) {\n-    return;\n-  }\n-  for (const d of node.decorators) {\n-    const expr = d.expression;\n-    if (!ts.isCallExpression(expr) || expr.arguments.length !== 1 ||\n-        !ts.isIdentifier(expr.expression)) {\n-      continue;\n-    }\n-    const arg = expr.arguments[0];\n-    if (ts.isObjectLiteralExpression(arg)) {\n-      return {\n-        decoratorId: expr.expression,\n-        classId: node.name,\n-      };\n-    }\n-  }\n-}\n-\n-/**\n- * Finds the value of a property assignment that is nested in a TypeScript node and is of a certain\n- * type T.\n- *\n- * @param startNode node to start searching for nested property assignment from\n- * @param propName property assignment name\n- * @param predicate function to verify that a node is of type T.\n- * @return node property assignment value of type T, or undefined if none is found\n- */\n-export function findPropertyValueOfType<T extends ts.Node>(\n-    startNode: ts.Node, propName: string, predicate: (node: ts.Node) => node is T): T|undefined {\n-  if (ts.isPropertyAssignment(startNode) && startNode.name.getText() === propName) {\n-    const {initializer} = startNode;\n-    if (predicate(initializer)) return initializer;\n-  }\n-  return startNode.forEachChild(c => findPropertyValueOfType(c, propName, predicate));\n-}\n-\n-/**\n- * Return the node that most tightly encompass the specified `position`.\n- * @param node\n- * @param position\n- */\n-export function findTightestNode(node: ts.Node, position: number): ts.Node|undefined {\n-  if (node.getStart() <= position && position < node.getEnd()) {\n-    return node.forEachChild(c => findTightestNode(c, position)) || node;\n-  }\n-}\n-\n-/**\n- * Returns a property assignment from the assignment value if the property name\n- * matches the specified `key`, or `undefined` if there is no match.\n- */\n-export function getPropertyAssignmentFromValue(value: ts.Node, key: string): ts.PropertyAssignment|\n-    undefined {\n-  const propAssignment = value.parent;\n-  if (!propAssignment || !ts.isPropertyAssignment(propAssignment) ||\n-      propAssignment.name.getText() !== key) {\n-    return;\n-  }\n-  return propAssignment;\n-}\n-\n-/**\n- * Given the node which is the string of the inline template for a component, returns the\n- * `ts.ClassDeclaration` for the component.\n- */\n-export function getClassDeclOfInlineTemplateNode(templateStringNode: ts.Node): ts.ClassDeclaration|\n-    undefined {\n-  if (!ts.isStringLiteralLike(templateStringNode)) {\n-    return;\n-  }\n-  const tmplAsgn = getPropertyAssignmentFromValue(templateStringNode, 'template');\n-  if (!tmplAsgn) {\n-    return;\n-  }\n-  return getClassDeclFromDecoratorProp(tmplAsgn);\n-}\n-\n-/**\n- * Given a decorator property assignment, return the ClassDeclaration node that corresponds to the\n- * directive class the property applies to.\n- * If the property assignment is not on a class decorator, no declaration is returned.\n- *\n- * For example,\n- *\n- * @Component({\n- *   template: '<div></div>'\n- *   ^^^^^^^^^^^^^^^^^^^^^^^---- property assignment\n- * })\n- * class AppComponent {}\n- *           ^---- class declaration node\n- *\n- * @param propAsgnNode property assignment\n- */\n-export function getClassDeclFromDecoratorProp(propAsgnNode: ts.PropertyAssignment):\n-    ts.ClassDeclaration|undefined {\n-  if (!propAsgnNode.parent || !ts.isObjectLiteralExpression(propAsgnNode.parent)) {\n-    return;\n-  }\n-  const objLitExprNode = propAsgnNode.parent;\n-  if (!objLitExprNode.parent || !ts.isCallExpression(objLitExprNode.parent)) {\n-    return;\n-  }\n-  const callExprNode = objLitExprNode.parent;\n-  if (!callExprNode.parent || !ts.isDecorator(callExprNode.parent)) {\n-    return;\n-  }\n-  const decorator = callExprNode.parent;\n-  if (!decorator.parent || !ts.isClassDeclaration(decorator.parent)) {\n-    return;\n-  }\n-  const classDeclNode = decorator.parent;\n-  return classDeclNode;\n-}"
        },
        {
            "sha": "f137054164988ac8e373796c7998a95776b0660b",
            "filename": "packages/language-service/src/types.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 292,
            "changes": 292,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Ftypes.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Ftypes.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,292 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompileDirectiveMetadata, CompileDirectiveSummary, CompilePipeSummary, CssSelector, NgAnalyzedModules, Node as HtmlAst, ParseError, Parser, StaticSymbol, TemplateAst} from '@angular/compiler';\n-import ts from 'typescript';\n-\n-import {Span, Symbol, SymbolQuery, SymbolTable} from './symbols';\n-\n-export {StaticSymbol} from '@angular/compiler';\n-export {BuiltinType, Definition, PipeInfo, Pipes, Signature, Span, Symbol, SymbolDeclaration, SymbolQuery, SymbolTable} from './symbols';\n-\n-/**\n- * The information `LanguageService` needs from the `LanguageServiceHost` to describe the content of\n- * a template and the language context the template is in.\n- *\n- * A host interface; see `LanguageServiceHost`.\n- *\n- * @publicApi\n- */\n-export interface TemplateSource {\n-  /**\n-   * The source of the template.\n-   */\n-  readonly source: string;\n-\n-  /**\n-   * The span of the template within the source file.\n-   */\n-  readonly span: Span;\n-\n-  /**\n-   * A static symbol for the template's component.\n-   */\n-  readonly type: StaticSymbol;\n-\n-  /**\n-   * The `SymbolTable` for the members of the component.\n-   */\n-  readonly members: SymbolTable;\n-\n-  /**\n-   * A `SymbolQuery` for the context of the template.\n-   */\n-  readonly query: SymbolQuery;\n-\n-  /**\n-   * Name of the file that contains the template. Could be `.html` or `.ts`.\n-   */\n-  readonly fileName: string;\n-}\n-\n-/**\n- * Error information found getting declaration information\n- *\n- * A host type; see `LanguageServiceHost`.\n- *\n- * @publicApi\n- */\n-export interface DeclarationError {\n-  /**\n-   * The span of the error in the declaration's module.\n-   */\n-  readonly span: Span;\n-\n-  /**\n-   * The message to display describing the error or a chain\n-   * of messages.\n-   */\n-  readonly message: string|DiagnosticMessageChain;\n-}\n-\n-/**\n- * Information about the component declarations.\n- *\n- * A file might contain a declaration without a template because the file contains only\n- * templateUrl references. However, the component declaration might contain errors that\n- * need to be reported such as the template string is missing or the component is not\n- * declared in a module. These error should be reported on the declaration, not the\n- * template.\n- *\n- * A host type; see `LanguageServiceHost`.\n- *\n- * @publicApi\n- */\n-export interface Declaration {\n-  /**\n-   * The static symbol of the compponent being declared.\n-   */\n-  readonly type: StaticSymbol;\n-\n-  /**\n-   * The span of the declaration annotation reference (e.g. the 'Component' or 'Directive'\n-   * reference).\n-   */\n-  readonly declarationSpan: Span;\n-\n-  /**\n-   * Reference to the compiler directive metadata for the declaration.\n-   */\n-  readonly metadata: CompileDirectiveMetadata;\n-\n-  /**\n-   * Error reported trying to get the metadata.\n-   */\n-  readonly errors: DeclarationError[];\n-}\n-\n-/**\n- * The host for a `LanguageService`. This provides all the `LanguageService` requires to respond\n- * to the `LanguageService` requests.\n- *\n- * This interface describes the requirements of the `LanguageService` on its host.\n- *\n- * The host interface is host language agnostic.\n- *\n- * Adding optional member to this interface or any interface that is described as a\n- * `LanguageServiceHost` interface is not considered a breaking change as defined by SemVer.\n- * Removing a method or changing a member from required to optional will also not be considered a\n- * breaking change.\n- *\n- * If a member is deprecated it will be changed to optional in a minor release before it is\n- * removed in a major release.\n- *\n- * Adding a required member or changing a method's parameters, is considered a breaking change and\n- * will only be done when breaking changes are allowed. When possible, a new optional member will\n- * be added and the old member will be deprecated. The new member will then be made required in\n- * and the old member will be removed only when breaking changes are allowed.\n- *\n- * While an interface is marked as experimental breaking-changes will be allowed between minor\n- * releases. After an interface is marked as stable breaking-changes will only be allowed between\n- * major releases. No breaking changes are allowed between patch releases.\n- *\n- * @publicApi\n- */\n-export interface LanguageServiceHost {\n-  /**\n-   * Return the template source information for all templates in `fileName` or for `fileName` if\n-   * it is a template file.\n-   */\n-  getTemplates(fileName: string): TemplateSource[];\n-\n-  /**\n-   * Returns the Angular declarations in the given file.\n-   */\n-  getDeclarations(fileName: string): Declaration[];\n-\n-  /**\n-   * Return a summary of all Angular modules in the project.\n-   */\n-  getAnalyzedModules(): NgAnalyzedModules;\n-\n-  /**\n-   * Return the AST for both HTML and template for the contextFile.\n-   */\n-  getTemplateAst(template: TemplateSource): AstResult|undefined;\n-\n-  /**\n-   * Return the template AST for the node that corresponds to the position.\n-   */\n-  getTemplateAstAtPosition(fileName: string, position: number): AstResult|undefined;\n-}\n-\n-/**\n- * The type of Angular directive. Used for QuickInfo in template.\n- */\n-export enum DirectiveKind {\n-  COMPONENT = 'component',\n-  DIRECTIVE = 'directive',\n-  EVENT = 'event',\n-}\n-\n-/**\n- * ScriptElementKind for completion.\n- */\n-export enum CompletionKind {\n-  ANGULAR_ELEMENT = 'angular element',\n-  ATTRIBUTE = 'attribute',\n-  COMPONENT = 'component',\n-  ELEMENT = 'element',\n-  ENTITY = 'entity',\n-  HTML_ATTRIBUTE = 'html attribute',\n-  HTML_ELEMENT = 'html element',\n-  KEY = 'key',\n-  METHOD = 'method',\n-  PIPE = 'pipe',\n-  PROPERTY = 'property',\n-  REFERENCE = 'reference',\n-  TYPE = 'type',\n-  VARIABLE = 'variable',\n-}\n-\n-export type CompletionEntry = Omit<ts.CompletionEntry, 'kind'>&{\n-  kind: CompletionKind,\n-};\n-\n-/**\n- * A template diagnostics message chain. This is similar to the TypeScript\n- * DiagnosticMessageChain. The messages are intended to be formatted as separate\n- * sentence fragments and indented.\n- *\n- * For compatibility previous implementation, the values are expected to override\n- * toString() to return a formatted message.\n- *\n- * @publicApi\n- */\n-export interface DiagnosticMessageChain {\n-  /**\n-   * The text of the diagnostic message to display.\n-   */\n-  message: string;\n-\n-  /**\n-   * The next message in the chain.\n-   */\n-  next?: DiagnosticMessageChain[];\n-}\n-\n-/**\n- * An template diagnostic message to display.\n- *\n- * @publicApi\n- */\n-export interface Diagnostic {\n-  /**\n-   * The kind of diagnostic message\n-   */\n-  kind: ts.DiagnosticCategory;\n-\n-  /**\n-   * The source span that should be highlighted.\n-   */\n-  span: Span;\n-\n-  /**\n-   * The text of the diagnostic message to display or a chain of messages.\n-   */\n-  message: string|DiagnosticMessageChain;\n-}\n-\n-/**\n- * An instance of an Angular language service created by `createLanguageService()`.\n- *\n- * The Angular language service implements a subset of methods defined in\n- * The Angular language service implements a subset of methods defined by\n- * the TypeScript language service.\n- *\n- * @publicApi\n- */\n-export type LanguageService = Pick<\n-    ts.LanguageService,\n-    'getCompletionsAtPosition'|'getDefinitionAndBoundSpan'|'getQuickInfoAtPosition'|\n-    'getSemanticDiagnostics'|'getReferencesAtPosition'>;\n-\n-/** Information about an Angular template AST. */\n-export interface AstResult {\n-  htmlAst: HtmlAst[];\n-  templateAst: TemplateAst[];\n-  directive: CompileDirectiveMetadata;\n-  directives: CompileDirectiveSummary[];\n-  pipes: CompilePipeSummary[];\n-  parseErrors?: ParseError[];\n-  expressionParser: Parser;\n-  template: TemplateSource;\n-}\n-\n-/** Information about a directive's selectors. */\n-export type SelectorInfo = {\n-  selectors: CssSelector[],\n-  map: Map<CssSelector, CompileDirectiveSummary>\n-};\n-\n-export interface SymbolInfo {\n-  symbol: Symbol;\n-  span: ts.TextSpan;\n-  staticSymbol?: StaticSymbol;\n-}\n-\n-/** TODO: this should probably be merged with AstResult */\n-export interface DiagnosticTemplateInfo {\n-  fileName?: string;\n-  offset: number;\n-  query: SymbolQuery;\n-  members: SymbolTable;\n-  htmlAst: HtmlAst[];\n-  templateAst: TemplateAst[];\n-  source: string;\n-}"
        },
        {
            "sha": "9840fde62c1d8641bceb2c841074e11925bbe241",
            "filename": "packages/language-service/src/typescript_host.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 643,
            "changes": 643,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Ftypescript_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Ftypescript_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Ftypescript_host.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,643 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {analyzeNgModules, AotSummaryResolver, CompileDirectiveSummary, CompileMetadataResolver, CompileNgModuleMetadata, CompilePipeSummary, CompilerConfig, DirectiveNormalizer, DirectiveResolver, DomElementSchemaRegistry, FormattedError, FormattedMessageChain, HtmlParser, isFormattedError, JitSummaryResolver, Lexer, NgAnalyzedModules, NgModuleResolver, Parser, ParseTreeResult, PipeResolver, ResourceLoader, StaticReflector, StaticSymbol, StaticSymbolCache, StaticSymbolResolver, TemplateParser, UrlResolver} from '@angular/compiler';\n-import {SchemaMetadata, ViewEncapsulation, Console as Console} from '@angular/core';\n-import * as path from 'path';\n-import * as tss from 'typescript/lib/tsserverlibrary';\n-\n-import {ReflectorHost} from './reflector_host';\n-import {ExternalTemplate, InlineTemplate} from './template';\n-import {findTightestNode, getClassDeclFromDecoratorProp, getDirectiveClassLike, getPropertyAssignmentFromValue} from './ts_utils';\n-import {AstResult, Declaration, DeclarationError, DiagnosticMessageChain, LanguageServiceHost, Span, TemplateSource} from './types';\n-\n-/**\n- * The language service never needs the normalized versions of the metadata. To avoid parsing\n- * the content and resolving references, return an empty file. This also allows normalizing\n- * template that are syntatically incorrect which is required to provide completions in\n- * syntactically incorrect templates.\n- */\n-export class DummyHtmlParser extends HtmlParser {\n-  override parse(): ParseTreeResult {\n-    return new ParseTreeResult([], []);\n-  }\n-}\n-\n-/**\n- * Avoid loading resources in the language servcie by using a dummy loader.\n- */\n-export class DummyResourceLoader extends ResourceLoader {\n-  override get(_url: string): Promise<string> {\n-    return Promise.resolve('');\n-  }\n-}\n-\n-/**\n- * An implementation of a `LanguageServiceHost` for a TypeScript project.\n- *\n- * The `TypeScriptServiceHost` implements the Angular `LanguageServiceHost` using\n- * the TypeScript language services.\n- *\n- * @publicApi\n- */\n-export class TypeScriptServiceHost implements LanguageServiceHost {\n-  private readonly summaryResolver: AotSummaryResolver;\n-  private readonly reflectorHost: ReflectorHost;\n-  private readonly staticSymbolResolver: StaticSymbolResolver;\n-\n-  private readonly staticSymbolCache = new StaticSymbolCache();\n-  /**\n-   * Key of the `fileToComponent` map must be TS internal normalized path (path\n-   * separator must be `/`), value of the map is the StaticSymbol for the\n-   * Component class declaration.\n-   */\n-  private readonly fileToComponent = new Map<ts.server.NormalizedPath, StaticSymbol>();\n-  private readonly collectedErrors = new Map<string, any[]>();\n-  private readonly fileVersions = new Map<string, string>();\n-  private readonly urlResolver: UrlResolver;\n-\n-  private lastProgram: tss.Program|undefined = undefined;\n-  private analyzedModules: NgAnalyzedModules = {\n-    files: [],\n-    ngModuleByPipeOrDirective: new Map(),\n-    ngModules: [],\n-  };\n-\n-  constructor(readonly tsLsHost: tss.LanguageServiceHost, readonly tsLS: tss.LanguageService) {\n-    this.summaryResolver = new AotSummaryResolver(\n-        {\n-          loadSummary(_filePath: string) {\n-            return null;\n-          },\n-          isSourceFile(_sourceFilePath: string) {\n-            return true;\n-          },\n-          toSummaryFileName(sourceFilePath: string) {\n-            return sourceFilePath;\n-          },\n-          fromSummaryFileName(filePath: string): string {\n-            return filePath;\n-          },\n-        },\n-        this.staticSymbolCache);\n-    this.reflectorHost = new ReflectorHost(() => this.program, tsLsHost);\n-    this.staticSymbolResolver = new StaticSymbolResolver(\n-        this.reflectorHost, this.staticSymbolCache, this.summaryResolver,\n-        (e, filePath) => this.collectError(e, filePath));\n-    this.urlResolver = {\n-      resolve: (baseUrl: string, url: string) => {\n-        // In practice, `directoryExists` is always defined.\n-        // https://github.com/microsoft/TypeScript/blob/0b6c9254a850dd07056259d4eefca7721745af75/src/server/project.ts#L1608-L1614\n-        if (tsLsHost.directoryExists!(baseUrl)) {\n-          return path.resolve(baseUrl, url);\n-        }\n-        return path.resolve(path.dirname(baseUrl), url);\n-      }\n-    };\n-  }\n-\n-  // The resolver is instantiated lazily and should not be accessed directly.\n-  // Instead, call the resolver getter. The instantiation of the resolver also\n-  // requires instantiation of the StaticReflector, and the latter requires\n-  // resolution of core Angular symbols. Module resolution should not be done\n-  // during instantiation to avoid cyclic dependency between the plugin and the\n-  // containing Project, so the Singleton pattern is used here.\n-  private _resolver: CompileMetadataResolver|undefined;\n-\n-  /**\n-   * Return the singleton instance of the MetadataResolver.\n-   */\n-  private get resolver(): CompileMetadataResolver {\n-    if (this._resolver) {\n-      return this._resolver;\n-    }\n-    // StaticReflector keeps its own private caches that are not clearable.\n-    // We have no choice but to create a new instance to invalidate the caches.\n-    // TODO: Revisit this when language service gets rewritten for Ivy.\n-    const staticReflector = new StaticReflector(\n-        this.summaryResolver, this.staticSymbolResolver,\n-        [],  // knownMetadataClasses\n-        [],  // knownMetadataFunctions\n-        (e, filePath) => this.collectError(e, filePath));\n-    // Because static reflector above is changed, we need to create a new\n-    // resolver.\n-    const moduleResolver = new NgModuleResolver(staticReflector);\n-    const directiveResolver = new DirectiveResolver(staticReflector);\n-    const pipeResolver = new PipeResolver(staticReflector);\n-    const elementSchemaRegistry = new DomElementSchemaRegistry();\n-    const resourceLoader = new DummyResourceLoader();\n-    const htmlParser = new DummyHtmlParser();\n-    // This tracks the CompileConfig in codegen.ts. Currently these options\n-    // are hard-coded.\n-    const config = new CompilerConfig({\n-      defaultEncapsulation: ViewEncapsulation.Emulated,\n-      useJit: false,\n-    });\n-    const directiveNormalizer =\n-        new DirectiveNormalizer(resourceLoader, this.urlResolver, htmlParser, config);\n-    this._resolver = new CompileMetadataResolver(\n-        config, htmlParser, moduleResolver, directiveResolver, pipeResolver,\n-        new JitSummaryResolver(), elementSchemaRegistry, directiveNormalizer, new Console(),\n-        this.staticSymbolCache, staticReflector,\n-        (error, type) => this.collectError(error, type && type.filePath));\n-    return this._resolver;\n-  }\n-\n-  /**\n-   * Return the singleton instance of the StaticReflector hosted in the\n-   * MetadataResolver.\n-   */\n-  private get reflector(): StaticReflector {\n-    return this.resolver.getReflector() as StaticReflector;\n-  }\n-\n-  /**\n-   * Return all known external templates.\n-   */\n-  getExternalTemplates(): ts.server.NormalizedPath[] {\n-    return [...this.fileToComponent.keys()];\n-  }\n-\n-  /**\n-   * Checks whether the program has changed and returns all analyzed modules.\n-   * If program has changed, invalidate all caches and update fileToComponent\n-   * and templateReferences.\n-   * In addition to returning information about NgModules, this method plays the\n-   * same role as 'synchronizeHostData' in tsserver.\n-   */\n-  getAnalyzedModules(): NgAnalyzedModules {\n-    if (this.upToDate()) {\n-      return this.analyzedModules;\n-    }\n-\n-    // Invalidate caches\n-    this.fileToComponent.clear();\n-    this.collectedErrors.clear();\n-    this.resolver.clearCache();\n-\n-    const analyzeHost = {\n-      isSourceFile(_filePath: string) {\n-        return true;\n-      }\n-    };\n-    const programFiles = this.program.getSourceFiles().map(sf => sf.fileName);\n-\n-    try {\n-      this.analyzedModules =\n-          analyzeNgModules(programFiles, analyzeHost, this.staticSymbolResolver, this.resolver);\n-    } catch (e) {\n-      // Analyzing modules may throw; in that case, reuse the old modules.\n-      this.error(`Analyzing NgModules failed. ${e}`);\n-      return this.analyzedModules;\n-    }\n-\n-    // update template references and fileToComponent\n-    for (const ngModule of this.analyzedModules.ngModules) {\n-      for (const directive of ngModule.declaredDirectives) {\n-        const {metadata} = this.resolver.getNonNormalizedDirectiveMetadata(directive.reference)!;\n-        if (metadata.isComponent && metadata.template && metadata.template.templateUrl) {\n-          const templateName = this.urlResolver.resolve(\n-              this.reflector.componentModuleUrl(directive.reference),\n-              metadata.template.templateUrl);\n-          this.fileToComponent.set(tss.server.toNormalizedPath(templateName), directive.reference);\n-        }\n-      }\n-    }\n-\n-    return this.analyzedModules;\n-  }\n-\n-  /**\n-   * Checks whether the program has changed, and invalidate static symbols in\n-   * the source files that have changed.\n-   * Returns true if modules are up-to-date, false otherwise.\n-   * This should only be called by getAnalyzedModules().\n-   */\n-  private upToDate(): boolean {\n-    const {lastProgram, program} = this;\n-    if (lastProgram === program) {\n-      return true;\n-    }\n-    this.lastProgram = program;\n-\n-    // Even though the program has changed, it could be the case that none of\n-    // the source files have changed. If all source files remain the same, then\n-    // program is still up-to-date, and we should not invalidate caches.\n-    let filesAdded = 0;\n-    const filesChangedOrRemoved: string[] = [];\n-\n-    // Check if any source files have been added / changed since last computation.\n-    const seen = new Set<string>();\n-    const ANGULAR_CORE = '@angular/core';\n-    const corePath = this.reflectorHost.moduleNameToFileName(ANGULAR_CORE);\n-    for (const {fileName} of program.getSourceFiles()) {\n-      // If `@angular/core` is edited, the language service would have to be\n-      // restarted, so ignore changes to `@angular/core`.\n-      // When the StaticReflector is initialized at startup, it loads core\n-      // symbols from @angular/core by calling initializeConversionMap(). This\n-      // is only done once. If the file is invalidated, some of the core symbols\n-      // will be lost permanently.\n-      if (fileName === corePath) {\n-        continue;\n-      }\n-      seen.add(fileName);\n-      const version = this.tsLsHost.getScriptVersion(fileName);\n-      const lastVersion = this.fileVersions.get(fileName);\n-      if (lastVersion === undefined) {\n-        filesAdded++;\n-        this.fileVersions.set(fileName, version);\n-      } else if (version !== lastVersion) {\n-        filesChangedOrRemoved.push(fileName);  // changed\n-        this.fileVersions.set(fileName, version);\n-      }\n-    }\n-\n-    // Check if any source files have been removed since last computation.\n-    for (const [fileName] of this.fileVersions) {\n-      if (!seen.has(fileName)) {\n-        filesChangedOrRemoved.push(fileName);  // removed\n-        // Because Maps are iterated in insertion order, it is safe to delete\n-        // entries from the same map while iterating.\n-        // See https://stackoverflow.com/questions/35940216 and\n-        // https://www.ecma-international.org/ecma-262/10.0/index.html#sec-map.prototype.foreach\n-        this.fileVersions.delete(fileName);\n-      }\n-    }\n-\n-    for (const fileName of filesChangedOrRemoved) {\n-      const symbols = this.staticSymbolResolver.invalidateFile(fileName);\n-      this.reflector.invalidateSymbols(symbols);\n-    }\n-\n-    // Program is up-to-date iff no files are added, changed, or removed.\n-    return filesAdded === 0 && filesChangedOrRemoved.length === 0;\n-  }\n-\n-  /**\n-   * Find all templates in the specified `file`.\n-   * @param fileName TS or HTML file\n-   */\n-  getTemplates(fileName: string): TemplateSource[] {\n-    const results: TemplateSource[] = [];\n-    if (fileName.endsWith('.ts')) {\n-      // Find every template string in the file\n-      const visit = (child: tss.Node) => {\n-        const template = this.getInternalTemplate(child);\n-        if (template) {\n-          results.push(template);\n-        } else {\n-          tss.forEachChild(child, visit);\n-        }\n-      };\n-      const sourceFile = this.getSourceFile(fileName);\n-      if (sourceFile) {\n-        tss.forEachChild(sourceFile, visit);\n-      }\n-    } else {\n-      const template = this.getExternalTemplate(fileName);\n-      if (template) {\n-        results.push(template);\n-      }\n-    }\n-    return results;\n-  }\n-\n-  /**\n-   * Return metadata about all class declarations in the file that are Angular\n-   * directives. Potential matches are `@NgModule`, `@Component`, `@Directive`,\n-   * `@Pipes`, etc. class declarations.\n-   *\n-   * @param fileName TS file\n-   */\n-  getDeclarations(fileName: string): Declaration[] {\n-    if (!fileName.endsWith('.ts')) {\n-      return [];\n-    }\n-    const sourceFile = this.getSourceFile(fileName);\n-    if (!sourceFile) {\n-      return [];\n-    }\n-    const results: Declaration[] = [];\n-    const visit = (child: tss.Node) => {\n-      const candidate = getDirectiveClassLike(child);\n-      if (candidate) {\n-        const {classId} = candidate;\n-        const declarationSpan = spanOf(classId);\n-        const className = classId.getText();\n-        const classSymbol = this.reflector.getStaticSymbol(sourceFile.fileName, className);\n-        // Ask the resolver to check if candidate is actually Angular directive\n-        if (!this.resolver.isDirective(classSymbol)) {\n-          return;\n-        }\n-        const data = this.resolver.getNonNormalizedDirectiveMetadata(classSymbol);\n-        if (!data) {\n-          return;\n-        }\n-        results.push({\n-          type: classSymbol,\n-          declarationSpan,\n-          metadata: data.metadata,\n-          errors: this.getCollectedErrors(declarationSpan, sourceFile),\n-        });\n-      } else {\n-        child.forEachChild(visit);\n-      }\n-    };\n-    tss.forEachChild(sourceFile, visit);\n-\n-    return results;\n-  }\n-\n-  getSourceFile(fileName: string): tss.SourceFile|undefined {\n-    if (!fileName.endsWith('.ts')) {\n-      throw new Error(`Non-TS source file requested: ${fileName}`);\n-    }\n-    return this.program.getSourceFile(fileName);\n-  }\n-\n-  get program(): tss.Program {\n-    const program = this.tsLS.getProgram();\n-    if (!program) {\n-      // Program is very very unlikely to be undefined.\n-      throw new Error('No program in language service!');\n-    }\n-    return program;\n-  }\n-\n-  /**\n-   * Return the TemplateSource if `node` is a template node.\n-   *\n-   * For example,\n-   *\n-   * @Component({\n-   *   template: '<div></div>' <-- template node\n-   * })\n-   * class AppComponent {}\n-   *           ^---- class declaration node\n-   *\n-   * @param node Potential template node\n-   */\n-  private getInternalTemplate(node: tss.Node): TemplateSource|undefined {\n-    if (!tss.isStringLiteralLike(node)) {\n-      return;\n-    }\n-    const tmplAsgn = getPropertyAssignmentFromValue(node, 'template');\n-    if (!tmplAsgn) {\n-      return;\n-    }\n-    const classDecl = getClassDeclFromDecoratorProp(tmplAsgn);\n-    if (!classDecl || !classDecl.name) {  // Does not handle anonymous class\n-      return;\n-    }\n-    const fileName = node.getSourceFile().fileName;\n-    const classSymbol = this.reflector.getStaticSymbol(fileName, classDecl.name.text);\n-    return new InlineTemplate(node, classDecl, classSymbol, this);\n-  }\n-\n-  /**\n-   * Return the external template for `fileName`.\n-   * @param fileName HTML file\n-   */\n-  private getExternalTemplate(fileName: string): TemplateSource|undefined {\n-    // First get the text for the template\n-    const snapshot = this.tsLsHost.getScriptSnapshot(fileName);\n-    if (!snapshot) {\n-      return;\n-    }\n-    const source = snapshot.getText(0, snapshot.getLength());\n-    // Next find the component class symbol\n-    const classSymbol = this.fileToComponent.get(tss.server.toNormalizedPath(fileName));\n-    if (!classSymbol) {\n-      return;\n-    }\n-    // Then use the class symbol to find the actual ts.ClassDeclaration node\n-    const sourceFile = this.getSourceFile(classSymbol.filePath);\n-    if (!sourceFile) {\n-      return;\n-    }\n-    // TODO: This only considers top-level class declarations in a source file.\n-    // This would not find a class declaration in a namespace, for example.\n-    const classDecl = sourceFile.forEachChild((child) => {\n-      if (tss.isClassDeclaration(child) && child.name && child.name.text === classSymbol.name) {\n-        return child;\n-      }\n-    });\n-    if (!classDecl) {\n-      return;\n-    }\n-    return new ExternalTemplate(source, fileName, classDecl, classSymbol, this);\n-  }\n-\n-  private collectError(error: any, filePath?: string) {\n-    if (filePath) {\n-      let errors = this.collectedErrors.get(filePath);\n-      if (!errors) {\n-        errors = [];\n-        this.collectedErrors.set(filePath, errors);\n-      }\n-      errors.push(error);\n-    }\n-  }\n-\n-  private getCollectedErrors(defaultSpan: Span, sourceFile: tss.SourceFile): DeclarationError[] {\n-    const errors = this.collectedErrors.get(sourceFile.fileName);\n-    if (!errors) {\n-      return [];\n-    }\n-    // TODO: Add better typings for the errors\n-    return errors.map((e: any) => {\n-      const line = e.line || (e.position && e.position.line);\n-      const column = e.column || (e.position && e.position.column);\n-      const span = spanAt(sourceFile, line, column) || defaultSpan;\n-      if (isFormattedError(e)) {\n-        return errorToDiagnosticWithChain(e, span);\n-      }\n-      return {message: e.message, span};\n-    });\n-  }\n-\n-  /**\n-   * Return the parsed template for the template at the specified `position`.\n-   * @param fileName TS or HTML file\n-   * @param position Position of the template in the TS file, otherwise ignored.\n-   */\n-  getTemplateAstAtPosition(fileName: string, position: number): AstResult|undefined {\n-    let template: TemplateSource|undefined;\n-    if (fileName.endsWith('.ts')) {\n-      const sourceFile = this.getSourceFile(fileName);\n-      if (!sourceFile) {\n-        return;\n-      }\n-      // Find the node that most closely matches the position\n-      const node = findTightestNode(sourceFile, position);\n-      if (!node) {\n-        return;\n-      }\n-      template = this.getInternalTemplate(node);\n-    } else {\n-      template = this.getExternalTemplate(fileName);\n-    }\n-    if (!template) {\n-      return;\n-    }\n-    return this.getTemplateAst(template);\n-  }\n-\n-  /**\n-   * Find the NgModule which the directive associated with the `classSymbol`\n-   * belongs to, then return its schema and transitive directives and pipes.\n-   * @param classSymbol Angular Symbol that defines a directive\n-   */\n-  private getModuleMetadataForDirective(classSymbol: StaticSymbol) {\n-    const result = {\n-      directives: [] as CompileDirectiveSummary[],\n-      pipes: [] as CompilePipeSummary[],\n-      schemas: [] as SchemaMetadata[],\n-    };\n-    // First find which NgModule the directive belongs to.\n-    const ngModule = this.analyzedModules.ngModuleByPipeOrDirective.get(classSymbol) ||\n-        findSuitableDefaultModule(this.analyzedModules);\n-    if (!ngModule) {\n-      return result;\n-    }\n-    // Then gather all transitive directives and pipes.\n-    const {directives, pipes} = ngModule.transitiveModule;\n-    for (const directive of directives) {\n-      const data = this.resolver.getNonNormalizedDirectiveMetadata(directive.reference);\n-      if (data) {\n-        result.directives.push(data.metadata.toSummary());\n-      }\n-    }\n-    for (const pipe of pipes) {\n-      const metadata = this.resolver.getOrLoadPipeMetadata(pipe.reference);\n-      result.pipes.push(metadata.toSummary());\n-    }\n-    result.schemas.push(...ngModule.schemas);\n-    return result;\n-  }\n-\n-  /**\n-   * Parse the `template` and return its AST, if any.\n-   * @param template template to be parsed\n-   */\n-  getTemplateAst(template: TemplateSource): AstResult|undefined {\n-    const {type: classSymbol, fileName} = template;\n-    const data = this.resolver.getNonNormalizedDirectiveMetadata(classSymbol);\n-    if (!data) {\n-      return;\n-    }\n-    const htmlParser = new HtmlParser();\n-    const expressionParser = new Parser(new Lexer());\n-    const parser = new TemplateParser(\n-        new CompilerConfig(), this.reflector, expressionParser, new DomElementSchemaRegistry(),\n-        htmlParser,\n-        null,  // console\n-        []     // tranforms\n-    );\n-    const htmlResult = htmlParser.parse(template.source, fileName, {\n-      tokenizeExpansionForms: true,\n-      preserveLineEndings: true,  // do not convert CRLF to LF\n-    });\n-    const {directives, pipes, schemas} = this.getModuleMetadataForDirective(classSymbol);\n-    const parseResult = parser.tryParseHtml(htmlResult, data.metadata, directives, pipes, schemas);\n-    if (!parseResult.templateAst) {\n-      return;\n-    }\n-    return {\n-      htmlAst: htmlResult.rootNodes,\n-      templateAst: parseResult.templateAst,\n-      directive: data.metadata,\n-      directives,\n-      pipes,\n-      parseErrors: parseResult.errors,\n-      expressionParser,\n-      template,\n-    };\n-  }\n-\n-  /**\n-   * Log the specified `msg` to file at INFO level. If logging is not enabled\n-   * this method is a no-op.\n-   * @param msg Log message\n-   */\n-  log(msg: string) {\n-    if (this.tsLsHost.log) {\n-      this.tsLsHost.log(msg);\n-    }\n-  }\n-\n-  /**\n-   * Log the specified `msg` to file at ERROR level. If logging is not enabled\n-   * this method is a no-op.\n-   * @param msg error message\n-   */\n-  error(msg: string) {\n-    if (this.tsLsHost.error) {\n-      this.tsLsHost.error(msg);\n-    }\n-  }\n-\n-  /**\n-   * Log debugging info to file at INFO level, only if verbose setting is turned\n-   * on. Otherwise, this method is a no-op.\n-   * @param msg debugging message\n-   */\n-  debug(msg: string) {\n-    const project = this.tsLsHost as tss.server.Project;\n-    if (!project.projectService) {\n-      // tsLsHost is not a Project\n-      return;\n-    }\n-    const {logger} = project.projectService;\n-    if (logger.hasLevel(tss.server.LogLevel.verbose)) {\n-      logger.info(msg);\n-    }\n-  }\n-}\n-\n-function findSuitableDefaultModule(modules: NgAnalyzedModules): CompileNgModuleMetadata|undefined {\n-  let result: CompileNgModuleMetadata|undefined = undefined;\n-  let resultSize = 0;\n-  for (const module of modules.ngModules) {\n-    const moduleSize = module.transitiveModule.directives.length;\n-    if (moduleSize > resultSize) {\n-      result = module;\n-      resultSize = moduleSize;\n-    }\n-  }\n-  return result;\n-}\n-\n-function spanOf(node: tss.Node): Span {\n-  return {start: node.getStart(), end: node.getEnd()};\n-}\n-\n-function spanAt(sourceFile: tss.SourceFile, line: number, column: number): Span|undefined {\n-  if (line != null && column != null) {\n-    const position = tss.getPositionOfLineAndCharacter(sourceFile, line, column);\n-    const findChild = function findChild(node: tss.Node): tss.Node|undefined {\n-      if (node.kind > tss.SyntaxKind.LastToken && node.pos <= position && node.end > position) {\n-        const betterNode = tss.forEachChild(node, findChild);\n-        return betterNode || node;\n-      }\n-    };\n-\n-    const node = tss.forEachChild(sourceFile, findChild);\n-    if (node) {\n-      return {start: node.getStart(), end: node.getEnd()};\n-    }\n-  }\n-}\n-\n-function convertChain(chain: FormattedMessageChain): DiagnosticMessageChain {\n-  return {message: chain.message, next: chain.next ? chain.next.map(convertChain) : undefined};\n-}\n-\n-function errorToDiagnosticWithChain(error: FormattedError, span: Span): DeclarationError {\n-  return {message: error.chain ? convertChain(error.chain) : error.message, span};\n-}"
        },
        {
            "sha": "8fb95f1a981666c19a228710ad7de8cfd1d5b88e",
            "filename": "packages/language-service/src/typescript_symbols.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 959,
            "changes": 959,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Ftypescript_symbols.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Ftypescript_symbols.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Ftypescript_symbols.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,959 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompilePipeSummary, StaticSymbol} from '@angular/compiler';\n-import * as path from 'path';\n-import ts from 'typescript';\n-\n-import {BuiltinType, DeclarationKind, Definition, Signature, Span, Symbol, SymbolDeclaration, SymbolQuery, SymbolTable} from './symbols';\n-\n-// In TypeScript 2.1 these flags moved\n-// These helpers work for both 2.0 and 2.1.\n-const isPrivate = (ts as any).ModifierFlags ?\n-    ((node: ts.Node) =>\n-         !!((ts as any).getCombinedModifierFlags(node) & (ts as any).ModifierFlags.Private)) :\n-    ((node: ts.Node) => !!(node.flags & (ts as any).NodeFlags.Private));\n-\n-const isReferenceType = (ts as any).ObjectFlags ?\n-    ((type: ts.Type) =>\n-         !!(type.flags & (ts as any).TypeFlags.Object &&\n-            (type as any).objectFlags & (ts as any).ObjectFlags.Reference)) :\n-    ((type: ts.Type) => !!(type.flags & (ts as any).TypeFlags.Reference));\n-\n-interface TypeContext {\n-  node: ts.Node;\n-  program: ts.Program;\n-  checker: ts.TypeChecker;\n-}\n-\n-export function getSymbolQuery(\n-    program: ts.Program, checker: ts.TypeChecker, source: ts.SourceFile,\n-    fetchPipes: () => SymbolTable): SymbolQuery {\n-  return new TypeScriptSymbolQuery(program, checker, source, fetchPipes);\n-}\n-\n-export function getClassMembers(\n-    program: ts.Program, checker: ts.TypeChecker, staticSymbol: StaticSymbol): SymbolTable|\n-    undefined {\n-  const declaration = getClassFromStaticSymbol(program, staticSymbol);\n-  if (declaration) {\n-    const type = checker.getTypeAtLocation(declaration);\n-    const node = program.getSourceFile(staticSymbol.filePath);\n-    if (node) {\n-      return new TypeWrapper(type, {node, program, checker}).members();\n-    }\n-  }\n-}\n-\n-export function getClassMembersFromDeclaration(\n-    program: ts.Program, checker: ts.TypeChecker, source: ts.SourceFile,\n-    declaration: ts.ClassDeclaration) {\n-  const type = checker.getTypeAtLocation(declaration);\n-  return new TypeWrapper(type, {node: source, program, checker}).members();\n-}\n-\n-export function getPipesTable(\n-    source: ts.SourceFile, program: ts.Program, checker: ts.TypeChecker,\n-    pipes: CompilePipeSummary[]): SymbolTable {\n-  return new PipesTable(pipes, {program, checker, node: source});\n-}\n-\n-function getClassFromStaticSymbol(program: ts.Program, type: StaticSymbol): ts.ClassDeclaration|\n-    undefined {\n-  const source = program.getSourceFile(type.filePath);\n-  if (source) {\n-    return ts.forEachChild(source, child => {\n-      if (child.kind === ts.SyntaxKind.ClassDeclaration) {\n-        const classDeclaration = child as ts.ClassDeclaration;\n-        if (classDeclaration.name != null && classDeclaration.name.text === type.name) {\n-          return classDeclaration;\n-        }\n-      }\n-    }) as (ts.ClassDeclaration | undefined);\n-  }\n-\n-  return undefined;\n-}\n-\n-class TypeScriptSymbolQuery implements SymbolQuery {\n-  private typeCache = new Map<BuiltinType, Symbol>();\n-  private pipesCache: SymbolTable|undefined;\n-\n-  constructor(\n-      private program: ts.Program, private checker: ts.TypeChecker, private source: ts.SourceFile,\n-      private fetchPipes: () => SymbolTable) {}\n-\n-  getTypeKind(symbol: Symbol): BuiltinType {\n-    const type = symbol instanceof TypeWrapper ? symbol.tsType : undefined;\n-    return typeKindOf(type);\n-  }\n-\n-  getBuiltinType(kind: BuiltinType): Symbol {\n-    let result = this.typeCache.get(kind);\n-    if (!result) {\n-      const type = getTsTypeFromBuiltinType(kind, {\n-        checker: this.checker,\n-        node: this.source,\n-        program: this.program,\n-      });\n-      result =\n-          new TypeWrapper(type, {program: this.program, checker: this.checker, node: this.source});\n-      this.typeCache.set(kind, result);\n-    }\n-    return result;\n-  }\n-\n-  getTypeUnion(...types: Symbol[]): Symbol {\n-    // No API exists so return any if the types are not all the same type.\n-    let result: Symbol|undefined = undefined;\n-    if (types.length) {\n-      result = types[0];\n-      for (let i = 1; i < types.length; i++) {\n-        if (types[i] != result) {\n-          result = undefined;\n-          break;\n-        }\n-      }\n-    }\n-    return result || this.getBuiltinType(BuiltinType.Any);\n-  }\n-\n-  getArrayType(_type: Symbol): Symbol {\n-    return this.getBuiltinType(BuiltinType.Any);\n-  }\n-\n-  getElementType(type: Symbol): Symbol|undefined {\n-    if (type instanceof TypeWrapper) {\n-      const ty = type.tsType;\n-      const tyArgs = type.typeArguments();\n-      // TODO(ayazhafiz): Track https://github.com/microsoft/TypeScript/issues/37711 to expose\n-      // `isArrayLikeType` as a public method.\n-      if (!(this.checker as any).isArrayLikeType(ty) || tyArgs?.length !== 1) return;\n-      return tyArgs[0];\n-    }\n-  }\n-\n-  getNonNullableType(symbol: Symbol): Symbol {\n-    if (symbol instanceof TypeWrapper && (typeof this.checker.getNonNullableType == 'function')) {\n-      const tsType = symbol.tsType;\n-      const nonNullableType = this.checker.getNonNullableType(tsType);\n-      if (nonNullableType != tsType) {\n-        return new TypeWrapper(nonNullableType, symbol.context);\n-      } else if (nonNullableType == tsType) {\n-        return symbol;\n-      }\n-    }\n-    return this.getBuiltinType(BuiltinType.Any);\n-  }\n-\n-  getPipes(): SymbolTable {\n-    let result = this.pipesCache;\n-    if (!result) {\n-      result = this.pipesCache = this.fetchPipes();\n-    }\n-    return result;\n-  }\n-\n-  getTemplateContext(type: StaticSymbol): SymbolTable|undefined {\n-    const context: TypeContext = {node: this.source, program: this.program, checker: this.checker};\n-    const typeSymbol = findClassSymbolInContext(type, context);\n-    if (typeSymbol) {\n-      const contextType = this.getTemplateRefContextType(typeSymbol, context);\n-      if (contextType) return contextType.members();\n-    }\n-  }\n-\n-  getTypeSymbol(type: StaticSymbol): Symbol|undefined {\n-    const context: TypeContext = {node: this.source, program: this.program, checker: this.checker};\n-    const typeSymbol = findClassSymbolInContext(type, context);\n-    return typeSymbol && new SymbolWrapper(typeSymbol, context);\n-  }\n-\n-  createSymbolTable(symbols: SymbolDeclaration[]): SymbolTable {\n-    const result = new MapSymbolTable();\n-    result.addAll(symbols.map(s => new DeclaredSymbol(s)));\n-    return result;\n-  }\n-\n-  mergeSymbolTable(symbolTables: SymbolTable[]): SymbolTable {\n-    const result = new MapSymbolTable();\n-    for (const symbolTable of symbolTables) {\n-      result.addAll(symbolTable.values());\n-    }\n-    return result;\n-  }\n-\n-  getSpanAt(line: number, column: number): Span|undefined {\n-    return spanAt(this.source, line, column);\n-  }\n-\n-  private getTemplateRefContextType(typeSymbol: ts.Symbol, context: TypeContext): Symbol|undefined {\n-    const type = this.checker.getTypeOfSymbolAtLocation(typeSymbol, this.source);\n-    const constructor = type.symbol && type.symbol.members &&\n-        getFromSymbolTable(type.symbol.members!, '__constructor');\n-\n-    if (constructor) {\n-      const constructorDeclaration = constructor.declarations![0] as ts.ConstructorTypeNode;\n-      for (const parameter of constructorDeclaration.parameters) {\n-        const type = this.checker.getTypeAtLocation(parameter.type!);\n-        if (type.symbol!.name == 'TemplateRef' && isReferenceType(type)) {\n-          const typeWrapper = new TypeWrapper(type, context);\n-          const typeArguments = typeWrapper.typeArguments();\n-          if (typeArguments && typeArguments.length === 1) {\n-            return typeArguments[0];\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-function typeCallable(type: ts.Type): boolean {\n-  const signatures = type.getCallSignatures();\n-  return signatures && signatures.length != 0;\n-}\n-\n-function signaturesOf(type: ts.Type, context: TypeContext): Signature[] {\n-  return type.getCallSignatures().map(s => new SignatureWrapper(s, context));\n-}\n-\n-function selectSignature(type: ts.Type, context: TypeContext, types: Symbol[]): Signature|\n-    undefined {\n-  // TODO: Do a better job of selecting the right signature. TypeScript does not currently support a\n-  // Type Relationship API (see https://github.com/angular/vscode-ng-language-service/issues/143).\n-  // Consider creating a TypeCheckBlock host in the language service that may also act as a\n-  // scratchpad for type comparisons.\n-  const signatures = type.getCallSignatures();\n-  const passedInTypes: Array<ts.Type|undefined> = types.map(type => {\n-    if (type instanceof TypeWrapper) {\n-      return type.tsType;\n-    }\n-  });\n-  // Try to select a matching signature in which all parameter types match.\n-  // Note that this is just a best-effort approach, because we're checking for\n-  // strict type equality rather than compatibility.\n-  // For example, if the signature contains a ReadonlyArray<number> and the\n-  // passed parameter type is an Array<number>, this will fail.\n-  function allParameterTypesMatch(signature: ts.Signature) {\n-    const tc = context.checker;\n-    return signature.getParameters().every((parameter: ts.Symbol, i: number) => {\n-      if (parameter.valueDeclaration === undefined) {\n-        return false;\n-      }\n-      const type = tc.getTypeOfSymbolAtLocation(parameter, parameter.valueDeclaration);\n-      return type === passedInTypes[i];\n-    });\n-  }\n-  const exactMatch = signatures.find(allParameterTypesMatch);\n-  if (exactMatch) {\n-    return new SignatureWrapper(exactMatch, context);\n-  }\n-  // If not, fallback to a naive selection\n-  return signatures.length ? new SignatureWrapper(signatures[0], context) : undefined;\n-}\n-\n-class TypeWrapper implements Symbol {\n-  constructor(public tsType: ts.Type, public context: TypeContext) {\n-    if (!tsType) {\n-      throw Error('Internal: null type');\n-    }\n-  }\n-\n-  get name(): string {\n-    return this.context.checker.typeToString(this.tsType);\n-  }\n-\n-  public readonly kind: DeclarationKind = 'type';\n-\n-  public readonly language: string = 'typescript';\n-\n-  public readonly type: Symbol|undefined = undefined;\n-\n-  public readonly container: Symbol|undefined = undefined;\n-\n-  public readonly public: boolean = true;\n-\n-  get callable(): boolean {\n-    return typeCallable(this.tsType);\n-  }\n-\n-  get nullable(): boolean {\n-    return this.context.checker.getNonNullableType(this.tsType) != this.tsType;\n-  }\n-\n-  get documentation(): ts.SymbolDisplayPart[] {\n-    const symbol = this.tsType.getSymbol();\n-    if (!symbol) {\n-      return [];\n-    }\n-    return symbol.getDocumentationComment(this.context.checker);\n-  }\n-\n-  get definition(): Definition|undefined {\n-    const symbol = this.tsType.getSymbol();\n-    return symbol ? definitionFromTsSymbol(symbol) : undefined;\n-  }\n-\n-  members(): SymbolTable {\n-    // Should call getApparentProperties() instead of getProperties() because\n-    // the former includes properties on the base class whereas the latter does\n-    // not. This provides properties like .bind(), .call(), .apply(), etc for\n-    // functions.\n-    return new SymbolTableWrapper(this.tsType.getApparentProperties(), this.context, this.tsType);\n-  }\n-\n-  signatures(): Signature[] {\n-    return signaturesOf(this.tsType, this.context);\n-  }\n-\n-  selectSignature(types: Symbol[]): Signature|undefined {\n-    return selectSignature(this.tsType, this.context, types);\n-  }\n-\n-  indexed(type: Symbol, value: any): Symbol|undefined {\n-    if (!(type instanceof TypeWrapper)) return;\n-\n-    const typeKind = typeKindOf(type.tsType);\n-    switch (typeKind) {\n-      case BuiltinType.Number:\n-        const nType = this.tsType.getNumberIndexType();\n-        if (nType) {\n-          // get the right tuple type by value, like 'var t: [number, string];'\n-          if (nType.isUnion()) {\n-            // return undefined if array index out of bound.\n-            return nType.types[value] && new TypeWrapper(nType.types[value], this.context);\n-          }\n-          return new TypeWrapper(nType, this.context);\n-        }\n-        return undefined;\n-      case BuiltinType.String:\n-        const sType = this.tsType.getStringIndexType();\n-        return sType && new TypeWrapper(sType, this.context);\n-    }\n-  }\n-\n-  typeArguments(): Symbol[]|undefined {\n-    if (!isReferenceType(this.tsType)) return;\n-\n-    const typeReference = (this.tsType as ts.TypeReference);\n-    let typeArguments: ReadonlyArray<ts.Type>|undefined;\n-    typeArguments = this.context.checker.getTypeArguments(typeReference);\n-    if (!typeArguments) return undefined;\n-    return typeArguments.map(ta => new TypeWrapper(ta, this.context));\n-  }\n-}\n-\n-// If stringIndexType a primitive type(e.g. 'string'), the Symbol is undefined;\n-// and in AstType.resolvePropertyRead method, the Symbol.type should get the right type.\n-class StringIndexTypeWrapper extends TypeWrapper {\n-  public override readonly type = new TypeWrapper(this.tsType, this.context);\n-}\n-\n-class SymbolWrapper implements Symbol {\n-  private symbol: ts.Symbol;\n-  private _members?: SymbolTable;\n-\n-  public readonly nullable: boolean = false;\n-  public readonly language: string = 'typescript';\n-\n-  constructor(\n-      symbol: ts.Symbol,\n-      /** TypeScript type context of the symbol. */\n-      private context: TypeContext,\n-      /**\n-       * Type of the TypeScript symbol, if known. If not provided, the type of the symbol\n-       * will be determined dynamically; see `SymbolWrapper#tsType`.\n-       */\n-      private _tsType?: ts.Type) {\n-    this.symbol = symbol && context && (symbol.flags & ts.SymbolFlags.Alias) ?\n-        context.checker.getAliasedSymbol(symbol) :\n-        symbol;\n-  }\n-\n-  get name(): string {\n-    return this.symbol.name;\n-  }\n-\n-  get kind(): DeclarationKind {\n-    return this.callable ? 'method' : 'property';\n-  }\n-\n-  get type(): TypeWrapper {\n-    return new TypeWrapper(this.tsType, this.context);\n-  }\n-\n-  get container(): Symbol|undefined {\n-    return getContainerOf(this.symbol, this.context);\n-  }\n-\n-  get public(): boolean {\n-    // Symbols that are not explicitly made private are public.\n-    return !isSymbolPrivate(this.symbol);\n-  }\n-\n-  get callable(): boolean {\n-    return typeCallable(this.tsType);\n-  }\n-\n-  get definition(): Definition {\n-    return definitionFromTsSymbol(this.symbol);\n-  }\n-\n-  get documentation(): ts.SymbolDisplayPart[] {\n-    return this.symbol.getDocumentationComment(this.context.checker);\n-  }\n-\n-  members(): SymbolTable {\n-    if (!this._members) {\n-      if ((this.symbol.flags & (ts.SymbolFlags.Class | ts.SymbolFlags.Interface)) != 0) {\n-        const declaredType = this.context.checker.getDeclaredTypeOfSymbol(this.symbol);\n-        const typeWrapper = new TypeWrapper(declaredType, this.context);\n-        this._members = typeWrapper.members();\n-      } else {\n-        this._members = new SymbolTableWrapper(this.symbol.members!, this.context, this.tsType);\n-      }\n-    }\n-    return this._members;\n-  }\n-\n-  signatures(): Signature[] {\n-    return signaturesOf(this.tsType, this.context);\n-  }\n-\n-  selectSignature(types: Symbol[]): Signature|undefined {\n-    return selectSignature(this.tsType, this.context, types);\n-  }\n-\n-  indexed(_argument: Symbol): Symbol|undefined {\n-    return undefined;\n-  }\n-\n-  typeArguments(): Symbol[]|undefined {\n-    return this.type.typeArguments();\n-  }\n-\n-  private get tsType(): ts.Type {\n-    let type = this._tsType;\n-    if (!type) {\n-      type = this._tsType =\n-          this.context.checker.getTypeOfSymbolAtLocation(this.symbol, this.context.node);\n-    }\n-    return type;\n-  }\n-}\n-\n-class DeclaredSymbol implements Symbol {\n-  public readonly language: string = 'ng-template';\n-\n-  public readonly nullable: boolean = false;\n-\n-  public readonly public: boolean = true;\n-\n-  constructor(private declaration: SymbolDeclaration) {}\n-\n-  get name() {\n-    return this.declaration.name;\n-  }\n-\n-  get kind() {\n-    return this.declaration.kind;\n-  }\n-\n-  get container(): Symbol|undefined {\n-    return undefined;\n-  }\n-\n-  get type(): Symbol {\n-    return this.declaration.type;\n-  }\n-\n-  get callable(): boolean {\n-    return this.type.callable;\n-  }\n-\n-  get definition(): Definition {\n-    return this.declaration.definition;\n-  }\n-\n-  get documentation(): ts.SymbolDisplayPart[] {\n-    return this.declaration.type.documentation;\n-  }\n-\n-  members(): SymbolTable {\n-    return this.type.members();\n-  }\n-\n-  signatures(): Signature[] {\n-    return this.type.signatures();\n-  }\n-\n-  selectSignature(types: Symbol[]): Signature|undefined {\n-    return this.type.selectSignature(types);\n-  }\n-\n-  typeArguments(): Symbol[]|undefined {\n-    return this.type.typeArguments();\n-  }\n-\n-  indexed(_argument: Symbol): Symbol|undefined {\n-    return undefined;\n-  }\n-}\n-\n-class SignatureWrapper implements Signature {\n-  constructor(private signature: ts.Signature, private context: TypeContext) {}\n-\n-  get arguments(): SymbolTable {\n-    return new SymbolTableWrapper(this.signature.getParameters(), this.context);\n-  }\n-\n-  get result(): Symbol {\n-    return new TypeWrapper(this.signature.getReturnType(), this.context);\n-  }\n-}\n-\n-class SignatureResultOverride implements Signature {\n-  constructor(private signature: Signature, private resultType: Symbol) {}\n-\n-  get arguments(): SymbolTable {\n-    return this.signature.arguments;\n-  }\n-\n-  get result(): Symbol {\n-    return this.resultType;\n-  }\n-}\n-\n-function toSymbolTableFactory(symbols: ts.Symbol[]): ts.SymbolTable {\n-  //  Typescript version >= 2.2, `SymbolTable` is implemented as an ES6 `Map`\n-  const result = new Map<string, ts.Symbol>();\n-  for (const symbol of symbols) {\n-    result.set(symbol.name, symbol);\n-  }\n-\n-  return result as ts.SymbolTable;\n-}\n-\n-function toSymbols(symbolTable: ts.SymbolTable|undefined): ts.Symbol[] {\n-  if (!symbolTable) return [];\n-\n-  const table = symbolTable as any;\n-\n-  if (typeof table.values === 'function') {\n-    return Array.from(table.values()) as ts.Symbol[];\n-  }\n-\n-  const result: ts.Symbol[] = [];\n-\n-  const own = typeof table.hasOwnProperty === 'function' ?\n-      (name: string) => table.hasOwnProperty(name) :\n-      (name: string) => !!table[name];\n-\n-  for (const name in table) {\n-    if (own(name)) {\n-      result.push(table[name]);\n-    }\n-  }\n-  return result;\n-}\n-\n-class SymbolTableWrapper implements SymbolTable {\n-  private symbols: ts.Symbol[];\n-  private symbolTable: ts.SymbolTable;\n-  private stringIndexType?: ts.Type;\n-\n-  /**\n-   * Creates a queryable table of symbols belonging to a TypeScript entity.\n-   * @param symbols symbols to query belonging to the entity\n-   * @param context program context\n-   * @param type original TypeScript type of entity owning the symbols, if known\n-   */\n-  constructor(symbols: ts.SymbolTable|ts.Symbol[], private context: TypeContext, type?: ts.Type) {\n-    symbols = symbols || [];\n-\n-    if (Array.isArray(symbols)) {\n-      this.symbols = symbols;\n-      this.symbolTable = toSymbolTableFactory(symbols);\n-    } else {\n-      this.symbols = toSymbols(symbols);\n-      this.symbolTable = symbols;\n-    }\n-\n-    if (type) {\n-      this.stringIndexType = type.getStringIndexType();\n-    }\n-  }\n-\n-  get size(): number {\n-    return this.symbols.length;\n-  }\n-\n-  get(key: string): Symbol|undefined {\n-    const symbol = getFromSymbolTable(this.symbolTable, key);\n-    if (symbol) {\n-      return new SymbolWrapper(symbol, this.context);\n-    }\n-\n-    if (this.stringIndexType) {\n-      // If the key does not exist as an explicit symbol on the type, it may be accessing a string\n-      // index signature using dot notation:\n-      //\n-      //   const obj<T>: { [key: string]: T };\n-      //   obj.stringIndex // equivalent to obj['stringIndex'];\n-      //\n-      // In this case, return the type indexed by an arbitrary string key.\n-      return new StringIndexTypeWrapper(this.stringIndexType, this.context);\n-    }\n-\n-    return undefined;\n-  }\n-\n-  has(key: string): boolean {\n-    const table: any = this.symbolTable;\n-    return ((typeof table.has === 'function') ? table.has(key) : table[key] != null) ||\n-        this.stringIndexType !== undefined;\n-  }\n-\n-  values(): Symbol[] {\n-    return this.symbols.map(s => new SymbolWrapper(s, this.context));\n-  }\n-}\n-\n-class MapSymbolTable implements SymbolTable {\n-  private map = new Map<string, Symbol>();\n-  private _values: Symbol[] = [];\n-\n-  get size(): number {\n-    return this.map.size;\n-  }\n-\n-  get(key: string): Symbol|undefined {\n-    return this.map.get(key);\n-  }\n-\n-  add(symbol: Symbol) {\n-    if (this.map.has(symbol.name)) {\n-      const previous = this.map.get(symbol.name)!;\n-      this._values[this._values.indexOf(previous)] = symbol;\n-    }\n-    this.map.set(symbol.name, symbol);\n-    this._values.push(symbol);\n-  }\n-\n-  addAll(symbols: Symbol[]) {\n-    for (const symbol of symbols) {\n-      this.add(symbol);\n-    }\n-  }\n-\n-  has(key: string): boolean {\n-    return this.map.has(key);\n-  }\n-\n-  values(): Symbol[] {\n-    // Switch to this.map.values once iterables are supported by the target language.\n-    return this._values;\n-  }\n-}\n-\n-class PipesTable implements SymbolTable {\n-  constructor(private pipes: CompilePipeSummary[], private context: TypeContext) {}\n-\n-  get size() {\n-    return this.pipes.length;\n-  }\n-\n-  get(key: string): Symbol|undefined {\n-    const pipe = this.pipes.find(pipe => pipe.name == key);\n-    if (pipe) {\n-      return new PipeSymbol(pipe, this.context);\n-    }\n-  }\n-\n-  has(key: string): boolean {\n-    return this.pipes.find(pipe => pipe.name == key) != null;\n-  }\n-\n-  values(): Symbol[] {\n-    return this.pipes.map(pipe => new PipeSymbol(pipe, this.context));\n-  }\n-}\n-\n-// This matches .d.ts files that look like \".../<package-name>/<package-name>.d.ts\",\n-const INDEX_PATTERN = /[\\\\/]([^\\\\/]+)[\\\\/]\\1\\.d\\.ts$/;\n-\n-class PipeSymbol implements Symbol {\n-  private _tsType: ts.Type|undefined;\n-  public readonly kind: DeclarationKind = 'pipe';\n-  public readonly language: string = 'typescript';\n-  public readonly container: Symbol|undefined = undefined;\n-  public readonly callable: boolean = true;\n-  public readonly nullable: boolean = false;\n-  public readonly public: boolean = true;\n-\n-  constructor(private pipe: CompilePipeSummary, private context: TypeContext) {}\n-\n-  get name(): string {\n-    return this.pipe.name;\n-  }\n-\n-  get type(): TypeWrapper {\n-    return new TypeWrapper(this.tsType, this.context);\n-  }\n-\n-  get definition(): Definition|undefined {\n-    const symbol = this.tsType.getSymbol();\n-    return symbol ? definitionFromTsSymbol(symbol) : undefined;\n-  }\n-\n-  get documentation(): ts.SymbolDisplayPart[] {\n-    const symbol = this.tsType.getSymbol();\n-    if (!symbol) {\n-      return [];\n-    }\n-    return symbol.getDocumentationComment(this.context.checker);\n-  }\n-\n-  members(): SymbolTable {\n-    return EmptyTable.instance;\n-  }\n-\n-  signatures(): Signature[] {\n-    return signaturesOf(this.tsType, this.context);\n-  }\n-\n-  selectSignature(types: Symbol[]): Signature|undefined {\n-    let signature = selectSignature(this.tsType, this.context, types)!;\n-    if (types.length > 0) {\n-      const parameterType = types[0];\n-      let resultType: Symbol|undefined = undefined;\n-      switch (this.name) {\n-        case 'async':\n-          // Get type argument of 'Observable', 'Promise', or 'EventEmitter'.\n-          const tArgs = parameterType.typeArguments();\n-          if (tArgs && tArgs.length === 1) {\n-            resultType = tArgs[0];\n-          }\n-          break;\n-        case 'slice':\n-          resultType = parameterType;\n-          break;\n-      }\n-      if (resultType) {\n-        signature = new SignatureResultOverride(signature, resultType);\n-      }\n-    }\n-    return signature;\n-  }\n-\n-  indexed(_argument: Symbol): Symbol|undefined {\n-    return undefined;\n-  }\n-\n-  typeArguments(): Symbol[]|undefined {\n-    return this.type.typeArguments();\n-  }\n-\n-  private get tsType(): ts.Type {\n-    let type = this._tsType;\n-    if (!type) {\n-      const classSymbol = this.findClassSymbol(this.pipe.type.reference);\n-      if (classSymbol) {\n-        type = this._tsType = this.findTransformMethodType(classSymbol)!;\n-      }\n-      if (!type) {\n-        type = this._tsType = getTsTypeFromBuiltinType(BuiltinType.Any, this.context);\n-      }\n-    }\n-    return type;\n-  }\n-\n-  private findClassSymbol(type: StaticSymbol): ts.Symbol|undefined {\n-    return findClassSymbolInContext(type, this.context);\n-  }\n-\n-  private findTransformMethodType(classSymbol: ts.Symbol): ts.Type|undefined {\n-    const classType = this.context.checker.getDeclaredTypeOfSymbol(classSymbol);\n-    if (classType) {\n-      const transform = classType.getProperty('transform');\n-      if (transform) {\n-        return this.context.checker.getTypeOfSymbolAtLocation(transform, this.context.node);\n-      }\n-    }\n-  }\n-}\n-\n-function findClassSymbolInContext(type: StaticSymbol, context: TypeContext): ts.Symbol|undefined {\n-  let sourceFile = context.program.getSourceFile(type.filePath);\n-  if (!sourceFile) {\n-    // This handles a case where an <packageName>/index.d.ts and a <packageName>/<packageName>.d.ts\n-    // are in the same directory. If we are looking for <packageName>/<packageName> and didn't\n-    // find it, look for <packageName>/index.d.ts as the program might have found that instead.\n-    const p = type.filePath;\n-    const m = p.match(INDEX_PATTERN);\n-    if (m) {\n-      const indexVersion = path.join(path.dirname(p), 'index.d.ts');\n-      sourceFile = context.program.getSourceFile(indexVersion);\n-    }\n-  }\n-  if (sourceFile) {\n-    const moduleSymbol = (sourceFile as any).module || (sourceFile as any).symbol;\n-    const exports = context.checker.getExportsOfModule(moduleSymbol);\n-    return (exports || []).find(symbol => symbol.name == type.name);\n-  }\n-}\n-\n-class EmptyTable implements SymbolTable {\n-  public readonly size: number = 0;\n-  get(_key: string): Symbol|undefined {\n-    return undefined;\n-  }\n-  has(_key: string): boolean {\n-    return false;\n-  }\n-  values(): Symbol[] {\n-    return [];\n-  }\n-  static instance = new EmptyTable();\n-}\n-\n-function isSymbolPrivate(s: ts.Symbol): boolean {\n-  return !!s.valueDeclaration && isPrivate(s.valueDeclaration);\n-}\n-\n-function getTsTypeFromBuiltinType(builtinType: BuiltinType, ctx: TypeContext): ts.Type {\n-  let syntaxKind: ts.SyntaxKind;\n-  switch (builtinType) {\n-    case BuiltinType.Any:\n-      syntaxKind = ts.SyntaxKind.AnyKeyword;\n-      break;\n-    case BuiltinType.Boolean:\n-      syntaxKind = ts.SyntaxKind.BooleanKeyword;\n-      break;\n-    case BuiltinType.Null:\n-      syntaxKind = ts.SyntaxKind.NullKeyword;\n-      break;\n-    case BuiltinType.Number:\n-      syntaxKind = ts.SyntaxKind.NumberKeyword;\n-      break;\n-    case BuiltinType.String:\n-      syntaxKind = ts.SyntaxKind.StringKeyword;\n-      break;\n-    case BuiltinType.Undefined:\n-      syntaxKind = ts.SyntaxKind.UndefinedKeyword;\n-      break;\n-    default:\n-      throw new Error(\n-          `Internal error, unhandled literal kind ${builtinType}:${BuiltinType[builtinType]}`);\n-  }\n-  const node = ts.createNode(syntaxKind);\n-  (node.parent as ts.Node) = ts.createEmptyStatement();\n-  return ctx.checker.getTypeAtLocation(node);\n-}\n-\n-function spanAt(sourceFile: ts.SourceFile, line: number, column: number): Span|undefined {\n-  if (line != null && column != null) {\n-    const position = ts.getPositionOfLineAndCharacter(sourceFile, line, column);\n-    const findChild = function findChild(node: ts.Node): ts.Node|undefined {\n-      if (node.kind > ts.SyntaxKind.LastToken && node.pos <= position && node.end > position) {\n-        const betterNode = ts.forEachChild(node, findChild);\n-        return betterNode || node;\n-      }\n-    };\n-\n-    const node = ts.forEachChild(sourceFile, findChild);\n-    if (node) {\n-      return {start: node.getStart(), end: node.getEnd()};\n-    }\n-  }\n-}\n-\n-function definitionFromTsSymbol(symbol: ts.Symbol): Definition {\n-  const declarations = symbol.declarations;\n-  if (declarations) {\n-    return declarations.map(declaration => {\n-      const sourceFile = declaration.getSourceFile();\n-      return {\n-        fileName: sourceFile.fileName,\n-        span: {start: declaration.getStart(), end: declaration.getEnd()}\n-      };\n-    });\n-  }\n-}\n-\n-function parentDeclarationOf(node: ts.Node): ts.Node|undefined {\n-  while (node) {\n-    switch (node.kind) {\n-      case ts.SyntaxKind.ClassDeclaration:\n-      case ts.SyntaxKind.InterfaceDeclaration:\n-        return node;\n-      case ts.SyntaxKind.SourceFile:\n-        return undefined;\n-    }\n-    node = node.parent!;\n-  }\n-}\n-\n-function getContainerOf(symbol: ts.Symbol, context: TypeContext): Symbol|undefined {\n-  if (symbol.getFlags() & ts.SymbolFlags.ClassMember && symbol.declarations) {\n-    for (const declaration of symbol.declarations) {\n-      const parent = parentDeclarationOf(declaration);\n-      if (parent) {\n-        const type = context.checker.getTypeAtLocation(parent);\n-        if (type) {\n-          return new TypeWrapper(type, context);\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-function typeKindOf(type: ts.Type|undefined): BuiltinType {\n-  if (type) {\n-    if (type.flags & ts.TypeFlags.Any) {\n-      return BuiltinType.Any;\n-    } else if (\n-        type.flags & (ts.TypeFlags.String | ts.TypeFlags.StringLike | ts.TypeFlags.StringLiteral)) {\n-      return BuiltinType.String;\n-    } else if (type.flags & (ts.TypeFlags.Number | ts.TypeFlags.NumberLike)) {\n-      return BuiltinType.Number;\n-    } else if (type.flags & ts.TypeFlags.Object) {\n-      return BuiltinType.Object;\n-    } else if (type.flags & (ts.TypeFlags.Undefined)) {\n-      return BuiltinType.Undefined;\n-    } else if (type.flags & (ts.TypeFlags.Null)) {\n-      return BuiltinType.Null;\n-    } else if (type.flags & ts.TypeFlags.Union) {\n-      const unionType = type as ts.UnionType;\n-      if (unionType.types.length === 0) return BuiltinType.Other;\n-      let ty: BuiltinType = 0;\n-      for (const subType of unionType.types) {\n-        ty |= typeKindOf(subType);\n-      }\n-      return ty;\n-    } else if (type.flags & ts.TypeFlags.TypeParameter) {\n-      return BuiltinType.Unbound;\n-    }\n-  }\n-  return BuiltinType.Other;\n-}\n-\n-function getFromSymbolTable(symbolTable: ts.SymbolTable, key: string): ts.Symbol|undefined {\n-  const table = symbolTable as any;\n-  let symbol: ts.Symbol|undefined;\n-\n-  if (typeof table.get === 'function') {\n-    // TS 2.2 uses a Map\n-    symbol = table.get(key);\n-  } else {\n-    // TS pre-2.2 uses an object\n-    symbol = table[key];\n-  }\n-\n-  return symbol;\n-}"
        },
        {
            "sha": "5eddc26584c775d6705502fab1de8de68718e653",
            "filename": "packages/language-service/src/utils.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 217,
            "changes": 217,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Fsrc%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Futils.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,217 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {AstPath, BoundEventAst, CompileDirectiveSummary, CompileTypeMetadata, CssSelector, DirectiveAst, ElementAst, EmbeddedTemplateAst, HtmlAstPath, identifierName, Identifiers, Node, ParseSourceSpan, RecursiveTemplateAstVisitor, RecursiveVisitor, TemplateAst, TemplateAstPath, templateVisitAll, visitAll} from '@angular/compiler';\n-import * as path from 'path';\n-\n-import {AstResult, DiagnosticTemplateInfo, SelectorInfo, Span, Symbol, SymbolQuery} from './types';\n-\n-interface SpanHolder {\n-  sourceSpan: ParseSourceSpan;\n-  endSourceSpan?: ParseSourceSpan|null;\n-  children?: SpanHolder[];\n-}\n-\n-function isParseSourceSpan(value: any): value is ParseSourceSpan {\n-  return value && !!value.start;\n-}\n-\n-export function spanOf(span: SpanHolder): Span;\n-export function spanOf(span: ParseSourceSpan): Span;\n-export function spanOf(span: SpanHolder|ParseSourceSpan|undefined): Span|undefined;\n-export function spanOf(span?: SpanHolder|ParseSourceSpan): Span|undefined {\n-  if (!span) return undefined;\n-  if (isParseSourceSpan(span)) {\n-    return {start: span.start.offset, end: span.end.offset};\n-  } else {\n-    if (span.endSourceSpan) {\n-      return {start: span.sourceSpan.start.offset, end: span.endSourceSpan.end.offset};\n-    } else if (span.children && span.children.length) {\n-      return {\n-        start: span.sourceSpan.start.offset,\n-        end: spanOf(span.children[span.children.length - 1])!.end\n-      };\n-    }\n-    return {start: span.sourceSpan.start.offset, end: span.sourceSpan.end.offset};\n-  }\n-}\n-\n-export function inSpan(position: number, span?: Span, exclusive?: boolean): boolean {\n-  return span != null &&\n-      (exclusive ? position >= span.start && position < span.end :\n-                   position >= span.start && position <= span.end);\n-}\n-\n-export function offsetSpan(span: Span, amount: number): Span {\n-  return {start: span.start + amount, end: span.end + amount};\n-}\n-\n-export function isNarrower(spanA: Span, spanB: Span): boolean {\n-  return spanA.start >= spanB.start && spanA.end <= spanB.end;\n-}\n-\n-export function isStructuralDirective(type: CompileTypeMetadata): boolean {\n-  for (const diDep of type.diDeps) {\n-    const diDepName = identifierName(diDep.token?.identifier);\n-    if (diDepName === Identifiers.TemplateRef.name ||\n-        diDepName === Identifiers.ViewContainerRef.name) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-export function getSelectors(info: AstResult): SelectorInfo {\n-  const map = new Map<CssSelector, CompileDirectiveSummary>();\n-  const results: CssSelector[] = [];\n-  for (const directive of info.directives) {\n-    const selectors: CssSelector[] = CssSelector.parse(directive.selector!);\n-    for (const selector of selectors) {\n-      results.push(selector);\n-      map.set(selector, directive);\n-    }\n-  }\n-  return {selectors: results, map};\n-}\n-\n-export function diagnosticInfoFromTemplateInfo(info: AstResult): DiagnosticTemplateInfo {\n-  return {\n-    fileName: info.template.fileName,\n-    offset: info.template.span.start,\n-    query: info.template.query,\n-    members: info.template.members,\n-    htmlAst: info.htmlAst,\n-    templateAst: info.templateAst,\n-    source: info.template.source,\n-  };\n-}\n-\n-export function findTemplateAstAt(ast: TemplateAst[], position: number): TemplateAstPath {\n-  const path: TemplateAst[] = [];\n-  const visitor = new class extends RecursiveTemplateAstVisitor {\n-    visit(ast: TemplateAst): any {\n-      let span = spanOf(ast);\n-      if (inSpan(position, span)) {\n-        const len = path.length;\n-        if (!len || isNarrower(span, spanOf(path[len - 1]))) {\n-          path.push(ast);\n-        }\n-      } else {\n-        // Returning a value here will result in the children being skipped.\n-        return true;\n-      }\n-    }\n-\n-    override visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n-      return this.visitChildren(context, visit => {\n-        // Ignore reference, variable and providers\n-        visit(ast.attrs);\n-        visit(ast.directives);\n-        visit(ast.children);\n-      });\n-    }\n-\n-    override visitElement(ast: ElementAst, context: any): any {\n-      return this.visitChildren(context, visit => {\n-        // Ingnore providers\n-        visit(ast.attrs);\n-        visit(ast.inputs);\n-        visit(ast.outputs);\n-        visit(ast.references);\n-        visit(ast.directives);\n-        visit(ast.children);\n-      });\n-    }\n-\n-    override visitDirective(ast: DirectiveAst, context: any): any {\n-      // Ignore the host properties of a directive\n-      const result = this.visitChildren(context, visit => {\n-        visit(ast.inputs);\n-      });\n-      // We never care about the diretive itself, just its inputs.\n-      if (path[path.length - 1] === ast) {\n-        path.pop();\n-      }\n-      return result;\n-    }\n-  };\n-\n-  templateVisitAll(visitor, ast);\n-\n-  return new AstPath<TemplateAst>(path, position);\n-}\n-\n-/**\n- * Find the tightest node at the specified `position` from the AST `nodes`, and\n- * return the path to the node.\n- * @param nodes HTML AST nodes\n- * @param position\n- */\n-export function getPathToNodeAtPosition(nodes: Node[], position: number): HtmlAstPath {\n-  const path: Node[] = [];\n-  const visitor = new class extends RecursiveVisitor {\n-    visit(ast: Node) {\n-      const span = spanOf(ast);\n-      if (inSpan(position, span)) {\n-        path.push(ast);\n-      } else {\n-        // Returning a truthy value here will skip all children and terminate\n-        // the visit.\n-        return true;\n-      }\n-    }\n-  };\n-  visitAll(visitor, nodes);\n-  return new AstPath<Node>(path, position);\n-}\n-\n-\n-/**\n- * Inverts an object's key-value pairs.\n- */\n-export function invertMap(obj: {[name: string]: string}): {[name: string]: string} {\n-  const result: {[name: string]: string} = {};\n-  for (const name of Object.keys(obj)) {\n-    const v = obj[name];\n-    result[v] = name;\n-  }\n-  return result;\n-}\n-\n-\n-/**\n- * Finds the directive member providing a template output binding, if one exists.\n- * @param info aggregate template AST information\n- * @param path narrowing\n- */\n-export function findOutputBinding(\n-    binding: BoundEventAst, path: TemplateAstPath, query: SymbolQuery): Symbol|undefined {\n-  const element = path.first(ElementAst);\n-  if (element) {\n-    for (const directive of element.directives) {\n-      const invertedOutputs = invertMap(directive.directive.outputs);\n-      const fieldName = invertedOutputs[binding.name];\n-      if (fieldName) {\n-        const classSymbol = query.getTypeSymbol(directive.directive.type.reference);\n-        if (classSymbol) {\n-          return classSymbol.members().get(fieldName);\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-/**\n- * Returns an absolute path from the text in `node`. If the text is already\n- * an absolute path, return it as is, otherwise join the path with the filename\n- * of the source file.\n- */\n-export function extractAbsoluteFilePath(node: ts.StringLiteralLike) {\n-  const url = node.text;\n-  return path.isAbsolute(url) ? url : path.join(path.dirname(node.getSourceFile().fileName), url);\n-}"
        },
        {
            "sha": "91fb273d3fa5d5647641b33d586fa472e9d4501a",
            "filename": "packages/language-service/test/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 136,
            "changes": 136,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2FBUILD.bazel?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,136 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"jasmine_node_test\", \"ts_library\")\n-load(\"//tools/circular_dependency_test:index.bzl\", \"circular_dependency_test\")\n-\n-circular_dependency_test(\n-    name = \"circular_deps_test\",\n-    entry_point = \"angular/packages/language-service/index.js\",\n-    deps = [\"//packages/language-service\"],\n-)\n-\n-ts_library(\n-    name = \"test_utils_lib\",\n-    testonly = True,\n-    srcs = [\n-        \"test_utils.ts\",\n-    ],\n-    visibility = [\"//packages/language-service:__subpackages__\"],\n-    deps = [\n-        \"//packages/compiler\",\n-        \"//packages/compiler-cli/test:test_utils\",\n-        \"//packages/language-service\",\n-        \"@npm//typescript\",\n-    ],\n-)\n-\n-ts_library(\n-    name = \"features_test_lib\",\n-    testonly = True,\n-    srcs = [\n-        \"completions_spec.ts\",\n-        \"definitions_spec.ts\",\n-        \"diagnostics_spec.ts\",\n-        \"hover_spec.ts\",\n-        \"references_spec.ts\",\n-    ],\n-    data = [\":project\"],\n-    deps = [\n-        \":test_utils_lib\",\n-        \"//packages/language-service\",\n-        \"@npm//typescript\",\n-    ],\n-)\n-\n-ts_library(\n-    name = \"infra_test_lib\",\n-    testonly = True,\n-    srcs = [\n-        \"diagnostic_messages_spec.ts\",\n-        \"global_symbols_spec.ts\",\n-        \"html_info_spec.ts\",\n-        \"language_service_spec.ts\",\n-        \"reflector_host_spec.ts\",\n-        \"ts_plugin_spec.ts\",\n-        \"typescript_host_spec.ts\",\n-        \"utils_spec.ts\",\n-    ],\n-    data = [\":project\"],\n-    deps = [\n-        \":test_utils_lib\",\n-        \"//packages/compiler\",\n-        \"//packages/language-service\",\n-        \"//packages/language-service:ts_utils\",\n-        \"@npm//typescript\",\n-    ],\n-)\n-\n-filegroup(\n-    name = \"project\",\n-    srcs = glob([\"project/**/*\"]),\n-    visibility = [\"//packages/language-service:__subpackages__\"],\n-)\n-\n-jasmine_node_test(\n-    name = \"test\",\n-    data = [\n-        \"@npm//@angular/common-12\",\n-        \"@npm//@angular/core-12\",\n-        \"@npm//@angular/forms-12\",\n-    ],\n-    tags = [\n-        # the language service is not yet compatible with Ivy\n-        \"view-engine-only\",\n-    ],\n-    deps = [\n-        \":features_test_lib\",\n-    ],\n-)\n-\n-jasmine_node_test(\n-    name = \"infra_test\",\n-    data = [\n-        \"@npm//@angular/common-12\",\n-        \"@npm//@angular/core-12\",\n-        \"@npm//@angular/forms-12\",\n-    ],\n-    tags = [\n-        # the language service is not yet compatible with Ivy\n-        \"view-engine-only\",\n-    ],\n-    deps = [\n-        \":infra_test_lib\",\n-    ],\n-)\n-\n-ts_library(\n-    name = \"diagnostics_lib\",\n-    testonly = True,\n-    srcs = [\n-        \"expression_diagnostics_spec.ts\",\n-        \"mocks.ts\",\n-        \"typescript_symbols_spec.ts\",\n-    ],\n-    deps = [\n-        \"//packages/compiler\",\n-        \"//packages/compiler-cli/test:test_utils\",\n-        \"//packages/core\",\n-        \"//packages/language-service\",\n-        \"@npm//typescript\",\n-    ],\n-)\n-\n-jasmine_node_test(\n-    name = \"diagnostics\",\n-    data = [\n-        \"@npm//@angular/common-12\",\n-        \"@npm//@angular/core-12\",\n-        \"@npm//@angular/forms-12\",\n-    ],\n-    tags = [\n-        # Disabled as these tests pertain to diagnostics in the old ngc compiler. The Ivy ngtsc\n-        # compiler has its own tests for diagnostics.\n-        \"view-engine-only\",\n-    ],\n-    deps = [\n-        \":diagnostics_lib\",\n-    ],\n-)"
        },
        {
            "sha": "ec051085f3d7435b96b3be0d5cf27555d06c53a0",
            "filename": "packages/language-service/test/completions_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 866,
            "changes": 866,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fcompletions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fcompletions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fcompletions_spec.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,866 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {createLanguageService} from '../src/language_service';\n-import {CompletionKind} from '../src/types';\n-import {TypeScriptServiceHost} from '../src/typescript_host';\n-\n-import {MockTypescriptHost} from './test_utils';\n-\n-const APP_COMPONENT = '/app/app.component.ts';\n-const TEST_TEMPLATE = '/app/test.ng';\n-\n-describe('completions', () => {\n-  const mockHost = new MockTypescriptHost(['/app/main.ts']);\n-  const tsLS = ts.createLanguageService(mockHost);\n-  const ngHost = new TypeScriptServiceHost(mockHost, tsLS);\n-  const ngLS = createLanguageService(ngHost);\n-\n-  beforeEach(() => {\n-    mockHost.reset();\n-  });\n-\n-  it('should be able to return html elements', () => {\n-    mockHost.overrideInlineTemplate(APP_COMPONENT, '<~{cursor}');\n-    const marker = mockHost.getLocationMarkerFor(APP_COMPONENT, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(APP_COMPONENT, marker.start);\n-    expectContain(completions, CompletionKind.HTML_ELEMENT, ['div', 'h1', 'h2', 'span']);\n-  });\n-\n-  it('should be able to return component directives', () => {\n-    mockHost.overrideInlineTemplate(APP_COMPONENT, '<~{cursor}');\n-    const marker = mockHost.getLocationMarkerFor(APP_COMPONENT, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(APP_COMPONENT, marker.start);\n-    expectContain(completions, CompletionKind.COMPONENT, [\n-      'ng-form',\n-      'my-app',\n-      'ng-component',\n-      'test-comp',\n-    ]);\n-  });\n-\n-  it('should be able to return attribute directives', () => {\n-    mockHost.overrideInlineTemplate(APP_COMPONENT, '<h1 ~{cursor}>');\n-    const marker = mockHost.getLocationMarkerFor(APP_COMPONENT, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(APP_COMPONENT, marker.start);\n-    expectContain(completions, CompletionKind.ATTRIBUTE, ['string-model', 'number-model']);\n-  });\n-\n-  it('should be able to return angular pseudo elements', () => {\n-    mockHost.overrideInlineTemplate(APP_COMPONENT, `<~{cursor}`);\n-    const marker = mockHost.getLocationMarkerFor(APP_COMPONENT, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(APP_COMPONENT, marker.start);\n-    expectContain(completions, CompletionKind.ANGULAR_ELEMENT, [\n-      'ng-container',\n-      'ng-content',\n-      'ng-template',\n-    ]);\n-  });\n-\n-  it('should be able to return h1 attributes', () => {\n-    mockHost.overrideInlineTemplate(APP_COMPONENT, '<h1 ~{cursor}>');\n-    const marker = mockHost.getLocationMarkerFor(APP_COMPONENT, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(APP_COMPONENT, marker.start);\n-    expectContain(completions, CompletionKind.HTML_ATTRIBUTE, [\n-      'class',\n-      'id',\n-      'onclick',\n-      'onmouseup',\n-    ]);\n-  });\n-\n-  it('should be able to find common Angular attributes', () => {\n-    mockHost.overrideInlineTemplate(APP_COMPONENT, '<div ~{cursor}>');\n-    const marker = mockHost.getLocationMarkerFor(APP_COMPONENT, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(APP_COMPONENT, marker.start);\n-    expectContain(completions, CompletionKind.ATTRIBUTE, [\n-      'ngClass',\n-      'ngForm',\n-      'ngModel',\n-      'string-model',\n-      'number-model',\n-    ]);\n-  });\n-\n-  it('should be able to get the completions at the beginning of an interpolation', () => {\n-    mockHost.overrideInlineTemplate(APP_COMPONENT, '<h2>{{ ~{cursor} }}</h2>');\n-    const marker = mockHost.getLocationMarkerFor(APP_COMPONENT, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(APP_COMPONENT, marker.start);\n-    expectContain(completions, CompletionKind.PROPERTY, ['title', 'hero']);\n-  });\n-\n-  it('should not include private members of a class', () => {\n-    mockHost.overrideInlineTemplate(APP_COMPONENT, '<h2>{{ ~{cursor} }}</h2>');\n-    const marker = mockHost.getLocationMarkerFor(APP_COMPONENT, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(APP_COMPONENT, marker.start);\n-    expect(completions).toBeDefined();\n-    const internal = completions!.entries.find(e => e.name === 'internal');\n-    expect(internal).toBeUndefined();\n-  });\n-\n-  it('should be able to get the completions at the end of an interpolation', () => {\n-    mockHost.overrideInlineTemplate(APP_COMPONENT, '{{ti~{cursor}}}');\n-    const marker = mockHost.getLocationMarkerFor(APP_COMPONENT, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(APP_COMPONENT, marker.start);\n-    expectContain(completions, CompletionKind.PROPERTY, ['title', 'hero']);\n-  });\n-\n-  it('should be able to get the completions in a property', () => {\n-    mockHost.overrideInlineTemplate(APP_COMPONENT, '<h2>{{ hero.~{cursor} }}</h2>');\n-    const marker = mockHost.getLocationMarkerFor(APP_COMPONENT, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(APP_COMPONENT, marker.start);\n-    expectContain(completions, CompletionKind.PROPERTY, ['id', 'name']);\n-  });\n-\n-  it('should suggest template references', () => {\n-    mockHost.override(TEST_TEMPLATE, `<div *~{cursor}></div>`);\n-    const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-    expectContain(completions, CompletionKind.ATTRIBUTE, [\n-      'ngFor',\n-      'ngForOf',\n-      'ngIf',\n-      'ngSwitchCase',\n-      'ngSwitchDefault',\n-      'ngPluralCase',\n-      'ngTemplateOutlet',\n-    ]);\n-  });\n-\n-  it('should be able to return attribute names with an incomplete attribute', () => {\n-    mockHost.overrideInlineTemplate(APP_COMPONENT, '<h1 h~{no-value-attribute}></h1>');\n-    const marker = mockHost.getLocationMarkerFor(APP_COMPONENT, 'no-value-attribute');\n-    const completions = ngLS.getCompletionsAtPosition(APP_COMPONENT, marker.start);\n-    expectContain(completions, CompletionKind.HTML_ATTRIBUTE, ['id', 'class', 'dir', 'lang']);\n-  });\n-\n-  it('should be able to return attributes of an incomplete element', () => {\n-    mockHost.overrideInlineTemplate(APP_COMPONENT, `\n-      <h1>\n-        Some <~{incomplete-open-lt}a~{incomplete-open-a} ~{incomplete-open-attr} text\n-      </h1>`);\n-\n-    const m1 = mockHost.getLocationMarkerFor(APP_COMPONENT, 'incomplete-open-lt');\n-    const c1 = ngLS.getCompletionsAtPosition(APP_COMPONENT, m1.start);\n-    expectContain(c1, CompletionKind.HTML_ELEMENT, ['a', 'div', 'p', 'span']);\n-\n-    const m2 = mockHost.getLocationMarkerFor(APP_COMPONENT, 'incomplete-open-a');\n-    const c2 = ngLS.getCompletionsAtPosition(APP_COMPONENT, m2.start);\n-    expectContain(c2, CompletionKind.HTML_ELEMENT, ['a', 'div', 'p', 'span']);\n-\n-    const m3 = mockHost.getLocationMarkerFor(APP_COMPONENT, 'incomplete-open-attr');\n-    const c3 = ngLS.getCompletionsAtPosition(APP_COMPONENT, m3.start);\n-    expectContain(c3, CompletionKind.HTML_ATTRIBUTE, ['id', 'class', 'href', 'name']);\n-  });\n-\n-  it('should be able to return completions with a missing closing tag', () => {\n-    mockHost.overrideInlineTemplate(APP_COMPONENT, '<h1>Some <a> ~{missing-closing} text</h1>');\n-    const marker = mockHost.getLocationMarkerFor(APP_COMPONENT, 'missing-closing');\n-    const completions = ngLS.getCompletionsAtPosition(APP_COMPONENT, marker.start);\n-    expectContain(completions, CompletionKind.HTML_ELEMENT, ['a', 'div', 'p', 'span', 'h1', 'h2']);\n-  });\n-\n-  it('should be able to return common attributes of an unknown tag', () => {\n-    mockHost.overrideInlineTemplate(\n-        APP_COMPONENT, '<h1>Some <unknown ~{unknown-element}> text</h1>');\n-    const marker = mockHost.getLocationMarkerFor(APP_COMPONENT, 'unknown-element');\n-    const completions = ngLS.getCompletionsAtPosition(APP_COMPONENT, marker.start);\n-    expectContain(completions, CompletionKind.HTML_ATTRIBUTE, ['id', 'dir', 'lang']);\n-  });\n-\n-  it('should be able to get completions in an empty interpolation', () => {\n-    mockHost.override(TEST_TEMPLATE, `{{ ~{cursor} }}`);\n-    const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-    expectContain(completions, CompletionKind.PROPERTY, ['title', 'hero']);\n-  });\n-\n-  it('should suggest $any() type cast function in an interpolation', () => {\n-    mockHost.overrideInlineTemplate(APP_COMPONENT, '{{ ~{cursor} }}');\n-    const marker = mockHost.getLocationMarkerFor(APP_COMPONENT, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(APP_COMPONENT, marker.start);\n-    expectContain(completions, CompletionKind.METHOD, ['$any']);\n-  });\n-\n-  it('should suggest attribute values', () => {\n-    mockHost.override(TEST_TEMPLATE, `<div [id]=\"~{cursor}\"></div>`);\n-    const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-    expectContain(completions, CompletionKind.PROPERTY, [\n-      'title',\n-      'hero',\n-      'heroes',\n-      'league',\n-      'anyValue',\n-    ]);\n-  });\n-\n-  it('should suggest event handlers', () => {\n-    mockHost.override(TEST_TEMPLATE, `<div (click)=\"~{cursor}\"></div>`);\n-    const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-    expectContain(completions, CompletionKind.METHOD, ['myClick']);\n-  });\n-\n-  it('for methods should include parentheses', () => {\n-    mockHost.override(TEST_TEMPLATE, `<div (click)=\"~{cursor}\"></div>`);\n-    const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-    expect(completions).toBeDefined();\n-    expect(completions!.entries).toContain(jasmine.objectContaining({\n-      name: 'myClick',\n-      kind: CompletionKind.METHOD as any,\n-      insertText: 'myClick()',\n-    }));\n-  });\n-\n-  it('for methods of pipe should not include parentheses', () => {\n-    mockHost.override(TEST_TEMPLATE, `<h1>{{title | lowe~{pipe-method} }}`);\n-    const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'pipe-method');\n-    const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-    expect(completions).toBeDefined();\n-    expect(completions!.entries).toContain(jasmine.objectContaining({\n-      name: 'lowercase',\n-      kind: CompletionKind.PIPE as any,\n-      insertText: 'lowercase',\n-    }));\n-  });\n-\n-  describe('in external template', () => {\n-    it('should not return html elements', () => {\n-      mockHost.override(TEST_TEMPLATE, '<~{cursor}');\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(completions).toBeDefined();\n-      const {entries} = completions!;\n-      expect(entries).not.toContain(jasmine.objectContaining({name: 'div'}));\n-      expect(entries).not.toContain(jasmine.objectContaining({name: 'h1'}));\n-      expect(entries).not.toContain(jasmine.objectContaining({name: 'h2'}));\n-      expect(entries).not.toContain(jasmine.objectContaining({name: 'span'}));\n-    });\n-\n-    it('should be able to return element directives', () => {\n-      mockHost.override(TEST_TEMPLATE, '<~{cursor}');\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.COMPONENT, [\n-        'ng-form',\n-        'my-app',\n-        'ng-component',\n-        'test-comp',\n-      ]);\n-    });\n-\n-    it('should not return html attributes', () => {\n-      mockHost.override(TEST_TEMPLATE, '<h1 ~{cursor}>');\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(completions).toBeDefined();\n-      const {entries} = completions!;\n-      expect(entries).not.toContain(jasmine.objectContaining({name: 'class'}));\n-      expect(entries).not.toContain(jasmine.objectContaining({name: 'id'}));\n-      expect(entries).not.toContain(jasmine.objectContaining({name: 'onclick'}));\n-      expect(entries).not.toContain(jasmine.objectContaining({name: 'onmouseup'}));\n-    });\n-\n-    it('should be able to find common Angular attributes', () => {\n-      mockHost.override(TEST_TEMPLATE, `<div ~{cursor}></div>`);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.ATTRIBUTE, [\n-        'ngClass',\n-        'ngForm',\n-        'ngModel',\n-        'string-model',\n-        'number-model',\n-      ]);\n-    });\n-  });\n-\n-  describe('with a *ngIf', () => {\n-    it('should be able to get completions for exported *ngIf variable', () => {\n-      mockHost.override(TEST_TEMPLATE, `\n-        <div *ngIf=\"heroP | async as h\">\n-          {{ h.~{cursor} }}\n-        </div>\n-      `);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.PROPERTY, ['id', 'name']);\n-    });\n-  });\n-\n-  describe('with a *ngFor', () => {\n-    it('should suggest NgForRow members for let initialization expression', () => {\n-      mockHost.override(TEST_TEMPLATE, `<div *ngFor=\"let i=~{cursor}\"></div>`);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.PROPERTY, [\n-        '$implicit',\n-        'ngForOf',\n-        'index',\n-        'count',\n-        'first',\n-        'last',\n-        'even',\n-        'odd',\n-      ]);\n-    });\n-\n-    it('should not provide suggestion before the = sign', () => {\n-      mockHost.override(TEST_TEMPLATE, `<div *ngFor=\"let i~{cursor}=\"></div>`);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(completions).toBeUndefined();\n-    });\n-\n-    describe('template binding: key expression', () => {\n-      it('should complete the RHS of a template key expression without an expression value', () => {\n-        mockHost.override(\n-            TEST_TEMPLATE, `<div *ngFor=\"let x of ~{cursor}\"></div>`);  // value is undefined\n-        const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-        const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-        expectContain(completions, CompletionKind.PROPERTY, ['title', 'heroes', 'league']);\n-        // the symbol 'x' declared in *ngFor is also in scope. This asserts that\n-        // we are actually taking the AST into account and not just referring to\n-        // the symbol table of the Component.\n-        expectContain(completions, CompletionKind.VARIABLE, ['x']);\n-      });\n-\n-      it('should complete the RHS of a template key expression with an expression value', () => {\n-        mockHost.override(\n-            TEST_TEMPLATE, `<div *ngFor=\"let x of t~{cursor}\"></div>`);  // value is defined\n-        const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-        const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-        expectContain(completions, CompletionKind.PROPERTY, ['title', 'heroes', 'league']);\n-        // the symbol 'x' declared in *ngFor is also in scope. This asserts that\n-        // we are actually taking the AST into account and not just referring to\n-        // the symbol table of the Component.\n-        expectContain(completions, CompletionKind.VARIABLE, ['x']);\n-      });\n-    });\n-\n-    it('should include expression completions', () => {\n-      mockHost.override(TEST_TEMPLATE, `<div *ngFor=\"let x of hero.~{expr-property-read}\"></div>`);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'expr-property-read');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.PROPERTY, ['name']);\n-    });\n-\n-    it('should include variable in the let scope in interpolation', () => {\n-      mockHost.override(TEST_TEMPLATE, `\n-        <div *ngFor=\"let h of heroes\">\n-          {{~{cursor}}}\n-        </div>\n-      `);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.VARIABLE, ['h']);\n-    });\n-\n-    it('should be able to infer the type of a ngForOf', () => {\n-      mockHost.override(TEST_TEMPLATE, `\n-        <div *ngFor=\"let h of heroes\">\n-          {{ h.~{cursor} }}\n-        </div>\n-      `);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.PROPERTY, ['id', 'name']);\n-    });\n-\n-    it('should be able to infer the type of a ngForOf with an async pipe', () => {\n-      mockHost.override(TEST_TEMPLATE, `\n-        <div *ngFor=\"let h of heroesP | async\">\n-          {{ h.~{cursor} }}\n-        </div>\n-      `);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.PROPERTY, ['id', 'name']);\n-    });\n-\n-    it('should be able to resolve variable in nested loop', () => {\n-      mockHost.override(TEST_TEMPLATE, `\n-        <div *ngFor=\"let leagueMembers of league\">\n-          <div *ngFor=\"let member of leagueMembers\">\n-            {{member.~{position}}}\n-          </div>\n-        </div>\n-      `);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'position');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      // member variable of type Hero has properties 'id' and 'name'.\n-      expectContain(completions, CompletionKind.PROPERTY, ['id', 'name']);\n-    });\n-  });\n-\n-  describe('data binding', () => {\n-    it('should be able to complete property value', () => {\n-      mockHost.override(TEST_TEMPLATE, `<h1 [model]=\"~{cursor}\"></h1>`);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.PROPERTY, ['title']);\n-    });\n-\n-    it('should be able to complete property read', () => {\n-      mockHost.override(TEST_TEMPLATE, `<h1 [model]=\"hero.~{property-read}\"></h1>`);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'property-read');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.PROPERTY, ['id', 'name']);\n-    });\n-\n-    it('should be able to complete an event', () => {\n-      mockHost.override(TEST_TEMPLATE, `<h1 (model)=\"~{cursor}\"></h1>`);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.METHOD, ['myClick']);\n-    });\n-\n-    it('should be able to complete a the LHS of a two-way binding', () => {\n-      mockHost.override(TEST_TEMPLATE, `<div [(~{cursor})]></div>`);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.ATTRIBUTE, ['ngModel']);\n-    });\n-\n-    it('should be able to complete a the RHS of a two-way binding', () => {\n-      mockHost.override(TEST_TEMPLATE, `<h1 [(model)]=\"~{cursor}\"></h1>`);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.PROPERTY, ['title']);\n-    });\n-\n-    it('should suggest property binding for input', () => {\n-      // Property binding via []\n-      mockHost.override(TEST_TEMPLATE, `<div number-model [~{cursor}]></div>`);\n-      const m1 = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const c1 = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, m1.start);\n-      expectContain(c1, CompletionKind.ATTRIBUTE, ['inputAlias']);\n-\n-      // Property binding via bind-\n-      mockHost.override(TEST_TEMPLATE, `<div number-model bind-~{cursor}></div>`);\n-      const m2 = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const c2 = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, m2.start);\n-      expectContain(c2, CompletionKind.ATTRIBUTE, ['inputAlias']);\n-    });\n-\n-    it('should suggest event binding for output', () => {\n-      // Event binding via ()\n-      mockHost.override(TEST_TEMPLATE, `<div number-model (~{cursor})></div>`);\n-      const m1 = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const c1 = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, m1.start);\n-      expectContain(c1, CompletionKind.ATTRIBUTE, ['outputAlias']);\n-\n-      // Event binding via on-\n-      mockHost.override(TEST_TEMPLATE, `<div number-mode on-~{cursor}></div>`);\n-      const m2 = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const c2 = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, m2.start);\n-      expectContain(c2, CompletionKind.ATTRIBUTE, ['outputAlias']);\n-    });\n-\n-    it('should suggest two-way binding for input and output', () => {\n-      // Banana-in-a-box via [()]\n-      mockHost.override(TEST_TEMPLATE, `<div string-model [(~{cursor})]></div>`);\n-      const m1 = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const c1 = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, m1.start);\n-      expectContain(c1, CompletionKind.ATTRIBUTE, ['model']);\n-\n-      // Banana-in-a-box via bindon-\n-      mockHost.override(TEST_TEMPLATE, `<div string-model bindon-~{cursor}></div>`);\n-      const m2 = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const c2 = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, m2.start);\n-      expectContain(c2, CompletionKind.ATTRIBUTE, ['model']);\n-    });\n-  });\n-\n-  describe('for pipes', () => {\n-    it('should be able to get a list of pipe values', () => {\n-      // TODO(kyliau): does not work for case {{ title | ~{cursor} }}\n-      //                  space before and after pipe ^^^\n-      mockHost.override(TEST_TEMPLATE, `{{ title|~{cursor} }}`);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.PIPE, [\n-        'async',\n-        'lowercase',\n-        'slice',\n-        'titlecase',\n-        'uppercase',\n-      ]);\n-    });\n-\n-    it('should be able to resolve lowercase', () => {\n-      mockHost.override(TEST_TEMPLATE, `{{ (title | lowercase).~{cursor} }}`);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.METHOD, [\n-        'charAt',\n-        'replace',\n-        'substring',\n-        'toLowerCase',\n-      ]);\n-    });\n-  });\n-\n-  describe('with references', () => {\n-    it('should list references', () => {\n-      mockHost.override(TEST_TEMPLATE, `\n-        <div #myDiv>\n-          <test-comp #test1>\n-            {{ ~{cursor} }}\n-          </test-comp>\n-        </div>\n-        <test-comp #test2></test-comp>\n-      `);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.REFERENCE, ['myDiv', 'test1', 'test2']);\n-    });\n-\n-    it('should reference the component', () => {\n-      mockHost.override(TEST_TEMPLATE, `\n-        <test-comp #test1>\n-          {{ test1.~{cursor} }}\n-        </test-comp>\n-      `);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.PROPERTY, ['name', 'testEvent']);\n-    });\n-\n-    it('should get reference property completions in a data binding', () => {\n-      mockHost.override(TEST_TEMPLATE, `\n-        <test-comp #test></test-comp>\n-        <div (click)=\"test.~{property-read}\"></div>\n-      `);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'property-read');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.PROPERTY, ['name', 'testEvent']);\n-    });\n-\n-    // TODO: Enable when we have a flag that indicates the project targets the DOM\n-    // it('should reference the element if no component', () => {\n-    //   const marker = mockHost.getLocationMarkerFor(PARSING_CASES, 'test-comp-after-div');\n-    //   const completions = ngLS.getCompletionsAtPosition(PARSING_CASES, marker.start);\n-    //   expectContain(completions, CompletionKind.PROPERTY, ['innerText']);\n-    // });\n-  });\n-\n-  describe('replacement span', () => {\n-    it('should not generate replacement entries for zero-length replacements', () => {\n-      const fileName = mockHost.addCode(`\n-        @Component({\n-          selector: 'foo-component',\n-          template: \\`\n-            <div>{{obj.~{key}}}</div>\n-          \\`,\n-        })\n-        export class FooComponent {\n-          obj: {key: 'value'};\n-        }\n-      `);\n-      const location = mockHost.getLocationMarkerFor(fileName, 'key');\n-      const completions = ngLS.getCompletionsAtPosition(fileName, location.start)!;\n-      expect(completions).toBeDefined();\n-      const completion = completions.entries.find(entry => entry.name === 'key')!;\n-      expect(completion).toBeDefined();\n-      expect(completion.kind).toBe('property');\n-      expect(completion.replacementSpan).toBeUndefined();\n-    });\n-\n-    it('should work for start of template', () => {\n-      const fileName = mockHost.addCode(`\n-        @Component({\n-          selector: 'foo-component',\n-          template: \\`~{start}abc\\`,\n-        })\n-        export class FooComponent {}\n-      `);\n-      const location = mockHost.getLocationMarkerFor(fileName, 'start');\n-      const completions = ngLS.getCompletionsAtPosition(fileName, location.start)!;\n-      expect(completions).toBeDefined();\n-      const completion = completions.entries.find(entry => entry.name === 'acronym')!;\n-      expect(completion).toBeDefined();\n-      expect(completion.kind).toBe('html element');\n-      expect(completion.replacementSpan).toEqual({start: location.start, length: 3});\n-    });\n-\n-    it('should work for end of template', () => {\n-      const fileName = mockHost.addCode(`\n-        @Component({\n-          selector: 'foo-component',\n-          template: \\`acro~{end}\\`,\n-        })\n-        export class FooComponent {}\n-      `);\n-      const location = mockHost.getLocationMarkerFor(fileName, 'end');\n-      const completions = ngLS.getCompletionsAtPosition(fileName, location.start)!;\n-      expect(completions).toBeDefined();\n-      const completion = completions.entries.find(entry => entry.name === 'acronym')!;\n-      expect(completion).toBeDefined();\n-      expect(completion.kind).toBe('html element');\n-      expect(completion.replacementSpan).toEqual({start: location.start - 4, length: 4});\n-    });\n-\n-    it('should work for middle-word replacements', () => {\n-      const fileName = mockHost.addCode(`\n-        @Component({\n-          selector: 'foo-component',\n-          template: \\`\n-            <div>{{obj.ke~{key}key}}</div>\n-          \\`,\n-        })\n-        export class FooComponent {\n-          obj: {key: 'value'};\n-        }\n-      `);\n-      const location = mockHost.getLocationMarkerFor(fileName, 'key');\n-      const completions = ngLS.getCompletionsAtPosition(fileName, location.start)!;\n-      expect(completions).toBeDefined();\n-      const completion = completions.entries.find(entry => entry.name === 'key')!;\n-      expect(completion).toBeDefined();\n-      expect(completion.kind).toBe('property');\n-      expect(completion.replacementSpan).toEqual({start: location.start - 2, length: 5});\n-    });\n-\n-    it('should work for all kinds of identifier characters', () => {\n-      const fileName = mockHost.addCode(`\n-        @Component({\n-          selector: 'foo-component',\n-          template: \\`\n-            <div>{{~{field}$title_1}}</div>\n-          \\`,\n-        })\n-        export class FooComponent {\n-          $title_1: string;\n-        }\n-      `);\n-      const location = mockHost.getLocationMarkerFor(fileName, 'field');\n-      const completions = ngLS.getCompletionsAtPosition(fileName, location.start)!;\n-      expect(completions).toBeDefined();\n-      const completion = completions.entries.find(entry => entry.name === '$title_1')!;\n-      expect(completion).toBeDefined();\n-      expect(completion.kind).toBe('property');\n-      expect(completion.replacementSpan).toEqual({start: location.start, length: 8});\n-    });\n-\n-    it('should work for attributes', () => {\n-      const fileName = mockHost.addCode(`\n-        @Component({\n-          selector: 'foo-component',\n-          template: \\`\n-            <div (cl~{click})></div>\n-          \\`,\n-        })\n-        export class FooComponent {}\n-      `);\n-      const location = mockHost.getLocationMarkerFor(fileName, 'click');\n-      const completions = ngLS.getCompletionsAtPosition(fileName, location.start)!;\n-      expect(completions).toBeDefined();\n-      const completion = completions.entries.find(entry => entry.name === 'click')!;\n-      expect(completion).toBeDefined();\n-      expect(completion.kind).toBe(CompletionKind.ATTRIBUTE);\n-      expect(completion.replacementSpan).toEqual({start: location.start - 2, length: 2});\n-    });\n-\n-    it('should work for events', () => {\n-      const fileName = mockHost.addCode(`\n-        @Component({\n-          selector: 'foo-component',\n-          template: \\`\n-            <div (click)=\"han~{handleClick}\"></div>\n-          \\`,\n-        })\n-        export class FooComponent {\n-          handleClick() {}\n-        }\n-      `);\n-      const location = mockHost.getLocationMarkerFor(fileName, 'handleClick');\n-      const completions = ngLS.getCompletionsAtPosition(fileName, location.start)!;\n-      expect(completions).toBeDefined();\n-      const completion = completions.entries.find(entry => entry.name === 'handleClick')!;\n-      expect(completion).toBeDefined();\n-      expect(completion.kind).toBe('method');\n-      expect(completion.replacementSpan).toEqual({start: location.start - 3, length: 3});\n-    });\n-\n-    it('should work for element names', () => {\n-      const fileName = mockHost.addCode(`\n-        @Component({\n-          selector: 'foo-component',\n-          template: \\`\n-            <test-comp~{test-comp}></test-comp>\n-          \\`,\n-        })\n-        export class FooComponent {}\n-      `);\n-      const location = mockHost.getLocationMarkerFor(fileName, 'test-comp');\n-      const completions = ngLS.getCompletionsAtPosition(fileName, location.start)!;\n-      expect(completions).toBeDefined();\n-      const completion = completions.entries.find(entry => entry.name === 'test-comp')!;\n-      expect(completion).toBeDefined();\n-      expect(completion.kind).toBe('component');\n-      expect(completion.replacementSpan).toEqual({start: location.start - 9, length: 9});\n-    });\n-\n-    it('should work for bindings', () => {\n-      const fileName = mockHost.addCode(`\n-        @Component({\n-          selector: 'foo-component',\n-          template: \\`\n-            <input [(ngMod~{model})] />\n-          \\`,\n-        })\n-        export class FooComponent {}\n-      `);\n-      const location = mockHost.getLocationMarkerFor(fileName, 'model');\n-      const completions = ngLS.getCompletionsAtPosition(fileName, location.start)!;\n-      expect(completions).toBeDefined();\n-      const completion = completions.entries.find(entry => entry.name === 'ngModel')!;\n-      expect(completion).toBeDefined();\n-      expect(completion.kind).toBe(CompletionKind.ATTRIBUTE);\n-      expect(completion.replacementSpan).toEqual({start: location.start - 5, length: 5});\n-    });\n-  });\n-\n-  describe('property completions for members of an indexed type', () => {\n-    it('should work with numeric index signatures (arrays)', () => {\n-      mockHost.override(TEST_TEMPLATE, `{{ heroes[0].~{heroes-number-index}}}`);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'heroes-number-index');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.PROPERTY, ['id', 'name']);\n-    });\n-\n-    it('should work with numeric index signatures (tuple arrays)', () => {\n-      mockHost.override(TEST_TEMPLATE, `{{ tupleArray[1].~{tuple-array-number-index}}}`);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'tuple-array-number-index');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.PROPERTY, ['id', 'name']);\n-    });\n-\n-    describe('with string index signatures', () => {\n-      it('should work with index notation', () => {\n-        mockHost.override(TEST_TEMPLATE, `{{ heroesByName['Jacky'].~{heroes-string-index}}}`);\n-        const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'heroes-string-index');\n-        const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-        expectContain(completions, CompletionKind.PROPERTY, ['id', 'name']);\n-      });\n-\n-      it('should work with dot notation', () => {\n-        mockHost.override(TEST_TEMPLATE, `{{ heroesByName.jacky.~{heroes-string-index}}}`);\n-        const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'heroes-string-index');\n-        const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-        expectContain(completions, CompletionKind.PROPERTY, ['id', 'name']);\n-      });\n-\n-      it('should work with dot notation if stringIndexType is a primitive type', () => {\n-        mockHost.override(TEST_TEMPLATE, `{{ primitiveIndexType.test.~{string-primitive-type}}}`);\n-        const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'string-primitive-type');\n-        const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-        expectContain(completions, CompletionKind.METHOD, ['substring']);\n-      });\n-    });\n-\n-    describe('with template reference variables', () => {\n-      it('should be able to get the completions (ref- prefix)', () => {\n-        mockHost.override(TEST_TEMPLATE, `<form ref-itemForm=\"ngF~{reference}\"></form>`);\n-        const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'reference');\n-        const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start)!;\n-        expectContain(completions, CompletionKind.REFERENCE, ['ngForm']);\n-      });\n-\n-      it('should be able to get the completions (# prefix)', () => {\n-        mockHost.override(TEST_TEMPLATE, `<form #itemForm=\"ngF~{reference}\"></form>`);\n-        const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'reference');\n-        const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start)!;\n-        expectContain(completions, CompletionKind.REFERENCE, ['ngForm']);\n-      });\n-    });\n-  });\n-\n-  it('should not expand i18n templates', () => {\n-    mockHost.override(TEST_TEMPLATE, `<div i18n=\"@@el\">{{~{cursor}}}</div>`);\n-    const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-    expectContain(completions, CompletionKind.PROPERTY, ['title']);\n-  });\n-\n-  describe('$event completions', () => {\n-    it('should suggest $event in event bindings', () => {\n-      mockHost.override(TEST_TEMPLATE, `<div (click)=\"myClick(~{cursor});\"></div>`);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.VARIABLE, ['$event']);\n-    });\n-  });\n-\n-  describe('$event completions', () => {\n-    it('should suggest $event in event bindings', () => {\n-      mockHost.override(TEST_TEMPLATE, `<div (click)=\"myClick(~{cursor});\"></div>`);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      expectContain(completions, CompletionKind.VARIABLE, ['$event']);\n-    });\n-\n-    it('should suggest $event completions in output bindings', () => {\n-      mockHost.override(TEST_TEMPLATE, `<div string-model (modelChange)=\"$event.~{cursor}\"></div>`);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-      // Expect string properties\n-      expectContain(completions, CompletionKind.METHOD, ['charAt', 'substring']);\n-    });\n-  });\n-\n-  it('should select the right signature for a pipe given exact type', () => {\n-    mockHost.override(TEST_TEMPLATE, '{{ (\"world\" | prefixPipe:\"hello\").~{cursor} }}');\n-    const m1 = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-    const c1 = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, m1.start);\n-    // should resolve to transform(value: string, prefix: string): string\n-    expectContain(c1, CompletionKind.METHOD, ['charCodeAt', 'trim']);\n-\n-    mockHost.override(TEST_TEMPLATE, '{{ (456 | prefixPipe:123).~{cursor} }}');\n-    const m2 = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-    const c2 = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, m2.start);\n-    // should resolve to transform(value: number, prefix: number): number\n-    expectContain(c2, CompletionKind.METHOD, ['toFixed', 'toExponential']);\n-  });\n-\n-  it('should work in the conditional operator', () => {\n-    mockHost.override(TEST_TEMPLATE, '{{ title ? title.~{cursor} }}');\n-    const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-    expectContain(completions, CompletionKind.METHOD, [\n-      'trim',\n-    ]);\n-  });\n-\n-  it('should not return any results for unknown symbol', () => {\n-    mockHost.override(TEST_TEMPLATE, '{{ doesnotexist.~{cursor} }}');\n-    const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-    expect(completions).toBeUndefined();\n-  });\n-\n-  it('should not provide completions for string', () => {\n-    mockHost.override(TEST_TEMPLATE, `<div [ngClass]=\"'str~{cursor}'\"></div>`);\n-    const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-    const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n-    expect(completions).toBeUndefined();\n-  });\n-});\n-\n-function expectContain(\n-    completions: ts.CompletionInfo|undefined, kind: CompletionKind, names: string[]) {\n-  expect(completions).toBeDefined();\n-  for (const name of names) {\n-    expect(completions!.entries).toContain(jasmine.objectContaining({name, kind} as any));\n-  }\n-}"
        },
        {
            "sha": "8b2317f95887c187473d4c450ce7a177d522b92c",
            "filename": "packages/language-service/test/definitions_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 483,
            "changes": 483,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fdefinitions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fdefinitions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fdefinitions_spec.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,483 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {createLanguageService} from '../src/language_service';\n-import {TypeScriptServiceHost} from '../src/typescript_host';\n-\n-import {MockTypescriptHost} from './test_utils';\n-\n-const TEST_TEMPLATE = '/app/test.ng';\n-const PARSING_CASES = '/app/parsing-cases.ts';\n-\n-describe('definitions', () => {\n-  const mockHost = new MockTypescriptHost(['/app/main.ts']);\n-  const service = ts.createLanguageService(mockHost);\n-  const ngHost = new TypeScriptServiceHost(mockHost, service);\n-  const ngService = createLanguageService(ngHost);\n-\n-  beforeEach(() => {\n-    mockHost.reset();\n-  });\n-\n-  it('should be able to find field in an interpolation', () => {\n-    const fileName = mockHost.addCode(`\n-      @Component({\n-        template: '{{name}}'\n-      })\n-      export class MyComponent {\n-        name: string;\n-      }`);\n-\n-    const marker = mockHost.getReferenceMarkerFor(fileName, 'name');\n-    const result = ngService.getDefinitionAndBoundSpan(fileName, marker.start);\n-    expect(result).toBeDefined();\n-    const {textSpan, definitions} = result!;\n-\n-    expect(textSpan).toEqual(marker);\n-    expect(definitions).toBeDefined();\n-    expect(definitions!.length).toBe(1);\n-    const def = definitions![0];\n-\n-    expect(def.fileName).toBe(fileName);\n-    expect(def.name).toBe('name');\n-    expect(def.kind).toBe('property');\n-    expect(def.textSpan).toEqual(mockHost.getDefinitionMarkerFor(fileName, 'name'));\n-  });\n-\n-  it('should be able to find a field in a attribute reference', () => {\n-    mockHost.override(TEST_TEMPLATE, `<input [(ngModel)]=\"title\">`);\n-\n-    const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'title');\n-    const result = ngService.getDefinitionAndBoundSpan(TEST_TEMPLATE, marker.start);\n-    expect(result).toBeDefined();\n-    const {textSpan, definitions} = result!;\n-\n-    expect(textSpan).toEqual(marker);\n-    expect(definitions).toBeDefined();\n-\n-    expect(definitions!.length).toBe(1);\n-    const def = definitions![0];\n-\n-    expect(def.fileName).toBe(PARSING_CASES);\n-    expect(def.name).toBe('title');\n-    expect(def.kind).toBe('property');\n-\n-    const fileContent = mockHost.readFile(def.fileName);\n-    expect(fileContent!.substring(def.textSpan.start, def.textSpan.start + def.textSpan.length))\n-        .toEqual(`title = 'Tour of Heroes';`);\n-  });\n-\n-  it('should be able to find a method from a call', () => {\n-    const fileName = mockHost.addCode(`\n-      @Component({\n-        template: '<div (click)=\"myClick();\"></div>'\n-      })\n-      export class MyComponent {\n-        myClick() { }\n-      }`);\n-\n-    const marker = mockHost.getReferenceMarkerFor(fileName, 'myClick');\n-    const result = ngService.getDefinitionAndBoundSpan(fileName, marker.start);\n-    expect(result).toBeDefined();\n-    const {textSpan, definitions} = result!;\n-\n-    expect(textSpan).toEqual(marker);\n-    expect(definitions).toBeDefined();\n-    expect(definitions!.length).toBe(1);\n-    const def = definitions![0];\n-\n-    expect(def.fileName).toBe(fileName);\n-    expect(def.name).toBe('myClick');\n-    expect(def.kind).toBe('method');\n-    expect(def.textSpan).toEqual(mockHost.getDefinitionMarkerFor(fileName, 'myClick'));\n-  });\n-\n-  it('should be able to find a field reference in an *ngIf', () => {\n-    const fileName = mockHost.addCode(`\n-      @Component({\n-        template: '<div *ngIf=\"include\"></div>'\n-      })\n-      export class MyComponent {\n-        include = true;\n-      }`);\n-\n-    const marker = mockHost.getReferenceMarkerFor(fileName, 'include');\n-    const result = ngService.getDefinitionAndBoundSpan(fileName, marker.start);\n-    expect(result).toBeDefined();\n-    const {textSpan, definitions} = result!;\n-\n-    expect(textSpan).toEqual(marker);\n-    expect(definitions).toBeDefined();\n-    expect(definitions!.length).toBe(1);\n-    const def = definitions![0];\n-\n-    expect(def.fileName).toBe(fileName);\n-    expect(def.name).toBe('include');\n-    expect(def.kind).toBe('property');\n-    expect(def.textSpan).toEqual(mockHost.getDefinitionMarkerFor(fileName, 'include'));\n-  });\n-\n-  it('should be able to find a reference to a component', () => {\n-    const fileName = mockHost.addCode(`\n-      @Component({\n-        template: '~{start-my}<test-comp></test-comp>~{end-my}'\n-      })\n-      export class MyComponent { }`);\n-\n-    // Get the marker for test-comp in the code added above.\n-    const marker = mockHost.getReferenceMarkerFor(fileName, 'test-comp');\n-\n-    const result = ngService.getDefinitionAndBoundSpan(fileName, marker.start);\n-    expect(result).toBeDefined();\n-    const {textSpan, definitions} = result!;\n-\n-    // Get the marker for bounded text in the code added above.\n-    const boundedText = mockHost.getLocationMarkerFor(fileName, 'my');\n-    expect(textSpan).toEqual(boundedText);\n-\n-    // There should be exactly 1 definition\n-    expect(definitions).toBeDefined();\n-    expect(definitions!.length).toBe(1);\n-    const def = definitions![0];\n-\n-    const refFileName = '/app/parsing-cases.ts';\n-    expect(def.fileName).toBe(refFileName);\n-    expect(def.name).toBe('TestComponent');\n-    expect(def.kind).toBe('component');\n-    const content = mockHost.readFile(refFileName)!;\n-    const begin = '/*BeginTestComponent*/ ';\n-    const start = content.indexOf(begin) + begin.length;\n-    const end = content.indexOf(' /*EndTestComponent*/');\n-    expect(def.textSpan).toEqual({\n-      start,\n-      length: end - start,\n-    });\n-  });\n-\n-  it('should be able to find an event provider', () => {\n-    const fileName = mockHost.addCode(`\n-      @Component({\n-        template: '<test-comp ~{start-my}(test)=\"myHandler()\"~{end-my}></div>'\n-      })\n-      export class MyComponent { myHandler() {} }`);\n-\n-    // Get the marker for test in the code added above.\n-    const marker = mockHost.getReferenceMarkerFor(fileName, 'test');\n-\n-    const result = ngService.getDefinitionAndBoundSpan(fileName, marker.start);\n-    expect(result).toBeDefined();\n-    const {textSpan, definitions} = result!;\n-\n-    // Get the marker for bounded text in the code added above\n-    const boundedText = mockHost.getLocationMarkerFor(fileName, 'my');\n-    expect(textSpan).toEqual(boundedText);\n-\n-    // There should be exactly 1 definition\n-    expect(definitions).toBeDefined();\n-    expect(definitions!.length).toBe(1);\n-    const def = definitions![0];\n-\n-    const refFileName = '/app/parsing-cases.ts';\n-    expect(def.fileName).toBe(refFileName);\n-    expect(def.name).toBe('testEvent');\n-    expect(def.kind).toBe('event');\n-    const content = mockHost.readFile(refFileName)!;\n-    const ref = `@Output('test') testEvent = new EventEmitter();`;\n-    expect(def.textSpan).toEqual({\n-      start: content.indexOf(ref),\n-      length: ref.length,\n-    });\n-  });\n-\n-  it('should be able to find an input provider', () => {\n-    const fileName = mockHost.addCode(`\n-      @Component({\n-        template: '<test-comp ~{start-my}[tcName]=\"name\"~{end-my}></div>'\n-      })\n-      export class MyComponent {\n-        name = 'my name';\n-      }`);\n-\n-    // Get the marker for test in the code added above.\n-    const marker = mockHost.getReferenceMarkerFor(fileName, 'tcName');\n-\n-    const result = ngService.getDefinitionAndBoundSpan(fileName, marker.start);\n-    expect(result).toBeDefined();\n-    const {textSpan, definitions} = result!;\n-\n-    // Get the marker for bounded text in the code added above\n-    const boundedText = mockHost.getLocationMarkerFor(fileName, 'my');\n-    expect(textSpan).toEqual(boundedText);\n-\n-    // There should be exactly 1 definition\n-    expect(definitions).toBeDefined();\n-    expect(definitions!.length).toBe(1);\n-    const def = definitions![0];\n-\n-    const refFileName = '/app/parsing-cases.ts';\n-    expect(def.fileName).toBe(refFileName);\n-    expect(def.name).toBe('name');\n-    expect(def.kind).toBe('property');\n-    const content = mockHost.readFile(refFileName)!;\n-    const ref = `@Input('tcName') name = 'test';`;\n-    expect(def.textSpan).toEqual({\n-      start: content.indexOf(ref),\n-      length: ref.length,\n-    });\n-  });\n-\n-  it('should be able to find a pipe', () => {\n-    const fileName = mockHost.addCode(`\n-      @Component({\n-        template: '<div *ngIf=\"input | async\"></div>'\n-      })\n-      export class MyComponent {\n-        input: EventEmitter;\n-      }`);\n-\n-    // Get the marker for async in the code added above.\n-    const marker = mockHost.getReferenceMarkerFor(fileName, 'async');\n-    const result = ngService.getDefinitionAndBoundSpan(fileName, marker.start);\n-\n-    expect(result).toBeDefined();\n-    const {textSpan, definitions} = result!;\n-    expect(textSpan).toEqual(marker);\n-\n-    expect(definitions).toBeDefined();\n-    expect(definitions!.length).toBe(3);\n-\n-    const refFileName = '/node_modules/@angular/common/common.d.ts';\n-    for (const def of definitions!) {\n-      expect(def.fileName).toBe(refFileName);\n-      expect(def.name).toBe('async');\n-      expect(def.kind).toBe('pipe');\n-      // Not asserting the textSpan of definition because it's external file\n-    }\n-  });\n-\n-  // https://github.com/angular/vscode-ng-language-service/issues/677\n-  it('should be able to find a pipe with arguments', () => {\n-    mockHost.override(TEST_TEMPLATE, `{{birthday | date: \"MM/dd/yy\"}}`);\n-\n-    const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'date');\n-    const result = ngService.getDefinitionAndBoundSpan(TEST_TEMPLATE, marker.start);\n-\n-    expect(result).toBeDefined();\n-    const {textSpan, definitions} = result!;\n-    expect(textSpan).toEqual(marker);\n-\n-    expect(definitions).toBeDefined();\n-    expect(definitions!.length).toBe(3);\n-\n-    const refFileName = '/node_modules/@angular/common/common.d.ts';\n-    for (const def of definitions!) {\n-      expect(def.fileName).toBe(refFileName);\n-      expect(def.name).toBe('date');\n-      expect(def.kind).toBe('pipe');\n-    }\n-  });\n-\n-  describe('in structural directive', () => {\n-    it('should be able to find the directive', () => {\n-      mockHost.override(\n-          TEST_TEMPLATE, `<div ~{start-my}*ngFor=\"let item of heroes;\"~{end-my}></div>`);\n-\n-      // Get the marker for ngFor in the code added above.\n-      const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'ngFor');\n-\n-      const result = ngService.getDefinitionAndBoundSpan(TEST_TEMPLATE, marker.start);\n-      expect(result).toBeDefined();\n-      const {textSpan, definitions} = result!;\n-\n-      // Get the marker for bounded text in the code added above\n-      const boundedText = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'my');\n-      expect(textSpan).toEqual(boundedText);\n-\n-      expect(definitions).toBeDefined();\n-      expect(definitions!.length).toBe(1);\n-\n-      const refFileName = '/node_modules/@angular/common/common.d.ts';\n-      const def = definitions![0];\n-      expect(def.fileName).toBe(refFileName);\n-      expect(def.name).toBe('NgForOf');\n-      expect(def.kind).toBe('directive');\n-      // Not asserting the textSpan of definition because it's external file\n-    });\n-\n-    it('should be able to find the directive property', () => {\n-      mockHost.override(TEST_TEMPLATE, `<div *ngFor=\"let item of heroes; trackBy: test;\"></div>`);\n-\n-      // Get the marker for trackBy in the code added above.\n-      const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'trackBy');\n-\n-      const result = ngService.getDefinitionAndBoundSpan(TEST_TEMPLATE, marker.start);\n-      expect(result).toBeDefined();\n-      const {textSpan, definitions} = result!;\n-\n-      // Get the marker for bounded text in the code added above\n-      expect(textSpan).toEqual(marker);\n-\n-      expect(definitions).toBeDefined();\n-      // The two definitions are setter and getter of 'ngForTrackBy'.\n-      expect(definitions!.length).toBe(2);\n-\n-      const refFileName = '/node_modules/@angular/common/common.d.ts';\n-      definitions!.forEach(def => {\n-        expect(def.fileName).toBe(refFileName);\n-        expect(def.name).toBe('ngForTrackBy');\n-        expect(def.kind).toBe('method');\n-      });\n-      // Not asserting the textSpan of definition because it's external file\n-    });\n-\n-    it('should be able to find the property value', () => {\n-      mockHost.override(TEST_TEMPLATE, `<div *ngFor=\"let item of heroes; trackBy: test;\"></div>`);\n-\n-      // Get the marker for heroes in the code added above.\n-      const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'heroes');\n-\n-      const result = ngService.getDefinitionAndBoundSpan(TEST_TEMPLATE, marker.start);\n-      expect(result).toBeDefined();\n-      const {textSpan, definitions} = result!;\n-\n-      expect(textSpan).toEqual(marker);\n-\n-      expect(definitions).toBeDefined();\n-      expect(definitions!.length).toBe(1);\n-\n-      const refFileName = '/app/parsing-cases.ts';\n-      const def = definitions![0];\n-      expect(def.fileName).toBe(refFileName);\n-      expect(def.name).toBe('heroes');\n-      expect(def.kind).toBe('property');\n-      const content = mockHost.readFile(refFileName)!;\n-      expect(content.substring(def.textSpan.start, def.textSpan.start + def.textSpan.length))\n-          .toEqual(`heroes: Hero[] = [this.hero];`);\n-    });\n-  });\n-\n-  it('should be able to find a two-way binding', () => {\n-    mockHost.override(\n-        TEST_TEMPLATE,\n-        `<test-comp string-model ~{start-my}[(model)]=\"title\"~{end-my}></test-comp>`);\n-    // Get the marker for model in the code added above.\n-    const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'model');\n-\n-    const result = ngService.getDefinitionAndBoundSpan(TEST_TEMPLATE, marker.start);\n-    expect(result).toBeDefined();\n-    const {textSpan, definitions} = result!;\n-\n-    // Get the marker for bounded text in the code added above\n-    const boundedText = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'my');\n-    expect(textSpan).toEqual(boundedText);\n-\n-    expect(definitions).toBeDefined();\n-    expect(definitions!.length).toBe(2);\n-    const [def1, def2] = definitions!;\n-\n-    const refFileName = '/app/parsing-cases.ts';\n-    expect(def1.fileName).toBe(refFileName);\n-    expect(def1.name).toBe('model');\n-    expect(def1.kind).toBe('property');\n-    let content = mockHost.readFile(refFileName)!;\n-    expect(content.substring(def1.textSpan.start, def1.textSpan.start + def1.textSpan.length))\n-        .toEqual(`@Input() model: string = 'model';`);\n-\n-    expect(def2.fileName).toBe(refFileName);\n-    expect(def2.name).toBe('modelChange');\n-    expect(def2.kind).toBe('event');\n-    content = mockHost.readFile(refFileName)!;\n-    expect(content.substring(def2.textSpan.start, def2.textSpan.start + def2.textSpan.length))\n-        .toEqual(`@Output() modelChange: EventEmitter<string> = new EventEmitter();`);\n-  });\n-\n-  it('should be able to find a template from a url', () => {\n-    const fileName = mockHost.addCode(`\n-\t      @Component({\n-\t        templateUrl: './test.ng',\n-\t      })\n-\t      export class MyComponent {}`);\n-\n-    const marker = mockHost.getReferenceMarkerFor(fileName, 'test');\n-    const result = ngService.getDefinitionAndBoundSpan(fileName, marker.start);\n-\n-    expect(result).toBeDefined();\n-    const {textSpan, definitions} = result!;\n-\n-    expect(textSpan).toEqual({start: marker.start - 2, length: 9});\n-\n-    expect(definitions).toBeDefined();\n-    expect(definitions!.length).toBe(1);\n-    const [def] = definitions!;\n-    expect(def.fileName).toBe('/app/test.ng');\n-    expect(def.textSpan).toEqual({start: 0, length: 0});\n-  });\n-\n-  it('should be able to find a template from an absolute url', () => {\n-    const fileName = mockHost.addCode(`\n-      @Component({\n-        templateUrl: '${TEST_TEMPLATE}',\n-      })\n-      export class MyComponent {}`);\n-\n-    const marker = mockHost.readFile(fileName)!.indexOf(TEST_TEMPLATE);\n-    const result = ngService.getDefinitionAndBoundSpan(fileName, marker);\n-\n-    expect(result?.definitions?.[0].fileName).toBe(TEST_TEMPLATE);\n-  });\n-\n-  it('should be able to find a stylesheet from a url', () => {\n-    const fileName = mockHost.addCode(`\n-\t      @Component({\n-\t        templateUrl: './test.ng',\n-                styleUrls: ['./test.css'],\n-\t      })\n-\t      export class MyComponent {}`);\n-\n-    const marker = mockHost.getReferenceMarkerFor(fileName, 'test');\n-    const result = ngService.getDefinitionAndBoundSpan(fileName, marker.start);\n-\n-    expect(result).toBeDefined();\n-    const {textSpan, definitions} = result!;\n-\n-    expect(textSpan).toEqual({start: marker.start - 2, length: 10});\n-\n-    expect(definitions).toBeDefined();\n-    expect(definitions!.length).toBe(1);\n-    const [def] = definitions!;\n-    expect(def.fileName).toBe('/app/test.css');\n-    expect(def.textSpan).toEqual({start: 0, length: 0});\n-  });\n-\n-  it('should not expand i18n templates', () => {\n-    const fileName = mockHost.addCode(`\n-      @Component({\n-        template: '<div i18n=\"@@el\">{{name}}</div>'\n-      })\n-      export class MyComponent {\n-        name: string;\n-      }`);\n-\n-    const marker = mockHost.getReferenceMarkerFor(fileName, 'name');\n-    const result = ngService.getDefinitionAndBoundSpan(fileName, marker.start);\n-    expect(result).toBeDefined();\n-    const {textSpan, definitions} = result!;\n-\n-    expect(textSpan).toEqual(marker);\n-    expect(definitions).toBeDefined();\n-    expect(definitions!.length).toBe(1);\n-    const def = definitions![0];\n-\n-    expect(def.fileName).toBe(fileName);\n-    expect(def.name).toBe('name');\n-    expect(def.kind).toBe('property');\n-    expect(def.textSpan).toEqual(mockHost.getDefinitionMarkerFor(fileName, 'name'));\n-  });\n-});"
        },
        {
            "sha": "ac9671825cf5608950d2201dba0369fd4279a1a9",
            "filename": "packages/language-service/test/diagnostic_messages_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 29,
            "changes": 29,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fdiagnostic_messages_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fdiagnostic_messages_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fdiagnostic_messages_spec.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,29 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {createDiagnostic, DiagnosticMessage} from '../src/diagnostic_messages';\n-\n-describe('create diagnostic', () => {\n-  it('should format and create diagnostics correctly', () => {\n-    const diagnosticMessage: DiagnosticMessage = {\n-      message: 'Check that %1 contains %2',\n-      kind: 'Error',\n-    };\n-\n-    const diagnostic =\n-        createDiagnostic({start: 0, end: 1}, diagnosticMessage, 'testCls', 'testMethod');\n-\n-    expect(diagnostic).toEqual({\n-      kind: ts.DiagnosticCategory.Error,\n-      message: 'Check that testCls contains testMethod',\n-      span: {start: 0, end: 1},\n-    });\n-  });\n-});"
        },
        {
            "sha": "19f3139f99d83d128f21794d22d6cccafc17b48e",
            "filename": "packages/language-service/test/diagnostics_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 1068,
            "changes": 1068,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fdiagnostics_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fdiagnostics_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fdiagnostics_spec.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,1068 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-import {createLanguageService} from '../src/language_service';\n-import {TypeScriptServiceHost} from '../src/typescript_host';\n-import {MockTypescriptHost} from './test_utils';\n-\n-/**\n- * Note: If we want to test that a specific diagnostic message is emitted, then\n- * use the `mockHost.addCode()` helper method to add code to an existing file and check\n- * that the diagnostic messages contain the expected output.\n- *\n- * If the goal is to assert that there is no error in a specific file, then use\n- * `mockHost.override()` method to completely override an existing file, and\n- * make sure no diagnostics are produced. When doing so, be extra cautious\n- * about import statements and make sure to assert empty TS diagnostic messages\n- * as well.\n- */\n-\n-const TEST_TEMPLATE = '/app/test.ng';\n-const APP_COMPONENT = '/app/app.component.ts';\n-\n-describe('diagnostics', () => {\n-  const mockHost = new MockTypescriptHost(['/app/main.ts', '/app/parsing-cases.ts']);\n-  const tsLS = ts.createLanguageService(mockHost);\n-  const ngHost = new TypeScriptServiceHost(mockHost, tsLS);\n-  const ngLS = createLanguageService(ngHost);\n-\n-  beforeEach(() => {\n-    mockHost.reset();\n-  });\n-\n-  it('should produce no diagnostics for test.ng', () => {\n-    // there should not be any errors on existing external template\n-    expect(ngLS.getSemanticDiagnostics('/app/test.ng')).toEqual([]);\n-  });\n-\n-  it('should not return TS and NG errors for existing files', () => {\n-    const files = [\n-      '/app/app.component.ts',\n-      '/app/main.ts',\n-    ];\n-    for (const file of files) {\n-      const syntaxDiags = tsLS.getSyntacticDiagnostics(file);\n-      expect(syntaxDiags).toEqual([]);\n-      const semanticDiags = tsLS.getSemanticDiagnostics(file);\n-      expect(semanticDiags).toEqual([]);\n-      const ngDiags = ngLS.getSemanticDiagnostics(file);\n-      expect(ngDiags).toEqual([]);\n-    }\n-  });\n-\n-  it('should report error for unexpected end of expression', () => {\n-    const content = mockHost.override(TEST_TEMPLATE, `{{ 5 / }}`);\n-    const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-    expect(diags.length).toBe(1);\n-    const {messageText, start, length} = diags[0];\n-    expect(messageText)\n-        .toBe(\n-            'Parser Error: Unexpected end of expression: {{ 5 / }} ' +\n-            'at the end of the expression [{{ 5 / }}] in /app/test.ng@0:0');\n-    expect(start).toBe(0);\n-    expect(length).toBe(content.length);\n-  });\n-\n-  // https://github.com/angular/vscode-ng-language-service/issues/242\n-  it('should support $any() type cast function', () => {\n-    mockHost.override(TEST_TEMPLATE, `<div>{{$any(title).xyz}}</div>`);\n-    const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-    expect(diags).toEqual([]);\n-  });\n-\n-  it('should report error for $any() with incorrect number of arguments', () => {\n-    const templates = [\n-      '<div>{{$any().xyz}}</div>',              // no argument\n-      '<div>{{$any(title, title).xyz}}</div>',  // two arguments\n-    ];\n-    for (const template of templates) {\n-      mockHost.override(TEST_TEMPLATE, template);\n-      const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-      expect(diags.length).toBe(1);\n-      expect(diags[0].messageText).toBe('Unable to resolve signature for call of $any');\n-    }\n-  });\n-\n-  it('should not produce diagnostics for absolute template url', () => {\n-    mockHost.override(APP_COMPONENT, `\n-      import {Component} from '@angular/core';\n-\n-      @Component({\n-        templateUrl: '${TEST_TEMPLATE}',\n-      })\n-      export class AppComponent {}\n-    `);\n-    const diags = ngLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(diags).toEqual([]);\n-  });\n-\n-  it('should not produce diagnostics for slice pipe with arguments', () => {\n-    mockHost.override(TEST_TEMPLATE, `\n-      <div *ngFor=\"let h of heroes | slice:0:1\">\n-        {{h.name}}\n-      </div>`);\n-    const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-    expect(diags).toEqual([]);\n-  });\n-\n-  it('should produce diagnostics for slice pipe with args when member is invalid', () => {\n-    mockHost.override(TEST_TEMPLATE, `\n-      <div *ngFor=\"let h of heroes | slice:0:1\">\n-        {{h.age}}\n-      </div>`);\n-    const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-    expect(diags.length).toBe(1);\n-    expect(diags[0].messageText)\n-        .toBe(`Identifier 'age' is not defined. 'Hero' does not contain such a member`);\n-  });\n-\n-  it('should not report error for variable initialized as class method', () => {\n-    mockHost.override(TEST_TEMPLATE, `\n-      <ng-template let-greet=\"myClick\">\n-        <span (click)=\"greet()\"></span>\n-      </ng-template>\n-    `);\n-    const diagnostics = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-    expect(diagnostics).toEqual([]);\n-  });\n-\n-  describe('diagnostics for expression comparisons', () => {\n-    for (let [left, right, leftTy, rightTy] of [\n-             ['\\'abc\\'', 1, 'string', 'number'],\n-             ['hero', 2, 'object', 'number'],\n-             ['strOrNumber', 'hero', 'string|number', 'object'],\n-    ]) {\n-      it(`it should report errors for mismtched types in a comparison: ${leftTy} and ${rightTy}`,\n-         () => {\n-           mockHost.override(TEST_TEMPLATE, `{{ ${left} != ${right} }}`);\n-           const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-           expect(diags.length).toBe(1);\n-           expect(diags[0].messageText).toBe(`Expected operands to be of comparable types or any`);\n-         });\n-    }\n-\n-    for (let [left, right, leftTy, rightTy] of [\n-             ['\\'abc\\'', 'anyValue', 'string', 'any'],\n-             ['\\'abc\\'', null, 'string', 'null'],\n-             ['\\'abc\\'', undefined, 'string', 'undefined'],\n-             [null, null, 'null', 'null'],\n-             ['{a: 1}', '{b: 2}', 'object', 'object'],\n-             ['strOrNumber', '1', 'string|number', 'number'],\n-    ]) {\n-      it(`it should not report errors for compatible types in a comparison: ${leftTy} and ${\n-             rightTy}`,\n-         () => {\n-           mockHost.override(TEST_TEMPLATE, `{{ ${left} != ${right} }}`);\n-           const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-           expect(diags.length).toBe(0);\n-         });\n-    }\n-  });\n-\n-  describe('diagnostics for ngFor exported values', () => {\n-    it('should report errors for mismatched exported types', () => {\n-      mockHost.override(TEST_TEMPLATE, `\n-        <div *ngFor=\"let hero of heroes; let i = index; let isFirst = first\">\n-            'i' is a number; 'isFirst' is a boolean\n-          {{ i === isFirst }}\n-        </div>\n-      `);\n-      const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-      expect(diags.length).toBe(1);\n-      expect(diags[0].messageText).toBe(`Expected operands to be of comparable types or any`);\n-    });\n-\n-    it('should not report errors for matching exported type', () => {\n-      mockHost.override(TEST_TEMPLATE, `\n-        <div *ngFor=\"let hero of heroes; let i = index\">\n-            'i' is a number\n-          {{ i < 2 }}\n-        </div>\n-      `);\n-      const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-      expect(diags.length).toBe(0);\n-    });\n-  });\n-\n-  describe('diagnostics for ngIf exported values', () => {\n-    it('should infer the type of an implicit value in an NgIf context', () => {\n-      mockHost.override(TEST_TEMPLATE, `\n-        <div *ngIf=\"title; let titleProxy;\">\n-            'titleProxy' is a string\n-          {{titleProxy.~{start-err}notAProperty~{end-err}}}\n-        </div>\n-      `);\n-      const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-      expect(diags.length).toBe(1);\n-      const {messageText, start, length} = diags[0];\n-      expect(messageText)\n-          .toBe(\n-              `Identifier 'notAProperty' is not defined. 'string' does not contain such a member`);\n-      const span = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'err');\n-      expect(start).toBe(span.start);\n-      expect(length).toBe(span.length);\n-    });\n-\n-    it('should infer the type of an ngIf value in an NgIf context', () => {\n-      mockHost.override(TEST_TEMPLATE, `\n-        <div *ngIf=\"title as titleProxy\">\n-            'titleProxy' is a string\n-          {{titleProxy.~{start-err}notAProperty~{end-err}}}\n-        </div>\n-      `);\n-      const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-      expect(diags.length).toBe(1);\n-      const {messageText, start, length} = diags[0];\n-      expect(messageText)\n-          .toBe(\n-              `Identifier 'notAProperty' is not defined. 'string' does not contain such a member`);\n-      const span = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'err');\n-      expect(start).toBe(span.start);\n-      expect(length).toBe(span.length);\n-    });\n-  });\n-\n-  describe('diagnostics for invalid indexed type property access', () => {\n-    it('should work with numeric index signatures (arrays)', () => {\n-      mockHost.override(TEST_TEMPLATE, `\n-        {{heroes[0].badProperty}}`);\n-      const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-      expect(diags.length).toBe(1);\n-      expect(diags[0].messageText)\n-          .toBe(`Identifier 'badProperty' is not defined. 'Hero' does not contain such a member`);\n-    });\n-\n-    describe('with string index signatures', () => {\n-      it('should work with index notation', () => {\n-        mockHost.override(TEST_TEMPLATE, `\n-        {{heroesByName['Jacky'].badProperty}}`);\n-        const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-        expect(diags.length).toBe(1);\n-        expect(diags[0].messageText)\n-            .toBe(`Identifier 'badProperty' is not defined. 'Hero' does not contain such a member`);\n-      });\n-\n-      it('should work with dot notation', () => {\n-        mockHost.override(TEST_TEMPLATE, `\n-        {{heroesByName.jacky.badProperty}}`);\n-        const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-        expect(diags.length).toBe(1);\n-        expect(diags[0].messageText)\n-            .toBe(`Identifier 'badProperty' is not defined. 'Hero' does not contain such a member`);\n-      });\n-\n-      it('should not produce errors with dot notation if stringIndexType is a primitive type',\n-         () => {\n-           mockHost.override(TEST_TEMPLATE, `{{primitiveIndexType.test}}`);\n-           const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-           expect(diags.length).toBe(0);\n-         });\n-    });\n-  });\n-\n-  it('should produce diagnostics for invalid tuple type property access', () => {\n-    mockHost.override(TEST_TEMPLATE, `\n-        {{tupleArray[1].badProperty}}`);\n-    const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-    expect(diags.length).toBe(1);\n-    expect(diags[0].messageText)\n-        .toBe(`Identifier 'badProperty' is not defined. 'Hero' does not contain such a member`);\n-  });\n-\n-  it('should not produce errors if tuple array index out of bound', () => {\n-    mockHost.override(TEST_TEMPLATE, `\n-        {{tupleArray[2].badProperty}}`);\n-    const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-    expect(diags).toEqual([]);\n-  });\n-\n-  it('should not produce errors on function.bind()', () => {\n-    mockHost.override(TEST_TEMPLATE, `\n-      <test-comp (test)=\"myClick.bind(this)\">\n-      </test-comp>`);\n-    const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-    expect(diags).toEqual([]);\n-  });\n-\n-  it('should report access to an unknown field', () => {\n-    mockHost.override(TEST_TEMPLATE, `{{ foo }}`);\n-    const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE).map(d => d.messageText);\n-    expect(diags).toContain(\n-        `Identifier 'foo' is not defined. ` +\n-        `The component declaration, template variable declarations, ` +\n-        `and element references do not contain such a member`);\n-  });\n-\n-  it('should report access to an unknown sub-field', () => {\n-    mockHost.override(TEST_TEMPLATE, `{{ hero.nam }}`);\n-    const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE).map(d => d.messageText);\n-    expect(diags).toContain(\n-        `Identifier 'nam' is not defined. 'Hero' does not contain such a member`);\n-  });\n-\n-  it('should report access to a private member', () => {\n-    mockHost.override(TEST_TEMPLATE, `{{ myField }}`);\n-    const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE).map(d => d.messageText);\n-    expect(diags).toContain(`Identifier 'myField' refers to a private member of the component`);\n-  });\n-\n-  it('should report numeric operator errors', () => {\n-    mockHost.override(TEST_TEMPLATE, `{{ 'a' % 2 }}`);\n-    const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE).map(d => d.messageText);\n-    expect(diags).toContain('Expected a number type');\n-  });\n-\n-  it('should report an unknown field', () => {\n-    mockHost.override(TEST_TEMPLATE, `<div *ngFor=\"let person of people\"></div>`);\n-    const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE).map(d => d.messageText);\n-    expect(diags).toContain(\n-        `Identifier 'people' is not defined. ` +\n-        `The component declaration, template variable declarations, ` +\n-        `and element references do not contain such a member`);\n-  });\n-\n-  it('should report an unknown value in a key expression', () => {\n-    mockHost.override(TEST_TEMPLATE, `<div *ngFor=\"let hero of heroes; trackBy: trackByFn\"></div>`);\n-    const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE).map(d => d.messageText);\n-    expect(diags).toContain(\n-        `Identifier 'trackByFn' is not defined. ` +\n-        `The component declaration, template variable declarations, ` +\n-        `and element references do not contain such a member`);\n-  });\n-\n-  describe('embedded templates', () => {\n-    it('should suggest refining a template context missing a property', () => {\n-      mockHost.override(\n-          TEST_TEMPLATE,\n-          `<button type=\"button\" *counter=\"~{start-emb}let hero ~{end-emb}of heroes\"></button>`);\n-      const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-      expect(diags.length).toBe(1);\n-      const {messageText, start, length, category} = diags[0];\n-      expect(category).toBe(ts.DiagnosticCategory.Suggestion);\n-      expect(messageText)\n-          .toBe(\n-              `The template context of 'CounterDirective' does not define an implicit value.\\n` +\n-                  `If the context type is a base type or 'any', consider refining it to a more specific type.`,\n-          );\n-\n-      const span = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'emb');\n-      expect(start).toBe(span.start);\n-      expect(length).toBe(span.length);\n-    });\n-\n-    it('should report an unknown context reference', () => {\n-      mockHost.override(\n-          TEST_TEMPLATE,\n-          `<div *ngFor=\"let hero of heroes; ~{start-emb}let e = even_1~{end-emb}\"></div>`);\n-      const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-      expect(diags.length).toBe(1);\n-      const {messageText, start, length, category} = diags[0];\n-      expect(category).toBe(ts.DiagnosticCategory.Suggestion);\n-      expect(messageText)\n-          .toBe(\n-              `The template context of 'NgForOf' does not define a member called 'even_1'.\\n` +\n-              `If the context type is a base type or 'any', consider refining it to a more specific type.`);\n-\n-      const span = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'emb');\n-      expect(start).toBe(span.start);\n-      expect(length).toBe(span.length);\n-    });\n-\n-    it('report an unknown field in $implicit context', () => {\n-      mockHost.override(TEST_TEMPLATE, `\n-        <div *withContext=\"let myVar\">\n-          {{ myVar.~{start-emb}missingField~{end-emb} }}\n-        </div>\n-      `);\n-      const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-      expect(diags.length).toBe(1);\n-      const {messageText, start, length, category} = diags[0];\n-      expect(category).toBe(ts.DiagnosticCategory.Error);\n-      expect(messageText)\n-          .toBe(\n-              `Identifier 'missingField' is not defined. '{ implicitPerson: Hero; }' does not contain such a member`,\n-          );\n-      const span = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'emb');\n-      expect(start).toBe(span.start);\n-      expect(length).toBe(span.length);\n-    });\n-\n-    it('report an unknown field in non implicit context', () => {\n-      mockHost.override(TEST_TEMPLATE, `\n-        <div *withContext=\"let myVar = nonImplicitPerson\">\n-          {{ myVar.~{start-emb}missingField~{end-emb} }}\n-        </div>\n-      `);\n-      const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-      expect(diags.length).toBe(1);\n-      const {messageText, start, length, category} = diags[0];\n-      expect(category).toBe(ts.DiagnosticCategory.Error);\n-      expect(messageText)\n-          .toBe(\n-              `Identifier 'missingField' is not defined. 'Hero' does not contain such a member`,\n-          );\n-      const span = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'emb');\n-      expect(start).toBe(span.start);\n-      expect(length).toBe(span.length);\n-    });\n-  });\n-\n-  // #17611\n-  it('should not report diagnostic on iteration of any', () => {\n-    const fileName = '/app/test.ng';\n-    mockHost.override(fileName, '<div *ngFor=\"let value of anyValue\">{{value.someField}}</div>');\n-    const diagnostics = ngLS.getSemanticDiagnostics(fileName);\n-    expect(diagnostics).toEqual([]);\n-  });\n-\n-  it('should report diagnostic for invalid property in nested ngFor', () => {\n-    const content = mockHost.override(TEST_TEMPLATE, `\n-      <div *ngFor=\"let leagueMembers of league\">\n-        <div *ngFor=\"let member of leagueMembers\">\n-          {{member.xyz}}\n-        </div>\n-      </div>\n-    `);\n-    const diagnostics = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-    expect(diagnostics.length).toBe(1);\n-    const {messageText, start, length} = diagnostics[0];\n-    expect(messageText)\n-        .toBe(`Identifier 'xyz' is not defined. 'Hero' does not contain such a member`);\n-    expect(content.substring(start!, start! + length!)).toBe('xyz');\n-  });\n-\n-  describe('with $event', () => {\n-    it('should accept an event', () => {\n-      mockHost.override(TEST_TEMPLATE, '<div (click)=\"myClick($event)\">Click me!</div>');\n-      const diagnostics = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-      expect(diagnostics).toEqual([]);\n-    });\n-\n-    it('should reject it when not in an event binding', () => {\n-      const content = mockHost.override(TEST_TEMPLATE, '<div [tabIndex]=\"$event\"></div>');\n-      const diagnostics = ngLS.getSemanticDiagnostics(TEST_TEMPLATE)!;\n-      expect(diagnostics.length).toBe(1);\n-      const {messageText, start, length} = diagnostics[0];\n-      expect(messageText)\n-          .toBe(\n-              `Identifier '$event' is not defined. The component declaration, template variable declarations, and element references do not contain such a member`);\n-      const keyword = '$event';\n-      expect(start).toBe(content.lastIndexOf(keyword));\n-      expect(length).toBe(keyword.length);\n-    });\n-\n-    it('should reject invalid properties on an event type', () => {\n-      const content = mockHost.override(\n-          TEST_TEMPLATE, '<div string-model (modelChange)=\"$event.notSubstring()\"></div>');\n-      const diagnostics = ngLS.getSemanticDiagnostics(TEST_TEMPLATE)!;\n-      expect(diagnostics.length).toBe(1);\n-      const {messageText, start, length} = diagnostics[0];\n-      expect(messageText)\n-          .toBe(\n-              `Identifier 'notSubstring' is not defined. 'string' does not contain such a member`);\n-      expect(content.substring(start!, start! + length!)).toBe('notSubstring');\n-    });\n-  });\n-\n-  it('should not crash with a incomplete *ngFor', () => {\n-    const fileName = mockHost.addCode(`\n-      @Component({\n-        template: '<div *ngFor></div> ~{after-div}'\n-      })\n-      export class MyComponent {}`);\n-    expect(() => ngLS.getSemanticDiagnostics(fileName)).not.toThrow();\n-  });\n-\n-  it('should report a component not in a module', () => {\n-    const fileName = mockHost.addCode(`\n-      @Component({\n-        template: '<div></div>'\n-      })\n-      export class MyComponent {}`);\n-    const diagnostics = ngLS.getSemanticDiagnostics(fileName)!;\n-    expect(diagnostics.length).toBe(1);\n-    const {messageText, start, length} = diagnostics[0];\n-    expect(messageText)\n-        .toBe(\n-            `Component 'MyComponent' is not included in a module and will not be available inside a template. Consider adding it to a NgModule declaration.`);\n-    const content = mockHost.readFile(fileName)!;\n-    expect(content.substring(start!, start! + length!)).toBe('MyComponent');\n-  });\n-\n-\n-  it(`should not report an error for a form's host directives`, () => {\n-    mockHost.override(APP_COMPONENT, `\n-      import { Component } from '@angular/core';\n-\n-      @Component({\n-        template: '<form></form>'})\n-      export class AppComponent {}`);\n-    const tsDiags = tsLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(tsDiags).toEqual([]);\n-    const ngDiags = ngLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(ngDiags).toEqual([]);\n-  });\n-\n-  it('should not throw getting diagnostics for an index expression', () => {\n-    const fileName = mockHost.addCode(`\n-      @Component({\n-        template: '<a *ngIf=\"(auth.isAdmin | async) || (event.leads && event.leads[(auth.uid | async)])\"></a>'\n-      })\n-      export class MyComponent {}`);\n-    expect(() => ngLS.getSemanticDiagnostics(fileName)).not.toThrow();\n-  });\n-\n-  it('should not throw using a directive with no value', () => {\n-    const fileName = mockHost.addCode(`\n-      @Component({\n-        template: '<form><input [(ngModel)]=\"name\" required /></form>'\n-      })\n-      export class MyComponent {\n-        name = 'some name';\n-      }`);\n-    expect(() => ngLS.getSemanticDiagnostics(fileName)).not.toThrow();\n-  });\n-\n-  it('should report an error for invalid metadata', () => {\n-    const content = mockHost.override(APP_COMPONENT, `\n-      import { Component } from '@angular/core';\n-\n-      @Component({\n-        template: '<div></div>',\n-        providers: [\n-          {provide: 'foo', useFactory: () => 'foo' }\n-        ]\n-      })\n-      export class AppComponent {\n-        name = 'some name';\n-      }`);\n-    const tsDiags = tsLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(tsDiags).toEqual([]);\n-    const ngDiags = ngLS.getSemanticDiagnostics(APP_COMPONENT)!;\n-    expect(ngDiags.length).toBe(1);\n-    const {messageText, start, length} = ngDiags[0];\n-    const keyword = `() => 'foo'`;\n-    expect(start).toBe(content.lastIndexOf(keyword));\n-    expect(length).toBe(keyword.length);\n-    // messageText is a three-part chain\n-    const firstPart = messageText as ts.DiagnosticMessageChain;\n-    expect(firstPart.messageText).toBe(`Error during template compile of 'AppComponent'`);\n-    const secondPart = firstPart.next!;\n-    expect(secondPart[0].messageText).toBe('Function expressions are not supported in decorators');\n-    const thirdPart = secondPart[0].next!;\n-    expect(thirdPart[0].messageText)\n-        .toBe('Consider changing the function expression into an exported function');\n-    expect(thirdPart[0].next).toBeFalsy();\n-  });\n-\n-  it('should not throw for an invalid class', () => {\n-    const fileName = mockHost.addCode(`\n-      @Component({\n-        template: ''\n-      }) class`);\n-    expect(() => ngLS.getSemanticDiagnostics(fileName)).not.toThrow();\n-  });\n-\n-  it('should not report an error for sub-types of string in non-strict mode', () => {\n-    mockHost.override(APP_COMPONENT, `\n-      import { Component } from '@angular/core';\n-\n-      @Component({\n-        template: \\`<div *ngIf=\"something === 'foo'\"></div>\\`\n-      })\n-      export class AppComponent {\n-        something: 'foo' | 'bar';\n-      }`);\n-    mockHost.overrideOptions({\n-      strict: false,  // TODO: this test fails in strict mode\n-    });\n-    const tsDiags = tsLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(tsDiags).toEqual([]);\n-    const ngDiags = ngLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(ngDiags).toEqual([]);\n-  });\n-\n-  it('should not report an error for sub-types of number in non-strict mode', () => {\n-    mockHost.override(APP_COMPONENT, `\n-      import { Component } from '@angular/core';\n-\n-      @Component({\n-        template: '<div *ngIf=\"something === 123\"></div>'\n-      })\n-      export class AppComponent {\n-        something: 123 | 456;\n-      }`);\n-    mockHost.overrideOptions({\n-      strict: false,  // TODO: This test fails in strict mode\n-    });\n-    const tsDiags = tsLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(tsDiags).toEqual([]);\n-    const ngDiags = ngLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(ngDiags).toEqual([]);\n-  });\n-\n-  it('should report a warning if an event results in a callable expression', () => {\n-    const content = mockHost.override(APP_COMPONENT, `\n-      import { Component } from '@angular/core';\n-\n-      @Component({\n-        template: '<div (click)=\"onClick\"></div>'\n-      })\n-      export class AppComponent {\n-        onClick() { }\n-      }`);\n-    const diagnostics = ngLS.getSemanticDiagnostics(APP_COMPONENT)!;\n-    const {messageText, start, length} = diagnostics[0];\n-    expect(messageText).toBe('Unexpected callable expression. Expected a method call');\n-    const keyword = `\"onClick\"`;\n-    expect(start).toBe(content.lastIndexOf(keyword) + 1);  // exclude leading quote\n-    expect(length).toBe(keyword.length - 2);               // exclude leading and trailing quotes\n-  });\n-\n-  // Issue #13326\n-  it('should report a narrow span for invalid pipes', () => {\n-    const content = mockHost.override(APP_COMPONENT, `\n-      import { Component } from '@angular/core';\n-\n-      @Component({\n-        template: '<p> Using an invalid pipe {{data | dat}} </p>'\n-      })\n-      export class AppComponent {\n-        data = 'some data';\n-      }`);\n-    const tsDiags = tsLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(tsDiags).toEqual([]);\n-    const ngDiags = ngLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(ngDiags.length).toBe(1);\n-    const {messageText, start, length} = ngDiags[0];\n-    expect(messageText).toBe(`The pipe 'dat' could not be found`);\n-    const keyword = 'data | dat';\n-    expect(start).toBe(content.lastIndexOf(keyword));\n-    expect(length).toBe(keyword.length);\n-  });\n-\n-  // Issue #19406\n-  it('should allow empty template', () => {\n-    mockHost.override(APP_COMPONENT, `\n-      import { Component } from '@angular/core';\n-\n-      @Component({\n-        template : '',\n-      })\n-      export class AppComponent {}`);\n-    const tsDiags = tsLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(tsDiags).toEqual([]);\n-    const ngDiags = ngLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(ngDiags).toEqual([]);\n-  });\n-\n-  // Issue #15460\n-  it('should be able to find members defined on an ancestor type', () => {\n-    mockHost.override(APP_COMPONENT, `\n-      import { Component } from '@angular/core';\n-      import { NgForm } from '@angular/forms';\n-\n-      @Component({\n-        selector: 'example-app',\n-        template: \\`\n-           <form #f=\"ngForm\" (ngSubmit)=\"onSubmit(f)\" novalidate>\n-            <input name=\"first\" ngModel required #first=\"ngModel\">\n-            <input name=\"last\" ngModel>\n-            <button>Submit</button>\n-          </form>\n-          <p>First name value: {{ first.value }}</p>\n-          <p>First name valid: {{ first.valid }}</p>\n-          <p>Form value: {{ f.value | json }}</p>\n-          <p>Form valid: {{ f.valid }}</p>\n-       \\`,\n-      })\n-      export class AppComponent {\n-        onSubmit(form: NgForm) {}\n-      }`);\n-    const tsDiags = tsLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(tsDiags).toEqual([]);\n-    const ngDiags = ngLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(ngDiags).toEqual([]);\n-  });\n-\n-  it('should report an error for invalid providers', () => {\n-    const content = mockHost.override(APP_COMPONENT, `\n-      import { Component } from '@angular/core';\n-\n-      @Component({\n-        template: '',\n-        providers: [null]\n-      })\n-      export class AppComponent {}`);\n-    const tsDiags = tsLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(tsDiags.length).toBe(1);\n-    const msgText = ts.flattenDiagnosticMessageText(tsDiags[0].messageText, '\\n');\n-    expect(msgText).toBe(`Type 'null' is not assignable to type 'Provider'.`);\n-    const ngDiags = ngLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(ngDiags.length).toBe(1);\n-    const {messageText, start, length} = ngDiags[0];\n-    expect(messageText)\n-        .toBe(\n-            'Invalid providers for \"AppComponent in /app/app.component.ts\" - only instances of Provider and Type are allowed, got: [?null?]');\n-    // TODO: Looks like this is the wrong span. Should point to 'null' instead.\n-    expect(content.substring(start!, start! + length!)).toBe('AppComponent');\n-  });\n-\n-  // Issue #15768\n-  it('should be able to parse a template reference', () => {\n-    mockHost.override(APP_COMPONENT, `\n-      import { Component } from '@angular/core';\n-\n-      @Component({\n-        selector: 'my-component',\n-        template: \\`\n-          <div *ngIf=\"comps | async; let comps; else loading\">\n-          </div>\n-          <ng-template #loading>Loading comps...</ng-template>\n-        \\`\n-      })\n-      export class AppComponent {}`);\n-    const tsDiags = tsLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(tsDiags).toEqual([]);\n-    const ngDiags = ngLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(ngDiags).toEqual([]);\n-  });\n-\n-  // Issue #15625\n-  it('should not report errors for localization syntax', () => {\n-    mockHost.override(APP_COMPONENT, `\n-      import { Component } from '@angular/core';\n-\n-      @Component({\n-        selector: 'my-component',\n-        template: \\`\n-        <div>\n-            {fieldCount, plural, =0 {no fields} =1 {1 field} other {{{fieldCount}} fields}}\n-        </div>\n-        \\`\n-      })\n-      export class AppComponent {\n-        fieldCount: number = 0;\n-      }`);\n-    const tsDiags = tsLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(tsDiags).toEqual([]);\n-    const ngDiags = ngLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(ngDiags).toEqual([]);\n-  });\n-\n-  // Issue #15885\n-  it('should be able to remove null and undefined from a type', () => {\n-    mockHost.overrideOptions({\n-      strictNullChecks: true,\n-    });\n-    mockHost.override(APP_COMPONENT, `\n-      import { Component } from '@angular/core';\n-\n-      @Component({\n-        selector: 'my-component',\n-        template: '{{test?.a}}',\n-      })\n-      export class AppComponent {\n-        test: {a: number, b: number} | null = {\n-          a: 1,\n-          b: 2,\n-        };\n-      }`);\n-    const tsDiags = tsLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(tsDiags).toEqual([]);\n-    const ngDiags = ngLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(ngDiags).toEqual([]);\n-  });\n-\n-  // Issue https://github.com/angular/angular/issues/34874\n-  it('should recognize inputs and outputs listed inside directive decorators', () => {\n-    mockHost.override(\n-        TEST_TEMPLATE, `<div hint-model [hint]=\"title\" (hintChange)=\"myClick($event)\"></div>`);\n-    const ngDiags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-    expect(ngDiags).toEqual([]);\n-  });\n-\n-  it('should be able to resolve modules using baseUrl', () => {\n-    mockHost.override(APP_COMPONENT, `\n-      import { Component } from '@angular/core';\n-      import { NgForm } from '@angular/forms';\n-      import { Server } from 'app/server';\n-\n-      @Component({\n-        selector: 'example-app',\n-        template: '...',\n-        providers: [Server]\n-      })\n-      export class AppComponent {\n-        onSubmit(form: NgForm) {}\n-      }`);\n-    mockHost.addScript('/other/files/app/server.ts', 'export class Server {}');\n-    mockHost.overrideOptions({\n-      baseUrl: '/other/files',\n-    });\n-    const tsDiags = tsLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(tsDiags).toEqual([]);\n-    const diagnostic = ngLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(diagnostic).toEqual([]);\n-  });\n-\n-  it('should report errors for using the now removed OpaqueToken (deprecated)', () => {\n-    mockHost.override(APP_COMPONENT, `\n-      import { Component, Inject, OpaqueToken } from '@angular/core';\n-      import { NgForm } from '@angular/forms';\n-\n-      export const token = new OpaqueToken('some token');\n-\n-      @Component({\n-        selector: 'example-app',\n-        template: '...'\n-      })\n-      export class AppComponent {\n-        constructor (@Inject(token) value: string) {}\n-        onSubmit(form: NgForm) {}\n-      }`);\n-    const tsDiags = tsLS.getSemanticDiagnostics(APP_COMPONENT);\n-    expect(tsDiags.length).toBe(1);\n-    expect(tsDiags[0].messageText)\n-        .toBe(`Module '\"@angular/core\"' has no exported member 'OpaqueToken'.`);\n-  });\n-\n-  describe('templates', () => {\n-    it('should report errors for invalid templateUrls', () => {\n-      const fileName = mockHost.addCode(`\n-        @Component({\n-          templateUrl: 'notAFile',\n-        })\n-        export class MyComponent {}`);\n-\n-      const marker = mockHost.getReferenceMarkerFor(fileName, 'notAFile');\n-\n-      const diagnostics = ngLS.getSemanticDiagnostics(fileName)!;\n-      const urlDiagnostic =\n-          diagnostics.find(d => d.messageText === 'URL does not point to a valid file');\n-      expect(urlDiagnostic).toBeDefined();\n-\n-      const {start, length} = urlDiagnostic!;\n-      expect(start).toBe(marker.start);\n-      expect(length).toBe(marker.length);\n-    });\n-\n-    it('should not report errors for valid templateUrls', () => {\n-      const fileName = mockHost.addCode(`\n-        @Component({\n-          templateUrl: './test.ng',\n-        })\n-        export class MyComponent {}`);\n-\n-      const diagnostics = ngLS.getSemanticDiagnostics(fileName)!;\n-      const urlDiagnostic =\n-          diagnostics.find(d => d.messageText === 'URL does not point to a valid file');\n-      expect(urlDiagnostic).toBeUndefined();\n-    });\n-\n-    it('should report diagnostic for missing template or templateUrl', () => {\n-      const content = mockHost.override(APP_COMPONENT, `\n-        import {Component} from '@angular/core';\n-\n-        @Component({\n-          selector: 'app-example',\n-        })\n-        export class AppComponent {}`);\n-      const diags = ngLS.getSemanticDiagnostics(APP_COMPONENT);\n-      expect(diags.length).toBe(1);\n-      const {file, messageText, start, length} = diags[0];\n-      expect(file!.fileName).toBe(APP_COMPONENT);\n-      expect(messageText).toBe(`Component 'AppComponent' must have a template or templateUrl`);\n-      expect(content.substring(start!, start! + length!)).toBe('AppComponent');\n-    });\n-\n-    it('should report diagnostic for both template and templateUrl', () => {\n-      const content = mockHost.override(APP_COMPONENT, `\n-        import {Component} from '@angular/core';\n-\n-        @Component({\n-          selector: 'app-example',\n-          template: '<div></div>',\n-          templateUrl: './test.ng',\n-        })\n-        export class AppComponent {}`);\n-      const diags = ngLS.getSemanticDiagnostics(APP_COMPONENT);\n-      expect(diags.length).toBe(1);\n-      const {file, messageText, start, length} = diags[0];\n-      expect(file!.fileName).toBe(APP_COMPONENT);\n-      expect(messageText)\n-          .toBe(`Component 'AppComponent' must not have both template and templateUrl`);\n-      expect(content.substring(start!, start! + length!)).toBe('AppComponent');\n-    });\n-\n-    it('should report errors for invalid styleUrls', () => {\n-      const fileName = mockHost.addCode(`\n-        @Component({\n-          styleUrls: ['notAFile'],\n-        })\n-        export class MyComponent {}`);\n-\n-      const marker = mockHost.getReferenceMarkerFor(fileName, 'notAFile');\n-\n-      const diagnostics = ngLS.getSemanticDiagnostics(fileName)!;\n-      const urlDiagnostic =\n-          diagnostics.find(d => d.messageText === 'URL does not point to a valid file');\n-      expect(urlDiagnostic).toBeDefined();\n-\n-      const {start, length} = urlDiagnostic!;\n-      expect(start).toBe(marker.start);\n-      expect(length).toBe(marker.length);\n-    });\n-\n-    it('should not report errors for valid styleUrls', () => {\n-      mockHost.override(APP_COMPONENT, `\n-        import {Component} from '@angular/core';\n-\n-        @Component({\n-          template: '<div></div>',\n-          styleUrls: ['./test.css', './test.css'],\n-        })\n-        export class AppComponent {}`);\n-\n-      const diagnostics = ngLS.getSemanticDiagnostics(APP_COMPONENT)!;\n-      expect(diagnostics.length).toBe(0);\n-    });\n-  });\n-\n-  it('should work correctly with CRLF endings in external template', () => {\n-    // https://github.com/angular/vscode-ng-language-service/issues/235\n-    // In the example below, the string\n-    // `\\r\\n{{line0}}\\r\\n{{line1}}\\r\\n{{line2}}` is tokenized as a whole,\n-    // and then CRLF characters are converted to LF.\n-    // Source span information is lost in the process.\n-    const content = mockHost.override(\n-        TEST_TEMPLATE, '\\r\\n<div>\\r\\n{{line0}}\\r\\n{{line1}}\\r\\n{{line2}}\\r\\n</div>');\n-    const ngDiags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-    expect(ngDiags.length).toBe(3);\n-    for (let i = 0; i < 3; ++i) {\n-      const {messageText, start, length} = ngDiags[i];\n-      expect(messageText)\n-          .toBe(\n-              `Identifier 'line${i}' is not defined. ` +\n-              `The component declaration, template variable declarations, and ` +\n-              `element references do not contain such a member`);\n-      // Assert that the span is actually highlight the bounded text. The span\n-      // would be off if CRLF endings are not handled properly.\n-      expect(content.substring(start!, start! + length!)).toBe(`line${i}`);\n-    }\n-  });\n-\n-  it('should work correctly with CRLF endings in inline template', () => {\n-    const fileName = mockHost.addCode(\n-        '\\n@Component({template:`\\r\\n\\r\\n{{line}}`})export class ComponentCRLF {}');\n-    const content = mockHost.readFile(fileName)!;\n-    const ngDiags = ngLS.getSemanticDiagnostics(fileName);\n-    expect(ngDiags.length).toBeGreaterThan(0);\n-    const {messageText, start, length} = ngDiags[0];\n-    expect(messageText)\n-        .toBe(\n-            `Identifier 'line' is not defined. ` +\n-            `The component declaration, template variable declarations, and ` +\n-            `element references do not contain such a member`);\n-    expect(content.substring(start!, start! + length!)).toBe('line');\n-  });\n-\n-  it('should not produce diagnostics for non-exported directives', () => {\n-    const fileName = '/app/test.component.ts';\n-    mockHost.addScript(fileName, `\n-      import {Component} from '@angular/core';\n-\n-      @Component({\n-        template: '<test-comp></test-comp>'\n-      })\n-      class TestHostComponent {}\n-    `);\n-    const tsDiags = tsLS.getSemanticDiagnostics(fileName);\n-    expect(tsDiags).toEqual([]);\n-    const ngDiags = ngLS.getSemanticDiagnostics(fileName);\n-    expect(ngDiags).toEqual([]);\n-  });\n-\n-  it('should suggest ? or ! operator if method receiver is nullable', () => {\n-    const content = mockHost.override(TEST_TEMPLATE, `{{optional && optional.toLowerCase()}}`);\n-    const ngDiags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-    expect(ngDiags.length).toBe(1);\n-    const {start, length, messageText, category} = ngDiags[0];\n-    expect(messageText)\n-        .toBe(\n-            `'optional' is possibly undefined. ` +\n-            `Consider using the safe navigation operator (optional?.toLowerCase) ` +\n-            `or non-null assertion operator (optional!.toLowerCase).`);\n-    expect(category).toBe(ts.DiagnosticCategory.Suggestion);\n-    expect(content.substring(start!, start! + length!)).toBe('toLowerCase');\n-  });\n-\n-  it('should suggest ? or ! operator if property receiver is nullable', () => {\n-    const content = mockHost.override(TEST_TEMPLATE, `{{optional && optional.length}}`);\n-    const ngDiags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-    expect(ngDiags.length).toBe(1);\n-    const {start, length, messageText, category} = ngDiags[0];\n-    expect(messageText)\n-        .toBe(\n-            `'optional' is possibly undefined. ` +\n-            `Consider using the safe navigation operator (optional?.length) ` +\n-            `or non-null assertion operator (optional!.length).`);\n-    expect(category).toBe(ts.DiagnosticCategory.Suggestion);\n-    expect(content.substring(start!, start! + length!)).toBe('length');\n-  });\n-\n-  it('should report error if method is not found on non-nullable receivers', () => {\n-    const expressions = [\n-      'optional?',\n-      'optional!',\n-    ];\n-    for (const expression of expressions) {\n-      const content = mockHost.override(TEST_TEMPLATE, `{{ ${expression}.someMethod() }}`);\n-      const ngDiags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-      expect(ngDiags.length).toBe(1);\n-      const {start, length, messageText, category} = ngDiags[0];\n-      expect(messageText)\n-          .toBe(`Identifier 'someMethod' is not defined. 'string' does not contain such a member`);\n-      expect(category).toBe(ts.DiagnosticCategory.Error);\n-      expect(content.substring(start!, start! + length!)).toBe('someMethod');\n-    }\n-  });\n-\n-  it('should report error if property is not found on non-nullable receivers', () => {\n-    const expressions = [\n-      'optional?',\n-      'optional!',\n-    ];\n-    for (const expression of expressions) {\n-      const content = mockHost.override(TEST_TEMPLATE, `{{ ${expression}.someProp }}`);\n-      const ngDiags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-      expect(ngDiags.length).toBe(1);\n-      const {start, length, messageText, category} = ngDiags[0];\n-      expect(messageText)\n-          .toBe(`Identifier 'someProp' is not defined. 'string' does not contain such a member`);\n-      expect(category).toBe(ts.DiagnosticCategory.Error);\n-      expect(content.substring(start!, start! + length!)).toBe('someProp');\n-    }\n-  });\n-\n-  describe('function calls', () => {\n-    it('should report error for non-callable function call', () => {\n-      mockHost.override(TEST_TEMPLATE, `\n-        <p>{{myClick()()}}</p>\n-      `);\n-\n-      const content = mockHost.readFile(TEST_TEMPLATE)!;\n-      const diags = ngLS.getSemanticDiagnostics(TEST_TEMPLATE);\n-      expect(diags.length).toBe(1);\n-      const {messageText, start, length} = diags[0]!;\n-      expect(messageText).toBe(`Call target 'myClick()' has non-callable type 'void'.`);\n-      expect(content.substring(start!, start! + length!)).toBe('myClick()()');\n-    });\n-  });\n-});"
        },
        {
            "sha": "34b9333b4b5bc3209659370f46e355fe96b326fa",
            "filename": "packages/language-service/test/expression_diagnostics_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 262,
            "changes": 262,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fexpression_diagnostics_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fexpression_diagnostics_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fexpression_diagnostics_spec.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,262 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {StaticSymbol} from '@angular/compiler';\n-import {Directory} from '@angular/compiler-cli/test/mocks';\n-import {ReflectorHost} from '@angular/language-service/src/reflector_host';\n-import ts from 'typescript';\n-\n-import {getTemplateExpressionDiagnostics} from '../src/expression_diagnostics';\n-\n-import {DiagnosticContext, getDiagnosticTemplateInfo, MockLanguageServiceHost} from './mocks';\n-\n-describe('expression diagnostics', () => {\n-  let registry: ts.DocumentRegistry;\n-\n-  let host: MockLanguageServiceHost;\n-  let service: ts.LanguageService;\n-  let context: DiagnosticContext;\n-  let type: StaticSymbol;\n-\n-  beforeAll(() => {\n-    registry = ts.createDocumentRegistry(false, '/src');\n-    host = new MockLanguageServiceHost(['app/app.component.ts'], FILES, '/src');\n-    service = ts.createLanguageService(host, registry);\n-    const program = service.getProgram()!;\n-    const checker = program.getTypeChecker();\n-    const symbolResolverHost = new ReflectorHost(() => program!, host);\n-    context = new DiagnosticContext(service, program!, checker, symbolResolverHost);\n-    type = context.getStaticSymbol('app/app.component.ts', 'AppComponent');\n-  });\n-\n-  it('should have no diagnostics in default app', () => {\n-    function messageToString(messageText: string|ts.DiagnosticMessageChain): string {\n-      if (typeof messageText == 'string') {\n-        return messageText;\n-      } else {\n-        if (messageText.next)\n-          return messageText.messageText + messageText.next.map(messageToString);\n-        return messageText.messageText;\n-      }\n-    }\n-\n-    function expectNoDiagnostics(diagnostics: ts.Diagnostic[]) {\n-      if (diagnostics && diagnostics.length) {\n-        const message =\n-            'messages: ' + diagnostics.map(d => messageToString(d.messageText)).join('\\n');\n-        expect(message).toEqual('');\n-      }\n-    }\n-\n-    expectNoDiagnostics(service.getCompilerOptionsDiagnostics());\n-    expectNoDiagnostics(service.getSyntacticDiagnostics('app/app.component.ts'));\n-    expectNoDiagnostics(service.getSemanticDiagnostics('app/app.component.ts'));\n-  });\n-\n-\n-  function accept(template: string) {\n-    const info = getDiagnosticTemplateInfo(context, type, 'app/app.component.html', template);\n-    if (info) {\n-      const diagnostics = getTemplateExpressionDiagnostics(info);\n-      if (diagnostics && diagnostics.length) {\n-        const message = diagnostics.map(d => d.message).join('\\n  ');\n-        throw new Error(`Unexpected diagnostics: ${message}`);\n-      }\n-    } else {\n-      expect(info).toBeDefined();\n-    }\n-  }\n-\n-  function reject(template: string, expected: string) {\n-    const info = getDiagnosticTemplateInfo(context, type, 'app/app.component.html', template);\n-    if (info) {\n-      const diagnostics = getTemplateExpressionDiagnostics(info);\n-      if (diagnostics && diagnostics.length) {\n-        const messages = diagnostics.map(d => d.message).join('\\n  ');\n-        expect(messages).toContain(expected);\n-      } else {\n-        throw new Error(`Expected an error containing \"${expected} in template \"${template}\"`);\n-      }\n-    } else {\n-      expect(info).toBeDefined();\n-    }\n-  }\n-\n-  it('should accept a simple template', () => accept('App works!'));\n-  it('should accept an interpolation', () => accept('App works: {{person.name.first}}'));\n-  it('should reject misspelled access',\n-     () => reject('{{persson}}', 'Identifier \\'persson\\' is not defined'));\n-  it('should reject access to private',\n-     () =>\n-         reject('{{private_person}}', 'Identifier \\'private_person\\' refers to a private member'));\n-  it('should accept an *ngIf', () => accept('<div *ngIf=\"person\">{{person.name.first}}</div>'));\n-  it('should reject *ngIf of misspelled identifier',\n-     () => reject(\n-         '<div *ngIf=\"persson\">{{person.name.first}}</div>',\n-         'Identifier \\'persson\\' is not defined'));\n-  it('should reject *ngIf of misspelled identifier in PrefixNot node',\n-     () =>\n-         reject('<div *ngIf=\"people && !persson\"></div>', 'Identifier \\'persson\\' is not defined'));\n-  it('should reject misspelled field in unary operator expression',\n-     () => reject('{{ +persson }}', `Identifier 'persson' is not defined`));\n-  it('should accept an *ngFor', () => accept(`\n-      <div *ngFor=\"let p of people\">\n-        {{p.name.first}} {{p.name.last}}\n-      </div>\n-    `));\n-  it('should reject misspelled field in *ngFor',\n-     () => reject(\n-         `\n-      <div *ngFor=\"let p of people\">\n-        {{p.names.first}} {{p.name.last}}\n-      </div>\n-    `,\n-         'Identifier \\'names\\' is not defined'));\n-  it('should accept an async expression',\n-     () => accept('{{(promised_person | async)?.name.first || \"\"}}'));\n-  it('should reject an async misspelled field',\n-     () => reject(\n-         '{{(promised_person | async)?.nume.first || \"\"}}', 'Identifier \\'nume\\' is not defined'));\n-  it('should accept an async *ngFor', () => accept(`\n-      <div *ngFor=\"let p of promised_people | async\">\n-        {{p.name.first}} {{p.name.last}}\n-      </div>\n-    `));\n-  it('should reject misspelled field an async *ngFor',\n-     () => reject(\n-         `\n-      <div *ngFor=\"let p of promised_people | async\">\n-        {{p.name.first}} {{p.nume.last}}\n-      </div>\n-    `,\n-         'Identifier \\'nume\\' is not defined'));\n-  it('should accept an async *ngIf', () => accept(`\n-      <div *ngIf=\"promised_person | async as p\">\n-        {{p.name.first}} {{p.name.last}}\n-      </div>\n-    `));\n-  it('should reject misspelled field in async *ngIf',\n-     () => reject(\n-         `\n-      <div *ngIf=\"promised_person | async as p\">\n-        {{p.name.first}} {{p.nume.last}}\n-      </div>\n-    `,\n-         'Identifier \\'nume\\' is not defined'));\n-  it('should reject access to potentially undefined field',\n-     () => reject(\n-         `<div>{{maybe_person.name.first}}`,\n-         `'maybe_person' is possibly undefined. Consider using the safe navigation operator (maybe_person?.name) or non-null assertion operator (maybe_person!.name).`));\n-  it('should accept a safe accss to an undefined field',\n-     () => accept(`<div>{{maybe_person?.name.first}}</div>`));\n-  it('should accept a type assert to an undefined field',\n-     () => accept(`<div>{{maybe_person!.name.first}}</div>`));\n-  it('should accept a # reference', () => accept(`\n-          <form #f=\"ngForm\" novalidate>\n-            <input name=\"first\" ngModel required #first=\"ngModel\">\n-            <input name=\"last\" ngModel>\n-            <button>Submit</button>\n-          </form>\n-          <p>First name value: {{ first.value }}</p>\n-          <p>First name valid: {{ first.valid }}</p>\n-          <p>Form value: {{ f.value | json }}</p>\n-          <p>Form valid: {{ f.valid }}</p>\n-    `));\n-  it('should reject a misspelled field of a # reference',\n-     () => reject(\n-         `\n-          <form #f=\"ngForm\" novalidate>\n-            <input name=\"first\" ngModel required #first=\"ngModel\">\n-            <input name=\"last\" ngModel>\n-            <button>Submit</button>\n-          </form>\n-          <p>First name value: {{ first.valwe }}</p>\n-          <p>First name valid: {{ first.valid }}</p>\n-          <p>Form value: {{ f.value | json }}</p>\n-          <p>Form valid: {{ f.valid }}</p>\n-    `,\n-         'Identifier \\'valwe\\' is not defined'));\n-  it('should accept a call to a method', () => accept('{{getPerson().name.first}}'));\n-  it('should reject a misspelled field of a method result',\n-     () => reject('{{getPerson().nume.first}}', 'Identifier \\'nume\\' is not defined'));\n-  it('should reject calling a uncallable member',\n-     () => reject('{{person().name.first}}', '\\'person\\' is not callable'));\n-  it('should accept an event handler',\n-     () => accept('<div (click)=\"click($event)\">{{person.name.first}}</div>'));\n-  it('should reject a misspelled event handler',\n-     () => reject(\n-         '<div (click)=\"clack($event)\">{{person.name.first}}</div>',\n-         `Identifier 'clack' is not defined. The component declaration, template variable declarations, and element references do not contain such a member`));\n-  it('should reject an uncalled event handler',\n-     () => reject(\n-         '<div (click)=\"click\">{{person.name.first}}</div>', 'Unexpected callable expression'));\n-  describe('with comparisons between nullable and non-nullable', () => {\n-    it('should accept ==', () => accept(`<div>{{e == 1 ? 'a' : 'b'}}</div>`));\n-    it('should accept ===', () => accept(`<div>{{e === 1 ? 'a' : 'b'}}</div>`));\n-    it('should accept !=', () => accept(`<div>{{e != 1 ? 'a' : 'b'}}</div>`));\n-    it('should accept !==', () => accept(`<div>{{e !== 1 ? 'a' : 'b'}}</div>`));\n-    it('should accept &&', () => accept(`<div>{{e && 1 ? 'a' : 'b'}}</div>`));\n-    it('should accept ||', () => accept(`<div>{{e || 1 ? 'a' : 'b'}}</div>`));\n-    it('should reject >',\n-       () => reject(`<div>{{e > 1 ? 'a' : 'b'}}</div>`, 'The expression might be null'));\n-  });\n-});\n-\n-const FILES: Directory = {\n-  'src': {\n-    'app': {\n-      'app.component.ts': `\n-        import { Component, NgModule } from '@angular/core';\n-        import { CommonModule } from '@angular/common';\n-        import { FormsModule } from '@angular/forms';\n-\n-        export interface Person {\n-          name: Name;\n-          address: Address;\n-        }\n-\n-        export interface Name {\n-          first: string;\n-          middle: string;\n-          last: string;\n-        }\n-\n-        export interface Address {\n-          street: string;\n-          city: string;\n-          state: string;\n-          zip: string;\n-        }\n-\n-        @Component({\n-          selector: 'my-app',\n-          templateUrl: './app.component.html'\n-        })\n-        export class AppComponent {\n-          person: Person;\n-          people: Person[];\n-          maybe_person?: Person;\n-          promised_person: Promise<Person>;\n-          promised_people: Promise<Person[]>;\n-          private private_person: Person;\n-          private private_people: Person[];\n-          e?: number;\n-\n-          getPerson(): Person { return this.person; }\n-          click() {}\n-        }\n-\n-        @NgModule({\n-          imports: [CommonModule, FormsModule],\n-          declarations: [AppComponent]\n-        })\n-        export class AppModule {}\n-      `\n-    }\n-  }\n-};"
        },
        {
            "sha": "b4a6269d09c5620cc56da552e6bf14635df4a287",
            "filename": "packages/language-service/test/global_symbols_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 28,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fglobal_symbols_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fglobal_symbols_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fglobal_symbols_spec.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,28 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as ts from 'typescript/lib/tsserverlibrary';\n-\n-import {createGlobalSymbolTable, EMPTY_SYMBOL_TABLE} from '../src/global_symbols';\n-import {getSymbolQuery} from '../src/typescript_symbols';\n-\n-import {MockTypescriptHost} from './test_utils';\n-\n-describe('GlobalSymbolTable', () => {\n-  const mockHost = new MockTypescriptHost([]);\n-  const tsLS = ts.createLanguageService(mockHost);\n-\n-  it(`contains $any()`, () => {\n-    const program = tsLS.getProgram()!;\n-    const typeChecker = program.getTypeChecker();\n-    const source = ts.createSourceFile('foo.ts', '', ts.ScriptTarget.ES2015);\n-    const query = getSymbolQuery(program, typeChecker, source, () => EMPTY_SYMBOL_TABLE);\n-    const table = createGlobalSymbolTable(query);\n-    expect(table.has('$any')).toBe(true);\n-  });\n-});"
        },
        {
            "sha": "1d9d87c32bb49a5a60d226f9501e455d3f57161a",
            "filename": "packages/language-service/test/hover_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 357,
            "changes": 357,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fhover_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fhover_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fhover_spec.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,357 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {createLanguageService} from '../src/language_service';\n-import {TypeScriptServiceHost} from '../src/typescript_host';\n-\n-import {MockTypescriptHost} from './test_utils';\n-\n-const TEST_TEMPLATE = '/app/test.ng';\n-const PARSING_CASES = '/app/parsing-cases.ts';\n-\n-describe('hover', () => {\n-  const mockHost = new MockTypescriptHost(['/app/main.ts']);\n-  const tsLS = ts.createLanguageService(mockHost);\n-  const ngLSHost = new TypeScriptServiceHost(mockHost, tsLS);\n-  const ngLS = createLanguageService(ngLSHost);\n-\n-  beforeEach(() => {\n-    mockHost.reset();\n-  });\n-\n-  describe('location of hover', () => {\n-    it('should find members in a text interpolation', () => {\n-      mockHost.override(TEST_TEMPLATE, '<div>{{title}}</div>');\n-      const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'title');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeTruthy();\n-      const {textSpan, displayParts} = quickInfo!;\n-      expect(textSpan).toEqual(marker);\n-      expect(toText(displayParts)).toBe('(property) TemplateReference.title: string');\n-    });\n-\n-    it('should find members in an attribute interpolation', () => {\n-      mockHost.override(TEST_TEMPLATE, `<div string-model model=\"{{title}}\"></div>`);\n-      const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'title');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeTruthy();\n-      const {textSpan, displayParts} = quickInfo!;\n-      expect(textSpan).toEqual(marker);\n-      expect(toText(displayParts)).toBe('(property) TemplateReference.title: string');\n-    });\n-\n-    it('should find members in a property binding', () => {\n-      mockHost.override(TEST_TEMPLATE, `<test-comp [tcName]=\"title\"></test-comp>`);\n-      const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'title');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeTruthy();\n-      const {textSpan, displayParts} = quickInfo!;\n-      expect(textSpan).toEqual(marker);\n-      expect(toText(displayParts)).toBe('(property) TemplateReference.title: string');\n-    });\n-\n-    it('should find members in an event binding', () => {\n-      mockHost.override(TEST_TEMPLATE, `<test-comp (test)=\"title=$event\"></test-comp>`);\n-      const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'title');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeTruthy();\n-      const {textSpan, displayParts} = quickInfo!;\n-      expect(textSpan).toEqual(marker);\n-      expect(toText(displayParts)).toBe('(property) TemplateReference.title: string');\n-    });\n-\n-    it('should find members in a two-way binding', () => {\n-      mockHost.override(TEST_TEMPLATE, `<input [(ngModel)]=\"title\" />`);\n-      const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'title');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeTruthy();\n-      const {textSpan, displayParts} = quickInfo!;\n-      expect(textSpan).toEqual(marker);\n-      expect(toText(displayParts)).toBe('(property) TemplateReference.title: string');\n-    });\n-\n-    it('should find members in a structural directive', () => {\n-      mockHost.override(TEST_TEMPLATE, `<div *ngIf=\"anyValue\"></div>`);\n-      const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'anyValue');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeTruthy();\n-      const {textSpan, displayParts} = quickInfo!;\n-      expect(textSpan).toEqual(marker);\n-      expect(toText(displayParts)).toBe('(property) TemplateReference.anyValue: any');\n-    });\n-  });\n-\n-  describe('hovering on expression nodes', () => {\n-    it('should provide documentation', () => {\n-      mockHost.override(TEST_TEMPLATE, `<div>{{~{cursor}title}}</div>`);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeDefined();\n-      const documentation = toText(quickInfo!.documentation);\n-      expect(documentation).toBe('This is the title of the `TemplateReference` Component.');\n-    });\n-\n-    describe('property reads', () => {\n-      it('should work for class members', () => {\n-        mockHost.override(TEST_TEMPLATE, `<div>{{title}}</div>`);\n-        const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'title');\n-        const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-        expect(quickInfo).toBeTruthy();\n-        const {textSpan, displayParts} = quickInfo!;\n-        expect(textSpan).toEqual(marker);\n-        expect(toText(displayParts)).toBe('(property) TemplateReference.title: string');\n-      });\n-\n-      it('should work for accessed property reads', () => {\n-        mockHost.override(TEST_TEMPLATE, `<div>{{title.length}}</div>`);\n-        const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'length');\n-        const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-        expect(quickInfo).toBeTruthy();\n-        const {textSpan, displayParts} = quickInfo!;\n-        expect(textSpan).toEqual(marker);\n-        expect(toText(displayParts)).toBe('(property) String.length: number');\n-      });\n-\n-      it('should work for properties in writes', () => {\n-        mockHost.override(TEST_TEMPLATE, `<div (click)=\"title = 't'\"></div>`);\n-        const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'title');\n-        const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-        expect(quickInfo).toBeTruthy();\n-        const {textSpan, displayParts} = quickInfo!;\n-        expect(textSpan).toEqual(marker);\n-        expect(toText(displayParts)).toBe('(property) TemplateReference.title: string');\n-      });\n-\n-      it('should work for accessed properties in writes', () => {\n-        mockHost.override(TEST_TEMPLATE, `<div (click)=\"hero.id = 2\"></div>`);\n-        const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'id');\n-        const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-        expect(quickInfo).toBeTruthy();\n-        const {textSpan, displayParts} = quickInfo!;\n-        expect(textSpan).toEqual(marker);\n-        expect(toText(displayParts)).toBe('(property) Hero.id: number');\n-      });\n-\n-      it('should work for array members', () => {\n-        mockHost.override(TEST_TEMPLATE, `<div *ngFor=\"let hero of heroes\">{{hero}}</div>`);\n-        const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'hero');\n-        const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-        expect(quickInfo).toBeTruthy();\n-        const {textSpan, displayParts} = quickInfo!;\n-        expect(textSpan).toEqual(marker);\n-        expect(toText(displayParts)).toBe('(variable) hero: Hero');\n-      });\n-\n-      it('should work for ReadonlyArray members (#36191)', () => {\n-        mockHost.override(\n-            TEST_TEMPLATE, `<div *ngFor=\"let hero of readonlyHeroes\">{{hero}}</div>`);\n-        const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'hero');\n-        const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-        expect(quickInfo).toBeTruthy();\n-        const {textSpan, displayParts} = quickInfo!;\n-        expect(textSpan).toEqual(marker);\n-        expect(toText(displayParts)).toBe('(variable) hero: Readonly<Hero>');\n-      });\n-\n-      it('should work for const array members (#36191)', () => {\n-        mockHost.override(TEST_TEMPLATE, `<div *ngFor=\"let name of constNames\">{{name}}</div>`);\n-        const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'name');\n-        const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-        expect(quickInfo).toBeTruthy();\n-        const {textSpan, displayParts} = quickInfo!;\n-        expect(textSpan).toEqual(marker);\n-        expect(toText(displayParts)).toBe('(variable) name: { readonly name: \"name\"; }');\n-      });\n-    });\n-\n-    it('should work for method calls', () => {\n-      mockHost.override(TEST_TEMPLATE, `<div (click)=\"myClick($event)\"></div>`);\n-      const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'myClick');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeTruthy();\n-      const {textSpan, displayParts} = quickInfo!;\n-      expect(textSpan).toEqual(marker);\n-      expect(toText(displayParts)).toBe('(method) TemplateReference.myClick: (event: any) => void');\n-    });\n-\n-    it('should work for structural directive inputs', () => {\n-      mockHost.override(TEST_TEMPLATE, `<div *ngFor=\"let item of heroes; trackBy: test;\"></div>`);\n-      const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'trackBy');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeTruthy();\n-      const {textSpan, displayParts} = quickInfo!;\n-      expect(textSpan).toEqual(marker);\n-      expect(toText(displayParts)).toBe('(method) NgForOf<T, U>.ngForTrackBy: TrackByFunction<T>');\n-    });\n-\n-    it('should work for members in structural directives', () => {\n-      mockHost.override(TEST_TEMPLATE, `<div *ngFor=\"let item of heroes; trackBy: test;\"></div>`);\n-      const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'heroes');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeTruthy();\n-      const {textSpan, displayParts} = quickInfo!;\n-      expect(textSpan).toEqual(marker);\n-      expect(toText(displayParts)).toBe('(property) TemplateReference.heroes: Hero[]');\n-    });\n-\n-    it('should work for pipes', () => {\n-      mockHost.override(TEST_TEMPLATE, `\n-        <p>The hero's birthday is {{birthday | date: \"MM/dd/yy\"}}</p>`);\n-      const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'date');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeTruthy();\n-      const {textSpan, displayParts} = quickInfo!;\n-      expect(textSpan).toEqual(marker);\n-      expect(toText(displayParts))\n-          .toBe(\n-              '(pipe) date: { (value: string | number | Date, format?: string | undefined, timezone?: string | undefined, locale?: string | undefined): string | null; (value: null | undefined, format?: string | undefined, timezone?: string | undefined, locale?: string | undefined): null; (value: string | ... 3 more ... | undefined, format?: st...');\n-    });\n-\n-    it('should work for the $any() cast function', () => {\n-      const content = mockHost.override(TEST_TEMPLATE, '<div>{{$any(title)}}</div>');\n-      const position = content.indexOf('$any');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, position);\n-      expect(quickInfo).toBeDefined();\n-      const {textSpan, displayParts} = quickInfo!;\n-      expect(textSpan).toEqual({\n-        start: position,\n-        length: '$any'.length,\n-      });\n-      expect(toText(displayParts)).toBe('(method) $any: $any');\n-    });\n-  });\n-\n-  describe('hovering on template nodes', () => {\n-    it('should provide documentation', () => {\n-      mockHost.override(TEST_TEMPLATE, `<~{cursor}test-comp></test-comp>`);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeDefined();\n-      const documentation = toText(quickInfo!.documentation);\n-      expect(documentation).toBe('This Component provides the `test-comp` selector.');\n-    });\n-\n-    it('should work for components', () => {\n-      mockHost.override(TEST_TEMPLATE, '<~{cursor}test-comp></test-comp>');\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeDefined();\n-      const {displayParts, documentation} = quickInfo!;\n-      expect(toText(displayParts))\n-          .toBe('(component) AppModule.TestComponent: typeof TestComponent');\n-      expect(toText(documentation)).toBe('This Component provides the `test-comp` selector.');\n-    });\n-\n-    it('should work for directives', () => {\n-      const content = mockHost.override(TEST_TEMPLATE, `<div string-model~{cursor}></div>`);\n-      const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeDefined();\n-      const {displayParts, textSpan} = quickInfo!;\n-      expect(toText(displayParts)).toBe('(directive) AppModule.StringModel: typeof StringModel');\n-      expect(content.substring(textSpan.start, textSpan.start + textSpan.length))\n-          .toBe('string-model');\n-    });\n-\n-    it('should work for event providers', () => {\n-      mockHost.override(TEST_TEMPLATE, `<test-comp (test)=\"myClick($event)\"></div>`);\n-      const marker = mockHost.getDefinitionMarkerFor(TEST_TEMPLATE, 'test');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeTruthy();\n-      const {textSpan, displayParts} = quickInfo!;\n-      expect(textSpan).toEqual(marker);\n-      expect(toText(displayParts)).toBe('(event) TestComponent.testEvent: EventEmitter<any>');\n-    });\n-\n-    it('should work for input providers', () => {\n-      mockHost.override(TEST_TEMPLATE, `<test-comp [tcName]=\"name\"></div>`);\n-      const marker = mockHost.getDefinitionMarkerFor(TEST_TEMPLATE, 'tcName');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeTruthy();\n-      const {textSpan, displayParts} = quickInfo!;\n-      expect(textSpan).toEqual(marker);\n-      expect(toText(displayParts)).toBe('(property) TestComponent.name: string');\n-    });\n-\n-    it('should work for two-way binding providers', () => {\n-      mockHost.override(\n-          TEST_TEMPLATE, `<test-comp string-model [(model)]=\"title\"></test-comp>`);\n-      const marker = mockHost.getDefinitionMarkerFor(TEST_TEMPLATE, 'model');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeTruthy();\n-      const {textSpan, displayParts} = quickInfo!;\n-      expect(textSpan).toEqual(marker);\n-      expect(toText(displayParts)).toBe('(property) StringModel.model: string');\n-    });\n-\n-    it('should work for structural directives', () => {\n-      mockHost.override(TEST_TEMPLATE, `<div *ngFor=\"let item of heroes\"></div>`);\n-      const marker = mockHost.getDefinitionMarkerFor(TEST_TEMPLATE, 'ngFor');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeTruthy();\n-      const {textSpan, displayParts} = quickInfo!;\n-      expect(textSpan).toEqual(marker);\n-      expect(toText(displayParts)).toBe('(directive) NgForOf: typeof NgForOf');\n-    });\n-  });\n-\n-  describe('hovering on TypeScript nodes', () => {\n-    it('should work for component TypeScript declarations', () => {\n-      const content = mockHost.readFile(PARSING_CASES)!;\n-      const position = content.indexOf('TemplateReference');\n-      expect(position).toBeGreaterThan(0);\n-      const quickInfo = ngLS.getQuickInfoAtPosition(PARSING_CASES, position);\n-      expect(quickInfo).toBeTruthy();\n-      const {textSpan, displayParts} = quickInfo!;\n-      expect(textSpan).toEqual({\n-        start: position,\n-        length: 'TemplateReference'.length,\n-      });\n-      expect(toText(displayParts)).toBe('(component) AppModule.TemplateReference: class');\n-    });\n-\n-    it('should work for directive TypeScript declarations', () => {\n-      const content = mockHost.readFile(PARSING_CASES)!;\n-      const position = content.indexOf('StringModel');\n-      expect(position).toBeGreaterThan(0);\n-      const quickInfo = ngLS.getQuickInfoAtPosition(PARSING_CASES, position);\n-      expect(quickInfo).toBeTruthy();\n-      const {textSpan, displayParts} = quickInfo!;\n-      expect(textSpan).toEqual({\n-        start: position,\n-        length: 'StringModel'.length,\n-      });\n-      expect(toText(displayParts)).toBe('(directive) AppModule.StringModel: class');\n-    });\n-  });\n-\n-  describe('non-goals', () => {\n-    it('should ignore reference declarations', () => {\n-      mockHost.override(TEST_TEMPLATE, `<div #chart></div>`);\n-      const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'chart');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeUndefined();\n-    });\n-\n-    it('should not expand i18n templates', () => {\n-      mockHost.override(TEST_TEMPLATE, `<div i18n=\"@@el\">{{title}}</div>`);\n-      const marker = mockHost.getReferenceMarkerFor(TEST_TEMPLATE, 'title');\n-      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, marker.start);\n-      expect(quickInfo).toBeTruthy();\n-      const {textSpan, displayParts} = quickInfo!;\n-      expect(textSpan).toEqual(marker);\n-      expect(toText(displayParts)).toBe('(property) TemplateReference.title: string');\n-    });\n-  });\n-});\n-\n-function toText(displayParts?: ts.SymbolDisplayPart[]): string {\n-  return (displayParts || []).map(p => p.text).join('');\n-}"
        },
        {
            "sha": "da7550c50fe48da911e701ece63e0ca7a5d670b1",
            "filename": "packages/language-service/test/html_info_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 51,
            "changes": 51,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fhtml_info_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fhtml_info_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fhtml_info_spec.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,51 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {DomElementSchemaRegistry} from '@angular/compiler';\n-import {SchemaInformation} from '../src/html_info';\n-\n-describe('html_info', () => {\n-  const domRegistry = new DomElementSchemaRegistry();\n-\n-  it('should have the same elements as the dom registry', () => {\n-    // If this test fails, replace the SCHEMA constant in html_info with the one\n-    // from dom_element_schema_registry and also verify the code to interpret\n-    // the schema is the same.\n-    const domElements = domRegistry.allKnownElementNames();\n-    const infoElements = SchemaInformation.instance.allKnownElements();\n-    const uniqueToDom = uniqueElements(infoElements, domElements);\n-    const uniqueToInfo = uniqueElements(domElements, infoElements);\n-    expect(uniqueToDom).toEqual([]);\n-    expect(uniqueToInfo).toEqual([]);\n-  });\n-\n-  it('should have at least a sub-set of properties', () => {\n-    const elements = SchemaInformation.instance.allKnownElements();\n-    for (const element of elements) {\n-      for (const prop of SchemaInformation.instance.propertiesOf(element)) {\n-        expect(domRegistry.hasProperty(element, prop, [])).toBeTrue();\n-      }\n-    }\n-  });\n-});\n-\n-function uniqueElements<T>(a: T[], b: T[]): T[] {\n-  const s = new Set<T>();\n-  for (const aItem of a) {\n-    s.add(aItem);\n-  }\n-  const result: T[] = [];\n-  const reported = new Set<T>();\n-  for (const bItem of b) {\n-    if (!s.has(bItem) && !reported.has(bItem)) {\n-      reported.add(bItem);\n-      result.push(bItem);\n-    }\n-  }\n-  return result;\n-}"
        },
        {
            "sha": "171bd4329e8893ad56b2f5aca07ce3b0ac59149a",
            "filename": "packages/language-service/test/language_service_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 49,
            "changes": 49,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Flanguage_service_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Flanguage_service_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Flanguage_service_spec.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,49 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {createLanguageService} from '../src/language_service';\n-import {TypeScriptServiceHost} from '../src/typescript_host';\n-\n-import {MockTypescriptHost} from './test_utils';\n-\n-describe('service without angular', () => {\n-  const mockHost = new MockTypescriptHost(['/app/main.ts']);\n-  const service = ts.createLanguageService(mockHost);\n-  const ngHost = new TypeScriptServiceHost(mockHost, service);\n-  const ngService = createLanguageService(ngHost);\n-  const TEST_TEMPLATE = '/app/test.ng';\n-  mockHost.override(TEST_TEMPLATE, '<h1> ~{cursor} </h1>');\n-  const position = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor').start;\n-\n-  beforeEach(() => {\n-    mockHost.reset();\n-  });\n-\n-  it('should not crash a get diagnostics', () => {\n-    expect(() => ngService.getSemanticDiagnostics(TEST_TEMPLATE)).not.toThrow();\n-  });\n-\n-  it('should not crash a completion', () => {\n-    expect(() => ngService.getCompletionsAtPosition(TEST_TEMPLATE, position)).not.toThrow();\n-  });\n-\n-  it('should not crash a get definition', () => {\n-    expect(() => ngService.getDefinitionAndBoundSpan(TEST_TEMPLATE, position)).not.toThrow();\n-  });\n-\n-  it('should not crash a hover', () => {\n-    expect(() => ngService.getQuickInfoAtPosition(TEST_TEMPLATE, position)).not.toThrow();\n-  });\n-\n-  it('should not crash with an incomplete class', () => {\n-    mockHost.addCode('\\nexport class');\n-    expect(() => ngHost.getAnalyzedModules()).not.toThrow();\n-  });\n-});"
        },
        {
            "sha": "4ea76eb4e21cc1b03fc0f1cbfe341a97956da10f",
            "filename": "packages/language-service/test/mocks.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 290,
            "changes": 290,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fmocks.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fmocks.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fmocks.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,290 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {analyzeNgModules, AotSummaryResolver, CompileMetadataResolver, CompilerConfig, createOfflineCompileUrlResolver, DirectiveNormalizer, DirectiveResolver, DomElementSchemaRegistry, HtmlParser, I18NHtmlParser, JitSummaryResolver, Lexer, NgAnalyzedModules, NgModuleResolver, Parser, ParseTreeResult, PipeResolver, ResourceLoader, StaticReflector, StaticSymbol, StaticSymbolCache, StaticSymbolResolver, StaticSymbolResolverHost, TemplateParser} from '@angular/compiler';\n-import {Directory, MockAotContext} from '@angular/compiler-cli/test/mocks';\n-import {setup} from '@angular/compiler-cli/test/test_support';\n-import {ViewEncapsulation, Console as Console} from '@angular/core';\n-import * as fs from 'fs';\n-import * as path from 'path';\n-import ts from 'typescript';\n-\n-import {DiagnosticTemplateInfo} from '../src/types';\n-import {getClassMembers, getPipesTable, getSymbolQuery} from '../src/typescript_symbols';\n-\n-const realFiles = new Map<string, string>();\n-\n-export class MockLanguageServiceHost implements ts.LanguageServiceHost {\n-  private options: ts.CompilerOptions;\n-  private context: MockAotContext;\n-  private assumedExist = new Set<string>();\n-\n-  constructor(private scripts: string[], files: Directory, currentDirectory: string = '/') {\n-    const support = setup();\n-\n-    this.options = {\n-      target: ts.ScriptTarget.ES5,\n-      module: ts.ModuleKind.CommonJS,\n-      moduleResolution: ts.ModuleResolutionKind.NodeJs,\n-      emitDecoratorMetadata: true,\n-      experimentalDecorators: true,\n-      removeComments: false,\n-      noImplicitAny: false,\n-      skipLibCheck: true,\n-      skipDefaultLibCheck: true,\n-      strictNullChecks: true,\n-      baseUrl: currentDirectory,\n-      lib: ['lib.es2015.d.ts', 'lib.dom.d.ts'],\n-      paths: {'@angular/*': [path.join(support.basePath, 'node_modules/@angular/*')]}\n-    };\n-    this.context = new MockAotContext(currentDirectory, files);\n-  }\n-\n-  getCompilationSettings(): ts.CompilerOptions {\n-    return this.options;\n-  }\n-\n-  getScriptFileNames(): string[] {\n-    return this.scripts;\n-  }\n-\n-  getScriptVersion(fileName: string): string {\n-    return '0';\n-  }\n-\n-  getScriptSnapshot(fileName: string): ts.IScriptSnapshot|undefined {\n-    const content = this.internalReadFile(fileName);\n-    if (content) {\n-      return ts.ScriptSnapshot.fromString(content);\n-    }\n-  }\n-\n-  getCurrentDirectory(): string {\n-    return this.context.currentDirectory;\n-  }\n-\n-  getDefaultLibFileName(options: ts.CompilerOptions): string {\n-    return 'lib.d.ts';\n-  }\n-\n-  readFile(fileName: string): string {\n-    return this.internalReadFile(fileName) as string;\n-  }\n-\n-  readResource(fileName: string): Promise<string> {\n-    return Promise.resolve('');\n-  }\n-\n-  assumeFileExists(fileName: string): void {\n-    this.assumedExist.add(fileName);\n-  }\n-\n-  fileExists(fileName: string): boolean {\n-    return this.assumedExist.has(fileName) || this.internalReadFile(fileName) != null;\n-  }\n-\n-  private internalReadFile(fileName: string): string|undefined {\n-    let basename = path.basename(fileName);\n-    if (/^lib.*\\.d\\.ts$/.test(basename)) {\n-      let libPath = path.posix.dirname(ts.getDefaultLibFilePath(this.getCompilationSettings()));\n-      fileName = path.posix.join(libPath, basename);\n-    }\n-    if (fileName.startsWith('app/')) {\n-      fileName = path.posix.join(this.context.currentDirectory, fileName);\n-    }\n-    if (this.context.fileExists(fileName)) {\n-      return this.context.readFile(fileName);\n-    }\n-    if (realFiles.has(fileName)) {\n-      return realFiles.get(fileName);\n-    }\n-    if (fs.existsSync(fileName)) {\n-      const content = fs.readFileSync(fileName, 'utf8');\n-      realFiles.set(fileName, content);\n-      return content;\n-    }\n-    return undefined;\n-  }\n-}\n-\n-const staticSymbolCache = new StaticSymbolCache();\n-const summaryResolver = new AotSummaryResolver(\n-    {\n-      loadSummary(filePath: string) {\n-        return null;\n-      },\n-      isSourceFile(sourceFilePath: string) {\n-        return true;\n-      },\n-      toSummaryFileName(sourceFilePath: string) {\n-        return sourceFilePath;\n-      },\n-      fromSummaryFileName(filePath: string): string {\n-        return filePath;\n-      },\n-    },\n-    staticSymbolCache);\n-\n-export class DiagnosticContext {\n-  private _analyzedModules: NgAnalyzedModules|undefined;\n-  private _staticSymbolResolver: StaticSymbolResolver|undefined;\n-  private _reflector: StaticReflector|undefined;\n-  private _errors: {e: any, path?: string}[] = [];\n-  private _resolver: CompileMetadataResolver|undefined;\n-\n-  constructor(\n-      public service: ts.LanguageService, public program: ts.Program,\n-      public checker: ts.TypeChecker, public host: StaticSymbolResolverHost) {}\n-\n-  private collectError(e: any, path?: string) {\n-    this._errors.push({e, path});\n-  }\n-\n-  private get staticSymbolResolver(): StaticSymbolResolver {\n-    let result = this._staticSymbolResolver;\n-    if (!result) {\n-      result = this._staticSymbolResolver = new StaticSymbolResolver(\n-          this.host, staticSymbolCache, summaryResolver,\n-          (e, filePath) => this.collectError(e, filePath));\n-    }\n-    return result;\n-  }\n-\n-  get reflector(): StaticReflector {\n-    if (!this._reflector) {\n-      const ssr = this.staticSymbolResolver;\n-      const result = this._reflector = new StaticReflector(\n-          summaryResolver, ssr, [], [], (e, filePath) => this.collectError(e, filePath!));\n-      this._reflector = result;\n-      return result;\n-    }\n-    return this._reflector;\n-  }\n-\n-  get resolver(): CompileMetadataResolver {\n-    let result = this._resolver;\n-    if (!result) {\n-      const moduleResolver = new NgModuleResolver(this.reflector);\n-      const directiveResolver = new DirectiveResolver(this.reflector);\n-      const pipeResolver = new PipeResolver(this.reflector);\n-      const elementSchemaRegistry = new DomElementSchemaRegistry();\n-      const resourceLoader = new class extends ResourceLoader {\n-        override get(url: string): Promise<string> {\n-          return Promise.resolve('');\n-        }\n-      };\n-      const urlResolver = createOfflineCompileUrlResolver();\n-      const htmlParser = new class extends HtmlParser {\n-        override parse(): ParseTreeResult {\n-          return new ParseTreeResult([], []);\n-        }\n-      };\n-\n-      // This tracks the CompileConfig in codegen.ts. Currently these options\n-      // are hard-coded.\n-      const config =\n-          new CompilerConfig({defaultEncapsulation: ViewEncapsulation.Emulated, useJit: false});\n-      const directiveNormalizer =\n-          new DirectiveNormalizer(resourceLoader, urlResolver, htmlParser, config);\n-\n-      result = this._resolver = new CompileMetadataResolver(\n-          config, htmlParser, moduleResolver, directiveResolver, pipeResolver,\n-          new JitSummaryResolver(), elementSchemaRegistry, directiveNormalizer, new Console(),\n-          staticSymbolCache, this.reflector,\n-          (error, type) => this.collectError(error, type && type.filePath));\n-    }\n-    return result;\n-  }\n-\n-  get analyzedModules(): NgAnalyzedModules {\n-    let analyzedModules = this._analyzedModules;\n-    if (!analyzedModules) {\n-      const analyzeHost = {\n-        isSourceFile(filePath: string) {\n-          return true;\n-        }\n-      };\n-      const programFiles = this.program.getSourceFiles().map(sf => sf.fileName);\n-      analyzedModules = this._analyzedModules =\n-          analyzeNgModules(programFiles, analyzeHost, this.staticSymbolResolver, this.resolver);\n-    }\n-    return analyzedModules;\n-  }\n-\n-  getStaticSymbol(path: string, name: string): StaticSymbol {\n-    return staticSymbolCache.get(path, name);\n-  }\n-}\n-\n-function compileTemplate(context: DiagnosticContext, type: StaticSymbol, template: string) {\n-  // Compiler the template string.\n-  const resolvedMetadata = context.resolver.getNonNormalizedDirectiveMetadata(type);\n-  const metadata = resolvedMetadata && resolvedMetadata.metadata;\n-  if (metadata) {\n-    const rawHtmlParser = new HtmlParser();\n-    const htmlParser = new I18NHtmlParser(rawHtmlParser);\n-    const expressionParser = new Parser(new Lexer());\n-    const config = new CompilerConfig();\n-    const parser = new TemplateParser(\n-        config, context.reflector, expressionParser, new DomElementSchemaRegistry(), htmlParser,\n-        null!, []);\n-    const htmlResult = htmlParser.parse(template, '', {tokenizeExpansionForms: true});\n-    const analyzedModules = context.analyzedModules;\n-    // let errors: Diagnostic[]|undefined = undefined;\n-    let ngModule = analyzedModules.ngModuleByPipeOrDirective.get(type);\n-    if (ngModule) {\n-      const resolvedDirectives = ngModule.transitiveModule.directives.map(\n-          d => context.resolver.getNonNormalizedDirectiveMetadata(d.reference));\n-      const directives = removeMissing(resolvedDirectives).map(d => d.metadata.toSummary());\n-      const pipes = ngModule.transitiveModule.pipes.map(\n-          p => context.resolver.getOrLoadPipeMetadata(p.reference).toSummary());\n-      const schemas = ngModule.schemas;\n-      const parseResult = parser.tryParseHtml(htmlResult, metadata, directives, pipes, schemas);\n-      return {\n-        htmlAst: htmlResult.rootNodes,\n-        templateAst: parseResult.templateAst,\n-        directive: metadata,\n-        directives,\n-        pipes,\n-        parseErrors: parseResult.errors,\n-        expressionParser\n-      };\n-    }\n-  }\n-}\n-\n-export function getDiagnosticTemplateInfo(\n-    context: DiagnosticContext, type: StaticSymbol, templateFile: string,\n-    template: string): DiagnosticTemplateInfo|undefined {\n-  const compiledTemplate = compileTemplate(context, type, template);\n-  if (compiledTemplate && compiledTemplate.templateAst) {\n-    const members = getClassMembers(context.program, context.checker, type);\n-    if (members) {\n-      const sourceFile = context.program.getSourceFile(type.filePath);\n-      if (sourceFile) {\n-        const query = getSymbolQuery(\n-            context.program, context.checker, sourceFile,\n-            () => getPipesTable(\n-                sourceFile, context.program, context.checker, compiledTemplate.pipes));\n-        return {\n-          fileName: templateFile,\n-          offset: 0,\n-          query,\n-          members,\n-          htmlAst: compiledTemplate.htmlAst,\n-          templateAst: compiledTemplate.templateAst,\n-          source: sourceFile.text,\n-        };\n-      }\n-    }\n-  }\n-}\n-\n-function removeMissing<T>(values: (T|null|undefined)[]): T[] {\n-  return values.filter(e => !!e) as T[];\n-}"
        },
        {
            "sha": "8d43c3190d1b8e707640d30c94d0eb20d11396b6",
            "filename": "packages/language-service/test/references_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 78,
            "changes": 78,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Freferences_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Freferences_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Freferences_spec.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,78 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {createLanguageService} from '../src/language_service';\n-import {TypeScriptServiceHost} from '../src/typescript_host';\n-\n-import {MockTypescriptHost} from './test_utils';\n-\n-const APP_COMPONENT = '/app/app.component.ts';\n-const TEST_TEMPLATE = '/app/test.ng';\n-\n-describe('references', () => {\n-  const mockHost = new MockTypescriptHost(['/app/main.ts']);\n-  const tsLS = ts.createLanguageService(mockHost);\n-  const ngHost = new TypeScriptServiceHost(mockHost, tsLS);\n-  const ngLS = createLanguageService(ngHost);\n-\n-  beforeEach(() => {\n-    mockHost.reset();\n-  });\n-\n-  for (const templateStrategy of ['inline', 'external'] as const) {\n-    describe(`template: ${templateStrategy}`, () => {\n-      describe('component members', () => {\n-        it('should get TS references for a member in template', () => {\n-          const fileName = overrideTemplate('{{title}}');\n-          const marker = mockHost.getReferenceMarkerFor(fileName, 'title');\n-          const references = ngLS.getReferencesAtPosition(fileName, marker.start)!;\n-\n-          expect(references).toBeDefined();\n-          expect(references.length).toBe(2);\n-\n-          for (let i = 0; i < references.length; ++i) {\n-            // The first reference is declared as a class member.\n-            // The second is in `setTitle`.\n-            const ref = references[i];\n-            expect(getSource(ref)).toBe('title');\n-            if (i == 0) {\n-              // The first reference is the member declaration, so it should\n-              // have a context span pointing to the whole declaration.\n-              expect(getSource(ref, 'contextSpan')).toBe('title = \\'Tour of Heroes\\';');\n-            }\n-          }\n-        });\n-      });\n-    });\n-\n-    // TODO: override parsing-cases#TemplateReference for inline templates.\n-    const overrideTemplate = (template: string): string => {\n-      if (templateStrategy === 'inline') {\n-        mockHost.overrideInlineTemplate(APP_COMPONENT, template);\n-        return APP_COMPONENT;\n-      } else {\n-        mockHost.override(TEST_TEMPLATE, template);\n-        return TEST_TEMPLATE;\n-      }\n-    };\n-  }\n-\n-  /**\n-   * Gets the source code of a reference entry. By default the reference\n-   * `textSpan` is checked, but this can be overridden by specifying `spanKind`.\n-   */\n-  function getSource(\n-      reference: ts.ReferenceEntry, spanKind: 'textSpan'|'contextSpan' = 'textSpan'): string {\n-    const span = reference[spanKind]!;\n-    const fileName = reference.fileName;\n-    const content = mockHost.readFile(fileName)!;\n-    return content.substring(span.start, span.start + span.length);\n-  }\n-});"
        },
        {
            "sha": "79850af500bf7fb05e307a4a15c305483616a804",
            "filename": "packages/language-service/test/reflector_host_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 80,
            "changes": 80,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Freflector_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Freflector_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Freflector_host_spec.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,80 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import path from 'path';\n-import ts from 'typescript';\n-\n-import {ReflectorHost} from '../src/reflector_host';\n-import {TypeScriptServiceHost} from '../src/typescript_host';\n-\n-import {MockTypescriptHost} from './test_utils';\n-\n-describe('reflector_host_spec', () => {\n-  // Regression #21811\n-  it('should be able to find angular under windows', () => {\n-    const originalJoin = path.join;\n-    const originalPosixJoin = path.posix.join;\n-    const mockHost =\n-        new MockTypescriptHost(['/app/main.ts', '/app/parsing-cases.ts'], 'node_modules', {\n-          ...path,\n-          join: (...args: string[]) => originalJoin.apply(path, args),\n-          posix: {...path.posix, join: (...args: string[]) => originalPosixJoin.apply(path, args)}\n-        });\n-    const reflectorHost = new ReflectorHost(() => undefined as any, mockHost);\n-\n-    if (process.platform !== 'win32') {\n-      // If we call this in Windows it will cause a 'Maximum call stack size exceeded error'\n-      // Because we are spying on the same function that we are call faking\n-      spyOn(path, 'join').and.callFake((...args: string[]) => {\n-        return path.win32.join(...args);\n-      });\n-    }\n-\n-    const result = reflectorHost.moduleNameToFileName('@angular/core');\n-    expect(result).not.toBeNull('could not find @angular/core using path.win32');\n-  });\n-\n-  it('should use module resolution cache', () => {\n-    const mockHost = new MockTypescriptHost(['/app/main.ts']);\n-    // TypeScript relies on `ModuleResolutionHost.fileExists()` to perform\n-    // module resolution, so spy on this method to determine how many times\n-    // it's called.\n-    const spy = spyOn(mockHost, 'fileExists').and.callThrough();\n-\n-    const tsLS = ts.createLanguageService(mockHost);\n-\n-    // First count is zero due to lazy instantiation of the StaticReflector\n-    // and MetadataResolver.\n-    const ngLSHost = new TypeScriptServiceHost(mockHost, tsLS);\n-    const firstCount = spy.calls.count();\n-    expect(firstCount).toBe(0);\n-    spy.calls.reset();\n-\n-    // Second count is due to resolution of the Tour of Heroes (toh) project.\n-    // This resolves all Angular directives in the project.\n-    ngLSHost.getAnalyzedModules();\n-    const secondCount = spy.calls.count();\n-    expect(secondCount).toBeGreaterThan(400);\n-    expect(secondCount).toBeLessThan(500);\n-    spy.calls.reset();\n-\n-    // Third count is due to recompution after the program changes.\n-    mockHost.addCode('');  // this will mark project as dirty\n-    ngLSHost.getAnalyzedModules();\n-    const thirdCount = spy.calls.count();\n-    expect(thirdCount).toBeGreaterThan(0);\n-    expect(thirdCount).toBeLessThan(10);\n-\n-    // Summary\n-    // |               | First Count | Second Count | Third Count |\n-    // |---------------|-------------|--------------|-------------|\n-    // | Without Cache | 2581        | 6291         | 257         |\n-    // | With Cache    | 26          | 550          | 84          |\n-    // | Improvement   | ~100x       | ~10x         | ~3x         |\n-  });\n-});"
        },
        {
            "sha": "f18d0ab6fb26b8d47aaa4586bf7cd42bffb3e701",
            "filename": "packages/language-service/test/test_utils.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 477,
            "changes": 477,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Ftest_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Ftest_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Ftest_utils.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,477 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompileNgModuleMetadata, NgAnalyzedModules} from '@angular/compiler';\n-import {setup} from '@angular/compiler-cli/test/test_support';\n-import * as fs from 'fs';\n-import * as path from 'path';\n-import ts from 'typescript';\n-\n-import {Span} from '../src/types';\n-\n-const angularts = /@angular\\/(\\w|\\/|-)+\\.tsx?$/;\n-const rxjsts = /rxjs\\/(\\w|\\/)+\\.tsx?$/;\n-const rxjsmetadata = /rxjs\\/(\\w|\\/)+\\.metadata\\.json?$/;\n-const tsxfile = /\\.tsx$/;\n-\n-/* The missing cache does two things. First it improves performance of the\n-   tests as it reduces the number of OS calls made during testing. Also it\n-   improves debugging experience as fewer exceptions are raised to allow you\n-   to use stopping on all exceptions. */\n-const missingCache = new Set<string>([\n-  '/node_modules/@angular/core.d.ts',\n-  '/node_modules/@angular/animations.d.ts',\n-  '/node_modules/@angular/platform-browser/animations.d.ts',\n-  '/node_modules/@angular/common.d.ts',\n-  '/node_modules/@angular/forms.d.ts',\n-  '/node_modules/@angular/core/src/di/provider.metadata.json',\n-  '/node_modules/@angular/core/src/change_detection/pipe_transform.metadata.json',\n-  '/node_modules/@angular/core/src/reflection/types.metadata.json',\n-  '/node_modules/@angular/core/src/reflection/platform_reflection_capabilities.metadata.json',\n-  '/node_modules/@angular/forms/src/directives/form_interface.metadata.json',\n-]);\n-\n-function isFile(path: string) {\n-  return fs.statSync(path).isFile();\n-}\n-\n-/**\n- * Return a Map with key = directory / file path, value = file content.\n- * [\n- *   /app => [[directory]]\n- *   /app/main.ts => ...\n- *   /app/app.component.ts => ...\n- *   /app/expression-cases.ts => ...\n- *   /app/ng-for-cases.ts => ...\n- *   /app/ng-if-cases.ts => ...\n- *   /app/parsing-cases.ts => ...\n- *   /app/test.css => ...\n- *   /app/test.ng => ...\n- * ]\n- */\n-function loadTourOfHeroes(): ReadonlyMap<string, string> {\n-  const {TEST_SRCDIR} = process.env;\n-  const root =\n-      path.join(TEST_SRCDIR!, 'angular', 'packages', 'language-service', 'test', 'project');\n-  const dirs = [root];\n-  const files = new Map<string, string>();\n-  while (dirs.length) {\n-    const dirPath = dirs.pop()!;\n-    for (const filePath of fs.readdirSync(dirPath)) {\n-      const absPath = path.join(dirPath, filePath);\n-      if (isFile(absPath)) {\n-        const key = path.join('/', path.relative(root, absPath));\n-        const value = fs.readFileSync(absPath, 'utf8');\n-        files.set(key, value);\n-      } else {\n-        const key = path.join('/', path.relative(root, absPath));\n-        files.set(key, '[[directory]]');\n-        dirs.push(absPath);\n-      }\n-    }\n-  }\n-  return files;\n-}\n-\n-const TOH = loadTourOfHeroes();\n-const COMPILER_OPTIONS: Readonly<ts.CompilerOptions> = {\n-  target: ts.ScriptTarget.ES5,\n-  module: ts.ModuleKind.CommonJS,\n-  moduleResolution: ts.ModuleResolutionKind.NodeJs,\n-  emitDecoratorMetadata: true,\n-  experimentalDecorators: true,\n-  removeComments: false,\n-  noImplicitAny: false,\n-  lib: ['lib.es2015.d.ts', 'lib.dom.d.ts'],\n-  strict: true,\n-};\n-\n-export class MockTypescriptHost implements ts.LanguageServiceHost {\n-  private readonly angularPath: string;\n-  private readonly nodeModulesPath: string;\n-  private readonly scriptVersion = new Map<string, number>();\n-  private readonly overrides = new Map<string, string>();\n-  private projectVersion = 0;\n-  private options: ts.CompilerOptions;\n-  private readonly overrideDirectory = new Set<string>();\n-  private readonly existsCache = new Map<string, boolean>();\n-  private readonly fileCache = new Map<string, string|undefined>();\n-  errors: string[] = [];\n-\n-  constructor(\n-      private readonly scriptNames: string[],\n-      private readonly node_modules: string = 'node_modules',\n-      private readonly myPath: typeof path = path) {\n-    const support = setup();\n-    this.nodeModulesPath = path.posix.join(support.basePath, 'node_modules');\n-    this.angularPath = path.posix.join(this.nodeModulesPath, '@angular');\n-    this.options = COMPILER_OPTIONS;\n-  }\n-\n-  override(fileName: string, content: string) {\n-    this.scriptVersion.set(fileName, (this.scriptVersion.get(fileName) || 0) + 1);\n-    this.projectVersion++;\n-    if (content) {\n-      this.overrides.set(fileName, content);\n-      this.overrideDirectory.add(path.dirname(fileName));\n-    } else {\n-      this.overrides.delete(fileName);\n-    }\n-    return content;\n-  }\n-\n-  /**\n-   * Override the inline template in `fileName`.\n-   * @param fileName path to component that has inline template\n-   * @param content new template\n-   *\n-   * @return the new content of the file\n-   */\n-  overrideInlineTemplate(fileName: string, content: string): string {\n-    const originalContent = this.getRawFileContent(fileName)!;\n-    const newContent =\n-        originalContent.replace(/template: `([\\s\\S]+?)`/, `template: \\`${content}\\``);\n-    return this.override(fileName, newContent);\n-  }\n-\n-  addScript(fileName: string, content: string) {\n-    if (this.scriptVersion.has(fileName)) {\n-      throw new Error(`${fileName} is already in the root files.`);\n-    }\n-    this.scriptVersion.set(fileName, 0);\n-    this.projectVersion++;\n-    this.overrides.set(fileName, content);\n-    this.overrideDirectory.add(path.dirname(fileName));\n-    this.scriptNames.push(fileName);\n-  }\n-\n-  overrideOptions(options: Partial<ts.CompilerOptions>) {\n-    this.options = {...this.options, ...options};\n-    this.projectVersion++;\n-  }\n-\n-  getCompilationSettings(): ts.CompilerOptions {\n-    return {...this.options};\n-  }\n-\n-  getProjectVersion(): string {\n-    return this.projectVersion.toString();\n-  }\n-\n-  getScriptFileNames(): string[] {\n-    return this.scriptNames;\n-  }\n-\n-  getScriptVersion(fileName: string): string {\n-    return (this.scriptVersion.get(fileName) || 0).toString();\n-  }\n-\n-  getScriptSnapshot(fileName: string): ts.IScriptSnapshot|undefined {\n-    const content = this.readFile(fileName);\n-    if (content) return ts.ScriptSnapshot.fromString(content);\n-    return undefined;\n-  }\n-\n-  getCurrentDirectory(): string {\n-    return '/';\n-  }\n-\n-  getDefaultLibFileName(options: ts.CompilerOptions): string {\n-    return 'lib.d.ts';\n-  }\n-\n-  directoryExists(directoryName: string): boolean {\n-    if (this.overrideDirectory.has(directoryName)) return true;\n-    const effectiveName = this.getEffectiveName(directoryName);\n-    if (effectiveName === directoryName) {\n-      return TOH.get(directoryName) === '[[directory]]';\n-    }\n-    if (effectiveName === '/' + this.node_modules) {\n-      return true;\n-    }\n-    return this.pathExists(effectiveName);\n-  }\n-\n-  fileExists(fileName: string): boolean {\n-    return this.getRawFileContent(fileName) != null;\n-  }\n-\n-  readFile(fileName: string): string|undefined {\n-    const content = this.getRawFileContent(fileName);\n-    if (content) {\n-      return removeReferenceMarkers(removeLocationMarkers(content));\n-    }\n-  }\n-\n-  /**\n-   * Reset the project to its original state, effectively removing all overrides.\n-   */\n-  reset() {\n-    // project version and script version must be monotonically increasing,\n-    // they must not be reset to zero.\n-    this.projectVersion++;\n-    for (const fileName of this.overrides.keys()) {\n-      const version = this.scriptVersion.get(fileName);\n-      if (version === undefined) {\n-        throw new Error(`No prior version found for ${fileName}`);\n-      }\n-      this.scriptVersion.set(fileName, version + 1);\n-    }\n-    // Remove overrides from scriptNames\n-    let length = 0;\n-    for (let i = 0; i < this.scriptNames.length; ++i) {\n-      const fileName = this.scriptNames[i];\n-      if (!this.overrides.has(fileName)) {\n-        this.scriptNames[length++] = fileName;\n-      }\n-    }\n-    this.scriptNames.splice(length);\n-    this.overrides.clear();\n-    this.overrideDirectory.clear();\n-    this.options = COMPILER_OPTIONS;\n-  }\n-\n-  private getRawFileContent(fileName: string): string|undefined {\n-    if (this.overrides.has(fileName)) {\n-      return this.overrides.get(fileName);\n-    }\n-    let basename = path.basename(fileName);\n-    if (/^lib.*\\.d\\.ts$/.test(basename)) {\n-      let libPath = ts.getDefaultLibFilePath(this.getCompilationSettings());\n-      return fs.readFileSync(this.myPath.join(path.dirname(libPath), basename), 'utf8');\n-    }\n-    if (missingCache.has(fileName)) {\n-      return undefined;\n-    }\n-\n-    const effectiveName = this.getEffectiveName(fileName);\n-    if (effectiveName === fileName) {\n-      return TOH.get(fileName);\n-    }\n-    if (!fileName.match(angularts) && !fileName.match(rxjsts) && !fileName.match(rxjsmetadata) &&\n-        !fileName.match(tsxfile)) {\n-      if (this.fileCache.has(effectiveName)) {\n-        return this.fileCache.get(effectiveName);\n-      } else if (this.pathExists(effectiveName)) {\n-        const content = fs.readFileSync(effectiveName, 'utf8');\n-        this.fileCache.set(effectiveName, content);\n-        return content;\n-      } else {\n-        missingCache.add(fileName);\n-      }\n-    }\n-  }\n-\n-  private pathExists(path: string): boolean {\n-    if (this.existsCache.has(path)) {\n-      return this.existsCache.get(path)!;\n-    }\n-\n-    const exists = fs.existsSync(path);\n-    this.existsCache.set(path, exists);\n-    return exists;\n-  }\n-\n-  private getEffectiveName(name: string): string {\n-    const node_modules = this.node_modules;\n-    const at_angular = '/@angular';\n-    if (name.startsWith('/' + node_modules)) {\n-      if (this.nodeModulesPath && !name.startsWith('/' + node_modules + at_angular)) {\n-        const result =\n-            this.myPath.posix.join(this.nodeModulesPath, name.substr(node_modules.length + 1));\n-        if (!name.match(rxjsts) && this.pathExists(result)) {\n-          return result;\n-        }\n-      }\n-      if (name.startsWith('/' + node_modules + at_angular)) {\n-        return this.myPath.posix.join(\n-            this.angularPath, name.substr(node_modules.length + at_angular.length + 1));\n-      }\n-    }\n-    return name;\n-  }\n-\n-\n-  /**\n-   * Append a snippet of code to `app.component.ts` and return the file name.\n-   * There must not be any name collision with existing code.\n-   * @param code Snippet of code\n-   */\n-  addCode(code: string) {\n-    const fileName = '/app/app.component.ts';\n-    const originalContent = this.readFile(fileName);\n-    const newContent = originalContent + code;\n-    this.override(fileName, newContent);\n-    return fileName;\n-  }\n-\n-  /**\n-   * Returns the definition marker `selector` for the specified 'selector'.\n-   * Asserts that marker exists.\n-   * @param fileName name of the file\n-   * @param selector name of the marker\n-   */\n-  getDefinitionMarkerFor(fileName: string, selector: string): ts.TextSpan {\n-    const content = this.getRawFileContent(fileName);\n-    if (!content) {\n-      throw new Error(`File does not exist: ${fileName}`);\n-    }\n-    const markers = getReferenceMarkers(content);\n-    const definitions = markers.definitions[selector];\n-    if (!definitions || !definitions.length) {\n-      throw new Error(`Failed to find marker '${selector}' in ${fileName}`);\n-    }\n-    if (definitions.length > 1) {\n-      throw new Error(`Multiple positions found for '${selector}' in ${fileName}`);\n-    }\n-    const {start, end} = definitions[0];\n-    if (start > end) {\n-      throw new Error(`Marker '${selector}' in ${fileName} is invalid: ${start} > ${end}`);\n-    }\n-    return {\n-      start,\n-      length: end - start,\n-    };\n-  }\n-\n-  /**\n-   * Returns the reference marker `selector` for the specified 'selector'.\n-   * Asserts that marker exists.\n-   * @param fileName name of the file\n-   * @param selector name of the marker\n-   */\n-  getReferenceMarkerFor(fileName: string, selector: string): ts.TextSpan {\n-    const content = this.getRawFileContent(fileName);\n-    if (!content) {\n-      throw new Error(`File does not exist: ${fileName}`);\n-    }\n-    const markers = getReferenceMarkers(content);\n-    const references = markers.references[selector];\n-    if (!references || !references.length) {\n-      throw new Error(`Failed to find marker '${selector}' in ${fileName}`);\n-    }\n-    if (references.length > 1) {\n-      throw new Error(`Multiple positions found for '${selector}' in ${fileName}`);\n-    }\n-    const {start, end} = references[0];\n-    if (start > end) {\n-      throw new Error(`Marker '${selector}' in ${fileName} is invalid: ${start} > ${end}`);\n-    }\n-    return {\n-      start,\n-      length: end - start,\n-    };\n-  }\n-\n-  /**\n-   * Returns the location marker `~{selector}` or the marker pair\n-   * `~{start-selector}` and `~{end-selector}` for the specified 'selector'.\n-   * Asserts that marker exists.\n-   * @param fileName name of the file\n-   * @param selector name of the marker\n-   */\n-  getLocationMarkerFor(fileName: string, selector: string): ts.TextSpan {\n-    const content = this.getRawFileContent(fileName);\n-    if (!content) {\n-      throw new Error(`File does not exist: ${fileName}`);\n-    }\n-    const markers = getLocationMarkers(content);\n-    // Look for just the selector itself\n-    const position = markers[selector];\n-    if (position !== undefined) {\n-      return {\n-        start: position,\n-        length: 0,\n-      };\n-    }\n-    // Look for start and end markers for the selector\n-    const start = markers[`start-${selector}`];\n-    const end = markers[`end-${selector}`];\n-    if (start !== undefined && end !== undefined) {\n-      return {\n-        start,\n-        length: end - start,\n-      };\n-    }\n-    throw new Error(`Failed to find marker '${selector}' in ${fileName}`);\n-  }\n-\n-  error(msg: string) {\n-    this.errors.push(msg);\n-  }\n-}\n-\n-const locationMarker = /\\~\\{(\\w+(-\\w+)*)\\}/g;\n-\n-function removeLocationMarkers(value: string): string {\n-  return value.replace(locationMarker, '');\n-}\n-\n-function getLocationMarkers(value: string): {[name: string]: number} {\n-  value = removeReferenceMarkers(value);\n-  let result: {[name: string]: number} = {};\n-  let adjustment = 0;\n-  value.replace(locationMarker, (match: string, name: string, _: any, index: number): string => {\n-    result[name] = index - adjustment;\n-    adjustment += match.length;\n-    return '';\n-  });\n-  return result;\n-}\n-\n-const referenceMarker = /(((\\w|\\-)+)|([^]*(\\w+).[^]*))/g;\n-\n-export type ReferenceMarkers = {\n-  [name: string]: Span[]\n-};\n-export interface ReferenceResult {\n-  text: string;\n-  definitions: ReferenceMarkers;\n-  references: ReferenceMarkers;\n-}\n-\n-function getReferenceMarkers(value: string): ReferenceResult {\n-  const references: ReferenceMarkers = {};\n-  const definitions: ReferenceMarkers = {};\n-  value = removeLocationMarkers(value);\n-\n-  let adjustment = 0;\n-  const text = value.replace(\n-      referenceMarker,\n-      (match: string, text: string, reference: string, _: string, definition: string,\n-       definitionName: string, index: number): string => {\n-        const result = reference ? text : text.replace(//g, '');\n-        const span: Span = {start: index - adjustment, end: index - adjustment + result.length};\n-        const markers = reference ? references : definitions;\n-        const name = reference || definitionName;\n-        (markers[name] = (markers[name] || [])).push(span);\n-        adjustment += match.length - result.length;\n-        return result;\n-      });\n-\n-  return {text, definitions, references};\n-}\n-\n-function removeReferenceMarkers(value: string): string {\n-  return value.replace(referenceMarker, (match, text) => text.replace(//g, ''));\n-}\n-\n-/**\n- * Find the StaticSymbol that has the specified `directiveName` and return its\n- * Angular metadata, if any.\n- * @param ngModules analyzed modules\n- * @param directiveName\n- */\n-export function findDirectiveMetadataByName(\n-    ngModules: NgAnalyzedModules, directiveName: string): CompileNgModuleMetadata|undefined {\n-  for (const [key, value] of ngModules.ngModuleByPipeOrDirective) {\n-    if (key.name === directiveName) {\n-      return value;\n-    }\n-  }\n-}"
        },
        {
            "sha": "9df941b12b928291a9263e02191d942738f914dc",
            "filename": "packages/language-service/test/ts_plugin_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 185,
            "changes": 185,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fts_plugin_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Fts_plugin_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fts_plugin_spec.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,185 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {create, getExternalFiles} from '../src/ts_plugin';\n-import {CompletionKind} from '../src/types';\n-\n-import {MockTypescriptHost} from './test_utils';\n-\n-const mockProject = {\n-  projectService: {\n-    logger: {\n-      info() {},\n-      hasLevel: () => false,\n-    },\n-  },\n-  hasRoots: () => true,\n-  fileExists: () => true,\n-} as any;\n-\n-describe('plugin', () => {\n-  const mockHost = new MockTypescriptHost(['/app/main.ts']);\n-  const tsLS = ts.createLanguageService(mockHost);\n-  const program = tsLS.getProgram()!;\n-  const plugin = create({\n-    languageService: tsLS,\n-    languageServiceHost: mockHost,\n-    project: mockProject,\n-    serverHost: {} as any,\n-    config: {},\n-  });\n-\n-  beforeEach(() => {\n-    mockHost.reset();\n-  });\n-\n-  it('should produce TypeScript diagnostics', () => {\n-    const fileName = '/foo.ts';\n-    mockHost.addScript(fileName, `\n-      function add(x: number) {\n-        return x + 42;\n-      }\n-      add('hello');\n-    `);\n-    const diags = plugin.getSemanticDiagnostics(fileName);\n-    expect(diags.length).toBe(1);\n-    expect(diags[0].messageText)\n-        .toBe(`Argument of type 'string' is not assignable to parameter of type 'number'.`);\n-  });\n-\n-  it('should not report TypeScript errors on tour of heroes', () => {\n-    const compilerDiags = tsLS.getCompilerOptionsDiagnostics();\n-    expect(compilerDiags).toEqual([]);\n-    const sourceFiles = program.getSourceFiles().filter(f => !f.fileName.endsWith('.d.ts'));\n-    // there are four .ts files in the test project\n-    expect(sourceFiles.length).toBe(4);\n-    for (const {fileName} of sourceFiles) {\n-      const syntacticDiags = tsLS.getSyntacticDiagnostics(fileName);\n-      expect(syntacticDiags).toEqual([]);\n-      const semanticDiags = tsLS.getSemanticDiagnostics(fileName);\n-      expect(semanticDiags).toEqual([]);\n-    }\n-  });\n-\n-  it('should not report template errors on tour of heroes', () => {\n-    const filesWithTemplates = [\n-      // Ignore all '*-cases.ts' files as they intentionally contain errors.\n-      '/app/app.component.ts',\n-    ];\n-    for (const fileName of filesWithTemplates) {\n-      const diags = plugin.getSemanticDiagnostics(fileName);\n-      expect(diags).toEqual([]);\n-    }\n-  });\n-\n-  it('should respect paths configuration', () => {\n-    const SHARED_MODULE = '/app/foo/bar/shared.ts';\n-    const MY_COMPONENT = '/app/my.component.ts';\n-    mockHost.overrideOptions({\n-      baseUrl: '/app',\n-      paths: {'bar/*': ['foo/bar/*']},\n-    });\n-    mockHost.addScript(SHARED_MODULE, `\n-      export interface Node {\n-        children: Node[];\n-      }\n-    `);\n-    mockHost.addScript(MY_COMPONENT, `\n-      import { Component, NgModule } from '@angular/core';\n-      import { Node } from 'bar/shared';\n-\n-      @Component({\n-        selector: 'my-component',\n-        template: '{{ tree.~{tree}children }}'\n-      })\n-      export class MyComponent {\n-        tree: Node = {\n-          children: [],\n-        };\n-      }\n-\n-      @NgModule({\n-        declarations: [MyComponent],\n-      })\n-      export class MyModule {}\n-    `);\n-    // First, make sure there are no errors in newly added scripts.\n-    for (const fileName of [SHARED_MODULE, MY_COMPONENT]) {\n-      const syntacticDiags = plugin.getSyntacticDiagnostics(fileName);\n-      expect(syntacticDiags).toEqual([]);\n-      const semanticDiags = plugin.getSemanticDiagnostics(fileName);\n-      expect(semanticDiags).toEqual([]);\n-    }\n-    const marker = mockHost.getLocationMarkerFor(MY_COMPONENT, 'tree');\n-    const completions = plugin.getCompletionsAtPosition(MY_COMPONENT, marker.start, undefined);\n-    expect(completions).toBeDefined();\n-    expect(completions!.entries).toEqual([\n-      {\n-        name: 'children',\n-        kind: CompletionKind.PROPERTY as any,\n-        sortText: 'children',\n-        replacementSpan: {start: 182, length: 8},\n-        insertText: 'children',\n-      },\n-    ]);\n-  });\n-\n-  it('should return external templates when getExternalFiles() is called', () => {\n-    const externalTemplates = getExternalFiles(mockProject);\n-    expect(new Set(externalTemplates)).toEqual(new Set([\n-      '/app/test.ng',\n-      '/app/#inner/inner.html',\n-    ]));\n-  });\n-\n-  it('should not return external template that does not exist', () => {\n-    spyOn(mockProject, 'fileExists').and.returnValue(false);\n-    const externalTemplates = getExternalFiles(mockProject);\n-    expect(externalTemplates.length).toBe(0);\n-  });\n-});\n-\n-describe(`with config 'angularOnly = true`, () => {\n-  const mockHost = new MockTypescriptHost(['/app/main.ts']);\n-  const tsLS = ts.createLanguageService(mockHost);\n-  const plugin = create({\n-    languageService: tsLS,\n-    languageServiceHost: mockHost,\n-    project: mockProject,\n-    serverHost: {} as any,\n-    config: {\n-      angularOnly: true,\n-    },\n-  });\n-\n-  it('should not produce TypeScript diagnostics', () => {\n-    const fileName = '/foo.ts';\n-    mockHost.addScript(fileName, `\n-      function add(x: number) {\n-        return x + 42;\n-      }\n-      add('hello');\n-    `);\n-    const diags = plugin.getSemanticDiagnostics(fileName);\n-    expect(diags).toEqual([]);\n-  });\n-\n-  it('should not report template errors on TOH', () => {\n-    const filesWithTemplates = [\n-      // Ignore all '*-cases.ts' files as they intentionally contain errors.\n-      '/app/app.component.ts',\n-      '/app/test.ng',\n-    ];\n-    for (const fileName of filesWithTemplates) {\n-      const diags = plugin.getSemanticDiagnostics(fileName);\n-      expect(diags).toEqual([]);\n-    }\n-  });\n-});"
        },
        {
            "sha": "e549e01eb9c227b19479f31000b6b2823c614639",
            "filename": "packages/language-service/test/typescript_host_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 287,
            "changes": 287,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Ftypescript_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Ftypescript_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Ftypescript_host_spec.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,287 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-// Note: We do not use a namespace import here because this will result in the\n-// named exports being modified if we apply jasmine spies on `path`. Using\n-// the default export gives us an object where we can patch properties on.\n-import path from 'path';\n-import ts from 'typescript';\n-\n-import {TypeScriptServiceHost} from '../src/typescript_host';\n-\n-import {findDirectiveMetadataByName, MockTypescriptHost} from './test_utils';\n-\n-\n-describe('TypeScriptServiceHost', () => {\n-  it('should be able to create a typescript host and analyze modules', () => {\n-    const tsLSHost = new MockTypescriptHost(['/app/main.ts']);\n-    const tsLS = ts.createLanguageService(tsLSHost);\n-    const ngLSHost = new TypeScriptServiceHost(tsLSHost, tsLS);\n-    const analyzedModules = ngLSHost.getAnalyzedModules();\n-    expect(analyzedModules.files.length).toBeGreaterThan(0);\n-    expect(analyzedModules.ngModules.length).toBeGreaterThan(0);\n-    expect(analyzedModules.ngModuleByPipeOrDirective.size).toBeGreaterThan(0);\n-    expect(analyzedModules.symbolsMissingModule).toEqual([]);\n-    // NgClass is defined in @angular/common, which is imported in main.ts\n-    const ngClass = findDirectiveMetadataByName(analyzedModules, 'NgClass');\n-    expect(ngClass).toBeDefined();\n-    // AppComponent is defined in app.component.ts\n-    const appComp = findDirectiveMetadataByName(analyzedModules, 'AppComponent');\n-    expect(appComp).toBeDefined();\n-  });\n-\n-  it('should be able to analyze modules without a tsconfig.json file', () => {\n-    const tsLSHost = new MockTypescriptHost(['foo.ts']);\n-    const tsLS = ts.createLanguageService(tsLSHost);\n-    const ngLSHost = new TypeScriptServiceHost(tsLSHost, tsLS);\n-    const analyzedModules = ngLSHost.getAnalyzedModules();\n-    expect(analyzedModules.files.length).toBeGreaterThan(0);\n-    expect(analyzedModules.ngModules.length).toBe(0);\n-    expect(analyzedModules.ngModuleByPipeOrDirective.size).toBe(0);\n-    expect(analyzedModules.symbolsMissingModule).toEqual([]);\n-  });\n-\n-  it('should not throw if there is no script names', () => {\n-    const tsLSHost = new MockTypescriptHost([]);\n-    const tsLS = ts.createLanguageService(tsLSHost);\n-    const ngLSHost = new TypeScriptServiceHost(tsLSHost, tsLS);\n-    const analyzedModules = ngLSHost.getAnalyzedModules();\n-    expect(analyzedModules.files.length).toBe(0);\n-    expect(analyzedModules.ngModules.length).toBe(0);\n-    expect(analyzedModules.ngModuleByPipeOrDirective.size).toBe(0);\n-    expect(analyzedModules.symbolsMissingModule).toBeUndefined();\n-  });\n-\n-  it('should clear the caches if new script is added', () => {\n-    // First create a TypescriptHost with empty script names\n-    const tsLSHost = new MockTypescriptHost([]);\n-    const tsLS = ts.createLanguageService(tsLSHost);\n-    const ngLSHost = new TypeScriptServiceHost(tsLSHost, tsLS);\n-    const oldModules = ngLSHost.getAnalyzedModules();\n-    expect(oldModules.ngModules).toEqual([]);\n-    // Now add a script, this would change the program\n-    const fileName = '/app/main.ts';\n-    const content = tsLSHost.readFile(fileName)!;\n-    tsLSHost.addScript(fileName, content);\n-    // If the caches are not cleared, we would get back an empty array.\n-    // But if the caches are cleared then the analyzed modules will be non-empty.\n-    const newModules = ngLSHost.getAnalyzedModules();\n-    expect(newModules.ngModules.length).toBeGreaterThan(0);\n-  });\n-\n-  it('should throw if getSourceFile is called on non-TS file', () => {\n-    const tsLSHost = new MockTypescriptHost([]);\n-    const tsLS = ts.createLanguageService(tsLSHost);\n-    const ngLSHost = new TypeScriptServiceHost(tsLSHost, tsLS);\n-    expect(() => {\n-      ngLSHost.getSourceFile('/src/test.ng');\n-    }).toThrowError('Non-TS source file requested: /src/test.ng');\n-  });\n-\n-  it('should be able to find a single inline template', () => {\n-    const tsLSHost = new MockTypescriptHost(['/app/app.component.ts']);\n-    const tsLS = ts.createLanguageService(tsLSHost);\n-    const ngLSHost = new TypeScriptServiceHost(tsLSHost, tsLS);\n-    const templates = ngLSHost.getTemplates('/app/app.component.ts');\n-    expect(templates.length).toBe(1);\n-    const template = templates[0];\n-    expect(template.source).toContain('<h2>{{hero.name}} details!</h2>');\n-  });\n-\n-  it('should be able to find multiple inline templates', () => {\n-    const tsLSHost = new MockTypescriptHost(['/app/parsing-cases.ts']);\n-    const tsLS = ts.createLanguageService(tsLSHost);\n-    const ngLSHost = new TypeScriptServiceHost(tsLSHost, tsLS);\n-    const templates = ngLSHost.getTemplates('/app/parsing-cases.ts');\n-    expect(templates.length).toBe(1);\n-  });\n-\n-  it('should be able to find external template', () => {\n-    const tsLSHost = new MockTypescriptHost(['/app/main.ts']);\n-    const tsLS = ts.createLanguageService(tsLSHost);\n-    const ngLSHost = new TypeScriptServiceHost(tsLSHost, tsLS);\n-    ngLSHost.getAnalyzedModules();\n-    const templates = ngLSHost.getTemplates('/app/test.ng');\n-    expect(templates.length).toBe(1);\n-    const template = templates[0];\n-    expect(template.source).toContain('<h2>{{hero.name}} details!</h2>');\n-  });\n-\n-  // https://github.com/angular/vscode-ng-language-service/issues/892\n-  it('should resolve external templates with `#` in the path', () => {\n-    const tsLSHost = new MockTypescriptHost(['/app/main.ts']);\n-    const tsLS = ts.createLanguageService(tsLSHost);\n-    const ngLSHost = new TypeScriptServiceHost(tsLSHost, tsLS);\n-    ngLSHost.getAnalyzedModules();\n-    expect(ngLSHost.getExternalTemplates() as string[]).toContain('/app/#inner/inner.html');\n-  });\n-\n-  // https://github.com/angular/angular/issues/32301\n-  it('should clear caches when program changes', () => {\n-    const tsLSHost = new MockTypescriptHost(['/app/main.ts']);\n-    const tsLS = ts.createLanguageService(tsLSHost);\n-    const ngLSHost = new TypeScriptServiceHost(tsLSHost, tsLS);\n-    const fileName = '/app/app.component.ts';\n-\n-    // Get initial state\n-    const oldModules = ngLSHost.getAnalyzedModules();\n-    // First, make sure there is no missing modules\n-    expect(oldModules.symbolsMissingModule).toEqual([]);\n-    // Expect to find AppComponent in the old modules\n-    const oldFile = oldModules.files.find(f => f.fileName === fileName);\n-    expect(oldFile!.directives.length).toBe(1);\n-    const appComp = oldFile!.directives[0];\n-    expect(appComp.name).toBe('AppComponent');\n-    expect(oldModules.ngModuleByPipeOrDirective.has(appComp)).toBe(true);\n-\n-    // Now, override app.component.ts with a different component\n-    tsLSHost.override(fileName, `\n-      import {Component} from '@angular/core';\n-\n-      @Component({\n-        template: '<div>Hello</div>',\n-      })\n-      export class HelloComponent {}\n-    `);\n-    // And override the containing NgModule to import the new component\n-    tsLSHost.override('/app/main.ts', `\n-      import {NgModule} from '@angular/core';\n-      import {HelloComponent} from './app.component';\n-\n-      @NgModule({\n-        declarations: [\n-          HelloComponent,\n-        ]\n-      })\n-      export class AppModule {}\n-    `);\n-    // Get the new state\n-    const newModules = ngLSHost.getAnalyzedModules();\n-    // Make sure there's no missing modules. If caches are not cleared properly,\n-    // it will be a non-empty array\n-    expect(newModules.symbolsMissingModule).toEqual([]);\n-    // Expect to find HelloComponent in the new modules\n-    const newFile = newModules.files.find(f => f.fileName === fileName);\n-    expect(newFile!.directives.length).toBe(1);\n-    const helloComp = newFile!.directives[0];\n-    expect(helloComp.name).toBe('HelloComponent');\n-    expect(newModules.ngModuleByPipeOrDirective.has(helloComp)).toBe(true);\n-    expect(newModules.ngModuleByPipeOrDirective.has(appComp)).toBe(false);\n-  });\n-\n-  it('should not clear caches when external template changes', () => {\n-    const tsLSHost = new MockTypescriptHost(['/app/main.ts']);\n-    const tsLS = ts.createLanguageService(tsLSHost);\n-    const ngLSHost = new TypeScriptServiceHost(tsLSHost, tsLS);\n-    const oldModules = ngLSHost.getAnalyzedModules();\n-    const oldProgram = ngLSHost.program;\n-    tsLSHost.override('/app/test.ng', '<div></div>');\n-    const newModules = ngLSHost.getAnalyzedModules();\n-    const newProgram = ngLSHost.program;\n-    // The program should not have changed since external templates are not part of\n-    // the TS source files. This is an improvement in TS 3.9 over previous versions.\n-    expect(newProgram).toBe(oldProgram);\n-    // And also analyzed modules should remain the same because none of the source\n-    // files have changed.\n-    expect(newModules).toBe(oldModules);\n-  });\n-\n-  it('should not reload @angular/core on changes', () => {\n-    const tsLSHost = new MockTypescriptHost(['/app/main.ts']);\n-    const tsLS = ts.createLanguageService(tsLSHost);\n-    const ngLSHost = new TypeScriptServiceHost(tsLSHost, tsLS);\n-    const oldModules = ngLSHost.getAnalyzedModules();\n-    const ngCore = '/node_modules/@angular/core/core.d.ts';\n-    const originalContent = tsLSHost.readFile(ngCore);\n-    const oldVersion = tsLSHost.getScriptVersion(ngCore);\n-    tsLSHost.override(ngCore, originalContent + '\\n\\n');\n-    const newVersion = tsLSHost.getScriptVersion(ngCore);\n-    expect(newVersion).not.toBe(oldVersion);\n-    const newModules = ngLSHost.getAnalyzedModules();\n-    // Had @angular/core been invalidated, we'd get a different instance of\n-    // analyzed modules, with one module missing - ApplicationModule\n-    // The absence of this module will cause language service to stop working.\n-    expect(newModules).toBe(oldModules);\n-    const ApplicationModule =\n-        newModules.ngModules.find(m => m.type.reference.name === 'ApplicationModule');\n-    expect(ApplicationModule).toBeDefined();\n-  });\n-\n-  it('should reload @angular/common on changes', () => {\n-    const tsLSHost = new MockTypescriptHost(['/app/main.ts']);\n-    const tsLS = ts.createLanguageService(tsLSHost);\n-    const ngLSHost = new TypeScriptServiceHost(tsLSHost, tsLS);\n-    const oldModules = ngLSHost.getAnalyzedModules();\n-    const ngCommon = '/node_modules/@angular/common/common.d.ts';\n-    const originalContent = tsLSHost.readFile(ngCommon);\n-    const oldVersion = tsLSHost.getScriptVersion(ngCommon);\n-    tsLSHost.override(ngCommon, originalContent + '\\n\\n');\n-    const newVersion = tsLSHost.getScriptVersion(ngCommon);\n-    expect(newVersion).not.toBe(oldVersion);\n-    const newModules = ngLSHost.getAnalyzedModules();\n-    // We get a new instance of analyzed modules\n-    expect(newModules).not.toBe(oldModules);\n-    // But the content should be exactly the same\n-    expect(newModules).toEqual(oldModules);\n-  });\n-\n-  it('should recover from error in analyzing ng modules', () => {\n-    // First create a TypescriptHost with empty script names\n-    const tsLSHost = new MockTypescriptHost([]);\n-    const tsLS = ts.createLanguageService(tsLSHost);\n-    const ngLSHost = new TypeScriptServiceHost(tsLSHost, tsLS);\n-    const oldModules = ngLSHost.getAnalyzedModules();\n-    expect(oldModules.ngModules).toEqual([]);\n-    // Now add a script, this would change the program\n-    let fileName = '/app/main.ts';\n-    let content = `\n-    import {CommonModule} from '@angular/common';\n-    import {NgModule} from '@angular/core';\n-\n-    @NgModule({\n-      entryComponents: [CommonModule],\n-    })\n-    export class AppModule {}\n-    `;\n-    tsLSHost.addScript(fileName, content);\n-\n-    // If analyzing modules throws, the old modules should be returned.\n-    let newModules = ngLSHost.getAnalyzedModules();\n-    expect(newModules.ngModules).toEqual([]);\n-    expect(tsLSHost.errors).toEqual([\n-      'Analyzing NgModules failed. Error: CommonModule cannot be used as an entry component.'\n-    ]);\n-\n-    content = `\n-    import {CommonModule} from '@angular/common';\n-    import {NgModule} from '@angular/core';\n-\n-    @NgModule({})\n-    export class AppModule {}\n-    `;\n-    tsLSHost.override(fileName, content);\n-    // Check that analyzing modules successfully still works.\n-    newModules = ngLSHost.getAnalyzedModules();\n-    expect(newModules.ngModules.length).toBeGreaterThan(0);\n-  });\n-\n-  it('should normalize path on Windows', () => {\n-    // Spy on the `path.resolve()` method called by the URL resolver and mimic\n-    // behavior on Windows.\n-    spyOn(path, 'resolve').and.callFake((...pathSegments: string[]) => {\n-      return path.win32.resolve(...pathSegments);\n-    });\n-    const tsLSHost = new MockTypescriptHost(['/app/main.ts']);\n-    const tsLS = ts.createLanguageService(tsLSHost);\n-    const ngLSHost = new TypeScriptServiceHost(tsLSHost, tsLS);\n-    ngLSHost.getAnalyzedModules();\n-    const externalTemplates: string[] = ngLSHost.getExternalTemplates();\n-    // External templates should be normalized.\n-    expect(externalTemplates).toContain('/app/test.ng');\n-  });\n-});"
        },
        {
            "sha": "6eaa2445d9c4f089bc0d40aeccdbe79cd1b76b80",
            "filename": "packages/language-service/test/typescript_symbols_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 132,
            "changes": 132,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Ftypescript_symbols_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Ftypescript_symbols_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Ftypescript_symbols_spec.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,132 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Directory} from '@angular/compiler-cli/test/mocks';\n-import {ReflectorHost} from '@angular/language-service/src/reflector_host';\n-import ts from 'typescript';\n-\n-import {BuiltinType, Symbol, SymbolQuery, SymbolTable} from '../src/symbols';\n-import {getSymbolQuery} from '../src/typescript_symbols';\n-\n-import {DiagnosticContext, MockLanguageServiceHost} from './mocks';\n-\n-function emptyPipes(): SymbolTable {\n-  return {\n-    size: 0,\n-    get(key: string) {\n-      return undefined;\n-    },\n-    has(key: string) {\n-      return false;\n-    },\n-    values(): Symbol[] {\n-      return [];\n-    }\n-  };\n-}\n-\n-describe('symbol query', () => {\n-  let program: ts.Program;\n-  let checker: ts.TypeChecker;\n-  let sourceFile: ts.SourceFile;\n-  let query: SymbolQuery;\n-  let context: DiagnosticContext;\n-  beforeEach(() => {\n-    const registry = ts.createDocumentRegistry(false, '/src');\n-    const host = new MockLanguageServiceHost(\n-        ['/quickstart/app/app.component.ts'], QUICKSTART, '/quickstart');\n-    const service = ts.createLanguageService(host, registry);\n-    program = service.getProgram()!;\n-    checker = program.getTypeChecker();\n-    sourceFile = program.getSourceFile('/quickstart/app/app.component.ts')!;\n-    const symbolResolverHost = new ReflectorHost(() => program, host);\n-    context = new DiagnosticContext(service, program, checker, symbolResolverHost);\n-    query = getSymbolQuery(program, checker, sourceFile, emptyPipes);\n-  });\n-\n-  it('should be able to get undefined for an unknown symbol', () => {\n-    const unknownType = context.getStaticSymbol('/unkonwn/file.ts', 'UnknownType');\n-    const symbol = query.getTypeSymbol(unknownType);\n-    expect(symbol).toBeUndefined();\n-  });\n-\n-  it('should return correct built-in types', () => {\n-    const tests: Array<[BuiltinType, boolean, ts.TypeFlags?]> = [\n-      // builtinType, throws, want\n-      [BuiltinType.Any, false, ts.TypeFlags.Any],\n-      [BuiltinType.Boolean, false, ts.TypeFlags.Boolean | ts.TypeFlags.Union],\n-      [BuiltinType.Null, false, ts.TypeFlags.Null],\n-      [BuiltinType.Number, false, ts.TypeFlags.Number],\n-      [BuiltinType.String, false, ts.TypeFlags.String],\n-      [BuiltinType.Undefined, false, ts.TypeFlags.Undefined],\n-      [BuiltinType.Unbound, true],\n-      [BuiltinType.Other, true],\n-    ];\n-    for (const [builtinType, throws, want] of tests) {\n-      if (throws) {\n-        expect(() => query.getBuiltinType(builtinType)).toThrow();\n-      } else {\n-        const symbol = query.getBuiltinType(builtinType);\n-        const got: ts.TypeFlags = (symbol as any).tsType.flags;\n-        expect(got).toBe(want!);\n-      }\n-    }\n-  });\n-});\n-\n-function appComponentSource(template: string): string {\n-  return `\n-    import {Component} from '@angular/core';\n-\n-    export interface Person {\n-      name: string;\n-      address: Address;\n-    }\n-\n-    export interface Address {\n-      street: string;\n-      city: string;\n-      state: string;\n-      zip: string;\n-    }\n-\n-    @Component({\n-      template: '${template}'\n-    })\n-    export class AppComponent {\n-      name = 'Angular';\n-      person: Person;\n-      people: Person[];\n-      maybePerson?: Person;\n-\n-      getName(): string { return this.name; }\n-      getPerson(): Person { return this.person; }\n-      getMaybePerson(): Person | undefined { this.maybePerson; }\n-    }\n-  `;\n-}\n-\n-const QUICKSTART: Directory = {\n-  quickstart: {\n-    app: {\n-      'app.component.ts': appComponentSource('<h1>Hello {{name}}</h1>'),\n-      'app.module.ts': `\n-        import { NgModule }      from '@angular/core';\n-        import { toString }      from './utils';\n-\n-        import { AppComponent }  from './app.component';\n-\n-        @NgModule({\n-          declarations: [ AppComponent ],\n-          bootstrap:    [ AppComponent ]\n-        })\n-        export class AppModule { }\n-      `\n-    }\n-  }\n-};"
        },
        {
            "sha": "d7ff22b413044e25a50df7317451392f590271de",
            "filename": "packages/language-service/test/utils_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 123,
            "changes": 123,
            "blob_url": "https://github.com/angular/angular/blob/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Futils_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/891318e805da3cdfb9839bf6cb3412c15c146253/packages%2Flanguage-service%2Ftest%2Futils_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Futils_spec.ts?ref=891318e805da3cdfb9839bf6cb3412c15c146253",
            "patch": "@@ -1,123 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as ng from '@angular/compiler';\n-import ts from 'typescript';\n-\n-import {getClassDeclFromDecoratorProp, getDirectiveClassLike} from '../src/ts_utils';\n-import {getPathToNodeAtPosition} from '../src/utils';\n-import {MockTypescriptHost} from './test_utils';\n-\n-describe('getDirectiveClassLike', () => {\n-  it('should return a directive class', () => {\n-    const sourceFile = ts.createSourceFile(\n-        'foo.ts', `\n-      @NgModule({\n-        declarations: [],\n-      })\n-      class AppModule {}\n-    `,\n-        ts.ScriptTarget.ES2015);\n-    const result = sourceFile.forEachChild(c => {\n-      const directive = getDirectiveClassLike(c);\n-      if (directive) {\n-        return directive;\n-      }\n-    });\n-    expect(result).toBeTruthy();\n-    const {decoratorId, classId} = result!;\n-    expect(decoratorId.kind).toBe(ts.SyntaxKind.Identifier);\n-    expect(decoratorId.text).toBe('NgModule');\n-    expect(classId.text).toBe('AppModule');\n-  });\n-});\n-\n-describe('getPathToNodeAtPosition', () => {\n-  const html = '<div c></div>';\n-  const nodes: ng.Node[] = [];\n-\n-  beforeAll(() => {\n-    const parser = new ng.HtmlParser();\n-    const {rootNodes, errors} = parser.parse(html, 'url');\n-    expect(errors.length).toBe(0);\n-    nodes.push(...rootNodes);\n-  });\n-\n-  it('should capture element', () => {\n-    // Try to get a path to an element\n-    // <|div c></div>\n-    //  ^ cursor is here\n-    const position = html.indexOf('div');\n-    const path = getPathToNodeAtPosition(nodes, position);\n-    // There should be just 1 node in the path, the Element node\n-    expect(path.empty).toBe(false);\n-    expect(path.head instanceof ng.Element).toBe(true);\n-    expect(path.head).toBe(path.tail);\n-  });\n-\n-  it('should capture attribute', () => {\n-    // Try to get a path to an attribute\n-    // <div |c></div>\n-    //      ^ cusor is here, before the attribute\n-    const position = html.indexOf('c');\n-    const path = getPathToNodeAtPosition(nodes, position);\n-    expect(path.empty).toBe(false);\n-    expect(path.head instanceof ng.Element).toBe(true);\n-    expect(path.tail instanceof ng.Attribute).toBe(true);\n-  });\n-\n-  it('should capture attribute before cursor', () => {\n-    // Try to get a path to an attribute\n-    // <div c|></div>\n-    //       ^ cursor is here, after the attribute\n-    const position = html.indexOf('c') + 1;\n-    const path = getPathToNodeAtPosition(nodes, position);\n-    expect(path.empty).toBe(false);\n-    expect(path.head instanceof ng.Element).toBe(true);\n-    expect(path.tail instanceof ng.Attribute).toBe(true);\n-  });\n-});\n-\n-describe('getClassDeclFromTemplateNode', () => {\n-  it('should find class declaration in syntax-only mode', () => {\n-    const sourceFile = ts.createSourceFile(\n-        'foo.ts', `\n-        @Component({\n-          template: '<div></div>'\n-        })\n-        class MyComponent {}`,\n-        ts.ScriptTarget.ES2015, true /* setParentNodes */);\n-    function visit(node: ts.Node): ts.ClassDeclaration|undefined {\n-      if (ts.isPropertyAssignment(node)) {\n-        return getClassDeclFromDecoratorProp(node);\n-      }\n-      return node.forEachChild(visit);\n-    }\n-    const classDecl = sourceFile.forEachChild(visit);\n-    expect(classDecl).toBeTruthy();\n-    expect(classDecl!.kind).toBe(ts.SyntaxKind.ClassDeclaration);\n-    expect((classDecl as ts.ClassDeclaration).name!.text).toBe('MyComponent');\n-  });\n-\n-\n-  it('should return class declaration for AppComponent', () => {\n-    const host = new MockTypescriptHost(['/app/app.component.ts']);\n-    const tsLS = ts.createLanguageService(host);\n-    const sourceFile = tsLS.getProgram()!.getSourceFile('/app/app.component.ts');\n-    expect(sourceFile).toBeTruthy();\n-    const classDecl = sourceFile!.forEachChild(function visit(node): ts.Node|undefined {\n-      if (ts.isPropertyAssignment(node)) {\n-        return getClassDeclFromDecoratorProp(node);\n-      }\n-      return node.forEachChild(visit);\n-    });\n-    expect(classDecl).toBeTruthy();\n-    expect(ts.isClassDeclaration(classDecl!)).toBe(true);\n-    expect((classDecl as ts.ClassDeclaration).name!.text).toBe('AppComponent');\n-  });\n-});"
        },
        {
            "sha": "29bfd891c9598b2ee0881a0c795a19e0c1d7fbf4",
            "filename": "packages/tsconfig.json",
            "status": "modified",
            "additions": 24,
            "deletions": 9,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Ftsconfig.json",
            "raw_url": "https://github.com/angular/angular/raw/4738569220b4e360aa77f8875ac866c6defd8f6c/packages%2Ftsconfig.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Ftsconfig.json?ref=4738569220b4e360aa77f8875ac866c6defd8f6c",
            "patch": "@@ -19,19 +19,34 @@\n     \"useUnknownInCatchVariables\": false,\n     \"noFallthroughCasesInSwitch\": true,\n     \"paths\": {\n-      \"selenium-webdriver\": [\"./node_modules/@types/selenium-webdriver/index.d.ts\"],\n-      \"rxjs/*\": [\"./node_modules/rxjs/*\"],\n-      \"@angular/*\": [\"./packages/*\"],\n-      \"zone.js/*\": [\"./packages/zone.js/*\"],\n-      \"angular-in-memory-web-api\": [\"./packages/misc/angular-in-memory-web-api/index.ts\"]\n+      \"selenium-webdriver\": [\n+        \"./node_modules/@types/selenium-webdriver/index.d.ts\"\n+      ],\n+      \"rxjs/*\": [\n+        \"./node_modules/rxjs/*\"\n+      ],\n+      \"@angular/*\": [\n+        \"./packages/*\"\n+      ],\n+      \"zone.js/*\": [\n+        \"./packages/zone.js/*\"\n+      ],\n+      \"angular-in-memory-web-api\": [\n+        \"./packages/misc/angular-in-memory-web-api/index.ts\"\n+      ]\n     },\n     \"rootDir\": \".\",\n     \"inlineSourceMap\": true,\n-    \"lib\": [\"es2020\", \"dom\"],\n+    \"lib\": [\n+      \"es2020\",\n+      \"dom\"\n+    ],\n     \"skipDefaultLibCheck\": true,\n     \"skipLibCheck\": true,\n     \"target\": \"es2020\",\n-    \"types\": [\"angular\"]\n+    \"types\": [\n+      \"angular\"\n+    ]\n   },\n   \"bazelOptions\": {\n     \"suppressTsconfigOverrideWarnings\": true\n@@ -49,8 +64,8 @@\n     // Http doesn't need to built since it is no longer maintained and\n     // will be removed eventually. See: FW-1392.\n     \"http/**\",\n-    \"language-service/test/project\",\n+    \"language-service/ivy/test/legacy/project\",\n     \"platform-server/integrationtest\",\n     \"router/test/aot_ngsummary_test\"\n   ]\n-}\n+}\n\\ No newline at end of file"
        }
    ],
    "stats": {
        "total": 11560,
        "additions": 47,
        "deletions": 11513
    }
}