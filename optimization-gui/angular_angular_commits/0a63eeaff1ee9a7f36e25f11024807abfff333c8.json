{
    "author": "petebacondarwin",
    "message": "Revert \"perf(ngcc): allow immediately reporting a stale lock file (#37250)\" (#39435)\n\nThis reverts commit 561c0f81a0d62b84fa47a98226eeb85eda864ffd.\n\nThe original commit provided a quick escape from an already terminal\nsituation by killing the process if the PID in the lockfile was not\nfound in the list of processes running on the current machine.\n\nBut this broke use-cases where the node_modules was being shared between\nmultiple machines (or more commonly Docker containers on the same actual\nmachine).\n\nFixes #38875\n\nPR Close #39435",
    "sha": "0a63eeaff1ee9a7f36e25f11024807abfff333c8",
    "files": [
        {
            "sha": "7e2f1dc7aad33ee64b3690313669fc912d558443",
            "filename": "packages/compiler-cli/ngcc/src/locking/async_locker.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 56,
            "changes": 66,
            "blob_url": "https://github.com/angular/angular/blob/0a63eeaff1ee9a7f36e25f11024807abfff333c8/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Flocking%2Fasync_locker.ts",
            "raw_url": "https://github.com/angular/angular/raw/0a63eeaff1ee9a7f36e25f11024807abfff333c8/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Flocking%2Fasync_locker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Flocking%2Fasync_locker.ts?ref=0a63eeaff1ee9a7f36e25f11024807abfff333c8",
            "patch": "@@ -60,68 +60,22 @@ export class AsyncLocker {\n           pid = newPid;\n         }\n         if (attempts === 0) {\n-          // Check to see if the process identified by the PID is still running. Because the\n-          // process *should* clean up after itself, we only check for a stale lock file when the\n-          // PID changes and only once. This may mean you have to wait if the process is killed\n-          // after the first check and isn't given the chance to clean up after itself.\n-          if (!this.isProcessRunning(pid)) {\n-            // try to re-lock one last time in case there was a race condition checking the process.\n-            try {\n-              return this.lockFile.write();\n-            } catch (e2) {\n-              if (e2.code !== 'EEXIST') {\n-                throw e2;\n-              }\n-            }\n-\n-            // finally check that the lock was held by the same process this whole time.\n-            const finalPid = this.lockFile.read();\n-            if (finalPid === pid) {\n-              throw new TimeoutError(this.lockFileMessage(\n-                  `Lock found, but no process with PID ${pid} seems to be running.`));\n-            } else {\n-              // attempts is still 0, but adjust the PID so the message below is correct.\n-              pid = finalPid;\n-            }\n-          }\n-\n-          this.logger.info(this.lockFileMessage(\n+          this.logger.info(\n               `Another process, with id ${pid}, is currently running ngcc.\\n` +\n-              `Waiting up to ${this.retryDelay * this.retryAttempts / 1000}s for it to finish.`));\n+              `Waiting up to ${this.retryDelay * this.retryAttempts / 1000}s for it to finish.\\n` +\n+              `(If you are sure no ngcc process is running then you should delete the lock-file at ${\n+                  this.lockFile.path}.)`);\n         }\n         // The file is still locked by another process so wait for a bit and retry\n         await new Promise(resolve => setTimeout(resolve, this.retryDelay));\n       }\n     }\n     // If we fall out of the loop then we ran out of rety attempts\n-    throw new TimeoutError(this.lockFileMessage(`Timed out waiting ${\n-        this.retryAttempts * this.retryDelay /\n-        1000}s for another ngcc process, with id ${pid}, to complete.`));\n-  }\n-\n-  protected isProcessRunning(pid: string): boolean {\n-    // let the normal logic run if this is not called with a valid PID\n-    if (isNaN(+pid)) {\n-      this.logger.debug(`Cannot check if invalid PID \"${pid}\" is running, a number is expected.`);\n-      return true;\n-    }\n-\n-    try {\n-      process.kill(+pid, 0);\n-      return true;\n-    } catch (e) {\n-      // If the process doesn't exist ESRCH will be thrown, if the error is not that, throw it.\n-      if (e.code !== 'ESRCH') {\n-        throw e;\n-      }\n-\n-      return false;\n-    }\n-  }\n-\n-  private lockFileMessage(message: string): string {\n-    return message +\n-        `\\n(If you are sure no ngcc process is running then you should delete the lock-file at ${\n-               this.lockFile.path}.)`;\n+    throw new TimeoutError(\n+        `Timed out waiting ${\n+            this.retryAttempts * this.retryDelay /\n+            1000}s for another ngcc process, with id ${pid}, to complete.\\n` +\n+        `(If you are sure no ngcc process is running then you should delete the lock-file at ${\n+            this.lockFile.path}.)`);\n   }\n }"
        },
        {
            "sha": "cfee2cfd010ad11f8cf66ddd57e8df018692d52c",
            "filename": "packages/compiler-cli/ngcc/test/locking/async_locker_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 48,
            "changes": 48,
            "blob_url": "https://github.com/angular/angular/blob/0a63eeaff1ee9a7f36e25f11024807abfff333c8/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Flocking%2Fasync_locker_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/0a63eeaff1ee9a7f36e25f11024807abfff333c8/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Flocking%2Fasync_locker_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Flocking%2Fasync_locker_spec.ts?ref=0a63eeaff1ee9a7f36e25f11024807abfff333c8",
            "patch": "@@ -71,7 +71,6 @@ runInEachFileSystem(() => {\n           }\n           return lockFileContents;\n         });\n-        spyOn(process, 'kill').and.returnValue();\n \n         const promise = locker.lock(async () => log.push('fn()'));\n         // The lock is now waiting on the lock-file becoming free, so no `fn()` in the log.\n@@ -81,7 +80,6 @@ runInEachFileSystem(() => {\n           `(If you are sure no ngcc process is running then you should delete the lock-file at ${\n               lockFile.path}.)`\n         ]]);\n-        expect(process.kill).toHaveBeenCalledWith(188, 0);\n \n         lockFileContents = null;\n         // The lock-file has been removed, so we can create our own lock-file, call `fn()` and then\n@@ -90,47 +88,6 @@ runInEachFileSystem(() => {\n         expect(log).toEqual(['write()', 'read() => 188', 'write()', 'fn()', 'remove()']);\n       });\n \n-      it('should fail fast when waiting on a dead process', async () => {\n-        const fs = getFileSystem();\n-        const log: string[] = [];\n-        const lockFile = new MockLockFile(fs, log);\n-        const logger = new MockLogger();\n-        const locker = new AsyncLocker(lockFile, logger, 100, 10);\n-\n-        let lockFileContents: string|null = '188';\n-        spyOn(lockFile, 'write').and.callFake(() => {\n-          log.push('write()');\n-          if (lockFileContents) {\n-            throw {code: 'EEXIST'};\n-          }\n-        });\n-        spyOn(lockFile, 'read').and.callFake(() => {\n-          log.push('read() => ' + lockFileContents);\n-          if (lockFileContents === null) {\n-            throw {code: 'ENOENT'};\n-          }\n-          return lockFileContents;\n-        });\n-        spyOn(process, 'kill').and.callFake(() => {\n-          throw {code: 'ESRCH'};\n-        });\n-\n-        const promise = locker.lock(async () => log.push('fn()'));\n-        // The lock has already failed so no `fn()` in the log.\n-        expect(log).toEqual(['write()', 'read() => 188', 'write()', 'read() => 188']);\n-        expect(logger.logs.info).toEqual([]);\n-        expect(process.kill).toHaveBeenCalledWith(188, 0);\n-        // Check that a missing process errors out.\n-        let error: Error;\n-        await promise.catch(e => error = e);\n-        expect(log).toEqual(['write()', 'read() => 188', 'write()', 'read() => 188']);\n-        expect(error!.message)\n-            .toEqual(\n-                `Lock found, but no process with PID 188 seems to be running.\\n` +\n-                `(If you are sure no ngcc process is running then you should delete the lock-file at ${\n-                    lockFile.path}.)`);\n-      });\n-\n       it('should extend the retry timeout if the other process locking the file changes', async () => {\n         const fs = getFileSystem();\n         const log: string[] = [];\n@@ -152,7 +109,6 @@ runInEachFileSystem(() => {\n           }\n           return lockFileContents;\n         });\n-        spyOn(process, 'kill').and.returnValue();\n \n         const promise = locker.lock(async () => log.push('fn()'));\n         // The lock is now waiting on the lock-file becoming free, so no `fn()` in the log.\n@@ -162,7 +118,6 @@ runInEachFileSystem(() => {\n           `(If you are sure no ngcc process is running then you should delete the lock-file at ${\n               lockFile.path}.)`\n         ]]);\n-        expect(process.kill).toHaveBeenCalledWith(188, 0);\n \n         lockFileContents = '444';\n         // The lock-file has been taken over by another process - wait for the next attempt\n@@ -176,7 +131,6 @@ runInEachFileSystem(() => {\n            `(If you are sure no ngcc process is running then you should delete the lock-file at ${\n                lockFile.path}.)`]\n         ]);\n-        expect(process.kill).toHaveBeenCalledWith(444, 0);\n \n         lockFileContents = null;\n         // The lock-file has been removed, so we can create our own lock-file, call `fn()` and\n@@ -209,13 +163,11 @@ runInEachFileSystem(() => {\n              }\n              return lockFileContents;\n            });\n-           spyOn(process, 'kill').and.returnValue();\n \n            const promise = locker.lock(async () => log.push('fn()'));\n \n            // The lock is now waiting on the lock-file becoming free, so no `fn()` in the log.\n            expect(log).toEqual(['write()', 'read() => 188']);\n-           expect(process.kill).toHaveBeenCalledWith(188, 0);\n            // Do not remove the lock-file and let the call to `lock()` timeout.\n            let error: Error;\n            await promise.catch(e => error = e);"
        }
    ],
    "stats": {
        "total": 114,
        "additions": 10,
        "deletions": 104
    }
}