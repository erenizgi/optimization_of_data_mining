{
    "author": "atscott",
    "message": "fix(compiler-cli): Allow analysis to continue with invalid style url (#41403)\n\nCurrently, we throw a FatalDiagnosticError when we fail to load a resource\n(`templateUrl` or `styleUrl`) at various stages in the compiler. This prevents\nanalysis of the component from completing. This will result in in users not being\nable to get any information in the component template when there is a missing\n`styleUrl`, for example.\n\nThis commit simply tracks the diagnostic, marks the component as poisoned, and\ncontinues merrily along. Environments configured to use poisoned data\n(like the language service) will then be able to use other information from the analysis.\n\nFixes https://github.com/angular/vscode-ng-language-service/issues/1241\n\nPR Close #41403",
    "sha": "8f12f4749262d113accd1a4a82cbbf603e325ce2",
    "files": [
        {
            "sha": "5487ac5ee3790e8a4fd27506bb32965bf018e6a1",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/component.ts",
            "status": "modified",
            "additions": 104,
            "deletions": 95,
            "changes": 199,
            "blob_url": "https://github.com/angular/angular/blob/8f12f4749262d113accd1a4a82cbbf603e325ce2/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/8f12f4749262d113accd1a4a82cbbf603e325ce2/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts?ref=8f12f4749262d113accd1a4a82cbbf603e325ce2",
            "patch": "@@ -10,7 +10,7 @@ import {compileComponentFromMetadata, compileDeclareComponentFromMetadata, Const\n import * as ts from 'typescript';\n \n import {Cycle, CycleAnalyzer, CycleHandlingStrategy} from '../../cycles';\n-import {ErrorCode, FatalDiagnosticError, makeRelatedInformation} from '../../diagnostics';\n+import {ErrorCode, FatalDiagnosticError, makeDiagnostic, makeRelatedInformation} from '../../diagnostics';\n import {absoluteFrom, relative} from '../../file_system';\n import {DefaultImportRecorder, ImportedFile, ModuleResolver, Reference, ReferenceEmitter} from '../../imports';\n import {DependencyTracker} from '../../incremental/api';\n@@ -262,13 +262,16 @@ export class ComponentDecoratorHandler implements\n     const component = reflectObjectLiteral(meta);\n     const containingFile = node.getSourceFile().fileName;\n \n-    const resolveStyleUrl =\n-        (styleUrl: string, nodeForError: ts.Node,\n-         resourceType: ResourceTypeForDiagnostics): Promise<void>|undefined => {\n-          const resourceUrl =\n-              this._resolveResourceOrThrow(styleUrl, containingFile, nodeForError, resourceType);\n-          return this.resourceLoader.preload(resourceUrl, {type: 'style', containingFile});\n-        };\n+    const resolveStyleUrl = (styleUrl: string): Promise<void>|undefined => {\n+      try {\n+        const resourceUrl = this.resourceLoader.resolve(styleUrl, containingFile);\n+        return this.resourceLoader.preload(resourceUrl, {type: 'style', containingFile});\n+      } catch {\n+        // Don't worry about failures to preload. We can handle this problem during analysis by\n+        // producing a diagnostic.\n+        return undefined;\n+      }\n+    };\n \n     // A Promise that waits for the template and all <link>ed styles within it to be preloaded.\n     const templateAndTemplateStyleResources =\n@@ -278,12 +281,7 @@ export class ComponentDecoratorHandler implements\n                 return undefined;\n               }\n \n-              const nodeForError = getTemplateDeclarationNodeForError(template.declaration);\n-              return Promise\n-                  .all(template.styleUrls.map(\n-                      styleUrl => resolveStyleUrl(\n-                          styleUrl, nodeForError,\n-                          ResourceTypeForDiagnostics.StylesheetFromTemplate)))\n+              return Promise.all(template.styleUrls.map(styleUrl => resolveStyleUrl(styleUrl)))\n                   .then(() => undefined);\n             });\n \n@@ -311,10 +309,7 @@ export class ComponentDecoratorHandler implements\n     return Promise\n         .all([\n           templateAndTemplateStyleResources, inlineStyles,\n-          ...componentStyleUrls.map(\n-              styleUrl => resolveStyleUrl(\n-                  styleUrl.url, styleUrl.nodeForError,\n-                  ResourceTypeForDiagnostics.StylesheetFromDecorator))\n+          ...componentStyleUrls.map(styleUrl => resolveStyleUrl(styleUrl.url))\n         ])\n         .then(() => undefined);\n   }\n@@ -326,6 +321,8 @@ export class ComponentDecoratorHandler implements\n     const containingFile = node.getSourceFile().fileName;\n     this.literalCache.delete(decorator);\n \n+    let diagnostics: ts.Diagnostic[]|undefined;\n+    let isPoisoned = false;\n     // @Component inherits @Directive, so begin by extracting the @Directive metadata and building\n     // on it.\n     const directiveResult = extractDirectiveMetadata(\n@@ -408,16 +405,24 @@ export class ComponentDecoratorHandler implements\n     ];\n \n     for (const styleUrl of styleUrls) {\n-      const resourceType = styleUrl.source === ResourceTypeForDiagnostics.StylesheetFromDecorator ?\n-          ResourceTypeForDiagnostics.StylesheetFromDecorator :\n-          ResourceTypeForDiagnostics.StylesheetFromTemplate;\n-      const resourceUrl = this._resolveResourceOrThrow(\n-          styleUrl.url, containingFile, styleUrl.nodeForError, resourceType);\n-      const resourceStr = this.resourceLoader.load(resourceUrl);\n-\n-      styles.push(resourceStr);\n-      if (this.depTracker !== null) {\n-        this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(resourceUrl));\n+      try {\n+        const resourceUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);\n+        const resourceStr = this.resourceLoader.load(resourceUrl);\n+        styles.push(resourceStr);\n+        if (this.depTracker !== null) {\n+          this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(resourceUrl));\n+        }\n+      } catch {\n+        if (diagnostics === undefined) {\n+          diagnostics = [];\n+        }\n+        const resourceType =\n+            styleUrl.source === ResourceTypeForDiagnostics.StylesheetFromDecorator ?\n+            ResourceTypeForDiagnostics.StylesheetFromDecorator :\n+            ResourceTypeForDiagnostics.StylesheetFromTemplate;\n+        diagnostics.push(\n+            this.makeResourceNotFoundError(styleUrl.url, styleUrl.nodeForError, resourceType)\n+                .toDiagnostic());\n       }\n     }\n \n@@ -496,8 +501,9 @@ export class ComponentDecoratorHandler implements\n           styles: styleResources,\n           template: templateResource,\n         },\n-        isPoisoned: false,\n+        isPoisoned,\n       },\n+      diagnostics,\n     };\n     if (changeDetection !== null) {\n       output.analysis!.meta.changeDetection = changeDetection;\n@@ -833,14 +839,14 @@ export class ComponentDecoratorHandler implements\n     let styles: string[] = [];\n     if (analysis.styleUrls !== null) {\n       for (const styleUrl of analysis.styleUrls) {\n-        const resourceType =\n-            styleUrl.source === ResourceTypeForDiagnostics.StylesheetFromDecorator ?\n-            ResourceTypeForDiagnostics.StylesheetFromDecorator :\n-            ResourceTypeForDiagnostics.StylesheetFromTemplate;\n-        const resolvedStyleUrl = this._resolveResourceOrThrow(\n-            styleUrl.url, containingFile, styleUrl.nodeForError, resourceType);\n-        const styleText = this.resourceLoader.load(resolvedStyleUrl);\n-        styles.push(styleText);\n+        try {\n+          const resolvedStyleUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);\n+          const styleText = this.resourceLoader.load(resolvedStyleUrl);\n+          styles.push(styleText);\n+        } catch (e) {\n+          // Resource resolve failures should already be in the diagnostics list from the analyze\n+          // stage. We do not need to do anything with them when updating resources.\n+        }\n       }\n     }\n     if (analysis.inlineStyles !== null) {\n@@ -978,10 +984,14 @@ export class ComponentDecoratorHandler implements\n     const styleUrlsExpr = component.get('styleUrls');\n     if (styleUrlsExpr !== undefined && ts.isArrayLiteralExpression(styleUrlsExpr)) {\n       for (const expression of stringLiteralElements(styleUrlsExpr)) {\n-        const resourceUrl = this._resolveResourceOrThrow(\n-            expression.text, containingFile, expression,\n-            ResourceTypeForDiagnostics.StylesheetFromDecorator);\n-        styles.add({path: absoluteFrom(resourceUrl), expression});\n+        try {\n+          const resourceUrl = this.resourceLoader.resolve(expression.text, containingFile);\n+          styles.add({path: absoluteFrom(resourceUrl), expression});\n+        } catch {\n+          // Errors in style resource extraction do not need to be handled here. We will produce\n+          // diagnostics for each one that fails in the analysis, after we evaluate the `styleUrls`\n+          // expression to determine _all_ style resources, not just the string literals.\n+        }\n       }\n     }\n \n@@ -1006,22 +1016,27 @@ export class ComponentDecoratorHandler implements\n         throw createValueHasWrongTypeError(\n             templateUrlExpr, templateUrl, 'templateUrl must be a string');\n       }\n-      const resourceUrl = this._resolveResourceOrThrow(\n-          templateUrl, containingFile, templateUrlExpr, ResourceTypeForDiagnostics.Template);\n-      const templatePromise =\n-          this.resourceLoader.preload(resourceUrl, {type: 'template', containingFile});\n-\n-      // If the preload worked, then actually load and parse the template, and wait for any style\n-      // URLs to resolve.\n-      if (templatePromise !== undefined) {\n-        return templatePromise.then(() => {\n-          const templateDecl = this.parseTemplateDeclaration(decorator, component, containingFile);\n-          const template = this.extractTemplate(node, templateDecl);\n-          this.preanalyzeTemplateCache.set(node, template);\n-          return template;\n-        });\n-      } else {\n-        return Promise.resolve(null);\n+      try {\n+        const resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);\n+        const templatePromise =\n+            this.resourceLoader.preload(resourceUrl, {type: 'template', containingFile});\n+\n+        // If the preload worked, then actually load and parse the template, and wait for any style\n+        // URLs to resolve.\n+        if (templatePromise !== undefined) {\n+          return templatePromise.then(() => {\n+            const templateDecl =\n+                this.parseTemplateDeclaration(decorator, component, containingFile);\n+            const template = this.extractTemplate(node, templateDecl);\n+            this.preanalyzeTemplateCache.set(node, template);\n+            return template;\n+          });\n+        } else {\n+          return Promise.resolve(null);\n+        }\n+      } catch (e) {\n+        throw this.makeResourceNotFoundError(\n+            templateUrl, templateUrlExpr, ResourceTypeForDiagnostics.Template);\n       }\n     } else {\n       const templateDecl = this.parseTemplateDeclaration(decorator, component, containingFile);\n@@ -1186,18 +1201,21 @@ export class ComponentDecoratorHandler implements\n         throw createValueHasWrongTypeError(\n             templateUrlExpr, templateUrl, 'templateUrl must be a string');\n       }\n-      const resourceUrl = this._resolveResourceOrThrow(\n-          templateUrl, containingFile, templateUrlExpr, ResourceTypeForDiagnostics.Template);\n-\n-      return {\n-        isInline: false,\n-        interpolationConfig,\n-        preserveWhitespaces,\n-        templateUrl,\n-        templateUrlExpression: templateUrlExpr,\n-        resolvedTemplateUrl: resourceUrl,\n-        sourceMapUrl: sourceMapUrl(resourceUrl),\n-      };\n+      try {\n+        const resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);\n+        return {\n+          isInline: false,\n+          interpolationConfig,\n+          preserveWhitespaces,\n+          templateUrl,\n+          templateUrlExpression: templateUrlExpr,\n+          resolvedTemplateUrl: resourceUrl,\n+          sourceMapUrl: sourceMapUrl(resourceUrl),\n+        };\n+      } catch (e) {\n+        throw this.makeResourceNotFoundError(\n+            templateUrl, templateUrlExpr, ResourceTypeForDiagnostics.Template);\n+      }\n     } else if (component.has('template')) {\n       return {\n         isInline: true,\n@@ -1260,33 +1278,24 @@ export class ComponentDecoratorHandler implements\n     this.cycleAnalyzer.recordSyntheticImport(origin, imported);\n   }\n \n-  /**\n-   * Resolve the url of a resource relative to the file that contains the reference to it.\n-   *\n-   * Throws a FatalDiagnosticError when unable to resolve the file.\n-   */\n-  private _resolveResourceOrThrow(\n-      file: string, basePath: string, nodeForError: ts.Node,\n-      resourceType: ResourceTypeForDiagnostics): string {\n-    try {\n-      return this.resourceLoader.resolve(file, basePath);\n-    } catch (e) {\n-      let errorText: string;\n-      switch (resourceType) {\n-        case ResourceTypeForDiagnostics.Template:\n-          errorText = `Could not find template file '${file}'.`;\n-          break;\n-        case ResourceTypeForDiagnostics.StylesheetFromTemplate:\n-          errorText = `Could not find stylesheet file '${file}' linked from the template.`;\n-          break;\n-        case ResourceTypeForDiagnostics.StylesheetFromDecorator:\n-          errorText = `Could not find stylesheet file '${file}'.`;\n-          break;\n-      }\n-\n-      throw new FatalDiagnosticError(\n-          ErrorCode.COMPONENT_RESOURCE_NOT_FOUND, nodeForError, errorText);\n+  private makeResourceNotFoundError(\n+      file: string, nodeForError: ts.Node,\n+      resourceType: ResourceTypeForDiagnostics): FatalDiagnosticError {\n+    let errorText: string;\n+    switch (resourceType) {\n+      case ResourceTypeForDiagnostics.Template:\n+        errorText = `Could not find template file '${file}'.`;\n+        break;\n+      case ResourceTypeForDiagnostics.StylesheetFromTemplate:\n+        errorText = `Could not find stylesheet file '${file}' linked from the template.`;\n+        break;\n+      case ResourceTypeForDiagnostics.StylesheetFromDecorator:\n+        errorText = `Could not find stylesheet file '${file}'.`;\n+        break;\n     }\n+\n+    return new FatalDiagnosticError(\n+        ErrorCode.COMPONENT_RESOURCE_NOT_FOUND, nodeForError, errorText);\n   }\n \n   private _extractTemplateStyleUrls(template: ParsedTemplateWithSource): StyleUrlMeta[] {"
        },
        {
            "sha": "9c07fc3457ff473be24223330b3d2619b77c7b69",
            "filename": "packages/language-service/ivy/test/quick_info_spec.ts",
            "status": "modified",
            "additions": 33,
            "deletions": 1,
            "changes": 34,
            "blob_url": "https://github.com/angular/angular/blob/8f12f4749262d113accd1a4a82cbbf603e325ce2/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/8f12f4749262d113accd1a4a82cbbf603e325ce2/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts?ref=8f12f4749262d113accd1a4a82cbbf603e325ce2",
            "patch": "@@ -553,8 +553,40 @@ describe('quick info', () => {\n       expectQuickInfo(\n           {templateOverride, expectedSpanText: 'date', expectedDisplayString: '(pipe) DatePipe'});\n     });\n-  });\n \n+    it('should still get quick info if there is an invalid css resource', () => {\n+      project = env.addProject('test', {\n+        'app.ts': `\n+         import {Component, NgModule} from '@angular/core';\n+\n+         @Component({\n+           selector: 'some-cmp',\n+           templateUrl: './app.html',\n+           styleUrls: ['./does_not_exist'],\n+         })\n+         export class SomeCmp {\n+           myValue!: string;\n+         }\n+\n+         @NgModule({\n+           declarations: [SomeCmp],\n+         })\n+         export class AppModule{\n+         }\n+       `,\n+        'app.html': `{{myValue}}`,\n+      });\n+      const diagnostics = project.getDiagnosticsForFile('app.ts');\n+      expect(diagnostics.length).toBe(1);\n+      expect(diagnostics[0].messageText)\n+          .toEqual(`Could not find stylesheet file './does_not_exist'.`);\n+\n+      const template = project.openFile('app.html');\n+      template.moveCursorToText('{{myVaÂ¦lue}}');\n+      const quickInfo = template.getQuickInfoAtPosition();\n+      expect(toText(quickInfo!.displayParts)).toEqual('(property) SomeCmp.myValue: string');\n+    });\n+  });\n \n   function expectQuickInfo(\n       {templateOverride, expectedSpanText, expectedDisplayString}:"
        }
    ],
    "stats": {
        "total": 233,
        "additions": 137,
        "deletions": 96
    }
}