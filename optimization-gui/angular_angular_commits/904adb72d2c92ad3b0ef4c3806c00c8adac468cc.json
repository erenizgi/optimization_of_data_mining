{
    "author": "atscott",
    "message": "feat(language-service): add quick info for inline templates in ivy (#39060)\n\nAdds implementation for `getQuickInfoAtPosition` to the Ivy Language\nService, which now returns `ts.QuickInfo` for inline templates.\n\nPR Close #39060",
    "sha": "904adb72d2c92ad3b0ef4c3806c00c8adac468cc",
    "files": [
        {
            "sha": "f512182eb60739c3b2c8ecdfd590ad34710572a0",
            "filename": "packages/language-service/ivy/BUILD.bazel",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fivy%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fivy%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2FBUILD.bazel?ref=904adb72d2c92ad3b0ef4c3806c00c8adac468cc",
            "patch": "@@ -15,6 +15,8 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/shims\",\n         \"//packages/compiler-cli/src/ngtsc/typecheck\",\n         \"//packages/compiler-cli/src/ngtsc/typecheck/api\",\n+        # TODO(atscott): Pull functions/variables common to VE and Ivy into a new package\n+        \"//packages/language-service\",\n         \"@npm//typescript\",\n     ],\n )"
        },
        {
            "sha": "b68d3e782a40e3c5a4f883b945358977b7ef85ed",
            "filename": "packages/language-service/ivy/hybrid_visitor.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 18,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fivy%2Fhybrid_visitor.ts",
            "raw_url": "https://github.com/angular/angular/raw/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fivy%2Fhybrid_visitor.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fhybrid_visitor.ts?ref=904adb72d2c92ad3b0ef4c3806c00c8adac468cc",
            "patch": "@@ -10,6 +10,8 @@ import {AbsoluteSourceSpan, ParseSourceSpan} from '@angular/compiler';\n import * as e from '@angular/compiler/src/expression_parser/ast';  // e for expression AST\n import * as t from '@angular/compiler/src/render3/r3_ast';         // t for template AST\n \n+import {isTemplateNode, isTemplateNodeWithKeyAndValue} from './utils';\n+\n /**\n  * Return the template AST node or expression AST node that most accurately\n  * represents the node at the specified cursor `position`.\n@@ -165,24 +167,6 @@ class ExpressionVisitor extends e.RecursiveAstVisitor {\n   }\n }\n \n-export function isTemplateNode(node: t.Node|e.AST): node is t.Node {\n-  // Template node implements the Node interface so we cannot use instanceof.\n-  return node.sourceSpan instanceof ParseSourceSpan;\n-}\n-\n-interface NodeWithKeyAndValue extends t.Node {\n-  keySpan: ParseSourceSpan;\n-  valueSpan?: ParseSourceSpan;\n-}\n-\n-export function isTemplateNodeWithKeyAndValue(node: t.Node|e.AST): node is NodeWithKeyAndValue {\n-  return isTemplateNode(node) && node.hasOwnProperty('keySpan');\n-}\n-\n-export function isExpressionNode(node: t.Node|e.AST): node is e.AST {\n-  return node instanceof e.AST;\n-}\n-\n function getSpanIncludingEndTag(ast: t.Node) {\n   const result = {\n     start: ast.sourceSpan.start.offset,"
        },
        {
            "sha": "a3a828b3315c0e5e0e6aba4bd618dc34ea4f216b",
            "filename": "packages/language-service/ivy/language_service.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "raw_url": "https://github.com/angular/angular/raw/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts?ref=904adb72d2c92ad3b0ef4c3806c00c8adac468cc",
            "patch": "@@ -16,6 +16,8 @@ import {TypeCheckShimGenerator} from '@angular/compiler-cli/src/ngtsc/typecheck'\n import {OptimizeFor, TypeCheckingProgramStrategy} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import * as ts from 'typescript/lib/tsserverlibrary';\n \n+import {QuickInfoBuilder} from './quick_info';\n+\n export class LanguageService {\n   private options: CompilerOptions;\n   private lastKnownProgram: ts.Program|null = null;\n@@ -45,6 +47,12 @@ export class LanguageService {\n     throw new Error('Ivy LS currently does not support external template');\n   }\n \n+  getQuickInfoAtPosition(fileName: string, position: number): ts.QuickInfo|undefined {\n+    const program = this.strategy.getProgram();\n+    const compiler = this.createCompiler(program);\n+    return new QuickInfoBuilder(this.tsLS, compiler).get(fileName, position);\n+  }\n+\n   private createCompiler(program: ts.Program): NgCompiler {\n     return new NgCompiler(\n         this.adapter,"
        },
        {
            "sha": "76ba3b0d403bc4f4870d5b07e2b6f69f17138146",
            "filename": "packages/language-service/ivy/quick_info.ts",
            "status": "added",
            "additions": 237,
            "deletions": 0,
            "changes": 237,
            "blob_url": "https://github.com/angular/angular/blob/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fivy%2Fquick_info.ts",
            "raw_url": "https://github.com/angular/angular/raw/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fivy%2Fquick_info.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fquick_info.ts?ref=904adb72d2c92ad3b0ef4c3806c00c8adac468cc",
            "patch": "@@ -0,0 +1,237 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {AST, BindingPipe, ImplicitReceiver, MethodCall, TmplAstBoundAttribute, TmplAstNode, TmplAstTextAttribute} from '@angular/compiler';\n+import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n+import {DirectiveSymbol, DomBindingSymbol, ElementSymbol, ExpressionSymbol, InputBindingSymbol, OutputBindingSymbol, ReferenceSymbol, ShimLocation, Symbol, SymbolKind, VariableSymbol} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n+import * as ts from 'typescript';\n+\n+import {createQuickInfo, SYMBOL_PUNC, SYMBOL_SPACE, SYMBOL_TEXT} from '../src/hover';\n+\n+import {findNodeAtPosition} from './hybrid_visitor';\n+import {filterAliasImports, getDirectiveMatches, getDirectiveMatchesForAttribute, getTemplateInfoAtPosition, getTextSpanOfNode} from './utils';\n+\n+/**\n+ * The type of Angular directive. Used for QuickInfo in template.\n+ */\n+export enum QuickInfoKind {\n+  COMPONENT = 'component',\n+  DIRECTIVE = 'directive',\n+  EVENT = 'event',\n+  REFERENCE = 'reference',\n+  ELEMENT = 'element',\n+  VARIABLE = 'variable',\n+  PIPE = 'pipe',\n+  PROPERTY = 'property',\n+  METHOD = 'method',\n+  TEMPLATE = 'template',\n+}\n+\n+export class QuickInfoBuilder {\n+  private readonly typeChecker = this.compiler.getNextProgram().getTypeChecker();\n+  constructor(private readonly tsLS: ts.LanguageService, private readonly compiler: NgCompiler) {}\n+\n+  get(fileName: string, position: number): ts.QuickInfo|undefined {\n+    const templateInfo = getTemplateInfoAtPosition(fileName, position, this.compiler);\n+    if (templateInfo === undefined) {\n+      return undefined;\n+    }\n+    const {template, component} = templateInfo;\n+\n+    const node = findNodeAtPosition(template, position);\n+    if (node === undefined) {\n+      return undefined;\n+    }\n+\n+    const symbol = this.compiler.getTemplateTypeChecker().getSymbolOfNode(node, component);\n+    if (symbol === null) {\n+      return isDollarAny(node) ? createDollarAnyQuickInfo(node) : undefined;\n+    }\n+\n+    return this.getQuickInfoForSymbol(symbol, node);\n+  }\n+\n+  private getQuickInfoForSymbol(symbol: Symbol, node: TmplAstNode|AST): ts.QuickInfo|undefined {\n+    switch (symbol.kind) {\n+      case SymbolKind.Input:\n+      case SymbolKind.Output:\n+        return this.getQuickInfoForBindingSymbol(symbol, node);\n+      case SymbolKind.Template:\n+        return createNgTemplateQuickInfo(node);\n+      case SymbolKind.Element:\n+        return this.getQuickInfoForElementSymbol(symbol);\n+      case SymbolKind.Variable:\n+        return this.getQuickInfoForVariableSymbol(symbol, node);\n+      case SymbolKind.Reference:\n+        return this.getQuickInfoForReferenceSymbol(symbol, node);\n+      case SymbolKind.DomBinding:\n+        return this.getQuickInfoForDomBinding(node, symbol);\n+      case SymbolKind.Directive:\n+        return this.getQuickInfoAtShimLocation(symbol.shimLocation, node);\n+      case SymbolKind.Expression:\n+        return node instanceof BindingPipe ?\n+            this.getQuickInfoForPipeSymbol(symbol, node) :\n+            this.getQuickInfoAtShimLocation(symbol.shimLocation, node);\n+    }\n+  }\n+\n+  private getQuickInfoForBindingSymbol(\n+      symbol: InputBindingSymbol|OutputBindingSymbol, node: TmplAstNode|AST): ts.QuickInfo\n+      |undefined {\n+    if (symbol.bindings.length === 0) {\n+      return undefined;\n+    }\n+\n+    const kind = symbol.kind === SymbolKind.Input ? QuickInfoKind.PROPERTY : QuickInfoKind.EVENT;\n+\n+    const quickInfo = this.getQuickInfoAtShimLocation(symbol.bindings[0].shimLocation, node);\n+    return quickInfo === undefined ? undefined : updateQuickInfoKind(quickInfo, kind);\n+  }\n+\n+  private getQuickInfoForElementSymbol(symbol: ElementSymbol): ts.QuickInfo {\n+    const {templateNode} = symbol;\n+    const matches = getDirectiveMatches(symbol.directives, templateNode.name);\n+    if (matches.size > 0) {\n+      return this.getQuickInfoForDirectiveSymbol(matches.values().next().value, templateNode);\n+    }\n+\n+    return createQuickInfo(\n+        templateNode.name, QuickInfoKind.ELEMENT, getTextSpanOfNode(templateNode),\n+        undefined /* containerName */, this.typeChecker.typeToString(symbol.tsType));\n+  }\n+\n+  private getQuickInfoForVariableSymbol(symbol: VariableSymbol, node: TmplAstNode|AST):\n+      ts.QuickInfo {\n+    const documentation = this.getDocumentationFromTypeDefAtLocation(symbol.shimLocation);\n+    return createQuickInfo(\n+        symbol.declaration.name, QuickInfoKind.VARIABLE, getTextSpanOfNode(node),\n+        undefined /* containerName */, this.typeChecker.typeToString(symbol.tsType), documentation);\n+  }\n+\n+  private getQuickInfoForReferenceSymbol(symbol: ReferenceSymbol, node: TmplAstNode|AST):\n+      ts.QuickInfo {\n+    const documentation = this.getDocumentationFromTypeDefAtLocation(symbol.shimLocation);\n+    return createQuickInfo(\n+        symbol.declaration.name, QuickInfoKind.REFERENCE, getTextSpanOfNode(node),\n+        undefined /* containerName */, this.typeChecker.typeToString(symbol.tsType), documentation);\n+  }\n+\n+  private getQuickInfoForPipeSymbol(symbol: ExpressionSymbol, node: TmplAstNode|AST): ts.QuickInfo\n+      |undefined {\n+    const quickInfo = this.getQuickInfoAtShimLocation(symbol.shimLocation, node);\n+    return quickInfo === undefined ? undefined : updateQuickInfoKind(quickInfo, QuickInfoKind.PIPE);\n+  }\n+\n+  private getQuickInfoForDomBinding(node: TmplAstNode|AST, symbol: DomBindingSymbol) {\n+    if (!(node instanceof TmplAstTextAttribute) && !(node instanceof TmplAstBoundAttribute)) {\n+      return undefined;\n+    }\n+    const directives = getDirectiveMatchesForAttribute(\n+        node.name, symbol.host.templateNode, symbol.host.directives);\n+    if (directives.size === 0) {\n+      return undefined;\n+    }\n+\n+    return this.getQuickInfoForDirectiveSymbol(directives.values().next().value, node);\n+  }\n+\n+  private getQuickInfoForDirectiveSymbol(dir: DirectiveSymbol, node: TmplAstNode|AST):\n+      ts.QuickInfo {\n+    const kind = dir.isComponent ? QuickInfoKind.COMPONENT : QuickInfoKind.DIRECTIVE;\n+    const documentation = this.getDocumentationFromTypeDefAtLocation(dir.shimLocation);\n+    return createQuickInfo(\n+        this.typeChecker.typeToString(dir.tsType), kind, getTextSpanOfNode(node),\n+        undefined /* containerName */, undefined, documentation);\n+  }\n+\n+  private getDocumentationFromTypeDefAtLocation(shimLocation: ShimLocation):\n+      ts.SymbolDisplayPart[]|undefined {\n+    const typeDefs = this.tsLS.getTypeDefinitionAtPosition(\n+        shimLocation.shimPath, shimLocation.positionInShimFile);\n+    if (typeDefs === undefined || typeDefs.length === 0) {\n+      return undefined;\n+    }\n+    return this.tsLS.getQuickInfoAtPosition(typeDefs[0].fileName, typeDefs[0].textSpan.start)\n+        ?.documentation;\n+  }\n+\n+  private getQuickInfoAtShimLocation(location: ShimLocation, node: TmplAstNode|AST): ts.QuickInfo\n+      |undefined {\n+    const quickInfo =\n+        this.tsLS.getQuickInfoAtPosition(location.shimPath, location.positionInShimFile);\n+    if (quickInfo === undefined || quickInfo.displayParts === undefined) {\n+      return quickInfo;\n+    }\n+\n+    quickInfo.displayParts = filterAliasImports(quickInfo.displayParts);\n+\n+    const textSpan = getTextSpanOfNode(node);\n+    return {...quickInfo, textSpan};\n+  }\n+}\n+\n+function updateQuickInfoKind(quickInfo: ts.QuickInfo, kind: QuickInfoKind): ts.QuickInfo {\n+  if (quickInfo.displayParts === undefined) {\n+    return quickInfo;\n+  }\n+\n+  const startsWithKind = quickInfo.displayParts.length >= 3 &&\n+      displayPartsEqual(quickInfo.displayParts[0], {text: '(', kind: SYMBOL_PUNC}) &&\n+      quickInfo.displayParts[1].kind === SYMBOL_TEXT &&\n+      displayPartsEqual(quickInfo.displayParts[2], {text: ')', kind: SYMBOL_PUNC});\n+  if (startsWithKind) {\n+    quickInfo.displayParts[1].text = kind;\n+  } else {\n+    quickInfo.displayParts = [\n+      {text: '(', kind: SYMBOL_PUNC},\n+      {text: kind, kind: SYMBOL_TEXT},\n+      {text: ')', kind: SYMBOL_PUNC},\n+      {text: ' ', kind: SYMBOL_SPACE},\n+      ...quickInfo.displayParts,\n+    ];\n+  }\n+  return quickInfo;\n+}\n+\n+function displayPartsEqual(a: {text: string, kind: string}, b: {text: string, kind: string}) {\n+  return a.text === b.text && a.kind === b.kind;\n+}\n+\n+function isDollarAny(node: TmplAstNode|AST): node is MethodCall {\n+  return node instanceof MethodCall && node.receiver instanceof ImplicitReceiver &&\n+      node.name === '$any' && node.args.length === 1;\n+}\n+\n+function createDollarAnyQuickInfo(node: MethodCall): ts.QuickInfo {\n+  return createQuickInfo(\n+      '$any',\n+      QuickInfoKind.METHOD,\n+      getTextSpanOfNode(node),\n+      /** containerName */ undefined,\n+      'any',\n+      [{\n+        kind: SYMBOL_TEXT,\n+        text: 'function to cast an expression to the `any` type',\n+      }],\n+  );\n+}\n+\n+// TODO(atscott): Create special `ts.QuickInfo` for `ng-template` and `ng-container` as well.\n+function createNgTemplateQuickInfo(node: TmplAstNode|AST): ts.QuickInfo {\n+  return createQuickInfo(\n+      'ng-template',\n+      QuickInfoKind.TEMPLATE,\n+      getTextSpanOfNode(node),\n+      /** containerName */ undefined,\n+      /** type */ undefined,\n+      [{\n+        kind: SYMBOL_TEXT,\n+        text:\n+            'The `<ng-template>` is an Angular element for rendering HTML. It is never displayed directly.',\n+      }],\n+  );\n+}"
        },
        {
            "sha": "9d295353564d8d8ef24ae60a74c5d922d916d913",
            "filename": "packages/language-service/ivy/test/hybrid_visitor_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fivy%2Ftest%2Fhybrid_visitor_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fivy%2Ftest%2Fhybrid_visitor_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fhybrid_visitor_spec.ts?ref=904adb72d2c92ad3b0ef4c3806c00c8adac468cc",
            "patch": "@@ -10,7 +10,8 @@ import {ParseError, parseTemplate} from '@angular/compiler';\n import * as e from '@angular/compiler/src/expression_parser/ast';  // e for expression AST\n import * as t from '@angular/compiler/src/render3/r3_ast';         // t for template AST\n \n-import {findNodeAtPosition, isExpressionNode, isTemplateNode} from '../hybrid_visitor';\n+import {findNodeAtPosition} from '../hybrid_visitor';\n+import {isExpressionNode, isTemplateNode} from '../utils';\n \n interface ParseResult {\n   nodes: t.Node[];"
        },
        {
            "sha": "590d986e8ddeecb18d898018be593d04e079d1a3",
            "filename": "packages/language-service/ivy/test/language_service_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fivy%2Ftest%2Flanguage_service_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fivy%2Ftest%2Flanguage_service_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flanguage_service_spec.ts?ref=904adb72d2c92ad3b0ef4c3806c00c8adac468cc",
            "patch": "@@ -17,7 +17,7 @@ describe('parseNgCompilerOptions', () => {\n     const options = parseNgCompilerOptions(project);\n     expect(options).toEqual(jasmine.objectContaining({\n       enableIvy: true,  // default for ivy is true\n-      fullTemplateTypeCheck: true,\n+      strictTemplates: true,\n       strictInjectionParameters: true,\n     }));\n   });"
        },
        {
            "sha": "ac262b78cd0c82a70e379d6b90ff8a9245a7f92a",
            "filename": "packages/language-service/ivy/test/quick_info_spec.ts",
            "status": "added",
            "additions": 393,
            "deletions": 0,
            "changes": 393,
            "blob_url": "https://github.com/angular/angular/blob/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts?ref=904adb72d2c92ad3b0ef4c3806c00c8adac468cc",
            "patch": "@@ -0,0 +1,393 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as ts from 'typescript/lib/tsserverlibrary';\n+\n+import {LanguageService} from '../language_service';\n+\n+import {APP_COMPONENT, setup, TEST_TEMPLATE} from './mock_host';\n+\n+describe('quick info', () => {\n+  const {project, service, tsLS} = setup();\n+  const ngLS = new LanguageService(project, tsLS);\n+\n+  beforeEach(() => {\n+    service.reset();\n+  });\n+\n+  describe('elements', () => {\n+    it('should work for native elements', () => {\n+      expectQuickInfo({\n+        templateOverride: `<butt¦on></button>`,\n+        expectedSpanText: '<button></button>',\n+        expectedDisplayString: '(element) button: HTMLButtonElement'\n+      });\n+    });\n+  });\n+\n+  describe('templates', () => {\n+    it('should return undefined for ng-templates', () => {\n+      const {documentation} = expectQuickInfo({\n+        templateOverride: `<ng-templ¦ate></ng-template>`,\n+        expectedSpanText: '<ng-template></ng-template>',\n+        expectedDisplayString: '(template) ng-template'\n+      });\n+      expect(toText(documentation))\n+          .toContain('The `<ng-template>` is an Angular element for rendering HTML.');\n+    });\n+  });\n+\n+  describe('directives', () => {\n+    it('should work for directives', () => {\n+      expectQuickInfo({\n+        templateOverride: `<div string-model¦></div>`,\n+        expectedSpanText: 'string-model',\n+        // TODO(atscott): Find a way to include the module\n+        // expectedDisplayParts: '(directive) AppModule.StringModel'\n+        expectedDisplayString: '(directive) StringModel'\n+      });\n+    });\n+\n+    it('should work for components', () => {\n+      const {documentation} = expectQuickInfo({\n+        templateOverride: `<t¦est-comp></test-comp>`,\n+        expectedSpanText: '<test-comp></test-comp>',\n+        // TODO(atscott): Find a way to include the module\n+        // expectedDisplayParts: '(component) AppModule.TestComponent'\n+        expectedDisplayString: '(component) TestComponent'\n+      });\n+      expect(toText(documentation)).toBe('This Component provides the `test-comp` selector.');\n+    });\n+\n+    it('should work for structural directives', () => {\n+      const {documentation} = expectQuickInfo({\n+        templateOverride: `<div *¦ngFor=\"let item of heroes\"></div>`,\n+        expectedSpanText: 'ngFor',\n+        expectedDisplayString: '(directive) NgForOf<Hero, Array<Hero>>'\n+      });\n+      expect(toText(documentation))\n+          .toContain('A [structural directive](guide/structural-directives) that renders');\n+    });\n+\n+    it('should work for directives with compound selectors, some of which are bindings', () => {\n+      expectQuickInfo({\n+        templateOverride: `<ng-template ngF¦or let-hero [ngForOf]=\"heroes\">{{item}}</ng-template>`,\n+        expectedSpanText: 'ngFor',\n+        expectedDisplayString: '(directive) NgForOf<Hero, Array<Hero>>'\n+      });\n+    });\n+\n+    it('should work for data-let- syntax', () => {\n+      expectQuickInfo({\n+        templateOverride:\n+            `<ng-template ngFor data-let-he¦ro [ngForOf]=\"heroes\">{{item}}</ng-template>`,\n+        expectedSpanText: 'hero',\n+        expectedDisplayString: '(variable) hero: Hero'\n+      });\n+    });\n+  });\n+\n+  describe('bindings', () => {\n+    describe('inputs', () => {\n+      it('should work for input providers', () => {\n+        expectQuickInfo({\n+          templateOverride: `<test-comp [tcN¦ame]=\"name\"></test-comp>`,\n+          expectedSpanText: 'tcName',\n+          expectedDisplayString: '(property) TestComponent.name: string'\n+        });\n+      });\n+\n+      it('should work for bind- syntax', () => {\n+        expectQuickInfo({\n+          templateOverride: `<test-comp bind-tcN¦ame=\"name\"></test-comp>`,\n+          expectedSpanText: 'tcName',\n+          expectedDisplayString: '(property) TestComponent.name: string'\n+        });\n+        expectQuickInfo({\n+          templateOverride: `<test-comp data-bind-tcN¦ame=\"name\"></test-comp>`,\n+          expectedSpanText: 'tcName',\n+          expectedDisplayString: '(property) TestComponent.name: string'\n+        });\n+      });\n+\n+      it('should work for structural directive inputs ngForTrackBy', () => {\n+        expectQuickInfo({\n+          templateOverride: `<div *ngFor=\"let item of heroes; tr¦ackBy: test;\"></div>`,\n+          expectedSpanText: 'trackBy',\n+          expectedDisplayString:\n+              '(property) NgForOf<Hero, Hero[]>.ngForTrackBy: TrackByFunction<Hero>'\n+        });\n+      });\n+\n+      it('should work for structural directive inputs ngForOf', () => {\n+        expectQuickInfo({\n+          templateOverride: `<div *ngFor=\"let item o¦f heroes; trackBy: test;\"></div>`,\n+          expectedSpanText: 'of',\n+          expectedDisplayString:\n+              '(property) NgForOf<Hero, Hero[]>.ngForOf: Hero[] | (Hero[] & Iterable<Hero>) | null | undefined'\n+        });\n+      });\n+\n+      it('should work for two-way binding providers', () => {\n+        expectQuickInfo({\n+          templateOverride: `<test-comp string-model [(mo¦del)]=\"title\"></test-comp>`,\n+          expectedSpanText: 'model',\n+          expectedDisplayString: '(property) StringModel.model: string'\n+        });\n+      });\n+    });\n+\n+    describe('outputs', () => {\n+      it('should work for event providers', () => {\n+        expectQuickInfo({\n+          templateOverride: `<test-comp (te¦st)=\"myClick($event)\"></test-comp>`,\n+          expectedSpanText: '(test)=\"myClick($event)\"',\n+          expectedDisplayString: '(event) TestComponent.testEvent: EventEmitter<any>'\n+        });\n+      });\n+\n+      it('should work for on- syntax binding', () => {\n+        expectQuickInfo({\n+          templateOverride: `<test-comp on-te¦st=\"myClick($event)\"></test-comp>`,\n+          expectedSpanText: 'on-test=\"myClick($event)\"',\n+          expectedDisplayString: '(event) TestComponent.testEvent: EventEmitter<any>'\n+        });\n+        expectQuickInfo({\n+          templateOverride: `<test-comp data-on-te¦st=\"myClick($event)\"></test-comp>`,\n+          expectedSpanText: 'data-on-test=\"myClick($event)\"',\n+          expectedDisplayString: '(event) TestComponent.testEvent: EventEmitter<any>'\n+        });\n+      });\n+\n+      it('should work for $event from EventEmitter', () => {\n+        expectQuickInfo({\n+          templateOverride: `<div string-model (modelChange)=\"myClick($e¦vent)\"></div>`,\n+          expectedSpanText: '$event',\n+          expectedDisplayString: '(parameter) $event: string'\n+        });\n+      });\n+\n+      it('should work for $event from native element', () => {\n+        expectQuickInfo({\n+          templateOverride: `<div (click)=\"myClick($e¦vent)\"></div>`,\n+          expectedSpanText: '$event',\n+          expectedDisplayString: '(parameter) $event: MouseEvent'\n+        });\n+      });\n+    });\n+  });\n+\n+  describe('references', () => {\n+    it('should work for element reference declarations', () => {\n+      const {documentation} = expectQuickInfo({\n+        templateOverride: `<div #¦chart></div>`,\n+        expectedSpanText: '#chart',\n+        expectedDisplayString: '(reference) chart: HTMLDivElement'\n+      });\n+      expect(toText(documentation))\n+          .toEqual(\n+              'Provides special properties (beyond the regular HTMLElement ' +\n+              'interface it also has available to it by inheritance) for manipulating <div> elements.');\n+    });\n+\n+    it('should work for ref- syntax', () => {\n+      expectQuickInfo({\n+        templateOverride: `<div ref-ch¦art></div>`,\n+        expectedSpanText: 'ref-chart',\n+        expectedDisplayString: '(reference) chart: HTMLDivElement'\n+      });\n+      expectQuickInfo({\n+        templateOverride: `<div data-ref-ch¦art></div>`,\n+        expectedSpanText: 'data-ref-chart',\n+        expectedDisplayString: '(reference) chart: HTMLDivElement'\n+      });\n+    });\n+  });\n+\n+  describe('variables', () => {\n+    it('should work for array members', () => {\n+      const {documentation} = expectQuickInfo({\n+        templateOverride: `<div *ngFor=\"let hero of heroes\">{{her¦o}}</div>`,\n+        expectedSpanText: 'hero',\n+        expectedDisplayString: '(variable) hero: Hero'\n+      });\n+      expect(toText(documentation)).toEqual('The most heroic being.');\n+    });\n+\n+    it('should work for ReadonlyArray members (#36191)', () => {\n+      expectQuickInfo({\n+        templateOverride: `<div *ngFor=\"let hero of readonlyHeroes\">{{her¦o}}</div>`,\n+        expectedSpanText: 'hero',\n+        expectedDisplayString: '(variable) hero: Readonly<Hero>'\n+      });\n+    });\n+\n+    it('should work for const array members (#36191)', () => {\n+      expectQuickInfo({\n+        templateOverride: `<div *ngFor=\"let name of constNames\">{{na¦me}}</div>`,\n+        expectedSpanText: 'name',\n+        expectedDisplayString: '(variable) name: { readonly name: \"name\"; }'\n+      });\n+    });\n+  });\n+\n+  describe('pipes', () => {\n+    it('should work for pipes', () => {\n+      const templateOverride = `<p>The hero's birthday is {{birthday | da¦te: \"MM/dd/yy\"}}</p>`;\n+      expectQuickInfo({\n+        templateOverride,\n+        expectedSpanText: 'date',\n+        expectedDisplayString:\n+            '(pipe) DatePipe.transform(value: string | number | Date, format?: string | undefined, timezone?: ' +\n+            'string | undefined, locale?: string | undefined): string | null (+2 overloads)'\n+      });\n+    });\n+  });\n+\n+  describe('expressions', () => {\n+    it('should find members in a text interpolation', () => {\n+      expectQuickInfo({\n+        templateOverride: `<div>{{ tit¦le }}</div>`,\n+        expectedSpanText: 'title',\n+        expectedDisplayString: '(property) AppComponent.title: string'\n+      });\n+    });\n+\n+    it('should work for accessed property reads', () => {\n+      expectQuickInfo({\n+        templateOverride: `<div>{{title.len¦gth}}</div>`,\n+        expectedSpanText: 'length',\n+        expectedDisplayString: '(property) String.length: number'\n+      });\n+    });\n+\n+    it('should find members in an attribute interpolation', () => {\n+      expectQuickInfo({\n+        templateOverride: `<div string-model model=\"{{tit¦le}}\"></div>`,\n+        expectedSpanText: 'title',\n+        expectedDisplayString: '(property) AppComponent.title: string'\n+      });\n+    });\n+\n+    it('should find members of input binding', () => {\n+      expectQuickInfo({\n+        templateOverride: `<test-comp [tcName]=\"ti¦tle\"></test-comp>`,\n+        expectedSpanText: 'title',\n+        expectedDisplayString: '(property) AppComponent.title: string'\n+      });\n+    });\n+\n+    it('should find input binding on text attribute', () => {\n+      expectQuickInfo({\n+        templateOverride: `<test-comp tcN¦ame=\"title\"></test-comp>`,\n+        expectedSpanText: 'tcName=\"title\"',\n+        expectedDisplayString: '(property) TestComponent.name: string'\n+      });\n+    });\n+\n+    it('should find members of event binding', () => {\n+      expectQuickInfo({\n+        templateOverride: `<test-comp (test)=\"ti¦tle=$event\"></test-comp>`,\n+        expectedSpanText: 'title',\n+        expectedDisplayString: '(property) AppComponent.title: string'\n+      });\n+    });\n+\n+    it('should work for method calls', () => {\n+      expectQuickInfo({\n+        templateOverride: `<div (click)=\"setT¦itle('title')\"></div>`,\n+        expectedSpanText: 'setTitle',\n+        expectedDisplayString: '(method) AppComponent.setTitle(newTitle: string): void'\n+      });\n+    });\n+\n+    it('should work for accessed properties in writes', () => {\n+      expectQuickInfo({\n+        templateOverride: `<div (click)=\"hero.i¦d = 2\"></div>`,\n+        expectedSpanText: 'id',\n+        expectedDisplayString: '(property) Hero.id: number'\n+      });\n+    });\n+\n+    it('should work for method call arguments', () => {\n+      expectQuickInfo({\n+        templateOverride: `<div (click)=\"setTitle(hero.nam¦e)\"></div>`,\n+        expectedSpanText: 'name',\n+        expectedDisplayString: '(property) Hero.name: string'\n+      });\n+    });\n+\n+    it('should find members of two-way binding', () => {\n+      expectQuickInfo({\n+        templateOverride: `<input [(ngModel)]=\"ti¦tle\" />`,\n+        expectedSpanText: 'title',\n+        expectedDisplayString: '(property) AppComponent.title: string'\n+      });\n+    });\n+\n+    it('should find members in a structural directive', () => {\n+      expectQuickInfo({\n+        templateOverride: `<div *ngIf=\"anyV¦alue\"></div>`,\n+        expectedSpanText: 'anyValue',\n+        expectedDisplayString: '(property) AppComponent.anyValue: any'\n+      });\n+    });\n+\n+    it('should work for members in structural directives', () => {\n+      expectQuickInfo({\n+        templateOverride: `<div *ngFor=\"let item of her¦oes; trackBy: test;\"></div>`,\n+        expectedSpanText: 'heroes',\n+        expectedDisplayString: '(property) AppComponent.heroes: Hero[]'\n+      });\n+    });\n+\n+    it('should work for the $any() cast function', () => {\n+      expectQuickInfo({\n+        templateOverride: `<div>{{$an¦y(title)}}</div>`,\n+        expectedSpanText: '$any',\n+        expectedDisplayString: '(method) $any: any'\n+      });\n+    });\n+\n+    it('should provide documentation', () => {\n+      const {position} = service.overwriteInlineTemplate(APP_COMPONENT, `<div>{{¦title}}</div>`);\n+      const quickInfo = ngLS.getQuickInfoAtPosition(APP_COMPONENT, position);\n+      const documentation = toText(quickInfo!.documentation);\n+      expect(documentation).toBe('This is the title of the `AppComponent` Component.');\n+    });\n+\n+    // TODO(atscott): Enable once #39065 is merged\n+    xit('works with external template', () => {\n+      const {position, text} = service.overwrite(TEST_TEMPLATE, '<butt¦on></button>');\n+      const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, position);\n+      expect(quickInfo).toBeTruthy();\n+      const {textSpan, displayParts} = quickInfo!;\n+      expect(text.substring(textSpan.start, textSpan.start + textSpan.length))\n+          .toEqual('<button></button>');\n+      expect(toText(displayParts)).toEqual('(element) button: HTMLButtonElement');\n+    });\n+  });\n+\n+  function expectQuickInfo(\n+      {templateOverride, expectedSpanText, expectedDisplayString}:\n+          {templateOverride: string, expectedSpanText: string, expectedDisplayString: string}):\n+      ts.QuickInfo {\n+    const {position, text} = service.overwriteInlineTemplate(APP_COMPONENT, templateOverride);\n+    const quickInfo = ngLS.getQuickInfoAtPosition(APP_COMPONENT, position);\n+    expect(quickInfo).toBeTruthy();\n+    const {textSpan, displayParts} = quickInfo!;\n+    expect(text.substring(textSpan.start, textSpan.start + textSpan.length))\n+        .toEqual(expectedSpanText);\n+    expect(toText(displayParts)).toEqual(expectedDisplayString);\n+    return quickInfo!;\n+  }\n+});\n+\n+function toText(displayParts?: ts.SymbolDisplayPart[]): string {\n+  return (displayParts || []).map(p => p.text).join('');\n+}"
        },
        {
            "sha": "67941a779640c2b1dfc4c13afb8e569c1b7155b1",
            "filename": "packages/language-service/ivy/ts_plugin.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fivy%2Fts_plugin.ts",
            "raw_url": "https://github.com/angular/angular/raw/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fivy%2Fts_plugin.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fts_plugin.ts?ref=904adb72d2c92ad3b0ef4c3806c00c8adac468cc",
            "patch": "@@ -28,9 +28,20 @@ export function create(info: ts.server.PluginCreateInfo): ts.LanguageService {\n     return undefined;\n   }\n \n+  function getQuickInfoAtPosition(fileName: string, position: number): ts.QuickInfo|undefined {\n+    if (angularOnly) {\n+      return ngLS.getQuickInfoAtPosition(fileName, position);\n+    } else {\n+      // If TS could answer the query, then return that result. Otherwise, return from Angular LS.\n+      return tsLS.getQuickInfoAtPosition(fileName, position) ??\n+          ngLS.getQuickInfoAtPosition(fileName, position);\n+    }\n+  }\n+\n   return {\n     ...tsLS,\n     getSemanticDiagnostics,\n     getTypeDefinitionAtPosition,\n+    getQuickInfoAtPosition,\n   };\n }"
        },
        {
            "sha": "a2ad10423da4c0444737dbc091f27b047a88893f",
            "filename": "packages/language-service/ivy/utils.ts",
            "status": "added",
            "additions": 228,
            "deletions": 0,
            "changes": 228,
            "blob_url": "https://github.com/angular/angular/blob/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Futils.ts?ref=904adb72d2c92ad3b0ef4c3806c00c8adac468cc",
            "patch": "@@ -0,0 +1,228 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {AbsoluteSourceSpan, CssSelector, ParseSourceSpan, SelectorMatcher} from '@angular/compiler';\n+import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n+import {DirectiveSymbol} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n+import * as e from '@angular/compiler/src/expression_parser/ast';  // e for expression AST\n+import * as t from '@angular/compiler/src/render3/r3_ast';         // t for template AST\n+import * as ts from 'typescript';\n+\n+import {ALIAS_NAME, SYMBOL_PUNC} from '../src/hover';\n+\n+/**\n+ * Given a list of directives and a text to use as a selector, returns the directives which match\n+ * for the selector.\n+ */\n+export function getDirectiveMatches(\n+    directives: DirectiveSymbol[], selector: string): Set<DirectiveSymbol> {\n+  const selectorToMatch = CssSelector.parse(selector);\n+  if (selectorToMatch.length === 0) {\n+    return new Set();\n+  }\n+  return new Set(directives.filter((dir: DirectiveSymbol) => {\n+    if (dir.selector === null) {\n+      return false;\n+    }\n+\n+    const matcher = new SelectorMatcher();\n+    matcher.addSelectables(CssSelector.parse(dir.selector));\n+\n+    return matcher.match(selectorToMatch[0], null);\n+  }));\n+}\n+\n+export function getTextSpanOfNode(node: t.Node|e.AST): ts.TextSpan {\n+  if (isTemplateNodeWithKeyAndValue(node)) {\n+    return toTextSpan(node.keySpan);\n+  } else if (\n+      node instanceof e.PropertyWrite || node instanceof e.MethodCall ||\n+      node instanceof e.BindingPipe || node instanceof e.PropertyRead) {\n+    // The `name` part of a `PropertyWrite`, `MethodCall`, and `BindingPipe` does not\n+    // have its own AST so there is no way to retrieve a `Symbol` for just the `name` via a specific\n+    // node.\n+    return toTextSpan(node.nameSpan);\n+  } else {\n+    return toTextSpan(node.sourceSpan);\n+  }\n+}\n+\n+export function toTextSpan(span: AbsoluteSourceSpan|ParseSourceSpan): ts.TextSpan {\n+  let start: number, end: number;\n+  if (span instanceof AbsoluteSourceSpan) {\n+    start = span.start;\n+    end = span.end;\n+  } else {\n+    start = span.start.offset;\n+    end = span.end.offset;\n+  }\n+  return {start, length: end - start};\n+}\n+\n+interface NodeWithKeyAndValue extends t.Node {\n+  keySpan: ParseSourceSpan;\n+  valueSpan?: ParseSourceSpan;\n+}\n+\n+export function isTemplateNodeWithKeyAndValue(node: t.Node|e.AST): node is NodeWithKeyAndValue {\n+  return isTemplateNode(node) && node.hasOwnProperty('keySpan');\n+}\n+\n+export function isTemplateNode(node: t.Node|e.AST): node is t.Node {\n+  // Template node implements the Node interface so we cannot use instanceof.\n+  return node.sourceSpan instanceof ParseSourceSpan;\n+}\n+\n+export function isExpressionNode(node: t.Node|e.AST): node is e.AST {\n+  return node instanceof e.AST;\n+}\n+\n+export interface TemplateInfo {\n+  template: t.Node[];\n+  component: ts.ClassDeclaration;\n+}\n+\n+/**\n+ * Retrieves the `ts.ClassDeclaration` at a location along with its template nodes.\n+ */\n+export function getTemplateInfoAtPosition(\n+    fileName: string, position: number, compiler: NgCompiler): TemplateInfo|undefined {\n+  if (fileName.endsWith('.ts')) {\n+    return getInlineTemplateInfoAtPosition(fileName, position, compiler);\n+  } else {\n+    return getFirstComponentForTemplateFile(fileName, compiler);\n+  }\n+}\n+\n+\n+/**\n+ * First, attempt to sort component declarations by file name.\n+ * If the files are the same, sort by start location of the declaration.\n+ */\n+function tsDeclarationSortComparator(a: ts.Declaration, b: ts.Declaration): number {\n+  const aFile = a.getSourceFile().fileName;\n+  const bFile = b.getSourceFile().fileName;\n+  if (aFile < bFile) {\n+    return -1;\n+  } else if (aFile > bFile) {\n+    return 1;\n+  } else {\n+    return b.getFullStart() - a.getFullStart();\n+  }\n+}\n+\n+function getFirstComponentForTemplateFile(fileName: string, compiler: NgCompiler): TemplateInfo|\n+    undefined {\n+  const templateTypeChecker = compiler.getTemplateTypeChecker();\n+  const components = compiler.getComponentsWithTemplateFile(fileName);\n+  const sortedComponents = Array.from(components).sort(tsDeclarationSortComparator);\n+  for (const component of sortedComponents) {\n+    if (!ts.isClassDeclaration(component)) {\n+      continue;\n+    }\n+    const template = templateTypeChecker.getTemplate(component);\n+    if (template === null) {\n+      continue;\n+    }\n+    return {template, component};\n+  }\n+\n+  return undefined;\n+}\n+\n+/**\n+ * Retrieves the `ts.ClassDeclaration` at a location along with its template nodes.\n+ */\n+function getInlineTemplateInfoAtPosition(\n+    fileName: string, position: number, compiler: NgCompiler): TemplateInfo|undefined {\n+  const sourceFile = compiler.getNextProgram().getSourceFile(fileName);\n+  if (!sourceFile) {\n+    return undefined;\n+  }\n+\n+  // We only support top level statements / class declarations\n+  for (const statement of sourceFile.statements) {\n+    if (!ts.isClassDeclaration(statement) || position < statement.pos || position > statement.end) {\n+      continue;\n+    }\n+\n+    const template = compiler.getTemplateTypeChecker().getTemplate(statement);\n+    if (template === null) {\n+      return undefined;\n+    }\n+\n+    return {template, component: statement};\n+  }\n+\n+  return undefined;\n+}\n+\n+/**\n+ * Given an attribute name and the element or template the attribute appears on, determines which\n+ * directives match because the attribute is present. That is, we find which directives are applied\n+ * because of this attribute by elimination: compare the directive matches with the attribute\n+ * present against the directive matches without it. The difference would be the directives which\n+ * match because the attribute is present.\n+ *\n+ * @param attribute The attribute name to use for directive matching.\n+ * @param hostNode The element or template node that the attribute is on.\n+ * @param directives The list of directives to match against.\n+ * @returns The list of directives matching the attribute via the strategy described above.\n+ */\n+export function getDirectiveMatchesForAttribute(\n+    attribute: string, hostNode: t.Template|t.Element,\n+    directives: DirectiveSymbol[]): Set<DirectiveSymbol> {\n+  const attributes: Array<t.TextAttribute|t.BoundAttribute> =\n+      [...hostNode.attributes, ...hostNode.inputs];\n+  if (hostNode instanceof t.Template) {\n+    attributes.push(...hostNode.templateAttrs);\n+  }\n+  function toAttributeString(a: t.TextAttribute|t.BoundAttribute) {\n+    return `[${a.name}=${a.valueSpan?.toString() ?? ''}]`;\n+  }\n+  const attrs = attributes.map(toAttributeString);\n+  const attrsOmit = attributes.map(a => a.name === attribute ? '' : toAttributeString(a));\n+\n+  const hostNodeName = hostNode instanceof t.Template ? hostNode.tagName : hostNode.name;\n+  const directivesWithAttribute = getDirectiveMatches(directives, hostNodeName + attrs.join(''));\n+  const directivesWithoutAttribute =\n+      getDirectiveMatches(directives, hostNodeName + attrsOmit.join(''));\n+\n+  const result = new Set<DirectiveSymbol>();\n+  for (const dir of directivesWithAttribute) {\n+    if (!directivesWithoutAttribute.has(dir)) {\n+      result.add(dir);\n+    }\n+  }\n+  return result;\n+}\n+\n+/**\n+ * Returns a new `ts.SymbolDisplayPart` array which has the alias imports from the tcb filtered\n+ * out, i.e. `i0.NgForOf`.\n+ */\n+export function filterAliasImports(displayParts: ts.SymbolDisplayPart[]): ts.SymbolDisplayPart[] {\n+  const tcbAliasImportRegex = /i\\d+/;\n+  function isImportAlias(part: {kind: string, text: string}) {\n+    return part.kind === ALIAS_NAME && tcbAliasImportRegex.test(part.text);\n+  }\n+  function isDotPunctuation(part: {kind: string, text: string}) {\n+    return part.kind === SYMBOL_PUNC && part.text === '.';\n+  }\n+\n+  return displayParts.filter((part, i) => {\n+    const previousPart = displayParts[i - 1];\n+    const nextPart = displayParts[i + 1];\n+\n+    const aliasNameFollowedByDot =\n+        isImportAlias(part) && nextPart !== undefined && isDotPunctuation(nextPart);\n+    const dotPrecededByAlias =\n+        isDotPunctuation(part) && previousPart !== undefined && isImportAlias(previousPart);\n+\n+    return !aliasNameFollowedByDot && !dotPrecededByAlias;\n+  });\n+}"
        },
        {
            "sha": "781d06d2b9dadf9451b5e80f49caa34b299c91c1",
            "filename": "packages/language-service/src/hover.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fsrc%2Fhover.ts",
            "raw_url": "https://github.com/angular/angular/raw/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Fsrc%2Fhover.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Fhover.ts?ref=904adb72d2c92ad3b0ef4c3806c00c8adac468cc",
            "patch": "@@ -13,10 +13,11 @@ import * as ng from './types';\n import {inSpan} from './utils';\n \n // Reverse mappings of enum would generate strings\n-const SYMBOL_SPACE = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.space];\n-const SYMBOL_PUNC = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.punctuation];\n-const SYMBOL_TEXT = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.text];\n-const SYMBOL_INTERFACE = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.interfaceName];\n+export const SYMBOL_SPACE = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.space];\n+export const SYMBOL_PUNC = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.punctuation];\n+export const SYMBOL_TEXT = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.text];\n+export const SYMBOL_INTERFACE = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.interfaceName];\n+export const ALIAS_NAME = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.aliasName];\n \n /**\n  * Traverse the template AST and look for the symbol located at `position`, then\n@@ -80,7 +81,7 @@ export function getTsHover(\n  * @param type user-friendly name of the type\n  * @param documentation docstring or comment\n  */\n-function createQuickInfo(\n+export function createQuickInfo(\n     name: string, kind: string, textSpan: ts.TextSpan, containerName?: string, type?: string,\n     documentation?: ts.SymbolDisplayPart[]): ts.QuickInfo {\n   const containerDisplayParts = containerName ?"
        },
        {
            "sha": "36bd6f7771f73c4d41a00183b991470b7d8f8a49",
            "filename": "packages/language-service/test/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2FBUILD.bazel?ref=904adb72d2c92ad3b0ef4c3806c00c8adac468cc",
            "patch": "@@ -13,6 +13,7 @@ ts_library(\n     srcs = [\n         \"test_utils.ts\",\n     ],\n+    visibility = [\"//packages/language-service:__subpackages__\"],\n     deps = [\n         \"//packages/compiler\",\n         \"//packages/compiler-cli/test:test_utils\","
        },
        {
            "sha": "be758449b5e6d4546295c6f3c23cbbe03d21da10",
            "filename": "packages/language-service/test/project/tsconfig.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Ftest%2Fproject%2Ftsconfig.json",
            "raw_url": "https://github.com/angular/angular/raw/904adb72d2c92ad3b0ef4c3806c00c8adac468cc/packages%2Flanguage-service%2Ftest%2Fproject%2Ftsconfig.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fproject%2Ftsconfig.json?ref=904adb72d2c92ad3b0ef4c3806c00c8adac468cc",
            "patch": "@@ -12,7 +12,7 @@\n     }\n   },\n   \"angularCompilerOptions\": {\n-    \"fullTemplateTypeCheck\": true,\n+    \"strictTemplates\": true,\n     \"strictInjectionParameters\": true\n   }\n }"
        }
    ],
    "stats": {
        "total": 918,
        "additions": 892,
        "deletions": 26
    }
}