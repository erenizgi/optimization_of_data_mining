{
    "author": "ivanwonder",
    "message": "fix(language-service): revert the test files for Ivy (#44528)\n\nThe `completions_spec` and `definitions_spec` is removed by accident\nin [bb9ff60](https://github.com/angular/angular/commit/bb9ff6003c620b3cf00232189d60097395382802)\n\nPR Close #44528",
    "sha": "756761d53418d2d4849d4c13b5dd067aa1a6a289",
    "files": [
        {
            "sha": "d4d4a300c86093a63102667f21498de07dcc6535",
            "filename": "packages/language-service/test/completions_spec.ts",
            "status": "added",
            "additions": 1243,
            "deletions": 0,
            "changes": 1243,
            "blob_url": "https://github.com/angular/angular/blob/756761d53418d2d4849d4c13b5dd067aa1a6a289/packages%2Flanguage-service%2Ftest%2Fcompletions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/756761d53418d2d4849d4c13b5dd067aa1a6a289/packages%2Flanguage-service%2Ftest%2Fcompletions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fcompletions_spec.ts?ref=756761d53418d2d4849d4c13b5dd067aa1a6a289",
            "patch": "@@ -0,0 +1,1243 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+import ts from 'typescript';\n+\n+import {DisplayInfoKind, unsafeCastDisplayInfoKindToScriptElementKind} from '../src/display_parts';\n+import {LanguageServiceTestEnv, OpenBuffer} from '../testing';\n+\n+const DIR_WITH_INPUT = {\n+  'Dir': `\n+     @Directive({\n+       selector: '[dir]',\n+       inputs: ['myInput']\n+     })\n+     export class Dir {\n+       myInput!: string;\n+     }\n+   `\n+};\n+\n+const DIR_WITH_UNION_TYPE_INPUT = {\n+  'Dir': `\n+     @Directive({\n+       selector: '[dir]',\n+       inputs: ['myInput']\n+     })\n+     export class Dir {\n+       myInput!: 'foo'|42|null|undefined\n+     }\n+   `\n+};\n+\n+const DIR_WITH_OUTPUT = {\n+  'Dir': `\n+     @Directive({\n+       selector: '[dir]',\n+       outputs: ['myOutput']\n+     })\n+     export class Dir {\n+       myInput!: any;\n+     }\n+   `\n+};\n+\n+const CUSTOM_BUTTON = {\n+  'Button': `\n+     @Directive({\n+       selector: 'button[mat-button]',\n+       inputs: ['color']\n+     })\n+     export class Button {\n+       color!: any;\n+     }\n+   `\n+};\n+\n+const DIR_WITH_TWO_WAY_BINDING = {\n+  'Dir': `\n+     @Directive({\n+       selector: '[dir]',\n+       inputs: ['model', 'otherInput'],\n+       outputs: ['modelChange', 'otherOutput'],\n+     })\n+     export class Dir {\n+       model!: any;\n+       modelChange!: any;\n+       otherInput!: any;\n+       otherOutput!: any;\n+     }\n+   `\n+};\n+\n+const DIR_WITH_BINDING_PROPERTY_NAME = {\n+  'Dir': `\n+     @Directive({\n+       selector: '[dir]',\n+       inputs: ['model: customModel'],\n+       outputs: ['update: customModelChange'],\n+     })\n+     export class Dir {\n+       model!: any;\n+       update!: any;\n+     }\n+   `\n+};\n+\n+const NG_FOR_DIR = {\n+  'NgFor': `\n+     @Directive({\n+       selector: '[ngFor][ngForOf]',\n+     })\n+     export class NgFor {\n+       constructor(ref: TemplateRef<any>) {}\n+ \n+       ngForOf!: any;\n+     }\n+   `\n+};\n+\n+const DIR_WITH_SELECTED_INPUT = {\n+  'Dir': `\n+     @Directive({\n+       selector: '[myInput]',\n+       inputs: ['myInput']\n+     })\n+     export class Dir {\n+       myInput!: string;\n+     }\n+   `\n+};\n+\n+const SOME_PIPE = {\n+  'SomePipe': `\n+     @Pipe({\n+       name: 'somePipe',\n+     })\n+     export class SomePipe {\n+       transform(value: string): string {\n+         return value;\n+       }\n+     }\n+    `\n+};\n+\n+const UNION_TYPE_PIPE = {\n+  'UnionTypePipe': `\n+     @Pipe({\n+       name: 'unionTypePipe',\n+     })\n+     export class UnionTypePipe {\n+       transform(value: string, config: 'foo' | 'bar'): string {\n+         return value;\n+       }\n+     }\n+    `\n+};\n+\n+describe('completions', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  describe('in the global scope', () => {\n+    it('should be able to complete an interpolation', () => {\n+      const {templateFile} = setup('{{ti}}', `title!: string; hero!: number;`);\n+      templateFile.moveCursorToText('{{ti¦}}');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title', 'hero']);\n+    });\n+\n+    it('should be able to complete an empty interpolation', () => {\n+      const {templateFile} = setup('{{  }}', `title!: string; hero!52: number;`);\n+      templateFile.moveCursorToText('{{ ¦ }}');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title', 'hero']);\n+    });\n+\n+    it('should be able to complete a property binding', () => {\n+      const {templateFile} = setup('<h1 [model]=\"ti\"></h1>', `title!: string; hero!: number;`);\n+      templateFile.moveCursorToText('\"ti¦');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title', 'hero']);\n+    });\n+\n+    it('should be able to complete an empty property binding', () => {\n+      const {templateFile} = setup('<h1 [model]=\"\"></h1>', `title!: string; hero!: number;`);\n+      templateFile.moveCursorToText('[model]=\"¦\"');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title', 'hero']);\n+    });\n+\n+    it('should be able to retrieve details for completions', () => {\n+      const {templateFile} = setup('{{ti}}', `\n+         /** This is the title of the 'AppCmp' Component. */\n+         title!: string;\n+         /** This comment should not appear in the output of this test. */\n+         hero!: number;\n+       `);\n+      templateFile.moveCursorToText('{{ti¦}}');\n+      const details = templateFile.getCompletionEntryDetails(\n+          'title', /* formatOptions */ undefined,\n+          /* preferences */ undefined)!;\n+      expect(details).toBeDefined();\n+      expect(toText(details.displayParts)).toEqual('(property) AppCmp.title: string');\n+      expect(toText(details.documentation))\n+          .toEqual('This is the title of the \\'AppCmp\\' Component.');\n+    });\n+\n+    it('should return reference completions when available', () => {\n+      const {templateFile} = setup(`<div #todo></div>{{t}}`, `title!: string;`);\n+      templateFile.moveCursorToText('{{t¦}}');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title']);\n+      expectContain(completions, DisplayInfoKind.REFERENCE, ['todo']);\n+    });\n+\n+    it('should return variable completions when available', () => {\n+      const {templateFile} = setup(\n+          `<div *ngFor=\"let hero of heroes\">\n+             {{h}}\n+           </div>\n+         `,\n+          `heroes!: {name: string}[];`);\n+      templateFile.moveCursorToText('{{h¦}}');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['heroes']);\n+      expectContain(completions, DisplayInfoKind.VARIABLE, ['hero']);\n+    });\n+\n+    it('should return completions inside an event binding', () => {\n+      const {templateFile} = setup(`<button (click)='t'></button>`, `title!: string;`);\n+      templateFile.moveCursorToText(`(click)='t¦'`);\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title']);\n+    });\n+\n+    it('should return completions inside an empty event binding', () => {\n+      const {templateFile} = setup(`<button (click)=''></button>`, `title!: string;`);\n+      templateFile.moveCursorToText(`(click)='¦'`);\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title']);\n+    });\n+\n+    it('should return completions inside the RHS of a two-way binding', () => {\n+      const {templateFile} = setup(`<h1 [(model)]=\"t\"></h1>`, `title!: string;`);\n+      templateFile.moveCursorToText('[(model)]=\"t¦\"');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title']);\n+    });\n+\n+    it('should return completions inside an empty RHS of a two-way binding', () => {\n+      const {templateFile} = setup(`<h1 [(model)]=\"\"></h1>`, `title!: string;`);\n+      templateFile.moveCursorToText('[(model)]=\"¦\"');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title']);\n+    });\n+\n+    it('should return completions of string literals, number literals, `true`, `false`, `null` and `undefined`',\n+       () => {\n+         const {templateFile} = setup(`<input dir [myInput]=\"\">`, '', DIR_WITH_UNION_TYPE_INPUT);\n+         templateFile.moveCursorToText('dir [myInput]=\"¦\">');\n+\n+         const completions = templateFile.getCompletionsAtPosition();\n+         expectContain(completions, ts.ScriptElementKind.string, [`'foo'`, '42']);\n+         expectContain(completions, ts.ScriptElementKind.keyword, ['null']);\n+         expectContain(completions, ts.ScriptElementKind.variableElement, ['undefined']);\n+         expectDoesNotContain(completions, ts.ScriptElementKind.parameterElement, ['ctx']);\n+       });\n+\n+    it('should return completions of string literals, number literals, `true`, `false`, `null` and `undefined` when the user tries to modify the symbol',\n+       () => {\n+         const {templateFile} = setup(`<input dir [myInput]=\"a\">`, '', DIR_WITH_UNION_TYPE_INPUT);\n+         templateFile.moveCursorToText('dir [myInput]=\"a¦\">');\n+\n+         const completions = templateFile.getCompletionsAtPosition();\n+         expectContain(completions, ts.ScriptElementKind.string, [`'foo'`, '42']);\n+         expectContain(completions, ts.ScriptElementKind.keyword, ['null']);\n+         expectContain(completions, ts.ScriptElementKind.variableElement, ['undefined']);\n+         expectDoesNotContain(completions, ts.ScriptElementKind.parameterElement, ['ctx']);\n+       });\n+  });\n+\n+  describe('in an expression scope', () => {\n+    it('should return completions in a property access expression', () => {\n+      const {templateFile} = setup(`{{name.f}}`, `name!: {first: string; last: string;};`);\n+      templateFile.moveCursorToText('{{name.f¦}}');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectAll(completions, {\n+        first: ts.ScriptElementKind.memberVariableElement,\n+        last: ts.ScriptElementKind.memberVariableElement,\n+      });\n+    });\n+\n+    it('should return completions in an empty property access expression', () => {\n+      const {templateFile} = setup(`{{name.}}`, `name!: {first: string; last: string;};`);\n+      templateFile.moveCursorToText('{{name.¦}}');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectAll(completions, {\n+        first: ts.ScriptElementKind.memberVariableElement,\n+        last: ts.ScriptElementKind.memberVariableElement,\n+      });\n+    });\n+\n+    it('should return completions in a property write expression', () => {\n+      const {templateFile} = setup(\n+          `<button (click)=\"name.fi = 'test\"></button>`, `name!: {first: string; last: string;};`);\n+      templateFile.moveCursorToText('name.fi¦');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectAll(completions, {\n+        first: ts.ScriptElementKind.memberVariableElement,\n+        last: ts.ScriptElementKind.memberVariableElement,\n+      });\n+    });\n+\n+    it('should return completions in a method call expression', () => {\n+      const {templateFile} = setup(`{{name.f()}}`, `name!: {first: string; full(): string;};`);\n+      templateFile.moveCursorToText('{{name.f¦()}}');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectAll(completions, {\n+        first: ts.ScriptElementKind.memberVariableElement,\n+        full: ts.ScriptElementKind.memberFunctionElement,\n+      });\n+    });\n+\n+    it('should return completions in an empty method call expression', () => {\n+      const {templateFile} = setup(`{{name.()}}`, `name!: {first: string; full(): string;};`);\n+      templateFile.moveCursorToText('{{name.¦()}}');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectAll(completions, {\n+        first: ts.ScriptElementKind.memberVariableElement,\n+        full: ts.ScriptElementKind.memberFunctionElement,\n+      });\n+    });\n+\n+    it('should return completions in a safe property navigation context', () => {\n+      const {templateFile} = setup(`{{name?.f}}`, `name?: {first: string; last: string;};`);\n+      templateFile.moveCursorToText('{{name?.f¦}}');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectAll(completions, {\n+        first: ts.ScriptElementKind.memberVariableElement,\n+        last: ts.ScriptElementKind.memberVariableElement,\n+      });\n+    });\n+\n+    it('should return completions in an empty safe property navigation context', () => {\n+      const {templateFile} = setup(`{{name?.}}`, `name?: {first: string; last: string;};`);\n+      templateFile.moveCursorToText('{{name?.¦}}');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectAll(completions, {\n+        first: ts.ScriptElementKind.memberVariableElement,\n+        last: ts.ScriptElementKind.memberVariableElement,\n+      });\n+    });\n+\n+    it('should return completions in a safe method call context', () => {\n+      const {templateFile} = setup(`{{name?.f()}}`, `name!: {first: string; full(): string;};`);\n+      templateFile.moveCursorToText('{{name?.f¦()}}');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectAll(completions, {\n+        first: ts.ScriptElementKind.memberVariableElement,\n+        full: ts.ScriptElementKind.memberFunctionElement,\n+      });\n+    });\n+\n+    it('should return completions in an empty safe method call context', () => {\n+      const {templateFile} = setup(`{{name?.()}}`, `name!: {first: string; full(): string;};`);\n+      templateFile.moveCursorToText('{{name?.¦()}}');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectAll(completions, {\n+        first: ts.ScriptElementKind.memberVariableElement,\n+        full: ts.ScriptElementKind.memberFunctionElement,\n+      });\n+    });\n+  });\n+\n+  describe('element tag scope', () => {\n+    it('should not return DOM completions for external template', () => {\n+      const {templateFile} = setup(`<div>`, '');\n+      templateFile.moveCursorToText('<div¦>');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectDoesNotContain(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ELEMENT),\n+          ['div', 'span']);\n+    });\n+\n+    it('should not return DOM completions for inline template', () => {\n+      const {appFile} = setupInlineTemplate(`<div>`, '');\n+      appFile.moveCursorToText('<div¦>');\n+      const completions = appFile.getCompletionsAtPosition();\n+      expectDoesNotContain(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ELEMENT),\n+          ['div', 'span']);\n+    });\n+\n+    it('should return directive completions', () => {\n+      const OTHER_DIR = {\n+        'OtherDir': `\n+             /** This is another directive. */\n+             @Directive({selector: 'other-dir'})\n+             export class OtherDir {}\n+           `,\n+      };\n+      const {templateFile} = setup(`<div>`, '', OTHER_DIR);\n+      templateFile.moveCursorToText('<div¦>');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+          ['other-dir']);\n+\n+      const details = templateFile.getCompletionEntryDetails('other-dir')!;\n+      expect(details).toBeDefined();\n+      expect(ts.displayPartsToString(details.displayParts))\n+          .toEqual('(directive) AppModule.OtherDir');\n+      expect(ts.displayPartsToString(details.documentation!)).toEqual('This is another directive.');\n+    });\n+\n+    it('should return component completions', () => {\n+      const OTHER_CMP = {\n+        'OtherCmp': `\n+             /** This is another component. */\n+             @Component({selector: 'other-cmp', template: 'unimportant'})\n+             export class OtherCmp {}\n+           `,\n+      };\n+      const {templateFile} = setup(`<div>`, '', OTHER_CMP);\n+      templateFile.moveCursorToText('<div¦>');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.COMPONENT),\n+          ['other-cmp']);\n+\n+\n+      const details = templateFile.getCompletionEntryDetails('other-cmp')!;\n+      expect(details).toBeDefined();\n+      expect(ts.displayPartsToString(details.displayParts))\n+          .toEqual('(component) AppModule.OtherCmp');\n+      expect(ts.displayPartsToString(details.documentation!)).toEqual('This is another component.');\n+    });\n+\n+    it('should return completions for an incomplete tag', () => {\n+      const OTHER_CMP = {\n+        'OtherCmp': `\n+             /** This is another component. */\n+             @Component({selector: 'other-cmp', template: 'unimportant'})\n+             export class OtherCmp {}\n+           `,\n+      };\n+      const {templateFile} = setup(`<other`, '', OTHER_CMP);\n+      templateFile.moveCursorToText('<other¦');\n+\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.COMPONENT),\n+          ['other-cmp']);\n+    });\n+\n+    it('should return completions with a blank open tag', () => {\n+      const OTHER_CMP = {\n+        'OtherCmp': `\n+             @Component({selector: 'other-cmp', template: 'unimportant'})\n+             export class OtherCmp {}\n+           `,\n+      };\n+      const {templateFile} = setup(`<`, '', OTHER_CMP);\n+      templateFile.moveCursorToText('<¦');\n+\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.COMPONENT),\n+          ['other-cmp']);\n+    });\n+\n+    it('should return completions with a blank open tag a character before', () => {\n+      const OTHER_CMP = {\n+        'OtherCmp': `\n+             @Component({selector: 'other-cmp', template: 'unimportant'})\n+             export class OtherCmp {}\n+           `,\n+      };\n+      const {templateFile} = setup(`a <`, '', OTHER_CMP);\n+      templateFile.moveCursorToText('a <¦');\n+\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.COMPONENT),\n+          ['other-cmp']);\n+    });\n+\n+    it('should not return completions when cursor is not after the open tag', () => {\n+      const OTHER_CMP = {\n+        'OtherCmp': `\n+             @Component({selector: 'other-cmp', template: 'unimportant'})\n+             export class OtherCmp {}\n+           `,\n+      };\n+      const {templateFile} = setup(`\\n\\n<         `, '', OTHER_CMP);\n+      templateFile.moveCursorToText('< ¦');\n+\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expect(completions).toBeUndefined();\n+\n+\n+      const details = templateFile.getCompletionEntryDetails('other-cmp')!;\n+      expect(details).toBeUndefined();\n+    });\n+\n+    describe('element attribute scope', () => {\n+      describe('dom completions', () => {\n+        it('should return dom property completions in external template', () => {\n+          const {templateFile} = setup(`<input >`, '');\n+          templateFile.moveCursorToText('<input ¦>');\n+\n+          const completions = templateFile.getCompletionsAtPosition();\n+          expectDoesNotContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+              ['value']);\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+              ['[value]']);\n+        });\n+\n+        it('should return completions for a new element property', () => {\n+          const {appFile} = setupInlineTemplate(`<input >`, '');\n+          appFile.moveCursorToText('<input ¦>');\n+\n+          const completions = appFile.getCompletionsAtPosition();\n+          expectDoesNotContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+              ['value']);\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+              ['[value]']);\n+        });\n+\n+        it('should return event completion', () => {\n+          const {templateFile} = setup(`<button ></button>`, ``);\n+          templateFile.moveCursorToText(`<button ¦>`);\n+          const completions = templateFile.getCompletionsAtPosition();\n+          expectContain(completions, DisplayInfoKind.EVENT, ['(click)']);\n+        });\n+\n+        it('should return event completion with empty parens', () => {\n+          const {templateFile} = setup(`<button ()></button>`, ``);\n+          templateFile.moveCursorToText(`<button (¦)>`);\n+          const completions = templateFile.getCompletionsAtPosition();\n+          expectContain(completions, DisplayInfoKind.EVENT, ['(click)']);\n+        });\n+\n+\n+        it('should return completions for a partial attribute', () => {\n+          const {appFile} = setupInlineTemplate(`<input val>`, '');\n+          appFile.moveCursorToText('<input val¦>');\n+\n+          const completions = appFile.getCompletionsAtPosition();\n+          expectDoesNotContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+              ['value']);\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+              ['[value]']);\n+          expectReplacementText(completions, appFile.contents, 'val');\n+        });\n+\n+        it('should return completions for a partial property binding', () => {\n+          const {appFile} = setupInlineTemplate(`<input [val]>`, '');\n+          appFile.moveCursorToText('[val¦]');\n+\n+          const completions = appFile.getCompletionsAtPosition();\n+          expectDoesNotContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+              ['value']);\n+          expectDoesNotContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+              ['[value]']);\n+          expectDoesNotContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+              ['value']);\n+          expectReplacementText(completions, appFile.contents, 'val');\n+        });\n+\n+        it('should return completions inside an event binding', () => {\n+          const {templateFile} = setup(`<button (cl)=''></button>`, ``);\n+          templateFile.moveCursorToText(`(cl¦)=''`);\n+          const completions = templateFile.getCompletionsAtPosition();\n+          expectContain(completions, DisplayInfoKind.EVENT, ['(click)']);\n+        });\n+      });\n+\n+      describe('directive present', () => {\n+        it('should return directive input completions for a new attribute', () => {\n+          const {templateFile} = setup(`<input dir >`, '', DIR_WITH_INPUT);\n+          templateFile.moveCursorToText('dir ¦>');\n+\n+          const completions = templateFile.getCompletionsAtPosition();\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+              ['[myInput]']);\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+              ['myInput']);\n+        });\n+\n+        it('should return directive input completions for a partial attribute', () => {\n+          const {templateFile} = setup(`<input dir my>`, '', DIR_WITH_INPUT);\n+          templateFile.moveCursorToText('my¦>');\n+\n+          const completions = templateFile.getCompletionsAtPosition();\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+              ['[myInput]']);\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+              ['myInput']);\n+        });\n+\n+        it('should return input completions for a partial property binding', () => {\n+          const {templateFile} = setup(`<input dir [my]>`, '', DIR_WITH_INPUT);\n+          templateFile.moveCursorToText('[my¦]');\n+\n+          const completions = templateFile.getCompletionsAtPosition();\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+              ['myInput']);\n+        });\n+      });\n+\n+      describe('structural directive present', () => {\n+        it('should return structural directive completions for an empty attribute', () => {\n+          const {templateFile} = setup(`<li >`, '', NG_FOR_DIR);\n+          templateFile.moveCursorToText('<li ¦>');\n+\n+          const completions = templateFile.getCompletionsAtPosition();\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+              ['*ngFor']);\n+        });\n+\n+        it('should return structural directive completions for an existing non-structural attribute',\n+           () => {\n+             const {templateFile} = setup(`<li ng>`, '', NG_FOR_DIR);\n+             templateFile.moveCursorToText('<li ng¦>');\n+\n+             const completions = templateFile.getCompletionsAtPosition();\n+             expectContain(\n+                 completions,\n+                 unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+                 ['*ngFor']);\n+             expectReplacementText(completions, templateFile.contents, 'ng');\n+           });\n+\n+        it('should return structural directive completions for an existing structural attribute',\n+           () => {\n+             const {templateFile} = setup(`<li *ng>`, '', NG_FOR_DIR);\n+             templateFile.moveCursorToText('*ng¦>');\n+\n+             const completions = templateFile.getCompletionsAtPosition();\n+             expectContain(\n+                 completions,\n+                 unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+                 ['ngFor']);\n+             expectReplacementText(completions, templateFile.contents, 'ng');\n+             const details = templateFile.getCompletionEntryDetails(\n+                 'ngFor', /* formatOptions */ undefined,\n+                 /* preferences */ undefined)!;\n+             expect(toText(details.displayParts)).toEqual('(directive) NgFor.NgFor: NgFor');\n+           });\n+\n+        it('should return structural directive completions for just the structural marker', () => {\n+          const {templateFile} = setup(`<li *>`, '', NG_FOR_DIR);\n+          templateFile.moveCursorToText('*¦>');\n+\n+          const completions = templateFile.getCompletionsAtPosition();\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+              ['ngFor']);\n+          // The completion should not try to overwrite the '*'.\n+          expectReplacementText(completions, templateFile.contents, '');\n+        });\n+      });\n+\n+      describe('directive not present', () => {\n+        it('should return input completions for a new attribute', () => {\n+          const {templateFile} = setup(`<input >`, '', DIR_WITH_SELECTED_INPUT);\n+          templateFile.moveCursorToText('¦>');\n+\n+          const completions = templateFile.getCompletionsAtPosition();\n+          // This context should generate two completions:\n+          //  * `[myInput]` as a property\n+          //  * `myInput` as an attribute\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+              ['[myInput]']);\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+              ['myInput']);\n+        });\n+      });\n+\n+      it('should return input completions for a partial attribute', () => {\n+        const {templateFile} = setup(`<input my>`, '', DIR_WITH_SELECTED_INPUT);\n+        templateFile.moveCursorToText('my¦>');\n+\n+        const completions = templateFile.getCompletionsAtPosition();\n+        // This context should generate two completions:\n+        //  * `[myInput]` as a property\n+        //  * `myInput` as an attribute\n+        expectContain(\n+            completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+            ['[myInput]']);\n+        expectContain(\n+            completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+            ['myInput']);\n+        expectReplacementText(completions, templateFile.contents, 'my');\n+      });\n+\n+      it('should return input completions for a partial property binding', () => {\n+        const {templateFile} = setup(`<input [my]>`, '', DIR_WITH_SELECTED_INPUT);\n+        templateFile.moveCursorToText('[my¦');\n+\n+        const completions = templateFile.getCompletionsAtPosition();\n+        // This context should generate two completions:\n+        //  * `[myInput]` as a property\n+        //  * `myInput` as an attribute\n+        expectContain(\n+            completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+            ['myInput']);\n+        expectReplacementText(completions, templateFile.contents, 'my');\n+      });\n+\n+      it('should return output completions for an empty binding', () => {\n+        const {templateFile} = setup(`<input dir >`, '', DIR_WITH_OUTPUT);\n+        templateFile.moveCursorToText('¦>');\n+\n+        const completions = templateFile.getCompletionsAtPosition();\n+        expectContain(\n+            completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n+            ['(myOutput)']);\n+      });\n+\n+      it('should return output completions for a partial event binding', () => {\n+        const {templateFile} = setup(`<input dir (my)>`, '', DIR_WITH_OUTPUT);\n+        templateFile.moveCursorToText('(my¦)');\n+\n+        const completions = templateFile.getCompletionsAtPosition();\n+        expectContain(\n+            completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n+            ['myOutput']);\n+        expectReplacementText(completions, templateFile.contents, 'my');\n+      });\n+\n+      it('should return completions inside an LHS of a partially complete two-way binding', () => {\n+        const {templateFile} = setup(`<h1 dir [(mod)]></h1>`, ``, DIR_WITH_TWO_WAY_BINDING);\n+        templateFile.moveCursorToText('[(mod¦)]');\n+        const completions = templateFile.getCompletionsAtPosition();\n+        expectReplacementText(completions, templateFile.contents, 'mod');\n+\n+        expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['model']);\n+\n+        // The completions should not include the events (because the 'Change' suffix is not used in\n+        // the two way binding) or inputs that do not have a corresponding name+'Change' output.\n+        expectDoesNotContain(\n+            completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n+            ['modelChange']);\n+        expectDoesNotContain(\n+            completions, ts.ScriptElementKind.memberVariableElement, ['otherInput']);\n+        expectDoesNotContain(\n+            completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n+            ['otherOutput']);\n+      });\n+\n+      it('should return input completions for a binding property name', () => {\n+        const {templateFile} =\n+            setup(`<h1 dir [customModel]></h1>`, ``, DIR_WITH_BINDING_PROPERTY_NAME);\n+        templateFile.moveCursorToText('[customModel¦]');\n+        const completions = templateFile.getCompletionsAtPosition();\n+        expectReplacementText(completions, templateFile.contents, 'customModel');\n+\n+        expectContain(\n+            completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+            ['customModel']);\n+      });\n+\n+      it('should return output completions for a binding property name', () => {\n+        const {templateFile} =\n+            setup(`<h1 dir (customModel)></h1>`, ``, DIR_WITH_BINDING_PROPERTY_NAME);\n+        templateFile.moveCursorToText('(customModel¦)');\n+        const completions = templateFile.getCompletionsAtPosition();\n+        expectReplacementText(completions, templateFile.contents, 'customModel');\n+\n+        expectContain(\n+            completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n+            ['customModelChange']);\n+      });\n+    });\n+  });\n+\n+  describe('pipe scope', () => {\n+    it('should complete a pipe binding', () => {\n+      const {templateFile} = setup(`{{ foo | some¦ }}`, '', SOME_PIPE);\n+      templateFile.moveCursorToText('some¦');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PIPE),\n+          ['somePipe']);\n+      expectReplacementText(completions, templateFile.contents, 'some');\n+    });\n+\n+    it('should complete an empty pipe binding', () => {\n+      const {templateFile} = setup(`{{foo | }}`, '', SOME_PIPE);\n+      templateFile.moveCursorToText('{{foo | ¦}}');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PIPE),\n+          ['somePipe']);\n+      expectReplacementText(completions, templateFile.contents, '');\n+    });\n+\n+    it('should not return extraneous completions', () => {\n+      const {templateFile} = setup(`{{ foo | some }}`, '');\n+      templateFile.moveCursorToText('{{ foo | some¦ }}');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expect(completions?.entries.length).toBe(0);\n+    });\n+  });\n+\n+  describe('literal primitive scope', () => {\n+    it('should complete a string union types in square brackets binding', () => {\n+      const {templateFile} = setup(`<input dir [myInput]=\"'foo'\">`, '', DIR_WITH_UNION_TYPE_INPUT);\n+      templateFile.moveCursorToText(`[myInput]=\"'foo¦'\"`);\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(completions, ts.ScriptElementKind.string, ['foo']);\n+      expectReplacementText(completions, templateFile.contents, 'foo');\n+    });\n+\n+    it('should complete a string union types in binding without brackets', () => {\n+      const {templateFile} = setup(`<input dir myInput=\"foo\">`, '', DIR_WITH_UNION_TYPE_INPUT);\n+      templateFile.moveCursorToText('myInput=\"foo¦\"');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(completions, ts.ScriptElementKind.string, ['foo']);\n+      expectReplacementText(completions, templateFile.contents, 'foo');\n+    });\n+\n+    it('should complete a string union types in binding without brackets when the cursor at the start of the string',\n+       () => {\n+         const {templateFile} = setup(`<input dir myInput=\"foo\">`, '', DIR_WITH_UNION_TYPE_INPUT);\n+         templateFile.moveCursorToText('myInput=\"¦foo\"');\n+         const completions = templateFile.getCompletionsAtPosition();\n+         expectContain(completions, ts.ScriptElementKind.string, ['foo']);\n+         expectReplacementText(completions, templateFile.contents, 'foo');\n+       });\n+\n+    it('should complete a string union types in pipe', () => {\n+      const {templateFile} =\n+          setup(`<input dir [myInput]=\"'foo'|unionTypePipe:'bar'\">`, '', UNION_TYPE_PIPE);\n+      templateFile.moveCursorToText(`[myInput]=\"'foo'|unionTypePipe:'bar¦'\"`);\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(completions, ts.ScriptElementKind.string, ['bar']);\n+      expectReplacementText(completions, templateFile.contents, 'bar');\n+    });\n+\n+    it('should complete a number union types', () => {\n+      const {templateFile} = setup(`<input dir [myInput]=\"42\">`, '', DIR_WITH_UNION_TYPE_INPUT);\n+      templateFile.moveCursorToText(`[myInput]=\"42¦\"`);\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(completions, ts.ScriptElementKind.string, ['42']);\n+      expectReplacementText(completions, templateFile.contents, '42');\n+    });\n+  });\n+\n+  describe('auto-apply optional chaining', () => {\n+    it('should be able to complete on nullable symbol', () => {\n+      const {templateFile} = setup('{{article.title}}', `article?: { title: string };`);\n+      templateFile.moveCursorToText('{{article.title¦}}');\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithInsertText: true,\n+        includeAutomaticOptionalChainCompletions: true,\n+      });\n+      expectContainInsertText(completions, ts.ScriptElementKind.memberVariableElement, ['?.title']);\n+      expectReplacementText(completions, templateFile.contents, '.title');\n+    });\n+\n+    it('should be able to complete on NonNullable symbol', () => {\n+      const {templateFile} = setup('{{article.title}}', `article: { title: string };`);\n+      templateFile.moveCursorToText('{{article.title¦}}');\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithInsertText: true,\n+        includeAutomaticOptionalChainCompletions: true,\n+      });\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title']);\n+      expectReplacementText(completions, templateFile.contents, 'title');\n+    });\n+\n+    it('should not shift the start location when the user has input the optional chaining', () => {\n+      const {templateFile} = setup('{{article?.title}}', `article?: { title: string };`);\n+      templateFile.moveCursorToText('{{article?.title¦}}');\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithInsertText: true,\n+        includeAutomaticOptionalChainCompletions: true,\n+      });\n+      expectContain(completions, ts.ScriptElementKind.memberVariableElement, ['title']);\n+      expectReplacementText(completions, templateFile.contents, 'title');\n+    });\n+  });\n+\n+  describe('insert snippet text', () => {\n+    it('should be able to complete for an empty attribute', () => {\n+      const {templateFile} = setup(`<input dir >`, '', DIR_WITH_OUTPUT);\n+      templateFile.moveCursorToText('¦>');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n+          ['(myOutput)=\"$1\"']);\n+    });\n+\n+    it('should be able to complete for a partial attribute', () => {\n+      const {templateFile} = setup(`<input dir my>`, '', DIR_WITH_OUTPUT);\n+      templateFile.moveCursorToText('¦>');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n+          ['(myOutput)=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, 'my');\n+    });\n+\n+    it('should be able to complete for the event binding with the value is empty', () => {\n+      const {templateFile} = setup(`<input dir ()=\"\">`, '', DIR_WITH_OUTPUT);\n+      templateFile.moveCursorToText('(¦)=\"\">');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n+          ['(myOutput)=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, '()=\"\"');\n+    });\n+\n+    it('should be able to complete for the event binding', () => {\n+      const {templateFile} = setup(`<input dir ()>`, '', DIR_WITH_OUTPUT);\n+      templateFile.moveCursorToText('(¦)>');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n+          ['(myOutput)=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, '()');\n+    });\n+\n+    it('should be able to complete for the dom event binding', () => {\n+      const {templateFile} = setup(`<input dir (cli)>`, '', DIR_WITH_OUTPUT);\n+      templateFile.moveCursorToText('(cli¦)>');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n+          ['(click)=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, '(cli)');\n+    });\n+\n+    it('should be able to complete for the property binding with the value is empty', () => {\n+      const {templateFile} = setup(`<input [my]=\"\">`, '', DIR_WITH_SELECTED_INPUT);\n+      templateFile.moveCursorToText('[my¦]=\"\"');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+          ['[myInput]=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, '[my]=\"\"');\n+    });\n+\n+    it('should be able to complete for the property binding', () => {\n+      const {templateFile} = setup(`<input [my]>`, '', DIR_WITH_SELECTED_INPUT);\n+      templateFile.moveCursorToText('[my¦]');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+          ['[myInput]=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, '[my]');\n+    });\n+\n+    it('should be able to complete for the dom property binding', () => {\n+      const {templateFile} = setup(`<input [val]>`, '', DIR_WITH_SELECTED_INPUT);\n+      templateFile.moveCursorToText('[val¦]');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+          ['[value]=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, '[val]');\n+    });\n+\n+    it('should be able to complete for the two way binding with the value is empty', () => {\n+      const {templateFile} = setup(`<h1 dir [(mod)]=\"\"></h1>`, ``, DIR_WITH_TWO_WAY_BINDING);\n+      templateFile.moveCursorToText('[(mod¦)]=\"\"');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+          ['[(model)]=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, '[(mod)]=\"\"');\n+    });\n+\n+    it('should be able to complete for the two way binding via', () => {\n+      const {templateFile} = setup(`<h1 dir [(mod)]></h1>`, ``, DIR_WITH_TWO_WAY_BINDING);\n+      templateFile.moveCursorToText('[(mod¦)]');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+          ['[(model)]=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, '[(mod)]');\n+    });\n+\n+    it('should be able to complete for the structural directive with the value is empty', () => {\n+      const {templateFile} = setup(`<input dir *ngFor=\"\">`, '', NG_FOR_DIR);\n+      templateFile.moveCursorToText('ngFor¦=\"\">');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      // Now here is using the `=` to check the value of the structural directive. If the\n+      // sourceSpan/valueSpan made more sense, it should behave like this `ngFor¦=\"\" -> ngFor=\"¦\"`,\n+      // and enable comments below.\n+      //\n+      // expectContainInsertTextWithSnippet(\n+      //     completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+      //     ['ngFor=\"$1\"']);\n+      // expectReplacementText(completions, templateFile.contents, 'ngFor=\"\"');\n+      expectContain(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+          ['ngFor']);\n+      expect(completions?.entries[0]).toBeDefined();\n+      expect(completions?.entries[0].isSnippet).toBeUndefined();\n+      expectReplacementText(completions, templateFile.contents, 'ngFor');\n+    });\n+\n+    it('should be able to complete for the structural directive', () => {\n+      const {templateFile} = setup(`<input dir *ngFor>`, '', NG_FOR_DIR);\n+      templateFile.moveCursorToText('ngFor¦>');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+          ['ngFor=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, 'ngFor');\n+    });\n+\n+    it('should not be included in the completion for an attribute with a value', () => {\n+      const {templateFile} = setup(`<input dir myInput=\"1\">`, '', DIR_WITH_SELECTED_INPUT);\n+      templateFile.moveCursorToText('myInput¦=\"1\">');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContain(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+          ['myInput']);\n+      expectDoesNotContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+          ['myInput=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, 'myInput');\n+    });\n+\n+    it('should not be included in the completion for a directive attribute without input', () => {\n+      const {templateFile} = setup(`<button mat-></button>`, '', CUSTOM_BUTTON);\n+      templateFile.moveCursorToText('mat-¦>');\n+\n+      const completions = templateFile.getCompletionsAtPosition({\n+        includeCompletionsWithSnippetText: true,\n+        includeCompletionsWithInsertText: true,\n+      });\n+      expectContain(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+          ['mat-button']);\n+      expectDoesNotContainInsertTextWithSnippet(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+          ['mat-button=\"$1\"']);\n+      expectReplacementText(completions, templateFile.contents, 'mat-');\n+    });\n+  });\n+});\n+\n+function expectContainInsertText(\n+    completions: ts.CompletionInfo|undefined, kind: ts.ScriptElementKind|DisplayInfoKind,\n+    insertTexts: string[]) {\n+  expect(completions).toBeDefined();\n+  for (const insertText of insertTexts) {\n+    expect(completions!.entries).toContain(jasmine.objectContaining({insertText, kind} as any));\n+  }\n+}\n+\n+function expectContainInsertTextWithSnippet(\n+    completions: ts.CompletionInfo|undefined, kind: ts.ScriptElementKind|DisplayInfoKind,\n+    insertTexts: string[]) {\n+  expect(completions).toBeDefined();\n+  for (const insertText of insertTexts) {\n+    expect(completions!.entries)\n+        .toContain(jasmine.objectContaining({insertText, kind, isSnippet: true} as any));\n+  }\n+}\n+\n+function expectDoesNotContainInsertTextWithSnippet(\n+    completions: ts.CompletionInfo|undefined, kind: ts.ScriptElementKind|DisplayInfoKind,\n+    insertTexts: string[]) {\n+  expect(completions).toBeDefined();\n+  for (const insertText of insertTexts) {\n+    expect(completions!.entries)\n+        .not.toContain(jasmine.objectContaining({insertText, kind, isSnippet: true} as any));\n+  }\n+}\n+\n+function expectContain(\n+    completions: ts.CompletionInfo|undefined, kind: ts.ScriptElementKind|DisplayInfoKind,\n+    names: string[]) {\n+  expect(completions).toBeDefined();\n+  for (const name of names) {\n+    expect(completions!.entries).toContain(jasmine.objectContaining({name, kind} as any));\n+  }\n+}\n+\n+function expectAll(\n+    completions: ts.CompletionInfo|undefined,\n+    contains: {[name: string]: ts.ScriptElementKind|DisplayInfoKind}): void {\n+  expect(completions).toBeDefined();\n+  for (const [name, kind] of Object.entries(contains)) {\n+    expect(completions!.entries).toContain(jasmine.objectContaining({name, kind} as any));\n+  }\n+  expect(completions!.entries.length).toEqual(Object.keys(contains).length);\n+}\n+\n+function expectDoesNotContain(\n+    completions: ts.CompletionInfo|undefined, kind: ts.ScriptElementKind|DisplayInfoKind,\n+    names: string[]) {\n+  expect(completions).toBeDefined();\n+  for (const name of names) {\n+    expect(completions!.entries).not.toContain(jasmine.objectContaining({name, kind} as any));\n+  }\n+}\n+\n+function expectReplacementText(\n+    completions: ts.CompletionInfo|undefined, text: string, replacementText: string) {\n+  if (completions === undefined) {\n+    return;\n+  }\n+\n+  for (const entry of completions.entries) {\n+    expect(entry.replacementSpan).toBeDefined();\n+    const completionReplaces =\n+        text.substr(entry.replacementSpan!.start, entry.replacementSpan!.length);\n+    expect(completionReplaces).toBe(replacementText);\n+  }\n+}\n+\n+function toText(displayParts?: ts.SymbolDisplayPart[]): string {\n+  return (displayParts ?? []).map(p => p.text).join('');\n+}\n+\n+function setup(\n+    template: string, classContents: string, otherDeclarations: {[name: string]: string} = {}): {\n+  templateFile: OpenBuffer,\n+} {\n+  const decls = ['AppCmp', ...Object.keys(otherDeclarations)];\n+\n+  const otherDirectiveClassDecls = Object.values(otherDeclarations).join('\\n\\n');\n+\n+  const env = LanguageServiceTestEnv.setup();\n+  const project = env.addProject('test', {\n+    'test.ts': `\n+         import {Component, Directive, NgModule, Pipe, TemplateRef} from '@angular/core';\n+ \n+         @Component({\n+           templateUrl: './test.html',\n+           selector: 'app-cmp',\n+         })\n+         export class AppCmp {\n+           ${classContents}\n+         }\n+ \n+         ${otherDirectiveClassDecls}\n+ \n+         @NgModule({\n+           declarations: [${decls.join(', ')}],\n+         })\n+         export class AppModule {}\n+         `,\n+    'test.html': template,\n+  });\n+  return {templateFile: project.openFile('test.html')};\n+}\n+\n+function setupInlineTemplate(\n+    template: string, classContents: string, otherDeclarations: {[name: string]: string} = {}): {\n+  appFile: OpenBuffer,\n+} {\n+  const decls = ['AppCmp', ...Object.keys(otherDeclarations)];\n+\n+  const otherDirectiveClassDecls = Object.values(otherDeclarations).join('\\n\\n');\n+\n+  const env = LanguageServiceTestEnv.setup();\n+  const project = env.addProject('test', {\n+    'test.ts': `\n+         import {Component, Directive, NgModule, Pipe, TemplateRef} from '@angular/core';\n+ \n+         @Component({\n+           template: '${template}',\n+           selector: 'app-cmp',\n+         })\n+         export class AppCmp {\n+           ${classContents}\n+         }\n+ \n+         ${otherDirectiveClassDecls}\n+ \n+         @NgModule({\n+           declarations: [${decls.join(', ')}],\n+         })\n+         export class AppModule {}\n+         `,\n+  });\n+  return {appFile: project.openFile('test.ts')};\n+}"
        },
        {
            "sha": "06c05fdcde5e27558c1e0690cb0875d47526f39c",
            "filename": "packages/language-service/test/definitions_spec.ts",
            "status": "modified",
            "additions": 205,
            "deletions": 1,
            "changes": 206,
            "blob_url": "https://github.com/angular/angular/blob/756761d53418d2d4849d4c13b5dd067aa1a6a289/packages%2Flanguage-service%2Ftest%2Fdefinitions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/756761d53418d2d4849d4c13b5dd067aa1a6a289/packages%2Flanguage-service%2Ftest%2Fdefinitions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fdefinitions_spec.ts?ref=756761d53418d2d4849d4c13b5dd067aa1a6a289",
            "patch": "@@ -8,7 +8,211 @@\n \n import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n \n-import {assertFileNames, assertTextSpans, humanizeDocumentSpanLike, LanguageServiceTestEnv, Project} from '../testing';\n+import {assertFileNames, assertTextSpans, createModuleAndProjectWithDeclarations, humanizeDocumentSpanLike, LanguageServiceTestEnv, OpenBuffer, Project} from '../testing';\n+\n+describe('definitions', () => {\n+  it('gets definition for template reference in overridden template', () => {\n+    initMockFileSystem('Native');\n+    const files = {\n+      'app.html': '',\n+      'app.ts': `\n+         import {Component} from '@angular/core';\n+ \n+         @Component({templateUrl: '/app.html'})\n+         export class AppCmp {}\n+       `,\n+    };\n+    const env = LanguageServiceTestEnv.setup();\n+\n+    const project = createModuleAndProjectWithDeclarations(env, 'test', files);\n+    const template = project.openFile('app.html');\n+    template.contents = '<input #myInput /> {{myInput.value}}';\n+    project.expectNoSourceDiagnostics();\n+\n+    template.moveCursorToText('{{myIn¦put.value}}');\n+    const {definitions} = getDefinitionsAndAssertBoundSpan(env, template);\n+    expect(definitions![0].name).toEqual('myInput');\n+    assertFileNames(Array.from(definitions!), ['app.html']);\n+  });\n+\n+  it('returns the pipe definitions when checkTypeOfPipes is false', () => {\n+    initMockFileSystem('Native');\n+    const files = {\n+      'app.ts': `\n+         import {Component, NgModule} from '@angular/core';\n+         import {CommonModule} from '@angular/common';\n+ \n+         @Component({templateUrl: 'app.html'})\n+         export class AppCmp {}\n+       `,\n+      'app.html': '{{\"1/1/2020\" | date}}'\n+    };\n+    // checkTypeOfPipes is set to false when strict templates is false\n+    const env = LanguageServiceTestEnv.setup();\n+    const project =\n+        createModuleAndProjectWithDeclarations(env, 'test', files, {strictTemplates: false});\n+    const template = project.openFile('app.html');\n+    project.expectNoSourceDiagnostics();\n+    template.moveCursorToText('da¦te');\n+\n+    const {textSpan, definitions} = getDefinitionsAndAssertBoundSpan(env, template);\n+    expect(template.contents.substr(textSpan.start, textSpan.length)).toEqual('date');\n+    expect(definitions.length).toEqual(3);\n+    assertTextSpans(definitions, ['transform']);\n+    assertFileNames(definitions, ['index.d.ts']);\n+  });\n+\n+  it('gets definitions for all inputs when attribute matches more than one', () => {\n+    initMockFileSystem('Native');\n+    const files = {\n+      'app.ts': `\n+         import {Component, NgModule} from '@angular/core';\n+         import {CommonModule} from '@angular/common';\n+ \n+         @Component({templateUrl: 'app.html'})\n+         export class AppCmp {}\n+       `,\n+      'app.html': '<div dir inputA=\"abc\"></div>',\n+      'dir.ts': `\n+       import {Directive, Input} from '@angular/core';\n+ \n+       @Directive({selector: '[dir]'})\n+       export class MyDir {\n+         @Input() inputA!: any;\n+       }`,\n+      'dir2.ts': `\n+       import {Directive, Input} from '@angular/core';\n+ \n+       @Directive({selector: '[dir]'})\n+       export class MyDir2 {\n+         @Input() inputA!: any;\n+       }`\n+\n+    };\n+    const env = LanguageServiceTestEnv.setup();\n+    const project = createModuleAndProjectWithDeclarations(env, 'test', files);\n+    const template = project.openFile('app.html');\n+    template.moveCursorToText('inpu¦tA=\"abc\"');\n+\n+    const {textSpan, definitions} = getDefinitionsAndAssertBoundSpan(env, template);\n+    expect(template.contents.substr(textSpan.start, textSpan.length)).toEqual('inputA');\n+\n+    expect(definitions!.length).toEqual(2);\n+    const [def, def2] = definitions!;\n+    expect(def.textSpan).toContain('inputA');\n+    expect(def2.textSpan).toContain('inputA');\n+    // TODO(atscott): investigate why the text span includes more than just 'inputA'\n+    // assertTextSpans([def, def2], ['inputA']);\n+    assertFileNames([def, def2], ['dir2.ts', 'dir.ts']);\n+  });\n+\n+  it('gets definitions for all outputs when attribute matches more than one', () => {\n+    initMockFileSystem('Native');\n+    const files = {\n+      'app.html': '<div dir (someEvent)=\"doSomething()\"></div>',\n+      'dir.ts': `\n+       import {Directive, Output, EventEmitter} from '@angular/core';\n+ \n+       @Directive({selector: '[dir]'})\n+       export class MyDir {\n+         @Output() someEvent = new EventEmitter<void>();\n+       }`,\n+      'dir2.ts': `\n+       import {Directive, Output, EventEmitter} from '@angular/core';\n+ \n+       @Directive({selector: '[dir]'})\n+       export class MyDir2 {\n+         @Output() someEvent = new EventEmitter<void>();\n+       }`,\n+      'app.ts': `\n+         import {Component, NgModule} from '@angular/core';\n+         import {CommonModule} from '@angular/common';\n+ \n+         @Component({templateUrl: 'app.html'})\n+         export class AppCmp {\n+           doSomething() {}\n+         }\n+       `\n+    };\n+    const env = LanguageServiceTestEnv.setup();\n+    const project = createModuleAndProjectWithDeclarations(env, 'test', files);\n+    const template = project.openFile('app.html');\n+    template.moveCursorToText('(someEv¦ent)');\n+\n+    const {textSpan, definitions} = getDefinitionsAndAssertBoundSpan(env, template);\n+    expect(template.contents.substr(textSpan.start, textSpan.length)).toEqual('someEvent');\n+\n+    expect(definitions.length).toEqual(2);\n+    const [def, def2] = definitions;\n+    expect(def.textSpan).toContain('someEvent');\n+    expect(def2.textSpan).toContain('someEvent');\n+    // TODO(atscott): investigate why the text span includes more than just 'someEvent'\n+    // assertTextSpans([def, def2], ['someEvent']);\n+    assertFileNames([def, def2], ['dir2.ts', 'dir.ts']);\n+  });\n+\n+  it('should go to the pre-compiled style sheet', () => {\n+    initMockFileSystem('Native');\n+    const files = {\n+      'app.ts': `\n+       import {Component} from '@angular/core';\n+ \n+       @Component({\n+         template: '',\n+         styleUrls: ['./style.css'],\n+       })\n+       export class AppCmp {}\n+       `,\n+      'style.scss': '',\n+    };\n+    const env = LanguageServiceTestEnv.setup();\n+    const project = createModuleAndProjectWithDeclarations(env, 'test', files);\n+    const appFile = project.openFile('app.ts');\n+    appFile.moveCursorToText(`['./styl¦e.css']`);\n+    const {textSpan, definitions} = getDefinitionsAndAssertBoundSpan(env, appFile);\n+    expect(appFile.contents.substr(textSpan.start, textSpan.length)).toEqual('./style.css');\n+\n+    expect(definitions.length).toEqual(1);\n+    assertFileNames(definitions, ['style.scss']);\n+  });\n+\n+  it('gets definition for property of variable declared in template', () => {\n+    initMockFileSystem('Native');\n+    const files = {\n+      'app.html': `\n+         <ng-container *ngIf=\"{prop: myVal} as myVar\">\n+           {{myVar.prop.name}}\n+         </ng-container>\n+       `,\n+      'app.ts': `\n+         import {Component} from '@angular/core';\n+ \n+         @Component({templateUrl: '/app.html'})\n+         export class AppCmp {\n+           myVal = {name: 'Andrew'};\n+         }\n+       `,\n+    };\n+    const env = LanguageServiceTestEnv.setup();\n+\n+    const project = createModuleAndProjectWithDeclarations(env, 'test', files);\n+    const template = project.openFile('app.html');\n+    project.expectNoSourceDiagnostics();\n+\n+    template.moveCursorToText('{{myVar.pro¦p.name}}');\n+    const {definitions} = getDefinitionsAndAssertBoundSpan(env, template);\n+    expect(definitions![0].name).toEqual('\"prop\"');\n+    assertFileNames(Array.from(definitions!), ['app.html']);\n+  });\n+\n+  function getDefinitionsAndAssertBoundSpan(env: LanguageServiceTestEnv, file: OpenBuffer) {\n+    env.expectNoSourceDiagnostics();\n+    const definitionAndBoundSpan = file.getDefinitionAndBoundSpan();\n+    const {textSpan, definitions} = definitionAndBoundSpan!;\n+    expect(definitions).toBeTruthy();\n+    return {textSpan, definitions: definitions!.map(d => humanizeDocumentSpanLike(d, env))};\n+  }\n+});\n \n describe('definitions', () => {\n   let env: LanguageServiceTestEnv;"
        }
    ],
    "stats": {
        "total": 1449,
        "additions": 1448,
        "deletions": 1
    }
}