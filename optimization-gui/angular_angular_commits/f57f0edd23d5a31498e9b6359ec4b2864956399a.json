{
    "author": "atscott",
    "message": "refactor(router): clean up unnecessary flag in `restoreHistory` function (#43382)\n\nThis restores the `finalize` function to directly call\n`resetUrlToCurrentUrlTree`, as it was before efb440eb2f507f9a2675f2663f1af0b3c574c902.\nThis allows us to simplify the `restoreHistory` function because it no\nlonger needs to handle the call from `finalize` where it should not\nreset the internal router state.\n\nPR Close #43382",
    "sha": "f57f0edd23d5a31498e9b6359ec4b2864956399a",
    "files": [
        {
            "sha": "d222f6d341b3c4e24268e2456df535b1d11c4c3d",
            "filename": "packages/router/src/router.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 22,
            "changes": 30,
            "blob_url": "https://github.com/angular/angular/blob/f57f0edd23d5a31498e9b6359ec4b2864956399a/packages%2Frouter%2Fsrc%2Frouter.ts",
            "raw_url": "https://github.com/angular/angular/raw/f57f0edd23d5a31498e9b6359ec4b2864956399a/packages%2Frouter%2Fsrc%2Frouter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frouter.ts?ref=f57f0edd23d5a31498e9b6359ec4b2864956399a",
            "patch": "@@ -883,19 +883,11 @@ export class Router {\n                            // AngularJS sync code which looks for a value here in order to determine\n                            // whether or not to handle a given popstate event or to leave it to the\n                            // Angular router.\n-                           this.restoreHistory(t);\n-                           this.cancelNavigationTransition(t, cancelationReason);\n-                         } else {\n-                           // We cannot trigger a `location.historyGo` if the\n-                           // cancellation was due to a new navigation before the previous could\n-                           // complete. This is because `location.historyGo` triggers a `popstate`\n-                           // which would also trigger another navigation. Instead, treat this as a\n-                           // redirect and do not reset the state.\n-                           this.cancelNavigationTransition(t, cancelationReason);\n-                           // TODO(atscott): The same problem happens here with a fresh page load\n-                           // and a new navigation before that completes where we won't set a page\n-                           // id.\n+                           this.resetUrlToCurrentUrlTree();\n                          }\n+                         // Note: Other `canceledNavigationResolution` strategies will not support\n+                         // the AngularJS use-case that's mentioned above.\n+                         this.cancelNavigationTransition(t, cancelationReason);\n                        }\n                        // currentNavigation should always be reset to null here. If navigation was\n                        // successful, lastSuccessfulTransition will have already been set. Therefore\n@@ -926,7 +918,7 @@ export class Router {\n                            // This is only applicable with initial navigation, so setting\n                            // `navigated` only when not redirecting resolves this scenario.\n                            this.navigated = true;\n-                           this.restoreHistory(t, true);\n+                           this.restoreHistory(t);\n                          }\n                          const navCancel = new NavigationCancel(\n                              t.id, this.serializeUrl(t.extractedUrl), e.message);\n@@ -963,7 +955,7 @@ export class Router {\n                          /* All other errors should reset to the router's internal URL reference to\n                           * the pre-error state. */\n                        } else {\n-                         this.restoreHistory(t, true);\n+                         this.restoreHistory(t);\n                          const navError =\n                              new NavigationError(t.id, this.serializeUrl(t.extractedUrl), e);\n                          eventsSubject.next(navError);\n@@ -1439,7 +1431,7 @@ export class Router {\n    * Performs the necessary rollback action to restore the browser URL to the\n    * state before the transition.\n    */\n-  private restoreHistory(t: NavigationTransition, restoringFromCaughtError = false) {\n+  private restoreHistory(t: NavigationTransition) {\n     if (this.canceledNavigationResolution === 'computed') {\n       const targetPagePosition = this.currentPageId - t.targetPageId;\n       // The navigator change the location before triggered the browser event,\n@@ -1467,13 +1459,7 @@ export class Router {\n         // there's no restoration needed.\n       }\n     } else if (this.canceledNavigationResolution === 'replace') {\n-      // TODO(atscott): It seems like we should _always_ reset the state here. It would be a no-op\n-      // for `deferred` navigations that haven't change the internal state yet because guards\n-      // reject. For 'eager' navigations, it seems like we also really should reset the state\n-      // because the navigation was cancelled. Investigate if this can be done by running TGP.\n-      if (restoringFromCaughtError) {\n-        this.resetState(t);\n-      }\n+      this.resetState(t);\n       this.resetUrlToCurrentUrlTree();\n     }\n   }"
        }
    ],
    "stats": {
        "total": 30,
        "additions": 8,
        "deletions": 22
    }
}