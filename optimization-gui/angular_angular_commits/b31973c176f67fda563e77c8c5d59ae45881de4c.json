{
    "author": "AndrewKushnir",
    "message": "test: remove Ivy/ViewEngine switch helpers and obsolete tests (#44120)\n\nThis commit removes special functions that were used to run tests in ViewEngine or Ivy only.\nSince ViewEngine is deprecated and we no longer run ViewEngine tests on CI, we can cleanup\nthose special helpers and ViewEngine-only tests.\n\nPR Close #44120",
    "sha": "b31973c176f67fda563e77c8c5d59ae45881de4c",
    "files": [
        {
            "sha": "2163f1188197c117e55a0869d307f19f9922eee4",
            "filename": "packages/bazel/test/ngc-wrapped/flat_module_test.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 11,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fbazel%2Ftest%2Fngc-wrapped%2Fflat_module_test.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fbazel%2Ftest%2Fngc-wrapped%2Fflat_module_test.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbazel%2Ftest%2Fngc-wrapped%2Fflat_module_test.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -6,7 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {obsoleteInIvy, onlyInIvy} from '@angular/private/testing';\n import {runfiles} from '@bazel/runfiles';\n import {existsSync, readFileSync} from 'fs';\n import {dirname, join} from 'path';\n@@ -26,15 +25,8 @@ describe('flat_module ng_module', () => {\n   });\n \n   describe('flat module out file', () => {\n-    obsoleteInIvy('Ngtsc computes the AMD module name differently than NGC')\n-        .it('should have a proper AMD module name', () => {\n-          expect(readFileSync(flatModuleOutFile, 'utf8'))\n-              .toContain(`define(\"flat_module/flat_module\"`);\n-        });\n-\n-    onlyInIvy('Ngtsc computes the AMD module name differently than NGC')\n-        .it('should have a proper AMD module name', () => {\n-          expect(readFileSync(flatModuleOutFile, 'utf8')).toContain(`define(\"flat_module\"`);\n-        });\n+    it('should have a proper AMD module name', () => {\n+      expect(readFileSync(flatModuleOutFile, 'utf8')).toContain(`define(\"flat_module\"`);\n+    });\n   });\n });"
        },
        {
            "sha": "c05950ee1b25c38f35f75099c61f475c6a18e66a",
            "filename": "packages/compiler-cli/integrationtest/bazel/injector_def/ivy_build/app/test/module_spec.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 7,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Finjector_def%2Fivy_build%2Fapp%2Ftest%2Fmodule_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Finjector_def%2Fivy_build%2Fapp%2Ftest%2Fmodule_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Finjector_def%2Fivy_build%2Fapp%2Ftest%2Fmodule_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -7,10 +7,9 @@\n  */\n \n import {forwardRef, Injectable, InjectionToken, Injector, NgModule, ɵcreateInjector as createInjector} from '@angular/core';\n-import {ivyEnabled} from '@angular/private/testing';\n import {AOT_TOKEN, AotModule, AotService} from 'app_built/src/module';\n \n-describe('Ivy NgModule', () => {\n+describe('NgModule', () => {\n   describe('AOT', () => {\n     let injector: Injector;\n \n@@ -62,12 +61,11 @@ describe('Ivy NgModule', () => {\n       class BModule {\n       }\n \n-      const errorCode = ivyEnabled ? 'NG0200: ' : '';\n-      const errorLink = ivyEnabled ? '. Find more at https://angular.io/errors/NG0200' : '';\n       expect(() => createInjector(AModule))\n-          .toThrowError(`${\n-              errorCode}Circular dependency in DI detected for AModule. Dependency path: AModule > BModule > AModule${\n-              errorLink}`);\n+          .toThrowError(\n+              'NG0200: Circular dependency in DI detected for AModule. ' +\n+              'Dependency path: AModule > BModule > AModule. ' +\n+              'Find more at https://angular.io/errors/NG0200');\n     });\n \n     it('merges imports and exports', () => {"
        },
        {
            "sha": "2b4b04245e0e809c538b3bb9270a2752549d5625",
            "filename": "packages/core/test/acceptance/bootstrap_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fbootstrap_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fbootstrap_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fbootstrap_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -9,7 +9,7 @@\n import {ApplicationRef, COMPILER_OPTIONS, Component, destroyPlatform, NgModule, NgZone, TestabilityRegistry, ViewEncapsulation} from '@angular/core';\n import {BrowserModule} from '@angular/platform-browser';\n import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';\n-import {onlyInIvy, withBody} from '@angular/private/testing';\n+import {withBody} from '@angular/private/testing';\n \n describe('bootstrap', () => {\n   beforeEach(destroyPlatform);\n@@ -242,7 +242,7 @@ describe('bootstrap', () => {\n          }));\n     });\n \n-    onlyInIvy('options cannot be changed in Ivy').describe('changing bootstrap options', () => {\n+    describe('changing bootstrap options', () => {\n       beforeEach(() => {\n         spyOn(console, 'error');\n       });"
        },
        {
            "sha": "6189ef33976bded308f7b067a01a59dd2a732cd7",
            "filename": "packages/core/test/acceptance/change_detection_spec.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 25,
            "changes": 37,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fchange_detection_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fchange_detection_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fchange_detection_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -11,7 +11,6 @@ import {CommonModule} from '@angular/common';\n import {ApplicationRef, ChangeDetectionStrategy, ChangeDetectorRef, Component, ComponentFactoryResolver, ComponentRef, Directive, DoCheck, EmbeddedViewRef, ErrorHandler, EventEmitter, Input, NgModule, OnInit, Output, QueryList, TemplateRef, Type, ViewChild, ViewChildren, ViewContainerRef} from '@angular/core';\n import {ComponentFixture, fakeAsync, TestBed, tick} from '@angular/core/testing';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {ivyEnabled} from '@angular/private/testing';\n import {BehaviorSubject} from 'rxjs';\n \n describe('change detection', () => {\n@@ -1122,7 +1121,7 @@ describe('change detection', () => {\n              template: ` <ng-container [ngTemplateOutlet]=\"template\"> </ng-container> `\n            })\n            class Insertion {\n-             @Input() template !: TemplateRef<{}>;\n+             @Input() template!: TemplateRef<{}>;\n            }\n \n            // This component uses async pipe (which calls markForCheck) in a view that has different\n@@ -1398,34 +1397,29 @@ describe('change detection', () => {\n     }\n \n     it('should include field name in case of property binding', () => {\n-      const message = ivyEnabled ? `Previous value for 'id': 'initial'. Current value: 'changed'` :\n-                                   `Previous value: 'id: initial'. Current value: 'id: changed'`;\n+      const message = `Previous value for 'id': 'initial'. Current value: 'changed'`;\n       expect(() => initWithTemplate('<div [id]=\"unstableStringExpression\"></div>'))\n           .toThrowError(new RegExp(message));\n     });\n \n     it('should include field name in case of property interpolation', () => {\n-      const message = ivyEnabled ?\n-          `Previous value for 'id': 'Expressions: a and initial!'. Current value: 'Expressions: a and changed!'` :\n-          `Previous value: 'id: Expressions: a and initial!'. Current value: 'id: Expressions: a and changed!'`;\n+      const message =\n+          `Previous value for 'id': 'Expressions: a and initial!'. Current value: 'Expressions: a and changed!'`;\n       expect(\n           () => initWithTemplate(\n               '<div id=\"Expressions: {{ a }} and {{ unstableStringExpression }}!\"></div>'))\n           .toThrowError(new RegExp(message));\n     });\n \n     it('should include field name in case of attribute binding', () => {\n-      const message = ivyEnabled ?\n-          `Previous value for 'attr.id': 'initial'. Current value: 'changed'` :\n-          `Previous value: 'id: initial'. Current value: 'id: changed'`;\n+      const message = `Previous value for 'attr.id': 'initial'. Current value: 'changed'`;\n       expect(() => initWithTemplate('<div [attr.id]=\"unstableStringExpression\"></div>'))\n           .toThrowError(new RegExp(message));\n     });\n \n     it('should include field name in case of attribute interpolation', () => {\n-      const message = ivyEnabled ?\n-          `Previous value for 'attr.id': 'Expressions: a and initial!'. Current value: 'Expressions: a and changed!'` :\n-          `Previous value: 'id: Expressions: a and initial!'. Current value: 'id: Expressions: a and changed!'`;\n+      const message =\n+          `Previous value for 'attr.id': 'Expressions: a and initial!'. Current value: 'Expressions: a and changed!'`;\n       expect(\n           () => initWithTemplate(\n               '<div attr.id=\"Expressions: {{ a }} and {{ unstableStringExpression }}!\"></div>'))\n@@ -1450,16 +1444,13 @@ describe('change detection', () => {\n        });\n \n     it('should include style prop name in case of style binding', () => {\n-      const message = ivyEnabled ? `Previous value for 'color': 'red'. Current value: 'green'` :\n-                                   `Previous value: 'color: red'. Current value: 'color: green'`;\n+      const message = `Previous value for 'color': 'red'. Current value: 'green'`;\n       expect(() => initWithTemplate('<div [style.color]=\"unstableColorExpression\"></div>'))\n           .toThrowError(new RegExp(message));\n     });\n \n     it('should include class name in case of class binding', () => {\n-      const message = ivyEnabled ?\n-          `Previous value for 'someClass': 'true'. Current value: 'false'` :\n-          `Previous value: 'someClass: true'. Current value: 'someClass: false'`;\n+      const message = `Previous value for 'someClass': 'true'. Current value: 'false'`;\n       expect(() => initWithTemplate('<div [class.someClass]=\"unstableBooleanExpression\"></div>'))\n           .toThrowError(new RegExp(message));\n     });\n@@ -1480,23 +1471,19 @@ describe('change detection', () => {\n        });\n \n     it('should include field name in case of host property binding', () => {\n-      const message = ivyEnabled ? `Previous value for 'id': 'initial'. Current value: 'changed'` :\n-                                   `Previous value: 'id: initial'. Current value: 'id: changed'`;\n+      const message = `Previous value for 'id': 'initial'. Current value: 'changed'`;\n       expect(() => initWithHostBindings({'[id]': 'unstableStringExpression'}))\n           .toThrowError(new RegExp(message));\n     });\n \n     it('should include style prop name in case of host style bindings', () => {\n-      const message = ivyEnabled ? `Previous value for 'color': 'red'. Current value: 'green'` :\n-                                   `Previous value: 'color: red'. Current value: 'color: green'`;\n+      const message = `Previous value for 'color': 'red'. Current value: 'green'`;\n       expect(() => initWithHostBindings({'[style.color]': 'unstableColorExpression'}))\n           .toThrowError(new RegExp(message));\n     });\n \n     it('should include class name in case of host class bindings', () => {\n-      const message = ivyEnabled ?\n-          `Previous value for 'someClass': 'true'. Current value: 'false'` :\n-          `Previous value: 'someClass: true'. Current value: 'someClass: false'`;\n+      const message = `Previous value for 'someClass': 'true'. Current value: 'false'`;\n       expect(() => initWithHostBindings({'[class.someClass]': 'unstableBooleanExpression'}))\n           .toThrowError(new RegExp(message));\n     });"
        },
        {
            "sha": "b905ea6bef66d9a8631f4029f22072fa5ac8c489",
            "filename": "packages/core/test/acceptance/change_detection_transplanted_view_spec.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 6,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fchange_detection_transplanted_view_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fchange_detection_transplanted_view_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fchange_detection_transplanted_view_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -11,7 +11,6 @@ import {ChangeDetectionStrategy, ChangeDetectorRef, Component, DoCheck, Input, T\n import {AfterViewChecked} from '@angular/core/src/core';\n import {ComponentFixture, TestBed} from '@angular/core/testing';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {onlyInIvy} from '@angular/private/testing';\n \n describe('change detection for transplanted views', () => {\n   describe('when declaration appears before insertion', () => {\n@@ -324,7 +323,7 @@ describe('change detection for transplanted views', () => {\n       changeDetection: ChangeDetectionStrategy.OnPush\n     })\n     class Insertion {\n-      @Input() template !: TemplateRef<{}>;\n+      @Input() template!: TemplateRef<{}>;\n       name = 'initial';\n       constructor(readonly changeDetectorRef: ChangeDetectorRef) {}\n     }\n@@ -479,7 +478,7 @@ describe('change detection for transplanted views', () => {\n       template: `<ng-container [ngTemplateOutlet]=\"template\"></ng-container>`\n     })\n     class CheckAlwaysInsertion {\n-      @Input() template !: TemplateRef<{}>;\n+      @Input() template!: TemplateRef<{}>;\n     }\n \n     @Component({\n@@ -488,7 +487,7 @@ describe('change detection for transplanted views', () => {\n       changeDetection: ChangeDetectionStrategy.OnPush\n     })\n     class OnPushInsertionHost {\n-      @Input() template !: TemplateRef<{}>;\n+      @Input() template!: TemplateRef<{}>;\n       constructor(readonly cdr: ChangeDetectorRef) {}\n     }\n     @Component({\n@@ -542,7 +541,7 @@ describe('change detection for transplanted views', () => {\n       expect(fixture.nativeElement.textContent).toEqual('new');\n     });\n \n-    onlyInIvy('behavior is inconsistent in VE').describe('when insertion is detached', () => {\n+    describe('when insertion is detached', () => {\n       it('does not refresh CheckAlways transplants', () => {\n         const fixture = getFixture(CheckAlwaysDeclaration);\n         fixture.detectChanges();\n@@ -570,7 +569,7 @@ describe('change detection for transplanted views', () => {\n       changeDetection: ChangeDetectionStrategy.OnPush\n     })\n     class TripleTemplate {\n-      @Input() template !: TemplateRef<{}>;\n+      @Input() template!: TemplateRef<{}>;\n     }\n \n     @Component({"
        },
        {
            "sha": "62caabf0f81716946f598923cd7715ec410f0d65",
            "filename": "packages/core/test/acceptance/component_spec.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 26,
            "changes": 34,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fcomponent_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fcomponent_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fcomponent_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -11,7 +11,6 @@ import {ApplicationRef, Component, ComponentFactoryResolver, ComponentRef, Eleme\n import {TestBed} from '@angular/core/testing';\n import {ɵDomRendererFactory2 as DomRendererFactory2} from '@angular/platform-browser';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {ivyEnabled, onlyInIvy} from '@angular/private/testing';\n \n import {domRendererFactory3} from '../../src/render3/interfaces/renderer';\n import {global} from '../../src/util/global';\n@@ -388,18 +387,9 @@ describe('component', () => {\n       }\n \n       TestBed.configureTestingModule({declarations: [App, Comp]});\n-      if (ivyEnabled) {\n-        expect(() => TestBed.createComponent(App))\n-            .toThrowError(\n-                /\"ng-container\" tags cannot be used as component hosts. Please use a different tag to activate the Comp component/);\n-      } else {\n-        // In VE there is no special check for the case when `<ng-container>` is used as a host\n-        // element for a Component. VE tries to attach Component's content to a Comment node that\n-        // represents the `<ng-container>` location and this call fails with a\n-        // browser/environment-specific error message, so we just verify that this scenario is\n-        // triggering an error in VE.\n-        expect(() => TestBed.createComponent(App)).toThrow();\n-      }\n+      expect(() => TestBed.createComponent(App))\n+          .toThrowError(\n+              /\"ng-container\" tags cannot be used as component hosts. Please use a different tag to activate the Comp component/);\n     });\n \n     it('should throw when <ng-template> is used as a host element for a Component', () => {\n@@ -418,15 +408,9 @@ describe('component', () => {\n       }\n \n       TestBed.configureTestingModule({declarations: [App, Comp]});\n-      if (ivyEnabled) {\n-        expect(() => TestBed.createComponent(App))\n-            .toThrowError(\n-                /\"ng-template\" tags cannot be used as component hosts. Please use a different tag to activate the Comp component/);\n-      } else {\n-        expect(() => TestBed.createComponent(App))\n-            .toThrowError(\n-                /Components on an embedded template: Comp \\(\"\\[ERROR ->\\]<ng-template><\\/ng-template>\"\\)/);\n-      }\n+      expect(() => TestBed.createComponent(App))\n+          .toThrowError(\n+              /\"ng-template\" tags cannot be used as component hosts. Please use a different tag to activate the Comp component/);\n     });\n   });\n \n@@ -702,9 +686,7 @@ describe('component', () => {\n     it('with Renderer2',\n        () => runTestWithRenderer([{provide: RendererFactory2, useClass: DomRendererFactory2}]));\n \n-    onlyInIvy('Renderer3 is supported only in Ivy')\n-        .it('with Renderer3',\n-            () =>\n-                runTestWithRenderer([{provide: RendererFactory2, useValue: domRendererFactory3}]));\n+    it('with Renderer3',\n+       () => runTestWithRenderer([{provide: RendererFactory2, useValue: domRendererFactory3}]));\n   });\n });"
        },
        {
            "sha": "bca21b65eb5b6d9e8fb0db97c0a4419a9a76cf22",
            "filename": "packages/core/test/acceptance/copy_definition_feature_spec.ts",
            "status": "modified",
            "additions": 64,
            "deletions": 67,
            "changes": 131,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fcopy_definition_feature_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fcopy_definition_feature_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fcopy_definition_feature_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -8,81 +8,78 @@\n \n import {Component, NgModule, ɵɵCopyDefinitionFeature as CopyDefinitionFeature, ɵɵdefineComponent as defineComponent, ɵɵInheritDefinitionFeature as InheritDefinitionFeature} from '@angular/core';\n import {TestBed} from '@angular/core/testing';\n-import {onlyInIvy} from '@angular/private/testing';\n \n-describe('Ivy CopyDefinitionFeature', () => {\n-  onlyInIvy('this feature is not required in View Engine')\n-      .it('should copy the template function of a component definition from parent to child',\n-          () => {\n-            // It would be nice if the base component could be JIT compiled. However, this creates\n-            // a getter for ɵcmp which precludes adding a static definition of that field for the\n-            // child class.\n-            // TODO(alxhub): see if there's a cleaner way to do this.\n-            class BaseComponent {\n-              name!: string;\n-              static ɵcmp = defineComponent({\n-                type: BaseComponent,\n-                selectors: [['some-cmp']],\n-                decls: 0,\n-                vars: 0,\n-                inputs: {name: 'name'},\n-                template:\n-                    function BaseComponent_Template(rf, ctx) {\n-                      ctx.rendered = true;\n-                    },\n-                encapsulation: 2\n-              });\n-              static ɵfac = function BaseComponent_Factory(t: any) {\n-                return new (t || BaseComponent)();\n-              };\n+describe('CopyDefinitionFeature', () => {\n+  it('should copy the template function of a component definition from parent to child', () => {\n+    // It would be nice if the base component could be JIT compiled. However, this creates\n+    // a getter for ɵcmp which precludes adding a static definition of that field for the\n+    // child class.\n+    // TODO(alxhub): see if there's a cleaner way to do this.\n+    class BaseComponent {\n+      name!: string;\n+      static ɵcmp = defineComponent({\n+        type: BaseComponent,\n+        selectors: [['some-cmp']],\n+        decls: 0,\n+        vars: 0,\n+        inputs: {name: 'name'},\n+        template:\n+            function BaseComponent_Template(rf, ctx) {\n+              ctx.rendered = true;\n+            },\n+        encapsulation: 2\n+      });\n+      static ɵfac = function BaseComponent_Factory(t: any) {\n+        return new (t || BaseComponent)();\n+      };\n \n-              rendered = false;\n-            }\n+      rendered = false;\n+    }\n \n-            class ChildComponent extends BaseComponent {\n-              static override ɵcmp = defineComponent({\n-                type: ChildComponent,\n-                selectors: [['some-cmp']],\n-                features: [InheritDefinitionFeature, CopyDefinitionFeature],\n-                decls: 0,\n-                vars: 0,\n-                template: function ChildComponent_Template(rf, ctx) {},\n-                encapsulation: 2\n-              });\n-              static override ɵfac = function ChildComponent_Factory(t: any) {\n-                return new (t || ChildComponent)();\n-              };\n-            }\n+    class ChildComponent extends BaseComponent {\n+      static override ɵcmp = defineComponent({\n+        type: ChildComponent,\n+        selectors: [['some-cmp']],\n+        features: [InheritDefinitionFeature, CopyDefinitionFeature],\n+        decls: 0,\n+        vars: 0,\n+        template: function ChildComponent_Template(rf, ctx) {},\n+        encapsulation: 2\n+      });\n+      static override ɵfac = function ChildComponent_Factory(t: any) {\n+        return new (t || ChildComponent)();\n+      };\n+    }\n \n-            @NgModule({\n-              declarations: [ChildComponent],\n-              exports: [ChildComponent],\n-            })\n-            class Module {\n-            }\n+    @NgModule({\n+      declarations: [ChildComponent],\n+      exports: [ChildComponent],\n+    })\n+    class Module {\n+    }\n \n-            @Component({\n-              selector: 'test-cmp',\n-              template: '<some-cmp name=\"Success!\"></some-cmp>',\n-            })\n-            class TestCmp {\n-            }\n+    @Component({\n+      selector: 'test-cmp',\n+      template: '<some-cmp name=\"Success!\"></some-cmp>',\n+    })\n+    class TestCmp {\n+    }\n \n-            TestBed.configureTestingModule({\n-              declarations: [TestCmp],\n-              imports: [Module],\n-            });\n+    TestBed.configureTestingModule({\n+      declarations: [TestCmp],\n+      imports: [Module],\n+    });\n \n-            const fixture = TestBed.createComponent(TestCmp);\n+    const fixture = TestBed.createComponent(TestCmp);\n \n-            // The child component should have matched and been instantiated.\n-            const child = fixture.debugElement.children[0].componentInstance as ChildComponent;\n-            expect(child instanceof ChildComponent).toBe(true);\n+    // The child component should have matched and been instantiated.\n+    const child = fixture.debugElement.children[0].componentInstance as ChildComponent;\n+    expect(child instanceof ChildComponent).toBe(true);\n \n-            // And the base class template function should've been called.\n-            expect(child.rendered).toBe(true);\n+    // And the base class template function should've been called.\n+    expect(child.rendered).toBe(true);\n \n-            // The input binding should have worked.\n-            expect(child.name).toBe('Success!');\n-          });\n+    // The input binding should have worked.\n+    expect(child.name).toBe('Success!');\n+  });\n });"
        },
        {
            "sha": "d7fdebce82b28b30a39edd0bb0209e2e41eebf32",
            "filename": "packages/core/test/acceptance/debug_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fdebug_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fdebug_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fdebug_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -13,11 +13,10 @@ import {TNodeType} from '@angular/core/src/render3/interfaces/node';\n import {HEADER_OFFSET} from '@angular/core/src/render3/interfaces/view';\n import {TestBed} from '@angular/core/testing';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {onlyInIvy} from '@angular/private/testing';\n \n import {matchDomElement, matchDomText, matchTI18n, matchTNode} from '../render3/matchers';\n \n-onlyInIvy('Ivy specific').describe('Debug Representation', () => {\n+describe('Debug Representation', () => {\n   it('should generate a human readable version', () => {\n     @Component({selector: 'my-comp', template: '<div id=\"123\">Hello World</div>'})\n     class MyComponent {"
        },
        {
            "sha": "c1dd2d6b72a649515d51a6c55089935a40a37ec3",
            "filename": "packages/core/test/acceptance/di_spec.ts",
            "status": "modified",
            "additions": 321,
            "deletions": 393,
            "changes": 714,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fdi_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fdi_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fdi_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -12,7 +12,6 @@ import {ɵINJECTOR_SCOPE} from '@angular/core/src/core';\n import {ViewRef as ViewRefInternal} from '@angular/core/src/render3/view_ref';\n import {TestBed} from '@angular/core/testing';\n import {By} from '@angular/platform-browser';\n-import {ivyEnabled, onlyInIvy} from '@angular/private/testing';\n import {BehaviorSubject} from 'rxjs';\n \n describe('di', () => {\n@@ -686,44 +685,42 @@ describe('di', () => {\n          expect(cmp.componentInstance.testB.a).toBeNull();\n        });\n \n-    onlyInIvy('Ivy has different error message for circular dependency')\n-        .it('should throw if directives try to inject each other', () => {\n-          @Directive({selector: '[dirB]'})\n-          class DirectiveB {\n-            constructor(@Inject(forwardRef(() => DirectiveA)) siblingDir: DirectiveA) {}\n-          }\n+    it('should throw if directives try to inject each other', () => {\n+      @Directive({selector: '[dirB]'})\n+      class DirectiveB {\n+        constructor(@Inject(forwardRef(() => DirectiveA)) siblingDir: DirectiveA) {}\n+      }\n \n-          @Directive({selector: '[dirA]'})\n-          class DirectiveA {\n-            constructor(siblingDir: DirectiveB) {}\n-          }\n+      @Directive({selector: '[dirA]'})\n+      class DirectiveA {\n+        constructor(siblingDir: DirectiveB) {}\n+      }\n \n-          @Component({template: '<div dirA dirB></div>'})\n-          class MyComp {\n-          }\n+      @Component({template: '<div dirA dirB></div>'})\n+      class MyComp {\n+      }\n \n-          TestBed.configureTestingModule({declarations: [DirectiveA, DirectiveB, MyComp]});\n-          expect(() => TestBed.createComponent(MyComp))\n-              .toThrowError(\n-                  'NG0200: Circular dependency in DI detected for DirectiveA. Find more at https://angular.io/errors/NG0200');\n-        });\n+      TestBed.configureTestingModule({declarations: [DirectiveA, DirectiveB, MyComp]});\n+      expect(() => TestBed.createComponent(MyComp))\n+          .toThrowError(\n+              'NG0200: Circular dependency in DI detected for DirectiveA. Find more at https://angular.io/errors/NG0200');\n+    });\n \n-    onlyInIvy('Ivy has different error message for circular dependency')\n-        .it('should throw if directive tries to inject itself', () => {\n-          @Directive({selector: '[dirA]'})\n-          class DirectiveA {\n-            constructor(siblingDir: DirectiveA) {}\n-          }\n+    it('should throw if directive tries to inject itself', () => {\n+      @Directive({selector: '[dirA]'})\n+      class DirectiveA {\n+        constructor(siblingDir: DirectiveA) {}\n+      }\n \n-          @Component({template: '<div dirA></div>'})\n-          class MyComp {\n-          }\n+      @Component({template: '<div dirA></div>'})\n+      class MyComp {\n+      }\n \n-          TestBed.configureTestingModule({declarations: [DirectiveA, DirectiveB, MyComp]});\n-          expect(() => TestBed.createComponent(MyComp))\n-              .toThrowError(\n-                  'NG0200: Circular dependency in DI detected for DirectiveA. Find more at https://angular.io/errors/NG0200');\n-        });\n+      TestBed.configureTestingModule({declarations: [DirectiveA, DirectiveB, MyComp]});\n+      expect(() => TestBed.createComponent(MyComp))\n+          .toThrowError(\n+              'NG0200: Circular dependency in DI detected for DirectiveA. Find more at https://angular.io/errors/NG0200');\n+    });\n \n     describe('flags', () => {\n       @Directive({selector: '[dirB]'})\n@@ -790,20 +787,19 @@ describe('di', () => {\n         });\n       });\n \n-      onlyInIvy('Ivy has different error message when dependency is not found')\n-          .it('should check only the current node with @Self', () => {\n-            @Directive({selector: '[dirA]'})\n-            class DirectiveA {\n-              constructor(@Self() public dirB: DirectiveB) {}\n-            }\n+      it('should check only the current node with @Self', () => {\n+        @Directive({selector: '[dirA]'})\n+        class DirectiveA {\n+          constructor(@Self() public dirB: DirectiveB) {}\n+        }\n \n-            @Component({template: '<div dirB><div dirA></div></div>'})\n-            class MyComp {\n-            }\n-            TestBed.configureTestingModule({declarations: [DirectiveA, DirectiveB, MyComp]});\n-            expect(() => TestBed.createComponent(MyComp))\n-                .toThrowError(/NG0201: No provider for DirectiveB found in NodeInjector/);\n-          });\n+        @Component({template: '<div dirB><div dirA></div></div>'})\n+        class MyComp {\n+        }\n+        TestBed.configureTestingModule({declarations: [DirectiveA, DirectiveB, MyComp]});\n+        expect(() => TestBed.createComponent(MyComp))\n+            .toThrowError(/NG0201: No provider for DirectiveB found in NodeInjector/);\n+      });\n \n       describe('SkipSelf', () => {\n         describe('Injectors', () => {\n@@ -919,18 +915,8 @@ describe('di', () => {\n                  imports: [MyModule],\n                });\n \n-               // If a token is injected with the @Host flag, the module injector is not searched\n-               // for that token in Ivy.\n-               if (ivyEnabled) {\n-                 expect(() => TestBed.createComponent(MyComponent))\n-                     .toThrowError(/NG0201: No provider for Injector found in NodeInjector/);\n-               } else {\n-                 const fixture = TestBed.createComponent(MyComponent);\n-                 fixture.detectChanges();\n-\n-                 expect(componentInjector!.get('token')).toBe('NG_MODULE');\n-                 expect(moduleInjector!.get('token')).toBe('NG_MODULE');\n-               }\n+               expect(() => TestBed.createComponent(MyComponent))\n+                   .toThrowError(/NG0201: No provider for Injector found in NodeInjector/);\n              });\n \n           it('should throw when injecting Injectors using @SkipSelf and @Host and no Injectors are available in a current view',\n@@ -962,10 +948,8 @@ describe('di', () => {\n                  declarations: [ParentComponent, ChildComponent],\n                });\n \n-               // Ivy has different error message when dependency is not found\n-               const expectedErrorMessage = ivyEnabled ?\n-                   /NG0201: No provider for Injector found in NodeInjector/ :\n-                   /No provider for Injector/;\n+               const expectedErrorMessage =\n+                   /NG0201: No provider for Injector found in NodeInjector/;\n                expect(() => TestBed.createComponent(ParentComponent))\n                    .toThrowError(expectedErrorMessage);\n              });\n@@ -999,10 +983,8 @@ describe('di', () => {\n                  declarations: [ParentComponent, ChildComponent],\n                });\n \n-               // Ivy has different error message when dependency is not found\n-               const expectedErrorMessage = ivyEnabled ?\n-                   /NG0201: No provider for Injector found in NodeInjector/ :\n-                   /No provider for Injector/;\n+               const expectedErrorMessage =\n+                   /NG0201: No provider for Injector found in NodeInjector/;\n                expect(() => TestBed.createComponent(ParentComponent))\n                    .not.toThrowError(expectedErrorMessage);\n              });\n@@ -1195,12 +1177,8 @@ describe('di', () => {\n             const fixture = TestBed.createComponent(ParentComponent);\n             fixture.detectChanges();\n \n-            if (ivyEnabled) {\n-              expect(requestedRef!.element.nativeElement).toBe(fixture.nativeElement.firstChild);\n-              expect(requestedRef!.element.nativeElement.tagName).toBe('DIV');\n-            } else {\n-              expect(requestedRef!).toBeNull();\n-            }\n+            expect(requestedRef!.element.nativeElement).toBe(fixture.nativeElement.firstChild);\n+            expect(requestedRef!.element.nativeElement.tagName).toBe('DIV');\n           });\n \n           it('should work for `ChangeDetectorRef` token', () => {\n@@ -1346,9 +1324,7 @@ describe('di', () => {\n               imports: [CommonModule],\n               declarations: [MyDir, ChildComp, MyComp],\n             });\n-            // Ivy has different error message when dependency is not found\n-            const expectedErrorMessage = ivyEnabled ? /NG0201: No provider for TemplateRef found/ :\n-                                                      /No provider for TemplateRef/;\n+            const expectedErrorMessage = /NG0201: No provider for TemplateRef found/;\n             expect(() => {\n               const fixture = TestBed.createComponent(MyComp);\n               fixture.detectChanges();\n@@ -1372,9 +1348,7 @@ describe('di', () => {\n               imports: [CommonModule],\n               declarations: [DirA, MyComp],\n             });\n-            // Ivy has different error message when dependency is not found\n-            const expectedErrorMessage = ivyEnabled ? /NG0201: No provider for TemplateRef found/ :\n-                                                      /No provider for TemplateRef/;\n+            const expectedErrorMessage = /NG0201: No provider for TemplateRef found/;\n             expect(() => {\n               const fixture = TestBed.createComponent(MyComp);\n               fixture.detectChanges();\n@@ -1489,20 +1463,12 @@ describe('di', () => {\n             TestBed.configureTestingModule(\n                 {declarations: [ParentDirective, ChildDirective, MyComp]});\n \n-            if (ivyEnabled) {\n-              const fixture = TestBed.createComponent(MyComp);\n-              fixture.detectChanges();\n+            const fixture = TestBed.createComponent(MyComp);\n+            fixture.detectChanges();\n \n-              // Assert against the `element` since Ivy always returns a new ViewContainerRef.\n-              expect(childViewContainer!.element.nativeElement)\n-                  .toBe(parentViewContainer!.element.nativeElement);\n-              expect(parentViewContainer!.element.nativeElement.tagName).toBe('DIV');\n-            } else {\n-              // Template parse errors happen in VE\n-              // \"<div parent>parent [ERROR ->]<span child>child</span></div>\"\n-              expect(() => TestBed.createComponent(MyComp))\n-                  .toThrowError(/No provider for ViewContainerRef/);\n-            }\n+            expect(childViewContainer!.element.nativeElement)\n+                .toBe(parentViewContainer!.element.nativeElement);\n+            expect(parentViewContainer!.element.nativeElement.tagName).toBe('DIV');\n           });\n \n           it('should get ViewContainerRef using @SkipSelf and @Host on parent', () => {\n@@ -1524,13 +1490,7 @@ describe('di', () => {\n             const fixture = TestBed.createComponent(MyComp);\n             fixture.detectChanges();\n \n-            if (ivyEnabled) {\n-              // Assert against the `element` since Ivy always returns a new ViewContainerRef.\n-              expect(parentViewContainer!.element.nativeElement.tagName).toBe('DIV');\n-            } else {\n-              // VE Doesn't throw, but the ref is null\n-              expect(parentViewContainer!).toBeNull();\n-            }\n+            expect(parentViewContainer!.element.nativeElement.tagName).toBe('DIV');\n           });\n \n           it('should throw when injecting ViewContainerRef using @SkipSelf and no ViewContainerRef are available in a current view',\n@@ -1704,12 +1664,7 @@ describe('di', () => {\n             fixture.detectChanges();\n \n             const child = fixture.componentInstance.child;\n-            if (ivyEnabled) {\n-              expect(child.bar).toBe('Bar as Provider');\n-            } else {\n-              // this seems like a ViewEngine bug\n-              expect(child.bar).toBe('Bar as ViewProvider');\n-            }\n+            expect(child.bar).toBe('Bar as Provider');\n           });\n \n           it('should throw when @SkipSelf and no accessible viewProvider', () => {\n@@ -1852,66 +1807,61 @@ describe('di', () => {\n           expect(dirComp.comp).toBe(myComp);\n         });\n \n-        onlyInIvy('Ivy has different error message when dependency is not found')\n-            .it('should not find providers on the host itself', () => {\n-              @Component({\n-                selector: 'my-comp',\n-                template: '<div dirString></div>',\n-                providers: [{provide: String, useValue: 'Foo'}]\n-              })\n-              class MyComp {\n-              }\n+        it('should not find providers on the host itself', () => {\n+          @Component({\n+            selector: 'my-comp',\n+            template: '<div dirString></div>',\n+            providers: [{provide: String, useValue: 'Foo'}]\n+          })\n+          class MyComp {\n+          }\n \n-              @Component({template: '<my-comp></my-comp>'})\n-              class MyApp {\n-              }\n+          @Component({template: '<my-comp></my-comp>'})\n+          class MyApp {\n+          }\n \n-              TestBed.configureTestingModule({declarations: [DirectiveString, MyComp, MyApp]});\n-              expect(() => TestBed.createComponent(MyApp))\n-                  .toThrowError(\n-                      'NG0201: No provider for String found in NodeInjector. Find more at https://angular.io/errors/NG0201');\n-            });\n+          TestBed.configureTestingModule({declarations: [DirectiveString, MyComp, MyApp]});\n+          expect(() => TestBed.createComponent(MyApp))\n+              .toThrowError(\n+                  'NG0201: No provider for String found in NodeInjector. Find more at https://angular.io/errors/NG0201');\n+        });\n \n-        onlyInIvy('Ivy has different error message when dependency is not found')\n-            .it('should not find other directives on the host itself', () => {\n-              @Component({selector: 'my-comp', template: '<div dirA></div>'})\n-              class MyComp {\n-              }\n+        it('should not find other directives on the host itself', () => {\n+          @Component({selector: 'my-comp', template: '<div dirA></div>'})\n+          class MyComp {\n+          }\n \n-              @Component({template: '<my-comp dirB></my-comp>'})\n-              class MyApp {\n-              }\n+          @Component({template: '<my-comp dirB></my-comp>'})\n+          class MyApp {\n+          }\n \n-              TestBed.configureTestingModule(\n-                  {declarations: [DirectiveA, DirectiveB, MyComp, MyApp]});\n-              expect(() => TestBed.createComponent(MyApp))\n-                  .toThrowError(/NG0201: No provider for DirectiveB found in NodeInjector/);\n-            });\n+          TestBed.configureTestingModule({declarations: [DirectiveA, DirectiveB, MyComp, MyApp]});\n+          expect(() => TestBed.createComponent(MyApp))\n+              .toThrowError(/NG0201: No provider for DirectiveB found in NodeInjector/);\n+        });\n \n-        onlyInIvy('Ivy has different error message when dependency is not found')\n-            .it('should not find providers on the host itself if in inline view', () => {\n-              @Component({\n-                selector: 'my-comp',\n-                template: '<ng-container *ngIf=\"showing\"><div dirA></div></ng-container>'\n-              })\n-              class MyComp {\n-                showing = false;\n-              }\n+        it('should not find providers on the host itself if in inline view', () => {\n+          @Component({\n+            selector: 'my-comp',\n+            template: '<ng-container *ngIf=\"showing\"><div dirA></div></ng-container>'\n+          })\n+          class MyComp {\n+            showing = false;\n+          }\n \n-              @Component({template: '<my-comp dirB></my-comp>'})\n-              class MyApp {\n-                @ViewChild(MyComp) myComp!: MyComp;\n-              }\n+          @Component({template: '<my-comp dirB></my-comp>'})\n+          class MyApp {\n+            @ViewChild(MyComp) myComp!: MyComp;\n+          }\n \n-              TestBed.configureTestingModule(\n-                  {declarations: [DirectiveA, DirectiveB, MyComp, MyApp]});\n-              const fixture = TestBed.createComponent(MyApp);\n-              fixture.detectChanges();\n-              expect(() => {\n-                fixture.componentInstance.myComp.showing = true;\n-                fixture.detectChanges();\n-              }).toThrowError(/NG0201: No provider for DirectiveB found in NodeInjector/);\n-            });\n+          TestBed.configureTestingModule({declarations: [DirectiveA, DirectiveB, MyComp, MyApp]});\n+          const fixture = TestBed.createComponent(MyApp);\n+          fixture.detectChanges();\n+          expect(() => {\n+            fixture.componentInstance.myComp.showing = true;\n+            fixture.detectChanges();\n+          }).toThrowError(/NG0201: No provider for DirectiveB found in NodeInjector/);\n+        });\n \n         it('should find providers across embedded views if not passing component boundary', () => {\n           @Component({template: '<div dirB><div *ngIf=\"showing\" dirA></div></div>'})\n@@ -1932,26 +1882,25 @@ describe('di', () => {\n           expect(dirA.dirB).toBe(dirB);\n         });\n \n-        onlyInIvy('Ivy has different error message when dependency is not found')\n-            .it('should not find component above the host', () => {\n-              @Directive({selector: '[dirComp]'})\n-              class DirectiveComp {\n-                constructor(@Inject(forwardRef(() => MyApp)) @Host() public comp: MyApp) {}\n-              }\n+        it('should not find component above the host', () => {\n+          @Directive({selector: '[dirComp]'})\n+          class DirectiveComp {\n+            constructor(@Inject(forwardRef(() => MyApp)) @Host() public comp: MyApp) {}\n+          }\n \n-              @Component({selector: 'my-comp', template: '<div dirComp></div>'})\n-              class MyComp {\n-              }\n+          @Component({selector: 'my-comp', template: '<div dirComp></div>'})\n+          class MyComp {\n+          }\n \n-              @Component({template: '<my-comp></my-comp>'})\n-              class MyApp {\n-              }\n+          @Component({template: '<my-comp></my-comp>'})\n+          class MyApp {\n+          }\n \n-              TestBed.configureTestingModule({declarations: [DirectiveComp, MyComp, MyApp]});\n-              expect(() => TestBed.createComponent(MyApp))\n-                  .toThrowError(\n-                      'NG0201: No provider for MyApp found in NodeInjector. Find more at https://angular.io/errors/NG0201');\n-            });\n+          TestBed.configureTestingModule({declarations: [DirectiveComp, MyComp, MyApp]});\n+          expect(() => TestBed.createComponent(MyApp))\n+              .toThrowError(\n+                  'NG0201: No provider for MyApp found in NodeInjector. Find more at https://angular.io/errors/NG0201');\n+        });\n \n         describe('regression', () => {\n           // based on https://stackblitz.com/edit/angular-riss8k?file=src/app/app.component.ts\n@@ -2007,125 +1956,121 @@ describe('di', () => {\n         });\n       });\n \n-      onlyInIvy('Ivy supports `InjectFlags` in NodeInjector')\n-          .describe('`InjectFlags` support in NodeInjector', () => {\n-            it('should support Optional flag in NodeInjector', () => {\n-              const NON_EXISTING_PROVIDER = new InjectionToken<string>('non-existing');\n-              @Component({template: '...'})\n-              class MyComp {\n-                tokenViaInjector =\n-                    this.injector.get(NON_EXISTING_PROVIDER, null, InjectFlags.Optional);\n-                constructor(\n-                    public injector: Injector,\n-                    @Inject(NON_EXISTING_PROVIDER) @Optional() public tokenViaConstructor: string) {\n-                }\n-              }\n-              TestBed.configureTestingModule({declarations: [MyComp]});\n-              const fixture = TestBed.createComponent(MyComp);\n-              fixture.detectChanges();\n-              expect(fixture.componentInstance.tokenViaInjector).toBe(null);\n-              expect(fixture.componentInstance.tokenViaInjector)\n-                  .toBe(fixture.componentInstance.tokenViaConstructor);\n-            });\n-            it('should support SkipSelf flag in NodeInjector', () => {\n-              const TOKEN = new InjectionToken<string>('token');\n-              @Component({\n-                selector: 'parent',\n-                template: '<child></child>',\n-                providers: [{\n-                  provide: TOKEN,\n-                  useValue: 'PARENT',\n-                }]\n-              })\n-              class ParentComponent {\n-              }\n+      describe('`InjectFlags` support in NodeInjector', () => {\n+        it('should support Optional flag in NodeInjector', () => {\n+          const NON_EXISTING_PROVIDER = new InjectionToken<string>('non-existing');\n+          @Component({template: '...'})\n+          class MyComp {\n+            tokenViaInjector = this.injector.get(NON_EXISTING_PROVIDER, null, InjectFlags.Optional);\n+            constructor(\n+                public injector: Injector,\n+                @Inject(NON_EXISTING_PROVIDER) @Optional() public tokenViaConstructor: string) {}\n+          }\n+          TestBed.configureTestingModule({declarations: [MyComp]});\n+          const fixture = TestBed.createComponent(MyComp);\n+          fixture.detectChanges();\n+          expect(fixture.componentInstance.tokenViaInjector).toBe(null);\n+          expect(fixture.componentInstance.tokenViaInjector)\n+              .toBe(fixture.componentInstance.tokenViaConstructor);\n+        });\n+        it('should support SkipSelf flag in NodeInjector', () => {\n+          const TOKEN = new InjectionToken<string>('token');\n+          @Component({\n+            selector: 'parent',\n+            template: '<child></child>',\n+            providers: [{\n+              provide: TOKEN,\n+              useValue: 'PARENT',\n+            }]\n+          })\n+          class ParentComponent {\n+          }\n \n-              @Component({\n-                selector: 'child',\n-                template: '...',\n-                providers: [{\n-                  provide: TOKEN,\n-                  useValue: 'CHILD',\n-                }]\n-              })\n-              class ChildComponent {\n-                tokenViaInjector = this.injector.get(TOKEN, null, InjectFlags.SkipSelf);\n-                constructor(\n-                    public injector: Injector,\n-                    @Inject(TOKEN) @SkipSelf() public tokenViaConstructor: string) {}\n-              }\n+          @Component({\n+            selector: 'child',\n+            template: '...',\n+            providers: [{\n+              provide: TOKEN,\n+              useValue: 'CHILD',\n+            }]\n+          })\n+          class ChildComponent {\n+            tokenViaInjector = this.injector.get(TOKEN, null, InjectFlags.SkipSelf);\n+            constructor(\n+                public injector: Injector,\n+                @Inject(TOKEN) @SkipSelf() public tokenViaConstructor: string) {}\n+          }\n \n-              TestBed.configureTestingModule({\n-                declarations: [ParentComponent, ChildComponent],\n-              });\n-              const fixture = TestBed.createComponent(ParentComponent);\n-              fixture.detectChanges();\n+          TestBed.configureTestingModule({\n+            declarations: [ParentComponent, ChildComponent],\n+          });\n+          const fixture = TestBed.createComponent(ParentComponent);\n+          fixture.detectChanges();\n \n-              const childComponent =\n-                  fixture.debugElement.query(By.directive(ChildComponent)).componentInstance;\n-              expect(childComponent.tokenViaInjector).toBe('PARENT');\n-              expect(childComponent.tokenViaConstructor).toBe(childComponent.tokenViaInjector);\n-            });\n-            it('should support Host flag in NodeInjector', () => {\n-              const TOKEN = new InjectionToken<string>('token');\n-              @Directive({selector: '[dirString]'})\n-              class DirectiveString {\n-                tokenViaInjector = this.injector.get(TOKEN, null, InjectFlags.Host);\n-                constructor(\n-                    public injector: Injector,\n-                    @Inject(TOKEN) @Host() public tokenViaConstructor: string) {}\n-              }\n+          const childComponent =\n+              fixture.debugElement.query(By.directive(ChildComponent)).componentInstance;\n+          expect(childComponent.tokenViaInjector).toBe('PARENT');\n+          expect(childComponent.tokenViaConstructor).toBe(childComponent.tokenViaInjector);\n+        });\n+        it('should support Host flag in NodeInjector', () => {\n+          const TOKEN = new InjectionToken<string>('token');\n+          @Directive({selector: '[dirString]'})\n+          class DirectiveString {\n+            tokenViaInjector = this.injector.get(TOKEN, null, InjectFlags.Host);\n+            constructor(\n+                public injector: Injector,\n+                @Inject(TOKEN) @Host() public tokenViaConstructor: string) {}\n+          }\n \n-              @Component({\n-                template: '<div dirString></div>',\n-                viewProviders: [{provide: TOKEN, useValue: 'Foo'}]\n-              })\n-              class MyComp {\n-                @ViewChild(DirectiveString) dirString!: DirectiveString;\n-              }\n+          @Component({\n+            template: '<div dirString></div>',\n+            viewProviders: [{provide: TOKEN, useValue: 'Foo'}]\n+          })\n+          class MyComp {\n+            @ViewChild(DirectiveString) dirString!: DirectiveString;\n+          }\n \n-              TestBed.configureTestingModule({declarations: [DirectiveString, MyComp]});\n-              const fixture = TestBed.createComponent(MyComp);\n-              fixture.detectChanges();\n+          TestBed.configureTestingModule({declarations: [DirectiveString, MyComp]});\n+          const fixture = TestBed.createComponent(MyComp);\n+          fixture.detectChanges();\n \n-              const dirString = fixture.componentInstance.dirString;\n-              expect(dirString.tokenViaConstructor).toBe('Foo');\n-              expect(dirString.tokenViaConstructor).toBe(dirString.tokenViaInjector!);\n-            });\n-            it('should support multiple flags in NodeInjector', () => {\n-              @Directive({selector: '[dirA]'})\n-              class DirectiveA {\n-              }\n-              @Directive({selector: '[dirB]'})\n-              class DirectiveB {\n-                public tokenSelfViaInjector =\n-                    this.injector.get(DirectiveA, null, InjectFlags.Self|InjectFlags.Optional);\n-                public tokenHostViaInjector =\n-                    this.injector.get(DirectiveA, null, InjectFlags.Host|InjectFlags.Optional);\n-                constructor(\n-                    public injector: Injector,\n-                    @Inject(DirectiveA) @Self() @Optional() public tokenSelfViaConstructor:\n-                        DirectiveA,\n-                    @Inject(DirectiveA) @Host() @Optional() public tokenHostViaConstructor:\n-                        DirectiveA) {}\n-              }\n+          const dirString = fixture.componentInstance.dirString;\n+          expect(dirString.tokenViaConstructor).toBe('Foo');\n+          expect(dirString.tokenViaConstructor).toBe(dirString.tokenViaInjector!);\n+        });\n+        it('should support multiple flags in NodeInjector', () => {\n+          @Directive({selector: '[dirA]'})\n+          class DirectiveA {\n+          }\n+          @Directive({selector: '[dirB]'})\n+          class DirectiveB {\n+            public tokenSelfViaInjector =\n+                this.injector.get(DirectiveA, null, InjectFlags.Self|InjectFlags.Optional);\n+            public tokenHostViaInjector =\n+                this.injector.get(DirectiveA, null, InjectFlags.Host|InjectFlags.Optional);\n+            constructor(\n+                public injector: Injector,\n+                @Inject(DirectiveA) @Self() @Optional() public tokenSelfViaConstructor: DirectiveA,\n+                @Inject(DirectiveA) @Host() @Optional() public tokenHostViaConstructor:\n+                    DirectiveA) {}\n+          }\n \n-              @Component({template: '<div dirB></div>'})\n-              class MyComp {\n-                @ViewChild(DirectiveB) dirB!: DirectiveB;\n-              }\n+          @Component({template: '<div dirB></div>'})\n+          class MyComp {\n+            @ViewChild(DirectiveB) dirB!: DirectiveB;\n+          }\n \n-              TestBed.configureTestingModule({declarations: [DirectiveB, MyComp]});\n-              const fixture = TestBed.createComponent(MyComp);\n-              fixture.detectChanges();\n+          TestBed.configureTestingModule({declarations: [DirectiveB, MyComp]});\n+          const fixture = TestBed.createComponent(MyComp);\n+          fixture.detectChanges();\n \n-              const dirB = fixture.componentInstance.dirB;\n-              expect(dirB.tokenSelfViaInjector).toBeNull();\n-              expect(dirB.tokenSelfViaInjector).toBe(dirB.tokenSelfViaConstructor);\n-              expect(dirB.tokenHostViaInjector).toBeNull();\n-              expect(dirB.tokenHostViaInjector).toBe(dirB.tokenHostViaConstructor);\n-            });\n-          });\n+          const dirB = fixture.componentInstance.dirB;\n+          expect(dirB.tokenSelfViaInjector).toBeNull();\n+          expect(dirB.tokenSelfViaInjector).toBe(dirB.tokenSelfViaConstructor);\n+          expect(dirB.tokenHostViaInjector).toBeNull();\n+          expect(dirB.tokenHostViaInjector).toBe(dirB.tokenHostViaConstructor);\n+        });\n+      });\n     });\n   });\n \n@@ -2233,11 +2178,9 @@ describe('di', () => {\n       const fixture = TestBed.createComponent(MyComp);\n       expect(fixture.componentInstance.myService.dep instanceof Dependency).toBe(true);\n \n-      if (ivyEnabled) {\n-        expect(warnSpy).toHaveBeenCalledWith(\n-            `DEPRECATED: DI is instantiating a token \"SubSubClass\" that inherits its @Injectable decorator but does not provide one itself.\\n` +\n-            `This will become an error in a future version of Angular. Please add @Injectable() to the \"SubSubClass\" class.`);\n-      }\n+      expect(warnSpy).toHaveBeenCalledWith(\n+          `DEPRECATED: DI is instantiating a token \"SubSubClass\" that inherits its @Injectable decorator but does not provide one itself.\\n` +\n+          `This will become an error in a future version of Angular. Please add @Injectable() to the \"SubSubClass\" class.`);\n     });\n \n     it('should instantiate correct class when undecorated class extends an injectable', () => {\n@@ -2264,11 +2207,9 @@ describe('di', () => {\n       expect(provider instanceof MyRootService).toBe(true);\n       expect(provider.id).toBe(2);\n \n-      if (ivyEnabled) {\n-        expect(warnSpy).toHaveBeenCalledWith(\n-            `DEPRECATED: DI is instantiating a token \"MyRootService\" that inherits its @Injectable decorator but does not provide one itself.\\n` +\n-            `This will become an error in a future version of Angular. Please add @Injectable() to the \"MyRootService\" class.`);\n-      }\n+      expect(warnSpy).toHaveBeenCalledWith(\n+          `DEPRECATED: DI is instantiating a token \"MyRootService\" that inherits its @Injectable decorator but does not provide one itself.\\n` +\n+          `This will become an error in a future version of Angular. Please add @Injectable() to the \"MyRootService\" class.`);\n     });\n \n     it('should inject services in constructor with overloads', () => {\n@@ -2337,12 +2278,7 @@ describe('di', () => {\n       fixture.detectChanges();\n \n       expect(provider!.getMessage()).toBe('bar');\n-\n-      // ViewEngine incorrectly uses the original class DI config, instead of the one from\n-      // useClass.\n-      if (ivyEnabled) {\n-        expect(provider!.dep.name).toBe('BarServiceDep');\n-      }\n+      expect(provider!.dep.name).toBe('BarServiceDep');\n     });\n \n     it('should use constructor config directly when token is explicitly provided via useClass',\n@@ -2384,13 +2320,8 @@ describe('di', () => {\n \n       expect(directProvider!.getMessage()).toBe('bar');\n       expect(overriddenProvider!.getMessage()).toBe('foo');\n-\n-      // ViewEngine incorrectly uses the original class DI config, instead of the one from\n-      // useClass.\n-      if (ivyEnabled) {\n-        expect(directProvider!.dep.name).toBe('BarServiceDep');\n-        expect(overriddenProvider!.dep.name).toBe('FooServiceDep');\n-      }\n+      expect(directProvider!.dep.name).toBe('BarServiceDep');\n+      expect(overriddenProvider!.dep.name).toBe('FooServiceDep');\n     });\n \n     it('should use constructor config directly when token is explicitly provided as a type provider',\n@@ -2652,38 +2583,37 @@ describe('di', () => {\n           this.value = (templateRef.constructor as any).name;\n         }\n       }\n-      onlyInIvy('Ivy creates a unique instance of TemplateRef for each directive')\n-          .it('should create directive with TemplateRef dependencies', () => {\n-            @Directive({selector: '[otherDir]', exportAs: 'otherDir'})\n-            class MyOtherDir {\n-              isSameInstance: boolean;\n-              constructor(public templateRef: TemplateRef<any>, public directive: MyDir) {\n-                this.isSameInstance = templateRef === directive.templateRef;\n-              }\n-            }\n \n-            @Component({\n-              template: '<ng-template dir otherDir #dir=\"dir\" #otherDir=\"otherDir\"></ng-template>'\n-            })\n-            class MyComp {\n-              @ViewChild(MyDir) directive!: MyDir;\n-              @ViewChild(MyOtherDir) otherDirective!: MyOtherDir;\n-            }\n+      it('should create directive with TemplateRef dependencies', () => {\n+        @Directive({selector: '[otherDir]', exportAs: 'otherDir'})\n+        class MyOtherDir {\n+          isSameInstance: boolean;\n+          constructor(public templateRef: TemplateRef<any>, public directive: MyDir) {\n+            this.isSameInstance = templateRef === directive.templateRef;\n+          }\n+        }\n \n-            TestBed.configureTestingModule({declarations: [MyDir, MyOtherDir, MyComp]});\n-            const fixture = TestBed.createComponent(MyComp);\n-            fixture.detectChanges();\n+        @Component(\n+            {template: '<ng-template dir otherDir #dir=\"dir\" #otherDir=\"otherDir\"></ng-template>'})\n+        class MyComp {\n+          @ViewChild(MyDir) directive!: MyDir;\n+          @ViewChild(MyOtherDir) otherDirective!: MyOtherDir;\n+        }\n \n-            const directive = fixture.componentInstance.directive;\n-            const otherDirective = fixture.componentInstance.otherDirective;\n+        TestBed.configureTestingModule({declarations: [MyDir, MyOtherDir, MyComp]});\n+        const fixture = TestBed.createComponent(MyComp);\n+        fixture.detectChanges();\n \n-            expect(directive.value).toContain('TemplateRef');\n-            expect(directive.templateRef).not.toBeNull();\n-            expect(otherDirective.templateRef).not.toBeNull();\n+        const directive = fixture.componentInstance.directive;\n+        const otherDirective = fixture.componentInstance.otherDirective;\n \n-            // Each TemplateRef instance should be unique\n-            expect(otherDirective.isSameInstance).toBe(false);\n-          });\n+        expect(directive.value).toContain('TemplateRef');\n+        expect(directive.templateRef).not.toBeNull();\n+        expect(otherDirective.templateRef).not.toBeNull();\n+\n+        // Each TemplateRef instance should be unique\n+        expect(otherDirective.isSameInstance).toBe(false);\n+      });\n \n       it('should throw if injected on an element', () => {\n         @Component({template: '<div dir></div>'})\n@@ -2721,42 +2651,41 @@ describe('di', () => {\n     });\n \n     describe('ViewContainerRef', () => {\n-      onlyInIvy('Ivy creates a unique instance of ViewContainerRef for each directive')\n-          .it('should create directive with ViewContainerRef dependencies', () => {\n-            @Directive({selector: '[dir]', exportAs: 'dir'})\n-            class MyDir {\n-              value: string;\n-              constructor(public viewContainerRef: ViewContainerRef) {\n-                this.value = (viewContainerRef.constructor as any).name;\n-              }\n-            }\n-            @Directive({selector: '[otherDir]', exportAs: 'otherDir'})\n-            class MyOtherDir {\n-              isSameInstance: boolean;\n-              constructor(public viewContainerRef: ViewContainerRef, public directive: MyDir) {\n-                this.isSameInstance = viewContainerRef === directive.viewContainerRef;\n-              }\n-            }\n-            @Component({template: '<div dir otherDir #dir=\"dir\" #otherDir=\"otherDir\"></div>'})\n-            class MyComp {\n-              @ViewChild(MyDir) directive!: MyDir;\n-              @ViewChild(MyOtherDir) otherDirective!: MyOtherDir;\n-            }\n+      it('should create directive with ViewContainerRef dependencies', () => {\n+        @Directive({selector: '[dir]', exportAs: 'dir'})\n+        class MyDir {\n+          value: string;\n+          constructor(public viewContainerRef: ViewContainerRef) {\n+            this.value = (viewContainerRef.constructor as any).name;\n+          }\n+        }\n+        @Directive({selector: '[otherDir]', exportAs: 'otherDir'})\n+        class MyOtherDir {\n+          isSameInstance: boolean;\n+          constructor(public viewContainerRef: ViewContainerRef, public directive: MyDir) {\n+            this.isSameInstance = viewContainerRef === directive.viewContainerRef;\n+          }\n+        }\n+        @Component({template: '<div dir otherDir #dir=\"dir\" #otherDir=\"otherDir\"></div>'})\n+        class MyComp {\n+          @ViewChild(MyDir) directive!: MyDir;\n+          @ViewChild(MyOtherDir) otherDirective!: MyOtherDir;\n+        }\n \n-            TestBed.configureTestingModule({declarations: [MyDir, MyOtherDir, MyComp]});\n-            const fixture = TestBed.createComponent(MyComp);\n-            fixture.detectChanges();\n+        TestBed.configureTestingModule({declarations: [MyDir, MyOtherDir, MyComp]});\n+        const fixture = TestBed.createComponent(MyComp);\n+        fixture.detectChanges();\n \n-            const directive = fixture.componentInstance.directive;\n-            const otherDirective = fixture.componentInstance.otherDirective;\n+        const directive = fixture.componentInstance.directive;\n+        const otherDirective = fixture.componentInstance.otherDirective;\n \n-            expect(directive.value).toContain('ViewContainerRef');\n-            expect(directive.viewContainerRef).not.toBeNull();\n-            expect(otherDirective.viewContainerRef).not.toBeNull();\n+        expect(directive.value).toContain('ViewContainerRef');\n+        expect(directive.viewContainerRef).not.toBeNull();\n+        expect(otherDirective.viewContainerRef).not.toBeNull();\n \n-            // Each ViewContainerRef instance should be unique\n-            expect(otherDirective.isSameInstance).toBe(false);\n-          });\n+        // Each ViewContainerRef instance should be unique\n+        expect(otherDirective.isSameInstance).toBe(false);\n+      });\n \n       it('should sync ViewContainerRef state between all injected instances', () => {\n         @Component({\n@@ -3538,39 +3467,38 @@ describe('di', () => {\n   describe('provider access on the same node', () => {\n     const token = new InjectionToken<number>('token');\n \n-    onlyInIvy('accessing providers on the same node through a pipe was not supported in ViewEngine')\n-        .it('pipes should access providers from the component they are on', () => {\n-          @Pipe({name: 'token'})\n-          class TokenPipe {\n-            constructor(@Inject(token) private _token: string) {}\n+    it('pipes should access providers from the component they are on', () => {\n+      @Pipe({name: 'token'})\n+      class TokenPipe {\n+        constructor(@Inject(token) private _token: string) {}\n \n-            transform(value: string): string {\n-              return value + this._token;\n-            }\n-          }\n+        transform(value: string): string {\n+          return value + this._token;\n+        }\n+      }\n \n-          @Component({\n-            selector: 'child-comp',\n-            template: '{{value}}',\n-            providers: [{provide: token, useValue: 'child'}]\n-          })\n-          class ChildComp {\n-            @Input() value: any;\n-          }\n+      @Component({\n+        selector: 'child-comp',\n+        template: '{{value}}',\n+        providers: [{provide: token, useValue: 'child'}]\n+      })\n+      class ChildComp {\n+        @Input() value: any;\n+      }\n \n-          @Component({\n-            template: `<child-comp [value]=\"'' | token\"></child-comp>`,\n-            providers: [{provide: token, useValue: 'parent'}]\n-          })\n-          class App {\n-          }\n+      @Component({\n+        template: `<child-comp [value]=\"'' | token\"></child-comp>`,\n+        providers: [{provide: token, useValue: 'parent'}]\n+      })\n+      class App {\n+      }\n \n-          TestBed.configureTestingModule({declarations: [App, ChildComp, TokenPipe]});\n-          const fixture = TestBed.createComponent(App);\n-          fixture.detectChanges();\n+      TestBed.configureTestingModule({declarations: [App, ChildComp, TokenPipe]});\n+      const fixture = TestBed.createComponent(App);\n+      fixture.detectChanges();\n \n-          expect(fixture.nativeElement.textContent.trim()).toBe('child');\n-        });\n+      expect(fixture.nativeElement.textContent.trim()).toBe('child');\n+    });\n \n     it('pipes should not access viewProviders from the component they are on', () => {\n       @Pipe({name: 'token'})"
        },
        {
            "sha": "f7c0450c312b6e6b9d70d31bafc22263e9091ede",
            "filename": "packages/core/test/acceptance/discover_utils_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fdiscover_utils_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fdiscover_utils_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fdiscover_utils_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -14,13 +14,12 @@ import {isLView} from '@angular/core/src/render3/interfaces/type_checks';\n import {CONTEXT} from '@angular/core/src/render3/interfaces/view';\n import {ComponentFixture, TestBed} from '@angular/core/testing';\n import {getElementStyles} from '@angular/core/testing/src/styling';\n-import {onlyInIvy} from '@angular/private/testing';\n \n import {getLContext} from '../../src/render3/context_discovery';\n import {getHostElement, markDirty} from '../../src/render3/index';\n import {ComponentDebugMetadata, getComponent, getComponentLView, getContext, getDebugNode, getDirectiveMetadata, getDirectives, getInjectionTokens, getInjector, getListeners, getLocalRefs, getOwningComponent, getRootComponents} from '../../src/render3/util/discovery_utils';\n \n-onlyInIvy('Ivy-specific utilities').describe('discovery utils', () => {\n+describe('discovery utils', () => {\n   let fixture: ComponentFixture<MyApp>;\n   let myApp: MyApp;\n   let dirA: DirectiveA[];\n@@ -314,7 +313,7 @@ onlyInIvy('Ivy-specific utilities').describe('discovery utils', () => {\n   });\n });\n \n-onlyInIvy('Ivy-specific utilities').describe('discovery utils deprecated', () => {\n+describe('discovery utils deprecated', () => {\n   describe('getRootComponents()', () => {\n     it('should return a list of the root components of the application from an element', () => {\n       @Component({selector: 'inner-comp', template: '<div></div>'})"
        },
        {
            "sha": "f15e7e06f7adab1a8ace6b2a10bf345cc122d83e",
            "filename": "packages/core/test/acceptance/exports_spec.ts",
            "status": "modified",
            "additions": 31,
            "deletions": 59,
            "changes": 90,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fexports_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fexports_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fexports_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -8,7 +8,6 @@\n \n import {Component, Directive, DoCheck, Input, OnChanges, OnInit, SimpleChanges, Type} from '@angular/core';\n import {TestBed} from '@angular/core/testing';\n-import {modifiedInIvy, onlyInIvy} from '@angular/private/testing';\n \n describe('exports', () => {\n   beforeEach(() => {\n@@ -49,49 +48,26 @@ describe('exports', () => {\n       expect(fixture.nativeElement.lastChild.textContent).toContain('Drew!?@');  // text node\n     });\n \n-    modifiedInIvy('Supporting input changes in hooks is limited in Ivy')\n-        .it('should support backward reference', () => {\n-          const fixture = initWithTemplate(\n-              AppComp,\n-              '{{ myDir.name }} <div dir-on-change #myDir=\"dirOnChange\" [in]=\"true\"></div>');\n-          fixture.detectChanges();\n-          expect(fixture.nativeElement.firstChild.textContent).toContain('Drew!?@');  // text node\n-          expect(fixture.nativeElement.lastChild.title).toBe('Drew!?@');              // div element\n-        });\n-\n-    onlyInIvy('Supporting input changes in hooks is limited in Ivy')\n-        .it('should not support backward reference', () => {\n-          expect(() => {\n-            const fixture = initWithTemplate(\n-                AppComp,\n-                '{{ myDir.name }} <div dir-on-change #myDir=\"dirOnChange\" [in]=\"true\"></div>');\n-            fixture.detectChanges();\n-          })\n-              .toThrowError(\n-                  /ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked/);\n-        });\n-\n-    modifiedInIvy('Supporting input changes in hooks is limited in Ivy')\n-        .it('should support reference on the same node', () => {\n-          const fixture = initWithTemplate(\n-              AppComp,\n-              '<div dir-on-change #myDir=\"dirOnChange\" [in]=\"true\" [id]=\"myDir.name\"></div>');\n-          fixture.detectChanges();\n-          expect(fixture.nativeElement.firstChild.id).toBe('Drew!?@');\n-          expect(fixture.nativeElement.firstChild.title).toBe('Drew!?@');\n-        });\n-\n-    onlyInIvy('Supporting input changes in hooks is limited in Ivy')\n-        .it('should not support reference on the same node', () => {\n-          expect(() => {\n-            const fixture = initWithTemplate(\n-                AppComp,\n-                '<div dir-on-change #myDir=\"dirOnChange\" [in]=\"true\" [id]=\"myDir.name\"></div>');\n-            fixture.detectChanges();\n-          })\n-              .toThrowError(\n-                  /ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked/);\n-        });\n+    it('should not support backward reference', () => {\n+      expect(() => {\n+        const fixture = initWithTemplate(\n+            AppComp, '{{ myDir.name }} <div dir-on-change #myDir=\"dirOnChange\" [in]=\"true\"></div>');\n+        fixture.detectChanges();\n+      })\n+          .toThrowError(\n+              /ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked/);\n+    });\n+\n+    it('should not support reference on the same node', () => {\n+      expect(() => {\n+        const fixture = initWithTemplate(\n+            AppComp,\n+            '<div dir-on-change #myDir=\"dirOnChange\" [in]=\"true\" [id]=\"myDir.name\"></div>');\n+        fixture.detectChanges();\n+      })\n+          .toThrowError(\n+              /ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked/);\n+    });\n \n     it('should support input referenced by host binding on that directive', () => {\n       const fixture =\n@@ -101,13 +77,12 @@ describe('exports', () => {\n     });\n   });\n \n-  onlyInIvy('Different error message is thrown in View Engine')\n-      .it('should throw if export name is not found', () => {\n-        expect(() => {\n-          const fixture = initWithTemplate(AppComp, '<div #myDir=\"dir\"></div>');\n-          fixture.detectChanges();\n-        }).toThrowError(/Export of name 'dir' not found!/);\n-      });\n+  it('should throw if export name is not found', () => {\n+    expect(() => {\n+      const fixture = initWithTemplate(AppComp, '<div #myDir=\"dir\"></div>');\n+      fixture.detectChanges();\n+    }).toThrowError(/Export of name 'dir' not found!/);\n+  });\n \n   it('should support component instance fed into directive', () => {\n     const fixture = initWithTemplate(\n@@ -120,21 +95,18 @@ describe('exports', () => {\n     expect(dirWithInput.comp).toEqual(myComp);\n   });\n \n-\n-  onlyInIvy(\n-      'in Ivy first declared ref is selected in case of multiple non-unique refs, when VE used the last one')\n-      .it('should point to the first declared ref', () => {\n-        const fixture = initWithTemplate(AppComp, `\n+  it('should point to the first declared ref', () => {\n+    const fixture = initWithTemplate(AppComp, `\n           <div>\n             <input value=\"First\" #ref />\n             <input value=\"Second\" #ref />\n             <input value=\"Third\" #ref />\n             <span>{{ ref.value }}</span>\n           </div>\n         `);\n-        fixture.detectChanges();\n-        expect(fixture.nativeElement.querySelector('span').innerHTML).toBe('First');\n-      });\n+    fixture.detectChanges();\n+    expect(fixture.nativeElement.querySelector('span').innerHTML).toBe('First');\n+  });\n \n   describe('forward refs', () => {\n     it('should work with basic text bindings', () => {"
        },
        {
            "sha": "58a0ea7c31b1864ab391a7a0407a40b8d25897f4",
            "filename": "packages/core/test/acceptance/host_binding_spec.ts",
            "status": "modified",
            "additions": 146,
            "deletions": 158,
            "changes": 304,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fhost_binding_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fhost_binding_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fhost_binding_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -13,38 +13,36 @@ import {bypassSanitizationTrustHtml, bypassSanitizationTrustStyle, bypassSanitiz\n import {TestBed} from '@angular/core/testing';\n import {By} from '@angular/platform-browser';\n import {NoopAnimationsModule} from '@angular/platform-browser/animations';\n-import {ivyEnabled, onlyInIvy} from '@angular/private/testing';\n \n describe('host bindings', () => {\n-  onlyInIvy('map-based [style] and [class] bindings are not supported in VE')\n-      .it('should render host bindings on the root component', () => {\n-        @Component({template: '...'})\n-        class MyApp {\n-          @HostBinding('style') myStylesExp = {};\n-          @HostBinding('class') myClassesExp = {};\n-        }\n+  it('should render host bindings on the root component', () => {\n+    @Component({template: '...'})\n+    class MyApp {\n+      @HostBinding('style') myStylesExp = {};\n+      @HostBinding('class') myClassesExp = {};\n+    }\n \n-        TestBed.configureTestingModule({declarations: [MyApp]});\n-        const fixture = TestBed.createComponent(MyApp);\n-        const element = fixture.nativeElement;\n-        fixture.detectChanges();\n+    TestBed.configureTestingModule({declarations: [MyApp]});\n+    const fixture = TestBed.createComponent(MyApp);\n+    const element = fixture.nativeElement;\n+    fixture.detectChanges();\n \n-        const component = fixture.componentInstance;\n-        component.myStylesExp = {width: '100px'};\n-        component.myClassesExp = 'foo';\n-        fixture.detectChanges();\n+    const component = fixture.componentInstance;\n+    component.myStylesExp = {width: '100px'};\n+    component.myClassesExp = 'foo';\n+    fixture.detectChanges();\n \n-        expect(element.style['width']).toEqual('100px');\n-        expect(element.classList.contains('foo')).toBeTruthy();\n+    expect(element.style['width']).toEqual('100px');\n+    expect(element.classList.contains('foo')).toBeTruthy();\n \n-        component.myStylesExp = {width: '200px'};\n-        component.myClassesExp = 'bar';\n-        fixture.detectChanges();\n+    component.myStylesExp = {width: '200px'};\n+    component.myClassesExp = 'bar';\n+    fixture.detectChanges();\n \n-        expect(element.style['width']).toEqual('200px');\n-        expect(element.classList.contains('foo')).toBeFalsy();\n-        expect(element.classList.contains('bar')).toBeTruthy();\n-      });\n+    expect(element.style['width']).toEqual('200px');\n+    expect(element.classList.contains('foo')).toBeFalsy();\n+    expect(element.classList.contains('bar')).toBeTruthy();\n+  });\n \n   describe('defined in @Component', () => {\n     it('should combine the inherited static classes of a parent and child component', () => {\n@@ -61,9 +59,7 @@ describe('host bindings', () => {\n       fixture.detectChanges();\n \n       const element = fixture.nativeElement;\n-      if (ivyEnabled) {\n-        expect(element.classList.contains('bar')).toBeTruthy();\n-      }\n+      expect(element.classList.contains('bar')).toBeTruthy();\n       expect(element.classList.contains('foo')).toBeTruthy();\n       expect(element.classList.contains('baz')).toBeTruthy();\n     });\n@@ -519,88 +515,86 @@ describe('host bindings', () => {\n       expect(childElement.style.opacity).toEqual('0.5');\n     });\n \n-    onlyInIvy('[style.prop] and [class.name] prioritization is a new feature')\n-        .it('should prioritize styling present in the order of directive hostBinding evaluation, but consider sub-classed directive styling to be the most important',\n-            () => {\n-              @Component({template: '<div child-dir sibling-dir></div>'})\n-              class MyApp {\n-              }\n-\n-              @Directive({selector: '[parent-dir]'})\n-              class ParentDir {\n-                @HostBinding('style.width')\n-                get width1() {\n-                  return '100px';\n-                }\n-\n-                @HostBinding('style.height')\n-                get height1() {\n-                  return '100px';\n-                }\n-\n-                @HostBinding('style.color')\n-                get color1() {\n-                  return 'red';\n-                }\n-              }\n-\n-              @Directive({selector: '[child-dir]'})\n-              class ChildDir extends ParentDir {\n-                @HostBinding('style.width')\n-                get width2() {\n-                  return '200px';\n-                }\n-\n-                @HostBinding('style.height')\n-                get height2() {\n-                  return '200px';\n-                }\n-              }\n-\n-              @Directive({selector: '[sibling-dir]'})\n-              class SiblingDir {\n-                @HostBinding('style.width')\n-                get width3() {\n-                  return '300px';\n-                }\n-\n-                @HostBinding('style.height')\n-                get height3() {\n-                  return '300px';\n-                }\n-\n-                @HostBinding('style.opacity')\n-                get opacity3() {\n-                  return '0.5';\n-                }\n-\n-                @HostBinding('style.color')\n-                get color1() {\n-                  return 'blue';\n-                }\n-              }\n-\n-              TestBed.configureTestingModule(\n-                  {declarations: [MyApp, ParentDir, SiblingDir, ChildDir]});\n-              const fixture = TestBed.createComponent(MyApp);\n-              const element = fixture.nativeElement;\n-              fixture.detectChanges();\n-\n-              const childElement = element.querySelector('div');\n-\n-              // width/height values were set in all directives, but the sub-class directive\n-              // (ChildDir) had priority over the parent directive (ParentDir) which is why its\n-              // value won. It also won over Dir because the SiblingDir directive was declared\n-              // later in `declarations`.\n-              expect(childElement.style.width).toEqual('200px');\n-              expect(childElement.style.height).toEqual('200px');\n-\n-              // ParentDir styled the color first before Dir\n-              expect(childElement.style.color).toEqual('red');\n-\n-              // Dir was the only directive to style opacity\n-              expect(childElement.style.opacity).toEqual('0.5');\n-            });\n+    it('should prioritize styling present in the order of directive hostBinding evaluation, but consider sub-classed directive styling to be the most important',\n+       () => {\n+         @Component({template: '<div child-dir sibling-dir></div>'})\n+         class MyApp {\n+         }\n+\n+         @Directive({selector: '[parent-dir]'})\n+         class ParentDir {\n+           @HostBinding('style.width')\n+           get width1() {\n+             return '100px';\n+           }\n+\n+           @HostBinding('style.height')\n+           get height1() {\n+             return '100px';\n+           }\n+\n+           @HostBinding('style.color')\n+           get color1() {\n+             return 'red';\n+           }\n+         }\n+\n+         @Directive({selector: '[child-dir]'})\n+         class ChildDir extends ParentDir {\n+           @HostBinding('style.width')\n+           get width2() {\n+             return '200px';\n+           }\n+\n+           @HostBinding('style.height')\n+           get height2() {\n+             return '200px';\n+           }\n+         }\n+\n+         @Directive({selector: '[sibling-dir]'})\n+         class SiblingDir {\n+           @HostBinding('style.width')\n+           get width3() {\n+             return '300px';\n+           }\n+\n+           @HostBinding('style.height')\n+           get height3() {\n+             return '300px';\n+           }\n+\n+           @HostBinding('style.opacity')\n+           get opacity3() {\n+             return '0.5';\n+           }\n+\n+           @HostBinding('style.color')\n+           get color1() {\n+             return 'blue';\n+           }\n+         }\n+\n+         TestBed.configureTestingModule({declarations: [MyApp, ParentDir, SiblingDir, ChildDir]});\n+         const fixture = TestBed.createComponent(MyApp);\n+         const element = fixture.nativeElement;\n+         fixture.detectChanges();\n+\n+         const childElement = element.querySelector('div');\n+\n+         // width/height values were set in all directives, but the sub-class directive\n+         // (ChildDir) had priority over the parent directive (ParentDir) which is why its\n+         // value won. It also won over Dir because the SiblingDir directive was declared\n+         // later in `declarations`.\n+         expect(childElement.style.width).toEqual('200px');\n+         expect(childElement.style.height).toEqual('200px');\n+\n+         // ParentDir styled the color first before Dir\n+         expect(childElement.style.color).toEqual('red');\n+\n+         // Dir was the only directive to style opacity\n+         expect(childElement.style.opacity).toEqual('0.5');\n+       });\n \n     it('should allow class-bindings to be placed on ng-container elements', () => {\n       @Component({\n@@ -1164,66 +1158,60 @@ describe('host bindings', () => {\n     const fixture = TestBed.createComponent(MyComp);\n     fixture.detectChanges();\n     const div: HTMLElement = fixture.debugElement.nativeElement.firstChild;\n-    expect(div.id).toEqual(\n-        ivyEnabled ?\n-            // In ivy the correct result is `tmpl` because template has the highest priority.\n-            'tmpl' :\n-            // In VE the order was simply that of execution and so dir2 would win.\n-            'dir2');\n+    expect(div.id).toEqual('tmpl');\n   });\n \n-  onlyInIvy('Host bindings do not get merged in ViewEngine')\n-      .it('should work correctly with inherited directives with hostBindings', () => {\n-        @Directive({selector: '[superDir]', host: {'[id]': 'id'}})\n-        class SuperDirective {\n-          id = 'my-id';\n-        }\n+  it('should work correctly with inherited directives with hostBindings', () => {\n+    @Directive({selector: '[superDir]', host: {'[id]': 'id'}})\n+    class SuperDirective {\n+      id = 'my-id';\n+    }\n \n-        @Directive({selector: '[subDir]', host: {'[title]': 'title'}})\n-        class SubDirective extends SuperDirective {\n-          title = 'my-title';\n-        }\n+    @Directive({selector: '[subDir]', host: {'[title]': 'title'}})\n+    class SubDirective extends SuperDirective {\n+      title = 'my-title';\n+    }\n \n-        @Component({\n-          template: `\n+    @Component({\n+      template: `\n         <div subDir></div>\n         <div superDir></div>\n       `\n-        })\n-        class App {\n-          @ViewChild(SubDirective) subDir!: SubDirective;\n-          @ViewChild(SuperDirective) superDir!: SuperDirective;\n-        }\n+    })\n+    class App {\n+      @ViewChild(SubDirective) subDir!: SubDirective;\n+      @ViewChild(SuperDirective) superDir!: SuperDirective;\n+    }\n \n-        TestBed.configureTestingModule({declarations: [App, SuperDirective, SubDirective]});\n-        const fixture = TestBed.createComponent(App);\n-        fixture.detectChanges();\n-        const els = fixture.nativeElement.querySelectorAll('div') as NodeListOf<HTMLElement>;\n+    TestBed.configureTestingModule({declarations: [App, SuperDirective, SubDirective]});\n+    const fixture = TestBed.createComponent(App);\n+    fixture.detectChanges();\n+    const els = fixture.nativeElement.querySelectorAll('div') as NodeListOf<HTMLElement>;\n \n-        const firstDivEl = els[0];\n-        const secondDivEl = els[1];\n+    const firstDivEl = els[0];\n+    const secondDivEl = els[1];\n \n-        // checking first div element with inherited directive\n-        expect(firstDivEl.id).toEqual('my-id');\n-        expect(firstDivEl.title).toEqual('my-title');\n+    // checking first div element with inherited directive\n+    expect(firstDivEl.id).toEqual('my-id');\n+    expect(firstDivEl.title).toEqual('my-title');\n \n-        fixture.componentInstance.subDir.title = 'new-title';\n-        fixture.detectChanges();\n-        expect(firstDivEl.id).toEqual('my-id');\n-        expect(firstDivEl.title).toEqual('new-title');\n+    fixture.componentInstance.subDir.title = 'new-title';\n+    fixture.detectChanges();\n+    expect(firstDivEl.id).toEqual('my-id');\n+    expect(firstDivEl.title).toEqual('new-title');\n \n-        fixture.componentInstance.subDir.id = 'new-id';\n-        fixture.detectChanges();\n-        expect(firstDivEl.id).toEqual('new-id');\n-        expect(firstDivEl.title).toEqual('new-title');\n+    fixture.componentInstance.subDir.id = 'new-id';\n+    fixture.detectChanges();\n+    expect(firstDivEl.id).toEqual('new-id');\n+    expect(firstDivEl.title).toEqual('new-title');\n \n-        // checking second div element with simple directive\n-        expect(secondDivEl.id).toEqual('my-id');\n+    // checking second div element with simple directive\n+    expect(secondDivEl.id).toEqual('my-id');\n \n-        fixture.componentInstance.superDir.id = 'new-id';\n-        fixture.detectChanges();\n-        expect(secondDivEl.id).toEqual('new-id');\n-      });\n+    fixture.componentInstance.superDir.id = 'new-id';\n+    fixture.detectChanges();\n+    expect(secondDivEl.id).toEqual('new-id');\n+  });\n \n   it('should support host attributes', () => {\n     @Directive({selector: '[hostAttributeDir]', host: {'role': 'listbox'}})\n@@ -1425,7 +1413,7 @@ describe('host bindings', () => {\n         /* isAttribute */ false);\n   });\n \n-  onlyInIvy('VE would silently ignore this').describe('host binding on containers', () => {\n+  describe('host binding on containers', () => {\n     @Directive({selector: '[staticHostAtt]', host: {'static': 'attr'}})\n     class StaticHostAttr {\n       constructor() {}\n@@ -1474,7 +1462,7 @@ describe('host bindings', () => {\n     });\n   });\n \n-  onlyInIvy('VE does not support this').describe('host bindings on edge case properties', () => {\n+  describe('host bindings on edge case properties', () => {\n     it('should handle host bindings with the same name as a primitive value', () => {\n       @Directive({\n         selector: '[dir]',"
        },
        {
            "sha": "49ceea9a2df4417e6fafdb841411f2f68a426e8c",
            "filename": "packages/core/test/acceptance/i18n_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fi18n_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fi18n_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fi18n_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -20,12 +20,11 @@ import {TestBed} from '@angular/core/testing';\n import {clearTranslations, loadTranslations} from '@angular/localize';\n import {By, ɵDomRendererFactory2 as DomRendererFactory2} from '@angular/platform-browser';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {onlyInIvy} from '@angular/private/testing';\n import {BehaviorSubject} from 'rxjs';\n \n \n \n-onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n+describe('runtime i18n', () => {\n   beforeEach(() => {\n     TestBed.configureTestingModule({\n       declarations: [AppComp, DirectiveWithTplRef, UppercasePipe],\n@@ -2480,7 +2479,7 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n       @Component({selector: 'div-query', template: '<ng-container #vc></ng-container>'})\n       class DivQuery {\n         // TODO(issue/24571): remove '!'.\n-        @ContentChild(TemplateRef, {static: true}) template !: TemplateRef<any>;\n+        @ContentChild(TemplateRef, {static: true}) template!: TemplateRef<any>;\n \n         // TODO(issue/24571): remove '!'.\n         @ViewChild('vc', {read: ViewContainerRef, static: true}) vc!: ViewContainerRef;"
        },
        {
            "sha": "e757d2097371d50efa583b50181b232a5c089c90",
            "filename": "packages/core/test/acceptance/inherit_definition_feature_spec.ts",
            "status": "modified",
            "additions": 176,
            "deletions": 181,
            "changes": 357,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Finherit_definition_feature_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Finherit_definition_feature_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Finherit_definition_feature_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -12,38 +12,36 @@ import {getDirectiveDef} from '@angular/core/src/render3/definition';\n import {TestBed} from '@angular/core/testing';\n import {By} from '@angular/platform-browser';\n import {NoopAnimationsModule} from '@angular/platform-browser/animations';\n-import {onlyInIvy} from '@angular/private/testing';\n \n describe('inheritance', () => {\n-  onlyInIvy('View Engine does not provide this check')\n-      .it('should throw when trying to inherit a component from a directive', () => {\n-        @Component({\n-          selector: 'my-comp',\n-          template: '<div></div>',\n-        })\n-        class MyComponent {\n-        }\n-\n-        @Directive({\n-          selector: '[my-dir]',\n-        })\n-        class MyDirective extends MyComponent {\n-        }\n-\n-        @Component({\n-          template: `<div my-dir></div>`,\n-        })\n-        class App {\n-        }\n-\n-        TestBed.configureTestingModule({\n-          declarations: [App, MyComponent, MyDirective],\n-        });\n+  it('should throw when trying to inherit a component from a directive', () => {\n+    @Component({\n+      selector: 'my-comp',\n+      template: '<div></div>',\n+    })\n+    class MyComponent {\n+    }\n+\n+    @Directive({\n+      selector: '[my-dir]',\n+    })\n+    class MyDirective extends MyComponent {\n+    }\n+\n+    @Component({\n+      template: `<div my-dir></div>`,\n+    })\n+    class App {\n+    }\n+\n+    TestBed.configureTestingModule({\n+      declarations: [App, MyComponent, MyDirective],\n+    });\n \n-        expect(() => {\n-          TestBed.createComponent(App);\n-        }).toThrowError('Directives cannot inherit Components');\n-      });\n+    expect(() => {\n+      TestBed.createComponent(App);\n+    }).toThrowError('Directives cannot inherit Components');\n+  });\n \n   describe('multiple children', () => {\n     it('should ensure that multiple child classes don\\'t cause multiple parent execution', () => {\n@@ -4326,96 +4324,94 @@ describe('inheritance', () => {\n     });\n \n     describe('animations', () => {\n-      onlyInIvy('View Engine does not inherit `host` metadata from superclass')\n-          .it('should work with inherited host bindings and animations', () => {\n-            @Component({\n-              selector: 'super-comp',\n-              template: '<div>super-comp</div>',\n-              host: {\n-                '[@animation]': 'colorExp',\n-              },\n-              animations: [\n-                trigger('animation', [state('color', style({color: 'red'}))]),\n-              ],\n-            })\n-            class SuperComponent {\n-              colorExp = 'color';\n-            }\n-\n-            @Component({\n-              selector: 'my-comp',\n-              template: `<div>my-comp</div>`,\n-            })\n-            class MyComponent extends SuperComponent {\n-            }\n-\n-            @Component({\n-              template: '<my-comp>app</my-comp>',\n-            })\n-            class App {\n-            }\n-\n-            TestBed.configureTestingModule({\n-              declarations: [App, MyComponent, SuperComponent],\n-              imports: [NoopAnimationsModule],\n-            });\n-            const fixture = TestBed.createComponent(App);\n-            fixture.detectChanges();\n-            const queryResult = fixture.debugElement.query(By.css('my-comp'));\n-\n-            expect(queryResult.nativeElement.style.color).toBe('red');\n-          });\n-\n-      onlyInIvy('View Engine does not inherit `host` metadata from superclass')\n-          .it('should compose animations (from super class)', () => {\n-            @Component({\n-              selector: 'super-comp',\n-              template: '...',\n-              animations: [\n-                trigger('animation1', [state('color', style({color: 'red'}))]),\n-                trigger('animation2', [state('opacity', style({opacity: '0.5'}))]),\n-              ],\n-            })\n-            class SuperComponent {\n-            }\n-\n-            @Component({\n-              selector: 'my-comp',\n-              template: '<div>my-comp</div>',\n-              host: {\n-                '[@animation1]': 'colorExp',\n-                '[@animation2]': 'opacityExp',\n-                '[@animation3]': 'bgExp',\n-              },\n-              animations: [\n-                trigger('animation1', [state('color', style({color: 'blue'}))]),\n-                trigger('animation3', [state('bg', style({backgroundColor: 'green'}))]),\n-              ],\n-            })\n-            class MyComponent extends SuperComponent {\n-              colorExp = 'color';\n-              opacityExp = 'opacity';\n-              bgExp = 'bg';\n-            }\n-\n-            @Component({\n-              template: '<my-comp>app</my-comp>',\n-            })\n-            class App {\n-            }\n-\n-            TestBed.configureTestingModule({\n-              declarations: [App, MyComponent, SuperComponent],\n-              imports: [NoopAnimationsModule],\n-            });\n-            const fixture = TestBed.createComponent(App);\n-            fixture.detectChanges();\n-            const queryResult = fixture.debugElement.query(By.css('my-comp'));\n-\n-            expect(queryResult.nativeElement.style.color).toBe('blue');\n-            expect(queryResult.nativeElement.style.opacity).toBe('0.5');\n-            expect(queryResult.nativeElement.style.backgroundColor).toBe('green');\n-          });\n+      it('should work with inherited host bindings and animations', () => {\n+        @Component({\n+          selector: 'super-comp',\n+          template: '<div>super-comp</div>',\n+          host: {\n+            '[@animation]': 'colorExp',\n+          },\n+          animations: [\n+            trigger('animation', [state('color', style({color: 'red'}))]),\n+          ],\n+        })\n+        class SuperComponent {\n+          colorExp = 'color';\n+        }\n+\n+        @Component({\n+          selector: 'my-comp',\n+          template: `<div>my-comp</div>`,\n+        })\n+        class MyComponent extends SuperComponent {\n+        }\n+\n+        @Component({\n+          template: '<my-comp>app</my-comp>',\n+        })\n+        class App {\n+        }\n+\n+        TestBed.configureTestingModule({\n+          declarations: [App, MyComponent, SuperComponent],\n+          imports: [NoopAnimationsModule],\n+        });\n+        const fixture = TestBed.createComponent(App);\n+        fixture.detectChanges();\n+        const queryResult = fixture.debugElement.query(By.css('my-comp'));\n+\n+        expect(queryResult.nativeElement.style.color).toBe('red');\n+      });\n+\n+      it('should compose animations (from super class)', () => {\n+        @Component({\n+          selector: 'super-comp',\n+          template: '...',\n+          animations: [\n+            trigger('animation1', [state('color', style({color: 'red'}))]),\n+            trigger('animation2', [state('opacity', style({opacity: '0.5'}))]),\n+          ],\n+        })\n+        class SuperComponent {\n+        }\n+\n+        @Component({\n+          selector: 'my-comp',\n+          template: '<div>my-comp</div>',\n+          host: {\n+            '[@animation1]': 'colorExp',\n+            '[@animation2]': 'opacityExp',\n+            '[@animation3]': 'bgExp',\n+          },\n+          animations: [\n+            trigger('animation1', [state('color', style({color: 'blue'}))]),\n+            trigger('animation3', [state('bg', style({backgroundColor: 'green'}))]),\n+          ],\n+        })\n+        class MyComponent extends SuperComponent {\n+          colorExp = 'color';\n+          opacityExp = 'opacity';\n+          bgExp = 'bg';\n+        }\n+\n+        @Component({\n+          template: '<my-comp>app</my-comp>',\n+        })\n+        class App {\n+        }\n+\n+        TestBed.configureTestingModule({\n+          declarations: [App, MyComponent, SuperComponent],\n+          imports: [NoopAnimationsModule],\n+        });\n+        const fixture = TestBed.createComponent(App);\n+        fixture.detectChanges();\n+        const queryResult = fixture.debugElement.query(By.css('my-comp'));\n+\n+        expect(queryResult.nativeElement.style.color).toBe('blue');\n+        expect(queryResult.nativeElement.style.opacity).toBe('0.5');\n+        expect(queryResult.nativeElement.style.backgroundColor).toBe('green');\n+      });\n     });\n \n     describe('host bindings (style related)', () => {\n@@ -5140,68 +5136,67 @@ describe('inheritance', () => {\n     });\n \n     describe('animations', () => {\n-      onlyInIvy('View Engine does not inherit `host` metadata from superclass')\n-          .it('should compose animations across multiple inheritance levels', () => {\n-            @Component({\n-              selector: 'super-comp',\n-              template: '...',\n-              host: {\n-                '[@animation1]': 'colorExp',\n-                '[@animation2]': 'opacityExp',\n-              },\n-              animations: [\n-                trigger('animation1', [state('color', style({color: 'red'}))]),\n-                trigger('animation2', [state('opacity', style({opacity: '0.5'}))]),\n-              ],\n-            })\n-            class SuperComponent {\n-              colorExp = 'color';\n-              opacityExp = 'opacity';\n-            }\n-\n-            @Component({\n-              selector: 'intermediate-comp',\n-              template: '...',\n-            })\n-            class IntermediateComponent extends SuperComponent {\n-            }\n-\n-            @Component({\n-              selector: 'my-comp',\n-              template: '<div>my-comp</div>',\n-              host: {\n-                '[@animation1]': 'colorExp',\n-                '[@animation3]': 'bgExp',\n-              },\n-              animations: [\n-                trigger('animation1', [state('color', style({color: 'blue'}))]),\n-                trigger('animation3', [state('bg', style({backgroundColor: 'green'}))]),\n-              ],\n-            })\n-            class MyComponent extends IntermediateComponent {\n-              override colorExp = 'color';\n-              override opacityExp = 'opacity';\n-              bgExp = 'bg';\n-            }\n-\n-            @Component({\n-              template: '<my-comp>app</my-comp>',\n-            })\n-            class App {\n-            }\n-\n-            TestBed.configureTestingModule({\n-              declarations: [App, MyComponent, IntermediateComponent, SuperComponent],\n-              imports: [NoopAnimationsModule],\n-            });\n-            const fixture = TestBed.createComponent(App);\n-            fixture.detectChanges();\n-            const queryResult = fixture.debugElement.query(By.css('my-comp'));\n-\n-            expect(queryResult.nativeElement.style.color).toBe('blue');\n-            expect(queryResult.nativeElement.style.opacity).toBe('0.5');\n-            expect(queryResult.nativeElement.style.backgroundColor).toBe('green');\n-          });\n+      it('should compose animations across multiple inheritance levels', () => {\n+        @Component({\n+          selector: 'super-comp',\n+          template: '...',\n+          host: {\n+            '[@animation1]': 'colorExp',\n+            '[@animation2]': 'opacityExp',\n+          },\n+          animations: [\n+            trigger('animation1', [state('color', style({color: 'red'}))]),\n+            trigger('animation2', [state('opacity', style({opacity: '0.5'}))]),\n+          ],\n+        })\n+        class SuperComponent {\n+          colorExp = 'color';\n+          opacityExp = 'opacity';\n+        }\n+\n+        @Component({\n+          selector: 'intermediate-comp',\n+          template: '...',\n+        })\n+        class IntermediateComponent extends SuperComponent {\n+        }\n+\n+        @Component({\n+          selector: 'my-comp',\n+          template: '<div>my-comp</div>',\n+          host: {\n+            '[@animation1]': 'colorExp',\n+            '[@animation3]': 'bgExp',\n+          },\n+          animations: [\n+            trigger('animation1', [state('color', style({color: 'blue'}))]),\n+            trigger('animation3', [state('bg', style({backgroundColor: 'green'}))]),\n+          ],\n+        })\n+        class MyComponent extends IntermediateComponent {\n+          override colorExp = 'color';\n+          override opacityExp = 'opacity';\n+          bgExp = 'bg';\n+        }\n+\n+        @Component({\n+          template: '<my-comp>app</my-comp>',\n+        })\n+        class App {\n+        }\n+\n+        TestBed.configureTestingModule({\n+          declarations: [App, MyComponent, IntermediateComponent, SuperComponent],\n+          imports: [NoopAnimationsModule],\n+        });\n+        const fixture = TestBed.createComponent(App);\n+        fixture.detectChanges();\n+        const queryResult = fixture.debugElement.query(By.css('my-comp'));\n+\n+        expect(queryResult.nativeElement.style.color).toBe('blue');\n+        expect(queryResult.nativeElement.style.opacity).toBe('0.5');\n+        expect(queryResult.nativeElement.style.backgroundColor).toBe('green');\n+      });\n     });\n     describe('host bindings (style related)', () => {\n       // TODO: sub and super HostBinding same property but different bindings"
        },
        {
            "sha": "a9df49bc35746a3adc77f928269310baa57f1ef5",
            "filename": "packages/core/test/acceptance/integration_spec.ts",
            "status": "modified",
            "additions": 340,
            "deletions": 353,
            "changes": 693,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fintegration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fintegration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fintegration_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -17,7 +17,7 @@ import {ngDevModeResetPerfCounters} from '@angular/core/src/util/ng_dev_mode';\n import {fakeAsync, flushMicrotasks, TestBed} from '@angular/core/testing';\n import {By} from '@angular/platform-browser';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {ivyEnabled, onlyInIvy} from '@angular/private/testing';\n+import {expectPerfCounters} from '@angular/private/testing';\n \n describe('acceptance integration tests', () => {\n   function stripHtmlComments(str: string) {\n@@ -43,7 +43,7 @@ describe('acceptance integration tests', () => {\n         name = '';\n       }\n \n-      onlyInIvy('perf counters').expectPerfCounters({\n+      expectPerfCounters({\n         tView: 0,\n         tNode: 0,\n       });\n@@ -55,7 +55,7 @@ describe('acceptance integration tests', () => {\n       fixture.detectChanges();\n \n       expect(fixture.nativeElement.innerHTML).toEqual('<h1>Hello, World!</h1>');\n-      onlyInIvy('perf counters').expectPerfCounters({\n+      expectPerfCounters({\n         tView: 2,  // Host view + App\n         tNode: 3,  // Host Node + <h1> + #text\n       });\n@@ -65,7 +65,7 @@ describe('acceptance integration tests', () => {\n \n       expect(fixture.nativeElement.innerHTML).toEqual('<h1>Hello, New World!</h1>');\n       // Assert that the tView/tNode count does not increase (they are correctly cached)\n-      onlyInIvy('perf counters').expectPerfCounters({\n+      expectPerfCounters({\n         tView: 2,\n         tNode: 3,\n       });\n@@ -1137,281 +1137,273 @@ describe('acceptance integration tests', () => {\n                .toEqual('cucumber grape');\n          });\n \n-      onlyInIvy('Passing an object into [style] works differently')\n-          .it('should update `[style]` and bindings in the provided directive if the input is matched',\n-              () => {\n-                @Component({template: '<div DirWithStyle [style]=\"value\"></div>'})\n-                class App {\n-                  @ViewChild(DirWithStyleDirective) mockStyleDirective!: DirWithStyleDirective;\n-                  value!: {[key: string]: string};\n-                }\n-\n-                TestBed.configureTestingModule({declarations: [App, DirWithStyleDirective]});\n-                const fixture = TestBed.createComponent(App);\n-                fixture.componentInstance.value = {width: '200px', height: '500px'};\n-                fixture.detectChanges();\n-\n-                expect(fixture.componentInstance.mockStyleDirective.stylesVal)\n-                    .toEqual({width: '200px', height: '500px'});\n-              });\n-\n-      onlyInIvy('Style binding merging works differently in Ivy')\n-          .it('should apply initial styling to the element that contains the directive with host styling',\n-              () => {\n-                @Directive({\n-                  selector: '[DirWithInitialStyling]',\n-                  host: {\n-                    'title': 'foo',\n-                    'class': 'heavy golden',\n-                    'style': 'color: purple',\n-                    '[style.font-weight]': '\"bold\"'\n-                  }\n-                })\n-                class DirWithInitialStyling {\n-                }\n-\n-                @Component({\n-                  template: `\n+      it('should update `[style]` and bindings in the provided directive if the input is matched',\n+         () => {\n+           @Component({template: '<div DirWithStyle [style]=\"value\"></div>'})\n+           class App {\n+             @ViewChild(DirWithStyleDirective) mockStyleDirective!: DirWithStyleDirective;\n+             value!: {[key: string]: string};\n+           }\n+\n+           TestBed.configureTestingModule({declarations: [App, DirWithStyleDirective]});\n+           const fixture = TestBed.createComponent(App);\n+           fixture.componentInstance.value = {width: '200px', height: '500px'};\n+           fixture.detectChanges();\n+\n+           expect(fixture.componentInstance.mockStyleDirective.stylesVal)\n+               .toEqual({width: '200px', height: '500px'});\n+         });\n+\n+      it('should apply initial styling to the element that contains the directive with host styling',\n+         () => {\n+           @Directive({\n+             selector: '[DirWithInitialStyling]',\n+             host: {\n+               'title': 'foo',\n+               'class': 'heavy golden',\n+               'style': 'color: purple',\n+               '[style.font-weight]': '\"bold\"'\n+             }\n+           })\n+           class DirWithInitialStyling {\n+           }\n+\n+           @Component({\n+             template: `\n                 <div DirWithInitialStyling\n                   class=\"big\"\n                   style=\"color:black; font-size:200px\"></div>\n              `\n-                })\n-                class App {\n-                }\n-\n-                TestBed.configureTestingModule({declarations: [App, DirWithInitialStyling]});\n-                const fixture = TestBed.createComponent(App);\n-                fixture.detectChanges();\n-\n-                const target: HTMLDivElement = fixture.nativeElement.querySelector('div');\n-                const classes = target.getAttribute('class')!.split(/\\s+/).sort();\n-                expect(classes).toEqual(['big', 'golden', 'heavy']);\n-\n-                expect(target.getAttribute('title')).toEqual('foo');\n-                expect(target.style.getPropertyValue('color')).toEqual('black');\n-                expect(target.style.getPropertyValue('font-size')).toEqual('200px');\n-                expect(target.style.getPropertyValue('font-weight')).toEqual('bold');\n-              });\n-\n-      onlyInIvy('Style binding merging works differently in Ivy')\n-          .it('should apply single styling bindings present within a directive onto the same element and defer the element\\'s initial styling values when missing',\n-              () => {\n-                @Directive({\n-                  selector: '[DirWithSingleStylingBindings]',\n-                  host: {\n-                    'class': 'def',\n-                    '[class.xyz]': 'activateXYZClass',\n-                    '[style.width]': 'width',\n-                    '[style.height]': 'height'\n-                  }\n-                })\n-                class DirWithSingleStylingBindings {\n-                  width: string|null|undefined = undefined;\n-                  height: string|null|undefined = undefined;\n-                  activateXYZClass: boolean = false;\n-                }\n-\n-                @Component({\n-                  template: `\n+           })\n+           class App {\n+           }\n+\n+           TestBed.configureTestingModule({declarations: [App, DirWithInitialStyling]});\n+           const fixture = TestBed.createComponent(App);\n+           fixture.detectChanges();\n+\n+           const target: HTMLDivElement = fixture.nativeElement.querySelector('div');\n+           const classes = target.getAttribute('class')!.split(/\\s+/).sort();\n+           expect(classes).toEqual(['big', 'golden', 'heavy']);\n+\n+           expect(target.getAttribute('title')).toEqual('foo');\n+           expect(target.style.getPropertyValue('color')).toEqual('black');\n+           expect(target.style.getPropertyValue('font-size')).toEqual('200px');\n+           expect(target.style.getPropertyValue('font-weight')).toEqual('bold');\n+         });\n+\n+      it('should apply single styling bindings present within a directive onto the same element and defer the element\\'s initial styling values when missing',\n+         () => {\n+           @Directive({\n+             selector: '[DirWithSingleStylingBindings]',\n+             host: {\n+               'class': 'def',\n+               '[class.xyz]': 'activateXYZClass',\n+               '[style.width]': 'width',\n+               '[style.height]': 'height'\n+             }\n+           })\n+           class DirWithSingleStylingBindings {\n+             width: string|null|undefined = undefined;\n+             height: string|null|undefined = undefined;\n+             activateXYZClass: boolean = false;\n+           }\n+\n+           @Component({\n+             template: `\n               <div DirWithSingleStylingBindings class=\"abc\" style=\"width:100px;\"></div>\n             `\n-                })\n-                class App {\n-                  @ViewChild(DirWithSingleStylingBindings)\n-                  dirInstance!: DirWithSingleStylingBindings;\n-                }\n-\n-                TestBed.configureTestingModule({declarations: [App, DirWithSingleStylingBindings]});\n-                const fixture = TestBed.createComponent(App);\n-                fixture.detectChanges();\n-                const dirInstance = fixture.componentInstance.dirInstance;\n-                const target: HTMLDivElement = fixture.nativeElement.querySelector('div');\n-                expect(target.style.getPropertyValue('width')).toEqual('100px');\n-                expect(target.style.getPropertyValue('height')).toEqual('');\n-                expect(target.classList.contains('abc')).toBeTruthy();\n-                expect(target.classList.contains('def')).toBeTruthy();\n-                expect(target.classList.contains('xyz')).toBeFalsy();\n-\n-                dirInstance.width = '444px';\n-                dirInstance.height = '999px';\n-                dirInstance.activateXYZClass = true;\n-                fixture.detectChanges();\n-\n-                expect(target.style.getPropertyValue('width')).toEqual('100px');\n-                expect(target.style.getPropertyValue('height')).toEqual('999px');\n-                expect(target.classList.contains('abc')).toBeTruthy();\n-                expect(target.classList.contains('def')).toBeTruthy();\n-                expect(target.classList.contains('xyz')).toBeTruthy();\n-\n-                dirInstance.width = undefined;\n-                dirInstance.height = undefined;\n-                fixture.detectChanges();\n-\n-                expect(target.style.getPropertyValue('width')).toEqual('100px');\n-                expect(target.style.getPropertyValue('height')).toEqual('');\n-                expect(target.classList.contains('abc')).toBeTruthy();\n-                expect(target.classList.contains('def')).toBeTruthy();\n-                expect(target.classList.contains('xyz')).toBeTruthy();\n-              });\n-\n-      onlyInIvy('Style binding merging works differently in Ivy')\n-          .it('should properly prioritize single style binding collisions when they exist on multiple directives',\n-              () => {\n-                @Directive({selector: '[Dir1WithStyle]', host: {'[style.width]': 'width'}})\n-                class Dir1WithStyle {\n-                  width: null|string|undefined = undefined;\n-                }\n-\n-                @Directive({\n-                  selector: '[Dir2WithStyle]',\n-                  host: {'style': 'width: 111px', '[style.width]': 'width'}\n-                })\n-                class Dir2WithStyle {\n-                  width: null|string|undefined = undefined;\n-                }\n-\n-                @Component(\n-                    {template: '<div Dir1WithStyle Dir2WithStyle [style.width]=\"width\"></div>'})\n-                class App {\n-                  @ViewChild(Dir1WithStyle) dir1Instance!: Dir1WithStyle;\n-                  @ViewChild(Dir2WithStyle) dir2Instance!: Dir2WithStyle;\n-                  width: string|null|undefined = undefined;\n-                }\n-\n-                TestBed.configureTestingModule({declarations: [App, Dir2WithStyle, Dir1WithStyle]});\n-                const fixture = TestBed.createComponent(App);\n-                fixture.detectChanges();\n-                const {dir1Instance, dir2Instance} = fixture.componentInstance;\n-\n-                const target: HTMLDivElement = fixture.nativeElement.querySelector('div');\n-                expect(target.style.getPropertyValue('width')).toEqual('111px');\n-\n-                fixture.componentInstance.width = '999px';\n-                dir1Instance.width = '222px';\n-                dir2Instance.width = '333px';\n-                fixture.detectChanges();\n-                expect(target.style.getPropertyValue('width')).toEqual('999px');\n-\n-                fixture.componentInstance.width = undefined;\n-                fixture.detectChanges();\n-                expect(target.style.getPropertyValue('width')).toEqual('222px');\n-\n-                dir1Instance.width = undefined;\n-                fixture.detectChanges();\n-                expect(target.style.getPropertyValue('width')).toEqual('333px');\n-\n-                dir2Instance.width = undefined;\n-                fixture.detectChanges();\n-                expect(target.style.getPropertyValue('width')).toEqual('111px');\n-\n-                dir1Instance.width = '666px';\n-                fixture.detectChanges();\n-                expect(target.style.getPropertyValue('width')).toEqual('666px');\n-\n-                fixture.componentInstance.width = '777px';\n-                fixture.detectChanges();\n-                expect(target.style.getPropertyValue('width')).toEqual('777px');\n-              });\n-\n-      onlyInIvy('Style binding merging works differently in Ivy')\n-          .it('should properly prioritize multi style binding collisions when they exist on multiple directives',\n-              () => {\n-                @Directive({\n-                  selector: '[Dir1WithStyling]',\n-                  host: {'[style]': 'stylesExp', '[class]': 'classesExp'}\n-                })\n-                class Dir1WithStyling {\n-                  classesExp: any = {};\n-                  stylesExp: any = {};\n-                }\n-\n-                @Directive({\n-                  selector: '[Dir2WithStyling]',\n-                  host: {'style': 'width: 111px', '[style]': 'stylesExp'}\n-                })\n-                class Dir2WithStyling {\n-                  stylesExp: any = {};\n-                }\n-\n-                @Component({\n-                  template:\n-                      '<div Dir1WithStyling Dir2WithStyling [style]=\"stylesExp\" [class]=\"classesExp\"></div>'\n-                })\n-                class App {\n-                  @ViewChild(Dir1WithStyling) dir1Instance!: Dir1WithStyling;\n-                  @ViewChild(Dir2WithStyling) dir2Instance!: Dir2WithStyling;\n-                  stylesExp: any = {};\n-                  classesExp: any = {};\n-                }\n-\n-                TestBed.configureTestingModule(\n-                    {declarations: [App, Dir2WithStyling, Dir1WithStyling]});\n-                const fixture = TestBed.createComponent(App);\n-                fixture.detectChanges();\n-                const {dir1Instance, dir2Instance} = fixture.componentInstance;\n-\n-                const target = fixture.nativeElement.querySelector('div')!;\n-                expect(target.style.getPropertyValue('width')).toEqual('111px');\n-\n-                const compInstance = fixture.componentInstance;\n-                compInstance.stylesExp = {width: '999px', height: undefined};\n-                compInstance.classesExp = {one: true, two: false};\n-                dir1Instance.stylesExp = {width: '222px'};\n-                dir1Instance.classesExp = {two: true, three: false};\n-                dir2Instance.stylesExp = {width: '333px', height: '100px'};\n-                fixture.detectChanges();\n-                expect(target.style.getPropertyValue('width')).toEqual('999px');\n-                expect(target.style.getPropertyValue('height')).toEqual('100px');\n-                expect(target.classList.contains('one')).toBeTruthy();\n-                expect(target.classList.contains('two')).toBeFalsy();\n-                expect(target.classList.contains('three')).toBeFalsy();\n-\n-                compInstance.stylesExp = {};\n-                compInstance.classesExp = {};\n-                dir1Instance.stylesExp = {width: '222px', height: '200px'};\n-                fixture.detectChanges();\n-                expect(target.style.getPropertyValue('width')).toEqual('222px');\n-                expect(target.style.getPropertyValue('height')).toEqual('200px');\n-                expect(target.classList.contains('one')).toBeFalsy();\n-                expect(target.classList.contains('two')).toBeTruthy();\n-                expect(target.classList.contains('three')).toBeFalsy();\n-\n-                dir1Instance.stylesExp = {};\n-                dir1Instance.classesExp = {};\n-                fixture.detectChanges();\n-                expect(target.style.getPropertyValue('width')).toEqual('333px');\n-                expect(target.style.getPropertyValue('height')).toEqual('100px');\n-                expect(target.classList.contains('one')).toBeFalsy();\n-                expect(target.classList.contains('two')).toBeFalsy();\n-                expect(target.classList.contains('three')).toBeFalsy();\n-\n-                dir2Instance.stylesExp = {};\n-                compInstance.stylesExp = {height: '900px'};\n-                fixture.detectChanges();\n-                expect(target.style.getPropertyValue('width')).toEqual('111px');\n-                expect(target.style.getPropertyValue('height')).toEqual('900px');\n-\n-                dir1Instance.stylesExp = {width: '666px', height: '600px'};\n-                dir1Instance.classesExp = {four: true, one: true};\n-                fixture.detectChanges();\n-                expect(target.style.getPropertyValue('width')).toEqual('666px');\n-                expect(target.style.getPropertyValue('height')).toEqual('900px');\n-                expect(target.classList.contains('one')).toBeTruthy();\n-                expect(target.classList.contains('two')).toBeFalsy();\n-                expect(target.classList.contains('three')).toBeFalsy();\n-                expect(target.classList.contains('four')).toBeTruthy();\n-\n-                compInstance.stylesExp = {width: '777px'};\n-                compInstance.classesExp = {four: false};\n-                fixture.detectChanges();\n-                expect(target.style.getPropertyValue('width')).toEqual('777px');\n-                expect(target.style.getPropertyValue('height')).toEqual('600px');\n-                expect(target.classList.contains('one')).toBeTruthy();\n-                expect(target.classList.contains('two')).toBeFalsy();\n-                expect(target.classList.contains('three')).toBeFalsy();\n-                expect(target.classList.contains('four')).toBeFalsy();\n-              });\n+           })\n+           class App {\n+             @ViewChild(DirWithSingleStylingBindings) dirInstance!: DirWithSingleStylingBindings;\n+           }\n+\n+           TestBed.configureTestingModule({declarations: [App, DirWithSingleStylingBindings]});\n+           const fixture = TestBed.createComponent(App);\n+           fixture.detectChanges();\n+           const dirInstance = fixture.componentInstance.dirInstance;\n+           const target: HTMLDivElement = fixture.nativeElement.querySelector('div');\n+           expect(target.style.getPropertyValue('width')).toEqual('100px');\n+           expect(target.style.getPropertyValue('height')).toEqual('');\n+           expect(target.classList.contains('abc')).toBeTruthy();\n+           expect(target.classList.contains('def')).toBeTruthy();\n+           expect(target.classList.contains('xyz')).toBeFalsy();\n+\n+           dirInstance.width = '444px';\n+           dirInstance.height = '999px';\n+           dirInstance.activateXYZClass = true;\n+           fixture.detectChanges();\n+\n+           expect(target.style.getPropertyValue('width')).toEqual('100px');\n+           expect(target.style.getPropertyValue('height')).toEqual('999px');\n+           expect(target.classList.contains('abc')).toBeTruthy();\n+           expect(target.classList.contains('def')).toBeTruthy();\n+           expect(target.classList.contains('xyz')).toBeTruthy();\n+\n+           dirInstance.width = undefined;\n+           dirInstance.height = undefined;\n+           fixture.detectChanges();\n+\n+           expect(target.style.getPropertyValue('width')).toEqual('100px');\n+           expect(target.style.getPropertyValue('height')).toEqual('');\n+           expect(target.classList.contains('abc')).toBeTruthy();\n+           expect(target.classList.contains('def')).toBeTruthy();\n+           expect(target.classList.contains('xyz')).toBeTruthy();\n+         });\n+\n+      it('should properly prioritize single style binding collisions when they exist on multiple directives',\n+         () => {\n+           @Directive({selector: '[Dir1WithStyle]', host: {'[style.width]': 'width'}})\n+           class Dir1WithStyle {\n+             width: null|string|undefined = undefined;\n+           }\n+\n+           @Directive({\n+             selector: '[Dir2WithStyle]',\n+             host: {'style': 'width: 111px', '[style.width]': 'width'}\n+           })\n+           class Dir2WithStyle {\n+             width: null|string|undefined = undefined;\n+           }\n+\n+           @Component({template: '<div Dir1WithStyle Dir2WithStyle [style.width]=\"width\"></div>'})\n+           class App {\n+             @ViewChild(Dir1WithStyle) dir1Instance!: Dir1WithStyle;\n+             @ViewChild(Dir2WithStyle) dir2Instance!: Dir2WithStyle;\n+             width: string|null|undefined = undefined;\n+           }\n+\n+           TestBed.configureTestingModule({declarations: [App, Dir2WithStyle, Dir1WithStyle]});\n+           const fixture = TestBed.createComponent(App);\n+           fixture.detectChanges();\n+           const {dir1Instance, dir2Instance} = fixture.componentInstance;\n+\n+           const target: HTMLDivElement = fixture.nativeElement.querySelector('div');\n+           expect(target.style.getPropertyValue('width')).toEqual('111px');\n+\n+           fixture.componentInstance.width = '999px';\n+           dir1Instance.width = '222px';\n+           dir2Instance.width = '333px';\n+           fixture.detectChanges();\n+           expect(target.style.getPropertyValue('width')).toEqual('999px');\n+\n+           fixture.componentInstance.width = undefined;\n+           fixture.detectChanges();\n+           expect(target.style.getPropertyValue('width')).toEqual('222px');\n+\n+           dir1Instance.width = undefined;\n+           fixture.detectChanges();\n+           expect(target.style.getPropertyValue('width')).toEqual('333px');\n+\n+           dir2Instance.width = undefined;\n+           fixture.detectChanges();\n+           expect(target.style.getPropertyValue('width')).toEqual('111px');\n+\n+           dir1Instance.width = '666px';\n+           fixture.detectChanges();\n+           expect(target.style.getPropertyValue('width')).toEqual('666px');\n+\n+           fixture.componentInstance.width = '777px';\n+           fixture.detectChanges();\n+           expect(target.style.getPropertyValue('width')).toEqual('777px');\n+         });\n+\n+      it('should properly prioritize multi style binding collisions when they exist on multiple directives',\n+         () => {\n+           @Directive({\n+             selector: '[Dir1WithStyling]',\n+             host: {'[style]': 'stylesExp', '[class]': 'classesExp'}\n+           })\n+           class Dir1WithStyling {\n+             classesExp: any = {};\n+             stylesExp: any = {};\n+           }\n+\n+           @Directive({\n+             selector: '[Dir2WithStyling]',\n+             host: {'style': 'width: 111px', '[style]': 'stylesExp'}\n+           })\n+           class Dir2WithStyling {\n+             stylesExp: any = {};\n+           }\n+\n+           @Component({\n+             template:\n+                 '<div Dir1WithStyling Dir2WithStyling [style]=\"stylesExp\" [class]=\"classesExp\"></div>'\n+           })\n+           class App {\n+             @ViewChild(Dir1WithStyling) dir1Instance!: Dir1WithStyling;\n+             @ViewChild(Dir2WithStyling) dir2Instance!: Dir2WithStyling;\n+             stylesExp: any = {};\n+             classesExp: any = {};\n+           }\n+\n+           TestBed.configureTestingModule({declarations: [App, Dir2WithStyling, Dir1WithStyling]});\n+           const fixture = TestBed.createComponent(App);\n+           fixture.detectChanges();\n+           const {dir1Instance, dir2Instance} = fixture.componentInstance;\n+\n+           const target = fixture.nativeElement.querySelector('div')!;\n+           expect(target.style.getPropertyValue('width')).toEqual('111px');\n+\n+           const compInstance = fixture.componentInstance;\n+           compInstance.stylesExp = {width: '999px', height: undefined};\n+           compInstance.classesExp = {one: true, two: false};\n+           dir1Instance.stylesExp = {width: '222px'};\n+           dir1Instance.classesExp = {two: true, three: false};\n+           dir2Instance.stylesExp = {width: '333px', height: '100px'};\n+           fixture.detectChanges();\n+           expect(target.style.getPropertyValue('width')).toEqual('999px');\n+           expect(target.style.getPropertyValue('height')).toEqual('100px');\n+           expect(target.classList.contains('one')).toBeTruthy();\n+           expect(target.classList.contains('two')).toBeFalsy();\n+           expect(target.classList.contains('three')).toBeFalsy();\n+\n+           compInstance.stylesExp = {};\n+           compInstance.classesExp = {};\n+           dir1Instance.stylesExp = {width: '222px', height: '200px'};\n+           fixture.detectChanges();\n+           expect(target.style.getPropertyValue('width')).toEqual('222px');\n+           expect(target.style.getPropertyValue('height')).toEqual('200px');\n+           expect(target.classList.contains('one')).toBeFalsy();\n+           expect(target.classList.contains('two')).toBeTruthy();\n+           expect(target.classList.contains('three')).toBeFalsy();\n+\n+           dir1Instance.stylesExp = {};\n+           dir1Instance.classesExp = {};\n+           fixture.detectChanges();\n+           expect(target.style.getPropertyValue('width')).toEqual('333px');\n+           expect(target.style.getPropertyValue('height')).toEqual('100px');\n+           expect(target.classList.contains('one')).toBeFalsy();\n+           expect(target.classList.contains('two')).toBeFalsy();\n+           expect(target.classList.contains('three')).toBeFalsy();\n+\n+           dir2Instance.stylesExp = {};\n+           compInstance.stylesExp = {height: '900px'};\n+           fixture.detectChanges();\n+           expect(target.style.getPropertyValue('width')).toEqual('111px');\n+           expect(target.style.getPropertyValue('height')).toEqual('900px');\n+\n+           dir1Instance.stylesExp = {width: '666px', height: '600px'};\n+           dir1Instance.classesExp = {four: true, one: true};\n+           fixture.detectChanges();\n+           expect(target.style.getPropertyValue('width')).toEqual('666px');\n+           expect(target.style.getPropertyValue('height')).toEqual('900px');\n+           expect(target.classList.contains('one')).toBeTruthy();\n+           expect(target.classList.contains('two')).toBeFalsy();\n+           expect(target.classList.contains('three')).toBeFalsy();\n+           expect(target.classList.contains('four')).toBeTruthy();\n+\n+           compInstance.stylesExp = {width: '777px'};\n+           compInstance.classesExp = {four: false};\n+           fixture.detectChanges();\n+           expect(target.style.getPropertyValue('width')).toEqual('777px');\n+           expect(target.style.getPropertyValue('height')).toEqual('600px');\n+           expect(target.classList.contains('one')).toBeTruthy();\n+           expect(target.classList.contains('two')).toBeFalsy();\n+           expect(target.classList.contains('three')).toBeFalsy();\n+           expect(target.classList.contains('four')).toBeFalsy();\n+         });\n     });\n \n     it('should properly handle and render interpolation for class attribute bindings', () => {\n@@ -1496,11 +1488,8 @@ describe('acceptance integration tests', () => {\n       class ModuleWithDeclaredModule {\n       }\n \n-      // The error is almost the same in Ivy and ViewEngine, however since Ivy's\n-      // message is more correct it doesn't make sense to align it ViewEngine.\n-      const expectedErrorMessage = ivyEnabled ?\n-          `Unexpected value 'SomeModule' declared by the module 'ModuleWithDeclaredModule'. Please add a @Pipe/@Directive/@Component annotation.` :\n-          `Unexpected module 'SomeModule' declared by the module 'ModuleWithDeclaredModule'. Please add a @Pipe/@Directive/@Component annotation.`;\n+      const expectedErrorMessage =\n+          `Unexpected value 'SomeModule' declared by the module 'ModuleWithDeclaredModule'. Please add a @Pipe/@Directive/@Component annotation.`;\n \n       expect(() => {\n         TestBed.configureTestingModule({imports: [ModuleWithDeclaredModule]})\n@@ -2166,85 +2155,83 @@ describe('acceptance integration tests', () => {\n       expect(element.getAttribute('data-dir')).toEqual(value);\n     }\n \n-    onlyInIvy('tView instances are ivy-specific')\n-        .it('should be marked with `firstUpdatePass` up until the template and host bindings are evaluated',\n-            () => {\n-              @Directive({\n-                selector: '[dir]',\n-              })\n-              class Dir {\n-                @HostBinding('attr.data-dir')\n-                get text() {\n-                  return isFirstUpdatePass() ? 'first-update-pass' : 'post-update-pass';\n-                }\n-              }\n-\n-              @Component({\n-                template: '<div [attr.data-comp]=\"text\" dir></div>',\n-              })\n-              class Cmp {\n-                get text() {\n-                  return isFirstUpdatePass() ? 'first-update-pass' : 'post-update-pass';\n-                }\n-              }\n-\n-              TestBed.configureTestingModule({\n-                declarations: [Cmp, Dir],\n-              });\n-              const fixture = TestBed.createComponent(Cmp);\n-              fixture.detectChanges(false);\n-              const element = fixture.nativeElement.querySelector('div')!;\n-\n-              assertAttrValues(element, 'first-update-pass');\n-\n-              fixture.detectChanges(false);\n-\n-              assertAttrValues(element, 'post-update-pass');\n-            });\n-\n-    onlyInIvy('tView instances are ivy-specific')\n-        .it('tView.firstUpdatePass should be applied immediately after the first embedded view is processed',\n-            () => {\n-              @Directive({\n-                selector: '[dir]',\n-              })\n-              class Dir {\n-                @HostBinding('attr.data-dir')\n-                get text() {\n-                  return isFirstUpdatePass() ? 'first-update-pass' : 'post-update-pass';\n-                }\n-              }\n-\n-              @Component({\n-                template: `\n+    it('should be marked with `firstUpdatePass` up until the template and host bindings are evaluated',\n+       () => {\n+         @Directive({\n+           selector: '[dir]',\n+         })\n+         class Dir {\n+           @HostBinding('attr.data-dir')\n+           get text() {\n+             return isFirstUpdatePass() ? 'first-update-pass' : 'post-update-pass';\n+           }\n+         }\n+\n+         @Component({\n+           template: '<div [attr.data-comp]=\"text\" dir></div>',\n+         })\n+         class Cmp {\n+           get text() {\n+             return isFirstUpdatePass() ? 'first-update-pass' : 'post-update-pass';\n+           }\n+         }\n+\n+         TestBed.configureTestingModule({\n+           declarations: [Cmp, Dir],\n+         });\n+         const fixture = TestBed.createComponent(Cmp);\n+         fixture.detectChanges(false);\n+         const element = fixture.nativeElement.querySelector('div')!;\n+\n+         assertAttrValues(element, 'first-update-pass');\n+\n+         fixture.detectChanges(false);\n+\n+         assertAttrValues(element, 'post-update-pass');\n+       });\n+\n+    it('tView.firstUpdatePass should be applied immediately after the first embedded view is processed',\n+       () => {\n+         @Directive({\n+           selector: '[dir]',\n+         })\n+         class Dir {\n+           @HostBinding('attr.data-dir')\n+           get text() {\n+             return isFirstUpdatePass() ? 'first-update-pass' : 'post-update-pass';\n+           }\n+         }\n+\n+         @Component({\n+           template: `\n           <div *ngFor=\"let item of items\" dir [attr.data-comp]=\"text\">\n             ...\n           </div>\n         `\n-              })\n-              class Cmp {\n-                items = [1, 2, 3];\n-                get text() {\n-                  return isFirstUpdatePass() ? 'first-update-pass' : 'post-update-pass';\n-                }\n-              }\n-\n-              TestBed.configureTestingModule({\n-                declarations: [Cmp, Dir],\n-              });\n-              const fixture = TestBed.createComponent(Cmp);\n-              fixture.detectChanges(false);\n-\n-              const elements = fixture.nativeElement.querySelectorAll('div');\n-              assertAttrValues(elements[0], 'first-update-pass');\n-              assertAttrValues(elements[1], 'post-update-pass');\n-              assertAttrValues(elements[2], 'post-update-pass');\n-\n-              fixture.detectChanges(false);\n-              assertAttrValues(elements[0], 'post-update-pass');\n-              assertAttrValues(elements[1], 'post-update-pass');\n-              assertAttrValues(elements[2], 'post-update-pass');\n-            });\n+         })\n+         class Cmp {\n+           items = [1, 2, 3];\n+           get text() {\n+             return isFirstUpdatePass() ? 'first-update-pass' : 'post-update-pass';\n+           }\n+         }\n+\n+         TestBed.configureTestingModule({\n+           declarations: [Cmp, Dir],\n+         });\n+         const fixture = TestBed.createComponent(Cmp);\n+         fixture.detectChanges(false);\n+\n+         const elements = fixture.nativeElement.querySelectorAll('div');\n+         assertAttrValues(elements[0], 'first-update-pass');\n+         assertAttrValues(elements[1], 'post-update-pass');\n+         assertAttrValues(elements[2], 'post-update-pass');\n+\n+         fixture.detectChanges(false);\n+         assertAttrValues(elements[0], 'post-update-pass');\n+         assertAttrValues(elements[1], 'post-update-pass');\n+         assertAttrValues(elements[2], 'post-update-pass');\n+       });\n   });\n \n   describe('animations', () => {"
        },
        {
            "sha": "bb68d3a0378f1dac187389f650f6da8e9c8fc3e5",
            "filename": "packages/core/test/acceptance/lifecycle_spec.ts",
            "status": "modified",
            "additions": 106,
            "deletions": 111,
            "changes": 217,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Flifecycle_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Flifecycle_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Flifecycle_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -10,7 +10,6 @@ import {CommonModule} from '@angular/common';\n import {AfterViewInit, ChangeDetectorRef, Component, ComponentFactoryResolver, ContentChildren, Directive, DoCheck, Input, NgModule, OnChanges, QueryList, SimpleChange, SimpleChanges, TemplateRef, ViewChild, ViewContainerRef} from '@angular/core';\n import {TestBed} from '@angular/core/testing';\n import {By} from '@angular/platform-browser';\n-import {onlyInIvy} from '@angular/private/testing';\n \n describe('onChanges', () => {\n   it('should correctly support updating one Input among many', () => {\n@@ -3938,65 +3937,63 @@ describe('onDestroy', () => {\n     expect(() => fixture.destroy()).not.toThrow();\n   });\n \n-  onlyInIvy(\n-      'View Engine has the opposite behavior, where it calls destroy on the directives first, then the components')\n-      .it('should be called on directives after component', () => {\n-        const events: string[] = [];\n+  it('should be called on directives after component', () => {\n+    const events: string[] = [];\n \n-        @Directive({\n-          selector: '[dir]',\n-        })\n-        class Dir {\n-          @Input('dir') name = '';\n+    @Directive({\n+      selector: '[dir]',\n+    })\n+    class Dir {\n+      @Input('dir') name = '';\n \n-          ngOnDestroy() {\n-            events.push('dir ' + this.name);\n-          }\n-        }\n+      ngOnDestroy() {\n+        events.push('dir ' + this.name);\n+      }\n+    }\n \n-        @Component({\n-          selector: 'comp',\n-          template: `<p>test</p>`,\n-        })\n-        class Comp {\n-          @Input() name = '';\n+    @Component({\n+      selector: 'comp',\n+      template: `<p>test</p>`,\n+    })\n+    class Comp {\n+      @Input() name = '';\n \n-          ngOnDestroy() {\n-            events.push('comp ' + this.name);\n-          }\n-        }\n+      ngOnDestroy() {\n+        events.push('comp ' + this.name);\n+      }\n+    }\n \n-        @Component({\n-          template: `\n+    @Component({\n+      template: `\n         <div *ngIf=\"show\">\n           <comp name=\"1\" dir=\"1\"></comp>\n           <comp name=\"2\" dir=\"2\"></comp>\n         </div>\n       `\n-        })\n-        class App {\n-          show = true;\n-        }\n+    })\n+    class App {\n+      show = true;\n+    }\n \n-        TestBed.configureTestingModule({\n-          declarations: [App, Dir, Comp],\n-          imports: [CommonModule],\n-        });\n-        const fixture = TestBed.createComponent(App);\n-        fixture.detectChanges();\n+    TestBed.configureTestingModule({\n+      declarations: [App, Dir, Comp],\n+      imports: [CommonModule],\n+    });\n+    const fixture = TestBed.createComponent(App);\n+    fixture.detectChanges();\n \n-        expect(events).toEqual([]);\n+    expect(events).toEqual([]);\n \n-        fixture.componentInstance.show = false;\n-        fixture.detectChanges();\n+    fixture.componentInstance.show = false;\n+    fixture.detectChanges();\n \n-        expect(events).toEqual([\n-          'comp 1',\n-          'dir 1',\n-          'comp 2',\n-          'dir 2',\n-        ]);\n-      });\n+    expect(events).toEqual([\n+      'comp 1',\n+      'dir 1',\n+      'comp 2',\n+      'dir 2',\n+    ]);\n+  });\n \n   it('should be called on directives on an element', () => {\n     const events: string[] = [];\n@@ -4378,71 +4375,69 @@ describe('non-regression', () => {\n     expect(destroyed).toBeTruthy();\n   });\n \n-  onlyInIvy('Use case is not supported in ViewEngine')\n-      .it('should not throw when calling detectChanges from a setter in the presence of a data binding, ngOnChanges and ngAfterViewInit',\n-          () => {\n-            const hooks: string[] = [];\n-\n-            @Directive({selector: '[testDir]'})\n-            class TestDirective implements OnChanges, AfterViewInit {\n-              constructor(private _changeDetectorRef: ChangeDetectorRef) {}\n-\n-              @Input('testDir')\n-              set value(_value: any) {\n-                this._changeDetectorRef.detectChanges();\n-              }\n-              ngOnChanges() {\n-                hooks.push('ngOnChanges');\n-              }\n-              ngAfterViewInit() {\n-                hooks.push('ngAfterViewInit');\n-              }\n-            }\n-\n-            @Component({template: `<div [testDir]=\"value\">{{value}}</div>`})\n-            class App {\n-              value = 1;\n-            }\n-\n-            TestBed.configureTestingModule({declarations: [App, TestDirective]});\n-            const fixture = TestBed.createComponent(App);\n-            expect(() => fixture.detectChanges()).not.toThrow();\n-            expect(hooks).toEqual(['ngOnChanges', 'ngAfterViewInit']);\n-            expect(fixture.nativeElement.textContent.trim()).toBe('1');\n-          });\n-\n-  onlyInIvy('Use case is not supported in ViewEngine')\n-      .it('should call hooks in the correct order when calling detectChanges in a setter', () => {\n-        const hooks: string[] = [];\n-\n-        @Directive({selector: '[testDir]'})\n-        class TestDirective implements OnChanges, DoCheck, AfterViewInit {\n-          constructor(private _changeDetectorRef: ChangeDetectorRef) {}\n-\n-          @Input('testDir')\n-          set value(_value: any) {\n-            this._changeDetectorRef.detectChanges();\n-          }\n-          ngOnChanges() {\n-            hooks.push('ngOnChanges');\n-          }\n-          ngDoCheck() {\n-            hooks.push('ngDoCheck');\n-          }\n-          ngAfterViewInit() {\n-            hooks.push('ngAfterViewInit');\n-          }\n-        }\n+  it('should not throw when calling detectChanges from a setter in the presence of a data binding, ngOnChanges and ngAfterViewInit',\n+     () => {\n+       const hooks: string[] = [];\n+\n+       @Directive({selector: '[testDir]'})\n+       class TestDirective implements OnChanges, AfterViewInit {\n+         constructor(private _changeDetectorRef: ChangeDetectorRef) {}\n+\n+         @Input('testDir')\n+         set value(_value: any) {\n+           this._changeDetectorRef.detectChanges();\n+         }\n+         ngOnChanges() {\n+           hooks.push('ngOnChanges');\n+         }\n+         ngAfterViewInit() {\n+           hooks.push('ngAfterViewInit');\n+         }\n+       }\n \n-        @Component({template: `<div [testDir]=\"value\">{{value}}</div>`})\n-        class App {\n-          value = 1;\n-        }\n+       @Component({template: `<div [testDir]=\"value\">{{value}}</div>`})\n+       class App {\n+         value = 1;\n+       }\n \n-        TestBed.configureTestingModule({declarations: [App, TestDirective]});\n-        const fixture = TestBed.createComponent(App);\n-        expect(() => fixture.detectChanges()).not.toThrow();\n-        expect(hooks).toEqual(['ngOnChanges', 'ngDoCheck', 'ngAfterViewInit']);\n-        expect(fixture.nativeElement.textContent.trim()).toBe('1');\n-      });\n+       TestBed.configureTestingModule({declarations: [App, TestDirective]});\n+       const fixture = TestBed.createComponent(App);\n+       expect(() => fixture.detectChanges()).not.toThrow();\n+       expect(hooks).toEqual(['ngOnChanges', 'ngAfterViewInit']);\n+       expect(fixture.nativeElement.textContent.trim()).toBe('1');\n+     });\n+\n+  it('should call hooks in the correct order when calling detectChanges in a setter', () => {\n+    const hooks: string[] = [];\n+\n+    @Directive({selector: '[testDir]'})\n+    class TestDirective implements OnChanges, DoCheck, AfterViewInit {\n+      constructor(private _changeDetectorRef: ChangeDetectorRef) {}\n+\n+      @Input('testDir')\n+      set value(_value: any) {\n+        this._changeDetectorRef.detectChanges();\n+      }\n+      ngOnChanges() {\n+        hooks.push('ngOnChanges');\n+      }\n+      ngDoCheck() {\n+        hooks.push('ngDoCheck');\n+      }\n+      ngAfterViewInit() {\n+        hooks.push('ngAfterViewInit');\n+      }\n+    }\n+\n+    @Component({template: `<div [testDir]=\"value\">{{value}}</div>`})\n+    class App {\n+      value = 1;\n+    }\n+\n+    TestBed.configureTestingModule({declarations: [App, TestDirective]});\n+    const fixture = TestBed.createComponent(App);\n+    expect(() => fixture.detectChanges()).not.toThrow();\n+    expect(hooks).toEqual(['ngOnChanges', 'ngDoCheck', 'ngAfterViewInit']);\n+    expect(fixture.nativeElement.textContent.trim()).toBe('1');\n+  });\n });"
        },
        {
            "sha": "fa039bc8679e3f8c0c18ade5e892df19315ac775",
            "filename": "packages/core/test/acceptance/listener_spec.ts",
            "status": "modified",
            "additions": 157,
            "deletions": 167,
            "changes": 324,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Flistener_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Flistener_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Flistener_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -10,7 +10,6 @@ import {CommonModule} from '@angular/common';\n import {Component, Directive, ErrorHandler, EventEmitter, HostListener, Input, OnInit, Output, QueryList, TemplateRef, ViewChild, ViewChildren, ViewContainerRef} from '@angular/core';\n import {TestBed} from '@angular/core/testing';\n import {By} from '@angular/platform-browser';\n-import {onlyInIvy} from '@angular/private/testing';\n \n function getNoOfNativeListeners(): number {\n   return ngDevMode ? ngDevMode.rendererAddEventListener : 0;\n@@ -67,75 +66,70 @@ describe('event listeners', () => {\n       }\n     }\n \n-    onlyInIvy('ngDevMode.rendererAddEventListener counters are only available in ivy')\n-        .it('should coalesce multiple event listeners for the same event on the same element',\n-            () => {\n-              @Component({\n-                selector: 'test-cmpt',\n-                template:\n-                    `<with-clicks-cmpt></with-clicks-cmpt><with-clicks-cmpt></with-clicks-cmpt>`\n-              })\n-              class TestCmpt {\n-              }\n-\n-              TestBed.configureTestingModule(\n-                  {declarations: [TestCmpt, WithClicksCmpt, LikesClicks, MdButton]});\n-              const noOfEventListenersRegisteredSoFar = getNoOfNativeListeners();\n-              const fixture = TestBed.createComponent(TestCmpt);\n-              fixture.detectChanges();\n-              const buttonDebugEls = fixture.debugElement.queryAll(By.css('button'));\n-              const withClicksEls = fixture.debugElement.queryAll(By.css('with-clicks-cmpt'));\n-\n-              // We want to assert that only one native event handler was registered but still all\n-              // directives are notified when an event fires. This assertion can only be verified in\n-              // the ngDevMode (but the coalescing always happens!).\n-              ngDevMode &&\n-                  expect(getNoOfNativeListeners()).toBe(noOfEventListenersRegisteredSoFar + 2);\n-\n-              buttonDebugEls[0].nativeElement.click();\n-              expect(withClicksEls[0].injector.get(WithClicksCmpt).counter).toBe(1);\n-              expect(buttonDebugEls[0].injector.get(LikesClicks).counter).toBe(1);\n-              expect(buttonDebugEls[0].injector.get(MdButton).counter).toBe(1);\n-              expect(withClicksEls[1].injector.get(WithClicksCmpt).counter).toBe(0);\n-              expect(buttonDebugEls[1].injector.get(LikesClicks).counter).toBe(0);\n-              expect(buttonDebugEls[1].injector.get(MdButton).counter).toBe(0);\n-\n-              buttonDebugEls[1].nativeElement.click();\n-              expect(withClicksEls[0].injector.get(WithClicksCmpt).counter).toBe(1);\n-              expect(buttonDebugEls[0].injector.get(LikesClicks).counter).toBe(1);\n-              expect(buttonDebugEls[0].injector.get(MdButton).counter).toBe(1);\n-              expect(withClicksEls[1].injector.get(WithClicksCmpt).counter).toBe(1);\n-              expect(buttonDebugEls[1].injector.get(LikesClicks).counter).toBe(1);\n-              expect(buttonDebugEls[1].injector.get(MdButton).counter).toBe(1);\n-            });\n-\n-    onlyInIvy('ngDevMode.rendererAddEventListener counters are only available in ivy')\n-        .it('should coalesce multiple event listeners in presence of queries', () => {\n-          @Component({\n-            selector: 'test-cmpt',\n-            template: `<button likes-clicks (click)=\"counter = counter+1\">Click me!</button>`\n-          })\n-          class TestCmpt {\n-            counter = 0;\n-\n-            @ViewChildren('nothing') nothing!: QueryList<any>;\n-          }\n-\n-          TestBed.configureTestingModule({declarations: [TestCmpt, LikesClicks]});\n-          const noOfEventListenersRegisteredSoFar = getNoOfNativeListeners();\n-          const fixture = TestBed.createComponent(TestCmpt);\n-          fixture.detectChanges();\n-          const buttonDebugEl = fixture.debugElement.query(By.css('button'));\n-\n-          // We want to assert that only one native event handler was registered but still all\n-          // directives are notified when an event fires. This assertion can only be verified in\n-          // the ngDevMode (but the coalescing always happens!).\n-          ngDevMode && expect(getNoOfNativeListeners()).toBe(noOfEventListenersRegisteredSoFar + 1);\n-\n-          buttonDebugEl.nativeElement.click();\n-          expect(buttonDebugEl.injector.get(LikesClicks).counter).toBe(1);\n-          expect(fixture.componentInstance.counter).toBe(1);\n-        });\n+    it('should coalesce multiple event listeners for the same event on the same element', () => {\n+      @Component({\n+        selector: 'test-cmpt',\n+        template: `<with-clicks-cmpt></with-clicks-cmpt><with-clicks-cmpt></with-clicks-cmpt>`\n+      })\n+      class TestCmpt {\n+      }\n+\n+      TestBed.configureTestingModule(\n+          {declarations: [TestCmpt, WithClicksCmpt, LikesClicks, MdButton]});\n+      const noOfEventListenersRegisteredSoFar = getNoOfNativeListeners();\n+      const fixture = TestBed.createComponent(TestCmpt);\n+      fixture.detectChanges();\n+      const buttonDebugEls = fixture.debugElement.queryAll(By.css('button'));\n+      const withClicksEls = fixture.debugElement.queryAll(By.css('with-clicks-cmpt'));\n+\n+      // We want to assert that only one native event handler was registered but still all\n+      // directives are notified when an event fires. This assertion can only be verified in\n+      // the ngDevMode (but the coalescing always happens!).\n+      ngDevMode && expect(getNoOfNativeListeners()).toBe(noOfEventListenersRegisteredSoFar + 2);\n+\n+      buttonDebugEls[0].nativeElement.click();\n+      expect(withClicksEls[0].injector.get(WithClicksCmpt).counter).toBe(1);\n+      expect(buttonDebugEls[0].injector.get(LikesClicks).counter).toBe(1);\n+      expect(buttonDebugEls[0].injector.get(MdButton).counter).toBe(1);\n+      expect(withClicksEls[1].injector.get(WithClicksCmpt).counter).toBe(0);\n+      expect(buttonDebugEls[1].injector.get(LikesClicks).counter).toBe(0);\n+      expect(buttonDebugEls[1].injector.get(MdButton).counter).toBe(0);\n+\n+      buttonDebugEls[1].nativeElement.click();\n+      expect(withClicksEls[0].injector.get(WithClicksCmpt).counter).toBe(1);\n+      expect(buttonDebugEls[0].injector.get(LikesClicks).counter).toBe(1);\n+      expect(buttonDebugEls[0].injector.get(MdButton).counter).toBe(1);\n+      expect(withClicksEls[1].injector.get(WithClicksCmpt).counter).toBe(1);\n+      expect(buttonDebugEls[1].injector.get(LikesClicks).counter).toBe(1);\n+      expect(buttonDebugEls[1].injector.get(MdButton).counter).toBe(1);\n+    });\n+\n+    it('should coalesce multiple event listeners in presence of queries', () => {\n+      @Component({\n+        selector: 'test-cmpt',\n+        template: `<button likes-clicks (click)=\"counter = counter+1\">Click me!</button>`\n+      })\n+      class TestCmpt {\n+        counter = 0;\n+\n+        @ViewChildren('nothing') nothing!: QueryList<any>;\n+      }\n+\n+      TestBed.configureTestingModule({declarations: [TestCmpt, LikesClicks]});\n+      const noOfEventListenersRegisteredSoFar = getNoOfNativeListeners();\n+      const fixture = TestBed.createComponent(TestCmpt);\n+      fixture.detectChanges();\n+      const buttonDebugEl = fixture.debugElement.query(By.css('button'));\n+\n+      // We want to assert that only one native event handler was registered but still all\n+      // directives are notified when an event fires. This assertion can only be verified in\n+      // the ngDevMode (but the coalescing always happens!).\n+      ngDevMode && expect(getNoOfNativeListeners()).toBe(noOfEventListenersRegisteredSoFar + 1);\n+\n+      buttonDebugEl.nativeElement.click();\n+      expect(buttonDebugEl.injector.get(LikesClicks).counter).toBe(1);\n+      expect(fixture.componentInstance.counter).toBe(1);\n+    });\n \n \n     it('should try to execute remaining coalesced listeners if one of the listeners throws', () => {\n@@ -398,136 +392,132 @@ describe('event listeners', () => {\n     expect(comp.counter).toBe(1);\n   });\n \n-  onlyInIvy('global event listeners on non-node host elements are supported only in Ivy')\n-      .it('should bind global event listeners on an ng-container directive host', () => {\n-        let clicks = 0;\n+  it('should bind global event listeners on an ng-container directive host', () => {\n+    let clicks = 0;\n \n-        @Directive({selector: '[add-global-listener]'})\n-        class AddGlobalListener {\n-          @HostListener('document:click')\n-          handleClick() {\n-            clicks++;\n-          }\n-        }\n+    @Directive({selector: '[add-global-listener]'})\n+    class AddGlobalListener {\n+      @HostListener('document:click')\n+      handleClick() {\n+        clicks++;\n+      }\n+    }\n \n-        @Component({\n-          template: `\n+    @Component({\n+      template: `\n             <ng-container add-global-listener>\n               <button>Click me!</button>\n             </ng-container>\n           `\n-        })\n-        class MyComp {\n-        }\n+    })\n+    class MyComp {\n+    }\n \n-        TestBed.configureTestingModule({declarations: [MyComp, AddGlobalListener]});\n-        const fixture = TestBed.createComponent(MyComp);\n-        fixture.detectChanges();\n-        const button = fixture.nativeElement.querySelector('button');\n-        button.click();\n-        fixture.detectChanges();\n-        expect(clicks).toBe(1);\n-      });\n+    TestBed.configureTestingModule({declarations: [MyComp, AddGlobalListener]});\n+    const fixture = TestBed.createComponent(MyComp);\n+    fixture.detectChanges();\n+    const button = fixture.nativeElement.querySelector('button');\n+    button.click();\n+    fixture.detectChanges();\n+    expect(clicks).toBe(1);\n+  });\n \n-  onlyInIvy('global event listeners on non-node host elements are supported only in Ivy')\n-      .it('should bind global event listeners on an ng-template directive host', () => {\n-        let clicks = 0;\n+  it('should bind global event listeners on an ng-template directive host', () => {\n+    let clicks = 0;\n \n-        @Directive({selector: '[add-global-listener]'})\n-        class AddGlobalListener {\n-          @HostListener('document:click')\n-          handleClick() {\n-            clicks++;\n-          }\n-        }\n+    @Directive({selector: '[add-global-listener]'})\n+    class AddGlobalListener {\n+      @HostListener('document:click')\n+      handleClick() {\n+        clicks++;\n+      }\n+    }\n \n-        @Component({\n-          template: `\n+    @Component({\n+      template: `\n             <ng-template #template add-global-listener>\n               <button>Click me!</button>\n             </ng-template>\n \n             <ng-container [ngTemplateOutlet]=\"template\"></ng-container>\n           `\n-        })\n-        class MyComp {\n-        }\n+    })\n+    class MyComp {\n+    }\n \n-        TestBed.configureTestingModule(\n-            {declarations: [MyComp, AddGlobalListener], imports: [CommonModule]});\n-        const fixture = TestBed.createComponent(MyComp);\n-        fixture.detectChanges();\n-        const button = fixture.nativeElement.querySelector('button');\n-        button.click();\n-        fixture.detectChanges();\n-        expect(clicks).toBe(1);\n-      });\n+    TestBed.configureTestingModule(\n+        {declarations: [MyComp, AddGlobalListener], imports: [CommonModule]});\n+    const fixture = TestBed.createComponent(MyComp);\n+    fixture.detectChanges();\n+    const button = fixture.nativeElement.querySelector('button');\n+    button.click();\n+    fixture.detectChanges();\n+    expect(clicks).toBe(1);\n+  });\n \n-  onlyInIvy('global event listeners on non-node host elements are supported only in Ivy')\n-      .it('should bind global event listeners on a structural directive host', () => {\n-        let clicks = 0;\n+  it('should bind global event listeners on a structural directive host', () => {\n+    let clicks = 0;\n \n-        @Directive({selector: '[add-global-listener]'})\n-        class AddGlobalListener implements OnInit {\n-          @HostListener('document:click')\n-          handleClick() {\n-            clicks++;\n-          }\n+    @Directive({selector: '[add-global-listener]'})\n+    class AddGlobalListener implements OnInit {\n+      @HostListener('document:click')\n+      handleClick() {\n+        clicks++;\n+      }\n \n-          constructor(private _vcr: ViewContainerRef, private _templateRef: TemplateRef<any>) {}\n+      constructor(private _vcr: ViewContainerRef, private _templateRef: TemplateRef<any>) {}\n \n-          ngOnInit() {\n-            this._vcr.createEmbeddedView(this._templateRef);\n-          }\n-        }\n+      ngOnInit() {\n+        this._vcr.createEmbeddedView(this._templateRef);\n+      }\n+    }\n \n-        @Component({\n-          template: `\n+    @Component({\n+      template: `\n             <div *add-global-listener>\n               <button>Click me!</button>\n             </div>\n           `\n-        })\n-        class MyComp {\n-        }\n+    })\n+    class MyComp {\n+    }\n \n-        TestBed.configureTestingModule({declarations: [MyComp, AddGlobalListener]});\n-        const fixture = TestBed.createComponent(MyComp);\n-        fixture.detectChanges();\n-        const button = fixture.nativeElement.querySelector('button');\n-        button.click();\n-        fixture.detectChanges();\n-        expect(clicks).toBe(1);\n-      });\n+    TestBed.configureTestingModule({declarations: [MyComp, AddGlobalListener]});\n+    const fixture = TestBed.createComponent(MyComp);\n+    fixture.detectChanges();\n+    const button = fixture.nativeElement.querySelector('button');\n+    button.click();\n+    fixture.detectChanges();\n+    expect(clicks).toBe(1);\n+  });\n \n-  onlyInIvy('issue has only been resolved for Ivy')\n-      .it('should be able to access a property called $event using `this`', () => {\n-        let eventVariable: number|undefined;\n-        let eventObject: MouseEvent|undefined;\n+  it('should be able to access a property called $event using `this`', () => {\n+    let eventVariable: number|undefined;\n+    let eventObject: MouseEvent|undefined;\n \n-        @Component({\n-          template: `\n+    @Component({\n+      template: `\n         <button (click)=\"clicked(this.$event, $event)\">Click me!</button>\n       `,\n-        })\n-        class MyComp {\n-          $event = 10;\n-\n-          clicked(value: number, event: MouseEvent) {\n-            eventVariable = value;\n-            eventObject = event;\n-          }\n-        }\n+    })\n+    class MyComp {\n+      $event = 10;\n \n-        TestBed.configureTestingModule({declarations: [MyComp]});\n-        const fixture = TestBed.createComponent(MyComp);\n-        fixture.detectChanges();\n-        fixture.nativeElement.querySelector('button').click();\n-        fixture.detectChanges();\n+      clicked(value: number, event: MouseEvent) {\n+        eventVariable = value;\n+        eventObject = event;\n+      }\n+    }\n \n-        expect(eventVariable).toBe(10);\n-        expect(eventObject?.type).toBe('click');\n-      });\n+    TestBed.configureTestingModule({declarations: [MyComp]});\n+    const fixture = TestBed.createComponent(MyComp);\n+    fixture.detectChanges();\n+    fixture.nativeElement.querySelector('button').click();\n+    fixture.detectChanges();\n+\n+    expect(eventVariable).toBe(10);\n+    expect(eventObject?.type).toBe('click');\n+  });\n \n   it('should be able to use a keyed write on `this` from a listener inside an ng-template', () => {\n     @Component({"
        },
        {
            "sha": "5d26ce241350fa61f8a6120ecc13193ad12b03ef",
            "filename": "packages/core/test/acceptance/ng_module_spec.ts",
            "status": "modified",
            "additions": 126,
            "deletions": 309,
            "changes": 435,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fng_module_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fng_module_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fng_module_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -12,7 +12,7 @@ import {TestBed} from '@angular/core/testing';\n import {BrowserModule} from '@angular/platform-browser';\n import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {modifiedInIvy, onlyInIvy, withBody} from '@angular/private/testing';\n+import {withBody} from '@angular/private/testing';\n \n describe('NgModule', () => {\n   @Component({template: 'hello'})\n@@ -141,64 +141,34 @@ describe('NgModule', () => {\n   });\n \n   describe('schemas', () => {\n-    onlyInIvy('Unknown property logs an error message instead of throwing')\n-        .it('should throw on unknown props if NO_ERRORS_SCHEMA is absent', () => {\n-          @Component({\n-            selector: 'my-comp',\n-            template: `\n-              <ng-container *ngIf=\"condition\">\n-                <div [unknown-prop]=\"true\"></div>\n-              </ng-container>\n-            `,\n-          })\n-          class MyComp {\n-            condition = true;\n-          }\n-\n-          @NgModule({\n-            imports: [CommonModule],\n-            declarations: [MyComp],\n-          })\n-          class MyModule {\n-          }\n-\n-          TestBed.configureTestingModule({imports: [MyModule]});\n-\n-          const spy = spyOn(console, 'error');\n-          const fixture = TestBed.createComponent(MyComp);\n-          fixture.detectChanges();\n-          expect(spy.calls.mostRecent().args[0])\n-              .toMatch(/Can't bind to 'unknown-prop' since it isn't a known property of 'div'/);\n-        });\n-\n-    modifiedInIvy('Unknown properties throw an error instead of logging a warning')\n-        .it('should throw on unknown props if NO_ERRORS_SCHEMA is absent', () => {\n-          @Component({\n-            selector: 'my-comp',\n-            template: `\n+    it('should throw on unknown props if NO_ERRORS_SCHEMA is absent', () => {\n+      @Component({\n+        selector: 'my-comp',\n+        template: `\n               <ng-container *ngIf=\"condition\">\n                 <div [unknown-prop]=\"true\"></div>\n               </ng-container>\n             `,\n-          })\n-          class MyComp {\n-            condition = true;\n-          }\n+      })\n+      class MyComp {\n+        condition = true;\n+      }\n \n-          @NgModule({\n-            imports: [CommonModule],\n-            declarations: [MyComp],\n-          })\n-          class MyModule {\n-          }\n+      @NgModule({\n+        imports: [CommonModule],\n+        declarations: [MyComp],\n+      })\n+      class MyModule {\n+      }\n \n-          TestBed.configureTestingModule({imports: [MyModule]});\n+      TestBed.configureTestingModule({imports: [MyModule]});\n \n-          expect(() => {\n-            const fixture = TestBed.createComponent(MyComp);\n-            fixture.detectChanges();\n-          }).toThrowError(/Can't bind to 'unknown-prop' since it isn't a known property of 'div'/);\n-        });\n+      const spy = spyOn(console, 'error');\n+      const fixture = TestBed.createComponent(MyComp);\n+      fixture.detectChanges();\n+      expect(spy.calls.mostRecent().args[0])\n+          .toMatch(/Can't bind to 'unknown-prop' since it isn't a known property of 'div'/);\n+    });\n \n     it('should not throw on unknown props if NO_ERRORS_SCHEMA is present', () => {\n       @Component({\n@@ -229,129 +199,62 @@ describe('NgModule', () => {\n       }).not.toThrow();\n     });\n \n-    onlyInIvy('unknown element check logs an error message rather than throwing')\n-        .it('should log an error about unknown element without CUSTOM_ELEMENTS_SCHEMA for element with dash in tag name',\n-            () => {\n-              @Component({template: `<custom-el></custom-el>`})\n-              class MyComp {\n-              }\n-\n-              const spy = spyOn(console, 'error');\n-              TestBed.configureTestingModule({declarations: [MyComp]});\n-              const fixture = TestBed.createComponent(MyComp);\n-              fixture.detectChanges();\n-              expect(spy.calls.mostRecent().args[0]).toMatch(/'custom-el' is not a known element/);\n-            });\n-\n-    modifiedInIvy('unknown element error thrown instead of warning')\n-        .it('should throw unknown element error without CUSTOM_ELEMENTS_SCHEMA for element with dash in tag name',\n-            () => {\n-              @Component({template: `<custom-el></custom-el>`})\n-              class MyComp {\n-              }\n-\n-              TestBed.configureTestingModule({declarations: [MyComp]});\n-\n-              expect(() => {\n-                const fixture = TestBed.createComponent(MyComp);\n-                fixture.detectChanges();\n-              }).toThrowError(/'custom-el' is not a known element/);\n-            });\n-\n-    onlyInIvy('unknown element check logs an error message rather than throwing')\n-        .it('should log an error about unknown element without CUSTOM_ELEMENTS_SCHEMA for element without dash in tag name',\n-            () => {\n-              @Component({template: `<custom></custom>`})\n-              class MyComp {\n-              }\n-\n-              const spy = spyOn(console, 'error');\n-              TestBed.configureTestingModule({declarations: [MyComp]});\n-              const fixture = TestBed.createComponent(MyComp);\n-              fixture.detectChanges();\n-              expect(spy.calls.mostRecent().args[0]).toMatch(/'custom' is not a known element/);\n-            });\n-\n-    modifiedInIvy('unknown element error thrown instead of warning')\n-        .it('should throw unknown element error without CUSTOM_ELEMENTS_SCHEMA for element without dash in tag name',\n-            () => {\n-              @Component({template: `<custom></custom>`})\n-              class MyComp {\n-              }\n-\n-              TestBed.configureTestingModule({declarations: [MyComp]});\n-\n-              expect(() => {\n-                const fixture = TestBed.createComponent(MyComp);\n-                fixture.detectChanges();\n-              }).toThrowError(/'custom' is not a known element/);\n-            });\n-\n-    onlyInIvy('unknown element check logs an error message rather than throwing')\n-        .it('should report unknown property bindings on ng-content', () => {\n-          @Component({template: `<ng-content *unknownProp=\"123\"></ng-content>`})\n-          class App {\n-          }\n-\n-          TestBed.configureTestingModule({declarations: [App]});\n-          const spy = spyOn(console, 'error');\n-          const fixture = TestBed.createComponent(App);\n-          fixture.detectChanges();\n-\n-          expect(spy.calls.mostRecent()?.args[0])\n-              .toMatch(\n-                  /Can't bind to 'unknownProp' since it isn't a known property of 'ng-content'/);\n-        });\n-\n-    modifiedInIvy('unknown element error thrown instead of warning')\n-        .it('should throw for unknown property bindings on ng-content', () => {\n-          @Component({template: `<ng-content *unknownProp=\"123\"></ng-content>`})\n-          class App {\n-          }\n+    it('should log an error about unknown element without CUSTOM_ELEMENTS_SCHEMA for element with dash in tag name',\n+       () => {\n+         @Component({template: `<custom-el></custom-el>`})\n+         class MyComp {\n+         }\n \n-          TestBed.configureTestingModule({declarations: [App]});\n+         const spy = spyOn(console, 'error');\n+         TestBed.configureTestingModule({declarations: [MyComp]});\n+         const fixture = TestBed.createComponent(MyComp);\n+         fixture.detectChanges();\n+         expect(spy.calls.mostRecent().args[0]).toMatch(/'custom-el' is not a known element/);\n+       });\n+\n+    it('should log an error about unknown element without CUSTOM_ELEMENTS_SCHEMA for element without dash in tag name',\n+       () => {\n+         @Component({template: `<custom></custom>`})\n+         class MyComp {\n+         }\n \n-          expect(() => {\n-            const fixture = TestBed.createComponent(App);\n-            fixture.detectChanges();\n-          })\n-              .toThrowError(\n-                  /Can't bind to 'unknownProp' since it isn't a known property of 'ng-content'/);\n-        });\n+         const spy = spyOn(console, 'error');\n+         TestBed.configureTestingModule({declarations: [MyComp]});\n+         const fixture = TestBed.createComponent(MyComp);\n+         fixture.detectChanges();\n+         expect(spy.calls.mostRecent().args[0]).toMatch(/'custom' is not a known element/);\n+       });\n \n-    onlyInIvy('unknown element check logs an error message rather than throwing')\n-        .it('should report unknown property bindings on ng-container', () => {\n-          @Component({template: `<ng-container [unknown-prop]=\"123\"></ng-container>`})\n-          class App {\n-          }\n+    it('should report unknown property bindings on ng-content', () => {\n+      @Component({template: `<ng-content *unknownProp=\"123\"></ng-content>`})\n+      class App {\n+      }\n \n-          TestBed.configureTestingModule({declarations: [App]});\n-          const spy = spyOn(console, 'error');\n-          const fixture = TestBed.createComponent(App);\n-          fixture.detectChanges();\n+      TestBed.configureTestingModule({declarations: [App]});\n+      const spy = spyOn(console, 'error');\n+      const fixture = TestBed.createComponent(App);\n+      fixture.detectChanges();\n \n-          expect(spy.calls.mostRecent()?.args[0])\n-              .toMatch(\n-                  /Can't bind to 'unknown-prop' since it isn't a known property of 'ng-container'/);\n-        });\n+      expect(spy.calls.mostRecent()?.args[0])\n+          .toMatch(/Can't bind to 'unknownProp' since it isn't a known property of 'ng-content'/);\n+    });\n \n-    modifiedInIvy('unknown element error thrown instead of warning')\n-        .it('should throw for unknown property bindings on ng-container', () => {\n-          @Component({template: `<ng-container [unknown-prop]=\"123\"></ng-container>`})\n-          class App {\n-          }\n+    it('should report unknown property bindings on ng-container', () => {\n+      @Component({template: `<ng-container [unknown-prop]=\"123\"></ng-container>`})\n+      class App {\n+      }\n \n-          TestBed.configureTestingModule({declarations: [App]});\n+      TestBed.configureTestingModule({declarations: [App]});\n+      const spy = spyOn(console, 'error');\n+      const fixture = TestBed.createComponent(App);\n+      fixture.detectChanges();\n \n-          expect(() => {\n-            const fixture = TestBed.createComponent(App);\n-            fixture.detectChanges();\n-          })\n-              .toThrowError(\n-                  /Can't bind to 'unknown-prop' since it isn't a known property of 'ng-container'/);\n-        });\n+      expect(spy.calls.mostRecent()?.args[0])\n+          .toMatch(\n+              /Can't bind to 'unknown-prop' since it isn't a known property of 'ng-container'/);\n+    });\n \n-    onlyInIvy('test relies on Ivy-specific AOT format').describe('AOT-compiled components', () => {\n+    describe('AOT-compiled components', () => {\n       function createComponent(\n           template: (rf: any) => void, vars: number, consts?: (number|string)[][]) {\n         class Comp {\n@@ -467,168 +370,82 @@ describe('NgModule', () => {\n       });\n     });\n \n-    onlyInIvy('unknown element check logs an error message rather than throwing')\n-        .it('should not log an error about unknown elements with CUSTOM_ELEMENTS_SCHEMA', () => {\n-          @Component({template: `<custom-el></custom-el>`})\n-          class MyComp {\n-          }\n-\n-          const spy = spyOn(console, 'error');\n-          TestBed.configureTestingModule({\n-            declarations: [MyComp],\n-            schemas: [CUSTOM_ELEMENTS_SCHEMA],\n-          });\n-\n-          const fixture = TestBed.createComponent(MyComp);\n-          fixture.detectChanges();\n-          expect(spy).not.toHaveBeenCalled();\n-        });\n-\n-    modifiedInIvy('unknown element error thrown instead of warning')\n-        .it('should not throw unknown element error with CUSTOM_ELEMENTS_SCHEMA', () => {\n-          @Component({template: `<custom-el></custom-el>`})\n-          class MyComp {\n-          }\n-\n-          TestBed.configureTestingModule({\n-            declarations: [MyComp],\n-            schemas: [CUSTOM_ELEMENTS_SCHEMA],\n-          });\n-\n-          expect(() => {\n-            const fixture = TestBed.createComponent(MyComp);\n-            fixture.detectChanges();\n-          }).not.toThrow();\n-        });\n-\n-    onlyInIvy('unknown element check logs an error message rather than throwing')\n-        .it('should not log an error about unknown elements with NO_ERRORS_SCHEMA', () => {\n-          @Component({template: `<custom-el></custom-el>`})\n-          class MyComp {\n-          }\n-\n-          const spy = spyOn(console, 'error');\n-          TestBed.configureTestingModule({\n-            declarations: [MyComp],\n-            schemas: [NO_ERRORS_SCHEMA],\n-          });\n-\n-          const fixture = TestBed.createComponent(MyComp);\n-          fixture.detectChanges();\n-          expect(spy).not.toHaveBeenCalled();\n-        });\n-\n-    modifiedInIvy('unknown element error thrown instead of warning')\n-        .it('should not throw unknown element error with NO_ERRORS_SCHEMA', () => {\n-          @Component({template: `<custom-el></custom-el>`})\n-          class MyComp {\n-          }\n-\n-          TestBed.configureTestingModule({\n-            declarations: [MyComp],\n-            schemas: [NO_ERRORS_SCHEMA],\n-          });\n-\n-          expect(() => {\n-            const fixture = TestBed.createComponent(MyComp);\n-            fixture.detectChanges();\n-          }).not.toThrow();\n-        });\n-\n-    onlyInIvy('unknown element check logs an error message rather than throwing')\n-        .it('should not log an error about unknown elements if element matches a directive', () => {\n-          @Component({\n-            selector: 'custom-el',\n-            template: '',\n-          })\n-          class CustomEl {\n-          }\n-\n-          @Component({template: `<custom-el></custom-el>`})\n-          class MyComp {\n-          }\n-\n-          const spy = spyOn(console, 'error');\n-          TestBed.configureTestingModule({declarations: [MyComp, CustomEl]});\n-\n-          const fixture = TestBed.createComponent(MyComp);\n-          fixture.detectChanges();\n-          expect(spy).not.toHaveBeenCalled();\n-        });\n+    it('should not log an error about unknown elements with CUSTOM_ELEMENTS_SCHEMA', () => {\n+      @Component({template: `<custom-el></custom-el>`})\n+      class MyComp {\n+      }\n \n-    modifiedInIvy('unknown element error thrown instead of warning')\n-        .it('should not throw unknown element error if element matches a directive', () => {\n-          @Component({\n-            selector: 'custom-el',\n-            template: '',\n-          })\n-          class CustomEl {\n-          }\n+      const spy = spyOn(console, 'error');\n+      TestBed.configureTestingModule({\n+        declarations: [MyComp],\n+        schemas: [CUSTOM_ELEMENTS_SCHEMA],\n+      });\n \n-          @Component({template: `<custom-el></custom-el>`})\n-          class MyComp {\n-          }\n+      const fixture = TestBed.createComponent(MyComp);\n+      fixture.detectChanges();\n+      expect(spy).not.toHaveBeenCalled();\n+    });\n \n-          TestBed.configureTestingModule({declarations: [MyComp, CustomEl]});\n+    it('should not log an error about unknown elements with NO_ERRORS_SCHEMA', () => {\n+      @Component({template: `<custom-el></custom-el>`})\n+      class MyComp {\n+      }\n \n-          expect(() => {\n-            const fixture = TestBed.createComponent(MyComp);\n-            fixture.detectChanges();\n-          }).not.toThrow();\n-        });\n+      const spy = spyOn(console, 'error');\n+      TestBed.configureTestingModule({\n+        declarations: [MyComp],\n+        schemas: [NO_ERRORS_SCHEMA],\n+      });\n \n-    onlyInIvy('unknown element check logs an error message rather than throwing')\n-        .it('should not log an error for HTML elements inside an SVG foreignObject', () => {\n-          @Component({\n-            template: `\n-          <svg>\n-            <svg:foreignObject>\n-              <xhtml:div>Hello</xhtml:div>\n-            </svg:foreignObject>\n-          </svg>\n-        `,\n-          })\n-          class MyComp {\n-          }\n+      const fixture = TestBed.createComponent(MyComp);\n+      fixture.detectChanges();\n+      expect(spy).not.toHaveBeenCalled();\n+    });\n \n-          @NgModule({declarations: [MyComp]})\n-          class MyModule {\n-          }\n+    it('should not log an error about unknown elements if element matches a directive', () => {\n+      @Component({\n+        selector: 'custom-el',\n+        template: '',\n+      })\n+      class CustomEl {\n+      }\n \n-          const spy = spyOn(console, 'error');\n-          TestBed.configureTestingModule({imports: [MyModule]});\n+      @Component({template: `<custom-el></custom-el>`})\n+      class MyComp {\n+      }\n \n-          const fixture = TestBed.createComponent(MyComp);\n-          fixture.detectChanges();\n-          expect(spy).not.toHaveBeenCalled();\n-        });\n+      const spy = spyOn(console, 'error');\n+      TestBed.configureTestingModule({declarations: [MyComp, CustomEl]});\n \n+      const fixture = TestBed.createComponent(MyComp);\n+      fixture.detectChanges();\n+      expect(spy).not.toHaveBeenCalled();\n+    });\n \n-    modifiedInIvy('unknown element error thrown instead of warning')\n-        .it('should not throw for HTML elements inside an SVG foreignObject', () => {\n-          @Component({\n-            template: `\n+    it('should not log an error for HTML elements inside an SVG foreignObject', () => {\n+      @Component({\n+        template: `\n           <svg>\n             <svg:foreignObject>\n               <xhtml:div>Hello</xhtml:div>\n             </svg:foreignObject>\n           </svg>\n         `,\n-          })\n-          class MyComp {\n-          }\n+      })\n+      class MyComp {\n+      }\n \n-          @NgModule({declarations: [MyComp]})\n-          class MyModule {\n-          }\n+      @NgModule({declarations: [MyComp]})\n+      class MyModule {\n+      }\n \n-          TestBed.configureTestingModule({imports: [MyModule]});\n+      const spy = spyOn(console, 'error');\n+      TestBed.configureTestingModule({imports: [MyModule]});\n \n-          expect(() => {\n-            const fixture = TestBed.createComponent(MyComp);\n-            fixture.detectChanges();\n-          }).not.toThrow();\n-        });\n+      const fixture = TestBed.createComponent(MyComp);\n+      fixture.detectChanges();\n+      expect(spy).not.toHaveBeenCalled();\n+    });\n   });\n \n   describe('createNgModuleRef function', () => {"
        },
        {
            "sha": "95153b004e2a952d123be6ed5e4e2d2b88f63b8d",
            "filename": "packages/core/test/acceptance/ngdevmode_debug_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fngdevmode_debug_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fngdevmode_debug_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fngdevmode_debug_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -13,7 +13,6 @@ import {getComponentLView} from '@angular/core/src/render3/util/discovery_utils'\n import {createNamedArrayType} from '@angular/core/src/util/named_array_type';\n import {ngDevModeResetPerfCounters} from '@angular/core/src/util/ng_dev_mode';\n import {TestBed} from '@angular/core/testing';\n-import {onlyInIvy} from '@angular/private/testing';\n \n class SupportsArraySubclassing extends Array {}\n \n@@ -28,7 +27,7 @@ const runtimeSupportsArraySubclassing =\n     (new (createNamedArrayType('SupportsArraySubclassing'))).constructor.name ===\n     'SupportsArraySubclassing';\n \n-onlyInIvy('Debug information exist in ivy only').describe('ngDevMode debug', () => {\n+describe('ngDevMode debug', () => {\n   describe('LViewDebug', () => {\n     beforeEach(ngDevModeResetPerfCounters);\n "
        },
        {
            "sha": "2b993b62aa27de029f561a5beb1ef6de1ac0f11f",
            "filename": "packages/core/test/acceptance/pipe_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fpipe_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fpipe_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fpipe_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -9,7 +9,6 @@\n import {ChangeDetectionStrategy, ChangeDetectorRef, Component, Directive, Inject, Injectable, InjectionToken, Input, NgModule, OnChanges, OnDestroy, Pipe, PipeTransform, SimpleChanges, ViewChild} from '@angular/core';\n import {TestBed} from '@angular/core/testing';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {ivyEnabled} from '@angular/private/testing';\n \n describe('pipe', () => {\n   @Pipe({name: 'countingPipe'})"
        },
        {
            "sha": "5ab678beba239feb6a0d2cea9e0067ce5e4f5a81",
            "filename": "packages/core/test/acceptance/profiler_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fprofiler_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fprofiler_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fprofiler_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -8,12 +8,11 @@\n \n import {ProfilerEvent, setProfiler} from '@angular/core/src/render3/profiler';\n import {TestBed} from '@angular/core/testing';\n-import {onlyInIvy} from '@angular/private/testing';\n \n import {AfterContentChecked, AfterContentInit, AfterViewChecked, AfterViewInit, Component, DoCheck, ErrorHandler, EventEmitter, Input, OnChanges, OnDestroy, OnInit, Output, ViewChild} from '../../src/core';\n \n \n-onlyInIvy('Ivy-specific functionality').describe('profiler', () => {\n+describe('profiler', () => {\n   class Profiler {\n     profile() {}\n   }"
        },
        {
            "sha": "f74c8e6d774097f7c505747b396cd8b93d33a352",
            "filename": "packages/core/test/acceptance/providers_spec.ts",
            "status": "modified",
            "additions": 203,
            "deletions": 246,
            "changes": 449,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fproviders_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fproviders_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fproviders_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -12,7 +12,6 @@ import {leaveView, specOnlyIsInstructionStateEmpty} from '@angular/core/src/rend\n import {inject, TestBed, waitForAsync} from '@angular/core/testing';\n import {By} from '@angular/platform-browser';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {modifiedInIvy, onlyInIvy} from '@angular/private/testing';\n \n describe('providers', () => {\n   describe('inheritance', () => {\n@@ -163,41 +162,39 @@ describe('providers', () => {\n       expect(logs).toEqual(['OnDestroy']);\n     });\n \n-    onlyInIvy('Destroy hook of useClass provider is invoked correctly')\n-        .it('should only call ngOnDestroy of value when providing via useClass', () => {\n-          const logs: string[] = [];\n+    it('should only call ngOnDestroy of value when providing via useClass', () => {\n+      const logs: string[] = [];\n \n-          @Injectable()\n-          class InjectableWithDestroyHookToken {\n-            ngOnDestroy() {\n-              logs.push('OnDestroy Token');\n-            }\n-          }\n+      @Injectable()\n+      class InjectableWithDestroyHookToken {\n+        ngOnDestroy() {\n+          logs.push('OnDestroy Token');\n+        }\n+      }\n \n-          @Injectable()\n-          class InjectableWithDestroyHookValue {\n-            ngOnDestroy() {\n-              logs.push('OnDestroy Value');\n-            }\n-          }\n+      @Injectable()\n+      class InjectableWithDestroyHookValue {\n+        ngOnDestroy() {\n+          logs.push('OnDestroy Value');\n+        }\n+      }\n \n-          @Component({\n-            template: '',\n-            providers: [\n-              {provide: InjectableWithDestroyHookToken, useClass: InjectableWithDestroyHookValue}\n-            ]\n-          })\n-          class App {\n-            constructor(foo: InjectableWithDestroyHookToken) {}\n-          }\n+      @Component({\n+        template: '',\n+        providers:\n+            [{provide: InjectableWithDestroyHookToken, useClass: InjectableWithDestroyHookValue}]\n+      })\n+      class App {\n+        constructor(foo: InjectableWithDestroyHookToken) {}\n+      }\n \n-          TestBed.configureTestingModule({declarations: [App]});\n-          const fixture = TestBed.createComponent(App);\n-          fixture.detectChanges();\n-          fixture.destroy();\n+      TestBed.configureTestingModule({declarations: [App]});\n+      const fixture = TestBed.createComponent(App);\n+      fixture.detectChanges();\n+      fixture.destroy();\n \n-          expect(logs).toEqual(['OnDestroy Value']);\n-        });\n+      expect(logs).toEqual(['OnDestroy Value']);\n+    });\n \n     it('should only call ngOnDestroy of value when providing via useExisting', () => {\n       const logs: string[] = [];\n@@ -286,228 +283,188 @@ describe('providers', () => {\n          expect(destroyContexts).toEqual([parentService, childService]);\n        });\n \n-    onlyInIvy('Destroy hook of useClass provider is invoked correctly')\n-        .it('should invoke ngOnDestroy with the correct context when providing a class provider multiple times on the same node',\n-            () => {\n-              const resolvedServices: (DestroyService|undefined)[] = [];\n-              const destroyContexts: (DestroyService|undefined)[] = [];\n-              const token = new InjectionToken<any>('token');\n-              let parentService: DestroyService|undefined;\n-              let childService: DestroyService|undefined;\n-\n-              @Injectable()\n-              class DestroyService {\n-                constructor() {\n-                  resolvedServices.push(this);\n-                }\n-                ngOnDestroy() {\n-                  destroyContexts.push(this);\n-                }\n-              }\n-\n-              @Directive(\n-                  {selector: '[dir-one]', providers: [{provide: token, useClass: DestroyService}]})\n-              class DirOne {\n-                constructor(@Inject(token) service: DestroyService) {\n-                  childService = service;\n-                }\n-              }\n-\n-              @Directive(\n-                  {selector: '[dir-two]', providers: [{provide: token, useClass: DestroyService}]})\n-              class DirTwo {\n-                constructor(@Inject(token) service: DestroyService) {\n-                  childService = service;\n-                }\n-              }\n-\n-              @Component({\n-                template: '<div dir-one dir-two></div>',\n-                providers: [{provide: token, useClass: DestroyService}]\n-              })\n-              class App {\n-                constructor(@Inject(token) service: DestroyService) {\n-                  parentService = service;\n-                }\n-              }\n-\n-              TestBed.configureTestingModule({declarations: [App, DirOne, DirTwo]});\n-              const fixture = TestBed.createComponent(App);\n-              fixture.detectChanges();\n-              fixture.destroy();\n-\n-              expect(parentService).toBeDefined();\n-              expect(childService).toBeDefined();\n-              expect(parentService).not.toBe(childService);\n-              expect(resolvedServices).toEqual([parentService, childService]);\n-              expect(destroyContexts).toEqual([parentService, childService]);\n-            });\n-\n-\n-    onlyInIvy('ngOnDestroy hooks for multi providers were not supported in ViewEngine')\n-        .describe('ngOnDestroy on multi providers', () => {\n-          it('should invoke ngOnDestroy on multi providers with the correct context', () => {\n-            const destroyCalls: any[] = [];\n-            const SERVICES = new InjectionToken<any>('SERVICES');\n-\n-            @Injectable()\n-            class DestroyService {\n-              ngOnDestroy() {\n-                destroyCalls.push(this);\n-              }\n-            }\n-\n-            @Injectable()\n-            class OtherDestroyService {\n-              ngOnDestroy() {\n-                destroyCalls.push(this);\n-              }\n-            }\n-\n-            @Component({\n-              template: '<div></div>',\n-              providers: [\n-                {provide: SERVICES, useClass: DestroyService, multi: true},\n-                {provide: SERVICES, useClass: OtherDestroyService, multi: true},\n-              ]\n-            })\n-            class App {\n-              constructor(@Inject(SERVICES) s: any) {}\n-            }\n-\n-            TestBed.configureTestingModule({declarations: [App]});\n-            const fixture = TestBed.createComponent(App);\n-            fixture.detectChanges();\n-            fixture.destroy();\n-\n-            expect(destroyCalls).toEqual([\n-              jasmine.any(DestroyService), jasmine.any(OtherDestroyService)\n-            ]);\n-          });\n-\n-          it('should invoke destroy hooks on multi providers with the correct context, if only some have a destroy hook',\n-             () => {\n-               const destroyCalls: any[] = [];\n-               const SERVICES = new InjectionToken<any>('SERVICES');\n-\n-               @Injectable()\n-               class Service1 {\n-               }\n-\n-               @Injectable()\n-               class Service2 {\n-                 ngOnDestroy() {\n-                   destroyCalls.push(this);\n-                 }\n-               }\n-\n-               @Injectable()\n-               class Service3 {\n-               }\n-\n-               @Injectable()\n-               class Service4 {\n-                 ngOnDestroy() {\n-                   destroyCalls.push(this);\n-                 }\n-               }\n-\n-               @Component({\n-                 template: '<div></div>',\n-                 providers: [\n-                   {provide: SERVICES, useClass: Service1, multi: true},\n-                   {provide: SERVICES, useClass: Service2, multi: true},\n-                   {provide: SERVICES, useClass: Service3, multi: true},\n-                   {provide: SERVICES, useClass: Service4, multi: true},\n-                 ]\n-               })\n-               class App {\n-                 constructor(@Inject(SERVICES) s: any) {}\n-               }\n-\n-               TestBed.configureTestingModule({declarations: [App]});\n-               const fixture = TestBed.createComponent(App);\n-               fixture.detectChanges();\n-               fixture.destroy();\n-\n-               expect(destroyCalls).toEqual([jasmine.any(Service2), jasmine.any(Service4)]);\n-             });\n-\n-          it('should not invoke ngOnDestroy on multi providers created via useFactory', () => {\n-            let destroyCalls = 0;\n-            const SERVICES = new InjectionToken<any>('SERVICES');\n-\n-            @Injectable()\n-            class DestroyService {\n-              ngOnDestroy() {\n-                destroyCalls++;\n-              }\n-            }\n-\n-            @Injectable()\n-            class OtherDestroyService {\n-              ngOnDestroy() {\n-                destroyCalls++;\n-              }\n-            }\n-\n-            @Component({\n-              template: '<div></div>',\n-              providers: [\n-                {provide: SERVICES, useFactory: () => new DestroyService(), multi: true},\n-                {provide: SERVICES, useFactory: () => new OtherDestroyService(), multi: true},\n-              ]\n-            })\n-            class App {\n-              constructor(@Inject(SERVICES) s: any) {}\n-            }\n-\n-            TestBed.configureTestingModule({declarations: [App]});\n-            const fixture = TestBed.createComponent(App);\n-            fixture.detectChanges();\n-            fixture.destroy();\n-\n-            expect(destroyCalls).toBe(0);\n-          });\n-        });\n-\n-    modifiedInIvy('ViewEngine did not support destroy hooks on multi providers')\n-        .it('should not invoke ngOnDestroy on multi providers', () => {\n-          let destroyCalls = 0;\n-          const SERVICES = new InjectionToken<any>('SERVICES');\n-\n-          @Injectable()\n-          class DestroyService {\n-            ngOnDestroy() {\n-              destroyCalls++;\n-            }\n+    it('should invoke ngOnDestroy with the correct context when providing a class provider multiple times on the same node',\n+       () => {\n+         const resolvedServices: (DestroyService|undefined)[] = [];\n+         const destroyContexts: (DestroyService|undefined)[] = [];\n+         const token = new InjectionToken<any>('token');\n+         let parentService: DestroyService|undefined;\n+         let childService: DestroyService|undefined;\n+\n+         @Injectable()\n+         class DestroyService {\n+           constructor() {\n+             resolvedServices.push(this);\n+           }\n+           ngOnDestroy() {\n+             destroyContexts.push(this);\n+           }\n+         }\n+\n+         @Directive(\n+             {selector: '[dir-one]', providers: [{provide: token, useClass: DestroyService}]})\n+         class DirOne {\n+           constructor(@Inject(token) service: DestroyService) {\n+             childService = service;\n+           }\n+         }\n+\n+         @Directive(\n+             {selector: '[dir-two]', providers: [{provide: token, useClass: DestroyService}]})\n+         class DirTwo {\n+           constructor(@Inject(token) service: DestroyService) {\n+             childService = service;\n+           }\n+         }\n+\n+         @Component({\n+           template: '<div dir-one dir-two></div>',\n+           providers: [{provide: token, useClass: DestroyService}]\n+         })\n+         class App {\n+           constructor(@Inject(token) service: DestroyService) {\n+             parentService = service;\n+           }\n+         }\n+\n+         TestBed.configureTestingModule({declarations: [App, DirOne, DirTwo]});\n+         const fixture = TestBed.createComponent(App);\n+         fixture.detectChanges();\n+         fixture.destroy();\n+\n+         expect(parentService).toBeDefined();\n+         expect(childService).toBeDefined();\n+         expect(parentService).not.toBe(childService);\n+         expect(resolvedServices).toEqual([parentService, childService]);\n+         expect(destroyContexts).toEqual([parentService, childService]);\n+       });\n+\n+\n+    describe('ngOnDestroy on multi providers', () => {\n+      it('should invoke ngOnDestroy on multi providers with the correct context', () => {\n+        const destroyCalls: any[] = [];\n+        const SERVICES = new InjectionToken<any>('SERVICES');\n+\n+        @Injectable()\n+        class DestroyService {\n+          ngOnDestroy() {\n+            destroyCalls.push(this);\n           }\n+        }\n \n-          @Injectable()\n-          class OtherDestroyService {\n-            ngOnDestroy() {\n-              destroyCalls++;\n-            }\n+        @Injectable()\n+        class OtherDestroyService {\n+          ngOnDestroy() {\n+            destroyCalls.push(this);\n           }\n+        }\n+\n+        @Component({\n+          template: '<div></div>',\n+          providers: [\n+            {provide: SERVICES, useClass: DestroyService, multi: true},\n+            {provide: SERVICES, useClass: OtherDestroyService, multi: true},\n+          ]\n+        })\n+        class App {\n+          constructor(@Inject(SERVICES) s: any) {}\n+        }\n+\n+        TestBed.configureTestingModule({declarations: [App]});\n+        const fixture = TestBed.createComponent(App);\n+        fixture.detectChanges();\n+        fixture.destroy();\n \n-          @Component({\n-            template: '<div></div>',\n-            providers: [\n-              {provide: SERVICES, useClass: DestroyService, multi: true},\n-              {provide: SERVICES, useClass: OtherDestroyService, multi: true},\n-            ]\n-          })\n-          class App {\n-            constructor(@Inject(SERVICES) s: any) {}\n+        expect(destroyCalls).toEqual([\n+          jasmine.any(DestroyService), jasmine.any(OtherDestroyService)\n+        ]);\n+      });\n+\n+      it('should invoke destroy hooks on multi providers with the correct context, if only some have a destroy hook',\n+         () => {\n+           const destroyCalls: any[] = [];\n+           const SERVICES = new InjectionToken<any>('SERVICES');\n+\n+           @Injectable()\n+           class Service1 {\n+           }\n+\n+           @Injectable()\n+           class Service2 {\n+             ngOnDestroy() {\n+               destroyCalls.push(this);\n+             }\n+           }\n+\n+           @Injectable()\n+           class Service3 {\n+           }\n+\n+           @Injectable()\n+           class Service4 {\n+             ngOnDestroy() {\n+               destroyCalls.push(this);\n+             }\n+           }\n+\n+           @Component({\n+             template: '<div></div>',\n+             providers: [\n+               {provide: SERVICES, useClass: Service1, multi: true},\n+               {provide: SERVICES, useClass: Service2, multi: true},\n+               {provide: SERVICES, useClass: Service3, multi: true},\n+               {provide: SERVICES, useClass: Service4, multi: true},\n+             ]\n+           })\n+           class App {\n+             constructor(@Inject(SERVICES) s: any) {}\n+           }\n+\n+           TestBed.configureTestingModule({declarations: [App]});\n+           const fixture = TestBed.createComponent(App);\n+           fixture.detectChanges();\n+           fixture.destroy();\n+\n+           expect(destroyCalls).toEqual([jasmine.any(Service2), jasmine.any(Service4)]);\n+         });\n+\n+      it('should not invoke ngOnDestroy on multi providers created via useFactory', () => {\n+        let destroyCalls = 0;\n+        const SERVICES = new InjectionToken<any>('SERVICES');\n+\n+        @Injectable()\n+        class DestroyService {\n+          ngOnDestroy() {\n+            destroyCalls++;\n+          }\n+        }\n+\n+        @Injectable()\n+        class OtherDestroyService {\n+          ngOnDestroy() {\n+            destroyCalls++;\n           }\n+        }\n+\n+        @Component({\n+          template: '<div></div>',\n+          providers: [\n+            {provide: SERVICES, useFactory: () => new DestroyService(), multi: true},\n+            {provide: SERVICES, useFactory: () => new OtherDestroyService(), multi: true},\n+          ]\n+        })\n+        class App {\n+          constructor(@Inject(SERVICES) s: any) {}\n+        }\n \n-          TestBed.configureTestingModule({declarations: [App]});\n-          const fixture = TestBed.createComponent(App);\n-          fixture.detectChanges();\n-          fixture.destroy();\n+        TestBed.configureTestingModule({declarations: [App]});\n+        const fixture = TestBed.createComponent(App);\n+        fixture.detectChanges();\n+        fixture.destroy();\n \n-          expect(destroyCalls).toBe(0);\n-        });\n+        expect(destroyCalls).toBe(0);\n+      });\n+    });\n \n     it('should call ngOnDestroy if host component is destroyed', () => {\n       const logs: string[] = [];"
        },
        {
            "sha": "d0cfb7837948bff9e36895038ba6198a154b20d6",
            "filename": "packages/core/test/acceptance/pure_function_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fpure_function_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fpure_function_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fpure_function_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -9,7 +9,6 @@ import {CommonModule} from '@angular/common';\n import {Component, Directive, Input, QueryList, ViewChild, ViewChildren} from '@angular/core';\n import {TestBed} from '@angular/core/testing';\n import {By} from '@angular/platform-browser';\n-import {onlyInIvy} from '@angular/private/testing';\n \n describe('components using pure function instructions internally', () => {\n   describe('with array literals', () => {\n@@ -476,7 +475,7 @@ describe('components using pure function instructions internally', () => {\n     });\n   });\n \n-  onlyInIvy('issue has only been fixed for Ivy').describe('identical literals', () => {\n+  describe('identical literals', () => {\n     @Directive({selector: '[dir]'})\n     class Dir {\n       @Input('dir') value: any;"
        },
        {
            "sha": "3a43c581929557d337a794e5e61ef42a798fb6df",
            "filename": "packages/core/test/acceptance/query_spec.ts",
            "status": "modified",
            "additions": 74,
            "deletions": 83,
            "changes": 157,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fquery_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fquery_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fquery_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -11,7 +11,6 @@ import {AfterViewInit, Component, ContentChild, ContentChildren, Directive, Elem\n import {TestBed} from '@angular/core/testing';\n import {By} from '@angular/platform-browser';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {onlyInIvy} from '@angular/private/testing';\n \n describe('query logic', () => {\n   beforeEach(() => {\n@@ -61,22 +60,21 @@ describe('query logic', () => {\n       expect(comp.viewChildren.first).toBeAnInstanceOf(ElementRef);\n     });\n \n-    onlyInIvy('multiple local refs are supported in Ivy')\n-        .it('should return ElementRefs when HTML elements are labeled and retrieved', () => {\n-          const template = `\n+    it('should return ElementRefs when HTML elements are labeled and retrieved', () => {\n+      const template = `\n               <div #viewQuery #first>A</div>\n               <div #viewQuery #second>B</div>\n             `;\n-          const fixture = initWithTemplate(QueryComp, template);\n-          const comp = fixture.componentInstance;\n+      const fixture = initWithTemplate(QueryComp, template);\n+      const comp = fixture.componentInstance;\n \n-          expect(comp.viewChild).toBeAnInstanceOf(ElementRef);\n-          expect(comp.viewChild.nativeElement).toBe(fixture.debugElement.children[0].nativeElement);\n+      expect(comp.viewChild).toBeAnInstanceOf(ElementRef);\n+      expect(comp.viewChild.nativeElement).toBe(fixture.debugElement.children[0].nativeElement);\n \n-          expect(comp.viewChildren.first).toBeAnInstanceOf(ElementRef);\n-          expect(comp.viewChildren.last).toBeAnInstanceOf(ElementRef);\n-          expect(comp.viewChildren.length).toBe(2);\n-        });\n+      expect(comp.viewChildren.first).toBeAnInstanceOf(ElementRef);\n+      expect(comp.viewChildren.last).toBeAnInstanceOf(ElementRef);\n+      expect(comp.viewChildren.length).toBe(2);\n+    });\n \n     it('should return TemplateRef when template is labeled and retrieved', () => {\n       const template = `\n@@ -100,22 +98,21 @@ describe('query logic', () => {\n       expect(instance.contentOptions.length).toBe(0);\n     });\n \n-    onlyInIvy('multiple local refs are supported in Ivy')\n-        .it('should return TemplateRefs when templates are labeled and retrieved', () => {\n-          const template = `\n+    it('should return TemplateRefs when templates are labeled and retrieved', () => {\n+      const template = `\n               <ng-template #viewQuery></ng-template>\n               <ng-template #viewQuery></ng-template>\n             `;\n-          const fixture = initWithTemplate(QueryComp, template);\n-          const comp = fixture.componentInstance;\n-          expect(comp.viewChild).toBeAnInstanceOf(TemplateRef);\n-          expect(comp.viewChild.elementRef.nativeElement)\n-              .toBe(fixture.debugElement.childNodes[0].nativeNode);\n+      const fixture = initWithTemplate(QueryComp, template);\n+      const comp = fixture.componentInstance;\n+      expect(comp.viewChild).toBeAnInstanceOf(TemplateRef);\n+      expect(comp.viewChild.elementRef.nativeElement)\n+          .toBe(fixture.debugElement.childNodes[0].nativeNode);\n \n-          expect(comp.viewChildren.first).toBeAnInstanceOf(TemplateRef);\n-          expect(comp.viewChildren.last).toBeAnInstanceOf(TemplateRef);\n-          expect(comp.viewChildren.length).toBe(2);\n-        });\n+      expect(comp.viewChildren.first).toBeAnInstanceOf(TemplateRef);\n+      expect(comp.viewChildren.last).toBeAnInstanceOf(TemplateRef);\n+      expect(comp.viewChildren.length).toBe(2);\n+    });\n \n     it('should set static view child queries in creation mode (and just in creation mode)', () => {\n       const fixture = TestBed.createComponent(StaticViewQueryComp);\n@@ -397,21 +394,20 @@ describe('query logic', () => {\n       expect(instance.contentOptions.length).toBe(2);\n     });\n \n-    onlyInIvy('multiple local refs are supported in Ivy')\n-        .it('should return Component instances when Components are labeled and retrieved', () => {\n-          const template = `\n+    it('should return Component instances when Components are labeled and retrieved', () => {\n+      const template = `\n                 <local-ref-query-component #q>\n                   <simple-comp-a #contentQuery></simple-comp-a>\n                   <simple-comp-b #contentQuery></simple-comp-b>\n                 </local-ref-query-component>\n               `;\n-          const fixture = initWithTemplate(AppComp, template);\n-          const comp = fixture.debugElement.children[0].references['q'];\n-          expect(comp.contentChild).toBeAnInstanceOf(SimpleCompA);\n-          expect(comp.contentChildren.first).toBeAnInstanceOf(SimpleCompA);\n-          expect(comp.contentChildren.last).toBeAnInstanceOf(SimpleCompB);\n-          expect(comp.contentChildren.length).toBe(2);\n-        });\n+      const fixture = initWithTemplate(AppComp, template);\n+      const comp = fixture.debugElement.children[0].references['q'];\n+      expect(comp.contentChild).toBeAnInstanceOf(SimpleCompA);\n+      expect(comp.contentChildren.first).toBeAnInstanceOf(SimpleCompA);\n+      expect(comp.contentChildren.last).toBeAnInstanceOf(SimpleCompB);\n+      expect(comp.contentChildren.length).toBe(2);\n+    });\n \n \n     it('should return ElementRef when HTML element is labeled and retrieved', () => {\n@@ -425,25 +421,24 @@ describe('query logic', () => {\n       expect(comp.contentChildren.first).toBeAnInstanceOf(ElementRef);\n     });\n \n-    onlyInIvy('multiple local refs are supported in Ivy')\n-        .it('should return ElementRefs when HTML elements are labeled and retrieved', () => {\n-          const template = `\n+    it('should return ElementRefs when HTML elements are labeled and retrieved', () => {\n+      const template = `\n               <local-ref-query-component #q>\n                 <div #contentQuery></div>\n                 <div #contentQuery></div>\n               </local-ref-query-component>\n             `;\n-          const fixture = initWithTemplate(AppComp, template);\n-          const firstChild = fixture.debugElement.children[0];\n-          const comp = firstChild.references['q'];\n+      const fixture = initWithTemplate(AppComp, template);\n+      const firstChild = fixture.debugElement.children[0];\n+      const comp = firstChild.references['q'];\n \n-          expect(comp.contentChild).toBeAnInstanceOf(ElementRef);\n-          expect(comp.contentChild.nativeElement).toBe(firstChild.children[0].nativeElement);\n+      expect(comp.contentChild).toBeAnInstanceOf(ElementRef);\n+      expect(comp.contentChild.nativeElement).toBe(firstChild.children[0].nativeElement);\n \n-          expect(comp.contentChildren.first).toBeAnInstanceOf(ElementRef);\n-          expect(comp.contentChildren.last).toBeAnInstanceOf(ElementRef);\n-          expect(comp.contentChildren.length).toBe(2);\n-        });\n+      expect(comp.contentChildren.first).toBeAnInstanceOf(ElementRef);\n+      expect(comp.contentChildren.last).toBeAnInstanceOf(ElementRef);\n+      expect(comp.contentChildren.length).toBe(2);\n+    });\n \n     it('should return TemplateRef when template is labeled and retrieved', () => {\n       const template = `\n@@ -456,26 +451,24 @@ describe('query logic', () => {\n       expect(comp.contentChildren.first).toBeAnInstanceOf(TemplateRef);\n     });\n \n-    onlyInIvy('multiple local refs are supported in Ivy')\n-        .it('should return TemplateRefs when templates are labeled and retrieved', () => {\n-          const template = `\n+    it('should return TemplateRefs when templates are labeled and retrieved', () => {\n+      const template = `\n               <local-ref-query-component #q>\n                 <ng-template #contentQuery></ng-template>\n                 <ng-template #contentQuery></ng-template>\n               </local-ref-query-component>\n             `;\n-          const fixture = initWithTemplate(AppComp, template);\n-          const firstChild = fixture.debugElement.children[0];\n-          const comp = firstChild.references['q'];\n+      const fixture = initWithTemplate(AppComp, template);\n+      const firstChild = fixture.debugElement.children[0];\n+      const comp = firstChild.references['q'];\n \n-          expect(comp.contentChild).toBeAnInstanceOf(TemplateRef);\n-          expect(comp.contentChild.elementRef.nativeElement)\n-              .toBe(firstChild.childNodes[0].nativeNode);\n+      expect(comp.contentChild).toBeAnInstanceOf(TemplateRef);\n+      expect(comp.contentChild.elementRef.nativeElement).toBe(firstChild.childNodes[0].nativeNode);\n \n-          expect(comp.contentChildren.first).toBeAnInstanceOf(TemplateRef);\n-          expect(comp.contentChildren.last).toBeAnInstanceOf(TemplateRef);\n-          expect(comp.contentChildren.length).toBe(2);\n-        });\n+      expect(comp.contentChildren.first).toBeAnInstanceOf(TemplateRef);\n+      expect(comp.contentChildren.last).toBeAnInstanceOf(TemplateRef);\n+      expect(comp.contentChildren.length).toBe(2);\n+    });\n \n     it('should set static content child queries in creation mode (and just in creation mode)',\n        () => {\n@@ -1063,21 +1056,19 @@ describe('query logic', () => {\n       expect(isElementRefLike(cmptWithQuery.localRefsTargets.first)).toBeTruthy();\n     });\n \n-    onlyInIvy(\n-        'VE uses injectors hierarchy to determine if node matches, ivy uses elements as written in a template')\n-        .it('should match directives on <ng-container> when crossing nested <ng-container>', () => {\n-          @Directive({selector: '[targetDir]'})\n-          class TargetDir {\n-          }\n-\n-          @Component({selector: 'needs-target', template: ``})\n-          class NeedsTarget {\n-            @ContentChildren(TargetDir) targets!: QueryList<HTMLElement>;\n-          }\n-\n-          @Component({\n-            selector: 'test-cmpt',\n-            template: `\n+    it('should match directives on <ng-container> when crossing nested <ng-container>', () => {\n+      @Directive({selector: '[targetDir]'})\n+      class TargetDir {\n+      }\n+\n+      @Component({selector: 'needs-target', template: ``})\n+      class NeedsTarget {\n+        @ContentChildren(TargetDir) targets!: QueryList<HTMLElement>;\n+      }\n+\n+      @Component({\n+        selector: 'test-cmpt',\n+        template: `\n           <needs-target>\n             <ng-container>\n               <ng-container targetDir>\n@@ -1088,17 +1079,17 @@ describe('query logic', () => {\n             </ng-container>\n           </needs-target>\n         `,\n-          })\n-          class TestCmpt {\n-          }\n+      })\n+      class TestCmpt {\n+      }\n \n-          TestBed.configureTestingModule({declarations: [TestCmpt, NeedsTarget, TargetDir]});\n-          const fixture = TestBed.createComponent(TestCmpt);\n-          const cmptWithQuery = fixture.debugElement.children[0].injector.get(NeedsTarget);\n+      TestBed.configureTestingModule({declarations: [TestCmpt, NeedsTarget, TargetDir]});\n+      const fixture = TestBed.createComponent(TestCmpt);\n+      const cmptWithQuery = fixture.debugElement.children[0].injector.get(NeedsTarget);\n \n-          fixture.detectChanges();\n-          expect(cmptWithQuery.targets.length).toBe(3);\n-        });\n+      fixture.detectChanges();\n+      expect(cmptWithQuery.targets.length).toBe(3);\n+    });\n   });\n \n "
        },
        {
            "sha": "ec29297b0d0a5d3fde1f8f82ec7bee1954d32849",
            "filename": "packages/core/test/acceptance/renderer_factory_spec.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 11,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Frenderer_factory_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Frenderer_factory_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Frenderer_factory_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -18,7 +18,6 @@ import {EventManager, ɵDomSharedStylesHost} from '@angular/platform-browser';\n import {ɵAnimationRendererFactory} from '@angular/platform-browser/animations';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n import {ServerRendererFactory2} from '@angular/platform-server/src/server_renderer';\n-import {onlyInIvy} from '@angular/private/testing';\n \n describe('renderer factory lifecycle', () => {\n   let logs: string[] = [];\n@@ -79,7 +78,7 @@ describe('renderer factory lifecycle', () => {\n     });\n   });\n \n-  onlyInIvy('FW-1320: Ivy creates renderer twice.').it('should work with a component', () => {\n+  it('should work with a component', () => {\n     const fixture = TestBed.createComponent(SomeComponent);\n     fixture.detectChanges();\n     expect(logs).toEqual(\n@@ -89,14 +88,13 @@ describe('renderer factory lifecycle', () => {\n     expect(logs).toEqual(['begin', 'some_component update', 'end']);\n   });\n \n-  onlyInIvy('FW-1320: Ivy creates renderer twice.')\n-      .it('should work with a component which throws', () => {\n-        expect(() => {\n-          const fixture = TestBed.createComponent(SomeComponentWhichThrows);\n-          fixture.detectChanges();\n-        }).toThrow();\n-        expect(logs).toEqual(['create', 'create', 'begin', 'end']);\n-      });\n+  it('should work with a component which throws', () => {\n+    expect(() => {\n+      const fixture = TestBed.createComponent(SomeComponentWhichThrows);\n+      fixture.detectChanges();\n+    }).toThrow();\n+    expect(logs).toEqual(['create', 'create', 'begin', 'end']);\n+  });\n });\n \n describe('animation renderer factory', () => {\n@@ -255,7 +253,7 @@ describe('custom renderer', () => {\n   });\n });\n \n-onlyInIvy('access global ngDevMode').describe('Renderer2 destruction hooks', () => {\n+describe('Renderer2 destruction hooks', () => {\n   @Component({\n     selector: 'some-component',\n     template: `"
        },
        {
            "sha": "121bed42f2b70c86ce8703b19967c872bf8ff709",
            "filename": "packages/core/test/acceptance/styling_spec.ts",
            "status": "modified",
            "additions": 1356,
            "deletions": 1558,
            "changes": 2914,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fstyling_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fstyling_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fstyling_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c"
        },
        {
            "sha": "75010d6b0a8d90d8506719ff935494702723a863",
            "filename": "packages/core/test/acceptance/template_ref_spec.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 38,
            "changes": 53,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Ftemplate_ref_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Ftemplate_ref_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Ftemplate_ref_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -9,7 +9,6 @@\n import {Component, ComponentFactoryResolver, Injector, NgModule, TemplateRef, ViewChild, ViewContainerRef} from '@angular/core';\n import {TestBed} from '@angular/core/testing';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {ivyEnabled, onlyInIvy} from '@angular/private/testing';\n \n describe('TemplateRef', () => {\n   describe('rootNodes', () => {\n@@ -40,18 +39,10 @@ describe('TemplateRef', () => {\n       expect(rootNodes.length).toBe(3);\n     });\n \n-    /**\n-     * This is different as compared to the view engine implementation which returns a comment node\n-     * in this case:\n-     * https://stackblitz.com/edit/angular-uiqry6?file=src/app/app.component.ts\n-     *\n-     * Returning a comment node for a template ref with no nodes is wrong is fixed in Ivy.\n-     */\n-    onlyInIvy('Fixed: Ivy no longer adds a comment node in this case.')\n-        .it('should return an empty array for embedded view with no nodes', () => {\n-          const rootNodes = getRootNodes('<ng-template #templateRef></ng-template>');\n-          expect(rootNodes.length).toBe(0);\n-        });\n+    it('should return an empty array for embedded view with no nodes', () => {\n+      const rootNodes = getRootNodes('<ng-template #templateRef></ng-template>');\n+      expect(rootNodes.length).toBe(0);\n+    });\n \n     it('should include projected nodes and their children', () => {\n       @Component({\n@@ -65,7 +56,7 @@ describe('TemplateRef', () => {\n         exportAs: 'menuContent'\n       })\n       class MenuContent {\n-        @ViewChild(TemplateRef, {static: true}) template !: TemplateRef<any>;\n+        @ViewChild(TemplateRef, {static: true}) template!: TemplateRef<any>;\n       }\n \n       @Component({\n@@ -168,33 +159,25 @@ describe('TemplateRef', () => {\n           </ng-template>\n         `);\n \n-      if (ivyEnabled) {\n-        expect(rootNodes.length).toBe(4);\n-        expect(rootNodes[0].nodeType).toBe(Node.COMMENT_NODE);  // ng-container\n-        expect(rootNodes[1].nodeType).toBe(Node.TEXT_NODE);     // \"Updated \" text\n-        expect(rootNodes[2].nodeType).toBe(Node.COMMENT_NODE);  // ICU container\n-        expect(rootNodes[3].nodeType).toBe(Node.TEXT_NODE);     // \"one minute ago\" text\n-      } else {\n-        // ViewEngine seems to produce very different DOM structure as compared to ivy\n-        // when it comes to ICU containers - this needs more investigation / fix.\n-        expect(rootNodes.length).toBe(7);\n-      }\n+      expect(rootNodes.length).toBe(4);\n+      expect(rootNodes[0].nodeType).toBe(Node.COMMENT_NODE);  // ng-container\n+      expect(rootNodes[1].nodeType).toBe(Node.TEXT_NODE);     // \"Updated \" text\n+      expect(rootNodes[2].nodeType).toBe(Node.COMMENT_NODE);  // ICU container\n+      expect(rootNodes[3].nodeType).toBe(Node.TEXT_NODE);     // \"one minute ago\" text\n     });\n \n     it('should return an empty array for an embedded view with projection and no projectable nodes',\n        () => {\n          const rootNodes =\n              getRootNodes(`<ng-template #templateRef><ng-content></ng-content></ng-template>`);\n-         // VE will, incorrectly, return an additional comment node in this case\n-         expect(rootNodes.length).toBe(ivyEnabled ? 0 : 1);\n+         expect(rootNodes.length).toBe(0);\n        });\n \n     it('should return an empty array for an embedded view with multiple projections and no projectable nodes',\n        () => {\n          const rootNodes = getRootNodes(\n              `<ng-template #templateRef><ng-content></ng-content><ng-content select=\"foo\"></ng-content></ng-template>`);\n-         // VE will, incorrectly, return an additional comment node in this case\n-         expect(rootNodes.length).toBe(ivyEnabled ? 0 : 1);\n+         expect(rootNodes.length).toBe(0);\n        });\n \n     describe('projectable nodes provided to a dynamically created component', () => {\n@@ -234,9 +217,7 @@ describe('TemplateRef', () => {\n         const projectableNodes = [[document.createTextNode('textNode')]];\n         const cmptRef = dynamicCmptFactory.create(Injector.NULL, projectableNodes);\n         const viewRef = cmptRef.instance.templateRef.createEmbeddedView({});\n-\n-        // VE will, incorrectly, return an additional comment node in this case\n-        expect(viewRef.rootNodes.length).toBe(ivyEnabled ? 1 : 2);\n+        expect(viewRef.rootNodes.length).toBe(1);\n       });\n \n       it('should return an empty collection when no projectable nodes were provided', () => {\n@@ -250,9 +231,7 @@ describe('TemplateRef', () => {\n         // There are slots but projectable nodes were not provided - nothing should be returned\n         const cmptRef = dynamicCmptFactory.create(Injector.NULL, []);\n         const viewRef = cmptRef.instance.templateRef.createEmbeddedView({});\n-\n-        // VE will, incorrectly, return an additional comment node in this case\n-        expect(viewRef.rootNodes.length).toBe(ivyEnabled ? 0 : 1);\n+        expect(viewRef.rootNodes.length).toBe(0);\n       });\n \n       it('should return an empty collection when projectable nodes were provided but there are no slots',\n@@ -267,9 +246,7 @@ describe('TemplateRef', () => {\n            const projectableNodes = [[document.createTextNode('textNode')]];\n            const cmptRef = dynamicCmptFactory.create(Injector.NULL, projectableNodes);\n            const viewRef = cmptRef.instance.templateRef.createEmbeddedView({});\n-\n-           // VE will, incorrectly, return an additional comment node in this case\n-           expect(viewRef.rootNodes.length).toBe(ivyEnabled ? 0 : 1);\n+           expect(viewRef.rootNodes.length).toBe(0);\n          });\n     });\n   });"
        },
        {
            "sha": "1baae1ea6bfcd82cd9227a7131b73d4a05acdd3f",
            "filename": "packages/core/test/acceptance/view_container_ref_spec.ts",
            "status": "modified",
            "additions": 110,
            "deletions": 184,
            "changes": 294,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fview_container_ref_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fview_container_ref_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fview_container_ref_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -15,7 +15,6 @@ import {ComponentFixture, TestBed, TestComponentRenderer} from '@angular/core/te\n import {clearTranslations, loadTranslations} from '@angular/localize';\n import {By, DomSanitizer, ɵDomRendererFactory2 as DomRendererFactory2} from '@angular/platform-browser';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {ivyEnabled, onlyInIvy} from '@angular/private/testing';\n \n describe('ViewContainerRef', () => {\n   /**\n@@ -111,17 +110,9 @@ describe('ViewContainerRef', () => {\n \n       expect(testParent.textContent).toBe('hello');\n       expect(testParent.childNodes.length).toBe(2);\n-\n-      // With Ivy, views are inserted before the container comment marker.\n-      if (ivyEnabled) {\n-        expect(testParent.childNodes[0].nodeType).toBe(Node.ELEMENT_NODE);\n-        expect(testParent.childNodes[0].textContent).toBe('hello');\n-        expect(testParent.childNodes[1].nodeType).toBe(Node.COMMENT_NODE);\n-      } else {\n-        expect(testParent.childNodes[0].nodeType).toBe(Node.COMMENT_NODE);\n-        expect(testParent.childNodes[1].nodeType).toBe(Node.ELEMENT_NODE);\n-        expect(testParent.childNodes[1].textContent).toBe('hello');\n-      }\n+      expect(testParent.childNodes[0].nodeType).toBe(Node.ELEMENT_NODE);\n+      expect(testParent.childNodes[0].textContent).toBe('hello');\n+      expect(testParent.childNodes[1].nodeType).toBe(Node.COMMENT_NODE);\n     });\n \n     it('should support attribute selectors in dynamically created components', () => {\n@@ -233,14 +224,8 @@ describe('ViewContainerRef', () => {\n \n           expect(fixture.nativeElement.querySelector('svg').namespaceURI)\n               .toEqual('http://www.w3.org/2000/svg');\n-\n-          // View Engine doesn't set MathML namespace, since it's not present in the list of\n-          // known namespaces here:\n-          // https://github.com/angular/angular/blob/master/packages/platform-browser/src/dom/dom_renderer.ts#L14\n-          if (ivyEnabled) {\n-            expect(fixture.nativeElement.querySelector('math').namespaceURI)\n-                .toEqual('http://www.w3.org/1998/MathML/');\n-          }\n+          expect(fixture.nativeElement.querySelector('math').namespaceURI)\n+              .toEqual('http://www.w3.org/1998/MathML/');\n         });\n       }\n \n@@ -310,36 +295,13 @@ describe('ViewContainerRef', () => {\n       // also passing element selector as an argument\n       const factoryHostElement = fixture.nativeElement.querySelector('#factory');\n \n-      if (ivyEnabled) {\n-        // In Ivy, if selector is passed when component is created, matched host node (found using\n-        // this selector) retains all attrs/classes and selector-based attrs/classes should *not* be\n-        // added\n-\n-        //  Verify original attrs and classes are still present\n-        expect(factoryHostElement.classList.contains('class-original')).toBe(true);\n-        expect(factoryHostElement.getAttribute('attr-a')).toBe('a-original');\n-\n-        // Make sure selector-based attrs and classes were not added to the host element\n-        expect(factoryHostElement.classList.contains('class-a')).toBe(false);\n-        expect(factoryHostElement.getAttribute('attr-c')).toBe(null);\n+      //  Verify original attrs and classes are still present\n+      expect(factoryHostElement.classList.contains('class-original')).toBe(true);\n+      expect(factoryHostElement.getAttribute('attr-a')).toBe('a-original');\n \n-      } else {\n-        // In View Engine, selector-based attrs/classes are *always* added to the host element\n-\n-        expect(factoryHostElement.classList.contains('class-a')).toBe(true);\n-        // `class-b` should not be present, since it's wrapped in `:not()` selector\n-        expect(factoryHostElement.classList.contains('class-b')).toBe(false);\n-        expect(factoryHostElement.classList.contains('class-c')).toBe(true);\n-        // Make sure classes are overridden with ones used in component selector\n-        expect(factoryHostElement.classList.contains('class-original')).toBe(false);\n-\n-        // Note: `attr-a` attr is also present on host element, but we update the value with the\n-        // value from component selector (i.e. using `[attr-a=a]`)\n-        expect(factoryHostElement.getAttribute('attr-a')).toBe('a');\n-        // `attr-b` should not be present, since it's wrapped in `:not()` selector\n-        expect(factoryHostElement.getAttribute('attr-b')).toBe(null);\n-        expect(factoryHostElement.getAttribute('attr-c')).toBe('');\n-      }\n+      // Make sure selector-based attrs and classes were not added to the host element\n+      expect(factoryHostElement.classList.contains('class-a')).toBe(false);\n+      expect(factoryHostElement.getAttribute('attr-c')).toBe(null);\n     });\n   });\n \n@@ -379,13 +341,7 @@ describe('ViewContainerRef', () => {\n       viewContainerRef.insert(ref0, 2);\n       fixture.detectChanges();\n \n-      // In Ivy, we correctly move the \"0\" view to index 2. VE\n-      // has a bug that duplicates the view, so it's at index 1.\n-      if (ivyEnabled) {\n-        expect(fixture.nativeElement.textContent).toEqual('120');\n-      } else {\n-        expect(fixture.nativeElement.textContent).toEqual('102');\n-      }\n+      expect(fixture.nativeElement.textContent).toEqual('120');\n     });\n \n     it('should do nothing when a view is re-inserted / moved at the same index', () => {\n@@ -435,33 +391,27 @@ describe('ViewContainerRef', () => {\n       // move the existing embedded view into the c2 container\n       cmpt.c2.insert(viewRef);\n       expect(native.textContent.trim()).toEqual('before||middle|content|after');\n-\n-      // VE has a bug where a view moved between containers is not correctly detached from the\n-      // previous container. Check https://github.com/angular/angular/issues/20824 for more details.\n-      if (ivyEnabled) {\n-        expect(cmpt.c1.indexOf(viewRef)).toBe(-1);\n-      }\n+      expect(cmpt.c1.indexOf(viewRef)).toBe(-1);\n       expect(cmpt.c2.indexOf(viewRef)).toBe(0);\n     });\n   });\n \n   describe('move', () => {\n-    onlyInIvy('Ivy will insert detached views in move')\n-        .it('should insert detached views in move()', () => {\n-          const fixture = TestBed.createComponent(ViewContainerRefApp);\n-          fixture.detectChanges();\n+    it('should insert detached views in move()', () => {\n+      const fixture = TestBed.createComponent(ViewContainerRefApp);\n+      fixture.detectChanges();\n \n-          const templates = fixture.componentInstance.vcrComp.templates.toArray();\n-          const viewContainerRef = fixture.componentInstance.vcrComp.vcr;\n-          const ref0 = viewContainerRef.createEmbeddedView(templates[0]);\n-          const ref1 = viewContainerRef.createEmbeddedView(templates[1]);\n-          const ref2 = viewContainerRef.createEmbeddedView(templates[2]);\n+      const templates = fixture.componentInstance.vcrComp.templates.toArray();\n+      const viewContainerRef = fixture.componentInstance.vcrComp.vcr;\n+      const ref0 = viewContainerRef.createEmbeddedView(templates[0]);\n+      const ref1 = viewContainerRef.createEmbeddedView(templates[1]);\n+      const ref2 = viewContainerRef.createEmbeddedView(templates[2]);\n \n-          viewContainerRef.detach(0);\n-          viewContainerRef.move(ref0, 0);\n+      viewContainerRef.detach(0);\n+      viewContainerRef.move(ref0, 0);\n \n-          expect(fixture.nativeElement.textContent).toEqual('012');\n-        });\n+      expect(fixture.nativeElement.textContent).toEqual('012');\n+    });\n   });\n \n   it('should not throw when calling remove() on an empty container', () => {\n@@ -582,15 +532,14 @@ describe('ViewContainerRef', () => {\n       </ng-template>`);\n     });\n \n-    onlyInIvy('Ivy i18n logic')\n-        .it('when ViewContainerRef is on an element inside a ng-container with i18n', () => {\n-          loadTranslations({\n-            [computeMsgId('Bar')]: 'o',\n-            [computeMsgId(\n-                '{$START_TAG_BEFORE}{$CLOSE_TAG_BEFORE}{$START_TAG_DIV}{$START_TAG_INSIDE}{$CLOSE_TAG_INSIDE}{$CLOSE_TAG_DIV}{$START_TAG_AFTER}{$CLOSE_TAG_AFTER}')]:\n-                'F{$START_TAG_DIV}{$CLOSE_TAG_DIV}o',\n-          });\n-          executeTest(`\n+    it('when ViewContainerRef is on an element inside a ng-container with i18n', () => {\n+      loadTranslations({\n+        [computeMsgId('Bar')]: 'o',\n+        [computeMsgId(\n+            '{$START_TAG_BEFORE}{$CLOSE_TAG_BEFORE}{$START_TAG_DIV}{$START_TAG_INSIDE}{$CLOSE_TAG_INSIDE}{$CLOSE_TAG_DIV}{$START_TAG_AFTER}{$CLOSE_TAG_AFTER}')]:\n+            'F{$START_TAG_DIV}{$CLOSE_TAG_DIV}o',\n+      });\n+      executeTest(`\n       <ng-template #foo>\n         <span i18n>Bar</span>\n       </ng-template>\n@@ -606,18 +555,17 @@ describe('ViewContainerRef', () => {\n         </ng-container>\n         <after></after>\n       </ng-template>`);\n-        });\n+    });\n \n-    onlyInIvy('Ivy i18n logic')\n-        .it('when ViewContainerRef is on an element, and i18n is on the parent ViewContainerRef', () => {\n-          loadTranslations({\n-            [computeMsgId(\n-                '{$START_TAG_BEFORE}{$CLOSE_TAG_BEFORE}{$START_TAG_DIV}{$START_TAG_IN}{$CLOSE_TAG_IN}{$CLOSE_TAG_DIV}{$START_TAG_AFTER}{$CLOSE_TAG_AFTER}')]:\n-                '{$START_TAG_DIV}{$CLOSE_TAG_DIV}{$START_TAG_BEFORE}oo{$CLOSE_TAG_BEFORE}',\n-            [computeMsgId('{VAR_SELECT, select, other {|{INTERPOLATION}|}}')]:\n-                '{VAR_SELECT, select, other {|{INTERPOLATION}|}}',\n-          });\n-          executeTest(`\n+    it('when ViewContainerRef is on an element, and i18n is on the parent ViewContainerRef', () => {\n+      loadTranslations({\n+        [computeMsgId(\n+            '{$START_TAG_BEFORE}{$CLOSE_TAG_BEFORE}{$START_TAG_DIV}{$START_TAG_IN}{$CLOSE_TAG_IN}{$CLOSE_TAG_DIV}{$START_TAG_AFTER}{$CLOSE_TAG_AFTER}')]:\n+            '{$START_TAG_DIV}{$CLOSE_TAG_DIV}{$START_TAG_BEFORE}oo{$CLOSE_TAG_BEFORE}',\n+        [computeMsgId('{VAR_SELECT, select, other {|{INTERPOLATION}|}}')]:\n+            '{VAR_SELECT, select, other {|{INTERPOLATION}|}}',\n+      });\n+      executeTest(`\n       <ng-template #foo>\n         <span>F</span>\n       </ng-template>\n@@ -629,7 +577,7 @@ describe('ViewContainerRef', () => {\n         </div>\n         <after></after>\n       </ng-template>`);\n-        });\n+    });\n   });\n \n   describe('length', () => {\n@@ -752,9 +700,8 @@ describe('ViewContainerRef', () => {\n       fixture.detectChanges();\n       expect(getElementHtml(fixture.nativeElement)).toEqual('<p vcref=\"\"></p>B**A**C');\n \n-      // Invalid indices when detaching throws an exception in Ivy: FW-1330.\n-      ivyEnabled && expect(() => vcRefDir.vcref.move(viewRef!, -1)).toThrow();\n-      ivyEnabled && expect(() => vcRefDir.vcref.move(viewRef!, 42)).toThrow();\n+      expect(() => vcRefDir.vcref.move(viewRef!, -1)).toThrow();\n+      expect(() => vcRefDir.vcref.move(viewRef!, 42)).toThrow();\n     });\n   });\n \n@@ -778,7 +725,7 @@ describe('ViewContainerRef', () => {\n       expect(vcRefDir.vcref.element.nativeElement.nodeType).toBe(Node.COMMENT_NODE);\n       // In Ivy, the comment for the view container ref has text that implies\n       // that the comment is a placeholder for a container.\n-      ivyEnabled && expect(vcRefDir.vcref.element.nativeElement.textContent).toEqual('container');\n+      expect(vcRefDir.vcref.element.nativeElement.textContent).toEqual('container');\n \n       expect(vcRefDir.vcref.injector.get(ElementRef).nativeElement.textContent);\n       expect(getElementHtml(vcRefDir.vcref.parentInjector.get(ElementRef).nativeElement))\n@@ -790,9 +737,9 @@ describe('ViewContainerRef', () => {\n     beforeEach(() => {\n       TestBed.configureTestingModule({declarations: [EmbeddedViewInsertionComp, VCRefDirective]});\n \n-      // Tests depend on perf counters when running with Ivy. In order to have\n-      // clean perf counters at the beginning of a test, we reset those here.\n-      ivyEnabled && ngDevModeResetPerfCounters();\n+      // Tests depend on perf counters. In order to have clean perf counters at the beginning of a\n+      // test, we reset those here.\n+      ngDevModeResetPerfCounters();\n     });\n \n     it('should detach the right embedded view when an index is specified', () => {\n@@ -819,10 +766,9 @@ describe('ViewContainerRef', () => {\n       expect(getElementHtml(fixture.nativeElement)).toEqual('<p vcref=\"\"></p>BCE');\n       expect(viewA.destroyed).toBeFalsy();\n \n-      // Invalid indices when detaching throws an exception in Ivy: FW-1330.\n-      ivyEnabled && expect(() => vcRefDir.vcref.detach(-1)).toThrow();\n-      ivyEnabled && expect(() => vcRefDir.vcref.detach(42)).toThrow();\n-      ivyEnabled && expect(ngDevMode!.rendererDestroyNode).toBe(0);\n+      expect(() => vcRefDir.vcref.detach(-1)).toThrow();\n+      expect(() => vcRefDir.vcref.detach(42)).toThrow();\n+      expect(ngDevMode!.rendererDestroyNode).toBe(0);\n     });\n \n     it('should detach the last embedded view when no index is specified', () => {\n@@ -843,7 +789,7 @@ describe('ViewContainerRef', () => {\n       fixture.detectChanges();\n       expect(getElementHtml(fixture.nativeElement)).toEqual('<p vcref=\"\"></p>ABCD');\n       expect(viewE.destroyed).toBeFalsy();\n-      ivyEnabled && expect(ngDevMode!.rendererDestroyNode).toBe(0);\n+      expect(ngDevMode!.rendererDestroyNode).toBe(0);\n     });\n   });\n \n@@ -860,9 +806,9 @@ describe('ViewContainerRef', () => {\n         return renderer;\n       };\n \n-      // Tests depend on perf counters when running with Ivy. In order to have\n-      // clean perf counters at the beginning of a test, we reset those here.\n-      ivyEnabled && ngDevModeResetPerfCounters();\n+      // Tests depend on perf counters. In order to have clean perf counters at the beginning of a\n+      // test, we reset those here.\n+      ngDevModeResetPerfCounters();\n     });\n \n     it('should remove the right embedded view when an index is specified', () => {\n@@ -889,10 +835,9 @@ describe('ViewContainerRef', () => {\n       expect(getElementHtml(fixture.nativeElement)).toEqual('<p vcref=\"\"></p>BCE');\n       expect(viewA.destroyed).toBeTruthy();\n \n-      // Invalid indices when detaching throws an exception in Ivy: FW-1330.\n-      ivyEnabled && expect(() => vcRefDir.vcref.remove(-1)).toThrow();\n-      ivyEnabled && expect(() => vcRefDir.vcref.remove(42)).toThrow();\n-      ivyEnabled && expect(ngDevMode!.rendererDestroyNode).toBe(2);\n+      expect(() => vcRefDir.vcref.remove(-1)).toThrow();\n+      expect(() => vcRefDir.vcref.remove(42)).toThrow();\n+      expect(ngDevMode!.rendererDestroyNode).toBe(2);\n     });\n \n     it('should remove the last embedded view when no index is specified', () => {\n@@ -913,7 +858,7 @@ describe('ViewContainerRef', () => {\n       fixture.detectChanges();\n       expect(getElementHtml(fixture.nativeElement)).toEqual('<p vcref=\"\"></p>ABCD');\n       expect(viewE.destroyed).toBeTruthy();\n-      ivyEnabled && expect(ngDevMode!.rendererDestroyNode).toBe(1);\n+      expect(ngDevMode!.rendererDestroyNode).toBe(1);\n     });\n \n     it('should throw when trying to insert a removed or destroyed view', () => {\n@@ -965,7 +910,7 @@ describe('ViewContainerRef', () => {\n \n       @Directive({selector: '[template]'})\n       class TemplateDirective<C> implements OnInit, OnDestroy {\n-        @Input() template !: TemplateRef<C>;\n+        @Input() template!: TemplateRef<C>;\n         ref!: EmbeddedViewRef<C>;\n \n         constructor(private readonly host: AppComponent) {}\n@@ -1030,9 +975,8 @@ describe('ViewContainerRef', () => {\n       expect(getElementHtml(fixture.nativeElement))\n           .toEqual('<header vcref=\"\"></header>YABC<footer></footer>');\n \n-      // Invalid indices when detaching throws an exception in Ivy: FW-1330.\n-      ivyEnabled && expect(() => vcRef.createView('Z', -1)).toThrow();\n-      ivyEnabled && expect(() => vcRef.createView('Z', 5)).toThrow();\n+      expect(() => vcRef.createView('Z', -1)).toThrow();\n+      expect(() => vcRef.createView('Z', 5)).toThrow();\n     });\n \n     it('should work on components', () => {\n@@ -1076,9 +1020,8 @@ describe('ViewContainerRef', () => {\n       expect(getElementHtml(fixture.nativeElement))\n           .toEqual('<header-cmp vcref=\"\"></header-cmp>YABC<footer></footer>');\n \n-      // Invalid indices when detaching throws an exception in Ivy: FW-1330.\n-      ivyEnabled && expect(() => vcRef.createView('Z', -1)).toThrow();\n-      ivyEnabled && expect(() => vcRef.createView('Z', 5)).toThrow();\n+      expect(() => vcRef.createView('Z', -1)).toThrow();\n+      expect(() => vcRef.createView('Z', 5)).toThrow();\n     });\n \n     it('should work with multiple instances of view container refs', () => {\n@@ -1138,10 +1081,8 @@ describe('ViewContainerRef', () => {\n       vcRef.createView('Y', 0);\n       fixture.detectChanges();\n       expect(getElementHtml(fixture.nativeElement)).toEqual('YABC<footer></footer>');\n-\n-      // Invalid indices when detaching throws an exception in Ivy: FW-1330.\n-      ivyEnabled && expect(() => vcRef!.createView('Z', -1)).toThrow();\n-      ivyEnabled && expect(() => vcRef!.createView('Z', 5)).toThrow();\n+      expect(() => vcRef!.createView('Z', -1)).toThrow();\n+      expect(() => vcRef!.createView('Z', 5)).toThrow();\n     });\n \n     it('should apply directives and pipes of the host view to the TemplateRef', () => {\n@@ -1556,14 +1497,8 @@ describe('ViewContainerRef', () => {\n       });\n \n       it('should be able to create a component when Type is provided', () => {\n-        if (ivyEnabled) {\n-          fixture.componentInstance.viewContainerRef.createComponent(ChildA);\n-          expect(fixture.nativeElement.parentNode.textContent).toContain('[Child Component A]');\n-        } else {\n-          expect(() => {\n-            fixture.componentInstance.viewContainerRef.createComponent(ChildA);\n-          }).toThrowError(/ViewEngine does not support Type/);\n-        }\n+        fixture.componentInstance.viewContainerRef.createComponent(ChildA);\n+        expect(fixture.nativeElement.parentNode.textContent).toContain('[Child Component A]');\n       });\n \n       it('should throw if class without @Component decorator is used as Component type', () => {\n@@ -1572,45 +1507,40 @@ describe('ViewContainerRef', () => {\n           fixture.componentInstance.viewContainerRef.createComponent(\n               MyClassWithoutComponentDecorator);\n         };\n-        if (ivyEnabled) {\n-          expect(createComponent)\n-              .toThrowError(/Provided Component class doesn't contain Component definition./);\n-        } else {\n-          expect(createComponent).toThrowError(/ViewEngine does not support Type/);\n-        }\n+        expect(createComponent)\n+            .toThrowError(/Provided Component class doesn't contain Component definition./);\n       });\n \n-      onlyInIvy('Ivy-only checks for the `createComponent` API with `options` argument')\n-          .describe('`options` argument handling', () => {\n-            it('should work correctly when an empty object is provided', () => {\n-              fixture.componentInstance.viewContainerRef.createComponent(ChildA, {});\n-              expect(fixture.nativeElement.parentNode.textContent).toContain('[Child Component A]');\n-            });\n-\n-            it('should take provided `options` arguments into account', () => {\n-              const {viewContainerRef, ngModuleRef, injector} = fixture.componentInstance;\n-              viewContainerRef.createComponent(ChildA);\n-\n-              const projectableNode = document.createElement('div');\n-              const textNode = document.createTextNode('[Projectable Node]');\n-              projectableNode.appendChild(textNode);\n-              const projectableNodes = [[projectableNode]];\n-\n-              // Insert ChildB in front of ChildA (since index = 0)\n-              viewContainerRef.createComponent(\n-                  ChildB, {index: 0, injector, ngModuleRef, projectableNodes});\n-\n-              fixture.detectChanges();\n-\n-              expect(fixture.nativeElement.parentNode.textContent.trim())\n-                  .toContain(\n-                      '[Child Component B] ' +\n-                      '[Projectable Node] ' +\n-                      '[TokenValueA] ' +\n-                      '[TokenValueB] ' +\n-                      '[Child Component A]');\n-            });\n-          });\n+      describe('`options` argument handling', () => {\n+        it('should work correctly when an empty object is provided', () => {\n+          fixture.componentInstance.viewContainerRef.createComponent(ChildA, {});\n+          expect(fixture.nativeElement.parentNode.textContent).toContain('[Child Component A]');\n+        });\n+\n+        it('should take provided `options` arguments into account', () => {\n+          const {viewContainerRef, ngModuleRef, injector} = fixture.componentInstance;\n+          viewContainerRef.createComponent(ChildA);\n+\n+          const projectableNode = document.createElement('div');\n+          const textNode = document.createTextNode('[Projectable Node]');\n+          projectableNode.appendChild(textNode);\n+          const projectableNodes = [[projectableNode]];\n+\n+          // Insert ChildB in front of ChildA (since index = 0)\n+          viewContainerRef.createComponent(\n+              ChildB, {index: 0, injector, ngModuleRef, projectableNodes});\n+\n+          fixture.detectChanges();\n+\n+          expect(fixture.nativeElement.parentNode.textContent.trim())\n+              .toContain(\n+                  '[Child Component B] ' +\n+                  '[Projectable Node] ' +\n+                  '[TokenValueA] ' +\n+                  '[TokenValueB] ' +\n+                  '[Child Component A]');\n+        });\n+      });\n     });\n   });\n \n@@ -2443,22 +2373,20 @@ describe('ViewContainerRef', () => {\n       const {vcRef, cfResolver} = fixture.componentInstance;\n       fixture.detectChanges();\n \n-      // Ivy inserts a comment for the root view container ref instance. This is not\n-      // the case for view engine and we need to adjust the assertions.\n-      expect(containerEl!.childNodes.length).toBe(ivyEnabled ? 2 : 1);\n-      ivyEnabled && expect(containerEl!.childNodes[1].nodeType).toBe(Node.COMMENT_NODE);\n+      expect(containerEl!.childNodes.length).toBe(2);\n+      expect(containerEl!.childNodes[1].nodeType).toBe(Node.COMMENT_NODE);\n \n       expect((containerEl!.childNodes[0] as Element).tagName).toBe('DIV');\n \n       vcRef.createComponent(cfResolver.resolveComponentFactory(DynamicCompWithBindings));\n       fixture.detectChanges();\n \n-      expect(containerEl!.childNodes.length).toBe(ivyEnabled ? 3 : 2);\n+      expect(containerEl!.childNodes.length).toBe(3);\n       expect(containerEl!.childNodes[1].textContent).toBe('check count: 1');\n \n       fixture.detectChanges();\n \n-      expect(containerEl!.childNodes.length).toBe(ivyEnabled ? 3 : 2);\n+      expect(containerEl!.childNodes.length).toBe(3);\n       expect(containerEl!.childNodes[1].textContent).toBe('check count: 2');\n     });\n \n@@ -2494,22 +2422,20 @@ describe('ViewContainerRef', () => {\n       const {vcRef, cfResolver} = fixture.componentInstance;\n       fixture.detectChanges();\n \n-      // Ivy inserts a comment for the root view container ref instance. This is not\n-      // the case for view engine and we need to adjust the assertions.\n-      expect(containerEl!.childNodes.length).toBe(ivyEnabled ? 2 : 1);\n-      ivyEnabled && expect(containerEl!.childNodes[1].nodeType).toBe(Node.COMMENT_NODE);\n+      expect(containerEl!.childNodes.length).toBe(2);\n+      expect(containerEl!.childNodes[1].nodeType).toBe(Node.COMMENT_NODE);\n \n       expect((containerEl!.childNodes[0] as Element).tagName).toBe('DIV');\n \n       vcRef.createComponent(cfResolver.resolveComponentFactory(DynamicCompWithChildren));\n \n-      expect(containerEl!.childNodes.length).toBe(ivyEnabled ? 3 : 2);\n+      expect(containerEl!.childNodes.length).toBe(3);\n       expect(getElementHtml(containerEl!.childNodes[1] as Element))\n           .toBe('<child><div></div></child>');\n \n       fixture.detectChanges();\n \n-      expect(containerEl!.childNodes.length).toBe(ivyEnabled ? 3 : 2);\n+      expect(containerEl!.childNodes.length).toBe(3);\n       expect(getElementHtml(containerEl!.childNodes[1] as Element))\n           .toBe(`<child><div>text</div></child>`);\n     });"
        },
        {
            "sha": "84847060280bb37869b858a07c7f6d644e61e44b",
            "filename": "packages/core/test/acceptance/view_insertion_spec.ts",
            "status": "modified",
            "additions": 32,
            "deletions": 35,
            "changes": 67,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fview_insertion_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Facceptance%2Fview_insertion_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fview_insertion_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -10,7 +10,6 @@ import {CommonModule} from '@angular/common';\n import {ChangeDetectorRef, Component, ComponentFactoryResolver, Directive, EmbeddedViewRef, Injectable, Injector, Input, NgModule, TemplateRef, ViewChild, ViewContainerRef, ViewRef} from '@angular/core';\n import {TestBed} from '@angular/core/testing';\n import {By} from '@angular/platform-browser';\n-import {onlyInIvy} from '@angular/private/testing';\n \n describe('view insertion', () => {\n   describe('of a simple template', () => {\n@@ -337,15 +336,14 @@ describe('view insertion', () => {\n             .toBe('insert|before');\n       });\n \n-      onlyInIvy('VE incorrectly inserts views before ng-container content')\n-          .it('should insert before a view with a ng-container where ViewContainerRef is injected',\n-              () => {\n-                expect(createAndInsertViews(`\n+      it('should insert before a view with a ng-container where ViewContainerRef is injected',\n+         () => {\n+           expect(createAndInsertViews(`\n           <ng-container [ngTemplateOutlet]=\"after\">|before</ng-container>\n           <ng-template #after>|after</ng-template>\n         `).textContent)\n-                    .toBe('insert|before|after');\n-              });\n+               .toBe('insert|before|after');\n+         });\n \n \n       it('should insert before a view with an element where ViewContainerRef is injected', () => {\n@@ -592,7 +590,7 @@ describe('view insertion', () => {\n          class AppComponent {\n            @ViewChild('container', {read: ViewContainerRef, static: true}) vcr!: ViewContainerRef;\n \n-           @ViewChild('template', {read: TemplateRef, static: true}) template !: TemplateRef<any>;\n+           @ViewChild('template', {read: TemplateRef, static: true}) template!: TemplateRef<any>;\n \n            click() {\n              this.vcr.createEmbeddedView(this.template, undefined, 0);\n@@ -707,36 +705,35 @@ describe('view insertion', () => {\n       expect(fixture.nativeElement.textContent).toContain('OK');\n     });\n \n-    onlyInIvy('Test depends on static inputs being set during creation')\n-        .it('should consistently report errors raised a directive input setter', () => {\n-          @Directive({\n-            selector: '[failInInputAlways]',\n-          })\n-          class FailInInputAlways {\n-            @Input()\n-            set failInInputAlways(_: string) {\n-              throw new Error('Error in an input');\n-            }\n-          }\n+    it('should consistently report errors raised a directive input setter', () => {\n+      @Directive({\n+        selector: '[failInInputAlways]',\n+      })\n+      class FailInInputAlways {\n+        @Input()\n+        set failInInputAlways(_: string) {\n+          throw new Error('Error in an input');\n+        }\n+      }\n \n-          @Component({\n-            template: `<div failInInputAlways=\"static\"></div>`,\n-          })\n-          class TestCmpt {\n-          }\n+      @Component({\n+        template: `<div failInInputAlways=\"static\"></div>`,\n+      })\n+      class TestCmpt {\n+      }\n \n-          TestBed.configureTestingModule({\n-            declarations: [TestCmpt, FailInInputAlways],\n-          });\n+      TestBed.configureTestingModule({\n+        declarations: [TestCmpt, FailInInputAlways],\n+      });\n \n-          expect(() => {\n-            TestBed.createComponent(TestCmpt);\n-          }).toThrowError('Error in an input');\n+      expect(() => {\n+        TestBed.createComponent(TestCmpt);\n+      }).toThrowError('Error in an input');\n \n-          expect(() => {\n-            TestBed.createComponent(TestCmpt);\n-          }).toThrowError('Error in an input');\n-        });\n+      expect(() => {\n+        TestBed.createComponent(TestCmpt);\n+      }).toThrowError('Error in an input');\n+    });\n \n     it('should consistently report errors raised a static query setter', () => {\n       @Directive({\n@@ -906,7 +903,7 @@ describe('view insertion', () => {\n         `,\n       })\n       class App {\n-        @ViewChild('broken') template !: TemplateRef<unknown>;\n+        @ViewChild('broken') template!: TemplateRef<unknown>;\n \n         constructor(private _viewContainerRef: ViewContainerRef) {}\n "
        },
        {
            "sha": "abbc5c8eb5e3e258418c6d8499790ba75422150d",
            "filename": "packages/core/test/animation/animation_integration_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 51,
            "changes": 52,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Fanimation%2Fanimation_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Fanimation%2Fanimation_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fanimation%2Fanimation_integration_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -13,7 +13,6 @@ import {fakeAsync, flushMicrotasks, TestBed} from '@angular/core/testing';\n import {ɵDomRendererFactory2} from '@angular/platform-browser';\n import {ANIMATION_MODULE_TYPE, BrowserAnimationsModule, NoopAnimationsModule} from '@angular/platform-browser/animations';\n import {hasStyle} from '@angular/platform-browser/testing/src/browser_util';\n-import {ivyEnabled, modifiedInIvy} from '@angular/private/testing';\n \n const DEFAULT_NAMESPACE_ID = 'id';\n const DEFAULT_COMPONENT_ID = '1';\n@@ -3195,9 +3194,7 @@ describe('animation tests', function() {\n           expect(element.style['height']).toEqual(height);\n         }\n \n-        // In Ivy, change detection needs to run before the ViewQuery for cmp.element will\n-        // resolve. Keeping this test enabled since we still want to test the animation logic.\n-        if (ivyEnabled) fixture.detectChanges();\n+        fixture.detectChanges();\n \n         const cmp = fixture.componentInstance;\n         const element = cmp.element.nativeElement;\n@@ -3773,53 +3770,6 @@ describe('animation tests', function() {\n     }).not.toThrowError();\n   });\n \n-  modifiedInIvy('FW-952 - Error recovery is handled differently in Ivy than VE')\n-      .it('should continue to clean up DOM-related animation artifacts even if a compiler-level error is thrown midway',\n-          () => {\n-            @Component({\n-              selector: 'if-cmp',\n-              animations: [\n-                trigger(\n-                    'foo',\n-                    [\n-                      transition('* => something', []),\n-                    ]),\n-              ],\n-              template: `\n-          value = {{ foo[bar] }}\n-          <div #contents>\n-            <div *ngIf=\"exp\">1</div>\n-            <div *ngIf=\"exp\" @foo>2</div>\n-            <div *ngIf=\"exp\" [@foo]=\"'123'\">3</div>\n-          </div>\n-        `,\n-            })\n-            class Cmp {\n-              exp: any = false;\n-\n-              @ViewChild('contents', {static: true}) public contents: any;\n-            }\n-\n-            TestBed.configureTestingModule({declarations: [Cmp]});\n-\n-            const engine = TestBed.inject(ɵAnimationEngine);\n-            const fixture = TestBed.createComponent(Cmp);\n-\n-            const runCD = () => fixture.detectChanges();\n-            const cmp = fixture.componentInstance;\n-\n-            cmp.exp = true;\n-            expect(runCD).toThrow();\n-\n-            const contents = cmp.contents.nativeElement;\n-            expect(contents.innerText.replace(/\\s+/gm, '')).toEqual('123');\n-\n-            cmp.exp = false;\n-            expect(runCD).toThrow();\n-\n-            expect(contents.innerText.trim()).toEqual('');\n-          });\n-\n   describe('errors for not using the animation module', () => {\n     beforeEach(() => {\n       TestBed.configureTestingModule({"
        },
        {
            "sha": "417c6389bb833b2e179ede068b67e866bafbc406",
            "filename": "packages/core/test/application_module_spec.ts",
            "status": "modified",
            "additions": 26,
            "deletions": 29,
            "changes": 55,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Fapplication_module_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Fapplication_module_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fapplication_module_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -8,7 +8,6 @@\n \n import {DEFAULT_CURRENCY_CODE, LOCALE_ID} from '@angular/core';\n import {inject} from '@angular/core/testing';\n-import {ivyEnabled} from '@angular/private/testing';\n \n import {getLocaleId} from '../src/render3';\n import {global} from '../src/util/global';\n@@ -25,37 +24,35 @@ import {TestBed} from '../testing';\n          expect(defaultCurrencyCode).toEqual('USD');\n        }));\n \n-    if (ivyEnabled) {\n-      it('should set the ivy locale with the configured LOCALE_ID', () => {\n-        TestBed.configureTestingModule({providers: [{provide: LOCALE_ID, useValue: 'fr'}]});\n-        const before = getLocaleId();\n-        const locale = TestBed.inject(LOCALE_ID);\n-        const after = getLocaleId();\n-        expect(before).toEqual('en-us');\n-        expect(locale).toEqual('fr');\n-        expect(after).toEqual('fr');\n-      });\n-\n-      describe('$localize.locale', () => {\n-        beforeEach(() => initLocale('de'));\n-        afterEach(() => restoreLocale());\n+    it('should set the ivy locale with the configured LOCALE_ID', () => {\n+      TestBed.configureTestingModule({providers: [{provide: LOCALE_ID, useValue: 'fr'}]});\n+      const before = getLocaleId();\n+      const locale = TestBed.inject(LOCALE_ID);\n+      const after = getLocaleId();\n+      expect(before).toEqual('en-us');\n+      expect(locale).toEqual('fr');\n+      expect(after).toEqual('fr');\n+    });\n \n-        it('should set the ivy locale to `$localize.locale` value if it is defined', () => {\n-          // Injecting `LOCALE_ID` should also initialize the ivy locale\n-          const locale = TestBed.inject(LOCALE_ID);\n-          expect(locale).toEqual('de');\n-          expect(getLocaleId()).toEqual('de');\n-        });\n+    describe('$localize.locale', () => {\n+      beforeEach(() => initLocale('de'));\n+      afterEach(() => restoreLocale());\n \n-        it('should set the ivy locale to an application provided LOCALE_ID even if `$localize.locale` is defined',\n-           () => {\n-             TestBed.configureTestingModule({providers: [{provide: LOCALE_ID, useValue: 'fr'}]});\n-             const locale = TestBed.inject(LOCALE_ID);\n-             expect(locale).toEqual('fr');\n-             expect(getLocaleId()).toEqual('fr');\n-           });\n+      it('should set the ivy locale to `$localize.locale` value if it is defined', () => {\n+        // Injecting `LOCALE_ID` should also initialize the ivy locale\n+        const locale = TestBed.inject(LOCALE_ID);\n+        expect(locale).toEqual('de');\n+        expect(getLocaleId()).toEqual('de');\n       });\n-    }\n+\n+      it('should set the ivy locale to an application provided LOCALE_ID even if `$localize.locale` is defined',\n+         () => {\n+           TestBed.configureTestingModule({providers: [{provide: LOCALE_ID, useValue: 'fr'}]});\n+           const locale = TestBed.inject(LOCALE_ID);\n+           expect(locale).toEqual('fr');\n+           expect(getLocaleId()).toEqual('fr');\n+         });\n+    });\n   });\n }\n "
        },
        {
            "sha": "679eedcf63897ede5b815797579445e390ec2407",
            "filename": "packages/core/test/application_ref_spec.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 14,
            "changes": 26,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Fapplication_ref_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Fapplication_ref_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fapplication_ref_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -16,7 +16,6 @@ import {getLocaleId} from '@angular/core/src/render3';\n import {BrowserModule} from '@angular/platform-browser';\n import {createTemplate, dispatchEvent, getContent} from '@angular/platform-browser/testing/src/browser_util';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {onlyInIvy} from '@angular/private/testing';\n \n import {NoopNgZone} from '../src/zone/ng_zone';\n import {ComponentFixtureNoNgZone, inject, TestBed, waitForAsync, withModule} from '../testing';\n@@ -345,21 +344,20 @@ class SomeComponent {\n         expect(loadResourceSpy).toHaveBeenCalledWith('/test-template.html');\n       });\n \n-      onlyInIvy('We only need to define `LOCALE_ID` for runtime i18n')\n-          .it('should define `LOCALE_ID`', async () => {\n-            @Component({\n-              selector: 'i18n-app',\n-              templateUrl: '',\n-            })\n-            class I18nComponent {\n-            }\n+      it('should define `LOCALE_ID`', async () => {\n+        @Component({\n+          selector: 'i18n-app',\n+          templateUrl: '',\n+        })\n+        class I18nComponent {\n+        }\n \n-            const testModule = createModule(\n-                {component: I18nComponent, providers: [{provide: LOCALE_ID, useValue: 'ro'}]});\n-            await defaultPlatform.bootstrapModule(testModule);\n+        const testModule = createModule(\n+            {component: I18nComponent, providers: [{provide: LOCALE_ID, useValue: 'ro'}]});\n+        await defaultPlatform.bootstrapModule(testModule);\n \n-            expect(getLocaleId()).toEqual('ro');\n-          });\n+        expect(getLocaleId()).toEqual('ro');\n+      });\n \n       it('should wait for APP_INITIALIZER to set providers for `LOCALE_ID`', async () => {\n         let locale: string = '';"
        },
        {
            "sha": "f9f4427f4f349c41379f777b1482bc04ba6972fb",
            "filename": "packages/core/test/debug/debug_node_spec.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 18,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Fdebug%2Fdebug_node_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Fdebug%2Fdebug_node_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fdebug%2Fdebug_node_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -14,7 +14,6 @@ import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';\n import {By} from '@angular/platform-browser/src/dom/debug/by';\n import {createMouseEvent, hasClass} from '@angular/platform-browser/testing/src/browser_util';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {ivyEnabled, onlyInIvy} from '@angular/private/testing';\n \n @Injectable()\n class Logger {\n@@ -745,12 +744,11 @@ class TestCmptWithPropInterpolation {\n         expect(() => el.query(e => e.injector === null)).not.toThrow();\n       });\n \n-      onlyInIvy('VE does not match elements created outside Angular context')\n-          .it('when using the out-of-context element as the DebugElement query root', () => {\n-            const debugElOutsideAngularContext = el.query(By.css('ul'));\n-            expect(debugElOutsideAngularContext.queryAll(By.css('li')).length).toBe(1);\n-            expect(debugElOutsideAngularContext.query(By.css('li'))).toBeDefined();\n-          });\n+      it('when using the out-of-context element as the DebugElement query root', () => {\n+        const debugElOutsideAngularContext = el.query(By.css('ul'));\n+        expect(debugElOutsideAngularContext.queryAll(By.css('li')).length).toBe(1);\n+        expect(debugElOutsideAngularContext.query(By.css('li'))).toBeDefined();\n+      });\n     });\n \n     it('DebugElement.queryAll should pick up both elements inserted via the view and through Renderer2',\n@@ -912,18 +910,17 @@ class TestCmptWithPropInterpolation {\n         expect(Object.keys(button.properties).filter(key => key.startsWith('on'))).toEqual([]);\n       });\n \n-      onlyInIvy('Show difference in behavior')\n-          .it('should pickup all of the element properties', () => {\n-            TestBed.overrideTemplate(\n-                TestCmptWithPropInterpolation, `<button title=\"myTitle\"></button>`);\n-            const fixture = TestBed.createComponent(TestCmptWithPropInterpolation);\n-            fixture.detectChanges();\n+      it('should pickup all of the element properties', () => {\n+        TestBed.overrideTemplate(\n+            TestCmptWithPropInterpolation, `<button title=\"myTitle\"></button>`);\n+        const fixture = TestBed.createComponent(TestCmptWithPropInterpolation);\n+        fixture.detectChanges();\n \n-            const host = fixture.debugElement;\n-            const button = fixture.debugElement.query(By.css('button'));\n+        const host = fixture.debugElement;\n+        const button = fixture.debugElement.query(By.css('button'));\n \n-            expect(button.properties.title).toEqual('myTitle');\n-          });\n+        expect(button.properties.title).toEqual('myTitle');\n+      });\n     });\n \n     it('should trigger events registered via Renderer2', () => {\n@@ -955,7 +952,7 @@ class TestCmptWithPropInterpolation {\n       // Ivy depends on `eventListeners` to pick up events that haven't been registered through\n       // Angular templates. At the time of writing Zone.js doesn't add `eventListeners` in Node\n       // environments so we have to skip the test.\n-      if (!ivyEnabled || typeof fixture.debugElement.nativeElement.eventListeners === 'function') {\n+      if (typeof fixture.debugElement.nativeElement.eventListeners === 'function') {\n         const event = {value: true};\n         fixture.detectChanges();\n         fixture.debugElement.triggerEventHandler('click', event);"
        },
        {
            "sha": "3710b0d2e79468b64e4828c92b39abd60783ded8",
            "filename": "packages/core/test/di/static_injector_spec.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 329,
            "changes": 333,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Fdi%2Fstatic_injector_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Fdi%2Fstatic_injector_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fdi%2Fstatic_injector_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -6,9 +6,8 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {forwardRef, Inject, InjectFlags, InjectionToken, Injector, Optional, Self, SkipSelf} from '@angular/core';\n+import {forwardRef, Inject, InjectFlags, Injector, Self, SkipSelf} from '@angular/core';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {ivyEnabled, modifiedInIvy} from '@angular/private/testing';\n \n import {stringify} from '../../src/util/stringify';\n \n@@ -23,15 +22,6 @@ class BrokenEngine {\n   }\n }\n \n-class DashboardSoftware {\n-  static PROVIDER = {provide: DashboardSoftware, useClass: DashboardSoftware, deps: []};\n-}\n-\n-class Dashboard {\n-  static PROVIDER = {provide: Dashboard, useClass: Dashboard, deps: [DashboardSoftware]};\n-  constructor(software: DashboardSoftware) {}\n-}\n-\n class TurboEngine extends Engine {\n   static override PROVIDER = {provide: Engine, useClass: TurboEngine, deps: []};\n }\n@@ -41,320 +31,11 @@ class Car {\n   constructor(public engine: Engine) {}\n }\n \n-class CarWithOptionalEngine {\n-  static PROVIDER = {\n-    provide: CarWithOptionalEngine,\n-    useClass: CarWithOptionalEngine,\n-    deps: [[new Optional(), Engine]]\n-  };\n-  constructor(public engine: Engine) {}\n-}\n-\n-class CarWithDashboard {\n-  static PROVIDER = {\n-    provide: CarWithDashboard,\n-    useClass: CarWithDashboard,\n-    deps: [Engine, Dashboard]\n-  };\n-  engine: Engine;\n-  dashboard: Dashboard;\n-  constructor(engine: Engine, dashboard: Dashboard) {\n-    this.engine = engine;\n-    this.dashboard = dashboard;\n-  }\n-}\n-\n class SportsCar extends Car {\n   static override PROVIDER = {provide: Car, useClass: SportsCar, deps: [Engine]};\n }\n \n-class CyclicEngine {\n-  static PROVIDER = {provide: Engine, useClass: CyclicEngine, deps: [Car]};\n-  constructor(car: Car) {}\n-}\n-\n-class NoAnnotations {\n-  constructor(secretDependency: any) {}\n-}\n-\n-function factoryFn(a: any) {}\n-\n {\n-  const dynamicProviders = [\n-    {provide: 'provider0', useValue: 1}, {provide: 'provider1', useValue: 1},\n-    {provide: 'provider2', useValue: 1}, {provide: 'provider3', useValue: 1},\n-    {provide: 'provider4', useValue: 1}, {provide: 'provider5', useValue: 1},\n-    {provide: 'provider6', useValue: 1}, {provide: 'provider7', useValue: 1},\n-    {provide: 'provider8', useValue: 1}, {provide: 'provider9', useValue: 1},\n-    {provide: 'provider10', useValue: 1}\n-  ];\n-\n-  modifiedInIvy('Ivy uses R3Injector').describe(`StaticInjector`, () => {\n-    it('should instantiate a class without dependencies', () => {\n-      const injector = Injector.create([Engine.PROVIDER]);\n-      const engine = injector.get(Engine);\n-\n-      expect(engine).toBeAnInstanceOf(Engine);\n-    });\n-\n-    it('should resolve dependencies based on type information', () => {\n-      const injector = Injector.create([Engine.PROVIDER, Car.PROVIDER]);\n-      const car = injector.get<Car>(Car);\n-\n-      expect(car).toBeAnInstanceOf(Car);\n-      expect(car.engine).toBeAnInstanceOf(Engine);\n-    });\n-\n-    it('should cache instances', () => {\n-      const injector = Injector.create([Engine.PROVIDER]);\n-\n-      const e1 = injector.get(Engine);\n-      const e2 = injector.get(Engine);\n-\n-      expect(e1).toBe(e2);\n-    });\n-\n-    it('should provide to a value', () => {\n-      const injector = Injector.create([{provide: Engine, useValue: 'fake engine'}]);\n-\n-      const engine = injector.get(Engine);\n-      expect(engine).toEqual('fake engine');\n-    });\n-\n-    it('should inject dependencies instance of InjectionToken', () => {\n-      const TOKEN = new InjectionToken<string>('token');\n-\n-      const injector = Injector.create([\n-        {provide: TOKEN, useValue: 'by token'},\n-        {provide: Engine, useFactory: (v: string) => v, deps: [[TOKEN]]},\n-      ]);\n-\n-      const engine = injector.get(Engine);\n-      expect(engine).toEqual('by token');\n-    });\n-\n-    it('should provide to a factory', () => {\n-      function sportsCarFactory(e: any) {\n-        return new SportsCar(e);\n-      }\n-\n-      const injector = Injector.create(\n-          [Engine.PROVIDER, {provide: Car, useFactory: sportsCarFactory, deps: [Engine]}]);\n-\n-      const car = injector.get<Car>(Car);\n-      expect(car).toBeAnInstanceOf(SportsCar);\n-      expect(car.engine).toBeAnInstanceOf(Engine);\n-    });\n-\n-    it('should supporting provider to null', () => {\n-      const injector = Injector.create([{provide: Engine, useValue: null}]);\n-      const engine = injector.get(Engine);\n-      expect(engine).toBeNull();\n-    });\n-\n-    it('should provide to an alias', () => {\n-      const injector = Injector.create([\n-        Engine.PROVIDER, {provide: SportsCar, useClass: SportsCar, deps: [Engine]},\n-        {provide: Car, useExisting: SportsCar}\n-      ]);\n-\n-      const car = injector.get(Car);\n-      const sportsCar = injector.get(SportsCar);\n-      expect(car).toBeAnInstanceOf(SportsCar);\n-      expect(car).toBe(sportsCar);\n-      expect(sportsCar.engine).toBeAnInstanceOf(Engine);\n-    });\n-\n-    it('should support multiProviders', () => {\n-      const injector = Injector.create([\n-        Engine.PROVIDER, {provide: Car, useClass: SportsCar, deps: [Engine], multi: true},\n-        {provide: Car, useClass: CarWithOptionalEngine, deps: [Engine], multi: true}\n-      ]);\n-\n-      const cars = injector.get(Car) as any as Car[];\n-      expect(cars.length).toEqual(2);\n-      expect(cars[0]).toBeAnInstanceOf(SportsCar);\n-      expect(cars[1]).toBeAnInstanceOf(CarWithOptionalEngine);\n-    });\n-\n-    it('should support multiProviders that are created using useExisting', () => {\n-      const injector = Injector.create([\n-        Engine.PROVIDER, {provide: SportsCar, useClass: SportsCar, deps: [Engine]},\n-        {provide: Car, useExisting: SportsCar, multi: true}\n-      ]);\n-\n-      const cars = injector.get(Car) as any as Car[];\n-      expect(cars.length).toEqual(1);\n-      expect(cars[0]).toBe(injector.get(SportsCar));\n-    });\n-\n-    it('should throw when the aliased provider does not exist', () => {\n-      const injector = Injector.create([{provide: 'car', useExisting: SportsCar}]);\n-      const e = `StaticInjectorError[car -> ${\n-          stringify(SportsCar)}]: \\n  NullInjectorError: No provider for ${stringify(SportsCar)}!`;\n-      expect(() => injector.get('car')).toThrowError(e);\n-    });\n-\n-    it('should handle forwardRef in useExisting', () => {\n-      const injector = Injector.create([\n-        {provide: 'originalEngine', useClass: forwardRef(() => Engine), deps: []},\n-        {provide: 'aliasedEngine', useExisting: <any>forwardRef(() => 'originalEngine'), deps: []}\n-      ]);\n-      expect(injector.get('aliasedEngine')).toBeAnInstanceOf(Engine);\n-    });\n-\n-    it('should support overriding factory dependencies', () => {\n-      const injector = Injector.create([\n-        Engine.PROVIDER, {provide: Car, useFactory: (e: Engine) => new SportsCar(e), deps: [Engine]}\n-      ]);\n-\n-      const car = injector.get<Car>(Car);\n-      expect(car).toBeAnInstanceOf(SportsCar);\n-      expect(car.engine).toBeAnInstanceOf(Engine);\n-    });\n-\n-    it('should support optional dependencies', () => {\n-      const injector = Injector.create([CarWithOptionalEngine.PROVIDER]);\n-\n-      const car = injector.get<CarWithOptionalEngine>(CarWithOptionalEngine);\n-      expect(car.engine).toBeNull();\n-    });\n-\n-    it('should flatten passed-in providers', () => {\n-      const injector = Injector.create([[[Engine.PROVIDER, Car.PROVIDER]]]);\n-\n-      const car = injector.get(Car);\n-      expect(car).toBeAnInstanceOf(Car);\n-    });\n-\n-    it('should use the last provider when there are multiple providers for same token', () => {\n-      const injector = Injector.create([\n-        {provide: Engine, useClass: Engine, deps: []},\n-        {provide: Engine, useClass: TurboEngine, deps: []}\n-      ]);\n-\n-      expect(injector.get(Engine)).toBeAnInstanceOf(TurboEngine);\n-    });\n-\n-    it('should use non-type tokens', () => {\n-      const injector = Injector.create([{provide: 'token', useValue: 'value'}]);\n-\n-      expect(injector.get('token')).toEqual('value');\n-    });\n-\n-    it('should throw when given invalid providers', () => {\n-      expect(() => Injector.create(<any>['blah']))\n-          .toThrowError('StaticInjectorError[blah]: Unexpected provider');\n-    });\n-\n-    it('should throw when missing deps', () => {\n-      expect(() => Injector.create(<any>[\n-        {provide: Engine, useClass: Engine}\n-      ])).toThrowError('StaticInjectorError[{provide:Engine, useClass:Engine}]: \\'deps\\' required');\n-    });\n-\n-    it('should throw when using reflective API', () => {\n-      expect(() => Injector.create(<any>[Engine]))\n-          .toThrowError('StaticInjectorError[Engine]: Function/Class not supported');\n-    });\n-\n-    it('should throw when unknown provider shape API', () => {\n-      expect(() => Injector.create(<any>[{provide: 'abc', deps: [Engine]}]))\n-          .toThrowError(\n-              'StaticInjectorError[{provide:\"abc\", deps:[Engine]}]: StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable');\n-    });\n-\n-    it('should throw when given invalid providers and serialize the provider', () => {\n-      expect(() => Injector.create(<any>[{foo: 'bar', bar: Car}]))\n-          .toThrowError('StaticInjectorError[{foo:\"bar\", bar:Car}]: Unexpected provider');\n-    });\n-\n-    it('should provide itself', () => {\n-      const parent = Injector.create([]);\n-      const child = Injector.create([], parent);\n-\n-      expect(child.get(Injector)).toBe(child);\n-    });\n-\n-    it('should throw when no provider defined', () => {\n-      const injector = Injector.create([]);\n-      expect(() => injector.get('NonExisting'))\n-          .toThrowError(\n-              'StaticInjectorError[NonExisting]: \\n  NullInjectorError: No provider for NonExisting!');\n-    });\n-\n-    it('should show the full path when no provider', () => {\n-      const injector =\n-          Injector.create([CarWithDashboard.PROVIDER, Engine.PROVIDER, Dashboard.PROVIDER]);\n-      expect(() => injector.get(CarWithDashboard))\n-          .toThrowError(\n-              `StaticInjectorError[${stringify(CarWithDashboard)} -> ${\n-                  stringify(Dashboard)} -> DashboardSoftware]: \\n` +\n-              '  NullInjectorError: No provider for DashboardSoftware!');\n-    });\n-\n-    it('should throw when trying to instantiate a cyclic dependency', () => {\n-      const injector = Injector.create([Car.PROVIDER, CyclicEngine.PROVIDER]);\n-\n-      expect(() => injector.get(Car))\n-          .toThrowError(`StaticInjectorError[${stringify(Car)} -> ${stringify(Engine)} -> ${\n-              stringify(Car)}]: Circular dependency`);\n-    });\n-\n-    it('should show the full path when error happens in a constructor', () => {\n-      const error = new Error('MyError');\n-      const injector = Injector.create([\n-        Car.PROVIDER, {\n-          provide: Engine,\n-          useFactory: () => {\n-            throw error;\n-          },\n-          deps: []\n-        }\n-      ]);\n-\n-      try {\n-        injector.get(Car);\n-        throw 'Must throw';\n-      } catch (e) {\n-        expect(e).toBe(error);\n-        expect(e.message).toContain(\n-            `StaticInjectorError[${stringify(Car)} -> Engine]: \\n  MyError`);\n-        expect(e.ngTokenPath[0]).toEqual(Car);\n-        expect(e.ngTokenPath[1]).toEqual(Engine);\n-      }\n-    });\n-\n-    it('should instantiate an object after a failed attempt', () => {\n-      let isBroken = true;\n-\n-      const injector = Injector.create([\n-        Car.PROVIDER, {\n-          provide: Engine,\n-          useFactory: (() => isBroken ? new BrokenEngine() : new Engine()),\n-          deps: []\n-        }\n-      ]);\n-\n-      expect(() => injector.get(Car))\n-          .toThrowError('StaticInjectorError[Car -> Engine]: \\n  Broken Engine');\n-\n-      isBroken = false;\n-\n-      expect(injector.get(Car)).toBeAnInstanceOf(Car);\n-    });\n-\n-    it('should support null/undefined values', () => {\n-      const injector = Injector.create([\n-        {provide: 'null', useValue: null},\n-        {provide: 'undefined', useValue: undefined},\n-      ]);\n-      expect(injector.get('null')).toBe(null);\n-      expect(injector.get('undefined')).toBe(undefined);\n-    });\n-  });\n-\n-\n   describe('child', () => {\n     it('should load instances from parent injector', () => {\n       const parent = Injector.create([Engine.PROVIDER]);\n@@ -421,11 +102,9 @@ function factoryFn(a: any) {}\n             [{provide: Car, useFactory: (e: Engine) => new Car(e), deps: [[Engine, new Self()]]}],\n             parent);\n \n-        const injectorName = ivyEnabled ? `R3Injector` : `StaticInjector`;\n-\n         expect(() => child.get(Car))\n             .toThrowError(\n-                `${injectorName}Error[${stringify(Car)} -> ${stringify(Engine)}]: \\n` +\n+                `R3InjectorError[${stringify(Car)} -> ${stringify(Engine)}]: \\n` +\n                 '  NullInjectorError: No provider for Engine!');\n       });\n \n@@ -451,10 +130,9 @@ function factoryFn(a: any) {}\n \n       it('should throw error when not requested provider on self', () => {\n         const injector = Injector.create([]);\n-        const injectorName = ivyEnabled ? `R3Injector` : `StaticInjector`;\n         expect(() => injector.get(Car, undefined, InjectFlags.Self))\n             .toThrowError(\n-                `${injectorName}Error[${stringify(Car)}]: \\n` +\n+                `R3InjectorError[${stringify(Car)}]: \\n` +\n                 `  NullInjectorError: No provider for ${stringify(Car)}!`);\n       });\n     });\n@@ -510,11 +188,8 @@ function factoryFn(a: any) {}\n \n   describe('displayName', () => {\n     it('should work', () => {\n-      const ivyError = `R3Injector[Engine, BrokenEngine, InjectionToken INJECTOR]`;\n-      const viewEngineError =\n-          `StaticInjector[Injector, InjectionToken INJECTOR, Engine, BrokenEngine]`;\n       expect(Injector.create([Engine.PROVIDER, {provide: BrokenEngine, useValue: null}]).toString())\n-          .toEqual(ivyEnabled ? ivyError : viewEngineError);\n+          .toEqual('R3Injector[Engine, BrokenEngine, InjectionToken INJECTOR]');\n     });\n   });\n }"
        },
        {
            "sha": "17b810e641d29949793b2d5cc462a4392ed4cbc7",
            "filename": "packages/core/test/linker/change_detection_integration_spec.ts",
            "status": "modified",
            "additions": 40,
            "deletions": 109,
            "changes": 149,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fchange_detection_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fchange_detection_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Fchange_detection_integration_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -12,7 +12,6 @@ import {ComponentFixture, fakeAsync, TestBed} from '@angular/core/testing';\n import {By} from '@angular/platform-browser/src/dom/debug/by';\n import {isTextNode} from '@angular/platform-browser/testing/src/browser_util';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {ivyEnabled, modifiedInIvy, onlyInIvy} from '@angular/private/testing';\n \n import {MockResourceLoader} from './resource_loader_mock';\n \n@@ -547,57 +546,29 @@ describe(`ChangeDetection`, () => {\n            expect(renderLog.loggedValues).toEqual(['null state:0', 'bob state:1', 'bart state:2']);\n          }));\n \n-      modifiedInIvy('Pure pipes are instantiated differently in view engine and ivy')\n-          .it('should call pure pipes that are used multiple times only when the arguments change and share state between pipe instances',\n-              fakeAsync(() => {\n-                const ctx = createCompFixture(\n-                    `<div [id]=\"name | countingPipe\"></div><div [id]=\"age | countingPipe\"></div>` +\n-                        '<div *ngFor=\"let x of [1,2]\" [id]=\"address.city | countingPipe\"></div>',\n-                    Person);\n-                ctx.componentInstance.name = 'a';\n-                ctx.componentInstance.age = 10;\n-                ctx.componentInstance.address = new Address('mtv');\n-                ctx.detectChanges(false);\n-                expect(renderLog.loggedValues).toEqual([\n-                  'mtv state:0', 'mtv state:1', 'a state:2', '10 state:3'\n-                ]);\n-                ctx.detectChanges(false);\n-                expect(renderLog.loggedValues).toEqual([\n-                  'mtv state:0', 'mtv state:1', 'a state:2', '10 state:3'\n-                ]);\n-                ctx.componentInstance.age = 11;\n-                ctx.detectChanges(false);\n-                expect(renderLog.loggedValues).toEqual([\n-                  'mtv state:0', 'mtv state:1', 'a state:2', '10 state:3', '11 state:4'\n-                ]);\n-              }));\n-\n-      // this is the ivy version of the above tests - the difference is in pure pipe instantiation\n-      // logic and binding execution order\n-      ivyEnabled &&\n-          it('should call pure pipes that are used multiple times only when the arguments change',\n-             fakeAsync(() => {\n-               const ctx = createCompFixture(\n-                   `<div [id]=\"name | countingPipe\"></div><div [id]=\"age | countingPipe\"></div>` +\n-                       '<div *ngFor=\"let x of [1,2]\" [id]=\"address.city | countingPipe\"></div>',\n-                   Person);\n-               ctx.componentInstance.name = 'a';\n-               ctx.componentInstance.age = 10;\n-               ctx.componentInstance.address = new Address('mtv');\n-               ctx.detectChanges(false);\n-               expect(renderLog.loggedValues).toEqual([\n-                 'a state:0', '10 state:0', 'mtv state:0', 'mtv state:0'\n-               ]);\n-               ctx.detectChanges(false);\n-               expect(renderLog.loggedValues).toEqual([\n-                 'a state:0', '10 state:0', 'mtv state:0', 'mtv state:0'\n-               ]);\n-               ctx.componentInstance.age = 11;\n-               ctx.detectChanges(false);\n-               expect(renderLog.loggedValues).toEqual([\n-                 'a state:0', '10 state:0', 'mtv state:0', 'mtv state:0', '11 state:1'\n-               ]);\n-             }));\n+      it('should call pure pipes that are used multiple times only when the arguments change',\n+         fakeAsync(() => {\n+           const ctx = createCompFixture(\n+               `<div [id]=\"name | countingPipe\"></div><div [id]=\"age | countingPipe\"></div>` +\n+                   '<div *ngFor=\"let x of [1,2]\" [id]=\"address.city | countingPipe\"></div>',\n+               Person);\n+           ctx.componentInstance.name = 'a';\n+           ctx.componentInstance.age = 10;\n+           ctx.componentInstance.address = new Address('mtv');\n+           ctx.detectChanges(false);\n+           expect(renderLog.loggedValues).toEqual([\n+             'a state:0', '10 state:0', 'mtv state:0', 'mtv state:0'\n+           ]);\n+           ctx.detectChanges(false);\n+           expect(renderLog.loggedValues).toEqual([\n+             'a state:0', '10 state:0', 'mtv state:0', 'mtv state:0'\n+           ]);\n+           ctx.componentInstance.age = 11;\n+           ctx.detectChanges(false);\n+           expect(renderLog.loggedValues).toEqual([\n+             'a state:0', '10 state:0', 'mtv state:0', 'mtv state:0', '11 state:1'\n+           ]);\n+         }));\n \n       it('should call impure pipes on each change detection run', fakeAsync(() => {\n            const ctx = _bindSimpleValue('name | countingImpurePipe', Person);\n@@ -1144,9 +1115,7 @@ describe(`ChangeDetection`, () => {\n          const ctx = createCompFixture('<div [id]=\"a\" [changed]=\"b\"></div>', TestData);\n \n          ctx.componentInstance.b = 1;\n-         const errMsgRegExp = ivyEnabled ?\n-             /Previous value: 'undefined'\\. Current value: '1'/g :\n-             /Previous value: 'changed: undefined'\\. Current value: 'changed: 1'/g;\n+         const errMsgRegExp = /Previous value: 'undefined'\\. Current value: '1'/g;\n          expect(() => ctx.checkNoChanges()).toThrowError(errMsgRegExp);\n        }));\n \n@@ -1166,9 +1135,7 @@ describe(`ChangeDetection`, () => {\n          ctx.detectChanges();\n \n          ctx.componentInstance.b = 2;\n-         const errMsgRegExp = ivyEnabled ?\n-             /Previous value: '1'\\. Current value: '2'/g :\n-             /Previous value: 'changed: 1'\\. Current value: 'changed: 2'/g;\n+         const errMsgRegExp = /Previous value: '1'\\. Current value: '2'/g;\n          expect(() => ctx.checkNoChanges()).toThrowError(errMsgRegExp);\n        }));\n \n@@ -1294,19 +1261,6 @@ describe(`ChangeDetection`, () => {\n        }));\n   });\n \n-  describe('multi directive order', () => {\n-    modifiedInIvy('order of bindings to directive inputs is different in ivy')\n-        .it('should follow the DI order for the same element', fakeAsync(() => {\n-              const ctx =\n-                  createCompFixture('<div orderCheck2=\"2\" orderCheck0=\"0\" orderCheck1=\"1\"></div>');\n-\n-              ctx.detectChanges(false);\n-              ctx.destroy();\n-\n-              expect(directiveLog.filter(['set'])).toEqual(['0.set', '1.set', '2.set']);\n-            }));\n-  });\n-\n   describe('nested view recursion', () => {\n     it('should recurse into nested components even if there are no bindings in the component view',\n        () => {\n@@ -1441,49 +1395,26 @@ describe(`ChangeDetection`, () => {\n         expect(log).toEqual(['inner-start', 'main-tpl', 'outer-tpl']);\n       });\n \n-      modifiedInIvy('Views should not be dirty checked if inserted into CD-detached view tree')\n-          .it('should dirty check projected views if the declaration place is dirty checked',\n-              () => {\n-                ctx.detectChanges(false);\n-                log = [];\n-                innerComp.cdRef.detach();\n-                mainComp.cdRef.detectChanges();\n-\n-                expect(log).toEqual(['main-start', 'outer-start', 'main-tpl', 'outer-tpl']);\n-\n-                log = [];\n-                outerComp.cdRef.detectChanges();\n-\n-                expect(log).toEqual(['outer-start', 'outer-tpl']);\n-\n-                log = [];\n-                outerComp.cdRef.detach();\n-                mainComp.cdRef.detectChanges();\n-\n-                expect(log).toEqual(['main-start', 'main-tpl']);\n-              });\n-\n-      onlyInIvy('Views should not be dirty checked if inserted into CD-detached view tree')\n-          .it('should not dirty check views that are inserted into a detached tree, even if the declaration place is dirty checked',\n-              () => {\n-                ctx.detectChanges(false);\n-                log = [];\n-                innerComp.cdRef.detach();\n-                mainComp.cdRef.detectChanges();\n+      it('should not dirty check views that are inserted into a detached tree, even if the declaration place is dirty checked',\n+         () => {\n+           ctx.detectChanges(false);\n+           log = [];\n+           innerComp.cdRef.detach();\n+           mainComp.cdRef.detectChanges();\n \n-                expect(log).toEqual(['main-start', 'outer-start']);\n+           expect(log).toEqual(['main-start', 'outer-start']);\n \n-                log = [];\n-                outerComp.cdRef.detectChanges();\n+           log = [];\n+           outerComp.cdRef.detectChanges();\n \n-                expect(log).toEqual(['outer-start']);\n+           expect(log).toEqual(['outer-start']);\n \n-                log = [];\n-                outerComp.cdRef.detach();\n-                mainComp.cdRef.detectChanges();\n+           log = [];\n+           outerComp.cdRef.detach();\n+           mainComp.cdRef.detectChanges();\n \n-                expect(log).toEqual(['main-start']);\n-              });\n+           expect(log).toEqual(['main-start']);\n+         });\n     });\n   });\n "
        },
        {
            "sha": "9367e4500510ab87a1924b6d333707eeb16bb35f",
            "filename": "packages/core/test/linker/entry_components_integration_spec.ts",
            "status": "modified",
            "additions": 36,
            "deletions": 60,
            "changes": 96,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fentry_components_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fentry_components_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Fentry_components_integration_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -8,14 +8,8 @@\n \n import {ANALYZE_FOR_ENTRY_COMPONENTS, Component, ComponentFactoryResolver} from '@angular/core';\n import {Console} from '@angular/core/src/console';\n-import {noComponentFactoryError} from '@angular/core/src/linker/component_factory_resolver';\n import {TestBed} from '@angular/core/testing';\n-import {obsoleteInIvy} from '@angular/private/testing';\n \n-\n-describe('ivy', () => {\n-  declareTests();\n-});\n class DummyConsole implements Console {\n   public warnings: string[] = [];\n \n@@ -25,65 +19,47 @@ class DummyConsole implements Console {\n   }\n }\n \n-function declareTests(config?: {useJit: boolean}) {\n-  describe('@Component.entryComponents', function() {\n-    let console: DummyConsole;\n-    beforeEach(() => {\n-      console = new DummyConsole();\n-      TestBed.configureCompiler({...config, providers: [{provide: Console, useValue: console}]});\n-      TestBed.configureTestingModule({declarations: [MainComp, ChildComp, NestedChildComp]});\n-    });\n-\n-    it('should resolve ComponentFactories from the same component', () => {\n-      const compFixture = TestBed.createComponent(MainComp);\n-      const mainComp: MainComp = compFixture.componentInstance;\n-      expect(compFixture.componentRef.injector.get(ComponentFactoryResolver)).toBe(mainComp.cfr);\n-      const cf = mainComp.cfr.resolveComponentFactory(ChildComp)!;\n-      expect(cf.componentType).toBe(ChildComp);\n-    });\n-\n-    it('should resolve ComponentFactories via ANALYZE_FOR_ENTRY_COMPONENTS', () => {\n-      TestBed.resetTestingModule();\n-      TestBed.configureTestingModule(\n-          {declarations: [CompWithAnalyzeEntryComponentsProvider, NestedChildComp, ChildComp]});\n-      const compFixture = TestBed.createComponent(CompWithAnalyzeEntryComponentsProvider);\n-      const mainComp: CompWithAnalyzeEntryComponentsProvider = compFixture.componentInstance;\n-      const cfr: ComponentFactoryResolver =\n-          compFixture.componentRef.injector.get(ComponentFactoryResolver);\n-      expect(cfr.resolveComponentFactory(ChildComp)!.componentType).toBe(ChildComp);\n-      expect(cfr.resolveComponentFactory(NestedChildComp)!.componentType).toBe(NestedChildComp);\n-    });\n+describe('@Component.entryComponents', function() {\n+  let console: DummyConsole;\n+  beforeEach(() => {\n+    console = new DummyConsole();\n+    TestBed.configureCompiler({providers: [{provide: Console, useValue: console}]});\n+    TestBed.configureTestingModule({declarations: [MainComp, ChildComp, NestedChildComp]});\n+  });\n \n-    it('should be able to get a component form a parent component (view hierarchy)', () => {\n-      TestBed.overrideComponent(MainComp, {set: {template: '<child></child>'}});\n+  it('should resolve ComponentFactories from the same component', () => {\n+    const compFixture = TestBed.createComponent(MainComp);\n+    const mainComp: MainComp = compFixture.componentInstance;\n+    expect(compFixture.componentRef.injector.get(ComponentFactoryResolver)).toBe(mainComp.cfr);\n+    const cf = mainComp.cfr.resolveComponentFactory(ChildComp)!;\n+    expect(cf.componentType).toBe(ChildComp);\n+  });\n \n-      const compFixture = TestBed.createComponent(MainComp);\n-      const childCompEl = compFixture.debugElement.children[0];\n-      const childComp: ChildComp = childCompEl.componentInstance;\n-      // declared on ChildComp directly\n-      expect(childComp.cfr.resolveComponentFactory(NestedChildComp)!.componentType)\n-          .toBe(NestedChildComp);\n-      // inherited from MainComp\n-      expect(childComp.cfr.resolveComponentFactory(ChildComp)!.componentType).toBe(ChildComp);\n-    });\n+  it('should resolve ComponentFactories via ANALYZE_FOR_ENTRY_COMPONENTS', () => {\n+    TestBed.resetTestingModule();\n+    TestBed.configureTestingModule(\n+        {declarations: [CompWithAnalyzeEntryComponentsProvider, NestedChildComp, ChildComp]});\n+    const compFixture = TestBed.createComponent(CompWithAnalyzeEntryComponentsProvider);\n+    const mainComp: CompWithAnalyzeEntryComponentsProvider = compFixture.componentInstance;\n+    const cfr: ComponentFactoryResolver =\n+        compFixture.componentRef.injector.get(ComponentFactoryResolver);\n+    expect(cfr.resolveComponentFactory(ChildComp)!.componentType).toBe(ChildComp);\n+    expect(cfr.resolveComponentFactory(NestedChildComp)!.componentType).toBe(NestedChildComp);\n+  });\n \n-    obsoleteInIvy('In Ivy, the ComponentFactoryResolver can resolve any component factory')\n-        .it('should not be able to get components from a parent component (content hierarchy)',\n-            () => {\n-              TestBed.overrideComponent(\n-                  MainComp, {set: {template: '<child><nested></nested></child>'}});\n-              TestBed.overrideComponent(ChildComp, {set: {template: '<ng-content></ng-content>'}});\n+  it('should be able to get a component form a parent component (view hierarchy)', () => {\n+    TestBed.overrideComponent(MainComp, {set: {template: '<child></child>'}});\n \n-              const compFixture = TestBed.createComponent(MainComp);\n-              const nestedChildCompEl = compFixture.debugElement.children[0].children[0];\n-              const nestedChildComp: NestedChildComp = nestedChildCompEl.componentInstance;\n-              expect(nestedChildComp.cfr.resolveComponentFactory(ChildComp)!.componentType)\n-                  .toBe(ChildComp);\n-              expect(() => nestedChildComp.cfr.resolveComponentFactory(NestedChildComp))\n-                  .toThrow(noComponentFactoryError(NestedChildComp));\n-            });\n+    const compFixture = TestBed.createComponent(MainComp);\n+    const childCompEl = compFixture.debugElement.children[0];\n+    const childComp: ChildComp = childCompEl.componentInstance;\n+    // declared on ChildComp directly\n+    expect(childComp.cfr.resolveComponentFactory(NestedChildComp)!.componentType)\n+        .toBe(NestedChildComp);\n+    // inherited from MainComp\n+    expect(childComp.cfr.resolveComponentFactory(ChildComp)!.componentType).toBe(ChildComp);\n   });\n-}\n+});\n \n @Component({selector: 'nested', template: ''})\n class NestedChildComp {"
        },
        {
            "sha": "b840c358aa1b3a0c6e2a797789e0b36e84f79066",
            "filename": "packages/core/test/linker/inheritance_integration_spec.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 19,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Finheritance_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Finheritance_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Finheritance_integration_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -8,7 +8,6 @@\n \n import {Component, Directive, HostBinding} from '@angular/core';\n import {TestBed} from '@angular/core/testing';\n-import {modifiedInIvy, onlyInIvy} from '@angular/private/testing';\n \n @Directive({selector: '[directiveA]'})\n class DirectiveA {\n@@ -69,22 +68,10 @@ describe('Inheritance logic', () => {\n     expect(fixture.nativeElement.firstChild.title).toBe('DirectiveB Title');\n   });\n \n-  modifiedInIvy('View Engine allows Directives to extend Components')\n-      .it('should handle Directives that extend Components', () => {\n-        TestBed.configureTestingModule({declarations: [DirectiveExtendsComponent, App]});\n-        const template = '<div directiveExtendsComponent>Some content</div>';\n-        TestBed.overrideComponent(App, {set: {template}});\n-        const fixture = TestBed.createComponent(App);\n-        fixture.detectChanges();\n-        expect(fixture.nativeElement.firstChild.title).toBe('DirectiveExtendsComponent Title');\n-      });\n-\n-  onlyInIvy('Ivy does not allow Directives to extend Components')\n-      .it('should throw in case a Directive tries to extend a Component', () => {\n-        TestBed.configureTestingModule({declarations: [DirectiveExtendsComponent, App]});\n-        const template = '<div directiveExtendsComponent>Some content</div>';\n-        TestBed.overrideComponent(App, {set: {template}});\n-        expect(() => TestBed.createComponent(App))\n-            .toThrowError('Directives cannot inherit Components');\n-      });\n+  it('should throw in case a Directive tries to extend a Component', () => {\n+    TestBed.configureTestingModule({declarations: [DirectiveExtendsComponent, App]});\n+    const template = '<div directiveExtendsComponent>Some content</div>';\n+    TestBed.overrideComponent(App, {set: {template}});\n+    expect(() => TestBed.createComponent(App)).toThrowError('Directives cannot inherit Components');\n+  });\n });"
        },
        {
            "sha": "0d7863351db799593fdf8747c354f72b7e024ded",
            "filename": "packages/core/test/linker/integration_spec.ts",
            "status": "modified",
            "additions": 1636,
            "deletions": 1767,
            "changes": 3403,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fintegration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fintegration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Fintegration_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c"
        },
        {
            "sha": "e705165ecdd756e669e4c8fd19745fb4b20a35e8",
            "filename": "packages/core/test/linker/ng_container_integration_spec.ts",
            "status": "modified",
            "additions": 48,
            "deletions": 141,
            "changes": 189,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fng_container_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fng_container_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Fng_container_integration_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -8,164 +8,71 @@\n // Make the `$localize()` global function available to the compiled templates, and the direct calls\n // below. This would normally be done inside the application `polyfills.ts` file.\n import '@angular/localize/init';\n-import {AfterContentInit, AfterViewInit, Component, ContentChildren, Directive, Input, QueryList, ViewChildren, ɵivyEnabled as ivyEnabled} from '@angular/core';\n+\n+import {AfterContentInit, AfterViewInit, Component, ContentChildren, Directive, Input, QueryList, ViewChildren} from '@angular/core';\n import {TestBed} from '@angular/core/testing';\n-import {isCommentNode} from '@angular/platform-browser/testing/src/browser_util';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {modifiedInIvy} from '@angular/private/testing';\n-\n-if (ivyEnabled) {\n-  describe('ivy', () => {\n-    declareTests();\n-  });\n-} else {\n-  describe('jit', () => {\n-    declareTests({useJit: true});\n-  });\n-  describe('no jit', () => {\n-    declareTests({useJit: false});\n-  });\n-}\n \n-function declareTests(config?: {useJit: boolean}) {\n-  describe('<ng-container>', function() {\n-    beforeEach(() => {\n-      TestBed.configureCompiler({...config});\n-      TestBed.configureTestingModule({\n-        declarations: [\n-          MyComp,\n-          NeedsContentChildren,\n-          NeedsViewChildren,\n-          TextDirective,\n-          Simple,\n-        ],\n-      });\n+describe('<ng-container>', function() {\n+  beforeEach(() => {\n+    TestBed.configureTestingModule({\n+      declarations: [\n+        MyComp,\n+        NeedsContentChildren,\n+        NeedsViewChildren,\n+        TextDirective,\n+        Simple,\n+      ],\n     });\n+  });\n \n-    it('should support the \"i18n\" attribute', () => {\n-      const template = '<ng-container i18n>foo</ng-container>';\n-      TestBed.overrideComponent(MyComp, {set: {template}});\n-      const fixture = TestBed.createComponent(MyComp);\n-\n-      fixture.detectChanges();\n+  it('should support the \"i18n\" attribute', () => {\n+    const template = '<ng-container i18n>foo</ng-container>';\n+    TestBed.overrideComponent(MyComp, {set: {template}});\n+    const fixture = TestBed.createComponent(MyComp);\n \n-      const el = fixture.nativeElement;\n-      expect(el).toHaveText('foo');\n-    });\n+    fixture.detectChanges();\n \n-    modifiedInIvy('FW-678: ivy generates different DOM structure for <ng-container>')\n-        .it('should be rendered as comment with children as siblings', () => {\n-          const template = '<ng-container><p></p></ng-container>';\n-          TestBed.overrideComponent(MyComp, {set: {template}});\n-          const fixture = TestBed.createComponent(MyComp);\n-\n-          fixture.detectChanges();\n-\n-          const el = fixture.nativeElement;\n-          const children = el.childNodes;\n-          expect(children.length).toBe(2);\n-          expect(isCommentNode(children[0])).toBe(true);\n-          expect((children[1] as Element).tagName.toUpperCase()).toEqual('P');\n-        });\n-\n-    modifiedInIvy('FW-678: ivy generates different DOM structure for <ng-container>')\n-        .it('should support nesting', () => {\n-          const template =\n-              '<ng-container>1</ng-container><ng-container><ng-container>2</ng-container></ng-container>';\n-          TestBed.overrideComponent(MyComp, {set: {template}});\n-          const fixture = TestBed.createComponent(MyComp);\n-\n-          fixture.detectChanges();\n-\n-          const el = fixture.nativeElement;\n-          const children = el.childNodes;\n-          expect(children.length).toBe(5);\n-          expect(isCommentNode(children[0])).toBe(true);\n-          expect(children[1]).toHaveText('1');\n-          expect(isCommentNode(children[2])).toBe(true);\n-          expect(isCommentNode(children[3])).toBe(true);\n-          expect(children[4]).toHaveText('2');\n-        });\n-\n-    modifiedInIvy('FW-678: ivy generates different DOM structure for <ng-container>')\n-        .it('should group inner nodes', () => {\n-          const template = '<ng-container *ngIf=\"ctxBoolProp\"><p></p><b></b></ng-container>';\n-          TestBed.overrideComponent(MyComp, {set: {template}});\n-          const fixture = TestBed.createComponent(MyComp);\n-\n-          fixture.componentInstance.ctxBoolProp = true;\n-          fixture.detectChanges();\n-\n-          const el = fixture.nativeElement;\n-          const children = el.childNodes;\n-\n-          expect(children.length).toBe(4);\n-          // ngIf anchor\n-          expect(isCommentNode(children[0])).toBe(true);\n-          // ng-container anchor\n-          expect(isCommentNode(children[1])).toBe(true);\n-          expect((children[2] as Element).tagName.toUpperCase()).toEqual('P');\n-          expect((children[3] as Element).tagName.toUpperCase()).toEqual('B');\n-\n-          fixture.componentInstance.ctxBoolProp = false;\n-          fixture.detectChanges();\n-\n-          expect(children.length).toBe(1);\n-          expect(isCommentNode(children[0])).toBe(true);\n-        });\n-\n-    it('should work with static content projection', () => {\n-      const template = `<simple><ng-container><p>1</p><p>2</p></ng-container></simple>`;\n-      TestBed.overrideComponent(MyComp, {set: {template}});\n-      const fixture = TestBed.createComponent(MyComp);\n-\n-      fixture.detectChanges();\n-\n-      const el = fixture.nativeElement;\n-      expect(el).toHaveText('SIMPLE(12)');\n-    });\n+    const el = fixture.nativeElement;\n+    expect(el).toHaveText('foo');\n+  });\n \n-    it('should support injecting the container from children', () => {\n-      const template = `<ng-container [text]=\"'container'\"><p></p></ng-container>`;\n-      TestBed.overrideComponent(MyComp, {set: {template}});\n-      const fixture = TestBed.createComponent(MyComp);\n+  it('should work with static content projection', () => {\n+    const template = `<simple><ng-container><p>1</p><p>2</p></ng-container></simple>`;\n+    TestBed.overrideComponent(MyComp, {set: {template}});\n+    const fixture = TestBed.createComponent(MyComp);\n \n-      fixture.detectChanges();\n+    fixture.detectChanges();\n \n-      const dir = fixture.debugElement.children[0].injector.get(TextDirective);\n-      expect(dir).toBeAnInstanceOf(TextDirective);\n-      expect(dir.text).toEqual('container');\n-    });\n+    const el = fixture.nativeElement;\n+    expect(el).toHaveText('SIMPLE(12)');\n+  });\n \n-    modifiedInIvy('Queries with descendants: true don\\'t descent into <ng-container>')\n-        .it('should contain all direct child directives in a <ng-container> (content dom)', () => {\n-          const template =\n-              '<needs-content-children #q><ng-container><div text=\"foo\"></div></ng-container></needs-content-children>';\n-          TestBed.overrideComponent(MyComp, {set: {template}});\n-          const fixture = TestBed.createComponent(MyComp);\n+  it('should support injecting the container from children', () => {\n+    const template = `<ng-container [text]=\"'container'\"><p></p></ng-container>`;\n+    TestBed.overrideComponent(MyComp, {set: {template}});\n+    const fixture = TestBed.createComponent(MyComp);\n \n-          fixture.detectChanges();\n-          const q = fixture.debugElement.children[0].references!['q'];\n-          fixture.detectChanges();\n+    fixture.detectChanges();\n \n-          expect(q.textDirChildren.length).toEqual(1);\n-          expect(q.numberOfChildrenAfterContentInit).toEqual(1);\n-        });\n+    const dir = fixture.debugElement.children[0].injector.get(TextDirective);\n+    expect(dir).toBeAnInstanceOf(TextDirective);\n+    expect(dir.text).toEqual('container');\n+  });\n \n-    it('should contain all child directives in a <ng-container> (view dom)', () => {\n-      const template = '<needs-view-children #q></needs-view-children>';\n-      TestBed.overrideComponent(MyComp, {set: {template}});\n-      const fixture = TestBed.createComponent(MyComp);\n+  it('should contain all child directives in a <ng-container> (view dom)', () => {\n+    const template = '<needs-view-children #q></needs-view-children>';\n+    TestBed.overrideComponent(MyComp, {set: {template}});\n+    const fixture = TestBed.createComponent(MyComp);\n \n-      fixture.detectChanges();\n-      const q = fixture.debugElement.children[0].references!['q'];\n-      fixture.detectChanges();\n+    fixture.detectChanges();\n+    const q = fixture.debugElement.children[0].references!['q'];\n+    fixture.detectChanges();\n \n-      expect(q.textDirChildren.length).toEqual(1);\n-      expect(q.numberOfChildrenAfterViewInit).toEqual(1);\n-    });\n+    expect(q.textDirChildren.length).toEqual(1);\n+    expect(q.numberOfChildrenAfterViewInit).toEqual(1);\n   });\n-}\n+});\n \n @Directive({selector: '[text]'})\n class TextDirective {"
        },
        {
            "sha": "40e919e8f608b3e05a1b95ef2fc9f82281a00b61",
            "filename": "packages/core/test/linker/ng_module_integration_spec.ts",
            "status": "modified",
            "additions": 1006,
            "deletions": 1111,
            "changes": 2117,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fng_module_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fng_module_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Fng_module_integration_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -6,33 +6,19 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {ANALYZE_FOR_ENTRY_COMPONENTS, Compiler, Component, ComponentFactoryResolver, CUSTOM_ELEMENTS_SCHEMA, Directive, forwardRef, getModuleFactory, getNgModuleById, HostBinding, Inject, Injectable, InjectionToken, Injector, Input, NgModule, NgModuleRef, Optional, Pipe, Provider, Self, Type, ɵivyEnabled as ivyEnabled, ɵɵdefineNgModule as defineNgModule} from '@angular/core';\n+import {ANALYZE_FOR_ENTRY_COMPONENTS, Compiler, Component, ComponentFactoryResolver, CUSTOM_ELEMENTS_SCHEMA, Directive, forwardRef, getModuleFactory, getNgModuleById, HostBinding, Inject, Injectable, InjectionToken, Injector, Input, NgModule, NgModuleRef, Optional, Pipe, Provider, Self, Type, ɵɵdefineNgModule as defineNgModule} from '@angular/core';\n import {ɵɵdefineInjectable} from '@angular/core/src/di/interface/defs';\n import {NgModuleType} from '@angular/core/src/render3';\n import {getNgModuleDef} from '@angular/core/src/render3/definition';\n-import {ComponentFixture, inject, TestBed} from '@angular/core/testing';\n+import {ComponentFixture, inject} from '@angular/core/testing';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {modifiedInIvy, obsoleteInIvy, onlyInIvy} from '@angular/private/testing';\n \n import {InternalNgModuleRef, NgModuleFactory} from '../../src/linker/ng_module_factory';\n import {clearModulesForTest} from '../../src/linker/ng_module_factory_registration';\n import {stringify} from '../../src/util/stringify';\n \n class Engine {}\n \n-class BrokenEngine {\n-  constructor() {\n-    throw new Error('Broken Engine');\n-  }\n-}\n-\n-class DashboardSoftware {}\n-\n-@Injectable()\n-class Dashboard {\n-  constructor(software: DashboardSoftware) {}\n-}\n-\n class TurboEngine extends Engine {}\n \n const CARS = new InjectionToken<Car[]>('Cars');\n@@ -46,11 +32,6 @@ class CarWithOptionalEngine {\n   constructor(@Optional() public engine: Engine) {}\n }\n \n-@Injectable()\n-class CarWithDashboard {\n-  constructor(public engine: Engine, public dashboard: Dashboard) {}\n-}\n-\n @Injectable()\n class SportsCar extends Car {\n   constructor(engine: Engine) {\n@@ -72,8 +53,6 @@ class NoAnnotations {\n   constructor(secretDependency: any) {}\n }\n \n-function factoryFn(a: any) {}\n-\n @Component({selector: 'comp', template: ''})\n class SomeComp {\n }\n@@ -95,1370 +74,1286 @@ class SomePipe {\n class CompUsingModuleDirectiveAndPipe {\n }\n \n-{\n-  if (ivyEnabled) {\n-    describe('ivy', () => {\n-      declareTests();\n-    });\n-  } else {\n-    describe('jit', () => {\n-      declareTests({useJit: true});\n-    });\n-    describe('no jit', () => {\n-      declareTests({useJit: false});\n-    });\n+describe('NgModule', () => {\n+  let compiler: Compiler;\n+  let injector: Injector;\n+\n+  beforeEach(inject([Compiler, Injector], (_compiler: Compiler, _injector: Injector) => {\n+    compiler = _compiler;\n+    injector = _injector;\n+  }));\n+\n+  function createModuleFactory<T>(moduleType: Type<T>): NgModuleFactory<T> {\n+    return compiler.compileModuleSync(moduleType);\n   }\n-}\n \n-function declareTests(config?: {useJit: boolean}) {\n-  describe('NgModule', () => {\n-    let compiler: Compiler;\n-    let injector: Injector;\n+  function createModule<T>(moduleType: Type<T>, parentInjector?: Injector|null): NgModuleRef<T> {\n+    // Read the `ngModuleDef` to cause it to be compiled and any errors thrown.\n+    getNgModuleDef(moduleType);\n+    return createModuleFactory(moduleType).create(parentInjector || null);\n+  }\n+\n+  function createComp<T>(compType: Type<T>, moduleType: Type<any>): ComponentFixture<T> {\n+    const componentDef = (compType as any).ɵcmp;\n+    if (componentDef) {\n+      // Since we avoid Components/Directives/Pipes recompiling in case there are no overrides, we\n+      // may face a problem where previously compiled defs available to a given\n+      // Component/Directive are cached in TView and may become stale (in case any of these defs\n+      // gets recompiled). In order to avoid this problem, we force fresh TView to be created.\n+      componentDef.TView = null;\n+    }\n+\n+    const ngModule = createModule(moduleType, injector);\n \n-    beforeEach(() => {\n-      TestBed.configureCompiler(config || {});\n+    const cf = ngModule.componentFactoryResolver.resolveComponentFactory(compType)!;\n+\n+    const comp = cf.create(Injector.NULL);\n+\n+    return new ComponentFixture(comp, null!, false);\n+  }\n+\n+  describe('errors', () => {\n+    it('should error when exporting a directive that was neither declared nor imported', () => {\n+      @NgModule({exports: [SomeDirective]})\n+      class SomeModule {\n+      }\n+\n+      expect(() => createModule(SomeModule))\n+          .toThrowError(`Can't export directive ${stringify(SomeDirective)} from ${\n+              stringify(SomeModule)} as it was neither declared nor imported!`);\n     });\n \n-    beforeEach(inject([Compiler, Injector], (_compiler: Compiler, _injector: Injector) => {\n-      compiler = _compiler;\n-      injector = _injector;\n-    }));\n+    it('should error when exporting a pipe that was neither declared nor imported', () => {\n+      @NgModule({exports: [SomePipe]})\n+      class SomeModule {\n+      }\n \n-    function createModuleFactory<T>(moduleType: Type<T>): NgModuleFactory<T> {\n-      return compiler.compileModuleSync(moduleType);\n-    }\n+      expect(() => createModule(SomeModule))\n+          .toThrowError(`Can't export pipe ${stringify(SomePipe)} from ${\n+              stringify(SomeModule)} as it was neither declared nor imported!`);\n+    });\n \n-    function createModule<T>(moduleType: Type<T>, parentInjector?: Injector|null): NgModuleRef<T> {\n-      // Read the `ngModuleDef` to cause it to be compiled and any errors thrown.\n-      getNgModuleDef(moduleType);\n-      return createModuleFactory(moduleType).create(parentInjector || null);\n-    }\n+    it('should error if a directive is declared in more than 1 module', () => {\n+      @NgModule({declarations: [SomeDirective]})\n+      class Module1 {\n+      }\n \n-    function createComp<T>(compType: Type<T>, moduleType: Type<any>): ComponentFixture<T> {\n-      const componentDef = (compType as any).ɵcmp;\n-      if (componentDef) {\n-        // Since we avoid Components/Directives/Pipes recompiling in case there are no overrides, we\n-        // may face a problem where previously compiled defs available to a given\n-        // Component/Directive are cached in TView and may become stale (in case any of these defs\n-        // gets recompiled). In order to avoid this problem, we force fresh TView to be created.\n-        componentDef.TView = null;\n+      @NgModule({declarations: [SomeDirective]})\n+      class Module2 {\n       }\n \n-      const ngModule = createModule(moduleType, injector);\n+      createModule(Module1);\n+\n+      expect(() => createModule(Module2))\n+          .toThrowError(\n+              `Type ${stringify(SomeDirective)} is part of the declarations of 2 modules: ${\n+                  stringify(Module1)} and ${stringify(Module2)}! ` +\n+              `Please consider moving ${stringify(SomeDirective)} to a higher module that imports ${\n+                  stringify(Module1)} and ${stringify(Module2)}. ` +\n+              `You can also create a new NgModule that exports and includes ${\n+                  stringify(SomeDirective)} then import that NgModule in ${\n+                  stringify(Module1)} and ${stringify(Module2)}.`);\n+    });\n \n-      const cf = ngModule.componentFactoryResolver.resolveComponentFactory(compType)!;\n+    it('should error if a directive is declared in more than 1 module also if the module declaring it is imported',\n+       () => {\n+         @NgModule({declarations: [SomeDirective], exports: [SomeDirective]})\n+         class Module1 {\n+         }\n+\n+         @NgModule({declarations: [SomeDirective], imports: [Module1]})\n+         class Module2 {\n+         }\n+\n+         expect(() => createModule(Module2))\n+             .toThrowError(\n+                 `Type ${stringify(SomeDirective)} is part of the declarations of 2 modules: ${\n+                     stringify(Module1)} and ${stringify(Module2)}! ` +\n+                 `Please consider moving ${\n+                     stringify(SomeDirective)} to a higher module that imports ${\n+                     stringify(Module1)} and ${stringify(Module2)}. ` +\n+                 `You can also create a new NgModule that exports and includes ${\n+                     stringify(SomeDirective)} then import that NgModule in ${\n+                     stringify(Module1)} and ${stringify(Module2)}.`);\n+       });\n+\n+    it('should error if a pipe is declared in more than 1 module', () => {\n+      @NgModule({declarations: [SomePipe]})\n+      class Module1 {\n+      }\n \n-      const comp = cf.create(Injector.NULL);\n+      @NgModule({declarations: [SomePipe]})\n+      class Module2 {\n+      }\n \n-      return new ComponentFixture(comp, null!, false);\n-    }\n+      createModule(Module1);\n+\n+      expect(() => createModule(Module2))\n+          .toThrowError(\n+              `Type ${stringify(SomePipe)} is part of the declarations of 2 modules: ${\n+                  stringify(Module1)} and ${stringify(Module2)}! ` +\n+              `Please consider moving ${stringify(SomePipe)} to a higher module that imports ${\n+                  stringify(Module1)} and ${stringify(Module2)}. ` +\n+              `You can also create a new NgModule that exports and includes ${\n+                  stringify(SomePipe)} then import that NgModule in ${stringify(Module1)} and ${\n+                  stringify(Module2)}.`);\n+    });\n \n-    describe('errors', () => {\n-      it('should error when exporting a directive that was neither declared nor imported', () => {\n-        @NgModule({exports: [SomeDirective]})\n-        class SomeModule {\n-        }\n+    it('should error if a pipe is declared in more than 1 module also if the module declaring it is imported',\n+       () => {\n+         @NgModule({declarations: [SomePipe], exports: [SomePipe]})\n+         class Module1 {\n+         }\n+\n+         @NgModule({declarations: [SomePipe], imports: [Module1]})\n+         class Module2 {\n+         }\n+\n+         expect(() => createModule(Module2))\n+             .toThrowError(\n+                 `Type ${stringify(SomePipe)} is part of the declarations of 2 modules: ${\n+                     stringify(Module1)} and ${stringify(Module2)}! ` +\n+                 `Please consider moving ${stringify(SomePipe)} to a higher module that imports ${\n+                     stringify(Module1)} and ${stringify(Module2)}. ` +\n+                 `You can also create a new NgModule that exports and includes ${\n+                     stringify(SomePipe)} then import that NgModule in ${stringify(Module1)} and ${\n+                     stringify(Module2)}.`);\n+       });\n+  });\n \n-        expect(() => createModule(SomeModule))\n-            .toThrowError(`Can't export directive ${stringify(SomeDirective)} from ${\n-                stringify(SomeModule)} as it was neither declared nor imported!`);\n-      });\n+  describe('schemas', () => {\n+    it('should error on unknown bound properties on custom elements by default', () => {\n+      @Component({template: '<div [someUnknownProp]=\"true\"></div>'})\n+      class ComponentUsingInvalidProperty {\n+      }\n \n-      it('should error when exporting a pipe that was neither declared nor imported', () => {\n-        @NgModule({exports: [SomePipe]})\n-        class SomeModule {\n-        }\n+      @NgModule({declarations: [ComponentUsingInvalidProperty]})\n+      class SomeModule {\n+      }\n \n-        expect(() => createModule(SomeModule))\n-            .toThrowError(`Can't export pipe ${stringify(SomePipe)} from ${\n-                stringify(SomeModule)} as it was neither declared nor imported!`);\n-      });\n+      const spy = spyOn(console, 'error');\n+      const fixture = createComp(ComponentUsingInvalidProperty, SomeModule);\n+      fixture.detectChanges();\n+      expect(spy.calls.mostRecent().args[0]).toMatch(/Can't bind to 'someUnknownProp'/);\n+    });\n \n-      it('should error if a directive is declared in more than 1 module', () => {\n-        @NgModule({declarations: [SomeDirective]})\n-        class Module1 {\n-        }\n+    it('should not error on unknown bound properties on custom elements when using the CUSTOM_ELEMENTS_SCHEMA',\n+       () => {\n+         @Component({template: '<some-element [someUnknownProp]=\"true\"></some-element>'})\n+         class ComponentUsingInvalidProperty {\n+         }\n+\n+         @NgModule({\n+           schemas: [CUSTOM_ELEMENTS_SCHEMA],\n+           declarations: [ComponentUsingInvalidProperty],\n+\n+           // Note that we need to add the component to `entryComponents`, because of the\n+           // `createComp` call below. In Ivy the property validation happens during the\n+           //  update phase so we need to create the component, in order for it to run.\n+           entryComponents: [ComponentUsingInvalidProperty]\n+         })\n+         class SomeModule {\n+         }\n+\n+         expect(() => {\n+           const fixture = createComp(ComponentUsingInvalidProperty, SomeModule);\n+           fixture.detectChanges();\n+         }).not.toThrow();\n+       });\n+  });\n \n-        @NgModule({declarations: [SomeDirective]})\n-        class Module2 {\n-        }\n+  describe('id', () => {\n+    const token = 'myid';\n \n-        createModule(Module1);\n+    afterEach(() => clearModulesForTest());\n \n-        expect(() => createModule(Module2))\n-            .toThrowError(\n-                `Type ${stringify(SomeDirective)} is part of the declarations of 2 modules: ${\n-                    stringify(Module1)} and ${stringify(Module2)}! ` +\n-                `Please consider moving ${\n-                    stringify(SomeDirective)} to a higher module that imports ${\n-                    stringify(Module1)} and ${stringify(Module2)}. ` +\n-                `You can also create a new NgModule that exports and includes ${\n-                    stringify(SomeDirective)} then import that NgModule in ${\n-                    stringify(Module1)} and ${stringify(Module2)}.`);\n-      });\n+    it('should register loaded modules', () => {\n+      @NgModule({id: token})\n+      class SomeModule {\n+      }\n+      createModule(SomeModule);\n \n-      it('should error if a directive is declared in more than 1 module also if the module declaring it is imported',\n-         () => {\n-           @NgModule({declarations: [SomeDirective], exports: [SomeDirective]})\n-           class Module1 {\n-           }\n+      const moduleType = getNgModuleById(token);\n+      expect(moduleType).toBeTruthy();\n+      expect(moduleType).toBe(SomeModule as NgModuleType);\n \n-           @NgModule({declarations: [SomeDirective], imports: [Module1]})\n-           class Module2 {\n-           }\n+      const factory = getModuleFactory(token);\n+      expect(factory).toBeTruthy();\n+      expect(factory.moduleType).toBe(SomeModule);\n+    });\n \n-           expect(() => createModule(Module2))\n-               .toThrowError(\n-                   `Type ${stringify(SomeDirective)} is part of the declarations of 2 modules: ${\n-                       stringify(Module1)} and ${stringify(Module2)}! ` +\n-                   `Please consider moving ${\n-                       stringify(SomeDirective)} to a higher module that imports ${\n-                       stringify(Module1)} and ${stringify(Module2)}. ` +\n-                   `You can also create a new NgModule that exports and includes ${\n-                       stringify(SomeDirective)} then import that NgModule in ${\n-                       stringify(Module1)} and ${stringify(Module2)}.`);\n-         });\n+    it('should throw when registering a duplicate module', () => {\n+      @NgModule({id: token})\n+      class SomeModule {\n+      }\n+      createModule(SomeModule);\n+      expect(() => {\n+        @NgModule({id: token})\n+        class SomeOtherModule {\n+        }\n+        createModule(SomeOtherModule);\n+      }).toThrowError(/Duplicate module registered/);\n+    });\n \n-      it('should error if a pipe is declared in more than 1 module', () => {\n-        @NgModule({declarations: [SomePipe]})\n-        class Module1 {\n+    it('should not throw immediately if two modules have the same id', () => {\n+      expect(() => {\n+        @NgModule({id: 'some-module'})\n+        class ModuleA {\n         }\n \n-        @NgModule({declarations: [SomePipe]})\n-        class Module2 {\n+        @NgModule({id: 'some-module'})\n+        class ModuleB {\n         }\n+      }).not.toThrow();\n+    });\n \n-        createModule(Module1);\n+    it('should register a module even if not importing the .ngfactory file or calling create()',\n+       () => {\n+         class ChildModule {\n+           static ɵmod = defineNgModule({\n+             type: ChildModule,\n+             id: 'child',\n+           });\n+         }\n \n-        expect(() => createModule(Module2))\n-            .toThrowError(\n-                `Type ${stringify(SomePipe)} is part of the declarations of 2 modules: ${\n-                    stringify(Module1)} and ${stringify(Module2)}! ` +\n-                `Please consider moving ${stringify(SomePipe)} to a higher module that imports ${\n-                    stringify(Module1)} and ${stringify(Module2)}. ` +\n-                `You can also create a new NgModule that exports and includes ${\n-                    stringify(SomePipe)} then import that NgModule in ${stringify(Module1)} and ${\n-                    stringify(Module2)}.`);\n-      });\n+         class Module {\n+           static ɵmod = defineNgModule({\n+             type: Module,\n+             id: 'test',\n+             imports: [ChildModule],\n+           });\n+         }\n \n-      it('should error if a pipe is declared in more than 1 module also if the module declaring it is imported',\n-         () => {\n-           @NgModule({declarations: [SomePipe], exports: [SomePipe]})\n-           class Module1 {\n-           }\n+         // Verify that we can retrieve NgModule factory by id.\n+         createModuleFactory(ChildModule);\n+         expect(getModuleFactory('child')).toBeAnInstanceOf(NgModuleFactory);\n \n-           @NgModule({declarations: [SomePipe], imports: [Module1]})\n-           class Module2 {\n-           }\n+         // Verify that we can also retrieve NgModule class by id.\n+         const moduleType = getNgModuleById('child');\n+         expect(moduleType).toBeTruthy();\n+         expect(moduleType).toBe(ChildModule as NgModuleType);\n+       });\n+  });\n \n-           expect(() => createModule(Module2))\n-               .toThrowError(\n-                   `Type ${stringify(SomePipe)} is part of the declarations of 2 modules: ${\n-                       stringify(Module1)} and ${stringify(Module2)}! ` +\n-                   `Please consider moving ${stringify(SomePipe)} to a higher module that imports ${\n-                       stringify(Module1)} and ${stringify(Module2)}. ` +\n-                   `You can also create a new NgModule that exports and includes ${\n-                       stringify(SomePipe)} then import that NgModule in ${\n-                       stringify(Module1)} and ${stringify(Module2)}.`);\n-         });\n+  describe('entryComponents', () => {\n+    it('should create ComponentFactories in root modules', () => {\n+      @NgModule({declarations: [SomeComp], entryComponents: [SomeComp]})\n+      class SomeModule {\n+      }\n+\n+      const ngModule = createModule(SomeModule);\n+      expect(ngModule.componentFactoryResolver.resolveComponentFactory(SomeComp)!.componentType)\n+          .toBe(SomeComp);\n+      expect(ngModule.injector.get(ComponentFactoryResolver)\n+                 .resolveComponentFactory(SomeComp)\n+                 .componentType)\n+          .toBe(SomeComp);\n     });\n \n-    describe('schemas', () => {\n-      modifiedInIvy('Unknown property error thrown during update mode, not creation mode')\n-          .it('should error on unknown bound properties on custom elements by default', () => {\n-            @Component({template: '<some-element [someUnknownProp]=\"true\"></some-element>'})\n-            class ComponentUsingInvalidProperty {\n-            }\n+    it('should throw if we cannot find a module associated with a module-level entryComponent', () => {\n+      @Component({template: ''})\n+      class SomeCompWithEntryComponents {\n+      }\n \n-            @NgModule({declarations: [ComponentUsingInvalidProperty]})\n-            class SomeModule {\n-            }\n+      @NgModule({declarations: [], entryComponents: [SomeCompWithEntryComponents]})\n+      class SomeModule {\n+      }\n \n-            expect(() => createModule(SomeModule)).toThrowError(/Can't bind to 'someUnknownProp'/);\n-          });\n+      expect(() => createModule(SomeModule))\n+          .toThrowError(\n+              'Component SomeCompWithEntryComponents is not part of any NgModule or the module has not been imported into your module.');\n+    });\n \n-      onlyInIvy('Unknown property error logged, instead of throwing')\n-          .it('should error on unknown bound properties on custom elements by default', () => {\n-            @Component({template: '<div [someUnknownProp]=\"true\"></div>'})\n-            class ComponentUsingInvalidProperty {\n-            }\n+    it('should throw if we cannot find a module associated with a component-level entryComponent',\n+       () => {\n+         @Component({template: '', entryComponents: [SomeComp]})\n+         class SomeCompWithEntryComponents {\n+         }\n+\n+         @NgModule({declarations: [SomeCompWithEntryComponents]})\n+         class SomeModule {\n+         }\n+\n+         expect(() => createModule(SomeModule))\n+             .toThrowError(\n+                 'Component SomeComp is not part of any NgModule or the module has not been imported into your module.');\n+       });\n+\n+    it('should create ComponentFactories via ANALYZE_FOR_ENTRY_COMPONENTS', () => {\n+      @NgModule({\n+        declarations: [SomeComp],\n+        providers: [{\n+          provide: ANALYZE_FOR_ENTRY_COMPONENTS,\n+          multi: true,\n+          useValue: [{a: 'b', component: SomeComp}]\n+        }]\n+      })\n+      class SomeModule {\n+      }\n \n-            @NgModule({declarations: [ComponentUsingInvalidProperty]})\n-            class SomeModule {\n-            }\n+      const ngModule = createModule(SomeModule);\n+      expect(ngModule.componentFactoryResolver.resolveComponentFactory(SomeComp)!.componentType)\n+          .toBe(SomeComp);\n+      expect(ngModule.injector.get(ComponentFactoryResolver)\n+                 .resolveComponentFactory(SomeComp)\n+                 .componentType)\n+          .toBe(SomeComp);\n+    });\n \n-            const spy = spyOn(console, 'error');\n-            const fixture = createComp(ComponentUsingInvalidProperty, SomeModule);\n-            fixture.detectChanges();\n-            expect(spy.calls.mostRecent().args[0]).toMatch(/Can't bind to 'someUnknownProp'/);\n-          });\n+    it('should create ComponentFactories in imported modules', () => {\n+      @NgModule({declarations: [SomeComp], entryComponents: [SomeComp]})\n+      class SomeImportedModule {\n+      }\n \n-      it('should not error on unknown bound properties on custom elements when using the CUSTOM_ELEMENTS_SCHEMA',\n-         () => {\n-           @Component({template: '<some-element [someUnknownProp]=\"true\"></some-element>'})\n-           class ComponentUsingInvalidProperty {\n-           }\n+      @NgModule({imports: [SomeImportedModule]})\n+      class SomeModule {\n+      }\n \n-           @NgModule({\n-             schemas: [CUSTOM_ELEMENTS_SCHEMA],\n-             declarations: [ComponentUsingInvalidProperty],\n+      const ngModule = createModule(SomeModule);\n+      expect(ngModule.componentFactoryResolver.resolveComponentFactory(SomeComp)!.componentType)\n+          .toBe(SomeComp);\n+      expect(ngModule.injector.get(ComponentFactoryResolver)\n+                 .resolveComponentFactory(SomeComp)\n+                 .componentType)\n+          .toBe(SomeComp);\n+    });\n \n-             // Note that we need to add the component to `entryComponents`, because of the\n-             // `createComp` call below. In Ivy the property validation happens during the\n-             //  update phase so we need to create the component, in order for it to run.\n-             entryComponents: [ComponentUsingInvalidProperty]\n-           })\n-           class SomeModule {\n-           }\n+    it('should create ComponentFactories if the component was imported', () => {\n+      @NgModule({declarations: [SomeComp], exports: [SomeComp]})\n+      class SomeImportedModule {\n+      }\n \n-           expect(() => {\n-             const fixture = createComp(ComponentUsingInvalidProperty, SomeModule);\n-             fixture.detectChanges();\n-           }).not.toThrow();\n-         });\n+      @NgModule({imports: [SomeImportedModule], entryComponents: [SomeComp]})\n+      class SomeModule {\n+      }\n+\n+      const ngModule = createModule(SomeModule);\n+      expect(ngModule.componentFactoryResolver.resolveComponentFactory(SomeComp)!.componentType)\n+          .toBe(SomeComp);\n+      expect(ngModule.injector.get(ComponentFactoryResolver)\n+                 .resolveComponentFactory(SomeComp)\n+                 .componentType)\n+          .toBe(SomeComp);\n     });\n+  });\n \n-    describe('id', () => {\n-      const token = 'myid';\n+  describe('bootstrap components', () => {\n+    it('should create ComponentFactories', () => {\n+      @NgModule({declarations: [SomeComp], bootstrap: [SomeComp]})\n+      class SomeModule {\n+      }\n \n-      afterEach(() => clearModulesForTest());\n+      const ngModule = createModule(SomeModule);\n+      expect(ngModule.componentFactoryResolver.resolveComponentFactory(SomeComp)!.componentType)\n+          .toBe(SomeComp);\n+    });\n \n-      it('should register loaded modules', () => {\n-        @NgModule({id: token})\n+    it('should store the ComponentFactories in the NgModuleInjector', () => {\n+      @NgModule({declarations: [SomeComp], bootstrap: [SomeComp]})\n+      class SomeModule {\n+      }\n+\n+      const ngModule = <InternalNgModuleRef<any>>createModule(SomeModule);\n+      expect(ngModule._bootstrapComponents.length).toBe(1);\n+      expect(ngModule._bootstrapComponents[0]).toBe(SomeComp);\n+    });\n+  });\n+\n+  describe('directives and pipes', () => {\n+    describe('declarations', () => {\n+      it('should be supported in root modules', () => {\n+        @NgModule({\n+          declarations: [CompUsingModuleDirectiveAndPipe, SomeDirective, SomePipe],\n+          entryComponents: [CompUsingModuleDirectiveAndPipe]\n+        })\n         class SomeModule {\n         }\n-        createModule(SomeModule);\n \n-        if (ivyEnabled) {\n-          const moduleType = getNgModuleById(token);\n-          expect(moduleType).toBeTruthy();\n-          expect(moduleType).toBe(SomeModule as NgModuleType);\n-        } else {\n-          // ViewEngine doesn't support this call, expect it to throw.\n-          expect(() => getNgModuleById(token))\n-              .toThrowError(`ViewEngine doesn't support retrieving NgModule classes by id`);\n-        }\n+        const compFixture = createComp(CompUsingModuleDirectiveAndPipe, SomeModule);\n \n-        const factory = getModuleFactory(token);\n-        expect(factory).toBeTruthy();\n-        expect(factory.moduleType).toBe(SomeModule);\n+        compFixture.detectChanges();\n+        expect(compFixture.debugElement.children[0].properties['title'])\n+            .toBe('transformed someValue');\n       });\n \n-      it('should throw when registering a duplicate module', () => {\n-        @NgModule({id: token})\n-        class SomeModule {\n+      it('should be supported in imported modules', () => {\n+        @NgModule({\n+          declarations: [CompUsingModuleDirectiveAndPipe, SomeDirective, SomePipe],\n+          entryComponents: [CompUsingModuleDirectiveAndPipe]\n+        })\n+        class SomeImportedModule {\n         }\n-        createModule(SomeModule);\n-        expect(() => {\n-          @NgModule({id: token})\n-          class SomeOtherModule {\n-          }\n-          createModule(SomeOtherModule);\n-        }).toThrowError(/Duplicate module registered/);\n-      });\n \n-      it('should not throw immediately if two modules have the same id', () => {\n-        expect(() => {\n-          @NgModule({id: 'some-module'})\n-          class ModuleA {\n-          }\n+        @NgModule({imports: [SomeImportedModule]})\n+        class SomeModule {\n+        }\n \n-          @NgModule({id: 'some-module'})\n-          class ModuleB {\n-          }\n-        }).not.toThrow();\n+        const compFixture = createComp(CompUsingModuleDirectiveAndPipe, SomeModule);\n+        compFixture.detectChanges();\n+        expect(compFixture.debugElement.children[0].properties['title'])\n+            .toBe('transformed someValue');\n       });\n \n-      onlyInIvy('VE does not allow use of NgModuleFactory without importing the .ngfactory')\n-          .it('should register a module even if not importing the .ngfactory file or calling create()',\n-              () => {\n-                class ChildModule {\n-                  static ɵmod = defineNgModule({\n-                    type: ChildModule,\n-                    id: 'child',\n-                  });\n-                }\n-\n-                class Module {\n-                  static ɵmod = defineNgModule({\n-                    type: Module,\n-                    id: 'test',\n-                    imports: [ChildModule],\n-                  });\n-                }\n-\n-                // Verify that we can retrieve NgModule factory by id.\n-                createModuleFactory(ChildModule);\n-                expect(getModuleFactory('child')).toBeAnInstanceOf(NgModuleFactory);\n-\n-                // Verify that we can also retrieve NgModule class by id.\n-                const moduleType = getNgModuleById('child');\n-                expect(moduleType).toBeTruthy();\n-                expect(moduleType).toBe(ChildModule as NgModuleType);\n-              });\n-    });\n \n-    describe('entryComponents', () => {\n-      it('should create ComponentFactories in root modules', () => {\n-        @NgModule({declarations: [SomeComp], entryComponents: [SomeComp]})\n+      it('should be supported in nested components', () => {\n+        @Component({\n+          selector: 'parent',\n+          template: '<comp></comp>',\n+        })\n+        class ParentCompUsingModuleDirectiveAndPipe {\n+        }\n+\n+        @NgModule({\n+          declarations: [\n+            ParentCompUsingModuleDirectiveAndPipe, CompUsingModuleDirectiveAndPipe, SomeDirective,\n+            SomePipe\n+          ],\n+          entryComponents: [ParentCompUsingModuleDirectiveAndPipe]\n+        })\n         class SomeModule {\n         }\n \n-        const ngModule = createModule(SomeModule);\n-        expect(ngModule.componentFactoryResolver.resolveComponentFactory(SomeComp)!.componentType)\n-            .toBe(SomeComp);\n-        expect(ngModule.injector.get(ComponentFactoryResolver)\n-                   .resolveComponentFactory(SomeComp)\n-                   .componentType)\n-            .toBe(SomeComp);\n+        const compFixture = createComp(ParentCompUsingModuleDirectiveAndPipe, SomeModule);\n+        compFixture.detectChanges();\n+        expect(compFixture.debugElement.children[0].children[0].properties['title'])\n+            .toBe('transformed someValue');\n       });\n+    });\n \n-      it('should throw if we cannot find a module associated with a module-level entryComponent', () => {\n-        @Component({template: ''})\n-        class SomeCompWithEntryComponents {\n+    describe('import/export', () => {\n+      it('should support exported directives and pipes', () => {\n+        @NgModule({declarations: [SomeDirective, SomePipe], exports: [SomeDirective, SomePipe]})\n+        class SomeImportedModule {\n         }\n \n-        @NgModule({declarations: [], entryComponents: [SomeCompWithEntryComponents]})\n+        @NgModule({\n+          declarations: [CompUsingModuleDirectiveAndPipe],\n+          imports: [SomeImportedModule],\n+          entryComponents: [CompUsingModuleDirectiveAndPipe]\n+        })\n         class SomeModule {\n         }\n \n-        expect(() => createModule(SomeModule))\n-            .toThrowError(\n-                'Component SomeCompWithEntryComponents is not part of any NgModule or the module has not been imported into your module.');\n+\n+        const compFixture = createComp(CompUsingModuleDirectiveAndPipe, SomeModule);\n+        compFixture.detectChanges();\n+        expect(compFixture.debugElement.children[0].properties['title'])\n+            .toBe('transformed someValue');\n       });\n \n-      it('should throw if we cannot find a module associated with a component-level entryComponent',\n+      it('should support exported directives and pipes if the module is wrapped into an `ModuleWithProviders`',\n          () => {\n-           @Component({template: '', entryComponents: [SomeComp]})\n-           class SomeCompWithEntryComponents {\n+           @NgModule({declarations: [SomeDirective, SomePipe], exports: [SomeDirective, SomePipe]})\n+           class SomeImportedModule {\n            }\n \n-           @NgModule({declarations: [SomeCompWithEntryComponents]})\n+           @NgModule({\n+             declarations: [CompUsingModuleDirectiveAndPipe],\n+             imports: [{ngModule: SomeImportedModule}],\n+             entryComponents: [CompUsingModuleDirectiveAndPipe]\n+           })\n            class SomeModule {\n            }\n \n-           expect(() => createModule(SomeModule))\n-               .toThrowError(\n-                   'Component SomeComp is not part of any NgModule or the module has not been imported into your module.');\n+\n+           const compFixture = createComp(CompUsingModuleDirectiveAndPipe, SomeModule);\n+           compFixture.detectChanges();\n+           expect(compFixture.debugElement.children[0].properties['title'])\n+               .toBe('transformed someValue');\n          });\n \n-      it('should create ComponentFactories via ANALYZE_FOR_ENTRY_COMPONENTS', () => {\n-        @NgModule({\n-          declarations: [SomeComp],\n-          providers: [{\n-            provide: ANALYZE_FOR_ENTRY_COMPONENTS,\n-            multi: true,\n-            useValue: [{a: 'b', component: SomeComp}]\n-          }]\n-        })\n-        class SomeModule {\n+      it('should support reexported modules', () => {\n+        @NgModule({declarations: [SomeDirective, SomePipe], exports: [SomeDirective, SomePipe]})\n+        class SomeReexportedModule {\n         }\n \n-        const ngModule = createModule(SomeModule);\n-        expect(ngModule.componentFactoryResolver.resolveComponentFactory(SomeComp)!.componentType)\n-            .toBe(SomeComp);\n-        expect(ngModule.injector.get(ComponentFactoryResolver)\n-                   .resolveComponentFactory(SomeComp)\n-                   .componentType)\n-            .toBe(SomeComp);\n-      });\n-\n-      it('should create ComponentFactories in imported modules', () => {\n-        @NgModule({declarations: [SomeComp], entryComponents: [SomeComp]})\n+        @NgModule({exports: [SomeReexportedModule]})\n         class SomeImportedModule {\n         }\n \n-        @NgModule({imports: [SomeImportedModule]})\n+        @NgModule({\n+          declarations: [CompUsingModuleDirectiveAndPipe],\n+          imports: [SomeImportedModule],\n+          entryComponents: [CompUsingModuleDirectiveAndPipe]\n+        })\n         class SomeModule {\n         }\n \n-        const ngModule = createModule(SomeModule);\n-        expect(ngModule.componentFactoryResolver.resolveComponentFactory(SomeComp)!.componentType)\n-            .toBe(SomeComp);\n-        expect(ngModule.injector.get(ComponentFactoryResolver)\n-                   .resolveComponentFactory(SomeComp)\n-                   .componentType)\n-            .toBe(SomeComp);\n+        const compFixture = createComp(CompUsingModuleDirectiveAndPipe, SomeModule);\n+        compFixture.detectChanges();\n+        expect(compFixture.debugElement.children[0].properties['title'])\n+            .toBe('transformed someValue');\n       });\n \n-      it('should create ComponentFactories if the component was imported', () => {\n-        @NgModule({declarations: [SomeComp], exports: [SomeComp]})\n+      it('should support exporting individual directives of an imported module', () => {\n+        @NgModule({declarations: [SomeDirective, SomePipe], exports: [SomeDirective, SomePipe]})\n+        class SomeReexportedModule {\n+        }\n+\n+        @NgModule({imports: [SomeReexportedModule], exports: [SomeDirective, SomePipe]})\n         class SomeImportedModule {\n         }\n \n-        @NgModule({imports: [SomeImportedModule], entryComponents: [SomeComp]})\n+        @NgModule({\n+          declarations: [CompUsingModuleDirectiveAndPipe],\n+          imports: [SomeImportedModule],\n+          entryComponents: [CompUsingModuleDirectiveAndPipe]\n+        })\n         class SomeModule {\n         }\n \n-        const ngModule = createModule(SomeModule);\n-        expect(ngModule.componentFactoryResolver.resolveComponentFactory(SomeComp)!.componentType)\n-            .toBe(SomeComp);\n-        expect(ngModule.injector.get(ComponentFactoryResolver)\n-                   .resolveComponentFactory(SomeComp)\n-                   .componentType)\n-            .toBe(SomeComp);\n+        const compFixture = createComp(CompUsingModuleDirectiveAndPipe, SomeModule);\n+        compFixture.detectChanges();\n+        expect(compFixture.debugElement.children[0].properties['title'])\n+            .toBe('transformed someValue');\n       });\n-    });\n \n-    describe('bootstrap components', () => {\n-      it('should create ComponentFactories', () => {\n-        @NgModule({declarations: [SomeComp], bootstrap: [SomeComp]})\n-        class SomeModule {\n+      it('should not use non exported pipes of an imported module', () => {\n+        @NgModule({\n+          declarations: [SomePipe],\n+        })\n+        class SomeImportedModule {\n         }\n \n-        const ngModule = createModule(SomeModule);\n-        expect(ngModule.componentFactoryResolver.resolveComponentFactory(SomeComp)!.componentType)\n-            .toBe(SomeComp);\n-      });\n-\n-      it('should store the ComponentFactories in the NgModuleInjector', () => {\n-        @NgModule({declarations: [SomeComp], bootstrap: [SomeComp]})\n+        @NgModule({\n+          declarations: [CompUsingModuleDirectiveAndPipe],\n+          imports: [SomeImportedModule],\n+          entryComponents: [CompUsingModuleDirectiveAndPipe]\n+        })\n         class SomeModule {\n         }\n \n-        const ngModule = <InternalNgModuleRef<any>>createModule(SomeModule);\n-        expect(ngModule._bootstrapComponents.length).toBe(1);\n-        expect(ngModule._bootstrapComponents[0]).toBe(SomeComp);\n+        expect(() => createComp(CompUsingModuleDirectiveAndPipe, SomeModule))\n+            .toThrowError(/The pipe 'somePipe' could not be found/);\n       });\n     });\n+  });\n \n-    describe('directives and pipes', () => {\n-      describe('declarations', () => {\n-        it('should be supported in root modules', () => {\n-          @NgModule({\n-            declarations: [CompUsingModuleDirectiveAndPipe, SomeDirective, SomePipe],\n-            entryComponents: [CompUsingModuleDirectiveAndPipe]\n-          })\n-          class SomeModule {\n-          }\n \n-          const compFixture = createComp(CompUsingModuleDirectiveAndPipe, SomeModule);\n+  describe('providers', function() {\n+    let moduleType: any = null;\n \n-          compFixture.detectChanges();\n-          expect(compFixture.debugElement.children[0].properties['title'])\n-              .toBe('transformed someValue');\n-        });\n \n-        it('should be supported in imported modules', () => {\n-          @NgModule({\n-            declarations: [CompUsingModuleDirectiveAndPipe, SomeDirective, SomePipe],\n-            entryComponents: [CompUsingModuleDirectiveAndPipe]\n-          })\n-          class SomeImportedModule {\n-          }\n+    function createInjector(providers: Provider[], parent?: Injector|null): Injector {\n+      @NgModule({providers: providers})\n+      class SomeModule {\n+      }\n \n-          @NgModule({imports: [SomeImportedModule]})\n-          class SomeModule {\n-          }\n+      moduleType = SomeModule;\n \n-          const compFixture = createComp(CompUsingModuleDirectiveAndPipe, SomeModule);\n-          compFixture.detectChanges();\n-          expect(compFixture.debugElement.children[0].properties['title'])\n-              .toBe('transformed someValue');\n-        });\n+      return createModule(SomeModule, parent).injector;\n+    }\n \n+    it('should provide the module', () => {\n+      expect(createInjector([]).get(moduleType)).toBeAnInstanceOf(moduleType);\n+    });\n \n-        it('should be supported in nested components', () => {\n-          @Component({\n-            selector: 'parent',\n-            template: '<comp></comp>',\n-          })\n-          class ParentCompUsingModuleDirectiveAndPipe {\n-          }\n+    it('should instantiate a class without dependencies', () => {\n+      const injector = createInjector([Engine]);\n+      const engine = injector.get(Engine);\n \n-          @NgModule({\n-            declarations: [\n-              ParentCompUsingModuleDirectiveAndPipe, CompUsingModuleDirectiveAndPipe, SomeDirective,\n-              SomePipe\n-            ],\n-            entryComponents: [ParentCompUsingModuleDirectiveAndPipe]\n-          })\n-          class SomeModule {\n-          }\n+      expect(engine).toBeAnInstanceOf(Engine);\n+    });\n \n-          const compFixture = createComp(ParentCompUsingModuleDirectiveAndPipe, SomeModule);\n-          compFixture.detectChanges();\n-          expect(compFixture.debugElement.children[0].children[0].properties['title'])\n-              .toBe('transformed someValue');\n-        });\n-      });\n+    it('should resolve dependencies based on type information', () => {\n+      const injector = createInjector([Engine, Car]);\n+      const car = injector.get(Car);\n \n-      describe('import/export', () => {\n-        it('should support exported directives and pipes', () => {\n-          @NgModule({declarations: [SomeDirective, SomePipe], exports: [SomeDirective, SomePipe]})\n-          class SomeImportedModule {\n-          }\n+      expect(car).toBeAnInstanceOf(Car);\n+      expect(car.engine).toBeAnInstanceOf(Engine);\n+    });\n \n-          @NgModule({\n-            declarations: [CompUsingModuleDirectiveAndPipe],\n-            imports: [SomeImportedModule],\n-            entryComponents: [CompUsingModuleDirectiveAndPipe]\n-          })\n-          class SomeModule {\n-          }\n+    it('should resolve dependencies based on @Inject annotation', () => {\n+      const injector = createInjector([TurboEngine, Engine, CarWithInject]);\n+      const car = injector.get(CarWithInject);\n \n+      expect(car).toBeAnInstanceOf(CarWithInject);\n+      expect(car.engine).toBeAnInstanceOf(TurboEngine);\n+    });\n \n-          const compFixture = createComp(CompUsingModuleDirectiveAndPipe, SomeModule);\n-          compFixture.detectChanges();\n-          expect(compFixture.debugElement.children[0].properties['title'])\n-              .toBe('transformed someValue');\n-        });\n+    it('should throw when no type and not @Inject (class case)', () => {\n+      expect(() => createInjector([NoAnnotations]))\n+          .toThrowError('Can\\'t resolve all parameters for NoAnnotations: (?).');\n+    });\n \n-        it('should support exported directives and pipes if the module is wrapped into an `ModuleWithProviders`',\n-           () => {\n-             @NgModule(\n-                 {declarations: [SomeDirective, SomePipe], exports: [SomeDirective, SomePipe]})\n-             class SomeImportedModule {\n-             }\n-\n-             @NgModule({\n-               declarations: [CompUsingModuleDirectiveAndPipe],\n-               imports: [{ngModule: SomeImportedModule}],\n-               entryComponents: [CompUsingModuleDirectiveAndPipe]\n-             })\n-             class SomeModule {\n-             }\n-\n-\n-             const compFixture = createComp(CompUsingModuleDirectiveAndPipe, SomeModule);\n-             compFixture.detectChanges();\n-             expect(compFixture.debugElement.children[0].properties['title'])\n-                 .toBe('transformed someValue');\n-           });\n+    it('should cache instances', () => {\n+      const injector = createInjector([Engine]);\n \n-        it('should support reexported modules', () => {\n-          @NgModule({declarations: [SomeDirective, SomePipe], exports: [SomeDirective, SomePipe]})\n-          class SomeReexportedModule {\n-          }\n+      const e1 = injector.get(Engine);\n+      const e2 = injector.get(Engine);\n \n-          @NgModule({exports: [SomeReexportedModule]})\n-          class SomeImportedModule {\n-          }\n+      expect(e1).toBe(e2);\n+    });\n \n-          @NgModule({\n-            declarations: [CompUsingModuleDirectiveAndPipe],\n-            imports: [SomeImportedModule],\n-            entryComponents: [CompUsingModuleDirectiveAndPipe]\n-          })\n-          class SomeModule {\n-          }\n+    it('should provide to a value', () => {\n+      const injector = createInjector([{provide: Engine, useValue: 'fake engine'}]);\n \n-          const compFixture = createComp(CompUsingModuleDirectiveAndPipe, SomeModule);\n-          compFixture.detectChanges();\n-          expect(compFixture.debugElement.children[0].properties['title'])\n-              .toBe('transformed someValue');\n-        });\n+      const engine = injector.get(Engine);\n+      expect(engine).toEqual('fake engine');\n+    });\n \n-        it('should support exporting individual directives of an imported module', () => {\n-          @NgModule({declarations: [SomeDirective, SomePipe], exports: [SomeDirective, SomePipe]})\n-          class SomeReexportedModule {\n-          }\n+    it('should provide to a factory', () => {\n+      function sportsCarFactory(e: Engine) {\n+        return new SportsCar(e);\n+      }\n \n-          @NgModule({imports: [SomeReexportedModule], exports: [SomeDirective, SomePipe]})\n-          class SomeImportedModule {\n-          }\n+      const injector =\n+          createInjector([Engine, {provide: Car, useFactory: sportsCarFactory, deps: [Engine]}]);\n \n-          @NgModule({\n-            declarations: [CompUsingModuleDirectiveAndPipe],\n-            imports: [SomeImportedModule],\n-            entryComponents: [CompUsingModuleDirectiveAndPipe]\n-          })\n-          class SomeModule {\n-          }\n+      const car = injector.get(Car);\n+      expect(car).toBeAnInstanceOf(SportsCar);\n+      expect(car.engine).toBeAnInstanceOf(Engine);\n+    });\n \n-          const compFixture = createComp(CompUsingModuleDirectiveAndPipe, SomeModule);\n-          compFixture.detectChanges();\n-          expect(compFixture.debugElement.children[0].properties['title'])\n-              .toBe('transformed someValue');\n-        });\n+    it('should supporting provider to null', () => {\n+      const injector = createInjector([{provide: Engine, useValue: null}]);\n+      const engine = injector.get(Engine);\n+      expect(engine).toBeNull();\n+    });\n \n-        it('should not use non exported pipes of an imported module', () => {\n-          @NgModule({\n-            declarations: [SomePipe],\n-          })\n-          class SomeImportedModule {\n-          }\n+    it('should provide to an alias', () => {\n+      const injector = createInjector([\n+        Engine, {provide: SportsCar, useClass: SportsCar}, {provide: Car, useExisting: SportsCar}\n+      ]);\n \n-          @NgModule({\n-            declarations: [CompUsingModuleDirectiveAndPipe],\n-            imports: [SomeImportedModule],\n-            entryComponents: [CompUsingModuleDirectiveAndPipe]\n-          })\n-          class SomeModule {\n-          }\n+      const car = injector.get(Car);\n+      const sportsCar = injector.get(SportsCar);\n+      expect(car).toBeAnInstanceOf(SportsCar);\n+      expect(car).toBe(sportsCar);\n+    });\n \n-          expect(() => createComp(CompUsingModuleDirectiveAndPipe, SomeModule))\n-              .toThrowError(/The pipe 'somePipe' could not be found/);\n-        });\n+    it('should support multiProviders', () => {\n+      const injector = createInjector([\n+        Engine, {provide: CARS, useClass: SportsCar, multi: true},\n+        {provide: CARS, useClass: CarWithOptionalEngine, multi: true}\n+      ]);\n \n-        obsoleteInIvy('Ivy does not have a restriction on classes being exported')\n-            .it('should not use non exported directives of an imported module', () => {\n-              @NgModule({\n-                declarations: [SomeDirective],\n-              })\n-              class SomeImportedModule {\n-              }\n-\n-              @NgModule({\n-                declarations: [CompUsingModuleDirectiveAndPipe, SomePipe],\n-                imports: [SomeImportedModule],\n-                entryComponents: [CompUsingModuleDirectiveAndPipe]\n-              })\n-              class SomeModule {\n-              }\n-\n-              expect(() => createComp(SomeComp, SomeModule))\n-                  .toThrowError(/Can't bind to 'someDir'/);\n-            });\n-      });\n+      const cars = injector.get(CARS);\n+      expect(cars.length).toEqual(2);\n+      expect(cars[0]).toBeAnInstanceOf(SportsCar);\n+      expect(cars[1]).toBeAnInstanceOf(CarWithOptionalEngine);\n     });\n \n+    it('should support multiProviders that are created using useExisting', () => {\n+      const injector =\n+          createInjector([Engine, SportsCar, {provide: CARS, useExisting: SportsCar, multi: true}]);\n \n-    describe('providers', function() {\n-      let moduleType: any = null;\n-\n+      const cars = injector.get(CARS);\n+      expect(cars.length).toEqual(1);\n+      expect(cars[0]).toBe(injector.get(SportsCar));\n+    });\n \n-      function createInjector(providers: Provider[], parent?: Injector|null): Injector {\n-        @NgModule({providers: providers})\n-        class SomeModule {\n-        }\n+    it('should throw when the aliased provider does not exist', () => {\n+      const injector = createInjector([{provide: 'car', useExisting: SportsCar}]);\n+      const errorMsg = `R3InjectorError(SomeModule)[car -> ${stringify(SportsCar)}]: \\n  ` +\n+          `NullInjectorError: No provider for ${stringify(SportsCar)}!`;\n+      expect(() => injector.get('car')).toThrowError(errorMsg);\n+    });\n \n-        moduleType = SomeModule;\n+    it('should handle forwardRef in useExisting', () => {\n+      const injector = createInjector([\n+        {provide: 'originalEngine', useClass: forwardRef(() => Engine)},\n+        {provide: 'aliasedEngine', useExisting: <any>forwardRef(() => 'originalEngine')}\n+      ]);\n+      expect(injector.get('aliasedEngine')).toBeAnInstanceOf(Engine);\n+    });\n \n-        return createModule(SomeModule, parent).injector;\n-      }\n+    it('should support overriding factory dependencies', () => {\n+      const injector = createInjector(\n+          [Engine, {provide: Car, useFactory: (e: Engine) => new SportsCar(e), deps: [Engine]}]);\n \n-      it('should provide the module', () => {\n-        expect(createInjector([]).get(moduleType)).toBeAnInstanceOf(moduleType);\n-      });\n+      const car = injector.get(Car);\n+      expect(car).toBeAnInstanceOf(SportsCar);\n+      expect(car.engine).toBeAnInstanceOf(Engine);\n+    });\n \n-      it('should instantiate a class without dependencies', () => {\n-        const injector = createInjector([Engine]);\n-        const engine = injector.get(Engine);\n+    it('should support optional dependencies', () => {\n+      const injector = createInjector([CarWithOptionalEngine]);\n \n-        expect(engine).toBeAnInstanceOf(Engine);\n-      });\n+      const car = injector.get(CarWithOptionalEngine);\n+      expect(car.engine).toBeNull();\n+    });\n \n-      it('should resolve dependencies based on type information', () => {\n-        const injector = createInjector([Engine, Car]);\n-        const car = injector.get(Car);\n+    it('should flatten passed-in providers', () => {\n+      const injector = createInjector([[[Engine, Car]]]);\n \n-        expect(car).toBeAnInstanceOf(Car);\n-        expect(car.engine).toBeAnInstanceOf(Engine);\n-      });\n+      const car = injector.get(Car);\n+      expect(car).toBeAnInstanceOf(Car);\n+    });\n \n-      it('should resolve dependencies based on @Inject annotation', () => {\n-        const injector = createInjector([TurboEngine, Engine, CarWithInject]);\n-        const car = injector.get(CarWithInject);\n+    it('should use the last provider when there are multiple providers for same token', () => {\n+      const injector = createInjector(\n+          [{provide: Engine, useClass: Engine}, {provide: Engine, useClass: TurboEngine}]);\n \n-        expect(car).toBeAnInstanceOf(CarWithInject);\n-        expect(car.engine).toBeAnInstanceOf(TurboEngine);\n-      });\n+      expect(injector.get(Engine)).toBeAnInstanceOf(TurboEngine);\n+    });\n \n-      it('should throw when no type and not @Inject (class case)', () => {\n-        expect(() => createInjector([NoAnnotations]))\n-            .toThrowError('Can\\'t resolve all parameters for NoAnnotations: (?).');\n-      });\n+    it('should use non-type tokens', () => {\n+      const injector = createInjector([{provide: 'token', useValue: 'value'}]);\n \n-      modifiedInIvy('Ivy does not use deps for factories as deps are inlined in generated code.')\n-          .it('should throw when no type and not @Inject (factory case)', () => {\n-            expect(() => createInjector([{provide: 'someToken', useFactory: factoryFn}]))\n-                .toThrowError('Can\\'t resolve all parameters for factoryFn: (?).');\n-          });\n+      expect(injector.get('token')).toEqual('value');\n+    });\n \n-      it('should cache instances', () => {\n-        const injector = createInjector([Engine]);\n+    it('should throw when given invalid providers', () => {\n+      expect(() => createInjector(<any>['blah']))\n+          .toThrowError(\n+              `Invalid provider for the NgModule 'SomeModule' - only instances of Provider and Type are allowed, got: [?blah?]`);\n+    });\n \n-        const e1 = injector.get(Engine);\n-        const e2 = injector.get(Engine);\n+    it('should throw when given blank providers', () => {\n+      expect(() => createInjector(<any>[null, {provide: 'token', useValue: 'value'}]))\n+          .toThrowError(\n+              `Invalid provider for the NgModule 'SomeModule' - only instances of Provider and Type are allowed, got: [?null?, ...]`);\n+    });\n \n-        expect(e1).toBe(e2);\n-      });\n+    it('should provide itself', () => {\n+      const parent = createInjector([]);\n+      const child = createInjector([], parent);\n \n-      it('should provide to a value', () => {\n-        const injector = createInjector([{provide: Engine, useValue: 'fake engine'}]);\n+      expect(child.get(Injector)).toBe(child);\n+    });\n \n-        const engine = injector.get(Engine);\n-        expect(engine).toEqual('fake engine');\n-      });\n+    it('should provide undefined', () => {\n+      let factoryCounter = 0;\n \n-      it('should provide to a factory', () => {\n-        function sportsCarFactory(e: Engine) {\n-          return new SportsCar(e);\n+      const injector = createInjector([{\n+        provide: 'token',\n+        useFactory: () => {\n+          factoryCounter++;\n+          return undefined;\n         }\n+      }]);\n \n-        const injector =\n-            createInjector([Engine, {provide: Car, useFactory: sportsCarFactory, deps: [Engine]}]);\n+      expect(injector.get('token')).toBeUndefined();\n+      expect(injector.get('token')).toBeUndefined();\n+      expect(factoryCounter).toBe(1);\n+    });\n \n-        const car = injector.get(Car);\n-        expect(car).toBeAnInstanceOf(SportsCar);\n-        expect(car.engine).toBeAnInstanceOf(Engine);\n-      });\n+    describe('injecting lazy providers into an eager provider via Injector.get', () => {\n+      it('should inject providers that were declared before it', () => {\n+        @NgModule({\n+          providers: [\n+            {provide: 'lazy', useFactory: () => 'lazyValue'},\n+            {\n+              provide: 'eager',\n+              useFactory: (i: Injector) => `eagerValue: ${i.get('lazy')}`,\n+              deps: [Injector]\n+            },\n+          ]\n+        })\n+        class MyModule {\n+          // NgModule is eager, which makes all of its deps eager\n+          constructor(@Inject('eager') eager: any) {}\n+        }\n \n-      it('should supporting provider to null', () => {\n-        const injector = createInjector([{provide: Engine, useValue: null}]);\n-        const engine = injector.get(Engine);\n-        expect(engine).toBeNull();\n+        expect(createModule(MyModule).injector.get('eager')).toBe('eagerValue: lazyValue');\n       });\n \n-      it('should provide to an alias', () => {\n-        const injector = createInjector([\n-          Engine, {provide: SportsCar, useClass: SportsCar}, {provide: Car, useExisting: SportsCar}\n-        ]);\n+      it('should inject providers that were declared after it', () => {\n+        @NgModule({\n+          providers: [\n+            {\n+              provide: 'eager',\n+              useFactory: (i: Injector) => `eagerValue: ${i.get('lazy')}`,\n+              deps: [Injector]\n+            },\n+            {provide: 'lazy', useFactory: () => 'lazyValue'},\n+          ]\n+        })\n+        class MyModule {\n+          // NgModule is eager, which makes all of its deps eager\n+          constructor(@Inject('eager') eager: any) {}\n+        }\n \n-        const car = injector.get(Car);\n-        const sportsCar = injector.get(SportsCar);\n-        expect(car).toBeAnInstanceOf(SportsCar);\n-        expect(car).toBe(sportsCar);\n+        expect(createModule(MyModule).injector.get('eager')).toBe('eagerValue: lazyValue');\n       });\n+    });\n \n-      it('should support multiProviders', () => {\n-        const injector = createInjector([\n-          Engine, {provide: CARS, useClass: SportsCar, multi: true},\n-          {provide: CARS, useClass: CarWithOptionalEngine, multi: true}\n-        ]);\n+    describe('injecting eager providers into an eager provider via Injector.get', () => {\n+      it('should inject providers that were declared before it', () => {\n+        @NgModule({\n+          providers: [\n+            {provide: 'eager1', useFactory: () => 'v1'},\n+            {\n+              provide: 'eager2',\n+              useFactory: (i: Injector) => `v2: ${i.get('eager1')}`,\n+              deps: [Injector]\n+            },\n+          ]\n+        })\n+        class MyModule {\n+          // NgModule is eager, which makes all of its deps eager\n+          constructor(@Inject('eager1') eager1: any, @Inject('eager2') eager2: any) {}\n+        }\n \n-        const cars = injector.get(CARS);\n-        expect(cars.length).toEqual(2);\n-        expect(cars[0]).toBeAnInstanceOf(SportsCar);\n-        expect(cars[1]).toBeAnInstanceOf(CarWithOptionalEngine);\n+        expect(createModule(MyModule).injector.get('eager2')).toBe('v2: v1');\n       });\n \n-      it('should support multiProviders that are created using useExisting', () => {\n-        const injector = createInjector(\n-            [Engine, SportsCar, {provide: CARS, useExisting: SportsCar, multi: true}]);\n+      it('should inject providers that were declared after it', () => {\n+        @NgModule({\n+          providers: [\n+            {\n+              provide: 'eager1',\n+              useFactory: (i: Injector) => `v1: ${i.get('eager2')}`,\n+              deps: [Injector]\n+            },\n+            {provide: 'eager2', useFactory: () => 'v2'},\n+          ]\n+        })\n+        class MyModule {\n+          // NgModule is eager, which makes all of its deps eager\n+          constructor(@Inject('eager1') eager1: any, @Inject('eager2') eager2: any) {}\n+        }\n \n-        const cars = injector.get(CARS);\n-        expect(cars.length).toEqual(1);\n-        expect(cars[0]).toBe(injector.get(SportsCar));\n+        expect(createModule(MyModule).injector.get('eager1')).toBe('v1: v2');\n       });\n \n-      it('should throw when the aliased provider does not exist', () => {\n-        const injector = createInjector([{provide: 'car', useExisting: SportsCar}]);\n-        let errorMsg = `NullInjectorError: No provider for ${stringify(SportsCar)}!`;\n-        if (ivyEnabled) {\n-          errorMsg = `R3InjectorError(SomeModule)[car -> ${stringify(SportsCar)}]: \\n  ` + errorMsg;\n+      it('eager providers should get initialized only once', () => {\n+        @Injectable()\n+        class MyService1 {\n+          public innerService: MyService2;\n+          constructor(injector: Injector) {\n+            // Create MyService2 before it it's initialized by TestModule.\n+            this.innerService = injector.get(MyService2);\n+          }\n         }\n-        expect(() => injector.get('car')).toThrowError(errorMsg);\n-      });\n \n-      it('should handle forwardRef in useExisting', () => {\n-        const injector = createInjector([\n-          {provide: 'originalEngine', useClass: forwardRef(() => Engine)},\n-          {provide: 'aliasedEngine', useExisting: <any>forwardRef(() => 'originalEngine')}\n-        ]);\n-        expect(injector.get('aliasedEngine')).toBeAnInstanceOf(Engine);\n-      });\n-\n-      it('should support overriding factory dependencies', () => {\n-        const injector = createInjector(\n-            [Engine, {provide: Car, useFactory: (e: Engine) => new SportsCar(e), deps: [Engine]}]);\n+        @Injectable()\n+        class MyService2 {\n+          constructor() {}\n+        }\n \n-        const car = injector.get(Car);\n-        expect(car).toBeAnInstanceOf(SportsCar);\n-        expect(car.engine).toBeAnInstanceOf(Engine);\n-      });\n+        @NgModule({\n+          providers: [MyService1, MyService2],\n+        })\n+        class TestModule {\n+          constructor(public service1: MyService1, public service2: MyService2) {}\n+        }\n \n-      it('should support optional dependencies', () => {\n-        const injector = createInjector([CarWithOptionalEngine]);\n+        const moduleRef = createModule(TestModule, injector);\n+        const module = moduleRef.instance;\n \n-        const car = injector.get(CarWithOptionalEngine);\n-        expect(car.engine).toBeNull();\n+        // MyService2 should not get initialized twice.\n+        expect(module.service1.innerService).toBe(module.service2);\n       });\n+    });\n \n-      it('should flatten passed-in providers', () => {\n-        const injector = createInjector([[[Engine, Car]]]);\n-\n-        const car = injector.get(Car);\n-        expect(car).toBeAnInstanceOf(Car);\n-      });\n+    it('should throw when no provider defined', () => {\n+      const injector = createInjector([]);\n+      const errorMsg = `R3InjectorError(SomeModule)[NonExisting]: \\n  ` +\n+          'NullInjectorError: No provider for NonExisting!';\n+      expect(() => injector.get('NonExisting')).toThrowError(errorMsg);\n+    });\n \n-      it('should use the last provider when there are multiple providers for same token', () => {\n-        const injector = createInjector(\n-            [{provide: Engine, useClass: Engine}, {provide: Engine, useClass: TurboEngine}]);\n+    it('should throw when trying to instantiate a cyclic dependency', () => {\n+      expect(() => createInjector([Car, {provide: Engine, useClass: CyclicEngine}]).get(Car))\n+          .toThrowError(/NG0200: Circular dependency in DI detected for Car/g);\n+    });\n \n-        expect(injector.get(Engine)).toBeAnInstanceOf(TurboEngine);\n-      });\n+    it('should support null values', () => {\n+      const injector = createInjector([{provide: 'null', useValue: null}]);\n+      expect(injector.get('null')).toBe(null);\n+    });\n \n-      it('should use non-type tokens', () => {\n-        const injector = createInjector([{provide: 'token', useValue: 'value'}]);\n \n-        expect(injector.get('token')).toEqual('value');\n-      });\n+    describe('child', () => {\n+      it('should load instances from parent injector', () => {\n+        const parent = createInjector([Engine]);\n+        const child = createInjector([], parent);\n \n-      it('should throw when given invalid providers', () => {\n-        expect(() => createInjector(<any>['blah']))\n-            .toThrowError(\n-                `Invalid provider for the NgModule 'SomeModule' - only instances of Provider and Type are allowed, got: [?blah?]`);\n-      });\n+        const engineFromParent = parent.get(Engine);\n+        const engineFromChild = child.get(Engine);\n \n-      it('should throw when given blank providers', () => {\n-        expect(() => createInjector(<any>[null, {provide: 'token', useValue: 'value'}]))\n-            .toThrowError(\n-                `Invalid provider for the NgModule 'SomeModule' - only instances of Provider and Type are allowed, got: [?null?, ...]`);\n+        expect(engineFromChild).toBe(engineFromParent);\n       });\n \n-      it('should provide itself', () => {\n-        const parent = createInjector([]);\n-        const child = createInjector([], parent);\n+      it('should not use the child providers when resolving the dependencies of a parent provider',\n+         () => {\n+           const parent = createInjector([Car, Engine]);\n+           const child = createInjector([{provide: Engine, useClass: TurboEngine}], parent);\n \n-        expect(child.get(Injector)).toBe(child);\n-      });\n+           const carFromChild = child.get(Car);\n+           expect(carFromChild.engine).toBeAnInstanceOf(Engine);\n+         });\n \n-      it('should provide undefined', () => {\n-        let factoryCounter = 0;\n+      it('should create new instance in a child injector', () => {\n+        const parent = createInjector([Engine]);\n+        const child = createInjector([{provide: Engine, useClass: TurboEngine}], parent);\n \n-        const injector = createInjector([{\n-          provide: 'token',\n-          useFactory: () => {\n-            factoryCounter++;\n-            return undefined;\n-          }\n-        }]);\n+        const engineFromParent = parent.get(Engine);\n+        const engineFromChild = child.get(Engine);\n \n-        expect(injector.get('token')).toBeUndefined();\n-        expect(injector.get('token')).toBeUndefined();\n-        expect(factoryCounter).toBe(1);\n+        expect(engineFromParent).not.toBe(engineFromChild);\n+        expect(engineFromChild).toBeAnInstanceOf(TurboEngine);\n       });\n+    });\n \n-      describe('injecting lazy providers into an eager provider via Injector.get', () => {\n-        it('should inject providers that were declared before it', () => {\n-          @NgModule({\n-            providers: [\n-              {provide: 'lazy', useFactory: () => 'lazyValue'},\n-              {\n-                provide: 'eager',\n-                useFactory: (i: Injector) => `eagerValue: ${i.get('lazy')}`,\n-                deps: [Injector]\n-              },\n-            ]\n-          })\n-          class MyModule {\n-            // NgModule is eager, which makes all of its deps eager\n-            constructor(@Inject('eager') eager: any) {}\n-          }\n+    describe('depedency resolution', () => {\n+      describe('@Self()', () => {\n+        it('should return a dependency from self', () => {\n+          const inj = createInjector([\n+            Engine,\n+            {provide: Car, useFactory: (e: Engine) => new Car(e), deps: [[Engine, new Self()]]}\n+          ]);\n \n-          expect(createModule(MyModule).injector.get('eager')).toBe('eagerValue: lazyValue');\n-        });\n-\n-        it('should inject providers that were declared after it', () => {\n-          @NgModule({\n-            providers: [\n-              {\n-                provide: 'eager',\n-                useFactory: (i: Injector) => `eagerValue: ${i.get('lazy')}`,\n-                deps: [Injector]\n-              },\n-              {provide: 'lazy', useFactory: () => 'lazyValue'},\n-            ]\n-          })\n-          class MyModule {\n-            // NgModule is eager, which makes all of its deps eager\n-            constructor(@Inject('eager') eager: any) {}\n-          }\n-\n-          expect(createModule(MyModule).injector.get('eager')).toBe('eagerValue: lazyValue');\n+          expect(inj.get(Car)).toBeAnInstanceOf(Car);\n         });\n       });\n \n-      describe('injecting eager providers into an eager provider via Injector.get', () => {\n-        it('should inject providers that were declared before it', () => {\n-          @NgModule({\n-            providers: [\n-              {provide: 'eager1', useFactory: () => 'v1'},\n-              {\n-                provide: 'eager2',\n-                useFactory: (i: Injector) => `v2: ${i.get('eager1')}`,\n-                deps: [Injector]\n-              },\n-            ]\n-          })\n-          class MyModule {\n-            // NgModule is eager, which makes all of its deps eager\n-            constructor(@Inject('eager1') eager1: any, @Inject('eager2') eager2: any) {}\n-          }\n-\n-          expect(createModule(MyModule).injector.get('eager2')).toBe('v2: v1');\n-        });\n-\n-        it('should inject providers that were declared after it', () => {\n-          @NgModule({\n-            providers: [\n-              {\n-                provide: 'eager1',\n-                useFactory: (i: Injector) => `v1: ${i.get('eager2')}`,\n-                deps: [Injector]\n-              },\n-              {provide: 'eager2', useFactory: () => 'v2'},\n-            ]\n-          })\n-          class MyModule {\n-            // NgModule is eager, which makes all of its deps eager\n-            constructor(@Inject('eager1') eager1: any, @Inject('eager2') eager2: any) {}\n-          }\n-\n-          expect(createModule(MyModule).injector.get('eager1')).toBe('v1: v2');\n+      describe('default', () => {\n+        it('should not skip self', () => {\n+          const parent = createInjector([Engine]);\n+          const child = createInjector(\n+              [\n+                {provide: Engine, useClass: TurboEngine},\n+                {provide: Car, useFactory: (e: Engine) => new Car(e), deps: [Engine]}\n+              ],\n+              parent);\n+\n+          expect(child.get(Car).engine).toBeAnInstanceOf(TurboEngine);\n         });\n+      });\n+    });\n \n-        it('eager providers should get initialized only once', () => {\n-          @Injectable()\n-          class MyService1 {\n-            public innerService: MyService2;\n-            constructor(injector: Injector) {\n-              // Create MyService2 before it it's initialized by TestModule.\n-              this.innerService = injector.get(MyService2);\n-            }\n-          }\n-\n-          @Injectable()\n-          class MyService2 {\n-            constructor() {}\n-          }\n+    describe('lifecycle', () => {\n+      it('should instantiate modules eagerly', () => {\n+        let created = false;\n \n-          @NgModule({\n-            providers: [MyService1, MyService2],\n-          })\n-          class TestModule {\n-            constructor(public service1: MyService1, public service2: MyService2) {}\n+        @NgModule()\n+        class ImportedModule {\n+          constructor() {\n+            created = true;\n           }\n+        }\n \n-          const moduleRef = createModule(TestModule, injector);\n-          const module = moduleRef.instance;\n-\n-          // MyService2 should not get initialized twice.\n-          expect(module.service1.innerService).toBe(module.service2);\n-        });\n-      });\n-\n-      it('should throw when no provider defined', () => {\n-        const injector = createInjector([]);\n-        let errorMsg = 'NullInjectorError: No provider for NonExisting!';\n-        if (ivyEnabled) {\n-          errorMsg = `R3InjectorError(SomeModule)[NonExisting]: \\n  ` + errorMsg;\n+        @NgModule({imports: [ImportedModule]})\n+        class SomeModule {\n         }\n-        expect(() => injector.get('NonExisting')).toThrowError(errorMsg);\n-      });\n \n-      it('should throw when trying to instantiate a cyclic dependency', () => {\n-        let errorMessage = ivyEnabled ? /NG0200: Circular dependency in DI detected for Car/g :\n-                                        /Cannot instantiate cyclic dependency! Car/g;\n-        expect(() => createInjector([Car, {provide: Engine, useClass: CyclicEngine}]).get(Car))\n-            .toThrowError(errorMessage);\n-      });\n+        createModule(SomeModule);\n \n-      it('should support null values', () => {\n-        const injector = createInjector([{provide: 'null', useValue: null}]);\n-        expect(injector.get('null')).toBe(null);\n+        expect(created).toBe(true);\n       });\n \n+      it('should instantiate providers that are not used by a module lazily', () => {\n+        let created = false;\n \n-      describe('child', () => {\n-        it('should load instances from parent injector', () => {\n-          const parent = createInjector([Engine]);\n-          const child = createInjector([], parent);\n-\n-          const engineFromParent = parent.get(Engine);\n-          const engineFromChild = child.get(Engine);\n-\n-          expect(engineFromChild).toBe(engineFromParent);\n-        });\n-\n-        it('should not use the child providers when resolving the dependencies of a parent provider',\n-           () => {\n-             const parent = createInjector([Car, Engine]);\n-             const child = createInjector([{provide: Engine, useClass: TurboEngine}], parent);\n-\n-             const carFromChild = child.get(Car);\n-             expect(carFromChild.engine).toBeAnInstanceOf(Engine);\n-           });\n-\n-        it('should create new instance in a child injector', () => {\n-          const parent = createInjector([Engine]);\n-          const child = createInjector([{provide: Engine, useClass: TurboEngine}], parent);\n-\n-          const engineFromParent = parent.get(Engine);\n-          const engineFromChild = child.get(Engine);\n+        createInjector([{\n+          provide: 'someToken',\n+          useFactory: () => {\n+            created = true;\n+            return true;\n+          }\n+        }]);\n \n-          expect(engineFromParent).not.toBe(engineFromChild);\n-          expect(engineFromChild).toBeAnInstanceOf(TurboEngine);\n-        });\n+        expect(created).toBe(false);\n       });\n \n-      describe('depedency resolution', () => {\n-        describe('@Self()', () => {\n-          it('should return a dependency from self', () => {\n-            const inj = createInjector([\n-              Engine,\n-              {provide: Car, useFactory: (e: Engine) => new Car(e), deps: [[Engine, new Self()]]}\n-            ]);\n+      it('should support ngOnDestroy on any provider', () => {\n+        let destroyed = false;\n \n-            expect(inj.get(Car)).toBeAnInstanceOf(Car);\n-          });\n-        });\n+        class SomeInjectable {\n+          ngOnDestroy() {\n+            destroyed = true;\n+          }\n+        }\n \n-        describe('default', () => {\n-          it('should not skip self', () => {\n-            const parent = createInjector([Engine]);\n-            const child = createInjector(\n-                [\n-                  {provide: Engine, useClass: TurboEngine},\n-                  {provide: Car, useFactory: (e: Engine) => new Car(e), deps: [Engine]}\n-                ],\n-                parent);\n-\n-            expect(child.get(Car).engine).toBeAnInstanceOf(TurboEngine);\n-          });\n-        });\n+        @NgModule({providers: [SomeInjectable]})\n+        class SomeModule {\n+          // Inject SomeInjectable to make it eager...\n+          constructor(i: SomeInjectable) {}\n+        }\n+\n+        const moduleRef = createModule(SomeModule);\n+        expect(destroyed).toBe(false);\n+        moduleRef.destroy();\n+        expect(destroyed).toBe(true);\n       });\n \n-      describe('lifecycle', () => {\n-        it('should instantiate modules eagerly', () => {\n-          let created = false;\n+      it('should support ngOnDestroy for lazy providers', () => {\n+        let created = false;\n+        let destroyed = false;\n \n-          @NgModule()\n-          class ImportedModule {\n-            constructor() {\n-              created = true;\n-            }\n+        class SomeInjectable {\n+          constructor() {\n+            created = true;\n           }\n-\n-          @NgModule({imports: [ImportedModule]})\n-          class SomeModule {\n+          ngOnDestroy() {\n+            destroyed = true;\n           }\n+        }\n \n-          createModule(SomeModule);\n-\n-          expect(created).toBe(true);\n-        });\n+        @NgModule({providers: [SomeInjectable]})\n+        class SomeModule {\n+        }\n \n-        it('should instantiate providers that are not used by a module lazily', () => {\n-          let created = false;\n+        let moduleRef = createModule(SomeModule);\n+        expect(created).toBe(false);\n+        expect(destroyed).toBe(false);\n \n-          createInjector([{\n-            provide: 'someToken',\n-            useFactory: () => {\n-              created = true;\n-              return true;\n-            }\n-          }]);\n+        // no error if the provider was not yet created\n+        moduleRef.destroy();\n+        expect(created).toBe(false);\n+        expect(destroyed).toBe(false);\n \n-          expect(created).toBe(false);\n-        });\n+        moduleRef = createModule(SomeModule);\n+        moduleRef.injector.get(SomeInjectable);\n+        expect(created).toBe(true);\n+        moduleRef.destroy();\n+        expect(destroyed).toBe(true);\n+      });\n+    });\n \n-        it('should support ngOnDestroy on any provider', () => {\n-          let destroyed = false;\n+    describe('imported and exported modules', () => {\n+      it('should add the providers of imported modules', () => {\n+        @NgModule({providers: [{provide: 'token1', useValue: 'imported'}]})\n+        class ImportedModule {\n+        }\n \n-          class SomeInjectable {\n-            ngOnDestroy() {\n-              destroyed = true;\n-            }\n-          }\n+        @NgModule({imports: [ImportedModule]})\n+        class SomeModule {\n+        }\n \n-          @NgModule({providers: [SomeInjectable]})\n-          class SomeModule {\n-            // Inject SomeInjectable to make it eager...\n-            constructor(i: SomeInjectable) {}\n-          }\n+        const injector = createModule(SomeModule).injector;\n \n-          const moduleRef = createModule(SomeModule);\n-          expect(destroyed).toBe(false);\n-          moduleRef.destroy();\n-          expect(destroyed).toBe(true);\n-        });\n+        expect(injector.get(SomeModule)).toBeAnInstanceOf(SomeModule);\n+        expect(injector.get(ImportedModule)).toBeAnInstanceOf(ImportedModule);\n+        expect(injector.get('token1')).toBe('imported');\n+      });\n \n-        it('should support ngOnDestroy for lazy providers', () => {\n-          let created = false;\n-          let destroyed = false;\n-\n-          class SomeInjectable {\n-            constructor() {\n-              created = true;\n-            }\n-            ngOnDestroy() {\n-              destroyed = true;\n-            }\n-          }\n \n-          @NgModule({providers: [SomeInjectable]})\n-          class SomeModule {\n-          }\n+      it('should add the providers of imported ModuleWithProviders', () => {\n+        @NgModule()\n+        class ImportedModule {\n+        }\n \n-          let moduleRef = createModule(SomeModule);\n-          expect(created).toBe(false);\n-          expect(destroyed).toBe(false);\n+        @NgModule({\n+          imports:\n+              [{ngModule: ImportedModule, providers: [{provide: 'token1', useValue: 'imported'}]}]\n+        })\n+        class SomeModule {\n+        }\n \n-          // no error if the provider was not yet created\n-          moduleRef.destroy();\n-          expect(created).toBe(false);\n-          expect(destroyed).toBe(false);\n+        const injector = createModule(SomeModule).injector;\n \n-          moduleRef = createModule(SomeModule);\n-          moduleRef.injector.get(SomeInjectable);\n-          expect(created).toBe(true);\n-          moduleRef.destroy();\n-          expect(destroyed).toBe(true);\n-        });\n+        expect(injector.get(SomeModule)).toBeAnInstanceOf(SomeModule);\n+        expect(injector.get(ImportedModule)).toBeAnInstanceOf(ImportedModule);\n+        expect(injector.get('token1')).toBe('imported');\n       });\n \n-      describe('imported and exported modules', () => {\n-        it('should add the providers of imported modules', () => {\n-          @NgModule({providers: [{provide: 'token1', useValue: 'imported'}]})\n-          class ImportedModule {\n-          }\n-\n-          @NgModule({imports: [ImportedModule]})\n-          class SomeModule {\n-          }\n-\n-          const injector = createModule(SomeModule).injector;\n-\n-          expect(injector.get(SomeModule)).toBeAnInstanceOf(SomeModule);\n-          expect(injector.get(ImportedModule)).toBeAnInstanceOf(ImportedModule);\n-          expect(injector.get('token1')).toBe('imported');\n-        });\n-\n+      it('should overwrite the providers of imported modules', () => {\n+        @NgModule({providers: [{provide: 'token1', useValue: 'imported'}]})\n+        class ImportedModule {\n+        }\n \n-        it('should add the providers of imported ModuleWithProviders', () => {\n-          @NgModule()\n-          class ImportedModule {\n-          }\n+        @NgModule({providers: [{provide: 'token1', useValue: 'direct'}], imports: [ImportedModule]})\n+        class SomeModule {\n+        }\n \n-          @NgModule({\n-            imports:\n-                [{ngModule: ImportedModule, providers: [{provide: 'token1', useValue: 'imported'}]}]\n-          })\n-          class SomeModule {\n-          }\n+        const injector = createModule(SomeModule).injector;\n+        expect(injector.get('token1')).toBe('direct');\n+      });\n \n-          const injector = createModule(SomeModule).injector;\n \n-          expect(injector.get(SomeModule)).toBeAnInstanceOf(SomeModule);\n-          expect(injector.get(ImportedModule)).toBeAnInstanceOf(ImportedModule);\n-          expect(injector.get('token1')).toBe('imported');\n-        });\n+      it('should overwrite the providers of imported ModuleWithProviders', () => {\n+        @NgModule()\n+        class ImportedModule {\n+        }\n \n-        it('should overwrite the providers of imported modules', () => {\n-          @NgModule({providers: [{provide: 'token1', useValue: 'imported'}]})\n-          class ImportedModule {\n-          }\n+        @NgModule({\n+          providers: [{provide: 'token1', useValue: 'direct'}],\n+          imports:\n+              [{ngModule: ImportedModule, providers: [{provide: 'token1', useValue: 'imported'}]}]\n+        })\n+        class SomeModule {\n+        }\n \n-          @NgModule(\n-              {providers: [{provide: 'token1', useValue: 'direct'}], imports: [ImportedModule]})\n-          class SomeModule {\n-          }\n+        const injector = createModule(SomeModule).injector;\n+        expect(injector.get('token1')).toBe('direct');\n+      });\n \n-          const injector = createModule(SomeModule).injector;\n-          expect(injector.get('token1')).toBe('direct');\n-        });\n+      it('should overwrite the providers of imported modules on the second import level', () => {\n+        @NgModule({providers: [{provide: 'token1', useValue: 'imported'}]})\n+        class ImportedModuleLevel2 {\n+        }\n \n+        @NgModule(\n+            {providers: [{provide: 'token1', useValue: 'direct'}], imports: [ImportedModuleLevel2]})\n+        class ImportedModuleLevel1 {\n+        }\n \n-        it('should overwrite the providers of imported ModuleWithProviders', () => {\n-          @NgModule()\n-          class ImportedModule {\n-          }\n+        @NgModule({imports: [ImportedModuleLevel1]})\n+        class SomeModule {\n+        }\n \n-          @NgModule({\n-            providers: [{provide: 'token1', useValue: 'direct'}],\n-            imports:\n-                [{ngModule: ImportedModule, providers: [{provide: 'token1', useValue: 'imported'}]}]\n-          })\n-          class SomeModule {\n-          }\n+        const injector = createModule(SomeModule).injector;\n+        expect(injector.get('token1')).toBe('direct');\n+      });\n \n-          const injector = createModule(SomeModule).injector;\n-          expect(injector.get('token1')).toBe('direct');\n-        });\n+      it('should add the providers of exported modules', () => {\n+        @NgModule({providers: [{provide: 'token1', useValue: 'exported'}]})\n+        class ExportedValue {\n+        }\n \n-        it('should overwrite the providers of imported modules on the second import level', () => {\n-          @NgModule({providers: [{provide: 'token1', useValue: 'imported'}]})\n-          class ImportedModuleLevel2 {\n-          }\n+        @NgModule({exports: [ExportedValue]})\n+        class SomeModule {\n+        }\n \n-          @NgModule({\n-            providers: [{provide: 'token1', useValue: 'direct'}],\n-            imports: [ImportedModuleLevel2]\n-          })\n-          class ImportedModuleLevel1 {\n-          }\n+        const injector = createModule(SomeModule).injector;\n \n-          @NgModule({imports: [ImportedModuleLevel1]})\n-          class SomeModule {\n-          }\n+        expect(injector.get(SomeModule)).toBeAnInstanceOf(SomeModule);\n+        expect(injector.get(ExportedValue)).toBeAnInstanceOf(ExportedValue);\n+        expect(injector.get('token1')).toBe('exported');\n+      });\n \n-          const injector = createModule(SomeModule).injector;\n-          expect(injector.get('token1')).toBe('direct');\n-        });\n+      it('should overwrite the providers of exported modules', () => {\n+        @NgModule({providers: [{provide: 'token1', useValue: 'exported'}]})\n+        class ExportedModule {\n+        }\n \n-        it('should add the providers of exported modules', () => {\n-          @NgModule({providers: [{provide: 'token1', useValue: 'exported'}]})\n-          class ExportedValue {\n-          }\n+        @NgModule({providers: [{provide: 'token1', useValue: 'direct'}], exports: [ExportedModule]})\n+        class SomeModule {\n+        }\n \n-          @NgModule({exports: [ExportedValue]})\n-          class SomeModule {\n-          }\n+        const injector = createModule(SomeModule).injector;\n+        expect(injector.get('token1')).toBe('direct');\n+      });\n \n-          const injector = createModule(SomeModule).injector;\n+      it('should overwrite the providers of imported modules by following imported modules', () => {\n+        @NgModule({providers: [{provide: 'token1', useValue: 'imported1'}]})\n+        class ImportedModule1 {\n+        }\n \n-          expect(injector.get(SomeModule)).toBeAnInstanceOf(SomeModule);\n-          expect(injector.get(ExportedValue)).toBeAnInstanceOf(ExportedValue);\n-          expect(injector.get('token1')).toBe('exported');\n-        });\n+        @NgModule({providers: [{provide: 'token1', useValue: 'imported2'}]})\n+        class ImportedModule2 {\n+        }\n \n-        it('should overwrite the providers of exported modules', () => {\n-          @NgModule({providers: [{provide: 'token1', useValue: 'exported'}]})\n-          class ExportedModule {\n-          }\n+        @NgModule({imports: [ImportedModule1, ImportedModule2]})\n+        class SomeModule {\n+        }\n \n-          @NgModule(\n-              {providers: [{provide: 'token1', useValue: 'direct'}], exports: [ExportedModule]})\n-          class SomeModule {\n-          }\n+        const injector = createModule(SomeModule).injector;\n+        expect(injector.get('token1')).toBe('imported2');\n+      });\n \n-          const injector = createModule(SomeModule).injector;\n-          expect(injector.get('token1')).toBe('direct');\n-        });\n+      it('should overwrite the providers of exported modules by following exported modules', () => {\n+        @NgModule({providers: [{provide: 'token1', useValue: 'exported1'}]})\n+        class ExportedModule1 {\n+        }\n \n-        it('should overwrite the providers of imported modules by following imported modules',\n-           () => {\n-             @NgModule({providers: [{provide: 'token1', useValue: 'imported1'}]})\n-             class ImportedModule1 {\n-             }\n+        @NgModule({providers: [{provide: 'token1', useValue: 'exported2'}]})\n+        class ExportedModule2 {\n+        }\n \n-             @NgModule({providers: [{provide: 'token1', useValue: 'imported2'}]})\n-             class ImportedModule2 {\n-             }\n+        @NgModule({exports: [ExportedModule1, ExportedModule2]})\n+        class SomeModule {\n+        }\n \n-             @NgModule({imports: [ImportedModule1, ImportedModule2]})\n-             class SomeModule {\n-             }\n+        const injector = createModule(SomeModule).injector;\n+        expect(injector.get('token1')).toBe('exported2');\n+      });\n \n-             const injector = createModule(SomeModule).injector;\n-             expect(injector.get('token1')).toBe('imported2');\n-           });\n+      it('should overwrite the providers of imported modules by exported modules', () => {\n+        @NgModule({providers: [{provide: 'token1', useValue: 'imported'}]})\n+        class ImportedModule {\n+        }\n \n-        it('should overwrite the providers of exported modules by following exported modules',\n-           () => {\n-             @NgModule({providers: [{provide: 'token1', useValue: 'exported1'}]})\n-             class ExportedModule1 {\n-             }\n+        @NgModule({providers: [{provide: 'token1', useValue: 'exported'}]})\n+        class ExportedModule {\n+        }\n \n-             @NgModule({providers: [{provide: 'token1', useValue: 'exported2'}]})\n-             class ExportedModule2 {\n-             }\n+        @NgModule({imports: [ImportedModule], exports: [ExportedModule]})\n+        class SomeModule {\n+        }\n \n-             @NgModule({exports: [ExportedModule1, ExportedModule2]})\n-             class SomeModule {\n-             }\n+        const injector = createModule(SomeModule).injector;\n+        expect(injector.get('token1')).toBe('exported');\n+      });\n \n-             const injector = createModule(SomeModule).injector;\n-             expect(injector.get('token1')).toBe('exported2');\n-           });\n+      it('should not overwrite the providers if a module was already used on the same level',\n+         () => {\n+           @NgModule({providers: [{provide: 'token1', useValue: 'imported1'}]})\n+           class ImportedModule1 {\n+           }\n \n-        it('should overwrite the providers of imported modules by exported modules', () => {\n-          @NgModule({providers: [{provide: 'token1', useValue: 'imported'}]})\n-          class ImportedModule {\n-          }\n+           @NgModule({providers: [{provide: 'token1', useValue: 'imported2'}]})\n+           class ImportedModule2 {\n+           }\n \n-          @NgModule({providers: [{provide: 'token1', useValue: 'exported'}]})\n-          class ExportedModule {\n-          }\n+           @NgModule({imports: [ImportedModule1, ImportedModule2, ImportedModule1]})\n+           class SomeModule {\n+           }\n \n-          @NgModule({imports: [ImportedModule], exports: [ExportedModule]})\n-          class SomeModule {\n-          }\n+           const injector = createModule(SomeModule).injector;\n+           expect(injector.get('token1')).toBe('imported2');\n+         });\n \n-          const injector = createModule(SomeModule).injector;\n-          expect(injector.get('token1')).toBe('exported');\n-        });\n+      it('should not overwrite the providers if a module was already used on a child level', () => {\n+        @NgModule({providers: [{provide: 'token1', useValue: 'imported1'}]})\n+        class ImportedModule1 {\n+        }\n \n-        it('should not overwrite the providers if a module was already used on the same level',\n-           () => {\n-             @NgModule({providers: [{provide: 'token1', useValue: 'imported1'}]})\n-             class ImportedModule1 {\n-             }\n+        @NgModule({imports: [ImportedModule1]})\n+        class ImportedModule3 {\n+        }\n \n-             @NgModule({providers: [{provide: 'token1', useValue: 'imported2'}]})\n-             class ImportedModule2 {\n-             }\n+        @NgModule({providers: [{provide: 'token1', useValue: 'imported2'}]})\n+        class ImportedModule2 {\n+        }\n \n-             @NgModule({imports: [ImportedModule1, ImportedModule2, ImportedModule1]})\n-             class SomeModule {\n-             }\n+        @NgModule({imports: [ImportedModule3, ImportedModule2, ImportedModule1]})\n+        class SomeModule {\n+        }\n \n-             const injector = createModule(SomeModule).injector;\n-             expect(injector.get('token1')).toBe('imported2');\n-           });\n+        const injector = createModule(SomeModule).injector;\n+        expect(injector.get('token1')).toBe('imported2');\n+      });\n \n-        it('should not overwrite the providers if a module was already used on a child level',\n-           () => {\n-             @NgModule({providers: [{provide: 'token1', useValue: 'imported1'}]})\n-             class ImportedModule1 {\n-             }\n+      it('should throw when given invalid providers in an imported ModuleWithProviders', () => {\n+        @NgModule()\n+        class ImportedModule1 {\n+        }\n \n-             @NgModule({imports: [ImportedModule1]})\n-             class ImportedModule3 {\n-             }\n+        @NgModule({imports: [{ngModule: ImportedModule1, providers: [<any>'broken']}]})\n+        class SomeModule {\n+        }\n \n-             @NgModule({providers: [{provide: 'token1', useValue: 'imported2'}]})\n-             class ImportedModule2 {\n-             }\n+        expect(() => createModule(SomeModule).injector)\n+            .toThrowError(\n+                `Invalid provider for the NgModule 'ImportedModule1' - only instances of Provider and Type are allowed, got: [?broken?]`);\n+      });\n+    });\n \n-             @NgModule({imports: [ImportedModule3, ImportedModule2, ImportedModule1]})\n-             class SomeModule {\n-             }\n+    describe('tree shakable providers', () => {\n+      it('definition should not persist across NgModuleRef instances', () => {\n+        @NgModule()\n+        class SomeModule {\n+        }\n \n-             const injector = createModule(SomeModule).injector;\n-             expect(injector.get('token1')).toBe('imported2');\n-           });\n+        class Bar {\n+          static ɵprov = ɵɵdefineInjectable({\n+            token: Bar,\n+            factory: () => new Bar(),\n+            providedIn: SomeModule,\n+          });\n+        }\n \n-        it('should throw when given invalid providers in an imported ModuleWithProviders', () => {\n-          @NgModule()\n-          class ImportedModule1 {\n-          }\n+        const factory = createModuleFactory(SomeModule);\n+        const ngModuleRef1 = factory.create(null);\n \n-          @NgModule({imports: [{ngModule: ImportedModule1, providers: [<any>'broken']}]})\n-          class SomeModule {\n-          }\n+        // Inject a tree shakeable provider token.\n+        ngModuleRef1.injector.get(Bar);\n \n-          expect(() => createModule(SomeModule).injector)\n-              .toThrowError(\n-                  `Invalid provider for the NgModule 'ImportedModule1' - only instances of Provider and Type are allowed, got: [?broken?]`);\n-        });\n-      });\n+        // Tree Shakeable provider definition should be available.\n+        const providerDef1 = (ngModuleRef1 as any)._r3Injector.records.get(Bar);\n+        expect(providerDef1).not.toBeUndefined();\n \n-      describe('tree shakable providers', () => {\n-        onlyInIvy(`Ivy and VE have different internal fields to access providers`)\n-            .it('definition should not persist across NgModuleRef instances', () => {\n-              @NgModule()\n-              class SomeModule {\n-              }\n-\n-              class Bar {\n-                static ɵprov = ɵɵdefineInjectable({\n-                  token: Bar,\n-                  factory: () => new Bar(),\n-                  providedIn: SomeModule,\n-                });\n-              }\n-\n-              const factory = createModuleFactory(SomeModule);\n-              const ngModuleRef1 = factory.create(null);\n-\n-              // Inject a tree shakeable provider token.\n-              ngModuleRef1.injector.get(Bar);\n-\n-              // Tree Shakeable provider definition should be available.\n-              const providerDef1 = (ngModuleRef1 as any)._r3Injector.records.get(Bar);\n-              expect(providerDef1).not.toBeUndefined();\n-\n-              // Instantiate the same module. The tree shakeable provider definition should not be\n-              // present.\n-              const ngModuleRef2 = factory.create(null);\n-              const providerDef2 = (ngModuleRef2 as any)._r3Injector.records.get(Bar);\n-              expect(providerDef2).toBeUndefined();\n-            });\n+        // Instantiate the same module. The tree shakeable provider definition should not be\n+        // present.\n+        const ngModuleRef2 = factory.create(null);\n+        const providerDef2 = (ngModuleRef2 as any)._r3Injector.records.get(Bar);\n+        expect(providerDef2).toBeUndefined();\n       });\n     });\n   });\n-}\n+});"
        },
        {
            "sha": "9f0100ece6c62dd9e12c68370198a86c535c9874",
            "filename": "packages/core/test/linker/projection_integration_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 43,
            "changes": 44,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fprojection_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fprojection_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Fprojection_integration_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -6,13 +6,12 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {CommonModule, ɵgetDOM as getDOM} from '@angular/common';\n+import {ɵgetDOM as getDOM} from '@angular/common';\n import {Component, ComponentFactoryResolver, ComponentRef, Directive, ElementRef, Injector, Input, NgModule, NO_ERRORS_SCHEMA, OnInit, TemplateRef, ViewChild, ViewContainerRef, ViewEncapsulation} from '@angular/core';\n import {ComponentFixture, TestBed} from '@angular/core/testing';\n import {By} from '@angular/platform-browser/src/dom/debug/by';\n import {browserDetection} from '@angular/platform-browser/testing/src/browser_util';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {modifiedInIvy} from '@angular/private/testing';\n \n describe('projection', () => {\n   beforeEach(() => TestBed.configureTestingModule({declarations: [MainComp, OtherComp, Simple]}));\n@@ -142,47 +141,6 @@ describe('projection', () => {\n     expect(component.location.nativeElement).toHaveText('(one, two)');\n   });\n \n-  modifiedInIvy(\n-      'FW-886: `projectableNodes` passed to a componentFactory should be in the order of' +\n-      'declaration. In Ivy, the ng-content slots are determined with breadth-first search.')\n-      .it('should respect order of declaration for projectable nodes', () => {\n-        @Component({\n-          selector: 'multiple-content-tags',\n-          template: `\n-          1<ng-content select=\"h1\"></ng-content>\n-          2<ng-template [ngIf]=\"true\"><ng-content></ng-content></ng-template>\n-          3<ng-content select=\"h2\"></ng-content>\n-        `,\n-        })\n-        class MultipleContentTagsComponent {\n-        }\n-\n-        @NgModule({\n-          declarations: [MultipleContentTagsComponent],\n-          entryComponents: [MultipleContentTagsComponent],\n-          imports: [CommonModule],\n-          schemas: [NO_ERRORS_SCHEMA],\n-        })\n-        class MyModule {\n-        }\n-\n-        TestBed.configureTestingModule({imports: [MyModule]});\n-        const injector: Injector = TestBed.inject(Injector);\n-\n-        const componentFactoryResolver: ComponentFactoryResolver =\n-            injector.get(ComponentFactoryResolver);\n-        const componentFactory =\n-            componentFactoryResolver.resolveComponentFactory(MultipleContentTagsComponent);\n-        expect(componentFactory.ngContentSelectors).toEqual(['h1', '*', 'h2']);\n-\n-        const nodeOne = getDOM().getDefaultDocument().createTextNode('one');\n-        const nodeTwo = getDOM().getDefaultDocument().createTextNode('two');\n-        const nodeThree = getDOM().getDefaultDocument().createTextNode('three');\n-        const component = componentFactory.create(injector, [[nodeOne], [nodeTwo], [nodeThree]]);\n-        component.changeDetectorRef.detectChanges();\n-        expect(component.location.nativeElement.textContent.trim()).toBe('1one 2two 3three');\n-      });\n-\n   it('should redistribute only direct children', () => {\n     TestBed.configureTestingModule({declarations: [MultipleContentTagsComponent]});\n     TestBed.overrideComponent(MainComp, {"
        },
        {
            "sha": "297a91627034eb1921ec51f2fe23197c58b61e11",
            "filename": "packages/core/test/linker/query_integration_spec.ts",
            "status": "modified",
            "additions": 60,
            "deletions": 164,
            "changes": 224,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fquery_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fquery_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Fquery_integration_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -10,7 +10,6 @@ import {AfterContentChecked, AfterContentInit, AfterViewChecked, AfterViewInit,\n import {ElementRef} from '@angular/core/src/core';\n import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {ivyEnabled, modifiedInIvy, onlyInIvy} from '@angular/private/testing';\n import {Subject} from 'rxjs';\n \n import {stringify} from '../../src/util/stringify';\n@@ -66,9 +65,8 @@ describe('Query API', () => {\n           `;\n       const view = createTestCmpAndDetectChanges(MyComp0, template);\n \n-      // Difference in expected text in ivy comes from the fact that ivy queries don't match host\n-      // nodes of a directive that defines a content query.\n-      expect(asNativeElements(view.debugElement.children)).toHaveText(ivyEnabled ? '3|' : '2|3|');\n+      // Queries don't match host nodes of a directive that defines a content query.\n+      expect(asNativeElements(view.debugElement.children)).toHaveText('3|');\n     });\n \n     it('should contain all direct child directives in the content dom', () => {\n@@ -134,20 +132,6 @@ describe('Query API', () => {\n       ]);\n     });\n \n-    modifiedInIvy('Static queries in Ivy require an explicit {static: true} arg')\n-        .it('should set static view and content children already after the constructor call', () => {\n-          const template =\n-              '<needs-static-content-view-child #q><div text=\"contentFoo\"></div></needs-static-content-view-child>';\n-          const view = createTestCmp(MyComp0, template);\n-          const q: NeedsStaticContentAndViewChild = view.debugElement.children[0].references!['q'];\n-          expect(q.contentChild.text).toBeFalsy();\n-          expect(q.viewChild.text).toBeFalsy();\n-\n-          view.detectChanges();\n-          expect(q.contentChild.text).toEqual('contentFoo');\n-          expect(q.viewChild.text).toEqual('viewFoo');\n-        });\n-\n     it('should contain the first view child across embedded views', () => {\n       TestBed.overrideComponent(\n           MyComp0, {set: {template: '<needs-view-child #q></needs-view-child>'}});\n@@ -184,10 +168,8 @@ describe('Query API', () => {\n           '<div text=\"5\"></div>';\n       const view = createTestCmpAndDetectChanges(MyComp0, template);\n \n-      // Difference in expected text in ivy comes from the fact that ivy queries don't match host\n-      // nodes of a directive that defines a content query.\n-      expect(asNativeElements(view.debugElement.children))\n-          .toHaveText(ivyEnabled ? '3|4|' : '2|3|4|');\n+      // Queries don't match host nodes of a directive that defines a content query.\n+      expect(asNativeElements(view.debugElement.children)).toHaveText('3|4|');\n     });\n \n     it('should contain all directives in the light dom', () => {\n@@ -196,25 +178,22 @@ describe('Query API', () => {\n           '<div text=\"4\"></div>';\n       const view = createTestCmpAndDetectChanges(MyComp0, template);\n \n-      // Difference in expected text in ivy comes from the fact that ivy queries don't match host\n-      // nodes of a directive that defines a content query.\n-      expect(asNativeElements(view.debugElement.children)).toHaveText(ivyEnabled ? '3|' : '2|3|');\n+      // Queries don't match host nodes of a directive that defines a content query.\n+      expect(asNativeElements(view.debugElement.children)).toHaveText('3|');\n     });\n \n     it('should reflect dynamically inserted directives', () => {\n       const template = '<div text=\"1\"></div>' +\n           '<needs-query text=\"2\"><div *ngIf=\"shouldShow\" [text]=\"\\'3\\'\"></div></needs-query>' +\n           '<div text=\"4\"></div>';\n       const view = createTestCmpAndDetectChanges(MyComp0, template);\n-      // Difference in expected text in ivy comes from the fact that ivy queries don't match host\n-      // nodes of a directive that defines a content query.\n-      expect(asNativeElements(view.debugElement.children)).toHaveText(ivyEnabled ? '' : '2|');\n+      // Queries don't match host nodes of a directive that defines a content query.\n+      expect(asNativeElements(view.debugElement.children)).toHaveText('');\n \n       view.componentInstance.shouldShow = true;\n       view.detectChanges();\n-      // Difference in expected text in ivy comes from the fact that ivy queries don't match host\n-      // nodes of a directive that defines a content query.\n-      expect(asNativeElements(view.debugElement.children)).toHaveText(ivyEnabled ? '3|' : '2|3|');\n+      // Queries don't match host nodes of a directive that defines a content query.\n+      expect(asNativeElements(view.debugElement.children)).toHaveText('3|');\n     });\n \n     it('should be cleanly destroyed when a query crosses view boundaries', () => {\n@@ -233,17 +212,13 @@ describe('Query API', () => {\n           '<needs-query text=\"2\"><div *ngFor=\"let  i of list\" [text]=\"i\"></div></needs-query>' +\n           '<div text=\"4\"></div>';\n       const view = createTestCmpAndDetectChanges(MyComp0, template);\n-      // Difference in expected text in ivy comes from the fact that ivy queries don't match host\n-      // nodes of a directive that defines a content query.\n-      expect(asNativeElements(view.debugElement.children))\n-          .toHaveText(ivyEnabled ? '1d|2d|3d|' : '2|1d|2d|3d|');\n+      // Queries don't match host nodes of a directive that defines a content query.\n+      expect(asNativeElements(view.debugElement.children)).toHaveText('1d|2d|3d|');\n \n       view.componentInstance.list = ['3d', '2d'];\n       view.detectChanges();\n-      // Difference in expected text in ivy comes from the fact that ivy queries don't match host\n-      // nodes of a directive that defines a content query.\n-      expect(asNativeElements(view.debugElement.children))\n-          .toHaveText(ivyEnabled ? '3d|2d|' : '2|3d|2d|');\n+      // Queries don't match host nodes of a directive that defines a content query.\n+      expect(asNativeElements(view.debugElement.children)).toHaveText('3d|2d|');\n     });\n \n     it('should throw with descriptive error when query selectors are not present', () => {\n@@ -278,19 +253,6 @@ describe('Query API', () => {\n   });\n \n   describe('read a different token', () => {\n-    modifiedInIvy('Host nodes no longer match in ContentChild queries in Ivy')\n-        .it('should contain all content children', () => {\n-          const template =\n-              '<needs-content-children-read #q text=\"ca\"><div #q text=\"cb\"></div></needs-content-children-read>';\n-          const view = createTestCmpAndDetectChanges(MyComp0, template);\n-\n-          const comp: NeedsContentChildrenWithRead =\n-              view.debugElement.children[0].injector.get(NeedsContentChildrenWithRead);\n-          expect(comp.textDirChildren.map(textDirective => textDirective.text)).toEqual([\n-            'ca', 'cb'\n-          ]);\n-        });\n-\n     it('should contain the first content child', () => {\n       const template =\n           '<needs-content-child-read><div #q text=\"ca\"></div></needs-content-child-read>';\n@@ -656,71 +618,39 @@ describe('Query API', () => {\n       expect(q.query.length).toBe(0);\n     });\n \n-    // Note: this test is just document our current behavior, which we do for performance reasons.\n-    modifiedInIvy('Query results from views are reported upon view insert / detach')\n-        .it('should not affect queries for projected templates if views are detached or moved',\n-            () => {\n-              const template = `<manual-projecting #q>\n-              <ng-template let-x=\"x\">\n-                 <div [text]=\"x\"></div>\n-              </ng-template>\n-          </manual-projecting>`;\n-              const view = createTestCmpAndDetectChanges(MyComp0, template);\n-              const q = view.debugElement.children[0].references!['q'] as ManualProjecting;\n-              expect(q.query.length).toBe(0);\n-\n-              const view1 = q.vc.createEmbeddedView(q.template, {'x': '1'});\n-              const view2 = q.vc.createEmbeddedView(q.template, {'x': '2'});\n-              view.detectChanges();\n-              expect(q.query.map((d: TextDirective) => d.text)).toEqual(['1', '2']);\n-\n-              q.vc.detach(1);\n-              q.vc.detach(0);\n-\n-              view.detectChanges();\n-              expect(q.query.map((d: TextDirective) => d.text)).toEqual(['1', '2']);\n-\n-              q.vc.insert(view2);\n-              q.vc.insert(view1);\n-\n-              view.detectChanges();\n-              expect(q.query.map((d: TextDirective) => d.text)).toEqual(['1', '2']);\n-            });\n-\n-    onlyInIvy('Query results from views are reported upon view insert / detach')\n-        .it('should update queries when a view is detached and re-inserted', () => {\n-          const template = `<manual-projecting #q>\n+    it('should update queries when a view is detached and re-inserted', () => {\n+      const template = `<manual-projecting #q>\n               <ng-template let-x=\"x\">\n                  <div [text]=\"x\"></div>\n               </ng-template>\n           </manual-projecting>`;\n-          const view = createTestCmpAndDetectChanges(MyComp0, template);\n-          const q = view.debugElement.children[0].references!['q'] as ManualProjecting;\n-          expect(q.query.length).toBe(0);\n+      const view = createTestCmpAndDetectChanges(MyComp0, template);\n+      const q = view.debugElement.children[0].references!['q'] as ManualProjecting;\n+      expect(q.query.length).toBe(0);\n \n-          const view1 = q.vc.createEmbeddedView(q.template, {'x': '1'});\n-          const view2 = q.vc.createEmbeddedView(q.template, {'x': '2'});\n+      const view1 = q.vc.createEmbeddedView(q.template, {'x': '1'});\n+      const view2 = q.vc.createEmbeddedView(q.template, {'x': '2'});\n \n-          // 2 views were created and inserted so we've got 2 matching results\n-          view.detectChanges();\n-          expect(q.query.map((d: TextDirective) => d.text)).toEqual(['1', '2']);\n+      // 2 views were created and inserted so we've got 2 matching results\n+      view.detectChanges();\n+      expect(q.query.map((d: TextDirective) => d.text)).toEqual(['1', '2']);\n \n-          q.vc.detach(1);\n-          q.vc.detach(0);\n+      q.vc.detach(1);\n+      q.vc.detach(0);\n \n-          // both views were detached so query results from those views should not be reported\n-          view.detectChanges();\n-          expect(q.query.map((d: TextDirective) => d.text)).toEqual([]);\n+      // both views were detached so query results from those views should not be reported\n+      view.detectChanges();\n+      expect(q.query.map((d: TextDirective) => d.text)).toEqual([]);\n \n-          q.vc.insert(view2);\n-          q.vc.insert(view1);\n+      q.vc.insert(view2);\n+      q.vc.insert(view1);\n \n-          // previously detached views are re-inserted in the different order so:\n-          // - query results from the inserted views are reported again\n-          // - the order results from views reflects orders of views\n-          view.detectChanges();\n-          expect(q.query.map((d: TextDirective) => d.text)).toEqual(['2', '1']);\n-        });\n+      // previously detached views are re-inserted in the different order so:\n+      // - query results from the inserted views are reported again\n+      // - the order results from views reflects orders of views\n+      view.detectChanges();\n+      expect(q.query.map((d: TextDirective) => d.text)).toEqual(['2', '1']);\n+    });\n \n     it('should remove manually projected templates if their parent view is destroyed', () => {\n       const template = `\n@@ -742,62 +672,28 @@ describe('Query API', () => {\n       expect(q.query.length).toBe(0);\n     });\n \n-    modifiedInIvy('https://github.com/angular/angular/issues/15117 fixed in ivy')\n-        .it('should not throw if a content template is queried and created in the view during change detection',\n-            () => {\n-              @Component({\n-                selector: 'auto-projecting',\n-                template: '<div *ngIf=\"true; then: content\"></div>'\n-              })\n-              class AutoProjecting {\n-                // TODO(issue/24571):\n-                // remove '!'.\n-                @ContentChild(TemplateRef) content!: TemplateRef<any>;\n-\n-                // TODO(issue/24571):\n-                // remove '!'.\n-                @ContentChildren(TextDirective) query!: QueryList<TextDirective>;\n-              }\n-\n-              TestBed.configureTestingModule({declarations: [AutoProjecting]});\n-              const template =\n-                  '<auto-projecting #q><ng-template><div text=\"1\"></div></ng-template></auto-projecting>';\n-              const view = createTestCmpAndDetectChanges(MyComp0, template);\n-\n-              const q = view.debugElement.children[0].references!['q'];\n-              // This should be 1, but due to\n-              // https://github.com/angular/angular/issues/15117\n-              // this is 0.\n-              expect(q.query.length).toBe(0);\n-            });\n-\n-    if (ivyEnabled) {\n-      // The fixed version of the \"should not throw if a content template is queried and created in\n-      // the view during change detection\" test. This test is a different as ivy fixes\n-      // https://github.com/angular/angular/issues/15117 present in the view engine.\n-      it('should not throw if a content template is queried and created in the view during change detection - fixed in ivy',\n-         () => {\n-           @Component(\n-               {selector: 'auto-projecting', template: '<div *ngIf=\"true; then: content\"></div>'})\n-           class AutoProjecting {\n-             // TODO(issue/24571):\n-             // remove '!'.\n-             @ContentChild(TemplateRef) content!: TemplateRef<any>;\n-\n-             // TODO(issue/24571):\n-             // remove '!'.\n-             @ContentChildren(TextDirective) query!: QueryList<TextDirective>;\n-           }\n-\n-           TestBed.configureTestingModule({declarations: [AutoProjecting]});\n-           const template =\n-               '<auto-projecting #q><ng-template><div text=\"1\"></div></ng-template></auto-projecting>';\n-           const view = createTestCmpAndDetectChanges(MyComp0, template);\n+    it('should not throw if a content template is queried and created in the view during change detection - fixed in ivy',\n+       () => {\n+         @Component(\n+             {selector: 'auto-projecting', template: '<div *ngIf=\"true; then: content\"></div>'})\n+         class AutoProjecting {\n+           // TODO(issue/24571):\n+           // remove '!'.\n+           @ContentChild(TemplateRef) content!: TemplateRef<any>;\n+\n+           // TODO(issue/24571):\n+           // remove '!'.\n+           @ContentChildren(TextDirective) query!: QueryList<TextDirective>;\n+         }\n+\n+         TestBed.configureTestingModule({declarations: [AutoProjecting]});\n+         const template =\n+             '<auto-projecting #q><ng-template><div text=\"1\"></div></ng-template></auto-projecting>';\n+         const view = createTestCmpAndDetectChanges(MyComp0, template);\n \n-           const q = view.debugElement.children[0].references!['q'];\n-           expect(q.query.length).toBe(1);\n-         });\n-    }\n+         const q = view.debugElement.children[0].references!['q'];\n+         expect(q.query.length).toBe(1);\n+       });\n   });\n });\n \n@@ -1111,7 +1007,7 @@ class NeedsViewContainerWithRead {\n   // TODO(issue/24571): remove '!'.\n   @ViewChild('nonExisting', {read: ViewContainerRef}) nonExistingVar!: ViewContainerRef;\n   // TODO(issue/24571): remove '!'.\n-  @ContentChild(TemplateRef, {static: true}) template !: TemplateRef<Object>;\n+  @ContentChild(TemplateRef, {static: true}) template!: TemplateRef<Object>;\n \n   createView() {\n     this.vc.createEmbeddedView(this.template);\n@@ -1136,7 +1032,7 @@ class MyCompBroken0 {\n @Component({selector: 'manual-projecting', template: '<div #vc></div>'})\n class ManualProjecting {\n   // TODO(issue/24571): remove '!'.\n-  @ContentChild(TemplateRef, {static: true}) template !: TemplateRef<any>;\n+  @ContentChild(TemplateRef, {static: true}) template!: TemplateRef<any>;\n \n   // TODO(issue/24571): remove '!'.\n   @ViewChild('vc', {read: ViewContainerRef}) vc!: ViewContainerRef;"
        },
        {
            "sha": "07cfae337c005728c532e9072fb6029ea415e2e0",
            "filename": "packages/core/test/linker/regression_integration_spec.ts",
            "status": "modified",
            "additions": 376,
            "deletions": 458,
            "changes": 834,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fregression_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fregression_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Fregression_integration_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -7,561 +7,479 @@\n  */\n \n import {DOCUMENT, ɵgetDOM as getDOM} from '@angular/common';\n-import {ANALYZE_FOR_ENTRY_COMPONENTS, ApplicationRef, Component, ComponentRef, ContentChild, destroyPlatform, Directive, ErrorHandler, EventEmitter, HostListener, InjectionToken, Injector, Input, NgModule, NgModuleRef, NgZone, Output, Pipe, PipeTransform, Provider, QueryList, Renderer2, SimpleChanges, TemplateRef, ViewChild, ViewChildren, ViewContainerRef, ɵivyEnabled as ivyEnabled} from '@angular/core';\n+import {ANALYZE_FOR_ENTRY_COMPONENTS, ApplicationRef, Component, ComponentRef, ContentChild, destroyPlatform, Directive, ErrorHandler, EventEmitter, HostListener, InjectionToken, Injector, Input, NgModule, NgModuleRef, NgZone, Output, Pipe, PipeTransform, Provider, QueryList, Renderer2, SimpleChanges, TemplateRef, ViewChildren, ViewContainerRef} from '@angular/core';\n import {fakeAsync, inject, TestBed, tick} from '@angular/core/testing';\n import {BrowserModule, By} from '@angular/platform-browser';\n import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {modifiedInIvy, onlyInIvy} from '@angular/private/testing';\n \n-if (ivyEnabled) {\n-  describe('ivy', () => {\n-    declareTests();\n+describe('regressions', () => {\n+  beforeEach(() => {\n+    TestBed.configureTestingModule({declarations: [MyComp1, PlatformPipe]});\n   });\n-} else {\n-  describe('jit', () => {\n-    declareTests({useJit: true});\n-  });\n-  describe('no jit', () => {\n-    declareTests({useJit: false});\n-  });\n-}\n \n-declareTestsUsingBootstrap();\n+  describe('platform pipes', () => {\n+    it('should overwrite them by custom pipes', () => {\n+      TestBed.configureTestingModule({declarations: [CustomPipe]});\n+      const template = '{{true | somePipe}}';\n+      TestBed.overrideComponent(MyComp1, {set: {template}});\n+      const fixture = TestBed.createComponent(MyComp1);\n \n-function declareTests(config?: {useJit: boolean}) {\n-  // Place to put reproductions for regressions\n-  describe('regressions', () => {\n-    beforeEach(() => {\n-      TestBed.configureTestingModule({declarations: [MyComp1, PlatformPipe]});\n+      fixture.detectChanges();\n+      expect(fixture.nativeElement).toHaveText('someCustomPipe');\n     });\n+  });\n \n-    describe('platform pipes', () => {\n-      beforeEach(() => {\n-        TestBed.configureCompiler({...config});\n-      });\n-\n-      it('should overwrite them by custom pipes', () => {\n-        TestBed.configureTestingModule({declarations: [CustomPipe]});\n-        const template = '{{true | somePipe}}';\n-        TestBed.overrideComponent(MyComp1, {set: {template}});\n-        const fixture = TestBed.createComponent(MyComp1);\n+  describe('expressions', () => {\n+    it('should evaluate conditional and boolean operators with right precedence - #8244', () => {\n+      const template = `{{'red' + (true ? ' border' : '')}}`;\n+      TestBed.overrideComponent(MyComp1, {set: {template}});\n+      const fixture = TestBed.createComponent(MyComp1);\n \n-        fixture.detectChanges();\n-        expect(fixture.nativeElement).toHaveText('someCustomPipe');\n-      });\n+      fixture.detectChanges();\n+      expect(fixture.nativeElement).toHaveText('red border');\n     });\n \n-    describe('expressions', () => {\n-      it('should evaluate conditional and boolean operators with right precedence - #8244', () => {\n-        const template = `{{'red' + (true ? ' border' : '')}}`;\n-        TestBed.overrideComponent(MyComp1, {set: {template}});\n-        const fixture = TestBed.createComponent(MyComp1);\n-\n-        fixture.detectChanges();\n-        expect(fixture.nativeElement).toHaveText('red border');\n-      });\n-\n-      it('should evaluate conditional and unary operators with right precedence - #8235', () => {\n-        const template = `{{!null?.length}}`;\n-        TestBed.overrideComponent(MyComp1, {set: {template}});\n-        const fixture = TestBed.createComponent(MyComp1);\n+    it('should evaluate conditional and unary operators with right precedence - #8235', () => {\n+      const template = `{{!null?.length}}`;\n+      TestBed.overrideComponent(MyComp1, {set: {template}});\n+      const fixture = TestBed.createComponent(MyComp1);\n \n-        fixture.detectChanges();\n-        expect(fixture.nativeElement).toHaveText('true');\n-      });\n+      fixture.detectChanges();\n+      expect(fixture.nativeElement).toHaveText('true');\n+    });\n \n-      it('should only evaluate stateful pipes once - #10639', () => {\n-        TestBed.configureTestingModule({declarations: [CountingPipe]});\n-        const template = '{{(null|countingPipe)?.value}}';\n-        TestBed.overrideComponent(MyComp1, {set: {template}});\n-        const fixture = TestBed.createComponent(MyComp1);\n+    it('should only evaluate stateful pipes once - #10639', () => {\n+      TestBed.configureTestingModule({declarations: [CountingPipe]});\n+      const template = '{{(null|countingPipe)?.value}}';\n+      TestBed.overrideComponent(MyComp1, {set: {template}});\n+      const fixture = TestBed.createComponent(MyComp1);\n \n-        CountingPipe.reset();\n-        fixture.detectChanges(/* checkNoChanges */ false);\n-        expect(fixture.nativeElement).toHaveText('counting pipe value');\n-        expect(CountingPipe.calls).toBe(1);\n-      });\n+      CountingPipe.reset();\n+      fixture.detectChanges(/* checkNoChanges */ false);\n+      expect(fixture.nativeElement).toHaveText('counting pipe value');\n+      expect(CountingPipe.calls).toBe(1);\n+    });\n \n-      it('should only update the bound property when using asyncPipe - #15205', fakeAsync(() => {\n-           @Component({template: '<div myDir [a]=\"p | async\" [b]=\"2\"></div>'})\n-           class MyComp {\n-             p = Promise.resolve(1);\n+    it('should only update the bound property when using asyncPipe - #15205', fakeAsync(() => {\n+         @Component({template: '<div myDir [a]=\"p | async\" [b]=\"2\"></div>'})\n+         class MyComp {\n+           p = Promise.resolve(1);\n+         }\n+\n+         @Directive({selector: '[myDir]'})\n+         class MyDir {\n+           setterCalls: {[key: string]: any} = {};\n+           // TODO(issue/24571): remove '!'.\n+           changes!: SimpleChanges;\n+\n+           @Input()\n+           set a(v: number) {\n+             this.setterCalls['a'] = v;\n+           }\n+           @Input()\n+           set b(v: number) {\n+             this.setterCalls['b'] = v;\n            }\n \n-           @Directive({selector: '[myDir]'})\n-           class MyDir {\n-             setterCalls: {[key: string]: any} = {};\n-             // TODO(issue/24571): remove '!'.\n-             changes!: SimpleChanges;\n-\n-             @Input()\n-             set a(v: number) {\n-               this.setterCalls['a'] = v;\n-             }\n-             @Input()\n-             set b(v: number) {\n-               this.setterCalls['b'] = v;\n-             }\n-\n-             ngOnChanges(changes: SimpleChanges) {\n-               this.changes = changes;\n-             }\n+           ngOnChanges(changes: SimpleChanges) {\n+             this.changes = changes;\n            }\n+         }\n \n-           TestBed.configureTestingModule({declarations: [MyDir, MyComp]});\n-           const fixture = TestBed.createComponent(MyComp);\n-           const dir = fixture.debugElement.query(By.directive(MyDir)).injector.get(MyDir) as MyDir;\n+         TestBed.configureTestingModule({declarations: [MyDir, MyComp]});\n+         const fixture = TestBed.createComponent(MyComp);\n+         const dir = fixture.debugElement.query(By.directive(MyDir)).injector.get(MyDir) as MyDir;\n \n-           fixture.detectChanges();\n-           expect(dir.setterCalls).toEqual({'a': null, 'b': 2});\n-           expect(Object.keys(dir.changes)).toEqual(['a', 'b']);\n+         fixture.detectChanges();\n+         expect(dir.setterCalls).toEqual({'a': null, 'b': 2});\n+         expect(Object.keys(dir.changes)).toEqual(['a', 'b']);\n \n-           dir.setterCalls = {};\n-           dir.changes = {};\n+         dir.setterCalls = {};\n+         dir.changes = {};\n \n-           tick();\n-           fixture.detectChanges();\n+         tick();\n+         fixture.detectChanges();\n \n-           expect(dir.setterCalls).toEqual({'a': 1});\n-           expect(Object.keys(dir.changes)).toEqual(['a']);\n-         }));\n+         expect(dir.setterCalls).toEqual({'a': 1});\n+         expect(Object.keys(dir.changes)).toEqual(['a']);\n+       }));\n \n-      it('should only evaluate methods once - #10639', () => {\n-        TestBed.configureTestingModule({declarations: [MyCountingComp]});\n-        const template = '{{method()?.value}}';\n-        TestBed.overrideComponent(MyCountingComp, {set: {template}});\n-        const fixture = TestBed.createComponent(MyCountingComp);\n+    it('should only evaluate methods once - #10639', () => {\n+      TestBed.configureTestingModule({declarations: [MyCountingComp]});\n+      const template = '{{method()?.value}}';\n+      TestBed.overrideComponent(MyCountingComp, {set: {template}});\n+      const fixture = TestBed.createComponent(MyCountingComp);\n \n-        MyCountingComp.reset();\n-        fixture.detectChanges(/* checkNoChanges */ false);\n-        expect(fixture.nativeElement).toHaveText('counting method value');\n-        expect(MyCountingComp.calls).toBe(1);\n-      });\n+      MyCountingComp.reset();\n+      fixture.detectChanges(/* checkNoChanges */ false);\n+      expect(fixture.nativeElement).toHaveText('counting method value');\n+      expect(MyCountingComp.calls).toBe(1);\n+    });\n \n-      it('should evaluate a conditional in a statement binding', () => {\n-        @Component({selector: 'some-comp', template: '<p (click)=\"nullValue?.click()\"></p>'})\n-        class SomeComponent {\n-          // TODO(issue/24571): remove '!'.\n-          nullValue!: SomeReferencedClass;\n-        }\n+    it('should evaluate a conditional in a statement binding', () => {\n+      @Component({selector: 'some-comp', template: '<p (click)=\"nullValue?.click()\"></p>'})\n+      class SomeComponent {\n+        // TODO(issue/24571): remove '!'.\n+        nullValue!: SomeReferencedClass;\n+      }\n \n-        class SomeReferencedClass {\n-          click() {}\n-        }\n+      class SomeReferencedClass {\n+        click() {}\n+      }\n \n-        expect(() => {\n-          const fixture = TestBed.configureTestingModule({declarations: [SomeComponent]})\n-                              .createComponent(SomeComponent);\n+      expect(() => {\n+        const fixture = TestBed.configureTestingModule({declarations: [SomeComponent]})\n+                            .createComponent(SomeComponent);\n \n-          fixture.detectChanges(/* checkNoChanges */ false);\n-        }).not.toThrow();\n-      });\n+        fixture.detectChanges(/* checkNoChanges */ false);\n+      }).not.toThrow();\n     });\n+  });\n \n-    describe('providers', () => {\n-      function createInjector(providers: Provider[]): Injector {\n-        TestBed.overrideComponent(MyComp1, {add: {providers}});\n-        return TestBed.createComponent(MyComp1).componentInstance.injector;\n-      }\n+  describe('providers', () => {\n+    function createInjector(providers: Provider[]): Injector {\n+      TestBed.overrideComponent(MyComp1, {add: {providers}});\n+      return TestBed.createComponent(MyComp1).componentInstance.injector;\n+    }\n \n-      it('should support providers with an InjectionToken that contains a `.` in the name', () => {\n-        const token = new InjectionToken('a.b');\n-        const tokenValue = 1;\n-        const injector = createInjector([{provide: token, useValue: tokenValue}]);\n-        expect(injector.get(token)).toEqual(tokenValue);\n-      });\n+    it('should support providers with an InjectionToken that contains a `.` in the name', () => {\n+      const token = new InjectionToken('a.b');\n+      const tokenValue = 1;\n+      const injector = createInjector([{provide: token, useValue: tokenValue}]);\n+      expect(injector.get(token)).toEqual(tokenValue);\n+    });\n \n-      it('should support providers with string token with a `.` in it', () => {\n-        const token = 'a.b';\n-        const tokenValue = 1;\n-        const injector = createInjector([{provide: token, useValue: tokenValue}]);\n+    it('should support providers with string token with a `.` in it', () => {\n+      const token = 'a.b';\n+      const tokenValue = 1;\n+      const injector = createInjector([{provide: token, useValue: tokenValue}]);\n \n-        expect(injector.get(token)).toEqual(tokenValue);\n-      });\n+      expect(injector.get(token)).toEqual(tokenValue);\n+    });\n \n-      it('should support providers with an anonymous function as token', () => {\n-        const token = () => true;\n-        const tokenValue = 1;\n-        const injector = createInjector([{provide: token, useValue: tokenValue}]);\n+    it('should support providers with an anonymous function as token', () => {\n+      const token = () => true;\n+      const tokenValue = 1;\n+      const injector = createInjector([{provide: token, useValue: tokenValue}]);\n \n-        expect(injector.get(token)).toEqual(tokenValue);\n-      });\n+      expect(injector.get(token)).toEqual(tokenValue);\n+    });\n \n-      it('should support providers with an InjectionToken that has a StringMap as value', () => {\n-        const token1 = new InjectionToken('someToken');\n-        const token2 = new InjectionToken('someToken');\n-        const tokenValue1 = {'a': 1};\n-        const tokenValue2 = {'a': 1};\n-        const injector = createInjector(\n-            [{provide: token1, useValue: tokenValue1}, {provide: token2, useValue: tokenValue2}]);\n+    it('should support providers with an InjectionToken that has a StringMap as value', () => {\n+      const token1 = new InjectionToken('someToken');\n+      const token2 = new InjectionToken('someToken');\n+      const tokenValue1 = {'a': 1};\n+      const tokenValue2 = {'a': 1};\n+      const injector = createInjector(\n+          [{provide: token1, useValue: tokenValue1}, {provide: token2, useValue: tokenValue2}]);\n \n-        expect(injector.get(token1)).toEqual(tokenValue1);\n-        expect(injector.get(token2)).toEqual(tokenValue2);\n-      });\n+      expect(injector.get(token1)).toEqual(tokenValue1);\n+      expect(injector.get(token2)).toEqual(tokenValue2);\n+    });\n \n-      it('should support providers that have a `name` property with a number value', () => {\n-        class TestClass {\n-          constructor(public name: number) {}\n-        }\n-        const data = [new TestClass(1), new TestClass(2)];\n-        const injector = createInjector([{provide: 'someToken', useValue: data}]);\n-        expect(injector.get('someToken')).toEqual(data);\n-      });\n+    it('should support providers that have a `name` property with a number value', () => {\n+      class TestClass {\n+        constructor(public name: number) {}\n+      }\n+      const data = [new TestClass(1), new TestClass(2)];\n+      const injector = createInjector([{provide: 'someToken', useValue: data}]);\n+      expect(injector.get('someToken')).toEqual(data);\n+    });\n \n-      describe('ANALYZE_FOR_ENTRY_COMPONENTS providers', () => {\n-        it('should support class instances', () => {\n-          class SomeObject {\n-            someMethod() {}\n-          }\n+    describe('ANALYZE_FOR_ENTRY_COMPONENTS providers', () => {\n+      it('should support class instances', () => {\n+        class SomeObject {\n+          someMethod() {}\n+        }\n \n-          expect(() => createInjector([\n-                   {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: new SomeObject(), multi: true}\n-                 ]))\n-              .not.toThrow();\n-        });\n+        expect(\n+            () => createInjector(\n+                [{provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: new SomeObject(), multi: true}]))\n+            .not.toThrow();\n       });\n     });\n+  });\n \n-    it('should allow logging a previous elements class binding via interpolation', () => {\n-      const template = `<div [class.a]=\"true\" #el>Class: {{el.className}}</div>`;\n-      TestBed.overrideComponent(MyComp1, {set: {template}});\n-      const fixture = TestBed.createComponent(MyComp1);\n-\n-      fixture.detectChanges();\n-      expect(fixture.nativeElement).toHaveText('Class: a');\n-    });\n+  it('should allow logging a previous elements class binding via interpolation', () => {\n+    const template = `<div [class.a]=\"true\" #el>Class: {{el.className}}</div>`;\n+    TestBed.overrideComponent(MyComp1, {set: {template}});\n+    const fixture = TestBed.createComponent(MyComp1);\n \n-    it('should support ngClass before a component and content projection inside of an ngIf', () => {\n-      TestBed.configureTestingModule({declarations: [CmpWithNgContent]});\n-      const template = `A<cmp-content *ngIf=\"true\" [ngClass]=\"'red'\">B</cmp-content>C`;\n-      TestBed.overrideComponent(MyComp1, {set: {template}});\n-      const fixture = TestBed.createComponent(MyComp1);\n+    fixture.detectChanges();\n+    expect(fixture.nativeElement).toHaveText('Class: a');\n+  });\n \n-      fixture.detectChanges();\n-      expect(fixture.nativeElement).toHaveText('ABC');\n-    });\n+  it('should support ngClass before a component and content projection inside of an ngIf', () => {\n+    TestBed.configureTestingModule({declarations: [CmpWithNgContent]});\n+    const template = `A<cmp-content *ngIf=\"true\" [ngClass]=\"'red'\">B</cmp-content>C`;\n+    TestBed.overrideComponent(MyComp1, {set: {template}});\n+    const fixture = TestBed.createComponent(MyComp1);\n \n-    it('should handle mutual recursion entered from multiple sides - #7084', () => {\n-      TestBed.configureTestingModule({declarations: [FakeRecursiveComp, LeftComp, RightComp]});\n-      const fixture = TestBed.createComponent(FakeRecursiveComp);\n+    fixture.detectChanges();\n+    expect(fixture.nativeElement).toHaveText('ABC');\n+  });\n \n-      fixture.detectChanges();\n-      expect(fixture.nativeElement).toHaveText('[]');\n-    });\n+  it('should handle mutual recursion entered from multiple sides - #7084', () => {\n+    TestBed.configureTestingModule({declarations: [FakeRecursiveComp, LeftComp, RightComp]});\n+    const fixture = TestBed.createComponent(FakeRecursiveComp);\n \n-    it('should generate the correct output when constructors have the same name', () => {\n-      function ComponentFactory(selector: string, template: string) {\n-        @Component({selector, template})\n-        class MyComponent {\n-        }\n-        return MyComponent;\n-      }\n-      const HeroComponent = ComponentFactory('my-hero', 'my hero');\n-      const VillainComponent = ComponentFactory('a-villain', 'a villain');\n-      const MainComponent = ComponentFactory(\n-          'my-app', 'I was saved by <my-hero></my-hero> from <a-villain></a-villain>.');\n-\n-      TestBed.configureTestingModule(\n-          {declarations: [HeroComponent, VillainComponent, MainComponent]});\n-      const fixture = TestBed.createComponent(MainComponent);\n-      expect(fixture.nativeElement).toHaveText('I was saved by my hero from a villain.');\n-    });\n+    fixture.detectChanges();\n+    expect(fixture.nativeElement).toHaveText('[]');\n+  });\n \n-    it('should allow to use the renderer outside of views', () => {\n-      @Component({template: ''})\n-      class MyComp {\n-        constructor(public renderer: Renderer2) {}\n+  it('should generate the correct output when constructors have the same name', () => {\n+    function ComponentFactory(selector: string, template: string) {\n+      @Component({selector, template})\n+      class MyComponent {\n       }\n+      return MyComponent;\n+    }\n+    const HeroComponent = ComponentFactory('my-hero', 'my hero');\n+    const VillainComponent = ComponentFactory('a-villain', 'a villain');\n+    const MainComponent = ComponentFactory(\n+        'my-app', 'I was saved by <my-hero></my-hero> from <a-villain></a-villain>.');\n+\n+    TestBed.configureTestingModule(\n+        {declarations: [HeroComponent, VillainComponent, MainComponent]});\n+    const fixture = TestBed.createComponent(MainComponent);\n+    expect(fixture.nativeElement).toHaveText('I was saved by my hero from a villain.');\n+  });\n \n-      TestBed.configureTestingModule({declarations: [MyComp]});\n-      const ctx = TestBed.createComponent(MyComp);\n+  it('should allow to use the renderer outside of views', () => {\n+    @Component({template: ''})\n+    class MyComp {\n+      constructor(public renderer: Renderer2) {}\n+    }\n \n-      const txtNode = ctx.componentInstance.renderer.createText('test');\n-      expect(txtNode).toHaveText('test');\n-    });\n+    TestBed.configureTestingModule({declarations: [MyComp]});\n+    const ctx = TestBed.createComponent(MyComp);\n \n-    it('should not recreate TemplateRef references during dirty checking', () => {\n-      @Component({template: '<div [someDir]=\"someRef\"></div><ng-template #someRef></ng-template>'})\n-      class MyComp {\n-      }\n+    const txtNode = ctx.componentInstance.renderer.createText('test');\n+    expect(txtNode).toHaveText('test');\n+  });\n \n-      @Directive({selector: '[someDir]'})\n-      class MyDir {\n-        // TODO(issue/24571): remove '!'.\n-        @Input('someDir') template !: TemplateRef<any>;\n-      }\n+  it('should not recreate TemplateRef references during dirty checking', () => {\n+    @Component({template: '<div [someDir]=\"someRef\"></div><ng-template #someRef></ng-template>'})\n+    class MyComp {\n+    }\n \n-      const ctx =\n-          TestBed.configureTestingModule({declarations: [MyComp, MyDir]}).createComponent(MyComp);\n-      const dir = <MyDir>ctx.debugElement.query(By.directive(MyDir)).injector.get(MyDir);\n+    @Directive({selector: '[someDir]'})\n+    class MyDir {\n+      // TODO(issue/24571): remove '!'.\n+      @Input('someDir') template!: TemplateRef<any>;\n+    }\n \n-      expect(dir.template).toBeUndefined();\n+    const ctx =\n+        TestBed.configureTestingModule({declarations: [MyComp, MyDir]}).createComponent(MyComp);\n+    const dir = <MyDir>ctx.debugElement.query(By.directive(MyDir)).injector.get(MyDir);\n \n-      ctx.detectChanges();\n-      const template = dir.template;\n-      expect(template).toBeDefined();\n+    expect(dir.template).toBeUndefined();\n \n-      ctx.detectChanges();\n-      expect(dir.template).toBe(template);\n-    });\n+    ctx.detectChanges();\n+    const template = dir.template;\n+    expect(template).toBeDefined();\n \n-    it('should not recreate ViewContainerRefs in queries', () => {\n-      @Component({template: '<div #vc></div><div *ngIf=\"show\" #vc></div>'})\n-      class MyComp {\n-        // TODO(issue/24571): remove '!'.\n-        @ViewChildren('vc', {read: ViewContainerRef}) viewContainers!: QueryList<ViewContainerRef>;\n+    ctx.detectChanges();\n+    expect(dir.template).toBe(template);\n+  });\n \n-        show = true;\n-      }\n+  it('should not recreate ViewContainerRefs in queries', () => {\n+    @Component({template: '<div #vc></div><div *ngIf=\"show\" #vc></div>'})\n+    class MyComp {\n+      // TODO(issue/24571): remove '!'.\n+      @ViewChildren('vc', {read: ViewContainerRef}) viewContainers!: QueryList<ViewContainerRef>;\n \n-      const ctx = TestBed.configureTestingModule({declarations: [MyComp]}).createComponent(MyComp);\n+      show = true;\n+    }\n \n-      ctx.componentInstance.show = true;\n-      ctx.detectChanges();\n-      expect(ctx.componentInstance.viewContainers.length).toBe(2);\n-      const vc = ctx.componentInstance.viewContainers.first;\n-      expect(vc).toBeDefined();\n+    const ctx = TestBed.configureTestingModule({declarations: [MyComp]}).createComponent(MyComp);\n \n-      ctx.componentInstance.show = false;\n-      ctx.detectChanges();\n-      expect(ctx.componentInstance.viewContainers.first).toBe(vc);\n-    });\n+    ctx.componentInstance.show = true;\n+    ctx.detectChanges();\n+    expect(ctx.componentInstance.viewContainers.length).toBe(2);\n+    const vc = ctx.componentInstance.viewContainers.first;\n+    expect(vc).toBeDefined();\n \n-    it('should not throw when encountering an empty class attribute', () => {\n-      const template = '<div class=\"\"></div>';\n-      TestBed.overrideComponent(MyComp1, {set: {template}});\n+    ctx.componentInstance.show = false;\n+    ctx.detectChanges();\n+    expect(ctx.componentInstance.viewContainers.first).toBe(vc);\n+  });\n \n-      expect(() => TestBed.createComponent(MyComp1)).not.toThrow();\n-    });\n+  it('should not throw when encountering an empty class attribute', () => {\n+    const template = '<div class=\"\"></div>';\n+    TestBed.overrideComponent(MyComp1, {set: {template}});\n \n-    describe('empty templates - #15143', () => {\n-      it('should allow empty components', () => {\n-        @Component({template: ''})\n-        class MyComp {\n-        }\n+    expect(() => TestBed.createComponent(MyComp1)).not.toThrow();\n+  });\n \n-        const fixture =\n-            TestBed.configureTestingModule({declarations: [MyComp]}).createComponent(MyComp);\n-        fixture.detectChanges();\n+  describe('empty templates - #15143', () => {\n+    it('should allow empty components', () => {\n+      @Component({template: ''})\n+      class MyComp {\n+      }\n \n-        expect(fixture.debugElement.childNodes.length).toBe(0);\n-      });\n+      const fixture =\n+          TestBed.configureTestingModule({declarations: [MyComp]}).createComponent(MyComp);\n+      fixture.detectChanges();\n \n-      modifiedInIvy('Comment node order changed')\n-          .it('should allow empty embedded templates', () => {\n-            @Component({template: '<ng-template [ngIf]=\"true\"></ng-template>'})\n-            class MyComp {\n-            }\n-\n-            const fixture =\n-                TestBed.configureTestingModule({declarations: [MyComp]}).createComponent(MyComp);\n-            fixture.detectChanges();\n-\n-            // Note: We always need to create at least a comment in an embedded template,\n-            // so we can append other templates after it.\n-            // 1 comment for the anchor,\n-            // 1 comment for the empty embedded template.\n-            expect(fixture.debugElement.childNodes.length).toBe(2);\n-          });\n+      expect(fixture.debugElement.childNodes.length).toBe(0);\n     });\n+  });\n \n-    modifiedInIvy('Static ViewChild and ContentChild queries are resolved in update mode')\n-        .it('should support @ContentChild and @Input on the same property for static queries',\n-            () => {\n-              @Directive({selector: 'test'})\n-              class Test {\n-                // TODO(issue/24571): remove '!'.\n-                @Input() @ContentChild(TemplateRef, {static: true}) tpl!: TemplateRef<any>;\n-              }\n-\n-              @Component({\n-                selector: 'my-app',\n-                template: `\n-          <test></test><br>\n-          <test><ng-template>Custom as a child</ng-template></test><br>\n-          <ng-template #custom>Custom as a binding</ng-template>\n-          <test [tpl]=\"custom\"></test><br>\n-        `\n-              })\n-              class App {\n-              }\n-\n-              const fixture =\n-                  TestBed.configureTestingModule({declarations: [App, Test]}).createComponent(App);\n-              fixture.detectChanges();\n-\n-              const testDirs = fixture.debugElement.queryAll(By.directive(Test))\n-                                   .map(el => el.injector.get(Test));\n-              expect(testDirs[0].tpl).toBeUndefined();\n-              expect(testDirs[1].tpl).toBeDefined();\n-              expect(testDirs[2].tpl).toBeDefined();\n-            });\n-\n-    onlyInIvy('Ivy does not support @ContentChild and @Input on the same property')\n-        .it('should throw if @ContentChild and @Input are on the same property', () => {\n-          @Directive({selector: 'test'})\n-          class Test {\n-            @Input() @ContentChild(TemplateRef, {static: true}) tpl!: TemplateRef<any>;\n-          }\n+  it('should throw if @ContentChild and @Input are on the same property', () => {\n+    @Directive({selector: 'test'})\n+    class Test {\n+      @Input() @ContentChild(TemplateRef, {static: true}) tpl!: TemplateRef<any>;\n+    }\n \n-          @Component({selector: 'my-app', template: `<test></test>`})\n-          class App {\n-          }\n+    @Component({selector: 'my-app', template: `<test></test>`})\n+    class App {\n+    }\n \n-          expect(() => {\n-            TestBed.configureTestingModule({declarations: [App, Test]}).createComponent(App);\n-          }).toThrowError(/Cannot combine @Input decorators with query decorators/);\n-        });\n+    expect(() => {\n+      TestBed.configureTestingModule({declarations: [App, Test]}).createComponent(App);\n+    }).toThrowError(/Cannot combine @Input decorators with query decorators/);\n+  });\n \n-    it('should not add ng-version for dynamically created components', () => {\n-      @Component({template: ''})\n-      class App {\n-      }\n+  it('should not add ng-version for dynamically created components', () => {\n+    @Component({template: ''})\n+    class App {\n+    }\n \n-      @NgModule({declarations: [App], entryComponents: [App]})\n-      class MyModule {\n-      }\n+    @NgModule({declarations: [App], entryComponents: [App]})\n+    class MyModule {\n+    }\n \n-      const modRef = TestBed.configureTestingModule({imports: [MyModule]}).get(NgModuleRef) as\n-          NgModuleRef<MyModule>;\n-      const compRef =\n-          modRef.componentFactoryResolver.resolveComponentFactory(App).create(Injector.NULL);\n+    const modRef = TestBed.configureTestingModule({imports: [MyModule]}).get(NgModuleRef) as\n+        NgModuleRef<MyModule>;\n+    const compRef =\n+        modRef.componentFactoryResolver.resolveComponentFactory(App).create(Injector.NULL);\n \n-      expect(compRef.location.nativeElement.hasAttribute('ng-version')).toBe(false);\n-    });\n+    expect(compRef.location.nativeElement.hasAttribute('ng-version')).toBe(false);\n   });\n-}\n+});\n \n-function declareTestsUsingBootstrap() {\n-  // Place to put reproductions for regressions\n-  describe('regressions using bootstrap', () => {\n-    const COMP_SELECTOR = 'root-comp';\n+describe('regressions using bootstrap', () => {\n+  const COMP_SELECTOR = 'root-comp';\n \n-    class MockConsole {\n-      errors: any[][] = [];\n-      error(...s: any[]): void {\n-        this.errors.push(s);\n-      }\n+  class MockConsole {\n+    errors: any[][] = [];\n+    error(...s: any[]): void {\n+      this.errors.push(s);\n     }\n+  }\n \n-    let logger: MockConsole;\n-    let errorHandler: ErrorHandler;\n+  let logger: MockConsole;\n+  let errorHandler: ErrorHandler;\n \n-    beforeEach(inject([DOCUMENT], (doc: any) => {\n-      destroyPlatform();\n-      const el = getDOM().createElement(COMP_SELECTOR, doc);\n-      doc.body.appendChild(el);\n+  beforeEach(inject([DOCUMENT], (doc: any) => {\n+    destroyPlatform();\n+    const el = getDOM().createElement(COMP_SELECTOR, doc);\n+    doc.body.appendChild(el);\n \n-      logger = new MockConsole();\n-      errorHandler = new ErrorHandler();\n-      (errorHandler as any)._console = logger as any;\n-    }));\n+    logger = new MockConsole();\n+    errorHandler = new ErrorHandler();\n+    (errorHandler as any)._console = logger as any;\n+  }));\n \n-    afterEach(() => {\n-      destroyPlatform();\n-    });\n+  afterEach(() => {\n+    destroyPlatform();\n+  });\n \n-    if (getDOM().supportsDOMEvents) {\n-      // This test needs a real DOM....\n-\n-      it('should keep change detecting if there was an error', (done) => {\n-        @Component({\n-          selector: COMP_SELECTOR,\n-          template:\n-              '<button (click)=\"next()\"></button><button (click)=\"nextAndThrow()\"></button><button (dirClick)=\"nextAndThrow()\"></button><span>Value:{{value}}</span><span>{{throwIfNeeded()}}</span>'\n-        })\n-        class ErrorComp {\n-          value = 0;\n-          thrownValue = 0;\n-          next() {\n-            this.value++;\n-          }\n-          nextAndThrow() {\n-            this.value++;\n-            this.throwIfNeeded();\n-          }\n-          throwIfNeeded() {\n-            NgZone.assertInAngularZone();\n-            if (this.thrownValue !== this.value) {\n-              this.thrownValue = this.value;\n-              throw new Error(`Error: ${this.value}`);\n-            }\n+  if (getDOM().supportsDOMEvents) {\n+    // This test needs a real DOM....\n+\n+    it('should keep change detecting if there was an error', (done) => {\n+      @Component({\n+        selector: COMP_SELECTOR,\n+        template:\n+            '<button (click)=\"next()\"></button><button (click)=\"nextAndThrow()\"></button><button (dirClick)=\"nextAndThrow()\"></button><span>Value:{{value}}</span><span>{{throwIfNeeded()}}</span>'\n+      })\n+      class ErrorComp {\n+        value = 0;\n+        thrownValue = 0;\n+        next() {\n+          this.value++;\n+        }\n+        nextAndThrow() {\n+          this.value++;\n+          this.throwIfNeeded();\n+        }\n+        throwIfNeeded() {\n+          NgZone.assertInAngularZone();\n+          if (this.thrownValue !== this.value) {\n+            this.thrownValue = this.value;\n+            throw new Error(`Error: ${this.value}`);\n           }\n         }\n+      }\n \n-        @Directive({selector: '[dirClick]'})\n-        class EventDir {\n-          @Output() dirClick = new EventEmitter();\n+      @Directive({selector: '[dirClick]'})\n+      class EventDir {\n+        @Output() dirClick = new EventEmitter();\n \n-          @HostListener('click', ['$event'])\n-          onClick(event: any) {\n-            this.dirClick.next(event);\n-          }\n+        @HostListener('click', ['$event'])\n+        onClick(event: any) {\n+          this.dirClick.next(event);\n         }\n+      }\n \n-        @NgModule({\n-          imports: [BrowserModule],\n-          declarations: [ErrorComp, EventDir],\n-          bootstrap: [ErrorComp],\n-          providers: [{provide: ErrorHandler, useValue: errorHandler}],\n-        })\n-        class TestModule {\n-        }\n+      @NgModule({\n+        imports: [BrowserModule],\n+        declarations: [ErrorComp, EventDir],\n+        bootstrap: [ErrorComp],\n+        providers: [{provide: ErrorHandler, useValue: errorHandler}],\n+      })\n+      class TestModule {\n+      }\n \n-        platformBrowserDynamic().bootstrapModule(TestModule).then((ref) => {\n-          NgZone.assertNotInAngularZone();\n-          const appRef = ref.injector.get(ApplicationRef) as ApplicationRef;\n-          const compRef = appRef.components[0] as ComponentRef<ErrorComp>;\n-          const compEl = compRef.location.nativeElement;\n-          const nextBtn = compEl.children[0];\n-          const nextAndThrowBtn = compEl.children[1];\n-          const nextAndThrowDirBtn = compEl.children[2];\n-\n-          // Note: the amount of events sent to the logger will differ between ViewEngine\n-          // and Ivy, because Ivy doesn't attach an error context. This means that the amount\n-          // of logged errors increases by 1 for Ivy and 2 for ViewEngine after each event.\n-          const errorDelta = ivyEnabled ? 1 : 2;\n-          let currentErrorIndex = 0;\n-\n-          nextBtn.click();\n-          assertValueAndErrors(compEl, 1, currentErrorIndex);\n-          currentErrorIndex += errorDelta;\n-          nextBtn.click();\n-          assertValueAndErrors(compEl, 2, currentErrorIndex);\n-          currentErrorIndex += errorDelta;\n-\n-          nextAndThrowBtn.click();\n-          assertValueAndErrors(compEl, 3, currentErrorIndex);\n-          currentErrorIndex += errorDelta;\n-          nextAndThrowBtn.click();\n-          assertValueAndErrors(compEl, 4, currentErrorIndex);\n-          currentErrorIndex += errorDelta;\n-\n-          nextAndThrowDirBtn.click();\n-          assertValueAndErrors(compEl, 5, currentErrorIndex);\n-          currentErrorIndex += errorDelta;\n-          nextAndThrowDirBtn.click();\n-          assertValueAndErrors(compEl, 6, currentErrorIndex);\n-          currentErrorIndex += errorDelta;\n-\n-          // Assert that there were no more errors\n-          expect(logger.errors.length).toBe(currentErrorIndex);\n-          done();\n-        });\n-\n-        function assertValueAndErrors(compEl: any, value: number, errorIndex: number) {\n-          expect(compEl).toHaveText(`Value:${value}`);\n-          expect(logger.errors[errorIndex][0]).toBe('ERROR');\n-          expect(logger.errors[errorIndex][1].message).toBe(`Error: ${value}`);\n-\n-          // Ivy doesn't attach an error context.\n-          !ivyEnabled && expect(logger.errors[errorIndex + 1][0]).toBe('ERROR CONTEXT');\n-        }\n+      platformBrowserDynamic().bootstrapModule(TestModule).then((ref) => {\n+        NgZone.assertNotInAngularZone();\n+        const appRef = ref.injector.get(ApplicationRef) as ApplicationRef;\n+        const compRef = appRef.components[0] as ComponentRef<ErrorComp>;\n+        const compEl = compRef.location.nativeElement;\n+        const nextBtn = compEl.children[0];\n+        const nextAndThrowBtn = compEl.children[1];\n+        const nextAndThrowDirBtn = compEl.children[2];\n+\n+        const errorDelta = 1;\n+        let currentErrorIndex = 0;\n+\n+        nextBtn.click();\n+        assertValueAndErrors(compEl, 1, currentErrorIndex);\n+        currentErrorIndex += errorDelta;\n+        nextBtn.click();\n+        assertValueAndErrors(compEl, 2, currentErrorIndex);\n+        currentErrorIndex += errorDelta;\n+\n+        nextAndThrowBtn.click();\n+        assertValueAndErrors(compEl, 3, currentErrorIndex);\n+        currentErrorIndex += errorDelta;\n+        nextAndThrowBtn.click();\n+        assertValueAndErrors(compEl, 4, currentErrorIndex);\n+        currentErrorIndex += errorDelta;\n+\n+        nextAndThrowDirBtn.click();\n+        assertValueAndErrors(compEl, 5, currentErrorIndex);\n+        currentErrorIndex += errorDelta;\n+        nextAndThrowDirBtn.click();\n+        assertValueAndErrors(compEl, 6, currentErrorIndex);\n+        currentErrorIndex += errorDelta;\n+\n+        // Assert that there were no more errors\n+        expect(logger.errors.length).toBe(currentErrorIndex);\n+        done();\n       });\n-    }\n-  });\n-}\n+\n+      function assertValueAndErrors(compEl: any, value: number, errorIndex: number) {\n+        expect(compEl).toHaveText(`Value:${value}`);\n+        expect(logger.errors[errorIndex][0]).toBe('ERROR');\n+        expect(logger.errors[errorIndex][1].message).toBe(`Error: ${value}`);\n+      }\n+    });\n+  }\n+});\n \n @Component({selector: 'my-comp', template: ''})\n class MyComp1 {"
        },
        {
            "sha": "8e0c04f178e79fa1bc00bdcf026dd912bbc49549",
            "filename": "packages/core/test/linker/security_integration_spec.ts",
            "status": "modified",
            "additions": 197,
            "deletions": 250,
            "changes": 447,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fsecurity_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fsecurity_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Fsecurity_integration_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -6,26 +6,9 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {ɵgetDOM as getDOM} from '@angular/common';\n-import {Component, Directive, HostBinding, Input, NO_ERRORS_SCHEMA, ɵivyEnabled as ivyEnabled} from '@angular/core';\n+import {Component, Directive, HostBinding, Input, NO_ERRORS_SCHEMA} from '@angular/core';\n import {ComponentFixture, getTestBed, TestBed} from '@angular/core/testing';\n import {DomSanitizer} from '@angular/platform-browser/src/security/dom_sanitization_service';\n-import {modifiedInIvy, onlyInIvy} from '@angular/private/testing';\n-\n-{\n-  if (ivyEnabled) {\n-    describe('ivy', () => {\n-      declareTests();\n-    });\n-  } else {\n-    describe('jit', () => {\n-      declareTests({useJit: true});\n-    });\n-    describe('no jit', () => {\n-      declareTests({useJit: false});\n-    });\n-  }\n-}\n \n @Component({selector: 'my-comp', template: ''})\n class SecuredComponent {\n@@ -38,268 +21,232 @@ class OnPrefixDir {\n   @Input() onclick: any;\n }\n \n-function declareTests(config?: {useJit: boolean}) {\n-  describe('security integration tests', function() {\n-    beforeEach(() => {\n-      TestBed.configureCompiler({...config}).configureTestingModule({\n-        declarations: [\n-          SecuredComponent,\n-          OnPrefixDir,\n-        ]\n-      });\n+describe('security integration tests', function() {\n+  beforeEach(() => {\n+    TestBed.configureTestingModule({\n+      declarations: [\n+        SecuredComponent,\n+        OnPrefixDir,\n+      ]\n     });\n+  });\n \n-    beforeEach(() => {\n-      // Disable logging for these tests.\n-      spyOn(console, 'log').and.callFake(() => {});\n-    });\n+  beforeEach(() => {\n+    // Disable logging for these tests.\n+    spyOn(console, 'log').and.callFake(() => {});\n+  });\n \n-    describe('events', () => {\n-      modifiedInIvy('on-prefixed attributes validation happens at runtime in Ivy')\n-          .it('should disallow binding to attr.on*', () => {\n-            const template = `<div [attr.onclick]=\"ctxProp\"></div>`;\n-            TestBed.overrideComponent(SecuredComponent, {set: {template}});\n-\n-            expect(() => TestBed.createComponent(SecuredComponent))\n-                .toThrowError(\n-                    /Binding to event attribute 'onclick' is disallowed for security reasons, please use \\(click\\)=.../);\n-          });\n-\n-      // this test is similar to the previous one, but since on-prefixed attributes validation now\n-      // happens at runtime, we need to invoke change detection to trigger elementProperty call\n-      onlyInIvy('on-prefixed attributes validation happens at runtime in Ivy')\n-          .it('should disallow binding to attr.on*', () => {\n-            const template = `<div [attr.onclick]=\"ctxProp\"></div>`;\n-            TestBed.overrideComponent(SecuredComponent, {set: {template}});\n-\n-            expect(() => {\n-              const cmp = TestBed.createComponent(SecuredComponent);\n-              cmp.detectChanges();\n-            })\n-                .toThrowError(\n-                    /Binding to event attribute 'onclick' is disallowed for security reasons, please use \\(click\\)=.../);\n-          });\n-\n-      modifiedInIvy('on-prefixed attributes validation happens at runtime in Ivy')\n-          .it('should disallow binding to on* with NO_ERRORS_SCHEMA', () => {\n-            const template = `<div [onclick]=\"ctxProp\"></div>`;\n-            TestBed.overrideComponent(SecuredComponent, {set: {template}}).configureTestingModule({\n-              schemas: [NO_ERRORS_SCHEMA]\n-            });\n-\n-            expect(() => TestBed.createComponent(SecuredComponent))\n-                .toThrowError(\n-                    /Binding to event property 'onclick' is disallowed for security reasons, please use \\(click\\)=.../);\n-          });\n-\n-      // this test is similar to the previous one, but since on-prefixed attributes validation now\n-      // happens at runtime, we need to invoke change detection to trigger elementProperty call\n-      onlyInIvy('on-prefixed attributes validation happens at runtime in Ivy')\n-          .it('should disallow binding to on* with NO_ERRORS_SCHEMA', () => {\n-            const template = `<div [onclick]=\"ctxProp\"></div>`;\n-            TestBed.overrideComponent(SecuredComponent, {set: {template}}).configureTestingModule({\n-              schemas: [NO_ERRORS_SCHEMA]\n-            });\n-\n-            expect(() => {\n-              const cmp = TestBed.createComponent(SecuredComponent);\n-              cmp.detectChanges();\n-            })\n-                .toThrowError(\n-                    /Binding to event property 'onclick' is disallowed for security reasons, please use \\(click\\)=.../);\n-          });\n-\n-      it('should disallow binding to on* unless it is consumed by a directive', () => {\n-        const template = `<div [onPrefixedProp]=\"ctxProp\" [onclick]=\"ctxProp\"></div>`;\n-        TestBed.overrideComponent(SecuredComponent, {set: {template}}).configureTestingModule({\n-          schemas: [NO_ERRORS_SCHEMA]\n-        });\n-\n-        // should not throw for inputs starting with \"on\"\n-        let cmp: ComponentFixture<SecuredComponent> = undefined!;\n-        expect(() => cmp = TestBed.createComponent(SecuredComponent)).not.toThrow();\n-\n-        // must bind to the directive not to the property of the div\n-        const value = cmp.componentInstance.ctxProp = {};\n+  describe('events', () => {\n+    // this test is similar to the previous one, but since on-prefixed attributes validation now\n+    // happens at runtime, we need to invoke change detection to trigger elementProperty call\n+    it('should disallow binding to attr.on*', () => {\n+      const template = `<div [attr.onclick]=\"ctxProp\"></div>`;\n+      TestBed.overrideComponent(SecuredComponent, {set: {template}});\n+\n+      expect(() => {\n+        const cmp = TestBed.createComponent(SecuredComponent);\n         cmp.detectChanges();\n-        const div = cmp.debugElement.children[0];\n-        expect(div.injector.get(OnPrefixDir).onclick).toBe(value);\n-        expect(div.nativeElement.onclick).not.toBe(value);\n-        expect(div.nativeElement.hasAttribute('onclick')).toEqual(false);\n-      });\n+      })\n+          .toThrowError(\n+              /Binding to event attribute 'onclick' is disallowed for security reasons, please use \\(click\\)=.../);\n     });\n \n-    describe('safe HTML values', function() {\n-      it('should not escape values marked as trusted', () => {\n-        const template = `<a [href]=\"ctxProp\">Link Title</a>`;\n-        TestBed.overrideComponent(SecuredComponent, {set: {template}});\n-        const fixture = TestBed.createComponent(SecuredComponent);\n-        const sanitizer: DomSanitizer = getTestBed().get(DomSanitizer);\n-\n-        const e = fixture.debugElement.children[0].nativeElement;\n-        const ci = fixture.componentInstance;\n-        const trusted = sanitizer.bypassSecurityTrustUrl('javascript:alert(1)');\n-        ci.ctxProp = trusted;\n-        fixture.detectChanges();\n-        expect(e.getAttribute('href')).toEqual('javascript:alert(1)');\n+    // this test is similar to the previous one, but since on-prefixed attributes validation now\n+    // happens at runtime, we need to invoke change detection to trigger elementProperty call\n+    it('should disallow binding to on* with NO_ERRORS_SCHEMA', () => {\n+      const template = `<div [onclick]=\"ctxProp\"></div>`;\n+      TestBed.overrideComponent(SecuredComponent, {set: {template}}).configureTestingModule({\n+        schemas: [NO_ERRORS_SCHEMA]\n       });\n \n-      it('should error when using the wrong trusted value', () => {\n-        const template = `<a [href]=\"ctxProp\">Link Title</a>`;\n-        TestBed.overrideComponent(SecuredComponent, {set: {template}});\n-        const fixture = TestBed.createComponent(SecuredComponent);\n-        const sanitizer: DomSanitizer = getTestBed().get(DomSanitizer);\n+      expect(() => {\n+        const cmp = TestBed.createComponent(SecuredComponent);\n+        cmp.detectChanges();\n+      })\n+          .toThrowError(\n+              /Binding to event property 'onclick' is disallowed for security reasons, please use \\(click\\)=.../);\n+    });\n \n-        const trusted = sanitizer.bypassSecurityTrustScript('javascript:alert(1)');\n-        const ci = fixture.componentInstance;\n-        ci.ctxProp = trusted;\n-        expect(() => fixture.detectChanges()).toThrowError(/Required a safe URL, got a Script/);\n+    it('should disallow binding to on* unless it is consumed by a directive', () => {\n+      const template = `<div [onPrefixedProp]=\"ctxProp\" [onclick]=\"ctxProp\"></div>`;\n+      TestBed.overrideComponent(SecuredComponent, {set: {template}}).configureTestingModule({\n+        schemas: [NO_ERRORS_SCHEMA]\n       });\n \n-      it('should warn when using in string interpolation', () => {\n-        const template = `<a href=\"/foo/{{ctxProp}}\">Link Title</a>`;\n-        TestBed.overrideComponent(SecuredComponent, {set: {template}});\n-        const fixture = TestBed.createComponent(SecuredComponent);\n-        const sanitizer: DomSanitizer = getTestBed().get(DomSanitizer);\n-\n-        const e = fixture.debugElement.children[0].nativeElement;\n-        const trusted = sanitizer.bypassSecurityTrustUrl('bar/baz');\n-        const ci = fixture.componentInstance;\n-        ci.ctxProp = trusted;\n-        fixture.detectChanges();\n-        expect(e.href).toMatch(/SafeValue(%20| )must(%20| )use/);\n-      });\n+      // should not throw for inputs starting with \"on\"\n+      let cmp: ComponentFixture<SecuredComponent> = undefined!;\n+      expect(() => cmp = TestBed.createComponent(SecuredComponent)).not.toThrow();\n+\n+      // must bind to the directive not to the property of the div\n+      const value = cmp.componentInstance.ctxProp = {};\n+      cmp.detectChanges();\n+      const div = cmp.debugElement.children[0];\n+      expect(div.injector.get(OnPrefixDir).onclick).toBe(value);\n+      expect(div.nativeElement.onclick).not.toBe(value);\n+      expect(div.nativeElement.hasAttribute('onclick')).toEqual(false);\n     });\n+  });\n \n-    describe('sanitizing', () => {\n-      function checkEscapeOfHrefProperty(fixture: ComponentFixture<any>) {\n-        const e = fixture.debugElement.children[0].nativeElement;\n-        const ci = fixture.componentInstance;\n-        ci.ctxProp = 'hello';\n-        fixture.detectChanges();\n-        expect(e.getAttribute('href')).toMatch(/.*\\/?hello$/);\n-\n-        ci.ctxProp = 'javascript:alert(1)';\n-        fixture.detectChanges();\n-        expect(e.getAttribute('href')).toEqual('unsafe:javascript:alert(1)');\n-      }\n+  describe('safe HTML values', function() {\n+    it('should not escape values marked as trusted', () => {\n+      const template = `<a [href]=\"ctxProp\">Link Title</a>`;\n+      TestBed.overrideComponent(SecuredComponent, {set: {template}});\n+      const fixture = TestBed.createComponent(SecuredComponent);\n+      const sanitizer: DomSanitizer = getTestBed().get(DomSanitizer);\n+\n+      const e = fixture.debugElement.children[0].nativeElement;\n+      const ci = fixture.componentInstance;\n+      const trusted = sanitizer.bypassSecurityTrustUrl('javascript:alert(1)');\n+      ci.ctxProp = trusted;\n+      fixture.detectChanges();\n+      expect(e.getAttribute('href')).toEqual('javascript:alert(1)');\n+    });\n \n-      it('should escape unsafe properties', () => {\n-        const template = `<a [href]=\"ctxProp\">Link Title</a>`;\n-        TestBed.overrideComponent(SecuredComponent, {set: {template}});\n-        const fixture = TestBed.createComponent(SecuredComponent);\n+    it('should error when using the wrong trusted value', () => {\n+      const template = `<a [href]=\"ctxProp\">Link Title</a>`;\n+      TestBed.overrideComponent(SecuredComponent, {set: {template}});\n+      const fixture = TestBed.createComponent(SecuredComponent);\n+      const sanitizer: DomSanitizer = getTestBed().get(DomSanitizer);\n \n-        checkEscapeOfHrefProperty(fixture);\n-      });\n+      const trusted = sanitizer.bypassSecurityTrustScript('javascript:alert(1)');\n+      const ci = fixture.componentInstance;\n+      ci.ctxProp = trusted;\n+      expect(() => fixture.detectChanges()).toThrowError(/Required a safe URL, got a Script/);\n+    });\n \n-      it('should escape unsafe attributes', () => {\n-        const template = `<a [attr.href]=\"ctxProp\">Link Title</a>`;\n-        TestBed.overrideComponent(SecuredComponent, {set: {template}});\n-        const fixture = TestBed.createComponent(SecuredComponent);\n+    it('should warn when using in string interpolation', () => {\n+      const template = `<a href=\"/foo/{{ctxProp}}\">Link Title</a>`;\n+      TestBed.overrideComponent(SecuredComponent, {set: {template}});\n+      const fixture = TestBed.createComponent(SecuredComponent);\n+      const sanitizer: DomSanitizer = getTestBed().get(DomSanitizer);\n+\n+      const e = fixture.debugElement.children[0].nativeElement;\n+      const trusted = sanitizer.bypassSecurityTrustUrl('bar/baz');\n+      const ci = fixture.componentInstance;\n+      ci.ctxProp = trusted;\n+      fixture.detectChanges();\n+      expect(e.href).toMatch(/SafeValue(%20| )must(%20| )use/);\n+    });\n+  });\n \n-        checkEscapeOfHrefProperty(fixture);\n-      });\n+  describe('sanitizing', () => {\n+    function checkEscapeOfHrefProperty(fixture: ComponentFixture<any>) {\n+      const e = fixture.debugElement.children[0].nativeElement;\n+      const ci = fixture.componentInstance;\n+      ci.ctxProp = 'hello';\n+      fixture.detectChanges();\n+      expect(e.getAttribute('href')).toMatch(/.*\\/?hello$/);\n+\n+      ci.ctxProp = 'javascript:alert(1)';\n+      fixture.detectChanges();\n+      expect(e.getAttribute('href')).toEqual('unsafe:javascript:alert(1)');\n+    }\n+\n+    it('should escape unsafe properties', () => {\n+      const template = `<a [href]=\"ctxProp\">Link Title</a>`;\n+      TestBed.overrideComponent(SecuredComponent, {set: {template}});\n+      const fixture = TestBed.createComponent(SecuredComponent);\n+\n+      checkEscapeOfHrefProperty(fixture);\n+    });\n \n-      it('should escape unsafe properties if they are used in host bindings', () => {\n-        @Directive({selector: '[dirHref]'})\n-        class HrefDirective {\n-          // TODO(issue/24571): remove '!'.\n-          @HostBinding('href') @Input() dirHref!: string;\n-        }\n+    it('should escape unsafe attributes', () => {\n+      const template = `<a [attr.href]=\"ctxProp\">Link Title</a>`;\n+      TestBed.overrideComponent(SecuredComponent, {set: {template}});\n+      const fixture = TestBed.createComponent(SecuredComponent);\n \n-        const template = `<a [dirHref]=\"ctxProp\">Link Title</a>`;\n-        TestBed.configureTestingModule({declarations: [HrefDirective]});\n-        TestBed.overrideComponent(SecuredComponent, {set: {template}});\n-        const fixture = TestBed.createComponent(SecuredComponent);\n+      checkEscapeOfHrefProperty(fixture);\n+    });\n \n-        checkEscapeOfHrefProperty(fixture);\n-      });\n+    it('should escape unsafe properties if they are used in host bindings', () => {\n+      @Directive({selector: '[dirHref]'})\n+      class HrefDirective {\n+        // TODO(issue/24571): remove '!'.\n+        @HostBinding('href') @Input() dirHref!: string;\n+      }\n \n-      it('should escape unsafe attributes if they are used in host bindings', () => {\n-        @Directive({selector: '[dirHref]'})\n-        class HrefDirective {\n-          // TODO(issue/24571): remove '!'.\n-          @HostBinding('attr.href') @Input() dirHref!: string;\n-        }\n+      const template = `<a [dirHref]=\"ctxProp\">Link Title</a>`;\n+      TestBed.configureTestingModule({declarations: [HrefDirective]});\n+      TestBed.overrideComponent(SecuredComponent, {set: {template}});\n+      const fixture = TestBed.createComponent(SecuredComponent);\n \n-        const template = `<a [dirHref]=\"ctxProp\">Link Title</a>`;\n-        TestBed.configureTestingModule({declarations: [HrefDirective]});\n-        TestBed.overrideComponent(SecuredComponent, {set: {template}});\n-        const fixture = TestBed.createComponent(SecuredComponent);\n+      checkEscapeOfHrefProperty(fixture);\n+    });\n \n-        checkEscapeOfHrefProperty(fixture);\n-      });\n+    it('should escape unsafe attributes if they are used in host bindings', () => {\n+      @Directive({selector: '[dirHref]'})\n+      class HrefDirective {\n+        // TODO(issue/24571): remove '!'.\n+        @HostBinding('attr.href') @Input() dirHref!: string;\n+      }\n \n-      modifiedInIvy('Unknown property error thrown during update mode, not creation mode')\n-          .it('should escape unsafe SVG attributes', () => {\n-            const template = `<svg:circle [xlink:href]=\"ctxProp\">Text</svg:circle>`;\n-            TestBed.overrideComponent(SecuredComponent, {set: {template}});\n-\n-            expect(() => TestBed.createComponent(SecuredComponent))\n-                .toThrowError(/Can't bind to 'xlink:href'/);\n-          });\n-\n-      onlyInIvy('Unknown property logs an error message instead of throwing')\n-          .it('should escape unsafe SVG attributes', () => {\n-            const template = `<svg:circle [xlink:href]=\"ctxProp\">Text</svg:circle>`;\n-            TestBed.overrideComponent(SecuredComponent, {set: {template}});\n-\n-            const spy = spyOn(console, 'error');\n-            const fixture = TestBed.createComponent(SecuredComponent);\n-            fixture.detectChanges();\n-            expect(spy.calls.mostRecent().args[0]).toMatch(/Can't bind to 'xlink:href'/);\n-          });\n-\n-      it('should escape unsafe HTML values', () => {\n-        const template = `<div [innerHTML]=\"ctxProp\">Text</div>`;\n-        TestBed.overrideComponent(SecuredComponent, {set: {template}});\n-        const fixture = TestBed.createComponent(SecuredComponent);\n-\n-        const e = fixture.debugElement.children[0].nativeElement;\n-        const ci = fixture.componentInstance;\n-        // Make sure binding harmless values works.\n-        ci.ctxProp = 'some <p>text</p>';\n-        fixture.detectChanges();\n-        expect(e.innerHTML).toEqual('some <p>text</p>');\n-\n-        ci.ctxProp = 'ha <script>evil()</script>';\n-        fixture.detectChanges();\n-        expect(e.innerHTML).toEqual('ha ');\n-\n-        ci.ctxProp = 'also <img src=\"x\" onerror=\"evil()\"> evil';\n-        fixture.detectChanges();\n-        expect(e.innerHTML).toEqual('also <img src=\"x\"> evil');\n-\n-        ci.ctxProp = 'also <iframe srcdoc=\"evil\"></iframe> evil';\n-        fixture.detectChanges();\n-        expect(e.innerHTML).toEqual('also  evil');\n-      });\n+      const template = `<a [dirHref]=\"ctxProp\">Link Title</a>`;\n+      TestBed.configureTestingModule({declarations: [HrefDirective]});\n+      TestBed.overrideComponent(SecuredComponent, {set: {template}});\n+      const fixture = TestBed.createComponent(SecuredComponent);\n+\n+      checkEscapeOfHrefProperty(fixture);\n     });\n \n-    onlyInIvy('Trusted Types are only supported in Ivy').describe('translation', () => {\n-      it('should throw error on security-sensitive attributes with constant values', () => {\n-        const template = `<iframe srcdoc=\"foo\" i18n-srcdoc></iframe>`;\n-        TestBed.overrideComponent(SecuredComponent, {set: {template}});\n+    it('should escape unsafe SVG attributes', () => {\n+      const template = `<svg:circle [xlink:href]=\"ctxProp\">Text</svg:circle>`;\n+      TestBed.overrideComponent(SecuredComponent, {set: {template}});\n \n-        expect(() => TestBed.createComponent(SecuredComponent))\n-            .toThrowError(/Translating attribute 'srcdoc' is disallowed for security reasons./);\n-      });\n+      const spy = spyOn(console, 'error');\n+      const fixture = TestBed.createComponent(SecuredComponent);\n+      fixture.detectChanges();\n+      expect(spy.calls.mostRecent().args[0]).toMatch(/Can't bind to 'xlink:href'/);\n+    });\n \n-      it('should throw error on security-sensitive attributes with interpolated values', () => {\n-        const template = `<object i18n-data data=\"foo{{bar}}baz\"></object>`;\n-        TestBed.overrideComponent(SecuredComponent, {set: {template}});\n+    it('should escape unsafe HTML values', () => {\n+      const template = `<div [innerHTML]=\"ctxProp\">Text</div>`;\n+      TestBed.overrideComponent(SecuredComponent, {set: {template}});\n+      const fixture = TestBed.createComponent(SecuredComponent);\n+\n+      const e = fixture.debugElement.children[0].nativeElement;\n+      const ci = fixture.componentInstance;\n+      // Make sure binding harmless values works.\n+      ci.ctxProp = 'some <p>text</p>';\n+      fixture.detectChanges();\n+      expect(e.innerHTML).toEqual('some <p>text</p>');\n+\n+      ci.ctxProp = 'ha <script>evil()</script>';\n+      fixture.detectChanges();\n+      expect(e.innerHTML).toEqual('ha ');\n+\n+      ci.ctxProp = 'also <img src=\"x\" onerror=\"evil()\"> evil';\n+      fixture.detectChanges();\n+      expect(e.innerHTML).toEqual('also <img src=\"x\"> evil');\n+\n+      ci.ctxProp = 'also <iframe srcdoc=\"evil\"></iframe> evil';\n+      fixture.detectChanges();\n+      expect(e.innerHTML).toEqual('also  evil');\n+    });\n+  });\n \n-        expect(() => TestBed.createComponent(SecuredComponent))\n-            .toThrowError(/Translating attribute 'data' is disallowed for security reasons./);\n-      });\n+  describe('translation', () => {\n+    it('should throw error on security-sensitive attributes with constant values', () => {\n+      const template = `<iframe srcdoc=\"foo\" i18n-srcdoc></iframe>`;\n+      TestBed.overrideComponent(SecuredComponent, {set: {template}});\n \n-      it('should throw error on security-sensitive attributes with bound values', () => {\n-        const template = `<div [innerHTML]=\"foo\" i18n-innerHTML></div>`;\n-        TestBed.overrideComponent(SecuredComponent, {set: {template}});\n+      expect(() => TestBed.createComponent(SecuredComponent))\n+          .toThrowError(/Translating attribute 'srcdoc' is disallowed for security reasons./);\n+    });\n \n-        expect(() => TestBed.createComponent(SecuredComponent))\n-            .toThrowError(/Translating attribute 'innerHTML' is disallowed for security reasons./);\n-      });\n+    it('should throw error on security-sensitive attributes with interpolated values', () => {\n+      const template = `<object i18n-data data=\"foo{{bar}}baz\"></object>`;\n+      TestBed.overrideComponent(SecuredComponent, {set: {template}});\n+\n+      expect(() => TestBed.createComponent(SecuredComponent))\n+          .toThrowError(/Translating attribute 'data' is disallowed for security reasons./);\n+    });\n+\n+    it('should throw error on security-sensitive attributes with bound values', () => {\n+      const template = `<div [innerHTML]=\"foo\" i18n-innerHTML></div>`;\n+      TestBed.overrideComponent(SecuredComponent, {set: {template}});\n+\n+      expect(() => TestBed.createComponent(SecuredComponent))\n+          .toThrowError(/Translating attribute 'innerHTML' is disallowed for security reasons./);\n     });\n   });\n-}\n+});"
        },
        {
            "sha": "25a2e260be34cb6b56e8b8911c5b6af9eccc4e44",
            "filename": "packages/core/test/linker/source_map_integration_node_only_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 220,
            "changes": 222,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fsource_map_integration_node_only_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fsource_map_integration_node_only_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Fsource_map_integration_node_only_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -10,12 +10,10 @@ import {ResourceLoader, SourceMap} from '@angular/compiler';\n import {CompilerFacadeImpl} from '@angular/compiler/src/jit_compiler_facade';\n import {JitEvaluator} from '@angular/compiler/src/output/output_jit';\n import {escapeRegExp} from '@angular/compiler/src/util';\n-import {Attribute, Component, Directive, ErrorHandler, ɵglobal} from '@angular/core';\n+import {Attribute, Component, Directive, ErrorHandler} from '@angular/core';\n import {CompilerFacade, ExportedCompilerFacade} from '@angular/core/src/compiler/compiler_facade';\n-import {getErrorLogger} from '@angular/core/src/errors';\n import {resolveComponentResources} from '@angular/core/src/metadata/resource_loading';\n import {fakeAsync, TestBed, tick} from '@angular/core/testing';\n-import {modifiedInIvy, onlyInIvy} from '@angular/private/testing';\n \n import {MockResourceLoader} from './resource_loader_mock';\n import {extractSourceMap, originalPositionFor} from './source_map_util';\n@@ -41,202 +39,7 @@ describe('jit source mapping', () => {\n     });\n   });\n \n-  modifiedInIvy('Generated filenames and stack traces have changed in ivy')\n-      .describe('(View Engine)', () => {\n-        describe('inline templates', () => {\n-          const ngUrl = 'ng:///DynamicTestModule/MyComp.html';\n-          function templateDecorator(template: string) {\n-            return {template};\n-          }\n-          declareTests({ngUrl, templateDecorator});\n-        });\n-\n-        describe('external templates', () => {\n-          const ngUrl = 'ng:///some/url.html';\n-          const templateUrl = 'http://localhost:1234/some/url.html';\n-          function templateDecorator(template: string) {\n-            resourceLoader.expect(templateUrl, template);\n-            return {templateUrl};\n-          }\n-          declareTests({ngUrl, templateDecorator});\n-        });\n-\n-        function declareTests({ngUrl, templateDecorator}: TestConfig) {\n-          const ngFactoryUrl = 'ng:///DynamicTestModule/MyComp.ngfactory.js';\n-\n-          it('should use the right source url in html parse errors', fakeAsync(() => {\n-               @Component({...templateDecorator('<div>\\n  </error>')})\n-               class MyComp {\n-               }\n-\n-               expect(() => {\n-                 compileAndCreateComponent(MyComp);\n-               })\n-                   .toThrowError(\n-                       new RegExp(`Template parse errors[\\\\s\\\\S]*${escapeRegExp(ngUrl)}@1:2`));\n-             }));\n-\n-          it('should use the right source url in template parse errors', fakeAsync(() => {\n-               @Component({...templateDecorator('<div>\\n  <div unknown=\"{{ctxProp}}\"></div>')})\n-               class MyComp {\n-               }\n-\n-               expect(() => {\n-                 compileAndCreateComponent(MyComp);\n-               })\n-                   .toThrowError(\n-                       new RegExp(`Template parse errors[\\\\s\\\\S]*${escapeRegExp(ngUrl)}@1:7`));\n-             }));\n-\n-          it('should create a sourceMap for templates', fakeAsync(() => {\n-               const template = `Hello World!`;\n-\n-               @Component({...templateDecorator(template)})\n-               class MyComp {\n-               }\n-\n-               compileAndCreateComponent(MyComp);\n-\n-               const sourceMap = jitEvaluator.getSourceMap(ngFactoryUrl);\n-               expect(sourceMap.sources).toEqual([ngFactoryUrl, ngUrl]);\n-               expect(sourceMap.sourcesContent).toEqual([' ', template]);\n-             }));\n-\n-\n-          it('should report source location for di errors', fakeAsync(() => {\n-               const template = `<div>\\n    <div   someDir></div></div>`;\n-\n-               @Component({...templateDecorator(template)})\n-               class MyComp {\n-               }\n-\n-               @Directive({selector: '[someDir]'})\n-               class SomeDir {\n-                 constructor() {\n-                   throw new Error('Test');\n-                 }\n-               }\n-\n-               TestBed.configureTestingModule({declarations: [SomeDir]});\n-               let error: any;\n-               try {\n-                 compileAndCreateComponent(MyComp);\n-               } catch (e) {\n-                 error = e;\n-               }\n-               // The error should be logged from the element\n-               expect(\n-                   jitEvaluator.getSourcePositionForStack(getErrorLoggerStack(error), ngFactoryUrl))\n-                   .toEqual({\n-                     line: 2,\n-                     column: 4,\n-                     source: ngUrl,\n-                   });\n-             }));\n-\n-          it('should report di errors with multiple elements and directives', fakeAsync(() => {\n-               const template = `<div someDir></div><div someDir=\"throw\"></div>`;\n-\n-               @Component({...templateDecorator(template)})\n-               class MyComp {\n-               }\n-\n-               @Directive({selector: '[someDir]'})\n-               class SomeDir {\n-                 constructor(@Attribute('someDir') someDir: string) {\n-                   if (someDir === 'throw') {\n-                     throw new Error('Test');\n-                   }\n-                 }\n-               }\n-\n-               TestBed.configureTestingModule({declarations: [SomeDir]});\n-               let error: any;\n-               try {\n-                 compileAndCreateComponent(MyComp);\n-               } catch (e) {\n-                 error = e;\n-               }\n-               // The error should be logged from the 2nd-element\n-               expect(\n-                   jitEvaluator.getSourcePositionForStack(getErrorLoggerStack(error), ngFactoryUrl))\n-                   .toEqual({\n-                     line: 1,\n-                     column: 19,\n-                     source: ngUrl,\n-                   });\n-             }));\n-\n-          it('should report source location for binding errors', fakeAsync(() => {\n-               const template = `<div>\\n    <span   [title]=\"createError()\"></span></div>`;\n-\n-               @Component({...templateDecorator(template)})\n-               class MyComp {\n-                 createError() {\n-                   throw new Error('Test');\n-                 }\n-               }\n-\n-               const comp = compileAndCreateComponent(MyComp);\n-\n-               let error: any;\n-               try {\n-                 comp.detectChanges();\n-               } catch (e) {\n-                 error = e;\n-               }\n-               // the stack should point to the binding\n-               expect(jitEvaluator.getSourcePositionForStack(error.stack, ngFactoryUrl)).toEqual({\n-                 line: 2,\n-                 column: 12,\n-                 source: ngUrl,\n-               });\n-               // The error should be logged from the element\n-               expect(\n-                   jitEvaluator.getSourcePositionForStack(getErrorLoggerStack(error), ngFactoryUrl))\n-                   .toEqual({\n-                     line: 2,\n-                     column: 4,\n-                     source: ngUrl,\n-                   });\n-             }));\n-\n-          it('should report source location for event errors', fakeAsync(() => {\n-               const template = `<div>\\n    <span   (click)=\"createError()\"></span></div>`;\n-\n-               @Component({...templateDecorator(template)})\n-               class MyComp {\n-                 createError() {\n-                   throw new Error('Test');\n-                 }\n-               }\n-\n-               const comp = compileAndCreateComponent(MyComp);\n-\n-               let error: any;\n-               const errorHandler = TestBed.inject(ErrorHandler);\n-               spyOn(errorHandler, 'handleError').and.callFake((e: any) => error = e);\n-               comp.debugElement.children[0].children[0].triggerEventHandler('click', 'EVENT');\n-               expect(error).toBeTruthy();\n-               // the stack should point to the binding\n-               expect(jitEvaluator.getSourcePositionForStack(error.stack, ngFactoryUrl)).toEqual({\n-                 line: 2,\n-                 column: 12,\n-                 source: ngUrl,\n-               });\n-               // The error should be logged from the element\n-               expect(\n-                   jitEvaluator.getSourcePositionForStack(getErrorLoggerStack(error), ngFactoryUrl))\n-                   .toEqual({\n-                     line: 2,\n-                     column: 4,\n-                     source: ngUrl,\n-                   });\n-             }));\n-        }\n-      });\n-\n-  onlyInIvy('Generated filenames and stack traces have changed in ivy').describe('(Ivy)', () => {\n+  describe('generated filenames and stack traces', () => {\n     beforeEach(() => overrideCompilerFacade());\n     afterEach(() => restoreCompilerFacade());\n \n@@ -273,21 +76,6 @@ describe('jit source mapping', () => {\n            }).toThrowError(new RegExp(`${escapeRegExp(ngUrl)}@1:2`));\n          }));\n \n-\n-      modifiedInIvy('Unknown binding errors have been moved to runtime in Ivy')\n-          .it('should use the right source url in template parse errors', fakeAsync(() => {\n-                const template = '<div>\\n  <div unknown=\"{{ctxProp}}\"></div>';\n-                @Component({...templateDecorator(template)})\n-                class MyComp {\n-                }\n-\n-                expect(() => {\n-                  resolveCompileAndCreateComponent(MyComp, template);\n-                })\n-                    .toThrowError(\n-                        new RegExp(`Template parse errors[\\\\s\\\\S]*${escapeRegExp(ngUrl)}@1:7`));\n-              }));\n-\n       it('should create a sourceMap for templates', fakeAsync(() => {\n            const template = `Hello World!`;\n \n@@ -512,10 +300,4 @@ describe('jit source mapping', () => {\n       return originalPositionFor(sourceMap, pos);\n     }\n   }\n-\n-  function getErrorLoggerStack(e: Error): string {\n-    let logStack: string = undefined!;\n-    getErrorLogger(e)(<any>{error: () => logStack = new Error().stack!}, e.message);\n-    return logStack;\n-  }\n });"
        },
        {
            "sha": "1f8fa9b6661ea34c2b3bd32dea049c90225a3207",
            "filename": "packages/core/test/linker/view_injector_integration_spec.ts",
            "status": "modified",
            "additions": 55,
            "deletions": 162,
            "changes": 217,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fview_injector_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Flinker%2Fview_injector_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Fview_injector_integration_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -9,7 +9,6 @@\n import {Attribute, ChangeDetectionStrategy, ChangeDetectorRef, Component, ComponentFactoryResolver, DebugElement, Directive, ElementRef, EmbeddedViewRef, Host, Inject, InjectionToken, Injector, Input, NgModule, Optional, Pipe, PipeTransform, Provider, Self, SkipSelf, TemplateRef, Type, ViewContainerRef} from '@angular/core';\n import {ComponentFixture, fakeAsync, TestBed} from '@angular/core/testing';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {ivyEnabled, modifiedInIvy, obsoleteInIvy, onlyInIvy} from '@angular/private/testing';\n \n @Directive({selector: '[simpleDirective]'})\n class SimpleDirective {\n@@ -616,113 +615,50 @@ describe('View injector', () => {\n       expect(el.children[0].injector.get(NeedsAppService).service).toEqual('appService');\n     });\n \n-    obsoleteInIvy('This error is no longer generated by the compiler')\n-        .it('should not instantiate a directive with cyclic dependencies', () => {\n-          TestBed.configureTestingModule({declarations: [CycleDirective]});\n-          expect(() => createComponent('<div cycleDirective></div>'))\n-              .toThrowError(\n-                  /Template parse errors:\\nCannot instantiate cyclic dependency! CycleDirective \\(\"\\[ERROR ->\\]<div cycleDirective><\\/div>\"\\): .*TestComp.html@0:0/);\n-        });\n-\n-    onlyInIvy('This error is generated by the runtime of Ivy')\n-        .it('should not instantiate a directive with cyclic dependencies', () => {\n-          TestBed.configureTestingModule({declarations: [CycleDirective]});\n-          expect(() => createComponent('<div cycleDirective></div>'))\n-              .toThrowError(\n-                  'NG0200: Circular dependency in DI detected for CycleDirective. Find more at https://angular.io/errors/NG0200');\n-        });\n-\n-    obsoleteInIvy('This error is no longer generated by the compiler')\n-        .it('should not instantiate a directive in a view that has a host dependency on providers' +\n-                ' of the component',\n-            () => {\n-              TestBed.configureTestingModule(\n-                  {declarations: [SimpleComponent, NeedsServiceFromHost]});\n-              TestBed.overrideComponent(\n-                  SimpleComponent,\n-                  {set: {providers: [{provide: 'service', useValue: 'hostService'}]}});\n-              TestBed.overrideComponent(\n-                  SimpleComponent, {set: {template: '<div needsServiceFromHost><div>'}});\n-\n-              expect(() => createComponent('<div simpleComponent></div>'))\n-                  .toThrowError(\n-                      /Template parse errors:\\nNo provider for service \\(\"\\[ERROR ->\\]<div needsServiceFromHost><div>\"\\): .*SimpleComponent.html@0:0/);\n-            });\n-\n-    onlyInIvy('This error is generated by the runtime of Ivy')\n-        .it('should not instantiate a directive in a view that has a host dependency on providers' +\n-                ' of the component',\n-            () => {\n-              TestBed.configureTestingModule(\n-                  {declarations: [SimpleComponent, NeedsServiceFromHost]});\n-              TestBed.overrideComponent(\n-                  SimpleComponent,\n-                  {set: {providers: [{provide: 'service', useValue: 'hostService'}]}});\n-              TestBed.overrideComponent(\n-                  SimpleComponent, {set: {template: '<div needsServiceFromHost><div>'}});\n-\n-              expect(() => createComponent('<div simpleComponent></div>'))\n-                  .toThrowError(\n-                      'NG0201: No provider for service found in NodeInjector. Find more at https://angular.io/errors/NG0201');\n-            });\n-\n-    obsoleteInIvy('This error is no longer generated by the compiler')\n-        .it('should not instantiate a directive in a view that has a host dependency on providers' +\n-                ' of a decorator directive',\n-            () => {\n-              TestBed.configureTestingModule(\n-                  {declarations: [SimpleComponent, SomeOtherDirective, NeedsServiceFromHost]});\n-              TestBed.overrideComponent(\n-                  SimpleComponent,\n-                  {set: {providers: [{provide: 'service', useValue: 'hostService'}]}});\n-              TestBed.overrideComponent(\n-                  SimpleComponent, {set: {template: '<div needsServiceFromHost><div>'}});\n-\n-              expect(() => createComponent('<div simpleComponent someOtherDirective></div>'))\n-                  .toThrowError(\n-                      /Template parse errors:\\nNo provider for service \\(\"\\[ERROR ->\\]<div needsServiceFromHost><div>\"\\): .*SimpleComponent.html@0:0/);\n-            });\n-\n-    onlyInIvy('This error is generated by the runtime of Ivy')\n-        .it('should not instantiate a directive in a view that has a host dependency on providers' +\n-                ' of a decorator directive',\n-            () => {\n-              TestBed.configureTestingModule(\n-                  {declarations: [SimpleComponent, SomeOtherDirective, NeedsServiceFromHost]});\n-              TestBed.overrideComponent(\n-                  SimpleComponent,\n-                  {set: {providers: [{provide: 'service', useValue: 'hostService'}]}});\n-              TestBed.overrideComponent(\n-                  SimpleComponent, {set: {template: '<div needsServiceFromHost><div>'}});\n-\n-              expect(() => createComponent('<div simpleComponent someOtherDirective></div>'))\n-                  .toThrowError(\n-                      'NG0201: No provider for service found in NodeInjector. Find more at https://angular.io/errors/NG0201');\n-            });\n-\n-    obsoleteInIvy('This error is no longer generated by the compiler')\n-        .it('should not instantiate a directive in a view that has a self dependency on a parent directive',\n-            () => {\n-              TestBed.configureTestingModule(\n-                  {declarations: [SimpleDirective, NeedsDirectiveFromSelf]});\n-              expect(\n-                  () => createComponent(\n-                      '<div simpleDirective><div needsDirectiveFromSelf></div></div>'))\n-                  .toThrowError(\n-                      /Template parse errors:\\nNo provider for SimpleDirective \\(\"<div simpleDirective>\\[ERROR ->\\]<div needsDirectiveFromSelf><\\/div><\\/div>\"\\): .*TestComp.html@0:21/);\n-            });\n-\n-    onlyInIvy('This error is generated by the runtime of Ivy')\n-        .it('should not instantiate a directive in a view that has a self dependency on a parent directive',\n-            () => {\n-              TestBed.configureTestingModule(\n-                  {declarations: [SimpleDirective, NeedsDirectiveFromSelf]});\n-              expect(\n-                  () => createComponent(\n-                      '<div simpleDirective><div needsDirectiveFromSelf></div></div>'))\n-                  .toThrowError(\n-                      'NG0201: No provider for SimpleDirective found in NodeInjector. Find more at https://angular.io/errors/NG0201');\n-            });\n+    it('should not instantiate a directive with cyclic dependencies', () => {\n+      TestBed.configureTestingModule({declarations: [CycleDirective]});\n+      expect(() => createComponent('<div cycleDirective></div>'))\n+          .toThrowError(\n+              'NG0200: Circular dependency in DI detected for CycleDirective. Find more at https://angular.io/errors/NG0200');\n+    });\n+\n+    it('should not instantiate a directive in a view that has a host dependency on providers' +\n+           ' of the component',\n+       () => {\n+         TestBed.configureTestingModule({declarations: [SimpleComponent, NeedsServiceFromHost]});\n+         TestBed.overrideComponent(\n+             SimpleComponent, {set: {providers: [{provide: 'service', useValue: 'hostService'}]}});\n+         TestBed.overrideComponent(\n+             SimpleComponent, {set: {template: '<div needsServiceFromHost><div>'}});\n+\n+         expect(() => createComponent('<div simpleComponent></div>'))\n+             .toThrowError(\n+                 'NG0201: No provider for service found in NodeInjector. Find more at https://angular.io/errors/NG0201');\n+       });\n+\n+    it('should not instantiate a directive in a view that has a host dependency on providers' +\n+           ' of a decorator directive',\n+       () => {\n+         TestBed.configureTestingModule(\n+             {declarations: [SimpleComponent, SomeOtherDirective, NeedsServiceFromHost]});\n+         TestBed.overrideComponent(\n+             SimpleComponent, {set: {providers: [{provide: 'service', useValue: 'hostService'}]}});\n+         TestBed.overrideComponent(\n+             SimpleComponent, {set: {template: '<div needsServiceFromHost><div>'}});\n+\n+         expect(() => createComponent('<div simpleComponent someOtherDirective></div>'))\n+             .toThrowError(\n+                 'NG0201: No provider for service found in NodeInjector. Find more at https://angular.io/errors/NG0201');\n+       });\n+\n+    it('should not instantiate a directive in a view that has a self dependency on a parent directive',\n+       () => {\n+         TestBed.configureTestingModule({declarations: [SimpleDirective, NeedsDirectiveFromSelf]});\n+         expect(\n+             () => createComponent('<div simpleDirective><div needsDirectiveFromSelf></div></div>'))\n+             .toThrowError(\n+                 'NG0201: No provider for SimpleDirective found in NodeInjector. Find more at https://angular.io/errors/NG0201');\n+       });\n \n     it('should instantiate directives that depend on other directives', fakeAsync(() => {\n          TestBed.configureTestingModule({declarations: [SimpleDirective, NeedsDirective]});\n@@ -756,36 +692,15 @@ describe('View injector', () => {\n       expect(d.dependency).toBeAnInstanceOf(SimpleComponent);\n     });\n \n-    obsoleteInIvy('@Host() / @Self() no longer looks in module injector')\n-        .it('should instantiate host views for components that have a @Host dependency ', () => {\n-          TestBed.configureTestingModule({declarations: [NeedsHostAppService]});\n-          const el = createComponent('', [], NeedsHostAppService);\n-          expect(el.componentInstance.service).toEqual('appService');\n-        });\n-\n-    obsoleteInIvy('This error is no longer generated by the compiler')\n-        .it('should not instantiate directives that depend on other directives on the host element',\n-            () => {\n-              TestBed.configureTestingModule(\n-                  {declarations: [SimpleComponent, SimpleDirective, NeedsDirectiveFromHost]});\n-              TestBed.overrideComponent(\n-                  SimpleComponent, {set: {template: '<div needsDirectiveFromHost></div>'}});\n-              expect(() => createComponent('<div simpleComponent simpleDirective></div>'))\n-                  .toThrowError(\n-                      /Template parse errors:\\nNo provider for SimpleDirective \\(\"\\[ERROR ->\\]<div needsDirectiveFromHost><\\/div>\"\\): .*SimpleComponent.html@0:0/);\n-            });\n-\n-    onlyInIvy('This error is generated by the runtime of Ivy')\n-        .it('should not instantiate directives that depend on other directives on the host element',\n-            () => {\n-              TestBed.configureTestingModule(\n-                  {declarations: [SimpleComponent, SimpleDirective, NeedsDirectiveFromHost]});\n-              TestBed.overrideComponent(\n-                  SimpleComponent, {set: {template: '<div needsDirectiveFromHost></div>'}});\n-              expect(() => createComponent('<div simpleComponent simpleDirective></div>'))\n-                  .toThrowError(\n-                      'NG0201: No provider for SimpleDirective found in NodeInjector. Find more at https://angular.io/errors/NG0201');\n-            });\n+    it('should not instantiate directives that depend on other directives on the host element', () => {\n+      TestBed.configureTestingModule(\n+          {declarations: [SimpleComponent, SimpleDirective, NeedsDirectiveFromHost]});\n+      TestBed.overrideComponent(\n+          SimpleComponent, {set: {template: '<div needsDirectiveFromHost></div>'}});\n+      expect(() => createComponent('<div simpleComponent simpleDirective></div>'))\n+          .toThrowError(\n+              'NG0201: No provider for SimpleDirective found in NodeInjector. Find more at https://angular.io/errors/NG0201');\n+    });\n \n     it('should allow to use the NgModule injector from a root ViewContainerRef.parentInjector',\n        () => {\n@@ -870,14 +785,8 @@ describe('View injector', () => {\n        * implementation details of `ViewRef` vary.\n        */\n       function _compareChangeDetectorRefs(a: ChangeDetectorRef, b: ChangeDetectorRef) {\n-        if (!ivyEnabled) {\n-          // View Engine case\n-          expect(a).toEqual(b);\n-        } else {\n-          // Ivy case\n-          expect((a as any)._lView).toEqual((b as any)._lView);\n-          expect((a as any).context).toEqual((b as any).context);\n-        }\n+        expect((a as any)._lView).toEqual((b as any)._lView);\n+        expect((a as any).context).toEqual((b as any).context);\n       }\n \n       _compareChangeDetectorRefs(\n@@ -1013,22 +922,6 @@ describe('View injector', () => {\n       expect(el.children[0].injector.get(SimpleDirective).value.changeDetectorRef).toEqual(cdRef);\n     });\n \n-    modifiedInIvy('Pure pipes are instantiated differently in view engine and ivy')\n-        .it('should cache pure pipes', () => {\n-          TestBed.configureTestingModule({declarations: [SimpleDirective, PurePipe]});\n-          const el = createComponent(\n-              '<div [simpleDirective]=\"true | purePipe\"></div><div [simpleDirective]=\"true | purePipe\"></div>' +\n-              '<div *ngFor=\"let x of [1,2]\" [simpleDirective]=\"true | purePipe\"></div>');\n-          const purePipe1 = el.children[0].injector.get(SimpleDirective).value;\n-          const purePipe2 = el.children[1].injector.get(SimpleDirective).value;\n-          const purePipe3 = el.children[2].injector.get(SimpleDirective).value;\n-          const purePipe4 = el.children[3].injector.get(SimpleDirective).value;\n-          expect(purePipe1).toBeAnInstanceOf(PurePipe);\n-          expect(purePipe2).toBe(purePipe1);\n-          expect(purePipe3).toBe(purePipe1);\n-          expect(purePipe4).toBe(purePipe1);\n-        });\n-\n     it('should not cache impure pipes', () => {\n       TestBed.configureTestingModule({declarations: [SimpleDirective, ImpurePipe]});\n       const el = createComponent("
        },
        {
            "sha": "694a42072ece220a901178e6b3db3dcf628aaae1",
            "filename": "packages/core/test/render3/matchers_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Frender3%2Fmatchers_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Frender3%2Fmatchers_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Fmatchers_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -9,11 +9,9 @@\n import {createTNode, createTView} from '@angular/core/src/render3/instructions/shared';\n import {TNodeType} from '@angular/core/src/render3/interfaces/node';\n import {TViewType} from '@angular/core/src/render3/interfaces/view';\n-import {onlyInIvy} from '@angular/private/testing';\n \n import {isShapeOf, ShapeOf} from './is_shape_of';\n import {matchDomElement, matchDomText, matchObjectShape, matchTNode, matchTView} from './matchers';\n-import {dedent} from './utils';\n \n describe('render3 matchers', () => {\n   describe('matchObjectShape', () => {"
        },
        {
            "sha": "70f99a5bca8a794d9a4a7d60404104498fbf7d7f",
            "filename": "packages/core/test/test_bed_spec.ts",
            "status": "modified",
            "additions": 380,
            "deletions": 392,
            "changes": 772,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Ftest_bed_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fcore%2Ftest%2Ftest_bed_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Ftest_bed_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -10,7 +10,6 @@ import {APP_INITIALIZER, ChangeDetectorRef, Compiler, Component, Directive, Erro\n import {getTestBed, TestBed} from '@angular/core/testing/src/test_bed';\n import {By} from '@angular/platform-browser';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {onlyInIvy} from '@angular/private/testing';\n \n import {TestBedRender3} from '../testing/src/r3_test_bed';\n import {TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT} from '../testing/src/test_bed_common';\n@@ -933,63 +932,61 @@ describe('TestBed', () => {\n     }).toThrowError();\n   });\n \n-  onlyInIvy('TestBed new feature to allow declaration and import of component')\n-      .it('should allow both the declaration and import of a component into the testing module',\n-          () => {\n-            // This test validates that a component (Outer) which is both declared and imported\n-            // (via its module) in the testing module behaves correctly. That is:\n-            //\n-            // 1) the component should be compiled in the scope of its original module.\n-            //\n-            // This condition is tested by having the component (Outer) use another component\n-            // (Inner) within its template. Thus, if it's compiled in the correct scope then the\n-            // text 'Inner' from the template of (Inner) should appear in the result.\n-            //\n-            // 2) the component should be available in the TestingModule scope.\n-            //\n-            // This condition is tested by attempting to use the component (Outer) inside a test\n-            // fixture component (Fixture) which is declared in the testing module only.\n-\n-            @Component({\n-              selector: 'inner',\n-              template: 'Inner',\n-            })\n-            class Inner {\n-            }\n-\n-            @Component({\n-              selector: 'outer',\n-              template: '<inner></inner>',\n-            })\n-            class Outer {\n-            }\n-\n-            @NgModule({\n-              declarations: [Inner, Outer],\n-            })\n-            class Module {\n-            }\n-\n-            @Component({\n-              template: '<outer></outer>',\n-              selector: 'fixture',\n-            })\n-            class Fixture {\n-            }\n-\n-            TestBed.configureTestingModule({\n-              declarations: [Outer, Fixture],\n-              imports: [Module],\n-            });\n-\n-            const fixture = TestBed.createComponent(Fixture);\n-            // The Outer component should have its template stamped out, and that template should\n-            // include a correct instance of the Inner component with the 'Inner' text from its\n-            // template.\n-            expect(fixture.nativeElement.innerHTML).toEqual('<outer><inner>Inner</inner></outer>');\n-          });\n-\n-  onlyInIvy('Ivy-specific errors').describe('checking types before compiling them', () => {\n+  it('should allow both the declaration and import of a component into the testing module', () => {\n+    // This test validates that a component (Outer) which is both declared and imported\n+    // (via its module) in the testing module behaves correctly. That is:\n+    //\n+    // 1) the component should be compiled in the scope of its original module.\n+    //\n+    // This condition is tested by having the component (Outer) use another component\n+    // (Inner) within its template. Thus, if it's compiled in the correct scope then the\n+    // text 'Inner' from the template of (Inner) should appear in the result.\n+    //\n+    // 2) the component should be available in the TestingModule scope.\n+    //\n+    // This condition is tested by attempting to use the component (Outer) inside a test\n+    // fixture component (Fixture) which is declared in the testing module only.\n+\n+    @Component({\n+      selector: 'inner',\n+      template: 'Inner',\n+    })\n+    class Inner {\n+    }\n+\n+    @Component({\n+      selector: 'outer',\n+      template: '<inner></inner>',\n+    })\n+    class Outer {\n+    }\n+\n+    @NgModule({\n+      declarations: [Inner, Outer],\n+    })\n+    class Module {\n+    }\n+\n+    @Component({\n+      template: '<outer></outer>',\n+      selector: 'fixture',\n+    })\n+    class Fixture {\n+    }\n+\n+    TestBed.configureTestingModule({\n+      declarations: [Outer, Fixture],\n+      imports: [Module],\n+    });\n+\n+    const fixture = TestBed.createComponent(Fixture);\n+    // The Outer component should have its template stamped out, and that template should\n+    // include a correct instance of the Inner component with the 'Inner' text from its\n+    // template.\n+    expect(fixture.nativeElement.innerHTML).toEqual('<outer><inner>Inner</inner></outer>');\n+  });\n+\n+  describe('checking types before compiling them', () => {\n     @Directive({\n       selector: 'my-dir',\n     })\n@@ -1019,368 +1016,359 @@ describe('TestBed', () => {\n   });\n \n \n-  onlyInIvy('TestBed should handle AOT pre-compiled Components')\n-      .describe('AOT pre-compiled components', () => {\n-        /**\n-         * Function returns a class that represents AOT-compiled version of the following Component:\n-         *\n-         * @Component({\n-         *  selector: 'comp',\n-         *  templateUrl: './template.ng.html',\n-         *  styleUrls: ['./style.css']\n-         * })\n-         * class ComponentClass {}\n-         *\n-         * This is needed to closer match the behavior of AOT pre-compiled components (compiled\n-         * outside of TestBed) without changing TestBed state and/or Component metadata to compile\n-         * them via TestBed with external resources.\n-         */\n-        const getAOTCompiledComponent = () => {\n-          class ComponentClass {\n-            static ɵfac = () => new ComponentClass();\n-            static ɵcmp = defineComponent({\n-              type: ComponentClass,\n-              selectors: [['comp']],\n-              decls: 1,\n-              vars: 0,\n-              template:\n-                  (rf: any, ctx: any) => {\n-                    if (rf & 1) {\n-                      text(0, 'Some template');\n-                    }\n-                  },\n-              styles: ['body { margin: 0; }']\n-            });\n-          }\n-          setClassMetadata(\n-              ComponentClass, [{\n-                type: Component,\n-                args: [{\n-                  selector: 'comp',\n-                  templateUrl: './template.ng.html',\n-                  styleUrls: ['./style.css'],\n-                }]\n-              }],\n-              null, null);\n-          return ComponentClass;\n-        };\n-\n-        it('should have an ability to override template', () => {\n-          const SomeComponent = getAOTCompiledComponent();\n-          TestBed.configureTestingModule({declarations: [SomeComponent]});\n-          TestBed.overrideTemplateUsingTestingModule(SomeComponent, 'Template override');\n-          const fixture = TestBed.createComponent(SomeComponent);\n-          expect(fixture.nativeElement.innerHTML).toBe('Template override');\n+  describe('AOT pre-compiled components', () => {\n+    /**\n+     * Function returns a class that represents AOT-compiled version of the following Component:\n+     *\n+     * @Component({\n+     *  selector: 'comp',\n+     *  templateUrl: './template.ng.html',\n+     *  styleUrls: ['./style.css']\n+     * })\n+     * class ComponentClass {}\n+     *\n+     * This is needed to closer match the behavior of AOT pre-compiled components (compiled\n+     * outside of TestBed) without changing TestBed state and/or Component metadata to compile\n+     * them via TestBed with external resources.\n+     */\n+    const getAOTCompiledComponent = () => {\n+      class ComponentClass {\n+        static ɵfac = () => new ComponentClass();\n+        static ɵcmp = defineComponent({\n+          type: ComponentClass,\n+          selectors: [['comp']],\n+          decls: 1,\n+          vars: 0,\n+          template:\n+              (rf: any, ctx: any) => {\n+                if (rf & 1) {\n+                  text(0, 'Some template');\n+                }\n+              },\n+          styles: ['body { margin: 0; }']\n         });\n+      }\n+      setClassMetadata(\n+          ComponentClass, [{\n+            type: Component,\n+            args: [{\n+              selector: 'comp',\n+              templateUrl: './template.ng.html',\n+              styleUrls: ['./style.css'],\n+            }]\n+          }],\n+          null, null);\n+      return ComponentClass;\n+    };\n+\n+    it('should have an ability to override template', () => {\n+      const SomeComponent = getAOTCompiledComponent();\n+      TestBed.configureTestingModule({declarations: [SomeComponent]});\n+      TestBed.overrideTemplateUsingTestingModule(SomeComponent, 'Template override');\n+      const fixture = TestBed.createComponent(SomeComponent);\n+      expect(fixture.nativeElement.innerHTML).toBe('Template override');\n+    });\n \n-        it('should have an ability to override template with empty string', () => {\n-          const SomeComponent = getAOTCompiledComponent();\n-          TestBed.configureTestingModule({declarations: [SomeComponent]});\n-          TestBed.overrideTemplateUsingTestingModule(SomeComponent, '');\n-          const fixture = TestBed.createComponent(SomeComponent);\n-          expect(fixture.nativeElement.innerHTML).toBe('');\n-        });\n+    it('should have an ability to override template with empty string', () => {\n+      const SomeComponent = getAOTCompiledComponent();\n+      TestBed.configureTestingModule({declarations: [SomeComponent]});\n+      TestBed.overrideTemplateUsingTestingModule(SomeComponent, '');\n+      const fixture = TestBed.createComponent(SomeComponent);\n+      expect(fixture.nativeElement.innerHTML).toBe('');\n+    });\n \n-        it('should allow component in both in declarations and imports', () => {\n-          const SomeComponent = getAOTCompiledComponent();\n+    it('should allow component in both in declarations and imports', () => {\n+      const SomeComponent = getAOTCompiledComponent();\n \n-          // This is an AOT compiled module which declares (but does not export) SomeComponent.\n-          class ModuleClass {\n-            static ɵmod = defineNgModule({\n-              type: ModuleClass,\n-              declarations: [SomeComponent],\n-            });\n-          }\n+      // This is an AOT compiled module which declares (but does not export) SomeComponent.\n+      class ModuleClass {\n+        static ɵmod = defineNgModule({\n+          type: ModuleClass,\n+          declarations: [SomeComponent],\n+        });\n+      }\n \n-          @Component({\n-            template: '<comp></comp>',\n+      @Component({\n+        template: '<comp></comp>',\n \n-            selector: 'fixture',\n-          })\n-          class TestFixture {\n-          }\n+        selector: 'fixture',\n+      })\n+      class TestFixture {\n+      }\n \n-          TestBed.configureTestingModule({\n-            // Here, SomeComponent is both declared, and then the module which declares it is\n-            // also imported. This used to be a duplicate declaration error, but is now interpreted\n-            // to mean:\n-            // 1) Compile (or reuse) SomeComponent in the context of its original NgModule\n-            // 2) Make SomeComponent available in the scope of the testing module, even if it wasn't\n-            //    originally exported from its NgModule.\n-            //\n-            // This allows TestFixture to use SomeComponent, which is asserted below.\n-            declarations: [SomeComponent, TestFixture],\n-            imports: [ModuleClass],\n-          });\n-          const fixture = TestBed.createComponent(TestFixture);\n-          // The regex avoids any issues with styling attributes.\n-          expect(fixture.nativeElement.innerHTML).toMatch(/<comp[^>]*>Some template<\\/comp>/);\n-        });\n+      TestBed.configureTestingModule({\n+        // Here, SomeComponent is both declared, and then the module which declares it is\n+        // also imported. This used to be a duplicate declaration error, but is now interpreted\n+        // to mean:\n+        // 1) Compile (or reuse) SomeComponent in the context of its original NgModule\n+        // 2) Make SomeComponent available in the scope of the testing module, even if it wasn't\n+        //    originally exported from its NgModule.\n+        //\n+        // This allows TestFixture to use SomeComponent, which is asserted below.\n+        declarations: [SomeComponent, TestFixture],\n+        imports: [ModuleClass],\n       });\n+      const fixture = TestBed.createComponent(TestFixture);\n+      // The regex avoids any issues with styling attributes.\n+      expect(fixture.nativeElement.innerHTML).toMatch(/<comp[^>]*>Some template<\\/comp>/);\n+    });\n+  });\n \n-  onlyInIvy('patched ng defs should be removed after resetting TestingModule')\n-      .describe('resetting ng defs', () => {\n-        it('should restore ng defs to their initial states', () => {\n-          @Pipe({name: 'somePipe', pure: true})\n-          class SomePipe {\n-            transform(value: string): string {\n-              return `transformed ${value}`;\n-            }\n-          }\n+  describe('resetting ng defs', () => {\n+    it('should restore ng defs to their initial states', () => {\n+      @Pipe({name: 'somePipe', pure: true})\n+      class SomePipe {\n+        transform(value: string): string {\n+          return `transformed ${value}`;\n+        }\n+      }\n \n-          @Directive({selector: 'someDirective'})\n-          class SomeDirective {\n-            someProp = 'hello';\n-          }\n+      @Directive({selector: 'someDirective'})\n+      class SomeDirective {\n+        someProp = 'hello';\n+      }\n \n-          @Component({selector: 'comp', template: 'someText'})\n-          class SomeComponent {\n-          }\n+      @Component({selector: 'comp', template: 'someText'})\n+      class SomeComponent {\n+      }\n \n-          @NgModule({declarations: [SomeComponent]})\n-          class SomeModule {\n-          }\n+      @NgModule({declarations: [SomeComponent]})\n+      class SomeModule {\n+      }\n \n-          TestBed.configureTestingModule({imports: [SomeModule]});\n+      TestBed.configureTestingModule({imports: [SomeModule]});\n \n-          // adding Pipe and Directive via metadata override\n-          TestBed.overrideModule(\n-              SomeModule, {set: {declarations: [SomeComponent, SomePipe, SomeDirective]}});\n-          TestBed.overrideComponent(\n-              SomeComponent,\n-              {set: {template: `<span someDirective>{{'hello' | somePipe}}</span>`}});\n-          TestBed.createComponent(SomeComponent);\n+      // adding Pipe and Directive via metadata override\n+      TestBed.overrideModule(\n+          SomeModule, {set: {declarations: [SomeComponent, SomePipe, SomeDirective]}});\n+      TestBed.overrideComponent(\n+          SomeComponent, {set: {template: `<span someDirective>{{'hello' | somePipe}}</span>`}});\n+      TestBed.createComponent(SomeComponent);\n \n-          const cmpDefBeforeReset = (SomeComponent as any).ɵcmp;\n-          expect(cmpDefBeforeReset.pipeDefs().length).toEqual(1);\n-          expect(cmpDefBeforeReset.directiveDefs().length).toEqual(2);  // directive + component\n+      const cmpDefBeforeReset = (SomeComponent as any).ɵcmp;\n+      expect(cmpDefBeforeReset.pipeDefs().length).toEqual(1);\n+      expect(cmpDefBeforeReset.directiveDefs().length).toEqual(2);  // directive + component\n \n-          const modDefBeforeReset = (SomeModule as any).ɵmod;\n-          const transitiveScope = modDefBeforeReset.transitiveCompileScopes.compilation;\n-          expect(transitiveScope.pipes.size).toEqual(1);\n-          expect(transitiveScope.directives.size).toEqual(2);\n+      const modDefBeforeReset = (SomeModule as any).ɵmod;\n+      const transitiveScope = modDefBeforeReset.transitiveCompileScopes.compilation;\n+      expect(transitiveScope.pipes.size).toEqual(1);\n+      expect(transitiveScope.directives.size).toEqual(2);\n \n-          TestBed.resetTestingModule();\n+      TestBed.resetTestingModule();\n \n-          const cmpDefAfterReset = (SomeComponent as any).ɵcmp;\n-          expect(cmpDefAfterReset.pipeDefs).toBe(null);\n-          expect(cmpDefAfterReset.directiveDefs).toBe(null);\n+      const cmpDefAfterReset = (SomeComponent as any).ɵcmp;\n+      expect(cmpDefAfterReset.pipeDefs).toBe(null);\n+      expect(cmpDefAfterReset.directiveDefs).toBe(null);\n \n-          const modDefAfterReset = (SomeModule as any).ɵmod;\n-          expect(modDefAfterReset.transitiveCompileScopes).toBe(null);\n-        });\n+      const modDefAfterReset = (SomeModule as any).ɵmod;\n+      expect(modDefAfterReset.transitiveCompileScopes).toBe(null);\n+    });\n \n-        it('should cleanup ng defs for classes with no ng annotations (in case of inheritance)',\n-           () => {\n-             @Component({selector: 'someDirective', template: '...'})\n-             class SomeComponent {\n-             }\n+    it('should cleanup ng defs for classes with no ng annotations (in case of inheritance)', () => {\n+      @Component({selector: 'someDirective', template: '...'})\n+      class SomeComponent {\n+      }\n \n-             class ComponentWithNoAnnotations extends SomeComponent {}\n-\n-             @Directive({selector: 'some-directive'})\n-             class SomeDirective {\n-             }\n-\n-             class DirectiveWithNoAnnotations extends SomeDirective {}\n-\n-             @Pipe({name: 'some-pipe'})\n-             class SomePipe {\n-             }\n-\n-             class PipeWithNoAnnotations extends SomePipe {}\n-\n-             TestBed.configureTestingModule({\n-               declarations:\n-                   [ComponentWithNoAnnotations, DirectiveWithNoAnnotations, PipeWithNoAnnotations]\n-             });\n-             TestBed.createComponent(ComponentWithNoAnnotations);\n+      class ComponentWithNoAnnotations extends SomeComponent {}\n \n-             expect(ComponentWithNoAnnotations.hasOwnProperty('ɵcmp')).toBeTruthy();\n-             expect(SomeComponent.hasOwnProperty('ɵcmp')).toBeTruthy();\n-\n-             expect(DirectiveWithNoAnnotations.hasOwnProperty('ɵdir')).toBeTruthy();\n-             expect(SomeDirective.hasOwnProperty('ɵdir')).toBeTruthy();\n-\n-             expect(PipeWithNoAnnotations.hasOwnProperty('ɵpipe')).toBeTruthy();\n-             expect(SomePipe.hasOwnProperty('ɵpipe')).toBeTruthy();\n-\n-             TestBed.resetTestingModule();\n-\n-             // ng defs should be removed from classes with no annotations\n-             expect(ComponentWithNoAnnotations.hasOwnProperty('ɵcmp')).toBeFalsy();\n-             expect(DirectiveWithNoAnnotations.hasOwnProperty('ɵdir')).toBeFalsy();\n-             expect(PipeWithNoAnnotations.hasOwnProperty('ɵpipe')).toBeFalsy();\n-\n-             // ng defs should be preserved on super types\n-             expect(SomeComponent.hasOwnProperty('ɵcmp')).toBeTruthy();\n-             expect(SomeDirective.hasOwnProperty('ɵdir')).toBeTruthy();\n-             expect(SomePipe.hasOwnProperty('ɵpipe')).toBeTruthy();\n-           });\n-\n-        it('should cleanup scopes (configured via `TestBed.configureTestingModule`) between tests',\n-           () => {\n-             @Component({\n-               selector: 'child',\n-               template: 'Child comp',\n-             })\n-             class ChildCmp {\n-             }\n-\n-             @Component({\n-               selector: 'root',\n-               template: '<child></child>',\n-             })\n-             class RootCmp {\n-             }\n-\n-             // Case #1: `RootCmp` and `ChildCmp` are both included in the `declarations` field of\n-             // the testing module, so `ChildCmp` is in the scope of `RootCmp`.\n-             TestBed.configureTestingModule({\n-               declarations: [RootCmp, ChildCmp],\n-             });\n-\n-             let fixture = TestBed.createComponent(RootCmp);\n-             fixture.detectChanges();\n-\n-             let childCmpInstance = fixture.debugElement.query(By.directive(ChildCmp));\n-             expect(childCmpInstance.componentInstance).toBeAnInstanceOf(ChildCmp);\n-             expect(fixture.nativeElement.textContent).toBe('Child comp');\n-\n-             TestBed.resetTestingModule();\n-\n-             // Case #2: the `TestBed.configureTestingModule` was not invoked, thus the `ChildCmp`\n-             // should not be available in the `RootCmp` scope and no child content should be\n-             // rendered.\n-             fixture = TestBed.createComponent(RootCmp);\n-             fixture.detectChanges();\n-\n-             childCmpInstance = fixture.debugElement.query(By.directive(ChildCmp));\n-             expect(childCmpInstance).toBeNull();\n-             expect(fixture.nativeElement.textContent).toBe('');\n-\n-             TestBed.resetTestingModule();\n-\n-             // Case #3: `ChildCmp` is included in the `declarations` field, but `RootCmp` is not,\n-             // so `ChildCmp` is NOT in the scope of `RootCmp` component.\n-             TestBed.configureTestingModule({\n-               declarations: [ChildCmp],\n-             });\n-\n-             fixture = TestBed.createComponent(RootCmp);\n-             fixture.detectChanges();\n-\n-             childCmpInstance = fixture.debugElement.query(By.directive(ChildCmp));\n-             expect(childCmpInstance).toBeNull();\n-             expect(fixture.nativeElement.textContent).toBe('');\n-           });\n-\n-        it('should clean up overridden providers for modules that are imported more than once',\n-           () => {\n-             @Injectable()\n-             class Token {\n-               name: string = 'real';\n-             }\n-\n-             @NgModule({\n-               providers: [Token],\n-             })\n-             class Module {\n-             }\n-\n-             TestBed.configureTestingModule({imports: [Module, Module]});\n-             TestBed.overrideProvider(Token, {useValue: {name: 'fake'}});\n-\n-             expect(TestBed.inject(Token).name).toEqual('fake');\n-\n-             TestBed.resetTestingModule();\n-\n-             // The providers for the module should have been restored to the original array, with\n-             // no trace of the overridden providers.\n-             expect((Module as any).ɵinj.providers).toEqual([Token]);\n-           });\n-\n-        it('should clean up overridden providers on components whose modules are compiled more than once',\n-           async () => {\n-             @Injectable()\n-             class SomeInjectable {\n-               id: string|undefined;\n-             }\n-\n-             @Component({providers: [SomeInjectable]})\n-             class ComponentWithProvider {\n-               constructor(readonly injectable: SomeInjectable) {}\n-             }\n-\n-             @NgModule({declarations: [ComponentWithProvider]})\n-             class MyModule {\n-             }\n-\n-             TestBed.configureTestingModule({imports: [MyModule]});\n-             const originalResolver = (ComponentWithProvider as any).ɵcmp.providersResolver;\n-             TestBed.overrideProvider(SomeInjectable, {useValue: {id: 'fake'}});\n-\n-             const compiler = TestBed.inject(Compiler);\n-             await compiler.compileModuleAsync(MyModule);\n-             compiler.compileModuleSync(MyModule);\n-\n-             TestBed.resetTestingModule();\n-             expect((ComponentWithProvider as any).ɵcmp.providersResolver)\n-                 .toEqual(originalResolver);\n-           });\n-      });\n+      @Directive({selector: 'some-directive'})\n+      class SomeDirective {\n+      }\n \n-  onlyInIvy('VE injects undefined when provider does not have useValue or useFactory')\n-      .describe('overrides provider', () => {\n-        it('with empty provider object', () => {\n-          @Injectable()\n-          class Service {\n-          }\n-          TestBed.overrideProvider(Service, {});\n-          // Should be able to get a Service instance because it has no dependencies that can't be\n-          // resolved\n-          expect(TestBed.inject(Service)).toBeDefined();\n-        });\n+      class DirectiveWithNoAnnotations extends SomeDirective {}\n+\n+      @Pipe({name: 'some-pipe'})\n+      class SomePipe {\n+      }\n+\n+      class PipeWithNoAnnotations extends SomePipe {}\n+\n+      TestBed.configureTestingModule({\n+        declarations:\n+            [ComponentWithNoAnnotations, DirectiveWithNoAnnotations, PipeWithNoAnnotations]\n       });\n+      TestBed.createComponent(ComponentWithNoAnnotations);\n \n-  onlyInIvy('uses Ivy-specific compiler output')\n-      .it('should handle provider overrides when module imports are provided as a function', () => {\n-        class InjectedString {\n-          value?: string;\n-        }\n+      expect(ComponentWithNoAnnotations.hasOwnProperty('ɵcmp')).toBeTruthy();\n+      expect(SomeComponent.hasOwnProperty('ɵcmp')).toBeTruthy();\n \n-        @Component({template: '{{injectedString.value}}'})\n-        class AppComponent {\n-          constructor(public injectedString: InjectedString) {}\n-        }\n+      expect(DirectiveWithNoAnnotations.hasOwnProperty('ɵdir')).toBeTruthy();\n+      expect(SomeDirective.hasOwnProperty('ɵdir')).toBeTruthy();\n \n-        @NgModule({})\n-        class DependencyModule {\n-        }\n+      expect(PipeWithNoAnnotations.hasOwnProperty('ɵpipe')).toBeTruthy();\n+      expect(SomePipe.hasOwnProperty('ɵpipe')).toBeTruthy();\n \n-        // We need to write the compiler output manually here,\n-        // because it depends on code generated by ngcc.\n-        class TestingModule {\n-          static ɵmod = defineNgModule({type: TestingModule});\n-          static ɵinj = defineInjector({imports: [DependencyModule]});\n-        }\n-        setNgModuleScope(TestingModule, {imports: () => [DependencyModule]});\n-\n-        TestBed\n-            .configureTestingModule({\n-              imports: [TestingModule],\n-              declarations: [AppComponent],\n-              providers: [{provide: InjectedString, useValue: {value: 'initial'}}],\n-            })\n-            .compileComponents();\n-\n-        TestBed.overrideProvider(InjectedString, {useValue: {value: 'changed'}})\n-            .compileComponents();\n-\n-        const fixture = TestBed.createComponent(AppComponent);\n-        fixture.detectChanges();\n-        expect(fixture!.nativeElement.textContent).toContain('changed');\n-      });\n+      TestBed.resetTestingModule();\n+\n+      // ng defs should be removed from classes with no annotations\n+      expect(ComponentWithNoAnnotations.hasOwnProperty('ɵcmp')).toBeFalsy();\n+      expect(DirectiveWithNoAnnotations.hasOwnProperty('ɵdir')).toBeFalsy();\n+      expect(PipeWithNoAnnotations.hasOwnProperty('ɵpipe')).toBeFalsy();\n+\n+      // ng defs should be preserved on super types\n+      expect(SomeComponent.hasOwnProperty('ɵcmp')).toBeTruthy();\n+      expect(SomeDirective.hasOwnProperty('ɵdir')).toBeTruthy();\n+      expect(SomePipe.hasOwnProperty('ɵpipe')).toBeTruthy();\n+    });\n+\n+    it('should cleanup scopes (configured via `TestBed.configureTestingModule`) between tests',\n+       () => {\n+         @Component({\n+           selector: 'child',\n+           template: 'Child comp',\n+         })\n+         class ChildCmp {\n+         }\n+\n+         @Component({\n+           selector: 'root',\n+           template: '<child></child>',\n+         })\n+         class RootCmp {\n+         }\n+\n+         // Case #1: `RootCmp` and `ChildCmp` are both included in the `declarations` field of\n+         // the testing module, so `ChildCmp` is in the scope of `RootCmp`.\n+         TestBed.configureTestingModule({\n+           declarations: [RootCmp, ChildCmp],\n+         });\n+\n+         let fixture = TestBed.createComponent(RootCmp);\n+         fixture.detectChanges();\n+\n+         let childCmpInstance = fixture.debugElement.query(By.directive(ChildCmp));\n+         expect(childCmpInstance.componentInstance).toBeAnInstanceOf(ChildCmp);\n+         expect(fixture.nativeElement.textContent).toBe('Child comp');\n+\n+         TestBed.resetTestingModule();\n+\n+         // Case #2: the `TestBed.configureTestingModule` was not invoked, thus the `ChildCmp`\n+         // should not be available in the `RootCmp` scope and no child content should be\n+         // rendered.\n+         fixture = TestBed.createComponent(RootCmp);\n+         fixture.detectChanges();\n+\n+         childCmpInstance = fixture.debugElement.query(By.directive(ChildCmp));\n+         expect(childCmpInstance).toBeNull();\n+         expect(fixture.nativeElement.textContent).toBe('');\n+\n+         TestBed.resetTestingModule();\n+\n+         // Case #3: `ChildCmp` is included in the `declarations` field, but `RootCmp` is not,\n+         // so `ChildCmp` is NOT in the scope of `RootCmp` component.\n+         TestBed.configureTestingModule({\n+           declarations: [ChildCmp],\n+         });\n+\n+         fixture = TestBed.createComponent(RootCmp);\n+         fixture.detectChanges();\n+\n+         childCmpInstance = fixture.debugElement.query(By.directive(ChildCmp));\n+         expect(childCmpInstance).toBeNull();\n+         expect(fixture.nativeElement.textContent).toBe('');\n+       });\n+\n+    it('should clean up overridden providers for modules that are imported more than once', () => {\n+      @Injectable()\n+      class Token {\n+        name: string = 'real';\n+      }\n+\n+      @NgModule({\n+        providers: [Token],\n+      })\n+      class Module {\n+      }\n+\n+      TestBed.configureTestingModule({imports: [Module, Module]});\n+      TestBed.overrideProvider(Token, {useValue: {name: 'fake'}});\n+\n+      expect(TestBed.inject(Token).name).toEqual('fake');\n+\n+      TestBed.resetTestingModule();\n+\n+      // The providers for the module should have been restored to the original array, with\n+      // no trace of the overridden providers.\n+      expect((Module as any).ɵinj.providers).toEqual([Token]);\n+    });\n+\n+    it('should clean up overridden providers on components whose modules are compiled more than once',\n+       async () => {\n+         @Injectable()\n+         class SomeInjectable {\n+           id: string|undefined;\n+         }\n+\n+         @Component({providers: [SomeInjectable]})\n+         class ComponentWithProvider {\n+           constructor(readonly injectable: SomeInjectable) {}\n+         }\n+\n+         @NgModule({declarations: [ComponentWithProvider]})\n+         class MyModule {\n+         }\n+\n+         TestBed.configureTestingModule({imports: [MyModule]});\n+         const originalResolver = (ComponentWithProvider as any).ɵcmp.providersResolver;\n+         TestBed.overrideProvider(SomeInjectable, {useValue: {id: 'fake'}});\n+\n+         const compiler = TestBed.inject(Compiler);\n+         await compiler.compileModuleAsync(MyModule);\n+         compiler.compileModuleSync(MyModule);\n+\n+         TestBed.resetTestingModule();\n+         expect((ComponentWithProvider as any).ɵcmp.providersResolver).toEqual(originalResolver);\n+       });\n+  });\n+\n+  describe('overrides provider', () => {\n+    it('with empty provider object', () => {\n+      @Injectable()\n+      class Service {\n+      }\n+      TestBed.overrideProvider(Service, {});\n+      // Should be able to get a Service instance because it has no dependencies that can't be\n+      // resolved\n+      expect(TestBed.inject(Service)).toBeDefined();\n+    });\n+  });\n+\n+  it('should handle provider overrides when module imports are provided as a function', () => {\n+    class InjectedString {\n+      value?: string;\n+    }\n+\n+    @Component({template: '{{injectedString.value}}'})\n+    class AppComponent {\n+      constructor(public injectedString: InjectedString) {}\n+    }\n+\n+    @NgModule({})\n+    class DependencyModule {\n+    }\n+\n+    // We need to write the compiler output manually here,\n+    // because it depends on code generated by ngcc.\n+    class TestingModule {\n+      static ɵmod = defineNgModule({type: TestingModule});\n+      static ɵinj = defineInjector({imports: [DependencyModule]});\n+    }\n+    setNgModuleScope(TestingModule, {imports: () => [DependencyModule]});\n+\n+    TestBed\n+        .configureTestingModule({\n+          imports: [TestingModule],\n+          declarations: [AppComponent],\n+          providers: [{provide: InjectedString, useValue: {value: 'initial'}}],\n+        })\n+        .compileComponents();\n+\n+    TestBed.overrideProvider(InjectedString, {useValue: {value: 'changed'}}).compileComponents();\n+\n+    const fixture = TestBed.createComponent(AppComponent);\n+    fixture.detectChanges();\n+    expect(fixture!.nativeElement.textContent).toContain('changed');\n+  });\n });\n \n "
        },
        {
            "sha": "55d15bc3a0cdefeda9fe575cb37ddf19e536fe4a",
            "filename": "packages/examples/common/ngComponentOutlet/ts/e2e_test/ngComponentOutlet_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 10,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fexamples%2Fcommon%2FngComponentOutlet%2Fts%2Fe2e_test%2FngComponentOutlet_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fexamples%2Fcommon%2FngComponentOutlet%2Fts%2Fe2e_test%2FngComponentOutlet_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fexamples%2Fcommon%2FngComponentOutlet%2Fts%2Fe2e_test%2FngComponentOutlet_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -6,7 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {modifiedInIvy} from '@angular/private/testing';\n import {$, browser, by, element, ExpectedConditions} from 'protractor';\n \n import {verifyNoBrowserErrors} from '../../../../test-utils';\n@@ -27,14 +26,5 @@ describe('ngComponentOutlet', () => {\n       waitForElement('ng-component-outlet-simple-example');\n       expect(element.all(by.css('hello-world')).getText()).toEqual(['Hello World!']);\n     });\n-\n-    modifiedInIvy('Different behavior for projectableNodes in ViewContainerRef.createComponent')\n-        .it('should render complete', () => {\n-          browser.get(URL);\n-          waitForElement('ng-component-outlet-complete-example');\n-          expect(element.all(by.css('complete-component')).getText()).toEqual([\n-            'Complete: AhojSvet!'\n-          ]);\n-        });\n   });\n });"
        },
        {
            "sha": "b011ec1bcab27d2559db35ee37a929d73e3d90c1",
            "filename": "packages/examples/common/ngIf/ts/e2e_test/ngIf_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fexamples%2Fcommon%2FngIf%2Fts%2Fe2e_test%2FngIf_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fexamples%2Fcommon%2FngIf%2Fts%2Fe2e_test%2FngIf_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fexamples%2Fcommon%2FngIf%2Fts%2Fe2e_test%2FngIf_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -6,7 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {modifiedInIvy} from '@angular/private/testing';\n import {$, browser, by, element, ExpectedConditions} from 'protractor';\n \n import {verifyNoBrowserErrors} from '../../../../test-utils';"
        },
        {
            "sha": "b14a233aa1b076721feb36129cd6d9bc10afe799",
            "filename": "packages/platform-browser/animations/test/animation_renderer_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fplatform-browser%2Fanimations%2Ftest%2Fanimation_renderer_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fplatform-browser%2Fanimations%2Ftest%2Fanimation_renderer_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser%2Fanimations%2Ftest%2Fanimation_renderer_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -12,7 +12,7 @@ import {TestBed} from '@angular/core/testing';\n import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';\n import {BrowserAnimationsModule, ɵAnimationRendererFactory as AnimationRendererFactory, ɵInjectableAnimationEngine as InjectableAnimationEngine} from '@angular/platform-browser/animations';\n import {DomRendererFactory2} from '@angular/platform-browser/src/dom/dom_renderer';\n-import {onlyInIvy, withBody} from '@angular/private/testing';\n+import {withBody} from '@angular/private/testing';\n \n import {el} from '../../testing/src/browser_util';\n \n@@ -326,7 +326,7 @@ describe('AnimationRendererFactory', () => {\n   });\n });\n \n-onlyInIvy('View Engine uses another mechanism of removing DOM nodes').describe('destroy', () => {\n+describe('destroy', () => {\n   beforeEach(destroyPlatform);\n   afterEach(destroyPlatform);\n "
        },
        {
            "sha": "1cabd14f6962bd31c5e7d97df27f715bae4d4b7e",
            "filename": "packages/platform-browser/test/browser/bootstrap_spec.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 43,
            "changes": 60,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fplatform-browser%2Ftest%2Fbrowser%2Fbootstrap_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fplatform-browser%2Ftest%2Fbrowser%2Fbootstrap_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser%2Ftest%2Fbrowser%2Fbootstrap_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -17,7 +17,6 @@ import {Log} from '@angular/core/testing/src/testing_internal';\n import {BrowserModule} from '@angular/platform-browser';\n import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {ivyEnabled, modifiedInIvy, onlyInIvy} from '@angular/private/testing';\n \n @Component({selector: 'non-existent', template: ''})\n class NonExistentComp {\n@@ -149,43 +148,25 @@ function bootstrap(\n \n     afterEach(destroyPlatform);\n \n-    modifiedInIvy('bootstrapping non-Component throws in View Engine')\n-        .it('should throw if bootstrapped Directive is not a Component', done => {\n-          const logger = new MockConsole();\n-          const errorHandler = new ErrorHandler();\n-          (errorHandler as any)._console = logger as any;\n-          expect(\n-              () => bootstrap(\n-                  HelloRootDirectiveIsNotCmp, [{provide: ErrorHandler, useValue: errorHandler}]))\n-              .toThrowError(`HelloRootDirectiveIsNotCmp cannot be used as an entry component.`);\n-          done();\n-        });\n-\n-    onlyInIvy('bootstrapping non-Component rejects Promise in Ivy')\n-        .it('should throw if bootstrapped Directive is not a Component', done => {\n-          const logger = new MockConsole();\n-          const errorHandler = new ErrorHandler();\n-          (errorHandler as any)._console = logger as any;\n-          bootstrap(HelloRootDirectiveIsNotCmp, [\n-            {provide: ErrorHandler, useValue: errorHandler}\n-          ]).catch((error: Error) => {\n-            expect(error).toEqual(\n-                new Error(`HelloRootDirectiveIsNotCmp cannot be used as an entry component.`));\n-            done();\n-          });\n-        });\n+    it('should throw if bootstrapped Directive is not a Component', done => {\n+      const logger = new MockConsole();\n+      const errorHandler = new ErrorHandler();\n+      (errorHandler as any)._console = logger as any;\n+      bootstrap(HelloRootDirectiveIsNotCmp, [\n+        {provide: ErrorHandler, useValue: errorHandler}\n+      ]).catch((error: Error) => {\n+        expect(error).toEqual(\n+            new Error(`HelloRootDirectiveIsNotCmp cannot be used as an entry component.`));\n+        done();\n+      });\n+    });\n \n     it('should retrieve sanitizer', inject([Injector], (injector: Injector) => {\n          const sanitizer: Sanitizer|null = injector.get(Sanitizer, null);\n-         if (ivyEnabled) {\n-           // In Ivy we don't want to have sanitizer in DI. We use DI only to overwrite the\n-           // sanitizer, but not for default one. The default one is pulled in by the Ivy\n-           // instructions as needed.\n-           expect(sanitizer).toBe(null);\n-         } else {\n-           // In VE we always need to have Sanitizer available.\n-           expect(sanitizer).not.toBe(null);\n-         }\n+         // We don't want to have sanitizer in DI. We use DI only to overwrite the\n+         // sanitizer, but not for default one. The default one is pulled in by the Ivy\n+         // instructions as needed.\n+         expect(sanitizer).toBe(null);\n        }));\n \n     it('should throw if no element is found', done => {\n@@ -227,14 +208,7 @@ function bootstrap(\n       bootstrap(RootCmp, [{provide: ErrorHandler, useValue: errorHandler}], [], [\n         CustomModule\n       ]).then(null, (e: Error) => {\n-        let errorMsg: string;\n-        if (ivyEnabled) {\n-          errorMsg = `R3InjectorError(TestModule)[IDontExist -> IDontExist -> IDontExist]: \\n`;\n-        } else {\n-          errorMsg = `StaticInjectorError(TestModule)[CustomCmp -> IDontExist]: \\n` +\n-              '  StaticInjectorError(Platform: core)[CustomCmp -> IDontExist]: \\n' +\n-              '    NullInjectorError: No provider for IDontExist!';\n-        }\n+        const errorMsg = `R3InjectorError(TestModule)[IDontExist -> IDontExist -> IDontExist]: \\n`;\n         expect(e.message).toContain(errorMsg);\n         done();\n         return null;"
        },
        {
            "sha": "1232250eae9ff6b11fffc841e07d6e9c4ab65afb",
            "filename": "packages/platform-browser/test/testing_public_spec.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 52,
            "changes": 66,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fplatform-browser%2Ftest%2Ftesting_public_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fplatform-browser%2Ftest%2Ftesting_public_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser%2Ftest%2Ftesting_public_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -6,11 +6,10 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {CompilerConfig, ResourceLoader} from '@angular/compiler';\n+import {ResourceLoader} from '@angular/compiler';\n import {Compiler, Component, ComponentFactoryResolver, CUSTOM_ELEMENTS_SCHEMA, Directive, Inject, Injectable, InjectionToken, Injector, Input, NgModule, Optional, Pipe, SkipSelf, Type, ɵstringify as stringify} from '@angular/core';\n import {fakeAsync, getTestBed, inject, TestBed, tick, waitForAsync, withModule} from '@angular/core/testing';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {ivyEnabled, modifiedInIvy, obsoleteInIvy, onlyInIvy} from '@angular/private/testing';\n \n // Services, and components for the tests.\n \n@@ -820,23 +819,6 @@ const bTok = new InjectionToken<string>('b');\n                 expect(compFixture.nativeElement).toHaveText('Hello world!');\n               }));\n         });\n-\n-        describe('useJit true', () => {\n-          beforeEach(() => TestBed.configureCompiler({useJit: true}));\n-          obsoleteInIvy('the Render3 compiler JiT mode is not configurable')\n-              .it('should set the value into CompilerConfig',\n-                  inject([CompilerConfig], (config: CompilerConfig) => {\n-                    expect(config.useJit).toBe(true);\n-                  }));\n-        });\n-        describe('useJit false', () => {\n-          beforeEach(() => TestBed.configureCompiler({useJit: false}));\n-          obsoleteInIvy('the Render3 compiler JiT mode is not configurable')\n-              .it('should set the value into CompilerConfig',\n-                  inject([CompilerConfig], (config: CompilerConfig) => {\n-                    expect(config.useJit).toBe(false);\n-                  }));\n-        });\n       });\n     });\n \n@@ -919,44 +901,24 @@ const bTok = new InjectionToken<string>('b');\n               expect(withModule(\n                          {declarations: [InlineCompWithUrlTemplate]},\n                          () => TestBed.createComponent(InlineCompWithUrlTemplate)))\n-                  .toThrowError(\n-                      ivyEnabled ?\n-                          `Component 'InlineCompWithUrlTemplate' is not resolved:\n+                  .toThrowError(`Component 'InlineCompWithUrlTemplate' is not resolved:\n  - templateUrl: /base/angular/packages/platform-browser/test/static_assets/test.html\n-Did you run and wait for 'resolveComponentResources()'?` :\n-                          `This test module uses the component ${\n-                              stringify(\n-                                  InlineCompWithUrlTemplate)} which is using a \"templateUrl\" or \"styleUrls\", but they were never compiled. ` +\n-                              `Please call \"TestBed.compileComponents\" before your test.`);\n+Did you run and wait for 'resolveComponentResources()'?`);\n             });\n       });\n \n-      modifiedInIvy(`Unknown property error thrown instead of logging a message`)\n-          .it('should error on unknown bound properties on custom elements by default', () => {\n-            @Component({template: '<some-element [someUnknownProp]=\"true\"></some-element>'})\n-            class ComponentUsingInvalidProperty {\n-            }\n-\n-            expect(\n-                () => withModule(\n-                    {declarations: [ComponentUsingInvalidProperty]},\n-                    () => TestBed.createComponent(ComponentUsingInvalidProperty))())\n-                .toThrowError(/Can't bind to 'someUnknownProp'/);\n-          });\n-\n-      onlyInIvy(`Unknown property error logged instead of throwing`)\n-          .it('should error on unknown bound properties on custom elements by default', () => {\n-            @Component({template: '<div [someUnknownProp]=\"true\"></div>'})\n-            class ComponentUsingInvalidProperty {\n-            }\n+      it('should error on unknown bound properties on custom elements by default', () => {\n+        @Component({template: '<div [someUnknownProp]=\"true\"></div>'})\n+        class ComponentUsingInvalidProperty {\n+        }\n \n-            const spy = spyOn(console, 'error');\n-            withModule({declarations: [ComponentUsingInvalidProperty]}, () => {\n-              const fixture = TestBed.createComponent(ComponentUsingInvalidProperty);\n-              fixture.detectChanges();\n-            })();\n-            expect(spy.calls.mostRecent().args[0]).toMatch(/Can't bind to 'someUnknownProp'/);\n-          });\n+        const spy = spyOn(console, 'error');\n+        withModule({declarations: [ComponentUsingInvalidProperty]}, () => {\n+          const fixture = TestBed.createComponent(ComponentUsingInvalidProperty);\n+          fixture.detectChanges();\n+        })();\n+        expect(spy.calls.mostRecent().args[0]).toMatch(/Can't bind to 'someUnknownProp'/);\n+      });\n     });\n \n     describe('creating components', () => {"
        },
        {
            "sha": "5ee8a1393188c644f6b268b0e5026850dcb24937",
            "filename": "packages/platform-server/test/integration_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 16,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fplatform-server%2Ftest%2Fintegration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fplatform-server%2Ftest%2Fintegration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-server%2Ftest%2Fintegration_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -14,7 +14,6 @@ import {ApplicationRef, CompilerFactory, Component, destroyPlatform, getPlatform\n import {inject, waitForAsync} from '@angular/core/testing';\n import {BrowserModule, makeStateKey, Title, TransferState} from '@angular/platform-browser';\n import {BEFORE_APP_SERIALIZED, INITIAL_CONFIG, platformDynamicServer, PlatformState, renderModule, renderModuleFactory, ServerModule, ServerTransferStateModule} from '@angular/platform-server';\n-import {ivyEnabled, modifiedInIvy} from '@angular/private/testing';\n import {Observable} from 'rxjs';\n import {first} from 'rxjs/operators';\n \n@@ -590,12 +589,6 @@ describe('platform-server integration', () => {\n       // PlatformConfig takes in a parsed document so that it can be cached across requests.\n       doc = '<html><head></head><body><app></app></body></html>';\n       called = false;\n-      // We use `window` and `document` directly in some parts of render3 for ivy\n-      // Only set it to undefined for legacy\n-      if (!ivyEnabled) {\n-        (global as any)['window'] = undefined;\n-        (global as any)['document'] = undefined;\n-      }\n     });\n     afterEach(() => {\n       expect(called).toBe(true);\n@@ -625,15 +618,6 @@ describe('platform-server integration', () => {\n          });\n        }));\n \n-    modifiedInIvy('Will not support binding to innerText in Ivy since domino does not')\n-        .it('should support binding to innerText', waitForAsync(() => {\n-              renderModule(InnerTextModule, {document: doc}).then(output => {\n-                expect(output).toBe(\n-                    '<html><head></head><body><app ng-version=\"0.0.0-PLACEHOLDER\"><div innertext=\"Some text\">Some text</div></app></body></html>');\n-                called = true;\n-              });\n-            }));\n-\n     it('using renderModuleFactory should work',\n        waitForAsync(inject([PlatformRef], (defaultPlatform: PlatformRef) => {\n          const compilerFactory: CompilerFactory ="
        },
        {
            "sha": "0cdbf319b81640c1de86617fd14bf9bde8fb6976",
            "filename": "packages/private/testing/index.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fprivate%2Ftesting%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fprivate%2Ftesting%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fprivate%2Ftesting%2Findex.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -7,4 +7,3 @@\n  */\n \n export * from './src/render3';\n-export * from './src/ivy_test_selectors';"
        },
        {
            "sha": "8a2caba0da1e128a2a307fc893d7b629e28b8e32",
            "filename": "packages/private/testing/src/angular_ivy_enabled.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 12,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/d8e65776cb35b08c435335ffeac0f82789477532/packages%2Fprivate%2Ftesting%2Fsrc%2Fangular_ivy_enabled.ts",
            "raw_url": "https://github.com/angular/angular/raw/d8e65776cb35b08c435335ffeac0f82789477532/packages%2Fprivate%2Ftesting%2Fsrc%2Fangular_ivy_enabled.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fprivate%2Ftesting%2Fsrc%2Fangular_ivy_enabled.ts?ref=d8e65776cb35b08c435335ffeac0f82789477532",
            "patch": "@@ -1,12 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-/**\n- * This variable shows if Ivy should be enabled at runtime.\n- */\n-export const ivyEnabled = true;"
        },
        {
            "sha": "31d3e2303441247ff514fe24e15fe55eb6c84fbb",
            "filename": "packages/private/testing/src/ivy_test_selectors.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 137,
            "changes": 137,
            "blob_url": "https://github.com/angular/angular/blob/d8e65776cb35b08c435335ffeac0f82789477532/packages%2Fprivate%2Ftesting%2Fsrc%2Fivy_test_selectors.ts",
            "raw_url": "https://github.com/angular/angular/raw/d8e65776cb35b08c435335ffeac0f82789477532/packages%2Fprivate%2Ftesting%2Fsrc%2Fivy_test_selectors.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fprivate%2Ftesting%2Fsrc%2Fivy_test_selectors.ts?ref=d8e65776cb35b08c435335ffeac0f82789477532",
            "patch": "@@ -1,137 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import {ivyEnabled} from './angular_ivy_enabled';\n-\n-/**\n- * A function to conditionally include a test or a block of tests only when tests run against Ivy.\n- *\n- * The modification of the behavior must be well justified, not affect common usage patterns, and\n- * documented as a breaking change.\n- *\n- * ```\n- * ivyEnabled && describe(...);\n- * ```\n- *\n- * or\n- *\n- * ```\n- * ivyEnabled && it(...);\n- * ```\n- */\n-export {ivyEnabled};\n-\n-/**\n- * A function to conditionally skip the execution of tests that are not relevant when\n- * running against Ivy.\n- *\n- * Any tests disabled using this switch should not be user-facing breaking changes.\n- *\n- * ```\n- * obsoleteInIvy('some reason').describe(...);\n- * ```\n- *\n- * or\n- *\n- * ```\n- * obsoleteInIvy('some reason').it(...);\n- * ```\n- */\n-export function obsoleteInIvy(reason: string): JasmineMethods {\n-  return ivyEnabled ? IGNORE : PASSTHROUGH;\n-}\n-\n-/**\n- * A function to conditionally skip the execution of tests that are not relevant when\n- * not running against Ivy.\n- *\n- * ```\n- * onlyInIvy('some reason').describe(...);\n- * ```\n- *\n- * or\n- *\n- * ```\n- * onlyInIvy('some reason').it(...);\n- * ```\n- */\n-export function onlyInIvy(reason: string): JasmineMethods {\n-  return PASSTHROUGH;\n-}\n-\n-/**\n- * A function to conditionally skip the execution of tests that have intentionally\n- * been broken when running against Ivy.\n- *\n- * The modification of the behavior must be well justified, not affect common usage patterns, and\n- * documented as a breaking change.\n- *\n- * ```\n- * modifiedInIvy('some reason').describe(...);\n- * ```\n- *\n- * or\n- *\n- * ```\n- * modifiedInIvy('some reason').it(...);\n- * ```\n- */\n-export function modifiedInIvy(reason: string): JasmineMethods {\n-  return IGNORE;\n-}\n-\n-export interface JasmineMethods {\n-  it: typeof it;\n-  fit: typeof fit;\n-  describe: typeof describe;\n-  fdescribe: typeof fdescribe;\n-\n-  /**\n-   * Runs jasmine expectations against the provided keys for `ngDevMode`.\n-   *\n-   * Will not perform expectations for keys that are not provided.\n-   *\n-   * ```ts\n-   * // Expect that `ngDevMode.styleMap` is `1`, and `ngDevMode.tNode` is `3`, but we don't care\n-   * // about the other values.\n-   * onlyInIvy('perf counters').expectPerfCounters({\n-   *   stylingMap: 1,\n-   *   tNode: 3,\n-   * })\n-   * ```\n-   */\n-  expectPerfCounters: (expectedCounters: Partial<NgDevModePerfCounters>) => void;\n-  isEnabled: boolean;\n-}\n-\n-const PASSTHROUGH: JasmineMethods = {\n-  it,\n-  fit,\n-  describe,\n-  fdescribe,\n-  expectPerfCounters,\n-  isEnabled: true,\n-};\n-\n-function noop() {}\n-\n-function expectPerfCounters(expectedCounters: Partial<NgDevModePerfCounters>) {\n-  Object.keys(expectedCounters).forEach(key => {\n-    const expected = (expectedCounters as any)[key];\n-    const actual = (ngDevMode as any)[key];\n-    expect(actual).toBe(expected, `ngDevMode.${key}`);\n-  });\n-}\n-\n-const IGNORE: JasmineMethods = {\n-  it: noop,\n-  fit: noop,\n-  describe: noop,\n-  fdescribe: noop,\n-  expectPerfCounters: noop,\n-  isEnabled: false,\n-};"
        },
        {
            "sha": "c1105dc63407cc45c27ad5d85d5ff818915fd5c9",
            "filename": "packages/private/testing/src/render3.ts",
            "status": "modified",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fprivate%2Ftesting%2Fsrc%2Frender3.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fprivate%2Ftesting%2Fsrc%2Frender3.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fprivate%2Ftesting%2Fsrc%2Frender3.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -50,6 +50,28 @@ export function withBody<T extends Function>(html: string, blockFn: T): T {\n   } as any;\n }\n \n+/**\n+ * Runs jasmine expectations against the provided keys for `ngDevMode`.\n+ *\n+ * Will not perform expectations for keys that are not provided.\n+ *\n+ * ```ts\n+ * // Expect that `ngDevMode.styleMap` is `1`, and `ngDevMode.tNode` is `3`, but we don't care\n+ * // about the other values.\n+ * expectPerfCounters({\n+ *   stylingMap: 1,\n+ *   tNode: 3,\n+ * })\n+ * ```\n+ */\n+export function expectPerfCounters(expectedCounters: Partial<NgDevModePerfCounters>): void {\n+  Object.keys(expectedCounters).forEach(key => {\n+    const expected = (expectedCounters as any)[key];\n+    const actual = (ngDevMode as any)[key];\n+    expect(actual).toBe(expected, `ngDevMode.${key}`);\n+  });\n+}\n+\n let savedDocument: Document|undefined = undefined;\n let savedRequestAnimationFrame: ((callback: FrameRequestCallback) => number)|undefined = undefined;\n let savedNode: typeof Node|undefined = undefined;"
        },
        {
            "sha": "8b314dfd7d5e3e6b87de2d0d47c97e229837db65",
            "filename": "packages/upgrade/static/test/integration/downgrade_module_spec.ts",
            "status": "modified",
            "additions": 48,
            "deletions": 50,
            "changes": 98,
            "blob_url": "https://github.com/angular/angular/blob/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fupgrade%2Fstatic%2Ftest%2Fintegration%2Fdowngrade_module_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b31973c176f67fda563e77c8c5d59ae45881de4c/packages%2Fupgrade%2Fstatic%2Ftest%2Fintegration%2Fdowngrade_module_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fupgrade%2Fstatic%2Ftest%2Fintegration%2Fdowngrade_module_spec.ts?ref=b31973c176f67fda563e77c8c5d59ae45881de4c",
            "patch": "@@ -11,7 +11,6 @@ import {fakeAsync, tick, waitForAsync} from '@angular/core/testing';\n import {BrowserModule} from '@angular/platform-browser';\n import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';\n import {browserDetection} from '@angular/platform-browser/testing/src/browser_util';\n-import {onlyInIvy} from '@angular/private/testing';\n import {downgradeComponent, downgradeModule, UpgradeComponent} from '@angular/upgrade/static';\n \n import * as angular from '../../../src/common/src/angular1';\n@@ -81,55 +80,54 @@ withEachNg1Version(() => {\n            setTimeout(() => expect(element.textContent).toBe('a | b'));\n          }));\n \n-      onlyInIvy('Factory-less API of the `downgradeModule` is supported only in Ivy')\n-          .it('should support downgrading modules by providing NgModule class to `downgradeModule` call',\n-              waitForAsync(() => {\n-                @Component({selector: 'ng2A', template: 'a'})\n-                class Ng2ComponentA {\n-                }\n-\n-                @Component({selector: 'ng2B', template: 'b'})\n-                class Ng2ComponentB {\n-                }\n-\n-                @NgModule({\n-                  declarations: [Ng2ComponentA],\n-                  entryComponents: [Ng2ComponentA],\n-                  imports: [BrowserModule],\n-                })\n-                class Ng2ModuleA {\n-                  ngDoBootstrap() {}\n-                }\n-\n-                @NgModule({\n-                  declarations: [Ng2ComponentB],\n-                  entryComponents: [Ng2ComponentB],\n-                  imports: [BrowserModule],\n-                })\n-                class Ng2ModuleB {\n-                  ngDoBootstrap() {}\n-                }\n-\n-                const downModA = downgradeModule(Ng2ModuleA);\n-                const downModB = downgradeModule(Ng2ModuleB);\n-                const ng1Module = angular.module_('ng1', [downModA, downModB])\n-                                      .directive('ng2A', downgradeComponent({\n-                                                   component: Ng2ComponentA,\n-                                                   downgradedModule: downModA,\n-                                                   propagateDigest,\n-                                                 }))\n-                                      .directive('ng2B', downgradeComponent({\n-                                                   component: Ng2ComponentB,\n-                                                   downgradedModule: downModB,\n-                                                   propagateDigest,\n-                                                 }));\n-\n-                const element = html('<ng2-a></ng2-a> | <ng2-b></ng2-b>');\n-                angular.bootstrap(element, [ng1Module.name]);\n-\n-                // Wait for the module to be bootstrapped.\n-                setTimeout(() => expect(element.textContent).toBe('a | b'));\n-              }));\n+      it('should support downgrading modules by providing NgModule class to `downgradeModule` call',\n+         waitForAsync(() => {\n+           @Component({selector: 'ng2A', template: 'a'})\n+           class Ng2ComponentA {\n+           }\n+\n+           @Component({selector: 'ng2B', template: 'b'})\n+           class Ng2ComponentB {\n+           }\n+\n+           @NgModule({\n+             declarations: [Ng2ComponentA],\n+             entryComponents: [Ng2ComponentA],\n+             imports: [BrowserModule],\n+           })\n+           class Ng2ModuleA {\n+             ngDoBootstrap() {}\n+           }\n+\n+           @NgModule({\n+             declarations: [Ng2ComponentB],\n+             entryComponents: [Ng2ComponentB],\n+             imports: [BrowserModule],\n+           })\n+           class Ng2ModuleB {\n+             ngDoBootstrap() {}\n+           }\n+\n+           const downModA = downgradeModule(Ng2ModuleA);\n+           const downModB = downgradeModule(Ng2ModuleB);\n+           const ng1Module = angular.module_('ng1', [downModA, downModB])\n+                                 .directive('ng2A', downgradeComponent({\n+                                              component: Ng2ComponentA,\n+                                              downgradedModule: downModA,\n+                                              propagateDigest,\n+                                            }))\n+                                 .directive('ng2B', downgradeComponent({\n+                                              component: Ng2ComponentB,\n+                                              downgradedModule: downModB,\n+                                              propagateDigest,\n+                                            }));\n+\n+           const element = html('<ng2-a></ng2-a> | <ng2-b></ng2-b>');\n+           angular.bootstrap(element, [ng1Module.name]);\n+\n+           // Wait for the module to be bootstrapped.\n+           setTimeout(() => expect(element.textContent).toBe('a | b'));\n+         }));\n \n       it('should support nesting components from different downgraded modules', waitForAsync(() => {\n            @Directive({selector: 'ng1A'})"
        }
    ],
    "stats": {
        "total": 17021,
        "additions": 7313,
        "deletions": 9708
    }
}