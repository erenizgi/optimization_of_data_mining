{
    "author": "atscott",
    "message": "feat(language-service): Add getTypeDefinitionAtPosition (go to type definition) (#39145)\n\nThis commit adds the implementation for providing \"go to type definition\"\nfunctionality in the Ivy Language Service.\n\nPR Close #39145",
    "sha": "a84976fdfcde45adeba406be48ed979c2010ee57",
    "files": [
        {
            "sha": "a5a4d4ea93a6ae834bba453249ac854032c65e8e",
            "filename": "packages/language-service/ivy/definitions.ts",
            "status": "modified",
            "additions": 87,
            "deletions": 28,
            "changes": 115,
            "blob_url": "https://github.com/angular/angular/blob/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts",
            "raw_url": "https://github.com/angular/angular/raw/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts?ref=a84976fdfcde45adeba406be48ed979c2010ee57",
            "patch": "@@ -6,43 +6,43 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, TmplAstNode} from '@angular/compiler';\n+import {AST, TmplAstNode, TmplAstTextAttribute} from '@angular/compiler';\n import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n import {ShimLocation, Symbol, SymbolKind} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import * as ts from 'typescript';\n \n import {findNodeAtPosition} from './hybrid_visitor';\n-import {getTemplateInfoAtPosition, getTextSpanOfNode, isDollarEvent, toTextSpan} from './utils';\n+import {flatMap, getDirectiveMatchesForAttribute, getDirectiveMatchesForElementTag, getTemplateInfoAtPosition, getTextSpanOfNode, isDollarEvent, TemplateInfo, toTextSpan} from './utils';\n+\n+interface DefinitionMeta {\n+  node: AST|TmplAstNode;\n+  symbol: Symbol;\n+}\n+\n+interface HasShimLocation {\n+  shimLocation: ShimLocation;\n+}\n \n export class DefinitionBuilder {\n   constructor(private readonly tsLS: ts.LanguageService, private readonly compiler: NgCompiler) {}\n \n-  // TODO(atscott): getTypeDefinitionAtPosition\n-\n   getDefinitionAndBoundSpan(fileName: string, position: number): ts.DefinitionInfoAndBoundSpan\n       |undefined {\n     const templateInfo = getTemplateInfoAtPosition(fileName, position, this.compiler);\n     if (templateInfo === undefined) {\n-      return undefined;\n+      return;\n     }\n-    const {template, component} = templateInfo;\n-\n-    const node = findNodeAtPosition(template, position);\n+    const definitionMeta = this.getDefinitionMetaAtPosition(templateInfo, position);\n     // The `$event` of event handlers would point to the $event parameter in the shim file, as in\n     // `_outputHelper(_t3[\"x\"]).subscribe(function ($event): any { $event }) ;`\n     // If we wanted to return something for this, it would be more appropriate for something like\n     // `getTypeDefinition`.\n-    if (node === undefined || isDollarEvent(node)) {\n-      return undefined;\n-    }\n-\n-    const symbol = this.compiler.getTemplateTypeChecker().getSymbolOfNode(node, component);\n-    if (symbol === null) {\n+    if (definitionMeta === undefined || isDollarEvent(definitionMeta.node)) {\n       return undefined;\n     }\n \n-    const definitions = this.getDefinitionsForSymbol(symbol, node);\n-    return {definitions, textSpan: getTextSpanOfNode(node)};\n+    const definitions = this.getDefinitionsForSymbol(definitionMeta.symbol, definitionMeta.node);\n+    return {definitions, textSpan: getTextSpanOfNode(definitionMeta.node)};\n   }\n \n   private getDefinitionsForSymbol(symbol: Symbol, node: TmplAstNode|AST):\n@@ -65,7 +65,7 @@ export class DefinitionBuilder {\n         return [];\n       case SymbolKind.Input:\n       case SymbolKind.Output:\n-        return this.getDefinitionsForSymbols(symbol.bindings);\n+        return this.getDefinitionsForSymbols(...symbol.bindings);\n       case SymbolKind.Variable:\n       case SymbolKind.Reference: {\n         const definitions: ts.DefinitionInfo[] = [];\n@@ -81,27 +81,86 @@ export class DefinitionBuilder {\n           });\n         }\n         if (symbol.kind === SymbolKind.Variable) {\n-          definitions.push(...this.getDefinitionInfos(symbol.shimLocation));\n+          definitions.push(...this.getDefinitionsForSymbols(symbol));\n         }\n         return definitions;\n       }\n       case SymbolKind.Expression: {\n-        const {shimLocation} = symbol;\n-        return this.getDefinitionInfos(shimLocation);\n+        return this.getDefinitionsForSymbols(symbol);\n       }\n     }\n   }\n \n-  private getDefinitionsForSymbols(symbols: {shimLocation: ShimLocation}[]) {\n-    const definitions: ts.DefinitionInfo[] = [];\n-    for (const {shimLocation} of symbols) {\n-      definitions.push(...this.getDefinitionInfos(shimLocation));\n+  private getDefinitionsForSymbols(...symbols: HasShimLocation[]): ts.DefinitionInfo[] {\n+    return flatMap(symbols, ({shimLocation}) => {\n+      const {shimPath, positionInShimFile} = shimLocation;\n+      return this.tsLS.getDefinitionAtPosition(shimPath, positionInShimFile) ?? [];\n+    });\n+  }\n+\n+  getTypeDefinitionsAtPosition(fileName: string, position: number):\n+      readonly ts.DefinitionInfo[]|undefined {\n+    const templateInfo = getTemplateInfoAtPosition(fileName, position, this.compiler);\n+    if (templateInfo === undefined) {\n+      return;\n+    }\n+    const definitionMeta = this.getDefinitionMetaAtPosition(templateInfo, position);\n+    if (definitionMeta === undefined) {\n+      return undefined;\n     }\n-    return definitions;\n+\n+    const {symbol, node} = definitionMeta;\n+    switch (symbol.kind) {\n+      case SymbolKind.Template: {\n+        const matches = getDirectiveMatchesForElementTag(symbol.templateNode, symbol.directives);\n+        return this.getTypeDefinitionsForSymbols(...matches);\n+      }\n+      case SymbolKind.Element: {\n+        const matches = getDirectiveMatchesForAttribute(\n+            symbol.templateNode.name, symbol.templateNode, symbol.directives);\n+        // If one of the directive matches is a component, we should not include the native element\n+        // in the results because it is replaced by the component.\n+        return Array.from(matches).some(dir => dir.isComponent) ?\n+            this.getTypeDefinitionsForSymbols(...matches) :\n+            this.getTypeDefinitionsForSymbols(...matches, symbol);\n+      }\n+      case SymbolKind.DomBinding: {\n+        if (!(node instanceof TmplAstTextAttribute)) {\n+          return [];\n+        }\n+        const dirs = getDirectiveMatchesForAttribute(\n+            node.name, symbol.host.templateNode, symbol.host.directives);\n+        return this.getTypeDefinitionsForSymbols(...dirs);\n+      }\n+      case SymbolKind.Output:\n+      case SymbolKind.Input:\n+        return this.getTypeDefinitionsForSymbols(...symbol.bindings);\n+      case SymbolKind.Reference:\n+      case SymbolKind.Directive:\n+      case SymbolKind.Expression:\n+      case SymbolKind.Variable:\n+        return this.getTypeDefinitionsForSymbols(symbol);\n+    }\n+  }\n+\n+  private getTypeDefinitionsForSymbols(...symbols: HasShimLocation[]): ts.DefinitionInfo[] {\n+    return flatMap(symbols, ({shimLocation}) => {\n+      const {shimPath, positionInShimFile} = shimLocation;\n+      return this.tsLS.getTypeDefinitionAtPosition(shimPath, positionInShimFile) ?? [];\n+    });\n   }\n \n-  private getDefinitionInfos({shimPath, positionInShimFile}: ShimLocation):\n-      readonly ts.DefinitionInfo[] {\n-    return this.tsLS.getDefinitionAtPosition(shimPath, positionInShimFile) ?? [];\n+  private getDefinitionMetaAtPosition({template, component}: TemplateInfo, position: number):\n+      DefinitionMeta|undefined {\n+    const node = findNodeAtPosition(template, position);\n+    if (node === undefined) {\n+      return;\n+    }\n+\n+    const symbol = this.compiler.getTemplateTypeChecker().getSymbolOfNode(node, component);\n+    if (symbol === null) {\n+      return;\n+    }\n+    return {node, symbol};\n   }\n }"
        },
        {
            "sha": "fd550cdeec2b9aba35fe1da44575beacdff0113d",
            "filename": "packages/language-service/ivy/language_service.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "raw_url": "https://github.com/angular/angular/raw/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts?ref=a84976fdfcde45adeba406be48ed979c2010ee57",
            "patch": "@@ -60,6 +60,14 @@ export class LanguageService {\n     return new DefinitionBuilder(this.tsLS, compiler).getDefinitionAndBoundSpan(fileName, position);\n   }\n \n+  getTypeDefinitionAtPosition(fileName: string, position: number):\n+      readonly ts.DefinitionInfo[]|undefined {\n+    const program = this.strategy.getProgram();\n+    const compiler = this.createCompiler(program, fileName);\n+    return new DefinitionBuilder(this.tsLS, compiler)\n+        .getTypeDefinitionsAtPosition(fileName, position);\n+  }\n+\n   getQuickInfoAtPosition(fileName: string, position: number): ts.QuickInfo|undefined {\n     const program = this.strategy.getProgram();\n     const compiler = this.createCompiler(program, fileName);"
        },
        {
            "sha": "bafb2c814c66921b32f3a3e629983653b0e4eea5",
            "filename": "packages/language-service/ivy/quick_info.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Fquick_info.ts",
            "raw_url": "https://github.com/angular/angular/raw/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Fquick_info.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fquick_info.ts?ref=a84976fdfcde45adeba406be48ed979c2010ee57",
            "patch": "@@ -13,7 +13,7 @@ import * as ts from 'typescript';\n import {createQuickInfo, SYMBOL_PUNC, SYMBOL_SPACE, SYMBOL_TEXT} from '../common/quick_info';\n \n import {findNodeAtPosition} from './hybrid_visitor';\n-import {filterAliasImports, getDirectiveMatches, getDirectiveMatchesForAttribute, getTemplateInfoAtPosition, getTextSpanOfNode} from './utils';\n+import {filterAliasImports, getDirectiveMatchesForAttribute, getDirectiveMatchesForElementTag, getTemplateInfoAtPosition, getTextSpanOfNode} from './utils';\n \n /**\n  * The type of Angular directive. Used for QuickInfo in template.\n@@ -94,7 +94,7 @@ export class QuickInfoBuilder {\n \n   private getQuickInfoForElementSymbol(symbol: ElementSymbol): ts.QuickInfo {\n     const {templateNode} = symbol;\n-    const matches = getDirectiveMatches(symbol.directives, templateNode.name);\n+    const matches = getDirectiveMatchesForElementTag(templateNode, symbol.directives);\n     if (matches.size > 0) {\n       return this.getQuickInfoForDirectiveSymbol(matches.values().next().value, templateNode);\n     }"
        },
        {
            "sha": "8f4dc42364ee38021bf0c48aa59a1d903bfb10d6",
            "filename": "packages/language-service/ivy/test/definitions_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 12,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Ftest%2Fdefinitions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Ftest%2Fdefinitions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fdefinitions_spec.ts?ref=a84976fdfcde45adeba406be48ed979c2010ee57",
            "patch": "@@ -11,6 +11,7 @@ import * as ts from 'typescript/lib/tsserverlibrary';\n import {LanguageService} from '../language_service';\n \n import {APP_COMPONENT, setup} from './mock_host';\n+import {humanizeDefinitionInfo} from './test_utils';\n \n describe('definitions', () => {\n   const {project, service, tsLS} = setup();\n@@ -404,17 +405,6 @@ describe('definitions', () => {\n     expect(text.substring(textSpan.start, textSpan.start + textSpan.length))\n         .toEqual(expectedSpanText);\n     expect(definitions).toBeTruthy();\n-    return definitions!.map(d => humanizeDefinitionInfo(d));\n-  }\n-\n-  function humanizeDefinitionInfo(def: ts.DefinitionInfo) {\n-    const snapshot = service.getScriptInfo(def.fileName).getSnapshot();\n-    return {\n-      fileName: def.fileName,\n-      textSpan: snapshot.getText(def.textSpan.start, def.textSpan.start + def.textSpan.length),\n-      contextSpan: def.contextSpan ?\n-          snapshot.getText(def.contextSpan.start, def.contextSpan.start + def.contextSpan.length) :\n-          undefined,\n-    };\n+    return definitions!.map(d => humanizeDefinitionInfo(d, service));\n   }\n });"
        },
        {
            "sha": "0d718ac8c7649e97c3e67e3f8da40070ed6960d8",
            "filename": "packages/language-service/ivy/test/mock_host.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Ftest%2Fmock_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Ftest%2Fmock_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fmock_host.ts?ref=a84976fdfcde45adeba406be48ed979c2010ee57",
            "patch": "@@ -110,7 +110,7 @@ interface OverwriteResult {\n   text: string;\n }\n \n-class MockService {\n+export class MockService {\n   private readonly overwritten = new Set<ts.server.NormalizedPath>();\n \n   constructor("
        },
        {
            "sha": "2924df166fbfb03304ad422aa7a87f4d8b06199e",
            "filename": "packages/language-service/ivy/test/quick_info_spec.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 2,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts?ref=a84976fdfcde45adeba406be48ed979c2010ee57",
            "patch": "@@ -28,6 +28,14 @@ describe('quick info', () => {\n         expectedDisplayString: '(element) button: HTMLButtonElement'\n       });\n     });\n+\n+    it('should work for directives which match native element tags', () => {\n+      expectQuickInfo({\n+        templateOverride: `<butt¦on compound custom-button></button>`,\n+        expectedSpanText: '<button compound custom-button></button>',\n+        expectedDisplayString: '(directive) AppModule.CompoundCustomButtonDirective'\n+      });\n+    });\n   });\n \n   describe('templates', () => {\n@@ -357,8 +365,7 @@ describe('quick info', () => {\n       expect(documentation).toBe('This is the title of the `AppComponent` Component.');\n     });\n \n-    // TODO(atscott): Enable once #39065 is merged\n-    xit('works with external template', () => {\n+    it('works with external template', () => {\n       const {position, text} = service.overwrite(TEST_TEMPLATE, '<butt¦on></button>');\n       const quickInfo = ngLS.getQuickInfoAtPosition(TEST_TEMPLATE, position);\n       expect(quickInfo).toBeTruthy();"
        },
        {
            "sha": "e4b62f8c611f0fa27ead63a1702f1fadf63ad918",
            "filename": "packages/language-service/ivy/test/test_utils.ts",
            "status": "added",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Ftest%2Ftest_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Ftest%2Ftest_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Ftest_utils.ts?ref=a84976fdfcde45adeba406be48ed979c2010ee57",
            "patch": "@@ -0,0 +1,27 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {MockService} from './mock_host';\n+\n+export interface HumanizedDefinitionInfo {\n+  fileName: string;\n+  textSpan: string;\n+  contextSpan: string|undefined;\n+}\n+\n+export function humanizeDefinitionInfo(\n+    def: ts.DefinitionInfo, service: MockService): HumanizedDefinitionInfo {\n+  const snapshot = service.getScriptInfo(def.fileName).getSnapshot();\n+  return {\n+    fileName: def.fileName,\n+    textSpan: snapshot.getText(def.textSpan.start, def.textSpan.start + def.textSpan.length),\n+    contextSpan: def.contextSpan ?\n+        snapshot.getText(def.contextSpan.start, def.contextSpan.start + def.contextSpan.length) :\n+        undefined,\n+  };\n+}"
        },
        {
            "sha": "fd394b0e0e15e4a99de51daa77470f47cb37a1be",
            "filename": "packages/language-service/ivy/test/type_definitions_spec.ts",
            "status": "added",
            "additions": 314,
            "deletions": 0,
            "changes": 314,
            "blob_url": "https://github.com/angular/angular/blob/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Ftest%2Ftype_definitions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Ftest%2Ftype_definitions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Ftype_definitions_spec.ts?ref=a84976fdfcde45adeba406be48ed979c2010ee57",
            "patch": "@@ -0,0 +1,314 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {LanguageService} from '../language_service';\n+\n+import {APP_COMPONENT, setup} from './mock_host';\n+import {HumanizedDefinitionInfo, humanizeDefinitionInfo} from './test_utils';\n+\n+describe('type definitions', () => {\n+  const {project, service, tsLS} = setup();\n+  const ngLS = new LanguageService(project, tsLS);\n+\n+  beforeEach(() => {\n+    service.reset();\n+  });\n+\n+  describe('elements', () => {\n+    it('should work for native elements', () => {\n+      const defs = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<butt¦on></button>`,\n+      });\n+      expect(defs.length).toEqual(2);\n+      expect(defs[0].fileName).toContain('lib.dom.d.ts');\n+      expect(defs[0].contextSpan).toContain('interface HTMLButtonElement extends HTMLElement');\n+      expect(defs[1].contextSpan).toContain('declare var HTMLButtonElement');\n+    });\n+\n+    it('should return directives which match the element tag', () => {\n+      const defs = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<butt¦on compound custom-button></button>`,\n+      });\n+      expect(defs.length).toEqual(3);\n+      expect(defs[0].contextSpan).toContain('export class CompoundCustomButtonDirective');\n+      expect(defs[1].contextSpan).toContain('interface HTMLButtonElement extends HTMLElement');\n+      expect(defs[2].contextSpan).toContain('declare var HTMLButtonElement');\n+    });\n+  });\n+\n+  describe('templates', () => {\n+    it('should return no definitions for ng-templates', () => {\n+      const {position} =\n+          service.overwriteInlineTemplate(APP_COMPONENT, `<ng-templ¦ate></ng-template>`);\n+      const defs = ngLS.getTypeDefinitionAtPosition(APP_COMPONENT, position);\n+      expect(defs).toEqual([]);\n+    });\n+  });\n+\n+  describe('directives', () => {\n+    it('should work for directives', () => {\n+      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div string-model¦></div>`,\n+      });\n+      expect(definitions.length).toEqual(1);\n+      expect(definitions[0].fileName).toContain('parsing-cases.ts');\n+      expect(definitions[0].textSpan).toEqual('StringModel');\n+      expect(definitions[0].contextSpan).toContain('@Directive');\n+    });\n+\n+    it('should work for components', () => {\n+      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<t¦est-comp></test-comp>`,\n+      });\n+      expect(definitions.length).toEqual(1);\n+      expect(definitions[0].textSpan).toEqual('TestComponent');\n+      expect(definitions[0].contextSpan).toContain('@Component');\n+    });\n+\n+    it('should work for structural directives', () => {\n+      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div *¦ngFor=\"let item of heroes\"></div>`,\n+      });\n+      expect(definitions.length).toEqual(1);\n+      expect(definitions[0].fileName).toContain('ng_for_of.d.ts');\n+      expect(definitions[0].textSpan).toEqual('NgForOf');\n+      expect(definitions[0].contextSpan)\n+          .toContain(\n+              'export declare class NgForOf<T, U extends NgIterable<T> = NgIterable<T>> implements DoCheck');\n+    });\n+\n+    it('should work for directives with compound selectors', () => {\n+      let defs = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<button com¦pound custom-button></button>`,\n+      });\n+      expect(defs.length).toEqual(1);\n+      expect(defs[0].contextSpan).toContain('export class CompoundCustomButtonDirective');\n+      defs = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<button compound cu¦stom-button></button>`,\n+      });\n+      expect(defs.length).toEqual(1);\n+      expect(defs[0].contextSpan).toContain('export class CompoundCustomButtonDirective');\n+    });\n+  });\n+\n+  describe('bindings', () => {\n+    describe('inputs', () => {\n+      it('should return something for input providers with non-primitive types', () => {\n+        const defs = getTypeDefinitionsAndAssertBoundSpan({\n+          templateOverride: `<button compound custom-button [config¦]=\"{}\"></button>`,\n+        });\n+        expect(defs.length).toEqual(1);\n+        expect(defs[0].textSpan).toEqual('{color?: string}');\n+      });\n+\n+      it('should work for structural directive inputs ngForTrackBy', () => {\n+        const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+          templateOverride: `<div *ngFor=\"let item of heroes; tr¦ackBy: test;\"></div>`,\n+        });\n+        expect(definitions!.length).toEqual(1);\n+\n+        const [def] = definitions;\n+        expect(def.textSpan).toEqual('TrackByFunction');\n+        expect(def.contextSpan).toContain('export interface TrackByFunction<T>');\n+      });\n+\n+      it('should work for structural directive inputs ngForOf', () => {\n+        const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+          templateOverride: `<div *ngFor=\"let item o¦f heroes\"></div>`,\n+        });\n+        expectAllArrayDefinitions(definitions);\n+      });\n+\n+      it('should return nothing for two-way binding providers', () => {\n+        const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+          templateOverride: `<test-comp string-model [(mo¦del)]=\"title\"></test-comp>`,\n+        });\n+        // TODO(atscott): This should actually return EventEmitter type but we only match the input\n+        // at the moment.\n+        expect(definitions).toEqual([]);\n+      });\n+    });\n+\n+    describe('outputs', () => {\n+      it('should work for event providers', () => {\n+        const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+          templateOverride: `<test-comp (te¦st)=\"myClick($event)\"></test-comp>`,\n+        });\n+        expect(definitions!.length).toEqual(2);\n+\n+        const [def, xyz] = definitions;\n+        expect(def.textSpan).toEqual('EventEmitter');\n+        expect(def.contextSpan).toContain('export interface EventEmitter<T> extends Subject<T>');\n+        expect(xyz.textSpan).toEqual('EventEmitter');\n+      });\n+    });\n+  });\n+\n+  describe('references', () => {\n+    it('should work for element references', () => {\n+      const defs = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div #chart></div>{{char¦t}}`,\n+      });\n+      expect(defs.length).toEqual(2);\n+      expect(defs[0].contextSpan).toContain('interface HTMLDivElement extends HTMLElement');\n+      expect(defs[1].contextSpan).toContain('declare var HTMLDivElement');\n+    });\n+\n+    it('should work for directive references', () => {\n+      const defs = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div #mod¦el=\"stringModel\" string-model></div>`,\n+      });\n+      expect(defs.length).toEqual(1);\n+      expect(defs[0].contextSpan).toContain('@Directive');\n+      expect(defs[0].contextSpan).toContain('export class StringModel');\n+    });\n+  });\n+\n+  describe('variables', () => {\n+    it('should work for array members', () => {\n+      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div *ngFor=\"let hero of heroes\">{{her¦o}}</div>`,\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      expect(definitions[0].textSpan).toEqual('Hero');\n+      expect(definitions[0].contextSpan).toContain('export interface Hero');\n+    });\n+  });\n+\n+  describe('pipes', () => {\n+    it('should work for pipes', () => {\n+      const templateOverride = `<p>The hero's birthday is {{birthday | da¦te: \"MM/dd/yy\"}}</p>`;\n+      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride,\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      const [def] = definitions;\n+      expect(def.textSpan).toEqual('transform');\n+      expect(def.contextSpan).toContain('transform(value: Date');\n+    });\n+  });\n+\n+  describe('expressions', () => {\n+    it('should return nothing for primitives', () => {\n+      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div>{{ tit¦le }}</div>`,\n+      });\n+      expect(definitions!.length).toEqual(0);\n+    });\n+\n+    // TODO(atscott): Investigate why this returns nothing in the test environment. This actually\n+    // works in the extension.\n+    xit('should work for functions on primitives', () => {\n+      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div>{{ title.toLower¦case() }}</div>`,\n+      });\n+      expect(definitions!.length).toEqual(1);\n+      expect(definitions[0].textSpan).toEqual('toLowerCase');\n+      expect(definitions[0].fileName).toContain('lib.es5.d.ts');\n+    });\n+\n+    it('should work for accessed property reads', () => {\n+      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div>{{heroes[0].addre¦ss}}</div>`,\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      const [def] = definitions;\n+      expect(def.textSpan).toEqual('Address');\n+      expect(def.contextSpan).toContain('export interface Address');\n+    });\n+\n+    it('should work for $event', () => {\n+      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<button (click)=\"title=$ev¦ent\"></button>`,\n+      });\n+      expect(definitions!.length).toEqual(2);\n+\n+      const [def1, def2] = definitions;\n+      expect(def1.textSpan).toEqual('MouseEvent');\n+      expect(def1.contextSpan).toContain(`interface MouseEvent extends UIEvent`);\n+      expect(def2.textSpan).toEqual('MouseEvent');\n+      expect(def2.contextSpan).toContain(`declare var MouseEvent:`);\n+    });\n+\n+    it('should work for method calls', () => {\n+      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div (click)=\"setT¦itle('title')\"></div>`,\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      const [def] = definitions;\n+      expect(def.textSpan).toEqual('setTitle');\n+      expect(def.contextSpan).toContain('setTitle(newTitle: string)');\n+    });\n+\n+    it('should work for accessed properties in writes', () => {\n+      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div (click)=\"hero.add¦ress = undefined\"></div>`,\n+      });\n+      expect(definitions!.length).toEqual(1);\n+\n+      const [def] = definitions;\n+      expect(def.textSpan).toEqual('Address');\n+      expect(def.contextSpan).toContain('export interface Address');\n+    });\n+\n+    it('should work for variables in structural directives', () => {\n+      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div *ngFor=\"let item of heroes as her¦oes2; trackBy: test;\"></div>`,\n+      });\n+      expectAllArrayDefinitions(definitions);\n+    });\n+\n+    it('should work for uses of members in structural directives', () => {\n+      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div *ngFor=\"let item of heroes as heroes2\">{{her¦oes2}}</div>`,\n+      });\n+      expectAllArrayDefinitions(definitions);\n+    });\n+\n+    it('should work for members in structural directives', () => {\n+      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div *ngFor=\"let item of her¦oes; trackBy: test;\"></div>`,\n+      });\n+      expectAllArrayDefinitions(definitions);\n+    });\n+\n+    it('should return nothing for the $any() cast function', () => {\n+      const {position} =\n+          service.overwriteInlineTemplate(APP_COMPONENT, `<div>{{$an¦y(title)}}</div>`);\n+      const definitionAndBoundSpan = ngLS.getTypeDefinitionAtPosition(APP_COMPONENT, position);\n+      expect(definitionAndBoundSpan).toBeUndefined();\n+    });\n+  });\n+\n+  function getTypeDefinitionsAndAssertBoundSpan({templateOverride}: {templateOverride: string}):\n+      HumanizedDefinitionInfo[] {\n+    const {position} = service.overwriteInlineTemplate(APP_COMPONENT, templateOverride);\n+    const defs = ngLS.getTypeDefinitionAtPosition(APP_COMPONENT, position);\n+    expect(defs).toBeTruthy();\n+    return defs!.map(d => humanizeDefinitionInfo(d, service));\n+  }\n+\n+  function expectAllArrayDefinitions(definitions: HumanizedDefinitionInfo[]) {\n+    expect(definitions!.length).toBeGreaterThan(0);\n+    const actualTextSpans = new Set(definitions.map(d => d.textSpan));\n+    expect(actualTextSpans).toEqual(new Set(['Array']));\n+    const possibleFileNames = [\n+      'lib.es5.d.ts', 'lib.es2015.core.d.ts', 'lib.es2015.iterable.d.ts',\n+      'lib.es2015.symbol.wellknown.d.ts', 'lib.es2016.array.include.d.ts'\n+    ];\n+    for (const def of definitions) {\n+      const fileName = def.fileName.split('/').slice(-1)[0];\n+      expect(possibleFileNames)\n+          .toContain(fileName, `Expected ${fileName} to be one of: ${possibleFileNames}`);\n+    }\n+  }\n+});"
        },
        {
            "sha": "f76ad6c9f8d50a44f9601b786c6acbee7c765a5e",
            "filename": "packages/language-service/ivy/ts_plugin.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 4,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Fts_plugin.ts",
            "raw_url": "https://github.com/angular/angular/raw/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Fts_plugin.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fts_plugin.ts?ref=a84976fdfcde45adeba406be48ed979c2010ee57",
            "patch": "@@ -24,10 +24,6 @@ export function create(info: ts.server.PluginCreateInfo): ts.LanguageService {\n     return diagnostics;\n   }\n \n-  function getTypeDefinitionAtPosition(fileName: string, position: number) {\n-    return undefined;\n-  }\n-\n   function getQuickInfoAtPosition(fileName: string, position: number): ts.QuickInfo|undefined {\n     if (angularOnly) {\n       return ngLS.getQuickInfoAtPosition(fileName, position);\n@@ -38,6 +34,17 @@ export function create(info: ts.server.PluginCreateInfo): ts.LanguageService {\n     }\n   }\n \n+  function getTypeDefinitionAtPosition(\n+      fileName: string, position: number): readonly ts.DefinitionInfo[]|undefined {\n+    if (angularOnly) {\n+      return ngLS.getTypeDefinitionAtPosition(fileName, position);\n+    } else {\n+      // If TS could answer the query, then return that result. Otherwise, return from Angular LS.\n+      return tsLS.getTypeDefinitionAtPosition(fileName, position) ??\n+          ngLS.getTypeDefinitionAtPosition(fileName, position);\n+    }\n+  }\n+\n   function getDefinitionAndBoundSpan(\n       fileName: string, position: number): ts.DefinitionInfoAndBoundSpan|undefined {\n     if (angularOnly) {"
        },
        {
            "sha": "110e655a28bdc05ef8b829e104824072679351fa",
            "filename": "packages/language-service/ivy/utils.ts",
            "status": "modified",
            "additions": 104,
            "deletions": 51,
            "changes": 155,
            "blob_url": "https://github.com/angular/angular/blob/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Futils.ts?ref=a84976fdfcde45adeba406be48ed979c2010ee57",
            "patch": "@@ -14,28 +14,6 @@ import * as ts from 'typescript';\n \n import {ALIAS_NAME, SYMBOL_PUNC} from '../common/quick_info';\n \n-/**\n- * Given a list of directives and a text to use as a selector, returns the directives which match\n- * for the selector.\n- */\n-export function getDirectiveMatches(\n-    directives: DirectiveSymbol[], selector: string): Set<DirectiveSymbol> {\n-  const selectorToMatch = CssSelector.parse(selector);\n-  if (selectorToMatch.length === 0) {\n-    return new Set();\n-  }\n-  return new Set(directives.filter((dir: DirectiveSymbol) => {\n-    if (dir.selector === null) {\n-      return false;\n-    }\n-\n-    const matcher = new SelectorMatcher();\n-    matcher.addSelectables(CssSelector.parse(dir.selector));\n-\n-    return matcher.match(selectorToMatch[0], null);\n-  }));\n-}\n-\n export function getTextSpanOfNode(node: t.Node|e.AST): ts.TextSpan {\n   if (isTemplateNodeWithKeyAndValue(node)) {\n     return toTextSpan(node.keySpan);\n@@ -162,43 +140,106 @@ function getInlineTemplateInfoAtPosition(\n }\n \n /**\n- * Given an attribute name and the element or template the attribute appears on, determines which\n- * directives match because the attribute is present. That is, we find which directives are applied\n- * because of this attribute by elimination: compare the directive matches with the attribute\n- * present against the directive matches without it. The difference would be the directives which\n- * match because the attribute is present.\n+ * Given an attribute node, converts it to string form.\n+ */\n+function toAttributeString(attribute: t.TextAttribute|t.BoundAttribute): string {\n+  return `[${attribute.name}=${attribute.valueSpan?.toString() ?? ''}]`;\n+}\n+\n+function getNodeName(node: t.Template|t.Element): string {\n+  return node instanceof t.Template ? node.tagName : node.name;\n+}\n+\n+/**\n+ * Given a template or element node, returns all attributes on the node.\n+ */\n+function getAttributes(node: t.Template|t.Element): Array<t.TextAttribute|t.BoundAttribute> {\n+  const attributes: Array<t.TextAttribute|t.BoundAttribute> = [...node.attributes, ...node.inputs];\n+  if (node instanceof t.Template) {\n+    attributes.push(...node.templateAttrs);\n+  }\n+  return attributes;\n+}\n+\n+/**\n+ * Given two `Set`s, returns all items in the `left` which do not appear in the `right`.\n+ */\n+function difference<T>(left: Set<T>, right: Set<T>): Set<T> {\n+  const result = new Set<T>();\n+  for (const dir of left) {\n+    if (!right.has(dir)) {\n+      result.add(dir);\n+    }\n+  }\n+  return result;\n+}\n+\n+/**\n+ * Given an element or template, determines which directives match because the tag is present. For\n+ * example, if a directive selector is `div[myAttr]`, this would match div elements but would not if\n+ * the selector were just `[myAttr]`. We find which directives are applied because of this tag by\n+ * elimination: compare the directive matches with the tag present against the directive matches\n+ * without it. The difference would be the directives which match because the tag is present.\n+ *\n+ * @param element The element or template node that the attribute/tag is part of.\n+ * @param directives The list of directives to match against.\n+ * @returns The list of directives matching the tag name via the strategy described above.\n+ */\n+// TODO(atscott): Add unit tests for this and the one for attributes\n+export function getDirectiveMatchesForElementTag(\n+    element: t.Template|t.Element, directives: DirectiveSymbol[]): Set<DirectiveSymbol> {\n+  const attributes = getAttributes(element);\n+  const allAttrs = attributes.map(toAttributeString);\n+  const allDirectiveMatches =\n+      getDirectiveMatchesForSelector(directives, getNodeName(element) + allAttrs.join(''));\n+  const matchesWithoutElement = getDirectiveMatchesForSelector(directives, allAttrs.join(''));\n+  return difference(allDirectiveMatches, matchesWithoutElement);\n+}\n+\n+/**\n+ * Given an attribute name, determines which directives match because the attribute is present. We\n+ * find which directives are applied because of this attribute by elimination: compare the directive\n+ * matches with the attribute present against the directive matches without it. The difference would\n+ * be the directives which match because the attribute is present.\n  *\n- * @param attribute The attribute name to use for directive matching.\n- * @param hostNode The element or template node that the attribute is on.\n+ * @param name The name of the attribute\n+ * @param hostNode The node which the attribute appears on\n  * @param directives The list of directives to match against.\n- * @returns The list of directives matching the attribute via the strategy described above.\n+ * @returns The list of directives matching the tag name via the strategy described above.\n  */\n export function getDirectiveMatchesForAttribute(\n-    attribute: string, hostNode: t.Template|t.Element,\n+    name: string, hostNode: t.Template|t.Element,\n     directives: DirectiveSymbol[]): Set<DirectiveSymbol> {\n-  const attributes: Array<t.TextAttribute|t.BoundAttribute> =\n-      [...hostNode.attributes, ...hostNode.inputs];\n-  if (hostNode instanceof t.Template) {\n-    attributes.push(...hostNode.templateAttrs);\n-  }\n-  function toAttributeString(a: t.TextAttribute|t.BoundAttribute) {\n-    return `[${a.name}=${a.valueSpan?.toString() ?? ''}]`;\n+  const attributes = getAttributes(hostNode);\n+  const allAttrs = attributes.map(toAttributeString);\n+  const allDirectiveMatches =\n+      getDirectiveMatchesForSelector(directives, getNodeName(hostNode) + allAttrs.join(''));\n+  const attrsExcludingName = attributes.filter(a => a.name !== name).map(toAttributeString);\n+  const matchesWithoutAttr =\n+      getDirectiveMatchesForSelector(directives, attrsExcludingName.join(''));\n+  return difference(allDirectiveMatches, matchesWithoutAttr);\n+}\n+\n+/**\n+ * Given a list of directives and a text to use as a selector, returns the directives which match\n+ * for the selector.\n+ */\n+function getDirectiveMatchesForSelector(\n+    directives: DirectiveSymbol[], selector: string): Set<DirectiveSymbol> {\n+  const selectors = CssSelector.parse(selector);\n+  if (selectors.length === 0) {\n+    return new Set();\n   }\n-  const attrs = attributes.map(toAttributeString);\n-  const attrsOmit = attributes.map(a => a.name === attribute ? '' : toAttributeString(a));\n+  return new Set(directives.filter((dir: DirectiveSymbol) => {\n+    if (dir.selector === null) {\n+      return false;\n+    }\n \n-  const hostNodeName = hostNode instanceof t.Template ? hostNode.tagName : hostNode.name;\n-  const directivesWithAttribute = getDirectiveMatches(directives, hostNodeName + attrs.join(''));\n-  const directivesWithoutAttribute =\n-      getDirectiveMatches(directives, hostNodeName + attrsOmit.join(''));\n+    const matcher = new SelectorMatcher();\n+    matcher.addSelectables(CssSelector.parse(dir.selector));\n \n-  const result = new Set<DirectiveSymbol>();\n-  for (const dir of directivesWithAttribute) {\n-    if (!directivesWithoutAttribute.has(dir)) {\n-      result.add(dir);\n-    }\n-  }\n-  return result;\n+    return selectors.some(selector => matcher.match(selector, null));\n+  }));\n }\n \n /**\n@@ -231,3 +272,15 @@ export function isDollarEvent(n: t.Node|e.AST): n is e.PropertyRead {\n   return n instanceof e.PropertyRead && n.name === '$event' &&\n       n.receiver instanceof e.ImplicitReceiver;\n }\n+\n+/**\n+ * Returns a new array formed by applying a given callback function to each element of the array,\n+ * and then flattening the result by one level.\n+ */\n+export function flatMap<T, R>(items: T[]|readonly T[], f: (item: T) => R[] | readonly R[]): R[] {\n+  const results: R[] = [];\n+  for (const x of items) {\n+    results.push(...f(x));\n+  }\n+  return results;\n+}"
        },
        {
            "sha": "1bcbbe95eb4aa57d1e92d9e69f493c142821eb99",
            "filename": "packages/language-service/test/project/app/app.component.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Ftest%2Fproject%2Fapp%2Fapp.component.ts",
            "raw_url": "https://github.com/angular/angular/raw/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Ftest%2Fproject%2Fapp%2Fapp.component.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fproject%2Fapp%2Fapp.component.ts?ref=a84976fdfcde45adeba406be48ed979c2010ee57",
            "patch": "@@ -8,10 +8,15 @@\n \n import {Component} from '@angular/core';\n \n+export interface Address {\n+  streetName: string;\n+}\n+\n /** The most heroic being. */\n export interface Hero {\n   id: number;\n   name: string;\n+  address?: Address;\n }\n \n @Component({"
        },
        {
            "sha": "331a79cd3b8a11a3ae8c7aec2a92c51e37096fdb",
            "filename": "packages/language-service/test/project/app/main.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Ftest%2Fproject%2Fapp%2Fmain.ts",
            "raw_url": "https://github.com/angular/angular/raw/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Ftest%2Fproject%2Fapp%2Fmain.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fproject%2Fapp%2Fmain.ts?ref=a84976fdfcde45adeba406be48ed979c2010ee57",
            "patch": "@@ -24,6 +24,7 @@ import * as ParsingCases from './parsing-cases';\n     ParsingCases.TestComponent,\n     ParsingCases.TestPipe,\n     ParsingCases.WithContextDirective,\n+    ParsingCases.CompoundCustomButtonDirective,\n   ]\n })\n export class AppModule {"
        },
        {
            "sha": "74004c02c6e4a3d5cffe047dac8ffb26b9987934",
            "filename": "packages/language-service/test/project/app/parsing-cases.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Ftest%2Fproject%2Fapp%2Fparsing-cases.ts",
            "raw_url": "https://github.com/angular/angular/raw/a84976fdfcde45adeba406be48ed979c2010ee57/packages%2Flanguage-service%2Ftest%2Fproject%2Fapp%2Fparsing-cases.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fproject%2Fapp%2Fparsing-cases.ts?ref=a84976fdfcde45adeba406be48ed979c2010ee57",
            "patch": "@@ -12,6 +12,7 @@ import {Hero} from './app.component';\n \n @Directive({\n   selector: '[string-model]',\n+  exportAs: 'stringModel',\n })\n export class StringModel {\n   @Input() model: string = 'model';\n@@ -69,6 +70,11 @@ export class WithContextDirective {\n   }\n }\n \n+@Directive({selector: 'button[custom-button][compound]'})\n+export class CompoundCustomButtonDirective {\n+  @Input() config?: {color?: string};\n+}\n+\n @Pipe({\n   name: 'prefixPipe',\n })"
        }
    ],
    "stats": {
        "total": 677,
        "additions": 577,
        "deletions": 100
    }
}