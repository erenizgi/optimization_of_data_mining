{
    "author": "alxhub",
    "message": "test: remove view-engine-only tests (#43884)\n\nThis commit removes most tests that were designated as only covering View\nEngine code. It also removes tag filters from CI and local commands to run\ntests.\n\nIn a few cases (such as with the packages/compiler tests), this tag was\nimproperly applied, and certain test cases have been added back running in\nIvy mode.\n\nThis commit also empties `@angular/compiler/testing` as it is no longer\nnecessary (this is safe since compiler packages are not public API). It can\nbe deleted in the future.\n\nPR Close #43884",
    "sha": "bb9ff6003c620b3cf00232189d60097395382802",
    "files": [
        {
            "sha": "23bbabbf18833f232d378a02acce6faf93ddccf0",
            "filename": ".circleci/config.yml",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/.circleci%2Fconfig.yml",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/.circleci%2Fconfig.yml",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/.circleci%2Fconfig.yml?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -344,7 +344,7 @@ jobs:\n           # See /tools/saucelabs/README.md for more info\n           command: |\n             yarn bazel run //tools/saucelabs:sauce_service_setup\n-            TESTS=$(./node_modules/.bin/bazelisk query --output label '(kind(karma_web_test, ...) intersect attr(\"tags\", \"saucelabs\", ...)) except attr(\"tags\", \"view-engine-only\", ...) except attr(\"tags\", \"fixme-saucelabs\", ...)')\n+            TESTS=$(./node_modules/.bin/bazelisk query --output label '(kind(karma_web_test, ...) intersect attr(\"tags\", \"saucelabs\", ...)) except attr(\"tags\", \"fixme-saucelabs\", ...)')\n             yarn bazel test --config=saucelabs ${TESTS}\n             yarn bazel run //tools/saucelabs:sauce_service_stop\n           no_output_timeout: 40m\n@@ -723,11 +723,11 @@ jobs:\n       - setup_win\n       - run:\n           name: Build all windows CI targets\n-          command: bazel build --build_tag_filters=-view-engine-only //packages/compiler-cli/...\n+          command: bazel build //packages/compiler-cli/...\n           no_output_timeout: 15m\n       - run:\n           name: Test all windows CI targets\n-          command: bazel test --test_tag_filters=\"-view-engine-only,-browser:chromium-local\" //packages/compiler-cli/...\n+          command: bazel test --test_tag_filters=\"-browser:chromium-local\" //packages/compiler-cli/...\n           no_output_timeout: 15m\n \n workflows:"
        },
        {
            "sha": "001c8c49eeb9b3784f41e69eac4eaee70342354a",
            "filename": "modules/benchmarks/src/tree/ng2_next/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 48,
            "changes": 48,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/modules%2Fbenchmarks%2Fsrc%2Ftree%2Fng2_next%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/modules%2Fbenchmarks%2Fsrc%2Ftree%2Fng2_next%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/modules%2Fbenchmarks%2Fsrc%2Ftree%2Fng2_next%2FBUILD.bazel?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,48 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_devserver\", \"ts_library\")\n-load(\"@npm//@angular/dev-infra-private/bazel/benchmark/component_benchmark:benchmark_test.bzl\", \"benchmark_test\")\n-load(\"//modules/benchmarks:e2e_test.bzl\", \"e2e_test\")\n-\n-package(default_visibility = [\"//modules/benchmarks:__subpackages__\"])\n-\n-ts_library(\n-    name = \"ng2_next\",\n-    srcs = glob([\"*.ts\"]),\n-    tsconfig = \"//modules/benchmarks:tsconfig-build.json\",\n-    deps = [\n-        \"//modules/benchmarks/src:util_lib\",\n-        \"//modules/benchmarks/src/tree:util_lib\",\n-        \"//packages/common\",\n-        \"//packages/core\",\n-        \"//packages/platform-browser\",\n-    ],\n-)\n-\n-ts_devserver(\n-    name = \"devserver\",\n-    entry_module = \"angular/modules/benchmarks/src/tree/ng2_next/index\",\n-    port = 4200,\n-    scripts = [\n-        \"@npm//:node_modules/tslib/tslib.js\",\n-        \"//tools/rxjs:rxjs_umd_modules\",\n-    ],\n-    static_files = [\"index.html\"],\n-    deps = [\":ng2_next\"],\n-)\n-\n-benchmark_test(\n-    name = \"perf\",\n-    server = \":devserver\",\n-    deps = [\n-        \"//modules/benchmarks/src/tree:detect_changes_perf_tests_lib\",\n-        \"//modules/benchmarks/src/tree:perf_tests_lib\",\n-    ],\n-)\n-\n-e2e_test(\n-    name = \"e2e\",\n-    server = \":devserver\",\n-    deps = [\n-        \"//modules/benchmarks/src/tree:detect_changes_e2e_tests_lib\",\n-        \"//modules/benchmarks/src/tree:e2e_tests_lib\",\n-    ],\n-)"
        },
        {
            "sha": "06f8c442a74a637a87c8259fcb51ed33aaf8429f",
            "filename": "modules/benchmarks/src/tree/ng2_next/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 46,
            "changes": 46,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/modules%2Fbenchmarks%2Fsrc%2Ftree%2Fng2_next%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/modules%2Fbenchmarks%2Fsrc%2Ftree%2Fng2_next%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/modules%2Fbenchmarks%2Fsrc%2Ftree%2Fng2_next%2FREADME.md?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,46 +0,0 @@\n-# Ng2 Next Benchmark\n-\n-This benchmark uses the upcoming view engine for Angular, which moves\n-more functionality from codegen into runtime to reduce generated code size.\n-\n-As we introduce more runtime code, we need to be very careful to not\n-regress in performance, compared to the pure codegen solution.\n-\n-## Initial results: size of Deep Tree Benchmark\n-\n-File size for Tree benchmark template,\n-view class of the component + the 2 embedded view classes (without imports nor host view factory):\n-\n-                               | bytes | ratio | bytes (gzip) | ratio (gzip)\n------------------------------- | ----- | ----- | ------------ | ------------\n-Source template + annotation   | 245   | 1x    | 159          | 1x\n-Gen code (Closure minified)    | 2693  | 11.9x | 746          | 4.7x\n-New View Engine (minified)     | 868   | 3.5x  | 436          | 2.7x\n-\n-## Initial results: performance of Deep Tree Benchmark\n-\n-Measured locally on a MacBook Pro.\n-\n-BENCHMARK deepTree....\n-Description:\n-- bundles: false\n-- depth: 11\n-- forceGc: false\n-- regressionSlopeMetric: scriptTime\n-- sampleSize: 20\n-- userAgent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36\n-\n-...createOnly   |           gcAmount |             gcTime |        majorGcTime |     pureScriptTime |         renderTime |         scriptTime\n---------------- | ------------------ | ------------------ | ------------------ | ------------------ | ------------------ | ------------------\n-ng2             |      11461.24+-21% |         12.35+-42% |         1.15+-429% |          72.49+-4% |          49.61+-4% |          82.69+-6%\n-ng2 next        |       6207.77+-93% |          9.84+-84% |         3.35+-238% |          73.95+-4% |          49.86+-4% |         77.53+-10%\n-\n-...update       |           gcAmount |             gcTime |        majorGcTime |     pureScriptTime |         renderTime |         scriptTime\n---------------- | ------------------ | ------------------ | ------------------ | ------------------ | ------------------ | ------------------\n-ng2             |               0.00 |         0.00+-435% |         0.00+-435% |          13.34+-8% |          28.55+-8% |          13.34+-8%\n-ng2 next        |       175.02+-435% |         0.74+-435% |         0.00+-302% |         20.55+-12% |          28.00+-6% |         20.55+-12%\n-\n-...pure cd (10x) |           gcAmount |             gcTime |        majorGcTime |     pureScriptTime |         renderTime |         scriptTime\n---------------- | ------------------ | ------------------ | ------------------ | ------------------ | ------------------ | ------------------\n-ng2             |      2155.57+-238% |         0.24+-238% |         0.00+-238% |          19.32+-9% |           2.54+-6% |          19.32+-9%\n-ng2 next        |       908.12+-366% |         1.62+-325% |         0.49+-435% |          30.66+-6% |          2.62+-19% |          30.66+-6%"
        },
        {
            "sha": "89a4f7d0c6e8233aeb261b37c61b09c7d6b0e008",
            "filename": "modules/benchmarks/src/tree/ng2_next/index.html",
            "status": "removed",
            "additions": 0,
            "deletions": 37,
            "changes": 37,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/modules%2Fbenchmarks%2Fsrc%2Ftree%2Fng2_next%2Findex.html",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/modules%2Fbenchmarks%2Fsrc%2Ftree%2Fng2_next%2Findex.html",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/modules%2Fbenchmarks%2Fsrc%2Ftree%2Fng2_next%2Findex.html?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,37 +0,0 @@\n-<!doctype html>\n-<html>\n-<head>\n-  <!-- Prevent the browser from requesting any favicon. -->\n-  <link rel=\"icon\" href=\"data:,\">\n-</head>\n-<body>\n-\n-  <h2>Params</h2>\n-  <form>\n-    Depth:\n-    <input type=\"number\" name=\"depth\" placeholder=\"depth\" value=\"10\">\n-    <br>\n-    <button>Apply</button>\n-  </form>\n-\n-  <h2>Ng2 Next Tree Benchmark</h2>\n-  <p>\n-    <button id=\"destroyDom\">destroyDom</button>\n-    <button id=\"createDom\">createDom</button>\n-    <button id=\"detectChanges\">detectChanges</button>\n-    <button id=\"updateDomProfile\">profile updateDom</button>\n-    <button id=\"createDomProfile\">profile createDom</button>\n-    <button id=\"detectChangesProfile\">profile detectChanges</button>\n-  </p>\n-\n-  <div>\n-    Change detection runs:<span id=\"numberOfChecks\"></span>\n-  </div>\n-  <div>\n-    <tree id=\"root\">Loading...</tree>\n-  </div>\n-\n-  <!--load location for ts_devserver-->\n-  <script src=\"/app_bundle.js\"></script>\n-</body>\n-</html>"
        },
        {
            "sha": "b97101c84c21e7bb14fe074f0633a1f78c09c87c",
            "filename": "modules/benchmarks/src/tree/ng2_next/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 52,
            "changes": 52,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/modules%2Fbenchmarks%2Fsrc%2Ftree%2Fng2_next%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/modules%2Fbenchmarks%2Fsrc%2Ftree%2Fng2_next%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/modules%2Fbenchmarks%2Fsrc%2Ftree%2Fng2_next%2Findex.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,52 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {enableProdMode} from '@angular/core';\n-\n-import {bindAction, profile} from '../../util';\n-import {buildTree, emptyTree} from '../util';\n-\n-import {AppModule, TreeComponent} from './tree';\n-\n-let tree: TreeComponent;\n-let appMod: AppModule;\n-let detectChangesRuns = 0;\n-\n-function destroyDom() {\n-  tree.data = emptyTree;\n-  appMod.tick();\n-}\n-\n-function createDom() {\n-  tree.data = buildTree();\n-  appMod.tick();\n-}\n-\n-function detectChanges() {\n-  for (let i = 0; i < 10; i++) {\n-    appMod.tick();\n-  }\n-  detectChangesRuns += 10;\n-  numberOfChecksEl.textContent = `${detectChangesRuns}`;\n-}\n-\n-function noop() {}\n-\n-const numberOfChecksEl = document.getElementById('numberOfChecks');\n-\n-enableProdMode();\n-appMod = new AppModule();\n-appMod.bootstrap();\n-tree = appMod.componentRef.instance;\n-\n-bindAction('#destroyDom', destroyDom);\n-bindAction('#createDom', createDom);\n-bindAction('#detectChanges', detectChanges);\n-bindAction('#detectChangesProfile', profile(detectChanges, noop, 'detectChanges'));\n-bindAction('#updateDomProfile', profile(createDom, noop, 'update'));\n-bindAction('#createDomProfile', profile(createDom, destroyDom, 'create'));"
        },
        {
            "sha": "59d64e1e53d5b282db32abeb073b77b963a5dab1",
            "filename": "modules/benchmarks/src/tree/ng2_next/tree.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 140,
            "changes": 140,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/modules%2Fbenchmarks%2Fsrc%2Ftree%2Fng2_next%2Ftree.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/modules%2Fbenchmarks%2Fsrc%2Ftree%2Fng2_next%2Ftree.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/modules%2Fbenchmarks%2Fsrc%2Ftree%2Fng2_next%2Ftree.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,140 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {NgIf} from '@angular/common';\n-import {ComponentFactory, ComponentFactoryResolver, ComponentRef, ErrorHandler, Injector, NgModuleRef, RendererFactory2, Sanitizer, TemplateRef, ViewContainerRef, ɵand as anchorDef, ɵArgumentType as ArgumentType, ɵBindingFlags as BindingFlags, ɵccf as createComponentFactory, ɵdid as directiveDef, ɵeld as elementDef, ɵinitServicesIfNeeded as initServicesIfNeeded, ɵNodeFlags as NodeFlags, ɵted as textDef, ɵvid as viewDef, ɵViewDefinition as ViewDefinition, ɵViewFlags as ViewFlags} from '@angular/core';\n-import {SafeStyle, ɵDomRendererFactory2 as DomRendererFactory2, ɵDomSanitizerImpl as DomSanitizerImpl} from '@angular/platform-browser';\n-\n-import {emptyTree, TreeNode} from '../util';\n-\n-let trustedEmptyColor: SafeStyle;\n-let trustedGreyColor: SafeStyle;\n-\n-export class TreeComponent {\n-  data: TreeNode = emptyTree;\n-  get bgColor() {\n-    return this.data.depth % 2 ? trustedEmptyColor : trustedGreyColor;\n-  }\n-}\n-\n-let viewFlags = ViewFlags.None;\n-\n-function TreeComponent_Host(): ViewDefinition {\n-  return viewDef(viewFlags, [\n-    elementDef(0, NodeFlags.None, null, null, 1, 'tree', null, null, null, null, TreeComponent_0),\n-    directiveDef(1, NodeFlags.Component, null, 0, TreeComponent, []),\n-  ]);\n-}\n-\n-function TreeComponent_1() {\n-  return viewDef(\n-      viewFlags,\n-      [\n-        elementDef(\n-            0, NodeFlags.None, null, null, 1, 'tree', null, null, null, null, TreeComponent_0),\n-        directiveDef(1, NodeFlags.Component, null, 0, TreeComponent, [], {data: [0, 'data']}),\n-      ],\n-      (check, view) => {\n-        const cmp = view.component;\n-        check(view, 1, ArgumentType.Inline, cmp.data.left);\n-      });\n-}\n-\n-function TreeComponent_2() {\n-  return viewDef(\n-      viewFlags,\n-      [\n-        elementDef(\n-            0, NodeFlags.None, null, null, 1, 'tree', null, null, null, null, TreeComponent_0),\n-        directiveDef(1, NodeFlags.Component, null, 0, TreeComponent, [], {data: [0, 'data']}),\n-      ],\n-      (check, view) => {\n-        const cmp = view.component;\n-        check(view, 1, ArgumentType.Inline, cmp.data.left);\n-      });\n-}\n-\n-function TreeComponent_0(): ViewDefinition {\n-  return viewDef(\n-      viewFlags,\n-      [\n-        elementDef(\n-            0, NodeFlags.None, null, null, 1, 'span', null,\n-            [[BindingFlags.TypeElementStyle, 'backgroundColor', null]]),\n-        textDef(1, null, [' ', ' ']),\n-        anchorDef(NodeFlags.EmbeddedViews, null, null, 1, null, TreeComponent_1),\n-        directiveDef(\n-            3, NodeFlags.None, null, 0, NgIf, [ViewContainerRef, TemplateRef], {ngIf: [0, 'ngIf']}),\n-        anchorDef(NodeFlags.EmbeddedViews, null, null, 1, null, TreeComponent_2),\n-        directiveDef(\n-            5, NodeFlags.None, null, 0, NgIf, [ViewContainerRef, TemplateRef], {ngIf: [0, 'ngIf']}),\n-      ],\n-      (check, view) => {\n-        const cmp = view.component;\n-        check(view, 3, ArgumentType.Inline, cmp.data.left != null);\n-        check(view, 5, ArgumentType.Inline, cmp.data.right != null);\n-      },\n-      (check, view) => {\n-        const cmp = view.component;\n-        check(view, 0, ArgumentType.Inline, cmp.bgColor);\n-        check(view, 1, ArgumentType.Inline, cmp.data.value);\n-      });\n-}\n-\n-export class AppModule implements Injector, NgModuleRef<any> {\n-  private sanitizer: DomSanitizerImpl;\n-  private componentFactory: ComponentFactory<TreeComponent>;\n-  private renderer2: RendererFactory2;\n-\n-  componentRef: ComponentRef<TreeComponent>;\n-\n-  constructor() {\n-    initServicesIfNeeded();\n-    this.sanitizer = new DomSanitizerImpl(document);\n-    this.renderer2 = new DomRendererFactory2(null, null, null);\n-    trustedEmptyColor = this.sanitizer.bypassSecurityTrustStyle('');\n-    trustedGreyColor = this.sanitizer.bypassSecurityTrustStyle('grey');\n-    this.componentFactory =\n-        createComponentFactory('#root', TreeComponent, TreeComponent_Host, {}, {}, []);\n-  }\n-\n-  get(token: any, notFoundValue: any = Injector.THROW_IF_NOT_FOUND): any {\n-    switch (token) {\n-      case RendererFactory2:\n-        return this.renderer2;\n-      case Sanitizer:\n-        return this.sanitizer;\n-      case ErrorHandler:\n-        return null;\n-      case NgModuleRef:\n-        return this;\n-    }\n-    return Injector.NULL.get(token, notFoundValue);\n-  }\n-\n-  bootstrap() {\n-    this.componentRef =\n-        this.componentFactory.create(Injector.NULL, [], this.componentFactory.selector, this);\n-  }\n-\n-  tick() {\n-    this.componentRef.changeDetectorRef.detectChanges();\n-  }\n-\n-  get injector() {\n-    return this;\n-  }\n-  get componentFactoryResolver(): ComponentFactoryResolver {\n-    return null;\n-  }\n-  get instance() {\n-    return this;\n-  }\n-  destroy() {}\n-  onDestroy(callback: () => void) {}\n-}"
        },
        {
            "sha": "2de9bb74c0f7a2d59ee8992e76c35a8d32bf484f",
            "filename": "package.json",
            "status": "modified",
            "additions": 1,
            "deletions": 4,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/package.json",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/package.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/package.json?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -24,10 +24,7 @@\n     \"/ \": \"\",\n     \"postinstall\": \"node scripts/webdriver-manager-update.js && node --preserve-symlinks --preserve-symlinks-main ./tools/postinstall-patches.js\",\n     \"prepare\": \"husky install\",\n-    \"test\": \"bazelisk test --build_tag_filters=-view-engine-only --test_tag_filters=-view-engine-only\",\n-    \"test-view-engine-only\": \"bazelisk test --config=view-engine --build_tag_filters=view-engine-only --test_tag_filters=view-engine-only\",\n-    \"test-ivy-aot\": \"echo \\\\`test-ivy-aot\\\\` no longer valid, use \\\\`yarn test\\\\` instead\",\n-    \"test-non-ivy\": \"echo \\\\`test-ivy-aot\\\\` no longer valid, use \\\\`yarn test-view-engine-only\\\\` instead\",\n+    \"test\": \"bazelisk test\",\n     \"test-tsec\": \"bazelisk test //... --build_tag_filters=tsec --test_tag_filters=tsec\",\n     \"lint\": \"yarn -s tslint && yarn -s ng-dev format changed --check\",\n     \"tslint\": \"tslint -c tslint.json --project tsconfig-tslint.json\","
        },
        {
            "sha": "bceeb2b93da43385edb87e25c3be12ef196eac11",
            "filename": "packages/bazel/test/ng_package/BUILD.bazel",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fbazel%2Ftest%2Fng_package%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fbazel%2Ftest%2Fng_package%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbazel%2Ftest%2Fng_package%2FBUILD.bazel?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -82,7 +82,6 @@ jasmine_node_test(\n     # file is based on non-ivy output and therefore won't work for ngc and Ivy at the same time.\n     # TODO: Update test to rely on Ivy partial compilation after View Engine's removal, update the\n     # golden files as appropriate for the change in compilation.\n-    tags = [\"view-engine-only\"],\n     deps = [\"@npm//diff\"],\n )\n "
        },
        {
            "sha": "1c5bd591d1be0f68aeb2be0457eda4b9875189ea",
            "filename": "packages/compiler-cli/integrationtest/BUILD.bazel",
            "status": "modified",
            "additions": 0,
            "deletions": 47,
            "changes": 47,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler-cli%2Fintegrationtest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler-cli%2Fintegrationtest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fintegrationtest%2FBUILD.bazel?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -1,4 +1,3 @@\n-load(\"@build_bazel_rules_nodejs//:index.bzl\", \"nodejs_test\")\n load(\"//tools:defaults.bzl\", \"nodejs_binary\")\n \n package(default_visibility = [\"//visibility:public\"])\n@@ -22,49 +21,3 @@ nodejs_binary(\n     ],\n     entry_point = \"//packages/compiler-cli:src/extract_i18n.ts\",\n )\n-\n-nodejs_test(\n-    name = \"integrationtest\",\n-    data = [\n-        \":ngc_bin\",\n-        \":ng_xi18n\",\n-        \"@nodejs//:node\",\n-        \"@npm//domino\",\n-        \"@npm//chokidar\",\n-        \"@npm//source-map-support\",\n-        \"@npm//shelljs\",\n-        \"@npm//typescript\",\n-        \"@npm//reflect-metadata\",\n-        \"@npm//rxjs\",\n-        \"@npm//tslib\",\n-        \"@npm//jasmine/bin:jasmine\",\n-        \"@npm//xhr2\",\n-        \"@npm//@types/node\",\n-        \"@npm//@types/jasmine\",\n-        # we need to reference zone.d.ts typing file from zone.js build target\n-        # instead of npm because angular repo will not depends on npm zone.js\n-        # any longer.\n-        \"//packages/zone.js/lib:zone_d_ts\",\n-        # we need to reference zone.js npm_package build target\n-        # instead of npm because angular repo will not depends on npm zone.js\n-        # any longer, so we need to build a zone.js npm release first.\n-        \"//packages/zone.js:npm_package\",\n-        \"//packages/animations:npm_package\",\n-        \"//packages/common:npm_package\",\n-        \"//packages/compiler:npm_package\",\n-        \"//packages/compiler-cli:npm_package\",\n-        \"//packages/core:npm_package\",\n-        \"//packages/forms:npm_package\",\n-        \"//packages/platform-browser:npm_package\",\n-        \"//packages/platform-browser-dynamic:npm_package\",\n-        \"//packages/platform-server:npm_package\",\n-        \"//packages/router:npm_package\",\n-    ] + glob([\"**/*\"]),\n-    entry_point = \"test.js\",\n-    tags = [\n-        # TODO(josephperrott): reenable or remove test after investigating the cause of failures\n-        # on windows CI runs.\n-        \"manual\",\n-        \"view-engine-only\",\n-    ],\n-)"
        },
        {
            "sha": "baf85d8dc71760ec5dc0de6601ee23d795d5d1eb",
            "filename": "packages/compiler-cli/integrationtest/bazel/ng_module/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 42,
            "changes": 42,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Fng_module%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Fng_module%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Fng_module%2FBUILD.bazel?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,42 +0,0 @@\n-load(\"//packages/bazel:index.bzl\", \"ng_module\")\n-load(\"//tools:defaults.bzl\", \"jasmine_node_test\")\n-load(\":extract_flat_module_index.bzl\", \"extract_flat_module_index\")\n-\n-ng_module(\n-    name = \"test_module\",\n-    testonly = True,\n-    srcs = glob([\"*.ts\"]),\n-    api_extractor = \"//packages/bazel/src/api-extractor:api_extractor\",\n-    compiler = \"//packages/bazel/src/ngc-wrapped\",\n-    entry_point = \"index.ts\",\n-    flat_module_out_file = \"flat_module_filename\",\n-    module_name = \"some_npm_module\",\n-    ng_xi18n = \"//packages/bazel/src/ngc-wrapped:xi18n\",\n-    node_modules = \"@npm//typescript:typescript__typings\",\n-    tags = [\n-        # Disabled as this test is specific to the flat module indexing of metadata.json files that\n-        # the old ngc compiler does. Ivy has no metadata.json files so this test does not apply.\n-        \"view-engine-only\",\n-    ],\n-    deps = [\n-        \"//packages/core\",\n-        \"@npm//tslib\",\n-    ],\n-)\n-\n-extract_flat_module_index(\n-    name = \"flat_module_index\",\n-    testonly = True,\n-    deps = [\":test_module\"],\n-)\n-\n-jasmine_node_test(\n-    name = \"test\",\n-    srcs = [\"spec.js\"],\n-    data = [\":flat_module_index\"],\n-    tags = [\n-        # Disabled as this test is specific to the flat module indexing of metadata.json files that\n-        # the old ngc compiler does. Ivy has no metadata.json files so this test does not apply.\n-        \"view-engine-only\",\n-    ],\n-)"
        },
        {
            "sha": "0b3311bf91ddcf121be68c095d8ad2041fd503c2",
            "filename": "packages/compiler-cli/integrationtest/bazel/ng_module/child.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 14,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Fng_module%2Fchild.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Fng_module%2Fchild.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Fng_module%2Fchild.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,14 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {NgModule} from '@angular/core';\n-import {Parent} from './parent';\n-\n-@NgModule({imports: [Parent]})\n-export class Child {\n-}"
        },
        {
            "sha": "0da1caa2ca036a32feefd27668dd6c669c729bf8",
            "filename": "packages/compiler-cli/integrationtest/bazel/ng_module/extract_flat_module_index.bzl",
            "status": "removed",
            "additions": 0,
            "deletions": 26,
            "changes": 26,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Fng_module%2Fextract_flat_module_index.bzl",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Fng_module%2Fextract_flat_module_index.bzl",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Fng_module%2Fextract_flat_module_index.bzl?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,26 +0,0 @@\n-# Copyright Google LLC All Rights Reserved.\n-#\n-# Use of this source code is governed by an MIT-style license that can be\n-# found in the LICENSE file at https://angular.io/license\n-\"\"\"Test utility to extract the \"flat_module_metadata\" from transitive Angular deps.\n-\"\"\"\n-\n-def _extract_flat_module_index(ctx):\n-    files = []\n-    for dep in ctx.attr.deps:\n-        if hasattr(dep, \"angular\") and hasattr(dep.angular, \"flat_module_metadata\"):\n-            flat_module = dep.angular.flat_module_metadata\n-            files.append(flat_module.typings_file)\n-\n-            # The flat module metadata file could be `None` for targets\n-            # built with Ivy. No metadata files are generated in ngtsc.\n-            if flat_module.metadata_file != None:\n-                files.append(flat_module.metadata_file)\n-    return [DefaultInfo(files = depset(files))]\n-\n-extract_flat_module_index = rule(\n-    implementation = _extract_flat_module_index,\n-    attrs = {\n-        \"deps\": attr.label_list(),\n-    },\n-)"
        },
        {
            "sha": "651d53abb7ab35568014a2fa461a2b19e69d64f5",
            "filename": "packages/compiler-cli/integrationtest/bazel/ng_module/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 9,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Fng_module%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Fng_module%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Fng_module%2Findex.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,9 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-export * from './child';"
        },
        {
            "sha": "59fc1a0a02137fec44b97a2a5113258a1947006f",
            "filename": "packages/compiler-cli/integrationtest/bazel/ng_module/parent.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 13,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Fng_module%2Fparent.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Fng_module%2Fparent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Fng_module%2Fparent.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,13 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {NgModule} from '@angular/core';\n-\n-@NgModule({})\n-export class Parent {\n-}"
        },
        {
            "sha": "588dc6cfff86a8ce56dd3a863768327410df5879",
            "filename": "packages/compiler-cli/integrationtest/bazel/ng_module/spec.js",
            "status": "removed",
            "additions": 0,
            "deletions": 33,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Fng_module%2Fspec.js",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Fng_module%2Fspec.js",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fintegrationtest%2Fbazel%2Fng_module%2Fspec.js?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,33 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-const fs = require('fs');\n-const PKG = 'angular/packages/compiler-cli/integrationtest/bazel/ng_module';\n-describe('flat module index', () => {\n-  describe('child metadata', () => {\n-    it('should have contents', () => {\n-      const metadata = fs.readFileSync(\n-          require.resolve(`${PKG}/flat_module_filename.metadata.json`), {encoding: 'utf-8'});\n-      expect(metadata).toContain('\"__symbolic\":\"module\"');\n-      expect(metadata).toContain('\"__symbolic\":\"reference\",\"module\":\"@angular/core\"');\n-      expect(metadata).toContain(\n-          '\"origins\":{\"Child\":\"./child\",\"ɵangular_packages_compiler_cli_integrationtest_bazel_ng_module_test_module_a\":\"./parent\"}');\n-      expect(metadata).toContain('\"importAs\":\"some_npm_module\"');\n-    });\n-  });\n-  describe('child typings', () => {\n-    it('should have contents', () => {\n-      const dts =\n-          fs.readFileSync(require.resolve(`${PKG}/flat_module_filename.d.ts`), {encoding: 'utf-8'});\n-\n-      expect(dts).toContain('export * from \\'./index\\';');\n-      expect(dts).toContain(\n-          'export { Parent as ɵangular_packages_compiler_cli_integrationtest_bazel_ng_module_test_module_a } from \\'./parent\\';');\n-    });\n-  });\n-});"
        },
        {
            "sha": "03cf2fcc09a5cfda4d6b5ef1a94e0f012cd04cd4",
            "filename": "packages/compiler-cli/test/BUILD.bazel",
            "status": "modified",
            "additions": 0,
            "deletions": 39,
            "changes": 39,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler-cli%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler-cli%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2FBUILD.bazel?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -52,45 +52,6 @@ jasmine_node_test(\n     ],\n )\n \n-# ngc_spec\n-ts_library(\n-    name = \"ngc_lib\",\n-    testonly = True,\n-    srcs = [\n-        \"ngc_spec.ts\",\n-    ],\n-    deps = [\n-        \":test_utils\",\n-        \"//packages/compiler\",\n-        \"//packages/compiler-cli\",\n-        \"@npm//tsickle\",\n-        \"@npm//typescript\",\n-    ],\n-)\n-\n-jasmine_node_test(\n-    name = \"ngc\",\n-    timeout = \"long\",  # 900 seconds\n-    bootstrap = [\"//tools/testing:node_es5\"],\n-    data = [\n-        \"@npm//@angular/common-12\",\n-        \"@npm//@angular/core-12\",\n-        \"@npm//@angular/platform-browser-12\",\n-        \"@npm//@angular/router-12\",\n-    ],\n-    tags = [\n-        # Disabled as these tests are specific to the old ngc compiler, and not ngtsc which has its\n-        # own tests under //packages/compiler-cli/test/ngtsc.\n-        \"view-engine-only\",\n-    ],\n-    deps = [\n-        \":ngc_lib\",\n-        \"//packages/core\",\n-        \"@npm//rxjs\",\n-        \"@npm//yargs\",\n-    ],\n-)\n-\n # perform_watch_spec\n ts_library(\n     name = \"perform_watch_lib\","
        },
        {
            "sha": "0ec3048c6132268ec56f83f9af9271eda7f695b6",
            "filename": "packages/compiler-cli/test/diagnostics/BUILD.bazel",
            "status": "modified",
            "additions": 0,
            "deletions": 31,
            "changes": 31,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler-cli%2Ftest%2Fdiagnostics%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler-cli%2Ftest%2Fdiagnostics%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fdiagnostics%2FBUILD.bazel?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -1,36 +1,5 @@\n load(\"//tools:defaults.bzl\", \"jasmine_node_test\", \"ts_library\")\n \n-# check_types_spec\n-ts_library(\n-    name = \"check_types_lib\",\n-    testonly = True,\n-    srcs = [\"check_types_spec.ts\"],\n-    deps = [\n-        \"//packages/compiler-cli\",\n-        \"//packages/compiler-cli/test:test_utils\",\n-        \"@npm//typescript\",\n-    ],\n-)\n-\n-jasmine_node_test(\n-    name = \"check_types\",\n-    timeout = \"long\",  # 900 seconds\n-    bootstrap = [\"//tools/testing:node_es5\"],\n-    data = [\n-        \"@npm//@angular/common-12\",\n-        \"@npm//@angular/core-12\",\n-    ],\n-    tags = [\n-        # Disabled as these tests pertain to typechecking in the old ngc compiler. The Ivy ngtsc\n-        # compiler has its own typechecking implementation and tests.\n-        \"view-engine-only\",\n-    ],\n-    deps = [\n-        \":check_types_lib\",\n-        \"//packages/core\",\n-    ],\n-)\n-\n # typescript_version_spec\n ts_library(\n     name = \"typescript_version_lib\","
        },
        {
            "sha": "fcf4777f6bb9cce7b72504c336066304cf7436ad",
            "filename": "packages/compiler-cli/test/transformers/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 40,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2FBUILD.bazel?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,40 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"jasmine_node_test\", \"ts_library\")\n-\n-ts_library(\n-    name = \"test_lib\",\n-    testonly = True,\n-    srcs = glob([\"**/*.ts\"]),\n-    deps = [\n-        \"//packages:types\",\n-        \"//packages/compiler\",\n-        \"//packages/compiler-cli\",\n-        \"//packages/compiler-cli/src/ngtsc/reflection\",\n-        \"//packages/compiler-cli/src/transformers/downlevel_decorators_transform\",\n-        \"//packages/compiler-cli/test:test_utils\",\n-        \"//packages/compiler/test:test_utils\",\n-        \"//packages/core\",\n-        \"//packages/platform-browser\",\n-        \"@npm//typescript\",\n-    ],\n-)\n-\n-jasmine_node_test(\n-    name = \"test\",\n-    timeout = \"long\",  # 900 seconds\n-    bootstrap = [\"//tools/testing:node_es5\"],\n-    data = [\n-        \"@npm//@angular/common-12\",\n-        \"@npm//@angular/core-12\",\n-        \"@npm//@angular/router-12\",\n-    ],\n-    tags = [\n-        # Disabled as these tests pertain to the old compiler and not ngtsc, which doesn't use any\n-        # of these transformer utilities.\n-        \"view-engine-only\",\n-    ],\n-    deps = [\n-        \":test_lib\",\n-        \"//packages/core\",\n-        \"@npm//source-map\",\n-    ],\n-)"
        },
        {
            "sha": "0e72c5b5e60d5ef98a2e56925af20568fbd0709a",
            "filename": "packages/compiler-cli/test/transformers/compiler_host_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 401,
            "changes": 401,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fcompiler_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fcompiler_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fcompiler_host_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,401 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as compiler from '@angular/compiler';\n-import ts from 'typescript';\n-\n-import {MetadataCollector} from '../../src/metadata/collector';\n-import {CompilerHost, CompilerOptions, LibrarySummary} from '../../src/transformers/api';\n-import {createCompilerHost, TsCompilerAotCompilerTypeCheckHostAdapter} from '../../src/transformers/compiler_host';\n-import {Directory, Entry, MockAotContext, MockCompilerHost} from '../mocks';\n-\n-const dummyModule = 'export let foo: any[];';\n-const aGeneratedFile = new compiler.GeneratedFile(\n-    '/tmp/src/index.ts', '/tmp/src/index.ngfactory.ts',\n-    [new compiler.DeclareVarStmt('x', new compiler.LiteralExpr(1))]);\n-const aGeneratedFileText = `var x:any = 1;\\n`;\n-\n-describe('NgCompilerHost', () => {\n-  let codeGenerator: {generateFile: jasmine.Spy; findGeneratedFileNames: jasmine.Spy;};\n-\n-  beforeEach(() => {\n-    codeGenerator = {\n-      generateFile: jasmine.createSpy('generateFile').and.returnValue(null),\n-      findGeneratedFileNames: jasmine.createSpy('findGeneratedFileNames').and.returnValue([]),\n-    };\n-  });\n-\n-  function createNgHost({files = {}}: {files?: Directory} = {}): CompilerHost {\n-    const context = new MockAotContext('/tmp/', files);\n-    return new MockCompilerHost(context) as ts.CompilerHost;\n-  }\n-\n-  function createHost({\n-    files = {},\n-    options = {\n-      basePath: '/tmp',\n-      moduleResolution: ts.ModuleResolutionKind.NodeJs,\n-    },\n-    rootNames = ['/tmp/index.ts'],\n-    ngHost = createNgHost({files}),\n-    librarySummaries = [],\n-  }: {\n-    files?: Directory,\n-    options?: CompilerOptions,\n-    rootNames?: string[],\n-    ngHost?: CompilerHost,\n-    librarySummaries?: LibrarySummary[]\n-  } = {}) {\n-    return new TsCompilerAotCompilerTypeCheckHostAdapter(\n-        rootNames, options, ngHost, new MetadataCollector(), codeGenerator,\n-        new Map(\n-            librarySummaries.map(entry => [entry.fileName, entry] as [string, LibrarySummary])));\n-  }\n-\n-  describe('fileNameToModuleName', () => {\n-    let host: TsCompilerAotCompilerTypeCheckHostAdapter;\n-    beforeEach(() => {\n-      host = createHost();\n-    });\n-\n-    it('should use a package import when accessing a package from a source file', () => {\n-      expect(host.fileNameToModuleName('/tmp/node_modules/@angular/core.d.ts', '/tmp/main.ts'))\n-          .toBe('@angular/core');\n-    });\n-\n-    it('should allow an import o a package whose name contains dot (e.g. @angular.io)', () => {\n-      expect(host.fileNameToModuleName('/tmp/node_modules/@angular.io/core.d.ts', '/tmp/main.ts'))\n-          .toBe('@angular.io/core');\n-    });\n-\n-    it('should use a package import when accessing a package from another package', () => {\n-      expect(host.fileNameToModuleName(\n-                 '/tmp/node_modules/mod1/index.d.ts', '/tmp/node_modules/mod2/index.d.ts'))\n-          .toBe('mod1/index');\n-      expect(host.fileNameToModuleName(\n-                 '/tmp/node_modules/@angular/core/index.d.ts',\n-                 '/tmp/node_modules/@angular/common/index.d.ts'))\n-          .toBe('@angular/core/index');\n-    });\n-\n-    it('should use a relative import when accessing a file in the same package', () => {\n-      expect(host.fileNameToModuleName(\n-                 '/tmp/node_modules/mod/a/child.d.ts', '/tmp/node_modules/mod/index.d.ts'))\n-          .toBe('./a/child');\n-      expect(host.fileNameToModuleName(\n-                 '/tmp/node_modules/@angular/core/src/core.d.ts',\n-                 '/tmp/node_modules/@angular/core/index.d.ts'))\n-          .toBe('./src/core');\n-    });\n-\n-    it('should use a relative import when accessing a source file from a source file', () => {\n-      expect(host.fileNameToModuleName('/tmp/src/a/child.ts', '/tmp/src/index.ts'))\n-          .toBe('./a/child');\n-    });\n-\n-    it('should use a relative import when accessing generated files, even if crossing packages',\n-       () => {\n-         expect(host.fileNameToModuleName(\n-                    '/tmp/node_modules/mod2/b.ngfactory.d.ts',\n-                    '/tmp/node_modules/mod1/a.ngfactory.d.ts'))\n-             .toBe('../mod2/b.ngfactory');\n-       });\n-\n-    it('should support multiple rootDirs when accessing a source file form a source file', () => {\n-      const hostWithMultipleRoots = createHost({\n-        options: {\n-          basePath: '/tmp/',\n-          rootDirs: [\n-            'src/a',\n-            'src/b',\n-          ]\n-        }\n-      });\n-      // both files are in the rootDirs\n-      expect(hostWithMultipleRoots.fileNameToModuleName('/tmp/src/b/b.ts', '/tmp/src/a/a.ts'))\n-          .toBe('./b');\n-\n-      // one file is not in the rootDirs\n-      expect(hostWithMultipleRoots.fileNameToModuleName('/tmp/src/c/c.ts', '/tmp/src/a/a.ts'))\n-          .toBe('../c/c');\n-    });\n-\n-    it('should error if accessing a source file from a package', () => {\n-      expect(\n-          () => host.fileNameToModuleName(\n-              '/tmp/src/a/child.ts', '/tmp/node_modules/@angular/core.d.ts'))\n-          .toThrowError(\n-              'Trying to import a source file from a node_modules package: ' +\n-              'import /tmp/src/a/child.ts from /tmp/node_modules/@angular/core.d.ts');\n-    });\n-\n-    it('should use the provided implementation if any', () => {\n-      const ngHost = createNgHost();\n-      ngHost.fileNameToModuleName = () => 'someResult';\n-      const host = createHost({ngHost});\n-      expect(host.fileNameToModuleName('a', 'b')).toBe('someResult');\n-    });\n-  });\n-\n-  describe('moduleNameToFileName', () => {\n-    it('should resolve an import using the containing file', () => {\n-      const host = createHost({files: {'tmp': {'src': {'a': {'child.d.ts': dummyModule}}}}});\n-      expect(host.moduleNameToFileName('./a/child', '/tmp/src/index.ts'))\n-          .toBe('/tmp/src/a/child.d.ts');\n-    });\n-\n-    it('should allow to skip the containing file for package imports', () => {\n-      const host =\n-          createHost({files: {'tmp': {'node_modules': {'@core': {'index.d.ts': dummyModule}}}}});\n-      expect(host.moduleNameToFileName('@core/index')).toBe('/tmp/node_modules/@core/index.d.ts');\n-    });\n-\n-    it('should use the provided implementation if any', () => {\n-      const ngHost = createNgHost();\n-      ngHost.moduleNameToFileName = () => 'someResult';\n-      const host = createHost({ngHost});\n-      expect(host.moduleNameToFileName('a', 'b')).toBe('someResult');\n-    });\n-\n-    it('should work well with windows paths', () => {\n-      const host = createHost({\n-        rootNames: ['\\\\tmp\\\\index.ts'],\n-        options: {basePath: '\\\\tmp'},\n-        files: {'tmp': {'node_modules': {'@core': {'index.d.ts': dummyModule}}}}\n-      });\n-      expect(host.moduleNameToFileName('@core/index')).toBe('/tmp/node_modules/@core/index.d.ts');\n-    });\n-  });\n-\n-  describe('resourceNameToFileName', () => {\n-    it('should resolve a relative import', () => {\n-      const host = createHost({files: {'tmp': {'src': {'a': {'child.html': '<div>'}}}}});\n-      expect(host.resourceNameToFileName('./a/child.html', '/tmp/src/index.ts'))\n-          .toBe('/tmp/src/a/child.html');\n-\n-      expect(host.resourceNameToFileName('./a/non-existing.html', '/tmp/src/index.ts')).toBe(null);\n-    });\n-\n-    it('should resolve package paths as relative paths', () => {\n-      const host = createHost({files: {'tmp': {'src': {'a': {'child.html': '<div>'}}}}});\n-      expect(host.resourceNameToFileName('a/child.html', '/tmp/src/index.ts'))\n-          .toBe('/tmp/src/a/child.html');\n-    });\n-\n-    it('should resolve absolute paths as package paths', () => {\n-      const host = createHost({files: {'tmp': {'node_modules': {'a': {'child.html': '<div>'}}}}});\n-      expect(host.resourceNameToFileName('/a/child.html', ''))\n-          .toBe('/tmp/node_modules/a/child.html');\n-    });\n-\n-    it('should use the provided implementation if any', () => {\n-      const ngHost = createNgHost();\n-      ngHost.resourceNameToFileName = () => 'someResult';\n-      const host = createHost({ngHost});\n-      expect(host.resourceNameToFileName('a', 'b')).toBe('someResult');\n-    });\n-    it('should resolve Sass imports to generated .css files', () => {\n-      const host = createHost({files: {'tmp': {'src': {'a': {'style.css': 'h1: bold'}}}}});\n-      expect(host.resourceNameToFileName('./a/style.scss', '/tmp/src/index.ts'))\n-          .toBe('/tmp/src/a/style.css');\n-    });\n-    it('should resolve Less imports to generated .css files', () => {\n-      const host = createHost({files: {'tmp': {'src': {'a': {'style.css': 'h1: bold'}}}}});\n-      expect(host.resourceNameToFileName('./a/style.less', '/tmp/src/index.ts'))\n-          .toBe('/tmp/src/a/style.css');\n-    });\n-    it('should resolve Stylus imports to generated .css files', () => {\n-      const host = createHost({files: {'tmp': {'src': {'a': {'style.css': 'h1: bold'}}}}});\n-      expect(host.resourceNameToFileName('./a/style.styl', '/tmp/src/index.ts'))\n-          .toBe('/tmp/src/a/style.css');\n-    });\n-  });\n-\n-  describe('addGeneratedFile', () => {\n-    function generate(path: string, files: {}) {\n-      codeGenerator.findGeneratedFileNames.and.returnValue([`${path}.ngfactory.ts`]);\n-      codeGenerator.generateFile.and.returnValue(\n-          new compiler.GeneratedFile(`${path}.ts`, `${path}.ngfactory.ts`, []));\n-      const host = createHost({\n-        files,\n-        options: {\n-          basePath: '/tmp',\n-          moduleResolution: ts.ModuleResolutionKind.NodeJs,\n-          // Request UMD, which should get default module names\n-          module: ts.ModuleKind.UMD\n-        },\n-      });\n-      return host.getSourceFile(`${path}.ngfactory.ts`, ts.ScriptTarget.Latest);\n-    }\n-\n-    it('should include a moduleName when the file is in node_modules', () => {\n-      const genSf = generate(\n-          '/tmp/node_modules/@angular/core/core',\n-          {'tmp': {'node_modules': {'@angular': {'core': {'core.ts': `// some content`}}}}});\n-      expect(genSf.moduleName).toBe('@angular/core/core.ngfactory');\n-    });\n-\n-    it('should not get tripped on nested node_modules', () => {\n-      const genSf = generate('/tmp/node_modules/lib1/node_modules/lib2/thing', {\n-        'tmp':\n-            {'node_modules': {'lib1': {'node_modules': {'lib2': {'thing.ts': `// some content`}}}}}\n-      });\n-      expect(genSf.moduleName).toBe('lib2/thing.ngfactory');\n-    });\n-  });\n-\n-  describe('getSourceFile', () => {\n-    it('should cache source files by name', () => {\n-      const host = createHost({files: {'tmp': {'src': {'index.ts': ``}}}});\n-\n-      const sf1 = host.getSourceFile('/tmp/src/index.ts', ts.ScriptTarget.Latest);\n-      const sf2 = host.getSourceFile('/tmp/src/index.ts', ts.ScriptTarget.Latest);\n-      expect(sf1).toBe(sf2);\n-    });\n-\n-    it('should generate code when asking for the base name and add it as referencedFiles', () => {\n-      codeGenerator.findGeneratedFileNames.and.returnValue(['/tmp/src/index.ngfactory.ts']);\n-      codeGenerator.generateFile.and.returnValue(aGeneratedFile);\n-      const host = createHost({\n-        files: {\n-          'tmp': {\n-            'src': {\n-              'index.ts': `\n-              /// <reference path=\"main.ts\"/>\n-            `\n-            }\n-          }\n-        }\n-      });\n-\n-      const sf = host.getSourceFile('/tmp/src/index.ts', ts.ScriptTarget.Latest);\n-      expect(sf.referencedFiles[0].fileName).toBe('main.ts');\n-      expect(sf.referencedFiles[1].fileName).toBe('/tmp/src/index.ngfactory.ts');\n-\n-      const genSf = host.getSourceFile('/tmp/src/index.ngfactory.ts', ts.ScriptTarget.Latest);\n-      expect(genSf.text).toBe(aGeneratedFileText);\n-\n-      // the codegen should have been cached\n-      expect(codeGenerator.generateFile).toHaveBeenCalledTimes(1);\n-      expect(codeGenerator.findGeneratedFileNames).toHaveBeenCalledTimes(1);\n-    });\n-\n-    it('should generate code when asking for the generated name first', () => {\n-      codeGenerator.findGeneratedFileNames.and.returnValue(['/tmp/src/index.ngfactory.ts']);\n-      codeGenerator.generateFile.and.returnValue(aGeneratedFile);\n-      const host = createHost({\n-        files: {\n-          'tmp': {\n-            'src': {\n-              'index.ts': `\n-              /// <reference path=\"main.ts\"/>\n-            `\n-            }\n-          }\n-        }\n-      });\n-\n-      const genSf = host.getSourceFile('/tmp/src/index.ngfactory.ts', ts.ScriptTarget.Latest);\n-      expect(genSf.text).toBe(aGeneratedFileText);\n-\n-      const sf = host.getSourceFile('/tmp/src/index.ts', ts.ScriptTarget.Latest);\n-      expect(sf.referencedFiles[0].fileName).toBe('main.ts');\n-      expect(sf.referencedFiles[1].fileName).toBe('/tmp/src/index.ngfactory.ts');\n-\n-      // the codegen should have been cached\n-      expect(codeGenerator.generateFile).toHaveBeenCalledTimes(1);\n-      expect(codeGenerator.findGeneratedFileNames).toHaveBeenCalledTimes(1);\n-    });\n-\n-    it('should clear old generated references if the original host cached them', () => {\n-      codeGenerator.findGeneratedFileNames.and.returnValue(['/tmp/src/index.ngfactory.ts']);\n-\n-      const sfText = `\n-          /// <reference path=\"main.ts\"/>\n-      `;\n-      const ngHost = createNgHost({files: {'tmp': {'src': {'index.ts': sfText}}}});\n-      const sf = ts.createSourceFile('/tmp/src/index.ts', sfText, ts.ScriptTarget.Latest);\n-      ngHost.getSourceFile = () => sf;\n-\n-      codeGenerator.findGeneratedFileNames.and.returnValue(['/tmp/src/index.ngfactory.ts']);\n-      codeGenerator.generateFile.and.returnValue(\n-          new compiler.GeneratedFile('/tmp/src/index.ts', '/tmp/src/index.ngfactory.ts', []));\n-      const host1 = createHost({ngHost});\n-\n-      host1.getSourceFile('/tmp/src/index.ts', ts.ScriptTarget.Latest);\n-      expect(sf.referencedFiles.length).toBe(2);\n-      expect(sf.referencedFiles[0].fileName).toBe('main.ts');\n-      expect(sf.referencedFiles[1].fileName).toBe('/tmp/src/index.ngfactory.ts');\n-\n-      codeGenerator.findGeneratedFileNames.and.returnValue([]);\n-      codeGenerator.generateFile.and.returnValue(null);\n-      const host2 = createHost({ngHost});\n-\n-      host2.getSourceFile('/tmp/src/index.ts', ts.ScriptTarget.Latest);\n-      expect(sf.referencedFiles.length).toBe(1);\n-      expect(sf.referencedFiles[0].fileName).toBe('main.ts');\n-    });\n-\n-    it('should generate for tsx files', () => {\n-      codeGenerator.findGeneratedFileNames.and.returnValue(['/tmp/src/index.ngfactory.ts']);\n-      codeGenerator.generateFile.and.returnValue(aGeneratedFile);\n-      const host = createHost({files: {'tmp': {'src': {'index.tsx': ``}}}});\n-\n-      const genSf = host.getSourceFile('/tmp/src/index.ngfactory.ts', ts.ScriptTarget.Latest);\n-      expect(genSf.text).toBe(aGeneratedFileText);\n-\n-      const sf = host.getSourceFile('/tmp/src/index.tsx', ts.ScriptTarget.Latest);\n-      expect(sf.referencedFiles[0].fileName).toBe('/tmp/src/index.ngfactory.ts');\n-\n-      // the codegen should have been cached\n-      expect(codeGenerator.generateFile).toHaveBeenCalledTimes(1);\n-      expect(codeGenerator.findGeneratedFileNames).toHaveBeenCalledTimes(1);\n-    });\n-  });\n-\n-  describe('updateSourceFile', () => {\n-    it('should update source files', () => {\n-      codeGenerator.findGeneratedFileNames.and.returnValue(['/tmp/src/index.ngfactory.ts']);\n-      codeGenerator.generateFile.and.returnValue(aGeneratedFile);\n-      const host = createHost({files: {'tmp': {'src': {'index.ts': ''}}}});\n-\n-      let genSf = host.getSourceFile('/tmp/src/index.ngfactory.ts', ts.ScriptTarget.Latest);\n-      expect(genSf.text).toBe(aGeneratedFileText);\n-\n-      host.updateGeneratedFile(new compiler.GeneratedFile(\n-          '/tmp/src/index.ts', '/tmp/src/index.ngfactory.ts',\n-          [new compiler.DeclareVarStmt('x', new compiler.LiteralExpr(2))]));\n-      genSf = host.getSourceFile('/tmp/src/index.ngfactory.ts', ts.ScriptTarget.Latest);\n-      expect(genSf.text).toBe(`var x:any = 2;\\n`);\n-    });\n-\n-    it('should error if the imports changed', () => {\n-      codeGenerator.findGeneratedFileNames.and.returnValue(['/tmp/src/index.ngfactory.ts']);\n-      codeGenerator.generateFile.and.returnValue(new compiler.GeneratedFile(\n-          '/tmp/src/index.ts', '/tmp/src/index.ngfactory.ts',\n-          [new compiler.DeclareVarStmt(\n-              'x',\n-              new compiler.ExternalExpr(new compiler.ExternalReference('aModule', 'aName')))]));\n-      const host = createHost({files: {'tmp': {'src': {'index.ts': ''}}}});\n-\n-      host.getSourceFile('/tmp/src/index.ngfactory.ts', ts.ScriptTarget.Latest);\n-\n-      expect(\n-          () => host.updateGeneratedFile(new compiler.GeneratedFile(\n-              '/tmp/src/index.ts', '/tmp/src/index.ngfactory.ts',\n-              [new compiler.DeclareVarStmt(\n-                  'x',\n-                  new compiler.ExternalExpr(\n-                      new compiler.ExternalReference('otherModule', 'aName')))])))\n-          .toThrowError([\n-            `Illegal State: external references changed in /tmp/src/index.ngfactory.ts.`,\n-            `Old: aModule.`, `New: otherModule`\n-          ].join('\\n'));\n-    });\n-  });\n-});"
        },
        {
            "sha": "9439e79dabeabe6064578bfff765489bcee34ddb",
            "filename": "packages/compiler-cli/test/transformers/downlevel_decorators_transform_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 868,
            "changes": 868,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fdownlevel_decorators_transform_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fdownlevel_decorators_transform_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fdownlevel_decorators_transform_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,868 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {TypeScriptReflectionHost} from '../../src/ngtsc/reflection';\n-import {getDownlevelDecoratorsTransform} from '../../src/transformers/downlevel_decorators_transform/index';\n-import {MockAotContext, MockCompilerHost} from '../mocks';\n-\n-const TEST_FILE_INPUT = '/test.ts';\n-const TEST_FILE_OUTPUT = `/test.js`;\n-const TEST_FILE_DTS_OUTPUT = `/test.d.ts`;\n-\n-describe('downlevel decorator transform', () => {\n-  let host: MockCompilerHost;\n-  let context: MockAotContext;\n-  let diagnostics: ts.Diagnostic[];\n-  let isClosureEnabled: boolean;\n-  let skipClassDecorators: boolean;\n-\n-  beforeEach(() => {\n-    diagnostics = [];\n-    context = new MockAotContext('/', {\n-      'dom_globals.d.ts': `\n-        declare class HTMLElement {};\n-        declare class Document {};\n-      `\n-    });\n-    host = new MockCompilerHost(context);\n-    isClosureEnabled = false;\n-    skipClassDecorators = false;\n-  });\n-\n-  function transform(\n-      contents: string, compilerOptions: ts.CompilerOptions = {},\n-      preTransformers: ts.TransformerFactory<ts.SourceFile>[] = []) {\n-    context.writeFile(TEST_FILE_INPUT, contents);\n-    const program = ts.createProgram(\n-        [TEST_FILE_INPUT, '/dom_globals.d.ts'], {\n-          module: ts.ModuleKind.CommonJS,\n-          importHelpers: true,\n-          lib: ['dom', 'es2015'],\n-          target: ts.ScriptTarget.ES2017,\n-          declaration: true,\n-          experimentalDecorators: true,\n-          emitDecoratorMetadata: false,\n-          ...compilerOptions\n-        },\n-        host);\n-    const testFile = program.getSourceFile(TEST_FILE_INPUT);\n-    const typeChecker = program.getTypeChecker();\n-    const reflectionHost = new TypeScriptReflectionHost(typeChecker);\n-    const transformers: ts.CustomTransformers = {\n-      before: [\n-        ...preTransformers,\n-        getDownlevelDecoratorsTransform(\n-            program.getTypeChecker(), reflectionHost, diagnostics,\n-            /* isCore */ false, isClosureEnabled, skipClassDecorators)\n-      ]\n-    };\n-    let output: string|null = null;\n-    let dtsOutput: string|null = null;\n-    const emitResult = program.emit(\n-        testFile, ((fileName, outputText) => {\n-          if (fileName === TEST_FILE_OUTPUT) {\n-            output = outputText;\n-          } else if (fileName === TEST_FILE_DTS_OUTPUT) {\n-            dtsOutput = outputText;\n-          }\n-        }),\n-        undefined, undefined, transformers);\n-    diagnostics.push(...emitResult.diagnostics);\n-    expect(output).not.toBeNull();\n-    return {\n-      output: omitLeadingWhitespace(output!),\n-      dtsOutput: dtsOutput ? omitLeadingWhitespace(dtsOutput) : null\n-    };\n-  }\n-\n-  it('should downlevel decorators for @Injectable decorated class', () => {\n-    const {output} = transform(`\n-      import {Injectable} from '@angular/core';\n-\n-      export class ClassInject {};\n-\n-      @Injectable()\n-      export class MyService {\n-        constructor(v: ClassInject) {}\n-      }\n-    `);\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).toContain(dedent`\n-      MyService.decorators = [\n-          { type: core_1.Injectable }\n-      ];\n-      MyService.ctorParameters = () => [\n-          { type: ClassInject }\n-      ];`);\n-    expect(output).not.toContain('tslib');\n-  });\n-\n-  it('should downlevel decorators for @Directive decorated class', () => {\n-    const {output} = transform(`\n-      import {Directive} from '@angular/core';\n-\n-      export class ClassInject {};\n-\n-      @Directive()\n-      export class MyDir {\n-        constructor(v: ClassInject) {}\n-      }\n-    `);\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).toContain(dedent`\n-      MyDir.decorators = [\n-          { type: core_1.Directive }\n-      ];\n-      MyDir.ctorParameters = () => [\n-          { type: ClassInject }\n-      ];`);\n-    expect(output).not.toContain('tslib');\n-  });\n-\n-  it('should downlevel decorators for @Component decorated class', () => {\n-    const {output} = transform(`\n-      import {Component} from '@angular/core';\n-\n-      export class ClassInject {};\n-\n-      @Component({template: 'hello'})\n-      export class MyComp {\n-        constructor(v: ClassInject) {}\n-      }\n-    `);\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).toContain(dedent`\n-      MyComp.decorators = [\n-        { type: core_1.Component, args: [{ template: 'hello' },] }\n-      ];\n-      MyComp.ctorParameters = () => [\n-        { type: ClassInject }\n-      ];`);\n-    expect(output).not.toContain('tslib');\n-  });\n-\n-  it('should downlevel decorators for @Pipe decorated class', () => {\n-    const {output} = transform(`\n-      import {Pipe} from '@angular/core';\n-\n-      export class ClassInject {};\n-\n-      @Pipe({selector: 'hello'})\n-      export class MyPipe {\n-        constructor(v: ClassInject) {}\n-      }\n-    `);\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).toContain(dedent`\n-      MyPipe.decorators = [\n-        { type: core_1.Pipe, args: [{ selector: 'hello' },] }\n-      ];\n-      MyPipe.ctorParameters = () => [\n-        { type: ClassInject }\n-      ];`);\n-    expect(output).not.toContain('tslib');\n-  });\n-\n-  it('should not downlevel non-Angular class decorators', () => {\n-    const {output} = transform(`\n-      @SomeUnknownDecorator()\n-      export class MyClass {}\n-    `);\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).toContain(dedent`\n-      MyClass = (0, tslib_1.__decorate)([\n-        SomeUnknownDecorator()\n-      ], MyClass);\n-    `);\n-    expect(output).not.toContain('MyClass.decorators');\n-  });\n-\n-  it('should not downlevel non-Angular class decorators generated by a builder', () => {\n-    const {output} = transform(`\n-      @DecoratorBuilder().customClassDecorator\n-      export class MyClass {}\n-    `);\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).toContain(dedent`\n-      MyClass = (0, tslib_1.__decorate)([\n-        DecoratorBuilder().customClassDecorator\n-      ], MyClass);\n-    `);\n-    expect(output).not.toContain('MyClass.decorators');\n-  });\n-\n-  it('should downlevel Angular-decorated class member', () => {\n-    const {output} = transform(`\n-      import {Input} from '@angular/core';\n-\n-      export class MyDir {\n-        @Input() disabled: boolean = false;\n-      }\n-    `);\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).toContain(dedent`\n-      MyDir.propDecorators = {\n-        disabled: [{ type: core_1.Input }]\n-      };\n-    `);\n-    expect(output).not.toContain('tslib');\n-  });\n-\n-  it('should not downlevel class member with unknown decorator', () => {\n-    const {output} = transform(`\n-      export class MyDir {\n-        @SomeDecorator() disabled: boolean = false;\n-      }\n-    `);\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).toContain(dedent`\n-      (0, tslib_1.__decorate)([\n-        SomeDecorator()\n-      ], MyDir.prototype, \"disabled\", void 0);\n-    `);\n-    expect(output).not.toContain('MyClass.propDecorators');\n-  });\n-\n-  // Angular is not concerned with type information for decorated class members. Instead,\n-  // the type is omitted. This also helps with server side rendering as DOM globals which\n-  // are used as types, do not load at runtime. https://github.com/angular/angular/issues/30586.\n-  it('should downlevel Angular-decorated class member but not preserve type', () => {\n-    context.writeFile('/other-file.ts', `export class MyOtherClass {}`);\n-    const {output} = transform(`\n-      import {Input} from '@angular/core';\n-      import {MyOtherClass} from './other-file';\n-\n-      export class MyDir {\n-        @Input() trigger: HTMLElement;\n-        @Input() fromOtherFile: MyOtherClass;\n-      }\n-    `);\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).toContain(dedent`\n-      MyDir.propDecorators = {\n-        trigger: [{ type: core_1.Input }],\n-        fromOtherFile: [{ type: core_1.Input }]\n-      };\n-    `);\n-    expect(output).not.toContain('HTMLElement');\n-    expect(output).not.toContain('MyOtherClass');\n-  });\n-\n-  it('should capture constructor type metadata with `emitDecoratorMetadata` enabled', () => {\n-    context.writeFile('/other-file.ts', `export class MyOtherClass {}`);\n-    const {output} = transform(\n-        `\n-      import {Directive} from '@angular/core';\n-      import {MyOtherClass} from './other-file';\n-\n-      @Directive()\n-      export class MyDir {\n-        constructor(other: MyOtherClass) {}\n-      }\n-    `,\n-        {emitDecoratorMetadata: true});\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).toContain('const other_file_1 = require(\"./other-file\");');\n-    expect(output).toContain(dedent`\n-      MyDir.decorators = [\n-        { type: core_1.Directive }\n-      ];\n-      MyDir.ctorParameters = () => [\n-        { type: other_file_1.MyOtherClass }\n-      ];\n-    `);\n-  });\n-\n-  it('should capture constructor type metadata with `emitDecoratorMetadata` disabled', () => {\n-    context.writeFile('/other-file.ts', `export class MyOtherClass {}`);\n-    const {output, dtsOutput} = transform(\n-        `\n-      import {Directive} from '@angular/core';\n-      import {MyOtherClass} from './other-file';\n-\n-      @Directive()\n-      export class MyDir {\n-        constructor(other: MyOtherClass) {}\n-      }\n-    `,\n-        {emitDecoratorMetadata: false});\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).toContain('const other_file_1 = require(\"./other-file\");');\n-    expect(output).toContain(dedent`\n-      MyDir.decorators = [\n-        { type: core_1.Directive }\n-      ];\n-      MyDir.ctorParameters = () => [\n-        { type: other_file_1.MyOtherClass }\n-      ];\n-    `);\n-    expect(dtsOutput).toContain('import');\n-  });\n-\n-  it('should properly serialize constructor parameter with external qualified name type', () => {\n-    context.writeFile('/other-file.ts', `export class MyOtherClass {}`);\n-    const {output} = transform(`\n-      import {Directive} from '@angular/core';\n-      import * as externalFile from './other-file';\n-\n-      @Directive()\n-      export class MyDir {\n-        constructor(other: externalFile.MyOtherClass) {}\n-      }\n-    `);\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).toContain('const externalFile = require(\"./other-file\");');\n-    expect(output).toContain(dedent`\n-      MyDir.decorators = [\n-        { type: core_1.Directive }\n-      ];\n-      MyDir.ctorParameters = () => [\n-        { type: externalFile.MyOtherClass }\n-      ];\n-    `);\n-  });\n-\n-  it('should properly serialize constructor parameter with local qualified name type', () => {\n-    const {output} = transform(`\n-      import {Directive} from '@angular/core';\n-\n-      namespace other {\n-        export class OtherClass {}\n-      };\n-\n-      @Directive()\n-      export class MyDir {\n-        constructor(other: other.OtherClass) {}\n-      }\n-    `);\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).toContain('var other;');\n-    expect(output).toContain(dedent`\n-      MyDir.decorators = [\n-        { type: core_1.Directive }\n-      ];\n-      MyDir.ctorParameters = () => [\n-        { type: other.OtherClass }\n-      ];\n-    `);\n-  });\n-\n-  it('should properly downlevel constructor parameter decorators', () => {\n-    const {output} = transform(`\n-      import {Inject, Directive, DOCUMENT} from '@angular/core';\n-\n-      @Directive()\n-      export class MyDir {\n-        constructor(@Inject(DOCUMENT) document: Document) {}\n-      }\n-    `);\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).toContain(dedent`\n-      MyDir.decorators = [\n-        { type: core_1.Directive }\n-      ];\n-      MyDir.ctorParameters = () => [\n-        { type: Document, decorators: [{ type: core_1.Inject, args: [core_1.DOCUMENT,] }] }\n-      ];\n-    `);\n-  });\n-\n-  it('should properly downlevel constructor parameters with union type', () => {\n-    const {output} = transform(`\n-      import {Optional, Directive, NgZone} from '@angular/core';\n-\n-      @Directive()\n-      export class MyDir {\n-        constructor(@Optional() ngZone: NgZone|null) {}\n-      }\n-    `);\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).toContain(dedent`\n-      MyDir.decorators = [\n-        { type: core_1.Directive }\n-      ];\n-      MyDir.ctorParameters = () => [\n-        { type: core_1.NgZone, decorators: [{ type: core_1.Optional }] }\n-      ];\n-    `);\n-  });\n-\n-  it('should add @nocollapse if closure compiler is enabled', () => {\n-    isClosureEnabled = true;\n-    const {output} = transform(`\n-      import {Directive} from '@angular/core';\n-\n-      export class ClassInject {};\n-\n-      @Directive()\n-      export class MyDir {\n-        constructor(v: ClassInject) {}\n-      }\n-    `);\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).toContain(dedent`\n-      /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */\n-      MyDir.decorators = [\n-        { type: core_1.Directive }\n-      ];\n-    `);\n-    expect(output).toContain(dedent`\n-      /**\n-       * @type {function(): !Array<(null|{\n-       *   type: ?,\n-       *   decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>),\n-       * })>}\n-       * @nocollapse\n-       */\n-       MyDir.ctorParameters = () => [\n-        { type: ClassInject }\n-      ];\n-    `);\n-    expect(output).not.toContain('tslib');\n-  });\n-\n-  it('should not retain unused type imports due to decorator downleveling with ' +\n-         '`emitDecoratorMetadata` enabled.',\n-     () => {\n-       context.writeFile('/external.ts', `\n-      export class ErrorHandler {}\n-      export class ClassInject {}\n-    `);\n-       const {output} = transform(\n-           `\n-      import {Directive} from '@angular/core';\n-      import {ErrorHandler, ClassInject} from './external';\n-\n-      @Directive()\n-      export class MyDir {\n-        private _errorHandler: ErrorHandler;\n-        constructor(v: ClassInject) {}\n-      }\n-    `,\n-           {module: ts.ModuleKind.ES2015, emitDecoratorMetadata: true});\n-\n-       expect(diagnostics.length).toBe(0);\n-       expect(output).not.toContain('tslib');\n-       expect(output).not.toContain('ErrorHandler');\n-     });\n-\n-  it('should not retain unused type imports due to decorator downleveling with ' +\n-         '`emitDecoratorMetadata` disabled',\n-     () => {\n-       context.writeFile('/external.ts', `\n-      export class ErrorHandler {}\n-      export class ClassInject {}\n-    `);\n-       const {output} = transform(\n-           `\n-      import {Directive} from '@angular/core';\n-      import {ErrorHandler, ClassInject} from './external';\n-\n-      @Directive()\n-      export class MyDir {\n-        private _errorHandler: ErrorHandler;\n-        constructor(v: ClassInject) {}\n-      }\n-    `,\n-           {module: ts.ModuleKind.ES2015, emitDecoratorMetadata: false});\n-\n-       expect(diagnostics.length).toBe(0);\n-       expect(output).not.toContain('tslib');\n-       expect(output).not.toContain('ErrorHandler');\n-     });\n-\n-  it('should not generate invalid reference due to conflicting parameter name', () => {\n-    context.writeFile('/external.ts', `\n-      export class Dep {\n-        greet() {}\n-      }\n-    `);\n-    const {output} = transform(\n-        `\n-      import {Directive} from '@angular/core';\n-      import {Dep} from './external';\n-\n-      @Directive()\n-      export class MyDir {\n-        constructor(Dep: Dep) {\n-          Dep.greet();\n-        }\n-      }\n-    `,\n-        {emitDecoratorMetadata: false});\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).not.toContain('tslib');\n-    expect(output).toContain(`external_1 = require(\"./external\");`);\n-    expect(output).toContain(dedent`\n-      MyDir.decorators = [\n-        { type: core_1.Directive }\n-      ];\n-      MyDir.ctorParameters = () => [\n-        { type: external_1.Dep }\n-      ];\n-    `);\n-  });\n-\n-  it('should be able to serialize circular constructor parameter type', () => {\n-    const {output} = transform(`\n-      import {Directive, Optional, Inject, SkipSelf} from '@angular/core';\n-\n-      @Directive()\n-      export class MyDir {\n-        constructor(@Optional() @SkipSelf() @Inject(MyDir) parentDir: MyDir|null) {}\n-      }\n-    `);\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).toContain(dedent`\n-      MyDir.decorators = [\n-        { type: core_1.Directive }\n-      ];\n-      MyDir.ctorParameters = () => [\n-        { type: MyDir, decorators: [{ type: core_1.Optional }, { type: core_1.SkipSelf }, { type: core_1.Inject, args: [MyDir,] }] }\n-      ];\n-    `);\n-  });\n-\n-  it('should create diagnostic if property name is non-serializable', () => {\n-    transform(`\n-      import {Directive, ViewChild, TemplateRef} from '@angular/core';\n-\n-      @Directive()\n-      export class MyDir {\n-        @ViewChild(TemplateRef) ['some' + 'name']: TemplateRef<any>|undefined;\n-      }\n-    `);\n-\n-    expect(diagnostics.length).toBe(1);\n-    expect(diagnostics[0].messageText as string)\n-        .toBe(`Cannot process decorators for class element with non-analyzable name.`);\n-  });\n-\n-  it('should not capture constructor parameter types when not resolving to a value', () => {\n-    context.writeFile('/external.ts', `\n-      export interface IState {}\n-      export type IOverlay = {hello: true}&IState;\n-      export default interface {\n-        hello: false;\n-      }\n-      export const enum KeyCodes {A, B}\n-    `);\n-    const {output} = transform(`\n-      import {Directive, Inject} from '@angular/core';\n-      import * as angular from './external';\n-      import {IOverlay, KeyCodes} from './external';\n-      import TypeFromDefaultImport from './external';\n-\n-      @Directive()\n-      export class MyDir {\n-        constructor(@Inject('$state') param: angular.IState,\n-                    @Inject('$overlay') other: IOverlay,\n-                    @Inject('$default') default: TypeFromDefaultImport,\n-                    @Inject('$keyCodes') keyCodes: KeyCodes) {}\n-      }\n-    `);\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).not.toContain('external');\n-    expect(output).toContain(dedent`\n-      MyDir.decorators = [\n-        { type: core_1.Directive }\n-      ];\n-      MyDir.ctorParameters = () => [\n-        { type: undefined, decorators: [{ type: core_1.Inject, args: ['$state',] }] },\n-        { type: undefined, decorators: [{ type: core_1.Inject, args: ['$overlay',] }] },\n-        { type: undefined, decorators: [{ type: core_1.Inject, args: ['$default',] }] },\n-        { type: undefined, decorators: [{ type: core_1.Inject, args: ['$keyCodes',] }] }\n-      ];\n-    `);\n-  });\n-\n-  it('should allow preceding custom transformers to strip decorators', () => {\n-    const stripAllDecoratorsTransform: ts.TransformerFactory<ts.SourceFile> = context => {\n-      return (sourceFile: ts.SourceFile) => {\n-        const visitNode = (node: ts.Node): ts.Node => {\n-          if (ts.isClassDeclaration(node) || ts.isClassElement(node)) {\n-            const cloned = ts.getMutableClone(node);\n-            (cloned.decorators as undefined) = undefined;\n-            return cloned;\n-          }\n-          return ts.visitEachChild(node, visitNode, context);\n-        };\n-        return visitNode(sourceFile) as ts.SourceFile;\n-      };\n-    };\n-\n-    const {output} = transform(\n-        `\n-      import {Directive} from '@angular/core';\n-\n-      export class MyInjectedClass {}\n-\n-      @Directive()\n-      export class MyDir {\n-        constructor(someToken: MyInjectedClass) {}\n-      }\n-    `,\n-        {}, [stripAllDecoratorsTransform]);\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).not.toContain('MyDir.decorators');\n-    expect(output).not.toContain('MyDir.ctorParameters');\n-    expect(output).not.toContain('tslib');\n-  });\n-\n-  it('should capture a non-const enum used as a constructor type', () => {\n-    const {output} = transform(`\n-      import {Component} from '@angular/core';\n-\n-      export enum Values {A, B};\n-\n-      @Component({template: 'hello'})\n-      export class MyComp {\n-        constructor(v: Values) {}\n-      }\n-    `);\n-\n-    expect(diagnostics.length).toBe(0);\n-    expect(output).toContain(dedent`\n-      MyComp.decorators = [\n-        { type: core_1.Component, args: [{ template: 'hello' },] }\n-      ];\n-      MyComp.ctorParameters = () => [\n-        { type: Values }\n-      ];`);\n-    expect(output).not.toContain('tslib');\n-  });\n-\n-  describe('class decorators skipped', () => {\n-    beforeEach(() => skipClassDecorators = true);\n-\n-    it('should not downlevel Angular class decorators', () => {\n-      const {output} = transform(`\n-        import {Injectable} from '@angular/core';\n-\n-        @Injectable()\n-        export class MyService {}\n-      `);\n-\n-      expect(diagnostics.length).toBe(0);\n-      expect(output).not.toContain('MyService.decorators');\n-      expect(output).toContain(dedent`\n-        MyService = (0, tslib_1.__decorate)([\n-          (0, core_1.Injectable)()\n-        ], MyService);\n-      `);\n-    });\n-\n-    it('should downlevel constructor parameters', () => {\n-      const {output} = transform(`\n-        import {Injectable} from '@angular/core';\n-\n-        @Injectable()\n-        export class InjectClass {}\n-\n-        @Injectable()\n-        export class MyService {\n-          constructor(dep: InjectClass) {}\n-        }\n-      `);\n-\n-      expect(diagnostics.length).toBe(0);\n-      expect(output).not.toContain('MyService.decorators');\n-      expect(output).toContain('MyService.ctorParameters');\n-      expect(output).toContain(dedent`\n-        MyService.ctorParameters = () => [\n-          { type: InjectClass }\n-        ];\n-        MyService = (0, tslib_1.__decorate)([\n-          (0, core_1.Injectable)()\n-        ], MyService);\n-      `);\n-    });\n-\n-    it('should downlevel constructor parameter decorators', () => {\n-      const {output} = transform(`\n-        import {Injectable, Inject} from '@angular/core';\n-\n-        @Injectable()\n-        export class InjectClass {}\n-\n-        @Injectable()\n-        export class MyService {\n-          constructor(@Inject('test') dep: InjectClass) {}\n-        }\n-      `);\n-\n-      expect(diagnostics.length).toBe(0);\n-      expect(output).not.toContain('MyService.decorators');\n-      expect(output).toContain('MyService.ctorParameters');\n-      expect(output).toContain(dedent`\n-        MyService.ctorParameters = () => [\n-          { type: InjectClass, decorators: [{ type: core_1.Inject, args: ['test',] }] }\n-        ];\n-        MyService = (0, tslib_1.__decorate)([\n-          (0, core_1.Injectable)()\n-        ], MyService);\n-      `);\n-    });\n-\n-    it('should downlevel class member Angular decorators', () => {\n-      const {output} = transform(`\n-        import {Injectable, Input} from '@angular/core';\n-\n-        export class MyService {\n-          @Input() disabled: boolean;\n-        }\n-      `);\n-\n-      expect(diagnostics.length).toBe(0);\n-      expect(output).not.toContain('tslib');\n-      expect(output).toContain(dedent`\n-        MyService.propDecorators = {\n-          disabled: [{ type: core_1.Input }]\n-        };\n-      `);\n-    });\n-  });\n-\n-  describe('transforming multiple files', () => {\n-    it('should work correctly for multiple files that import distinct declarations', () => {\n-      context.writeFile('foo_service.d.ts', `\n-        export declare class Foo {};\n-      `);\n-      context.writeFile('foo.ts', `\n-        import {Injectable} from '@angular/core';\n-        import {Foo} from './foo_service';\n-\n-        @Injectable()\n-        export class MyService {\n-          constructor(foo: Foo) {}\n-        }\n-      `);\n-\n-      context.writeFile('bar_service.d.ts', `\n-        export declare class Bar {};\n-      `);\n-      context.writeFile('bar.ts', `\n-        import {Injectable} from '@angular/core';\n-        import {Bar} from './bar_service';\n-\n-        @Injectable()\n-        export class MyService {\n-          constructor(bar: Bar) {}\n-        }\n-      `);\n-\n-      const {program, transformers} = createProgramWithTransform(['/foo.ts', '/bar.ts']);\n-      program.emit(undefined, undefined, undefined, undefined, transformers);\n-\n-      expect(context.readFile('/foo.js')).toContain(`import { Foo } from './foo_service';`);\n-      expect(context.readFile('/bar.js')).toContain(`import { Bar } from './bar_service';`);\n-    });\n-\n-    it('should not result in a stack overflow for a large number of files', () => {\n-      // The decorators transform used to patch `ts.EmitResolver.isReferencedAliasDeclaration`\n-      // repeatedly for each source file in the program, causing a stack overflow once a large\n-      // number of source files was reached. This test verifies that emit succeeds even when there's\n-      // lots of source files. See https://github.com/angular/angular/issues/40276.\n-      context.writeFile('foo.d.ts', `\n-        export declare class Foo {};\n-      `);\n-\n-      // A somewhat minimal number of source files that used to trigger a stack overflow.\n-      const numberOfTestFiles = 6500;\n-      const files: string[] = [];\n-      for (let i = 0; i < numberOfTestFiles; i++) {\n-        const file = `/${i}.ts`;\n-        files.push(file);\n-        context.writeFile(file, `\n-          import {Injectable} from '@angular/core';\n-          import {Foo} from './foo';\n-\n-          @Injectable()\n-          export class MyService {\n-            constructor(foo: Foo) {}\n-          }\n-        `);\n-      }\n-\n-      const {program, transformers} = createProgramWithTransform(files);\n-\n-      let written = 0;\n-      program.emit(undefined, (fileName, outputText) => {\n-        written++;\n-\n-        // The below assertion throws an explicit error instead of using a Jasmine expectation,\n-        // as we want to abort on the first failure, if any. This avoids as many as `numberOfFiles`\n-        // expectation failures, which would bloat the test output.\n-        if (!outputText.includes(`import { Foo } from './foo';`)) {\n-          throw new Error(`Transform failed to preserve the import in ${fileName}:\\n${outputText}`);\n-        }\n-      }, undefined, undefined, transformers);\n-      expect(written).toBe(numberOfTestFiles);\n-    });\n-\n-    function createProgramWithTransform(files: string[]) {\n-      const program = ts.createProgram(\n-          files, {\n-            moduleResolution: ts.ModuleResolutionKind.NodeJs,\n-            importHelpers: true,\n-            lib: [],\n-            module: ts.ModuleKind.ESNext,\n-            target: ts.ScriptTarget.Latest,\n-            declaration: false,\n-            experimentalDecorators: true,\n-            emitDecoratorMetadata: false,\n-          },\n-          host);\n-      const typeChecker = program.getTypeChecker();\n-      const reflectionHost = new TypeScriptReflectionHost(typeChecker);\n-      const transformers: ts.CustomTransformers = {\n-        before: [getDownlevelDecoratorsTransform(\n-            program.getTypeChecker(), reflectionHost, diagnostics,\n-            /* isCore */ false, isClosureEnabled, skipClassDecorators)]\n-      };\n-      return {program, transformers};\n-    }\n-  });\n-});\n-\n-/** Template string function that can be used to dedent a given string literal. */\n-export function dedent(strings: TemplateStringsArray, ...values: any[]) {\n-  let joinedString = '';\n-  for (let i = 0; i < values.length; i++) {\n-    joinedString += `${strings[i]}${values[i]}`;\n-  }\n-  joinedString += strings[strings.length - 1];\n-  return omitLeadingWhitespace(joinedString);\n-}\n-\n-/** Omits the leading whitespace for each line of the given text. */\n-function omitLeadingWhitespace(text: string): string {\n-  return text.replace(/^\\s+/gm, '');\n-}"
        },
        {
            "sha": "23e6e89f2b706a94e2a0711b52b7ca6b5e87083c",
            "filename": "packages/compiler-cli/test/transformers/inline_resources_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 194,
            "changes": 194,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Finline_resources_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Finline_resources_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Finline_resources_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,194 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {isClassMetadata, MetadataCollector} from '../../src/metadata/index';\n-import {getInlineResourcesTransformFactory, InlineResourcesMetadataTransformer} from '../../src/transformers/inline_resources';\n-import {MetadataCache} from '../../src/transformers/metadata_cache';\n-import {MockAotContext, MockCompilerHost} from '../mocks';\n-\n-describe('inline resources transformer', () => {\n-  describe('decorator input', () => {\n-    describe('should not touch unrecognized decorators', () => {\n-      it('Not from @angular/core', () => {\n-        expect(convert(`declare const Component: Function;\n-          @Component({templateUrl: './thing.html'}) class Foo {}`))\n-            .toContain('templateUrl');\n-      });\n-      it('missing @ sign', () => {\n-        expect(convert(`import {Component} from '@angular/core';\n-          Component({templateUrl: './thing.html'}) class Foo {}`))\n-            .toContain('templateUrl');\n-      });\n-      it('too many arguments to @Component', () => {\n-        expect(convert(`import {Component} from '@angular/core';\n-          @Component(1, {templateUrl: './thing.html'}) class Foo {}`))\n-            .toContain('templateUrl');\n-      });\n-      it('wrong argument type to @Component', () => {\n-        expect(convert(`import {Component} from '@angular/core';\n-          @Component([{templateUrl: './thing.html'}]) class Foo {}`))\n-            .toContain('templateUrl');\n-      });\n-    });\n-\n-    it('should replace templateUrl', () => {\n-      const actual = convert(`import {Component} from '@angular/core';\n-        @Component({\n-          templateUrl: './thing.html',\n-\t        otherProp: 3,\n-\t      }) export class Foo {}`);\n-      expect(actual).not.toContain('templateUrl:');\n-      expect(actual.replace(/\\s+/g, ' '))\n-          .toContain(\n-              'Foo = __decorate([ (0, core_1.Component)({ template: \"Some template\", otherProp: 3 }) ], Foo)');\n-    });\n-    it('should allow different quotes', () => {\n-      const actual = convert(`import {Component} from '@angular/core';\n-        @Component({\"templateUrl\": \\`./thing.html\\`}) export class Foo {}`);\n-      expect(actual).not.toContain('templateUrl:');\n-      expect(actual).toContain('{ template: \"Some template\" }');\n-    });\n-    it('should replace styleUrls', () => {\n-      const actual = convert(`import {Component} from '@angular/core';\n-        @Component({\n-          styleUrls: ['./thing1.css', './thing2.css'],\n-        })\n-        export class Foo {}`);\n-      expect(actual).not.toContain('styleUrls:');\n-      expect(actual).toContain('styles: [\".some_style {}\", \".some_other_style {}\"]');\n-    });\n-    it('should preserve existing styles', () => {\n-      const actual = convert(`import {Component} from '@angular/core';\n-        @Component({\n-          styles: ['h1 { color: blue }'],\n-          styleUrls: ['./thing1.css'],\n-        })\n-        export class Foo {}`);\n-      expect(actual).not.toContain('styleUrls:');\n-      expect(actual).toContain(`styles: ['h1 { color: blue }', \".some_style {}\"]`);\n-    });\n-    it('should handle empty styleUrls', () => {\n-      const actual = convert(`import {Component} from '@angular/core';\n-        @Component({styleUrls: [], styles: []}) export class Foo {}`);\n-      expect(actual).not.toContain('styleUrls:');\n-      expect(actual).not.toContain('styles:');\n-    });\n-  });\n-  describe('annotation input', () => {\n-    it('should replace templateUrl', () => {\n-      const actual = convert(`import {Component} from '@angular/core';\n-      declare const NotComponent: Function;\n-\n-      export class Foo {\n-        static decorators: {type: Function, args?: any[]}[] = [\n-          {\n-            type: NotComponent,\n-            args: [],\n-          },{\n-            type: Component,\n-            args: [{\n-              templateUrl: './thing.html'\n-          }],\n-        }];\n-      }\n-    `);\n-      expect(actual).not.toContain('templateUrl:');\n-      expect(actual.replace(/\\s+/g, ' '))\n-          .toMatch(\n-              /Foo\\.decorators = [{ .*type: core_1\\.Component, args: [{ template: \"Some template\" }]/);\n-    });\n-    it('should replace styleUrls', () => {\n-      const actual = convert(`import {Component} from '@angular/core';\n-      declare const NotComponent: Function;\n-\n-      export class Foo {\n-        static decorators: {type: Function, args?: any[]}[] = [{\n-          type: Component,\n-          args: [{\n-            styleUrls: ['./thing1.css', './thing2.css'],\n-          }],\n-        }];\n-      }\n-    `);\n-      expect(actual).not.toContain('styleUrls:');\n-      expect(actual.replace(/\\s+/g, ' '))\n-          .toMatch(\n-              /Foo\\.decorators = [{ .*type: core_1\\.Component, args: [{ style: \"Some template\" }]/);\n-    });\n-  });\n-});\n-\n-describe('metadata transformer', () => {\n-  it('should transform decorators', () => {\n-    const source = `import {Component} from '@angular/core';\n-      @Component({\n-        templateUrl: './thing.html',\n-        styleUrls: ['./thing1.css', './thing2.css'],\n-        styles: ['h1 { color: red }'],\n-      })\n-      export class Foo {}\n-    `;\n-    const sourceFile = ts.createSourceFile(\n-        'someFile.ts', source, ts.ScriptTarget.Latest, /* setParentNodes */ true);\n-    const cache = new MetadataCache(\n-        new MetadataCollector(), /* strict */ true,\n-        [new InlineResourcesMetadataTransformer(\n-            {loadResource, resourceNameToFileName: (u: string) => u})]);\n-    const metadata = cache.getMetadata(sourceFile);\n-    expect(metadata).toBeDefined('Expected metadata from test source file');\n-    if (metadata) {\n-      const classData = metadata.metadata['Foo'];\n-      expect(classData && isClassMetadata(classData))\n-          .toBeDefined(`Expected metadata to contain data for Foo`);\n-      if (classData && isClassMetadata(classData)) {\n-        expect(JSON.stringify(classData)).not.toContain('templateUrl');\n-        expect(JSON.stringify(classData)).toContain('\"template\":\"Some template\"');\n-        expect(JSON.stringify(classData)).not.toContain('styleUrls');\n-        expect(JSON.stringify(classData))\n-            .toContain('\"styles\":[\"h1 { color: red }\",\".some_style {}\",\".some_other_style {}\"]');\n-      }\n-    }\n-  });\n-});\n-\n-function loadResource(path: string): Promise<string>|string {\n-  if (path === './thing.html') return 'Some template';\n-  if (path === './thing1.css') return '.some_style {}';\n-  if (path === './thing2.css') return '.some_other_style {}';\n-  throw new Error('No fake data for path ' + path);\n-}\n-\n-function convert(source: string) {\n-  const baseFileName = 'someFile';\n-  const moduleName = '/' + baseFileName;\n-  const fileName = moduleName + '.ts';\n-  const context = new MockAotContext('/', {[baseFileName + '.ts']: source});\n-  const host = new MockCompilerHost(context);\n-\n-  const program = ts.createProgram(\n-      [fileName], {\n-        module: ts.ModuleKind.CommonJS,\n-        target: ts.ScriptTarget.ES2017,\n-      },\n-      host);\n-  const moduleSourceFile = program.getSourceFile(fileName);\n-  const transformers: ts.CustomTransformers = {\n-    before: [getInlineResourcesTransformFactory(\n-        program, {loadResource, resourceNameToFileName: (u: string) => u})]\n-  };\n-  let result = '';\n-  program.emit(\n-      moduleSourceFile, (emittedFileName, data, writeByteOrderMark, onError, sourceFiles) => {\n-        if (fileName.startsWith(moduleName)) {\n-          result = data;\n-        }\n-      }, undefined, undefined, transformers);\n-  return result;\n-}"
        },
        {
            "sha": "d3d983c2391d935297c7a7252e83d4c9247d0f54",
            "filename": "packages/compiler-cli/test/transformers/lower_expressions_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 262,
            "changes": 262,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Flower_expressions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Flower_expressions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Flower_expressions_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,262 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {MetadataCollector, ModuleMetadata} from '../../src/metadata/index';\n-import {getExpressionLoweringTransformFactory, LoweringRequest, LowerMetadataTransform, RequestLocationMap} from '../../src/transformers/lower_expressions';\n-import {MetadataCache} from '../../src/transformers/metadata_cache';\n-import {Directory, MockAotContext, MockCompilerHost} from '../mocks';\n-\n-const DEFAULT_FIELDS_TO_LOWER = ['useFactory', 'useValue', 'data'];\n-\n-describe('Expression lowering', () => {\n-  describe('transform', () => {\n-    it('should be able to lower a simple expression', () => {\n-      expect(convert('const a = 1 +◊b: 2◊;')).toBe('const b = 2; const a = 1 + b; export { b };');\n-    });\n-\n-    it('should be able to lower an expression in a decorator', () => {\n-      expect(convert(`\n-          import {Component} from '@angular/core';\n-\n-          @Component({\n-            provider: [{provide: 'someToken', useFactory:◊l: () => null◊}]\n-          })\n-          class MyClass {}\n-      `)).toContain('const l = () => null; exports.l = l;');\n-    });\n-\n-    it('should be able to export a variable if the whole value is lowered', () => {\n-      expect(convert('/*a*/ const a =◊b: () => null◊;'))\n-          .toBe('/*a*/ const a = () => null; const b = a; export { b };');\n-    });\n-  });\n-\n-  describe('collector', () => {\n-    it('should request a lowering for useValue', () => {\n-      const collected = collect(`\n-        import {Component} from '@angular/core';\n-\n-        enum SomeEnum {\n-          OK,\n-          NotOK\n-        }\n-\n-        @Component({\n-          provider: [{provide: 'someToken', useValue:◊enum: SomeEnum.OK◊}]\n-        })\n-        export class MyClass {}\n-      `);\n-      expect(collected.requests.has(collected.annotations[0].start))\n-          .toBeTruthy('did not find the useValue');\n-    });\n-\n-    it('should not request a lowering for useValue with a reference to a static property', () => {\n-      const collected = collect(`\n-        import {Component} from '@angular/core';\n-\n-        @Component({\n-          provider: [{provide: 'someToken', useValue:◊value: MyClass.someMethod◊}]\n-        })\n-        export class MyClass {\n-          static someMethod() {}\n-        }\n-      `);\n-      expect(collected.requests.size).toBe(0);\n-    });\n-\n-    it('should request a lowering for useFactory', () => {\n-      const collected = collect(`\n-        import {Component} from '@angular/core';\n-\n-        @Component({\n-          provider: [{provide: 'someToken', useFactory:◊lambda: () => null◊}]\n-        })\n-        export class MyClass {}\n-      `);\n-      expect(collected.requests.has(collected.annotations[0].start))\n-          .toBeTruthy('did not find the useFactory');\n-    });\n-\n-    it('should request a lowering for data', () => {\n-      const collected = collect(`\n-        import {Component} from '@angular/core';\n-\n-        enum SomeEnum {\n-          OK,\n-          NotOK\n-        }\n-\n-        @Component({\n-          provider: [{provide: 'someToken', data:◊enum: SomeEnum.OK◊}]\n-        })\n-        export class MyClass {}\n-      `);\n-      expect(collected.requests.has(collected.annotations[0].start))\n-          .toBeTruthy('did not find the data field');\n-    });\n-\n-    it('should not lower a non-module', () => {\n-      const collected = collect(`\n-          declare const global: any;\n-          const ngDevMode: boolean = (function(global: any) {\n-            return global.ngDevMode = true;\n-          })(typeof window != 'undefined' && window || typeof self != 'undefined' && self || typeof global != 'undefined' && global);\n-       `);\n-      expect(collected.requests.size).toBe(0, 'unexpected rewriting');\n-    });\n-\n-    it('should throw a validation exception for invalid files', () => {\n-      const cache = new MetadataCache(\n-          new MetadataCollector({}), /* strict */ true,\n-          [new LowerMetadataTransform(DEFAULT_FIELDS_TO_LOWER)]);\n-      const sourceFile = ts.createSourceFile(\n-          'foo.ts', `\n-        import {Injectable} from '@angular/core';\n-\n-        class SomeLocalClass {}\n-        @Injectable()\n-        export class SomeClass {\n-          constructor(a: SomeLocalClass) {}\n-        }\n-      `,\n-          ts.ScriptTarget.Latest, true);\n-      expect(() => cache.getMetadata(sourceFile)).toThrow();\n-    });\n-\n-    it('should not report validation errors on a .d.ts file', () => {\n-      const cache = new MetadataCache(\n-          new MetadataCollector({}), /* strict */ true,\n-          [new LowerMetadataTransform(DEFAULT_FIELDS_TO_LOWER)]);\n-      const dtsFile = ts.createSourceFile(\n-          'foo.d.ts', `\n-        import {Injectable} from '@angular/core';\n-\n-        class SomeLocalClass {}\n-        @Injectable()\n-        export class SomeClass {\n-          constructor(a: SomeLocalClass) {}\n-        }\n-      `,\n-          ts.ScriptTarget.Latest, true);\n-      expect(() => cache.getMetadata(dtsFile)).not.toThrow();\n-    });\n-  });\n-});\n-\n-// Helpers\n-\n-interface Annotation {\n-  start: number;\n-  length: number;\n-  name: string;\n-}\n-\n-function getAnnotations(annotatedSource: string):\n-    {unannotatedSource: string, annotations: Annotation[]} {\n-  const annotations: {start: number, length: number, name: string}[] = [];\n-  let adjustment = 0;\n-  const unannotatedSource = annotatedSource.replace(\n-      /◊([a-zA-Z]+):(.*)◊/g,\n-      (text: string, name: string, source: string, index: number): string => {\n-        annotations.push({start: index + adjustment, length: source.length, name});\n-        adjustment -= text.length - source.length;\n-        return source;\n-      });\n-  return {unannotatedSource, annotations};\n-}\n-\n-// Transform helpers\n-\n-function convert(annotatedSource: string) {\n-  const {annotations, unannotatedSource} = getAnnotations(annotatedSource);\n-\n-  const baseFileName = 'someFile';\n-  const moduleName = '/' + baseFileName;\n-  const fileName = moduleName + '.ts';\n-  const context = new MockAotContext('/', {[baseFileName + '.ts']: unannotatedSource});\n-  const host = new MockCompilerHost(context);\n-\n-  const sourceFile = ts.createSourceFile(\n-      fileName, unannotatedSource, ts.ScriptTarget.Latest, /* setParentNodes */ true);\n-  const requests = new Map<number, LoweringRequest>();\n-\n-  for (const annotation of annotations) {\n-    const node = findNode(sourceFile, annotation.start, annotation.length);\n-    if (!node) throw new Error('Invalid test specification. Could not find the node to substitute');\n-    const location = node.pos;\n-    requests.set(location, {name: annotation.name, kind: node.kind, location, end: node.end});\n-  }\n-\n-  const program = ts.createProgram(\n-      [fileName], {module: ts.ModuleKind.CommonJS, target: ts.ScriptTarget.ES2017}, host);\n-  const moduleSourceFile = program.getSourceFile(fileName)!;\n-  const transformers: ts.CustomTransformers = {\n-    before: [getExpressionLoweringTransformFactory(\n-        {\n-          getRequests(sourceFile: ts.SourceFile): RequestLocationMap {\n-            if (sourceFile.fileName == moduleSourceFile.fileName) {\n-              return requests;\n-            } else {\n-              return new Map();\n-            }\n-          }\n-        },\n-        program)]\n-  };\n-  let result: string = '';\n-  const emitResult = program.emit(\n-      moduleSourceFile, (emittedFileName, data, writeByteOrderMark, onError, sourceFiles) => {\n-        if (fileName.startsWith(moduleName)) {\n-          result = data;\n-        }\n-      }, undefined, undefined, transformers);\n-  return normalizeResult(result);\n-}\n-\n-function findNode(node: ts.Node, start: number, length: number): ts.Node|undefined {\n-  function find(node: ts.Node): ts.Node|undefined {\n-    if (node.getFullStart() == start && node.getEnd() == start + length) {\n-      return node;\n-    }\n-    if (node.getFullStart() <= start && node.getEnd() >= start + length) {\n-      return ts.forEachChild(node, find);\n-    }\n-  }\n-  return ts.forEachChild(node, find);\n-}\n-\n-function normalizeResult(result: string): string {\n-  // Remove TypeScript prefixes\n-  // Remove new lines\n-  // Squish adjacent spaces\n-  // Remove prefix and postfix spaces\n-  return result.replace('\"use strict\";', ' ')\n-      .replace('exports.__esModule = true;', ' ')\n-      .replace('Object.defineProperty(exports, \"__esModule\", { value: true });', ' ')\n-      .replace(/\\n/g, ' ')\n-      .replace(/ +/g, ' ')\n-      .replace(/^ /g, '')\n-      .replace(/ $/g, '');\n-}\n-\n-// Collector helpers\n-\n-function collect(annotatedSource: string) {\n-  const {annotations, unannotatedSource} = getAnnotations(annotatedSource);\n-  const transformer = new LowerMetadataTransform(DEFAULT_FIELDS_TO_LOWER);\n-  const cache = new MetadataCache(new MetadataCollector({}), false, [transformer]);\n-  const sourceFile = ts.createSourceFile(\n-      'someName.ts', unannotatedSource, ts.ScriptTarget.Latest, /* setParentNodes */ true);\n-  return {\n-    metadata: cache.getMetadata(sourceFile),\n-    requests: transformer.getRequests(sourceFile),\n-    annotations\n-  };\n-}"
        },
        {
            "sha": "ec941df1746a4d4b9a5a5007021aab6d90dd04b7",
            "filename": "packages/compiler-cli/test/transformers/metadata_reader_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 178,
            "changes": 178,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fmetadata_reader_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fmetadata_reader_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fmetadata_reader_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,178 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {METADATA_VERSION, MetadataCollector, ModuleMetadata} from '../../src/metadata';\n-import {MetadataReaderHost, readMetadata} from '../../src/transformers/metadata_reader';\n-import {Directory, Entry, MockAotContext} from '../mocks';\n-\n-describe('metadata reader', () => {\n-  let host: MetadataReaderHost;\n-\n-  beforeEach(() => {\n-    const context = new MockAotContext('/tmp/src', clone(FILES));\n-    const metadataCollector = new MetadataCollector();\n-    host = {\n-      fileExists: (fileName) => context.fileExists(fileName),\n-      readFile: (fileName) => context.readFile(fileName),\n-      getSourceFileMetadata: (fileName) => {\n-        const sourceText = context.readFile(fileName);\n-        return sourceText != null ? metadataCollector.getMetadata(ts.createSourceFile(\n-                                        fileName, sourceText, ts.ScriptTarget.Latest)) :\n-                                    undefined;\n-      },\n-    };\n-  });\n-\n-\n-  it('should be able to read a metadata file', () => {\n-    expect(readMetadata('node_modules/@angular/core.d.ts', host)).toEqual([\n-      {__symbolic: 'module', version: METADATA_VERSION, metadata: {foo: {__symbolic: 'class'}}}\n-    ]);\n-  });\n-\n-  it('should be able to read metadata from an otherwise unused .d.ts file ', () => {\n-    expect(readMetadata('node_modules/@angular/unused.d.ts', host)).toEqual([dummyMetadata]);\n-  });\n-\n-  it('should be able to read empty metadata ', () => {\n-    expect(readMetadata('node_modules/@angular/empty.d.ts', host)).toEqual([]);\n-  });\n-\n-  it('should return undefined for missing modules', () => {\n-    expect(readMetadata('node_modules/@angular/missing.d.ts', host)).toBeUndefined();\n-  });\n-\n-  it(`should add missing v${METADATA_VERSION} metadata from v1 metadata and .d.ts files`, () => {\n-    expect(readMetadata('metadata_versions/v1.d.ts', host)).toEqual([\n-      {__symbolic: 'module', version: 1, metadata: {foo: {__symbolic: 'class'}}}, {\n-        __symbolic: 'module',\n-        version: METADATA_VERSION,\n-        metadata: {\n-          foo: {__symbolic: 'class'},\n-          aType: {__symbolic: 'interface'},\n-          Bar: {__symbolic: 'class', members: {ngOnInit: [{__symbolic: 'method'}]}},\n-          BarChild: {__symbolic: 'class', extends: {__symbolic: 'reference', name: 'Bar'}},\n-          ReExport: {__symbolic: 'reference', module: './lib/utils2', name: 'ReExport'},\n-        },\n-        exports: [{from: './lib/utils2', export: ['Export']}],\n-      }\n-    ]);\n-  });\n-\n-  it(`should upgrade a missing metadata file into v${METADATA_VERSION}`, () => {\n-    expect(readMetadata('metadata_versions/v1_empty.d.ts', host)).toEqual([{\n-      __symbolic: 'module',\n-      version: METADATA_VERSION,\n-      metadata: {},\n-      exports: [{from: './lib/utils'}]\n-    }]);\n-  });\n-\n-  it(`should upgrade v3 metadata into v${METADATA_VERSION}`, () => {\n-    expect(readMetadata('metadata_versions/v3.d.ts', host)).toEqual([\n-      {__symbolic: 'module', version: 3, metadata: {foo: {__symbolic: 'class'}}}, {\n-        __symbolic: 'module',\n-        version: METADATA_VERSION,\n-        metadata: {\n-          foo: {__symbolic: 'class'},\n-          aType: {__symbolic: 'interface'},\n-          Bar: {__symbolic: 'class', members: {ngOnInit: [{__symbolic: 'method'}]}},\n-          BarChild: {__symbolic: 'class', extends: {__symbolic: 'reference', name: 'Bar'}},\n-          ReExport: {__symbolic: 'reference', module: './lib/utils2', name: 'ReExport'},\n-        }\n-        // Note: exports is missing because it was elided in the original.\n-      }\n-    ]);\n-  });\n-});\n-\n-const dummyModule = 'export let foo: any[];';\n-const dummyMetadata: ModuleMetadata = {\n-  __symbolic: 'module',\n-  version: METADATA_VERSION,\n-  metadata:\n-      {foo: {__symbolic: 'error', message: 'Variable not initialized', line: 0, character: 11}}\n-};\n-const FILES: Entry = {\n-  'tmp': {\n-    'src': {\n-      'main.ts': `\n-        import * as c from '@angular/core';\n-        import * as r from '@angular/router';\n-        import * as u from './lib/utils';\n-        import * as cs from './lib/collections';\n-        import * as u2 from './lib2/utils2';\n-      `,\n-      'lib': {\n-        'utils.ts': dummyModule,\n-        'collections.ts': dummyModule,\n-      },\n-      'lib2': {'utils2.ts': dummyModule},\n-      'node_modules': {\n-        '@angular': {\n-          'core.d.ts': dummyModule,\n-          'core.metadata.json': `{\"__symbolic\":\"module\", \"version\": ${\n-              METADATA_VERSION}, \"metadata\": {\"foo\": {\"__symbolic\": \"class\"}}}`,\n-          'router': {'index.d.ts': dummyModule, 'src': {'providers.d.ts': dummyModule}},\n-          'unused.d.ts': dummyModule,\n-          'empty.d.ts': 'export declare var a: string;',\n-          'empty.metadata.json': '[]',\n-        }\n-      },\n-      'metadata_versions': {\n-        'v1.d.ts': `\n-          import {ReExport} from './lib/utils2';\n-          export {ReExport};\n-\n-          export {Export} from './lib/utils2';\n-\n-          export type aType = number;\n-\n-          export declare class Bar {\n-            ngOnInit() {}\n-          }\n-          export declare class BarChild extends Bar {}\n-        `,\n-        'v1.metadata.json':\n-            `{\"__symbolic\":\"module\", \"version\": 1, \"metadata\": {\"foo\": {\"__symbolic\": \"class\"}}}`,\n-        'v1_empty.d.ts': `\n-          export * from './lib/utils';\n-        `,\n-        'v3.d.ts': `\n-          import {ReExport} from './lib/utils2';\n-          export {ReExport};\n-\n-          export {Export} from './lib/utils2';\n-\n-          export type aType = number;\n-\n-          export declare class Bar {\n-            ngOnInit() {}\n-          }\n-          export declare class BarChild extends Bar {}\n-        `,\n-        'v3.metadata.json':\n-            `{\"__symbolic\":\"module\", \"version\": 3, \"metadata\": {\"foo\": {\"__symbolic\": \"class\"}}}`,\n-      }\n-    }\n-  }\n-};\n-\n-function clone(entry: Entry): Entry {\n-  if (typeof entry === 'string') {\n-    return entry;\n-  } else {\n-    const result: Directory = {};\n-    for (const name in entry) {\n-      result[name] = clone(entry[name]);\n-    }\n-    return result;\n-  }\n-}"
        },
        {
            "sha": "0f1cf4bc939d50fdc8a1f08143fd4c99f3b90e03",
            "filename": "packages/compiler-cli/test/transformers/node_emitter_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 612,
            "changes": 612,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fnode_emitter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fnode_emitter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fnode_emitter_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,612 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ParseLocation, ParseSourceFile, ParseSourceSpan} from '@angular/compiler';\n-import * as o from '@angular/compiler/src/output/output_ast';\n-import ts from 'typescript';\n-\n-import {TypeScriptNodeEmitter} from '../../src/transformers/node_emitter';\n-import {Directory, MockAotContext, MockCompilerHost} from '../mocks';\n-\n-const sourceMap = require('source-map');\n-\n-const someGenFilePath = '/somePackage/someGenFile';\n-const someGenFileName = someGenFilePath + '.ts';\n-const anotherModuleUrl = '/somePackage/someOtherPath';\n-\n-const sameModuleIdentifier = new o.ExternalReference(null, 'someLocalId', null);\n-\n-const externalModuleIdentifier = new o.ExternalReference(anotherModuleUrl, 'someExternalId', null);\n-\n-describe('TypeScriptNodeEmitter', () => {\n-  let context: MockAotContext;\n-  let host: MockCompilerHost;\n-  let emitter: TypeScriptNodeEmitter;\n-  let someVar: o.ReadVarExpr;\n-\n-  beforeEach(() => {\n-    context = new MockAotContext('/', FILES);\n-    host = new MockCompilerHost(context);\n-    emitter = new TypeScriptNodeEmitter(false);\n-    someVar = o.variable('someVar', null, null);\n-  });\n-\n-  function emitStmt(\n-      stmt: o.Statement|o.Statement[], format: Format = Format.Flat, preamble?: string): string {\n-    const stmts = Array.isArray(stmt) ? stmt : [stmt];\n-\n-    const program = ts.createProgram(\n-        [someGenFileName], {module: ts.ModuleKind.CommonJS, target: ts.ScriptTarget.ES2017}, host);\n-    const moduleSourceFile = program.getSourceFile(someGenFileName);\n-    const transformers: ts.CustomTransformers = {\n-      before: [() => {\n-        return sourceFile => {\n-          const [newSourceFile] = emitter.updateSourceFile(sourceFile, stmts, preamble);\n-          return newSourceFile;\n-        };\n-      }]\n-    };\n-    let result: string = '';\n-    program.emit(moduleSourceFile, (fileName, data) => {\n-      if (fileName.startsWith(someGenFilePath)) {\n-        result = data;\n-      }\n-    }, undefined, undefined, transformers);\n-    return normalizeResult(result, format);\n-  }\n-\n-  it('should declare variables', () => {\n-    expect(emitStmt(someVar.set(o.literal(1)).toDeclStmt())).toEqual(`var someVar = 1;`);\n-    expect(emitStmt(someVar.set(o.literal(1)).toDeclStmt(null, [o.StmtModifier.Final])))\n-        .toEqual(`var someVar = 1;`);\n-    expect(emitStmt(someVar.set(o.literal(1)).toDeclStmt(null, [o.StmtModifier.Exported])))\n-        .toEqual(`var someVar = 1; exports.someVar = someVar;`);\n-  });\n-\n-  describe('declare variables with ExternExpressions as values', () => {\n-    it('should create no reexport if the identifier is in the same module', () => {\n-      // identifier is in the same module -> no reexport\n-      expect(emitStmt(someVar.set(o.importExpr(sameModuleIdentifier)).toDeclStmt(null, [\n-        o.StmtModifier.Exported\n-      ]))).toEqual('var someVar = someLocalId; exports.someVar = someVar;');\n-    });\n-\n-    it('should create no reexport if the variable is not exported', () => {\n-      expect(emitStmt(someVar.set(o.importExpr(externalModuleIdentifier)).toDeclStmt()))\n-          .toEqual(\n-              `const i0 = require(\"/somePackage/someOtherPath\"); var someVar = i0.someExternalId;`);\n-    });\n-\n-    it('should create no reexport if the variable is typed', () => {\n-      expect(emitStmt(someVar.set(o.importExpr(externalModuleIdentifier))\n-                          .toDeclStmt(o.DYNAMIC_TYPE, [o.StmtModifier.Exported])))\n-          .toEqual(\n-              `const i0 = require(\"/somePackage/someOtherPath\"); var someVar = i0.someExternalId; exports.someVar = someVar;`);\n-    });\n-\n-    it('should create a reexport', () => {\n-      const result = emitStmt(someVar.set(o.importExpr(externalModuleIdentifier)).toDeclStmt(null, [\n-        o.StmtModifier.Exported\n-      ]));\n-      expect(result).toContain(`var someOtherPath_1 = require(\"/somePackage/someOtherPath\");`);\n-      if (!result.includes('exports.someVar = someOtherPath_1.someExternalId;') &&\n-          // In TS 3.9 re-exports of namespaced imports are defined as getters\n-          !result.includes(\n-              'Object.defineProperty(exports, \"someVar\", { enumerable: true, get: function () { return someOtherPath_1.someExternalId; } });')) {\n-        fail(\n-            'Expected `someVar` to be exported directly or via a `definedProperty` call. Instead got:\\n' +\n-            result);\n-      }\n-    });\n-\n-    it('should create multiple reexports from the same file', () => {\n-      const someVar2 = o.variable('someVar2');\n-      const externalModuleIdentifier2 =\n-          new o.ExternalReference(anotherModuleUrl, 'someExternalId2', null);\n-      const result = emitStmt([\n-        someVar.set(o.importExpr(externalModuleIdentifier))\n-            .toDeclStmt(null, [o.StmtModifier.Exported]),\n-        someVar2.set(o.importExpr(externalModuleIdentifier2))\n-            .toDeclStmt(null, [o.StmtModifier.Exported])\n-      ]);\n-      expect(result).toContain(`var someOtherPath_1 = require(\"/somePackage/someOtherPath\");`);\n-      if (!result.includes(\n-              'exports.someVar = someOtherPath_1.someExternalId;' +\n-              'exports.someVar2 = someOtherPath_1.someExternalId2;') &&\n-          // In TS 3.9 re-exports of namespaced imports are defined as getters\n-          !result.includes(\n-              'Object.defineProperty(exports, \"someVar\", { enumerable: true, get: function () { return someOtherPath_1.someExternalId; } }); ' +\n-              'Object.defineProperty(exports, \"someVar2\", { enumerable: true, get: function () { return someOtherPath_1.someExternalId2; } })')) {\n-        fail(\n-            'Expected `someVar` and `someVar2` to be exported directly or via a `definedProperty` call. Instead got:\\n' +\n-            result);\n-      }\n-    });\n-  });\n-\n-  it('should read and write variables', () => {\n-    expect(emitStmt(someVar.toStmt())).toEqual(`someVar;`);\n-    expect(emitStmt(someVar.set(o.literal(1)).toStmt())).toEqual(`someVar = 1;`);\n-    expect(emitStmt(someVar.set(o.variable('someOtherVar').set(o.literal(1))).toStmt()))\n-        .toEqual(`someVar = someOtherVar = 1;`);\n-  });\n-\n-  it('should read and write keys', () => {\n-    expect(emitStmt(o.variable('someMap').key(o.variable('someKey')).toStmt()))\n-        .toEqual(`someMap[someKey];`);\n-    expect(emitStmt(o.variable('someMap').key(o.variable('someKey')).set(o.literal(1)).toStmt()))\n-        .toEqual(`someMap[someKey] = 1;`);\n-  });\n-\n-  it('should read and write properties', () => {\n-    expect(emitStmt(o.variable('someObj').prop('someProp').toStmt())).toEqual(`someObj.someProp;`);\n-    expect(emitStmt(o.variable('someObj').prop('someProp').set(o.literal(1)).toStmt()))\n-        .toEqual(`someObj.someProp = 1;`);\n-  });\n-\n-  it('should invoke functions and methods and constructors', () => {\n-    expect(emitStmt(o.variable('someFn').callFn([o.literal(1)]).toStmt())).toEqual('someFn(1);');\n-    expect(emitStmt(o.variable('someObj').prop('someMethod').callFn([o.literal(1)]).toStmt()))\n-        .toEqual('someObj.someMethod(1);');\n-    expect(emitStmt(o.variable('SomeClass').instantiate([o.literal(1)]).toStmt()))\n-        .toEqual('new SomeClass(1);');\n-  });\n-\n-  it('should invoke functions and methods and constructors', () => {\n-    expect(emitStmt(o.variable('someFn').callFn([o.literal(1)]).toStmt())).toEqual('someFn(1);');\n-    expect(emitStmt(o.variable('someObj').prop('someMethod').callFn([o.literal(1)]).toStmt()))\n-        .toEqual('someObj.someMethod(1);');\n-    expect(emitStmt(o.variable('SomeClass').instantiate([o.literal(1)]).toStmt()))\n-        .toEqual('new SomeClass(1);');\n-  });\n-\n-  it('should support literals', () => {\n-    expect(emitStmt(o.literal(0).toStmt())).toEqual('0;');\n-    expect(emitStmt(o.literal(true).toStmt())).toEqual('true;');\n-    expect(emitStmt(o.literal('someStr').toStmt())).toEqual(`\"someStr\";`);\n-    expect(emitStmt(o.literalArr([o.literal(1)]).toStmt())).toEqual(`[1];`);\n-    expect(emitStmt(o.literalMap([\n-                       {key: 'someKey', value: o.literal(1), quoted: false},\n-                       {key: 'a', value: o.literal('a'), quoted: false},\n-                       {key: 'b', value: o.literal('b'), quoted: true},\n-                       {key: '*', value: o.literal('star'), quoted: false},\n-                     ]).toStmt())\n-               .replace(/\\s+/gm, ''))\n-        .toEqual(`({someKey:1,a:\"a\",\"b\":\"b\",\"*\":\"star\"});`);\n-\n-    // Regressions #22774\n-    expect(emitStmt(o.literal('\\\\0025BC').toStmt())).toEqual('\"\\\\\\\\0025BC\";');\n-    expect(emitStmt(o.literal('\"some value\"').toStmt())).toEqual('\"\\\\\"some value\\\\\"\";');\n-    expect(emitStmt(o.literal('\"some \\\\0025BC value\"').toStmt()))\n-        .toEqual('\"\\\\\"some \\\\\\\\0025BC value\\\\\"\";');\n-    expect(emitStmt(o.literal('\\n \\\\0025BC \\n ').toStmt())).toEqual('\"\\\\n \\\\\\\\0025BC \\\\n \";');\n-    expect(emitStmt(o.literal('\\r \\\\0025BC \\r ').toStmt())).toEqual('\"\\\\r \\\\\\\\0025BC \\\\r \";');\n-  });\n-\n-  it('should support blank literals', () => {\n-    expect(emitStmt(o.literal(null).toStmt())).toEqual('null;');\n-    expect(emitStmt(o.literal(undefined).toStmt())).toEqual('undefined;');\n-    expect(emitStmt(o.variable('a', null).isBlank().toStmt())).toEqual('(a == null);');\n-  });\n-\n-  it('should support external identifiers', () => {\n-    expect(emitStmt(o.importExpr(sameModuleIdentifier).toStmt())).toEqual('someLocalId;');\n-    expect(emitStmt(o.importExpr(externalModuleIdentifier).toStmt()))\n-        .toEqual(`const i0 = require(\"/somePackage/someOtherPath\"); i0.someExternalId;`);\n-  });\n-\n-  it('should support operators', () => {\n-    const lhs = o.variable('lhs');\n-    const rhs = o.variable('rhs');\n-    expect(emitStmt(someVar.cast(o.INT_TYPE).toStmt())).toEqual('someVar;');\n-    expect(emitStmt(o.not(someVar).toStmt())).toEqual('!someVar;');\n-    expect(emitStmt(o.assertNotNull(someVar).toStmt())).toEqual('someVar;');\n-    expect(emitStmt(someVar.conditional(o.variable('trueCase'), o.variable('falseCase')).toStmt()))\n-        .toEqual('(someVar ? trueCase : falseCase);');\n-    expect(emitStmt(someVar.conditional(o.variable('trueCase'), o.variable('falseCase'))\n-                        .conditional(o.variable('trueCase'), o.variable('falseCase'))\n-                        .toStmt()))\n-        .toEqual('((someVar ? trueCase : falseCase) ? trueCase : falseCase);');\n-\n-    expect(emitStmt(lhs.equals(rhs).toStmt())).toEqual('(lhs == rhs);');\n-    expect(emitStmt(lhs.notEquals(rhs).toStmt())).toEqual('(lhs != rhs);');\n-    expect(emitStmt(lhs.identical(rhs).toStmt())).toEqual('(lhs === rhs);');\n-    expect(emitStmt(lhs.notIdentical(rhs).toStmt())).toEqual('(lhs !== rhs);');\n-    expect(emitStmt(lhs.minus(rhs).toStmt())).toEqual('(lhs - rhs);');\n-    expect(emitStmt(lhs.plus(rhs).toStmt())).toEqual('(lhs + rhs);');\n-    expect(emitStmt(lhs.divide(rhs).toStmt())).toEqual('(lhs / rhs);');\n-    expect(emitStmt(lhs.multiply(rhs).toStmt())).toEqual('(lhs * rhs);');\n-    expect(emitStmt(lhs.plus(rhs).multiply(rhs).toStmt())).toEqual('((lhs + rhs) * rhs);');\n-    expect(emitStmt(lhs.modulo(rhs).toStmt())).toEqual('(lhs % rhs);');\n-    expect(emitStmt(lhs.and(rhs).toStmt())).toEqual('(lhs && rhs);');\n-    expect(emitStmt(lhs.or(rhs).toStmt())).toEqual('(lhs || rhs);');\n-    expect(emitStmt(lhs.lower(rhs).toStmt())).toEqual('(lhs < rhs);');\n-    expect(emitStmt(lhs.lowerEquals(rhs).toStmt())).toEqual('(lhs <= rhs);');\n-    expect(emitStmt(lhs.bigger(rhs).toStmt())).toEqual('(lhs > rhs);');\n-    expect(emitStmt(lhs.biggerEquals(rhs).toStmt())).toEqual('(lhs >= rhs);');\n-  });\n-\n-  it('should support function expressions', () => {\n-    expect(emitStmt(o.fn([], []).toStmt())).toEqual(`(function () { });`);\n-    expect(emitStmt(o.fn([], [new o.ReturnStatement(o.literal(1))], o.INT_TYPE).toStmt()))\n-        .toEqual(`(function () { return 1; });`);\n-    expect(emitStmt(o.fn([new o.FnParam('param1', o.INT_TYPE)], []).toStmt()))\n-        .toEqual(`(function (param1) { });`);\n-  });\n-\n-  it('should support function statements', () => {\n-    expect(emitStmt(new o.DeclareFunctionStmt('someFn', [], []))).toEqual('function someFn() { }');\n-    expect(emitStmt(new o.DeclareFunctionStmt('someFn', [], [], null, [o.StmtModifier.Exported])))\n-        .toEqual(`function someFn() { } exports.someFn = someFn;`);\n-    expect(emitStmt(new o.DeclareFunctionStmt(\n-               'someFn', [], [new o.ReturnStatement(o.literal(1))], o.INT_TYPE)))\n-        .toEqual(`function someFn() { return 1; }`);\n-    expect(emitStmt(new o.DeclareFunctionStmt('someFn', [new o.FnParam('param1', o.INT_TYPE)], [])))\n-        .toEqual(`function someFn(param1) { }`);\n-  });\n-\n-  describe('comments', () => {\n-    it('should support a preamble, which is wrapped as a multi-line comment with no trimming or padding',\n-       () => {\n-         expect(emitStmt(o.variable('a').toStmt(), Format.Raw, '*\\n * SomePreamble\\n '))\n-             .toBe('/**\\n * SomePreamble\\n */\\na;');\n-       });\n-\n-    it('should support singleline comments', () => {\n-      expect(emitStmt(\n-                 new o.ReturnStatement(o.literal(1), null, [o.leadingComment(' a\\n b', false)]),\n-                 Format.Raw))\n-          .toBe('// a\\n// b\\nreturn 1;');\n-    });\n-\n-    it('should support multiline comments', () => {\n-      expect(emitStmt(\n-                 new o.ReturnStatement(\n-                     o.literal(1), null, [o.leadingComment('Multiline comment', true)]),\n-                 Format.Raw))\n-          .toBe('/* Multiline comment */\\nreturn 1;');\n-      expect(emitStmt(\n-                 new o.ReturnStatement(\n-                     o.literal(1), null, [o.leadingComment(`Multiline\\ncomment`, true)]),\n-                 Format.Raw))\n-          .toBe(`/* Multiline\\ncomment */\\nreturn 1;`);\n-    });\n-\n-    describe('JSDoc comments', () => {\n-      it('should be supported', () => {\n-        expect(emitStmt(\n-                   new o.ReturnStatement(\n-                       o.literal(1), null, [o.jsDocComment([{text: 'Intro comment'}])]),\n-                   Format.Raw))\n-            .toBe(`/**\\n * Intro comment\\n */\\nreturn 1;`);\n-        expect(emitStmt(\n-                   new o.ReturnStatement(\n-                       o.literal(1), null,\n-                       [o.jsDocComment([{tagName: o.JSDocTagName.Desc, text: 'description'}])]),\n-                   Format.Raw))\n-            .toBe(`/**\\n * @desc description\\n */\\nreturn 1;`);\n-        expect(emitStmt(\n-                   new o.ReturnStatement(\n-                       o.literal(1), null, [o.jsDocComment([\n-                         {text: 'Intro comment'},\n-                         {tagName: o.JSDocTagName.Desc, text: 'description'},\n-                         {tagName: o.JSDocTagName.Id, text: '{number} identifier 123'},\n-                       ])]),\n-                   Format.Raw))\n-            .toBe(\n-                `/**\\n * Intro comment\\n * @desc description\\n * @id {number} identifier 123\\n */\\nreturn 1;`);\n-      });\n-\n-      it('should escape @ in the text', () => {\n-        expect(emitStmt(\n-                   new o.ReturnStatement(\n-                       o.literal(1), null, [o.jsDocComment([{text: 'email@google.com'}])]),\n-                   Format.Raw))\n-            .toBe(`/**\\n * email\\\\@google.com\\n */\\nreturn 1;`);\n-      });\n-\n-      it('should not allow /* and */ in the text', () => {\n-        expect(\n-            () => emitStmt(new o.ReturnStatement(\n-                o.literal(1), null, [o.jsDocComment([{text: 'some text /* */'}])])))\n-            .toThrowError(`JSDoc text cannot contain \"/*\" and \"*/\"`);\n-      });\n-    });\n-  });\n-\n-  it('should support if stmt', () => {\n-    const trueCase = o.variable('trueCase').callFn([]).toStmt();\n-    const falseCase = o.variable('falseCase').callFn([]).toStmt();\n-    expect(emitStmt(new o.IfStmt(o.variable('cond'), [trueCase])))\n-        .toEqual('if (cond) { trueCase(); }');\n-    expect(emitStmt(new o.IfStmt(o.variable('cond'), [trueCase], [falseCase])))\n-        .toEqual('if (cond) { trueCase(); } else { falseCase(); }');\n-  });\n-\n-  it('should support try/catch', () => {\n-    const bodyStmt = o.variable('body').callFn([]).toStmt();\n-    const catchStmt = o.variable('catchFn').callFn([o.CATCH_ERROR_VAR, o.CATCH_STACK_VAR]).toStmt();\n-    expect(emitStmt(new o.TryCatchStmt([bodyStmt], [catchStmt])))\n-        .toEqual(\n-            `try { body(); } catch (error) { var stack = error.stack; catchFn(error, stack); }`);\n-  });\n-\n-  it('should support support throwing', () => {\n-    expect(emitStmt(new o.ThrowStmt(someVar))).toEqual('throw someVar;');\n-  });\n-\n-  describe('classes', () => {\n-    let callSomeMethod: o.Statement;\n-\n-    beforeEach(() => {\n-      callSomeMethod = o.THIS_EXPR.prop('someMethod').callFn([]).toStmt();\n-    });\n-\n-\n-    it('should support declaring classes', () => {\n-      expect(emitStmt(new o.ClassStmt('SomeClass', null!, [], [], null!, [])))\n-          .toEqual('class SomeClass { }');\n-      expect(emitStmt(new o.ClassStmt('SomeClass', null!, [], [], null!, [], [\n-        o.StmtModifier.Exported\n-      ]))).toEqual('class SomeClass { } exports.SomeClass = SomeClass;');\n-      expect(\n-          emitStmt(new o.ClassStmt('SomeClass', o.variable('SomeSuperClass'), [], [], null!, [])))\n-          .toEqual('class SomeClass extends SomeSuperClass { }');\n-    });\n-\n-    it('should support declaring constructors', () => {\n-      const superCall = o.SUPER_EXPR.callFn([o.variable('someParam')]).toStmt();\n-      expect(emitStmt(\n-                 new o.ClassStmt('SomeClass', null!, [], [], new o.ClassMethod(null!, [], []), [])))\n-          .toEqual(`class SomeClass { constructor() { } }`);\n-      expect(emitStmt(new o.ClassStmt(\n-                 'SomeClass', null!, [], [],\n-                 new o.ClassMethod(null!, [new o.FnParam('someParam', o.INT_TYPE)], []), [])))\n-          .toEqual(`class SomeClass { constructor(someParam) { } }`);\n-      expect(emitStmt(new o.ClassStmt(\n-                 'SomeClass', null!, [], [], new o.ClassMethod(null!, [], [superCall]), [])))\n-          .toEqual(`class SomeClass { constructor() { super(someParam); } }`);\n-      expect(emitStmt(new o.ClassStmt(\n-                 'SomeClass', null!, [], [], new o.ClassMethod(null!, [], [callSomeMethod]), [])))\n-          .toEqual(`class SomeClass { constructor() { this.someMethod(); } }`);\n-    });\n-\n-    it('should support declaring fields', () => {\n-      expect(emitStmt(new o.ClassStmt(\n-                 'SomeClass', null!, [new o.ClassField('someField')], [], null!, [])))\n-          .toEqual(`class SomeClass { constructor() { this.someField = null; } }`);\n-      expect(emitStmt(new o.ClassStmt(\n-                 'SomeClass', null!, [new o.ClassField('someField', o.INT_TYPE)], [], null!, [])))\n-          .toEqual(`class SomeClass { constructor() { this.someField = null; } }`);\n-      expect(emitStmt(new o.ClassStmt(\n-                 'SomeClass', null!,\n-                 [new o.ClassField('someField', o.INT_TYPE, [o.StmtModifier.Private])], [], null!,\n-                 [])))\n-          .toEqual(`class SomeClass { constructor() { this.someField = null; } }`);\n-    });\n-\n-    it('should support declaring getters', () => {\n-      expect(emitStmt(new o.ClassStmt(\n-                 'SomeClass', null!, [], [new o.ClassGetter('someGetter', [])], null!, [])))\n-          .toEqual(`class SomeClass { get someGetter() { } }`);\n-      expect(emitStmt(new o.ClassStmt(\n-                 'SomeClass', null!, [], [new o.ClassGetter('someGetter', [], o.INT_TYPE)], null!,\n-                 [])))\n-          .toEqual(`class SomeClass { get someGetter() { } }`);\n-      expect(emitStmt(new o.ClassStmt(\n-                 'SomeClass', null!, [], [new o.ClassGetter('someGetter', [callSomeMethod])], null!,\n-                 [])))\n-          .toEqual(`class SomeClass { get someGetter() { this.someMethod(); } }`);\n-      expect(\n-          emitStmt(new o.ClassStmt(\n-              'SomeClass', null!, [],\n-              [new o.ClassGetter('someGetter', [], null!, [o.StmtModifier.Private])], null!, [])))\n-          .toEqual(`class SomeClass { get someGetter() { } }`);\n-    });\n-\n-    it('should support methods', () => {\n-      expect(emitStmt(new o.ClassStmt('SomeClass', null!, [], [], null!, [\n-        new o.ClassMethod('someMethod', [], [])\n-      ]))).toEqual(`class SomeClass { someMethod() { } }`);\n-      expect(emitStmt(new o.ClassStmt('SomeClass', null!, [], [], null!, [\n-        new o.ClassMethod('someMethod', [], [], o.INT_TYPE)\n-      ]))).toEqual(`class SomeClass { someMethod() { } }`);\n-      expect(emitStmt(new o.ClassStmt('SomeClass', null!, [], [], null!, [\n-        new o.ClassMethod('someMethod', [new o.FnParam('someParam', o.INT_TYPE)], [])\n-      ]))).toEqual(`class SomeClass { someMethod(someParam) { } }`);\n-      expect(emitStmt(new o.ClassStmt('SomeClass', null!, [], [], null!, [\n-        new o.ClassMethod('someMethod', [], [callSomeMethod])\n-      ]))).toEqual(`class SomeClass { someMethod() { this.someMethod(); } }`);\n-    });\n-  });\n-\n-  it('should support builtin types', () => {\n-    const writeVarExpr = o.variable('a').set(o.NULL_EXPR);\n-    expect(emitStmt(writeVarExpr.toDeclStmt(o.DYNAMIC_TYPE))).toEqual('var a = null;');\n-    expect(emitStmt(writeVarExpr.toDeclStmt(o.BOOL_TYPE))).toEqual('var a = null;');\n-    expect(emitStmt(writeVarExpr.toDeclStmt(o.INT_TYPE))).toEqual('var a = null;');\n-    expect(emitStmt(writeVarExpr.toDeclStmt(o.NUMBER_TYPE))).toEqual('var a = null;');\n-    expect(emitStmt(writeVarExpr.toDeclStmt(o.STRING_TYPE))).toEqual('var a = null;');\n-    expect(emitStmt(writeVarExpr.toDeclStmt(o.FUNCTION_TYPE))).toEqual('var a = null;');\n-  });\n-\n-  it('should support external types', () => {\n-    const writeVarExpr = o.variable('a').set(o.NULL_EXPR);\n-    expect(emitStmt(writeVarExpr.toDeclStmt(o.importType(sameModuleIdentifier))))\n-        .toEqual('var a = null;');\n-    expect(emitStmt(writeVarExpr.toDeclStmt(o.importType(externalModuleIdentifier))))\n-        .toEqual(`var a = null;`);\n-  });\n-\n-  it('should support expression types', () => {\n-    expect(emitStmt(o.variable('a').set(o.NULL_EXPR).toDeclStmt(o.expressionType(o.variable('b')))))\n-        .toEqual('var a = null;');\n-  });\n-\n-  it('should support expressions with type parameters', () => {\n-    expect(emitStmt(o.variable('a')\n-                        .set(o.NULL_EXPR)\n-                        .toDeclStmt(o.importType(externalModuleIdentifier, [o.STRING_TYPE]))))\n-        .toEqual(`var a = null;`);\n-  });\n-\n-  it('should support combined types', () => {\n-    const writeVarExpr = o.variable('a').set(o.NULL_EXPR);\n-    expect(emitStmt(writeVarExpr.toDeclStmt(new o.ArrayType(null!)))).toEqual('var a = null;');\n-    expect(emitStmt(writeVarExpr.toDeclStmt(new o.ArrayType(o.INT_TYPE)))).toEqual('var a = null;');\n-\n-    expect(emitStmt(writeVarExpr.toDeclStmt(new o.MapType(null)))).toEqual('var a = null;');\n-    expect(emitStmt(writeVarExpr.toDeclStmt(new o.MapType(o.INT_TYPE)))).toEqual('var a = null;');\n-  });\n-\n-  describe('source maps', () => {\n-    function emitStmt(stmt: o.Statement|o.Statement[], preamble?: string): string {\n-      const stmts = Array.isArray(stmt) ? stmt : [stmt];\n-\n-      const program = ts.createProgram(\n-          [someGenFileName], {\n-            module: ts.ModuleKind.CommonJS,\n-            target: ts.ScriptTarget.ES2017,\n-            sourceMap: true,\n-            inlineSourceMap: true,\n-            inlineSources: true,\n-          },\n-          host);\n-      const moduleSourceFile = program.getSourceFile(someGenFileName);\n-      const transformers: ts.CustomTransformers = {\n-        before: [context => {\n-          return sourceFile => {\n-            const [newSourceFile] = emitter.updateSourceFile(sourceFile, stmts, preamble);\n-            return newSourceFile;\n-          };\n-        }]\n-      };\n-      let result: string = '';\n-      const emitResult = program.emit(\n-          moduleSourceFile, (fileName, data, writeByteOrderMark, onError, sourceFiles) => {\n-            if (fileName.startsWith(someGenFilePath)) {\n-              result = data;\n-            }\n-          }, undefined, undefined, transformers);\n-      return result;\n-    }\n-\n-    function mappingItemsOf(text: string) {\n-      // find the source map:\n-      const sourceMapMatch = /sourceMappingURL\\=data\\:application\\/json;base64,(.*)$/.exec(text);\n-      const sourceMapBase64 = sourceMapMatch![1];\n-      const sourceMapBuffer = Buffer.from(sourceMapBase64, 'base64');\n-      const sourceMapText = sourceMapBuffer.toString('utf8');\n-      const sourceMapParsed = JSON.parse(sourceMapText) as unknown;\n-      const consumer = new sourceMap.SourceMapConsumer(sourceMapParsed);\n-      const mappings: any[] = [];\n-      consumer.eachMapping((mapping: any) => {\n-        mappings.push(mapping);\n-      });\n-      return mappings;\n-    }\n-\n-    it('should produce a source map that maps back to the source', () => {\n-      const statement = someVar.set(o.literal(1)).toDeclStmt();\n-      const text = '<my-comp> a = 1 </my-comp>';\n-      const sourceName = '/some/file.html';\n-      const sourceUrl = '../some/file.html';\n-      const file = new ParseSourceFile(text, sourceName);\n-      const start = new ParseLocation(file, 0, 0, 0);\n-      const end = new ParseLocation(file, text.length, 0, text.length);\n-      statement.sourceSpan = new ParseSourceSpan(start, end);\n-\n-      const result = emitStmt(statement);\n-      const mappings = mappingItemsOf(result);\n-\n-      expect(mappings).toEqual([\n-        {\n-          source: sourceUrl,\n-          generatedLine: 3,\n-          generatedColumn: 0,\n-          originalLine: 1,\n-          originalColumn: 0,\n-          name: null!  // TODO: Review use of `!` here (#19904)\n-        },\n-        {\n-          source: sourceUrl,\n-          generatedLine: 3,\n-          generatedColumn: 16,\n-          originalLine: 1,\n-          originalColumn: 26,\n-          name: null!  // TODO: Review use of `!` here (#19904)\n-        }\n-      ]);\n-    });\n-\n-    it('should produce a mapping per range instead of a mapping per node', () => {\n-      const text = '<my-comp> a = 1 </my-comp>';\n-      const sourceName = '/some/file.html';\n-      const sourceUrl = '../some/file.html';\n-      const file = new ParseSourceFile(text, sourceName);\n-      const start = new ParseLocation(file, 0, 0, 0);\n-      const end = new ParseLocation(file, text.length, 0, text.length);\n-      const stmt = (loc: number) => {\n-        const start = new ParseLocation(file, loc, 0, loc);\n-        const end = new ParseLocation(file, loc + 1, 0, loc + 1);\n-        const span = new ParseSourceSpan(start, end);\n-        return someVar\n-            .set(new o.BinaryOperatorExpr(\n-                o.BinaryOperator.Plus, o.literal(loc, null, span), o.literal(loc, null, span), null,\n-                span))\n-            .toDeclStmt();\n-      };\n-      const stmts = [1, 2, 3, 4, 5, 6].map(stmt);\n-      const result = emitStmt(stmts);\n-      const mappings = mappingItemsOf(result);\n-\n-      // The span is used in three different nodes but should only be emitted at most twice\n-      // (once for the start and once for the end of a span).\n-      const maxDup = Math.max(\n-          ...Array.from(countsOfDuplicatesMap(mappings.map(m => m.originalColumn)).values()));\n-      expect(maxDup <= 2).toBeTruthy('A redundant range was emitted');\n-    });\n-  });\n-});\n-\n-function countsOfDuplicatesMap<T>(a: T[]): Map<T, number> {\n-  const result = new Map<T, number>();\n-  for (const item of a) {\n-    result.set(item, (result.get(item) || 0) + 1);\n-  }\n-  return result;\n-}\n-\n-const FILES: Directory = {\n-  somePackage: {'someGenFile.ts': `export var a: number;`}\n-};\n-\n-const enum Format {\n-  Raw,\n-  Flat\n-}\n-\n-function normalizeResult(result: string, format: Format): string {\n-  // Remove TypeScript prefixes\n-  let res = result.replace('\"use strict\";', ' ')\n-                .replace('exports.__esModule = true;', ' ')\n-                .replace('Object.defineProperty(exports, \"__esModule\", { value: true });', ' ');\n-\n-  // Remove hoisted initial export assignments. These were added in TS 3.9:\n-  // https://github.com/Microsoft/TypeScript/commit/c6c2c4c8d5aa0947de16f484b8c16fb0eab1c48f\n-  res = res.replace(/^exports\\.\\S+ = void 0;$/gm, '');\n-\n-  // Remove new lines\n-  // Squish adjacent spaces\n-  if (format === Format.Flat) {\n-    return res.replace(/\\n/g, ' ').replace(/ +/g, ' ').replace(/^ /g, '').replace(/ $/g, '');\n-  }\n-\n-  // Remove prefix and postfix spaces\n-  return res.trim();\n-}"
        },
        {
            "sha": "b48d3038e86028cfac1f444623511ea3ae1da186",
            "filename": "packages/compiler-cli/test/transformers/program_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 791,
            "changes": 791,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fprogram_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fprogram_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fprogram_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,791 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-/// <reference types=\"node\" />\n-import * as ng from '@angular/compiler-cli';\n-import * as fs from 'fs';\n-import * as path from 'path';\n-import ts from 'typescript';\n-\n-import {formatDiagnostics} from '../../src/perform_compile';\n-import {CompilerHost, EmitFlags, LazyRoute} from '../../src/transformers/api';\n-import {createSrcToOutPathMapper, resetTempProgramHandlerForTest, setTempProgramHandlerForTest} from '../../src/transformers/program';\n-import {StructureIsReused, tsStructureIsReused} from '../../src/transformers/util';\n-import {expectNoDiagnosticsInProgram, setup, stripAnsi, TestSupport} from '../test_support';\n-\n-describe('ng program', () => {\n-  let testSupport: TestSupport;\n-  let errorSpy: jasmine.Spy&((s: string) => void);\n-\n-  beforeEach(() => {\n-    errorSpy = jasmine.createSpy('consoleError').and.callFake(console.error);\n-    testSupport = setup();\n-  });\n-\n-  function createModuleAndCompSource(prefix: string, template: string = prefix + 'template') {\n-    const templateEntry =\n-        template.endsWith('.html') ? `templateUrl: '${template}'` : `template: \\`${template}\\``;\n-    return `\n-      import {Component, NgModule} from '@angular/core';\n-\n-      @Component({selector: '${prefix}', ${templateEntry}})\n-      export class ${prefix}Comp {}\n-\n-      @NgModule({declarations: [${prefix}Comp]})\n-      export class ${prefix}Module {}\n-    `;\n-  }\n-\n-  function compileLib(libName: string) {\n-    testSupport.writeFiles({\n-      [`${libName}_src/index.ts`]: createModuleAndCompSource(libName),\n-    });\n-    const options = testSupport.createCompilerOptions();\n-    const program = ng.createProgram({\n-      rootNames: [path.resolve(testSupport.basePath, `${libName}_src/index.ts`)],\n-      options,\n-      host: ng.createCompilerHost({options}),\n-    });\n-    expectNoDiagnosticsInProgram(options, program);\n-    fs.symlinkSync(\n-        path.resolve(testSupport.basePath, 'built', `${libName}_src`),\n-        path.resolve(testSupport.basePath, 'node_modules', libName), 'dir');\n-    program.emit({emitFlags: ng.EmitFlags.DTS | ng.EmitFlags.JS | ng.EmitFlags.Metadata});\n-  }\n-\n-  function compile(\n-      oldProgram?: ng.Program, overrideOptions?: ng.CompilerOptions, rootNames?: string[],\n-      host?: CompilerHost): {program: ng.Program, emitResult: ts.EmitResult} {\n-    const options = testSupport.createCompilerOptions(overrideOptions);\n-    if (!rootNames) {\n-      rootNames = [path.resolve(testSupport.basePath, 'src/index.ts')];\n-    }\n-    if (!host) {\n-      host = ng.createCompilerHost({options});\n-    }\n-    const program = ng.createProgram({\n-      rootNames: rootNames,\n-      options,\n-      host,\n-      oldProgram,\n-    });\n-    expectNoDiagnosticsInProgram(options, program);\n-    const emitResult = program.emit();\n-    return {emitResult, program};\n-  }\n-\n-  function createWatchModeHost(): ng.CompilerHost {\n-    const options = testSupport.createCompilerOptions();\n-    const host = ng.createCompilerHost({options});\n-\n-    const originalGetSourceFile = host.getSourceFile;\n-    const cache = new Map<string, ts.SourceFile>();\n-    host.getSourceFile = function(fileName: string, languageVersion: ts.ScriptTarget):\n-                             ts.SourceFile|\n-                         undefined {\n-                           const sf = originalGetSourceFile.call(host, fileName, languageVersion);\n-                           if (sf) {\n-                             if (cache.has(sf.fileName)) {\n-                               const oldSf = cache.get(sf.fileName)!;\n-                               if (oldSf.getFullText() === sf.getFullText()) {\n-                                 return oldSf;\n-                               }\n-                             }\n-                             cache.set(sf.fileName, sf);\n-                           }\n-                           return sf;\n-                         };\n-    return host;\n-  }\n-\n-  function resolveFiles(rootNames: string[]) {\n-    const preOptions = testSupport.createCompilerOptions();\n-    const preHost = ts.createCompilerHost(preOptions);\n-    // don't resolve symlinks\n-    preHost.realpath = (f) => f;\n-    const preProgram = ts.createProgram(rootNames, preOptions, preHost);\n-    return preProgram.getSourceFiles().map(sf => sf.fileName);\n-  }\n-\n-  describe('reuse of old program', () => {\n-    it('should reuse generated code for libraries from old programs', () => {\n-      compileLib('lib');\n-      testSupport.writeFiles({\n-        'src/main.ts': createModuleAndCompSource('main'),\n-        'src/index.ts': `\n-            export * from './main';\n-            export * from 'lib/index';\n-          `\n-      });\n-      const p1 = compile().program;\n-      expect(p1.getTsProgram().getSourceFiles().some(\n-                 sf => /node_modules\\/lib\\/.*\\.ngfactory\\.ts$/.test(sf.fileName)))\n-          .toBe(true);\n-      expect(p1.getTsProgram().getSourceFiles().some(\n-                 sf => /node_modules\\/lib2\\/.*\\.ngfactory.*$/.test(sf.fileName)))\n-          .toBe(false);\n-      const p2 = compile(p1).program;\n-      expect(p2.getTsProgram().getSourceFiles().some(\n-                 sf => /node_modules\\/lib\\/.*\\.ngfactory.*$/.test(sf.fileName)))\n-          .toBe(false);\n-      expect(p2.getTsProgram().getSourceFiles().some(\n-                 sf => /node_modules\\/lib2\\/.*\\.ngfactory.*$/.test(sf.fileName)))\n-          .toBe(false);\n-\n-      // import a library for which we didn't generate code before\n-      compileLib('lib2');\n-      testSupport.writeFiles({\n-        'src/index.ts': `\n-          export * from './main';\n-          export * from 'lib/index';\n-          export * from 'lib2/index';\n-        `,\n-      });\n-      const p3 = compile(p2).program;\n-      expect(p3.getTsProgram().getSourceFiles().some(\n-                 sf => /node_modules\\/lib\\/.*\\.ngfactory.*$/.test(sf.fileName)))\n-          .toBe(false);\n-      expect(p3.getTsProgram().getSourceFiles().some(\n-                 sf => /node_modules\\/lib2\\/.*\\.ngfactory\\.ts$/.test(sf.fileName)))\n-          .toBe(true);\n-\n-      const p4 = compile(p3).program;\n-      expect(p4.getTsProgram().getSourceFiles().some(\n-                 sf => /node_modules\\/lib\\/.*\\.ngfactory.*$/.test(sf.fileName)))\n-          .toBe(false);\n-      expect(p4.getTsProgram().getSourceFiles().some(\n-                 sf => /node_modules\\/lib2\\/.*\\.ngfactory.*$/.test(sf.fileName)))\n-          .toBe(false);\n-    });\n-\n-    // Note: this is the case for watch mode with declaration:false\n-    it('should reuse generated code from libraries from old programs with declaration:false',\n-       () => {\n-         compileLib('lib');\n-\n-         testSupport.writeFiles({\n-           'src/main.ts': createModuleAndCompSource('main'),\n-           'src/index.ts': `\n-            export * from './main';\n-            export * from 'lib/index';\n-          `\n-         });\n-         const p1 = compile(undefined, {declaration: false}).program;\n-         expect(p1.getTsProgram().getSourceFiles().some(\n-                    sf => /node_modules\\/lib\\/.*\\.ngfactory\\.ts$/.test(sf.fileName)))\n-             .toBe(true);\n-         expect(p1.getTsProgram().getSourceFiles().some(\n-                    sf => /node_modules\\/lib2\\/.*\\.ngfactory.*$/.test(sf.fileName)))\n-             .toBe(false);\n-         const p2 = compile(p1, {declaration: false}).program;\n-         expect(p2.getTsProgram().getSourceFiles().some(\n-                    sf => /node_modules\\/lib\\/.*\\.ngfactory.*$/.test(sf.fileName)))\n-             .toBe(false);\n-         expect(p2.getTsProgram().getSourceFiles().some(\n-                    sf => /node_modules\\/lib2\\/.*\\.ngfactory.*$/.test(sf.fileName)))\n-             .toBe(false);\n-       });\n-\n-    it('should only emit changed files', () => {\n-      testSupport.writeFiles({\n-        'src/index.ts': createModuleAndCompSource('comp', 'index.html'),\n-        'src/index.html': `Start`\n-      });\n-      const options: ng.CompilerOptions = {declaration: false};\n-      const host = ng.createCompilerHost({options});\n-      const originalGetSourceFile = host.getSourceFile;\n-      const fileCache = new Map<string, ts.SourceFile>();\n-      host.getSourceFile = (fileName: string, languageVersion: ts.ScriptTarget) => {\n-        if (fileCache.has(fileName)) {\n-          return fileCache.get(fileName);\n-        }\n-        const sf = originalGetSourceFile.call(host, fileName, languageVersion);\n-        if (sf !== undefined) {\n-          fileCache.set(fileName, sf);\n-        }\n-        return sf;\n-      };\n-\n-      const written = new Map<string, string>();\n-      host.writeFile = (fileName: string, data: string) => written.set(fileName, data);\n-\n-      // compile libraries\n-      const p1 = compile(undefined, options, undefined, host).program;\n-\n-      // compile without libraries\n-      const p2 = compile(p1, options, undefined, host).program;\n-      expect(written.has(path.posix.join(testSupport.basePath, 'built/src/index.js'))).toBe(true);\n-      let ngFactoryContent =\n-          written.get(path.posix.join(testSupport.basePath, 'built/src/index.ngfactory.js'));\n-      expect(ngFactoryContent).toMatch(/Start/);\n-\n-      // no change -> no emit\n-      written.clear();\n-      const p3 = compile(p2, options, undefined, host).program;\n-      expect(written.size).toBe(0);\n-\n-      // change a user file\n-      written.clear();\n-      fileCache.delete(path.posix.join(testSupport.basePath, 'src/index.ts'));\n-      const p4 = compile(p3, options, undefined, host).program;\n-      expect(written.size).toBe(1);\n-      expect(written.has(path.posix.join(testSupport.basePath, 'built/src/index.js'))).toBe(true);\n-\n-      // change a file that is input to generated files\n-      written.clear();\n-      testSupport.writeFiles({'src/index.html': 'Hello'});\n-      const p5 = compile(p4, options, undefined, host).program;\n-      expect(written.size).toBe(1);\n-      ngFactoryContent =\n-          written.get(path.posix.join(testSupport.basePath, 'built/src/index.ngfactory.js'));\n-      expect(ngFactoryContent).toMatch(/Hello/);\n-\n-      // change a file and create an intermediate program that is not emitted\n-      written.clear();\n-      fileCache.delete(path.posix.join(testSupport.basePath, 'src/index.ts'));\n-      const p6 = ng.createProgram({\n-        rootNames: [path.posix.join(testSupport.basePath, 'src/index.ts')],\n-        options: testSupport.createCompilerOptions(options),\n-        host,\n-        oldProgram: p5\n-      });\n-      const p7 = compile(p6, options, undefined, host).program;\n-      expect(written.size).toBe(1);\n-    });\n-\n-    it('should set emitSkipped to false for full and incremental emit', () => {\n-      testSupport.writeFiles({\n-        'src/index.ts': createModuleAndCompSource('main'),\n-      });\n-      const {emitResult: emitResult1, program: p1} = compile();\n-      expect(emitResult1.emitSkipped).toBe(false);\n-      const {emitResult: emitResult2, program: p2} = compile(p1);\n-      expect(emitResult2.emitSkipped).toBe(false);\n-      const {emitResult: emitResult3, program: p3} = compile(p2);\n-      expect(emitResult3.emitSkipped).toBe(false);\n-    });\n-\n-    it('should store library summaries on emit', () => {\n-      compileLib('lib');\n-      testSupport.writeFiles({\n-        'src/main.ts': createModuleAndCompSource('main'),\n-        'src/index.ts': `\n-            export * from './main';\n-            export * from 'lib/index';\n-          `\n-      });\n-      const p1 = compile().program;\n-      expect(Array.from(p1.getLibrarySummaries().values())\n-                 .some(sf => /node_modules\\/lib\\/index\\.ngfactory\\.d\\.ts$/.test(sf.fileName)))\n-          .toBe(true);\n-      expect(Array.from(p1.getLibrarySummaries().values())\n-                 .some(sf => /node_modules\\/lib\\/index\\.ngsummary\\.json$/.test(sf.fileName)))\n-          .toBe(true);\n-      expect(Array.from(p1.getLibrarySummaries().values())\n-                 .some(sf => /node_modules\\/lib\\/index\\.d\\.ts$/.test(sf.fileName)))\n-          .toBe(true);\n-\n-      expect(Array.from(p1.getLibrarySummaries().values())\n-                 .some(sf => /src\\/main.*$/.test(sf.fileName)))\n-          .toBe(false);\n-    });\n-\n-    describe(\n-        'verify that program structure is reused within tsc in order to speed up incremental compilation',\n-        () => {\n-          afterEach(resetTempProgramHandlerForTest);\n-\n-          function captureStructureReuse(compile: () => void): StructureIsReused|null {\n-            let structureReuse: StructureIsReused|null = null;\n-            setTempProgramHandlerForTest(program => {\n-              structureReuse = tsStructureIsReused(program);\n-            });\n-            compile();\n-            return structureReuse;\n-          }\n-\n-          it('should reuse the old ts program completely if nothing changed', () => {\n-            testSupport.writeFiles({'src/index.ts': createModuleAndCompSource('main')});\n-            const host = createWatchModeHost();\n-            // Note: the second compile drops factories for library files,\n-            // and therefore changes the structure again\n-            const p1 = compile(undefined, undefined, undefined, host).program;\n-            const p2 = compile(p1, undefined, undefined, host).program;\n-            const structureReuse =\n-                captureStructureReuse(() => compile(p2, undefined, undefined, host));\n-            expect(structureReuse).toBe(StructureIsReused.Completely);\n-          });\n-\n-          it('should reuse the old ts program completely if a template or a ts file changed',\n-             () => {\n-               const host = createWatchModeHost();\n-               testSupport.writeFiles({\n-                 'src/main.ts': createModuleAndCompSource('main', 'main.html'),\n-                 'src/main.html': `Some template`,\n-                 'src/util.ts': `export const x = 1`,\n-                 'src/index.ts': `\n-            export * from './main';\n-            export * from './util';\n-          `\n-               });\n-               // Note: the second compile drops factories for library files,\n-               // and therefore changes the structure again\n-               const p1 = compile(undefined, undefined, undefined, host).program;\n-               const p2 = compile(p1, undefined, undefined, host).program;\n-               testSupport.writeFiles({\n-                 'src/main.html': `Another template`,\n-                 'src/util.ts': `export const x = 2`,\n-               });\n-               const structureReuse =\n-                   captureStructureReuse(() => compile(p2, undefined, undefined, host));\n-               expect(structureReuse).toBe(StructureIsReused.Completely);\n-             });\n-\n-          it('should not reuse the old ts program if an import changed', () => {\n-            const host = createWatchModeHost();\n-            testSupport.writeFiles({\n-              'src/main.ts': createModuleAndCompSource('main'),\n-              'src/util.ts': `export const x = 1`,\n-              'src/index.ts': `\n-            export * from './main';\n-            export * from './util';\n-          `\n-            });\n-            // Note: the second compile drops factories for library files,\n-            // and therefore changes the structure again\n-            const p1 = compile(undefined, undefined, undefined, host).program;\n-            const p2 = compile(p1, undefined, undefined, host).program;\n-            testSupport.writeFiles(\n-                {'src/util.ts': `import {Injectable} from '@angular/core'; export const x = 1;`});\n-            const structureReuse =\n-                captureStructureReuse(() => compile(p2, undefined, undefined, host));\n-            expect(structureReuse).toBe(StructureIsReused.SafeModules);\n-          });\n-        });\n-  });\n-\n-  it('should not typecheck templates if skipTemplateCodegen is set but fullTemplateTypeCheck is not',\n-     () => {\n-       testSupport.writeFiles({\n-         'src/main.ts': `\n-        import {NgModule} from '@angular/core';\n-\n-        @NgModule((() => {if (1==1) return null as any;}) as any)\n-        export class SomeClassWithInvalidMetadata {}\n-      `,\n-       });\n-       const options = testSupport.createCompilerOptions({skipTemplateCodegen: true});\n-       const host = ng.createCompilerHost({options});\n-       const program = ng.createProgram(\n-           {rootNames: [path.resolve(testSupport.basePath, 'src/main.ts')], options, host});\n-       expectNoDiagnosticsInProgram(options, program);\n-       const emitResult = program.emit({emitFlags: EmitFlags.All});\n-       expect(emitResult.diagnostics.length).toBe(0);\n-\n-       testSupport.shouldExist('built/src/main.metadata.json');\n-     });\n-\n-  it('should typecheck templates if skipTemplateCodegen and fullTemplateTypeCheck is set', () => {\n-    testSupport.writeFiles({\n-      'src/main.ts': createModuleAndCompSource('main', `{{nonExistent}}`),\n-    });\n-    const options = testSupport.createCompilerOptions({\n-      skipTemplateCodegen: true,\n-      fullTemplateTypeCheck: true,\n-    });\n-    const host = ng.createCompilerHost({options});\n-    const program = ng.createProgram(\n-        {rootNames: [path.resolve(testSupport.basePath, 'src/main.ts')], options, host});\n-    const diags = program.getNgSemanticDiagnostics();\n-    expect(diags.length).toBe(1);\n-    expect(diags[0].messageText).toBe(`Property 'nonExistent' does not exist on type 'mainComp'.`);\n-  });\n-\n-  it('should be able to use asynchronously loaded resources', (done) => {\n-    testSupport.writeFiles({\n-      'src/main.ts': createModuleAndCompSource('main', 'main.html'),\n-      // Note: we need to be able to resolve the template synchronously,\n-      // only the content is delivered asynchronously.\n-      'src/main.html': '',\n-    });\n-    const options = testSupport.createCompilerOptions();\n-    const host = ng.createCompilerHost({options});\n-    host.readResource = () => Promise.resolve('Hello world!');\n-    const program = ng.createProgram(\n-        {rootNames: [path.resolve(testSupport.basePath, 'src/main.ts')], options, host});\n-    program.loadNgStructureAsync().then(() => {\n-      program.emit();\n-      const ngFactoryPath = path.resolve(testSupport.basePath, 'built/src/main.ngfactory.js');\n-      const factory = fs.readFileSync(ngFactoryPath, 'utf8');\n-      expect(factory).toContain('Hello world!');\n-      done();\n-    });\n-  });\n-\n-  it('should work with noResolve', () => {\n-    // create a temporary ts program to get the list of all files from angular...\n-    testSupport.writeFiles({\n-      'src/main.ts': createModuleAndCompSource('main'),\n-    });\n-    const allRootNames = resolveFiles([path.resolve(testSupport.basePath, 'src/main.ts')]);\n-\n-    // now do the actual test with noResolve\n-    const program = compile(undefined, {noResolve: true}, allRootNames);\n-\n-    testSupport.shouldExist('built/src/main.ngfactory.js');\n-    testSupport.shouldExist('built/src/main.ngfactory.d.ts');\n-  });\n-\n-  it('should work with tsx files', () => {\n-    // create a temporary ts program to get the list of all files from angular...\n-    testSupport.writeFiles({\n-      'src/main.tsx': createModuleAndCompSource('main'),\n-    });\n-    const allRootNames = resolveFiles([path.resolve(testSupport.basePath, 'src/main.tsx')]);\n-\n-    const program = compile(undefined, {jsx: ts.JsxEmit.React}, allRootNames);\n-\n-    testSupport.shouldExist('built/src/main.js');\n-    testSupport.shouldExist('built/src/main.d.ts');\n-    testSupport.shouldExist('built/src/main.ngfactory.js');\n-    testSupport.shouldExist('built/src/main.ngfactory.d.ts');\n-    testSupport.shouldExist('built/src/main.ngsummary.json');\n-  });\n-\n-  it('should emit also empty generated files depending on the options', () => {\n-    testSupport.writeFiles({\n-      'src/main.ts': `\n-        import {Component, NgModule} from '@angular/core';\n-\n-        @Component({selector: 'main', template: '', styleUrls: ['main.css']})\n-        export class MainComp {}\n-\n-        @NgModule({declarations: [MainComp]})\n-        export class MainModule {}\n-      `,\n-      'src/main.css': ``,\n-      'src/util.ts': 'export const x = 1;',\n-      'src/index.ts': `\n-        export * from './util';\n-        export * from './main';\n-      `,\n-    });\n-    const options = testSupport.createCompilerOptions({\n-      allowEmptyCodegenFiles: true,\n-      enableSummariesForJit: true,\n-    });\n-    const host = ng.createCompilerHost({options});\n-    const written = new Map < string, {\n-      original: ReadonlyArray<ts.SourceFile>|undefined;\n-      data: string;\n-    }\n-    > ();\n-\n-    host.writeFile =\n-        (fileName: string, data: string, writeByteOrderMark: boolean,\n-         onError: ((message: string) => void)|undefined,\n-         sourceFiles?: ReadonlyArray<ts.SourceFile>) => {\n-          written.set(fileName, {original: sourceFiles, data});\n-        };\n-    const program = ng.createProgram(\n-        {rootNames: [path.resolve(testSupport.basePath, 'src/index.ts')], options, host});\n-    program.emit();\n-\n-    const enum ShouldBe { Empty, EmptyExport, NoneEmpty }\n-    function assertGenFile(\n-        fileName: string, checks: {originalFileName: string, shouldBe: ShouldBe}) {\n-      const writeData = written.get(path.posix.join(testSupport.basePath, fileName));\n-      expect(writeData).toBeTruthy();\n-      expect(\n-          writeData!.original!.some(\n-              sf => sf.fileName === path.posix.join(testSupport.basePath, checks.originalFileName)))\n-          .toBe(true);\n-      switch (checks.shouldBe) {\n-        case ShouldBe.Empty:\n-          expect(writeData!.data).toMatch(/^(\\s*\\/\\*([^*]|\\*[^\\/])*\\*\\/\\s*)?$/);\n-          break;\n-        case ShouldBe.EmptyExport:\n-          expect(writeData!.data)\n-              .toMatch(/^((\\s*\\/\\*([^*]|\\*[^\\/])*\\*\\/\\s*)|(\\s*export\\s*{\\s*};\\s*))$/m);\n-          break;\n-        case ShouldBe.NoneEmpty:\n-          expect(writeData!.data).not.toBe('');\n-          break;\n-      }\n-    }\n-\n-    assertGenFile(\n-        'built/src/util.ngfactory.js',\n-        {originalFileName: 'src/util.ts', shouldBe: ShouldBe.EmptyExport});\n-    assertGenFile(\n-        'built/src/util.ngfactory.d.ts',\n-        {originalFileName: 'src/util.ts', shouldBe: ShouldBe.EmptyExport});\n-    assertGenFile(\n-        'built/src/util.ngsummary.js',\n-        {originalFileName: 'src/util.ts', shouldBe: ShouldBe.EmptyExport});\n-    assertGenFile(\n-        'built/src/util.ngsummary.d.ts',\n-        {originalFileName: 'src/util.ts', shouldBe: ShouldBe.EmptyExport});\n-    assertGenFile(\n-        'built/src/util.ngsummary.json',\n-        {originalFileName: 'src/util.ts', shouldBe: ShouldBe.NoneEmpty});\n-\n-    // Note: we always fill non shim and shim style files as they might\n-    // be shared by component with and without ViewEncapsulation.\n-    assertGenFile(\n-        'built/src/main.css.ngstyle.js',\n-        {originalFileName: 'src/main.ts', shouldBe: ShouldBe.NoneEmpty});\n-    assertGenFile(\n-        'built/src/main.css.ngstyle.d.ts',\n-        {originalFileName: 'src/main.ts', shouldBe: ShouldBe.EmptyExport});\n-    // Note: this file is not empty as we actually generated code for it\n-    assertGenFile(\n-        'built/src/main.css.shim.ngstyle.js',\n-        {originalFileName: 'src/main.ts', shouldBe: ShouldBe.NoneEmpty});\n-    assertGenFile(\n-        'built/src/main.css.shim.ngstyle.d.ts',\n-        {originalFileName: 'src/main.ts', shouldBe: ShouldBe.EmptyExport});\n-  });\n-\n-  it('should not emit /// references in .d.ts files', () => {\n-    testSupport.writeFiles({\n-      'src/main.ts': createModuleAndCompSource('main'),\n-    });\n-    compile(undefined, {declaration: true}, [path.resolve(testSupport.basePath, 'src/main.ts')]);\n-\n-    const dts =\n-        fs.readFileSync(path.resolve(testSupport.basePath, 'built', 'src', 'main.d.ts')).toString();\n-    expect(dts).toMatch('export declare class');\n-    expect(dts).not.toMatch('///');\n-  });\n-\n-  it('should not emit generated files whose sources are outside of the rootDir', () => {\n-    testSupport.writeFiles({\n-      'src/main.ts': createModuleAndCompSource('main'),\n-      'src/index.ts': `\n-          export * from './main';\n-        `\n-    });\n-    const options =\n-        testSupport.createCompilerOptions({rootDir: path.resolve(testSupport.basePath, 'src')});\n-    const host = ng.createCompilerHost({options});\n-    const writtenFileNames: string[] = [];\n-    const oldWriteFile = host.writeFile;\n-    host.writeFile = (fileName, data, writeByteOrderMark, onError, sourceFiles) => {\n-      writtenFileNames.push(fileName);\n-      oldWriteFile(fileName, data, writeByteOrderMark, onError, sourceFiles);\n-    };\n-\n-    compile(/*oldProgram*/ undefined, options, /*rootNames*/ undefined, host);\n-\n-    // no emit for files from node_modules as they are outside of rootDir\n-    expect(writtenFileNames.some(f => /node_modules/.test(f))).toBe(false);\n-\n-    // emit all gen files for files under src/\n-    testSupport.shouldExist('built/main.js');\n-    testSupport.shouldExist('built/main.d.ts');\n-    testSupport.shouldExist('built/main.ngfactory.js');\n-    testSupport.shouldExist('built/main.ngfactory.d.ts');\n-    testSupport.shouldExist('built/main.ngsummary.json');\n-  });\n-\n-  describe('createSrcToOutPathMapper', () => {\n-    it('should return identity mapping if no outDir is present', () => {\n-      const mapper = createSrcToOutPathMapper(undefined, undefined, undefined, path.posix);\n-      expect(mapper('/tmp/b/y.js')).toBe('/tmp/b/y.js');\n-    });\n-\n-    it('should return identity mapping if first src and out fileName have same dir', () => {\n-      const mapper = createSrcToOutPathMapper('/tmp', '/tmp/a/x.ts', '/tmp/a/x.js', path.posix);\n-      expect(mapper('/tmp/b/y.js')).toBe('/tmp/b/y.js');\n-    });\n-\n-    it('should adjust the filename if the outDir is inside of the rootDir', () => {\n-      const mapper =\n-          createSrcToOutPathMapper('/tmp/out', '/tmp/a/x.ts', '/tmp/out/a/x.js', path.posix);\n-      expect(mapper('/tmp/b/y.js')).toBe('/tmp/out/b/y.js');\n-    });\n-\n-    it('should adjust the filename if the outDir is outside of the rootDir', () => {\n-      const mapper = createSrcToOutPathMapper('/out', '/tmp/a/x.ts', '/out/a/x.js', path.posix);\n-      expect(mapper('/tmp/b/y.js')).toBe('/out/b/y.js');\n-    });\n-\n-    it('should adjust the filename if the common prefix of sampleSrc and sampleOut is outside of outDir',\n-       () => {\n-         const mapper = createSrcToOutPathMapper(\n-             '/dist/common', '/src/common/x.ts', '/dist/common/x.js', path.posix);\n-         expect(mapper('/src/common/y.js')).toBe('/dist/common/y.js');\n-       });\n-\n-    it('should work on windows with normalized paths', () => {\n-      const mapper =\n-          createSrcToOutPathMapper('c:/tmp/out', 'c:/tmp/a/x.ts', 'c:/tmp/out/a/x.js', path.win32);\n-      expect(mapper('c:/tmp/b/y.js')).toBe('c:/tmp/out/b/y.js');\n-    });\n-\n-    it('should work on windows with non-normalized paths', () => {\n-      const mapper = createSrcToOutPathMapper(\n-          'c:\\\\tmp\\\\out', 'c:\\\\tmp\\\\a\\\\x.ts', 'c:\\\\tmp\\\\out\\\\a\\\\x.js', path.win32);\n-      expect(mapper('c:\\\\tmp\\\\b\\\\y.js')).toBe('c:/tmp/out/b/y.js');\n-    });\n-  });\n-\n-  it('should report errors for ts and ng errors on emit with noEmitOnError=true', () => {\n-    testSupport.writeFiles({\n-      'src/main.ts': `\n-        import {Component, NgModule} from '@angular/core';\n-\n-        // Ts error\n-        let x: string = 1;\n-\n-        // Ng error\n-        @Component({selector: 'comp', templateUrl: './main.html'})\n-        export class MyComp {}\n-\n-        @NgModule({declarations: [MyComp]})\n-        export class MyModule {}\n-        `,\n-      'src/main.html': '{{nonExistent}}'\n-    });\n-    const options = testSupport.createCompilerOptions({noEmitOnError: true});\n-    const host = ng.createCompilerHost({options});\n-    const program1 = ng.createProgram(\n-        {rootNames: [path.resolve(testSupport.basePath, 'src/main.ts')], options, host});\n-    const errorDiags =\n-        program1.emit().diagnostics.filter(d => d.category === ts.DiagnosticCategory.Error);\n-    expect(stripAnsi(formatDiagnostics(errorDiags)))\n-        .toContain(\n-            `src/main.ts:5:13 - error TS2322: Type 'number' is not assignable to type 'string'.`);\n-    expect(stripAnsi(formatDiagnostics(errorDiags)))\n-        .toContain(\n-            `src/main.html:1:1 - error TS100: Property 'nonExistent' does not exist on type 'MyComp'.`);\n-  });\n-\n-  it('should not report emit errors with noEmitOnError=false', () => {\n-    testSupport.writeFiles({\n-      'src/main.ts': `\n-        @NgModule()\n-      `\n-    });\n-    const options = testSupport.createCompilerOptions({noEmitOnError: false});\n-    const host = ng.createCompilerHost({options});\n-    const program1 = ng.createProgram(\n-        {rootNames: [path.resolve(testSupport.basePath, 'src/main.ts')], options, host});\n-    expect(program1.emit().diagnostics.length).toBe(0);\n-  });\n-\n-  describe('errors', () => {\n-    const fileWithStructuralError = `\n-      import {NgModule} from '@angular/core';\n-\n-      @NgModule(() => (1===1 ? null as any : null as any))\n-      export class MyModule {}\n-    `;\n-    const fileWithGoodContent = `\n-      import {NgModule} from '@angular/core';\n-\n-      @NgModule()\n-      export class MyModule {}\n-    `;\n-\n-    it('should not throw on structural errors but collect them', () => {\n-      testSupport.write('src/index.ts', fileWithStructuralError);\n-\n-      const options = testSupport.createCompilerOptions();\n-      const host = ng.createCompilerHost({options});\n-      const program = ng.createProgram(\n-          {rootNames: [path.resolve(testSupport.basePath, 'src/index.ts')], options, host});\n-\n-      const structuralErrors = program.getNgStructuralDiagnostics();\n-      expect(structuralErrors.length).toBe(1);\n-      expect(structuralErrors[0].messageText).toContain('Function expressions are not supported');\n-    });\n-\n-    it('should not throw on structural errors but collect them (loadNgStructureAsync)', (done) => {\n-      testSupport.write('src/index.ts', fileWithStructuralError);\n-\n-      const options = testSupport.createCompilerOptions();\n-      const host = ng.createCompilerHost({options});\n-      const program = ng.createProgram(\n-          {rootNames: [path.resolve(testSupport.basePath, 'src/index.ts')], options, host});\n-      program.loadNgStructureAsync().then(() => {\n-        const structuralErrors = program.getNgStructuralDiagnostics();\n-        expect(structuralErrors.length).toBe(1);\n-        expect(structuralErrors[0].messageText).toContain('Function expressions are not supported');\n-        done();\n-      });\n-    });\n-\n-    it('should include non-formatted errors (e.g. invalid templateUrl)', () => {\n-      testSupport.write('src/index.ts', `\n-        import {Component, NgModule} from '@angular/core';\n-\n-        @Component({\n-          selector: 'my-component',\n-          templateUrl: 'template.html',   // invalid template url\n-        })\n-        export class MyComponent {}\n-\n-        @NgModule({\n-          declarations: [MyComponent]\n-        })\n-        export class MyModule {}\n-      `);\n-\n-      const options = testSupport.createCompilerOptions();\n-      const host = ng.createCompilerHost({options});\n-      const program = ng.createProgram({\n-        rootNames: [path.resolve(testSupport.basePath, 'src/index.ts')],\n-        options,\n-        host,\n-      });\n-\n-      const structuralErrors = program.getNgStructuralDiagnostics();\n-      expect(structuralErrors.length).toBe(1);\n-      expect(structuralErrors[0].messageText).toContain('Couldn\\'t resolve resource template.html');\n-    });\n-\n-    it('should be able report structural errors with noResolve:true and generateCodeForLibraries:false ' +\n-           'even if getSourceFile throws for non existent files',\n-       () => {\n-         testSupport.write('src/index.ts', fileWithGoodContent);\n-\n-         // compile angular and produce .ngsummary.json / ngfactory.d.ts files\n-         compile();\n-\n-         testSupport.write('src/ok.ts', fileWithGoodContent);\n-         testSupport.write('src/error.ts', fileWithStructuralError);\n-\n-         // Make sure the ok.ts file is before the error.ts file,\n-         // so we added a .ngfactory.ts file for it.\n-         const allRootNames = resolveFiles(\n-             ['src/ok.ts', 'src/error.ts'].map(fn => path.resolve(testSupport.basePath, fn)));\n-\n-         const options = testSupport.createCompilerOptions({\n-           noResolve: true,\n-           generateCodeForLibraries: false,\n-         });\n-         const host = ng.createCompilerHost({options});\n-         const originalGetSourceFile = host.getSourceFile;\n-         host.getSourceFile =\n-             (fileName: string, languageVersion: ts.ScriptTarget,\n-              onError?: ((message: string) => void)|undefined): ts.SourceFile|undefined => {\n-               // We should never try to load .ngfactory.ts files\n-               if (fileName.match(/\\.ngfactory\\.ts$/)) {\n-                 throw new Error(`Non existent ngfactory file: ` + fileName);\n-               }\n-               return originalGetSourceFile.call(host, fileName, languageVersion, onError);\n-             };\n-         const program = ng.createProgram({rootNames: allRootNames, options, host});\n-         const structuralErrors = program.getNgStructuralDiagnostics();\n-         expect(structuralErrors.length).toBe(1);\n-         expect(structuralErrors[0].messageText)\n-             .toContain('Function expressions are not supported');\n-       });\n-  });\n-});"
        },
        {
            "sha": "4a14c3b43002a3e78956a5441ec69c0426329820",
            "filename": "packages/compiler-cli/test/transformers/r3_metadata_transform_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 57,
            "changes": 57,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fr3_metadata_transform_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fr3_metadata_transform_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fr3_metadata_transform_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,57 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ClassField, ClassMethod, ClassStmt, PartialModule, Statement, StmtModifier} from '@angular/compiler';\n-import ts from 'typescript';\n-\n-import {isClassMetadata, MetadataCollector} from '../../src/metadata/index';\n-import {MetadataCache} from '../../src/transformers/metadata_cache';\n-import {PartialModuleMetadataTransformer} from '../../src/transformers/r3_metadata_transform';\n-\n-describe('r3_transform_spec', () => {\n-  it('should add a static method to collected metadata', () => {\n-    const fileName = '/some/directory/someFileName.ts';\n-    const className = 'SomeClass';\n-    const newFieldName = 'newStaticField';\n-    const source = `\n-      export class ${className} {\n-        myMethod(): void {}\n-      }\n-    `;\n-\n-    const sourceFile =\n-        ts.createSourceFile(fileName, source, ts.ScriptTarget.Latest, /* setParentNodes */ true);\n-    const partialModule: PartialModule = {\n-      fileName,\n-      statements: [new ClassStmt(\n-          className, /* parent */ null, /* fields */[new ClassField(\n-              /* name */ newFieldName, /* type */ null, /* modifiers */[StmtModifier.Static])],\n-          /* getters */[],\n-          /* constructorMethod */ new ClassMethod(/* name */ null, /* params */[], /* body */[]),\n-          /* methods */[])]\n-    };\n-\n-    const cache = new MetadataCache(\n-        new MetadataCollector(), /* strict */ true,\n-        [new PartialModuleMetadataTransformer([partialModule])]);\n-    const metadata = cache.getMetadata(sourceFile);\n-    expect(metadata).toBeDefined('Expected metadata from test source file');\n-    if (metadata) {\n-      const classData = metadata.metadata[className];\n-      expect(classData && isClassMetadata(classData))\n-          .toBeDefined(`Expected metadata to contain data for \"${className}\"`);\n-      if (classData && isClassMetadata(classData)) {\n-        const statics = classData.statics;\n-        expect(statics).toBeDefined(`Expected \"${className}\" metadata to contain statics`);\n-        if (statics) {\n-          expect(statics[newFieldName]).toEqual({}, 'Expected new field to recorded as a function');\n-        }\n-      }\n-    }\n-  });\n-});"
        },
        {
            "sha": "1f2a0e9359cd0a006299fe782d119bd43fca8b52",
            "filename": "packages/compiler-cli/test/transformers/r3_transform_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 164,
            "changes": 164,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fr3_transform_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fr3_transform_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fr3_transform_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,164 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {PartialModule} from '@angular/compiler';\n-import * as o from '@angular/compiler/src/output/output_ast';\n-import ts from 'typescript';\n-\n-import {getAngularClassTransformerFactory} from '../../src/transformers/r3_transform';\n-import {Directory, MockAotContext, MockCompilerHost} from '../mocks';\n-\n-const someGenFilePath = '/somePackage/someGenFile';\n-const someGenFileName = someGenFilePath + '.ts';\n-\n-describe('r3_transform_spec', () => {\n-  let context: MockAotContext;\n-  let host: MockCompilerHost;\n-\n-  beforeEach(() => {\n-    context = new MockAotContext('/', FILES);\n-    host = new MockCompilerHost(context);\n-  });\n-\n-  it('should be able to generate a simple identity function', () => {\n-    expect(emitStaticMethod(new o.ReturnStatement(o.variable('v')), ['v']))\n-        .toContain('static someMethod(v) { return v; }');\n-  });\n-\n-  it('should be able to generate a static field declaration', () => {\n-    expect(emitStaticField(o.literal(10))).toContain('SomeClass.someField = 10');\n-  });\n-\n-  it('should be able to import a symbol', () => {\n-    expect(emitStaticMethod(new o.ReturnStatement(\n-               o.importExpr(new o.ExternalReference('@angular/core', 'Component')))))\n-        .toContain('static someMethod() { return i0.Component; } }');\n-  });\n-\n-  it('should be able to modify multiple classes in the same module', () => {\n-    const result = emit(getAngularClassTransformerFactory(\n-        [{\n-          fileName: someGenFileName,\n-          statements: [\n-            classMethod(new o.ReturnStatement(o.variable('v')), ['v'], 'someMethod', 'SomeClass'),\n-            classMethod(\n-                new o.ReturnStatement(o.variable('v')), ['v'], 'someOtherMethod', 'SomeOtherClass')\n-          ]\n-        }],\n-        false));\n-    expect(result).toContain('static someMethod(v) { return v; }');\n-    expect(result).toContain('static someOtherMethod(v) { return v; }');\n-  });\n-\n-  it('should insert imports after existing imports', () => {\n-    context = context.override({\n-      somePackage: {\n-        'someGenFile.ts': `\n-        import {Component} from '@angular/core';\n-\n-        @Component({selector: 'some-class', template: 'hello!'})\n-        export class SomeClass {}\n-\n-        export class SomeOtherClass {}\n-      `\n-      }\n-    });\n-    host = new MockCompilerHost(context);\n-\n-    expect(emitStaticMethod(new o.ReturnStatement(\n-               o.importExpr(new o.ExternalReference('@angular/core', 'Component')))))\n-        .toContain('const core_1 = require(\"@angular/core\"); const i0 = require(\"@angular/core\");');\n-  });\n-\n-  function emit(factory: ts.TransformerFactory<ts.SourceFile>): string {\n-    let result: string = '';\n-    const program = ts.createProgram(\n-        [someGenFileName], {module: ts.ModuleKind.CommonJS, target: ts.ScriptTarget.ES2017}, host);\n-    const moduleSourceFile = program.getSourceFile(someGenFileName);\n-    const transformers: ts.CustomTransformers = {before: [factory]};\n-    const emitResult = program.emit(\n-        moduleSourceFile, (fileName, data, writeByteOrderMark, onError, sourceFiles) => {\n-          if (fileName.startsWith(someGenFilePath)) {\n-            result = data;\n-          }\n-        }, undefined, undefined, transformers);\n-    return normalizeResult(result);\n-  }\n-\n-  function emitStaticMethod(\n-      stmt: o.Statement|o.Statement[], parameters: string[] = [], methodName: string = 'someMethod',\n-      className: string = 'SomeClass'): string {\n-    const module: PartialModule = {\n-      fileName: someGenFileName,\n-      statements: [classMethod(stmt, parameters, methodName, className)]\n-    };\n-    return emit(getAngularClassTransformerFactory([module], false));\n-  }\n-\n-  function emitStaticField(\n-      initializer: o.Expression, fieldName: string = 'someField',\n-      className: string = 'SomeClass'): string {\n-    const module: PartialModule = {\n-      fileName: someGenFileName,\n-      statements: [classField(initializer, fieldName, className)]\n-    };\n-    return emit(getAngularClassTransformerFactory([module], false));\n-  }\n-});\n-\n-const FILES: Directory = {\n-  somePackage: {\n-    'someGenFile.ts': `\n-\n-  export class SomeClass {}\n-\n-  export class SomeOtherClass {}\n-`\n-  }\n-};\n-\n-function classMethod(\n-    stmt: o.Statement|o.Statement[], parameters: string[] = [], methodName: string = 'someMethod',\n-    className: string = 'SomeClass'): o.ClassStmt {\n-  const statements = Array.isArray(stmt) ? stmt : [stmt];\n-  return new o.ClassStmt(\n-      /* name */ className,\n-      /* parent */ null,\n-      /* fields */[],\n-      /* getters */[],\n-      /* constructorMethod */ new o.ClassMethod(null, [], []),\n-      /* methods */[new o.ClassMethod(\n-          methodName, parameters.map(name => new o.FnParam(name)), statements, null,\n-          [o.StmtModifier.Static])]);\n-}\n-\n-function classField(\n-    initializer: o.Expression, fieldName: string = 'someField',\n-    className: string = 'SomeClass'): o.ClassStmt {\n-  return new o.ClassStmt(\n-      /* name */ className,\n-      /* parent */ null,\n-      /* fields */[new o.ClassField(fieldName, null, [o.StmtModifier.Static], initializer)],\n-      /* getters */[],\n-      /* constructorMethod */ new o.ClassMethod(null, [], []),\n-      /* methods */[]);\n-}\n-\n-function normalizeResult(result: string): string {\n-  // Remove TypeScript prefixes\n-  // Remove new lines\n-  // Squish adjacent spaces\n-  // Remove prefix and postfix spaces\n-  return result.replace('\"use strict\";', ' ')\n-      .replace('exports.__esModule = true;', ' ')\n-      .replace('Object.defineProperty(exports, \"__esModule\", { value: true });', ' ')\n-      .replace(/\\n/g, ' ')\n-      .replace(/ +/g, ' ')\n-      .replace(/^ /g, '')\n-      .replace(/ $/g, '');\n-}"
        },
        {
            "sha": "b772d75482220574c80e8d7300999f168d1d68f8",
            "filename": "packages/compiler/test/BUILD.bazel",
            "status": "modified",
            "additions": 3,
            "deletions": 39,
            "changes": 42,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2FBUILD.bazel?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -7,53 +7,33 @@ NODE_ONLY = [\n     \"aot/**/*.ts\",\n ]\n \n-UTILS = [\n-    \"aot/test_util.ts\",\n-]\n-\n circular_dependency_test(\n     name = \"circular_deps_test\",\n     entry_point = \"angular/packages/compiler/index.js\",\n     deps = [\"//packages/compiler\"],\n )\n \n-ts_library(\n-    name = \"test_utils\",\n-    testonly = True,\n-    srcs = UTILS,\n-    visibility = [\n-        \"//packages/compiler-cli/test:__subpackages__\",\n-        \"//packages/compiler/test:__subpackages__\",\n-    ],\n-    deps = [\n-        \"//packages:types\",\n-        \"//packages/compiler\",\n-        \"//packages/compiler-cli\",\n-        \"//packages/compiler-cli/src/ngtsc/testing\",\n-        \"@npm//typescript\",\n-    ],\n-)\n-\n ts_library(\n     name = \"test_lib\",\n     testonly = True,\n     srcs = glob(\n         [\"**/*.ts\"],\n-        exclude = NODE_ONLY + UTILS,\n+        exclude = NODE_ONLY,\n     ),\n     deps = [\n         \"//packages:types\",\n         \"//packages/common\",\n         \"//packages/compiler\",\n         \"//packages/compiler/test/expression_parser/utils\",\n         \"//packages/compiler/test/ml_parser/util\",\n-        \"//packages/compiler/testing\",\n         \"//packages/core\",\n         \"//packages/core/src/compiler\",\n         \"//packages/core/testing\",\n         \"//packages/platform-browser\",\n         \"//packages/platform-browser-dynamic\",\n         \"//packages/platform-browser/testing\",\n+        \"@npm//base64-js\",\n+        \"@npm//source-map\",\n     ],\n )\n \n@@ -62,15 +42,11 @@ ts_library(\n     testonly = True,\n     srcs = glob(\n         NODE_ONLY,\n-        exclude = UTILS,\n     ),\n     deps = [\n         \":test_lib\",\n-        \":test_utils\",\n         \"//packages/compiler\",\n-        \"//packages/compiler-cli\",\n         \"//packages/compiler/test/expression_parser/utils\",\n-        \"//packages/compiler/testing\",\n         \"//packages/core\",\n         \"@npm//typescript\",\n     ],\n@@ -79,14 +55,6 @@ ts_library(\n jasmine_node_test(\n     name = \"test\",\n     bootstrap = [\"//tools/testing:node_es5\"],\n-    data = [\n-        \"@npm//@angular/animations-12\",\n-        \"@npm//@angular/core-12\",\n-    ],\n-    tags = [\n-        # Disabled as these tests pertain to the old ngc compilation and are not relevant in Ivy.\n-        \"view-engine-only\",\n-    ],\n     deps = [\n         \":test_lib\",\n         \":test_node_only_lib\",\n@@ -97,10 +65,6 @@ jasmine_node_test(\n \n karma_web_test_suite(\n     name = \"test_web\",\n-    tags = [\n-        # Disabled as these tests pertain to the old ngc compilation and are not relevant in Ivy.\n-        \"view-engine-only\",\n-    ],\n     deps = [\n         \":test_lib\",\n     ],"
        },
        {
            "sha": "7c522a139603957ba4149c8b9665d5d1a70f7211",
            "filename": "packages/compiler/test/aot/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Faot%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Faot%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Faot%2FREADME.md?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1 +0,0 @@\n-Tests in this directory are excluded from running in the browser and only run in node.\n\\ No newline at end of file"
        },
        {
            "sha": "0678b52eda18f9aa446f23594912d5fdc4ca72ff",
            "filename": "packages/compiler/test/aot/compiler_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 1144,
            "changes": 1144,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Faot%2Fcompiler_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Faot%2Fcompiler_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Faot%2Fcompiler_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,1144 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {AotSummaryResolver, GeneratedFile, StaticSymbolCache, StaticSymbolResolver, toTypeScript} from '@angular/compiler';\n-import {MetadataBundler} from '@angular/compiler-cli/src/metadata/bundler';\n-import {privateEntriesToIndex} from '@angular/compiler-cli/src/metadata/index_writer';\n-import {extractSourceMap, originalPositionFor} from '@angular/compiler/testing/src/output/source_map_util';\n-import {NodeFlags} from '@angular/core/src/view/index';\n-import ts from 'typescript';\n-\n-import {arrayToMockDir, compile, EmittingCompilerHost, expectNoDiagnostics, isInBazel, MockAotCompilerHost, MockCompilerHost, MockDirectory, MockMetadataBundlerHost, settings, setup, toMockFileArray} from './test_util';\n-\n-describe('compiler (unbundled Angular)', () => {\n-  let angularFiles = setup();\n-\n-  describe('Quickstart', () => {\n-    it('should compile', () => {\n-      const {genFiles} = compile([QUICKSTART, angularFiles]);\n-      expect(genFiles.find(f => /app\\.component\\.ngfactory\\.ts/.test(f.genFileUrl))).toBeDefined();\n-      expect(genFiles.find(f => /app\\.module\\.ngfactory\\.ts/.test(f.genFileUrl))).toBeDefined();\n-    });\n-  });\n-\n-  describe('aot source mapping', () => {\n-    const componentPath = '/app/app.component.ts';\n-    const ngFactoryPath = '/app/app.component.ngfactory.ts';\n-\n-    let rootDir: MockDirectory;\n-    let appDir: MockDirectory;\n-\n-    beforeEach(() => {\n-      appDir = {\n-        'app.module.ts': `\n-              import { NgModule }      from '@angular/core';\n-\n-              import { AppComponent }  from './app.component';\n-\n-              @NgModule({\n-                declarations: [ AppComponent ],\n-                bootstrap:    [ AppComponent ]\n-              })\n-              export class AppModule { }\n-            `\n-      };\n-      rootDir = {'app': appDir};\n-    });\n-\n-    function compileApp(): GeneratedFile {\n-      const {genFiles} = compile([rootDir, angularFiles]);\n-      return genFiles.find(\n-          genFile => genFile.srcFileUrl === componentPath && genFile.genFileUrl.endsWith('.ts'))!;\n-    }\n-\n-    function findLineAndColumn(file: string, token: string): {line: number, column: number}|null {\n-      const index = file.indexOf(token);\n-      if (index === -1) {\n-        return null;\n-      }\n-      const linesUntilToken = file.slice(0, index).split('\\n');\n-      const line = linesUntilToken.length;\n-      const column = linesUntilToken[linesUntilToken.length - 1].length;\n-      return {line, column};\n-    }\n-\n-    function createComponentSource(componentDecorator: string) {\n-      return `\n-        import { NgModule, Component } from '@angular/core';\n-\n-        @Component({\n-          ${componentDecorator}\n-        })\n-        export class AppComponent {\n-          someMethod() {}\n-        }\n-      `;\n-    }\n-\n-    describe('inline templates', () => {\n-      const ngUrl = `${componentPath}.AppComponent.html`;\n-\n-      function templateDecorator(template: string) {\n-        return `template: \\`${template}\\`,`;\n-      }\n-\n-      declareTests({ngUrl, templateDecorator});\n-    });\n-\n-    describe('external templates', () => {\n-      const ngUrl = '/app/app.component.html';\n-      const templateUrl = '/app/app.component.html';\n-\n-      function templateDecorator(template: string) {\n-        appDir['app.component.html'] = template;\n-        return `templateUrl: 'app.component.html',`;\n-      }\n-\n-      declareTests({ngUrl, templateDecorator});\n-    });\n-\n-    function declareTests({ngUrl, templateDecorator}:\n-                              {ngUrl: string, templateDecorator: (template: string) => string}) {\n-      it('should use the right source url in html parse errors', () => {\n-        appDir['app.component.ts'] = createComponentSource(templateDecorator('<div>\\n  </error>'));\n-\n-        expect(() => compileApp())\n-            .toThrowError(new RegExp(`Template parse errors[\\\\s\\\\S]*${ngUrl}@1:2`));\n-      });\n-\n-      it('should use the right source url in template parse errors', () => {\n-        appDir['app.component.ts'] =\n-            createComponentSource(templateDecorator('<div>\\n  <div unknown=\"{{ctxProp}}\"></div>'));\n-\n-        expect(() => compileApp())\n-            .toThrowError(new RegExp(`Template parse errors[\\\\s\\\\S]*${ngUrl}@1:7`));\n-      });\n-\n-      it('should create a sourceMap for the template', () => {\n-        const template = 'Hello World!';\n-\n-        appDir['app.component.ts'] = createComponentSource(templateDecorator(template));\n-\n-        const genFile = compileApp();\n-        const genSource = toTypeScript(genFile);\n-        const sourceMap = extractSourceMap(genSource)!;\n-        expect(sourceMap.file).toEqual(genFile.genFileUrl);\n-\n-        // Note: the generated file also contains code that is not mapped to\n-        // the template (e.g. import statements, ...)\n-        const templateIndex = sourceMap.sources.indexOf(ngUrl);\n-        expect(sourceMap.sourcesContent[templateIndex]).toEqual(template);\n-\n-        // for the mapping to the original source file we don't store the source code\n-        // as we want to keep whatever TypeScript / ... produced for them.\n-        const sourceIndex = sourceMap.sources.indexOf(ngFactoryPath);\n-        expect(sourceMap.sourcesContent[sourceIndex]).toBe(' ');\n-      });\n-\n-      it('should map elements correctly to the source', () => {\n-        const template = '<div>\\n   <span></span></div>';\n-\n-        appDir['app.component.ts'] = createComponentSource(templateDecorator(template));\n-\n-        const genFile = compileApp();\n-        const genSource = toTypeScript(genFile);\n-        const sourceMap = extractSourceMap(genSource)!;\n-        expect(originalPositionFor(sourceMap, findLineAndColumn(genSource, `'span'`)!))\n-            .toEqual({line: 2, column: 3, source: ngUrl});\n-      });\n-\n-      it('should map bindings correctly to the source', () => {\n-        const template = `<div>\\n   <span [title]=\"someMethod()\"></span></div>`;\n-\n-        appDir['app.component.ts'] = createComponentSource(templateDecorator(template));\n-\n-        const genFile = compileApp();\n-        const genSource = toTypeScript(genFile);\n-        const sourceMap = extractSourceMap(genSource)!;\n-        expect(originalPositionFor(sourceMap, findLineAndColumn(genSource, `someMethod()`)!))\n-            .toEqual({line: 2, column: 9, source: ngUrl});\n-      });\n-\n-      it('should map events correctly to the source', () => {\n-        const template = `<div>\\n   <span (click)=\"someMethod()\"></span></div>`;\n-\n-        appDir['app.component.ts'] = createComponentSource(templateDecorator(template));\n-\n-        const genFile = compileApp();\n-        const genSource = toTypeScript(genFile);\n-        const sourceMap = extractSourceMap(genSource)!;\n-        expect(originalPositionFor(sourceMap, findLineAndColumn(genSource, `someMethod()`)!))\n-            .toEqual({line: 2, column: 9, source: ngUrl});\n-      });\n-\n-      it('should map non template parts to the factory file', () => {\n-        appDir['app.component.ts'] = createComponentSource(templateDecorator('Hello World!'));\n-\n-        const genFile = compileApp();\n-        const genSource = toTypeScript(genFile);\n-        const sourceMap = extractSourceMap(genSource)!;\n-        expect(originalPositionFor(sourceMap, {line: 1, column: 0}))\n-            .toEqual({line: 1, column: 0, source: ngFactoryPath});\n-      });\n-    }\n-  });\n-\n-  describe('errors', () => {\n-    it('should not error or warn if an unprovided @Injectable with DI-incompatible ' +\n-           'constructor is discovered',\n-       () => {\n-         const FILES: MockDirectory = {\n-           app: {\n-             'app.ts': `\n-            import {Injectable, NgModule} from '@angular/core';\n-\n-            // This injectable is not provided. It is used as a base class for another\n-            // service but is not directly provided. It's allowed for such classes to\n-            // have a decorator applied as they use Angular features.\n-            @Injectable()\n-            export class ServiceBase {\n-              constructor(a: boolean) {}\n-\n-              ngOnDestroy() {}\n-            }\n-\n-            @Injectable()\n-            export class MyService extends ServiceBase {\n-              constructor() {\n-                super(true);\n-              }\n-            }\n-\n-            @NgModule({providers: [MyService]})\n-            export class AppModule {}\n-          `\n-           }\n-         };\n-\n-         spyOn(console, 'error');\n-         spyOn(console, 'warn');\n-         expect(() => compile([FILES, angularFiles])).not.toThrowError();\n-         expect(console.warn).toHaveBeenCalledTimes(0);\n-         expect(console.error).toHaveBeenCalledTimes(0);\n-       });\n-\n-    it('should error if parameters of a provided @Injectable class cannot be resolved', () => {\n-      const FILES: MockDirectory = {\n-        app: {\n-          'app.ts': `\n-            import {Injectable, NgModule} from '@angular/core';\n-\n-            @Injectable()\n-            export class MyService {\n-              constructor(a: boolean) {}\n-            }\n-\n-            @NgModule({\n-              providers: [MyService],\n-            })\n-            export class MyModule {}\n-          `\n-        }\n-      };\n-      expect(() => compile([FILES, angularFiles]))\n-          .toThrowError(`Can't resolve all parameters for MyService in /app/app.ts: (?).`);\n-    });\n-\n-    it('should error if not all arguments of an @Injectable class can be resolved if strictInjectionParameters is true',\n-       () => {\n-         const FILES: MockDirectory = {\n-           app: {\n-             'app.ts': `\n-                import {Injectable} from '@angular/core';\n-\n-                @Injectable()\n-                export class MyService {\n-                  constructor(a: boolean) {}\n-                }\n-              `\n-           }\n-         };\n-         const warnSpy = spyOn(console, 'warn');\n-         expect(() => compile([FILES, angularFiles], {strictInjectionParameters: true}))\n-             .toThrowError(`Can't resolve all parameters for MyService in /app/app.ts: (?).`);\n-         expect(warnSpy).not.toHaveBeenCalled();\n-       });\n-\n-    it('should be able to suppress a null access', () => {\n-      const FILES: MockDirectory = {\n-        app: {\n-          'app.ts': `\n-                import {Component, NgModule} from '@angular/core';\n-\n-                interface Person { name: string; }\n-\n-                @Component({\n-                  selector: 'my-comp',\n-                  template: '{{maybe_person!.name}}'\n-                })\n-                export class MyComp {\n-                  maybe_person?: Person;\n-                }\n-\n-                @NgModule({\n-                  declarations: [MyComp]\n-                })\n-                export class MyModule {}\n-              `\n-        }\n-      };\n-      compile([FILES, angularFiles], {postCompile: expectNoDiagnostics});\n-    });\n-\n-    it('should not contain a self import in factory', () => {\n-      const FILES: MockDirectory = {\n-        app: {\n-          'app.ts': `\n-                import {Component, NgModule} from '@angular/core';\n-\n-                interface Person { name: string; }\n-\n-                @Component({\n-                  selector: 'my-comp',\n-                  template: '{{person.name}}'\n-                })\n-                export class MyComp {\n-                  person: Person;\n-                }\n-\n-                @NgModule({\n-                  declarations: [MyComp]\n-                })\n-                export class MyModule {}\n-              `\n-        }\n-      };\n-      compile([FILES, angularFiles], {\n-        postCompile: program => {\n-          const factorySource = program.getSourceFile('/app/app.ngfactory.ts')!;\n-          expect(factorySource.text).not.toContain('\\'/app/app.ngfactory\\'');\n-        }\n-      });\n-    });\n-  });\n-\n-  it('should report when a component is declared in any module', () => {\n-    const FILES: MockDirectory = {\n-      app: {\n-        'app.ts': `\n-          import {Component, NgModule} from '@angular/core';\n-\n-          @Component({selector: 'my-comp', template: ''})\n-          export class MyComp {}\n-\n-          @NgModule({})\n-          export class MyModule {}\n-        `\n-      }\n-    };\n-    expect(() => compile([FILES, angularFiles]))\n-        .toThrowError(/Cannot determine the module for class MyComp/);\n-  });\n-\n-  it('should add the preamble to generated files', () => {\n-    const FILES: MockDirectory = {\n-      app: {\n-        'app.ts': `\n-              import { NgModule, Component } from '@angular/core';\n-\n-              @Component({ template: '' })\n-              export class AppComponent {}\n-\n-              @NgModule({ declarations: [ AppComponent ] })\n-              export class AppModule { }\n-            `\n-      }\n-    };\n-    const genFilePreamble = '/* Hello world! */';\n-    const {genFiles} = compile([FILES, angularFiles]);\n-    const genFile =\n-        genFiles.find(gf => gf.srcFileUrl === '/app/app.ts' && gf.genFileUrl.endsWith('.ts'))!;\n-    const genSource = toTypeScript(genFile, genFilePreamble);\n-    expect(genSource.startsWith(genFilePreamble)).toBe(true);\n-  });\n-\n-  it('should be able to use animation macro methods', () => {\n-    const FILES = {\n-      app: {\n-        'app.ts': `\n-      import {Component, NgModule} from '@angular/core';\n-      import {trigger, state, style, transition, animate} from '@angular/animations';\n-\n-      export const EXPANSION_PANEL_ANIMATION_TIMING = '225ms cubic-bezier(0.4,0.0,0.2,1)';\n-\n-      @Component({\n-        selector: 'app-component',\n-        template: '<div></div>',\n-        animations: [\n-          trigger('bodyExpansion', [\n-            state('collapsed', style({height: '0px'})),\n-            state('expanded', style({height: '*'})),\n-            transition('expanded <=> collapsed', animate(EXPANSION_PANEL_ANIMATION_TIMING)),\n-          ]),\n-          trigger('displayMode', [\n-            state('collapsed', style({margin: '0'})),\n-            state('default', style({margin: '16px 0'})),\n-            state('flat', style({margin: '0'})),\n-            transition('flat <=> collapsed, default <=> collapsed, flat <=> default',\n-                      animate(EXPANSION_PANEL_ANIMATION_TIMING)),\n-          ]),\n-        ],\n-      })\n-      export class AppComponent { }\n-\n-      @NgModule({ declarations: [ AppComponent ] })\n-      export class AppModule { }\n-    `\n-      }\n-    };\n-    compile([FILES, angularFiles]);\n-  });\n-\n-  it('should detect an entry component via an indirection', () => {\n-    const FILES = {\n-      app: {\n-        'app.ts': `\n-          import {NgModule, ANALYZE_FOR_ENTRY_COMPONENTS} from '@angular/core';\n-          import {AppComponent} from './app.component';\n-          import {COMPONENT_VALUE, MyComponent} from './my-component';\n-\n-          @NgModule({\n-            declarations: [ AppComponent, MyComponent ],\n-            bootstrap: [ AppComponent ],\n-            providers: [{\n-              provide: ANALYZE_FOR_ENTRY_COMPONENTS,\n-              multi: true,\n-              useValue: COMPONENT_VALUE\n-            }],\n-          })\n-          export class AppModule { }\n-        `,\n-        'app.component.ts': `\n-          import {Component} from '@angular/core';\n-\n-          @Component({\n-            selector: 'app-component',\n-            template: '<div></div>',\n-          })\n-          export class AppComponent { }\n-        `,\n-        'my-component.ts': `\n-          import {Component} from '@angular/core';\n-\n-          @Component({\n-            selector: 'my-component',\n-            template: '<div></div>',\n-          })\n-          export class MyComponent {}\n-\n-          export const COMPONENT_VALUE = [{a: 'b', component: MyComponent}];\n-        `\n-      }\n-    };\n-    const result = compile([FILES, angularFiles]);\n-    const appModuleFactory =\n-        result.genFiles.find(f => /my-component\\.ngfactory/.test(f.genFileUrl));\n-    expect(appModuleFactory).toBeDefined();\n-    if (appModuleFactory) {\n-      expect(toTypeScript(appModuleFactory)).toContain('MyComponentNgFactory');\n-    }\n-  });\n-\n-  describe('ComponentFactories', () => {\n-    it('should include inputs, outputs and ng-content selectors in the component factory', () => {\n-      const FILES: MockDirectory = {\n-        app: {\n-          'app.ts': `\n-                import {Component, NgModule, Input, Output} from '@angular/core';\n-\n-                @Component({\n-                  selector: 'my-comp',\n-                  template:\n-                  '<ng-content select=\"child1\"></ng-content>' +\n-                  '<ng-content></ng-content>' +\n-                  '<ng-template><ng-content select=\"child2\"></ng-content></ng-template>' +\n-                  '<ng-content select=\"child3\"></ng-content>' +\n-                  '<ng-content select=\"child1\"></ng-content>'\n-                })\n-                export class MyComp {\n-                  @Input('aInputName')\n-                  aInputProp: string;\n-\n-                  @Output('aOutputName')\n-                  aOutputProp: any;\n-                }\n-\n-                @NgModule({\n-                  declarations: [MyComp]\n-                })\n-                export class MyModule {}\n-              `\n-        }\n-      };\n-      const {genFiles} = compile([FILES, angularFiles]);\n-      const genFile = genFiles.find(genFile => genFile.srcFileUrl === '/app/app.ts')!;\n-      const genSource = toTypeScript(genFile);\n-      const createComponentFactoryCall = /ɵccf\\([^)]*\\)/m.exec(genSource)![0].replace(/\\s*/g, '');\n-      // selector\n-      expect(createComponentFactoryCall).toContain('my-comp');\n-      // inputs\n-      expect(createComponentFactoryCall).toContain(`{aInputProp:'aInputName'}`);\n-      // outputs\n-      expect(createComponentFactoryCall).toContain(`{aOutputProp:'aOutputName'}`);\n-      // ngContentSelectors - note that the catch-all doesn't have to appear at the start\n-      expect(createComponentFactoryCall).toContain(`['child1','*','child2','child3','child1']`);\n-    });\n-  });\n-\n-  describe('generated templates', () => {\n-    it('should not call `check` for directives without bindings nor ngDoCheck/ngOnInit', () => {\n-      const FILES: MockDirectory = {\n-        app: {\n-          'app.ts': `\n-                import { NgModule, Component } from '@angular/core';\n-\n-                @Component({ template: '' })\n-                export class AppComponent {}\n-\n-                @NgModule({ declarations: [ AppComponent ] })\n-                export class AppModule { }\n-              `\n-        }\n-      };\n-      const {genFiles} = compile([FILES, angularFiles]);\n-      const genFile =\n-          genFiles.find(gf => gf.srcFileUrl === '/app/app.ts' && gf.genFileUrl.endsWith('.ts'))!;\n-      const genSource = toTypeScript(genFile);\n-      expect(genSource).not.toContain('check(');\n-    });\n-  });\n-\n-  describe('summaries', () => {\n-    let angularSummaryFiles: MockDirectory;\n-    beforeAll(() => {\n-      angularSummaryFiles = compile(angularFiles, {useSummaries: false, emit: true}).outDir;\n-    });\n-\n-    inheritanceWithSummariesSpecs(() => angularSummaryFiles);\n-\n-    describe('external symbol re-exports enabled', () => {\n-      it('should not reexport type symbols mentioned in constructors', () => {\n-        const libInput: MockDirectory = {\n-          'lib': {\n-            'base.ts': `\n-              export class AValue {}\n-              export type AType = {};\n-\n-              export class AClass {\n-                constructor(a: AType, b: AValue) {}\n-              }\n-            `\n-          }\n-        };\n-        const appInput: MockDirectory = {\n-          'app': {\n-            'main.ts': `\n-              export {AClass} from '../lib/base';\n-            `\n-          }\n-        };\n-\n-        const {outDir: libOutDir} = compile(\n-            [libInput, angularSummaryFiles],\n-            {useSummaries: true, createExternalSymbolFactoryReexports: true});\n-        const {genFiles: appGenFiles} = compile(\n-            [appInput, libOutDir, angularSummaryFiles],\n-            {useSummaries: true, createExternalSymbolFactoryReexports: true});\n-        const appNgFactory = appGenFiles.find((f) => f.genFileUrl === '/app/main.ngfactory.ts')!;\n-        const appNgFactoryTs = toTypeScript(appNgFactory);\n-        expect(appNgFactoryTs).not.toContain('AType');\n-        expect(appNgFactoryTs).toContain('AValue');\n-      });\n-\n-      it('should not reexport complex function calls', () => {\n-        const libInput: MockDirectory = {\n-          'lib': {\n-            'base.ts': `\n-              export class AClass {\n-                constructor(arg: any) {}\n-\n-                static create(arg: any = null): AClass { return new AClass(arg); }\n-\n-                call(arg: any) {}\n-              }\n-\n-              export function simple(arg: any) { return [arg]; }\n-\n-              export const ctor_arg = {};\n-              export const ctor_call = new AClass(ctor_arg);\n-\n-              export const static_arg = {};\n-              export const static_call = AClass.create(static_arg);\n-\n-              export const complex_arg = {};\n-              export const complex_call = AClass.create().call(complex_arg);\n-\n-              export const simple_arg = {};\n-              export const simple_call = simple(simple_arg);\n-            `\n-          }\n-        };\n-        const appInput: MockDirectory = {\n-          'app': {\n-            'main.ts': `\n-              import {ctor_call, static_call, complex_call, simple_call} from '../lib/base';\n-\n-              export const calls = [ctor_call, static_call, complex_call, simple_call];\n-            `,\n-          }\n-        };\n-\n-        const {outDir: libOutDir} = compile(\n-            [libInput, angularSummaryFiles],\n-            {useSummaries: true, createExternalSymbolFactoryReexports: true});\n-        const {genFiles: appGenFiles} = compile(\n-            [appInput, libOutDir, angularSummaryFiles],\n-            {useSummaries: true, createExternalSymbolFactoryReexports: true});\n-        const appNgFactory = appGenFiles.find((f) => f.genFileUrl === '/app/main.ngfactory.ts')!;\n-        const appNgFactoryTs = toTypeScript(appNgFactory);\n-\n-        // metadata of ctor calls is preserved, so we reexport the argument\n-        expect(appNgFactoryTs).toContain('ctor_arg');\n-        expect(appNgFactoryTs).toContain('ctor_call');\n-\n-        // metadata of static calls is preserved, so we reexport the argument\n-        expect(appNgFactoryTs).toContain('static_arg');\n-        expect(appNgFactoryTs).toContain('AClass');\n-        expect(appNgFactoryTs).toContain('static_call');\n-\n-        // metadata of complex calls is elided, so we don't reexport the argument\n-        expect(appNgFactoryTs).not.toContain('complex_arg');\n-        expect(appNgFactoryTs).toContain('complex_call');\n-\n-        // metadata of simple calls is preserved, so we reexport the argument\n-        expect(appNgFactoryTs).toContain('simple_arg');\n-        expect(appNgFactoryTs).toContain('simple_call');\n-      });\n-\n-      it('should not reexport already exported symbols except for lowered symbols', () => {\n-        const libInput: MockDirectory = {\n-          'lib': {\n-            'base.ts': `\n-              export const exportedVar = 1;\n-\n-              // A symbol introduced by lowering expressions\n-              export const ɵ1 = 'lowered symbol';\n-            `\n-          }\n-        };\n-        const appInput: MockDirectory = {\n-          'app': {\n-            'main.ts': `export * from '../lib/base';`,\n-          }\n-        };\n-\n-        const {outDir: libOutDir} = compile(\n-            [libInput, angularSummaryFiles],\n-            {useSummaries: true, createExternalSymbolFactoryReexports: true});\n-        const {genFiles: appGenFiles} = compile(\n-            [appInput, libOutDir, angularSummaryFiles],\n-            {useSummaries: true, createExternalSymbolFactoryReexports: true});\n-        const appNgFactory = appGenFiles.find((f) => f.genFileUrl === '/app/main.ngfactory.ts')!;\n-        const appNgFactoryTs = toTypeScript(appNgFactory);\n-\n-        // we don't need to reexport exported symbols via the .ngfactory\n-        // as we can refer to them via the reexport.\n-        expect(appNgFactoryTs).not.toContain('exportedVar');\n-\n-        // although ɵ1 is reexported via `export *`, we still need to reexport it\n-        // via the .ngfactory as tsickle expands `export *` into named exports,\n-        // and doesn't know about our lowered symbols as we introduce them\n-        // after the typecheck phase.\n-        expect(appNgFactoryTs).toContain('ɵ1');\n-      });\n-    });\n-  });\n-\n-  function inheritanceWithSummariesSpecs(getAngularSummaryFiles: () => MockDirectory) {\n-    function compileParentAndChild(\n-        {parentClassDecorator, parentModuleDecorator, childClassDecorator, childModuleDecorator}: {\n-          parentClassDecorator: string,\n-          parentModuleDecorator: string,\n-          childClassDecorator: string,\n-          childModuleDecorator: string\n-        }) {\n-      const libInput: MockDirectory = {\n-        'lib': {\n-          'base.ts': `\n-              import {Injectable, Pipe, Directive, Component, NgModule} from '@angular/core';\n-\n-              ${parentClassDecorator}\n-              export class Base {}\n-\n-              ${parentModuleDecorator}\n-              export class BaseModule {}\n-            `\n-        }\n-      };\n-      const appInput: MockDirectory = {\n-        'app': {\n-          'main.ts': `\n-              import {Injectable, Pipe, Directive, Component, NgModule} from '@angular/core';\n-              import {Base} from '../lib/base';\n-\n-              ${childClassDecorator}\n-              export class Extends extends Base {}\n-\n-              ${childModuleDecorator}\n-              export class MyModule {}\n-            `\n-        }\n-      };\n-\n-      const {outDir: libOutDir} =\n-          compile([libInput, getAngularSummaryFiles()], {useSummaries: true});\n-      const {genFiles} =\n-          compile([libOutDir, appInput, getAngularSummaryFiles()], {useSummaries: true});\n-      return genFiles.find(gf => gf.srcFileUrl === '/app/main.ts');\n-    }\n-\n-    it('should inherit ctor and lifecycle hooks from classes in other compilation units', () => {\n-      const libInput: MockDirectory = {\n-        'lib': {\n-          'base.ts': `\n-            export class AParam {}\n-\n-            export class Base {\n-              constructor(a: AParam) {}\n-              ngOnDestroy() {}\n-            }\n-          `\n-        }\n-      };\n-      const appInput: MockDirectory = {\n-        'app': {\n-          'main.ts': `\n-            import {NgModule, Component} from '@angular/core';\n-            import {Base} from '../lib/base';\n-\n-            @Component({template: ''})\n-            export class Extends extends Base {}\n-\n-            @NgModule({\n-              declarations: [Extends]\n-            })\n-            export class MyModule {}\n-          `\n-        }\n-      };\n-\n-      const {outDir: libOutDir} =\n-          compile([libInput, getAngularSummaryFiles()], {useSummaries: true});\n-      const {genFiles} =\n-          compile([libOutDir, appInput, getAngularSummaryFiles()], {useSummaries: true});\n-      const mainNgFactory = genFiles.find(gf => gf.srcFileUrl === '/app/main.ts')!;\n-      const flags = NodeFlags.TypeDirective | NodeFlags.Component | NodeFlags.OnDestroy;\n-      expect(toTypeScript(mainNgFactory))\n-          .toContain(`${flags},(null as any),0,i1.Extends,[i2.AParam]`);\n-    });\n-\n-    it('should inherit ctor and lifecycle hooks from classes in other compilation units over 2 levels',\n-       () => {\n-         const lib1Input: MockDirectory = {\n-           'lib1': {\n-             'base.ts': `\n-            export class AParam {}\n-\n-            export class Base {\n-              constructor(a: AParam) {}\n-              ngOnDestroy() {}\n-            }\n-          `\n-           }\n-         };\n-\n-         const lib2Input: MockDirectory = {\n-           'lib2': {\n-             'middle.ts': `\n-            import {Base} from '../lib1/base';\n-            export class Middle extends Base {}\n-          `\n-           }\n-         };\n-\n-\n-         const appInput: MockDirectory = {\n-           'app': {\n-             'main.ts': `\n-            import {NgModule, Component} from '@angular/core';\n-            import {Middle} from '../lib2/middle';\n-\n-            @Component({template: ''})\n-            export class Extends extends Middle {}\n-\n-            @NgModule({\n-              declarations: [Extends]\n-            })\n-            export class MyModule {}\n-          `\n-           }\n-         };\n-         const {outDir: lib1OutDir} =\n-             compile([lib1Input, getAngularSummaryFiles()], {useSummaries: true});\n-         const {outDir: lib2OutDir} =\n-             compile([lib1OutDir, lib2Input, getAngularSummaryFiles()], {useSummaries: true});\n-         const {genFiles} = compile(\n-             [lib1OutDir, lib2OutDir, appInput, getAngularSummaryFiles()], {useSummaries: true});\n-\n-         const mainNgFactory = genFiles.find(gf => gf.srcFileUrl === '/app/main.ts')!;\n-         const flags = NodeFlags.TypeDirective | NodeFlags.Component | NodeFlags.OnDestroy;\n-         const mainNgFactorySource = toTypeScript(mainNgFactory);\n-         expect(mainNgFactorySource).toContain(`import * as i2 from '/lib1/base';`);\n-         expect(mainNgFactorySource).toContain(`${flags},(null as any),0,i1.Extends,[i2.AParam]`);\n-       });\n-\n-    describe('Injectable', () => {\n-      it('should allow to inherit', () => {\n-        const mainNgFactory = compileParentAndChild({\n-          parentClassDecorator: '@Injectable()',\n-          parentModuleDecorator: '@NgModule({providers: [Base]})',\n-          childClassDecorator: '@Injectable()',\n-          childModuleDecorator: '@NgModule({providers: [Extends]})',\n-        });\n-        expect(mainNgFactory).toBeTruthy();\n-      });\n-\n-      it('should error if the child class has no matching decorator', () => {\n-        expect(() => compileParentAndChild({\n-                 parentClassDecorator: '@Injectable()',\n-                 parentModuleDecorator: '@NgModule({providers: [Base]})',\n-                 childClassDecorator: '',\n-                 childModuleDecorator: '@NgModule({providers: [Extends]})',\n-               }))\n-            .toThrowError(`Error during template compile of 'Extends'\n-  Class Extends in /app/main.ts extends from a Injectable in another compilation unit without duplicating the decorator\n-    Please add a Injectable or Pipe or Directive or Component or NgModule decorator to the class.`);\n-      });\n-    });\n-\n-    describe('Component', () => {\n-      it('should allow to inherit', () => {\n-        const mainNgFactory = compileParentAndChild({\n-          parentClassDecorator: `@Component({template: ''})`,\n-          parentModuleDecorator: '@NgModule({declarations: [Base]})',\n-          childClassDecorator: `@Component({template: ''})`,\n-          childModuleDecorator: '@NgModule({declarations: [Extends]})'\n-        });\n-        expect(mainNgFactory).toBeTruthy();\n-      });\n-\n-      it('should error if the child class has no matching decorator', () => {\n-        expect(() => compileParentAndChild({\n-                 parentClassDecorator: `@Component({template: ''})`,\n-                 parentModuleDecorator: '@NgModule({declarations: [Base]})',\n-                 childClassDecorator: '',\n-                 childModuleDecorator: '@NgModule({declarations: [Extends]})',\n-               }))\n-            .toThrowError(`Error during template compile of 'Extends'\n-  Class Extends in /app/main.ts extends from a Directive in another compilation unit without duplicating the decorator\n-    Please add a Directive or Component decorator to the class.`);\n-      });\n-    });\n-\n-    describe('Directive', () => {\n-      it('should allow to inherit', () => {\n-        const mainNgFactory = compileParentAndChild({\n-          parentClassDecorator: `@Directive({selector: '[someDir]'})`,\n-          parentModuleDecorator: '@NgModule({declarations: [Base]})',\n-          childClassDecorator: `@Directive({selector: '[someDir]'})`,\n-          childModuleDecorator: '@NgModule({declarations: [Extends]})',\n-        });\n-        expect(mainNgFactory).toBeTruthy();\n-      });\n-\n-      it('should error if the child class has no matching decorator', () => {\n-        expect(() => compileParentAndChild({\n-                 parentClassDecorator: `@Directive({selector: '[someDir]'})`,\n-                 parentModuleDecorator: '@NgModule({declarations: [Base]})',\n-                 childClassDecorator: '',\n-                 childModuleDecorator: '@NgModule({declarations: [Extends]})',\n-               }))\n-            .toThrowError(`Error during template compile of 'Extends'\n-  Class Extends in /app/main.ts extends from a Directive in another compilation unit without duplicating the decorator\n-    Please add a Directive or Component decorator to the class.`);\n-      });\n-    });\n-\n-    describe('Pipe', () => {\n-      it('should allow to inherit', () => {\n-        const mainNgFactory = compileParentAndChild({\n-          parentClassDecorator: `@Pipe({name: 'somePipe'})`,\n-          parentModuleDecorator: '@NgModule({declarations: [Base]})',\n-          childClassDecorator: `@Pipe({name: 'somePipe'})`,\n-          childModuleDecorator: '@NgModule({declarations: [Extends]})',\n-        });\n-        expect(mainNgFactory).toBeTruthy();\n-      });\n-\n-      it('should error if the child class has no matching decorator', () => {\n-        expect(() => compileParentAndChild({\n-                 parentClassDecorator: `@Pipe({name: 'somePipe'})`,\n-                 parentModuleDecorator: '@NgModule({declarations: [Base]})',\n-                 childClassDecorator: '',\n-                 childModuleDecorator: '@NgModule({declarations: [Extends]})',\n-               }))\n-            .toThrowError(`Error during template compile of 'Extends'\n-  Class Extends in /app/main.ts extends from a Pipe in another compilation unit without duplicating the decorator\n-    Please add a Pipe decorator to the class.`);\n-      });\n-    });\n-\n-    describe('NgModule', () => {\n-      it('should allow to inherit', () => {\n-        const mainNgFactory = compileParentAndChild({\n-          parentClassDecorator: `@NgModule()`,\n-          parentModuleDecorator: '',\n-          childClassDecorator: `@NgModule()`,\n-          childModuleDecorator: '',\n-        });\n-        expect(mainNgFactory).toBeTruthy();\n-      });\n-\n-      it('should error if the child class has no matching decorator', () => {\n-        expect(() => compileParentAndChild({\n-                 parentClassDecorator: `@NgModule()`,\n-                 parentModuleDecorator: '',\n-                 childClassDecorator: '',\n-                 childModuleDecorator: '',\n-               }))\n-            .toThrowError(`Error during template compile of 'Extends'\n-  Class Extends in /app/main.ts extends from a NgModule in another compilation unit without duplicating the decorator\n-    Please add a NgModule decorator to the class.`);\n-      });\n-    });\n-  }\n-});\n-\n-describe('compiler (bundled Angular)', () => {\n-  let angularFiles: Map<string, string> = setup();\n-\n-  beforeAll(() => {\n-    if (!isInBazel()) {\n-      // If we are not using Bazel then we need to build these files explicitly\n-      const emittingHost = new EmittingCompilerHost(['@angular/core/index'], {emitMetadata: false});\n-\n-      // Create the metadata bundled\n-      const indexModule = emittingHost.effectiveName('@angular/core/index');\n-      const bundler = new MetadataBundler(\n-          indexModule, '@angular/core', new MockMetadataBundlerHost(emittingHost));\n-      const bundle = bundler.getMetadataBundle();\n-      const metadata = JSON.stringify(bundle.metadata, null, ' ');\n-      const bundleIndexSource = privateEntriesToIndex('./index', bundle.privates);\n-      emittingHost.override('@angular/core/bundle_index.ts', bundleIndexSource);\n-      emittingHost.addWrittenFile(\n-          '@angular/core/package.json', JSON.stringify({typings: 'bundle_index.d.ts'}));\n-      emittingHost.addWrittenFile('@angular/core/bundle_index.metadata.json', metadata);\n-\n-      // Emit the sources\n-      const bundleIndexName = emittingHost.effectiveName('@angular/core/bundle_index.ts');\n-      const emittingProgram = ts.createProgram([bundleIndexName], settings, emittingHost);\n-      emittingProgram.emit();\n-      angularFiles = emittingHost.writtenAngularFiles();\n-    }\n-  });\n-\n-  describe('Quickstart', () => {\n-    it('should compile', () => {\n-      const {genFiles} = compile([QUICKSTART, angularFiles]);\n-      expect(genFiles.find(f => /app\\.component\\.ngfactory\\.ts/.test(f.genFileUrl))).toBeDefined();\n-      expect(genFiles.find(f => /app\\.module\\.ngfactory\\.ts/.test(f.genFileUrl))).toBeDefined();\n-    });\n-\n-    it('should support tsx', () => {\n-      const tsOptions = {jsx: ts.JsxEmit.React};\n-      const {genFiles} =\n-          compile([QUICKSTART_TSX, angularFiles], /* options */ undefined, tsOptions);\n-      expect(genFiles.find(f => /app\\.component\\.ngfactory\\.ts/.test(f.genFileUrl))).toBeDefined();\n-      expect(genFiles.find(f => /app\\.module\\.ngfactory\\.ts/.test(f.genFileUrl))).toBeDefined();\n-    });\n-  });\n-\n-  describe('Bundled library', () => {\n-    let libraryFiles: MockDirectory;\n-\n-    beforeAll(() => {\n-      // Emit the library bundle\n-      const emittingHost =\n-          new EmittingCompilerHost(['/bolder/index.ts'], {emitMetadata: false, mockData: LIBRARY});\n-\n-      if (isInBazel()) {\n-        // In bazel we can just add the angular files from the ones read during setup.\n-        emittingHost.addFiles(angularFiles);\n-      }\n-\n-      // Create the metadata bundled\n-      const indexModule = '/bolder/public-api';\n-      const bundler =\n-          new MetadataBundler(indexModule, 'bolder', new MockMetadataBundlerHost(emittingHost));\n-      const bundle = bundler.getMetadataBundle();\n-      const metadata = JSON.stringify(bundle.metadata, null, ' ');\n-      const bundleIndexSource = privateEntriesToIndex('./public-api', bundle.privates);\n-      emittingHost.override('/bolder/index.ts', bundleIndexSource);\n-      emittingHost.addWrittenFile('/bolder/index.metadata.json', metadata);\n-\n-      // Emit the sources\n-      const emittingProgram = ts.createProgram(['/bolder/index.ts'], settings, emittingHost);\n-      emittingProgram.emit();\n-      const libFiles = emittingHost.written;\n-\n-      // Copy the .html file\n-      const htmlFileName = '/bolder/src/bolder.component.html';\n-      libFiles.set(htmlFileName, emittingHost.readFile(htmlFileName));\n-\n-      libraryFiles = arrayToMockDir(toMockFileArray(libFiles).map(\n-          ({fileName, content}) => ({fileName: `/node_modules${fileName}`, content})));\n-    });\n-\n-    it('should compile', () => compile([LIBRARY_USING_APP, libraryFiles, angularFiles]));\n-  });\n-});\n-\n-\n-const QUICKSTART: MockDirectory = {\n-  quickstart: {\n-    app: {\n-      'app.component.ts': `\n-        import {Component} from '@angular/core';\n-\n-        @Component({\n-          template: '<h1>Hello {{name}}</h1>'\n-        })\n-        export class AppComponent {\n-          name = 'Angular';\n-        }\n-      `,\n-      'app.module.ts': `\n-        import { NgModule }      from '@angular/core';\n-        import { toString }      from './utils';\n-\n-        import { AppComponent }  from './app.component';\n-\n-        @NgModule({\n-          declarations: [ AppComponent ],\n-          bootstrap:    [ AppComponent ]\n-        })\n-        export class AppModule { }\n-      `,\n-      // #15420\n-      'utils.ts': `\n-        export function toString(value: any): string {\n-          return  '';\n-        }\n-      `\n-    }\n-  }\n-};\n-\n-const QUICKSTART_TSX: MockDirectory = {\n-  quickstart: {\n-    app: {\n-      // #20555\n-      'app.component.tsx': `\n-        import {Component} from '@angular/core';\n-\n-        @Component({\n-          template: '<h1>Hello {{name}}</h1>'\n-        })\n-        export class AppComponent {\n-          name = 'Angular';\n-        }\n-      `,\n-      'app.module.ts': `\n-        import { NgModule }      from '@angular/core';\n-        import { AppComponent }  from './app.component';\n-\n-        @NgModule({\n-          declarations: [ AppComponent ],\n-          bootstrap:    [ AppComponent ]\n-        })\n-        export class AppModule { }\n-      `\n-    }\n-  }\n-};\n-\n-const LIBRARY: MockDirectory = {\n-  bolder: {\n-    'public-api.ts': `\n-      export * from './src/bolder.component';\n-      export * from './src/bolder.module';\n-      export {BolderModule as ReExportedModule} from './src/bolder.module';\n-    `,\n-    src: {\n-      'bolder.component.ts': `\n-        import {Component, Input} from '@angular/core';\n-\n-        @Component({\n-          selector: 'bolder',\n-          templateUrl: './bolder.component.html'\n-        })\n-        export class BolderComponent {\n-          @Input() data: string;\n-        }\n-      `,\n-      'bolder.component.html': `\n-        <b>{{data}}</b>\n-      `,\n-      'bolder.module.ts': `\n-        import {NgModule} from '@angular/core';\n-        import {BolderComponent} from './bolder.component';\n-\n-        @NgModule({\n-          declarations: [BolderComponent],\n-          exports: [BolderComponent]\n-        })\n-        export class BolderModule {}\n-      `\n-    }\n-  }\n-};\n-\n-const LIBRARY_USING_APP: MockDirectory = {\n-  'lib-user': {\n-    app: {\n-      'app.component.ts': `\n-        import {Component} from '@angular/core';\n-\n-        @Component({\n-          template: '<h1>Hello <bolder [data]=\"name\"></bolder></h1>'\n-        })\n-        export class AppComponent {\n-          name = 'Angular';\n-        }\n-      `,\n-      'app.module.ts': `\n-        import { NgModule }      from '@angular/core';\n-        import { BolderModule }  from 'bolder';\n-\n-        import { AppComponent }  from './app.component';\n-\n-        @NgModule({\n-          declarations: [ AppComponent ],\n-          bootstrap:    [ AppComponent ],\n-          imports:      [ BolderModule ]\n-        })\n-        export class AppModule { }\n-      `\n-    }\n-  }\n-};"
        },
        {
            "sha": "9d37f8ce5207b50c0699dd4b16493f5d52a982bb",
            "filename": "packages/compiler/test/aot/jit_summaries_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 463,
            "changes": 463,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Faot%2Fjit_summaries_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Faot%2Fjit_summaries_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Faot%2Fjit_summaries_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,463 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {AotCompiler, AotCompilerHost, AotCompilerOptions, CompileSummaryKind, GeneratedFile, toTypeScript} from '@angular/compiler';\n-\n-import {compile, MockDirectory, setup} from './test_util';\n-\n-describe('aot summaries for jit', () => {\n-  let angularFiles = setup();\n-  let angularSummaryFiles: MockDirectory;\n-\n-  beforeEach(() => {\n-    angularSummaryFiles = compile(angularFiles, {useSummaries: false, emit: true}).outDir;\n-  });\n-\n-  function compileApp(\n-      rootDir: MockDirectory, options: {useSummaries?: boolean}&AotCompilerOptions = {}):\n-      {genFiles: GeneratedFile[], outDir: MockDirectory} {\n-    return compile(\n-        [rootDir, options.useSummaries ? angularSummaryFiles : angularFiles],\n-        {...options, enableSummariesForJit: true});\n-  }\n-\n-  it('should create @Injectable summaries', () => {\n-    const appDir = {\n-      'app.module.ts': `\n-        import { Injectable } from '@angular/core';\n-\n-        export class Dep {}\n-\n-        @Injectable()\n-        export class MyService {\n-          constructor(d: Dep) {}\n-        }\n-      `\n-    };\n-    const rootDir = {'app': appDir};\n-\n-    const genFile =\n-        compileApp(rootDir).genFiles.find(f => f.genFileUrl === '/app/app.module.ngsummary.ts')!;\n-    const genSource = toTypeScript(genFile);\n-\n-    expect(genSource).toContain(`import * as i0 from '/app/app.module'`);\n-    expect(genSource).toContain('export function MyServiceNgSummary()');\n-    // Note: CompileSummaryKind.Injectable = 3\n-    expect(genSource).toMatch(/summaryKind:3,\\s*type:\\{\\s*reference:i0.MyService/);\n-    expect(genSource).toContain('token:{identifier:{reference:i0.Dep}}');\n-  });\n-\n-  it('should create @Pipe summaries', () => {\n-    const appDir = {\n-      'app.module.ts': `\n-        import { Pipe, NgModule } from '@angular/core';\n-\n-        export class Dep {}\n-\n-        @Pipe({name: 'myPipe'})\n-        export class MyPipe {\n-          constructor(d: Dep) {}\n-        }\n-\n-        @NgModule({declarations: [MyPipe]})\n-        export class MyModule {}\n-      `\n-    };\n-    const rootDir = {'app': appDir};\n-\n-    const genFile =\n-        compileApp(rootDir).genFiles.find(f => f.genFileUrl === '/app/app.module.ngsummary.ts')!;\n-    const genSource = toTypeScript(genFile);\n-\n-    expect(genSource).toContain(`import * as i0 from '/app/app.module'`);\n-    expect(genSource).toContain('export function MyPipeNgSummary()');\n-    // Note: CompileSummaryKind.Pipe = 1\n-    expect(genSource).toMatch(/summaryKind:0,\\s*type:\\{\\s*reference:i0.MyPipe/);\n-    expect(genSource).toContain('token:{identifier:{reference:i0.Dep}}');\n-  });\n-\n-  it('should create @Directive summaries', () => {\n-    const appDir = {\n-      'app.module.ts': `\n-        import { Directive, NgModule } from '@angular/core';\n-\n-        export class Dep {}\n-\n-        @Directive({selector: '[myDir]'})\n-        export class MyDirective {\n-          constructor(a: Dep) {}\n-        }\n-\n-        @NgModule({declarations: [MyDirective]})\n-        export class MyModule {}\n-      `\n-    };\n-    const rootDir = {'app': appDir};\n-\n-    const genFile =\n-        compileApp(rootDir).genFiles.find(f => f.genFileUrl === '/app/app.module.ngsummary.ts')!;\n-    const genSource = toTypeScript(genFile);\n-\n-    expect(genSource).toContain(`import * as i0 from '/app/app.module'`);\n-    expect(genSource).toContain('export function MyDirectiveNgSummary()');\n-    // Note: CompileSummaryKind.Directive = 1\n-    expect(genSource).toMatch(/summaryKind:1,\\s*type:\\{\\s*reference:i0.MyDirective/);\n-    expect(genSource).toContain('token:{identifier:{reference:i0.Dep}}');\n-  });\n-\n-  it('should create @NgModule summaries', () => {\n-    const appDir = {\n-      'app.module.ts': `\n-        import { NgModule } from '@angular/core';\n-\n-        export class Dep {}\n-\n-        @NgModule()\n-        export class MyModule {\n-          constructor(d: Dep) {}\n-        }\n-      `\n-    };\n-    const rootDir = {'app': appDir};\n-\n-    const genFile =\n-        compileApp(rootDir).genFiles.find(f => f.genFileUrl === '/app/app.module.ngsummary.ts')!;\n-    const genSource = toTypeScript(genFile);\n-\n-    expect(genSource).toContain(`import * as i0 from '/app/app.module'`);\n-    expect(genSource).toContain('export function MyModuleNgSummary()');\n-    // Note: CompileSummaryKind.NgModule = 2\n-    expect(genSource).toMatch(/summaryKind:2,\\s*type:\\{\\s*reference:i0.MyModule/);\n-    expect(genSource).toContain('token:{identifier:{reference:i0.Dep}}');\n-  });\n-\n-  it('should embed useClass provider summaries in @Directive summaries', () => {\n-    const appDir = {\n-      'app.service.ts': `\n-        import { Injectable } from '@angular/core';\n-\n-        export class Dep {}\n-\n-        @Injectable()\n-        export class MyService {\n-          constructor(d: Dep) {}\n-        }\n-      `,\n-      'app.module.ts': `\n-        import { Directive, NgModule } from '@angular/core';\n-        import { MyService } from './app.service';\n-\n-        @Directive({\n-          selector: '[myDir]',\n-          providers: [MyService]\n-        })\n-        export class MyDirective {}\n-\n-        @NgModule({declarations: [MyDirective]})\n-        export class MyModule {}\n-      `\n-    };\n-    const rootDir = {'app': appDir};\n-\n-    const genFile =\n-        compileApp(rootDir).genFiles.find(f => f.genFileUrl === '/app/app.module.ngsummary.ts')!;\n-    const genSource = toTypeScript(genFile);\n-\n-    expect(genSource).toMatch(/useClass:\\{\\s*reference:i1.MyService/);\n-    // Note: CompileSummaryKind.Injectable = 3\n-    expect(genSource).toMatch(/summaryKind:3,\\s*type:\\{\\s*reference:i1.MyService/);\n-    expect(genSource).toContain('token:{identifier:{reference:i1.Dep}}');\n-  });\n-\n-  it('should embed useClass provider summaries into @NgModule summaries', () => {\n-    const appDir = {\n-      'app.service.ts': `\n-        import { Injectable } from '@angular/core';\n-\n-        export class Dep {}\n-\n-        @Injectable()\n-        export class MyService {\n-          constructor(d: Dep) {}\n-        }\n-      `,\n-      'app.module.ts': `\n-        import { NgModule } from '@angular/core';\n-        import { MyService } from './app.service';\n-\n-        @NgModule({\n-          providers: [MyService]\n-        })\n-        export class MyModule {}\n-      `\n-    };\n-    const rootDir = {'app': appDir};\n-\n-    const genFile =\n-        compileApp(rootDir).genFiles.find(f => f.genFileUrl === '/app/app.module.ngsummary.ts')!;\n-    const genSource = toTypeScript(genFile);\n-\n-    expect(genSource).toMatch(/useClass:\\{\\s*reference:i1.MyService/);\n-    // Note: CompileSummaryKind.Injectable = 3\n-    expect(genSource).toMatch(/summaryKind:3,\\s*type:\\{\\s*reference:i1.MyService/);\n-    expect(genSource).toContain('token:{identifier:{reference:i1.Dep}}');\n-  });\n-\n-  it('should reference declared @Directive and @Pipe summaries in @NgModule summaries', () => {\n-    const appDir = {\n-      'app.module.ts': `\n-        import { Directive, Pipe, NgModule } from '@angular/core';\n-\n-        @Directive({selector: '[myDir]'})\n-        export class MyDirective {}\n-\n-        @Pipe({name: 'myPipe'})\n-        export class MyPipe {}\n-\n-        @NgModule({declarations: [MyDirective, MyPipe]})\n-        export class MyModule {}\n-      `\n-    };\n-    const rootDir = {'app': appDir};\n-\n-    const genFile =\n-        compileApp(rootDir).genFiles.find(f => f.genFileUrl === '/app/app.module.ngsummary.ts')!;\n-    const genSource = toTypeScript(genFile);\n-\n-    expect(genSource).toMatch(\n-        /export function MyModuleNgSummary()[^;]*,\\s*MyDirectiveNgSummary,\\s*MyPipeNgSummary\\s*\\]\\s*;/);\n-  });\n-\n-  it('should reference imported @NgModule summaries in @NgModule summaries', () => {\n-    const appDir = {\n-      'app.module.ts': `\n-        import { NgModule } from '@angular/core';\n-\n-        @NgModule()\n-        export class MyImportedModule {}\n-\n-        @NgModule({imports: [MyImportedModule]})\n-        export class MyModule {}\n-      `\n-    };\n-    const rootDir = {'app': appDir};\n-\n-    const genFile =\n-        compileApp(rootDir).genFiles.find(f => f.genFileUrl === '/app/app.module.ngsummary.ts')!;\n-    const genSource = toTypeScript(genFile);\n-\n-    expect(genSource).toMatch(\n-        /export function MyModuleNgSummary()[^;]*,\\s*MyImportedModuleNgSummary\\s*\\]\\s*;/);\n-  });\n-\n-  it('should create and use reexports for imported NgModules ' +\n-         'across compilation units if symbol re-exports are enabled',\n-     () => {\n-       const lib1In = {\n-         'lib1': {\n-           'module.ts': `\n-          import { NgModule } from '@angular/core';\n-\n-          @NgModule()\n-          export class Lib1Module {}\n-        `,\n-           'reexport.ts': `\n-          import { NgModule } from '@angular/core';\n-\n-          @NgModule()\n-          export class ReexportModule {}\n-\n-          export const reexports: any[] = [ ReexportModule ];\n-        `,\n-         }\n-       };\n-       const {outDir: lib2In, genFiles: lib1Gen} = compileApp(lib1In, {\n-         useSummaries: true,\n-         createExternalSymbolFactoryReexports: true,\n-       });\n-\n-       lib2In['lib2'] = {\n-         'module.ts': `\n-          import { NgModule } from '@angular/core';\n-          import { Lib1Module } from '../lib1/module';\n-\n-          @NgModule({\n-            imports: [Lib1Module]\n-          })\n-          export class Lib2Module {}\n-        `,\n-         'reexport.ts': `\n-        import { reexports as reexports_lib1 } from '../lib1/reexport';\n-        export const reexports: any[] = [ reexports_lib1 ];\n-        `,\n-       };\n-       const {outDir: lib3In, genFiles: lib2Gen} = compileApp(lib2In, {\n-         useSummaries: true,\n-         createExternalSymbolFactoryReexports: true,\n-       });\n-\n-       const lib2ModuleNgSummary = lib2Gen.find(f => f.genFileUrl === '/lib2/module.ngsummary.ts')!;\n-       const lib2ReexportNgSummary =\n-           lib2Gen.find(f => f.genFileUrl === '/lib2/reexport.ngsummary.ts')!;\n-\n-       // ngsummaries should add reexports for imported NgModules from a direct dependency\n-       expect(toTypeScript(lib2ModuleNgSummary))\n-           .toContain(\n-               `export {Lib1ModuleNgSummary as Lib1Module_1NgSummary} from '/lib1/module.ngsummary'`);\n-       // ngsummaries should add reexports for reexported values from a direct dependency\n-       expect(toTypeScript(lib2ReexportNgSummary))\n-           .toContain(\n-               `export {ReexportModuleNgSummary as ReexportModule_2NgSummary} from '/lib1/reexport.ngsummary'`);\n-\n-       lib3In['lib3'] = {\n-         'module.ts': `\n-          import { NgModule } from '@angular/core';\n-          import { Lib2Module } from '../lib2/module';\n-          import { reexports } from '../lib2/reexport';\n-\n-          @NgModule({\n-            imports: [Lib2Module, reexports]\n-          })\n-          export class Lib3Module {}\n-        `,\n-         'reexport.ts': `\n-        import { reexports as reexports_lib2 } from '../lib2/reexport';\n-        export const reexports: any[] = [ reexports_lib2 ];\n-        `,\n-       };\n-\n-       const lib3Gen = compileApp(lib3In, {\n-                         useSummaries: true,\n-                         createExternalSymbolFactoryReexports: true\n-                       }).genFiles;\n-       const lib3ModuleNgSummary = lib3Gen.find(f => f.genFileUrl === '/lib3/module.ngsummary.ts')!;\n-       const lib3ReexportNgSummary =\n-           lib3Gen.find(f => f.genFileUrl === '/lib3/reexport.ngsummary.ts')!;\n-\n-       // ngsummary.ts files should use the reexported values from direct and deep deps\n-       const lib3ModuleNgSummarySource = toTypeScript(lib3ModuleNgSummary);\n-       expect(lib3ModuleNgSummarySource).toContain(`import * as i4 from '/lib2/module.ngsummary'`);\n-       expect(lib3ModuleNgSummarySource)\n-           .toContain(`import * as i5 from '/lib2/reexport.ngsummary'`);\n-       expect(lib3ModuleNgSummarySource)\n-           .toMatch(\n-               /export function Lib3ModuleNgSummary()[^;]*,\\s*i4.Lib1Module_1NgSummary,\\s*i4.Lib2ModuleNgSummary,\\s*i5.ReexportModule_2NgSummary\\s*\\]\\s*;/);\n-\n-       // ngsummaries should add reexports for imported NgModules from a deep dependency\n-       expect(lib3ModuleNgSummarySource)\n-           .toContain(\n-               `export {Lib1Module_1NgSummary as Lib1Module_1NgSummary,Lib2ModuleNgSummary as Lib2Module_2NgSummary} from '/lib2/module.ngsummary'`);\n-       // ngsummaries should add reexports for reexported values from a deep dependency\n-       expect(toTypeScript(lib3ReexportNgSummary))\n-           .toContain(\n-               `export {ReexportModule_2NgSummary as ReexportModule_3NgSummary} from '/lib2/reexport.ngsummary'`);\n-     });\n-\n-  it('should not create reexports for external symbols imported by NgModules', () => {\n-    const lib1In = {\n-      'lib1': {\n-        'module.ts': `\n-          import { NgModule } from '@angular/core';\n-\n-          @NgModule()\n-          export class Lib1Module {}`,\n-        'reexport.ts': `\n-          import { NgModule } from '@angular/core';\n-\n-          @NgModule()\n-          export class ReexportModule {}\n-\n-          export const reexports: any[] = [ ReexportModule ];`,\n-      }\n-    };\n-    const {outDir: lib1Out} = compileApp(lib1In, {useSummaries: true});\n-\n-    const lib2In = {\n-      ...lib1Out,\n-      'lib2': {\n-        'module.ts': `\n-          import { NgModule } from '@angular/core';\n-          import { Lib1Module } from '../lib1/module';\n-\n-          @NgModule({\n-            imports: [Lib1Module]\n-          })\n-          export class Lib2Module {}`,\n-        'reexport.ts': `\n-          import { reexports as reexports_lib1 } from '../lib1/reexport';\n-          export const reexports: any[] = [ reexports_lib1 ];`,\n-      },\n-    };\n-\n-    const {outDir: lib2Out, genFiles: lib2Gen} = compileApp(lib2In, {useSummaries: true});\n-\n-    const lib2ModuleNgSummary = lib2Gen.find(f => f.genFileUrl === '/lib2/module.ngsummary.ts')!;\n-    const lib2ReexportNgSummary =\n-        lib2Gen.find(f => f.genFileUrl === '/lib2/reexport.ngsummary.ts')!;\n-\n-    // ngsummaries should not add reexports by default for imported NgModules from a direct\n-    // dependency\n-    expect(toTypeScript(lib2ModuleNgSummary))\n-        .toContain(\n-            `export {Lib1ModuleNgSummary as Lib1ModuleNgSummary} from '/lib1/module.ngsummary'`);\n-    // ngsummaries should not add reexports by default for reexported values from a direct\n-    // dependency.\n-    expect(toTypeScript(lib2ReexportNgSummary))\n-        .toContain(\n-            `export {ReexportModuleNgSummary as ReexportModuleNgSummary} from '/lib1/reexport.ngsummary'`);\n-\n-    const lib3In = {\n-      ...lib1Out,\n-      ...lib2Out,\n-      'lib3': {\n-        'module.ts': `\n-          import { NgModule } from '@angular/core';\n-          import { Lib2Module } from '../lib2/module';\n-          import { reexports } from '../lib2/reexport';\n-\n-          @NgModule({\n-            imports: [Lib2Module, reexports]\n-          })\n-          export class Lib3Module {}\n-        `,\n-        'reexport.ts': `\n-          import { reexports as reexports_lib2 } from '../lib2/reexport';\n-          export const reexports: any[] = [ reexports_lib2 ];\n-        `,\n-      },\n-    };\n-\n-    const lib3Gen = compileApp(lib3In, {useSummaries: true}).genFiles;\n-    const lib3ModuleNgSummary = lib3Gen.find(f => f.genFileUrl === '/lib3/module.ngsummary.ts')!;\n-    const lib3ReexportNgSummary =\n-        lib3Gen.find(f => f.genFileUrl === '/lib3/reexport.ngsummary.ts')!;\n-\n-    // ngsummary.ts files should use the external symbols which are manually re-exported from\n-    // \"lib2\" from their original symbol location. With re-exported external symbols this would\n-    // be different because there would be no *direct* dependency on \"lib1\" at all.\n-    const lib3ModuleNgSummarySource = toTypeScript(lib3ModuleNgSummary);\n-    expect(lib3ModuleNgSummarySource).toContain(`import * as i1 from '/lib1/module';`);\n-    expect(lib3ModuleNgSummarySource).toContain(`import * as i3 from '/lib1/reexport';`);\n-    expect(lib3ModuleNgSummarySource)\n-        .toMatch(/export function Lib3ModuleNgSummary\\(\\).*modules:\\[{reference:i1\\.Lib1Module,/s);\n-    expect(lib3ModuleNgSummarySource)\n-        .toMatch(/export function Lib3ModuleNgSummary\\(\\).*reference:i3\\.ReexportModule,/s);\n-    // ngsummaries should re-export all used summaries directly. With external symbol re-exports\n-    // enabled, the \"lib1\" summaries would be re-exported through \"lib2\" in order to avoid\n-    // a *direct* dependency on \"lib1\".\n-    expect(lib3ModuleNgSummarySource)\n-        .toContain(\n-            `export {Lib1ModuleNgSummary as Lib1ModuleNgSummary} from '/lib1/module.ngsummary';`);\n-    expect(lib3ModuleNgSummarySource)\n-        .toContain(\n-            `export {ReexportModuleNgSummary as ReexportModuleNgSummary} from '/lib1/reexport.ngsummary';`);\n-    expect(toTypeScript(lib3ReexportNgSummary))\n-        .toContain(\n-            `export {ReexportModuleNgSummary as ReexportModuleNgSummary} from '/lib1/reexport.ngsummary';`);\n-  });\n-});"
        },
        {
            "sha": "c167b2ab98aec57358c3af8bb9ffe3412b590f54",
            "filename": "packages/compiler/test/aot/regression_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 32,
            "changes": 32,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Faot%2Fregression_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Faot%2Fregression_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Faot%2Fregression_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,32 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {compile, expectNoDiagnostics, MockDirectory, setup} from './test_util';\n-\n-describe('regressions', () => {\n-  let angularFiles = setup();\n-\n-  it('should compile components with empty templates', () => {\n-    const appDir = {\n-      'app.module.ts': `\n-        import { Component, NgModule } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class EmptyComp {}\n-\n-        @NgModule({declarations: [EmptyComp]})\n-        export class MyModule {}\n-      `\n-    };\n-    const rootDir = {'app': appDir};\n-    const {genFiles} = compile(\n-        [rootDir, angularFiles], {postCompile: expectNoDiagnostics},\n-        {noUnusedLocals: true, noUnusedParameters: true});\n-    expect(genFiles.find((f) => f.genFileUrl === '/app/app.module.ngfactory.ts')).toBeTruthy();\n-  });\n-});"
        },
        {
            "sha": "cf56450fbe4f23acc39df41bbbe6aeee3355dce5",
            "filename": "packages/compiler/test/aot/static_reflector_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 1728,
            "changes": 1728,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Faot%2Fstatic_reflector_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Faot%2Fstatic_reflector_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Faot%2Fstatic_reflector_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,1728 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {core as compilerCore, StaticReflector, StaticSymbol, StaticSymbolCache, StaticSymbolResolver, StaticSymbolResolverHost} from '@angular/compiler';\n-import {CollectorOptions, METADATA_VERSION} from '@angular/compiler-cli';\n-\n-import {MockStaticSymbolResolverHost, MockSummaryResolver} from './static_symbol_resolver_spec';\n-\n-describe('StaticReflector', () => {\n-  let noContext: StaticSymbol;\n-  let host: StaticSymbolResolverHost;\n-  let symbolResolver: StaticSymbolResolver;\n-  let reflector: StaticReflector;\n-\n-  function init(\n-      testData: {[key: string]: any} = DEFAULT_TEST_DATA,\n-      decorators: {name: string, filePath: string, ctor: any}[] = [],\n-      errorRecorder?: (error: any, fileName?: string) => void,\n-      collectorOptions?: CollectorOptions) {\n-    const symbolCache = new StaticSymbolCache();\n-    host = new MockStaticSymbolResolverHost(testData, collectorOptions);\n-    const summaryResolver = new MockSummaryResolver([]);\n-    spyOn(summaryResolver, 'isLibraryFile').and.returnValue(false);\n-    symbolResolver = new StaticSymbolResolver(host, symbolCache, summaryResolver, errorRecorder);\n-    reflector = new StaticReflector(summaryResolver, symbolResolver, decorators, [], errorRecorder);\n-    noContext = reflector.getStaticSymbol('', '');\n-  }\n-\n-  beforeEach(() => init());\n-\n-  function simplify(context: StaticSymbol, value: any) {\n-    return (reflector as any).simplify(context, value);\n-  }\n-\n-  it('should get annotations for NgFor', () => {\n-    const NgFor = reflector.findDeclaration('@angular/common/src/directives/ng_for', 'NgFor');\n-    const annotations = reflector.annotations(NgFor);\n-    expect(annotations.length).toEqual(1);\n-    const annotation = annotations[0];\n-    expect(annotation.selector).toEqual('[ngFor][ngForOf]');\n-    expect(annotation.inputs).toEqual(['ngForTrackBy', 'ngForOf', 'ngForTemplate']);\n-  });\n-\n-  it('should get constructor for NgFor', () => {\n-    const NgFor = reflector.findDeclaration('@angular/common/src/directives/ng_for', 'NgFor');\n-    const ViewContainerRef = reflector.findDeclaration('@angular/core', 'ViewContainerRef');\n-    const TemplateRef = reflector.findDeclaration('@angular/core', 'TemplateRef');\n-    const IterableDiffers = reflector.findDeclaration('@angular/core', 'IterableDiffers');\n-    const ChangeDetectorRef = reflector.findDeclaration('@angular/core', 'ChangeDetectorRef');\n-\n-    const parameters = reflector.parameters(NgFor);\n-    expect(parameters).toEqual([\n-      [ViewContainerRef], [TemplateRef], [IterableDiffers], [ChangeDetectorRef]\n-    ]);\n-  });\n-\n-  it('should get annotations for HeroDetailComponent', () => {\n-    const HeroDetailComponent =\n-        reflector.findDeclaration('src/app/hero-detail.component', 'HeroDetailComponent');\n-    const annotations = reflector.annotations(HeroDetailComponent);\n-    expect(annotations.length).toEqual(1);\n-    const annotation = annotations[0];\n-    expect(annotation.selector).toEqual('my-hero-detail');\n-  });\n-\n-  it('should get and empty annotation list for an unknown class', () => {\n-    const UnknownClass = reflector.findDeclaration('src/app/app.component', 'UnknownClass');\n-    const annotations = reflector.annotations(UnknownClass);\n-    expect(annotations).toEqual([]);\n-  });\n-\n-  it('should get and empty annotation list for a symbol with null value', () => {\n-    init({\n-      '/tmp/test.ts': `\n-        export var x = null;\n-      `\n-    });\n-    const annotations = reflector.annotations(reflector.getStaticSymbol('/tmp/test.ts', 'x'));\n-    expect(annotations).toEqual([]);\n-  });\n-\n-  it('should get propMetadata for HeroDetailComponent', () => {\n-    const HeroDetailComponent =\n-        reflector.findDeclaration('src/app/hero-detail.component', 'HeroDetailComponent');\n-    const props = reflector.propMetadata(HeroDetailComponent);\n-    expect(props['hero']).toBeTruthy();\n-    expect(props['onMouseOver']).toEqual([compilerCore.createHostListener(\n-        'mouseover', ['$event'])]);\n-  });\n-\n-  it('should get an empty object from propMetadata for an unknown class', () => {\n-    const UnknownClass = reflector.findDeclaration('src/app/app.component', 'UnknownClass');\n-    const properties = reflector.propMetadata(UnknownClass);\n-    expect(properties).toEqual({});\n-  });\n-\n-  it('should get empty parameters list for an unknown class ', () => {\n-    const UnknownClass = reflector.findDeclaration('src/app/app.component', 'UnknownClass');\n-    const parameters = reflector.parameters(UnknownClass);\n-    expect(parameters).toEqual([]);\n-  });\n-\n-  it('should provide context for errors reported by the collector', () => {\n-    const SomeClass = reflector.findDeclaration('src/error-reporting', 'SomeClass');\n-    expect(() => reflector.annotations(SomeClass))\n-        .toThrow(new Error(`Error during template compile of 'SomeClass'\n-  A reasonable error message in 'Link1'\n-    'Link1' references 'Link2'\n-      'Link2' references 'ErrorSym'\n-        'ErrorSym' contains the error at /tmp/src/error-references.ts(13,34).`));\n-  });\n-\n-  it('should simplify primitive into itself', () => {\n-    expect(simplify(noContext, 1)).toBe(1);\n-    expect(simplify(noContext, true)).toBe(true);\n-    expect(simplify(noContext, 'some value')).toBe('some value');\n-  });\n-\n-  it('should simplify a static symbol into itself', () => {\n-    const staticSymbol = reflector.getStaticSymbol('', '');\n-    expect(simplify(noContext, staticSymbol)).toBe(staticSymbol);\n-  });\n-\n-  it('should simplify an array into a copy of the array', () => {\n-    expect(simplify(noContext, [1, 2, 3])).toEqual([1, 2, 3]);\n-  });\n-\n-  it('should simplify an object to a copy of the object', () => {\n-    const expr = {a: 1, b: 2, c: 3};\n-    expect(simplify(noContext, expr)).toEqual(expr);\n-  });\n-\n-  it('should simplify &&', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '&&', left: true, right: true})))\n-        .toBe(true);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '&&', left: true, right: false})))\n-        .toBe(false);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '&&', left: false, right: true})))\n-        .toBe(false);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '&&', left: false, right: false})))\n-        .toBe(false);\n-  });\n-\n-  it('should simplify ||', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '||', left: true, right: true})))\n-        .toBe(true);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '||', left: true, right: false})))\n-        .toBe(true);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '||', left: false, right: true})))\n-        .toBe(true);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '||', left: false, right: false})))\n-        .toBe(false);\n-  });\n-\n-  it('should simplify &', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '&', left: 0x22, right: 0x0F})))\n-        .toBe(0x22 & 0x0F);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '&', left: 0x22, right: 0xF0})))\n-        .toBe(0x22 & 0xF0);\n-  });\n-\n-  it('should simplify |', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '|', left: 0x22, right: 0x0F})))\n-        .toBe(0x22 | 0x0F);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '|', left: 0x22, right: 0xF0})))\n-        .toBe(0x22 | 0xF0);\n-  });\n-\n-  it('should simplify ^', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '|', left: 0x22, right: 0x0F})))\n-        .toBe(0x22 | 0x0F);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '|', left: 0x22, right: 0xF0})))\n-        .toBe(0x22 | 0xF0);\n-  });\n-\n-  it('should simplify ==', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '==', left: 0x22, right: 0x22})))\n-        .toBe(0x22 == 0x22);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '==', left: 0x22, right: 0xF0})))\n-        .toBe(0x22 as any == 0xF0);\n-  });\n-\n-  it('should simplify !=', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '!=', left: 0x22, right: 0x22})))\n-        .toBe(0x22 != 0x22);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '!=', left: 0x22, right: 0xF0})))\n-        .toBe(0x22 as any != 0xF0);\n-  });\n-\n-  it('should simplify ===', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '===', left: 0x22, right: 0x22})))\n-        .toBe(0x22 === 0x22);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '===', left: 0x22, right: 0xF0})))\n-        .toBe(0x22 as any === 0xF0);\n-  });\n-\n-  it('should simplify !==', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '!==', left: 0x22, right: 0x22})))\n-        .toBe(0x22 !== 0x22);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '!==', left: 0x22, right: 0xF0})))\n-        .toBe(0x22 as any !== 0xF0);\n-  });\n-\n-  it('should simplify >', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '>', left: 1, right: 1})))\n-        .toBe(1 > 1);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '>', left: 1, right: 0})))\n-        .toBe(1 > 0);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '>', left: 0, right: 1})))\n-        .toBe(0 > 1);\n-  });\n-\n-  it('should simplify >=', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '>=', left: 1, right: 1})))\n-        .toBe(1 >= 1);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '>=', left: 1, right: 0})))\n-        .toBe(1 >= 0);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '>=', left: 0, right: 1})))\n-        .toBe(0 >= 1);\n-  });\n-\n-  it('should simplify <=', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '<=', left: 1, right: 1})))\n-        .toBe(1 <= 1);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '<=', left: 1, right: 0})))\n-        .toBe(1 <= 0);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '<=', left: 0, right: 1})))\n-        .toBe(0 <= 1);\n-  });\n-\n-  it('should simplify <', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '<', left: 1, right: 1})))\n-        .toBe(1 < 1);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '<', left: 1, right: 0})))\n-        .toBe(1 < 0);\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '<', left: 0, right: 1})))\n-        .toBe(0 < 1);\n-  });\n-\n-  it('should simplify <<', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '<<', left: 0x55, right: 2})))\n-        .toBe(0x55 << 2);\n-  });\n-\n-  it('should simplify >>', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '>>', left: 0x55, right: 2})))\n-        .toBe(0x55 >> 2);\n-  });\n-\n-  it('should simplify +', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '+', left: 0x55, right: 2})))\n-        .toBe(0x55 + 2);\n-  });\n-\n-  it('should simplify -', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '-', left: 0x55, right: 2})))\n-        .toBe(0x55 - 2);\n-  });\n-\n-  it('should simplify *', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '*', left: 0x55, right: 2})))\n-        .toBe(0x55 * 2);\n-  });\n-\n-  it('should simplify /', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '/', left: 0x55, right: 2})))\n-        .toBe(0x55 / 2);\n-  });\n-\n-  it('should simplify %', () => {\n-    expect(simplify(noContext, ({__symbolic: 'binop', operator: '%', left: 0x55, right: 2})))\n-        .toBe(0x55 % 2);\n-  });\n-\n-  it('should simplify prefix -', () => {\n-    expect(simplify(noContext, ({__symbolic: 'pre', operator: '-', operand: 2}))).toBe(-2);\n-  });\n-\n-  it('should simplify prefix ~', () => {\n-    expect(simplify(noContext, ({__symbolic: 'pre', operator: '~', operand: 2}))).toBe(~2);\n-  });\n-\n-  it('should simplify prefix !', () => {\n-    expect(simplify(noContext, ({__symbolic: 'pre', operator: '!', operand: true}))).toBe(!true);\n-    expect(simplify(noContext, ({__symbolic: 'pre', operator: '!', operand: false}))).toBe(!false);\n-  });\n-\n-  it('should simplify an array index', () => {\n-    expect(simplify(noContext, ({__symbolic: 'index', expression: [1, 2, 3], index: 2}))).toBe(3);\n-  });\n-\n-  it('should simplify an object index', () => {\n-    const expr = {__symbolic: 'select', expression: {a: 1, b: 2, c: 3}, member: 'b'};\n-    expect(simplify(noContext, expr)).toBe(2);\n-  });\n-\n-  it('should simplify a file reference', () => {\n-    expect(simplify(\n-               reflector.getStaticSymbol('/src/cases', ''),\n-               reflector.getStaticSymbol('/src/extern.d.ts', 's')))\n-        .toEqual('s');\n-  });\n-\n-  it('should simplify a non existing reference as a static symbol', () => {\n-    expect(simplify(\n-               reflector.getStaticSymbol('/src/cases', ''),\n-               reflector.getStaticSymbol('/src/extern.d.ts', 'nonExisting')))\n-        .toEqual(reflector.getStaticSymbol('/src/extern.d.ts', 'nonExisting'));\n-  });\n-\n-  it('should simplify a function reference as a static symbol', () => {\n-    expect(simplify(\n-               reflector.getStaticSymbol('/src/cases', 'myFunction'),\n-               ({__symbolic: 'function', parameters: ['a'], value: []})))\n-        .toEqual(reflector.getStaticSymbol('/src/cases', 'myFunction'));\n-  });\n-\n-  it('should simplify values initialized with a function call', () => {\n-    expect(simplify(\n-               reflector.getStaticSymbol('/tmp/src/function-reference.ts', ''),\n-               reflector.getStaticSymbol('/tmp/src/function-reference.ts', 'one')))\n-        .toEqual(['some-value']);\n-    expect(simplify(\n-               reflector.getStaticSymbol('/tmp/src/function-reference.ts', ''),\n-               reflector.getStaticSymbol('/tmp/src/function-reference.ts', 'three')))\n-        .toEqual(3);\n-  });\n-\n-  it('should error on direct recursive calls', () => {\n-    expect(\n-        () => simplify(\n-            reflector.getStaticSymbol('/tmp/src/function-reference.ts', 'MyComp'),\n-            reflector.getStaticSymbol('/tmp/src/function-reference.ts', 'recursion')))\n-        .toThrow(new Error(`Error during template compile of 'MyComp'\n-  Recursion is not supported in 'recursion'\n-    'recursion' references 'recursive'\n-      'recursive' called 'recursive' recursively.`));\n-  });\n-\n-  it('should throw a SyntaxError without stack trace when the required resource cannot be resolved',\n-     () => {\n-       expect(\n-           () => simplify(\n-               reflector.getStaticSymbol('/tmp/src/function-reference.ts', 'AppModule'), ({\n-                 __symbolic: 'error',\n-                 message:\n-                     'Could not resolve ./does-not-exist.component relative to /tmp/src/function-reference.ts'\n-               })))\n-           .toThrowError(`Error during template compile of 'AppModule'\n-  Could not resolve ./does-not-exist.component relative to /tmp/src/function-reference.ts.`);\n-     });\n-\n-  it('should record data about the error in the exception', () => {\n-    let threw = false;\n-    try {\n-      const metadata = host.getMetadataFor('/tmp/src/invalid-metadata.ts')!;\n-      expect(metadata).toBeDefined();\n-      const moduleMetadata: any = metadata[0]['metadata'];\n-      expect(moduleMetadata).toBeDefined();\n-      const classData: any = moduleMetadata['InvalidMetadata'];\n-      expect(classData).toBeDefined();\n-      simplify(\n-          reflector.getStaticSymbol('/tmp/src/invalid-metadata.ts', ''),\n-          classData.decorators[0].arguments);\n-    } catch (e) {\n-      expect(e.position).toBeDefined();\n-      threw = true;\n-    }\n-    expect(threw).toBe(true);\n-  });\n-\n-  it('should error on indirect recursive calls', () => {\n-    expect(\n-        () => simplify(\n-            reflector.getStaticSymbol('/tmp/src/function-reference.ts', 'MyComp'),\n-            reflector.getStaticSymbol('/tmp/src/function-reference.ts', 'indirectRecursion')))\n-        .toThrow(new Error(`Error during template compile of 'MyComp'\n-  Recursion is not supported in 'indirectRecursion'\n-    'indirectRecursion' references 'indirectRecursion1'\n-      'indirectRecursion1' references 'indirectRecursion2'\n-        'indirectRecursion2' called 'indirectRecursion1' recursively.`));\n-  });\n-\n-  it('should simplify a spread expression', () => {\n-    expect(simplify(\n-               reflector.getStaticSymbol('/tmp/src/spread.ts', ''),\n-               reflector.getStaticSymbol('/tmp/src/spread.ts', 'spread')))\n-        .toEqual([0, 1, 2, 3, 4, 5]);\n-  });\n-\n-  it('should be able to get metadata for a class containing a custom decorator', () => {\n-    const props = reflector.propMetadata(\n-        reflector.getStaticSymbol('/tmp/src/custom-decorator-reference.ts', 'Foo'));\n-    expect(props).toEqual({foo: []});\n-  });\n-\n-  it('should read ctor parameters with forwardRef', () => {\n-    const src = '/tmp/src/forward-ref.ts';\n-    const dep = reflector.getStaticSymbol(src, 'Dep');\n-    const props = reflector.parameters(reflector.getStaticSymbol(src, 'Forward'));\n-    expect(props).toEqual([[dep, compilerCore.createInject(dep)]]);\n-  });\n-\n-  it('should report an error for invalid function calls', () => {\n-    expect(\n-        () => reflector.annotations(\n-            reflector.getStaticSymbol('/tmp/src/invalid-calls.ts', 'MyComponent')))\n-        .toThrow(new Error(\n-            `/tmp/src/invalid-calls.ts(8,29): Error during template compile of 'MyComponent'\n-  Function calls are not supported in decorators but 'someFunction' was called.`));\n-  });\n-\n-  it('should be able to get metadata for a class containing a static method call', () => {\n-    const annotations = reflector.annotations(\n-        reflector.getStaticSymbol('/tmp/src/static-method-call.ts', 'MyComponent'));\n-    expect(annotations.length).toBe(1);\n-    expect(annotations[0].providers).toEqual({provider: 'a', useValue: 100});\n-  });\n-\n-  it('should be able to get metadata for a class containing a static field reference', () => {\n-    const annotations = reflector.annotations(\n-        reflector.getStaticSymbol('/tmp/src/static-field-reference.ts', 'Foo'));\n-    expect(annotations.length).toBe(1);\n-    expect(annotations[0].providers).toEqual([{provider: 'a', useValue: 'Some string'}]);\n-  });\n-\n-  it('should be able to get the metadata for a class calling a method with a conditional expression',\n-     () => {\n-       const annotations = reflector.annotations(\n-           reflector.getStaticSymbol('/tmp/src/static-method-call.ts', 'MyCondComponent'));\n-       expect(annotations.length).toBe(1);\n-       expect(annotations[0].providers).toEqual([\n-         [{provider: 'a', useValue: '1'}], [{provider: 'a', useValue: '2'}]\n-       ]);\n-     });\n-\n-  it('should be able to get metadata for a class with nested method calls', () => {\n-    const annotations = reflector.annotations(\n-        reflector.getStaticSymbol('/tmp/src/static-method-call.ts', 'MyFactoryComponent'));\n-    expect(annotations.length).toBe(1);\n-    expect(annotations[0].providers).toEqual({\n-      provide: 'c',\n-      useFactory:\n-          reflector.getStaticSymbol('/tmp/src/static-method.ts', 'AnotherModule', ['someFactory'])\n-    });\n-  });\n-\n-  it('should be able to get the metadata for a class calling a method with default parameters',\n-     () => {\n-       const annotations = reflector.annotations(\n-           reflector.getStaticSymbol('/tmp/src/static-method-call.ts', 'MyDefaultsComponent'));\n-       expect(annotations.length).toBe(1);\n-       expect(annotations[0].providers).toEqual([['a', true, false]]);\n-     });\n-\n-  it('should be able to get metadata with a reference to a static method', () => {\n-    const annotations = reflector.annotations(\n-        reflector.getStaticSymbol('/tmp/src/static-method-ref.ts', 'MethodReference'));\n-    expect(annotations.length).toBe(1);\n-    expect(annotations[0].providers[0].useValue.members[0]).toEqual('staticMethod');\n-  });\n-\n-  it('should be able to get metadata for a class calling a macro function', () => {\n-    const annotations = reflector.annotations(\n-        reflector.getStaticSymbol('/tmp/src/call-macro-function.ts', 'MyComponent'));\n-    expect(annotations.length).toBe(1);\n-    expect(annotations[0].providers.useValue).toBe(100);\n-  });\n-\n-  it('should be able to get metadata for a class calling a nested macro function', () => {\n-    const annotations = reflector.annotations(\n-        reflector.getStaticSymbol('/tmp/src/call-macro-function.ts', 'MyComponentNested'));\n-    expect(annotations.length).toBe(1);\n-    expect(annotations[0].providers.useValue.useValue).toBe(100);\n-  });\n-\n-  // #13605\n-  it('should not throw on unknown decorators', () => {\n-    const data = Object.create(DEFAULT_TEST_DATA);\n-    const file = '/tmp/src/app.component.ts';\n-    data[file] = `\n-      import { Component } from '@angular/core';\n-\n-      export const enum TypeEnum {\n-        type\n-      }\n-\n-      export function MyValidationDecorator(p1: any, p2: any): any {\n-        return null;\n-      }\n-\n-      export function ValidationFunction(a1: any): any {\n-        return null;\n-      }\n-\n-      @Component({\n-        selector: 'my-app',\n-        template: \"<h1>Hello {{name}}</h1>\",\n-      })\n-      export class AppComponent  {\n-        name = 'Angular';\n-\n-        @MyValidationDecorator( TypeEnum.type, ValidationFunction({option: 'value'}))\n-        myClassProp: number;\n-    }`;\n-    init(data);\n-    const appComponent = reflector.getStaticSymbol(file, 'AppComponent');\n-    expect(() => reflector.propMetadata(appComponent)).not.toThrow();\n-  });\n-\n-  it('should not throw with an invalid extends', () => {\n-    const data = Object.create(DEFAULT_TEST_DATA);\n-    const file = '/tmp/src/invalid-component.ts';\n-    data[file] = `\n-        import {Component} from '@angular/core';\n-\n-        function InvalidParent() {\n-          return InvalidParent;\n-        }\n-\n-        @Component({\n-          selector: 'tmp',\n-          template: '',\n-        })\n-        export class BadComponent extends InvalidParent() {\n-\n-        }\n-      `;\n-    init(data);\n-    const badComponent = reflector.getStaticSymbol(file, 'BadComponent');\n-    expect(reflector.propMetadata(badComponent)).toEqual({});\n-    expect(reflector.parameters(badComponent)).toEqual([]);\n-    expect(reflector.hasLifecycleHook(badComponent, 'onDestroy')).toEqual(false);\n-  });\n-\n-  it('should produce a annotation even if it contains errors', () => {\n-    const data = Object.create(DEFAULT_TEST_DATA);\n-    const file = '/tmp/src/invalid-component.ts';\n-    data[file] = `\n-        import {Component} from '@angular/core';\n-\n-        @Component({\n-          selector: 'tmp',\n-          template: () => {},\n-          providers: [1, 2, (() => {}), 3, !(() => {}), 4, 5, (() => {}) + (() => {}), 6, 7]\n-        })\n-        export class BadComponent {\n-\n-        }\n-      `;\n-    init(data, [], () => {}, {verboseInvalidExpression: true});\n-\n-    const badComponent = reflector.getStaticSymbol(file, 'BadComponent');\n-    const annotations = reflector.annotations(badComponent);\n-    const annotation = annotations[0];\n-    expect(annotation.selector).toEqual('tmp');\n-    expect(annotation.template).toBeUndefined();\n-    expect(annotation.providers).toEqual([1, 2, 3, 4, 5, 6, 7]);\n-  });\n-\n-  it('should ignore unresolved calls', () => {\n-    const data = Object.create(DEFAULT_TEST_DATA);\n-    const file = '/tmp/src/invalid-component.ts';\n-    data[file] = `\n-        import {Component} from '@angular/core';\n-        import {unknown} from 'unresolved';\n-\n-        @Component({\n-          selector: 'tmp',\n-          template: () => {},\n-          providers: [triggers()]\n-        })\n-        export class BadComponent {\n-\n-        }\n-      `;\n-    init(data, [], () => {}, {verboseInvalidExpression: true});\n-\n-    const badComponent = reflector.getStaticSymbol(file, 'BadComponent');\n-    const annotations = reflector.annotations(badComponent);\n-    const annotation = annotations[0];\n-    expect(annotation.providers).toEqual([]);\n-  });\n-\n-  // #15424\n-  it('should be able to inject a ctor parameter with a @Inject and a type expression', () => {\n-    const data = Object.create(DEFAULT_TEST_DATA);\n-    const file = '/tmp/src/invalid-component.ts';\n-    data[file] = `\n-        import {Injectable, Inject} from '@angular/core';\n-\n-        @Injectable()\n-        export class SomeClass {\n-          constructor (@Inject('some-token') a: {a: string, b: string}) {}\n-        }\n-      `;\n-    init(data);\n-\n-    const someClass = reflector.getStaticSymbol(file, 'SomeClass');\n-    const parameters = reflector.parameters(someClass);\n-    expect(compilerCore.createInject.isTypeOf(parameters[0][0])).toBe(true);\n-  });\n-\n-  it('should reject a ctor parameter without a @Inject and a type exprssion', () => {\n-    const data = Object.create(DEFAULT_TEST_DATA);\n-    const file = '/tmp/src/invalid-component.ts';\n-    data[file] = `\n-        import {Injectable} from '@angular/core';\n-\n-        @Injectable()\n-        export class SomeClass {\n-          constructor (a: {a: string, b: string}) {}\n-        }\n-      `;\n-\n-    let error: any = undefined;\n-    init(data, [], (err: any, filePath?: string) => {\n-      expect(error).toBeUndefined();\n-      error = err;\n-    });\n-\n-    const someClass = reflector.getStaticSymbol(file, 'SomeClass');\n-    expect(reflector.parameters(someClass)).toEqual([[]]);\n-    expect(error).toBeUndefined();\n-  });\n-\n-  describe('inheritance', () => {\n-    class ClassDecorator {\n-      constructor(public value: any) {}\n-    }\n-\n-    class ParamDecorator {\n-      constructor(public value: any) {}\n-    }\n-\n-    class PropDecorator {\n-      constructor(public value: any) {}\n-    }\n-\n-    function initWithDecorator(testData: {[key: string]: any}) {\n-      testData['/tmp/src/decorator.ts'] = `\n-            export function ClassDecorator(): any {}\n-            export function ParamDecorator(): any {}\n-            export function PropDecorator(): any {}\n-      `;\n-      init(testData, [\n-        {filePath: '/tmp/src/decorator.ts', name: 'ClassDecorator', ctor: ClassDecorator},\n-        {filePath: '/tmp/src/decorator.ts', name: 'ParamDecorator', ctor: ParamDecorator},\n-        {filePath: '/tmp/src/decorator.ts', name: 'PropDecorator', ctor: PropDecorator}\n-      ]);\n-    }\n-\n-    it('should inherit annotations', () => {\n-      initWithDecorator({\n-        '/tmp/src/main.ts': `\n-            import {ClassDecorator} from './decorator';\n-\n-            @ClassDecorator('parent')\n-            export class Parent {}\n-\n-            @ClassDecorator('child')\n-            export class Child extends Parent {}\n-\n-            export class ChildNoDecorators extends Parent {}\n-\n-            export class ChildInvalidParent extends a.InvalidParent {}\n-          `\n-      });\n-\n-      // Check that metadata for Parent was not changed!\n-      expect(reflector.annotations(reflector.getStaticSymbol('/tmp/src/main.ts', 'Parent')))\n-          .toEqual([new ClassDecorator('parent')]);\n-\n-      expect(reflector.annotations(reflector.getStaticSymbol('/tmp/src/main.ts', 'Child')))\n-          .toEqual([new ClassDecorator('parent'), new ClassDecorator('child')]);\n-\n-      expect(\n-          reflector.annotations(reflector.getStaticSymbol('/tmp/src/main.ts', 'ChildNoDecorators')))\n-          .toEqual([new ClassDecorator('parent')]);\n-\n-      expect(reflector.annotations(\n-                 reflector.getStaticSymbol('/tmp/src/main.ts', 'ChildInvalidParent')))\n-          .toEqual([]);\n-    });\n-\n-    it('should inherit parameters', () => {\n-      initWithDecorator({\n-        '/tmp/src/main.ts': `\n-            import {ParamDecorator} from './decorator';\n-\n-            export class A {}\n-            export class B {}\n-            export class C {}\n-\n-            export class Parent {\n-              constructor(@ParamDecorator('a') a: A, @ParamDecorator('b') b: B) {}\n-            }\n-\n-            export class Child extends Parent {}\n-\n-            export class ChildWithCtor extends Parent {\n-              constructor(@ParamDecorator('c') c: C) {}\n-            }\n-\n-            export class ChildInvalidParent extends a.InvalidParent {}\n-          `\n-      });\n-\n-      // Check that metadata for Parent was not changed!\n-      expect(reflector.parameters(reflector.getStaticSymbol('/tmp/src/main.ts', 'Parent')))\n-          .toEqual([\n-            [reflector.getStaticSymbol('/tmp/src/main.ts', 'A'), new ParamDecorator('a')],\n-            [reflector.getStaticSymbol('/tmp/src/main.ts', 'B'), new ParamDecorator('b')]\n-          ]);\n-\n-      expect(reflector.parameters(reflector.getStaticSymbol('/tmp/src/main.ts', 'Child'))).toEqual([\n-        [reflector.getStaticSymbol('/tmp/src/main.ts', 'A'), new ParamDecorator('a')],\n-        [reflector.getStaticSymbol('/tmp/src/main.ts', 'B'), new ParamDecorator('b')]\n-      ]);\n-\n-      expect(reflector.parameters(reflector.getStaticSymbol('/tmp/src/main.ts', 'ChildWithCtor')))\n-          .toEqual([[reflector.getStaticSymbol('/tmp/src/main.ts', 'C'), new ParamDecorator('c')]]);\n-\n-      expect(\n-          reflector.parameters(reflector.getStaticSymbol('/tmp/src/main.ts', 'ChildInvalidParent')))\n-          .toEqual([]);\n-    });\n-\n-    it('should inherit property metadata', () => {\n-      initWithDecorator({\n-        '/tmp/src/main.ts': `\n-            import {PropDecorator} from './decorator';\n-\n-            export class A {}\n-            export class B {}\n-            export class C {}\n-\n-            export class Parent {\n-              @PropDecorator('a')\n-              a: A;\n-              @PropDecorator('b1')\n-              b: B;\n-            }\n-\n-            export class Child extends Parent {\n-              @PropDecorator('b2')\n-              b: B;\n-              @PropDecorator('c')\n-              c: C;\n-            }\n-\n-            export class ChildInvalidParent extends a.InvalidParent {}\n-          `\n-      });\n-\n-      // Check that metadata for Parent was not changed!\n-      expect(reflector.propMetadata(reflector.getStaticSymbol('/tmp/src/main.ts', 'Parent')))\n-          .toEqual({\n-            'a': [new PropDecorator('a')],\n-            'b': [new PropDecorator('b1')],\n-          });\n-\n-      expect(reflector.propMetadata(reflector.getStaticSymbol('/tmp/src/main.ts', 'Child')))\n-          .toEqual({\n-            'a': [new PropDecorator('a')],\n-            'b': [new PropDecorator('b1'), new PropDecorator('b2')],\n-            'c': [new PropDecorator('c')]\n-          });\n-\n-      expect(reflector.propMetadata(\n-                 reflector.getStaticSymbol('/tmp/src/main.ts', 'ChildInvalidParent')))\n-          .toEqual({});\n-    });\n-\n-    it('should not inherit methods from Object.prototype', () => {\n-      const filePath = '/tmp/test.ts';\n-      init({\n-        ...DEFAULT_TEST_DATA,\n-        [filePath]: `\n-          import {Component} from '@angular/core';\n-\n-          @Component({\n-            selector: 'test-component',\n-          })\n-          export class TestComponent {\n-            title = 'Hello World';\n-\n-            toString() {\n-              return 'Test Component';\n-            }\n-          }\n-        `,\n-      });\n-      const declaration = reflector.getStaticSymbol(filePath, 'TestComponent');\n-      expect(declaration.filePath).toBe(filePath);\n-      expect(declaration.name).toBe('TestComponent');\n-      const propMetadata = reflector.propMetadata(declaration);\n-      // 'toString' is a member of TestComponent so it should be part of the metadata.\n-      expect(propMetadata.hasOwnProperty('toString')).toBe(true);\n-      // There are no decorators on 'toString' so it should be an empty array.\n-      expect(propMetadata['toString']).toEqual([]);\n-    });\n-\n-    it('should inherit lifecycle hooks', () => {\n-      initWithDecorator({\n-        '/tmp/src/main.ts': `\n-            export class Parent {\n-              hook1() {}\n-              hook2() {}\n-            }\n-\n-            export class Child extends Parent {\n-              hook2() {}\n-              hook3() {}\n-            }\n-\n-            export class ChildInvalidParent extends a.InvalidParent {}\n-          `\n-      });\n-\n-      function hooks(symbol: StaticSymbol, names: string[]): boolean[] {\n-        return names.map(name => reflector.hasLifecycleHook(symbol, name));\n-      }\n-\n-      // Check that metadata for Parent was not changed!\n-      expect(hooks(reflector.getStaticSymbol('/tmp/src/main.ts', 'Parent'), [\n-        'hook1', 'hook2', 'hook3'\n-      ])).toEqual([true, true, false]);\n-\n-      expect(hooks(reflector.getStaticSymbol('/tmp/src/main.ts', 'Child'), [\n-        'hook1', 'hook2', 'hook3'\n-      ])).toEqual([true, true, true]);\n-\n-      expect(hooks(reflector.getStaticSymbol('/tmp/src/main.ts', 'ChildInvalidParent'), [\n-        'hook1', 'hook2', 'hook3'\n-      ])).toEqual([false, false, false]);\n-    });\n-\n-    it('should allow inheritance from expressions', () => {\n-      initWithDecorator({\n-        '/tmp/src/main.ts': `\n-            export function metaClass() { return null; };\n-            export class Child extends metaClass() {}\n-          `\n-      });\n-\n-      expect(reflector.annotations(reflector.getStaticSymbol('/tmp/src/main.ts', 'Child')))\n-          .toEqual([]);\n-    });\n-\n-    it('should allow inheritance from functions', () => {\n-      initWithDecorator({\n-        '/tmp/src/main.ts': `\n-            export let ctor: {new(): T} = function() { return null; }\n-            export class Child extends ctor {}\n-          `\n-      });\n-\n-      expect(reflector.annotations(reflector.getStaticSymbol('/tmp/src/main.ts', 'Child')))\n-          .toEqual([]);\n-    });\n-\n-    it('should support constructor parameters with @Inject and an interface type', () => {\n-      const data = Object.create(DEFAULT_TEST_DATA);\n-      const file = '/tmp/src/inject_interface.ts';\n-      data[file] = `\n-        import {Injectable, Inject} from '@angular/core';\n-        import {F} from './f';\n-\n-        export interface InjectedInterface {\n-\n-        }\n-\n-        export class Token {}\n-\n-        @Injectable()\n-        export class SomeClass {\n-          constructor (@Inject(Token) injected: InjectedInterface, t: Token, @Inject(Token) f: F) {}\n-        }\n-      `;\n-\n-      init(data);\n-\n-      expect(reflector.parameters(reflector.getStaticSymbol(file, 'SomeClass'))[0].length)\n-          .toEqual(1);\n-    });\n-  });\n-\n-  describe('expression lowering', () => {\n-    it('should be able to accept a lambda in a reference location', () => {\n-      const data = Object.create(DEFAULT_TEST_DATA);\n-      const file = '/tmp/src/my_component.ts';\n-      data[file] = `\n-        import {Component, InjectionToken} from '@angular/core';\n-\n-        export const myLambda = () => [1, 2, 3];\n-        export const NUMBERS = new InjectionToken<number[]>();\n-\n-        @Component({\n-          template: '<div>{{name}}</div>',\n-          providers: [{provide: NUMBERS, useFactory: myLambda}]\n-        })\n-        export class MyComponent {\n-          name = 'Some name';\n-        }\n-      `;\n-      init(data);\n-\n-      expect(reflector.annotations(reflector.getStaticSymbol(file, 'MyComponent'))[0]\n-                 .providers[0]\n-                 .useFactory)\n-          .toBe(reflector.getStaticSymbol(file, 'myLambda'));\n-    });\n-  });\n-\n-  // Regression #18170\n-  it('should continue to aggresively evaluate enum member accessors', () => {\n-    const data = Object.create(DEFAULT_TEST_DATA);\n-    const file = '/tmp/src/my_component.ts';\n-    data[file] = `\n-      import {Component} from '@angular/core';\n-      import {intermediate} from './index';\n-\n-      @Component({\n-        template: '<div></div>',\n-        providers: [{provide: 'foo', useValue: [...intermediate]}]\n-      })\n-      export class MyComponent { }\n-    `;\n-    data['/tmp/src/intermediate.ts'] = `\n-      import {MyEnum} from './indirect';\n-      export const intermediate = [{\n-        data: {\n-          c: [MyEnum.Value]\n-        }\n-      }];`;\n-    data['/tmp/src/index.ts'] = `export * from './intermediate';`;\n-    data['/tmp/src/indirect.ts'] = `export * from './consts';`;\n-    data['/tmp/src/consts.ts'] = `\n-      export enum MyEnum {\n-        Value = 3\n-      }\n-    `;\n-    init(data);\n-\n-    expect(reflector.annotations(reflector.getStaticSymbol(file, 'MyComponent'))[0]\n-               .providers[0]\n-               .useValue)\n-        .toEqual([{data: {c: [3]}}]);\n-  });\n-\n-  // Regression #18170\n-  it('should evaluate enums and statics that are 0', () => {\n-    const data = Object.create(DEFAULT_TEST_DATA);\n-    const file = '/tmp/src/my_component.ts';\n-    data[file] = `\n-      import {Component} from '@angular/core';\n-      import {provideRoutes} from './macro';\n-      import {MyEnum, MyClass} from './consts';\n-\n-      @Component({\n-        template: '<div></div>',\n-        providers: [provideRoutes({\n-          path: 'foo',\n-          data: {\n-            e: MyEnum.Value\n-          }\n-        })]\n-      })\n-      export class MyComponent { }\n-    `;\n-    data['/tmp/src/macro.ts'] = `\n-      import {ANALYZE_FOR_ENTRY_COMPONENTS, ROUTES} from '@angular/core';\n-\n-      export interface Route {\n-        path?: string;\n-        data?: any;\n-      }\n-      export type Routes = Route[];\n-      export function provideRoutes(routes: Routes): any {\n-        return [\n-          {provide: ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes},\n-          {provide: ROUTES, multi: true, useValue: routes},\n-        ];\n-      }\n-    `;\n-    data['/tmp/src/consts.ts'] = `\n-      export enum MyEnum {\n-        Value = 0,\n-      }\n-    `;\n-    init(data);\n-    expect(reflector.annotations(reflector.getStaticSymbol(file, 'MyComponent'))[0]\n-               .providers[0][0]\n-               .useValue)\n-        .toEqual({path: 'foo', data: {e: 0}});\n-  });\n-\n-  // Regression #18170\n-  it('should eagerly evaluate enums selects', () => {\n-    const data = Object.create(DEFAULT_TEST_DATA);\n-    const file = '/tmp/src/my_component.ts';\n-    data[file] = `\n-      import {Component} from '@angular/core';\n-      import {provideRoutes} from './macro';\n-      import {E} from './indirect';\n-\n-      @Component({\n-        template: '<div></div>',\n-        providers: [provideRoutes({\n-          path: 'foo',\n-          data: {\n-            e: E.Value,\n-          }\n-        })]\n-      })\n-      export class MyComponent { }\n-    `;\n-    data['/tmp/src/macro.ts'] = `\n-      import {ANALYZE_FOR_ENTRY_COMPONENTS, ROUTES} from '@angular/core';\n-\n-      export interface Route {\n-        path?: string;\n-        data?: any;\n-      }\n-      export type Routes = Route[];\n-      export function provideRoutes(routes: Routes): any {\n-        return [\n-          {provide: ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes},\n-          {provide: ROUTES, multi: true, useValue: routes},\n-        ];\n-      }\n-    `;\n-    data['/tmp/src/indirect.ts'] = `\n-      import {MyEnum} from './consts';\n-\n-      export const E = MyEnum;\n-    `,\n-    data['/tmp/src/consts.ts'] = `\n-      export enum MyEnum {\n-        Value = 1,\n-      }\n-    `;\n-    init(data);\n-    expect(reflector.annotations(reflector.getStaticSymbol(file, 'MyComponent'))[0]\n-               .providers[0][0]\n-               .useValue)\n-        .toEqual({path: 'foo', data: {e: 1}});\n-  });\n-\n-  // Regression #18170\n-  it('should aggressively evaluate array indexes', () => {\n-    const data = Object.create(DEFAULT_TEST_DATA);\n-    const file = '/tmp/src/my_component.ts';\n-    data[file] = `\n-      import {Component} from '@angular/core';\n-      import {provideRoutes} from './macro';\n-      import {E} from './indirect';\n-\n-      @Component({\n-        template: '<div></div>',\n-        providers: [provideRoutes({\n-          path: 'foo',\n-          data: {\n-            e: E[E[E[1]]],\n-          }\n-        })]\n-      })\n-      export class MyComponent { }\n-    `;\n-    data['/tmp/src/macro.ts'] = `\n-      import {ANALYZE_FOR_ENTRY_COMPONENTS, ROUTES} from '@angular/core';\n-\n-      export interface Route {\n-        path?: string;\n-        data?: any;\n-      }\n-      export type Routes = Route[];\n-      export function provideRoutes(routes: Routes): any {\n-        return [\n-          {provide: ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes},\n-          {provide: ROUTES, multi: true, useValue: routes},\n-        ];\n-      }\n-    `;\n-    data['/tmp/src/indirect.ts'] = `\n-      import {A} from './consts';\n-\n-      export const E = A;\n-    `,\n-    data['/tmp/src/consts.ts'] = `\n-      export const A = [0, 1];\n-    `;\n-    init(data);\n-    expect(reflector.annotations(reflector.getStaticSymbol(file, 'MyComponent'))[0]\n-               .providers[0][0]\n-               .useValue)\n-        .toEqual({path: 'foo', data: {e: 1}});\n-  });\n-\n-  describe('resolveExternalReference', () => {\n-    it('should register modules names in the StaticSymbolResolver if no containingFile is given',\n-       () => {\n-         init({\n-           '/tmp/root.ts': ``,\n-           '/tmp/a.ts': `export const x = 1;`,\n-         });\n-         let symbol = reflector.resolveExternalReference(\n-             {moduleName: './a', name: 'x', runtime: null}, '/tmp/root.ts');\n-         expect(symbolResolver.getKnownModuleName(symbol.filePath)).toBeFalsy();\n-\n-         symbol = reflector.resolveExternalReference({moduleName: 'a', name: 'x', runtime: null});\n-         expect(symbolResolver.getKnownModuleName(symbol.filePath)).toBe('a');\n-       });\n-  });\n-\n-  describe('formatted error reporting', () => {\n-    describe('function calls', () => {\n-      const fileName = '/tmp/src/invalid/components.ts';\n-      beforeEach(() => {\n-        const localData = {\n-          '/tmp/src/invalid/function-call.ts': `\n-        import {functionToCall} from 'some-module';\n-        export const CALL_FUNCTION = functionToCall();\n-    `,\n-          '/tmp/src/invalid/indirect.ts': `\n-        import {CALL_FUNCTION} from './function-call';\n-\n-        export const INDIRECT_CALL_FUNCTION = CALL_FUNCTION + 1;\n-    `,\n-          '/tmp/src/invalid/two-levels-indirect.ts': `\n-        import {INDIRECT_CALL_FUNCTION} from './indirect';\n-\n-        export const TWO_LEVELS_INDIRECT_CALL_FUNCTION = INDIRECT_CALL_FUNCTION + 1;\n-    `,\n-          '/tmp/src/invalid/components.ts': `\n-        import {functionToCall} from 'some-module';\n-        import {Component} from '@angular/core';\n-        import {CALL_FUNCTION} from './function-call';\n-        import {INDIRECT_CALL_FUNCTION} from './indirect';\n-        import {TWO_LEVELS_INDIRECT_CALL_FUNCTION} from './two-levels-indirect';\n-\n-        @Component({\n-          value: functionToCall()\n-        })\n-        export class CallImportedFunction {}\n-\n-        @Component({\n-          value: CALL_FUNCTION\n-        })\n-        export class ReferenceCalledFunction {}\n-\n-        @Component({\n-          value: INDIRECT_CALL_FUNCTION\n-        })\n-        export class IndirectReferenceCalledFunction {}\n-\n-        @Component({\n-          value: TWO_LEVELS_INDIRECT_CALL_FUNCTION\n-        })\n-        export class TwoLevelsIndirectReferenceCalledFunction {}\n-    `\n-        };\n-        init({...DEFAULT_TEST_DATA, ...localData});\n-      });\n-\n-      it('should report a formatted error for a direct function call', () => {\n-        expect(() => {\n-          return reflector.annotations(reflector.getStaticSymbol(fileName, 'CallImportedFunction'));\n-        })\n-            .toThrowError(\n-                `/tmp/src/invalid/components.ts(9,18): Error during template compile of 'CallImportedFunction'\n-  Function calls are not supported in decorators but 'functionToCall' was called.`);\n-      });\n-\n-      it('should report a formatted error for a reference to a function call', () => {\n-        expect(() => {\n-          return reflector.annotations(\n-              reflector.getStaticSymbol(fileName, 'ReferenceCalledFunction'));\n-        })\n-            .toThrowError(\n-                `/tmp/src/invalid/components.ts(14,18): Error during template compile of 'ReferenceCalledFunction'\n-  Function calls are not supported in decorators but 'functionToCall' was called in 'CALL_FUNCTION'\n-    'CALL_FUNCTION' calls 'functionToCall' at /tmp/src/invalid/function-call.ts(3,38).`);\n-      });\n-\n-      it('should report a formatted error for an indirect reference to a function call', () => {\n-        expect(() => {\n-          return reflector.annotations(\n-              reflector.getStaticSymbol(fileName, 'IndirectReferenceCalledFunction'));\n-        })\n-            .toThrowError(\n-                `/tmp/src/invalid/components.ts(19,18): Error during template compile of 'IndirectReferenceCalledFunction'\n-  Function calls are not supported in decorators but 'functionToCall' was called in 'INDIRECT_CALL_FUNCTION'\n-    'INDIRECT_CALL_FUNCTION' references 'CALL_FUNCTION' at /tmp/src/invalid/indirect.ts(4,47)\n-      'CALL_FUNCTION' calls 'functionToCall' at /tmp/src/invalid/function-call.ts(3,38).`);\n-      });\n-\n-      it('should report a formatted error for a double-indirect reference to a function call', () => {\n-        expect(() => {\n-          return reflector.annotations(\n-              reflector.getStaticSymbol(fileName, 'TwoLevelsIndirectReferenceCalledFunction'));\n-        })\n-            .toThrowError(\n-                `/tmp/src/invalid/components.ts(24,18): Error during template compile of 'TwoLevelsIndirectReferenceCalledFunction'\n-  Function calls are not supported in decorators but 'functionToCall' was called in 'TWO_LEVELS_INDIRECT_CALL_FUNCTION'\n-    'TWO_LEVELS_INDIRECT_CALL_FUNCTION' references 'INDIRECT_CALL_FUNCTION' at /tmp/src/invalid/two-levels-indirect.ts(4,58)\n-      'INDIRECT_CALL_FUNCTION' references 'CALL_FUNCTION' at /tmp/src/invalid/indirect.ts(4,47)\n-        'CALL_FUNCTION' calls 'functionToCall' at /tmp/src/invalid/function-call.ts(3,38).`);\n-      });\n-    });\n-\n-    describe('macro functions', () => {\n-      const fileName = '/tmp/src/invalid/components.ts';\n-      beforeEach(() => {\n-        const localData = {\n-          '/tmp/src/invalid/function-call.ts': `\n-        import {functionToCall} from 'some-module';\n-        export const CALL_FUNCTION = functionToCall();\n-    `,\n-          '/tmp/src/invalid/indirect.ts': `\n-        import {CALL_FUNCTION} from './function-call';\n-\n-        export const INDIRECT_CALL_FUNCTION = CALL_FUNCTION + 1;\n-    `,\n-          '/tmp/src/invalid/macros.ts': `\n-        export function someMacro(value: any) {\n-          return [ { provide: 'key', value: value } ];\n-        }\n-    `,\n-          '/tmp/src/invalid/components.ts': `\n-        import {Component} from '@angular/core';\n-        import {functionToCall} from 'some-module';\n-        import {someMacro} from './macros';\n-        import {CALL_FUNCTION} from './function-call';\n-        import {INDIRECT_CALL_FUNCTION} from './indirect';\n-\n-        @Component({\n-          template: someMacro(functionToCall())\n-        })\n-        export class DirectCall {}\n-\n-        @Component({\n-          template: someMacro(CALL_FUNCTION)\n-        })\n-        export class IndirectCall {}\n-\n-        @Component({\n-          template: someMacro(INDIRECT_CALL_FUNCTION)\n-        })\n-        export class DoubleIndirectCall {}\n-    `\n-        };\n-        init({...DEFAULT_TEST_DATA, ...localData});\n-      });\n-\n-      it('should report a formatted error for a direct function call', () => {\n-        expect(() => {\n-          return reflector.annotations(reflector.getStaticSymbol(fileName, 'DirectCall'));\n-        })\n-            .toThrowError(\n-                `/tmp/src/invalid/components.ts(9,31): Error during template compile of 'DirectCall'\n-  Function calls are not supported in decorators but 'functionToCall' was called.`);\n-      });\n-\n-      it('should report a formatted error for a reference to a function call', () => {\n-        expect(() => {\n-          return reflector.annotations(reflector.getStaticSymbol(fileName, 'IndirectCall'));\n-        })\n-            .toThrowError(\n-                `/tmp/src/invalid/components.ts(14,31): Error during template compile of 'IndirectCall'\n-  Function calls are not supported in decorators but 'functionToCall' was called in 'CALL_FUNCTION'\n-    'CALL_FUNCTION' calls 'functionToCall' at /tmp/src/invalid/function-call.ts(3,38).`);\n-      });\n-\n-      it('should report a formatted error for an indirect refernece to a function call', () => {\n-        expect(() => {\n-          return reflector.annotations(reflector.getStaticSymbol(fileName, 'DoubleIndirectCall'));\n-        })\n-            .toThrowError(\n-                `/tmp/src/invalid/components.ts(19,31): Error during template compile of 'DoubleIndirectCall'\n-  Function calls are not supported in decorators but 'functionToCall' was called in 'INDIRECT_CALL_FUNCTION'\n-    'INDIRECT_CALL_FUNCTION' references 'CALL_FUNCTION' at /tmp/src/invalid/indirect.ts(4,47)\n-      'CALL_FUNCTION' calls 'functionToCall' at /tmp/src/invalid/function-call.ts(3,38).`);\n-      });\n-    });\n-\n-    describe('and give advice', () => {\n-      // If in a reference expression, advice the user to replace with a reference.\n-      const fileName = '/tmp/src/invalid/components.ts';\n-\n-      function collectError(symbol: string): string {\n-        try {\n-          reflector.annotations(reflector.getStaticSymbol(fileName, symbol));\n-        } catch (e) {\n-          return e.message;\n-        }\n-        fail('Expected an exception to be thrown');\n-        return '';\n-      }\n-\n-      function initWith(content: string) {\n-        init({\n-          ...DEFAULT_TEST_DATA,\n-          [fileName]: `import {Component} from '@angular/core';\\n${content}`\n-        });\n-      }\n-\n-      it('should advise exorting a local', () => {\n-        initWith(`const f: string; @Component({value: f}) export class MyComp {}`);\n-        expect(collectError('MyComp')).toContain(`Consider exporting 'f'`);\n-      });\n-\n-      it('should advise export a class', () => {\n-        initWith('class Foo {} @Component({value: Foo}) export class MyComp {}');\n-        expect(collectError('MyComp')).toContain(`Consider exporting 'Foo'`);\n-      });\n-\n-      it('should advise avoiding destructuring', () => {\n-        initWith(\n-            'export const {foo, bar} = {foo: 1, bar: 2}; @Component({value: foo}) export class MyComp {}');\n-        expect(collectError('MyComp')).toContain(`Consider simplifying to avoid destructuring`);\n-      });\n-\n-      it('should advise converting an arrow function into an exported function', () => {\n-        initWith('@Component({value: () => true}) export class MyComp {}');\n-        expect(collectError('MyComp'))\n-            .toContain(`Consider changing the function expression into an exported function`);\n-      });\n-\n-      it('should advise converting a function expression into an exported function', () => {\n-        initWith('@Component({value: function () { return true; }}) export class MyComp {}');\n-        expect(collectError('MyComp'))\n-            .toContain(`Consider changing the function expression into an exported function`);\n-      });\n-    });\n-  });\n-});\n-\n-const DEFAULT_TEST_DATA: {[key: string]: any} = {\n-  '/tmp/@angular/common/src/forms-deprecated/directives.d.ts': [{\n-    '__symbolic': 'module',\n-    'version': METADATA_VERSION,\n-    'metadata': {\n-      'FORM_DIRECTIVES': [{\n-        '__symbolic': 'reference',\n-        'name': 'NgFor',\n-        'module': '@angular/common/src/directives/ng_for'\n-      }]\n-    }\n-  }],\n-  '/tmp/@angular/common/src/directives/ng_for.d.ts': {\n-    '__symbolic': 'module',\n-    'version': METADATA_VERSION,\n-    'metadata': {\n-      'NgFor': {\n-        '__symbolic': 'class',\n-        'decorators': [{\n-          '__symbolic': 'call',\n-          'expression': {'__symbolic': 'reference', 'name': 'Directive', 'module': '@angular/core'},\n-          'arguments': [\n-            {'selector': '[ngFor][ngForOf]', 'inputs': ['ngForTrackBy', 'ngForOf', 'ngForTemplate']}\n-          ]\n-        }],\n-        'members': {\n-          '__ctor__': [{\n-            '__symbolic': 'constructor',\n-            'parameters': [\n-              {'__symbolic': 'reference', 'module': '@angular/core', 'name': 'ViewContainerRef'},\n-              {'__symbolic': 'reference', 'module': '@angular/core', 'name': 'TemplateRef'},\n-              {'__symbolic': 'reference', 'module': '@angular/core', 'name': 'IterableDiffers'},\n-              {'__symbolic': 'reference', 'module': '@angular/core', 'name': 'ChangeDetectorRef'}\n-            ]\n-          }]\n-        }\n-      }\n-    }\n-  },\n-  '/tmp/@angular/core/src/linker/view_container_ref.d.ts':\n-      {version: METADATA_VERSION, 'metadata': {'ViewContainerRef': {'__symbolic': 'class'}}},\n-  '/tmp/@angular/core/src/linker/template_ref.d.ts': {\n-    version: METADATA_VERSION,\n-    'module': './template_ref',\n-    'metadata': {'TemplateRef': {'__symbolic': 'class'}}\n-  },\n-  '/tmp/@angular/core/src/change_detection/differs/iterable_differs.d.ts':\n-      {version: METADATA_VERSION, 'metadata': {'IterableDiffers': {'__symbolic': 'class'}}},\n-  '/tmp/@angular/core/src/change_detection/change_detector_ref.d.ts':\n-      {version: METADATA_VERSION, 'metadata': {'ChangeDetectorRef': {'__symbolic': 'class'}}},\n-  '/tmp/src/app/hero-detail.component.d.ts': {\n-    '__symbolic': 'module',\n-    'version': METADATA_VERSION,\n-    'metadata': {\n-      'HeroDetailComponent': {\n-        '__symbolic': 'class',\n-        'decorators': [{\n-          '__symbolic': 'call',\n-          'expression': {'__symbolic': 'reference', 'name': 'Component', 'module': '@angular/core'},\n-          'arguments': [{\n-            'selector': 'my-hero-detail',\n-            'template':\n-                '\\n  <div *ngIf=\"hero\">\\n    <h2>{{hero.name}} details!</h2>\\n    <div><label>id: </label>{{hero.id}}</div>\\n    <div>\\n      <label>name: </label>\\n      <input [(ngModel)]=\"hero.name\" placeholder=\"name\"/>\\n    </div>\\n  </div>\\n',\n-          }]\n-        }],\n-        'members': {\n-          'hero': [{\n-            '__symbolic': 'property',\n-            'decorators': [{\n-              '__symbolic': 'call',\n-              'expression': {'__symbolic': 'reference', 'name': 'Input', 'module': '@angular/core'}\n-            }]\n-          }],\n-          'onMouseOver': [{\n-            '__symbolic': 'method',\n-            'decorators': [{\n-              '__symbolic': 'call',\n-              'expression':\n-                  {'__symbolic': 'reference', 'module': '@angular/core', 'name': 'HostListener'},\n-              'arguments': ['mouseover', ['$event']]\n-            }]\n-          }]\n-        }\n-      }\n-    }\n-  },\n-  '/src/extern.d.ts': {'__symbolic': 'module', 'version': METADATA_VERSION, metadata: {s: 's'}},\n-  '/tmp/src/error-reporting.d.ts': {\n-    __symbolic: 'module',\n-    version: METADATA_VERSION,\n-    metadata: {\n-      SomeClass: {\n-        __symbolic: 'class',\n-        decorators: [{\n-          __symbolic: 'call',\n-          expression: {__symbolic: 'reference', name: 'Component', module: '@angular/core'},\n-          arguments: [{\n-            entryComponents: [{\n-              __symbolic: 'reference',\n-              module: 'src/error-references',\n-              name: 'Link1',\n-            }]\n-          }]\n-        }],\n-      }\n-    }\n-  },\n-  '/tmp/src/error-references.d.ts': {\n-    __symbolic: 'module',\n-    version: METADATA_VERSION,\n-    metadata: {\n-      Link1: {__symbolic: 'reference', module: 'src/error-references', name: 'Link2'},\n-      Link2: {__symbolic: 'reference', module: 'src/error-references', name: 'ErrorSym'},\n-      ErrorSym:\n-          {__symbolic: 'error', message: 'A reasonable error message', line: 12, character: 33}\n-    }\n-  },\n-  '/tmp/src/function-declaration.d.ts': {\n-    __symbolic: 'module',\n-    version: METADATA_VERSION,\n-    metadata: {\n-      one: {\n-        __symbolic: 'function',\n-        parameters: ['a'],\n-        value: [{__symbolic: 'reference', name: 'a'}]\n-      },\n-      add: {\n-        __symbolic: 'function',\n-        parameters: ['a', 'b'],\n-        value: {\n-          __symbolic: 'binop',\n-          operator: '+',\n-          left: {__symbolic: 'reference', name: 'a'},\n-          right: {\n-            __symbolic: 'binop',\n-            operator: '+',\n-            left: {__symbolic: 'reference', name: 'b'},\n-            right: {__symbolic: 'reference', name: 'oneLiteral'}\n-          }\n-        }\n-      },\n-      oneLiteral: 1\n-    }\n-  },\n-  '/tmp/src/function-reference.ts': {\n-    __symbolic: 'module',\n-    version: METADATA_VERSION,\n-    metadata: {\n-      one: {\n-        __symbolic: 'call',\n-        expression: {__symbolic: 'reference', module: './function-declaration', name: 'one'},\n-        arguments: ['some-value']\n-      },\n-      three: {\n-        __symbolic: 'call',\n-        expression: {__symbolic: 'reference', module: './function-declaration', name: 'add'},\n-        arguments: [1, 1]\n-      },\n-      recursion: {\n-        __symbolic: 'call',\n-        expression: {__symbolic: 'reference', module: './function-recursive', name: 'recursive'},\n-        arguments: [1]\n-      },\n-      indirectRecursion: {\n-        __symbolic: 'call',\n-        expression:\n-            {__symbolic: 'reference', module: './function-recursive', name: 'indirectRecursion1'},\n-        arguments: [1]\n-      }\n-    }\n-  },\n-  '/tmp/src/function-recursive.d.ts': {\n-    __symbolic: 'modules',\n-    version: METADATA_VERSION,\n-    metadata: {\n-      recursive: {\n-        __symbolic: 'function',\n-        parameters: ['a'],\n-        value: {\n-          __symbolic: 'call',\n-          expression: {\n-            __symbolic: 'reference',\n-            module: './function-recursive',\n-            name: 'recursive',\n-          },\n-          arguments: [{__symbolic: 'reference', name: 'a'}]\n-        }\n-      },\n-      indirectRecursion1: {\n-        __symbolic: 'function',\n-        parameters: ['a'],\n-        value: {\n-          __symbolic: 'call',\n-          expression: {\n-            __symbolic: 'reference',\n-            module: './function-recursive',\n-            name: 'indirectRecursion2',\n-          },\n-          arguments: [{__symbolic: 'reference', name: 'a'}]\n-        }\n-      },\n-      indirectRecursion2: {\n-        __symbolic: 'function',\n-        parameters: ['a'],\n-        value: {\n-          __symbolic: 'call',\n-          expression: {\n-            __symbolic: 'reference',\n-            module: './function-recursive',\n-            name: 'indirectRecursion1',\n-          },\n-          arguments: [{__symbolic: 'reference', name: 'a'}]\n-        }\n-      }\n-    },\n-  },\n-  '/tmp/src/spread.ts': {\n-    __symbolic: 'module',\n-    version: METADATA_VERSION,\n-    metadata: {spread: [0, {__symbolic: 'spread', expression: [1, 2, 3, 4]}, 5]}\n-  },\n-  '/tmp/src/custom-decorator.ts': `\n-        export function CustomDecorator(): any {\n-          return () => {};\n-        }\n-      `,\n-  '/tmp/src/custom-decorator-reference.ts': `\n-        import {CustomDecorator} from './custom-decorator';\n-\n-        @CustomDecorator()\n-        export class Foo {\n-          @CustomDecorator() get foo(): string { return ''; }\n-        }\n-      `,\n-  '/tmp/src/invalid-call-definitions.ts': `\n-        export function someFunction(a: any) {\n-          if (Array.isArray(a)) {\n-            return a;\n-          }\n-          return undefined;\n-        }\n-      `,\n-  '/tmp/src/invalid-calls.ts': `\n-        import {someFunction} from './nvalid-call-definitions.ts';\n-        import {Component} from '@angular/core';\n-        import {NgIf} from '@angular/common';\n-\n-        @Component({\n-          selector: 'my-component',\n-          entryComponents: [someFunction([NgIf])]\n-        })\n-        export class MyComponent {}\n-\n-        @someFunction()\n-        @Component({\n-          selector: 'my-component',\n-          entryComponents: [NgIf]\n-        })\n-        export class MyOtherComponent { }\n-      `,\n-  '/tmp/src/static-method.ts': `\n-        import {Component} from '@angular/core/src/metadata';\n-\n-        @Component({\n-          selector: 'stub'\n-        })\n-        export class MyModule {\n-          static with(data: any) {\n-            return { provider: 'a', useValue: data }\n-          }\n-          static condMethod(cond: boolean) {\n-            return [{ provider: 'a', useValue: cond ? '1' : '2'}];\n-          }\n-          static defaultsMethod(a, b = true, c = false) {\n-            return [a, b, c];\n-          }\n-          static withFactory() {\n-            return { provide: 'c', useFactory: AnotherModule.someFactory };\n-          }\n-        }\n-\n-        export class AnotherModule {\n-          static someFactory() {\n-            return 'e';\n-          }\n-        }\n-      `,\n-  '/tmp/src/static-method-call.ts': `\n-        import {Component} from '@angular/core';\n-        import {MyModule} from './static-method';\n-\n-        @Component({\n-          providers: MyModule.with(100)\n-        })\n-        export class MyComponent { }\n-\n-        @Component({\n-          providers: [MyModule.condMethod(true), MyModule.condMethod(false)]\n-        })\n-        export class MyCondComponent { }\n-\n-        @Component({\n-          providers: [MyModule.defaultsMethod('a')]\n-        })\n-        export class MyDefaultsComponent { }\n-\n-        @Component({\n-          providers: MyModule.withFactory()\n-        })\n-        export class MyFactoryComponent { }\n-      `,\n-  '/tmp/src/static-field.ts': `\n-        import {Injectable} from '@angular/core';\n-\n-        @Injectable()\n-        export class MyModule {\n-          static VALUE = 'Some string';\n-        }\n-      `,\n-  '/tmp/src/macro-function.ts': `\n-        export function v(value: any) {\n-          return { provide: 'a', useValue: value };\n-        }\n-      `,\n-  '/tmp/src/call-macro-function.ts': `\n-        import {Component} from '@angular/core';\n-        import {v} from './macro-function';\n-\n-        @Component({\n-          providers: v(100)\n-        })\n-        export class MyComponent { }\n-\n-        @Component({\n-          providers: v(v(100))\n-        })\n-        export class MyComponentNested { }\n-      `,\n-  '/tmp/src/static-field-reference.ts': `\n-        import {Component} from '@angular/core';\n-        import {MyModule} from './static-field';\n-\n-        @Component({\n-          providers: [ { provider: 'a', useValue: MyModule.VALUE } ]\n-        })\n-        export class Foo { }\n-      `,\n-  '/tmp/src/static-method-def.ts': `\n-        export class ClassWithStatics {\n-          static staticMethod() {}\n-        }\n-      `,\n-  '/tmp/src/static-method-ref.ts': `\n-        import {Component} from '@angular/core';\n-        import {ClassWithStatics} from './static-method-def';\n-\n-        @Component({\n-          providers: [ { provider: 'a', useValue: ClassWithStatics.staticMethod}]\n-        })\n-        export class MethodReference {\n-\n-        }\n-      `,\n-  '/tmp/src/invalid-metadata.ts': `\n-        import {Component} from '@angular/core';\n-\n-        @Component({\n-          providers: [ { provider: 'a', useValue: (() => 1)() }]\n-        })\n-        export class InvalidMetadata {}\n-      `,\n-  '/tmp/src/forward-ref.ts': `\n-        import {forwardRef} from '@angular/core';\n-        import {Component} from '@angular/core';\n-        import {Inject} from '@angular/core';\n-        @Component({})\n-        export class Forward {\n-          constructor(@Inject(forwardRef(() => Dep)) d: Dep) {}\n-        }\n-        export class Dep {\n-          @Input f: Forward;\n-        }\n-      `,\n-};"
        },
        {
            "sha": "e969d199ba00175e41320ca4414b1ae407210fb0",
            "filename": "packages/compiler/test/aot/static_symbol_resolver_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 603,
            "changes": 603,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Faot%2Fstatic_symbol_resolver_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Faot%2Fstatic_symbol_resolver_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Faot%2Fstatic_symbol_resolver_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,603 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {StaticSymbol, StaticSymbolCache, StaticSymbolResolver, StaticSymbolResolverHost, Summary, SummaryResolver} from '@angular/compiler';\n-import {CollectorOptions, METADATA_VERSION} from '@angular/compiler-cli';\n-import {MetadataCollector} from '@angular/compiler-cli/src/metadata/collector';\n-import ts from 'typescript';\n-\n-// This matches .ts files but not .d.ts files.\n-const TS_EXT = /(^.|(?!\\.d)..)\\.ts$/;\n-\n-describe('StaticSymbolResolver', () => {\n-  let host: StaticSymbolResolverHost;\n-  let symbolResolver: StaticSymbolResolver;\n-  let symbolCache: StaticSymbolCache;\n-\n-  beforeEach(() => {\n-    symbolCache = new StaticSymbolCache();\n-  });\n-\n-  function init(\n-      testData: {[key: string]: any} = DEFAULT_TEST_DATA, summaries: Summary<StaticSymbol>[] = [],\n-      summaryImportAs: {symbol: StaticSymbol, importAs: StaticSymbol}[] = []) {\n-    host = new MockStaticSymbolResolverHost(testData);\n-    symbolResolver = new StaticSymbolResolver(\n-        host, symbolCache, new MockSummaryResolver(summaries, summaryImportAs));\n-  }\n-\n-  beforeEach(() => init());\n-\n-  it('should throw an exception for unsupported metadata versions', () => {\n-    expect(\n-        () => symbolResolver.resolveSymbol(\n-            symbolResolver.getSymbolByModule('src/version-error', 'e')))\n-        .toThrow(new Error(\n-            `Metadata version mismatch for module /tmp/src/version-error.d.ts, found version 100, expected ${\n-                METADATA_VERSION}`));\n-  });\n-\n-  it('should throw an exception for version 2 metadata', () => {\n-    expect(\n-        () => symbolResolver.resolveSymbol(\n-            symbolResolver.getSymbolByModule('src/version-2-error', 'e')))\n-        .toThrowError(\n-            'Unsupported metadata version 2 for module /tmp/src/version-2-error.d.ts. This module should be compiled with a newer version of ngc');\n-  });\n-\n-  it('should be produce the same symbol if asked twice', () => {\n-    const foo1 = symbolResolver.getStaticSymbol('main.ts', 'foo');\n-    const foo2 = symbolResolver.getStaticSymbol('main.ts', 'foo');\n-    expect(foo1).toBe(foo2);\n-  });\n-\n-  it('should be able to produce a symbol for a module with no file', () => {\n-    expect(symbolResolver.getStaticSymbol('angularjs', 'SomeAngularSymbol')).toBeDefined();\n-  });\n-\n-  it('should be able to split the metadata per symbol', () => {\n-    init({\n-      '/tmp/src/test.ts': `\n-        export var a = 1;\n-        export var b = 2;\n-      `\n-    });\n-    expect(symbolResolver.resolveSymbol(symbolResolver.getStaticSymbol('/tmp/src/test.ts', 'a'))\n-               .metadata)\n-        .toBe(1);\n-    expect(symbolResolver.resolveSymbol(symbolResolver.getStaticSymbol('/tmp/src/test.ts', 'b'))\n-               .metadata)\n-        .toBe(2);\n-  });\n-\n-  it('should be able to resolve static symbols with members', () => {\n-    init({\n-      '/tmp/src/test.ts': `\n-        export {exportedObj} from './export';\n-\n-        export var obj = {a: 1};\n-        export class SomeClass {\n-          static someField = 2;\n-        }\n-      `,\n-      '/tmp/src/export.ts': `\n-        export var exportedObj = {};\n-      `,\n-    });\n-    expect(symbolResolver\n-               .resolveSymbol(symbolResolver.getStaticSymbol('/tmp/src/test.ts', 'obj', ['a']))\n-               .metadata)\n-        .toBe(1);\n-    expect(symbolResolver\n-               .resolveSymbol(\n-                   symbolResolver.getStaticSymbol('/tmp/src/test.ts', 'SomeClass', ['someField']))\n-               .metadata)\n-        .toBe(2);\n-    expect(symbolResolver\n-               .resolveSymbol(symbolResolver.getStaticSymbol(\n-                   '/tmp/src/test.ts', 'exportedObj', ['someMember']))\n-               .metadata)\n-        .toBe(symbolResolver.getStaticSymbol('/tmp/src/export.ts', 'exportedObj', ['someMember']));\n-  });\n-\n-  it('should not explore re-exports of the same module', () => {\n-    init({\n-      '/tmp/src/test.ts': `\n-        export * from './test';\n-\n-        export const testValue = 10;\n-      `,\n-    });\n-\n-    const symbols = symbolResolver.getSymbolsOf('/tmp/src/test.ts');\n-    expect(symbols).toEqual([symbolResolver.getStaticSymbol('/tmp/src/test.ts', 'testValue')]);\n-  });\n-\n-  it('should use summaries in resolveSymbol and prefer them over regular metadata', () => {\n-    const symbolA = symbolCache.get('/test.ts', 'a');\n-    const symbolB = symbolCache.get('/test.ts', 'b');\n-    const symbolC = symbolCache.get('/test.ts', 'c');\n-    init({'/test.ts': 'export var a = 2; export var b = 2; export var c = 2;'}, [\n-      {symbol: symbolA, metadata: 1},\n-      {symbol: symbolB, metadata: 1},\n-    ]);\n-    // reading the metadata of a symbol without a summary first,\n-    // to test whether summaries are still preferred after this.\n-    expect(symbolResolver.resolveSymbol(symbolC).metadata).toBe(2);\n-    expect(symbolResolver.resolveSymbol(symbolA).metadata).toBe(1);\n-    expect(symbolResolver.resolveSymbol(symbolB).metadata).toBe(1);\n-  });\n-\n-  it('should be able to get all exported symbols of a file', () => {\n-    expect(symbolResolver.getSymbolsOf('/tmp/src/reexport/src/origin1.d.ts')).toEqual([\n-      symbolResolver.getStaticSymbol('/tmp/src/reexport/src/origin1.d.ts', 'One'),\n-      symbolResolver.getStaticSymbol('/tmp/src/reexport/src/origin1.d.ts', 'Two'),\n-      symbolResolver.getStaticSymbol('/tmp/src/reexport/src/origin1.d.ts', 'Three'),\n-      symbolResolver.getStaticSymbol('/tmp/src/reexport/src/origin1.d.ts', 'Six'),\n-    ]);\n-  });\n-\n-  it('should be able to get all reexported symbols of a file', () => {\n-    expect(symbolResolver.getSymbolsOf('/tmp/src/reexport/reexport.d.ts')).toEqual([\n-      symbolResolver.getStaticSymbol('/tmp/src/reexport/reexport.d.ts', 'One'),\n-      symbolResolver.getStaticSymbol('/tmp/src/reexport/reexport.d.ts', 'Two'),\n-      symbolResolver.getStaticSymbol('/tmp/src/reexport/reexport.d.ts', 'Four'),\n-      symbolResolver.getStaticSymbol('/tmp/src/reexport/reexport.d.ts', 'Six'),\n-      symbolResolver.getStaticSymbol('/tmp/src/reexport/reexport.d.ts', 'Five'),\n-      symbolResolver.getStaticSymbol('/tmp/src/reexport/reexport.d.ts', 'Thirty'),\n-    ]);\n-  });\n-\n-  it('should read the exported symbols of a file from the summary and ignore exports in the source',\n-     () => {\n-       init(\n-           {'/test.ts': 'export var b = 2'},\n-           [{symbol: symbolCache.get('/test.ts', 'a'), metadata: 1}]);\n-       expect(symbolResolver.getSymbolsOf('/test.ts')).toEqual([symbolCache.get('/test.ts', 'a')]);\n-     });\n-\n-  describe('importAs', () => {\n-    it('should calculate importAs relationship for non source files without summaries', () => {\n-      init(\n-          {\n-            '/test.d.ts': [{\n-              '__symbolic': 'module',\n-              'version': METADATA_VERSION,\n-              'metadata': {\n-                'a': {'__symbolic': 'reference', 'name': 'b', 'module': './test2'},\n-              }\n-            }],\n-            '/test2.d.ts': [{\n-              '__symbolic': 'module',\n-              'version': METADATA_VERSION,\n-              'metadata': {\n-                'b': {'__symbolic': 'reference', 'name': 'c', 'module': './test3'},\n-              }\n-            }]\n-          },\n-          []);\n-      symbolResolver.getSymbolsOf('/test.d.ts');\n-      symbolResolver.getSymbolsOf('/test2.d.ts');\n-\n-      expect(symbolResolver.getImportAs(symbolCache.get('/test2.d.ts', 'b')))\n-          .toBe(symbolCache.get('/test.d.ts', 'a'));\n-      expect(symbolResolver.getImportAs(symbolCache.get('/test3.d.ts', 'c')))\n-          .toBe(symbolCache.get('/test.d.ts', 'a'));\n-    });\n-\n-    it('should calculate importAs relationship for non source files with summaries', () => {\n-      init(\n-          {\n-            '/test.ts': `\n-          export {a} from './test2';\n-        `\n-          },\n-          [], [{\n-            symbol: symbolCache.get('/test2.d.ts', 'a'),\n-            importAs: symbolCache.get('/test3.d.ts', 'b')\n-          }]);\n-      symbolResolver.getSymbolsOf('/test.ts');\n-\n-      expect(symbolResolver.getImportAs(symbolCache.get('/test2.d.ts', 'a')))\n-          .toBe(symbolCache.get('/test3.d.ts', 'b'));\n-    });\n-\n-    it('should ignore summaries for inputAs if requested', () => {\n-      init(\n-          {\n-            '/test.ts': `\n-        export {a} from './test2';\n-      `\n-          },\n-          [], [{\n-            symbol: symbolCache.get('/test2.d.ts', 'a'),\n-            importAs: symbolCache.get('/test3.d.ts', 'b')\n-          }]);\n-\n-      symbolResolver.getSymbolsOf('/test.ts');\n-\n-      expect(\n-          symbolResolver.getImportAs(symbolCache.get('/test2.d.ts', 'a'), /* useSummaries */ false))\n-          .toBeUndefined();\n-    });\n-\n-    it('should calculate importAs for symbols with members based on importAs for symbols without',\n-       () => {\n-         init(\n-             {\n-               '/test.ts': `\n-          export {a} from './test2';\n-        `\n-             },\n-             [], [{\n-               symbol: symbolCache.get('/test2.d.ts', 'a'),\n-               importAs: symbolCache.get('/test3.d.ts', 'b')\n-             }]);\n-         symbolResolver.getSymbolsOf('/test.ts');\n-\n-         expect(symbolResolver.getImportAs(symbolCache.get('/test2.d.ts', 'a', ['someMember'])))\n-             .toBe(symbolCache.get('/test3.d.ts', 'b', ['someMember']));\n-       });\n-  });\n-\n-  it('should replace references by StaticSymbols', () => {\n-    init({\n-      '/test.ts': `\n-        import {b, y} from './test2';\n-        export var a = b;\n-        export var x = [y];\n-\n-        export function simpleFn(fnArg) {\n-          return [a, y, fnArg];\n-        }\n-      `,\n-      '/test2.ts': `\n-        export var b;\n-        export var y;\n-      `\n-    });\n-    expect(symbolResolver.resolveSymbol(symbolCache.get('/test.ts', 'a')).metadata)\n-        .toEqual(symbolCache.get('/test2.ts', 'b'));\n-    expect(symbolResolver.resolveSymbol(symbolCache.get('/test.ts', 'x')).metadata).toEqual([{\n-      __symbolic: 'resolved',\n-      symbol: symbolCache.get('/test2.ts', 'y'),\n-      line: 3,\n-      character: 24,\n-      fileName: '/test.ts'\n-    }]);\n-    expect(symbolResolver.resolveSymbol(symbolCache.get('/test.ts', 'simpleFn')).metadata).toEqual({\n-      __symbolic: 'function',\n-      parameters: ['fnArg'],\n-      value: [\n-        symbolCache.get('/test.ts', 'a'), {\n-          __symbolic: 'resolved',\n-          symbol: symbolCache.get('/test2.ts', 'y'),\n-          line: 6,\n-          character: 21,\n-          fileName: '/test.ts'\n-        },\n-        {__symbolic: 'reference', name: 'fnArg'}\n-      ]\n-    });\n-  });\n-\n-  it('should ignore module references without a name', () => {\n-    init({\n-      '/test.ts': `\n-        import Default from './test2';\n-        export {Default};\n-      `\n-    });\n-\n-    expect(symbolResolver.resolveSymbol(symbolCache.get('/test.ts', 'Default')).metadata)\n-        .toBeFalsy();\n-  });\n-\n-  it('should fill references to ambient symbols with undefined', () => {\n-    init({\n-      '/test.ts': `\n-        export var y = 1;\n-        export var z = [window, z];\n-      `\n-    });\n-\n-    expect(symbolResolver.resolveSymbol(symbolCache.get('/test.ts', 'z')).metadata).toEqual([\n-      undefined, symbolCache.get('/test.ts', 'z')\n-    ]);\n-  });\n-\n-  it('should allow to use symbols with __', () => {\n-    init({\n-      '/test.ts': `\n-        export {__a__ as __b__} from './test2';\n-        import {__c__} from './test2';\n-\n-        export var __x__ = 1;\n-        export var __y__ = __c__;\n-      `\n-    });\n-\n-    expect(symbolResolver.resolveSymbol(symbolCache.get('/test.ts', '__x__')).metadata).toBe(1);\n-    expect(symbolResolver.resolveSymbol(symbolCache.get('/test.ts', '__y__')).metadata)\n-        .toBe(symbolCache.get('/test2.d.ts', '__c__'));\n-    expect(symbolResolver.resolveSymbol(symbolCache.get('/test.ts', '__b__')).metadata)\n-        .toBe(symbolCache.get('/test2.d.ts', '__a__'));\n-\n-    expect(symbolResolver.getSymbolsOf('/test.ts')).toEqual([\n-      symbolCache.get('/test.ts', '__b__'),\n-      symbolCache.get('/test.ts', '__x__'),\n-      symbolCache.get('/test.ts', '__y__'),\n-    ]);\n-  });\n-\n-  it('should only use the arity for classes from libraries without summaries', () => {\n-    init({\n-      '/test.d.ts': [{\n-        '__symbolic': 'module',\n-        'version': METADATA_VERSION,\n-        'metadata': {\n-          'AParam': {__symbolic: 'class'},\n-          'AClass': {\n-            __symbolic: 'class',\n-            arity: 1,\n-            members: {\n-              __ctor__: [\n-                {__symbolic: 'constructor', parameters: [symbolCache.get('/test.d.ts', 'AParam')]}\n-              ]\n-            }\n-          }\n-        }\n-      }]\n-    });\n-\n-    expect(symbolResolver.resolveSymbol(symbolCache.get('/test.d.ts', 'AClass')).metadata)\n-        .toEqual({__symbolic: 'class', arity: 1});\n-  });\n-\n-  it('should be able to trace a named export', () => {\n-    const symbol = symbolResolver\n-                       .resolveSymbol(symbolResolver.getSymbolByModule(\n-                           './reexport/reexport', 'One', '/tmp/src/main.ts'))\n-                       .metadata;\n-    expect(symbol.name).toEqual('One');\n-    expect(symbol.filePath).toEqual('/tmp/src/reexport/src/origin1.d.ts');\n-  });\n-\n-  it('should be able to trace a renamed export', () => {\n-    const symbol = symbolResolver\n-                       .resolveSymbol(symbolResolver.getSymbolByModule(\n-                           './reexport/reexport', 'Four', '/tmp/src/main.ts'))\n-                       .metadata;\n-    expect(symbol.name).toEqual('Three');\n-    expect(symbol.filePath).toEqual('/tmp/src/reexport/src/origin1.d.ts');\n-  });\n-\n-  it('should be able to trace an export * export', () => {\n-    const symbol = symbolResolver\n-                       .resolveSymbol(symbolResolver.getSymbolByModule(\n-                           './reexport/reexport', 'Five', '/tmp/src/main.ts'))\n-                       .metadata;\n-    expect(symbol.name).toEqual('Five');\n-    expect(symbol.filePath).toEqual('/tmp/src/reexport/src/origin5.d.ts');\n-  });\n-\n-  it('should be able to trace a multi-level re-export', () => {\n-    const symbol1 = symbolResolver\n-                        .resolveSymbol(symbolResolver.getSymbolByModule(\n-                            './reexport/reexport', 'Thirty', '/tmp/src/main.ts'))\n-                        .metadata;\n-    expect(symbol1.name).toEqual('Thirty');\n-    expect(symbol1.filePath).toEqual('/tmp/src/reexport/src/reexport2.d.ts');\n-    const symbol2 = symbolResolver.resolveSymbol(symbol1).metadata;\n-    expect(symbol2.name).toEqual('Thirty');\n-    expect(symbol2.filePath).toEqual('/tmp/src/reexport/src/origin30.d.ts');\n-  });\n-\n-  it('should prefer names in the file over reexports', () => {\n-    const metadata = symbolResolver\n-                         .resolveSymbol(symbolResolver.getSymbolByModule(\n-                             './reexport/reexport', 'Six', '/tmp/src/main.ts'))\n-                         .metadata;\n-    expect(metadata.__symbolic).toBe('class');\n-  });\n-\n-  it('should cache tracing a named export', () => {\n-    const moduleNameToFileNameSpy = spyOn(host, 'moduleNameToFileName').and.callThrough();\n-    const getMetadataForSpy = spyOn(host, 'getMetadataFor').and.callThrough();\n-    symbolResolver.resolveSymbol(\n-        symbolResolver.getSymbolByModule('./reexport/reexport', 'One', '/tmp/src/main.ts'));\n-    moduleNameToFileNameSpy.calls.reset();\n-    getMetadataForSpy.calls.reset();\n-\n-    const symbol = symbolResolver\n-                       .resolveSymbol(symbolResolver.getSymbolByModule(\n-                           './reexport/reexport', 'One', '/tmp/src/main.ts'))\n-                       .metadata;\n-    expect(moduleNameToFileNameSpy.calls.count()).toBe(1);\n-    expect(getMetadataForSpy.calls.count()).toBe(0);\n-    expect(symbol.name).toEqual('One');\n-    expect(symbol.filePath).toEqual('/tmp/src/reexport/src/origin1.d.ts');\n-  });\n-});\n-\n-export class MockSummaryResolver implements SummaryResolver<StaticSymbol> {\n-  constructor(private summaries: Summary<StaticSymbol>[] = [], private importAs: {\n-    symbol: StaticSymbol,\n-    importAs: StaticSymbol\n-  }[] = []) {}\n-  addSummary(summary: Summary<StaticSymbol>) {\n-    this.summaries.push(summary);\n-  }\n-  resolveSummary(reference: StaticSymbol): Summary<StaticSymbol> {\n-    return this.summaries.find(summary => summary.symbol === reference)!;\n-  }\n-  getSymbolsOf(filePath: string): StaticSymbol[]|null {\n-    const symbols = this.summaries.filter(summary => summary.symbol.filePath === filePath)\n-                        .map(summary => summary.symbol);\n-    return symbols.length ? symbols : null;\n-  }\n-  getImportAs(symbol: StaticSymbol): StaticSymbol {\n-    const entry = this.importAs.find(entry => entry.symbol === symbol);\n-    return entry ? entry.importAs : undefined!;\n-  }\n-  getKnownModuleName(fileName: string): string|null {\n-    return null;\n-  }\n-  isLibraryFile(filePath: string): boolean {\n-    return filePath.endsWith('.d.ts');\n-  }\n-  toSummaryFileName(filePath: string): string {\n-    return filePath.replace(/(\\.d)?\\.ts$/, '.d.ts');\n-  }\n-  fromSummaryFileName(filePath: string): string {\n-    return filePath;\n-  }\n-}\n-\n-export class MockStaticSymbolResolverHost implements StaticSymbolResolverHost {\n-  private collector: MetadataCollector;\n-\n-  constructor(private data: {[key: string]: any}, collectorOptions?: CollectorOptions) {\n-    this.collector = new MetadataCollector(collectorOptions);\n-  }\n-\n-  // In tests, assume that symbols are not re-exported\n-  moduleNameToFileName(modulePath: string, containingFile?: string): string {\n-    function splitPath(path: string): string[] {\n-      return path.split(/\\/|\\\\/g);\n-    }\n-\n-    function resolvePath(pathParts: string[]): string {\n-      const result: string[] = [];\n-      pathParts.forEach((part, index) => {\n-        switch (part) {\n-          case '':\n-          case '.':\n-            if (index > 0) return;\n-            break;\n-          case '..':\n-            if (index > 0 && result.length != 0) result.pop();\n-            return;\n-        }\n-        result.push(part);\n-      });\n-      return result.join('/');\n-    }\n-\n-    function pathTo(from: string, to: string): string {\n-      let result = to;\n-      if (to.startsWith('.')) {\n-        const fromParts = splitPath(from);\n-        fromParts.pop();  // remove the file name.\n-        const toParts = splitPath(to);\n-        result = resolvePath(fromParts.concat(toParts));\n-      }\n-      return result;\n-    }\n-\n-    if (modulePath.indexOf('.') === 0) {\n-      const baseName = pathTo(containingFile!, modulePath);\n-      const tsName = baseName + '.ts';\n-      if (this._getMetadataFor(tsName)) {\n-        return tsName;\n-      }\n-      return baseName + '.d.ts';\n-    }\n-    if (modulePath == 'unresolved') {\n-      return undefined!;\n-    }\n-    return '/tmp/' + modulePath + '.d.ts';\n-  }\n-\n-  getMetadataFor(moduleId: string): any {\n-    return this._getMetadataFor(moduleId);\n-  }\n-\n-  getOutputName(filePath: string): string {\n-    return filePath;\n-  }\n-\n-  private _getMetadataFor(filePath: string): any {\n-    if (this.data[filePath] && filePath.match(TS_EXT)) {\n-      const text = this.data[filePath];\n-      if (typeof text === 'string') {\n-        const sf = ts.createSourceFile(\n-            filePath, this.data[filePath], ts.ScriptTarget.ES5, /* setParentNodes */ true);\n-        const diagnostics: ts.Diagnostic[] = (<any>sf).parseDiagnostics;\n-        if (diagnostics && diagnostics.length) {\n-          const errors = diagnostics\n-                             .map(d => {\n-                               const {line, character} =\n-                                   ts.getLineAndCharacterOfPosition(d.file!, d.start!);\n-                               return `(${line}:${character}): ${d.messageText}`;\n-                             })\n-                             .join('\\n');\n-          throw Error(`Error encountered during parse of file ${filePath}\\n${errors}`);\n-        }\n-        return [this.collector.getMetadata(sf)];\n-      }\n-    }\n-    const result = this.data[filePath];\n-    if (result) {\n-      return Array.isArray(result) ? result : [result];\n-    } else {\n-      return null;\n-    }\n-  }\n-}\n-\n-const DEFAULT_TEST_DATA: {[key: string]: any} = {\n-  '/tmp/src/version-error.d.ts': {'__symbolic': 'module', 'version': 100, metadata: {e: 's'}},\n-  '/tmp/src/version-2-error.d.ts': {'__symbolic': 'module', 'version': 2, metadata: {e: 's'}},\n-  '/tmp/src/reexport/reexport.d.ts': {\n-    __symbolic: 'module',\n-    version: METADATA_VERSION,\n-    metadata: {\n-      Six: {__symbolic: 'class'},\n-    },\n-    exports: [\n-      {from: './src/origin1', export: ['One', 'Two', {name: 'Three', as: 'Four'}, 'Six']},\n-      {from: './src/origin5'}, {from: './src/reexport2'}\n-    ]\n-  },\n-  '/tmp/src/reexport/src/origin1.d.ts': {\n-    __symbolic: 'module',\n-    version: METADATA_VERSION,\n-    metadata: {\n-      One: {__symbolic: 'class'},\n-      Two: {__symbolic: 'class'},\n-      Three: {__symbolic: 'class'},\n-      Six: {__symbolic: 'class'},\n-    },\n-  },\n-  '/tmp/src/reexport/src/origin5.d.ts': {\n-    __symbolic: 'module',\n-    version: METADATA_VERSION,\n-    metadata: {\n-      Five: {__symbolic: 'class'},\n-    },\n-  },\n-  '/tmp/src/reexport/src/origin30.d.ts': {\n-    __symbolic: 'module',\n-    version: METADATA_VERSION,\n-    metadata: {\n-      Thirty: {__symbolic: 'class'},\n-    },\n-  },\n-  '/tmp/src/reexport/src/originNone.d.ts': {\n-    __symbolic: 'module',\n-    version: METADATA_VERSION,\n-    metadata: {},\n-  },\n-  '/tmp/src/reexport/src/reexport2.d.ts': {\n-    __symbolic: 'module',\n-    version: METADATA_VERSION,\n-    metadata: {},\n-    exports: [{from: './originNone'}, {from: './origin30'}]\n-  }\n-};"
        },
        {
            "sha": "2870dc6ca0d5960ee425a655154f81c9c8b9cc23",
            "filename": "packages/compiler/test/aot/summary_resolver_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 145,
            "changes": 145,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Faot%2Fsummary_resolver_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Faot%2Fsummary_resolver_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Faot%2Fsummary_resolver_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,145 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {AotSummaryResolver, AotSummaryResolverHost, ResolvedStaticSymbol, StaticSymbolCache, StaticSymbolResolver} from '@angular/compiler';\n-import {serializeSummaries} from '@angular/compiler/src/aot/summary_serializer';\n-import {ConstantPool, OutputContext} from '@angular/compiler/src/constant_pool';\n-import * as o from '@angular/compiler/src/output/output_ast';\n-import * as path from 'path';\n-\n-import {MockStaticSymbolResolverHost, MockSummaryResolver} from './static_symbol_resolver_spec';\n-\n-const EXT = /(\\.d)?\\.ts$/;\n-\n-{\n-  describe('AotSummaryResolver', () => {\n-    let summaryResolver: AotSummaryResolver;\n-    let symbolCache: StaticSymbolCache;\n-    let host: MockAotSummaryResolverHost;\n-\n-    beforeEach(() => {\n-      symbolCache = new StaticSymbolCache();\n-    });\n-\n-    function init(summaries: {[filePath: string]: string} = {}) {\n-      host = new MockAotSummaryResolverHost(summaries);\n-      summaryResolver = new AotSummaryResolver(host, symbolCache);\n-    }\n-\n-    function serialize(\n-        symbols: ResolvedStaticSymbol[], enableExternalSymbolReexports = false): string {\n-      // Note: Don't use the top level host / summaryResolver as they might not be created yet\n-      const mockSummaryResolver = new MockSummaryResolver([]);\n-      const symbolResolver = new StaticSymbolResolver(\n-          new MockStaticSymbolResolverHost({}), symbolCache, mockSummaryResolver);\n-      return serializeSummaries(\n-                 'someFile.ts', createMockOutputContext(), mockSummaryResolver, symbolResolver,\n-                 symbols, [], enableExternalSymbolReexports)\n-          .json;\n-    }\n-\n-    it('should load serialized summary files', () => {\n-      const asymbol = symbolCache.get('/a.d.ts', 'a');\n-      init({'/a.ngsummary.json': serialize([{symbol: asymbol, metadata: 1}])});\n-      expect(summaryResolver.resolveSummary(asymbol)).toEqual({symbol: asymbol, metadata: 1});\n-    });\n-\n-    it('should not load summaries for source files', () => {\n-      init({});\n-      spyOn(host, 'loadSummary').and.callThrough();\n-\n-      expect(summaryResolver.resolveSummary(symbolCache.get('/a.ts', 'a'))).toBeFalsy();\n-      expect(host.loadSummary).not.toHaveBeenCalled();\n-    });\n-\n-    it('should cache summaries', () => {\n-      const asymbol = symbolCache.get('/a.d.ts', 'a');\n-      init({'/a.ngsummary.json': serialize([{symbol: asymbol, metadata: 1}])});\n-      expect(summaryResolver.resolveSummary(asymbol)).toBe(summaryResolver.resolveSummary(asymbol));\n-    });\n-\n-    it('should return all symbols in a summary', () => {\n-      const asymbol = symbolCache.get('/a.d.ts', 'a');\n-      init({'/a.ngsummary.json': serialize([{symbol: asymbol, metadata: 1}])});\n-      expect(summaryResolver.getSymbolsOf('/a.d.ts')).toEqual([asymbol]);\n-    });\n-\n-    it('should fill importAs for deep symbols if external symbol re-exports are enabled', () => {\n-      const libSymbol = symbolCache.get('/lib.d.ts', 'Lib');\n-      const srcSymbol = symbolCache.get('/src.ts', 'Src');\n-      init({\n-        '/src.ngsummary.json':\n-            serialize([{symbol: srcSymbol, metadata: 1}, {symbol: libSymbol, metadata: 2}], true)\n-      });\n-      summaryResolver.getSymbolsOf('/src.d.ts');\n-\n-      expect(summaryResolver.getImportAs(symbolCache.get('/src.d.ts', 'Src'))).toBeFalsy();\n-      expect(summaryResolver.getImportAs(libSymbol))\n-          .toBe(symbolCache.get('/src.ngfactory.d.ts', 'Lib_1'));\n-    });\n-\n-    describe('isLibraryFile', () => {\n-      it('should use host.isSourceFile to calculate the result', () => {\n-        init();\n-        expect(summaryResolver.isLibraryFile('someFile.ts')).toBe(false);\n-        expect(summaryResolver.isLibraryFile('someFile.d.ts')).toBe(true);\n-      });\n-\n-      it('should calculate the result for generated files based on the result for non generated files',\n-         () => {\n-           init();\n-           spyOn(host, 'isSourceFile').and.callThrough();\n-           expect(summaryResolver.isLibraryFile('someFile.ngfactory.ts')).toBe(false);\n-           expect(host.isSourceFile).toHaveBeenCalledWith('someFile.ts');\n-         });\n-    });\n-\n-    describe('regression', () => {\n-      // #18170\n-      it('should support resolving symbol with members ', () => {\n-        init();\n-        expect(summaryResolver.resolveSummary(symbolCache.get('/src.d.ts', 'Src', ['One', 'Two'])))\n-            .toBeNull();\n-      });\n-    });\n-  });\n-}\n-\n-\n-export class MockAotSummaryResolverHost implements AotSummaryResolverHost {\n-  constructor(private summaries: {[fileName: string]: string}) {}\n-\n-  fileNameToModuleName(fileName: string): string {\n-    return './' + path.basename(fileName).replace(EXT, '');\n-  }\n-\n-  toSummaryFileName(sourceFileName: string): string {\n-    return sourceFileName.replace(EXT, '') + '.d.ts';\n-  }\n-\n-  fromSummaryFileName(filePath: string): string {\n-    return filePath;\n-  }\n-\n-  isSourceFile(filePath: string) {\n-    return !filePath.endsWith('.d.ts');\n-  }\n-\n-  loadSummary(filePath: string): string {\n-    return this.summaries[filePath];\n-  }\n-}\n-\n-export function createMockOutputContext(): OutputContext {\n-  return {\n-    statements: [],\n-    genFilePath: 'someGenFilePath',\n-    importExpr: () => o.NULL_EXPR,\n-    constantPool: new ConstantPool()\n-  };\n-}"
        },
        {
            "sha": "4905f73944f754ad97ac2b438ea11614e0eb3f01",
            "filename": "packages/compiler/test/aot/summary_serializer_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 525,
            "changes": 525,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Faot%2Fsummary_serializer_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Faot%2Fsummary_serializer_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Faot%2Fsummary_serializer_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,525 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {AotSummaryResolver, AotSummaryResolverHost, CompileSummaryKind, StaticSymbol, StaticSymbolCache, StaticSymbolResolver, StaticSymbolResolverHost} from '@angular/compiler';\n-import {METADATA_VERSION} from '@angular/compiler-cli';\n-import {deserializeSummaries, serializeSummaries} from '@angular/compiler/src/aot/summary_serializer';\n-import {summaryFileName} from '@angular/compiler/src/aot/util';\n-\n-import {MockStaticSymbolResolverHost} from './static_symbol_resolver_spec';\n-import {createMockOutputContext, MockAotSummaryResolverHost} from './summary_resolver_spec';\n-\n-\n-{\n-  describe('summary serializer', () => {\n-    let summaryResolver: AotSummaryResolver;\n-    let symbolResolver: StaticSymbolResolver;\n-    let symbolCache: StaticSymbolCache;\n-    let host: MockAotSummaryResolverHost;\n-\n-    beforeEach(() => {\n-      symbolCache = new StaticSymbolCache();\n-    });\n-\n-    function init(\n-        summaries: {[filePath: string]: string} = {}, metadata: {[key: string]: any} = {}) {\n-      host = new MockAotSummaryResolverHost(summaries);\n-      summaryResolver = new AotSummaryResolver(host, symbolCache);\n-      symbolResolver = new StaticSymbolResolver(\n-          new MockStaticSymbolResolverHost(metadata), symbolCache, summaryResolver);\n-    }\n-\n-    describe('summaryFileName', () => {\n-      it('should add .ngsummary.json to the filename', () => {\n-        init();\n-        expect(summaryFileName('a.ts')).toBe('a.ngsummary.json');\n-        expect(summaryFileName('a.d.ts')).toBe('a.ngsummary.json');\n-        expect(summaryFileName('a.js')).toBe('a.ngsummary.json');\n-      });\n-    });\n-\n-    it('should serialize various data correctly', () => {\n-      init();\n-      const serializedData = serializeSummaries(\n-          'someFile.ts', createMockOutputContext(), summaryResolver, symbolResolver,\n-          [\n-            {\n-              symbol: symbolCache.get('/tmp/some_values.ts', 'Values'),\n-              metadata: {\n-                aNumber: 1,\n-                aString: 'hello',\n-                anArray: [1, 2],\n-                aStaticSymbol: symbolCache.get('/tmp/some_symbol.ts', 'someName'),\n-                aStaticSymbolWithMembers:\n-                    symbolCache.get('/tmp/some_symbol.ts', 'someName', ['someMember']),\n-              }\n-            },\n-            {\n-              symbol: symbolCache.get('/tmp/some_service.ts', 'SomeService'),\n-              metadata: {\n-                __symbolic: 'class',\n-                members: {'aMethod': {__symbolic: 'function'}},\n-                statics: {aStatic: true},\n-                decorators: ['aDecoratorData']\n-              }\n-            }\n-          ],\n-          [{\n-            summary: {\n-              summaryKind: CompileSummaryKind.Injectable,\n-              type: {\n-                reference: symbolCache.get('/tmp/some_service.ts', 'SomeService'),\n-              }\n-            } as any,\n-            metadata: null as any\n-          }]);\n-\n-\n-      const summaries =\n-          deserializeSummaries(symbolCache, summaryResolver, 'someFile.d.ts', serializedData.json)\n-              .summaries;\n-      expect(summaries.length).toBe(2);\n-\n-      // Note: change from .ts to .d.ts is expected\n-      expect(summaries[0].symbol).toBe(symbolCache.get('/tmp/some_values.d.ts', 'Values'));\n-      expect(summaries[0].metadata).toEqual({\n-        aNumber: 1,\n-        aString: 'hello',\n-        anArray: [1, 2],\n-        aStaticSymbol: symbolCache.get('/tmp/some_symbol.d.ts', 'someName'),\n-        aStaticSymbolWithMembers:\n-            symbolCache.get('/tmp/some_symbol.d.ts', 'someName', ['someMember'])\n-      });\n-\n-      expect(summaries[1].symbol).toBe(symbolCache.get('/tmp/some_service.d.ts', 'SomeService'));\n-      // serialization should drop class decorators\n-      expect(summaries[1].metadata).toEqual({\n-        __symbolic: 'class',\n-        members: {aMethod: {__symbolic: 'function'}},\n-        statics: {aStatic: true}\n-      });\n-      expect(summaries[1].type!.type.reference)\n-          .toBe(symbolCache.get('/tmp/some_service.d.ts', 'SomeService'));\n-    });\n-\n-    it('should automatically add exported directives / pipes of NgModules that are not source files',\n-       () => {\n-         init();\n-         const externalSerialized = serializeSummaries(\n-             'someFile.ts', createMockOutputContext(), summaryResolver, symbolResolver,\n-             [\n-               {symbol: symbolCache.get('/tmp/external.ts', 'SomeExternalPipe'), metadata: null},\n-               {symbol: symbolCache.get('/tmp/external.ts', 'SomeExternalDir'), metadata: null},\n-             ],\n-             [\n-               {\n-                 summary: {\n-                   summaryKind: CompileSummaryKind.Pipe,\n-                   type: {\n-                     reference: symbolCache.get('/tmp/external.ts', 'SomeExternalPipe'),\n-                   }\n-                 } as any,\n-                 metadata: null as any\n-               },\n-               {\n-                 summary: {\n-                   summaryKind: CompileSummaryKind.Directive,\n-                   type: {\n-                     reference: symbolCache.get('/tmp/external.ts', 'SomeExternalDir'),\n-                   },\n-                   providers: [],\n-                   viewProviders: [],\n-                 } as any,\n-                 metadata: null as any\n-               }\n-             ]);\n-         init({\n-           '/tmp/external.ngsummary.json': externalSerialized.json,\n-         });\n-\n-         const serialized = serializeSummaries(\n-             'someFile.ts', createMockOutputContext(), summaryResolver, symbolResolver,\n-             [\n-               {symbol: symbolCache.get('/tmp/some_module.ts', 'SomeModule'), metadata: null},\n-             ],\n-             [{\n-               summary: <any>{\n-                 summaryKind: CompileSummaryKind.NgModule,\n-                 type: {reference: symbolCache.get('/tmp/some_module.ts', 'SomeModule')},\n-                 exportedPipes: [\n-                   {reference: symbolCache.get('/tmp/some_pipe.ts', 'SomePipe')},\n-                   {reference: symbolCache.get('/tmp/external.d.ts', 'SomeExternalPipe')}\n-                 ],\n-                 exportedDirectives: [\n-                   {reference: symbolCache.get('/tmp/some_dir.ts', 'SomeDir')},\n-                   {reference: symbolCache.get('/tmp/external.d.ts', 'SomeExternalDir')}\n-                 ],\n-                 providers: [],\n-                 modules: [],\n-               },\n-               metadata: null as any\n-             }]);\n-         const summaries =\n-             deserializeSummaries(symbolCache, summaryResolver, 'someFile.d.ts', serialized.json)\n-                 .summaries;\n-         init({\n-           '/tmp/some_module.ngsummary.json': serialized.json,\n-         });\n-\n-         const serializedReexport = serializeSummaries(\n-             'someFile.ts', createMockOutputContext(), summaryResolver, symbolResolver,\n-             [\n-               {\n-                 symbol: symbolCache.get('/tmp/some_reexport.ts', 'ReexportModule'),\n-                 metadata: symbolCache.get('/tmp/some_module.d.ts', 'SomeModule')\n-               },\n-             ],\n-             []);\n-\n-         expect(summaries.length).toBe(3);\n-         expect(summaries[0].symbol).toBe(symbolCache.get('/tmp/some_module.d.ts', 'SomeModule'));\n-         expect(summaries[1].symbol).toBe(symbolCache.get('/tmp/external.d.ts', 'SomeExternalDir'));\n-         expect(summaries[2].symbol)\n-             .toBe(symbolCache.get('/tmp/external.d.ts', 'SomeExternalPipe'));\n-\n-         const reexportSummaries =\n-             deserializeSummaries(\n-                 symbolCache, summaryResolver, 'someFile.d.ts', serializedReexport.json)\n-                 .summaries;\n-         expect(reexportSummaries.length).toBe(4);\n-         expect(reexportSummaries[0].symbol)\n-             .toBe(symbolCache.get('/tmp/some_reexport.d.ts', 'ReexportModule'));\n-         expect(reexportSummaries[1].symbol)\n-             .toBe(symbolCache.get('/tmp/some_module.d.ts', 'SomeModule'));\n-         expect(reexportSummaries[2].symbol)\n-             .toBe(symbolCache.get('/tmp/external.d.ts', 'SomeExternalDir'));\n-         expect(reexportSummaries[3].symbol)\n-             .toBe(symbolCache.get('/tmp/external.d.ts', 'SomeExternalPipe'));\n-       });\n-\n-    it('should automatically add the metadata of referenced symbols that are not in the source files',\n-       () => {\n-         init();\n-         const externalSerialized = serializeSummaries(\n-             'someFile.ts', createMockOutputContext(), summaryResolver, symbolResolver,\n-             [\n-               {\n-                 symbol: symbolCache.get('/tmp/external.ts', 'PROVIDERS'),\n-                 metadata: [symbolCache.get('/tmp/external_svc.ts', 'SomeService')]\n-               },\n-               {\n-                 symbol: symbolCache.get('/tmp/external_svc.ts', 'SomeService'),\n-                 metadata: {__symbolic: 'class'}\n-               },\n-               // Note: This is an important usecase when using ng1 and ng2 together via\n-               // goog.module.\n-               // In these cases, users write the following to get a referrable symbol in metadata\n-               // collection:\n-               //   import UsernameService from 'goog:somePackage.UsernameService';\n-               //   export {UsernameService};\n-               {\n-                 symbol: symbolCache.get('/tmp/external.ts', 'ReexportNonExistent'),\n-                 metadata: symbolCache.get('/tmp/external.ts', 'NonExistent'),\n-               }\n-             ],\n-             [{\n-               summary: {\n-                 summaryKind: CompileSummaryKind.Injectable,\n-                 type: {\n-                   reference: symbolCache.get('/tmp/external_svc.ts', 'SomeService'),\n-                 }\n-               } as any,\n-               metadata: null as any\n-             }]);\n-         init(\n-             {\n-               '/tmp/external.ngsummary.json': externalSerialized.json,\n-             },\n-             {\n-               '/tmp/local.ts': `\n-          export var local = 'a';\n-        `,\n-               '/tmp/non_summary.d.ts':\n-                   {__symbolic: 'module', version: METADATA_VERSION, metadata: {'external': 'b'}}\n-             });\n-         const serialized = serializeSummaries(\n-             'someFile.ts', createMockOutputContext(), summaryResolver, symbolResolver, [{\n-               symbol: symbolCache.get('/tmp/test.ts', 'main'),\n-               metadata: {\n-                 local: symbolCache.get('/tmp/local.ts', 'local'),\n-                 external: symbolCache.get('/tmp/external.d.ts', 'PROVIDERS'),\n-                 externalNonSummary: symbolCache.get('/tmp/non_summary.d.ts', 'external'),\n-                 reexportNonExistent: symbolCache.get('/tmp/external.ts', 'ReexportNonExistent'),\n-               }\n-             }],\n-             []);\n-\n-         const summaries =\n-             deserializeSummaries(symbolCache, summaryResolver, 'someFile.d.ts', serialized.json)\n-                 .summaries;\n-         // Note: local should not show up!\n-         expect(summaries.length).toBe(4);\n-         expect(summaries[0].symbol).toBe(symbolCache.get('/tmp/test.d.ts', 'main'));\n-         expect(summaries[0].metadata).toEqual({\n-           local: symbolCache.get('/tmp/local.d.ts', 'local'),\n-           external: symbolCache.get('/tmp/external.d.ts', 'PROVIDERS'),\n-           externalNonSummary: symbolCache.get('/tmp/non_summary.d.ts', 'external'),\n-           reexportNonExistent: symbolCache.get('/tmp/external.d.ts', 'ReexportNonExistent'),\n-         });\n-         expect(summaries[1].symbol).toBe(symbolCache.get('/tmp/external.d.ts', 'PROVIDERS'));\n-         expect(summaries[1].metadata).toEqual([symbolCache.get(\n-             '/tmp/external_svc.d.ts', 'SomeService')]);\n-         // SomService is a transitive dep, but should have been serialized as well.\n-         expect(summaries[2].symbol).toBe(symbolCache.get('/tmp/external_svc.d.ts', 'SomeService'));\n-         expect(summaries[2].type!.type.reference)\n-             .toBe(symbolCache.get('/tmp/external_svc.d.ts', 'SomeService'));\n-         // there was no summary for non_summary, but it should have\n-         // been serialized as well.\n-         expect(summaries[3].symbol).toBe(symbolCache.get('/tmp/non_summary.d.ts', 'external'));\n-         expect(summaries[3].metadata).toEqual('b');\n-       });\n-\n-    it('should resolve reexported values in libraries', () => {\n-      init();\n-      const externalSerialized = serializeSummaries(\n-          'someFile.ts', createMockOutputContext(), summaryResolver, symbolResolver,\n-          [\n-            {symbol: symbolCache.get('/tmp/external.ts', 'value'), metadata: 'someString'},\n-            {\n-              symbol: symbolCache.get('/tmp/external.ts', 'reexportValue'),\n-              metadata: symbolCache.get('/tmp/external.ts', 'value')\n-            },\n-          ],\n-          []);\n-      init({\n-        '/tmp/external.ngsummary.json': externalSerialized.json,\n-      });\n-      const serialized = serializeSummaries(\n-          'someFile.ts', createMockOutputContext(), summaryResolver, symbolResolver,\n-          [\n-            {\n-              symbol: symbolCache.get('/tmp/test.ts', 'mainValue'),\n-              metadata: symbolCache.get('/tmp/external.d.ts', 'reexportValue'),\n-            },\n-          ],\n-          []);\n-\n-      const summaries =\n-          deserializeSummaries(symbolCache, summaryResolver, 'someFile.d.ts', serialized.json)\n-              .summaries;\n-      expect(summaries.length).toBe(2);\n-      expect(summaries[0].symbol).toBe(symbolCache.get('/tmp/test.d.ts', 'mainValue'));\n-      expect(summaries[0].metadata).toBe(symbolCache.get('/tmp/external.d.ts', 'value'));\n-      expect(summaries[1].symbol).toBe(symbolCache.get('/tmp/external.d.ts', 'value'));\n-      expect(summaries[1].metadata).toBe('someString');\n-    });\n-\n-    it('should use existing reexports for \"importAs\" for symbols of libraries', () => {\n-      init();\n-      const externalSerialized = serializeSummaries(\n-          'someFile.ts', createMockOutputContext(), summaryResolver, symbolResolver,\n-          [\n-            {symbol: symbolCache.get('/tmp/external.ts', 'value'), metadata: 'aValue'},\n-            {\n-              symbol: symbolCache.get('/tmp/external.ts', 'reexportValue'),\n-              metadata: symbolCache.get('/tmp/external.ts', 'value')\n-            },\n-          ],\n-          []);\n-      expect(externalSerialized.exportAs).toEqual([]);\n-      init({\n-        '/tmp/external.ngsummary.json': externalSerialized.json,\n-      });\n-      const serialized = serializeSummaries(\n-          'someFile.ts', createMockOutputContext(), summaryResolver, symbolResolver, [{\n-            symbol: symbolCache.get('/tmp/test.ts', 'mainValue'),\n-            metadata: symbolCache.get('/tmp/external.d.ts', 'reexportValue'),\n-          }],\n-          []);\n-      expect(serialized.exportAs).toEqual([]);\n-      const importAs =\n-          deserializeSummaries(symbolCache, summaryResolver, 'someFile.d.ts', serialized.json)\n-              .importAs;\n-      expect(importAs).toEqual([{\n-        symbol: symbolCache.get('/tmp/external.d.ts', 'value'),\n-        importAs: symbolCache.get('/tmp/test.d.ts', 'mainValue'),\n-      }]);\n-    });\n-\n-    describe('with resolved symbols', () => {\n-      it('should be able to serialize a call', () => {\n-        init();\n-        const serialized = serializeSummaries(\n-            'someFile.ts', createMockOutputContext(), summaryResolver, symbolResolver, [{\n-              symbol: symbolCache.get('/tmp/test.ts', 'main'),\n-              metadata: {\n-                __symbolic: 'call',\n-                expression:\n-                    {__symbolic: 'resolved', symbol: symbolCache.get('/tmp/test2.ts', 'ref')}\n-              }\n-            }],\n-            []);\n-        expect(serialized.json).not.toContain('error');\n-      });\n-\n-      it('should be able to serialize a call to a method', () => {\n-        init();\n-        const serialized = serializeSummaries(\n-            'someFile.ts', createMockOutputContext(), summaryResolver, symbolResolver, [{\n-              symbol: symbolCache.get('/tmp/test.ts', 'main'),\n-              metadata: {\n-                __symbolic: 'call',\n-                expression: {\n-                  __symbolic: 'select',\n-                  expression:\n-                      {__symbolic: 'resolved', symbol: symbolCache.get('/tmp/test2.ts', 'ref')},\n-                  name: 'foo'\n-                }\n-              }\n-            }],\n-            []);\n-        expect(serialized.json).not.toContain('error');\n-      });\n-    });\n-\n-\n-    describe('symbol re-exports enabled', () => {\n-      it('should not create \"importAs\" names for ctor arguments which are types of reexported classes in libraries',\n-         () => {\n-           init();\n-           const externalSerialized = serializeSummaries(\n-               'someFile.ts', createMockOutputContext(), summaryResolver, symbolResolver,\n-               [\n-                 {\n-                   symbol: symbolCache.get('/tmp/external.ts', 'type'),\n-                   metadata: {__symbolic: 'interface'}\n-                 },\n-                 {\n-                   symbol: symbolCache.get('/tmp/external.ts', 'value'),\n-                   metadata: {__symbolic: 'class'}\n-                 },\n-                 {\n-                   symbol: symbolCache.get('/tmp/external.ts', 'reexportClass'),\n-                   metadata: {\n-                     __symbolic: 'class',\n-                     'members': {\n-                       '__ctor__': [{\n-                         '__symbolic': 'constructor',\n-                         'parameters': [\n-                           symbolCache.get('/tmp/external.ts', 'type'),\n-                           symbolCache.get('/tmp/external.ts', 'value'),\n-                         ]\n-                       }]\n-                     }\n-\n-                   }\n-                 },\n-               ],\n-               [], true);\n-           expect(externalSerialized.exportAs).toEqual([]);\n-           init({\n-             '/tmp/external.ngsummary.json': externalSerialized.json,\n-           });\n-           const serialized = serializeSummaries(\n-               'someFile.ts', createMockOutputContext(), summaryResolver, symbolResolver, [{\n-                 symbol: symbolCache.get('/tmp/test.ts', 'mainClass'),\n-                 metadata: symbolCache.get('/tmp/external.d.ts', 'reexportClass'),\n-               }],\n-               [], true);\n-           const importAs =\n-               deserializeSummaries(symbolCache, summaryResolver, 'someFile.d.ts', serialized.json)\n-                   .importAs;\n-           expect(importAs).toEqual([\n-             {\n-               symbol: symbolCache.get('/tmp/external.d.ts', 'reexportClass'),\n-               importAs: symbolCache.get('/tmp/test.d.ts', 'mainClass'),\n-             },\n-             {\n-               symbol: symbolCache.get('/tmp/external.d.ts', 'value'),\n-               importAs: symbolCache.get('someFile.ngfactory.d.ts', 'value_3'),\n-             }\n-           ]);\n-         });\n-\n-      it('should create reexports in the ngfactory for symbols of libraries', () => {\n-        init();\n-        const serialized = serializeSummaries(\n-            'someFile.ts', createMockOutputContext(), summaryResolver, symbolResolver, [{\n-              symbol: symbolCache.get('/tmp/test.ts', 'main'),\n-              metadata: [\n-                symbolCache.get('/tmp/external.d.ts', 'lib'),\n-                symbolCache.get('/tmp/external.d.ts', 'lib', ['someMember']),\n-              ]\n-            }],\n-            [], true);\n-        // Note: no entry for the symbol with members!\n-        expect(serialized.exportAs).toEqual([\n-          {symbol: symbolCache.get('/tmp/external.d.ts', 'lib'), exportAs: 'lib_1'}\n-        ]);\n-\n-        const deserialized =\n-            deserializeSummaries(symbolCache, summaryResolver, 'someFile.d.ts', serialized.json);\n-        // Note: no entry for the symbol with members!\n-        expect(deserialized.importAs).toEqual([{\n-          symbol: symbolCache.get('/tmp/external.d.ts', 'lib'),\n-          importAs: symbolCache.get('someFile.ngfactory.d.ts', 'lib_1')\n-        }]);\n-      });\n-    });\n-\n-    it('should use existing reexports for \"importAs\" for symbols of libraries', () => {\n-      init();\n-      const externalSerialized = serializeSummaries(\n-          'someFile.ts', createMockOutputContext(), summaryResolver, symbolResolver,\n-          [\n-            {symbol: symbolCache.get('/tmp/external.ts', 'value'), metadata: 'aValue'},\n-            {\n-              symbol: symbolCache.get('/tmp/external.ts', 'reexportValue'),\n-              metadata: symbolCache.get('/tmp/external.ts', 'value')\n-            },\n-          ],\n-          [], false);\n-      expect(externalSerialized.exportAs).toEqual([]);\n-      init({\n-        '/tmp/external.ngsummary.json': externalSerialized.json,\n-      });\n-      const serialized = serializeSummaries(\n-          'someFile.ts', createMockOutputContext(), summaryResolver, symbolResolver, [{\n-            symbol: symbolCache.get('/tmp/test.ts', 'mainValue'),\n-            metadata: symbolCache.get('/tmp/external.d.ts', 'reexportValue'),\n-          }],\n-          []);\n-      expect(serialized.exportAs).toEqual([]);\n-      const importAs =\n-          deserializeSummaries(symbolCache, summaryResolver, 'someFile.d.ts', serialized.json)\n-              .importAs;\n-      expect(importAs).toEqual([{\n-        symbol: symbolCache.get('/tmp/external.d.ts', 'value'),\n-        importAs: symbolCache.get('/tmp/test.d.ts', 'mainValue'),\n-      }]);\n-    });\n-\n-    it('should not create reexports in the ngfactory for external symbols', () => {\n-      init();\n-      const serialized = serializeSummaries(\n-          'someFile.ts', createMockOutputContext(), summaryResolver, symbolResolver, [{\n-            symbol: symbolCache.get('/tmp/test.ts', 'main'),\n-            metadata: [\n-              symbolCache.get('/tmp/external.d.ts', 'lib'),\n-              symbolCache.get('/tmp/external.d.ts', 'lib', ['someMember']),\n-            ]\n-          }],\n-          [], false);\n-      expect(serialized.exportAs.length).toBe(0, 'Expected no external symbols to be re-exported.');\n-      const deserialized =\n-          deserializeSummaries(symbolCache, summaryResolver, 'someFile.d.ts', serialized.json);\n-      expect(deserialized.importAs.length)\n-          .toBe(0, 'Expected no symbols that can be imported from a re-exported location');\n-    });\n-  });\n-}"
        },
        {
            "sha": "18994d6abafbfbac128d7c61d4ebd32ba1d06b88",
            "filename": "packages/compiler/test/aot/test_util.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 890,
            "changes": 890,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Faot%2Ftest_util.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Faot%2Ftest_util.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Faot%2Ftest_util.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,890 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {AotCompilerHost, AotCompilerOptions, createAotCompiler, GeneratedFile, toTypeScript} from '@angular/compiler';\n-import {MetadataBundlerHost} from '@angular/compiler-cli/src/metadata/bundler';\n-import {MetadataCollector} from '@angular/compiler-cli/src/metadata/collector';\n-import {ModuleMetadata} from '@angular/compiler-cli/src/metadata/index';\n-import {getCachedSourceFile} from '@angular/compiler-cli/src/ngtsc/testing';\n-import {newArray} from '@angular/compiler/src/util';\n-import * as fs from 'fs';\n-import * as path from 'path';\n-import ts from 'typescript';\n-\n-export interface MetadataProvider {\n-  getMetadata(source: ts.SourceFile): ModuleMetadata|undefined;\n-}\n-\n-let nodeModulesPath: string;\n-let angularSourcePath: string;\n-let rootPath: string;\n-\n-calcPathsOnDisc();\n-\n-export type MockFileOrDirectory = string|MockDirectory;\n-\n-export type MockDirectory = {\n-  [name: string]: MockFileOrDirectory|undefined;\n-};\n-\n-export function isDirectory(data: MockFileOrDirectory|undefined): data is MockDirectory {\n-  return typeof data !== 'string';\n-}\n-\n-const rxjs = /\\/rxjs\\//;\n-export const settings: ts.CompilerOptions = {\n-  target: ts.ScriptTarget.ES5,\n-  declaration: true,\n-  module: ts.ModuleKind.CommonJS,\n-  moduleResolution: ts.ModuleResolutionKind.NodeJs,\n-  emitDecoratorMetadata: true,\n-  experimentalDecorators: true,\n-  removeComments: false,\n-  noImplicitAny: false,\n-  skipLibCheck: true,\n-  strictNullChecks: true,\n-  lib: ['lib.es2015.d.ts', 'lib.dom.d.ts'],\n-  types: []\n-};\n-\n-export interface EmitterOptions {\n-  emitMetadata: boolean;\n-  mockData?: MockDirectory;\n-  context?: Map<string, string>;\n-}\n-\n-function calcPathsOnDisc() {\n-  const moduleFilename = module.filename.replace(/\\\\/g, '/');\n-  const distIndex = moduleFilename.indexOf('/dist/all');\n-  if (distIndex >= 0) {\n-    rootPath = moduleFilename.substr(0, distIndex);\n-    nodeModulesPath = path.join(rootPath, 'node_modules');\n-    angularSourcePath = path.join(rootPath, 'packages');\n-  }\n-}\n-\n-\n-export class EmittingCompilerHost implements ts.CompilerHost {\n-  private addedFiles = new Map<string, string>();\n-  private writtenFiles = new Map<string, string>();\n-  private scriptNames: string[];\n-  private root = '/';\n-  private collector = new MetadataCollector();\n-  private cachedAddedDirectories: Set<string>|undefined;\n-\n-  constructor(scriptNames: string[], private options: EmitterOptions) {\n-    // Rewrite references to scripts with '@angular' to its corresponding location in\n-    // the source tree.\n-    this.scriptNames = scriptNames.map(f => this.effectiveName(f));\n-    this.root = rootPath || this.root;\n-    if (options.context) {\n-      this.addedFiles = mergeMaps(options.context);\n-    }\n-  }\n-\n-  public writtenAngularFiles(target = new Map<string, string>()): Map<string, string> {\n-    this.written.forEach((value, key) => {\n-      const path = `/node_modules/@angular${key.substring(angularSourcePath.length)}`;\n-      target.set(path, value);\n-    });\n-    return target;\n-  }\n-\n-  public addScript(fileName: string, content: string) {\n-    const scriptName = this.effectiveName(fileName);\n-    this.addedFiles.set(scriptName, content);\n-    this.cachedAddedDirectories = undefined;\n-    this.scriptNames.push(scriptName);\n-  }\n-\n-  public override(fileName: string, content: string) {\n-    const scriptName = this.effectiveName(fileName);\n-    this.addedFiles.set(scriptName, content);\n-    this.cachedAddedDirectories = undefined;\n-  }\n-\n-  public addFiles(map: Map<string, string>) {\n-    for (const [name, content] of Array.from(map.entries())) {\n-      this.addedFiles.set(name, content);\n-    }\n-  }\n-\n-  public addWrittenFile(fileName: string, content: string) {\n-    this.writtenFiles.set(this.effectiveName(fileName), content);\n-  }\n-\n-  public getWrittenFiles(): {name: string, content: string}[] {\n-    return Array.from(this.writtenFiles).map(f => ({name: f[0], content: f[1]}));\n-  }\n-\n-  public get scripts(): string[] {\n-    return this.scriptNames;\n-  }\n-\n-  public get written(): Map<string, string> {\n-    return this.writtenFiles;\n-  }\n-\n-  public effectiveName(fileName: string): string {\n-    const prefix = '@angular/';\n-    return angularSourcePath && fileName.startsWith(prefix) ?\n-        path.join(angularSourcePath, fileName.substr(prefix.length)) :\n-        fileName;\n-  }\n-\n-  // ts.ModuleResolutionHost\n-  fileExists(fileName: string): boolean {\n-    return this.addedFiles.has(fileName) || open(fileName, this.options.mockData) != null ||\n-        fs.existsSync(fileName);\n-  }\n-\n-  readFile(fileName: string): string {\n-    const result = this.addedFiles.get(fileName) || open(fileName, this.options.mockData);\n-    if (result) return result;\n-\n-    let basename = path.basename(fileName);\n-    if (/^lib.*\\.d\\.ts$/.test(basename)) {\n-      let libPath = ts.getDefaultLibFilePath(settings);\n-      return fs.readFileSync(path.join(path.dirname(libPath), basename), 'utf8');\n-    }\n-    return fs.readFileSync(fileName, 'utf8');\n-  }\n-\n-  directoryExists(directoryName: string): boolean {\n-    return directoryExists(directoryName, this.options.mockData) ||\n-        this.getAddedDirectories().has(directoryName) ||\n-        (fs.existsSync(directoryName) && fs.statSync(directoryName).isDirectory());\n-  }\n-\n-  getCurrentDirectory(): string {\n-    return this.root;\n-  }\n-\n-  getDirectories(dir: string): string[] {\n-    const result = open(dir, this.options.mockData);\n-    if (result && typeof result !== 'string') {\n-      return Object.keys(result);\n-    }\n-    return fs.readdirSync(dir).filter(p => {\n-      const name = path.join(dir, p);\n-      const stat = fs.statSync(name);\n-      return stat && stat.isDirectory();\n-    });\n-  }\n-\n-  // ts.CompilerHost\n-  getSourceFile(\n-      fileName: string, languageVersion: ts.ScriptTarget,\n-      onError?: (message: string) => void): ts.SourceFile {\n-    const content = this.readFile(fileName);\n-    if (content) {\n-      const cachedSf = getCachedSourceFile(fileName, () => content);\n-      if (cachedSf !== null) {\n-        return cachedSf;\n-      }\n-      return ts.createSourceFile(fileName, content, languageVersion, /* setParentNodes */ true);\n-    }\n-    throw new Error(`File not found '${fileName}'.`);\n-  }\n-\n-  getDefaultLibFileName(options: ts.CompilerOptions): string {\n-    return 'lib.d.ts';\n-  }\n-\n-  writeFile: ts.WriteFileCallback =\n-      (fileName: string, data: string, writeByteOrderMark: boolean,\n-       onError?: (message: string) => void, sourceFiles?: ReadonlyArray<ts.SourceFile>) => {\n-        this.addWrittenFile(fileName, data);\n-        if (this.options.emitMetadata && sourceFiles && sourceFiles.length && DTS.test(fileName)) {\n-          const metadataFilePath = fileName.replace(DTS, '.metadata.json');\n-          const metadata = this.collector.getMetadata(sourceFiles[0]);\n-          if (metadata) {\n-            this.addWrittenFile(metadataFilePath, JSON.stringify(metadata));\n-          }\n-        }\n-      }\n-\n-  getCanonicalFileName(fileName: string): string {\n-    return fileName;\n-  }\n-  useCaseSensitiveFileNames(): boolean {\n-    return false;\n-  }\n-  getNewLine(): string {\n-    return '\\n';\n-  }\n-\n-  private getAddedDirectories(): Set<string> {\n-    let result = this.cachedAddedDirectories;\n-    if (!result) {\n-      const newCache = new Set<string>();\n-      const addFile = (fileName: string) => {\n-        const directory = fileName.substr(0, fileName.lastIndexOf('/'));\n-        if (!newCache.has(directory)) {\n-          newCache.add(directory);\n-          addFile(directory);\n-        }\n-      };\n-      Array.from(this.addedFiles.keys()).forEach(addFile);\n-      this.cachedAddedDirectories = result = newCache;\n-    }\n-    return result;\n-  }\n-}\n-\n-export class MockCompilerHost implements ts.CompilerHost {\n-  scriptNames: string[];\n-\n-  public overrides = new Map<string, string>();\n-  public writtenFiles = new Map<string, string>();\n-  private sourceFiles = new Map<string, ts.SourceFile>();\n-  private assumeExists = new Set<string>();\n-  private traces: string[] = [];\n-\n-  constructor(scriptNames: string[], private data: MockDirectory) {\n-    this.scriptNames = [...scriptNames];\n-  }\n-\n-  // Test API\n-  override(fileName: string, content: string) {\n-    if (content) {\n-      this.overrides.set(fileName, content);\n-    } else {\n-      this.overrides.delete(fileName);\n-    }\n-    this.sourceFiles.delete(fileName);\n-  }\n-\n-  addScript(fileName: string, content: string) {\n-    this.overrides.set(fileName, content);\n-    this.scriptNames.push(fileName);\n-    this.sourceFiles.delete(fileName);\n-  }\n-\n-  assumeFileExists(fileName: string) {\n-    this.assumeExists.add(fileName);\n-  }\n-\n-  remove(files: string[]) {\n-    // Remove the files from the list of scripts.\n-    const fileSet = new Set(files);\n-    this.scriptNames = this.scriptNames.filter(f => fileSet.has(f));\n-\n-    // Remove files from written files\n-    files.forEach(f => this.writtenFiles.delete(f));\n-  }\n-\n-  // ts.ModuleResolutionHost\n-  fileExists(fileName: string): boolean {\n-    if (this.overrides.has(fileName) || this.writtenFiles.has(fileName) ||\n-        this.assumeExists.has(fileName)) {\n-      return true;\n-    }\n-    const effectiveName = this.getEffectiveName(fileName);\n-    if (effectiveName == fileName) {\n-      return open(fileName, this.data) != null;\n-    }\n-    if (fileName.match(rxjs)) {\n-      return fs.existsSync(effectiveName);\n-    }\n-    return false;\n-  }\n-\n-  readFile(fileName: string): string {\n-    return this.getFileContent(fileName)!;\n-  }\n-\n-  trace(s: string): void {\n-    this.traces.push(s);\n-  }\n-\n-  getCurrentDirectory(): string {\n-    return '/';\n-  }\n-\n-  getDirectories(dir: string): string[] {\n-    const effectiveName = this.getEffectiveName(dir);\n-    if (effectiveName === dir) {\n-      const data = find(dir, this.data);\n-      if (isDirectory(data)) {\n-        return Object.keys(data).filter(k => isDirectory(data[k]));\n-      }\n-    }\n-    return [];\n-  }\n-\n-  // ts.CompilerHost\n-  getSourceFile(\n-      fileName: string, languageVersion: ts.ScriptTarget,\n-      onError?: (message: string) => void): ts.SourceFile|undefined {\n-    let result = this.sourceFiles.get(fileName);\n-    if (!result) {\n-      const content = this.getFileContent(fileName);\n-      const cachedSf = getCachedSourceFile(fileName, () => content);\n-      if (cachedSf !== null) {\n-        return cachedSf;\n-      }\n-      if (content) {\n-        result = ts.createSourceFile(fileName, content, languageVersion);\n-        this.sourceFiles.set(fileName, result);\n-      }\n-    }\n-    return result;\n-  }\n-\n-  getDefaultLibFileName(options: ts.CompilerOptions): string {\n-    return 'lib.d.ts';\n-  }\n-\n-  writeFile: ts.WriteFileCallback =\n-      (fileName: string, data: string, writeByteOrderMark: boolean) => {\n-        this.writtenFiles.set(fileName, data);\n-        this.sourceFiles.delete(fileName);\n-      }\n-\n-  getCanonicalFileName(fileName: string): string {\n-    return fileName;\n-  }\n-  useCaseSensitiveFileNames(): boolean {\n-    return false;\n-  }\n-  getNewLine(): string {\n-    return '\\n';\n-  }\n-\n-  // Private methods\n-  private getFileContent(fileName: string): string|undefined {\n-    if (this.overrides.has(fileName)) {\n-      return this.overrides.get(fileName);\n-    }\n-    if (this.writtenFiles.has(fileName)) {\n-      return this.writtenFiles.get(fileName);\n-    }\n-    let basename = path.basename(fileName);\n-    if (/^lib.*\\.d\\.ts$/.test(basename)) {\n-      let libPath = ts.getDefaultLibFilePath(settings);\n-      return fs.readFileSync(path.join(path.dirname(libPath), basename), 'utf8');\n-    }\n-    let effectiveName = this.getEffectiveName(fileName);\n-    if (effectiveName === fileName) {\n-      return open(fileName, this.data);\n-    }\n-    if (fileName.match(rxjs) && fs.existsSync(fileName)) {\n-      return fs.readFileSync(fileName, 'utf8');\n-    }\n-  }\n-\n-  private getEffectiveName(name: string): string {\n-    const node_modules = 'node_modules';\n-    const rxjs = '/rxjs';\n-    if (name.startsWith('/' + node_modules)) {\n-      if (nodeModulesPath && name.startsWith('/' + node_modules + rxjs)) {\n-        return path.join(nodeModulesPath, name.substr(node_modules.length + 1));\n-      }\n-    }\n-    return name;\n-  }\n-}\n-\n-const EXT = /(\\.ts|\\.d\\.ts|\\.js|\\.jsx|\\.tsx)$/;\n-const DTS = /\\.d\\.ts$/;\n-const GENERATED_FILES = /\\.ngfactory\\.ts$|\\.ngstyle\\.ts$/;\n-\n-export class MockAotCompilerHost implements AotCompilerHost {\n-  private metadataVisible: boolean = true;\n-  private dtsAreSource: boolean = true;\n-  private resolveModuleNameHost: ts.ModuleResolutionHost;\n-\n-  constructor(\n-      private tsHost: MockCompilerHost,\n-      private metadataProvider: MetadataProvider = new MetadataCollector()) {\n-    this.resolveModuleNameHost = Object.create(tsHost);\n-    this.resolveModuleNameHost.fileExists = (fileName) => {\n-      fileName = stripNgResourceSuffix(fileName);\n-      return tsHost.fileExists(fileName);\n-    };\n-  }\n-\n-  hideMetadata() {\n-    this.metadataVisible = false;\n-  }\n-\n-  tsFilesOnly() {\n-    this.dtsAreSource = false;\n-  }\n-\n-  // StaticSymbolResolverHost\n-  getMetadataFor(modulePath: string): {[key: string]: any}[]|undefined {\n-    if (!this.tsHost.fileExists(modulePath)) {\n-      return undefined;\n-    }\n-    if (DTS.test(modulePath)) {\n-      if (this.metadataVisible) {\n-        const metadataPath = modulePath.replace(DTS, '.metadata.json');\n-        if (this.tsHost.fileExists(metadataPath)) {\n-          let result = JSON.parse(this.tsHost.readFile(metadataPath)) as {[key: string]: any}[];\n-          return Array.isArray(result) ? result : [result];\n-        }\n-      }\n-    } else {\n-      const sf = this.tsHost.getSourceFile(modulePath, ts.ScriptTarget.Latest);\n-      const metadata = sf && this.metadataProvider.getMetadata(sf);\n-      return metadata ? [metadata] : [];\n-    }\n-    return undefined;\n-  }\n-\n-  moduleNameToFileName(moduleName: string, containingFile: string): string|null {\n-    if (!containingFile || !containingFile.length) {\n-      if (moduleName.indexOf('.') === 0) {\n-        throw new Error('Resolution of relative paths requires a containing file.');\n-      }\n-      // Any containing file gives the same result for absolute imports\n-      containingFile = path.join('/', 'index.ts');\n-    }\n-    moduleName = moduleName.replace(EXT, '');\n-    const resolved = ts.resolveModuleName(\n-                           moduleName, containingFile.replace(/\\\\/g, '/'),\n-                           {baseDir: '/', genDir: '/'}, this.resolveModuleNameHost)\n-                         .resolvedModule;\n-    return resolved ? resolved.resolvedFileName : null;\n-  }\n-\n-  getOutputName(filePath: string) {\n-    return filePath;\n-  }\n-\n-  resourceNameToFileName(resourceName: string, containingFile: string) {\n-    // Note: we convert package paths into relative paths to be compatible with the the\n-    // previous implementation of UrlResolver.\n-    if (resourceName && resourceName.charAt(0) !== '.' && !path.isAbsolute(resourceName)) {\n-      resourceName = `./${resourceName}`;\n-    }\n-    const filePathWithNgResource =\n-        this.moduleNameToFileName(addNgResourceSuffix(resourceName), containingFile);\n-    return filePathWithNgResource ? stripNgResourceSuffix(filePathWithNgResource) : null;\n-  }\n-\n-  // AotSummaryResolverHost\n-  loadSummary(filePath: string): string|null {\n-    return this.tsHost.readFile(filePath);\n-  }\n-\n-  isSourceFile(sourceFilePath: string): boolean {\n-    return !GENERATED_FILES.test(sourceFilePath) &&\n-        (this.dtsAreSource || !DTS.test(sourceFilePath));\n-  }\n-\n-  toSummaryFileName(filePath: string): string {\n-    return filePath.replace(EXT, '') + '.d.ts';\n-  }\n-\n-  fromSummaryFileName(filePath: string): string {\n-    return filePath;\n-  }\n-\n-  // AotCompilerHost\n-  fileNameToModuleName(importedFile: string, containingFile: string): string {\n-    return importedFile.replace(EXT, '');\n-  }\n-\n-  loadResource(path: string): string {\n-    if (this.tsHost.fileExists(path)) {\n-      return this.tsHost.readFile(path);\n-    } else {\n-      throw new Error(`Resource ${path} not found.`);\n-    }\n-  }\n-}\n-\n-export class MockMetadataBundlerHost implements MetadataBundlerHost {\n-  private collector = new MetadataCollector();\n-\n-  constructor(private host: ts.CompilerHost) {}\n-\n-  getMetadataFor(moduleName: string): ModuleMetadata|undefined {\n-    const source = this.host.getSourceFile(moduleName + '.ts', ts.ScriptTarget.Latest);\n-    return source && this.collector.getMetadata(source);\n-  }\n-}\n-\n-function find(fileName: string, data: MockFileOrDirectory|undefined): MockFileOrDirectory|\n-    undefined {\n-  if (!data) return undefined;\n-  const names = fileName.split('/');\n-  if (names.length && !names[0].length) names.shift();\n-  let current: MockFileOrDirectory|undefined = data;\n-  for (const name of names) {\n-    if (typeof current !== 'object') {\n-      return undefined;\n-    }\n-    current = current[name];\n-  }\n-  return current;\n-}\n-\n-function open(fileName: string, data: MockFileOrDirectory|undefined): string|undefined {\n-  let result = find(fileName, data);\n-  if (typeof result === 'string') {\n-    return result;\n-  }\n-  return undefined;\n-}\n-\n-function directoryExists(dirname: string, data: MockFileOrDirectory|undefined): boolean {\n-  let result = find(dirname, data);\n-  return !!result && typeof result !== 'string';\n-}\n-\n-export type MockFileArray = {\n-  fileName: string,\n-  content: string\n-}[];\n-\n-export type MockData = MockDirectory|Map<string, string>|(MockDirectory|Map<string, string>)[];\n-\n-export function toMockFileArray(data: MockData, target: MockFileArray = []): MockFileArray {\n-  if (data instanceof Map) {\n-    mapToMockFileArray(data, target);\n-  } else if (Array.isArray(data)) {\n-    data.forEach(entry => toMockFileArray(entry, target));\n-  } else {\n-    mockDirToFileArray(data, '', target);\n-  }\n-  return target;\n-}\n-\n-function mockDirToFileArray(dir: MockDirectory, path: string, target: MockFileArray) {\n-  Object.keys(dir).forEach((localFileName) => {\n-    const value = dir[localFileName]!;\n-    const fileName = `${path}/${localFileName}`;\n-    if (typeof value === 'string') {\n-      target.push({fileName, content: value});\n-    } else {\n-      mockDirToFileArray(value, fileName, target);\n-    }\n-  });\n-}\n-\n-function mapToMockFileArray(files: Map<string, string>, target: MockFileArray) {\n-  files.forEach((content, fileName) => {\n-    target.push({fileName, content});\n-  });\n-}\n-\n-export function arrayToMockMap(arr: MockFileArray): Map<string, string> {\n-  const map = new Map<string, string>();\n-  arr.forEach(({fileName, content}) => {\n-    map.set(fileName, content);\n-  });\n-  return map;\n-}\n-\n-export function arrayToMockDir(arr: MockFileArray): MockDirectory {\n-  const rootDir: MockDirectory = {};\n-  arr.forEach(({fileName, content}) => {\n-    let pathParts = fileName.split('/');\n-    // trim trailing slash\n-    let startIndex = pathParts[0] ? 0 : 1;\n-    // get/create the directory\n-    let currentDir = rootDir;\n-    for (let i = startIndex; i < pathParts.length - 1; i++) {\n-      const pathPart = pathParts[i];\n-      let localDir = <MockDirectory>currentDir[pathPart];\n-      if (!localDir) {\n-        currentDir[pathPart] = localDir = {};\n-      }\n-      currentDir = localDir;\n-    }\n-    // write the file\n-    currentDir[pathParts[pathParts.length - 1]] = content;\n-  });\n-  return rootDir;\n-}\n-\n-const minCoreIndex = `\n-  export * from './src/application_module';\n-  export * from './src/change_detection';\n-  export * from './src/metadata';\n-  export * from './src/di/metadata';\n-  export * from './src/di/injectable';\n-  export * from './src/di/injector';\n-  export * from './src/di/injection_token';\n-  export * from './src/linker';\n-  export * from './src/render';\n-  export * from './src/codegen_private_exports';\n-`;\n-\n-function readBazelWrittenFilesFrom(\n-    bazelPackageRoot: string, packageName: string, map: Map<string, string>,\n-    skip: (name: string, fullName: string) => boolean = () => false) {\n-  function processDirectory(dir: string, dest: string) {\n-    const entries = fs.readdirSync(dir);\n-    for (const name of entries) {\n-      const fullName = path.posix.join(dir, name);\n-      const destName = path.posix.join(dest, name);\n-      const stat = fs.statSync(fullName);\n-      if (!skip(name, fullName)) {\n-        if (stat.isDirectory()) {\n-          processDirectory(fullName, destName);\n-        } else {\n-          const content = fs.readFileSync(fullName, 'utf8');\n-          map.set(destName, content);\n-        }\n-      }\n-    }\n-  }\n-  try {\n-    processDirectory(bazelPackageRoot, path.posix.join('/node_modules/@angular', packageName));\n-    // todo: check why we always need an index.d.ts\n-    if (fs.existsSync(path.join(bazelPackageRoot, `${packageName}.d.ts`))) {\n-      const content = fs.readFileSync(path.join(bazelPackageRoot, `${packageName}.d.ts`), 'utf8');\n-      map.set(path.posix.join('/node_modules/@angular', packageName, 'index.d.ts'), content);\n-    }\n-  } catch (e) {\n-    console.error(`Consider adding //packages/${\n-        packageName} as a data dependency in the BUILD.bazel rule for the failing test`);\n-    throw e;\n-  }\n-}\n-\n-export function isInBazel(): boolean {\n-  return process.env.TEST_SRCDIR != null;\n-}\n-\n-export function setup(options: {\n-  compileAngular: boolean,\n-  compileFakeCore?: boolean, compileAnimations: boolean,\n-  compileCommon?: boolean\n-} = {\n-  compileAngular: true,\n-  compileAnimations: true,\n-}) {\n-  let angularFiles = new Map<string, string>();\n-\n-  beforeAll(() => {\n-    const sources = process.env.TEST_SRCDIR;\n-    if (sources) {\n-      // If running under bazel then we get the compiled version of the files from the bazel package\n-      // output.\n-      const bundles = new Set([\n-        'bundles', 'esm2015', 'esm5', 'testing', 'testing.d.ts', 'testing.metadata.json', 'browser',\n-        'browser.d.ts'\n-      ]);\n-      const skipDirs = (name: string) => bundles.has(name);\n-      if (options.compileAngular) {\n-        // If this fails please add //packages/core:npm_package as a test data dependency.\n-        readBazelWrittenFilesFrom(\n-            resolveNpmTreeArtifact('npm/node_modules/@angular/core-12'), 'core', angularFiles,\n-            skipDirs);\n-      }\n-      if (options.compileAnimations) {\n-        // If this fails please add //packages/animations:npm_package as a test data dependency.\n-        readBazelWrittenFilesFrom(\n-            resolveNpmTreeArtifact('npm/node_modules/@angular/animations-12'), 'animations',\n-            angularFiles, skipDirs);\n-      }\n-      return;\n-    }\n-\n-    if (options.compileAngular) {\n-      const emittingHost = new EmittingCompilerHost([], {emitMetadata: true});\n-      emittingHost.addScript('@angular/core/index.ts', minCoreIndex);\n-      const emittingProgram = ts.createProgram(emittingHost.scripts, settings, emittingHost);\n-      emittingProgram.emit();\n-      emittingHost.writtenAngularFiles(angularFiles);\n-    }\n-    if (options.compileAnimations) {\n-      const emittingHost =\n-          new EmittingCompilerHost(['@angular/animations/index.ts'], {emitMetadata: true});\n-      const emittingProgram = ts.createProgram(emittingHost.scripts, settings, emittingHost);\n-      emittingProgram.emit();\n-      emittingHost.writtenAngularFiles(angularFiles);\n-    }\n-  });\n-\n-  return angularFiles;\n-}\n-\n-export function expectNoDiagnostics(program: ts.Program) {\n-  function fileInfo(diagnostic: ts.Diagnostic): string {\n-    if (diagnostic.file) {\n-      return `${diagnostic.file.fileName}(${diagnostic.start}): `;\n-    }\n-    return '';\n-  }\n-\n-  function chars(len: number, ch: string): string {\n-    return newArray(len, ch).join('');\n-  }\n-\n-  function lineNoOf(offset: number, text: string): number {\n-    let result = 1;\n-    for (let i = 0; i < offset; i++) {\n-      if (text[i] == '\\n') result++;\n-    }\n-    return result;\n-  }\n-\n-  function lineInfo(diagnostic: ts.Diagnostic): string {\n-    if (diagnostic.file) {\n-      const start = diagnostic.start!;\n-      let end = diagnostic.start! + diagnostic.length!;\n-      const source = diagnostic.file.text;\n-      let lineStart = start;\n-      let lineEnd = end;\n-      while (lineStart > 0 && source[lineStart] != '\\n') lineStart--;\n-      if (lineStart < start) lineStart++;\n-      while (lineEnd < source.length && source[lineEnd] != '\\n') lineEnd++;\n-      let line = source.substring(lineStart, lineEnd);\n-      const lineIndex = line.indexOf('/n');\n-      if (lineIndex > 0) {\n-        line = line.substr(0, lineIndex);\n-        end = start + lineIndex;\n-      }\n-      const lineNo = lineNoOf(start, source) + ': ';\n-      return '\\n' + lineNo + line + '\\n' + chars(start - lineStart + lineNo.length, ' ') +\n-          chars(end - start, '^');\n-    }\n-    return '';\n-  }\n-\n-  function expectNoDiagnostics(diagnostics: ReadonlyArray<ts.Diagnostic>) {\n-    if (diagnostics && diagnostics.length) {\n-      throw new Error(\n-          'Errors from TypeScript:\\n' +\n-          diagnostics\n-              .map(\n-                  d => `${fileInfo(d)}${ts.flattenDiagnosticMessageText(d.messageText, '\\n')}${\n-                      lineInfo(d)}`)\n-              .join(' \\n'));\n-    }\n-  }\n-  expectNoDiagnostics(program.getOptionsDiagnostics());\n-  expectNoDiagnostics(program.getSyntacticDiagnostics());\n-  expectNoDiagnostics(program.getSemanticDiagnostics());\n-}\n-\n-export function isSource(fileName: string): boolean {\n-  return !isDts(fileName) && /\\.ts$/.test(fileName);\n-}\n-\n-function isDts(fileName: string): boolean {\n-  return /\\.d.ts$/.test(fileName);\n-}\n-\n-function isSourceOrDts(fileName: string): boolean {\n-  return /\\.ts$/.test(fileName) && !/(ngfactory|ngstyle|ngsummary).d.ts$/.test(fileName);\n-}\n-\n-function resolveNpmTreeArtifact(manifestPath: string, resolveFile = 'package.json') {\n-  return path.dirname(require.resolve(path.posix.join(manifestPath, resolveFile)));\n-}\n-\n-export function compile(\n-    rootDirs: MockData, options: {\n-      emit?: boolean,\n-      useSummaries?: boolean,\n-      preCompile?: (program: ts.Program) => void,\n-      postCompile?: (program: ts.Program) => void,\n-    }&AotCompilerOptions = {},\n-    tsOptions: ts.CompilerOptions = {}): {genFiles: GeneratedFile[], outDir: MockDirectory} {\n-  // when using summaries, always emit so the next step can use the results.\n-  const emit = options.emit || options.useSummaries;\n-  const preCompile = options.preCompile || (() => {});\n-  const postCompile = options.postCompile || expectNoDiagnostics;\n-  const rootDirArr = toMockFileArray(rootDirs);\n-  const scriptNames = rootDirArr.map(entry => entry.fileName)\n-                          .filter(options.useSummaries ? isSource : isSourceOrDts);\n-\n-  const host = new MockCompilerHost(scriptNames, arrayToMockDir(rootDirArr));\n-  const aotHost = new MockAotCompilerHost(host);\n-  if (options.useSummaries) {\n-    aotHost.hideMetadata();\n-    aotHost.tsFilesOnly();\n-  }\n-  const tsSettings = {...settings, ...tsOptions};\n-  const program = ts.createProgram([...host.scriptNames], tsSettings, host);\n-  preCompile(program);\n-  const {compiler, reflector} = createAotCompiler(aotHost, options, (err) => {\n-    throw err;\n-  });\n-  const analyzedModules =\n-      compiler.analyzeModulesSync(program.getSourceFiles().map(sf => sf.fileName));\n-  const genFiles = compiler.emitAllImpls(analyzedModules);\n-  genFiles.forEach((file) => {\n-    const source = file.source || toTypeScript(file);\n-    if (isSource(file.genFileUrl)) {\n-      host.addScript(file.genFileUrl, source);\n-    } else {\n-      host.override(file.genFileUrl, source);\n-    }\n-  });\n-  const newProgram = ts.createProgram([...host.scriptNames], tsSettings, host);\n-  postCompile(newProgram);\n-  if (emit) {\n-    newProgram.emit();\n-  }\n-  let outDir: MockDirectory = {};\n-  if (emit) {\n-    const dtsFilesWithGenFiles = new Set<string>(genFiles.map(gf => gf.srcFileUrl).filter(isDts));\n-    outDir =\n-        arrayToMockDir(toMockFileArray([host.writtenFiles, host.overrides])\n-                           .filter((entry) => !isSource(entry.fileName))\n-                           .concat(rootDirArr.filter(e => dtsFilesWithGenFiles.has(e.fileName))));\n-  }\n-  return {genFiles, outDir};\n-}\n-\n-function stripNgResourceSuffix(fileName: string): string {\n-  return fileName.replace(/\\.\\$ngresource\\$.*/, '');\n-}\n-\n-function addNgResourceSuffix(fileName: string): string {\n-  return `${fileName}.$ngresource$`;\n-}\n-\n-function extractFileNames(directory: MockDirectory): string[] {\n-  const result: string[] = [];\n-  const scan = (directory: MockDirectory, prefix: string) => {\n-    for (let name of Object.getOwnPropertyNames(directory)) {\n-      const entry = directory[name];\n-      const fileName = `${prefix}/${name}`;\n-      if (typeof entry === 'string') {\n-        result.push(fileName);\n-      } else if (entry) {\n-        scan(entry, fileName);\n-      }\n-    }\n-  };\n-  scan(directory, '');\n-  return result;\n-}\n-\n-export function emitLibrary(\n-    context: Map<string, string>, mockData: MockDirectory,\n-    scriptFiles?: string[]): Map<string, string> {\n-  const emittingHost = new EmittingCompilerHost(\n-      scriptFiles || extractFileNames(mockData), {emitMetadata: true, mockData, context});\n-  const emittingProgram = ts.createProgram(emittingHost.scripts, settings, emittingHost);\n-  expectNoDiagnostics(emittingProgram);\n-  emittingProgram.emit();\n-  return emittingHost.written;\n-}\n-\n-export function mergeMaps<K, V>(...maps: Map<K, V>[]): Map<K, V> {\n-  const result = new Map<K, V>();\n-\n-  for (const map of maps) {\n-    for (const [key, value] of Array.from(map.entries())) {\n-      result.set(key, value);\n-    }\n-  }\n-\n-  return result;\n-}"
        },
        {
            "sha": "a453dec5db1c5b8c290ae32040890ed564af2d9b",
            "filename": "packages/compiler/test/config_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 30,
            "changes": 30,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fconfig_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fconfig_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fconfig_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,30 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {MissingTranslationStrategy} from '@angular/core';\n-import {CompilerConfig, preserveWhitespacesDefault} from '../src/config';\n-\n-{\n-  describe('compiler config', () => {\n-    it('should set missing translation strategy', () => {\n-      const config = new CompilerConfig({missingTranslation: MissingTranslationStrategy.Error});\n-      expect(config.missingTranslation).toEqual(MissingTranslationStrategy.Error);\n-    });\n-  });\n-\n-  describe('preserveWhitespacesDefault', () => {\n-    it('should return the default `false` setting when no preserveWhitespacesOption are provided',\n-       () => {\n-         expect(preserveWhitespacesDefault(null)).toEqual(false);\n-       });\n-    it('should return the preserveWhitespacesOption when provided as a parameter', () => {\n-      expect(preserveWhitespacesDefault(true)).toEqual(true);\n-      expect(preserveWhitespacesDefault(false)).toEqual(false);\n-    });\n-  });\n-}"
        },
        {
            "sha": "6e98b952c4d583be803ab78af025614259024173",
            "filename": "packages/compiler/test/core_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 206,
            "changes": 206,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fcore_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fcore_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fcore_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,206 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {core as compilerCore} from '@angular/compiler';\n-import * as core from '@angular/core';\n-\n-{\n-  describe('compiler core', () => {\n-    it('Attribute should be equal', () => {\n-      typeExtends<compilerCore.Attribute, core.Attribute>();\n-      typeExtends<core.Attribute, compilerCore.Attribute>();\n-      compareRuntimeShape(new core.Attribute('someName'), compilerCore.createAttribute('someName'));\n-    });\n-\n-    it('Inject should be equal', () => {\n-      typeExtends<compilerCore.Inject, core.Inject>();\n-      typeExtends<core.Inject, compilerCore.Inject>();\n-      compareRuntimeShape(new core.Inject('someName'), compilerCore.createInject('someName'));\n-    });\n-\n-    it('Query should be equal', () => {\n-      typeExtends<compilerCore.Query, core.Query>();\n-      typeExtends<core.Query, compilerCore.Query>();\n-      compareRuntimeShape(\n-          new core.ContentChild('someSelector'), compilerCore.createContentChild('someSelector'));\n-      compareRuntimeShape(\n-          new core.ContentChild('someSelector', {read: 'someRead'}),\n-          compilerCore.createContentChild('someSelector', {read: 'someRead'}));\n-      compareRuntimeShape(\n-          new core.ContentChildren('someSelector'),\n-          compilerCore.createContentChildren('someSelector'));\n-      compareRuntimeShape(\n-          new core.ContentChildren('someSelector', {read: 'someRead', descendants: false}),\n-          compilerCore.createContentChildren(\n-              'someSelector', {read: 'someRead', descendants: false}));\n-      compareRuntimeShape(\n-          new core.ViewChild('someSelector'), compilerCore.createViewChild('someSelector'));\n-      compareRuntimeShape(\n-          new core.ViewChild('someSelector', {read: 'someRead'}),\n-          compilerCore.createViewChild('someSelector', {read: 'someRead'}));\n-      compareRuntimeShape(\n-          new core.ViewChildren('someSelector'), compilerCore.createViewChildren('someSelector'));\n-      compareRuntimeShape(\n-          new core.ViewChildren('someSelector', {read: 'someRead'}),\n-          compilerCore.createViewChildren('someSelector', {read: 'someRead'}));\n-    });\n-\n-    it('Directive should be equal', () => {\n-      typeExtends<compilerCore.Directive, core.Directive>();\n-      typeExtends<core.Directive, compilerCore.Directive>();\n-      compareRuntimeShape(new core.Directive({}), compilerCore.createDirective({}));\n-    });\n-\n-    it('Component should be equal', () => {\n-      typeExtends<compilerCore.Component, core.Component>();\n-      typeExtends<core.Component, compilerCore.Component>();\n-      compareRuntimeShape(new core.Component({}), compilerCore.createComponent({}));\n-    });\n-\n-    it('Pipe should be equal', () => {\n-      typeExtends<compilerCore.Pipe, core.Pipe>();\n-      typeExtends<core.Pipe, compilerCore.Pipe>();\n-      compareRuntimeShape(\n-          new core.Pipe({name: 'someName'}), compilerCore.createPipe({name: 'someName'}));\n-    });\n-\n-    it('NgModule should be equal', () => {\n-      typeExtends<compilerCore.NgModule, core.NgModule>();\n-      typeExtends<core.NgModule, compilerCore.NgModule>();\n-      compareRuntimeShape(new core.NgModule({}), compilerCore.createNgModule({}));\n-    });\n-\n-    it('marker metadata should be equal', () => {\n-      compareRuntimeShape(new core.Injectable(), compilerCore.createInjectable());\n-      compareRuntimeShape(new core.Optional(), compilerCore.createOptional());\n-      compareRuntimeShape(new core.Self(), compilerCore.createSelf());\n-      compareRuntimeShape(new core.SkipSelf(), compilerCore.createSkipSelf());\n-      compareRuntimeShape(new core.Host(), compilerCore.createHost());\n-    });\n-\n-    it('InjectionToken should be equal', () => {\n-      compareRuntimeShape(\n-          new core.InjectionToken('someName'), compilerCore.createInjectionToken('someName'));\n-    });\n-\n-    it('non const enums should be equal', () => {\n-      typeExtends<compilerCore.ViewEncapsulation, core.ViewEncapsulation>();\n-      typeExtends<core.ViewEncapsulation, compilerCore.ViewEncapsulation>();\n-\n-      typeExtends<compilerCore.ChangeDetectionStrategy, core.ChangeDetectionStrategy>();\n-      typeExtends<core.ChangeDetectionStrategy, compilerCore.ChangeDetectionStrategy>();\n-\n-      typeExtends<compilerCore.SecurityContext, core.SecurityContext>();\n-      typeExtends<core.SecurityContext, compilerCore.SecurityContext>();\n-\n-      typeExtends<compilerCore.MissingTranslationStrategy, core.MissingTranslationStrategy>();\n-      typeExtends<core.MissingTranslationStrategy, compilerCore.MissingTranslationStrategy>();\n-    });\n-\n-    it('const enums should be equal', () => {\n-      const expectToBe = (val1: any, val2: any) => expect(val1).toBe(val2);\n-\n-      expectToBe(compilerCore.NodeFlags.None, core.ɵNodeFlags.None);\n-      expectToBe(compilerCore.NodeFlags.TypeElement, core.ɵNodeFlags.TypeElement);\n-      expectToBe(compilerCore.NodeFlags.TypeText, core.ɵNodeFlags.TypeText);\n-      expectToBe(compilerCore.NodeFlags.ProjectedTemplate, core.ɵNodeFlags.ProjectedTemplate);\n-      expectToBe(compilerCore.NodeFlags.CatRenderNode, core.ɵNodeFlags.CatRenderNode);\n-      expectToBe(compilerCore.NodeFlags.TypeNgContent, core.ɵNodeFlags.TypeNgContent);\n-      expectToBe(compilerCore.NodeFlags.TypePipe, core.ɵNodeFlags.TypePipe);\n-      expectToBe(compilerCore.NodeFlags.TypePureArray, core.ɵNodeFlags.TypePureArray);\n-      expectToBe(compilerCore.NodeFlags.TypePureObject, core.ɵNodeFlags.TypePureObject);\n-      expectToBe(compilerCore.NodeFlags.TypePurePipe, core.ɵNodeFlags.TypePurePipe);\n-      expectToBe(compilerCore.NodeFlags.CatPureExpression, core.ɵNodeFlags.CatPureExpression);\n-      expectToBe(compilerCore.NodeFlags.TypeValueProvider, core.ɵNodeFlags.TypeValueProvider);\n-      expectToBe(compilerCore.NodeFlags.TypeClassProvider, core.ɵNodeFlags.TypeClassProvider);\n-      expectToBe(compilerCore.NodeFlags.TypeFactoryProvider, core.ɵNodeFlags.TypeFactoryProvider);\n-      expectToBe(\n-          compilerCore.NodeFlags.TypeUseExistingProvider, core.ɵNodeFlags.TypeUseExistingProvider);\n-      expectToBe(compilerCore.NodeFlags.LazyProvider, core.ɵNodeFlags.LazyProvider);\n-      expectToBe(compilerCore.NodeFlags.PrivateProvider, core.ɵNodeFlags.PrivateProvider);\n-      expectToBe(compilerCore.NodeFlags.TypeDirective, core.ɵNodeFlags.TypeDirective);\n-      expectToBe(compilerCore.NodeFlags.Component, core.ɵNodeFlags.Component);\n-      expectToBe(\n-          compilerCore.NodeFlags.CatProviderNoDirective, core.ɵNodeFlags.CatProviderNoDirective);\n-      expectToBe(compilerCore.NodeFlags.CatProvider, core.ɵNodeFlags.CatProvider);\n-      expectToBe(compilerCore.NodeFlags.OnInit, core.ɵNodeFlags.OnInit);\n-      expectToBe(compilerCore.NodeFlags.OnDestroy, core.ɵNodeFlags.OnDestroy);\n-      expectToBe(compilerCore.NodeFlags.DoCheck, core.ɵNodeFlags.DoCheck);\n-      expectToBe(compilerCore.NodeFlags.OnChanges, core.ɵNodeFlags.OnChanges);\n-      expectToBe(compilerCore.NodeFlags.AfterContentInit, core.ɵNodeFlags.AfterContentInit);\n-      expectToBe(compilerCore.NodeFlags.AfterContentChecked, core.ɵNodeFlags.AfterContentChecked);\n-      expectToBe(compilerCore.NodeFlags.AfterViewInit, core.ɵNodeFlags.AfterViewInit);\n-      expectToBe(compilerCore.NodeFlags.AfterViewChecked, core.ɵNodeFlags.AfterViewChecked);\n-      expectToBe(compilerCore.NodeFlags.EmbeddedViews, core.ɵNodeFlags.EmbeddedViews);\n-      expectToBe(compilerCore.NodeFlags.ComponentView, core.ɵNodeFlags.ComponentView);\n-      expectToBe(compilerCore.NodeFlags.TypeContentQuery, core.ɵNodeFlags.TypeContentQuery);\n-      expectToBe(compilerCore.NodeFlags.TypeViewQuery, core.ɵNodeFlags.TypeViewQuery);\n-      expectToBe(compilerCore.NodeFlags.StaticQuery, core.ɵNodeFlags.StaticQuery);\n-      expectToBe(compilerCore.NodeFlags.DynamicQuery, core.ɵNodeFlags.DynamicQuery);\n-      expectToBe(compilerCore.NodeFlags.CatQuery, core.ɵNodeFlags.CatQuery);\n-      expectToBe(compilerCore.NodeFlags.Types, core.ɵNodeFlags.Types);\n-\n-      expectToBe(compilerCore.DepFlags.None, core.ɵDepFlags.None);\n-      expectToBe(compilerCore.DepFlags.SkipSelf, core.ɵDepFlags.SkipSelf);\n-      expectToBe(compilerCore.DepFlags.Optional, core.ɵDepFlags.Optional);\n-      expectToBe(compilerCore.DepFlags.Value, core.ɵDepFlags.Value);\n-\n-      expectToBe(compilerCore.InjectFlags.Default, core.InjectFlags.Default);\n-      expectToBe(compilerCore.InjectFlags.SkipSelf, core.InjectFlags.SkipSelf);\n-      expectToBe(compilerCore.InjectFlags.Self, core.InjectFlags.Self);\n-      expectToBe(compilerCore.InjectFlags.Host, core.InjectFlags.Host);\n-      expectToBe(compilerCore.InjectFlags.Optional, core.InjectFlags.Optional);\n-\n-      expectToBe(compilerCore.ArgumentType.Inline, core.ɵArgumentType.Inline);\n-      expectToBe(compilerCore.ArgumentType.Dynamic, core.ɵArgumentType.Dynamic);\n-\n-      expectToBe(\n-          compilerCore.BindingFlags.TypeElementAttribute, core.ɵBindingFlags.TypeElementAttribute);\n-      expectToBe(compilerCore.BindingFlags.TypeElementClass, core.ɵBindingFlags.TypeElementClass);\n-      expectToBe(compilerCore.BindingFlags.TypeElementStyle, core.ɵBindingFlags.TypeElementStyle);\n-      expectToBe(compilerCore.BindingFlags.TypeProperty, core.ɵBindingFlags.TypeProperty);\n-      expectToBe(compilerCore.BindingFlags.SyntheticProperty, core.ɵBindingFlags.SyntheticProperty);\n-      expectToBe(\n-          compilerCore.BindingFlags.SyntheticHostProperty,\n-          core.ɵBindingFlags.SyntheticHostProperty);\n-      expectToBe(\n-          compilerCore.BindingFlags.CatSyntheticProperty, core.ɵBindingFlags.CatSyntheticProperty);\n-      expectToBe(compilerCore.BindingFlags.Types, core.ɵBindingFlags.Types);\n-\n-      expectToBe(compilerCore.QueryBindingType.First, core.ɵQueryBindingType.First);\n-      expectToBe(compilerCore.QueryBindingType.All, core.ɵQueryBindingType.All);\n-\n-      expectToBe(compilerCore.QueryValueType.ElementRef, core.ɵQueryValueType.ElementRef);\n-      expectToBe(compilerCore.QueryValueType.RenderElement, core.ɵQueryValueType.RenderElement);\n-      expectToBe(compilerCore.QueryValueType.TemplateRef, core.ɵQueryValueType.TemplateRef);\n-      expectToBe(\n-          compilerCore.QueryValueType.ViewContainerRef, core.ɵQueryValueType.ViewContainerRef);\n-      expectToBe(compilerCore.QueryValueType.Provider, core.ɵQueryValueType.Provider);\n-\n-      expectToBe(compilerCore.ViewFlags.None, core.ɵViewFlags.None);\n-      expectToBe(compilerCore.ViewFlags.OnPush, core.ɵViewFlags.OnPush);\n-    });\n-  });\n-}\n-\n-function compareRuntimeShape(a: any, b: any) {\n-  const keys = metadataKeys(a);\n-  expect(keys).toEqual(metadataKeys(b));\n-  keys.forEach(key => {\n-    expect(a[key]).toBe(b[key]);\n-  });\n-  // Need to check 'ngMetadataName' separately, as this is\n-  // on the prototype in @angular/core, but a regular property in @angular/compiler.\n-  expect(a.ngMetadataName).toBe(b.ngMetadataName);\n-}\n-\n-function metadataKeys(a: any): string[] {\n-  return Object.keys(a).filter(prop => prop !== 'ngMetadataName' && !prop.startsWith('_')).sort();\n-}\n-\n-function typeExtends<T1 extends T2, T2>() {}"
        },
        {
            "sha": "7815f79419ea987c508c3019c08d8fae8ef9fdc4",
            "filename": "packages/compiler/test/directive_lifecycle_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 141,
            "changes": 141,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fdirective_lifecycle_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fdirective_lifecycle_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fdirective_lifecycle_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,141 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {hasLifecycleHook as hasLifecycleHookImpl, LifecycleHooks as Hooks} from '@angular/compiler/src/lifecycle_reflector';\n-import {SimpleChanges} from '@angular/core';\n-import {JitReflector} from '@angular/platform-browser-dynamic/src/compiler_reflector';\n-\n-function hasLifecycleHook(hook: Hooks, directive: any): boolean {\n-  return hasLifecycleHookImpl(new JitReflector(), hook, directive);\n-}\n-\n-{\n-  describe('Create Directive', () => {\n-    describe('lifecycle', () => {\n-      describe('ngOnChanges', () => {\n-        it('should be true when the directive has the ngOnChanges method', () => {\n-          expect(hasLifecycleHook(Hooks.OnChanges, DirectiveWithOnChangesMethod)).toBe(true);\n-        });\n-\n-        it('should be false otherwise', () => {\n-          expect(hasLifecycleHook(Hooks.OnChanges, DirectiveNoHooks)).toBe(false);\n-        });\n-      });\n-\n-      describe('ngOnDestroy', () => {\n-        it('should be true when the directive has the ngOnDestroy method', () => {\n-          expect(hasLifecycleHook(Hooks.OnDestroy, DirectiveWithOnDestroyMethod)).toBe(true);\n-        });\n-\n-        it('should be false otherwise', () => {\n-          expect(hasLifecycleHook(Hooks.OnDestroy, DirectiveNoHooks)).toBe(false);\n-        });\n-      });\n-\n-      describe('ngOnInit', () => {\n-        it('should be true when the directive has the ngOnInit method', () => {\n-          expect(hasLifecycleHook(Hooks.OnInit, DirectiveWithOnInitMethod)).toBe(true);\n-        });\n-\n-        it('should be false otherwise', () => {\n-          expect(hasLifecycleHook(Hooks.OnInit, DirectiveNoHooks)).toBe(false);\n-        });\n-      });\n-\n-      describe('ngDoCheck', () => {\n-        it('should be true when the directive has the ngDoCheck method', () => {\n-          expect(hasLifecycleHook(Hooks.DoCheck, DirectiveWithOnCheckMethod)).toBe(true);\n-        });\n-\n-        it('should be false otherwise', () => {\n-          expect(hasLifecycleHook(Hooks.DoCheck, DirectiveNoHooks)).toBe(false);\n-        });\n-      });\n-\n-      describe('ngAfterContentInit', () => {\n-        it('should be true when the directive has the ngAfterContentInit method', () => {\n-          expect(hasLifecycleHook(Hooks.AfterContentInit, DirectiveWithAfterContentInitMethod))\n-              .toBe(true);\n-        });\n-\n-        it('should be false otherwise', () => {\n-          expect(hasLifecycleHook(Hooks.AfterContentInit, DirectiveNoHooks)).toBe(false);\n-        });\n-      });\n-\n-      describe('ngAfterContentChecked', () => {\n-        it('should be true when the directive has the ngAfterContentChecked method', () => {\n-          expect(\n-              hasLifecycleHook(Hooks.AfterContentChecked, DirectiveWithAfterContentCheckedMethod))\n-              .toBe(true);\n-        });\n-\n-        it('should be false otherwise', () => {\n-          expect(hasLifecycleHook(Hooks.AfterContentChecked, DirectiveNoHooks)).toBe(false);\n-        });\n-      });\n-\n-\n-      describe('ngAfterViewInit', () => {\n-        it('should be true when the directive has the ngAfterViewInit method', () => {\n-          expect(hasLifecycleHook(Hooks.AfterViewInit, DirectiveWithAfterViewInitMethod))\n-              .toBe(true);\n-        });\n-\n-        it('should be false otherwise', () => {\n-          expect(hasLifecycleHook(Hooks.AfterViewInit, DirectiveNoHooks)).toBe(false);\n-        });\n-      });\n-\n-      describe('ngAfterViewChecked', () => {\n-        it('should be true when the directive has the ngAfterViewChecked method', () => {\n-          expect(hasLifecycleHook(Hooks.AfterViewChecked, DirectiveWithAfterViewCheckedMethod))\n-              .toBe(true);\n-        });\n-\n-        it('should be false otherwise', () => {\n-          expect(hasLifecycleHook(Hooks.AfterViewChecked, DirectiveNoHooks)).toBe(false);\n-        });\n-      });\n-    });\n-  });\n-}\n-\n-class DirectiveNoHooks {}\n-\n-class DirectiveWithOnChangesMethod {\n-  ngOnChanges(_: SimpleChanges) {}\n-}\n-\n-class DirectiveWithOnInitMethod {\n-  ngOnInit() {}\n-}\n-\n-class DirectiveWithOnCheckMethod {\n-  ngDoCheck() {}\n-}\n-\n-class DirectiveWithOnDestroyMethod {\n-  ngOnDestroy() {}\n-}\n-\n-class DirectiveWithAfterContentInitMethod {\n-  ngAfterContentInit() {}\n-}\n-\n-class DirectiveWithAfterContentCheckedMethod {\n-  ngAfterContentChecked() {}\n-}\n-\n-class DirectiveWithAfterViewInitMethod {\n-  ngAfterViewInit() {}\n-}\n-\n-class DirectiveWithAfterViewCheckedMethod {\n-  ngAfterViewChecked() {}\n-}"
        },
        {
            "sha": "94df9dcdb658f9d30fe4d6dfc5a8c356b0e434bc",
            "filename": "packages/compiler/test/directive_normalizer_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 403,
            "changes": 403,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fdirective_normalizer_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fdirective_normalizer_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fdirective_normalizer_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,403 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import {CompileStylesheetMetadata, CompileTemplateMetadata} from '@angular/compiler/src/compile_metadata';\n-import {CompilerConfig, preserveWhitespacesDefault} from '@angular/compiler/src/config';\n-import {DirectiveNormalizer} from '@angular/compiler/src/directive_normalizer';\n-import {ResourceLoader} from '@angular/compiler/src/resource_loader';\n-import {ViewEncapsulation} from '@angular/core/src/metadata/view';\n-import {inject, TestBed} from '@angular/core/testing';\n-\n-import {noUndefined} from '../src/util';\n-\n-import {TEST_COMPILER_PROVIDERS} from './test_bindings';\n-\n-const SOME_MODULE_URL = 'package:some/module/a.js';\n-const SOME_HTTP_MODULE_URL = 'http://some/module/a.js';\n-\n-function normalizeTemplate(normalizer: DirectiveNormalizer, o: {\n-  moduleUrl?: string;\n-  template?: string | null;\n-  templateUrl?: string | null;\n-  styles?: string[];\n-  styleUrls?: string[];\n-  interpolation?: [string, string] | null;\n-  encapsulation?: ViewEncapsulation | null;\n-  animations?: any[];\n-  preserveWhitespaces?: boolean | null;\n-}) {\n-  return normalizer.normalizeTemplate({\n-    ngModuleType: null,\n-    componentType: SomeComp,\n-    moduleUrl: noUndefined(o.moduleUrl || SOME_MODULE_URL),\n-    template: noUndefined(o.template),\n-    templateUrl: noUndefined(o.templateUrl),\n-    styles: noUndefined(o.styles),\n-    styleUrls: noUndefined(o.styleUrls),\n-    interpolation: noUndefined(o.interpolation),\n-    encapsulation: noUndefined(o.encapsulation),\n-    animations: noUndefined(o.animations),\n-    preserveWhitespaces: noUndefined(o.preserveWhitespaces),\n-  });\n-}\n-\n-{\n-  describe('DirectiveNormalizer', () => {\n-    let resourceLoaderSpy: jasmine.Spy;\n-\n-    beforeEach(() => {\n-      resourceLoaderSpy =\n-          jasmine.createSpy('get').and.callFake((url: string) => `resource(${url})`);\n-      const resourceLoader = {get: resourceLoaderSpy};\n-      TestBed.configureCompiler({\n-        providers: [...TEST_COMPILER_PROVIDERS, {provide: ResourceLoader, useValue: resourceLoader}]\n-      });\n-    });\n-\n-    describe('normalizeTemplate', () => {\n-      it('should throw if no template was specified',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           expect(() => normalizeTemplate(normalizer, {}))\n-               .toThrowError('No template specified for component SomeComp');\n-         }));\n-      it('should throw if template is not a string',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           expect(() => normalizeTemplate(normalizer, {template: <any> {}}))\n-               .toThrowError('The template specified for component SomeComp is not a string');\n-         }));\n-      it('should throw if templateUrl is not a string',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           expect(() => normalizeTemplate(normalizer, {templateUrl: <any> {}}))\n-               .toThrowError('The templateUrl specified for component SomeComp is not a string');\n-         }));\n-      it('should throw if both template and templateUrl are defined',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           expect(() => normalizeTemplate(normalizer, {\n-                    template: '',\n-                    templateUrl: '',\n-                  }))\n-               .toThrowError(`'SomeComp' component cannot define both template and templateUrl`);\n-         }));\n-      it('should throw if preserveWhitespaces is not a boolean',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           expect(() => normalizeTemplate(normalizer, {\n-                    template: '',\n-                    preserveWhitespaces: <any>'WRONG',\n-                  }))\n-               .toThrowError(\n-                   'The preserveWhitespaces option for component SomeComp must be a boolean');\n-         }));\n-    });\n-\n-    describe('inline template', () => {\n-      it('should store the template',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             template: 'a',\n-           });\n-           expect(template.template).toEqual('a');\n-           expect(template.templateUrl).toEqual('package:some/module/a.js');\n-           expect(template.isInline).toBe(true);\n-         }));\n-\n-      it('should resolve styles on the annotation against the moduleUrl',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(\n-               normalizer, {template: '', styleUrls: ['test.css']});\n-           expect(template.styleUrls).toEqual(['package:some/module/test.css']);\n-         }));\n-\n-      it('should resolve styles in the template against the moduleUrl and add them to the styles',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             template: '<style>template @import test.css</style>',\n-             styles: ['direct'],\n-           });\n-           expect(template.styles).toEqual([\n-             'direct', 'template ', 'resource(package:some/module/test.css)'\n-           ]);\n-         }));\n-\n-      it('should use ViewEncapsulation.Emulated by default',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(\n-               normalizer, {template: '', styleUrls: ['test.css']});\n-           expect(template.encapsulation).toEqual(ViewEncapsulation.Emulated);\n-         }));\n-\n-      it('should use default encapsulation provided by CompilerConfig',\n-         inject(\n-             [CompilerConfig, DirectiveNormalizer],\n-             (config: CompilerConfig, normalizer: DirectiveNormalizer) => {\n-               config.defaultEncapsulation = ViewEncapsulation.None;\n-               const template = <CompileTemplateMetadata>normalizeTemplate(\n-                   normalizer, {template: '', styleUrls: ['test.css']});\n-               expect(template.encapsulation).toEqual(ViewEncapsulation.None);\n-             }));\n-    });\n-\n-    it('should load a template from a url that is resolved against moduleUrl',\n-       inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-         const template = <CompileTemplateMetadata>normalizeTemplate(\n-             normalizer, {templateUrl: 'sometplurl.html', styleUrls: ['test.css']});\n-         expect(template.template).toEqual('resource(package:some/module/sometplurl.html)');\n-         expect(template.templateUrl).toEqual('package:some/module/sometplurl.html');\n-         expect(template.isInline).toBe(false);\n-       }));\n-\n-    it('should resolve styles on the annotation against the moduleUrl',\n-       inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-         const template = <CompileTemplateMetadata>normalizeTemplate(\n-             normalizer, {templateUrl: 'tpl/sometplurl.html', styleUrls: ['test.css']});\n-         expect(template.styleUrls).toEqual(['package:some/module/test.css']);\n-       }));\n-\n-    it('should resolve styles in the template against the templateUrl and add them to the styles',\n-       inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-         resourceLoaderSpy.and.callFake((url: string) => {\n-           switch (url) {\n-             case 'package:some/module/tpl/sometplurl.html':\n-               return '<style>template @import test.css</style>';\n-             default:\n-               return `resource(${url})`;\n-           }\n-         });\n-         const template = <CompileTemplateMetadata>normalizeTemplate(\n-             normalizer, {templateUrl: 'tpl/sometplurl.html', styles: ['direct']});\n-         expect(template.styles).toEqual([\n-           'direct', 'template ', 'resource(package:some/module/tpl/test.css)'\n-         ]);\n-       }));\n-\n-    describe('externalStylesheets', () => {\n-      it('should load an external stylesheet',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(\n-               normalizer, {template: '', styleUrls: ['package:some/module/test.css']});\n-           expect(template.externalStylesheets.length).toBe(1);\n-           expect(template.externalStylesheets[0]).toEqual(new CompileStylesheetMetadata({\n-             moduleUrl: 'package:some/module/test.css',\n-             styles: ['resource(package:some/module/test.css)'],\n-           }));\n-         }));\n-\n-      it('should load stylesheets referenced by external stylesheets and inline them',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           resourceLoaderSpy.and.callFake((url: string) => {\n-             switch (url) {\n-               case 'package:some/module/test.css':\n-                 return 'a@import \"test2.css\"';\n-               case 'package:some/module/test2.css':\n-                 return 'b';\n-               default:\n-                 throw new Error(`Unexpected url ${url}`);\n-             }\n-           });\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             template: '',\n-             styleUrls: ['package:some/module/test.css'],\n-           });\n-           expect(template.externalStylesheets.length).toBe(1);\n-           expect(template.externalStylesheets[0])\n-               .toEqual(new CompileStylesheetMetadata(\n-                   {moduleUrl: 'package:some/module/test.css', styles: ['a', 'b'], styleUrls: []}));\n-         }));\n-    });\n-\n-    describe('caching', () => {\n-      it('should work for templateUrl',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const prenormMeta = {\n-             templateUrl: 'cmp.html',\n-           };\n-           const template1 = <CompileTemplateMetadata>normalizeTemplate(normalizer, prenormMeta);\n-           const template2 = <CompileTemplateMetadata>normalizeTemplate(normalizer, prenormMeta);\n-           expect(template1.template).toEqual('resource(package:some/module/cmp.html)');\n-           expect(template2.template).toEqual('resource(package:some/module/cmp.html)');\n-\n-           expect(resourceLoaderSpy).toHaveBeenCalledTimes(1);\n-         }));\n-    });\n-\n-    describe('normalizeLoadedTemplate', () => {\n-      it('should store the viewEncapsulation in the result',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const viewEncapsulation = ViewEncapsulation.ShadowDom;\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             encapsulation: viewEncapsulation,\n-             template: '',\n-           });\n-           expect(template.encapsulation).toBe(viewEncapsulation);\n-         }));\n-\n-      it('should use preserveWhitespaces setting from compiler config if none provided',\n-         inject(\n-             [DirectiveNormalizer, CompilerConfig],\n-             (normalizer: DirectiveNormalizer, config: CompilerConfig) => {\n-               const template =\n-                   <CompileTemplateMetadata>normalizeTemplate(normalizer, {template: ''});\n-               expect(template.preserveWhitespaces).toBe(config.preserveWhitespaces);\n-             }));\n-\n-      it('should store the preserveWhitespaces=false in the result',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(\n-               normalizer, {preserveWhitespaces: false, template: ''});\n-           expect(template.preserveWhitespaces).toBe(false);\n-         }));\n-\n-      it('should store the preserveWhitespaces=true in the result',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(\n-               normalizer, {preserveWhitespaces: true, template: ''});\n-           expect(template.preserveWhitespaces).toBe(true);\n-         }));\n-\n-      it('should keep the template as html',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             template: 'a',\n-           });\n-           expect(template.template).toEqual('a');\n-         }));\n-\n-      it('should collect ngContent',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             template: '<ng-content select=\"a\"></ng-content>',\n-           });\n-           expect(template.ngContentSelectors).toEqual(['a']);\n-         }));\n-\n-      it('should normalize ngContent wildcard selector',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             template:\n-                 '<ng-content></ng-content><ng-content select></ng-content><ng-content select=\"*\"></ng-content>',\n-           });\n-           expect(template.ngContentSelectors).toEqual(['*', '*', '*']);\n-         }));\n-\n-      it('should collect top level styles in the template',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             template: '<style>a</style>',\n-           });\n-           expect(template.styles).toEqual(['a']);\n-         }));\n-\n-      it('should collect styles inside elements',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             template: '<div><style>a</style></div>',\n-           });\n-           expect(template.styles).toEqual(['a']);\n-         }));\n-\n-      it('should collect styleUrls in the template and add them to the styles',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             template: '<link rel=\"stylesheet\" href=\"aUrl\">',\n-           });\n-           expect(template.styles).toEqual(['resource(package:some/module/aUrl)']);\n-           expect(template.styleUrls).toEqual([]);\n-         }));\n-\n-      it('should collect styleUrls in elements and add them to the styles',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             template: '<div><link rel=\"stylesheet\" href=\"aUrl\"></div>',\n-           });\n-           expect(template.styles).toEqual(['resource(package:some/module/aUrl)']);\n-           expect(template.styleUrls).toEqual([]);\n-         }));\n-\n-      it('should ignore link elements with non stylesheet rel attribute',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             template: '<link href=\"b\" rel=\"a\">',\n-           });\n-           expect(template.styleUrls).toEqual([]);\n-         }));\n-\n-      it('should ignore link elements with absolute urls but non package: scheme',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             template: '<link href=\"http://some/external.css\" rel=\"stylesheet\">',\n-           });\n-           expect(template.styleUrls).toEqual([]);\n-         }));\n-\n-      it('should extract @import style urls and add them to the styles',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             styles: ['@import \"test.css\";'],\n-             template: '',\n-           });\n-           expect(template.styles).toEqual(['', 'resource(package:some/module/test.css)']);\n-           expect(template.styleUrls).toEqual([]);\n-         }));\n-\n-      it('should not resolve relative urls in inline styles',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             styles: ['.foo{background-image: url(\\'double.jpg\\');'],\n-             template: '',\n-           });\n-           expect(template.styles).toEqual(['.foo{background-image: url(\\'double.jpg\\');']);\n-         }));\n-\n-      it('should resolve relative style urls in styleUrls',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             styleUrls: ['test.css'],\n-             template: '',\n-           });\n-           expect(template.styles).toEqual([]);\n-           expect(template.styleUrls).toEqual(['package:some/module/test.css']);\n-         }));\n-\n-      it('should resolve relative style urls in styleUrls with http directive url',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             moduleUrl: SOME_HTTP_MODULE_URL,\n-             styleUrls: ['test.css'],\n-             template: '',\n-           });\n-           expect(template.styles).toEqual([]);\n-           expect(template.styleUrls).toEqual(['http://some/module/test.css']);\n-         }));\n-\n-      it('should normalize ViewEncapsulation.Emulated to ViewEncapsulation.None if there are no styles nor stylesheets',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             encapsulation: ViewEncapsulation.Emulated,\n-             template: '',\n-           });\n-           expect(template.encapsulation).toEqual(ViewEncapsulation.None);\n-         }));\n-\n-      it('should ignore ng-content in elements with ngNonBindable',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             template: '<div ngNonBindable><ng-content select=\"a\"></ng-content></div>',\n-           });\n-           expect(template.ngContentSelectors).toEqual([]);\n-         }));\n-\n-      it('should still collect <style> in elements with ngNonBindable',\n-         inject([DirectiveNormalizer], (normalizer: DirectiveNormalizer) => {\n-           const template = <CompileTemplateMetadata>normalizeTemplate(normalizer, {\n-             template: '<div ngNonBindable><style>div {color:red}</style></div>',\n-           });\n-           expect(template.styles).toEqual(['div {color:red}']);\n-         }));\n-    });\n-  });\n-}\n-\n-class SomeComp {}"
        },
        {
            "sha": "bbf5281aefd5a6793e59a724386c60f39509c316",
            "filename": "packages/compiler/test/directive_resolver_mock_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 54,
            "changes": 54,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fdirective_resolver_mock_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fdirective_resolver_mock_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fdirective_resolver_mock_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,54 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Component, Directive, Injector} from '@angular/core';\n-import {inject, TestBed} from '@angular/core/testing';\n-import {JitReflector} from '@angular/platform-browser-dynamic/src/compiler_reflector';\n-\n-import {MockDirectiveResolver} from '../testing';\n-\n-{\n-  describe('MockDirectiveResolver', () => {\n-    let dirResolver: MockDirectiveResolver;\n-\n-    beforeEach(() => {\n-      TestBed.configureTestingModule(\n-          {declarations: [SomeDirective, SomeOtherDirective, SomeComponent]});\n-    });\n-\n-    beforeEach(inject([Injector], (injector: Injector) => {\n-      dirResolver = new MockDirectiveResolver(new JitReflector());\n-    }));\n-\n-    describe('Directive overriding', () => {\n-      it('should fallback to the default DirectiveResolver when templates are not overridden',\n-         () => {\n-           const ngModule = dirResolver.resolve(SomeComponent);\n-           expect(ngModule.selector).toEqual('cmp');\n-         });\n-\n-      it('should allow overriding the @Directive', () => {\n-        dirResolver.setDirective(SomeComponent, new Component({selector: 'someOtherSelector'}));\n-        const metadata = dirResolver.resolve(SomeComponent);\n-        expect(metadata.selector).toEqual('someOtherSelector');\n-      });\n-    });\n-  });\n-}\n-\n-@Directive({selector: 'some-directive'})\n-class SomeDirective {\n-}\n-\n-@Component({selector: 'cmp', template: 'template'})\n-class SomeComponent {\n-}\n-\n-@Directive({selector: 'some-other-directive'})\n-class SomeOtherDirective {\n-}"
        },
        {
            "sha": "e2fcabb5578e3134fa90560570672b92f26137bb",
            "filename": "packages/compiler/test/directive_resolver_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 451,
            "changes": 451,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fdirective_resolver_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fdirective_resolver_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fdirective_resolver_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,451 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {core} from '@angular/compiler';\n-import {DirectiveResolver} from '@angular/compiler/src/directive_resolver';\n-import {Component, ContentChild, ContentChildren, Directive, HostBinding, HostListener, Input, Output, ViewChild, ViewChildren} from '@angular/core/src/metadata';\n-import {JitReflector} from '@angular/platform-browser-dynamic/src/compiler_reflector';\n-\n-@Directive({selector: 'someDirective'})\n-class SomeDirective {\n-}\n-\n-@Directive({selector: 'someDirective', inputs: ['c']})\n-class SomeDirectiveWithInputs {\n-  @Input() a: any;\n-  @Input('renamed') b: any;\n-  c: any;\n-}\n-\n-@Directive({selector: 'someDirective', outputs: ['c']})\n-class SomeDirectiveWithOutputs {\n-  @Output() a: any;\n-  @Output('renamed') b: any;\n-  c: any;\n-}\n-\n-@Directive({selector: 'someDirective'})\n-class SomeDirectiveWithSetterProps {\n-  @Input('renamed')\n-  set a(value: any) {\n-  }\n-}\n-\n-@Directive({selector: 'someDirective'})\n-class SomeDirectiveWithGetterOutputs {\n-  @Output('renamed')\n-  get a(): any {\n-    return null;\n-  }\n-}\n-\n-@Directive({selector: 'someDirective', host: {'[c]': 'c'}})\n-class SomeDirectiveWithHostBindings {\n-  @HostBinding() a: any;\n-  @HostBinding('renamed') b: any;\n-  c: any;\n-}\n-\n-@Directive({selector: 'someDirective', host: {'(c)': 'onC()'}})\n-class SomeDirectiveWithHostListeners {\n-  @HostListener('a')\n-  onA() {\n-  }\n-  @HostListener('b', ['$event.value'])\n-  onB(value: any) {\n-  }\n-}\n-\n-@Directive({selector: 'someDirective', queries: {'cs': new ContentChildren('c')}})\n-class SomeDirectiveWithContentChildren {\n-  @ContentChildren('a') as: any;\n-  c: any;\n-}\n-\n-@Directive({selector: 'someDirective', queries: {'cs': new ViewChildren('c')}})\n-class SomeDirectiveWithViewChildren {\n-  @ViewChildren('a') as: any;\n-  c: any;\n-}\n-\n-@Directive({selector: 'someDirective', queries: {'c': new ContentChild('c')}})\n-class SomeDirectiveWithContentChild {\n-  @ContentChild('a') a: any;\n-  c: any;\n-}\n-\n-@Directive({selector: 'someDirective', queries: {'c': new ViewChild('c')}})\n-class SomeDirectiveWithViewChild {\n-  @ViewChild('a') a: any;\n-  c: any;\n-}\n-\n-@Component({\n-  selector: 'sample',\n-  template: 'some template',\n-  styles: ['some styles'],\n-  preserveWhitespaces: true\n-})\n-class ComponentWithTemplate {\n-}\n-\n-@Directive({\n-  selector: 'someDirective',\n-  host: {'[decorator]': 'decorator'},\n-  inputs: ['decorator'],\n-})\n-class SomeDirectiveWithSameHostBindingAndInput {\n-  @Input() @HostBinding() prop: any;\n-}\n-\n-@Directive({selector: 'someDirective'})\n-class SomeDirectiveWithMalformedHostBinding1 {\n-  @HostBinding('(a)')\n-  onA() {\n-  }\n-}\n-\n-@Directive({selector: 'someDirective'})\n-class SomeDirectiveWithMalformedHostBinding2 {\n-  @HostBinding('[a]')\n-  onA() {\n-  }\n-}\n-\n-class SomeDirectiveWithoutMetadata {}\n-\n-{\n-  describe('DirectiveResolver', () => {\n-    let resolver: DirectiveResolver;\n-\n-    beforeEach(() => {\n-      resolver = new DirectiveResolver(new JitReflector());\n-    });\n-\n-    it('should read out the Directive metadata', () => {\n-      const directiveMetadata = resolver.resolve(SomeDirective);\n-      expect(directiveMetadata).toEqual(core.createDirective({\n-        selector: 'someDirective',\n-        inputs: [],\n-        outputs: [],\n-        host: {},\n-        queries: {},\n-        guards: {},\n-        exportAs: undefined,\n-        providers: undefined\n-      }));\n-    });\n-\n-    it('should throw if not matching metadata is found', () => {\n-      expect(() => {\n-        resolver.resolve(SomeDirectiveWithoutMetadata);\n-      }).toThrowError('No Directive annotation found on SomeDirectiveWithoutMetadata');\n-    });\n-\n-    it('should support inheriting the Directive metadata', function() {\n-      @Directive({selector: 'p'})\n-      class Parent {\n-      }\n-\n-      class ChildNoDecorator extends Parent {}\n-\n-      @Directive({selector: 'c'})\n-      class ChildWithDecorator extends Parent {\n-      }\n-\n-      expect(resolver.resolve(ChildNoDecorator)).toEqual(core.createDirective({\n-        selector: 'p',\n-        inputs: [],\n-        outputs: [],\n-        host: {},\n-        queries: {},\n-        guards: {},\n-        exportAs: undefined,\n-        providers: undefined\n-      }));\n-\n-      expect(resolver.resolve(ChildWithDecorator)).toEqual(core.createDirective({\n-        selector: 'c',\n-        inputs: [],\n-        outputs: [],\n-        host: {},\n-        queries: {},\n-        guards: {},\n-        exportAs: undefined,\n-        providers: undefined\n-      }));\n-    });\n-\n-    describe('inputs', () => {\n-      it('should append directive inputs', () => {\n-        const directiveMetadata = resolver.resolve(SomeDirectiveWithInputs);\n-        expect(directiveMetadata.inputs).toEqual(['c', 'a', 'b: renamed']);\n-      });\n-\n-      it('should work with getters and setters', () => {\n-        const directiveMetadata = resolver.resolve(SomeDirectiveWithSetterProps);\n-        expect(directiveMetadata.inputs).toEqual(['a: renamed']);\n-      });\n-\n-      it('should remove duplicate inputs', () => {\n-        @Directive({selector: 'someDirective', inputs: ['a', 'a']})\n-        class SomeDirectiveWithDuplicateInputs {\n-        }\n-\n-        const directiveMetadata = resolver.resolve(SomeDirectiveWithDuplicateInputs);\n-        expect(directiveMetadata.inputs).toEqual(['a']);\n-      });\n-\n-      it('should use the last input if duplicate inputs (with rename)', () => {\n-        @Directive({selector: 'someDirective', inputs: ['a', 'localA: a']})\n-        class SomeDirectiveWithDuplicateInputs {\n-        }\n-\n-        const directiveMetadata = resolver.resolve(SomeDirectiveWithDuplicateInputs);\n-        expect(directiveMetadata.inputs).toEqual(['localA: a']);\n-      });\n-\n-      it('should prefer @Input over @Directive.inputs', () => {\n-        @Directive({selector: 'someDirective', inputs: ['a']})\n-        class SomeDirectiveWithDuplicateInputs {\n-          @Input('a') propA: any;\n-        }\n-        const directiveMetadata = resolver.resolve(SomeDirectiveWithDuplicateInputs);\n-        expect(directiveMetadata.inputs).toEqual(['propA: a']);\n-      });\n-\n-      it('should support inheriting inputs', () => {\n-        @Directive({selector: 'p'})\n-        class Parent {\n-          @Input() p1: any;\n-          @Input('p21') p2: any;\n-        }\n-\n-        class Child extends Parent {\n-          @Input('p22') override p2: any;\n-          @Input() p3: any;\n-        }\n-\n-        const directiveMetadata = resolver.resolve(Child);\n-        expect(directiveMetadata.inputs).toEqual(['p1', 'p2: p22', 'p3']);\n-      });\n-    });\n-\n-    describe('outputs', () => {\n-      it('should append directive outputs', () => {\n-        const directiveMetadata = resolver.resolve(SomeDirectiveWithOutputs);\n-        expect(directiveMetadata.outputs).toEqual(['c', 'a', 'b: renamed']);\n-      });\n-\n-      it('should work with getters and setters', () => {\n-        const directiveMetadata = resolver.resolve(SomeDirectiveWithGetterOutputs);\n-        expect(directiveMetadata.outputs).toEqual(['a: renamed']);\n-      });\n-\n-      it('should remove duplicate outputs', () => {\n-        @Directive({selector: 'someDirective', outputs: ['a', 'a']})\n-        class SomeDirectiveWithDuplicateOutputs {\n-        }\n-\n-        const directiveMetadata = resolver.resolve(SomeDirectiveWithDuplicateOutputs);\n-        expect(directiveMetadata.outputs).toEqual(['a']);\n-      });\n-\n-      it('should use the last output if duplicate outputs (with rename)', () => {\n-        @Directive({selector: 'someDirective', outputs: ['a', 'localA: a']})\n-        class SomeDirectiveWithDuplicateOutputs {\n-        }\n-\n-        const directiveMetadata = resolver.resolve(SomeDirectiveWithDuplicateOutputs);\n-        expect(directiveMetadata.outputs).toEqual(['localA: a']);\n-      });\n-\n-      it('should prefer @Output over @Directive.outputs', () => {\n-        @Directive({selector: 'someDirective', outputs: ['a']})\n-        class SomeDirectiveWithDuplicateOutputs {\n-          @Output('a') propA: any;\n-        }\n-        const directiveMetadata = resolver.resolve(SomeDirectiveWithDuplicateOutputs);\n-        expect(directiveMetadata.outputs).toEqual(['propA: a']);\n-      });\n-\n-      it('should support inheriting outputs', () => {\n-        @Directive({selector: 'p'})\n-        class Parent {\n-          @Output() p1: any;\n-          @Output('p21') p2: any;\n-        }\n-\n-        class Child extends Parent {\n-          @Output('p22') override p2: any;\n-          @Output() p3: any;\n-        }\n-\n-        const directiveMetadata = resolver.resolve(Child);\n-        expect(directiveMetadata.outputs).toEqual(['p1', 'p2: p22', 'p3']);\n-      });\n-    });\n-\n-    describe('host', () => {\n-      it('should append host bindings', () => {\n-        const directiveMetadata = resolver.resolve(SomeDirectiveWithHostBindings);\n-        expect(directiveMetadata.host).toEqual({'[c]': 'c', '[a]': 'a', '[renamed]': 'b'});\n-      });\n-\n-      it('should append host binding and input on the same property', () => {\n-        const directiveMetadata = resolver.resolve(SomeDirectiveWithSameHostBindingAndInput);\n-        expect(directiveMetadata.host).toEqual({'[decorator]': 'decorator', '[prop]': 'prop'});\n-        expect(directiveMetadata.inputs).toEqual(['decorator', 'prop']);\n-      });\n-\n-      it('should append host listeners', () => {\n-        const directiveMetadata = resolver.resolve(SomeDirectiveWithHostListeners);\n-        expect(directiveMetadata.host)\n-            .toEqual({'(c)': 'onC()', '(a)': 'onA()', '(b)': 'onB($event.value)'});\n-      });\n-\n-      it('should throw when @HostBinding name starts with \"(\"', () => {\n-        expect(() => resolver.resolve(SomeDirectiveWithMalformedHostBinding1))\n-            .toThrowError('@HostBinding can not bind to events. Use @HostListener instead.');\n-      });\n-\n-      it('should throw when @HostBinding name starts with \"[\"', () => {\n-        expect(() => resolver.resolve(SomeDirectiveWithMalformedHostBinding2))\n-            .toThrowError(\n-                `@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.`);\n-      });\n-\n-      it('should support inheriting host bindings', () => {\n-        @Directive({selector: 'p'})\n-        class Parent {\n-          @HostBinding() p1: any;\n-          @HostBinding('p21') p2: any;\n-        }\n-\n-        class Child extends Parent {\n-          @HostBinding('p22') override p2: any;\n-          @HostBinding() p3: any;\n-        }\n-\n-        const directiveMetadata = resolver.resolve(Child);\n-        expect(directiveMetadata.host)\n-            .toEqual({'[p1]': 'p1', '[p21]': 'p2', '[p22]': 'p2', '[p3]': 'p3'});\n-      });\n-\n-      it('should support inheriting host listeners', () => {\n-        @Directive({selector: 'p'})\n-        class Parent {\n-          @HostListener('p1')\n-          p1() {\n-          }\n-          @HostListener('p21')\n-          p2() {\n-          }\n-        }\n-\n-        class Child extends Parent {\n-          @HostListener('p22')\n-          override p2() {\n-          }\n-          @HostListener('p3')\n-          p3() {\n-          }\n-        }\n-\n-        const directiveMetadata = resolver.resolve(Child);\n-        expect(directiveMetadata.host)\n-            .toEqual({'(p1)': 'p1()', '(p21)': 'p2()', '(p22)': 'p2()', '(p3)': 'p3()'});\n-      });\n-\n-      it('should combine host bindings and listeners during inheritance', () => {\n-        @Directive({selector: 'p'})\n-        class Parent {\n-          @HostListener('p11')\n-          @HostListener('p12')\n-          p1() {\n-          }\n-\n-          @HostBinding('p21') @HostBinding('p22') p2: any;\n-        }\n-\n-        class Child extends Parent {\n-          @HostListener('c1')\n-          override p1() {\n-          }\n-\n-          @HostBinding('c2') override p2: any;\n-        }\n-\n-        const directiveMetadata = resolver.resolve(Child);\n-        expect(directiveMetadata.host).toEqual({\n-          '(p11)': 'p1()',\n-          '(p12)': 'p1()',\n-          '(c1)': 'p1()',\n-          '[p21]': 'p2',\n-          '[p22]': 'p2',\n-          '[c2]': 'p2'\n-        });\n-      });\n-    });\n-\n-    describe('queries', () => {\n-      it('should append ContentChildren', () => {\n-        const directiveMetadata = resolver.resolve(SomeDirectiveWithContentChildren);\n-        expect(directiveMetadata.queries)\n-            .toEqual({'cs': new ContentChildren('c'), 'as': new ContentChildren('a')});\n-      });\n-\n-      it('should append ViewChildren', () => {\n-        const directiveMetadata = resolver.resolve(SomeDirectiveWithViewChildren);\n-        expect(directiveMetadata.queries)\n-            .toEqual({'cs': new ViewChildren('c'), 'as': new ViewChildren('a')});\n-      });\n-\n-      it('should append ContentChild', () => {\n-        const directiveMetadata = resolver.resolve(SomeDirectiveWithContentChild);\n-        expect(directiveMetadata.queries)\n-            .toEqual({'c': new ContentChild('c'), 'a': new ContentChild('a')});\n-      });\n-\n-      it('should append ViewChild', () => {\n-        const directiveMetadata = resolver.resolve(SomeDirectiveWithViewChild);\n-        expect(directiveMetadata.queries)\n-            .toEqual({'c': new ViewChild('c'), 'a': new ViewChild('a')});\n-      });\n-\n-      it('should support inheriting queries', () => {\n-        @Directive({selector: 'p'})\n-        class Parent {\n-          @ContentChild('p1') p1: any;\n-          @ContentChild('p21') p2: any;\n-        }\n-\n-        class Child extends Parent {\n-          @ContentChild('p22') override p2: any;\n-          @ContentChild('p3') p3: any;\n-        }\n-\n-        const directiveMetadata = resolver.resolve(Child);\n-        expect(directiveMetadata.queries).toEqual({\n-          'p1': new ContentChild('p1'),\n-          'p2': new ContentChild('p22'),\n-          'p3': new ContentChild('p3')\n-        });\n-      });\n-    });\n-\n-    describe('Component', () => {\n-      it('should read out the template related metadata from the Component metadata', () => {\n-        const compMetadata: Component = resolver.resolve(ComponentWithTemplate);\n-        expect(compMetadata.template).toEqual('some template');\n-        expect(compMetadata.styles).toEqual(['some styles']);\n-        expect(compMetadata.preserveWhitespaces).toBe(true);\n-      });\n-    });\n-  });\n-}"
        },
        {
            "sha": "fa834c2f3f5a618b1316d5591152edd608c0166e",
            "filename": "packages/compiler/test/expression_parser/BUILD.bazel",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Fexpression_parser%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Fexpression_parser%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fexpression_parser%2FBUILD.bazel?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -8,7 +8,6 @@ ts_library(\n         \"//packages:types\",\n         \"//packages/compiler\",\n         \"//packages/compiler/test/expression_parser/utils\",\n-        \"//packages/compiler/testing\",\n         \"//packages/platform-browser/testing\",\n     ],\n )"
        },
        {
            "sha": "20fe282c0ecd2e1d00a58218a4d59044e9b8e9f3",
            "filename": "packages/compiler/test/i18n/integration_xliff2_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Fi18n%2Fintegration_xliff2_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Fi18n%2Fintegration_xliff2_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fi18n%2Fintegration_xliff2_spec.ts?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -12,7 +12,8 @@ import {expect} from '@angular/platform-browser/testing/src/matchers';\n \n import {configureCompiler, createComponent, HTML, serializeTranslations, validateHtml} from './integration_common';\n \n-describe('i18n XLIFF integration spec', () => {\n+// TODO(alxhub): figure out if this test is still relevant.\n+xdescribe('i18n XLIFF integration spec', () => {\n   describe('(with LF line endings)', () => {\n     beforeEach(waitForAsync(\n         () => configureCompiler(XLIFF2_TOMERGE + LF_LINE_ENDING_XLIFF2_TOMERGE, 'xlf2')));"
        },
        {
            "sha": "09d8c917ada0db025b18321a9ee42593ae1aebc8",
            "filename": "packages/compiler/test/i18n/integration_xliff_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Fi18n%2Fintegration_xliff_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Fi18n%2Fintegration_xliff_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fi18n%2Fintegration_xliff_spec.ts?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -12,7 +12,8 @@ import {expect} from '@angular/platform-browser/testing/src/matchers';\n \n import {configureCompiler, createComponent, HTML, serializeTranslations, validateHtml} from './integration_common';\n \n-describe('i18n XLIFF integration spec', () => {\n+// TODO(alxhub): figure out if this test is still relevant.\n+xdescribe('i18n XLIFF integration spec', () => {\n   describe('(with LF line endings)', () => {\n     beforeEach(\n         waitForAsync(() => configureCompiler(XLIFF_TOMERGE + LF_LINE_ENDING_XLIFF_TOMERGE, 'xlf')));"
        },
        {
            "sha": "c3fdf58e2103b136b86c14f3c4102a0b8af9487c",
            "filename": "packages/compiler/test/i18n/integration_xmb_xtb_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Fi18n%2Fintegration_xmb_xtb_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Fi18n%2Fintegration_xmb_xtb_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fi18n%2Fintegration_xmb_xtb_spec.ts?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -12,7 +12,8 @@ import {expect} from '@angular/platform-browser/testing/src/matchers';\n \n import {configureCompiler, createComponent, HTML, serializeTranslations, validateHtml} from './integration_common';\n \n-describe('i18n XMB/XTB integration spec', () => {\n+// TODO(alxhub): figure out if this test is still relevant.\n+xdescribe('i18n XMB/XTB integration spec', () => {\n   describe('(with LF line endings)', () => {\n     beforeEach(waitForAsync(() => configureCompiler(XTB + LF_LINE_ENDING_XTB, 'xtb')));\n "
        },
        {
            "sha": "013f5159e6fce0a745334f55c1a5469818202c5d",
            "filename": "packages/compiler/test/metadata_resolver_fixture.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 13,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fmetadata_resolver_fixture.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fmetadata_resolver_fixture.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fmetadata_resolver_fixture.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,13 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Component} from '@angular/core';\n-\n-@Component({styles: <any>('foo'), template: ''})\n-export class MalformedStylesComponent {\n-}"
        },
        {
            "sha": "78856d6dba7464aec2f827fb5dc260feb2cb1343",
            "filename": "packages/compiler/test/metadata_resolver_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 554,
            "changes": 554,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fmetadata_resolver_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fmetadata_resolver_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fmetadata_resolver_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,554 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {LIFECYCLE_HOOKS_VALUES, LifecycleHooks} from '@angular/compiler/src/lifecycle_reflector';\n-import {AfterContentChecked, AfterContentInit, AfterViewChecked, AfterViewInit, ChangeDetectionStrategy, Component, Directive, DoCheck, Injectable, NgModule, OnChanges, OnDestroy, OnInit, Pipe, SimpleChanges, ViewEncapsulation, ɵstringify as stringify} from '@angular/core';\n-import {inject, TestBed, waitForAsync} from '@angular/core/testing';\n-\n-import {CompileDiDependencyMetadata} from '../src/compile_metadata';\n-import {CompileMetadataResolver} from '../src/metadata_resolver';\n-import {identifierName} from '../src/parse_util';\n-import {ResourceLoader} from '../src/resource_loader';\n-import {MockResourceLoader} from '../testing/src/resource_loader_mock';\n-\n-import {MalformedStylesComponent} from './metadata_resolver_fixture';\n-import {TEST_COMPILER_PROVIDERS} from './test_bindings';\n-\n-{\n-  describe('CompileMetadataResolver', () => {\n-    beforeEach(() => {\n-      TestBed.configureCompiler({providers: TEST_COMPILER_PROVIDERS});\n-    });\n-\n-    it('should throw on the getDirectiveMetadata/getPipeMetadata methods if the module has not been loaded yet',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({})\n-         class SomeModule {\n-         }\n-\n-         @Pipe({name: 'pipe'})\n-         class SomePipe {\n-         }\n-\n-         expect(() => resolver.getDirectiveMetadata(ComponentWithEverythingInline))\n-             .toThrowError(/Illegal state/);\n-         expect(() => resolver.getPipeMetadata(SomePipe)).toThrowError(/Illegal state/);\n-       }));\n-\n-    it('should read metadata in sync for components with inline resources',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({declarations: [ComponentWithEverythingInline]})\n-         class SomeModule {\n-         }\n-         resolver.loadNgModuleDirectiveAndPipeMetadata(SomeModule, true);\n-\n-         const meta = resolver.getDirectiveMetadata(ComponentWithEverythingInline);\n-         expect(meta.selector).toEqual('someSelector');\n-         expect(meta.exportAs).toEqual('someExportAs');\n-         expect(meta.isComponent).toBe(true);\n-         expect(meta.type.reference).toBe(ComponentWithEverythingInline);\n-         expect(identifierName(meta.type)).toEqual(stringify(ComponentWithEverythingInline));\n-         expect(meta.type.lifecycleHooks).toEqual(LIFECYCLE_HOOKS_VALUES);\n-         expect(meta.changeDetection).toBe(ChangeDetectionStrategy.Default);\n-         expect(meta.inputs).toEqual({'someProp': 'someProp'});\n-         expect(meta.outputs).toEqual({'someEvent': 'someEvent'});\n-         expect(meta.hostListeners).toEqual({'someHostListener': 'someHostListenerExpr'});\n-         expect(meta.hostProperties).toEqual({'someHostProp': 'someHostPropExpr'});\n-         expect(meta.hostAttributes).toEqual({'someHostAttr': 'someHostAttrValue'});\n-         expect(meta.template !.encapsulation).toBe(ViewEncapsulation.Emulated);\n-         expect(meta.template !.styles).toEqual(['someStyle']);\n-         expect(meta.template !.template).toEqual('someTemplate');\n-         expect(meta.template !.interpolation).toEqual(['{{', '}}']);\n-       }));\n-\n-    it('should throw when reading metadata for component with external resources when sync=true is passed',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({declarations: [ComponentWithExternalResources]})\n-         class SomeModule {\n-         }\n-\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(SomeModule, true))\n-             .toThrowError(`Can't compile synchronously as ${\n-                 stringify(ComponentWithExternalResources)} is still being loaded!`);\n-       }));\n-\n-    it('should read external metadata when sync=false',\n-       waitForAsync(inject(\n-           [CompileMetadataResolver, ResourceLoader],\n-           (resolver: CompileMetadataResolver, resourceLoader: MockResourceLoader) => {\n-             @NgModule({declarations: [ComponentWithExternalResources]})\n-             class SomeModule {\n-             }\n-\n-             resourceLoader.when('someTemplateUrl', 'someTemplate');\n-             resolver.loadNgModuleDirectiveAndPipeMetadata(SomeModule, false).then(() => {\n-               const meta = resolver.getDirectiveMetadata(ComponentWithExternalResources);\n-               expect(meta.selector).toEqual('someSelector');\n-               expect(meta.template !.styleUrls).toEqual(['someStyleUrl']);\n-               expect(meta.template !.templateUrl).toEqual('someTemplateUrl');\n-               expect(meta.template !.template).toEqual('someTemplate');\n-             });\n-             resourceLoader.flush();\n-           })));\n-\n-    it('should use `./` as base url for templates during runtime compilation if no moduleId is given',\n-       waitForAsync(inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @Component({selector: 'someComponent', templateUrl: 'someUrl'})\n-         class ComponentWithoutModuleId {\n-         }\n-\n-\n-         @NgModule({declarations: [ComponentWithoutModuleId]})\n-         class SomeModule {\n-         }\n-\n-         resolver.loadNgModuleDirectiveAndPipeMetadata(SomeModule, false).then(() => {\n-           const value: string =\n-               resolver.getDirectiveMetadata(ComponentWithoutModuleId).template !.templateUrl!;\n-           const expectedEndValue = './someUrl';\n-           expect(value.endsWith(expectedEndValue)).toBe(true);\n-         });\n-       })));\n-\n-    it('should throw when the moduleId is not a string',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({declarations: [ComponentWithInvalidModuleId]})\n-         class SomeModule {\n-         }\n-\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(SomeModule, true))\n-             .toThrowError(\n-                 `moduleId should be a string in \"ComponentWithInvalidModuleId\". See` +\n-                 ` https://goo.gl/wIDDiL for more information.\\n` +\n-                 `If you're using Webpack you should inline the template and the styles, see` +\n-                 ` https://goo.gl/X2J8zc.`);\n-       }));\n-\n-\n-    it('should throw when metadata is incorrectly typed',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({declarations: [MalformedStylesComponent]})\n-         class SomeModule {\n-         }\n-\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(SomeModule, true))\n-             .toThrowError(`Expected 'styles' to be an array of strings.`);\n-       }));\n-\n-    it('should throw with descriptive error message when a module imports itself',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({imports: [SomeModule]})\n-         class SomeModule {\n-         }\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(SomeModule, true))\n-             .toThrowError(`'SomeModule' module can't import itself`);\n-       }));\n-\n-    it('should throw with descriptive error message when provider token can not be resolved',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({declarations: [MyBrokenComp1]})\n-         class SomeModule {\n-         }\n-\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(SomeModule, true))\n-             .toThrowError(`Can't resolve all parameters for MyBrokenComp1: (?).`);\n-       }));\n-\n-    it('should throw with descriptive error message when a directive is passed to imports',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({imports: [ComponentWithoutModuleId]})\n-         class ModuleWithImportedComponent {\n-         }\n-         expect(\n-             () => resolver.loadNgModuleDirectiveAndPipeMetadata(ModuleWithImportedComponent, true))\n-             .toThrowError(\n-                 `Unexpected directive 'ComponentWithoutModuleId' imported by the module 'ModuleWithImportedComponent'. Please add a @NgModule annotation.`);\n-       }));\n-\n-    it('should throw with descriptive error message when a pipe is passed to imports',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @Pipe({name: 'somePipe'})\n-         class SomePipe {\n-         }\n-         @NgModule({imports: [SomePipe]})\n-         class ModuleWithImportedPipe {\n-         }\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(ModuleWithImportedPipe, true))\n-             .toThrowError(\n-                 `Unexpected pipe 'SomePipe' imported by the module 'ModuleWithImportedPipe'. Please add a @NgModule annotation.`);\n-       }));\n-\n-    it('should throw with descriptive error message when a module is passed to declarations',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({})\n-         class SomeModule {\n-         }\n-         @NgModule({declarations: [SomeModule]})\n-         class ModuleWithDeclaredModule {\n-         }\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(ModuleWithDeclaredModule, true))\n-             .toThrowError(\n-                 `Unexpected module 'SomeModule' declared by the module 'ModuleWithDeclaredModule'. Please add a @Pipe/@Directive/@Component annotation.`);\n-       }));\n-\n-    it('should throw with descriptive error message when a declared pipe is missing annotation',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         class SomePipe {}\n-         @NgModule({declarations: [SomePipe]})\n-         class ModuleWithDeclaredModule {\n-         }\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(ModuleWithDeclaredModule, true))\n-             .toThrowError(\n-                 `Unexpected value 'SomePipe' declared by the module 'ModuleWithDeclaredModule'. Please add a @Pipe/@Directive/@Component annotation.`);\n-       }));\n-\n-    it('should throw with descriptive error message when an imported module is missing annotation',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         class SomeModule {}\n-         @NgModule({imports: [SomeModule]})\n-         class ModuleWithImportedModule {\n-         }\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(ModuleWithImportedModule, true))\n-             .toThrowError(\n-                 `Unexpected value 'SomeModule' imported by the module 'ModuleWithImportedModule'. Please add a @NgModule annotation.`);\n-       }));\n-\n-    it('should throw with descriptive error message when null is passed to declarations',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({declarations: [null!]})\n-         class ModuleWithNullDeclared {\n-         }\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(ModuleWithNullDeclared, true))\n-             .toThrowError(\n-                 `Unexpected value 'null' declared by the module 'ModuleWithNullDeclared'`);\n-       }));\n-\n-    it('should throw with descriptive error message when null is passed to imports',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({imports: [null!]})\n-         class ModuleWithNullImported {\n-         }\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(ModuleWithNullImported, true))\n-             .toThrowError(\n-                 `Unexpected value 'null' imported by the module 'ModuleWithNullImported'`);\n-       }));\n-\n-\n-    it('should throw with descriptive error message when a param token of a dependency is undefined',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({declarations: [MyBrokenComp2]})\n-         class SomeModule {\n-         }\n-\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(SomeModule, true))\n-             .toThrowError(`Can't resolve all parameters for NonAnnotatedService: (?).`);\n-       }));\n-\n-    it('should throw with descriptive error message when encounter invalid provider',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({providers: [{provide: SimpleService, useClass: undefined!}]})\n-         class SomeModule {\n-         }\n-\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(SomeModule, true))\n-             .toThrowError(/Invalid provider for SimpleService. useClass cannot be undefined./);\n-       }));\n-\n-    it('should throw with descriptive error message when provider is undefined',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({providers: [undefined!]})\n-         class SomeModule {\n-         }\n-\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(SomeModule, true))\n-             .toThrowError(/Encountered undefined provider!/);\n-       }));\n-\n-    it('should throw with descriptive error message when one of providers is not present',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({declarations: [MyBrokenComp3]})\n-         class SomeModule {\n-         }\n-\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(SomeModule, true))\n-             .toThrowError(\n-                 `Invalid providers for \"MyBrokenComp3\" - only instances of Provider and Type are allowed, got: [SimpleService, ?null?, ...]`);\n-       }));\n-\n-    it('should throw with descriptive error message when one of viewProviders is not present',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({declarations: [MyBrokenComp4]})\n-         class SomeModule {\n-         }\n-\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(SomeModule, true))\n-             .toThrowError(\n-                 `Invalid viewProviders for \"MyBrokenComp4\" - only instances of Provider and Type are allowed, got: [?null?, ...]`);\n-       }));\n-\n-    it('should throw with descriptive error message when null or undefined is passed to module bootstrap',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({bootstrap: [null!]})\n-         class ModuleWithNullBootstrap {\n-         }\n-         @NgModule({bootstrap: [undefined!]})\n-         class ModuleWithUndefinedBootstrap {\n-         }\n-\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(ModuleWithNullBootstrap, true))\n-             .toThrowError(\n-                 `Unexpected value 'null' used in the bootstrap property of module 'ModuleWithNullBootstrap'`);\n-         expect(\n-             () =>\n-                 resolver.loadNgModuleDirectiveAndPipeMetadata(ModuleWithUndefinedBootstrap, true))\n-             .toThrowError(\n-                 `Unexpected value 'undefined' used in the bootstrap property of module 'ModuleWithUndefinedBootstrap'`);\n-       }));\n-\n-    it('should throw an error when the interpolation config has invalid symbols',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({declarations: [ComponentWithInvalidInterpolation1]})\n-         class Module1 {\n-         }\n-\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(Module1, true))\n-             .toThrowError(`[' ', ' '] contains unusable interpolation symbol.`);\n-\n-         @NgModule({declarations: [ComponentWithInvalidInterpolation2]})\n-         class Module2 {\n-         }\n-\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(Module2, true))\n-             .toThrowError(`['{', '}'] contains unusable interpolation symbol.`);\n-\n-         @NgModule({declarations: [ComponentWithInvalidInterpolation3]})\n-         class Module3 {\n-         }\n-\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(Module3, true))\n-             .toThrowError(`['<%', '%>'] contains unusable interpolation symbol.`);\n-\n-         @NgModule({declarations: [ComponentWithInvalidInterpolation4]})\n-         class Module4 {\n-         }\n-\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(Module4, true))\n-             .toThrowError(`['&#', '}}'] contains unusable interpolation symbol.`);\n-\n-         @NgModule({declarations: [ComponentWithInvalidInterpolation5]})\n-         class Module5 {\n-         }\n-\n-         expect(() => resolver.loadNgModuleDirectiveAndPipeMetadata(Module5, true))\n-             .toThrowError(`['&lbrace;', '}}'] contains unusable interpolation symbol.`);\n-       }));\n-\n-    it(`should throw an error when a Pipe is added to module's bootstrap list`,\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @Pipe({name: 'pipe'})\n-         class MyPipe {\n-         }\n-\n-         @NgModule({declarations: [MyPipe], bootstrap: [MyPipe]})\n-         class ModuleWithPipeInBootstrap {\n-         }\n-\n-         expect(() => resolver.getNgModuleMetadata(ModuleWithPipeInBootstrap))\n-             .toThrowError(`MyPipe cannot be used as an entry component.`);\n-       }));\n-\n-    it(`should throw an error when a Service is added to module's bootstrap list`,\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({declarations: [], bootstrap: [SimpleService]})\n-         class ModuleWithServiceInBootstrap {\n-         }\n-\n-         expect(() => resolver.getNgModuleMetadata(ModuleWithServiceInBootstrap))\n-             .toThrowError(`SimpleService cannot be used as an entry component.`);\n-       }));\n-\n-    it('should generate an error when a dependency could not be resolved',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         // Override the errorCollector so that error gets collected instead of\n-         // being thrown.\n-         (resolver as any)._errorCollector = (error: Error, type?: any) => {\n-           expect(error.message).toBe(`Can't resolve all parameters for MyComponent: (?).`);\n-         };\n-\n-         @Component({template: ''})\n-         class MyComponent {\n-           // @ts-ignore UserService is a non-existent class.\n-           constructor(service: UserService) {}\n-         }\n-\n-         @NgModule({declarations: [MyComponent]})\n-         class AppModule {\n-         }\n-\n-         const moduleMetadata = resolver.getNgModuleMetadata(AppModule)!;\n-         expect(moduleMetadata).toBeTruthy();\n-         expect(moduleMetadata.declaredDirectives.length).toBe(1);\n-         const directive = moduleMetadata.declaredDirectives[0];\n-         const directiveMetadata = resolver.getNonNormalizedDirectiveMetadata(directive.reference)!;\n-         expect(directiveMetadata).toBeTruthy();\n-         const {metadata} = directiveMetadata;\n-         const diDeps: CompileDiDependencyMetadata[] = metadata.type.diDeps;\n-         // 'null' does not conform to the shape of `CompileDiDependencyMetadata`\n-         expect(diDeps.every(d => d !== null)).toBe(true);\n-       }));\n-\n-    it(`should throw an error when a Directive is added to module's bootstrap list`,\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @Directive({selector: 'directive'})\n-         class MyDirective {\n-         }\n-\n-         @NgModule({declarations: [], bootstrap: [MyDirective]})\n-         class ModuleWithDirectiveInBootstrap {\n-         }\n-\n-         expect(() => resolver.getNgModuleMetadata(ModuleWithDirectiveInBootstrap))\n-             .toThrowError(`MyDirective cannot be used as an entry component.`);\n-       }));\n-\n-    it(`should not throw an error when a Component is added to module's bootstrap list`,\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @Component({template: ''})\n-         class MyComp {\n-         }\n-\n-         @NgModule({declarations: [MyComp], bootstrap: [MyComp]})\n-         class ModuleWithComponentInBootstrap {\n-         }\n-\n-         expect(() => resolver.getNgModuleMetadata(ModuleWithComponentInBootstrap)).not.toThrow();\n-       }));\n-\n-    // #20049\n-    it('should throw a reasonable message when an invalid import is given',\n-       inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-         @NgModule({imports: [{ngModule: true as any}]})\n-         class InvalidModule {\n-         }\n-\n-         expect(() => {\n-           resolver.getNgModuleMetadata(InvalidModule);\n-         })\n-             .toThrowError(\n-                 `Unexpected value '[object Object]' imported by the module 'InvalidModule'. Please add a @NgModule annotation.`);\n-       }));\n-  });\n-\n-  it('should dedupe declarations in NgModule',\n-     inject([CompileMetadataResolver], (resolver: CompileMetadataResolver) => {\n-       @Component({template: ''})\n-       class MyComp {\n-       }\n-\n-       @NgModule({declarations: [MyComp, MyComp]})\n-       class MyModule {\n-       }\n-\n-       const modMeta = resolver.getNgModuleMetadata(MyModule)!;\n-       expect(modMeta.declaredDirectives.length).toBe(1);\n-       expect(modMeta.declaredDirectives[0].reference).toBe(MyComp);\n-     }));\n-}\n-\n-@Component({selector: 'someComponent', template: ''})\n-class ComponentWithoutModuleId {\n-}\n-\n-@Component({selector: 'someComponent', template: '', moduleId: <any>0})\n-class ComponentWithInvalidModuleId {\n-}\n-\n-@Component({\n-  selector: 'someSelector',\n-  templateUrl: 'someTemplateUrl',\n-  styleUrls: ['someStyleUrl'],\n-})\n-class ComponentWithExternalResources {\n-}\n-\n-@Component({\n-  selector: 'someSelector',\n-  inputs: ['someProp'],\n-  outputs: ['someEvent'],\n-  host: {\n-    '[someHostProp]': 'someHostPropExpr',\n-    '(someHostListener)': 'someHostListenerExpr',\n-    'someHostAttr': 'someHostAttrValue'\n-  },\n-  exportAs: 'someExportAs',\n-  moduleId: 'someModuleId',\n-  changeDetection: ChangeDetectionStrategy.Default,\n-  template: 'someTemplate',\n-  encapsulation: ViewEncapsulation.Emulated,\n-  styles: ['someStyle'],\n-  interpolation: ['{{', '}}']\n-})\n-class ComponentWithEverythingInline implements OnChanges, OnInit, DoCheck, OnDestroy,\n-                                               AfterContentInit, AfterContentChecked, AfterViewInit,\n-                                               AfterViewChecked {\n-  ngOnChanges(changes: SimpleChanges): void {}\n-  ngOnInit(): void {}\n-  ngDoCheck(): void {}\n-  ngOnDestroy(): void {}\n-  ngAfterContentInit(): void {}\n-  ngAfterContentChecked(): void {}\n-  ngAfterViewInit(): void {}\n-  ngAfterViewChecked(): void {}\n-}\n-\n-@Component({selector: 'my-broken-comp', template: ''})\n-class MyBrokenComp1 {\n-  constructor(public dependency: any) {}\n-}\n-\n-class NonAnnotatedService {\n-  constructor(dep: any) {}\n-}\n-\n-@Component({selector: 'my-broken-comp', template: '', providers: [NonAnnotatedService]})\n-class MyBrokenComp2 {\n-  constructor(dependency: NonAnnotatedService) {}\n-}\n-\n-@Injectable()\n-class SimpleService {\n-}\n-\n-@Component({selector: 'my-broken-comp', template: '', providers: [SimpleService, null!, [null]]})\n-class MyBrokenComp3 {\n-}\n-\n-@Component(\n-    {selector: 'my-broken-comp', template: '', viewProviders: [null!, SimpleService, [null]]})\n-class MyBrokenComp4 {\n-}\n-\n-@Component({selector: 'someSelector', template: '', interpolation: [' ', ' ']})\n-class ComponentWithInvalidInterpolation1 {\n-}\n-\n-@Component({selector: 'someSelector', template: '', interpolation: ['{', '}']})\n-class ComponentWithInvalidInterpolation2 {\n-}\n-\n-@Component({selector: 'someSelector', template: '', interpolation: ['<%', '%>']})\n-class ComponentWithInvalidInterpolation3 {\n-}\n-\n-@Component({selector: 'someSelector', template: '', interpolation: ['&#', '}}']})\n-class ComponentWithInvalidInterpolation4 {\n-}\n-\n-@Component({selector: 'someSelector', template: '', interpolation: ['&lbrace;', '}}']})\n-class ComponentWithInvalidInterpolation5 {\n-}"
        },
        {
            "sha": "487b7ed4e29380e9d4e4d9b8ee118c79de16e231",
            "filename": "packages/compiler/test/ng_module_resolver_mock_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 45,
            "changes": 45,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fng_module_resolver_mock_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fng_module_resolver_mock_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fng_module_resolver_mock_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,45 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {NgModule} from '@angular/core';\n-import {JitReflector} from '@angular/platform-browser-dynamic/src/compiler_reflector';\n-\n-import {MockNgModuleResolver} from '../testing';\n-\n-{\n-  describe('MockNgModuleResolver', () => {\n-    let ngModuleResolver: MockNgModuleResolver;\n-\n-    beforeEach(() => {\n-      ngModuleResolver = new MockNgModuleResolver(new JitReflector());\n-    });\n-\n-    describe('NgModule overriding', () => {\n-      it('should fallback to the default NgModuleResolver when templates are not overridden',\n-         () => {\n-           const ngModule = ngModuleResolver.resolve(SomeNgModule);\n-           expect(ngModule.declarations).toEqual([SomeDirective]);\n-         });\n-\n-      it('should allow overriding the @NgModule', () => {\n-        ngModuleResolver.setNgModule(\n-            SomeNgModule, new NgModule({declarations: [SomeOtherDirective]}));\n-        const ngModule = ngModuleResolver.resolve(SomeNgModule);\n-        expect(ngModule.declarations).toEqual([SomeOtherDirective]);\n-      });\n-    });\n-  });\n-}\n-\n-class SomeDirective {}\n-\n-class SomeOtherDirective {}\n-\n-@NgModule({declarations: [SomeDirective]})\n-class SomeNgModule {\n-}"
        },
        {
            "sha": "1526da8b51599d9bbbf51abbd738d1619611e521",
            "filename": "packages/compiler/test/ng_module_resolver_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 85,
            "changes": 85,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fng_module_resolver_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fng_module_resolver_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fng_module_resolver_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,85 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {NgModuleResolver} from '@angular/compiler/src/ng_module_resolver';\n-import {Component, Directive, Injectable, NgModule, ɵstringify as stringify} from '@angular/core';\n-import {JitReflector} from '@angular/platform-browser-dynamic/src/compiler_reflector';\n-\n-@Directive()\n-class SomeClass1 {\n-}\n-\n-@NgModule()\n-class SomeClass2 {\n-}\n-\n-@NgModule()\n-class SomeClass3 {\n-}\n-\n-@Injectable()\n-class SomeClass4 {\n-}\n-\n-@Component({template: ''})\n-class SomeClass5 {\n-}\n-\n-@NgModule({\n-  declarations: [SomeClass1],\n-  imports: [SomeClass2],\n-  exports: [SomeClass3],\n-  providers: [SomeClass4],\n-  entryComponents: [SomeClass5]\n-})\n-class SomeModule {\n-}\n-\n-class SimpleClass {}\n-\n-{\n-  describe('NgModuleResolver', () => {\n-    let resolver: NgModuleResolver;\n-\n-    beforeEach(() => {\n-      resolver = new NgModuleResolver(new JitReflector());\n-    });\n-\n-    it('should read out the metadata from the class', () => {\n-      const moduleMetadata = resolver.resolve(SomeModule);\n-      expect(moduleMetadata).toEqual(new NgModule({\n-        declarations: [SomeClass1],\n-        imports: [SomeClass2],\n-        exports: [SomeClass3],\n-        providers: [SomeClass4],\n-        entryComponents: [SomeClass5]\n-      }));\n-    });\n-\n-    it('should throw when simple class has no NgModule decorator', () => {\n-      expect(() => resolver.resolve(SimpleClass))\n-          .toThrowError(`No NgModule metadata found for '${stringify(SimpleClass)}'.`);\n-    });\n-\n-    it('should support inheriting the metadata', function() {\n-      @NgModule({id: 'p'})\n-      class Parent {\n-      }\n-\n-      class ChildNoDecorator extends Parent {}\n-\n-      @NgModule({id: 'c'})\n-      class ChildWithDecorator extends Parent {\n-      }\n-\n-      expect(resolver.resolve(ChildNoDecorator)).toEqual(new NgModule({id: 'p'}));\n-\n-      expect(resolver.resolve(ChildWithDecorator)).toEqual(new NgModule({id: 'c'}));\n-    });\n-  });\n-}"
        },
        {
            "sha": "082ea67b750104cda32b8661d050b753fe008591",
            "filename": "packages/compiler/test/output/abstract_emitter_node_only_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Foutput%2Fabstract_emitter_node_only_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Foutput%2Fabstract_emitter_node_only_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Foutput%2Fabstract_emitter_node_only_spec.ts?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -9,7 +9,8 @@\n import {ParseLocation, ParseSourceFile, ParseSourceSpan} from '@angular/compiler';\n import {EmitterVisitorContext} from '@angular/compiler/src/output/abstract_emitter';\n import {SourceMap} from '@angular/compiler/src/output/source_map';\n-import {extractSourceMap, originalPositionFor} from '@angular/compiler/testing/src/output/source_map_util';\n+\n+import {extractSourceMap, originalPositionFor} from './source_map_util';\n \n {\n   describe('AbstractEmitter', () => {"
        },
        {
            "sha": "96cfc00b5384e1f89d68c3ffadac7c4a15e1b6ae",
            "filename": "packages/compiler/test/output/js_emitter_node_only_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Foutput%2Fjs_emitter_node_only_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Foutput%2Fjs_emitter_node_only_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Foutput%2Fjs_emitter_node_only_spec.ts?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -11,7 +11,7 @@ import * as o from '@angular/compiler/src/output/output_ast';\n import {SourceMap} from '@angular/compiler/src/output/source_map';\n import {ParseLocation, ParseSourceFile, ParseSourceSpan} from '@angular/compiler/src/parse_util';\n \n-import {extractSourceMap, originalPositionFor} from '@angular/compiler/testing/src/output/source_map_util';\n+import {extractSourceMap, originalPositionFor} from './source_map_util';\n \n const someGenFilePath = 'somePackage/someGenFile';\n "
        },
        {
            "sha": "03d43c059919c3bbe774d6389a877456923b0111",
            "filename": "packages/compiler/test/output/source_map_util.ts",
            "status": "renamed",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Foutput%2Fsource_map_util.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Foutput%2Fsource_map_util.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Foutput%2Fsource_map_util.ts?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -32,7 +32,7 @@ export function extractSourceMap(source: string): SourceMap|null {\n   if (idx == -1) return null;\n   const smComment = source.slice(idx).split('\\n', 2)[1].trim();\n   const smB64 = smComment.split('sourceMappingURL=data:application/json;base64,')[1];\n-  return smB64 ? JSON.parse(decodeB64String(smB64)) : null;\n+  return smB64 ? JSON.parse(decodeB64String(smB64)) as SourceMap : null;\n }\n \n function decodeB64String(s: string): string {",
            "previous_filename": "packages/compiler/testing/src/output/source_map_util.ts"
        },
        {
            "sha": "4293f3c8f3883660d6181e2e27566d7320e7275f",
            "filename": "packages/compiler/test/output/ts_emitter_node_only_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Foutput%2Fts_emitter_node_only_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Foutput%2Fts_emitter_node_only_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Foutput%2Fts_emitter_node_only_spec.ts?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -13,7 +13,7 @@ import {SourceMap} from '@angular/compiler/src/output/source_map';\n import {TypeScriptEmitter} from '@angular/compiler/src/output/ts_emitter';\n import {ParseSourceSpan} from '@angular/compiler/src/parse_util';\n \n-import {extractSourceMap, originalPositionFor} from '@angular/compiler/testing/src/output/source_map_util';\n+import {extractSourceMap, originalPositionFor} from './source_map_util';\n \n const someGenFilePath = 'somePackage/someGenFile';\n "
        },
        {
            "sha": "23efd0ac1eee06b9537e88d45bbcc82b34d9f421",
            "filename": "packages/compiler/test/parse_util_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 26,
            "changes": 26,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fparse_util_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fparse_util_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fparse_util_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,26 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ParseError, ParseErrorLevel, ParseLocation, ParseSourceFile, ParseSourceSpan} from '../src/parse_util';\n-\n-{\n-  describe('ParseError', () => {\n-    it('should reflect the level in the message', () => {\n-      const file = new ParseSourceFile(`foo\\nbar\\nfoo`, 'url');\n-      const start = new ParseLocation(file, 4, 1, 0);\n-      const end = new ParseLocation(file, 6, 1, 2);\n-      const span = new ParseSourceSpan(start, end);\n-\n-      const fatal = new ParseError(span, 'fatal', ParseErrorLevel.ERROR);\n-      expect(fatal.toString()).toEqual('fatal (\"foo\\n[ERROR ->]bar\\nfoo\"): url@1:0');\n-\n-      const warning = new ParseError(span, 'warning', ParseErrorLevel.WARNING);\n-      expect(warning.toString()).toEqual('warning (\"foo\\n[WARNING ->]bar\\nfoo\"): url@1:0');\n-    });\n-  });\n-}"
        },
        {
            "sha": "0389883f52d84294f74259ca6c7c69cb8bd0d336",
            "filename": "packages/compiler/test/pipe_resolver_mock_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 40,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fpipe_resolver_mock_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fpipe_resolver_mock_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fpipe_resolver_mock_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,40 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Injector, Pipe} from '@angular/core';\n-import {inject} from '@angular/core/testing';\n-import {JitReflector} from '@angular/platform-browser-dynamic/src/compiler_reflector';\n-\n-import {MockPipeResolver} from '../testing';\n-\n-{\n-  describe('MockPipeResolver', () => {\n-    let pipeResolver: MockPipeResolver;\n-\n-    beforeEach(inject([Injector], (injector: Injector) => {\n-      pipeResolver = new MockPipeResolver(new JitReflector());\n-    }));\n-\n-    describe('Pipe overriding', () => {\n-      it('should fallback to the default PipeResolver when templates are not overridden', () => {\n-        const pipe = pipeResolver.resolve(SomePipe);\n-        expect(pipe.name).toEqual('somePipe');\n-      });\n-\n-      it('should allow overriding the @Pipe', () => {\n-        pipeResolver.setPipe(SomePipe, new Pipe({name: 'someOtherName'}));\n-        const pipe = pipeResolver.resolve(SomePipe);\n-        expect(pipe.name).toEqual('someOtherName');\n-      });\n-    });\n-  });\n-}\n-\n-@Pipe({name: 'somePipe'})\n-class SomePipe {\n-}"
        },
        {
            "sha": "76867c42291eddd809d30609020082549f171011",
            "filename": "packages/compiler/test/pipe_resolver_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 54,
            "changes": 54,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fpipe_resolver_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fpipe_resolver_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fpipe_resolver_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,54 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {PipeResolver} from '@angular/compiler/src/pipe_resolver';\n-import {ɵstringify as stringify} from '@angular/core';\n-import {Pipe} from '@angular/core/src/metadata';\n-import {JitReflector} from '@angular/platform-browser-dynamic/src/compiler_reflector';\n-\n-@Pipe({name: 'somePipe', pure: true})\n-class SomePipe {\n-}\n-\n-class SimpleClass {}\n-\n-{\n-  describe('PipeResolver', () => {\n-    let resolver: PipeResolver;\n-\n-    beforeEach(() => {\n-      resolver = new PipeResolver(new JitReflector());\n-    });\n-\n-    it('should read out the metadata from the class', () => {\n-      const moduleMetadata = resolver.resolve(SomePipe);\n-      expect(moduleMetadata).toEqual(new Pipe({name: 'somePipe', pure: true}));\n-    });\n-\n-    it('should throw when simple class has no pipe decorator', () => {\n-      expect(() => resolver.resolve(SimpleClass))\n-          .toThrowError(`No Pipe decorator found on ${stringify(SimpleClass)}`);\n-    });\n-\n-    it('should support inheriting the metadata', function() {\n-      @Pipe({name: 'p'})\n-      class Parent {\n-      }\n-\n-      class ChildNoDecorator extends Parent {}\n-\n-      @Pipe({name: 'c'})\n-      class ChildWithDecorator extends Parent {\n-      }\n-\n-      expect(resolver.resolve(ChildNoDecorator)).toEqual(new Pipe({name: 'p'}));\n-\n-      expect(resolver.resolve(ChildWithDecorator)).toEqual(new Pipe({name: 'c'}));\n-    });\n-  });\n-}"
        },
        {
            "sha": "a41c153a35d784f35ac11b844008a7472886b275",
            "filename": "packages/compiler/test/render3/BUILD.bazel",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Frender3%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Frender3%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Frender3%2FBUILD.bazel?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -9,9 +9,7 @@ ts_library(\n     deps = [\n         \"//packages:types\",\n         \"//packages/compiler\",\n-        \"//packages/compiler/test:test_utils\",\n         \"//packages/compiler/test/expression_parser/utils\",\n-        \"//packages/compiler/testing\",\n         \"//packages/core\",\n     ],\n )"
        },
        {
            "sha": "c1c84c84e77834c408ecb57c98384c826b7d2682",
            "filename": "packages/compiler/test/render3/view/util.ts",
            "status": "modified",
            "additions": 63,
            "deletions": 1,
            "changes": 64,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Frender3%2Fview%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Frender3%2Fview%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Frender3%2Fview%2Futil.ts?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -18,8 +18,70 @@ import * as a from '../../../src/render3/r3_ast';\n import {htmlAstToRender3Ast, Render3ParseResult} from '../../../src/render3/r3_template_transform';\n import {I18nMetaVisitor} from '../../../src/render3/view/i18n/meta';\n import {LEADING_TRIVIA_CHARS} from '../../../src/render3/view/template';\n+import {ElementSchemaRegistry} from '../../../src/schema/element_schema_registry';\n import {BindingParser} from '../../../src/template_parser/binding_parser';\n-import {MockSchemaRegistry} from '../../../testing';\n+\n+class MockSchemaRegistry implements ElementSchemaRegistry {\n+  constructor(\n+      public existingProperties: {[key: string]: boolean},\n+      public attrPropMapping: {[key: string]: string},\n+      public existingElements: {[key: string]: boolean}, public invalidProperties: Array<string>,\n+      public invalidAttributes: Array<string>) {}\n+\n+  hasProperty(tagName: string, property: string, schemas: any[]): boolean {\n+    const value = this.existingProperties[property];\n+    return value === void 0 ? true : value;\n+  }\n+\n+  hasElement(tagName: string, schemaMetas: any[]): boolean {\n+    const value = this.existingElements[tagName.toLowerCase()];\n+    return value === void 0 ? true : value;\n+  }\n+\n+  allKnownElementNames(): string[] {\n+    return Object.keys(this.existingElements);\n+  }\n+\n+  securityContext(selector: string, property: string, isAttribute: boolean): any {\n+    return 0;\n+  }\n+\n+  getMappedPropName(attrName: string): string {\n+    return this.attrPropMapping[attrName] || attrName;\n+  }\n+\n+  getDefaultComponentElementName(): string {\n+    return 'ng-component';\n+  }\n+\n+  validateProperty(name: string): {error: boolean, msg?: string} {\n+    if (this.invalidProperties.indexOf(name) > -1) {\n+      return {error: true, msg: `Binding to property '${name}' is disallowed for security reasons`};\n+    } else {\n+      return {error: false};\n+    }\n+  }\n+\n+  validateAttribute(name: string): {error: boolean, msg?: string} {\n+    if (this.invalidAttributes.indexOf(name) > -1) {\n+      return {\n+        error: true,\n+        msg: `Binding to attribute '${name}' is disallowed for security reasons`\n+      };\n+    } else {\n+      return {error: false};\n+    }\n+  }\n+\n+  normalizeAnimationStyleProperty(propName: string): string {\n+    return propName;\n+  }\n+  normalizeAnimationStyleValue(camelCaseProp: string, userProvidedProp: string, val: string|number):\n+      {error: string, value: string} {\n+    return {error: null!, value: val.toString()};\n+  }\n+}\n+\n \n export function findExpression(tmpl: a.Node[], expr: string): e.AST|null {\n   const res = tmpl.reduce((found, node) => {"
        },
        {
            "sha": "6723fa5d2e649e817b9b677d330a52f4b78b4d3b",
            "filename": "packages/compiler/test/resource_loader_mock_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 118,
            "changes": 118,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fresource_loader_mock_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fresource_loader_mock_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fresource_loader_mock_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,118 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {MockResourceLoader} from '@angular/compiler/testing/src/resource_loader_mock';\n-\n-{\n-  describe('MockResourceLoader', () => {\n-    let resourceLoader: MockResourceLoader;\n-\n-    beforeEach(() => {\n-      resourceLoader = new MockResourceLoader();\n-    });\n-\n-    function expectResponse(\n-        request: Promise<string>, url: string, response: string, done: () => void = null!) {\n-      function onResponse(text: string): string {\n-        if (response === null) {\n-          throw `Unexpected response ${url} -> ${text}`;\n-        } else {\n-          expect(text).toEqual(response);\n-          if (done != null) done();\n-        }\n-        return text;\n-      }\n-\n-      function onError(error: string): string {\n-        if (response !== null) {\n-          throw `Unexpected error ${url}`;\n-        } else {\n-          expect(error).toEqual(`Failed to load ${url}`);\n-          if (done != null) done();\n-        }\n-        return error;\n-      }\n-\n-      request.then(onResponse, onError);\n-    }\n-\n-    it('should return a response from the definitions', done => {\n-      const url = '/foo';\n-      const response = 'bar';\n-      resourceLoader.when(url, response);\n-      expectResponse(resourceLoader.get(url), url, response, () => done());\n-      resourceLoader.flush();\n-    });\n-\n-    it('should return an error from the definitions', done => {\n-      const url = '/foo';\n-      const response: string = null!;\n-      resourceLoader.when(url, response);\n-      expectResponse(resourceLoader.get(url), url, response, () => done());\n-      resourceLoader.flush();\n-    });\n-\n-    it('should return a response from the expectations', done => {\n-      const url = '/foo';\n-      const response = 'bar';\n-      resourceLoader.expect(url, response);\n-      expectResponse(resourceLoader.get(url), url, response, () => done());\n-      resourceLoader.flush();\n-    });\n-\n-    it('should return an error from the expectations', done => {\n-      const url = '/foo';\n-      const response: string = null!;\n-      resourceLoader.expect(url, response);\n-      expectResponse(resourceLoader.get(url), url, response, () => done());\n-      resourceLoader.flush();\n-    });\n-\n-    it('should not reuse expectations', () => {\n-      const url = '/foo';\n-      const response = 'bar';\n-      resourceLoader.expect(url, response);\n-      resourceLoader.get(url);\n-      resourceLoader.get(url);\n-      expect(() => {\n-        resourceLoader.flush();\n-      }).toThrowError('Unexpected request /foo');\n-    });\n-\n-    it('should return expectations before definitions', done => {\n-      const url = '/foo';\n-      resourceLoader.when(url, 'when');\n-      resourceLoader.expect(url, 'expect');\n-      expectResponse(resourceLoader.get(url), url, 'expect');\n-      expectResponse(resourceLoader.get(url), url, 'when', () => done());\n-      resourceLoader.flush();\n-    });\n-\n-    it('should throw when there is no definitions or expectations', () => {\n-      resourceLoader.get('/foo');\n-      expect(() => {\n-        resourceLoader.flush();\n-      }).toThrowError('Unexpected request /foo');\n-    });\n-\n-    it('should throw when flush is called without any pending requests', () => {\n-      expect(() => {\n-        resourceLoader.flush();\n-      }).toThrowError('No pending requests to flush');\n-    });\n-\n-    it('should throw on unsatisfied expectations', () => {\n-      resourceLoader.expect('/foo', 'bar');\n-      resourceLoader.when('/bar', 'foo');\n-      resourceLoader.get('/bar');\n-      expect(() => {\n-        resourceLoader.flush();\n-      }).toThrowError('Unsatisfied requests: /foo');\n-    });\n-  });\n-}"
        },
        {
            "sha": "c0fbe40cd7aa045ffd479feee772d40e50833a08",
            "filename": "packages/compiler/test/runtime_compiler_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 171,
            "changes": 171,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fruntime_compiler_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Fruntime_compiler_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fruntime_compiler_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,171 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {DirectiveResolver, ResourceLoader} from '@angular/compiler';\n-import {Compiler, Component, Injector, NgModule, NgModuleFactory, ɵstringify as stringify} from '@angular/core';\n-import {fakeAsync, inject, TestBed, tick, waitForAsync} from '@angular/core/testing';\n-import {expect} from '@angular/platform-browser/testing/src/matchers';\n-\n-import {MockDirectiveResolver} from '../testing';\n-\n-@Component({selector: 'child-cmp'})\n-class ChildComp {\n-}\n-\n-@Component({selector: 'some-cmp', template: 'someComp'})\n-class SomeComp {\n-}\n-\n-@Component({selector: 'some-cmp', templateUrl: './someTpl'})\n-class SomeCompWithUrlTemplate {\n-}\n-\n-{\n-  describe('RuntimeCompiler', () => {\n-    describe('compilerComponentSync', () => {\n-      describe('never resolving loader', () => {\n-        class StubResourceLoader {\n-          get(url: string) {\n-            return new Promise(() => {});\n-          }\n-        }\n-\n-        beforeEach(() => {\n-          TestBed.configureCompiler(\n-              {providers: [{provide: ResourceLoader, useClass: StubResourceLoader, deps: []}]});\n-        });\n-\n-        it('should throw when using a templateUrl that has not been compiled before',\n-           waitForAsync(() => {\n-             TestBed.configureTestingModule({declarations: [SomeCompWithUrlTemplate]});\n-             TestBed.compileComponents().then(() => {\n-               expect(() => TestBed.createComponent(SomeCompWithUrlTemplate))\n-                   .toThrowError(`Can't compile synchronously as ${\n-                       stringify(SomeCompWithUrlTemplate)} is still being loaded!`);\n-             });\n-           }));\n-\n-        it('should throw when using a templateUrl in a nested component that has not been compiled before',\n-           () => {\n-             TestBed.configureTestingModule({declarations: [SomeComp, ChildComp]});\n-             TestBed.overrideComponent(ChildComp, {set: {templateUrl: '/someTpl.html'}});\n-             TestBed.overrideComponent(SomeComp, {set: {template: '<child-cmp></child-cmp>'}});\n-             TestBed.compileComponents().then(() => {\n-               expect(() => TestBed.createComponent(SomeComp))\n-                   .toThrowError(`Can't compile synchronously as ${\n-                       stringify(ChildComp)} is still being loaded!`);\n-             });\n-           });\n-      });\n-\n-      describe('resolving loader', () => {\n-        class StubResourceLoader {\n-          get(url: string) {\n-            return Promise.resolve('hello');\n-          }\n-        }\n-\n-        beforeEach(() => {\n-          TestBed.configureCompiler(\n-              {providers: [{provide: ResourceLoader, useClass: StubResourceLoader, deps: []}]});\n-        });\n-\n-        it('should allow to use templateUrl components that have been loaded before',\n-           waitForAsync(() => {\n-             TestBed.configureTestingModule({declarations: [SomeCompWithUrlTemplate]});\n-             TestBed.compileComponents().then(() => {\n-               const fixture = TestBed.createComponent(SomeCompWithUrlTemplate);\n-               expect(fixture.nativeElement).toHaveText('hello');\n-             });\n-           }));\n-      });\n-    });\n-  });\n-\n-  describe('RuntimeCompiler', () => {\n-    let compiler: Compiler;\n-    let resourceLoader: {get: jasmine.Spy};\n-    let dirResolver: MockDirectiveResolver;\n-\n-    beforeEach(() => {\n-      resourceLoader = jasmine.createSpyObj('ResourceLoader', ['get']);\n-      TestBed.configureCompiler({providers: [{provide: ResourceLoader, useValue: resourceLoader}]});\n-    });\n-\n-    beforeEach(fakeAsync(inject(\n-        [Compiler, ResourceLoader, DirectiveResolver, Injector],\n-        (_compiler: Compiler, _resourceLoader: any, _dirResolver: MockDirectiveResolver) => {\n-          compiler = _compiler;\n-          resourceLoader = _resourceLoader;\n-          dirResolver = _dirResolver;\n-        })));\n-\n-    describe('compileModuleAsync', () => {\n-      it('should allow to use templateUrl components', fakeAsync(() => {\n-           @NgModule({\n-             declarations: [SomeCompWithUrlTemplate],\n-             entryComponents: [SomeCompWithUrlTemplate]\n-           })\n-           class SomeModule {\n-           }\n-\n-           resourceLoader.get.and.callFake(() => Promise.resolve('hello'));\n-           let ngModuleFactory: NgModuleFactory<any> = undefined!;\n-           compiler.compileModuleAsync(SomeModule).then((f) => ngModuleFactory = f);\n-           tick();\n-           expect(ngModuleFactory.moduleType).toBe(SomeModule);\n-         }));\n-    });\n-\n-    describe('compileModuleSync', () => {\n-      it('should throw when using a templateUrl that has not been compiled before', () => {\n-        @NgModule(\n-            {declarations: [SomeCompWithUrlTemplate], entryComponents: [SomeCompWithUrlTemplate]})\n-        class SomeModule {\n-        }\n-\n-        resourceLoader.get.and.callFake(() => Promise.resolve(''));\n-        expect(() => compiler.compileModuleSync(SomeModule))\n-            .toThrowError(`Can't compile synchronously as ${\n-                stringify(SomeCompWithUrlTemplate)} is still being loaded!`);\n-      });\n-\n-      it('should throw when using a templateUrl in a nested component that has not been compiled before',\n-         () => {\n-           @NgModule({declarations: [SomeComp, ChildComp], entryComponents: [SomeComp]})\n-           class SomeModule {\n-           }\n-\n-           resourceLoader.get.and.callFake(() => Promise.resolve(''));\n-           dirResolver.setDirective(SomeComp, new Component({selector: 'some-cmp', template: ''}));\n-           dirResolver.setDirective(\n-               ChildComp, new Component({selector: 'child-cmp', templateUrl: '/someTpl.html'}));\n-           expect(() => compiler.compileModuleSync(SomeModule))\n-               .toThrowError(\n-                   `Can't compile synchronously as ${stringify(ChildComp)} is still being loaded!`);\n-         });\n-\n-      it('should allow to use templateUrl components that have been loaded before',\n-         fakeAsync(() => {\n-           @NgModule({\n-             declarations: [SomeCompWithUrlTemplate],\n-             entryComponents: [SomeCompWithUrlTemplate]\n-           })\n-           class SomeModule {\n-           }\n-\n-           resourceLoader.get.and.callFake(() => Promise.resolve('hello'));\n-           compiler.compileModuleAsync(SomeModule);\n-           tick();\n-\n-           const ngModuleFactory = compiler.compileModuleSync(SomeModule);\n-           expect(ngModuleFactory).toBeTruthy();\n-         }));\n-    });\n-  });\n-}"
        },
        {
            "sha": "af9b5c903c1c68f468ab0e473d10633435eb9048",
            "filename": "packages/compiler/test/selector/BUILD.bazel",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Fselector%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Fselector%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fselector%2FBUILD.bazel?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -6,11 +6,7 @@ ts_library(\n     srcs = glob([\"**/*.ts\"]),\n     deps = [\n         \"//packages:types\",\n-        \"//packages/common\",\n         \"//packages/compiler\",\n-        \"//packages/compiler/testing\",\n-        \"//packages/core/testing\",\n-        \"//packages/platform-browser\",\n         \"//packages/platform-browser/testing\",\n     ],\n )"
        },
        {
            "sha": "084e4a062e6b3433fdca831f79a62af279e28de5",
            "filename": "packages/compiler/test/selector/selector_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Fselector%2Fselector_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Fselector%2Fselector_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fselector%2Fselector_spec.ts?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -6,7 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {ɵgetDOM as getDOM} from '@angular/common';\n import {CssSelector, SelectorMatcher} from '@angular/compiler/src/selector';\n import {el} from '@angular/platform-browser/testing/src/browser_util';\n "
        },
        {
            "sha": "7d8ae14eeebb36fa09e4ea16fd864be87354ed39",
            "filename": "packages/compiler/test/template_parser/binding_parser_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 62,
            "changes": 62,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Fbinding_parser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Fbinding_parser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Fbinding_parser_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,62 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {SecurityContext} from '@angular/core';\n-import {inject} from '@angular/core/testing';\n-\n-import {ElementSchemaRegistry} from '../../src/schema/element_schema_registry';\n-import {calcPossibleSecurityContexts} from '../../src/template_parser/binding_parser';\n-\n-{\n-  describe('BindingParser', () => {\n-    let registry: ElementSchemaRegistry;\n-\n-    beforeEach(inject([ElementSchemaRegistry], (_registry: ElementSchemaRegistry) => {\n-      registry = _registry;\n-    }));\n-\n-    describe('possibleSecurityContexts', () => {\n-      function hrefSecurityContexts(selector: string) {\n-        return calcPossibleSecurityContexts(registry, selector, 'href', false);\n-      }\n-\n-      it('should return a single security context if the selector as an element name', () => {\n-        expect(hrefSecurityContexts('a')).toEqual([SecurityContext.URL]);\n-      });\n-\n-      it('should return the possible security contexts if the selector has no element name', () => {\n-        expect(hrefSecurityContexts('[myDir]')).toEqual([\n-          SecurityContext.NONE, SecurityContext.URL, SecurityContext.RESOURCE_URL\n-        ]);\n-      });\n-\n-      it('should exclude possible elements via :not', () => {\n-        expect(hrefSecurityContexts('[myDir]:not(link):not(base)')).toEqual([\n-          SecurityContext.NONE, SecurityContext.URL\n-        ]);\n-      });\n-\n-      it('should not exclude possible narrowed elements via :not', () => {\n-        expect(hrefSecurityContexts('[myDir]:not(link.someClass):not(base.someClass)')).toEqual([\n-          SecurityContext.NONE, SecurityContext.URL, SecurityContext.RESOURCE_URL\n-        ]);\n-      });\n-\n-      it('should return SecurityContext.NONE if there are no possible elements', () => {\n-        expect(hrefSecurityContexts('img:not(img)')).toEqual([SecurityContext.NONE]);\n-      });\n-\n-      it('should return the union of the possible security contexts if multiple selectors are specified',\n-         () => {\n-           expect(calcPossibleSecurityContexts(registry, 'a,link', 'href', false)).toEqual([\n-             SecurityContext.URL, SecurityContext.RESOURCE_URL\n-           ]);\n-         });\n-    });\n-  });\n-}"
        },
        {
            "sha": "a218282ae4acdfd24183d3846b9d12eb6ac43ff7",
            "filename": "packages/compiler/test/template_parser/template_parser_absolute_span_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 367,
            "changes": 367,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Ftemplate_parser_absolute_span_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Ftemplate_parser_absolute_span_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Ftemplate_parser_absolute_span_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,367 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {AbsoluteSourceSpan, CompileDirectiveSummary, CompilePipeMetadata, CompilePipeSummary, SchemaMetadata} from '@angular/compiler';\n-import {TemplateAst} from '@angular/compiler/src/template_parser/template_ast';\n-import {TemplateParser} from '@angular/compiler/src/template_parser/template_parser';\n-import {inject} from '@angular/core/testing';\n-\n-import {humanizeExpressionSource} from './util/expression';\n-import {compileDirectiveMetadataCreate, compileTemplateMetadata, createTypeMeta} from './util/metadata';\n-\n-describe('expression AST absolute source spans', () => {\n-  const fakeTemplate = compileTemplateMetadata({animations: []});\n-  const fakeComponent = compileDirectiveMetadataCreate({\n-    isHost: false,\n-    selector: 'app-fake',\n-    template: fakeTemplate,\n-    type: createTypeMeta({reference: {filePath: 'fake-path', name: 'FakeComponent'}}),\n-    isComponent: true\n-  });\n-  const ngIf = compileDirectiveMetadataCreate({\n-                 selector: '[ngIf]',\n-                 template: fakeTemplate,\n-                 type: createTypeMeta({reference: {filePath: 'fake-path', name: 'NgIf'}}),\n-                 inputs: ['ngIf']\n-               }).toSummary();\n-  let parse: (\n-      template: string, directives?: CompileDirectiveSummary[], pipes?: CompilePipeSummary[],\n-      schemas?: SchemaMetadata[], preserveWhitespaces?: boolean) => TemplateAst[];\n-\n-  beforeEach(inject([TemplateParser], (parser: TemplateParser) => {\n-    parse =\n-        (template: string, directives: CompileDirectiveSummary[] = [],\n-         pipes: CompilePipeSummary[]|null = null, schemas: SchemaMetadata[] = [],\n-         preserveWhitespaces = true): TemplateAst[] => {\n-          if (pipes === null) {\n-            pipes = [];\n-          }\n-          return parser\n-              .parse(\n-                  fakeComponent, template, directives, pipes, schemas, 'TestComponent',\n-                  preserveWhitespaces)\n-              .template;\n-        };\n-  }));\n-\n-  it('should provide absolute offsets of an expression in a bound text', () => {\n-    expect(humanizeExpressionSource(parse('<div>{{foo}}</div>'))).toContain([\n-      '{{ foo }}', new AbsoluteSourceSpan(5, 12)\n-    ]);\n-  });\n-\n-  it('should provide absolute offsets of an expression in a bound event', () => {\n-    expect(humanizeExpressionSource(parse('<div (click)=\"foo();bar();\"></div>'))).toContain([\n-      'foo(); bar();', new AbsoluteSourceSpan(14, 26)\n-    ]);\n-\n-    expect(humanizeExpressionSource(parse('<div on-click=\"foo();bar();\"></div>'))).toContain([\n-      'foo(); bar();', new AbsoluteSourceSpan(15, 27)\n-    ]);\n-  });\n-\n-  it('should provide absolute offsets of an expression in a bound attribute', () => {\n-    expect(humanizeExpressionSource(parse('<input [disabled]=\"condition ? true : false\" />')))\n-        .toContain(['condition ? true : false', new AbsoluteSourceSpan(19, 43)]);\n-\n-    expect(humanizeExpressionSource(parse('<input bind-disabled=\"condition ? true : false\" />')))\n-        .toContain(['condition ? true : false', new AbsoluteSourceSpan(22, 46)]);\n-  });\n-\n-  it('should provide absolute offsets of an expression in a template attribute', () => {\n-    const ngTemplate =\n-        compileDirectiveMetadataCreate({\n-          selector: 'ng-template',\n-          type: createTypeMeta({reference: {filePath: 'fake-path', name: 'OnTemplate'}})\n-        }).toSummary();\n-\n-    expect(humanizeExpressionSource(parse('<div *ngIf=\"value\"></div>', [ngIf, ngTemplate])))\n-        .toContain(['value', new AbsoluteSourceSpan(12, 17)]);\n-  });\n-\n-  describe('binary expression', () => {\n-    it('should provide absolute offsets of a binary expression', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{1 + 2}}<div>'))).toContain([\n-        '1 + 2', new AbsoluteSourceSpan(7, 12)\n-      ]);\n-    });\n-\n-    it('should provide absolute offsets of expressions in a binary expression', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{1 + 2}}<div>')))\n-          .toEqual(jasmine.arrayContaining([\n-            ['1', new AbsoluteSourceSpan(7, 8)],\n-            ['2', new AbsoluteSourceSpan(11, 12)],\n-          ]));\n-    });\n-  });\n-\n-  describe('conditional', () => {\n-    it('should provide absolute offsets of a conditional', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{bool ? 1 : 0}}<div>'))).toContain([\n-        'bool ? 1 : 0', new AbsoluteSourceSpan(7, 19)\n-      ]);\n-    });\n-\n-    it('should provide absolute offsets of expressions in a conditional', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{bool ? 1 : 0}}<div>')))\n-          .toEqual(jasmine.arrayContaining([\n-            ['bool', new AbsoluteSourceSpan(7, 11)],\n-            ['1', new AbsoluteSourceSpan(14, 15)],\n-            ['0', new AbsoluteSourceSpan(18, 19)],\n-          ]));\n-    });\n-  });\n-\n-  describe('chain', () => {\n-    it('should provide absolute offsets of a chain', () => {\n-      expect(humanizeExpressionSource(parse('<div (click)=\"a(); b();\"><div>'))).toContain([\n-        'a(); b();', new AbsoluteSourceSpan(14, 23)\n-      ]);\n-    });\n-\n-    it('should provide absolute offsets of expressions in a chain', () => {\n-      expect(humanizeExpressionSource(parse('<div (click)=\"a(); b();\"><div>')))\n-          .toEqual(jasmine.arrayContaining([\n-            ['a()', new AbsoluteSourceSpan(14, 17)],\n-            ['b()', new AbsoluteSourceSpan(19, 22)],\n-          ]));\n-    });\n-  });\n-\n-  describe('function call', () => {\n-    it('should provide absolute offsets of a function call', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{fn()()}}<div>'))).toContain([\n-        'fn()()', new AbsoluteSourceSpan(7, 13)\n-      ]);\n-    });\n-\n-    it('should provide absolute offsets of expressions in a function call', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{fn()(param)}}<div>'))).toContain([\n-        'param', new AbsoluteSourceSpan(12, 17)\n-      ]);\n-    });\n-  });\n-\n-  it('should provide absolute offsets of an implicit receiver', () => {\n-    expect(humanizeExpressionSource(parse('<div>{{a.b}}<div>'))).toContain([\n-      '', new AbsoluteSourceSpan(7, 7)\n-    ]);\n-  });\n-\n-  describe('interpolation', () => {\n-    it('should provide absolute offsets of an interpolation', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{1 + foo.length}}<div>'))).toContain([\n-        '{{ 1 + foo.length }}', new AbsoluteSourceSpan(5, 23)\n-      ]);\n-    });\n-\n-    it('should provide absolute offsets of expressions in an interpolation', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{1 + 2}}<div>')))\n-          .toEqual(jasmine.arrayContaining([\n-            ['1', new AbsoluteSourceSpan(7, 8)],\n-            ['2', new AbsoluteSourceSpan(11, 12)],\n-          ]));\n-    });\n-  });\n-\n-  describe('keyed read', () => {\n-    it('should provide absolute offsets of a keyed read', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{obj[key]}}<div>'))).toContain([\n-        'obj[key]', new AbsoluteSourceSpan(7, 15)\n-      ]);\n-    });\n-\n-    it('should provide absolute offsets of expressions in a keyed read', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{obj[key]}}<div>'))).toContain([\n-        'key', new AbsoluteSourceSpan(11, 14)\n-      ]);\n-    });\n-  });\n-\n-  describe('keyed write', () => {\n-    it('should provide absolute offsets of a keyed write', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{obj[key] = 0}}<div>'))).toContain([\n-        'obj[key] = 0', new AbsoluteSourceSpan(7, 19)\n-      ]);\n-    });\n-\n-    it('should provide absolute offsets of expressions in a keyed write', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{obj[key] = 0}}<div>')))\n-          .toEqual(jasmine.arrayContaining([\n-            ['key', new AbsoluteSourceSpan(11, 14)],\n-            ['0', new AbsoluteSourceSpan(18, 19)],\n-          ]));\n-    });\n-  });\n-\n-  it('should provide absolute offsets of a literal primitive', () => {\n-    expect(humanizeExpressionSource(parse('<div>{{100}}<div>'))).toContain([\n-      '100', new AbsoluteSourceSpan(7, 10)\n-    ]);\n-  });\n-\n-  describe('literal array', () => {\n-    it('should provide absolute offsets of a literal array', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{[0, 1, 2]}}<div>'))).toContain([\n-        '[0, 1, 2]', new AbsoluteSourceSpan(7, 16)\n-      ]);\n-    });\n-\n-    it('should provide absolute offsets of expressions in a literal array', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{[0, 1, 2]}}<div>')))\n-          .toEqual(jasmine.arrayContaining([\n-            ['0', new AbsoluteSourceSpan(8, 9)],\n-            ['1', new AbsoluteSourceSpan(11, 12)],\n-            ['2', new AbsoluteSourceSpan(14, 15)],\n-          ]));\n-    });\n-  });\n-\n-  describe('literal map', () => {\n-    it('should provide absolute offsets of a literal map', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{ {a: 0} }}<div>'))).toContain([\n-        '{a: 0}', new AbsoluteSourceSpan(8, 14)\n-      ]);\n-    });\n-\n-    it('should provide absolute offsets of expressions in a literal map', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{ {a: 0} }}<div>')))\n-          .toEqual(jasmine.arrayContaining([\n-            ['0', new AbsoluteSourceSpan(12, 13)],\n-          ]));\n-    });\n-  });\n-\n-  describe('method call', () => {\n-    it('should provide absolute offsets of a method call', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{method()}}</div>'))).toContain([\n-        'method()', new AbsoluteSourceSpan(7, 15)\n-      ]);\n-    });\n-\n-    it('should provide absolute offsets of expressions in a method call', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{method(param)}}<div>'))).toContain([\n-        'param', new AbsoluteSourceSpan(14, 19)\n-      ]);\n-    });\n-  });\n-\n-  describe('non-null assert', () => {\n-    it('should provide absolute offsets of a non-null assert', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{prop!}}</div>'))).toContain([\n-        'prop!', new AbsoluteSourceSpan(7, 12)\n-      ]);\n-    });\n-\n-    it('should provide absolute offsets of expressions in a non-null assert', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{prop!}}<div>'))).toContain([\n-        'prop', new AbsoluteSourceSpan(7, 11)\n-      ]);\n-    });\n-  });\n-\n-  describe('pipe', () => {\n-    const testPipe = new CompilePipeMetadata({\n-                       name: 'test',\n-                       type: createTypeMeta({reference: {filePath: 'fake-path', name: 'TestPipe'}}),\n-                       pure: false\n-                     }).toSummary();\n-\n-    it('should provide absolute offsets of a pipe', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{prop | test}}<div>', [], [testPipe])))\n-          .toContain(['(prop | test)', new AbsoluteSourceSpan(7, 18)]);\n-    });\n-\n-    it('should provide absolute offsets expressions in a pipe', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{prop | test}}<div>', [], [testPipe])))\n-          .toContain(['prop', new AbsoluteSourceSpan(7, 11)]);\n-    });\n-  });\n-\n-  describe('property read', () => {\n-    it('should provide absolute offsets of a property read', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{prop.obj}}<div>'))).toContain([\n-        'prop.obj', new AbsoluteSourceSpan(7, 15)\n-      ]);\n-    });\n-\n-    it('should provide absolute offsets of expressions in a property read', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{prop.obj}}<div>'))).toContain([\n-        'prop', new AbsoluteSourceSpan(7, 11)\n-      ]);\n-    });\n-  });\n-\n-  describe('property write', () => {\n-    it('should provide absolute offsets of a property write', () => {\n-      expect(humanizeExpressionSource(parse('<div (click)=\"prop = 0\"></div>'))).toContain([\n-        'prop = 0', new AbsoluteSourceSpan(14, 22)\n-      ]);\n-    });\n-\n-    it('should provide absolute offsets of an accessed property write', () => {\n-      expect(humanizeExpressionSource(parse('<div (click)=\"prop.inner = 0\"></div>'))).toContain([\n-        'prop.inner = 0', new AbsoluteSourceSpan(14, 28)\n-      ]);\n-    });\n-\n-    it('should provide absolute offsets of expressions in a property write', () => {\n-      expect(humanizeExpressionSource(parse('<div (click)=\"prop = 0\"></div>'))).toContain([\n-        '0', new AbsoluteSourceSpan(21, 22)\n-      ]);\n-    });\n-  });\n-\n-  describe('\"not\" prefix', () => {\n-    it('should provide absolute offsets of a \"not\" prefix', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{!prop}}</div>'))).toContain([\n-        '!prop', new AbsoluteSourceSpan(7, 12)\n-      ]);\n-    });\n-\n-    it('should provide absolute offsets of expressions in a \"not\" prefix', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{!prop}}<div>'))).toContain([\n-        'prop', new AbsoluteSourceSpan(8, 12)\n-      ]);\n-    });\n-  });\n-\n-  describe('safe method call', () => {\n-    it('should provide absolute offsets of a safe method call', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{prop?.safe()}}<div>'))).toContain([\n-        'prop?.safe()', new AbsoluteSourceSpan(7, 19)\n-      ]);\n-    });\n-\n-    it('should provide absolute offsets of expressions in safe method call', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{prop?.safe()}}<div>'))).toContain([\n-        'prop', new AbsoluteSourceSpan(7, 11)\n-      ]);\n-    });\n-  });\n-\n-  describe('safe property read', () => {\n-    it('should provide absolute offsets of a safe property read', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{prop?.safe}}<div>'))).toContain([\n-        'prop?.safe', new AbsoluteSourceSpan(7, 17)\n-      ]);\n-    });\n-\n-    it('should provide absolute offsets of expressions in safe property read', () => {\n-      expect(humanizeExpressionSource(parse('<div>{{prop?.safe}}<div>'))).toContain([\n-        'prop', new AbsoluteSourceSpan(7, 11)\n-      ]);\n-    });\n-  });\n-\n-  it('should provide absolute offsets of a quote', () => {\n-    expect(humanizeExpressionSource(parse('<div [class.some-class]=\"a:b\"></div>'))).toContain([\n-      'a:b', new AbsoluteSourceSpan(25, 28)\n-    ]);\n-  });\n-});"
        },
        {
            "sha": "50581c1c1f90abf39647d9ac9e71c0e73f3626b0",
            "filename": "packages/compiler/test/template_parser/template_parser_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 2334,
            "changes": 2334,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Ftemplate_parser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Ftemplate_parser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Ftemplate_parser_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,2334 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import {preserveWhitespacesDefault} from '@angular/compiler';\n-import {CompileDiDependencyMetadata, CompileDirectiveMetadata, CompileDirectiveSummary, CompilePipeMetadata, CompilePipeSummary, CompileProviderMetadata, CompileTemplateMetadata, CompileTokenMetadata, tokenReference} from '@angular/compiler/src/compile_metadata';\n-import {DomElementSchemaRegistry} from '@angular/compiler/src/schema/dom_element_schema_registry';\n-import {ElementSchemaRegistry} from '@angular/compiler/src/schema/element_schema_registry';\n-import {AttrAst, BoundDirectivePropertyAst, BoundElementPropertyAst, BoundEventAst, BoundTextAst, DirectiveAst, ElementAst, EmbeddedTemplateAst, NgContentAst, PropertyBindingType, ProviderAstType, ReferenceAst, TemplateAst, TemplateAstVisitor, templateVisitAll, TextAst, VariableAst} from '@angular/compiler/src/template_parser/template_ast';\n-import {splitClasses, TemplateParser} from '@angular/compiler/src/template_parser/template_parser';\n-import {SchemaMetadata, SecurityContext} from '@angular/core';\n-import {Console} from '@angular/core/src/console';\n-import {inject, TestBed} from '@angular/core/testing';\n-import {JitReflector} from '@angular/platform-browser-dynamic/src/compiler_reflector';\n-\n-import {createTokenForExternalReference, createTokenForReference, Identifiers} from '../../src/identifiers';\n-import {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../../src/ml_parser/interpolation_config';\n-import {newArray} from '../../src/util';\n-import {MockSchemaRegistry} from '../../testing';\n-import {unparse} from '../expression_parser/utils/unparser';\n-import {TEST_COMPILER_PROVIDERS} from '../test_bindings';\n-\n-import {compileDirectiveMetadataCreate, compileTemplateMetadata, createTypeMeta} from './util/metadata';\n-\n-const someModuleUrl = 'package:someModule';\n-\n-const MOCK_SCHEMA_REGISTRY = [{\n-  provide: ElementSchemaRegistry,\n-  useValue: new MockSchemaRegistry(\n-      {'invalidProp': false}, {'mappedAttr': 'mappedProp'}, {'unknown': false, 'un-known': false},\n-      ['onEvent'], ['onEvent']),\n-}];\n-\n-\n-function humanizeTplAst(\n-    templateAsts: TemplateAst[], interpolationConfig?: InterpolationConfig): any[] {\n-  const humanizer = new TemplateHumanizer(false, interpolationConfig);\n-  templateVisitAll(humanizer, templateAsts);\n-  return humanizer.result;\n-}\n-\n-function humanizeTplAstSourceSpans(\n-    templateAsts: TemplateAst[], interpolationConfig?: InterpolationConfig): any[] {\n-  const humanizer = new TemplateHumanizer(true, interpolationConfig);\n-  templateVisitAll(humanizer, templateAsts);\n-  return humanizer.result;\n-}\n-\n-class TemplateHumanizer implements TemplateAstVisitor {\n-  result: any[] = [];\n-\n-  constructor(\n-      private includeSourceSpan: boolean,\n-      private interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {}\n-\n-  visitNgContent(ast: NgContentAst, context: any): any {\n-    const res = [NgContentAst];\n-    this.result.push(this._appendSourceSpan(ast, res));\n-    return null;\n-  }\n-  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n-    const res = [EmbeddedTemplateAst];\n-    this.result.push(this._appendSourceSpan(ast, res));\n-    templateVisitAll(this, ast.attrs);\n-    templateVisitAll(this, ast.outputs);\n-    templateVisitAll(this, ast.references);\n-    templateVisitAll(this, ast.variables);\n-    templateVisitAll(this, ast.directives);\n-    templateVisitAll(this, ast.children);\n-    return null;\n-  }\n-  visitElement(ast: ElementAst, context: any): any {\n-    const res = [ElementAst, ast.name];\n-    this.result.push(this._appendSourceSpan(ast, res));\n-    templateVisitAll(this, ast.attrs);\n-    templateVisitAll(this, ast.inputs);\n-    templateVisitAll(this, ast.outputs);\n-    templateVisitAll(this, ast.references);\n-    templateVisitAll(this, ast.directives);\n-    templateVisitAll(this, ast.children);\n-    return null;\n-  }\n-  visitReference(ast: ReferenceAst, context: any): any {\n-    const res = [ReferenceAst, ast.name, ast.value];\n-    this.result.push(this._appendSourceSpan(ast, res));\n-    return null;\n-  }\n-  visitVariable(ast: VariableAst, context: any): any {\n-    const res = [VariableAst, ast.name, ast.value];\n-    this.result.push(this._appendSourceSpan(ast, res));\n-    return null;\n-  }\n-  visitEvent(ast: BoundEventAst, context: any): any {\n-    const res =\n-        [BoundEventAst, ast.name, ast.target, unparse(ast.handler, this.interpolationConfig)];\n-    this.result.push(this._appendSourceSpan(ast, res));\n-    return null;\n-  }\n-  visitElementProperty(ast: BoundElementPropertyAst, context: any): any {\n-    const res = [\n-      BoundElementPropertyAst, ast.type, ast.name, unparse(ast.value, this.interpolationConfig),\n-      ast.unit\n-    ];\n-    this.result.push(this._appendSourceSpan(ast, res));\n-    return null;\n-  }\n-  visitAttr(ast: AttrAst, context: any): any {\n-    const res = [AttrAst, ast.name, ast.value];\n-    this.result.push(this._appendSourceSpan(ast, res));\n-    return null;\n-  }\n-  visitBoundText(ast: BoundTextAst, context: any): any {\n-    const res = [BoundTextAst, unparse(ast.value, this.interpolationConfig)];\n-    this.result.push(this._appendSourceSpan(ast, res));\n-    return null;\n-  }\n-  visitText(ast: TextAst, context: any): any {\n-    const res = [TextAst, ast.value];\n-    this.result.push(this._appendSourceSpan(ast, res));\n-    return null;\n-  }\n-  visitDirective(ast: DirectiveAst, context: any): any {\n-    const res = [DirectiveAst, ast.directive];\n-    this.result.push(this._appendSourceSpan(ast, res));\n-    templateVisitAll(this, ast.inputs);\n-    templateVisitAll(this, ast.hostProperties);\n-    templateVisitAll(this, ast.hostEvents);\n-    return null;\n-  }\n-  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any {\n-    const res = [\n-      BoundDirectivePropertyAst, ast.directiveName, unparse(ast.value, this.interpolationConfig)\n-    ];\n-    this.result.push(this._appendSourceSpan(ast, res));\n-    return null;\n-  }\n-\n-  private _appendSourceSpan(ast: TemplateAst, input: any[]): any[] {\n-    if (!this.includeSourceSpan) return input;\n-    input.push(ast.sourceSpan.toString());\n-    return input;\n-  }\n-}\n-\n-function humanizeContentProjection(templateAsts: TemplateAst[]): any[] {\n-  const humanizer = new TemplateContentProjectionHumanizer();\n-  templateVisitAll(humanizer, templateAsts);\n-  return humanizer.result;\n-}\n-\n-class TemplateContentProjectionHumanizer implements TemplateAstVisitor {\n-  result: any[] = [];\n-  visitNgContent(ast: NgContentAst, context: any): any {\n-    this.result.push(['ng-content', ast.ngContentIndex]);\n-    return null;\n-  }\n-  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n-    this.result.push(['template', ast.ngContentIndex]);\n-    templateVisitAll(this, ast.children);\n-    return null;\n-  }\n-  visitElement(ast: ElementAst, context: any): any {\n-    this.result.push([ast.name, ast.ngContentIndex]);\n-    templateVisitAll(this, ast.children);\n-    return null;\n-  }\n-  visitReference(ast: ReferenceAst, context: any): any {\n-    return null;\n-  }\n-  visitVariable(ast: VariableAst, context: any): any {\n-    return null;\n-  }\n-  visitEvent(ast: BoundEventAst, context: any): any {\n-    return null;\n-  }\n-  visitElementProperty(ast: BoundElementPropertyAst, context: any): any {\n-    return null;\n-  }\n-  visitAttr(ast: AttrAst, context: any): any {\n-    return null;\n-  }\n-  visitBoundText(ast: BoundTextAst, context: any): any {\n-    this.result.push([`#text(${unparse(ast.value)})`, ast.ngContentIndex]);\n-    return null;\n-  }\n-  visitText(ast: TextAst, context: any): any {\n-    this.result.push([`#text(${ast.value})`, ast.ngContentIndex]);\n-    return null;\n-  }\n-  visitDirective(ast: DirectiveAst, context: any): any {\n-    return null;\n-  }\n-  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any {\n-    return null;\n-  }\n-}\n-\n-class ThrowingVisitor implements TemplateAstVisitor {\n-  visitNgContent(ast: NgContentAst, context: any): any {\n-    throw 'not implemented';\n-  }\n-  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n-    throw 'not implemented';\n-  }\n-  visitElement(ast: ElementAst, context: any): any {\n-    throw 'not implemented';\n-  }\n-  visitReference(ast: ReferenceAst, context: any): any {\n-    throw 'not implemented';\n-  }\n-  visitVariable(ast: VariableAst, context: any): any {\n-    throw 'not implemented';\n-  }\n-  visitEvent(ast: BoundEventAst, context: any): any {\n-    throw 'not implemented';\n-  }\n-  visitElementProperty(ast: BoundElementPropertyAst, context: any): any {\n-    throw 'not implemented';\n-  }\n-  visitAttr(ast: AttrAst, context: any): any {\n-    throw 'not implemented';\n-  }\n-  visitBoundText(ast: BoundTextAst, context: any): any {\n-    throw 'not implemented';\n-  }\n-  visitText(ast: TextAst, context: any): any {\n-    throw 'not implemented';\n-  }\n-  visitDirective(ast: DirectiveAst, context: any): any {\n-    throw 'not implemented';\n-  }\n-  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any {\n-    throw 'not implemented';\n-  }\n-}\n-\n-class FooAstTransformer extends ThrowingVisitor {\n-  override visitElement(ast: ElementAst, context: any): any {\n-    if (ast.name != 'div') return ast;\n-    return new ElementAst(\n-        'foo', [], [], [], [], [], [], false, [], [], ast.ngContentIndex, ast.sourceSpan,\n-        ast.endSourceSpan);\n-  }\n-}\n-\n-class BarAstTransformer extends FooAstTransformer {\n-  override visitElement(ast: ElementAst, context: any): any {\n-    if (ast.name != 'foo') return ast;\n-    return new ElementAst(\n-        'bar', [], [], [], [], [], [], false, [], [], ast.ngContentIndex, ast.sourceSpan,\n-        ast.endSourceSpan);\n-  }\n-}\n-\n-class NullVisitor implements TemplateAstVisitor {\n-  visitNgContent(ast: NgContentAst, context: any): any {}\n-  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {}\n-  visitElement(ast: ElementAst, context: any): any {}\n-  visitReference(ast: ReferenceAst, context: any): any {}\n-  visitVariable(ast: VariableAst, context: any): any {}\n-  visitEvent(ast: BoundEventAst, context: any): any {}\n-  visitElementProperty(ast: BoundElementPropertyAst, context: any): any {}\n-  visitAttr(ast: AttrAst, context: any): any {}\n-  visitBoundText(ast: BoundTextAst, context: any): any {}\n-  visitText(ast: TextAst, context: any): any {}\n-  visitDirective(ast: DirectiveAst, context: any): any {}\n-  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any {}\n-}\n-\n-class ArrayConsole implements Console {\n-  logs: string[] = [];\n-  warnings: string[] = [];\n-  log(msg: string) {\n-    this.logs.push(msg);\n-  }\n-  warn(msg: string) {\n-    this.warnings.push(msg);\n-  }\n-}\n-\n-\n-(function() {\n-let ngIf: CompileDirectiveSummary;\n-let parse: (\n-    template: string, directives: CompileDirectiveSummary[], pipes?: CompilePipeSummary[],\n-    schemas?: SchemaMetadata[], preserveWhitespaces?: boolean) => TemplateAst[];\n-let console: ArrayConsole;\n-\n-function configureCompiler() {\n-  console = new ArrayConsole();\n-  beforeEach(() => {\n-    TestBed.configureCompiler({\n-      providers: [\n-        {provide: Console, useValue: console},\n-      ],\n-    });\n-  });\n-}\n-\n-function commonBeforeEach() {\n-  beforeEach(inject([TemplateParser], (parser: TemplateParser) => {\n-    const someAnimation = ['someAnimation'];\n-    const someTemplate = compileTemplateMetadata({animations: [someAnimation]});\n-    const component = compileDirectiveMetadataCreate({\n-      isHost: false,\n-      selector: 'root',\n-      template: someTemplate,\n-      type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'Root'}}),\n-      isComponent: true\n-    });\n-    ngIf = compileDirectiveMetadataCreate({\n-             selector: '[ngIf]',\n-             template: someTemplate,\n-             type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'NgIf'}}),\n-             inputs: ['ngIf']\n-           }).toSummary();\n-\n-    parse =\n-        (template: string, directives: CompileDirectiveSummary[],\n-         pipes: CompilePipeSummary[]|null = null, schemas: SchemaMetadata[] = [],\n-         preserveWhitespaces = true): TemplateAst[] => {\n-          if (pipes === null) {\n-            pipes = [];\n-          }\n-          return parser\n-              .parse(\n-                  component, template, directives, pipes, schemas, 'TestComp', preserveWhitespaces)\n-              .template;\n-        };\n-  }));\n-}\n-\n-describe('TemplateAstVisitor', () => {\n-  function expectVisitedNode(visitor: TemplateAstVisitor, node: TemplateAst) {\n-    expect(node.visit(visitor, null)).toEqual(node);\n-  }\n-\n-  it('should visit NgContentAst', () => {\n-    expectVisitedNode(new class extends NullVisitor {\n-      override visitNgContent(ast: NgContentAst, context: any): any {\n-        return ast;\n-      }\n-    }, new NgContentAst(0, 0, null!));\n-  });\n-\n-  it('should visit EmbeddedTemplateAst', () => {\n-    expectVisitedNode(new class extends NullVisitor {\n-      override visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any) {\n-        return ast;\n-      }\n-    }, new EmbeddedTemplateAst([], [], [], [], [], [], false, [], [], 0, null!));\n-  });\n-\n-  it('should visit ElementAst', () => {\n-    expectVisitedNode(new class extends NullVisitor {\n-      override visitElement(ast: ElementAst, context: any) {\n-        return ast;\n-      }\n-    }, new ElementAst('foo', [], [], [], [], [], [], false, [], [], 0, null!, null!));\n-  });\n-\n-  it('should visit RefererenceAst', () => {\n-    expectVisitedNode(new class extends NullVisitor {\n-      override visitReference(ast: ReferenceAst, context: any): any {\n-        return ast;\n-      }\n-    }, new ReferenceAst('foo', null!, null!, null!));\n-  });\n-\n-  it('should visit VariableAst', () => {\n-    expectVisitedNode(new class extends NullVisitor {\n-      override visitVariable(ast: VariableAst, context: any): any {\n-        return ast;\n-      }\n-    }, new VariableAst('foo', 'bar', null!));\n-  });\n-\n-  it('should visit BoundEventAst', () => {\n-    expectVisitedNode(new class extends NullVisitor {\n-      override visitEvent(ast: BoundEventAst, context: any): any {\n-        return ast;\n-      }\n-    }, new BoundEventAst('foo', 'bar', 'goo', null!, null!, null!));\n-  });\n-\n-  it('should visit BoundElementPropertyAst', () => {\n-    expectVisitedNode(new class extends NullVisitor {\n-      override visitElementProperty(ast: BoundElementPropertyAst, context: any): any {\n-        return ast;\n-      }\n-    }, new BoundElementPropertyAst('foo', null!, null!, null!, 'bar', null!));\n-  });\n-\n-  it('should visit AttrAst', () => {\n-    expectVisitedNode(new class extends NullVisitor {\n-      override visitAttr(ast: AttrAst, context: any): any {\n-        return ast;\n-      }\n-    }, new AttrAst('foo', 'bar', null!));\n-  });\n-\n-  it('should visit BoundTextAst', () => {\n-    expectVisitedNode(new class extends NullVisitor {\n-      override visitBoundText(ast: BoundTextAst, context: any): any {\n-        return ast;\n-      }\n-    }, new BoundTextAst(null!, 0, null!));\n-  });\n-\n-  it('should visit TextAst', () => {\n-    expectVisitedNode(new class extends NullVisitor {\n-      override visitText(ast: TextAst, context: any): any {\n-        return ast;\n-      }\n-    }, new TextAst('foo', 0, null!));\n-  });\n-\n-  it('should visit DirectiveAst', () => {\n-    expectVisitedNode(new class extends NullVisitor {\n-      override visitDirective(ast: DirectiveAst, context: any): any {\n-        return ast;\n-      }\n-    }, new DirectiveAst(null!, [], [], [], 0, null!));\n-  });\n-\n-  it('should visit DirectiveAst', () => {\n-    expectVisitedNode(new class extends NullVisitor {\n-      override visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any {\n-        return ast;\n-      }\n-    }, new BoundDirectivePropertyAst('foo', 'bar', null!, null!));\n-  });\n-\n-  it('should skip the typed call of a visitor if visit() returns a truthy value', () => {\n-    const visitor = new class extends ThrowingVisitor {\n-      visit(ast: TemplateAst, context: any): any {\n-        return true;\n-      }\n-    };\n-    const nodes: TemplateAst[] = [\n-      new NgContentAst(0, 0, null!),\n-      new EmbeddedTemplateAst([], [], [], [], [], [], false, [], [], 0, null!),\n-      new ElementAst('foo', [], [], [], [], [], [], false, [], [], 0, null!, null!),\n-      new ReferenceAst('foo', null!, 'bar', null!), new VariableAst('foo', 'bar', null!),\n-      new BoundEventAst('foo', 'bar', 'goo', null!, null!, null!),\n-      new BoundElementPropertyAst('foo', null!, null!, null!, 'bar', null!),\n-      new AttrAst('foo', 'bar', null!), new BoundTextAst(null!, 0, null!),\n-      new TextAst('foo', 0, null!), new DirectiveAst(null!, [], [], [], 0, null!),\n-      new BoundDirectivePropertyAst('foo', 'bar', null!, null!)\n-    ];\n-    const result = templateVisitAll(visitor, nodes, null);\n-    expect(result).toEqual(newArray(nodes.length).fill(true));\n-  });\n-});\n-\n-describe('TemplateParser Security', () => {\n-  // Semi-integration test to make sure TemplateParser properly sets the security context.\n-  // Uses the actual DomElementSchemaRegistry.\n-  beforeEach(() => {\n-    TestBed.configureCompiler({\n-      providers: [\n-        TEST_COMPILER_PROVIDERS,\n-        {provide: ElementSchemaRegistry, useClass: DomElementSchemaRegistry, deps: []}\n-      ]\n-    });\n-  });\n-\n-  configureCompiler();\n-  commonBeforeEach();\n-\n-  describe('security context', () => {\n-    function secContext(tpl: string): SecurityContext {\n-      const ast = parse(tpl, []);\n-      const propBinding = (<ElementAst>ast[0]).inputs[0];\n-      return propBinding.securityContext;\n-    }\n-\n-    it('should set for properties', () => {\n-      expect(secContext('<div [title]=\"v\">')).toBe(SecurityContext.NONE);\n-      expect(secContext('<div [innerHTML]=\"v\">')).toBe(SecurityContext.HTML);\n-    });\n-    it('should set for property value bindings', () => {\n-      expect(secContext('<div innerHTML=\"{{v}}\">')).toBe(SecurityContext.HTML);\n-    });\n-    it('should set for attributes', () => {\n-      expect(secContext('<a [attr.href]=\"v\">')).toBe(SecurityContext.URL);\n-      // NB: attributes below need to change case.\n-      expect(secContext('<a [attr.innerHtml]=\"v\">')).toBe(SecurityContext.HTML);\n-      expect(secContext('<a [attr.formaction]=\"v\">')).toBe(SecurityContext.URL);\n-    });\n-    it('should set for style', () => {\n-      expect(secContext('<a [style.backgroundColor]=\"v\">')).toBe(SecurityContext.STYLE);\n-    });\n-  });\n-});\n-\n-describe('TemplateParser', () => {\n-  beforeEach(() => {\n-    TestBed.configureCompiler({providers: [TEST_COMPILER_PROVIDERS, MOCK_SCHEMA_REGISTRY]});\n-  });\n-\n-  configureCompiler();\n-  commonBeforeEach();\n-\n-  describe('parse', () => {\n-    describe('nodes without bindings', () => {\n-      it('should parse text nodes', () => {\n-        expect(humanizeTplAst(parse('a', []))).toEqual([[TextAst, 'a']]);\n-      });\n-\n-      it('should parse elements with attributes', () => {\n-        expect(humanizeTplAst(parse('<div a=b>', []))).toEqual([\n-          [ElementAst, 'div'], [AttrAst, 'a', 'b']\n-        ]);\n-      });\n-    });\n-\n-    it('should parse ngContent', () => {\n-      const parsed = parse('<ng-content select=\"a\"></ng-content>', []);\n-      expect(humanizeTplAst(parsed)).toEqual([[NgContentAst]]);\n-    });\n-\n-    it('should parse ngContent when it contains WS only', () => {\n-      const parsed = parse('<ng-content select=\"a\">    \\n   </ng-content>', []);\n-      expect(humanizeTplAst(parsed)).toEqual([[NgContentAst]]);\n-    });\n-\n-    it('should parse ngContent regardless the namespace', () => {\n-      const parsed = parse('<svg><ng-content></ng-content></svg>', []);\n-      expect(humanizeTplAst(parsed)).toEqual([\n-        [ElementAst, ':svg:svg'],\n-        [NgContentAst],\n-      ]);\n-    });\n-\n-    it('should parse bound text nodes', () => {\n-      expect(humanizeTplAst(parse('{{a}}', []))).toEqual([[BoundTextAst, '{{ a }}']]);\n-    });\n-\n-    it('should parse bound text nodes inside quotes', () => {\n-      expect(humanizeTplAst(parse('\"{{a}}\"', []))).toEqual([[BoundTextAst, '\"{{ a }}\"']]);\n-    });\n-\n-    it('should parse bound text nodes with interpolations inside quotes', () => {\n-      expect(humanizeTplAst(parse('{{ \"{{a}}\" }}', []))).toEqual([[BoundTextAst, '{{ \"{{a}}\" }}']]);\n-      expect(humanizeTplAst(parse('{{\"{{\"}}', []))).toEqual([[BoundTextAst, '{{ \"{{\" }}']]);\n-      expect(humanizeTplAst(parse('{{\"}}\"}}', []))).toEqual([[BoundTextAst, '{{ \"}}\" }}']]);\n-      expect(humanizeTplAst(parse('{{\"{\"}}', []))).toEqual([[BoundTextAst, '{{ \"{\" }}']]);\n-      expect(humanizeTplAst(parse('{{\"}\"}}', []))).toEqual([[BoundTextAst, '{{ \"}\" }}']]);\n-    });\n-\n-    it('should parse bound text nodes with escaped quotes', () => {\n-      expect(humanizeTplAst(parse(`{{'It\\\\'s just Angular'}}`, []))).toEqual([\n-        [BoundTextAst, `{{ \"It's just Angular\" }}`]\n-      ]);\n-\n-      expect(humanizeTplAst(parse(`{{'It\\\\'s {{ just Angular'}}`, []))).toEqual([\n-        [BoundTextAst, `{{ \"It's {{ just Angular\" }}`]\n-      ]);\n-\n-      expect(humanizeTplAst(parse(`{{'It\\\\'s }} just Angular'}}`, []))).toEqual([\n-        [BoundTextAst, `{{ \"It's }} just Angular\" }}`]\n-      ]);\n-    });\n-\n-    it('should not parse bound text nodes with mismatching quotes', () => {\n-      expect(humanizeTplAst(parse(`{{ \"{{a}}' }}`, []))).toEqual([[TextAst, `{{ \"{{a}}' }}`]]);\n-    });\n-\n-    it('should parse interpolation with escaped backslashes', () => {\n-      expect(humanizeTplAst(parse(`{{foo.split('\\\\\\\\')}}`, []))).toEqual([\n-        [BoundTextAst, `{{ foo.split(\"\\\\\") }}`]\n-      ]);\n-      expect(humanizeTplAst(parse(`{{foo.split('\\\\\\\\\\\\\\\\')}}`, []))).toEqual([\n-        [BoundTextAst, `{{ foo.split(\"\\\\\\\\\") }}`]\n-      ]);\n-      expect(humanizeTplAst(parse(`{{foo.split('\\\\\\\\\\\\\\\\\\\\\\\\')}}`, []))).toEqual([\n-        [BoundTextAst, `{{ foo.split(\"\\\\\\\\\\\\\") }}`]\n-      ]);\n-    });\n-\n-    it('should ignore quotes inside a comment', () => {\n-      expect(humanizeTplAst(parse(`\"{{name // \" }}\"`, []))).toEqual([\n-        [BoundTextAst, `\"{{ name }}\"`]\n-      ]);\n-    });\n-\n-    it('should parse with custom interpolation config',\n-       inject([TemplateParser], (parser: TemplateParser) => {\n-         const component = CompileDirectiveMetadata.create({\n-           selector: 'test',\n-           type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'Test'}}),\n-           isComponent: true,\n-           template: new CompileTemplateMetadata({\n-             interpolation: ['{%', '%}'],\n-             isInline: false,\n-             animations: [],\n-             template: null,\n-             templateUrl: null,\n-             htmlAst: null,\n-             ngContentSelectors: [],\n-             externalStylesheets: [],\n-             styleUrls: [],\n-             styles: [],\n-             encapsulation: null,\n-             preserveWhitespaces: preserveWhitespacesDefault(null),\n-           }),\n-           isHost: false,\n-           exportAs: null,\n-           changeDetection: null,\n-           inputs: [],\n-           outputs: [],\n-           host: {},\n-           providers: [],\n-           viewProviders: [],\n-           queries: [],\n-           guards: {},\n-           viewQueries: [],\n-           entryComponents: [],\n-           componentViewType: null,\n-           rendererType: null,\n-           componentFactory: null\n-\n-         });\n-         expect(humanizeTplAst(\n-                    parser.parse(component, '{%a%}', [], [], [], 'TestComp', true).template,\n-                    {start: '{%', end: '%}'}))\n-             .toEqual([[BoundTextAst, '{% a %}']]);\n-       }));\n-\n-    describe('bound properties', () => {\n-      it('should parse mixed case bound properties', () => {\n-        expect(humanizeTplAst(parse('<div [someProp]=\"v\">', []))).toEqual([\n-          [ElementAst, 'div'],\n-          [BoundElementPropertyAst, PropertyBindingType.Property, 'someProp', 'v', null]\n-        ]);\n-      });\n-\n-      it('should parse dash case bound properties', () => {\n-        expect(humanizeTplAst(parse('<div [some-prop]=\"v\">', []))).toEqual([\n-          [ElementAst, 'div'],\n-          [BoundElementPropertyAst, PropertyBindingType.Property, 'some-prop', 'v', null]\n-        ]);\n-      });\n-\n-      it('should parse dotted name bound properties', () => {\n-        expect(humanizeTplAst(parse('<div [dot.name]=\"v\">', []))).toEqual([\n-          [ElementAst, 'div'],\n-          [BoundElementPropertyAst, PropertyBindingType.Property, 'dot.name', 'v', null]\n-        ]);\n-      });\n-\n-      it('should normalize property names via the element schema', () => {\n-        expect(humanizeTplAst(parse('<div [mappedAttr]=\"v\">', []))).toEqual([\n-          [ElementAst, 'div'],\n-          [BoundElementPropertyAst, PropertyBindingType.Property, 'mappedProp', 'v', null]\n-        ]);\n-      });\n-\n-      it('should parse mixed case bound attributes', () => {\n-        expect(humanizeTplAst(parse('<div [attr.someAttr]=\"v\">', []))).toEqual([\n-          [ElementAst, 'div'],\n-          [BoundElementPropertyAst, PropertyBindingType.Attribute, 'someAttr', 'v', null]\n-        ]);\n-      });\n-\n-      it('should parse mixed case bound attributes with dot in the attribute name', () => {\n-        expect(humanizeTplAst(parse('<div [attr.someAttr.someAttrSuffix]=\"v\">', []))).toEqual([\n-          [ElementAst, 'div'],\n-          [\n-            BoundElementPropertyAst, PropertyBindingType.Attribute, 'someAttr.someAttrSuffix', 'v',\n-            null\n-          ]\n-        ]);\n-      });\n-\n-      it('should parse and dash case bound classes', () => {\n-        expect(humanizeTplAst(parse('<div [class.some-class]=\"v\">', []))).toEqual([\n-          [ElementAst, 'div'],\n-          [BoundElementPropertyAst, PropertyBindingType.Class, 'some-class', 'v', null]\n-        ]);\n-      });\n-\n-      it('should parse mixed case bound classes', () => {\n-        expect(humanizeTplAst(parse('<div [class.someClass]=\"v\">', []))).toEqual([\n-          [ElementAst, 'div'],\n-          [BoundElementPropertyAst, PropertyBindingType.Class, 'someClass', 'v', null]\n-        ]);\n-      });\n-\n-      it('should parse mixed case bound styles', () => {\n-        expect(humanizeTplAst(parse('<div [style.someStyle]=\"v\">', []))).toEqual([\n-          [ElementAst, 'div'],\n-          [BoundElementPropertyAst, PropertyBindingType.Style, 'someStyle', 'v', null]\n-        ]);\n-      });\n-\n-      describe('errors', () => {\n-        it('should throw error when binding to an unknown property', () => {\n-          expect(() => parse('<my-component [invalidProp]=\"bar\"></my-component>', []))\n-              .toThrowError(`Template parse errors:\n-Can't bind to 'invalidProp' since it isn't a known property of 'my-component'.\n-1. If 'my-component' is an Angular component and it has 'invalidProp' input, then verify that it is part of this module.\n-2. If 'my-component' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\n-3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component. (\"<my-component [ERROR ->][invalidProp]=\"bar\"></my-component>\"): TestComp@0:14`);\n-        });\n-\n-        it('should throw error when binding to an unknown property of ng-container', () => {\n-          expect(() => parse('<ng-container [invalidProp]=\"bar\"></ng-container>', []))\n-              .toThrowError(\n-                  `Template parse errors:\n-Can't bind to 'invalidProp' since it isn't a known property of 'ng-container'.\n-1. If 'invalidProp' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.\n-2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.` +\n-                  ` (\"<ng-container [ERROR ->][invalidProp]=\"bar\"></ng-container>\"): TestComp@0:14`);\n-        });\n-\n-        it('should throw error when binding to an unknown element w/o bindings', () => {\n-          expect(() => parse('<unknown></unknown>', [])).toThrowError(`Template parse errors:\n-'unknown' is not a known element:\n-1. If 'unknown' is an Angular component, then verify that it is part of this module.\n-2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component. (\"[ERROR ->]<unknown></unknown>\"): TestComp@0:0`);\n-        });\n-\n-        it('should throw error when binding to an unknown custom element w/o bindings', () => {\n-          expect(() => parse('<un-known></un-known>', [])).toThrowError(`Template parse errors:\n-'un-known' is not a known element:\n-1. If 'un-known' is an Angular component, then verify that it is part of this module.\n-2. If 'un-known' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message. (\"[ERROR ->]<un-known></un-known>\"): TestComp@0:0`);\n-        });\n-\n-        it('should throw error when binding to an invalid property', () => {\n-          expect(() => parse('<my-component [onEvent]=\"bar\"></my-component>', []))\n-              .toThrowError(`Template parse errors:\n-Binding to property 'onEvent' is disallowed for security reasons (\"<my-component [ERROR ->][onEvent]=\"bar\"></my-component>\"): TestComp@0:14`);\n-        });\n-\n-        it('should throw error when binding to an invalid attribute', () => {\n-          expect(() => parse('<my-component [attr.onEvent]=\"bar\"></my-component>', []))\n-              .toThrowError(`Template parse errors:\n-Binding to attribute 'onEvent' is disallowed for security reasons (\"<my-component [ERROR ->][attr.onEvent]=\"bar\"></my-component>\"): TestComp@0:14`);\n-        });\n-      });\n-\n-      it('should parse bound properties via [...] and not report them as attributes', () => {\n-        expect(humanizeTplAst(parse('<div [prop]=\"v\">', []))).toEqual([\n-          [ElementAst, 'div'],\n-          [BoundElementPropertyAst, PropertyBindingType.Property, 'prop', 'v', null]\n-        ]);\n-      });\n-\n-      it('should parse bound properties via bind- and not report them as attributes', () => {\n-        expect(humanizeTplAst(parse('<div bind-prop=\"v\">', []))).toEqual([\n-          [ElementAst, 'div'],\n-          [BoundElementPropertyAst, PropertyBindingType.Property, 'prop', 'v', null]\n-        ]);\n-      });\n-\n-      it('should report missing property names in bind- syntax', () => {\n-        expect(() => parse('<div bind-></div>', [])).toThrowError(`Template parse errors:\n-Property name is missing in binding (\"<div [ERROR ->]bind-></div>\"): TestComp@0:5`);\n-      });\n-\n-      it('should parse bound properties via {{...}} and not report them as attributes', () => {\n-        expect(humanizeTplAst(parse('<div prop=\"{{v}}\">', []))).toEqual([\n-          [ElementAst, 'div'],\n-          [BoundElementPropertyAst, PropertyBindingType.Property, 'prop', '{{ v }}', null]\n-        ]);\n-      });\n-\n-      it('should parse bound properties via bind-animate- and not report them as attributes',\n-         () => {\n-           expect(humanizeTplAst(parse('<div bind-animate-someAnimation=\"value2\">', [], [], [])))\n-               .toEqual([\n-                 [ElementAst, 'div'],\n-                 [\n-                   BoundElementPropertyAst, PropertyBindingType.Animation, 'someAnimation',\n-                   'value2', null\n-                 ]\n-               ]);\n-         });\n-\n-      it('should throw an error when parsing detects non-bound properties via @ that contain a value',\n-         () => {\n-           expect(() => {\n-             parse('<div @someAnimation=\"value2\">', [], [], []);\n-           })\n-               .toThrowError(\n-                   /Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid. Use property bindings \\(e.g. \\[@prop\\]=\"exp\"\\) or use an attribute without a value \\(e.g. @prop\\) instead. \\(\"<div \\[ERROR ->\\]@someAnimation=\"value2\">\"\\): TestComp@0:5/);\n-         });\n-\n-      it('should report missing animation trigger in @ syntax', () => {\n-        expect(() => parse('<div @></div>', [])).toThrowError(`Template parse errors:\n-Animation trigger is missing (\"<div [ERROR ->]@></div>\"): TestComp@0:5`);\n-      });\n-\n-      it('should not issue a warning when host attributes contain a valid property-bound animation trigger',\n-         () => {\n-           const animationEntries = ['prop'];\n-           const dirA = compileDirectiveMetadataCreate({\n-                          selector: 'div',\n-                          template: compileTemplateMetadata({animations: animationEntries}),\n-                          type: createTypeMeta({\n-                            reference: {filePath: someModuleUrl, name: 'DirA'},\n-                          }),\n-                          host: {'[@prop]': 'expr'}\n-                        }).toSummary();\n-\n-           humanizeTplAst(parse('<div></div>', [dirA]));\n-           expect(console.warnings.length).toEqual(0);\n-         });\n-\n-      it('should throw descriptive error when a host binding is not a string expression', () => {\n-        const dirA = compileDirectiveMetadataCreate({\n-                       selector: 'broken',\n-                       type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                       host: {'[class.foo]': null!}\n-                     }).toSummary();\n-\n-        expect(() => {\n-          parse('<broken></broken>', [dirA]);\n-        })\n-            .toThrowError(\n-                `Template parse errors:\\nValue of the host property binding \"class.foo\" needs to be a string representing an expression but got \"null\" (object) (\"[ERROR ->]<broken></broken>\"): TestComp@0:0, Directive DirA`);\n-      });\n-\n-      it('should throw descriptive error when a host event is not a string expression', () => {\n-        const dirA = compileDirectiveMetadataCreate({\n-                       selector: 'broken',\n-                       type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                       host: {'(click)': null!}\n-                     }).toSummary();\n-\n-        expect(() => {\n-          parse('<broken></broken>', [dirA]);\n-        })\n-            .toThrowError(\n-                `Template parse errors:\\nValue of the host listener \"click\" needs to be a string representing an expression but got \"null\" (object) (\"[ERROR ->]<broken></broken>\"): TestComp@0:0, Directive DirA`);\n-      });\n-\n-      it('should not issue a warning when an animation property is bound without an expression',\n-         () => {\n-           humanizeTplAst(parse('<div @someAnimation>', [], [], []));\n-           expect(console.warnings.length).toEqual(0);\n-         });\n-\n-      it('should parse bound properties via [@] and not report them as attributes', () => {\n-        expect(humanizeTplAst(parse('<div [@someAnimation]=\"value2\">', [], [], []))).toEqual([\n-          [ElementAst, 'div'],\n-          [BoundElementPropertyAst, PropertyBindingType.Animation, 'someAnimation', 'value2', null]\n-        ]);\n-      });\n-\n-      it('should support * directives', () => {\n-        expect(humanizeTplAst(parse('<div *ngIf>', [ngIf]))).toEqual([\n-          [EmbeddedTemplateAst],\n-          [DirectiveAst, ngIf],\n-          [BoundDirectivePropertyAst, 'ngIf', 'null'],\n-          [ElementAst, 'div'],\n-        ]);\n-      });\n-\n-      it('should support <ng-template>', () => {\n-        expect(humanizeTplAst(parse('<ng-template>', []))).toEqual([\n-          [EmbeddedTemplateAst],\n-        ]);\n-      });\n-\n-      it('should treat <template> as a regular tag', () => {\n-        expect(humanizeTplAst(parse('<template>', []))).toEqual([\n-          [ElementAst, 'template'],\n-        ]);\n-      });\n-\n-      it('should not special case the template attribute', () => {\n-        expect(humanizeTplAst(parse('<p template=\"ngFor\">', []))).toEqual([\n-          [ElementAst, 'p'],\n-          [AttrAst, 'template', 'ngFor'],\n-        ]);\n-      });\n-    });\n-\n-    describe('events', () => {\n-      it('should parse bound events with a target', () => {\n-        expect(humanizeTplAst(parse('<div (window:event)=\"v\">', []))).toEqual([\n-          [ElementAst, 'div'],\n-          [BoundEventAst, 'event', 'window', 'v'],\n-        ]);\n-      });\n-\n-      it('should report an error on empty expression', () => {\n-        expect(() => parse('<div (event)=\"\">', []))\n-            .toThrowError(/Empty expressions are not allowed/);\n-\n-        expect(() => parse('<div (event)=\"  \">', []))\n-            .toThrowError(/Empty expressions are not allowed/);\n-      });\n-\n-      it('should parse bound events via (...) and not report them as attributes', () => {\n-        expect(humanizeTplAst(parse('<div (event)=\"v\">', []))).toEqual([\n-          [ElementAst, 'div'], [BoundEventAst, 'event', null, 'v']\n-        ]);\n-      });\n-\n-      it('should parse event names case sensitive', () => {\n-        expect(humanizeTplAst(parse('<div (some-event)=\"v\">', []))).toEqual([\n-          [ElementAst, 'div'], [BoundEventAst, 'some-event', null, 'v']\n-        ]);\n-        expect(humanizeTplAst(parse('<div (someEvent)=\"v\">', []))).toEqual([\n-          [ElementAst, 'div'], [BoundEventAst, 'someEvent', null, 'v']\n-        ]);\n-      });\n-\n-      it('should parse bound events via on- and not report them as attributes', () => {\n-        expect(humanizeTplAst(parse('<div on-event=\"v\">', []))).toEqual([\n-          [ElementAst, 'div'], [BoundEventAst, 'event', null, 'v']\n-        ]);\n-      });\n-\n-      it('should report missing event names in on- syntax', () => {\n-        expect(() => parse('<div on-></div>', [])).toThrowError(/Event name is missing in binding/);\n-      });\n-\n-      it('should allow events on explicit embedded templates that are emitted by a directive',\n-         () => {\n-           const dirA = compileDirectiveMetadataCreate({\n-                          selector: 'ng-template',\n-                          outputs: ['e'],\n-                          type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}})\n-                        }).toSummary();\n-\n-           expect(humanizeTplAst(parse('<ng-template (e)=\"f\"></ng-template>', [dirA]))).toEqual([\n-             [EmbeddedTemplateAst],\n-             [BoundEventAst, 'e', null, 'f'],\n-             [DirectiveAst, dirA],\n-           ]);\n-         });\n-    });\n-\n-    describe('bindon', () => {\n-      it('should parse bound events and properties via [(...)] and not report them as attributes',\n-         () => {\n-           expect(humanizeTplAst(parse('<div [(prop)]=\"v\">', []))).toEqual([\n-             [ElementAst, 'div'],\n-             [BoundElementPropertyAst, PropertyBindingType.Property, 'prop', 'v', null],\n-             [BoundEventAst, 'propChange', null, 'v = $event']\n-           ]);\n-         });\n-\n-      it('should parse bound events and properties via bindon- and not report them as attributes',\n-         () => {\n-           expect(humanizeTplAst(parse('<div bindon-prop=\"v\">', []))).toEqual([\n-             [ElementAst, 'div'],\n-             [BoundElementPropertyAst, PropertyBindingType.Property, 'prop', 'v', null],\n-             [BoundEventAst, 'propChange', null, 'v = $event']\n-           ]);\n-         });\n-\n-      it('should report missing property names in bindon- syntax', () => {\n-        expect(() => parse('<div bindon-></div>', []))\n-            .toThrowError(/Property name is missing in binding/);\n-      });\n-    });\n-\n-    describe('directives', () => {\n-      it('should order directives by the directives array in the View and match them only once',\n-         () => {\n-           const dirA = compileDirectiveMetadataCreate({\n-                          selector: '[a]',\n-                          type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}})\n-                        }).toSummary();\n-           const dirB = compileDirectiveMetadataCreate({\n-                          selector: '[b]',\n-                          type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirB'}})\n-                        }).toSummary();\n-           const dirC = compileDirectiveMetadataCreate({\n-                          selector: '[c]',\n-                          type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirC'}})\n-                        }).toSummary();\n-           expect(humanizeTplAst(parse('<div a c b a b>', [dirA, dirB, dirC]))).toEqual([\n-             [ElementAst, 'div'], [AttrAst, 'a', ''], [AttrAst, 'c', ''], [AttrAst, 'b', ''],\n-             [AttrAst, 'a', ''], [AttrAst, 'b', ''], [DirectiveAst, dirA], [DirectiveAst, dirB],\n-             [DirectiveAst, dirC]\n-           ]);\n-         });\n-\n-      it('should parse directive dotted properties', () => {\n-        const dirA = compileDirectiveMetadataCreate({\n-                       selector: '[dot.name]',\n-                       type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                       inputs: ['localName: dot.name'],\n-                     }).toSummary();\n-\n-        expect(humanizeTplAst(parse('<div [dot.name]=\"expr\"></div>', [dirA]))).toEqual([\n-          [ElementAst, 'div'],\n-          [DirectiveAst, dirA],\n-          [BoundDirectivePropertyAst, 'localName', 'expr'],\n-        ]);\n-      });\n-\n-      it('should locate directives in property bindings', () => {\n-        const dirA = compileDirectiveMetadataCreate({\n-                       selector: '[a=b]',\n-                       type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}})\n-                     }).toSummary();\n-        const dirB = compileDirectiveMetadataCreate({\n-                       selector: '[b]',\n-                       type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirB'}})\n-                     }).toSummary();\n-        expect(humanizeTplAst(parse('<div [a]=\"b\">', [dirA, dirB]))).toEqual([\n-          [ElementAst, 'div'],\n-          [BoundElementPropertyAst, PropertyBindingType.Property, 'a', 'b', null],\n-          [DirectiveAst, dirA]\n-        ]);\n-      });\n-\n-      it('should locate directives in inline templates', () => {\n-        const dirTemplate =\n-            compileDirectiveMetadataCreate({\n-              selector: 'ng-template',\n-              type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'onTemplate'}})\n-            }).toSummary();\n-        expect(humanizeTplAst(parse('<div *ngIf=\"cond\">', [ngIf, dirTemplate]))).toEqual([\n-          [EmbeddedTemplateAst],\n-          [DirectiveAst, ngIf],\n-          [BoundDirectivePropertyAst, 'ngIf', 'cond'],\n-          [DirectiveAst, dirTemplate],\n-          [ElementAst, 'div'],\n-        ]);\n-      });\n-\n-      it('should locate directives in event bindings', () => {\n-        const dirA = compileDirectiveMetadataCreate({\n-                       selector: '[a]',\n-                       type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirB'}})\n-                     }).toSummary();\n-\n-        expect(humanizeTplAst(parse('<div (a)=\"b\">', [dirA]))).toEqual([\n-          [ElementAst, 'div'], [BoundEventAst, 'a', null, 'b'], [DirectiveAst, dirA]\n-        ]);\n-      });\n-\n-      it('should parse directive host properties', () => {\n-        const dirA = compileDirectiveMetadataCreate({\n-                       selector: 'div',\n-                       type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                       host: {'[a]': 'expr'}\n-                     }).toSummary();\n-        expect(humanizeTplAst(parse('<div></div>', [dirA]))).toEqual([\n-          [ElementAst, 'div'], [DirectiveAst, dirA],\n-          [BoundElementPropertyAst, PropertyBindingType.Property, 'a', 'expr', null]\n-        ]);\n-      });\n-\n-      it('should parse directive host listeners', () => {\n-        const dirA = compileDirectiveMetadataCreate({\n-                       selector: 'div',\n-                       type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                       host: {'(a)': 'expr'}\n-                     }).toSummary();\n-        expect(humanizeTplAst(parse('<div></div>', [dirA]))).toEqual([\n-          [ElementAst, 'div'], [DirectiveAst, dirA], [BoundEventAst, 'a', null, 'expr']\n-        ]);\n-      });\n-\n-      it('should parse directive properties', () => {\n-        const dirA = compileDirectiveMetadataCreate({\n-                       selector: 'div',\n-                       type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                       inputs: ['aProp']\n-                     }).toSummary();\n-        expect(humanizeTplAst(parse('<div [aProp]=\"expr\"></div>', [dirA]))).toEqual([\n-          [ElementAst, 'div'], [DirectiveAst, dirA], [BoundDirectivePropertyAst, 'aProp', 'expr']\n-        ]);\n-      });\n-\n-      it('should parse renamed directive properties', () => {\n-        const dirA = compileDirectiveMetadataCreate({\n-                       selector: 'div',\n-                       type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                       inputs: ['b:a']\n-                     }).toSummary();\n-        expect(humanizeTplAst(parse('<div [a]=\"expr\"></div>', [dirA]))).toEqual([\n-          [ElementAst, 'div'], [DirectiveAst, dirA], [BoundDirectivePropertyAst, 'b', 'expr']\n-        ]);\n-      });\n-\n-      it('should parse literal directive properties', () => {\n-        const dirA = compileDirectiveMetadataCreate({\n-                       selector: 'div',\n-                       type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                       inputs: ['a']\n-                     }).toSummary();\n-        expect(humanizeTplAst(parse('<div a=\"literal\"></div>', [dirA]))).toEqual([\n-          [ElementAst, 'div'], [AttrAst, 'a', 'literal'], [DirectiveAst, dirA],\n-          [BoundDirectivePropertyAst, 'a', '\"literal\"']\n-        ]);\n-      });\n-\n-      it('should favor explicit bound properties over literal properties', () => {\n-        const dirA = compileDirectiveMetadataCreate({\n-                       selector: 'div',\n-                       type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                       inputs: ['a']\n-                     }).toSummary();\n-        expect(humanizeTplAst(parse('<div a=\"literal\" [a]=\"\\'literal2\\'\"></div>', [dirA])))\n-            .toEqual([\n-              [ElementAst, 'div'], [AttrAst, 'a', 'literal'], [DirectiveAst, dirA],\n-              [BoundDirectivePropertyAst, 'a', '\"literal2\"']\n-            ]);\n-      });\n-\n-      it('should support optional directive properties', () => {\n-        const dirA = compileDirectiveMetadataCreate({\n-                       selector: 'div',\n-                       type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                       inputs: ['a']\n-                     }).toSummary();\n-        expect(humanizeTplAst(parse('<div></div>', [dirA]))).toEqual([\n-          [ElementAst, 'div'], [DirectiveAst, dirA]\n-        ]);\n-      });\n-    });\n-\n-    describe('providers', () => {\n-      let nextProviderId: number;\n-\n-      function createToken(value: string): CompileTokenMetadata {\n-        let token: CompileTokenMetadata;\n-        if (value.startsWith('type:')) {\n-          const name = value.substring(5);\n-          token = {identifier: createTypeMeta({reference: <any>name})};\n-        } else {\n-          token = {value: value};\n-        }\n-        return token;\n-      }\n-\n-      function createDep(value: string): CompileDiDependencyMetadata {\n-        let isOptional = false;\n-        if (value.startsWith('optional:')) {\n-          isOptional = true;\n-          value = value.substring(9);\n-        }\n-        let isSelf = false;\n-        if (value.startsWith('self:')) {\n-          isSelf = true;\n-          value = value.substring(5);\n-        }\n-        let isHost = false;\n-        if (value.startsWith('host:')) {\n-          isHost = true;\n-          value = value.substring(5);\n-        }\n-        return {token: createToken(value), isOptional: isOptional, isSelf: isSelf, isHost: isHost};\n-      }\n-\n-      function createProvider(\n-          token: string, {multi = false, deps = []}: {multi?: boolean, deps?: string[]} = {}):\n-          CompileProviderMetadata {\n-        const compileToken = createToken(token);\n-        return {\n-          token: compileToken,\n-          multi: multi,\n-          useClass: createTypeMeta({reference: tokenReference(compileToken)}),\n-          deps: deps.map(createDep),\n-          useExisting: undefined,\n-          useFactory: undefined,\n-          useValue: undefined\n-        };\n-      }\n-\n-      function createDir(\n-          selector: string,\n-          {providers = undefined, viewProviders = undefined, deps = [], queries = []}: {\n-            providers?: CompileProviderMetadata[]|undefined,\n-            viewProviders?: CompileProviderMetadata[]|undefined,\n-            deps?: string[],\n-            queries?: string[]\n-          } = {}): CompileDirectiveSummary {\n-        const isComponent = !selector.startsWith('[');\n-        return compileDirectiveMetadataCreate({\n-                 selector: selector,\n-                 type: createTypeMeta({\n-                   reference: <any>selector,\n-                   diDeps: deps.map(createDep),\n-                 }),\n-                 isComponent: isComponent,\n-                 template: compileTemplateMetadata({ngContentSelectors: []}),\n-                 providers: providers,\n-                 viewProviders: viewProviders,\n-                 queries: queries.map((value) => {\n-                   return {\n-                     selectors: [createToken(value)],\n-                     descendants: false,\n-                     first: false,\n-                     propertyName: 'test',\n-                     read: undefined!\n-                   };\n-                 })\n-               })\n-            .toSummary();\n-      }\n-\n-      beforeEach(() => {\n-        nextProviderId = 0;\n-      });\n-\n-      it('should provide a component', () => {\n-        const comp = createDir('my-comp');\n-        const elAst: ElementAst = <ElementAst>parse('<my-comp>', [comp])[0];\n-        expect(elAst.providers.length).toBe(1);\n-        expect(elAst.providers[0].providerType).toBe(ProviderAstType.Component);\n-        expect(elAst.providers[0].providers[0].useClass).toBe(comp.type);\n-      });\n-\n-      it('should provide a directive', () => {\n-        const dirA = createDir('[dirA]');\n-        const elAst: ElementAst = <ElementAst>parse('<div dirA>', [dirA])[0];\n-        expect(elAst.providers.length).toBe(1);\n-        expect(elAst.providers[0].providerType).toBe(ProviderAstType.Directive);\n-        expect(elAst.providers[0].providers[0].useClass).toBe(dirA.type);\n-      });\n-\n-      it('should use the public providers of a directive', () => {\n-        const provider = createProvider('service');\n-        const dirA = createDir('[dirA]', {providers: [provider]});\n-        const elAst: ElementAst = <ElementAst>parse('<div dirA>', [dirA])[0];\n-        expect(elAst.providers.length).toBe(2);\n-        expect(elAst.providers[0].providerType).toBe(ProviderAstType.PublicService);\n-        expect(elAst.providers[0].providers).toEqual([provider]);\n-      });\n-\n-      it('should use the private providers of a component', () => {\n-        const provider = createProvider('service');\n-        const comp = createDir('my-comp', {viewProviders: [provider]});\n-        const elAst: ElementAst = <ElementAst>parse('<my-comp>', [comp])[0];\n-        expect(elAst.providers.length).toBe(2);\n-        expect(elAst.providers[0].providerType).toBe(ProviderAstType.PrivateService);\n-        expect(elAst.providers[0].providers).toEqual([provider]);\n-      });\n-\n-      it('should support multi providers', () => {\n-        const provider0 = createProvider('service0', {multi: true});\n-        const provider1 = createProvider('service1', {multi: true});\n-        const provider2 = createProvider('service0', {multi: true});\n-        const dirA = createDir('[dirA]', {providers: [provider0, provider1]});\n-        const dirB = createDir('[dirB]', {providers: [provider2]});\n-        const elAst: ElementAst = <ElementAst>parse('<div dirA dirB>', [dirA, dirB])[0];\n-        expect(elAst.providers.length).toBe(4);\n-        expect(elAst.providers[0].providers).toEqual([provider0, provider2]);\n-        expect(elAst.providers[1].providers).toEqual([provider1]);\n-      });\n-\n-      it('should overwrite non multi providers', () => {\n-        const provider1 = createProvider('service0');\n-        const provider2 = createProvider('service1');\n-        const provider3 = createProvider('service0');\n-        const dirA = createDir('[dirA]', {providers: [provider1, provider2]});\n-        const dirB = createDir('[dirB]', {providers: [provider3]});\n-        const elAst: ElementAst = <ElementAst>parse('<div dirA dirB>', [dirA, dirB])[0];\n-        expect(elAst.providers.length).toBe(4);\n-        expect(elAst.providers[0].providers).toEqual([provider3]);\n-        expect(elAst.providers[1].providers).toEqual([provider2]);\n-      });\n-\n-      it('should overwrite component providers by directive providers', () => {\n-        const compProvider = createProvider('service0');\n-        const dirProvider = createProvider('service0');\n-        const comp = createDir('my-comp', {providers: [compProvider]});\n-        const dirA = createDir('[dirA]', {providers: [dirProvider]});\n-        const elAst: ElementAst = <ElementAst>parse('<my-comp dirA>', [dirA, comp])[0];\n-        expect(elAst.providers.length).toBe(3);\n-        expect(elAst.providers[0].providers).toEqual([dirProvider]);\n-      });\n-\n-      it('should overwrite view providers by directive providers', () => {\n-        const viewProvider = createProvider('service0');\n-        const dirProvider = createProvider('service0');\n-        const comp = createDir('my-comp', {viewProviders: [viewProvider]});\n-        const dirA = createDir('[dirA]', {providers: [dirProvider]});\n-        const elAst: ElementAst = <ElementAst>parse('<my-comp dirA>', [dirA, comp])[0];\n-        expect(elAst.providers.length).toBe(3);\n-        expect(elAst.providers[0].providers).toEqual([dirProvider]);\n-      });\n-\n-      it('should overwrite directives by providers', () => {\n-        const dirProvider = createProvider('type:my-comp');\n-        const comp = createDir('my-comp', {providers: [dirProvider]});\n-        const elAst: ElementAst = <ElementAst>parse('<my-comp>', [comp])[0];\n-        expect(elAst.providers.length).toBe(1);\n-        expect(elAst.providers[0].providers).toEqual([dirProvider]);\n-      });\n-\n-      it('if mixing multi and non multi providers', () => {\n-        const provider0 = createProvider('service0');\n-        const provider1 = createProvider('service0', {multi: true});\n-        const dirA = createDir('[dirA]', {providers: [provider0]});\n-        const dirB = createDir('[dirB]', {providers: [provider1]});\n-        expect(() => parse('<div dirA dirB>', [dirA, dirB]))\n-            .toThrowError(\n-                `Template parse errors:\\n` +\n-                `Mixing multi and non multi provider is not possible for token service0 (\"[ERROR ->]<div dirA dirB>\"): TestComp@0:0`);\n-      });\n-\n-      it('should sort providers by their DI order, lazy providers first', () => {\n-        const provider0 = createProvider('service0', {deps: ['type:[dir2]']});\n-        const provider1 = createProvider('service1');\n-        const dir2 = createDir('[dir2]', {deps: ['service1']});\n-        const comp = createDir('my-comp', {providers: [provider0, provider1]});\n-        const elAst: ElementAst = <ElementAst>parse('<my-comp dir2>', [comp, dir2])[0];\n-        expect(elAst.providers.length).toBe(4);\n-        expect(elAst.providers[1].providers[0].useClass).toEqual(comp.type);\n-        expect(elAst.providers[2].providers).toEqual([provider1]);\n-        expect(elAst.providers[3].providers[0].useClass).toEqual(dir2.type);\n-        expect(elAst.providers[0].providers).toEqual([provider0]);\n-      });\n-\n-      it('should sort directives by their DI order', () => {\n-        const dir0 = createDir('[dir0]', {deps: ['type:my-comp']});\n-        const dir1 = createDir('[dir1]', {deps: ['type:[dir0]']});\n-        const dir2 = createDir('[dir2]', {deps: ['type:[dir1]']});\n-        const comp = createDir('my-comp');\n-        const elAst: ElementAst =\n-            <ElementAst>parse('<my-comp dir2 dir0 dir1>', [comp, dir2, dir0, dir1])[0];\n-        expect(elAst.providers.length).toBe(4);\n-        expect(elAst.directives[0].directive).toBe(comp);\n-        expect(elAst.directives[1].directive).toBe(dir0);\n-        expect(elAst.directives[2].directive).toBe(dir1);\n-        expect(elAst.directives[3].directive).toBe(dir2);\n-      });\n-\n-      it('should mark directives and dependencies of directives as eager', () => {\n-        const provider0 = createProvider('service0');\n-        const provider1 = createProvider('service1');\n-        const dirA = createDir('[dirA]', {providers: [provider0, provider1], deps: ['service0']});\n-        const elAst: ElementAst = <ElementAst>parse('<div dirA>', [dirA])[0];\n-        expect(elAst.providers.length).toBe(3);\n-        expect(elAst.providers[1].providers).toEqual([provider0]);\n-        expect(elAst.providers[1].eager).toBe(true);\n-        expect(elAst.providers[2].providers[0].useClass).toEqual(dirA.type);\n-        expect(elAst.providers[2].eager).toBe(true);\n-        expect(elAst.providers[0].providers).toEqual([provider1]);\n-        expect(elAst.providers[0].eager).toBe(false);\n-      });\n-\n-      it('should mark dependencies on parent elements as eager', () => {\n-        const provider0 = createProvider('service0');\n-        const provider1 = createProvider('service1');\n-        const dirA = createDir('[dirA]', {providers: [provider0, provider1]});\n-        const dirB = createDir('[dirB]', {deps: ['service0']});\n-        const elAst: ElementAst =\n-            <ElementAst>parse('<div dirA><div dirB></div></div>', [dirA, dirB])[0];\n-        expect(elAst.providers.length).toBe(3);\n-        expect(elAst.providers[1].providers[0].useClass).toEqual(dirA.type);\n-        expect(elAst.providers[1].eager).toBe(true);\n-        expect(elAst.providers[2].providers).toEqual([provider0]);\n-        expect(elAst.providers[2].eager).toBe(true);\n-        expect(elAst.providers[0].providers).toEqual([provider1]);\n-        expect(elAst.providers[0].eager).toBe(false);\n-      });\n-\n-      it('should mark queried providers as eager', () => {\n-        const provider0 = createProvider('service0');\n-        const provider1 = createProvider('service1');\n-        const dirA =\n-            createDir('[dirA]', {providers: [provider0, provider1], queries: ['service0']});\n-        const elAst: ElementAst = <ElementAst>parse('<div dirA></div>', [dirA])[0];\n-        expect(elAst.providers.length).toBe(3);\n-        expect(elAst.providers[1].providers[0].useClass).toEqual(dirA.type);\n-        expect(elAst.providers[1].eager).toBe(true);\n-        expect(elAst.providers[2].providers).toEqual([provider0]);\n-        expect(elAst.providers[2].eager).toBe(true);\n-        expect(elAst.providers[0].providers).toEqual([provider1]);\n-        expect(elAst.providers[0].eager).toBe(false);\n-      });\n-\n-      it('should not mark dependencies across embedded views as eager', () => {\n-        const provider0 = createProvider('service0');\n-        const dirA = createDir('[dirA]', {providers: [provider0]});\n-        const dirB = createDir('[dirB]', {deps: ['service0']});\n-        const elAst: ElementAst =\n-            <ElementAst>parse('<div dirA><div *ngIf dirB></div></div>', [dirA, dirB])[0];\n-        expect(elAst.providers.length).toBe(2);\n-        expect(elAst.providers[1].providers[0].useClass).toEqual(dirA.type);\n-        expect(elAst.providers[1].eager).toBe(true);\n-        expect(elAst.providers[0].providers).toEqual([provider0]);\n-        expect(elAst.providers[0].eager).toBe(false);\n-      });\n-\n-      it('should report missing @Self() deps as errors', () => {\n-        const dirA = createDir('[dirA]', {deps: ['self:provider0']});\n-        expect(() => parse('<div dirA></div>', [dirA]))\n-            .toThrowError(\n-                'Template parse errors:\\nNo provider for provider0 (\"[ERROR ->]<div dirA></div>\"): TestComp@0:0');\n-      });\n-\n-      it('should change missing @Self() that are optional to nulls', () => {\n-        const dirA = createDir('[dirA]', {deps: ['optional:self:provider0']});\n-        const elAst: ElementAst = <ElementAst>parse('<div dirA></div>', [dirA])[0];\n-        expect(elAst.providers[0].providers[0].deps![0].isValue).toBe(true);\n-        expect(elAst.providers[0].providers[0].deps![0].value).toBe(null);\n-      });\n-\n-      it('should report missing @Host() deps as errors', () => {\n-        const dirA = createDir('[dirA]', {deps: ['host:provider0']});\n-        expect(() => parse('<div dirA></div>', [dirA]))\n-            .toThrowError(\n-                'Template parse errors:\\nNo provider for provider0 (\"[ERROR ->]<div dirA></div>\"): TestComp@0:0');\n-      });\n-\n-      it('should change missing @Host() that are optional to nulls', () => {\n-        const dirA = createDir('[dirA]', {deps: ['optional:host:provider0']});\n-        const elAst: ElementAst = <ElementAst>parse('<div dirA></div>', [dirA])[0];\n-        expect(elAst.providers[0].providers[0].deps![0].isValue).toBe(true);\n-        expect(elAst.providers[0].providers[0].deps![0].value).toBe(null);\n-      });\n-    });\n-\n-    describe('references', () => {\n-      it('should parse references via #... and not report them as attributes', () => {\n-        expect(humanizeTplAst(parse('<div #a>', []))).toEqual([\n-          [ElementAst, 'div'], [ReferenceAst, 'a', null]\n-        ]);\n-      });\n-\n-      it('should parse references via ref-... and not report them as attributes', () => {\n-        expect(humanizeTplAst(parse('<div ref-a>', []))).toEqual([\n-          [ElementAst, 'div'], [ReferenceAst, 'a', null]\n-        ]);\n-      });\n-\n-      it('should parse camel case references', () => {\n-        expect(humanizeTplAst(parse('<div ref-someA>', []))).toEqual([\n-          [ElementAst, 'div'], [ReferenceAst, 'someA', null]\n-        ]);\n-      });\n-\n-      it('should assign references with empty value to the element', () => {\n-        expect(humanizeTplAst(parse('<div #a></div>', []))).toEqual([\n-          [ElementAst, 'div'], [ReferenceAst, 'a', null]\n-        ]);\n-      });\n-\n-      it('should assign references to directives via exportAs', () => {\n-        const dirA = compileDirectiveMetadataCreate({\n-                       selector: '[a]',\n-                       type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                       exportAs: 'dirA'\n-                     }).toSummary();\n-        expect(humanizeTplAst(parse('<div a #a=\"dirA\"></div>', [dirA]))).toEqual([\n-          [ElementAst, 'div'],\n-          [AttrAst, 'a', ''],\n-          [ReferenceAst, 'a', createTokenForReference(dirA.type.reference)],\n-          [DirectiveAst, dirA],\n-        ]);\n-      });\n-\n-      it('should assign references to directives via exportAs with multiple names', () => {\n-        const pizzaTestDirective =\n-            compileDirectiveMetadataCreate({\n-              selector: 'pizza-test',\n-              type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'Pizza'}}),\n-              exportAs: 'pizza, cheeseSauceBread'\n-            }).toSummary();\n-\n-        const template = '<pizza-test #food=\"pizza\" #yum=\"cheeseSauceBread\"></pizza-test>';\n-\n-        expect(humanizeTplAst(parse(template, [pizzaTestDirective]))).toEqual([\n-          [ElementAst, 'pizza-test'],\n-          [ReferenceAst, 'food', createTokenForReference(pizzaTestDirective.type.reference)],\n-          [ReferenceAst, 'yum', createTokenForReference(pizzaTestDirective.type.reference)],\n-          [DirectiveAst, pizzaTestDirective],\n-        ]);\n-      });\n-\n-      it('should report references with values that don\\'t match a directive as errors', () => {\n-        expect(() => parse('<div #a=\"dirA\"></div>', [])).toThrowError(`Template parse errors:\n-There is no directive with \"exportAs\" set to \"dirA\" (\"<div [ERROR ->]#a=\"dirA\"></div>\"): TestComp@0:5`);\n-      });\n-\n-      it('should report invalid reference names', () => {\n-        expect(() => parse('<div #a-b></div>', [])).toThrowError(`Template parse errors:\n-\"-\" is not allowed in reference names (\"<div [ERROR ->]#a-b></div>\"): TestComp@0:5`);\n-      });\n-\n-      it('should report missing reference names', () => {\n-        expect(() => parse('<div #></div>', [])).toThrowError(`Template parse errors:\n-Reference does not have a name (\"<div [ERROR ->]#></div>\"): TestComp@0:5`);\n-      });\n-\n-      it('should report variables as errors', () => {\n-        expect(() => parse('<div let-a></div>', [])).toThrowError(`Template parse errors:\n-\"let-\" is only supported on ng-template elements. (\"<div [ERROR ->]let-a></div>\"): TestComp@0:5`);\n-      });\n-\n-      it('should report missing variable names', () => {\n-        expect(() => parse('<ng-template let-></ng-template>', []))\n-            .toThrowError(`Template parse errors:\n-Variable does not have a name (\"<ng-template [ERROR ->]let-></ng-template>\"): TestComp@0:13`);\n-      });\n-\n-      it('should report duplicate reference names', () => {\n-        expect(() => parse('<div #a></div><div #a></div>', [])).toThrowError(`Template parse errors:\n-Reference \"#a\" is defined several times (\"<div #a></div><div [ERROR ->]#a></div>\"): TestComp@0:19`);\n-      });\n-\n-      it('should report duplicate reference names when using multiple exportAs names', () => {\n-        const pizzaDirective =\n-            compileDirectiveMetadataCreate({\n-              selector: '[dessert-pizza]',\n-              type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'Pizza'}}),\n-              exportAs: 'dessertPizza, chocolate'\n-            }).toSummary();\n-\n-        const chocolateDirective =\n-            compileDirectiveMetadataCreate({\n-              selector: '[chocolate]',\n-              type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'Chocolate'}}),\n-              exportAs: 'chocolate'\n-            }).toSummary();\n-\n-        const template = '<div dessert-pizza chocolate #snack=\"chocolate\"></div>';\n-        const compileTemplate = () => parse(template, [pizzaDirective, chocolateDirective]);\n-        const duplicateReferenceError = 'Template parse errors:\\n' +\n-            'Reference \"#snack\" is defined several times ' +\n-            '(\"<div dessert-pizza chocolate [ERROR ->]#snack=\"chocolate\"></div>\")' +\n-            ': TestComp@0:29';\n-\n-        expect(compileTemplate).toThrowError(duplicateReferenceError);\n-      });\n-\n-      it('should not throw error when there is same reference name in different templates', () => {\n-        expect(() => parse('<div #a><ng-template #a><span>OK</span></ng-template></div>', []))\n-            .not.toThrowError();\n-      });\n-\n-      it('should assign references with empty value to components', () => {\n-        const dirA = compileDirectiveMetadataCreate({\n-                       selector: '[a]',\n-                       isComponent: true,\n-                       type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                       exportAs: 'dirA',\n-                       template: compileTemplateMetadata({ngContentSelectors: []})\n-                     }).toSummary();\n-        expect(humanizeTplAst(parse('<div a #a></div>', [dirA]))).toEqual([\n-          [ElementAst, 'div'],\n-          [AttrAst, 'a', ''],\n-          [ReferenceAst, 'a', createTokenForReference(dirA.type.reference)],\n-          [DirectiveAst, dirA],\n-        ]);\n-      });\n-\n-      it('should not locate directives in references', () => {\n-        const dirA = compileDirectiveMetadataCreate({\n-                       selector: '[a]',\n-                       type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}})\n-                     }).toSummary();\n-        expect(humanizeTplAst(parse('<div ref-a>', [dirA]))).toEqual([\n-          [ElementAst, 'div'], [ReferenceAst, 'a', null]\n-        ]);\n-      });\n-    });\n-\n-    describe('explicit templates', () => {\n-      let reflector: JitReflector;\n-\n-      beforeEach(() => {\n-        reflector = new JitReflector();\n-      });\n-\n-      it('should create embedded templates for <ng-template> elements', () => {\n-        expect(humanizeTplAst(parse('<ng-template></ng-template>', []))).toEqual([\n-          [EmbeddedTemplateAst]\n-        ]);\n-      });\n-\n-      it('should create embedded templates for <ng-template> elements regardless the namespace',\n-         () => {\n-           expect(humanizeTplAst(parse('<svg><ng-template></ng-template></svg>', []))).toEqual([\n-             [ElementAst, ':svg:svg'],\n-             [EmbeddedTemplateAst],\n-           ]);\n-         });\n-\n-      it('should support references via #...', () => {\n-        expect(humanizeTplAst(parse('<ng-template #a>', []))).toEqual([\n-          [EmbeddedTemplateAst],\n-          [ReferenceAst, 'a', createTokenForExternalReference(reflector, Identifiers.TemplateRef)],\n-        ]);\n-      });\n-\n-      it('should support references via ref-...', () => {\n-        expect(humanizeTplAst(parse('<ng-template ref-a>', []))).toEqual([\n-          [EmbeddedTemplateAst],\n-          [ReferenceAst, 'a', createTokenForExternalReference(reflector, Identifiers.TemplateRef)]\n-        ]);\n-      });\n-\n-      it('should parse variables via let-...', () => {\n-        expect(humanizeTplAst(parse('<ng-template let-a=\"b\">', []))).toEqual([\n-          [EmbeddedTemplateAst],\n-          [VariableAst, 'a', 'b'],\n-        ]);\n-      });\n-\n-      it('should not locate directives in variables', () => {\n-        const dirA = compileDirectiveMetadataCreate({\n-                       selector: '[a]',\n-                       type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}})\n-                     }).toSummary();\n-        expect(humanizeTplAst(parse('<ng-template let-a=\"b\"></ng-template>', [dirA]))).toEqual([\n-          [EmbeddedTemplateAst],\n-          [VariableAst, 'a', 'b'],\n-        ]);\n-      });\n-    });\n-\n-    describe('inline templates', () => {\n-      it('should report an error on variables declared with #', () => {\n-        expect(() => humanizeTplAst(parse('<div *ngIf=\"#a=b\">', [])))\n-            .toThrowError(\n-                /Parser Error: Private identifiers are not supported\\. Unexpected private identifier: #a at column 1/);\n-      });\n-\n-      it('should parse variables via let ...', () => {\n-        const targetAst = [\n-          [EmbeddedTemplateAst],\n-          [VariableAst, 'a', 'b'],\n-          [ElementAst, 'div'],\n-        ];\n-\n-        expect(humanizeTplAst(parse('<div *ngIf=\"let a=b\">', []))).toEqual(targetAst);\n-\n-        expect(humanizeTplAst(parse('<div data-*ngIf=\"let a=b\">', []))).toEqual(targetAst);\n-      });\n-\n-      it('should parse variables via as ...', () => {\n-        const targetAst = [\n-          [EmbeddedTemplateAst],\n-          [VariableAst, 'local', 'ngIf'],\n-          [DirectiveAst, ngIf],\n-          [BoundDirectivePropertyAst, 'ngIf', 'expr'],\n-          [ElementAst, 'div'],\n-        ];\n-\n-        expect(humanizeTplAst(parse('<div *ngIf=\"expr as local\">', [ngIf]))).toEqual(targetAst);\n-      });\n-\n-      describe('directives', () => {\n-        it('should locate directives in property bindings', () => {\n-          const dirA = compileDirectiveMetadataCreate({\n-                         selector: '[a=b]',\n-                         type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                         inputs: ['a']\n-                       }).toSummary();\n-          const dirB = compileDirectiveMetadataCreate({\n-                         selector: '[b]',\n-                         type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirB'}})\n-                       }).toSummary();\n-          expect(humanizeTplAst(parse('<div *a=\"b\" b>', [dirA, dirB]))).toEqual([\n-            [EmbeddedTemplateAst], [DirectiveAst, dirA], [BoundDirectivePropertyAst, 'a', 'b'],\n-            [ElementAst, 'div'], [AttrAst, 'b', ''], [DirectiveAst, dirB]\n-          ]);\n-        });\n-\n-        it('should not locate directives in variables', () => {\n-          const dirA = compileDirectiveMetadataCreate({\n-                         selector: '[a]',\n-                         type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}})\n-                       }).toSummary();\n-          expect(humanizeTplAst(parse('<ng-template let-a=\"b\"><div></div></ng-template>', [dirA])))\n-              .toEqual([\n-                [EmbeddedTemplateAst],\n-                [VariableAst, 'a', 'b'],\n-                [ElementAst, 'div'],\n-              ]);\n-        });\n-\n-        it('should not locate directives in references', () => {\n-          const dirA = compileDirectiveMetadataCreate({\n-                         selector: '[a]',\n-                         type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}})\n-                       }).toSummary();\n-          expect(humanizeTplAst(parse('<div ref-a>', [dirA]))).toEqual([\n-            [ElementAst, 'div'], [ReferenceAst, 'a', null]\n-          ]);\n-        });\n-      });\n-\n-\n-      it('should work with *... and use the attribute name as property binding name', () => {\n-        expect(humanizeTplAst(parse('<div *ngIf=\"test\">', [ngIf]))).toEqual([\n-          [EmbeddedTemplateAst],\n-          [DirectiveAst, ngIf],\n-          [BoundDirectivePropertyAst, 'ngIf', 'test'],\n-          [ElementAst, 'div'],\n-\n-        ]);\n-\n-        // https://github.com/angular/angular/issues/13800\n-        expect(humanizeTplAst(parse('<div *ngIf=\"-1\">', [ngIf]))).toEqual([\n-          [EmbeddedTemplateAst],\n-          [DirectiveAst, ngIf],\n-          [BoundDirectivePropertyAst, 'ngIf', '-1'],\n-          [ElementAst, 'div'],\n-        ]);\n-      });\n-\n-      it('should work with *... and empty value', () => {\n-        expect(humanizeTplAst(parse('<div *ngIf>', [ngIf]))).toEqual([\n-          [EmbeddedTemplateAst],\n-          [DirectiveAst, ngIf],\n-          [BoundDirectivePropertyAst, 'ngIf', 'null'],\n-          [ElementAst, 'div'],\n-        ]);\n-      });\n-    });\n-  });\n-\n-  describe('content projection', () => {\n-    let compCounter: number;\n-    beforeEach(() => {\n-      compCounter = 0;\n-    });\n-\n-    function createComp(selector: string, ngContentSelectors: string[]): CompileDirectiveSummary {\n-      return compileDirectiveMetadataCreate({\n-               selector: selector,\n-               isComponent: true,\n-               type: createTypeMeta(\n-                   {reference: {filePath: someModuleUrl, name: `SomeComp${compCounter++}`}}),\n-               template: compileTemplateMetadata({ngContentSelectors: ngContentSelectors})\n-             })\n-          .toSummary();\n-    }\n-\n-    function createDir(selector: string): CompileDirectiveSummary {\n-      return compileDirectiveMetadataCreate({\n-               selector: selector,\n-               type: createTypeMeta(\n-                   {reference: {filePath: someModuleUrl, name: `SomeDir${compCounter++}`}})\n-             })\n-          .toSummary();\n-    }\n-\n-    describe('project text nodes', () => {\n-      it('should project text nodes with wildcard selector', () => {\n-        expect(humanizeContentProjection(parse('<div>hello</div>', [createComp('div', ['*'])])))\n-            .toEqual([\n-              ['div', null],\n-              ['#text(hello)', 0],\n-            ]);\n-      });\n-    });\n-\n-    describe('project elements', () => {\n-      it('should project elements with wildcard selector', () => {\n-        expect(humanizeContentProjection(parse('<div><span></span></div>', [\n-          createComp('div', ['*'])\n-        ]))).toEqual([['div', null], ['span', 0]]);\n-      });\n-\n-      it('should project elements with css selector', () => {\n-        expect(humanizeContentProjection(\n-                   parse('<div><a x></a><b></b></div>', [createComp('div', ['a[x]'])])))\n-            .toEqual([\n-              ['div', null],\n-              ['a', 0],\n-              ['b', null],\n-            ]);\n-      });\n-    });\n-\n-    describe('embedded templates', () => {\n-      it('should project embedded templates with wildcard selector', () => {\n-        expect(humanizeContentProjection(\n-                   parse('<div><ng-template></ng-template></div>', [createComp('div', ['*'])])))\n-            .toEqual([\n-              ['div', null],\n-              ['template', 0],\n-            ]);\n-      });\n-\n-      it('should project embedded templates with css selector', () => {\n-        expect(humanizeContentProjection(parse(\n-                   '<div><ng-template x></ng-template><ng-template></ng-template></div>',\n-                   [createComp('div', ['ng-template[x]'])])))\n-            .toEqual([\n-              ['div', null],\n-              ['template', 0],\n-              ['template', null],\n-            ]);\n-      });\n-    });\n-\n-    describe('ng-content', () => {\n-      it('should project ng-content with wildcard selector', () => {\n-        expect(humanizeContentProjection(parse('<div><ng-content></ng-content></div>', [\n-          createComp('div', ['*'])\n-        ]))).toEqual([['div', null], ['ng-content', 0]]);\n-      });\n-\n-      it('should project ng-content with css selector', () => {\n-        expect(humanizeContentProjection(parse(\n-                   '<div><ng-content x></ng-content><ng-content></ng-content></div>',\n-                   [createComp('div', ['ng-content[x]'])])))\n-            .toEqual([['div', null], ['ng-content', 0], ['ng-content', null]]);\n-      });\n-    });\n-\n-    it('should project into the first matching ng-content', () => {\n-      expect(humanizeContentProjection(parse('<div>hello<b></b><a></a></div>', [\n-        createComp('div', ['a', 'b', '*'])\n-      ]))).toEqual([['div', null], ['#text(hello)', 2], ['b', 1], ['a', 0]]);\n-    });\n-\n-    it('should project into wildcard ng-content last', () => {\n-      expect(humanizeContentProjection(parse('<div>hello<a></a></div>', [\n-        createComp('div', ['*', 'a'])\n-      ]))).toEqual([['div', null], ['#text(hello)', 0], ['a', 1]]);\n-    });\n-\n-    it('should only project direct child nodes', () => {\n-      expect(humanizeContentProjection(parse('<div><span><a></a></span><a></a></div>', [\n-        createComp('div', ['a'])\n-      ]))).toEqual([['div', null], ['span', null], ['a', null], ['a', 0]]);\n-    });\n-\n-    it('should project nodes of nested components', () => {\n-      expect(humanizeContentProjection(parse('<a><b>hello</b></a>', [\n-        createComp('a', ['*']), createComp('b', ['*'])\n-      ]))).toEqual([['a', null], ['b', 0], ['#text(hello)', 0]]);\n-    });\n-\n-    it('should project children of components with ngNonBindable', () => {\n-      expect(humanizeContentProjection(parse('<div ngNonBindable>{{hello}}<span></span></div>', [\n-        createComp('div', ['*'])\n-      ]))).toEqual([['div', null], ['#text({{hello}})', 0], ['span', 0]]);\n-    });\n-\n-    it('should match the element when there is an inline template', () => {\n-      expect(humanizeContentProjection(parse('<div><b *ngIf=\"cond\"></b></div>', [\n-        createComp('div', ['a', 'b']), ngIf\n-      ]))).toEqual([['div', null], ['template', 1], ['b', null]]);\n-    });\n-\n-    describe('ngProjectAs', () => {\n-      it('should override elements', () => {\n-        expect(humanizeContentProjection(parse('<div><a ngProjectAs=\"b\"></a></div>', [\n-          createComp('div', ['a', 'b'])\n-        ]))).toEqual([['div', null], ['a', 1]]);\n-      });\n-\n-      it('should override <ng-content>', () => {\n-        expect(humanizeContentProjection(parse(\n-                   '<div><ng-content ngProjectAs=\"b\"></ng-content></div>',\n-                   [createComp('div', ['ng-content', 'b'])])))\n-            .toEqual([['div', null], ['ng-content', 1]]);\n-      });\n-\n-      it('should override <ng-template>', () => {\n-        expect(humanizeContentProjection(parse(\n-                   '<div><ng-template ngProjectAs=\"b\"></ng-template></div>',\n-                   [createComp('div', ['template', 'b'])])))\n-            .toEqual([\n-              ['div', null],\n-              ['template', 1],\n-            ]);\n-      });\n-\n-      it('should override inline templates', () => {\n-        expect(humanizeContentProjection(parse(\n-                   '<div><a *ngIf=\"cond\" ngProjectAs=\"b\"></a></div>',\n-                   [createComp('div', ['a', 'b']), ngIf])))\n-            .toEqual([\n-              ['div', null],\n-              ['template', 1],\n-              ['a', null],\n-            ]);\n-      });\n-    });\n-\n-    it('should support other directives before the component', () => {\n-      expect(humanizeContentProjection(parse('<div>hello</div>', [\n-        createDir('div'), createComp('div', ['*'])\n-      ]))).toEqual([['div', null], ['#text(hello)', 0]]);\n-    });\n-  });\n-\n-  describe('splitClasses', () => {\n-    it('should keep an empty class', () => {\n-      expect(splitClasses('a')).toEqual(['a']);\n-    });\n-\n-    it('should split 2 classes', () => {\n-      expect(splitClasses('a b')).toEqual(['a', 'b']);\n-    });\n-\n-    it('should trim classes', () => {\n-      expect(splitClasses(' a  b ')).toEqual(['a', 'b']);\n-    });\n-  });\n-\n-  describe('error cases', () => {\n-    it('should report when ng-content has non WS content', () => {\n-      expect(() => parse('<ng-content>content</ng-content>', []))\n-          .toThrowError(\n-              `Template parse errors:\\n` +\n-              `<ng-content> element cannot have content. (\"[ERROR ->]<ng-content>content</ng-content>\"): TestComp@0:0`);\n-    });\n-\n-    it('should treat *attr on a template element as valid', () => {\n-      expect(() => parse('<ng-template *ngIf>', [])).not.toThrowError();\n-    });\n-\n-    it('should report when multiple *attrs are used on the same element', () => {\n-      expect(() => parse('<div *ngIf *ngFor>', [])).toThrowError(`Template parse errors:\n-Can't have multiple template bindings on one element. Use only one attribute prefixed with * (\"<div *ngIf [ERROR ->]*ngFor>\"): TestComp@0:11`);\n-    });\n-\n-\n-    it('should report invalid property names', () => {\n-      expect(() => parse('<div [invalidProp]></div>', [])).toThrowError(`Template parse errors:\n-Can't bind to 'invalidProp' since it isn't a known property of 'div'. (\"<div [ERROR ->][invalidProp]></div>\"): TestComp@0:5`);\n-    });\n-\n-    it('should report invalid host property names', () => {\n-      const dirA = compileDirectiveMetadataCreate({\n-                     selector: 'div',\n-                     type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                     host: {'[invalidProp]': 'someProp'}\n-                   }).toSummary();\n-      expect(() => parse('<div></div>', [dirA])).toThrowError(`Template parse errors:\n-Can't bind to 'invalidProp' since it isn't a known property of 'div'. (\"[ERROR ->]<div></div>\"): TestComp@0:0, Directive DirA`);\n-    });\n-\n-    it('should report errors in expressions', () => {\n-      expect(() => parse('<div [prop]=\"a b\"></div>', [])).toThrowError(`Template parse errors:\n-Parser Error: Unexpected token 'b' at column 3 in [a b] in TestComp@0:13 (\"<div [prop]=\"[ERROR ->]a b\"></div>\"): TestComp@0:13`);\n-    });\n-\n-    it('should not throw on invalid property names if the property is used by a directive', () => {\n-      const dirA = compileDirectiveMetadataCreate({\n-                     selector: 'div',\n-                     type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                     inputs: ['invalidProp']\n-                   }).toSummary();\n-      expect(() => parse('<div [invalid-prop]></div>', [dirA])).not.toThrow();\n-    });\n-\n-    it('should not allow more than 1 component per element', () => {\n-      const dirA = compileDirectiveMetadataCreate({\n-                     selector: 'div',\n-                     isComponent: true,\n-                     type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                     template: compileTemplateMetadata({ngContentSelectors: []})\n-                   }).toSummary();\n-      const dirB = compileDirectiveMetadataCreate({\n-                     selector: 'div',\n-                     isComponent: true,\n-                     type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirB'}}),\n-                     template: compileTemplateMetadata({ngContentSelectors: []})\n-                   }).toSummary();\n-      expect(() => parse('<div>', [dirB, dirA]))\n-          .toThrowError(\n-              `Template parse errors:\\n` +\n-              `More than one component matched on this element.\\n` +\n-              `Make sure that only one component's selector can match a given element.\\n` +\n-              `Conflicting components: DirB,DirA (\"[ERROR ->]<div>\"): TestComp@0:0`);\n-    });\n-\n-    it('should not allow components or element bindings nor dom events on explicit embedded templates',\n-       () => {\n-         const dirA = compileDirectiveMetadataCreate({\n-                        selector: '[a]',\n-                        isComponent: true,\n-                        type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                        template: compileTemplateMetadata({ngContentSelectors: []})\n-                      }).toSummary();\n-\n-         expect(() => parse('<ng-template [a]=\"b\" (e)=\"f\"></ng-template>', [dirA]))\n-             .toThrowError(`Template parse errors:\n-Event binding e not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \"@NgModule.declarations\". (\"<ng-template [a]=\"b\" [ERROR ->](e)=\"f\"></ng-template>\"): TestComp@0:21\n-Components on an embedded template: DirA (\"[ERROR ->]<ng-template [a]=\"b\" (e)=\"f\"></ng-template>\"): TestComp@0:0\n-Property binding a not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \"@NgModule.declarations\". (\"[ERROR ->]<ng-template [a]=\"b\" (e)=\"f\"></ng-template>\"): TestComp@0:0`);\n-       });\n-\n-    it('should not allow components or element bindings on inline embedded templates', () => {\n-      const dirA = compileDirectiveMetadataCreate({\n-                     selector: '[a]',\n-                     isComponent: true,\n-                     type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                     template: compileTemplateMetadata({ngContentSelectors: []})\n-                   }).toSummary();\n-      expect(() => parse('<div *a=\"b\"></div>', [dirA])).toThrowError(`Template parse errors:\n-Components on an embedded template: DirA (\"[ERROR ->]<div *a=\"b\"></div>\"): TestComp@0:0\n-Property binding a not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \"@NgModule.declarations\". (\"[ERROR ->]<div *a=\"b\"></div>\"): TestComp@0:0`);\n-    });\n-  });\n-\n-  describe('ignore elements', () => {\n-    it('should ignore <script> elements', () => {\n-      expect(humanizeTplAst(parse('<script></script>a', []))).toEqual([[TextAst, 'a']]);\n-    });\n-\n-    it('should ignore <style> elements', () => {\n-      expect(humanizeTplAst(parse('<style></style>a', []))).toEqual([[TextAst, 'a']]);\n-    });\n-\n-    describe('<link rel=\"stylesheet\">', () => {\n-      it('should keep <link rel=\"stylesheet\"> elements if they have an absolute url', () => {\n-        expect(humanizeTplAst(parse('<link rel=\"stylesheet\" href=\"http://someurl\">a', [])))\n-            .toEqual([\n-              [ElementAst, 'link'], [AttrAst, 'rel', 'stylesheet'],\n-              [AttrAst, 'href', 'http://someurl'], [TextAst, 'a']\n-            ]);\n-      });\n-\n-      it('should keep <link rel=\"stylesheet\"> elements if they have no uri', () => {\n-        expect(humanizeTplAst(parse('<link rel=\"stylesheet\">a', []))).toEqual([\n-          [ElementAst, 'link'], [AttrAst, 'rel', 'stylesheet'], [TextAst, 'a']\n-        ]);\n-        expect(humanizeTplAst(parse('<link REL=\"stylesheet\">a', []))).toEqual([\n-          [ElementAst, 'link'], [AttrAst, 'REL', 'stylesheet'], [TextAst, 'a']\n-        ]);\n-      });\n-\n-      it('should ignore <link rel=\"stylesheet\"> elements if they have a relative uri', () => {\n-        expect(humanizeTplAst(parse('<link rel=\"stylesheet\" href=\"./other.css\">a', []))).toEqual([\n-          [TextAst, 'a']\n-        ]);\n-        expect(humanizeTplAst(parse('<link rel=\"stylesheet\" HREF=\"./other.css\">a', []))).toEqual([\n-          [TextAst, 'a']\n-        ]);\n-      });\n-\n-      it('should ignore <link rel=\"stylesheet\"> elements if they have a package: uri', () => {\n-        expect(humanizeTplAst(parse('<link rel=\"stylesheet\" href=\"package:somePackage\">a', [])))\n-            .toEqual([[TextAst, 'a']]);\n-      });\n-    });\n-\n-    it('should ignore bindings on children of elements with ngNonBindable', () => {\n-      expect(humanizeTplAst(parse('<div ngNonBindable>{{b}}</div>', []))).toEqual([\n-        [ElementAst, 'div'], [AttrAst, 'ngNonBindable', ''], [TextAst, '{{b}}']\n-      ]);\n-    });\n-\n-    it('should keep nested children of elements with ngNonBindable', () => {\n-      expect(humanizeTplAst(parse('<div ngNonBindable><span>{{b}}</span></div>', []))).toEqual([\n-        [ElementAst, 'div'], [AttrAst, 'ngNonBindable', ''], [ElementAst, 'span'],\n-        [TextAst, '{{b}}']\n-      ]);\n-    });\n-\n-    it('should ignore <script> elements inside of elements with ngNonBindable', () => {\n-      expect(humanizeTplAst(parse('<div ngNonBindable><script></script>a</div>', []))).toEqual([\n-        [ElementAst, 'div'], [AttrAst, 'ngNonBindable', ''], [TextAst, 'a']\n-      ]);\n-    });\n-\n-    it('should ignore <style> elements inside of elements with ngNonBindable', () => {\n-      expect(humanizeTplAst(parse('<div ngNonBindable><style></style>a</div>', []))).toEqual([\n-        [ElementAst, 'div'], [AttrAst, 'ngNonBindable', ''], [TextAst, 'a']\n-      ]);\n-    });\n-\n-    it('should ignore <link rel=\"stylesheet\"> elements inside of elements with ngNonBindable',\n-       () => {\n-         expect(humanizeTplAst(parse('<div ngNonBindable><link rel=\"stylesheet\">a</div>', [])))\n-             .toEqual([[ElementAst, 'div'], [AttrAst, 'ngNonBindable', ''], [TextAst, 'a']]);\n-       });\n-\n-    it('should convert <ng-content> elements into regular elements inside of elements with ngNonBindable',\n-       () => {\n-         expect(humanizeTplAst(parse('<div ngNonBindable><ng-content></ng-content>a</div>', [])))\n-             .toEqual([\n-               [ElementAst, 'div'], [AttrAst, 'ngNonBindable', ''], [ElementAst, 'ng-content'],\n-               [TextAst, 'a']\n-             ]);\n-       });\n-  });\n-\n-  describe('source spans', () => {\n-    it('should support ng-content', () => {\n-      const parsed = parse('<ng-content select=\"a\">', []);\n-      expect(humanizeTplAstSourceSpans(parsed)).toEqual([\n-        [NgContentAst, '<ng-content select=\"a\">']\n-      ]);\n-    });\n-\n-    it('should support embedded template', () => {\n-      expect(humanizeTplAstSourceSpans(parse('<ng-template></ng-template>', []))).toEqual([\n-        [EmbeddedTemplateAst, '<ng-template></ng-template>']\n-      ]);\n-    });\n-\n-    it('should support element and attributes', () => {\n-      expect(humanizeTplAstSourceSpans(parse('<div key=value>', []))).toEqual([\n-        [ElementAst, 'div', '<div key=value>'], [AttrAst, 'key', 'value', 'key=value']\n-      ]);\n-    });\n-\n-    it('should support references', () => {\n-      expect(humanizeTplAstSourceSpans(parse('<div #a></div>', []))).toEqual([\n-        [ElementAst, 'div', '<div #a></div>'], [ReferenceAst, 'a', null, '#a']\n-      ]);\n-    });\n-\n-    it('should support variables', () => {\n-      expect(humanizeTplAstSourceSpans(parse('<ng-template let-a=\"b\"></ng-template>', [])))\n-          .toEqual([\n-            [EmbeddedTemplateAst, '<ng-template let-a=\"b\"></ng-template>'],\n-            [VariableAst, 'a', 'b', 'let-a=\"b\"'],\n-          ]);\n-    });\n-\n-    it('should support events', () => {\n-      expect(humanizeTplAstSourceSpans(parse('<div (window:event)=\"v\">', []))).toEqual([\n-        [ElementAst, 'div', '<div (window:event)=\"v\">'],\n-        [BoundEventAst, 'event', 'window', 'v', '(window:event)=\"v\"']\n-      ]);\n-    });\n-\n-    it('should support element property', () => {\n-      expect(humanizeTplAstSourceSpans(parse('<div [someProp]=\"v\">', []))).toEqual([\n-        [ElementAst, 'div', '<div [someProp]=\"v\">'],\n-        [\n-          BoundElementPropertyAst, PropertyBindingType.Property, 'someProp', 'v', null,\n-          '[someProp]=\"v\"'\n-        ]\n-      ]);\n-    });\n-\n-    it('should support bound text', () => {\n-      expect(humanizeTplAstSourceSpans(parse('{{a}}', []))).toEqual([\n-        [BoundTextAst, '{{ a }}', '{{a}}']\n-      ]);\n-    });\n-\n-    it('should support text nodes', () => {\n-      expect(humanizeTplAstSourceSpans(parse('a', []))).toEqual([[TextAst, 'a', 'a']]);\n-    });\n-\n-    it('should support directive', () => {\n-      const dirA = compileDirectiveMetadataCreate({\n-                     selector: '[a]',\n-                     type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}})\n-                   }).toSummary();\n-      const comp = compileDirectiveMetadataCreate({\n-                     selector: 'div',\n-                     isComponent: true,\n-                     type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'ZComp'}}),\n-                     template: compileTemplateMetadata({ngContentSelectors: []})\n-                   }).toSummary();\n-      expect(humanizeTplAstSourceSpans(parse('<div a>', [dirA, comp]))).toEqual([\n-        [ElementAst, 'div', '<div a>'], [AttrAst, 'a', '', 'a'], [DirectiveAst, dirA, '<div a>'],\n-        [DirectiveAst, comp, '<div a>']\n-      ]);\n-    });\n-\n-    it('should support directive in namespace', () => {\n-      const tagSel = compileDirectiveMetadataCreate({\n-                       selector: 'circle',\n-                       type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'elDir'}})\n-                     }).toSummary();\n-      const attrSel =\n-          compileDirectiveMetadataCreate({\n-            selector: '[href]',\n-            type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'attrDir'}})\n-          }).toSummary();\n-\n-      expect(humanizeTplAstSourceSpans(\n-                 parse('<svg><circle /><use xlink:href=\"Port\" /></svg>', [tagSel, attrSel])))\n-          .toEqual([\n-            [ElementAst, ':svg:svg', '<svg><circle /><use xlink:href=\"Port\" /></svg>'],\n-            [ElementAst, ':svg:circle', '<circle />'],\n-            [DirectiveAst, tagSel, '<circle />'],\n-            [ElementAst, ':svg:use', '<use xlink:href=\"Port\" />'],\n-            [AttrAst, ':xlink:href', 'Port', 'xlink:href=\"Port\"'],\n-            [DirectiveAst, attrSel, '<use xlink:href=\"Port\" />'],\n-          ]);\n-    });\n-\n-    it('should support directive property', () => {\n-      const dirA = compileDirectiveMetadataCreate({\n-                     selector: 'div',\n-                     type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                     inputs: ['aProp']\n-                   }).toSummary();\n-      expect(humanizeTplAstSourceSpans(parse('<div [aProp]=\"foo\"></div>', [dirA]))).toEqual([\n-        [ElementAst, 'div', '<div [aProp]=\"foo\"></div>'],\n-        [DirectiveAst, dirA, '<div [aProp]=\"foo\"></div>'],\n-        [BoundDirectivePropertyAst, 'aProp', 'foo', '[aProp]=\"foo\"']\n-      ]);\n-    });\n-\n-    it('should support endSourceSpan for elements', () => {\n-      const tagSel = compileDirectiveMetadataCreate({\n-                       selector: 'circle',\n-                       type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'elDir'}})\n-                     }).toSummary();\n-      const result = parse('<circle></circle>', [tagSel]);\n-      const circle = result[0] as ElementAst;\n-      expect(circle.endSourceSpan).toBeDefined();\n-      expect(circle.endSourceSpan!.start.offset).toBe(8);\n-      expect(circle.endSourceSpan!.end.offset).toBe(17);\n-    });\n-\n-    it('should report undefined for endSourceSpan for elements without an end-tag', () => {\n-      const ulSel = compileDirectiveMetadataCreate({\n-                      selector: 'ul',\n-                      type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'ulDir'}})\n-                    }).toSummary();\n-      const liSel = compileDirectiveMetadataCreate({\n-                      selector: 'li',\n-                      type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'liDir'}})\n-                    }).toSummary();\n-      const result = parse('<ul><li><li></ul>', [ulSel, liSel]);\n-      const ul = result[0] as ElementAst;\n-      const li = ul.children[0] as ElementAst;\n-      expect(li.endSourceSpan).toBe(null);\n-    });\n-  });\n-\n-  describe('pipes', () => {\n-    it('should allow pipes that have been defined as dependencies', () => {\n-      const testPipe = new CompilePipeMetadata({\n-                         name: 'test',\n-                         type: createTypeMeta({reference: {filePath: someModuleUrl, name: 'DirA'}}),\n-                         pure: false\n-                       }).toSummary();\n-      expect(() => parse('{{a | test}}', [], [testPipe])).not.toThrow();\n-    });\n-\n-    it('should report pipes as error that have not been defined as dependencies', () => {\n-      expect(() => parse('{{a | test}}', [])).toThrowError(`Template parse errors:\n-The pipe 'test' could not be found (\"{{[ERROR ->]a | test}}\"): TestComp@0:2`);\n-    });\n-  });\n-\n-  describe('ICU messages', () => {\n-    it('should expand plural messages', () => {\n-      const shortForm = '{ count, plural, =0 {small} many {big} }';\n-      const expandedForm = '<ng-container [ngPlural]=\"count\">' +\n-          '<ng-template ngPluralCase=\"=0\">small</ng-template>' +\n-          '<ng-template ngPluralCase=\"many\">big</ng-template>' +\n-          '</ng-container>';\n-\n-      expect(humanizeTplAst(parse(shortForm, []))).toEqual(humanizeTplAst(parse(expandedForm, [])));\n-    });\n-\n-    it('should expand select messages', () => {\n-      const shortForm = '{ sex, select, female {foo} other {bar} }';\n-      const expandedForm = '<ng-container [ngSwitch]=\"sex\">' +\n-          '<ng-template ngSwitchCase=\"female\">foo</ng-template>' +\n-          '<ng-template ngSwitchDefault>bar</ng-template>' +\n-          '</ng-container>';\n-\n-      expect(humanizeTplAst(parse(shortForm, []))).toEqual(humanizeTplAst(parse(expandedForm, [])));\n-    });\n-\n-    it('should be possible to escape ICU messages', () => {\n-      const escapedForm = 'escaped {{ \"{\" }}  }';\n-\n-      expect(humanizeTplAst(parse(escapedForm, []))).toEqual([\n-        [BoundTextAst, 'escaped {{ \"{\" }}  }'],\n-      ]);\n-    });\n-  });\n-});\n-\n-describe('whitespaces removal', () => {\n-  beforeEach(() => {\n-    TestBed.configureCompiler({providers: [TEST_COMPILER_PROVIDERS, MOCK_SCHEMA_REGISTRY]});\n-  });\n-\n-  commonBeforeEach();\n-\n-  it('should not remove whitespaces by default', () => {\n-    expect(humanizeTplAst(parse(' <br>  <br>\\t<br>\\n<br> ', []))).toEqual([\n-      [TextAst, ' '],\n-      [ElementAst, 'br'],\n-      [TextAst, '  '],\n-      [ElementAst, 'br'],\n-      [TextAst, '\\t'],\n-      [ElementAst, 'br'],\n-      [TextAst, '\\n'],\n-      [ElementAst, 'br'],\n-      [TextAst, ' '],\n-    ]);\n-  });\n-\n-  it('should replace each &ngsp; with a space when preserveWhitespaces is true', () => {\n-    expect(humanizeTplAst(parse('foo&ngsp;&ngsp;&ngsp;bar', [], [], [], true))).toEqual([\n-      [TextAst, 'foo   bar'],\n-    ]);\n-  });\n-\n-  it('should replace every &ngsp; with a single space when preserveWhitespaces is false', () => {\n-    expect(humanizeTplAst(parse('foo&ngsp;&ngsp;&ngsp;bar', [], [], [], false))).toEqual([\n-      [TextAst, 'foo bar'],\n-    ]);\n-  });\n-\n-  it('should remove whitespaces when explicitly requested', () => {\n-    expect(humanizeTplAst(parse(' <br>  <br>\\t<br>\\n<br> ', [], [], [], false))).toEqual([\n-      [ElementAst, 'br'],\n-      [ElementAst, 'br'],\n-      [ElementAst, 'br'],\n-      [ElementAst, 'br'],\n-    ]);\n-  });\n-\n-  it('should remove whitespace between ICU expansions when not preserving whitespaces', () => {\n-    const shortForm = '{ count, plural, =0 {small} many {big} }';\n-    const expandedForm = '<ng-container [ngPlural]=\"count\">' +\n-        '<ng-template ngPluralCase=\"=0\">small</ng-template>' +\n-        '<ng-template ngPluralCase=\"many\">big</ng-template>' +\n-        '</ng-container>';\n-    const humanizedExpandedForm = humanizeTplAst(parse(expandedForm, []));\n-\n-    // ICU expansions are converted to `<ng-container>` tags and all blank text nodes are reomved\n-    // so any whitespace between ICU exansions are removed as well\n-    expect(humanizeTplAst(parse(`${shortForm} ${shortForm}`, [], [], [], false))).toEqual([\n-      ...humanizedExpandedForm, ...humanizedExpandedForm\n-    ]);\n-  });\n-});\n-})();"
        },
        {
            "sha": "f07caa14fb357a9d1a29725087d0e3e529630857",
            "filename": "packages/compiler/test/template_parser/template_preparser_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 54,
            "changes": 54,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Ftemplate_preparser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Ftemplate_preparser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Ftemplate_preparser_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,54 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {inject} from '../../../core/testing';\n-import {Element} from '../../src/ml_parser/ast';\n-import {HtmlParser} from '../../src/ml_parser/html_parser';\n-import {PreparsedElement, PreparsedElementType, preparseElement} from '../../src/template_parser/template_preparser';\n-\n-{\n-  describe('preparseElement', () => {\n-    let htmlParser: HtmlParser;\n-    beforeEach(inject([HtmlParser], (_htmlParser: HtmlParser) => {\n-      htmlParser = _htmlParser;\n-    }));\n-\n-    function preparse(html: string): PreparsedElement {\n-      return preparseElement(htmlParser.parse(html, 'TestComp').rootNodes[0] as Element);\n-    }\n-\n-    it('should detect script elements', inject([HtmlParser], (htmlParser: HtmlParser) => {\n-         expect(preparse('<script>').type).toBe(PreparsedElementType.SCRIPT);\n-       }));\n-\n-    it('should detect style elements', inject([HtmlParser], (htmlParser: HtmlParser) => {\n-         expect(preparse('<style>').type).toBe(PreparsedElementType.STYLE);\n-       }));\n-\n-    it('should detect stylesheet elements', inject([HtmlParser], (htmlParser: HtmlParser) => {\n-         expect(preparse('<link rel=\"stylesheet\">').type).toBe(PreparsedElementType.STYLESHEET);\n-         expect(preparse('<link rel=\"stylesheet\" href=\"someUrl\">').hrefAttr).toEqual('someUrl');\n-         expect(preparse('<link rel=\"someRel\">').type).toBe(PreparsedElementType.OTHER);\n-       }));\n-\n-    it('should detect ng-content elements', inject([HtmlParser], (htmlParser: HtmlParser) => {\n-         expect(preparse('<ng-content>').type).toBe(PreparsedElementType.NG_CONTENT);\n-       }));\n-\n-    it('should normalize ng-content.select attribute',\n-       inject([HtmlParser], (htmlParser: HtmlParser) => {\n-         expect(preparse('<ng-content>').selectAttr).toEqual('*');\n-         expect(preparse('<ng-content select>').selectAttr).toEqual('*');\n-         expect(preparse('<ng-content select=\"*\">').selectAttr).toEqual('*');\n-       }));\n-\n-    it('should extract ngProjectAs value', () => {\n-      expect(preparse('<p ngProjectAs=\"el[attr].class\"></p>').projectAs).toEqual('el[attr].class');\n-    });\n-  });\n-}"
        },
        {
            "sha": "c913c609c6f10a33e7fd8a578deb8f51074c8443",
            "filename": "packages/compiler/test/template_parser/util/expression.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 167,
            "changes": 167,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Futil%2Fexpression.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Futil%2Fexpression.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Futil%2Fexpression.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,167 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {AbsoluteSourceSpan} from '@angular/compiler';\n-import * as e from '../../../src/expression_parser/ast';\n-import * as t from '../../../src/template_parser/template_ast';\n-import {unparse} from '../../expression_parser/utils/unparser';\n-\n-type HumanizedExpressionSource = [string, AbsoluteSourceSpan];\n-class ExpressionSourceHumanizer extends e.RecursiveAstVisitor implements t.TemplateAstVisitor {\n-  result: HumanizedExpressionSource[] = [];\n-\n-  private recordAst(ast: e.AST) {\n-    this.result.push([unparse(ast), ast.sourceSpan]);\n-  }\n-\n-  // This method is defined to reconcile the type of ExpressionSourceHumanizer\n-  // since both RecursiveAstVisitor and TemplateAstVisitor define the visit()\n-  // method in their interfaces.\n-  override visit(node: e.AST|t.TemplateAst, context?: any) {\n-    node.visit(this, context);\n-  }\n-\n-  visitASTWithSource(ast: e.ASTWithSource) {\n-    this.recordAst(ast);\n-    this.visitAll([ast.ast], null);\n-  }\n-  override visitUnary(ast: e.Unary) {\n-    this.recordAst(ast);\n-    super.visitUnary(ast, null);\n-  }\n-  override visitBinary(ast: e.Binary) {\n-    this.recordAst(ast);\n-    super.visitBinary(ast, null);\n-  }\n-  override visitChain(ast: e.Chain) {\n-    this.recordAst(ast);\n-    super.visitChain(ast, null);\n-  }\n-  override visitConditional(ast: e.Conditional) {\n-    this.recordAst(ast);\n-    super.visitConditional(ast, null);\n-  }\n-  override visitImplicitReceiver(ast: e.ImplicitReceiver) {\n-    this.recordAst(ast);\n-    super.visitImplicitReceiver(ast, null);\n-  }\n-  override visitInterpolation(ast: e.Interpolation) {\n-    this.recordAst(ast);\n-    super.visitInterpolation(ast, null);\n-  }\n-  override visitKeyedRead(ast: e.KeyedRead) {\n-    this.recordAst(ast);\n-    super.visitKeyedRead(ast, null);\n-  }\n-  override visitKeyedWrite(ast: e.KeyedWrite) {\n-    this.recordAst(ast);\n-    super.visitKeyedWrite(ast, null);\n-  }\n-  override visitLiteralPrimitive(ast: e.LiteralPrimitive) {\n-    this.recordAst(ast);\n-    super.visitLiteralPrimitive(ast, null);\n-  }\n-  override visitLiteralArray(ast: e.LiteralArray) {\n-    this.recordAst(ast);\n-    super.visitLiteralArray(ast, null);\n-  }\n-  override visitLiteralMap(ast: e.LiteralMap) {\n-    this.recordAst(ast);\n-    super.visitLiteralMap(ast, null);\n-  }\n-  override visitNonNullAssert(ast: e.NonNullAssert) {\n-    this.recordAst(ast);\n-    super.visitNonNullAssert(ast, null);\n-  }\n-  override visitPipe(ast: e.BindingPipe) {\n-    this.recordAst(ast);\n-    super.visitPipe(ast, null);\n-  }\n-  override visitPrefixNot(ast: e.PrefixNot) {\n-    this.recordAst(ast);\n-    super.visitPrefixNot(ast, null);\n-  }\n-  override visitPropertyRead(ast: e.PropertyRead) {\n-    this.recordAst(ast);\n-    super.visitPropertyRead(ast, null);\n-  }\n-  override visitPropertyWrite(ast: e.PropertyWrite) {\n-    this.recordAst(ast);\n-    super.visitPropertyWrite(ast, null);\n-  }\n-  override visitSafePropertyRead(ast: e.SafePropertyRead) {\n-    this.recordAst(ast);\n-    super.visitSafePropertyRead(ast, null);\n-  }\n-  override visitQuote(ast: e.Quote) {\n-    this.recordAst(ast);\n-    super.visitQuote(ast, null);\n-  }\n-  override visitSafeKeyedRead(ast: e.SafeKeyedRead) {\n-    this.recordAst(ast);\n-    super.visitSafeKeyedRead(ast, null);\n-  }\n-  override visitCall(ast: e.Call) {\n-    this.recordAst(ast);\n-    super.visitCall(ast, null);\n-  }\n-\n-  visitNgContent(ast: t.NgContentAst) {}\n-  visitEmbeddedTemplate(ast: t.EmbeddedTemplateAst) {\n-    t.templateVisitAll(this, ast.attrs);\n-    t.templateVisitAll(this, ast.children);\n-    t.templateVisitAll(this, ast.directives);\n-    t.templateVisitAll(this, ast.outputs);\n-    t.templateVisitAll(this, ast.providers);\n-    t.templateVisitAll(this, ast.references);\n-    t.templateVisitAll(this, ast.variables);\n-  }\n-  visitElement(ast: t.ElementAst) {\n-    t.templateVisitAll(this, ast.attrs);\n-    t.templateVisitAll(this, ast.children);\n-    t.templateVisitAll(this, ast.directives);\n-    t.templateVisitAll(this, ast.inputs);\n-    t.templateVisitAll(this, ast.outputs);\n-    t.templateVisitAll(this, ast.providers);\n-    t.templateVisitAll(this, ast.references);\n-  }\n-  visitReference(ast: t.ReferenceAst) {}\n-  visitVariable(ast: t.VariableAst) {}\n-  visitEvent(ast: t.BoundEventAst) {\n-    ast.handler.visit(this);\n-  }\n-  visitElementProperty(ast: t.BoundElementPropertyAst) {\n-    ast.value.visit(this);\n-  }\n-  visitAttr(ast: t.AttrAst) {}\n-  visitBoundText(ast: t.BoundTextAst) {\n-    ast.value.visit(this);\n-  }\n-  visitText(ast: t.TextAst) {}\n-  visitDirective(ast: t.DirectiveAst) {\n-    t.templateVisitAll(this, ast.hostEvents);\n-    t.templateVisitAll(this, ast.hostProperties);\n-    t.templateVisitAll(this, ast.inputs);\n-  }\n-  visitDirectiveProperty(ast: t.BoundDirectivePropertyAst) {\n-    ast.value.visit(this);\n-  }\n-}\n-\n-/**\n- * Humanizes expression AST source spans in a template by returning an array of tuples\n- *   [unparsed AST, AST source span]\n- * for each expression in the template.\n- * @param templateAsts template AST to humanize\n- */\n-export function humanizeExpressionSource(templateAsts: t.TemplateAst[]):\n-    HumanizedExpressionSource[] {\n-  const humanizer = new ExpressionSourceHumanizer();\n-  t.templateVisitAll(humanizer, templateAsts);\n-  return humanizer.result;\n-}"
        },
        {
            "sha": "1b6d019c8a3a6558e6c345e774cdeaf5f87021ab",
            "filename": "packages/compiler/test/template_parser/util/metadata.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 87,
            "changes": 87,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Futil%2Fmetadata.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Futil%2Fmetadata.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Futil%2Fmetadata.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,87 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import {CompileDirectiveMetadata, CompileEntryComponentMetadata, CompileProviderMetadata, CompileQueryMetadata, CompileStylesheetMetadata, CompileTemplateMetadata, CompileTypeMetadata, preserveWhitespacesDefault, ProxyClass, StaticSymbol} from '@angular/compiler';\n-import {ChangeDetectionStrategy, RendererType2, ViewEncapsulation} from '@angular/core';\n-\n-import {noUndefined} from '../../../src/util';\n-\n-export function createTypeMeta({reference, diDeps}: {reference: any, diDeps?: any[]}):\n-    CompileTypeMetadata {\n-  return {reference: reference, diDeps: diDeps || [], lifecycleHooks: []};\n-}\n-\n-export function compileDirectiveMetadataCreate({\n-  isHost,\n-  type,\n-  isComponent,\n-  selector,\n-  exportAs,\n-  inputs,\n-  outputs,\n-  host,\n-  providers,\n-  viewProviders,\n-  queries,\n-  guards,\n-  viewQueries,\n-  entryComponents,\n-  template,\n-  componentViewType,\n-  rendererType\n-}: Partial<Parameters<typeof CompileDirectiveMetadata.create>[0]>) {\n-  return CompileDirectiveMetadata.create({\n-    isHost: !!isHost,\n-    type: noUndefined(type)!,\n-    isComponent: !!isComponent,\n-    selector: noUndefined(selector),\n-    exportAs: noUndefined(exportAs),\n-    changeDetection: null,\n-    inputs: inputs || [],\n-    outputs: outputs || [],\n-    host: host || {},\n-    providers: providers || [],\n-    viewProviders: viewProviders || [],\n-    queries: queries || [],\n-    guards: guards || {},\n-    viewQueries: viewQueries || [],\n-    entryComponents: entryComponents || [],\n-    template: noUndefined(template)!,\n-    componentViewType: noUndefined(componentViewType),\n-    rendererType: noUndefined(rendererType),\n-    componentFactory: null,\n-  });\n-}\n-\n-export function compileTemplateMetadata({\n-  encapsulation,\n-  template,\n-  templateUrl,\n-  styles,\n-  styleUrls,\n-  externalStylesheets,\n-  animations,\n-  ngContentSelectors,\n-  interpolation,\n-  isInline,\n-  preserveWhitespaces\n-}: Partial<CompileTemplateMetadata>): CompileTemplateMetadata {\n-  return new CompileTemplateMetadata({\n-    encapsulation: noUndefined(encapsulation),\n-    template: noUndefined(template),\n-    templateUrl: noUndefined(templateUrl),\n-    htmlAst: null,\n-    styles: styles || [],\n-    styleUrls: styleUrls || [],\n-    externalStylesheets: externalStylesheets || [],\n-    animations: animations || [],\n-    ngContentSelectors: ngContentSelectors || [],\n-    interpolation: noUndefined(interpolation),\n-    isInline: !!isInline,\n-    preserveWhitespaces: preserveWhitespacesDefault(noUndefined(preserveWhitespaces)),\n-  });\n-}"
        },
        {
            "sha": "ea0dfba273795e0da6883aea20e3574e9f6c99ea",
            "filename": "packages/compiler/test/test_bindings.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 25,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Ftest_bindings.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftest%2Ftest_bindings.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Ftest_bindings.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,25 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ElementSchemaRegistry, ResourceLoader, UrlResolver} from '@angular/compiler';\n-import {MockResourceLoader} from '@angular/compiler/testing/src/resource_loader_mock';\n-import {MockSchemaRegistry} from '@angular/compiler/testing/src/schema_registry_mock';\n-import {Provider} from '@angular/core';\n-\n-export function createUrlResolverWithoutPackagePrefix(): UrlResolver {\n-  return new UrlResolver();\n-}\n-\n-// This provider is put here just so that we can access it from multiple\n-// internal test packages.\n-// TODO: get rid of it or move to a separate @angular/internal_testing package\n-export const TEST_COMPILER_PROVIDERS: Provider[] = [\n-  {provide: ElementSchemaRegistry, useValue: new MockSchemaRegistry({}, {}, {}, [], [])},\n-  {provide: ResourceLoader, useClass: MockResourceLoader, deps: []},\n-  {provide: UrlResolver, useFactory: createUrlResolverWithoutPackagePrefix, deps: []}\n-];"
        },
        {
            "sha": "66226517b9f284aefea0988a372f191ee12c0155",
            "filename": "packages/compiler/test/url_resolver_spec.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Furl_resolver_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftest%2Furl_resolver_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Furl_resolver_spec.ts?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -93,10 +93,12 @@ import {inject} from '@angular/core/testing';\n         expect(resolver.resolve(null!, 'some/dir/file.txt')).toEqual('some/dir/file.txt');\n       });\n \n-      it('should contain a default value of \"/\" when nothing is provided',\n-         inject([UrlResolver], (resolver: UrlResolver) => {\n-           expect(resolver.resolve(null!, 'package:file')).toEqual('/file');\n-         }));\n+      // TODO(alxhub): figure out if this test is still relevant, as it fails in Ivy\n+      // since UrlResolver is not part of TestBed.\n+      xit('should contain a default value of \"/\" when nothing is provided',\n+          inject([UrlResolver], (resolver: UrlResolver) => {\n+            expect(resolver.resolve(null!, 'package:file')).toEqual('/file');\n+          }));\n \n       it('should resolve a package value when present within the baseurl', () => {\n         resolver = new UrlResolver('/my_special_dir');"
        },
        {
            "sha": "4a29a11436ee9f9d98758f04c03b7649d20b6a95",
            "filename": "packages/compiler/testing/src/directive_resolver_mock.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 34,
            "changes": 34,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftesting%2Fsrc%2Fdirective_resolver_mock.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftesting%2Fsrc%2Fdirective_resolver_mock.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftesting%2Fsrc%2Fdirective_resolver_mock.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,34 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import {CompileReflector, core, DirectiveResolver} from '@angular/compiler';\n-\n-/**\n- * An implementation of {@link DirectiveResolver} that allows overriding\n- * various properties of directives.\n- */\n-export class MockDirectiveResolver extends DirectiveResolver {\n-  private _directives = new Map<core.Type, core.Directive>();\n-\n-  constructor(reflector: CompileReflector) {\n-    super(reflector);\n-  }\n-\n-  override resolve(type: core.Type): core.Directive;\n-  override resolve(type: core.Type, throwIfNotFound: true): core.Directive;\n-  override resolve(type: core.Type, throwIfNotFound: boolean): core.Directive|null;\n-  override resolve(type: core.Type, throwIfNotFound = true): core.Directive|null {\n-    return this._directives.get(type) || super.resolve(type, throwIfNotFound);\n-  }\n-\n-  /**\n-   * Overrides the {@link core.Directive} for a directive.\n-   */\n-  setDirective(type: core.Type, metadata: core.Directive): void {\n-    this._directives.set(type, metadata);\n-  }\n-}"
        },
        {
            "sha": "83ff2fda84c42310b94c5818b29f294aa0d2c8c0",
            "filename": "packages/compiler/testing/src/ng_module_resolver_mock.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 34,
            "changes": 34,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftesting%2Fsrc%2Fng_module_resolver_mock.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftesting%2Fsrc%2Fng_module_resolver_mock.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftesting%2Fsrc%2Fng_module_resolver_mock.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,34 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompileReflector, core, NgModuleResolver} from '@angular/compiler';\n-\n-export class MockNgModuleResolver extends NgModuleResolver {\n-  private _ngModules = new Map<core.Type, core.NgModule>();\n-\n-  constructor(reflector: CompileReflector) {\n-    super(reflector);\n-  }\n-\n-  /**\n-   * Overrides the {@link NgModule} for a module.\n-   */\n-  setNgModule(type: core.Type, metadata: core.NgModule): void {\n-    this._ngModules.set(type, metadata);\n-  }\n-\n-  /**\n-   * Returns the {@link NgModule} for a module:\n-   * - Set the {@link NgModule} to the overridden view when it exists or fallback to the\n-   * default\n-   * `NgModuleResolver`, see `setNgModule`.\n-   */\n-  override resolve(type: core.Type, throwIfNotFound = true): core.NgModule {\n-    return this._ngModules.get(type) || super.resolve(type, throwIfNotFound)!;\n-  }\n-}"
        },
        {
            "sha": "e64460230a485e99830348bff3b0a06cf448a3bc",
            "filename": "packages/compiler/testing/src/pipe_resolver_mock.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 38,
            "changes": 38,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftesting%2Fsrc%2Fpipe_resolver_mock.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftesting%2Fsrc%2Fpipe_resolver_mock.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftesting%2Fsrc%2Fpipe_resolver_mock.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,38 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompileReflector, core, PipeResolver} from '@angular/compiler';\n-\n-export class MockPipeResolver extends PipeResolver {\n-  private _pipes = new Map<core.Type, core.Pipe>();\n-\n-  constructor(refector: CompileReflector) {\n-    super(refector);\n-  }\n-\n-  /**\n-   * Overrides the {@link Pipe} for a pipe.\n-   */\n-  setPipe(type: core.Type, metadata: core.Pipe): void {\n-    this._pipes.set(type, metadata);\n-  }\n-\n-  /**\n-   * Returns the {@link Pipe} for a pipe:\n-   * - Set the {@link Pipe} to the overridden view when it exists or fallback to the\n-   * default\n-   * `PipeResolver`, see `setPipe`.\n-   */\n-  override resolve(type: core.Type, throwIfNotFound = true): core.Pipe {\n-    let metadata = this._pipes.get(type);\n-    if (!metadata) {\n-      metadata = super.resolve(type, throwIfNotFound)!;\n-    }\n-    return metadata;\n-  }\n-}"
        },
        {
            "sha": "3363e5e5f475b995b6a77745d7e3a1ea726ce86a",
            "filename": "packages/compiler/testing/src/schema_registry_mock.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 70,
            "changes": 70,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftesting%2Fsrc%2Fschema_registry_mock.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcompiler%2Ftesting%2Fsrc%2Fschema_registry_mock.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftesting%2Fsrc%2Fschema_registry_mock.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,70 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {core, ElementSchemaRegistry} from '@angular/compiler';\n-\n-export class MockSchemaRegistry implements ElementSchemaRegistry {\n-  constructor(\n-      public existingProperties: {[key: string]: boolean},\n-      public attrPropMapping: {[key: string]: string},\n-      public existingElements: {[key: string]: boolean}, public invalidProperties: Array<string>,\n-      public invalidAttributes: Array<string>) {}\n-\n-  hasProperty(tagName: string, property: string, schemas: core.SchemaMetadata[]): boolean {\n-    const value = this.existingProperties[property];\n-    return value === void 0 ? true : value;\n-  }\n-\n-  hasElement(tagName: string, schemaMetas: core.SchemaMetadata[]): boolean {\n-    const value = this.existingElements[tagName.toLowerCase()];\n-    return value === void 0 ? true : value;\n-  }\n-\n-  allKnownElementNames(): string[] {\n-    return Object.keys(this.existingElements);\n-  }\n-\n-  securityContext(selector: string, property: string, isAttribute: boolean): core.SecurityContext {\n-    return core.SecurityContext.NONE;\n-  }\n-\n-  getMappedPropName(attrName: string): string {\n-    return this.attrPropMapping[attrName] || attrName;\n-  }\n-\n-  getDefaultComponentElementName(): string {\n-    return 'ng-component';\n-  }\n-\n-  validateProperty(name: string): {error: boolean, msg?: string} {\n-    if (this.invalidProperties.indexOf(name) > -1) {\n-      return {error: true, msg: `Binding to property '${name}' is disallowed for security reasons`};\n-    } else {\n-      return {error: false};\n-    }\n-  }\n-\n-  validateAttribute(name: string): {error: boolean, msg?: string} {\n-    if (this.invalidAttributes.indexOf(name) > -1) {\n-      return {\n-        error: true,\n-        msg: `Binding to attribute '${name}' is disallowed for security reasons`\n-      };\n-    } else {\n-      return {error: false};\n-    }\n-  }\n-\n-  normalizeAnimationStyleProperty(propName: string): string {\n-    return propName;\n-  }\n-  normalizeAnimationStyleValue(camelCaseProp: string, userProvidedProp: string, val: string|number):\n-      {error: string, value: string} {\n-    return {error: null!, value: val.toString()};\n-  }\n-}"
        },
        {
            "sha": "90f4df4bba99257b95a542e2152042235ae82d1f",
            "filename": "packages/compiler/testing/src/testing.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftesting%2Fsrc%2Ftesting.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcompiler%2Ftesting%2Fsrc%2Ftesting.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftesting%2Fsrc%2Ftesting.ts?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -21,8 +21,10 @@\n  *   </p>\n  * </div>\n  */\n-export * from './resource_loader_mock';\n-export * from './schema_registry_mock';\n-export * from './directive_resolver_mock';\n-export * from './ng_module_resolver_mock';\n-export * from './pipe_resolver_mock';\n+\n+// TODO(alxhub): @angular/compiler/testing is unused in Ivy. A placeholder\n+// is left here because the components repo still depends on this package\n+// directly. It will be cleaned up at a later date.\n+//\n+// This export ensures this package is not empty.\n+export const unusedExport = true;"
        },
        {
            "sha": "3446327df5e8b39e0a1a7f9511a51daf116f512e",
            "filename": "packages/core/test/BUILD.bazel",
            "status": "modified",
            "additions": 22,
            "deletions": 4,
            "changes": 26,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2FBUILD.bazel?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -32,26 +32,41 @@ genrule(\n     tools = [\"@npm//typescript/bin:tsc\"],\n )\n \n+UTILS = [\n+    \"linker/source_map_util.ts\",\n+]\n+\n+ts_library(\n+    name = \"test_utils\",\n+    testonly = True,\n+    srcs = UTILS,\n+    deps = [\n+        \"//packages/compiler\",\n+        \"@npm//base64-js\",\n+        \"@npm//source-map\",\n+    ],\n+)\n+\n ts_library(\n     name = \"test_lib\",\n     testonly = True,\n     srcs = glob(\n         [\"**/*.ts\"],\n-        exclude = [\n+        exclude = UTILS + [\n             \"**/*_node_only_spec.ts\",\n             \"reflection/es2015_inheritance_fixture.ts\",\n         ],\n     ),\n     # Visible to //:saucelabs_unit_tests_poc target\n     visibility = [\"//:__pkg__\"],\n     deps = [\n+        \":test_utils\",\n         \"//packages/animations\",\n         \"//packages/animations/browser\",\n         \"//packages/animations/browser/testing\",\n         \"//packages/common\",\n         \"//packages/common/locales\",\n         \"//packages/compiler\",\n-        \"//packages/compiler/testing\",\n         \"//packages/core\",\n         \"//packages/core/src/di/interface\",\n         \"//packages/core/src/interface\",\n@@ -74,11 +89,14 @@ ts_library(\n ts_library(\n     name = \"test_node_only_lib\",\n     testonly = True,\n-    srcs = glob([\"**/*_node_only_spec.ts\"]),\n+    srcs = glob(\n+        [\"**/*_node_only_spec.ts\"],\n+        exclude = UTILS,\n+    ),\n     deps = [\n         \":test_lib\",\n+        \":test_utils\",\n         \"//packages/compiler\",\n-        \"//packages/compiler/testing\",\n         \"//packages/core\",\n         \"//packages/core/src/compiler\",\n         \"//packages/core/testing\","
        },
        {
            "sha": "d973f707fe4c2345004cf31ddc6ad8e6600a62de",
            "filename": "packages/core/test/acceptance/BUILD.bazel",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftest%2Facceptance%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftest%2Facceptance%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2FBUILD.bazel?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -1,7 +1,7 @@\n-package(default_visibility = [\"//visibility:private\"])\n-\n load(\"//tools:defaults.bzl\", \"jasmine_node_test\", \"karma_web_test_suite\", \"ts_library\")\n \n+package(default_visibility = [\"//visibility:private\"])\n+\n ts_library(\n     name = \"acceptance_lib\",\n     testonly = True,\n@@ -17,7 +17,6 @@ ts_library(\n         \"//packages/common\",\n         \"//packages/common/locales\",\n         \"//packages/compiler\",\n-        \"//packages/compiler/testing\",\n         \"//packages/core\",\n         \"//packages/core/src/util\",\n         \"//packages/core/test/render3:matchers\","
        },
        {
            "sha": "828c01e96b1a0fff46475d73017be4ddd46c333b",
            "filename": "packages/core/test/bundling/core_all/BUILD.bazel",
            "status": "modified",
            "additions": 2,
            "deletions": 23,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftest%2Fbundling%2Fcore_all%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftest%2Fbundling%2Fcore_all%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Fcore_all%2FBUILD.bazel?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -27,35 +27,14 @@ js_size_tracking_test(\n     src = \"angular/packages/core/test/bundling/core_all/bundle.min.js\",\n     angular_ivy_enabled = \"True\",\n     data = [\n-        \"bundle.golden_size_map_ivy.json\",\n+        \"bundle.golden_size_map.json\",\n         \":bundle\",\n     ],\n-    golden_file = \"angular/packages/core/test/bundling/core_all/bundle.golden_size_map_ivy.json\",\n+    golden_file = \"angular/packages/core/test/bundling/core_all/bundle.golden_size_map.json\",\n     max_byte_diff = 250,\n     max_percentage_diff = 15,\n     source_map = \"angular/packages/core/test/bundling/core_all/bundle.min.js.map\",\n     tags = [\n         \"manual\",\n     ],\n )\n-\n-js_size_tracking_test(\n-    name = \"size_test_view_engine\",\n-    src = \"angular/packages/core/test/bundling/core_all/bundle.min.js\",\n-    # Ensures that this target runs with `--config=view-engine`. This is\n-    # necessary because we don't run this test on CI currently, but if we run it manually,\n-    # we need to ensure that it runs with View Engine for proper size comparisons.\n-    angular_ivy_enabled = \"False\",\n-    data = [\n-        \"bundle.golden_size_map_view_engine.json\",\n-        \":bundle\",\n-    ],\n-    golden_file = \"angular/packages/core/test/bundling/core_all/bundle.golden_size_map_view_engine.json\",\n-    max_byte_diff = 250,\n-    max_percentage_diff = 15,\n-    source_map = \"angular/packages/core/test/bundling/core_all/bundle.min.js.map\",\n-    tags = [\n-        \"manual\",\n-        \"view-engine-only\",\n-    ],\n-)"
        },
        {
            "sha": "85047305d61bf920902d00b4999ad8e7c749af82",
            "filename": "packages/core/test/bundling/core_all/bundle.golden_size_map.json",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftest%2Fbundling%2Fcore_all%2Fbundle.golden_size_map.json",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftest%2Fbundling%2Fcore_all%2Fbundle.golden_size_map.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Fcore_all%2Fbundle.golden_size_map.json?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "previous_filename": "packages/core/test/bundling/core_all/bundle.golden_size_map_ivy.json"
        },
        {
            "sha": "bbff0f85c26be3a841cc502a816a39053958fa76",
            "filename": "packages/core/test/bundling/core_all/bundle.golden_size_map_view_engine.json",
            "status": "removed",
            "additions": 0,
            "deletions": 366,
            "changes": 366,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fbundling%2Fcore_all%2Fbundle.golden_size_map_view_engine.json",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fbundling%2Fcore_all%2Fbundle.golden_size_map_view_engine.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Fcore_all%2Fbundle.golden_size_map_view_engine.json?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,366 +0,0 @@\n-{\n-  \"unmapped\": 21331,\n-  \"files\": {\n-    \"size\": 274151,\n-    \"@angular/\": {\n-      \"size\": 241140,\n-      \"core/\": {\n-        \"size\": 241140,\n-        \"src/\": {\n-          \"size\": 241126,\n-          \"application_init.ts\": 539,\n-          \"application_module.ts\": 531,\n-          \"application_ref.ts\": 6867,\n-          \"application_tokens.ts\": 302,\n-          \"change_detection/\": {\n-            \"size\": 13979,\n-            \"change_detection.ts\": 46,\n-            \"change_detection_util.ts\": 813,\n-            \"change_detector_ref.ts\": 163,\n-            \"constants.ts\": 311,\n-            \"differs/\": {\n-              \"size\": 12646,\n-              \"default_iterable_differ.ts\": 7551,\n-              \"default_keyvalue_differ.ts\": 3846,\n-              \"iterable_differs.ts\": 654,\n-              \"keyvalue_differs.ts\": 595\n-            }\n-          },\n-          \"compiler/\": {\n-            \"size\": 442,\n-            \"compiler_facade.ts\": 442\n-          },\n-          \"console.ts\": 140,\n-          \"debug/\": {\n-            \"size\": 6955,\n-            \"debug_node.ts\": 6955\n-          },\n-          \"di/\": {\n-            \"size\": 21250,\n-            \"forward_ref.ts\": 229,\n-            \"injectable.ts\": 207,\n-            \"injection_token.ts\": 336,\n-            \"injector.ts\": 3375,\n-            \"injector_compatibility.ts\": 1879,\n-            \"interface/\": {\n-              \"size\": 761,\n-              \"defs.ts\": 623,\n-              \"injector.ts\": 138\n-            },\n-            \"jit/\": {\n-              \"size\": 2127,\n-              \"environment.ts\": 227,\n-              \"injectable.ts\": 801,\n-              \"util.ts\": 1099\n-            },\n-            \"metadata.ts\": 163,\n-            \"r3_injector.ts\": 4593,\n-            \"reflective_errors.ts\": 1376,\n-            \"reflective_injector.ts\": 2940,\n-            \"reflective_key.ts\": 589,\n-            \"reflective_provider.ts\": 2001,\n-            \"scope.ts\": 32,\n-            \"util.ts\": 642\n-          },\n-          \"error_handler.ts\": 444,\n-          \"errors.ts\": 171,\n-          \"event_emitter.ts\": 943,\n-          \"i18n/\": {\n-            \"size\": 2266,\n-            \"locale_data.ts\": 740,\n-            \"locale_data_api.ts\": 247,\n-            \"locale_en.ts\": 929,\n-            \"localization.ts\": 182,\n-            \"tokens.ts\": 168\n-          },\n-          \"interface/\": {\n-            \"size\": 224,\n-            \"simple_change.ts\": 170,\n-            \"type.ts\": 54\n-          },\n-          \"ivy_switch.ts\": 4,\n-          \"linker/\": {\n-            \"size\": 4981,\n-            \"compiler.ts\": 809,\n-            \"component_factory.ts\": 82,\n-            \"component_factory_resolver.ts\": 994,\n-            \"element_ref.ts\": 116,\n-            \"ng_module_factory.ts\": 78,\n-            \"ng_module_factory_loader.ts\": 218,\n-            \"ng_module_factory_registration.ts\": 436,\n-            \"query_list.ts\": 1040,\n-            \"system_js_ng_module_factory_loader.ts\": 918,\n-            \"template_ref.ts\": 94,\n-            \"view_container_ref.ts\": 94,\n-            \"view_ref.ts\": 102\n-          },\n-          \"metadata/\": {\n-            \"size\": 2425,\n-            \"di.ts\": 546,\n-            \"directives.ts\": 600,\n-            \"ng_module.ts\": 251,\n-            \"resource_loading.ts\": 857,\n-            \"schema.ts\": 51,\n-            \"view.ts\": 120\n-          },\n-          \"platform_core_providers.ts\": 118,\n-          \"profile/\": {\n-            \"size\": 442,\n-            \"profile.ts\": 170,\n-            \"wtf_impl.ts\": 272\n-          },\n-          \"reflection/\": {\n-            \"size\": 4878,\n-            \"reflection.ts\": 16,\n-            \"reflection_capabilities.ts\": 3677,\n-            \"reflector.ts\": 1185\n-          },\n-          \"render/\": {\n-            \"size\": 472,\n-            \"api.ts\": 472\n-          },\n-          \"render3/\": {\n-            \"size\": 98145,\n-            \"bindings.ts\": 308,\n-            \"component.ts\": 1254,\n-            \"component_ref.ts\": 2311,\n-            \"context_discovery.ts\": 2098,\n-            \"definition.ts\": 2565,\n-            \"di.ts\": 3517,\n-            \"di_setup.ts\": 1576,\n-            \"empty.ts\": 16,\n-            \"errors.ts\": 472,\n-            \"features/\": {\n-              \"size\": 2573,\n-              \"inherit_definition_feature.ts\": 1889,\n-              \"ng_onchanges_feature.ts\": 571,\n-              \"providers_feature.ts\": 113\n-            },\n-            \"fields.ts\": 187,\n-            \"hooks.ts\": 1748,\n-            \"i18n.ts\": 8980,\n-            \"instructions/\": {\n-              \"size\": 24631,\n-              \"advance.ts\": 231,\n-              \"alloc_host_vars.ts\": 290,\n-              \"attribute.ts\": 78,\n-              \"attribute_interpolation.ts\": 1003,\n-              \"change_detection.ts\": 62,\n-              \"class_map_interpolation.ts\": 675,\n-              \"container.ts\": 945,\n-              \"di.ts\": 130,\n-              \"element.ts\": 877,\n-              \"element_container.ts\": 451,\n-              \"embedded_view.ts\": 655,\n-              \"get_current_view.ts\": 26,\n-              \"host_property.ts\": 165,\n-              \"interpolation.ts\": 1194,\n-              \"listener.ts\": 1431,\n-              \"lview_debug.ts\": 685,\n-              \"next_context.ts\": 44,\n-              \"projection.ts\": 517,\n-              \"property.ts\": 78,\n-              \"property_interpolation.ts\": 1008,\n-              \"shared.ts\": 10199,\n-              \"storage.ts\": 136,\n-              \"style_prop_interpolation.ts\": 837,\n-              \"styling.ts\": 1870,\n-              \"text.ts\": 116,\n-              \"text_interpolation.ts\": 928\n-            },\n-            \"interfaces/\": {\n-              \"size\": 909,\n-              \"container.ts\": 34,\n-              \"context.ts\": 23,\n-              \"i18n.ts\": 48,\n-              \"injector.ts\": 227,\n-              \"renderer.ts\": 165,\n-              \"type_checks.ts\": 302,\n-              \"view.ts\": 110\n-            },\n-            \"jit/\": {\n-              \"size\": 10595,\n-              \"directive.ts\": 3998,\n-              \"environment.ts\": 3364,\n-              \"module.ts\": 2764,\n-              \"pipe.ts\": 469\n-            },\n-            \"metadata.ts\": 392,\n-            \"ng_module_ref.ts\": 966,\n-            \"node_manipulation.ts\": 4148,\n-            \"node_selector_matcher.ts\": 1650,\n-            \"node_util.ts\": 222,\n-            \"pipe.ts\": 1034,\n-            \"pure_function.ts\": 1274,\n-            \"query.ts\": 5226,\n-            \"state.ts\": 1311,\n-            \"styling/\": {\n-              \"size\": 5655,\n-              \"bindings.ts\": 3235,\n-              \"map_based_bindings.ts\": 941,\n-              \"state.ts\": 403,\n-              \"styling_debug.ts\": 1076\n-            },\n-            \"tokens.ts\": 10,\n-            \"util/\": {\n-              \"size\": 6561,\n-              \"attrs_utils.ts\": 374,\n-              \"discovery_utils.ts\": 1984,\n-              \"global_utils.ts\": 330,\n-              \"injector_utils.ts\": 150,\n-              \"misc_utils.ts\": 575,\n-              \"styling_utils.ts\": 2381,\n-              \"view_traversal_utils.ts\": 228,\n-              \"view_utils.ts\": 539\n-            },\n-            \"view_engine_compatibility.ts\": 3713,\n-            \"view_engine_compatibility_prebound.ts\": 180,\n-            \"view_ref.ts\": 2063\n-          },\n-          \"sanitization/\": {\n-            \"size\": 10193,\n-            \"bypass.ts\": 1241,\n-            \"html_sanitizer.ts\": 4491,\n-            \"inert_body.ts\": 2066,\n-            \"sanitization.ts\": 1065,\n-            \"sanitizer.ts\": 121,\n-            \"security.ts\": 160,\n-            \"style_sanitizer.ts\": 576,\n-            \"url_sanitizer.ts\": 473\n-          },\n-          \"testability/\": {\n-            \"size\": 3154,\n-            \"testability.ts\": 3154\n-          },\n-          \"util/\": {\n-            \"size\": 4294,\n-            \"array_utils.ts\": 467,\n-            \"assert.ts\": 116,\n-            \"closure.ts\": 37,\n-            \"comparison.ts\": 90,\n-            \"decorators.ts\": 1606,\n-            \"errors.ts\": 164,\n-            \"global.ts\": 243,\n-            \"is_dev_mode.ts\": 138,\n-            \"lang.ts\": 109,\n-            \"microtask.ts\": 180,\n-            \"ng_reflect.ts\": 330,\n-            \"noop.ts\": 68,\n-            \"property.ts\": 201,\n-            \"stringify.ts\": 290,\n-            \"symbol.ts\": 255\n-          },\n-          \"version.ts\": 179,\n-          \"view/\": {\n-            \"size\": 54087,\n-            \"element.ts\": 3697,\n-            \"entrypoint.ts\": 698,\n-            \"errors.ts\": 642,\n-            \"ng_content.ts\": 440,\n-            \"ng_module.ts\": 2384,\n-            \"provider.ts\": 5331,\n-            \"pure_expression.ts\": 2195,\n-            \"query.ts\": 2378,\n-            \"refs.ts\": 8739,\n-            \"services.ts\": 11374,\n-            \"text.ts\": 1525,\n-            \"types.ts\": 768,\n-            \"util.ts\": 4652,\n-            \"view.ts\": 8133,\n-            \"view_attach.ts\": 1131\n-          },\n-          \"zone/\": {\n-            \"size\": 2701,\n-            \"ng_zone.ts\": 2701\n-          }\n-        },\n-        \"test/\": {\n-          \"size\": 14,\n-          \"bundling/\": {\n-            \"size\": 14,\n-            \"core_all/\": {\n-              \"size\": 14,\n-              \"index.ts\": 14\n-            }\n-          }\n-        }\n-      }\n-    },\n-    \"external/\": {\n-      \"size\": 11680,\n-      \"npm/\": {\n-        \"size\": 11680,\n-        \"node_modules/\": {\n-          \"size\": 11680,\n-          \"rxjs/\": {\n-            \"size\": 10200,\n-            \"src/\": {\n-              \"size\": 10200,\n-              \"internal/\": {\n-                \"size\": 10200,\n-                \"InnerSubscriber.ts\": 247,\n-                \"Notification.ts\": 15,\n-                \"Observable.ts\": 622,\n-                \"Observer.ts\": 78,\n-                \"OuterSubscriber.ts\": 80,\n-                \"Subject.ts\": 1102,\n-                \"SubjectSubscription.ts\": 268,\n-                \"Subscriber.ts\": 2066,\n-                \"Subscription.ts\": 783,\n-                \"config.ts\": 32,\n-                \"observable/\": {\n-                  \"size\": 2105,\n-                  \"ConnectableObservable.ts\": 978,\n-                  \"from.ts\": 67,\n-                  \"fromArray.ts\": 132,\n-                  \"fromIterable.ts\": 224,\n-                  \"fromObservable.ts\": 315,\n-                  \"fromPromise.ts\": 217,\n-                  \"merge.ts\": 172\n-                },\n-                \"operators/\": {\n-                  \"size\": 1651,\n-                  \"map.ts\": 235,\n-                  \"mergeAll.ts\": 22,\n-                  \"mergeMap.ts\": 712,\n-                  \"multicast.ts\": 264,\n-                  \"refCount.ts\": 400,\n-                  \"share.ts\": 14,\n-                  \"windowToggle.ts\": 4\n-                },\n-                \"symbol/\": {\n-                  \"size\": 103,\n-                  \"iterator.ts\": 55,\n-                  \"rxSubscriber.ts\": 48\n-                },\n-                \"util/\": {\n-                  \"size\": 1048,\n-                  \"EmptyError.ts\": 6,\n-                  \"ObjectUnsubscribedError.ts\": 137,\n-                  \"UnsubscriptionError.ts\": 243,\n-                  \"canReportError.ts\": 56,\n-                  \"isInteropObservable.ts\": 14,\n-                  \"isIterable.ts\": 14,\n-                  \"isObject.ts\": 3,\n-                  \"isScheduler.ts\": 5,\n-                  \"pipe.ts\": 32,\n-                  \"subscribeTo.ts\": 181,\n-                  \"subscribeToArray.ts\": 9,\n-                  \"subscribeToIterable.ts\": 126,\n-                  \"subscribeToObservable.ts\": 48,\n-                  \"subscribeToPromise.ts\": 58,\n-                  \"subscribeToResult.ts\": 65,\n-                  \"toSubscriber.ts\": 51\n-                }\n-              }\n-            }\n-          },\n-          \"tslib/\": {\n-            \"size\": 1480,\n-            \"tslib.es6.js\": 1480\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n\\ No newline at end of file"
        },
        {
            "sha": "33591c2c5d01ba87e53073fbe4f23a392e12a425",
            "filename": "packages/core/test/linker/change_detection_integration_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftest%2Flinker%2Fchange_detection_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftest%2Flinker%2Fchange_detection_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Fchange_detection_integration_spec.ts?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -7,14 +7,15 @@\n  */\n \n import {ResourceLoader, UrlResolver} from '@angular/compiler';\n-import {MockResourceLoader} from '@angular/compiler/testing';\n import {AfterContentChecked, AfterContentInit, AfterViewChecked, AfterViewInit, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, DebugElement, Directive, DoCheck, EventEmitter, HostBinding, Injectable, Input, OnChanges, OnDestroy, OnInit, Output, Pipe, PipeTransform, Provider, RendererFactory2, RendererType2, SimpleChange, SimpleChanges, TemplateRef, Type, ViewChild, ViewContainerRef} from '@angular/core';\n import {ComponentFixture, fakeAsync, TestBed} from '@angular/core/testing';\n import {By} from '@angular/platform-browser/src/dom/debug/by';\n import {isTextNode} from '@angular/platform-browser/testing/src/browser_util';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n import {ivyEnabled, modifiedInIvy, onlyInIvy} from '@angular/private/testing';\n \n+import {MockResourceLoader} from './resource_loader_mock';\n+\n export function createUrlResolverWithoutPackagePrefix(): UrlResolver {\n   return new UrlResolver();\n }\n@@ -1329,7 +1330,7 @@ describe(`ChangeDetection`, () => {\n            // TODO(issue/24571): remove '!'.\n            @ViewChild('vc', {read: ViewContainerRef, static: true}) vc!: ViewContainerRef;\n            // TODO(issue/24571): remove '!'.\n-           @ViewChild(TemplateRef, {static: true}) template !: TemplateRef<any>;\n+           @ViewChild(TemplateRef, {static: true}) template!: TemplateRef<any>;\n          }\n \n          TestBed.configureTestingModule({declarations: [Comp]});"
        },
        {
            "sha": "436e8aa1df3e44b51d9dfdc64581596498c6ca52",
            "filename": "packages/core/test/linker/jit_summaries_integration_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 294,
            "changes": 294,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Flinker%2Fjit_summaries_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Flinker%2Fjit_summaries_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Fjit_summaries_integration_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,294 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ResourceLoader} from '@angular/compiler';\n-import {CompileMetadataResolver} from '@angular/compiler/src/metadata_resolver';\n-import {MockResourceLoader} from '@angular/compiler/testing/src/resource_loader_mock';\n-import {Component, Directive, Injectable, NgModule, OnDestroy, Pipe} from '@angular/core';\n-import {getTestBed, TestBed, waitForAsync} from '@angular/core/testing';\n-import {expect} from '@angular/platform-browser/testing/src/matchers';\n-import {obsoleteInIvy} from '@angular/private/testing';\n-\n-{\n-  obsoleteInIvy('Summaries are not used/supported/able to be produced in Ivy. See FW-838.')\n-      .describe('Jit Summaries', () => {\n-        let instances: Map<any, Base>;\n-        let summaries: () => any[];\n-\n-        class SomeDep {}\n-\n-        class Base {\n-          static annotations: any[];\n-          static parameters: any[][];\n-\n-          constructor(public dep: SomeDep) {\n-            instances.set(Object.getPrototypeOf(this).constructor, this);\n-          }\n-        }\n-\n-        function expectInstanceCreated(type: any) {\n-          const instance = instances.get(type)!;\n-          expect(instance).toBeDefined();\n-          expect(instance.dep instanceof SomeDep).toBe(true);\n-        }\n-\n-        class SomeModule extends Base {}\n-\n-        class SomePrivateComponent extends Base {}\n-\n-        class SomePublicComponent extends Base {}\n-\n-        class SomeDirective extends Base {}\n-\n-        class SomePipe extends Base {\n-          transform(value: any) {\n-            return value;\n-          }\n-        }\n-\n-        class SomeService extends Base {}\n-\n-        // Move back into the it which needs it after https://github.com/angular/tsickle/issues/547\n-        // is\n-        // fixed.\n-        @Component({template: '<div someDir>{{1 | somePipe}}</div>'})\n-        class TestComp3 {\n-          constructor(service: SomeService) {}\n-        }\n-\n-        @Component({template: ''})\n-        class TestCompErrorOnDestroy implements OnDestroy {\n-          ngOnDestroy() {}\n-        }\n-\n-        function resetTestEnvironmentWithSummaries(summaries?: () => any[]) {\n-          const {platform, ngModule} = getTestBed();\n-          TestBed.resetTestEnvironment();\n-          TestBed.initTestEnvironment(ngModule, platform, summaries);\n-        }\n-\n-        function createSummaries() {\n-          const resourceLoader = new MockResourceLoader();\n-\n-          setMetadata(resourceLoader);\n-\n-          TestBed.configureCompiler(\n-              {providers: [{provide: ResourceLoader, useValue: resourceLoader}]});\n-          TestBed.configureTestingModule({imports: [SomeModule], providers: [SomeDep]});\n-\n-          let summariesPromise = TestBed.compileComponents().then(() => {\n-            const metadataResolver = TestBed.inject(CompileMetadataResolver);\n-            const summaries = [\n-              metadataResolver.getNgModuleSummary(SomeModule),\n-              // test nesting via closures, as we use this in the generated code too.\n-              () =>\n-                  [metadataResolver.getDirectiveSummary(SomePublicComponent),\n-                   metadataResolver.getDirectiveSummary(SomePrivateComponent),\n-            ],\n-              metadataResolver.getDirectiveSummary(SomeDirective),\n-              metadataResolver.getPipeSummary(SomePipe),\n-              metadataResolver.getInjectableSummary(SomeService)\n-            ];\n-            clearMetadata();\n-            TestBed.resetTestingModule();\n-            return () => summaries;\n-          });\n-\n-          resourceLoader.flush();\n-          return summariesPromise;\n-        }\n-\n-        function setMetadata(resourceLoader: MockResourceLoader) {\n-          Base.parameters = [[SomeDep]];\n-\n-          SomeModule.annotations = [new NgModule({\n-            declarations: [SomePublicComponent, SomePrivateComponent, SomeDirective, SomePipe],\n-            exports: [SomeDirective, SomePipe, SomePublicComponent],\n-            providers: [SomeService]\n-          })];\n-\n-          SomePublicComponent.annotations = [new Component({templateUrl: 'somePublicUrl.html'})];\n-          resourceLoader.expect('somePublicUrl.html', `Hello public world!`);\n-\n-          SomePrivateComponent.annotations = [new Component({templateUrl: 'somePrivateUrl.html'})];\n-          resourceLoader.expect('somePrivateUrl.html', `Hello private world!`);\n-\n-          SomeDirective.annotations = [new Directive({selector: '[someDir]'})];\n-\n-          SomePipe.annotations = [new Pipe({name: 'somePipe'})];\n-\n-          SomeService.annotations = [new Injectable()];\n-        }\n-\n-        function clearMetadata() {\n-          Base.parameters = [];\n-          SomeModule.annotations = [];\n-          SomePublicComponent.annotations = [];\n-          SomePrivateComponent.annotations = [];\n-          SomeDirective.annotations = [];\n-          SomePipe.annotations = [];\n-          SomeService.annotations = [];\n-        }\n-\n-        beforeEach(waitForAsync(() => {\n-          instances = new Map<any, any>();\n-          createSummaries().then(s => summaries = s);\n-        }));\n-\n-        afterEach(() => {\n-          resetTestEnvironmentWithSummaries();\n-        });\n-\n-        it('should use directive metadata from summaries', () => {\n-          resetTestEnvironmentWithSummaries(summaries);\n-\n-          @Component({template: '<div someDir></div>'})\n-          class TestComp {\n-          }\n-\n-          TestBed\n-              .configureTestingModule(\n-                  {providers: [SomeDep], declarations: [TestComp, SomeDirective]})\n-              .createComponent(TestComp);\n-          expectInstanceCreated(SomeDirective);\n-        });\n-\n-\n-        it('should use pipe metadata from summaries', () => {\n-          resetTestEnvironmentWithSummaries(summaries);\n-\n-          @Component({template: '{{1 | somePipe}}'})\n-          class TestComp {\n-          }\n-\n-          TestBed.configureTestingModule({providers: [SomeDep], declarations: [TestComp, SomePipe]})\n-              .createComponent(TestComp);\n-          expectInstanceCreated(SomePipe);\n-        });\n-\n-        it('should use Service metadata from summaries', () => {\n-          resetTestEnvironmentWithSummaries(summaries);\n-\n-          TestBed.configureTestingModule({\n-            providers: [SomeService, SomeDep],\n-          });\n-          TestBed.inject(SomeService);\n-          expectInstanceCreated(SomeService);\n-        });\n-\n-        it('should use NgModule metadata from summaries', () => {\n-          resetTestEnvironmentWithSummaries(summaries);\n-\n-          TestBed\n-              .configureTestingModule(\n-                  {providers: [SomeDep], declarations: [TestComp3], imports: [SomeModule]})\n-              .createComponent(TestComp3);\n-\n-          expectInstanceCreated(SomeModule);\n-          expectInstanceCreated(SomeDirective);\n-          expectInstanceCreated(SomePipe);\n-          expectInstanceCreated(SomeService);\n-        });\n-\n-        it('should allow to create private components from imported NgModule summaries', () => {\n-          resetTestEnvironmentWithSummaries(summaries);\n-\n-          TestBed.configureTestingModule({providers: [SomeDep], imports: [SomeModule]})\n-              .createComponent(SomePrivateComponent);\n-          expectInstanceCreated(SomePrivateComponent);\n-        });\n-\n-        it('should throw when trying to mock a type with a summary', () => {\n-          resetTestEnvironmentWithSummaries(summaries);\n-\n-          TestBed.resetTestingModule();\n-          expect(\n-              () => TestBed.overrideComponent(SomePrivateComponent, {add: {}}).compileComponents())\n-              .toThrowError(\n-                  'SomePrivateComponent was AOT compiled, so its metadata cannot be changed.');\n-          TestBed.resetTestingModule();\n-          expect(() => TestBed.overrideDirective(SomeDirective, {add: {}}).compileComponents())\n-              .toThrowError('SomeDirective was AOT compiled, so its metadata cannot be changed.');\n-          TestBed.resetTestingModule();\n-          expect(() => TestBed.overridePipe(SomePipe, {add: {name: 'test'}}).compileComponents())\n-              .toThrowError('SomePipe was AOT compiled, so its metadata cannot be changed.');\n-          TestBed.resetTestingModule();\n-          expect(() => TestBed.overrideModule(SomeModule, {add: {}}).compileComponents())\n-              .toThrowError('SomeModule was AOT compiled, so its metadata cannot be changed.');\n-        });\n-\n-        it('should return stack trace and component data on resetTestingModule when error is thrown',\n-           () => {\n-             resetTestEnvironmentWithSummaries();\n-\n-             const fixture =\n-                 TestBed.configureTestingModule({declarations: [TestCompErrorOnDestroy]})\n-                     .createComponent<TestCompErrorOnDestroy>(TestCompErrorOnDestroy);\n-\n-             const expectedError = 'Error from ngOnDestroy';\n-\n-             const component: TestCompErrorOnDestroy = fixture.componentInstance;\n-\n-             spyOn(console, 'error');\n-             spyOn(component, 'ngOnDestroy').and.throwError(expectedError);\n-\n-             const expectedObject = {\n-               stacktrace: new Error(expectedError),\n-               component,\n-             };\n-\n-             expect(() => TestBed.resetTestingModule())\n-                 .toThrowError('1 component threw errors during cleanup');\n-             expect(console.error)\n-                 .toHaveBeenCalledWith('Error during cleanup of component', expectedObject);\n-           });\n-\n-        it('should allow to add summaries via configureTestingModule', () => {\n-          resetTestEnvironmentWithSummaries();\n-\n-          @Component({template: '<div someDir></div>'})\n-          class TestComp {\n-          }\n-\n-          TestBed\n-              .configureTestingModule({\n-                providers: [SomeDep],\n-                declarations: [TestComp, SomeDirective],\n-                aotSummaries: summaries\n-              })\n-              .createComponent(TestComp);\n-          expectInstanceCreated(SomeDirective);\n-        });\n-\n-        it('should allow to override a provider', () => {\n-          resetTestEnvironmentWithSummaries(summaries);\n-\n-          const overwrittenValue = {};\n-\n-          const fixture =\n-              TestBed.overrideProvider(SomeDep, {useFactory: () => overwrittenValue, deps: []})\n-                  .configureTestingModule({providers: [SomeDep], imports: [SomeModule]})\n-                  .createComponent<SomePublicComponent>(SomePublicComponent);\n-\n-          expect(fixture.componentInstance.dep).toBe(overwrittenValue);\n-        });\n-\n-        it('should allow to override a template', () => {\n-          resetTestEnvironmentWithSummaries(summaries);\n-\n-          TestBed.overrideTemplateUsingTestingModule(SomePublicComponent, 'overwritten');\n-\n-          const fixture =\n-              TestBed.configureTestingModule({providers: [SomeDep], imports: [SomeModule]})\n-                  .createComponent(SomePublicComponent);\n-          expectInstanceCreated(SomePublicComponent);\n-\n-          expect(fixture.nativeElement).toHaveText('overwritten');\n-        });\n-      });\n-}"
        },
        {
            "sha": "114c67b971e266f3fffeaac8ca468ff56ded3f0e",
            "filename": "packages/core/test/linker/resource_loader_mock.ts",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftest%2Flinker%2Fresource_loader_mock.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftest%2Flinker%2Fresource_loader_mock.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Fresource_loader_mock.ts?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "previous_filename": "packages/compiler/testing/src/resource_loader_mock.ts"
        },
        {
            "sha": "c8ac79d7867f74ab8c73c959cb4e9fbfe1b38d78",
            "filename": "packages/core/test/linker/source_map_integration_node_only_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftest%2Flinker%2Fsource_map_integration_node_only_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftest%2Flinker%2Fsource_map_integration_node_only_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Fsource_map_integration_node_only_spec.ts?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -10,15 +10,16 @@ import {ResourceLoader, SourceMap} from '@angular/compiler';\n import {CompilerFacadeImpl} from '@angular/compiler/src/jit_compiler_facade';\n import {JitEvaluator} from '@angular/compiler/src/output/output_jit';\n import {escapeRegExp} from '@angular/compiler/src/util';\n-import {extractSourceMap, originalPositionFor} from '@angular/compiler/testing/src/output/source_map_util';\n-import {MockResourceLoader} from '@angular/compiler/testing/src/resource_loader_mock';\n import {Attribute, Component, Directive, ErrorHandler, ɵglobal} from '@angular/core';\n import {CompilerFacade, ExportedCompilerFacade} from '@angular/core/src/compiler/compiler_facade';\n import {getErrorLogger} from '@angular/core/src/errors';\n import {resolveComponentResources} from '@angular/core/src/metadata/resource_loading';\n import {fakeAsync, TestBed, tick} from '@angular/core/testing';\n import {modifiedInIvy, onlyInIvy} from '@angular/private/testing';\n \n+import {MockResourceLoader} from './resource_loader_mock';\n+import {extractSourceMap, originalPositionFor} from './source_map_util';\n+\n describe('jit source mapping', () => {\n   let resourceLoader: MockResourceLoader;\n   let jitEvaluator: MockJitEvaluator;"
        },
        {
            "sha": "03d43c059919c3bbe774d6389a877456923b0111",
            "filename": "packages/core/test/linker/source_map_util.ts",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftest%2Flinker%2Fsource_map_util.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftest%2Flinker%2Fsource_map_util.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Fsource_map_util.ts?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -0,0 +1,40 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {SourceMap} from '@angular/compiler';\n+import b64 from 'base64-js';\n+import {SourceMapConsumer} from 'source-map';\n+\n+export interface SourceLocation {\n+  line: number;\n+  column: number;\n+  source: string;\n+}\n+\n+export function originalPositionFor(\n+    sourceMap: SourceMap, genPosition: {line: number, column: number}): SourceLocation {\n+  // Note: The `SourceMap` type from the compiler is different to `RawSourceMap`\n+  // from the `source-map` package, but the method we rely on works as expected.\n+  const smc = new SourceMapConsumer(sourceMap as any);\n+  // Note: We don't return the original object as it also contains a `name` property\n+  // which is always null and we don't want to include that in our assertions...\n+  const {line, column, source} = smc.originalPositionFor(genPosition);\n+  return {line, column, source};\n+}\n+\n+export function extractSourceMap(source: string): SourceMap|null {\n+  let idx = source.lastIndexOf('\\n//#');\n+  if (idx == -1) return null;\n+  const smComment = source.slice(idx).split('\\n', 2)[1].trim();\n+  const smB64 = smComment.split('sourceMappingURL=data:application/json;base64,')[1];\n+  return smB64 ? JSON.parse(decodeB64String(smB64)) as SourceMap : null;\n+}\n+\n+function decodeB64String(s: string): string {\n+  return b64.toByteArray(s).reduce((s: string, c: number) => s + String.fromCharCode(c), '');\n+}"
        },
        {
            "sha": "7031eea6c017f86b2c03421fdf7a7ac2ccca4c46",
            "filename": "packages/core/test/view/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 55,
            "changes": 55,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fview%2FBUILD.bazel?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,55 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"jasmine_node_test\", \"karma_web_test_suite\", \"ts_library\")\n-\n-package(default_visibility = [\"//visibility:public\"])\n-\n-ts_library(\n-    name = \"view_lib\",\n-    testonly = True,\n-    srcs = glob(\n-        [\"**/*.ts\"],\n-    ),\n-    deps = [\n-        \"//packages/common\",\n-        \"//packages/core\",\n-        \"//packages/core/src/di/interface\",\n-        \"//packages/core/src/interface\",\n-        \"//packages/core/src/util\",\n-        \"//packages/core/testing\",\n-        \"//packages/platform-browser\",\n-        \"//packages/private/testing\",\n-    ],\n-)\n-\n-ts_library(\n-    name = \"view_node_only_lib\",\n-    testonly = True,\n-    srcs = glob([\"**/*_node_only_spec.ts\"]),\n-    deps = [\n-        \":view_lib\",\n-        \"//packages/core\",\n-        \"//packages/core/testing\",\n-        \"//packages/private/testing\",\n-    ],\n-)\n-\n-jasmine_node_test(\n-    name = \"view\",\n-    bootstrap = [\"//tools/testing:node_es5\"],\n-    tags = [\n-        \"view-engine-only\",\n-    ],\n-    deps = [\n-        \":view_lib\",\n-        \":view_node_only_lib\",\n-    ],\n-)\n-\n-karma_web_test_suite(\n-    name = \"view_web\",\n-    tags = [\n-        \"view-engine-only\",\n-    ],\n-    deps = [\n-        \":view_lib\",\n-    ],\n-)"
        },
        {
            "sha": "9d4f0786514ace21ae86c0c9125e964ded5660f7",
            "filename": "packages/core/test/view/anchor_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 49,
            "changes": 49,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fanchor_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fanchor_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fview%2Fanchor_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,49 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ɵgetDOM as getDOM} from '@angular/common';\n-import {getDebugNode} from '@angular/core';\n-import {anchorDef, asElementData, elementDef, NodeFlags} from '@angular/core/src/view/index';\n-\n-import {compViewDef, createAndGetRootNodes} from './helper';\n-\n-{\n-  describe(`View Anchor`, () => {\n-    describe('create', () => {\n-      it('should create anchor nodes without parents', () => {\n-        const rootNodes = createAndGetRootNodes(compViewDef([\n-                            anchorDef(NodeFlags.None, null, null, 0)\n-                          ])).rootNodes;\n-        expect(rootNodes.length).toBe(1);\n-      });\n-\n-      it('should create views with multiple root anchor nodes', () => {\n-        const rootNodes =\n-            createAndGetRootNodes(compViewDef([\n-              anchorDef(NodeFlags.None, null, null, 0), anchorDef(NodeFlags.None, null, null, 0)\n-            ])).rootNodes;\n-        expect(rootNodes.length).toBe(2);\n-      });\n-\n-      it('should create anchor nodes with parents', () => {\n-        const rootNodes = createAndGetRootNodes(compViewDef([\n-                            elementDef(0, NodeFlags.None, null, null, 1, 'div'),\n-                            anchorDef(NodeFlags.None, null, null, 0),\n-                          ])).rootNodes;\n-        expect(rootNodes[0].childNodes.length).toBe(1);\n-      });\n-\n-      it('should add debug information to the renderer', () => {\n-        const someContext = {};\n-        const {view, rootNodes} = createAndGetRootNodes(\n-            compViewDef([anchorDef(NodeFlags.None, null, null, 0)]), someContext);\n-        expect(getDebugNode(rootNodes[0])!.nativeNode).toBe(asElementData(view, 0).renderElement);\n-      });\n-    });\n-  });\n-}"
        },
        {
            "sha": "9167fedad88ac1f3d360c26c1932ae230c528b82",
            "filename": "packages/core/test/view/component_view_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 353,
            "changes": 353,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fcomponent_view_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fcomponent_view_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fview%2Fcomponent_view_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,353 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ɵgetDOM as getDOM} from '@angular/common';\n-import {SecurityContext} from '@angular/core';\n-import {ArgumentType, asElementData, BindingFlags, directiveDef, elementDef, NodeCheckFn, NodeFlags, rootRenderNodes, Services, ViewData, ViewFlags, ViewState} from '@angular/core/src/view/index';\n-\n-import {callMostRecentEventListenerHandler, compViewDef, createAndGetRootNodes, createRootView, isBrowser, recordNodeToRemove} from './helper';\n-\n-\n-\n-/**\n- * We map addEventListener to the Zones internal name. This is because we want to be fast\n- * and bypass the zone bookkeeping. We know that we can do the bookkeeping faster.\n- */\n-const addEventListener = 'addEventListener';\n-\n-{\n-  describe(`Component Views`, () => {\n-    it('should create and attach component views', () => {\n-      let instance: AComp = undefined!;\n-      class AComp {\n-        constructor() {\n-          instance = this;\n-        }\n-      }\n-\n-      const {view, rootNodes} = createAndGetRootNodes(compViewDef([\n-        elementDef(\n-            0, NodeFlags.None, null, null, 1, 'div', null, null, null, null,\n-            () => compViewDef([\n-              elementDef(0, NodeFlags.None, null, null, 0, 'span'),\n-            ])),\n-        directiveDef(1, NodeFlags.Component, null, 0, AComp, []),\n-      ]));\n-\n-      const compView = asElementData(view, 0).componentView;\n-\n-      expect(compView.context).toBe(instance);\n-      expect(compView.component).toBe(instance);\n-\n-      const compRootEl = rootNodes[0].childNodes[0];\n-      expect(compRootEl.nodeName.toLowerCase()).toBe('span');\n-    });\n-\n-    if (isBrowser()) {\n-      describe('root views', () => {\n-        let rootNode: HTMLElement;\n-        beforeEach(() => {\n-          rootNode = document.createElement('root');\n-          document.body.appendChild(rootNode);\n-          recordNodeToRemove(rootNode);\n-        });\n-\n-        it('should select root elements based on a selector', () => {\n-          const view = createRootView(\n-              compViewDef([\n-                elementDef(0, NodeFlags.None, null, null, 0, 'div'),\n-              ]),\n-              {}, [], 'root');\n-          const rootNodes = rootRenderNodes(view);\n-          expect(rootNodes).toEqual([rootNode]);\n-        });\n-\n-        it('should select root elements based on a node', () => {\n-          const view = createRootView(\n-              compViewDef([\n-                elementDef(0, NodeFlags.None, null, null, 0, 'div'),\n-              ]),\n-              {}, [], rootNode);\n-          const rootNodes = rootRenderNodes(view);\n-          expect(rootNodes).toEqual([rootNode]);\n-        });\n-\n-        it('should set attributes on the root node', () => {\n-          createRootView(\n-              compViewDef([\n-                elementDef(0, NodeFlags.None, null, null, 0, 'div', [['a', 'b']]),\n-              ]),\n-              {}, [], rootNode);\n-          expect(rootNode.getAttribute('a')).toBe('b');\n-        });\n-\n-        it('should clear the content of the root node', () => {\n-          rootNode.appendChild(document.createElement('div'));\n-          createRootView(\n-              compViewDef([\n-                elementDef(0, NodeFlags.None, null, null, 0, 'div', [['a', 'b']]),\n-              ]),\n-              {}, [], rootNode);\n-          expect(rootNode.childNodes.length).toBe(0);\n-        });\n-      });\n-    }\n-\n-    describe('data binding', () => {\n-      it('should dirty check component views', () => {\n-        let value: any;\n-        class AComp {\n-          a: any;\n-        }\n-\n-        const update =\n-            jasmine.createSpy('updater').and.callFake((check: NodeCheckFn, view: ViewData) => {\n-              check(view, 0, ArgumentType.Inline, value);\n-            });\n-\n-        const {view, rootNodes} = createAndGetRootNodes(compViewDef([\n-          elementDef(\n-              0, NodeFlags.None, null, null, 1, 'div', null, null, null, null,\n-              () => compViewDef(\n-                  [\n-                    elementDef(\n-                        0, NodeFlags.None, null, null, 0, 'span', null,\n-                        [[BindingFlags.TypeElementAttribute, 'a', SecurityContext.NONE]]),\n-                  ],\n-                  null, update)),\n-          directiveDef(1, NodeFlags.Component, null, 0, AComp, []),\n-        ]));\n-        const compView = asElementData(view, 0).componentView;\n-\n-        value = 'v1';\n-        Services.checkAndUpdateView(view);\n-\n-        expect(update.calls.mostRecent().args[1]).toBe(compView);\n-\n-        update.calls.reset();\n-        Services.checkNoChangesView(view);\n-\n-        expect(update.calls.mostRecent().args[1]).toBe(compView);\n-\n-        value = 'v2';\n-        expect(() => Services.checkNoChangesView(view))\n-            .toThrowError(\n-                `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: 'a: v1'. Current value: 'a: v2'.`);\n-      });\n-\n-      // fixes https://github.com/angular/angular/issues/21788\n-      it('report the binding name when an expression changes after it has been checked', () => {\n-        let value: any;\n-        class AComp {}\n-\n-        const update =\n-            jasmine.createSpy('updater').and.callFake((check: NodeCheckFn, view: ViewData) => {\n-              check(view, 0, ArgumentType.Inline, 'const', 'const', value);\n-            });\n-\n-        const {view, rootNodes} = createAndGetRootNodes(\n-          compViewDef([\n-            elementDef(0, NodeFlags.None, null, null, 1, 'div', null, null, null, null, () => compViewDef([\n-                elementDef(0, NodeFlags.None, null, null, 0, 'span', null, [\n-                 [BindingFlags.TypeElementAttribute, 'p1', SecurityContext.NONE],\n-                [BindingFlags.TypeElementAttribute, 'p2', SecurityContext.NONE],\n-                [BindingFlags.TypeElementAttribute, 'p3', SecurityContext.NONE],\n-              ]),\n-              ], null, update)\n-            ),\n-            directiveDef(1, NodeFlags.Component, null, 0, AComp, []),\n-          ]));\n-\n-        value = 'v1';\n-        Services.checkAndUpdateView(view);\n-        value = 'v2';\n-        expect(() => Services.checkNoChangesView(view))\n-            .toThrowError(\n-                `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: 'p3: v1'. Current value: 'p3: v2'.`);\n-      });\n-\n-      it('should support detaching and attaching component views for dirty checking', () => {\n-        class AComp {\n-          a: any;\n-        }\n-\n-        const update = jasmine.createSpy('updater');\n-\n-        const {view, rootNodes} = createAndGetRootNodes(compViewDef([\n-          elementDef(\n-              0, NodeFlags.None, null, null, 1, 'div', null, null, null, null,\n-              () => compViewDef(\n-                  [\n-                    elementDef(0, NodeFlags.None, null, null, 0, 'span'),\n-                  ],\n-                  update)),\n-          directiveDef(1, NodeFlags.Component, null, 0, AComp, [], null, null),\n-        ]));\n-\n-        const compView = asElementData(view, 0).componentView;\n-\n-        Services.checkAndUpdateView(view);\n-        update.calls.reset();\n-\n-        compView.state &= ~ViewState.ChecksEnabled;\n-        Services.checkAndUpdateView(view);\n-        expect(update).not.toHaveBeenCalled();\n-\n-        compView.state |= ViewState.ChecksEnabled;\n-        Services.checkAndUpdateView(view);\n-        expect(update).toHaveBeenCalled();\n-      });\n-\n-      if (isBrowser()) {\n-        it('should support OnPush components', () => {\n-          let compInputValue: any;\n-          class AComp {\n-            a: any;\n-          }\n-\n-          const update = jasmine.createSpy('updater');\n-\n-          const addListenerSpy = spyOn(HTMLElement.prototype, addEventListener).and.callThrough();\n-\n-          const {view} = createAndGetRootNodes(compViewDef(\n-              [\n-                elementDef(\n-                    0, NodeFlags.None, null, null, 1, 'div', null, null, null, null,\n-                    () => {\n-                      return compViewDef(\n-                          [\n-                            elementDef(\n-                                0, NodeFlags.None, null, null, 0, 'span', null, null,\n-                                [[null!, 'click']]),\n-                          ],\n-                          update, null, ViewFlags.OnPush);\n-                    }),\n-                directiveDef(1, NodeFlags.Component, null, 0, AComp, [], {a: [0, 'a']}),\n-              ],\n-              (check, view) => {\n-                check(view, 1, ArgumentType.Inline, compInputValue);\n-              }));\n-\n-          Services.checkAndUpdateView(view);\n-\n-          // auto detach\n-          update.calls.reset();\n-          Services.checkAndUpdateView(view);\n-          expect(update).not.toHaveBeenCalled();\n-\n-          // auto attach on input changes\n-          update.calls.reset();\n-          compInputValue = 'v1';\n-          Services.checkAndUpdateView(view);\n-          expect(update).toHaveBeenCalled();\n-\n-          // auto detach\n-          update.calls.reset();\n-          Services.checkAndUpdateView(view);\n-          expect(update).not.toHaveBeenCalled();\n-\n-          // auto attach on events\n-          callMostRecentEventListenerHandler(addListenerSpy, 'SomeEvent');\n-          update.calls.reset();\n-          Services.checkAndUpdateView(view);\n-          expect(update).toHaveBeenCalled();\n-\n-          // auto detach\n-          update.calls.reset();\n-          Services.checkAndUpdateView(view);\n-          expect(update).not.toHaveBeenCalled();\n-        });\n-      }\n-\n-      it('should not stop dirty checking views that threw errors in change detection', () => {\n-        class AComp {\n-          a: any;\n-        }\n-\n-        const update = jasmine.createSpy('updater');\n-\n-        const {view, rootNodes} = createAndGetRootNodes(compViewDef([\n-          elementDef(\n-              0, NodeFlags.None, null, null, 1, 'div', null, null, null, null,\n-              () => compViewDef(\n-                  [elementDef(\n-                      0, NodeFlags.None, null, null, 0, 'span', null,\n-                      [[BindingFlags.TypeElementAttribute, 'a', SecurityContext.NONE]])],\n-                  null, update)),\n-          directiveDef(\n-              1,\n-              NodeFlags.Component,\n-              null,\n-              0,\n-              AComp,\n-              [],\n-              null,\n-              null,\n-              ),\n-        ]));\n-\n-        update.and.callFake((check: NodeCheckFn, view: ViewData) => {\n-          throw new Error('Test');\n-        });\n-        expect(() => Services.checkAndUpdateView(view)).toThrowError('Test');\n-        expect(update).toHaveBeenCalled();\n-\n-        update.calls.reset();\n-        expect(() => Services.checkAndUpdateView(view)).toThrowError('Test');\n-        expect(update).toHaveBeenCalled();\n-      });\n-    });\n-\n-    describe('destroy', () => {\n-      it('should destroy component views', () => {\n-        const log: string[] = [];\n-\n-        class AComp {}\n-\n-        class ChildProvider {\n-          ngOnDestroy() {\n-            log.push('ngOnDestroy');\n-          }\n-        }\n-\n-        const {view, rootNodes} = createAndGetRootNodes(compViewDef([\n-          elementDef(\n-              0, NodeFlags.None, null, null, 1, 'div', null, null, null, null,\n-              () => compViewDef([\n-                elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-                directiveDef(1, NodeFlags.OnDestroy, null, 0, ChildProvider, [])\n-              ])),\n-          directiveDef(\n-              1,\n-              NodeFlags.Component,\n-              null,\n-              0,\n-              AComp,\n-              [],\n-              null,\n-              null,\n-              ),\n-        ]));\n-\n-        Services.destroyView(view);\n-\n-        expect(log).toEqual(['ngOnDestroy']);\n-      });\n-\n-      it('should throw on dirty checking destroyed views', () => {\n-        const {view, rootNodes} = createAndGetRootNodes(\n-            compViewDef([elementDef(0, NodeFlags.None, null, null, 0, 'div')]));\n-\n-        Services.destroyView(view);\n-\n-        expect(() => Services.checkAndUpdateView(view))\n-            .toThrowError('ViewDestroyedError: Attempt to use a destroyed view: detectChanges');\n-      });\n-    });\n-  });\n-}"
        },
        {
            "sha": "9977909ff48b2580ac2cec17621a36a09bd64ba1",
            "filename": "packages/core/test/view/element_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 299,
            "changes": 299,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Felement_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Felement_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fview%2Felement_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,299 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ɵgetDOM as getDOM} from '@angular/common';\n-import {ErrorHandler, getDebugNode, SecurityContext} from '@angular/core';\n-import {getDebugContext} from '@angular/core/src/errors';\n-import {asElementData, BindingFlags, elementDef, NodeFlags, Services, ViewData, ViewDefinition} from '@angular/core/src/view/index';\n-import {TestBed} from '@angular/core/testing';\n-\n-import {ARG_TYPE_VALUES, callMostRecentEventListenerHandler, checkNodeInlineOrDynamic, compViewDef, createAndGetRootNodes, isBrowser, recordNodeToRemove} from './helper';\n-\n-\n-\n-/**\n- * We map addEventListener to the Zones internal name. This is because we want to be fast\n- * and bypass the zone bookkeeping. We know that we can do the bookkeeping faster.\n- */\n-const addEventListener = 'addEventListener';\n-const removeEventListener = 'removeEventListener';\n-\n-{\n-  describe(`View Elements`, () => {\n-    describe('create', () => {\n-      it('should create elements without parents', () => {\n-        const rootNodes = createAndGetRootNodes(compViewDef([\n-                            elementDef(0, NodeFlags.None, null, null, 0, 'span')\n-                          ])).rootNodes;\n-        expect(rootNodes.length).toBe(1);\n-        expect(rootNodes[0].nodeName.toLowerCase()).toBe('span');\n-      });\n-\n-      it('should create views with multiple root elements', () => {\n-        const rootNodes = createAndGetRootNodes(compViewDef([\n-                            elementDef(0, NodeFlags.None, null, null, 0, 'span'),\n-                            elementDef(1, NodeFlags.None, null, null, 0, 'span'),\n-                          ])).rootNodes;\n-        expect(rootNodes.length).toBe(2);\n-      });\n-\n-      it('should create elements with parents', () => {\n-        const rootNodes = createAndGetRootNodes(compViewDef([\n-                            elementDef(0, NodeFlags.None, null, null, 1, 'div'),\n-                            elementDef(1, NodeFlags.None, null, null, 0, 'span'),\n-                          ])).rootNodes;\n-        expect(rootNodes.length).toBe(1);\n-        const spanEl = rootNodes[0].childNodes[0];\n-        expect(spanEl.nodeName.toLowerCase()).toBe('span');\n-      });\n-\n-      it('should set fixed attributes', () => {\n-        const rootNodes = createAndGetRootNodes(compViewDef([\n-                            elementDef(0, NodeFlags.None, null, null, 0, 'div', [['title', 'a']]),\n-                          ])).rootNodes;\n-        expect(rootNodes.length).toBe(1);\n-        expect(rootNodes[0].getAttribute('title')).toBe('a');\n-      });\n-\n-      it('should add debug information to the renderer', () => {\n-        const someContext = {};\n-        const {view, rootNodes} = createAndGetRootNodes(\n-            compViewDef([elementDef(0, NodeFlags.None, null, null, 0, 'div')]), someContext);\n-        expect(getDebugNode(rootNodes[0])!.nativeNode).toBe(asElementData(view, 0).renderElement);\n-      });\n-    });\n-\n-    describe('change properties', () => {\n-      ARG_TYPE_VALUES.forEach((inlineDynamic) => {\n-        it(`should update via strategy ${inlineDynamic}`, () => {\n-          const {view, rootNodes} = createAndGetRootNodes(compViewDef(\n-              [\n-                elementDef(\n-                    0, NodeFlags.None, null, null, 0, 'input', null,\n-                    [\n-                      [BindingFlags.TypeProperty, 'title', SecurityContext.NONE],\n-                      [BindingFlags.TypeProperty, 'value', SecurityContext.NONE],\n-                    ]),\n-              ],\n-              null, (check, view) => {\n-                checkNodeInlineOrDynamic(check, view, 0, inlineDynamic, ['v1', 'v2']);\n-              }));\n-\n-          Services.checkAndUpdateView(view);\n-\n-          const el = rootNodes[0];\n-          expect(el.title).toBe('v1');\n-          expect(el.value).toBe('v2');\n-        });\n-      });\n-    });\n-\n-    describe('change attributes', () => {\n-      ARG_TYPE_VALUES.forEach((inlineDynamic) => {\n-        it(`should update via strategy ${inlineDynamic}`, () => {\n-          const {view, rootNodes} = createAndGetRootNodes(compViewDef(\n-              [\n-                elementDef(\n-                    0, NodeFlags.None, null, null, 0, 'div', null,\n-                    [\n-                      [BindingFlags.TypeElementAttribute, 'a1', SecurityContext.NONE],\n-                      [BindingFlags.TypeElementAttribute, 'a2', SecurityContext.NONE],\n-                    ]),\n-              ],\n-              null, (check, view) => {\n-                checkNodeInlineOrDynamic(check, view, 0, inlineDynamic, ['v1', 'v2']);\n-              }));\n-\n-          Services.checkAndUpdateView(view);\n-\n-          const el = rootNodes[0];\n-          expect(el.getAttribute('a1')).toBe('v1');\n-          expect(el.getAttribute('a2')).toBe('v2');\n-        });\n-      });\n-    });\n-\n-    describe('change classes', () => {\n-      ARG_TYPE_VALUES.forEach((inlineDynamic) => {\n-        it(`should update via strategy ${inlineDynamic}`, () => {\n-          const {view, rootNodes} = createAndGetRootNodes(compViewDef(\n-              [\n-                elementDef(\n-                    0, NodeFlags.None, null, null, 0, 'div', null,\n-                    [\n-                      [BindingFlags.TypeElementClass, 'c1', null],\n-                      [BindingFlags.TypeElementClass, 'c2', null],\n-                    ]),\n-              ],\n-              (check, view) => {\n-                checkNodeInlineOrDynamic(check, view, 0, inlineDynamic, [true, true]);\n-              }));\n-\n-          Services.checkAndUpdateView(view);\n-\n-          const el = rootNodes[0];\n-          expect(el.classList.contains('c1')).toBeTruthy();\n-          expect(el.classList.contains('c2')).toBeTruthy();\n-        });\n-      });\n-    });\n-\n-    describe('change styles', () => {\n-      ARG_TYPE_VALUES.forEach((inlineDynamic) => {\n-        it(`should update via strategy ${inlineDynamic}`, () => {\n-          const {view, rootNodes} = createAndGetRootNodes(compViewDef(\n-              [\n-                elementDef(\n-                    0, NodeFlags.None, null, null, 0, 'div', null,\n-                    [\n-                      [BindingFlags.TypeElementStyle, 'width', 'px'],\n-                      [BindingFlags.TypeElementStyle, 'color', null],\n-                    ]),\n-              ],\n-              null, (check, view) => {\n-                checkNodeInlineOrDynamic(check, view, 0, inlineDynamic, [10, 'red']);\n-              }));\n-\n-          Services.checkAndUpdateView(view);\n-\n-          const el = rootNodes[0];\n-          expect(el.style['width']).toBe('10px');\n-          expect(el.style['color']).toBe('red');\n-        });\n-      });\n-    });\n-\n-    if (isBrowser()) {\n-      describe('listen to DOM events', () => {\n-        function createAndAttachAndGetRootNodes(viewDef: ViewDefinition):\n-            {rootNodes: any[], view: ViewData} {\n-          const result = createAndGetRootNodes(viewDef);\n-          // Note: We need to append the node to the document.body, otherwise `click` events\n-          // won't work in IE.\n-          result.rootNodes.forEach((node) => {\n-            document.body.appendChild(node);\n-            recordNodeToRemove(node);\n-          });\n-          return result;\n-        }\n-\n-        it('should listen to DOM events', () => {\n-          const handleEventSpy = jasmine.createSpy('handleEvent');\n-          const removeListenerSpy =\n-              spyOn(HTMLElement.prototype, removeEventListener).and.callThrough();\n-          const {view, rootNodes} = createAndAttachAndGetRootNodes(compViewDef([elementDef(\n-              0, NodeFlags.None, null, null, 0, 'button', null, null, [[null!, 'click']],\n-              handleEventSpy)]));\n-\n-          rootNodes[0].click();\n-\n-          expect(handleEventSpy).toHaveBeenCalled();\n-          let handleEventArgs = handleEventSpy.calls.mostRecent().args;\n-          expect(handleEventArgs[0]).toBe(view);\n-          expect(handleEventArgs[1]).toBe('click');\n-          expect(handleEventArgs[2]).toBeTruthy();\n-\n-          Services.destroyView(view);\n-\n-          expect(removeListenerSpy).toHaveBeenCalled();\n-        });\n-\n-        it('should listen to window events', () => {\n-          const handleEventSpy = jasmine.createSpy('handleEvent');\n-          const addListenerSpy = spyOn(window, addEventListener);\n-          const removeListenerSpy = spyOn(window, removeEventListener);\n-          const {view, rootNodes} = createAndAttachAndGetRootNodes(compViewDef([elementDef(\n-              0, NodeFlags.None, null, null, 0, 'button', null, null, [['window', 'windowClick']],\n-              handleEventSpy)]));\n-\n-          expect(addListenerSpy).toHaveBeenCalled();\n-          expect(addListenerSpy.calls.mostRecent().args[0]).toBe('windowClick');\n-          callMostRecentEventListenerHandler(addListenerSpy, {name: 'windowClick'});\n-\n-          expect(handleEventSpy).toHaveBeenCalled();\n-          const handleEventArgs = handleEventSpy.calls.mostRecent().args;\n-          expect(handleEventArgs[0]).toBe(view);\n-          expect(handleEventArgs[1]).toBe('window:windowClick');\n-          expect(handleEventArgs[2]).toBeTruthy();\n-\n-          Services.destroyView(view);\n-\n-          expect(removeListenerSpy).toHaveBeenCalled();\n-        });\n-\n-        it('should listen to document events', () => {\n-          const handleEventSpy = jasmine.createSpy('handleEvent');\n-          const addListenerSpy = spyOn(document, addEventListener);\n-          const removeListenerSpy = spyOn(document, removeEventListener);\n-          const {view, rootNodes} = createAndAttachAndGetRootNodes(compViewDef([elementDef(\n-              0, NodeFlags.None, null, null, 0, 'button', null, null,\n-              [['document', 'documentClick']], handleEventSpy)]));\n-\n-          expect(addListenerSpy).toHaveBeenCalled();\n-          expect(addListenerSpy.calls.mostRecent().args[0]).toBe('documentClick');\n-          callMostRecentEventListenerHandler(addListenerSpy, {name: 'windowClick'});\n-\n-          expect(handleEventSpy).toHaveBeenCalled();\n-          const handleEventArgs = handleEventSpy.calls.mostRecent().args;\n-          expect(handleEventArgs[0]).toBe(view);\n-          expect(handleEventArgs[1]).toBe('document:documentClick');\n-          expect(handleEventArgs[2]).toBeTruthy();\n-\n-          Services.destroyView(view);\n-\n-          expect(removeListenerSpy).toHaveBeenCalled();\n-        });\n-\n-        it('should preventDefault only if the handler returns false', () => {\n-          let eventHandlerResult: any;\n-          let preventDefaultSpy: jasmine.Spy = undefined!;\n-\n-          const {view, rootNodes} = createAndAttachAndGetRootNodes(compViewDef([elementDef(\n-              0, NodeFlags.None, null, null, 0, 'button', null, null, [[null!, 'click']],\n-              (view, eventName, event) => {\n-                preventDefaultSpy = spyOn(event, 'preventDefault').and.callThrough();\n-                return eventHandlerResult;\n-              })]));\n-\n-          eventHandlerResult = undefined;\n-          rootNodes[0].click();\n-          expect(preventDefaultSpy).not.toHaveBeenCalled();\n-\n-          eventHandlerResult = true;\n-          rootNodes[0].click();\n-          expect(preventDefaultSpy).not.toHaveBeenCalled();\n-\n-          eventHandlerResult = 'someString';\n-          rootNodes[0].click();\n-          expect(preventDefaultSpy).not.toHaveBeenCalled();\n-\n-          eventHandlerResult = false;\n-          rootNodes[0].click();\n-          expect(preventDefaultSpy).toHaveBeenCalled();\n-        });\n-\n-        it('should report debug info on event errors', () => {\n-          const handleErrorSpy = spyOn(TestBed.inject(ErrorHandler), 'handleError');\n-          const addListenerSpy = spyOn(HTMLElement.prototype, addEventListener).and.callThrough();\n-          const {view, rootNodes} = createAndAttachAndGetRootNodes(compViewDef([elementDef(\n-              0, NodeFlags.None, null, null, 0, 'button', null, null, [[null!, 'click']], () => {\n-                throw new Error('Test');\n-              })]));\n-\n-          callMostRecentEventListenerHandler(addListenerSpy, 'SomeEvent');\n-          const err = handleErrorSpy.calls.mostRecent().args[0];\n-          expect(err).toBeTruthy();\n-          expect(err.message).toBe('Test');\n-          const debugCtx = getDebugContext(err);\n-          expect(debugCtx.view).toBe(view);\n-          expect(debugCtx.nodeIndex).toBe(0);\n-        });\n-      });\n-    }\n-  });\n-}"
        },
        {
            "sha": "a1b1d954ba294d788ea67f9eb2029d4842f539b6",
            "filename": "packages/core/test/view/embedded_view_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 175,
            "changes": 175,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fembedded_view_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fembedded_view_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fview%2Fembedded_view_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,175 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ɵgetDOM as getDOM} from '@angular/common';\n-import {SecurityContext} from '@angular/core';\n-import {anchorDef, ArgumentType, asElementData, attachEmbeddedView, BindingFlags, detachEmbeddedView, directiveDef, elementDef, moveEmbeddedView, NodeCheckFn, NodeFlags, rootRenderNodes, Services, ViewData} from '@angular/core/src/view/index';\n-\n-import {compViewDef, compViewDefFactory, createAndGetRootNodes, createEmbeddedView} from './helper';\n-\n-{\n-  describe(`Embedded Views`, () => {\n-    it('should create embedded views with the right context', () => {\n-      const parentContext = {};\n-      const childContext = {};\n-\n-      const {view: parentView} = createAndGetRootNodes(\n-          compViewDef([\n-            elementDef(0, NodeFlags.None, null, null, 1, 'div'),\n-            anchorDef(\n-                NodeFlags.EmbeddedViews, null, null, 0, null,\n-                compViewDefFactory([elementDef(0, NodeFlags.None, null, null, 0, 'span')])),\n-          ]),\n-          parentContext);\n-\n-      const childView = createEmbeddedView(parentView, parentView.def.nodes[1], childContext);\n-      expect(childView.component).toBe(parentContext);\n-      expect(childView.context).toBe(childContext);\n-    });\n-\n-    it('should attach and detach embedded views', () => {\n-      const {view: parentView, rootNodes} = createAndGetRootNodes(compViewDef([\n-        elementDef(0, NodeFlags.None, null, null, 2, 'div'),\n-        anchorDef(NodeFlags.EmbeddedViews, null, null, 0, null, compViewDefFactory([\n-                    elementDef(0, NodeFlags.None, null, null, 0, 'span', [['name', 'child0']])\n-                  ])),\n-        anchorDef(NodeFlags.None, null, null, 0, null, compViewDefFactory([\n-                    elementDef(0, NodeFlags.None, null, null, 0, 'span', [['name', 'child1']])\n-                  ]))\n-      ]));\n-      const viewContainerData = asElementData(parentView, 1);\n-      const rf = parentView.root.rendererFactory;\n-\n-      const childView0 = createEmbeddedView(parentView, parentView.def.nodes[1]);\n-      const childView1 = createEmbeddedView(parentView, parentView.def.nodes[2]);\n-\n-      attachEmbeddedView(parentView, viewContainerData, 0, childView0);\n-      attachEmbeddedView(parentView, viewContainerData, 1, childView1);\n-\n-      // 2 anchors + 2 elements\n-      const rootChildren = rootNodes[0].childNodes;\n-      expect(rootChildren.length).toBe(4);\n-      expect(rootChildren[1].getAttribute('name')).toBe('child0');\n-      expect(rootChildren[2].getAttribute('name')).toBe('child1');\n-\n-      rf.begin!();\n-      detachEmbeddedView(viewContainerData, 1);\n-      detachEmbeddedView(viewContainerData, 0);\n-      rf.end!();\n-\n-      expect(rootNodes[0].childNodes.length).toBe(2);\n-    });\n-\n-    it('should move embedded views', () => {\n-      const {view: parentView, rootNodes} = createAndGetRootNodes(compViewDef([\n-        elementDef(0, NodeFlags.None, null, null, 2, 'div'),\n-        anchorDef(NodeFlags.EmbeddedViews, null, null, 0, null, compViewDefFactory([\n-                    elementDef(0, NodeFlags.None, null, null, 0, 'span', [['name', 'child0']])\n-                  ])),\n-        anchorDef(NodeFlags.None, null, null, 0, null, compViewDefFactory([\n-                    elementDef(0, NodeFlags.None, null, null, 0, 'span', [['name', 'child1']])\n-                  ]))\n-      ]));\n-      const viewContainerData = asElementData(parentView, 1);\n-\n-      const childView0 = createEmbeddedView(parentView, parentView.def.nodes[1]);\n-      const childView1 = createEmbeddedView(parentView, parentView.def.nodes[2]);\n-\n-      attachEmbeddedView(parentView, viewContainerData, 0, childView0);\n-      attachEmbeddedView(parentView, viewContainerData, 1, childView1);\n-\n-      moveEmbeddedView(viewContainerData, 0, 1);\n-\n-      expect(viewContainerData.viewContainer!._embeddedViews).toEqual([childView1, childView0]);\n-      // 2 anchors + 2 elements\n-      const rootChildren = rootNodes[0].childNodes;\n-      expect(rootChildren.length).toBe(4);\n-      expect(rootChildren[1].getAttribute('name')).toBe('child1');\n-      expect(rootChildren[2].getAttribute('name')).toBe('child0');\n-    });\n-\n-    it('should include embedded views in root nodes', () => {\n-      const {view: parentView} = createAndGetRootNodes(compViewDef([\n-        anchorDef(NodeFlags.EmbeddedViews, null, null, 0, null, compViewDefFactory([\n-                    elementDef(0, NodeFlags.None, null, null, 0, 'span', [['name', 'child0']])\n-                  ])),\n-        elementDef(1, NodeFlags.None, null, null, 0, 'span', [['name', 'after']])\n-      ]));\n-\n-      const childView0 = createEmbeddedView(parentView, parentView.def.nodes[0]);\n-      attachEmbeddedView(parentView, asElementData(parentView, 0), 0, childView0);\n-\n-      const rootNodes = rootRenderNodes(parentView);\n-      expect(rootNodes.length).toBe(3);\n-      expect(rootNodes[1].getAttribute('name')).toBe('child0');\n-      expect(rootNodes[2].getAttribute('name')).toBe('after');\n-    });\n-\n-    it('should dirty check embedded views', () => {\n-      let childValue = 'v1';\n-      const update =\n-          jasmine.createSpy('updater').and.callFake((check: NodeCheckFn, view: ViewData) => {\n-            check(view, 0, ArgumentType.Inline, childValue);\n-          });\n-\n-      const {view: parentView, rootNodes} = createAndGetRootNodes(compViewDef([\n-        elementDef(0, NodeFlags.None, null, null, 1, 'div'),\n-        anchorDef(\n-            NodeFlags.EmbeddedViews, null, null, 0, null,\n-            compViewDefFactory(\n-                [elementDef(\n-                    0, NodeFlags.None, null, null, 0, 'span', null,\n-                    [[BindingFlags.TypeElementAttribute, 'name', SecurityContext.NONE]])],\n-                update))\n-      ]));\n-\n-      const childView0 = createEmbeddedView(parentView, parentView.def.nodes[1]);\n-\n-      attachEmbeddedView(parentView, asElementData(parentView, 1), 0, childView0);\n-\n-      Services.checkAndUpdateView(parentView);\n-\n-      expect(update.calls.mostRecent().args[1]).toBe(childView0);\n-\n-      update.calls.reset();\n-      Services.checkNoChangesView(parentView);\n-\n-      expect(update.calls.mostRecent().args[1]).toBe(childView0);\n-\n-      childValue = 'v2';\n-      expect(() => Services.checkNoChangesView(parentView))\n-          .toThrowError(\n-              `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: 'name: v1'. Current value: 'name: v2'.`);\n-    });\n-\n-    it('should destroy embedded views', () => {\n-      const log: string[] = [];\n-\n-      class ChildProvider {\n-        ngOnDestroy() {\n-          log.push('ngOnDestroy');\n-        }\n-      }\n-\n-      const {view: parentView} = createAndGetRootNodes(compViewDef([\n-        elementDef(0, NodeFlags.None, null, null, 1, 'div'),\n-        anchorDef(NodeFlags.EmbeddedViews, null, null, 0, null, compViewDefFactory([\n-                    elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-                    directiveDef(1, NodeFlags.OnDestroy, null, 0, ChildProvider, [])\n-                  ]))\n-      ]));\n-\n-      const childView0 = createEmbeddedView(parentView, parentView.def.nodes[1]);\n-\n-      attachEmbeddedView(parentView, asElementData(parentView, 1), 0, childView0);\n-      Services.destroyView(parentView);\n-\n-      expect(log).toEqual(['ngOnDestroy']);\n-    });\n-  });\n-}"
        },
        {
            "sha": "52cd8ae419272c2e633024fffecd6021a432c047",
            "filename": "packages/core/test/view/helper.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 103,
            "changes": 103,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fhelper.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fhelper.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fview%2Fhelper.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,103 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ɵgetDOM as getDOM} from '@angular/common';\n-import {Injector, NgModuleRef} from '@angular/core';\n-import {ArgumentType, initServicesIfNeeded, NodeCheckFn, NodeDef, rootRenderNodes, Services, ViewData, viewDef, ViewDefinition, ViewDefinitionFactory, ViewFlags, ViewUpdateFn} from '@angular/core/src/view/index';\n-import {TestBed} from '@angular/core/testing';\n-\n-export function isBrowser() {\n-  return getDOM().supportsDOMEvents;\n-}\n-\n-export const ARG_TYPE_VALUES = [ArgumentType.Inline, ArgumentType.Dynamic];\n-\n-export function checkNodeInlineOrDynamic(\n-    check: NodeCheckFn, view: ViewData, nodeIndex: number, argType: ArgumentType,\n-    values: any[]): any {\n-  switch (argType) {\n-    case ArgumentType.Inline:\n-      return (<any>check)(view, nodeIndex, argType, ...values);\n-    case ArgumentType.Dynamic:\n-      return check(view, nodeIndex, argType, values);\n-  }\n-}\n-\n-export function createRootView(\n-    def: ViewDefinition, context?: any, projectableNodes?: any[][],\n-    rootSelectorOrNode?: any): ViewData {\n-  initServicesIfNeeded();\n-  return Services.createRootView(\n-      TestBed.inject(Injector), projectableNodes || [], rootSelectorOrNode, def,\n-      TestBed.inject(NgModuleRef), context);\n-}\n-\n-export function createEmbeddedView(parent: ViewData, anchorDef: NodeDef, context?: any): ViewData {\n-  return Services.createEmbeddedView(parent, anchorDef, anchorDef.element!.template !, context);\n-}\n-\n-export function compViewDef(\n-    nodes: NodeDef[], updateDirectives?: null|ViewUpdateFn, updateRenderer?: null|ViewUpdateFn,\n-    viewFlags: ViewFlags = ViewFlags.None): ViewDefinition {\n-  const def = viewDef(viewFlags, nodes, updateDirectives, updateRenderer);\n-\n-  def.nodes.forEach((node, index) => {\n-    if (node.nodeIndex !== index) {\n-      throw new Error('nodeIndex should be the same as the index of the node');\n-    }\n-\n-    // This check should be removed when we start reordering nodes at runtime\n-    if (node.checkIndex > -1 && node.checkIndex !== node.nodeIndex) {\n-      throw new Error(`nodeIndex and checkIndex should be the same, got ${node.nodeIndex} !== ${\n-          node.checkIndex}`);\n-    }\n-  });\n-\n-  return def;\n-}\n-\n-export function compViewDefFactory(\n-    nodes: NodeDef[], updateDirectives?: null|ViewUpdateFn, updateRenderer?: null|ViewUpdateFn,\n-    viewFlags: ViewFlags = ViewFlags.None): ViewDefinitionFactory {\n-  return () => compViewDef(nodes, updateDirectives, updateRenderer, viewFlags);\n-}\n-\n-export function createAndGetRootNodes(\n-    viewDef: ViewDefinition, ctx?: any): {rootNodes: any[], view: ViewData} {\n-  const view = createRootView(viewDef, ctx);\n-  const rootNodes = rootRenderNodes(view);\n-  return {rootNodes, view};\n-}\n-\n-let removeNodes: Node[];\n-\n-beforeEach(() => {\n-  removeNodes = [];\n-});\n-afterEach(() => {\n-  removeNodes.forEach((node) => getDOM().remove(node));\n-});\n-\n-export function recordNodeToRemove(node: Node) {\n-  removeNodes.push(node);\n-}\n-\n-export function callMostRecentEventListenerHandler(spy: any, params: any) {\n-  const mostRecent = spy.calls.mostRecent();\n-  if (!mostRecent) {\n-    return;\n-  }\n-\n-  const obj = mostRecent.object;\n-  const args = mostRecent.args;\n-\n-  const eventName = args[0];\n-  const handler = args[1];\n-\n-  handler && handler.apply(obj, [{type: eventName}]);\n-}"
        },
        {
            "sha": "11f8280c8e49b8897703671d17dc39ed4fe30fbd",
            "filename": "packages/core/test/view/ng_content_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 137,
            "changes": 137,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fng_content_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fng_content_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fview%2Fng_content_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,137 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ɵgetDOM as getDOM} from '@angular/common';\n-import {TemplateRef, ViewContainerRef} from '@angular/core';\n-import {anchorDef, asElementData, asTextData, attachEmbeddedView, detachEmbeddedView, directiveDef, elementDef, ngContentDef, NodeDef, NodeFlags, rootRenderNodes, textDef, ViewData, ViewDefinition} from '@angular/core/src/view/index';\n-\n-import {compViewDef, compViewDefFactory, createEmbeddedView, createRootView, isBrowser} from './helper';\n-\n-{\n-  describe(`View NgContent`, () => {\n-    function hostElDef(\n-        checkIndex: number, contentNodes: NodeDef[], viewNodes: NodeDef[]): NodeDef[] {\n-      class AComp {}\n-\n-      const aCompViewDef = compViewDef(viewNodes);\n-\n-      return [\n-        elementDef(\n-            checkIndex, NodeFlags.None, null, null, 1 + contentNodes.length, 'acomp', null, null,\n-            null, null, () => aCompViewDef),\n-        directiveDef(checkIndex + 1, NodeFlags.Component, null, 0, AComp, []), ...contentNodes\n-      ];\n-    }\n-\n-    function createAndGetRootNodes(\n-        viewDef: ViewDefinition, ctx?: any): {rootNodes: any[], view: ViewData} {\n-      const view = createRootView(viewDef, ctx || {});\n-      const rootNodes = rootRenderNodes(view);\n-      return {rootNodes, view};\n-    }\n-\n-    it('should create ng-content nodes without parents', () => {\n-      const {view, rootNodes} = createAndGetRootNodes(\n-          compViewDef(hostElDef(0, [textDef(2, 0, ['a'])], [ngContentDef(null, 0)])));\n-\n-      expect(rootNodes[0].firstChild).toBe(asTextData(view, 2).renderText);\n-    });\n-\n-    it('should create views with multiple root ng-content nodes', () => {\n-      const {view, rootNodes} = createAndGetRootNodes(compViewDef(hostElDef(\n-          0, [textDef(2, 0, ['a']), textDef(3, 1, ['b'])],\n-          [ngContentDef(null, 0), ngContentDef(null, 1)])));\n-\n-      expect(rootNodes[0].childNodes[0]).toBe(asTextData(view, 2).renderText);\n-      expect(rootNodes[0].childNodes[1]).toBe(asTextData(view, 3).renderText);\n-    });\n-\n-    it('should create ng-content nodes with parents', () => {\n-      const {view, rootNodes} = createAndGetRootNodes(compViewDef(hostElDef(\n-          0, [textDef(2, 0, ['a'])],\n-          [elementDef(0, NodeFlags.None, null, null, 1, 'div'), ngContentDef(null, 0)])));\n-\n-      expect(rootNodes[0].firstChild.firstChild).toBe(asTextData(view, 2).renderText);\n-    });\n-\n-    it('should reproject ng-content nodes', () => {\n-      const {view, rootNodes} = createAndGetRootNodes(compViewDef(\n-          hostElDef(0, [textDef(2, 0, ['a'])], hostElDef(0, [ngContentDef(0, 0)], [\n-                      elementDef(0, NodeFlags.None, null, null, 1, 'span'), ngContentDef(null, 0)\n-                    ]))));\n-      expect(rootNodes[0].firstChild.firstChild.firstChild).toBe(asTextData(view, 2).renderText);\n-    });\n-\n-    it('should project already attached embedded views', () => {\n-      class CreateViewService {\n-        constructor(templateRef: TemplateRef<any>, viewContainerRef: ViewContainerRef) {\n-          viewContainerRef.createEmbeddedView(templateRef);\n-        }\n-      }\n-\n-      const {view, rootNodes} = createAndGetRootNodes(compViewDef(hostElDef(\n-          0,\n-          [\n-            anchorDef(NodeFlags.EmbeddedViews, null, 0, 1, null, compViewDefFactory([textDef(\n-                                                                     0, null, ['a'])])),\n-            directiveDef(\n-                3, NodeFlags.None, null, 0, CreateViewService, [TemplateRef, ViewContainerRef]),\n-          ],\n-          [\n-            elementDef(0, NodeFlags.None, null, null, 1, 'div'),\n-            ngContentDef(null, 0),\n-          ])));\n-\n-      const anchor = asElementData(view, 2);\n-      const child = rootNodes[0].firstChild;\n-      expect(child.childNodes[0]).toBe(anchor.renderElement);\n-      const embeddedView = anchor.viewContainer!._embeddedViews[0];\n-      expect(child.childNodes[1]).toBe(asTextData(embeddedView, 0).renderText);\n-    });\n-\n-    it('should include projected nodes when attaching / detaching embedded views', () => {\n-      const {view, rootNodes} =\n-          createAndGetRootNodes(compViewDef(hostElDef(0, [textDef(2, 0, ['a'])], [\n-            elementDef(0, NodeFlags.None, null, null, 1, 'div'),\n-            anchorDef(NodeFlags.EmbeddedViews, null, 0, 0, null, compViewDefFactory([\n-                        ngContentDef(null, 0),\n-                        // The anchor would be added by the compiler after the ngContent\n-                        anchorDef(NodeFlags.None, null, null, 0),\n-                      ])),\n-          ])));\n-\n-      const componentView = asElementData(view, 0).componentView;\n-      const rf = componentView.root.rendererFactory;\n-      const view0 = createEmbeddedView(componentView, componentView.def.nodes[1]);\n-\n-      attachEmbeddedView(view, asElementData(componentView, 1), 0, view0);\n-      let child = rootNodes[0].firstChild;\n-      expect(child.childNodes.length).toBe(3);\n-      expect(child.childNodes[1]).toBe(asTextData(view, 2).renderText);\n-\n-      rf.begin!();\n-      detachEmbeddedView(asElementData(componentView, 1), 0);\n-      rf.end!();\n-      child = rootNodes[0].firstChild;\n-      expect(child.childNodes.length).toBe(1);\n-    });\n-\n-    if (isBrowser()) {\n-      it('should use root projectable nodes', () => {\n-        const projectableNodes = [[document.createTextNode('a')], [document.createTextNode('b')]];\n-        const view = createRootView(\n-            compViewDef(hostElDef(0, [], [ngContentDef(null, 0), ngContentDef(null, 1)])), {},\n-            projectableNodes);\n-        const rootNodes = rootRenderNodes(view);\n-\n-        expect(rootNodes[0].childNodes[0]).toBe(projectableNodes[0][0]);\n-        expect(rootNodes[0].childNodes[1]).toBe(projectableNodes[1][0]);\n-      });\n-    }\n-  });\n-}"
        },
        {
            "sha": "9d762b511e5f9fc4a21e723e74adced3bcb668a9",
            "filename": "packages/core/test/view/ng_module_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 312,
            "changes": 312,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fng_module_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fng_module_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fview%2Fng_module_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,312 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {NgModuleRef, ɵINJECTOR_SCOPE as INJECTOR_SCOPE} from '@angular/core';\n-import {inject, InjectFlags} from '@angular/core/src/di';\n-import {Injector} from '@angular/core/src/di/injector';\n-import {INJECTOR} from '@angular/core/src/di/injector_token';\n-import {ɵɵdefineInjectable} from '@angular/core/src/di/interface/defs';\n-import {NgModuleDefinition, NgModuleProviderDef, NodeFlags} from '@angular/core/src/view';\n-import {moduleDef} from '@angular/core/src/view/ng_module';\n-import {createNgModuleRef} from '@angular/core/src/view/refs';\n-import {tokenKey} from '@angular/core/src/view/util';\n-\n-class Foo {}\n-\n-class MyModule {}\n-\n-class MyChildModule {}\n-\n-class NotMyModule {}\n-\n-class Bar {\n-  static ɵprov = ɵɵdefineInjectable({\n-    token: Bar,\n-    factory: () => new Bar(),\n-    providedIn: MyModule,\n-  });\n-}\n-\n-class Baz {\n-  static ɵprov = ɵɵdefineInjectable({\n-    token: Baz,\n-    factory: () => new Baz(),\n-    providedIn: NotMyModule,\n-  });\n-}\n-\n-class HasNormalDep {\n-  constructor(public foo: Foo) {}\n-\n-  static ɵprov = ɵɵdefineInjectable({\n-    token: HasNormalDep,\n-    factory: () => new HasNormalDep(inject(Foo)),\n-    providedIn: MyModule,\n-  });\n-}\n-\n-class HasDefinedDep {\n-  constructor(public bar: Bar) {}\n-\n-  static ɵprov = ɵɵdefineInjectable({\n-    token: HasDefinedDep,\n-    factory: () => new HasDefinedDep(inject(Bar)),\n-    providedIn: MyModule,\n-  });\n-}\n-\n-class HasOptionalDep {\n-  constructor(public baz: Baz|null) {}\n-\n-  static ɵprov = ɵɵdefineInjectable({\n-    token: HasOptionalDep,\n-    factory: () => new HasOptionalDep(inject(Baz, InjectFlags.Optional)),\n-    providedIn: MyModule,\n-  });\n-}\n-\n-class ChildDep {\n-  static ɵprov = ɵɵdefineInjectable({\n-    token: ChildDep,\n-    factory: () => new ChildDep(),\n-    providedIn: MyChildModule,\n-  });\n-}\n-\n-class FromChildWithOptionalDep {\n-  constructor(public baz: Baz|null) {}\n-  static ɵprov = ɵɵdefineInjectable({\n-    token: FromChildWithOptionalDep,\n-    factory: () => new FromChildWithOptionalDep(inject(Baz, InjectFlags.Default)),\n-    providedIn: MyChildModule,\n-  });\n-}\n-\n-class FromChildWithSkipSelfDep {\n-  constructor(\n-      public skipSelfChildDep: ChildDep|null, public selfChildDep: ChildDep|null,\n-      public optionalSelfBar: Bar|null) {}\n-  static ɵprov = ɵɵdefineInjectable({\n-    token: FromChildWithSkipSelfDep,\n-    factory: () => new FromChildWithSkipSelfDep(\n-        inject(ChildDep, InjectFlags.SkipSelf|InjectFlags.Optional),\n-        inject(ChildDep, InjectFlags.Self),\n-        inject(Bar, InjectFlags.Self|InjectFlags.Optional),\n-        ),\n-    providedIn: MyChildModule,\n-  });\n-}\n-\n-class UsesInject {\n-  constructor() {\n-    inject(INJECTOR);\n-  }\n-}\n-\n-function makeProviders(classes: any[], modules: any[]): NgModuleDefinition {\n-  const providers = classes.map((token, index) => ({\n-                                  index,\n-                                  deps: [],\n-                                  flags: NodeFlags.TypeClassProvider | NodeFlags.LazyProvider,\n-                                  token,\n-                                  value: token,\n-                                }));\n-  return makeModule(modules, providers);\n-}\n-\n-function makeFactoryProviders(\n-    factories: {token: any, factory: Function}[], modules: any[]): NgModuleDefinition {\n-  const providers = factories.map((factory, index) => ({\n-                                    index,\n-                                    deps: [],\n-                                    flags: NodeFlags.TypeFactoryProvider | NodeFlags.LazyProvider,\n-                                    token: factory.token,\n-                                    value: factory.factory,\n-                                  }));\n-  return makeModule(modules, providers);\n-}\n-\n-function makeModule(modules: any[], providers: NgModuleProviderDef[]): NgModuleDefinition {\n-  const providersByKey: {[key: string]: NgModuleProviderDef} = {};\n-  providers.forEach(provider => providersByKey[tokenKey(provider.token)] = provider);\n-  return {factory: null, providers, providersByKey, modules, scope: 'root'};\n-}\n-\n-describe('NgModuleRef_ injector', () => {\n-  let ref: NgModuleRef<any>;\n-  let childRef: NgModuleRef<any>;\n-  beforeEach(() => {\n-    ref = createNgModuleRef(\n-        MyModule, Injector.NULL, [], makeProviders([MyModule, Foo, UsesInject], [MyModule]));\n-    childRef = createNgModuleRef(\n-        MyChildModule, ref.injector, [], makeProviders([MyChildModule], [MyChildModule]));\n-  });\n-\n-  it('injects a provided value', () => {\n-    expect(ref.injector.get(Foo) instanceof Foo).toBeTruthy();\n-  });\n-\n-  it('injects an injectable value', () => {\n-    expect(ref.injector.get(Bar) instanceof Bar).toBeTruthy();\n-  });\n-\n-  it('caches injectable values', () => {\n-    expect(ref.injector.get(Bar)).toBe(ref.injector.get(Bar));\n-  });\n-\n-  it('injects provided deps properly', () => {\n-    const instance = ref.injector.get(HasNormalDep);\n-    expect(instance instanceof HasNormalDep).toBeTruthy();\n-    expect(instance.foo).toBe(ref.injector.get(Foo));\n-  });\n-\n-  it('injects defined deps properly', () => {\n-    const instance = ref.injector.get(HasDefinedDep);\n-    expect(instance instanceof HasDefinedDep).toBeTruthy();\n-    expect(instance.bar).toBe(ref.injector.get(Bar));\n-  });\n-\n-  it('injects optional deps properly', () => {\n-    const instance = ref.injector.get(HasOptionalDep);\n-    expect(instance instanceof HasOptionalDep).toBeTruthy();\n-    expect(instance.baz).toBeNull();\n-  });\n-\n-  it('injects skip-self and self deps across injectors properly', () => {\n-    const instance = childRef.injector.get(FromChildWithSkipSelfDep);\n-    expect(instance instanceof FromChildWithSkipSelfDep).toBeTruthy();\n-    expect(instance.skipSelfChildDep).toBeNull();\n-    expect(instance.selfChildDep instanceof ChildDep).toBeTruthy();\n-    expect(instance.optionalSelfBar).toBeNull();\n-  });\n-\n-  it('does not inject something not scoped to the module', () => {\n-    expect(ref.injector.get(Baz, null)).toBeNull();\n-  });\n-\n-  it('injects with the current injector always set', () => {\n-    expect(() => ref.injector.get(UsesInject)).not.toThrow();\n-  });\n-\n-  it('calls ngOnDestroy on services created via factory', () => {\n-    class Module {}\n-\n-    class Service {\n-      static destroyed = 0;\n-      ngOnDestroy(): void {\n-        Service.destroyed++;\n-      }\n-    }\n-\n-    const ref = createNgModuleRef(\n-        Module, Injector.NULL, [],\n-        makeFactoryProviders(\n-            [{\n-              token: Service,\n-              factory: () => new Service(),\n-            }],\n-            [Module]));\n-\n-    expect(ref.injector.get(Service)).toBeDefined();\n-    expect(Service.destroyed).toBe(0);\n-    ref.destroy();\n-    expect(Service.destroyed).toBe(1);\n-  });\n-\n-  it('calls ngOnDestroy on scoped providers', () => {\n-    class Module {}\n-\n-    class Service {\n-      static destroyed = 0;\n-\n-      ngOnDestroy(): void {\n-        Service.destroyed++;\n-      }\n-\n-      static ɵprov = ɵɵdefineInjectable({\n-        token: Service,\n-        factory: () => new Service(),\n-        providedIn: 'root',\n-      });\n-    }\n-\n-    const ref = createNgModuleRef(Module, Injector.NULL, [], makeFactoryProviders([], [Module]));\n-\n-    expect(ref.injector.get(Service)).toBeDefined();\n-    expect(Service.destroyed).toBe(0);\n-    ref.destroy();\n-    expect(Service.destroyed).toBe(1);\n-  });\n-\n-  it('only calls ngOnDestroy once per instance', () => {\n-    class Module {}\n-\n-    class Service {\n-      static destroyed = 0;\n-      ngOnDestroy(): void {\n-        Service.destroyed++;\n-      }\n-    }\n-\n-    class OtherToken {}\n-\n-    const instance = new Service();\n-    const ref = createNgModuleRef(\n-        Module, Injector.NULL, [],\n-        makeFactoryProviders(\n-            [\n-              {\n-                token: Service,\n-                factory: () => instance,\n-              },\n-              {\n-                token: OtherToken,\n-                factory: () => instance,\n-              }\n-            ],\n-            [Module]));\n-\n-    expect(ref.injector.get(Service)).toBe(instance);\n-    expect(ref.injector.get(OtherToken)).toBe(instance);\n-    expect(Service.destroyed).toBe(0);\n-    ref.destroy();\n-    expect(Service.destroyed).toBe(1);\n-  });\n-\n-  describe('moduleDef', () => {\n-    function createProvider(token: any, value: any) {\n-      return {\n-        index: 0,\n-        flags: NodeFlags.TypeValueProvider | NodeFlags.LazyProvider,\n-        deps: [],\n-        token,\n-        value\n-      };\n-    }\n-\n-    it('sets scope to `root` when INJECTOR_SCOPE is `root`', () => {\n-      const def = moduleDef([createProvider(INJECTOR_SCOPE, 'root')]);\n-      expect(def.scope).toBe('root');\n-    });\n-\n-    it('sets scope to `platform` when INJECTOR_SCOPE is `platform`', () => {\n-      const def = moduleDef([createProvider(INJECTOR_SCOPE, 'platform')]);\n-      expect(def.scope).toBe('platform');\n-    });\n-\n-    it('sets scope to `null` when INJECTOR_SCOPE is absent', () => {\n-      const def = moduleDef([]);\n-      expect(def.scope).toBe(null);\n-    });\n-\n-    it('sets scope to `null` when INJECTOR_SCOPE is `null`', () => {\n-      const def = moduleDef([createProvider(INJECTOR_SCOPE, null)]);\n-      expect(def.scope).toBe(null);\n-    });\n-  });\n-});"
        },
        {
            "sha": "5c13af5b3c6a7e36ed4343eafd7bef01cdb76c99",
            "filename": "packages/core/test/view/provider_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 581,
            "changes": 581,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fprovider_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fprovider_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fview%2Fprovider_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,581 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ɵgetDOM as getDOM} from '@angular/common';\n-import {AfterContentChecked, AfterContentInit, AfterViewChecked, AfterViewInit, ChangeDetectorRef, DoCheck, ElementRef, ErrorHandler, EventEmitter, Injector, OnChanges, OnDestroy, OnInit, Renderer2, SimpleChange, TemplateRef, ViewContainerRef,} from '@angular/core';\n-import {getDebugContext} from '@angular/core/src/errors';\n-import {anchorDef, ArgumentType, asElementData, DepFlags, directiveDef, elementDef, NodeFlags, providerDef, Services, textDef} from '@angular/core/src/view/index';\n-import {TestBed, withModule} from '@angular/core/testing';\n-import {ivyEnabled} from '@angular/private/testing';\n-\n-import {ARG_TYPE_VALUES, checkNodeInlineOrDynamic, compViewDef, compViewDefFactory, createAndGetRootNodes, createRootView} from './helper';\n-\n-{\n-  describe(`View Providers`, () => {\n-    describe('create', () => {\n-      let instance: SomeService;\n-\n-      class SomeService {\n-        constructor(public dep: any) {\n-          instance = this;\n-        }\n-      }\n-\n-      beforeEach(() => {\n-        instance = null!;\n-      });\n-\n-      it('should create providers eagerly', () => {\n-        createAndGetRootNodes(compViewDef([\n-          elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-          directiveDef(1, NodeFlags.None, null, 0, SomeService, [])\n-        ]));\n-\n-        expect(instance instanceof SomeService).toBe(true);\n-      });\n-\n-      it('should create providers lazily', () => {\n-        let lazy: LazyService = undefined!;\n-        class LazyService {\n-          constructor() {\n-            lazy = this;\n-          }\n-        }\n-\n-        createAndGetRootNodes(compViewDef([\n-          elementDef(0, NodeFlags.None, null, null, 2, 'span'),\n-          providerDef(\n-              NodeFlags.TypeClassProvider | NodeFlags.LazyProvider, null, LazyService, LazyService,\n-              []),\n-          directiveDef(2, NodeFlags.None, null, 0, SomeService, [Injector])\n-        ]));\n-\n-        expect(lazy).toBeUndefined();\n-        instance.dep.get(LazyService);\n-        expect(lazy instanceof LazyService).toBe(true);\n-      });\n-\n-      it('should create value providers', () => {\n-        createAndGetRootNodes(compViewDef([\n-          elementDef(0, NodeFlags.None, null, null, 2, 'span'),\n-          providerDef(NodeFlags.TypeValueProvider, null, 'someToken', 'someValue', []),\n-          directiveDef(2, NodeFlags.None, null, 0, SomeService, ['someToken']),\n-        ]));\n-\n-        expect(instance.dep).toBe('someValue');\n-      });\n-\n-      it('should create factory providers', () => {\n-        function someFactory() {\n-          return 'someValue';\n-        }\n-\n-        createAndGetRootNodes(compViewDef([\n-          elementDef(0, NodeFlags.None, null, null, 2, 'span'),\n-          providerDef(NodeFlags.TypeFactoryProvider, null, 'someToken', someFactory, []),\n-          directiveDef(2, NodeFlags.None, null, 0, SomeService, ['someToken']),\n-        ]));\n-\n-        expect(instance.dep).toBe('someValue');\n-      });\n-\n-      it('should create useExisting providers', () => {\n-        createAndGetRootNodes(compViewDef([\n-          elementDef(0, NodeFlags.None, null, null, 3, 'span'),\n-          providerDef(NodeFlags.TypeValueProvider, null, 'someExistingToken', 'someValue', []),\n-          providerDef(\n-              NodeFlags.TypeUseExistingProvider, null, 'someToken', null, ['someExistingToken']),\n-          directiveDef(3, NodeFlags.None, null, 0, SomeService, ['someToken']),\n-        ]));\n-\n-        expect(instance.dep).toBe('someValue');\n-      });\n-\n-      it('should add a DebugContext to errors in provider factories', () => {\n-        class SomeService {\n-          constructor() {\n-            throw new Error('Test');\n-          }\n-        }\n-\n-        let err: any;\n-        try {\n-          createRootView(\n-              compViewDef([\n-                elementDef(\n-                    0, NodeFlags.None, null, null, 1, 'div', null, null, null, null,\n-                    () => compViewDef([textDef(0, null, ['a'])])),\n-                directiveDef(1, NodeFlags.Component, null, 0, SomeService, [])\n-              ]),\n-              TestBed.inject(Injector), [], getDOM().createElement('div'));\n-        } catch (e) {\n-          err = e;\n-        }\n-        expect(err).toBeTruthy();\n-        expect(err.message).toBe('Test');\n-        const debugCtx = getDebugContext(err);\n-        expect(debugCtx.view).toBeTruthy();\n-        expect(debugCtx.nodeIndex).toBe(1);\n-      });\n-\n-      describe('deps', () => {\n-        class Dep {}\n-\n-        it('should inject deps from the same element', () => {\n-          createAndGetRootNodes(compViewDef([\n-            elementDef(0, NodeFlags.None, null, null, 2, 'span'),\n-            directiveDef(1, NodeFlags.None, null, 0, Dep, []),\n-            directiveDef(2, NodeFlags.None, null, 0, SomeService, [Dep])\n-          ]));\n-\n-          expect(instance.dep instanceof Dep).toBeTruthy();\n-        });\n-\n-        it('should inject deps from a parent element', () => {\n-          createAndGetRootNodes(compViewDef([\n-            elementDef(0, NodeFlags.None, null, null, 3, 'span'),\n-            directiveDef(1, NodeFlags.None, null, 0, Dep, []),\n-            elementDef(2, NodeFlags.None, null, null, 1, 'span'),\n-            directiveDef(3, NodeFlags.None, null, 0, SomeService, [Dep])\n-          ]));\n-\n-          expect(instance.dep instanceof Dep).toBeTruthy();\n-        });\n-\n-        it('should not inject deps from sibling root elements', () => {\n-          const rootElNodes = [\n-            elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-            directiveDef(1, NodeFlags.None, null, 0, Dep, []),\n-            elementDef(2, NodeFlags.None, null, null, 1, 'span'),\n-            directiveDef(3, NodeFlags.None, null, 0, SomeService, [Dep]),\n-          ];\n-\n-          expect(() => createAndGetRootNodes(compViewDef(rootElNodes)))\n-              .toThrowError(\n-                  `${\n-                      ivyEnabled ?\n-                          'R3InjectorError' :\n-                          'StaticInjectorError'}(DynamicTestModule)[SomeService -> Dep]: \\n` +\n-                  '  StaticInjectorError(Platform: core)[SomeService -> Dep]: \\n' +\n-                  '    NullInjectorError: No provider for Dep!');\n-\n-          const nonRootElNodes = [\n-            elementDef(0, NodeFlags.None, null, null, 4, 'span'),\n-            elementDef(1, NodeFlags.None, null, null, 1, 'span'),\n-            directiveDef(2, NodeFlags.None, null, 0, Dep, []),\n-            elementDef(3, NodeFlags.None, null, null, 1, 'span'),\n-            directiveDef(4, NodeFlags.None, null, 0, SomeService, [Dep]),\n-          ];\n-\n-          expect(() => createAndGetRootNodes(compViewDef(nonRootElNodes)))\n-              .toThrowError(\n-                  `${\n-                      ivyEnabled ?\n-                          'R3InjectorError' :\n-                          'StaticInjectorError'}(DynamicTestModule)[SomeService -> Dep]: \\n` +\n-                  '  StaticInjectorError(Platform: core)[SomeService -> Dep]: \\n' +\n-                  '    NullInjectorError: No provider for Dep!');\n-        });\n-\n-        it('should inject from a parent element in a parent view', () => {\n-          createAndGetRootNodes(compViewDef([\n-            elementDef(\n-                0, NodeFlags.None, null, null, 1, 'div', null, null, null, null,\n-                () => compViewDef([\n-                  elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-                  directiveDef(1, NodeFlags.None, null, 0, SomeService, [Dep])\n-                ])),\n-            directiveDef(1, NodeFlags.Component, null, 0, Dep, []),\n-          ]));\n-\n-          expect(instance.dep instanceof Dep).toBeTruthy();\n-        });\n-\n-        it('should throw for missing dependencies', () => {\n-          expect(() => createAndGetRootNodes(compViewDef([\n-                   elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-                   directiveDef(1, NodeFlags.None, null, 0, SomeService, ['nonExistingDep'])\n-                 ])))\n-              .toThrowError(\n-                  `${\n-                      ivyEnabled ? 'R3InjectorError' :\n-                                   'StaticInjectorError'}(DynamicTestModule)[nonExistingDep]: \\n` +\n-                  '  StaticInjectorError(Platform: core)[nonExistingDep]: \\n' +\n-                  '    NullInjectorError: No provider for nonExistingDep!');\n-        });\n-\n-        it('should use null for optional missing dependencies', () => {\n-          createAndGetRootNodes(compViewDef([\n-            elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-            directiveDef(\n-                1, NodeFlags.None, null, 0, SomeService, [[DepFlags.Optional, 'nonExistingDep']])\n-          ]));\n-          expect(instance.dep).toBe(null);\n-        });\n-\n-        it('should skip the current element when using SkipSelf', () => {\n-          createAndGetRootNodes(compViewDef([\n-            elementDef(0, NodeFlags.None, null, null, 4, 'span'),\n-            providerDef(NodeFlags.TypeValueProvider, null, 'someToken', 'someParentValue', []),\n-            elementDef(2, NodeFlags.None, null, null, 2, 'span'),\n-            providerDef(NodeFlags.TypeValueProvider, null, 'someToken', 'someValue', []),\n-            directiveDef(\n-                4, NodeFlags.None, null, 0, SomeService, [[DepFlags.SkipSelf, 'someToken']])\n-          ]));\n-          expect(instance.dep).toBe('someParentValue');\n-        });\n-\n-        it('should ask the root injector',\n-           withModule({providers: [{provide: 'rootDep', useValue: 'rootValue'}]}, () => {\n-             createAndGetRootNodes(compViewDef([\n-               elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-               directiveDef(1, NodeFlags.None, null, 0, SomeService, ['rootDep'])\n-             ]));\n-\n-             expect(instance.dep).toBe('rootValue');\n-           }));\n-\n-        describe('builtin tokens', () => {\n-          it('should inject ViewContainerRef', () => {\n-            createAndGetRootNodes(compViewDef([\n-              anchorDef(NodeFlags.EmbeddedViews, null, null, 1),\n-              directiveDef(1, NodeFlags.None, null, 0, SomeService, [ViewContainerRef]),\n-            ]));\n-\n-            expect(instance.dep.createEmbeddedView).toBeTruthy();\n-          });\n-\n-          it('should inject TemplateRef', () => {\n-            createAndGetRootNodes(compViewDef([\n-              anchorDef(NodeFlags.None, null, null, 1, null, compViewDefFactory([anchorDef(\n-                                                                 NodeFlags.None, null, null, 0)])),\n-              directiveDef(1, NodeFlags.None, null, 0, SomeService, [TemplateRef]),\n-            ]));\n-\n-            expect(instance.dep.createEmbeddedView).toBeTruthy();\n-          });\n-\n-          it('should inject ElementRef', () => {\n-            const {view} = createAndGetRootNodes(compViewDef([\n-              elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-              directiveDef(1, NodeFlags.None, null, 0, SomeService, [ElementRef]),\n-            ]));\n-\n-            expect(instance.dep.nativeElement).toBe(asElementData(view, 0).renderElement);\n-          });\n-\n-          it('should inject Injector', () => {\n-            const {view} = createAndGetRootNodes(compViewDef([\n-              elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-              directiveDef(1, NodeFlags.None, null, 0, SomeService, [Injector]),\n-            ]));\n-\n-            expect(instance.dep.get(SomeService)).toBe(instance);\n-          });\n-\n-          it('should inject ChangeDetectorRef for non component providers', () => {\n-            const {view} = createAndGetRootNodes(compViewDef([\n-              elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-              directiveDef(1, NodeFlags.None, null, 0, SomeService, [ChangeDetectorRef])\n-            ]));\n-\n-            expect(instance.dep._view).toBe(view);\n-          });\n-\n-          it('should inject ChangeDetectorRef for component providers', () => {\n-            const {view, rootNodes} = createAndGetRootNodes(compViewDef([\n-              elementDef(\n-                  0, NodeFlags.None, null, null, 1, 'div', null, null, null, null,\n-                  () => compViewDef([\n-                    elementDef(0, NodeFlags.None, null, null, 0, 'span'),\n-                  ])),\n-              directiveDef(1, NodeFlags.Component, null, 0, SomeService, [ChangeDetectorRef]),\n-            ]));\n-\n-            const compView = asElementData(view, 0).componentView;\n-            expect(instance.dep._view).toBe(compView);\n-          });\n-\n-          it('should inject Renderer2', () => {\n-            createAndGetRootNodes(compViewDef([\n-              elementDef(\n-                  0, NodeFlags.None, null, null, 1, 'span', null, null, null, null,\n-                  () => compViewDef([anchorDef(NodeFlags.None, null, null, 0)])),\n-              directiveDef(1, NodeFlags.Component, null, 0, SomeService, [Renderer2])\n-            ]));\n-\n-            expect(instance.dep.createElement).toBeTruthy();\n-          });\n-        });\n-      });\n-    });\n-\n-    describe('data binding', () => {\n-      ARG_TYPE_VALUES.forEach((inlineDynamic) => {\n-        it(`should update via strategy ${inlineDynamic}`, () => {\n-          let instance: SomeService = undefined!;\n-\n-          class SomeService {\n-            a: any;\n-            b: any;\n-            constructor() {\n-              instance = this;\n-            }\n-          }\n-\n-          const {view, rootNodes} = createAndGetRootNodes(compViewDef(\n-              [\n-                elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-                directiveDef(\n-                    1, NodeFlags.None, null, 0, SomeService, [], {a: [0, 'a'], b: [1, 'b']})\n-              ],\n-              (check, view) => {\n-                checkNodeInlineOrDynamic(check, view, 1, inlineDynamic, ['v1', 'v2']);\n-              }));\n-\n-          Services.checkAndUpdateView(view);\n-\n-          expect(instance.a).toBe('v1');\n-          expect(instance.b).toBe('v2');\n-\n-          const el = rootNodes[0];\n-          expect(el.getAttribute('ng-reflect-a')).toBe('v1');\n-        });\n-      });\n-    });\n-\n-    describe('outputs', () => {\n-      it('should listen to provider events', () => {\n-        let emitter = new EventEmitter<any>();\n-        let unsubscribeSpy: any;\n-\n-        class SomeService {\n-          emitter = {\n-            subscribe: (callback: any) => {\n-              const subscription = emitter.subscribe(callback);\n-              unsubscribeSpy = spyOn(subscription, 'unsubscribe').and.callThrough();\n-              return subscription;\n-            }\n-          };\n-        }\n-\n-        const handleEvent = jasmine.createSpy('handleEvent');\n-\n-        const {view, rootNodes} = createAndGetRootNodes(compViewDef([\n-          elementDef(0, NodeFlags.None, null, null, 1, 'span', null, null, null, handleEvent),\n-          directiveDef(\n-              1, NodeFlags.None, null, 0, SomeService, [], null, {emitter: 'someEventName'})\n-        ]));\n-\n-        emitter.emit('someEventInstance');\n-        expect(handleEvent).toHaveBeenCalledWith(view, 'someEventName', 'someEventInstance');\n-\n-        Services.destroyView(view);\n-        expect(unsubscribeSpy).toHaveBeenCalled();\n-      });\n-\n-      it('should report debug info on event errors', () => {\n-        const handleErrorSpy = spyOn(TestBed.inject(ErrorHandler), 'handleError');\n-        let emitter = new EventEmitter<any>();\n-\n-        class SomeService {\n-          emitter = emitter;\n-        }\n-\n-        const {view, rootNodes} = createAndGetRootNodes(compViewDef([\n-          elementDef(\n-              0, NodeFlags.None, null, null, 1, 'span', null, null, null,\n-              () => {\n-                throw new Error('Test');\n-              }),\n-          directiveDef(\n-              1, NodeFlags.None, null, 0, SomeService, [], null, {emitter: 'someEventName'})\n-        ]));\n-\n-        emitter.emit('someEventInstance');\n-        const err = handleErrorSpy.calls.mostRecent().args[0];\n-        expect(err).toBeTruthy();\n-        const debugCtx = getDebugContext(err);\n-        expect(debugCtx.view).toBe(view);\n-        // events are emitted with the index of the element, not the index of the provider.\n-        expect(debugCtx.nodeIndex).toBe(0);\n-      });\n-    });\n-\n-    describe('lifecycle hooks', () => {\n-      it('should call the lifecycle hooks in the right order', () => {\n-        let instanceCount = 0;\n-        let log: string[] = [];\n-\n-        class SomeService implements OnInit, DoCheck, OnChanges, AfterContentInit,\n-                                     AfterContentChecked, AfterViewInit, AfterViewChecked,\n-                                     OnDestroy {\n-          id: number;\n-          a: any;\n-          ngOnInit() {\n-            log.push(`${this.id}_ngOnInit`);\n-          }\n-          ngDoCheck() {\n-            log.push(`${this.id}_ngDoCheck`);\n-          }\n-          ngOnChanges() {\n-            log.push(`${this.id}_ngOnChanges`);\n-          }\n-          ngAfterContentInit() {\n-            log.push(`${this.id}_ngAfterContentInit`);\n-          }\n-          ngAfterContentChecked() {\n-            log.push(`${this.id}_ngAfterContentChecked`);\n-          }\n-          ngAfterViewInit() {\n-            log.push(`${this.id}_ngAfterViewInit`);\n-          }\n-          ngAfterViewChecked() {\n-            log.push(`${this.id}_ngAfterViewChecked`);\n-          }\n-          ngOnDestroy() {\n-            log.push(`${this.id}_ngOnDestroy`);\n-          }\n-          constructor() {\n-            this.id = instanceCount++;\n-          }\n-        }\n-\n-        const allFlags = NodeFlags.OnInit | NodeFlags.DoCheck | NodeFlags.OnChanges |\n-            NodeFlags.AfterContentInit | NodeFlags.AfterContentChecked | NodeFlags.AfterViewInit |\n-            NodeFlags.AfterViewChecked | NodeFlags.OnDestroy;\n-        const {view, rootNodes} = createAndGetRootNodes(compViewDef(\n-            [\n-              elementDef(0, NodeFlags.None, null, null, 3, 'span'),\n-              directiveDef(1, allFlags, null, 0, SomeService, [], {a: [0, 'a']}),\n-              elementDef(2, NodeFlags.None, null, null, 1, 'span'),\n-              directiveDef(3, allFlags, null, 0, SomeService, [], {a: [0, 'a']})\n-            ],\n-            (check, view) => {\n-              check(view, 1, ArgumentType.Inline, 'someValue');\n-              check(view, 3, ArgumentType.Inline, 'someValue');\n-            }));\n-\n-        Services.checkAndUpdateView(view);\n-\n-        // Note: After... hooks are called bottom up.\n-        expect(log).toEqual([\n-          '0_ngOnChanges',\n-          '0_ngOnInit',\n-          '0_ngDoCheck',\n-          '1_ngOnChanges',\n-          '1_ngOnInit',\n-          '1_ngDoCheck',\n-          '1_ngAfterContentInit',\n-          '1_ngAfterContentChecked',\n-          '0_ngAfterContentInit',\n-          '0_ngAfterContentChecked',\n-          '1_ngAfterViewInit',\n-          '1_ngAfterViewChecked',\n-          '0_ngAfterViewInit',\n-          '0_ngAfterViewChecked',\n-        ]);\n-\n-        log = [];\n-        Services.checkAndUpdateView(view);\n-\n-        // Note: After... hooks are called bottom up.\n-        expect(log).toEqual([\n-          '0_ngDoCheck', '1_ngDoCheck', '1_ngAfterContentChecked', '0_ngAfterContentChecked',\n-          '1_ngAfterViewChecked', '0_ngAfterViewChecked'\n-        ]);\n-\n-        log = [];\n-        Services.destroyView(view);\n-\n-        // Note: ngOnDestroy ist called bottom up.\n-        expect(log).toEqual(['1_ngOnDestroy', '0_ngOnDestroy']);\n-      });\n-\n-      it('should call ngOnChanges with the changed values and the non minified names', () => {\n-        let changesLog: SimpleChange[] = [];\n-        let currValue = 'v1';\n-\n-        class SomeService implements OnChanges {\n-          a: any;\n-          ngOnChanges(changes: {[name: string]: SimpleChange}) {\n-            changesLog.push(changes['nonMinifiedA']);\n-          }\n-        }\n-\n-        const {view, rootNodes} = createAndGetRootNodes(compViewDef(\n-            [\n-              elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-              directiveDef(\n-                  1, NodeFlags.OnChanges, null, 0, SomeService, [], {a: [0, 'nonMinifiedA']})\n-            ],\n-            (check, view) => {\n-              check(view, 1, ArgumentType.Inline, currValue);\n-            }));\n-\n-        Services.checkAndUpdateView(view);\n-        expect(changesLog).toEqual([new SimpleChange(undefined, 'v1', true)]);\n-\n-        currValue = 'v2';\n-        changesLog = [];\n-        Services.checkAndUpdateView(view);\n-        expect(changesLog).toEqual([new SimpleChange('v1', 'v2', false)]);\n-      });\n-\n-      it('should add a DebugContext to errors in provider afterXXX lifecycles', () => {\n-        class SomeService implements AfterContentChecked {\n-          ngAfterContentChecked() {\n-            throw new Error('Test');\n-          }\n-        }\n-\n-        const {view, rootNodes} = createAndGetRootNodes(compViewDef([\n-          elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-          directiveDef(1, NodeFlags.AfterContentChecked, null, 0, SomeService, [], {a: [0, 'a']}),\n-        ]));\n-\n-        let err: any;\n-        try {\n-          Services.checkAndUpdateView(view);\n-        } catch (e) {\n-          err = e;\n-        }\n-        expect(err).toBeTruthy();\n-        expect(err.message).toBe('Test');\n-        const debugCtx = getDebugContext(err);\n-        expect(debugCtx.view).toBe(view);\n-        expect(debugCtx.nodeIndex).toBe(1);\n-      });\n-\n-      it('should add a DebugContext to errors inServices.destroyView', () => {\n-        class SomeService implements OnDestroy {\n-          ngOnDestroy() {\n-            throw new Error('Test');\n-          }\n-        }\n-\n-        const {view, rootNodes} = createAndGetRootNodes(compViewDef([\n-          elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-          directiveDef(1, NodeFlags.OnDestroy, null, 0, SomeService, [], {a: [0, 'a']}),\n-        ]));\n-\n-        let err: any;\n-        try {\n-          Services.destroyView(view);\n-        } catch (e) {\n-          err = e;\n-        }\n-        expect(err).toBeTruthy();\n-        expect(err.message).toBe('Test');\n-        const debugCtx = getDebugContext(err);\n-        expect(debugCtx.view).toBe(view);\n-        expect(debugCtx.nodeIndex).toBe(1);\n-      });\n-    });\n-  });\n-}"
        },
        {
            "sha": "3c17374317d69c4a12ebfff33b88a3ed5ad6dcee",
            "filename": "packages/core/test/view/pure_expression_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 136,
            "changes": 136,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fpure_expression_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fpure_expression_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fview%2Fpure_expression_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,136 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {PipeTransform} from '@angular/core';\n-import {asProviderData, directiveDef, elementDef, NodeFlags, nodeValue, pipeDef, pureArrayDef, pureObjectDef, purePipeDef, Services} from '@angular/core/src/view/index';\n-\n-import {ARG_TYPE_VALUES, checkNodeInlineOrDynamic, compViewDef, createAndGetRootNodes} from './helper';\n-\n-{\n-  describe(`View Pure Expressions`, () => {\n-    class Service {\n-      data: any;\n-    }\n-\n-    describe('pure arrays', () => {\n-      ARG_TYPE_VALUES.forEach((inlineDynamic) => {\n-        it(`should update via strategy ${inlineDynamic}`, () => {\n-          let values: any[];\n-\n-          const {view, rootNodes} = createAndGetRootNodes(compViewDef(\n-              [\n-                elementDef(0, NodeFlags.None, null, null, 2, 'span'),\n-                pureArrayDef(1, 2),\n-                directiveDef(2, NodeFlags.None, null, 0, Service, [], {data: [0, 'data']}),\n-              ],\n-              (check, view) => {\n-                const pureValue = checkNodeInlineOrDynamic(check, view, 1, inlineDynamic, values);\n-                checkNodeInlineOrDynamic(check, view, 2, inlineDynamic, [pureValue]);\n-              }));\n-          const service = asProviderData(view, 2).instance;\n-\n-          values = [1, 2];\n-          Services.checkAndUpdateView(view);\n-          const arr0 = service.data;\n-          expect(arr0).toEqual([1, 2]);\n-\n-          // instance should not change\n-          // if the values don't change\n-          Services.checkAndUpdateView(view);\n-          expect(service.data).toBe(arr0);\n-\n-          values = [3, 2];\n-          Services.checkAndUpdateView(view);\n-          const arr1 = service.data;\n-          expect(arr1).not.toBe(arr0);\n-          expect(arr1).toEqual([3, 2]);\n-        });\n-      });\n-    });\n-\n-    describe('pure objects', () => {\n-      ARG_TYPE_VALUES.forEach((inlineDynamic) => {\n-        it(`should update via strategy ${inlineDynamic}`, () => {\n-          let values: any[];\n-\n-          const {view, rootNodes} = createAndGetRootNodes(compViewDef(\n-              [\n-                elementDef(0, NodeFlags.None, null, null, 2, 'span'),\n-                pureObjectDef(1, {a: 0, b: 1}),\n-                directiveDef(2, NodeFlags.None, null, 0, Service, [], {data: [0, 'data']})\n-              ],\n-              (check, view) => {\n-                const pureValue = checkNodeInlineOrDynamic(check, view, 1, inlineDynamic, values);\n-                checkNodeInlineOrDynamic(check, view, 2, inlineDynamic, [pureValue]);\n-              }));\n-          const service = asProviderData(view, 2).instance;\n-\n-          values = [1, 2];\n-          Services.checkAndUpdateView(view);\n-          const obj0 = service.data;\n-          expect(obj0).toEqual({a: 1, b: 2});\n-\n-          // instance should not change\n-          // if the values don't change\n-          Services.checkAndUpdateView(view);\n-          expect(service.data).toBe(obj0);\n-\n-          values = [3, 2];\n-          Services.checkAndUpdateView(view);\n-          const obj1 = service.data;\n-          expect(obj1).not.toBe(obj0);\n-          expect(obj1).toEqual({a: 3, b: 2});\n-        });\n-      });\n-    });\n-\n-    describe('pure pipes', () => {\n-      ARG_TYPE_VALUES.forEach((inlineDynamic) => {\n-        it(`should update via strategy ${inlineDynamic}`, () => {\n-          class SomePipe implements PipeTransform {\n-            transform(v1: any, v2: any) {\n-              return [v1 + 10, v2 + 20];\n-            }\n-          }\n-\n-          let values: any[];\n-\n-          const {view, rootNodes} = createAndGetRootNodes(compViewDef(\n-              [\n-                elementDef(0, NodeFlags.None, null!, null!, 3, 'span'),\n-                pipeDef(NodeFlags.None, SomePipe, []),\n-                purePipeDef(2, 2),\n-                directiveDef(3, NodeFlags.None, null, 0, Service, [], {data: [0, 'data']}),\n-              ],\n-              (check, view) => {\n-                const pureValue = checkNodeInlineOrDynamic(\n-                    check, view, 2, inlineDynamic, [nodeValue(view, 1)].concat(values));\n-                checkNodeInlineOrDynamic(check, view, 3, inlineDynamic, [pureValue]);\n-              }));\n-          const service = asProviderData(view, 3).instance;\n-\n-          values = [1, 2];\n-          Services.checkAndUpdateView(view);\n-          const obj0 = service.data;\n-          expect(obj0).toEqual([11, 22]);\n-\n-          // instance should not change\n-          // if the values don't change\n-          Services.checkAndUpdateView(view);\n-          expect(service.data).toBe(obj0);\n-\n-          values = [3, 2];\n-          Services.checkAndUpdateView(view);\n-          const obj1 = service.data;\n-          expect(obj1).not.toBe(obj0);\n-          expect(obj1).toEqual([13, 22]);\n-        });\n-      });\n-    });\n-  });\n-}"
        },
        {
            "sha": "c473f56505fb2b647de1a929324f4d20278a4aa1",
            "filename": "packages/core/test/view/query_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 400,
            "changes": 400,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fquery_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fquery_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fview%2Fquery_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,400 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ElementRef, QueryList, TemplateRef, ViewContainerRef} from '@angular/core';\n-import {getDebugContext} from '@angular/core/src/errors';\n-import {anchorDef, asElementData, asProviderData, attachEmbeddedView, detachEmbeddedView, directiveDef, elementDef, NodeDef, NodeFlags, QueryBindingType, queryDef, QueryValueType, Services} from '@angular/core/src/view/index';\n-\n-import {compViewDef, compViewDefFactory, createAndGetRootNodes, createEmbeddedView} from './helper';\n-\n-{\n-  describe(`Query Views`, () => {\n-    const someQueryId = 1;\n-\n-    class AService {}\n-\n-    class QueryService {\n-      // TODO(issue/24571): remove '!'.\n-      a!: QueryList<AService>;\n-    }\n-\n-    function contentQueryProviders(checkIndex: number) {\n-      return [\n-        directiveDef(checkIndex, NodeFlags.None, null, 1, QueryService, []),\n-        queryDef(\n-            NodeFlags.TypeContentQuery | NodeFlags.DynamicQuery, someQueryId,\n-            {'a': QueryBindingType.All})\n-      ];\n-    }\n-\n-    const cQPLength = contentQueryProviders(0).length;\n-\n-    // nodes first checkIndex should be 1 (to account for the `queryDef`\n-    function compViewQueryProviders(checkIndex: number, extraChildCount: number, nodes: NodeDef[]) {\n-      return [\n-        elementDef(\n-            checkIndex, NodeFlags.None, null, null, 1 + extraChildCount, 'div', null, null, null,\n-            null, () => compViewDef([\n-                    queryDef(\n-                        NodeFlags.TypeViewQuery | NodeFlags.DynamicQuery, someQueryId,\n-                        {'a': QueryBindingType.All}),\n-                    ...nodes\n-                  ])),\n-        directiveDef(\n-            checkIndex + 1,\n-            NodeFlags.Component,\n-            null!,\n-            0,\n-            QueryService,\n-            [],\n-            null!,\n-            null!,\n-            ),\n-      ];\n-    }\n-\n-    const cVQLength = compViewQueryProviders(0, 0, []).length;\n-\n-\n-    function aServiceProvider(checkIndex: number) {\n-      return directiveDef(\n-          checkIndex, NodeFlags.None, [[someQueryId, QueryValueType.Provider]], 0, AService, []);\n-    }\n-\n-    describe('content queries', () => {\n-      it('should query providers on the same element and child elements', () => {\n-        const {view} = createAndGetRootNodes(compViewDef([\n-          elementDef(0, NodeFlags.None, null, null, 5, 'div'),\n-          ...contentQueryProviders(1),\n-          aServiceProvider(1 + cQPLength),\n-          elementDef(2 + cQPLength, NodeFlags.None, null, null, 1, 'div'),\n-          aServiceProvider(3 + cQPLength),\n-        ]));\n-\n-        const qs: QueryService = asProviderData(view, 1).instance;\n-        expect(qs.a).toBeUndefined();\n-\n-        Services.checkAndUpdateView(view);\n-\n-        const as = qs.a.toArray();\n-        expect(as.length).toBe(2);\n-        expect(as [0]).toBe(asProviderData(view, 3).instance);\n-        expect(as [1]).toBe(asProviderData(view, 5).instance);\n-      });\n-\n-      it('should not query providers on sibling or parent elements', () => {\n-        const {view} = createAndGetRootNodes(compViewDef([\n-          elementDef(0, NodeFlags.None, null, null, 6, 'div'),\n-          aServiceProvider(1),\n-          elementDef(2, NodeFlags.None, null, null, 2, 'div'),\n-          ...contentQueryProviders(3),\n-          elementDef(3 + cQPLength, NodeFlags.None, null, null, 1, 'div'),\n-          aServiceProvider(4 + cQPLength),\n-        ]));\n-\n-        Services.checkAndUpdateView(view);\n-\n-        const qs: QueryService = asProviderData(view, 3).instance;\n-        expect(qs.a.length).toBe(0);\n-      });\n-    });\n-\n-    describe('view queries', () => {\n-      it('should query providers in the view', () => {\n-        const {view} = createAndGetRootNodes(compViewDef([\n-          ...compViewQueryProviders(\n-              0, 0,\n-              [\n-                elementDef(1, NodeFlags.None, null, null, 1, 'span'),\n-                aServiceProvider(2),\n-              ]),\n-        ]));\n-\n-        Services.checkAndUpdateView(view);\n-\n-        const comp: QueryService = asProviderData(view, 1).instance;\n-        const compView = asElementData(view, 0).componentView;\n-        expect(comp.a.length).toBe(1);\n-        expect(comp.a.first).toBe(asProviderData(compView, 2).instance);\n-      });\n-\n-      it('should not query providers on the host element', () => {\n-        const {view} = createAndGetRootNodes(compViewDef([\n-          ...compViewQueryProviders(0, 1, [elementDef(1, NodeFlags.None, null, null, 0, 'span')]),\n-          aServiceProvider(cVQLength),\n-        ]));\n-\n-        Services.checkAndUpdateView(view);\n-        const comp: QueryService = asProviderData(view, 1).instance;\n-        expect(comp.a.length).toBe(0);\n-      });\n-    });\n-\n-    describe('embedded views', () => {\n-      it('should query providers in embedded views', () => {\n-        const {view} = createAndGetRootNodes(compViewDef([\n-          elementDef(0, NodeFlags.None, null, null, 5, 'div'),\n-          ...contentQueryProviders(1),\n-          anchorDef(NodeFlags.EmbeddedViews, null, null, 2, null, compViewDefFactory([\n-                      elementDef(0, NodeFlags.None, null, null, 1, 'div'),\n-                      aServiceProvider(1),\n-                    ])),\n-          ...contentQueryProviders(2 + cQPLength),\n-        ]));\n-\n-        const childView = createEmbeddedView(view, view.def.nodes[3]);\n-        attachEmbeddedView(view, asElementData(view, 3), 0, childView);\n-        Services.checkAndUpdateView(view);\n-\n-        // queries on parent elements of anchors\n-        const qs1: QueryService = asProviderData(view, 1).instance;\n-        expect(qs1.a.length).toBe(1);\n-        expect(qs1.a.first instanceof AService).toBe(true);\n-\n-        // queries on the anchor\n-        const qs2: QueryService = asProviderData(view, 4).instance;\n-        expect(qs2.a.length).toBe(1);\n-        expect(qs2.a.first instanceof AService).toBe(true);\n-      });\n-\n-      it('should query providers in embedded views only at the template declaration', () => {\n-        const {view} = createAndGetRootNodes(compViewDef([\n-          elementDef(0, NodeFlags.None, null, null, 3, 'div'),\n-          ...contentQueryProviders(1),\n-          anchorDef(NodeFlags.EmbeddedViews, null, null, 0, null, compViewDefFactory([\n-                      elementDef(0, NodeFlags.None, null, null, 1, 'div'),\n-                      aServiceProvider(1),\n-                    ])),\n-          elementDef(2 + cQPLength, NodeFlags.None, null, null, 3, 'div'),\n-          ...contentQueryProviders(3 + cQPLength),\n-          anchorDef(NodeFlags.EmbeddedViews, null, null, 0),\n-        ]));\n-\n-        const childView = createEmbeddedView(view, view.def.nodes[3]);\n-        // attach at a different place than the one where the template was defined\n-        attachEmbeddedView(view, asElementData(view, 7), 0, childView);\n-\n-        Services.checkAndUpdateView(view);\n-\n-        // query on the declaration place\n-        const qs1: QueryService = asProviderData(view, 1).instance;\n-        expect(qs1.a.length).toBe(1);\n-        expect(qs1.a.first instanceof AService).toBe(true);\n-\n-        // query on the attach place\n-        const qs2: QueryService = asProviderData(view, 5).instance;\n-        expect(qs2.a.length).toBe(0);\n-      });\n-\n-      it('should update content queries if embedded views are added or removed', () => {\n-        const {view} = createAndGetRootNodes(compViewDef([\n-          elementDef(0, NodeFlags.None, null, null, 3, 'div'),\n-          ...contentQueryProviders(1),\n-          anchorDef(NodeFlags.EmbeddedViews, null, null, 0, null, compViewDefFactory([\n-                      elementDef(0, NodeFlags.None, null, null, 1, 'div'),\n-                      aServiceProvider(1),\n-                    ])),\n-        ]));\n-\n-        Services.checkAndUpdateView(view);\n-\n-        const qs: QueryService = asProviderData(view, 1).instance;\n-        expect(qs.a.length).toBe(0);\n-\n-        const childView = createEmbeddedView(view, view.def.nodes[3]);\n-        attachEmbeddedView(view, asElementData(view, 3), 0, childView);\n-        Services.checkAndUpdateView(view);\n-\n-        expect(qs.a.length).toBe(1);\n-\n-        detachEmbeddedView(asElementData(view, 3), 0);\n-\n-        Services.checkAndUpdateView(view);\n-\n-        expect(qs.a.length).toBe(0);\n-      });\n-\n-      it('should update view queries if embedded views are added or removed', () => {\n-        const {view} = createAndGetRootNodes(compViewDef([\n-          ...compViewQueryProviders(\n-              0, 0,\n-              [\n-                anchorDef(NodeFlags.EmbeddedViews, null, null, 0, null, compViewDefFactory([\n-                            elementDef(0, NodeFlags.None, null, null, 1, 'div'),\n-                            aServiceProvider(1),\n-                          ])),\n-              ]),\n-        ]));\n-\n-        Services.checkAndUpdateView(view);\n-\n-        const comp: QueryService = asProviderData(view, 1).instance;\n-        expect(comp.a.length).toBe(0);\n-\n-        const compView = asElementData(view, 0).componentView;\n-        const childView = createEmbeddedView(compView, compView.def.nodes[1]);\n-        attachEmbeddedView(view, asElementData(compView, 1), 0, childView);\n-        Services.checkAndUpdateView(view);\n-\n-        expect(comp.a.length).toBe(1);\n-\n-        detachEmbeddedView(asElementData(compView, 1), 0);\n-        Services.checkAndUpdateView(view);\n-\n-        expect(comp.a.length).toBe(0);\n-      });\n-    });\n-\n-    describe('QueryBindingType', () => {\n-      it('should query all matches', () => {\n-        class QueryService {\n-          // TODO(issue/24571): remove '!'.\n-          a!: QueryList<AService>;\n-        }\n-\n-        const {view} = createAndGetRootNodes(compViewDef([\n-          elementDef(0, NodeFlags.None, null, null, 4, 'div'),\n-          directiveDef(1, NodeFlags.None, null, 1, QueryService, []),\n-          queryDef(\n-              NodeFlags.TypeContentQuery | NodeFlags.DynamicQuery, someQueryId,\n-              {'a': QueryBindingType.All}),\n-          aServiceProvider(3),\n-          aServiceProvider(4),\n-        ]));\n-\n-        Services.checkAndUpdateView(view);\n-\n-        const qs: QueryService = asProviderData(view, 1).instance;\n-        expect(qs.a instanceof QueryList).toBeTruthy();\n-        expect(qs.a.toArray()).toEqual([\n-          asProviderData(view, 3).instance,\n-          asProviderData(view, 4).instance,\n-        ]);\n-      });\n-\n-      it('should query the first match', () => {\n-        class QueryService {\n-          // TODO(issue/24571): remove '!'.\n-          a!: AService;\n-        }\n-\n-        const {view} = createAndGetRootNodes(compViewDef([\n-          elementDef(0, NodeFlags.None, null, null, 4, 'div'),\n-          directiveDef(1, NodeFlags.None, null, 1, QueryService, []),\n-          queryDef(\n-              NodeFlags.TypeContentQuery | NodeFlags.DynamicQuery, someQueryId,\n-              {'a': QueryBindingType.First}),\n-          aServiceProvider(3),\n-          aServiceProvider(4),\n-        ]));\n-\n-        Services.checkAndUpdateView(view);\n-\n-        const qs: QueryService = asProviderData(view, 1).instance;\n-        expect(qs.a).toBe(asProviderData(view, 3).instance);\n-      });\n-    });\n-\n-    describe('query builtins', () => {\n-      it('should query ElementRef', () => {\n-        class QueryService {\n-          // TODO(issue/24571): remove '!'.\n-          a!: ElementRef;\n-        }\n-\n-        const {view} = createAndGetRootNodes(compViewDef([\n-          elementDef(0, NodeFlags.None, [[someQueryId, QueryValueType.ElementRef]], null, 2, 'div'),\n-          directiveDef(1, NodeFlags.None, null, 1, QueryService, []),\n-          queryDef(\n-              NodeFlags.TypeContentQuery | NodeFlags.DynamicQuery, someQueryId,\n-              {'a': QueryBindingType.First}),\n-        ]));\n-\n-        Services.checkAndUpdateView(view);\n-\n-        const qs: QueryService = asProviderData(view, 1).instance;\n-        expect(qs.a.nativeElement).toBe(asElementData(view, 0).renderElement);\n-      });\n-\n-      it('should query TemplateRef', () => {\n-        class QueryService {\n-          // TODO(issue/24571): remove '!'.\n-          a!: TemplateRef<any>;\n-        }\n-\n-        const {view} = createAndGetRootNodes(compViewDef([\n-          anchorDef(\n-              NodeFlags.None, [[someQueryId, QueryValueType.TemplateRef]], null, 2, null,\n-              compViewDefFactory([anchorDef(NodeFlags.None, null, null, 0)])),\n-          directiveDef(1, NodeFlags.None, null, 1, QueryService, []),\n-          queryDef(\n-              NodeFlags.TypeContentQuery | NodeFlags.DynamicQuery, someQueryId,\n-              {'a': QueryBindingType.First}),\n-        ]));\n-\n-        Services.checkAndUpdateView(view);\n-\n-        const qs: QueryService = asProviderData(view, 1).instance;\n-        expect(qs.a.createEmbeddedView).toBeTruthy();\n-      });\n-\n-      it('should query ViewContainerRef', () => {\n-        class QueryService {\n-          // TODO(issue/24571): remove '!'.\n-          a!: ViewContainerRef;\n-        }\n-\n-        const {view} = createAndGetRootNodes(compViewDef([\n-          anchorDef(\n-              NodeFlags.EmbeddedViews, [[someQueryId, QueryValueType.ViewContainerRef]], null, 2),\n-          directiveDef(1, NodeFlags.None, null, 1, QueryService, []),\n-          queryDef(\n-              NodeFlags.TypeContentQuery | NodeFlags.DynamicQuery, someQueryId,\n-              {'a': QueryBindingType.First}),\n-        ]));\n-\n-        Services.checkAndUpdateView(view);\n-\n-        const qs: QueryService = asProviderData(view, 1).instance;\n-        expect(qs.a.createEmbeddedView).toBeTruthy();\n-      });\n-    });\n-\n-    describe('general binding behavior', () => {\n-      it('should report debug info on binding errors', () => {\n-        class QueryService {\n-          set a(value: any) {\n-            throw new Error('Test');\n-          }\n-        }\n-\n-        const {view} = createAndGetRootNodes(compViewDef([\n-          elementDef(0, NodeFlags.None, null, null, 3, 'div'),\n-          directiveDef(1, NodeFlags.None, null, 1, QueryService, []),\n-          queryDef(\n-              NodeFlags.TypeContentQuery | NodeFlags.DynamicQuery, someQueryId,\n-              {'a': QueryBindingType.All}),\n-          aServiceProvider(3),\n-        ]));\n-\n-\n-        let err: any;\n-        try {\n-          Services.checkAndUpdateView(view);\n-        } catch (e) {\n-          err = e;\n-        }\n-        expect(err).toBeTruthy();\n-        expect(err.message).toBe('Test');\n-        const debugCtx = getDebugContext(err);\n-        expect(debugCtx.view).toBe(view);\n-        expect(debugCtx.nodeIndex).toBe(2);\n-      });\n-    });\n-  });\n-}"
        },
        {
            "sha": "8ae06eb5035c7fb46f79d28e5a700b8223b43cb5",
            "filename": "packages/core/test/view/services_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 73,
            "changes": 73,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fservices_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fservices_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fview%2Fservices_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,73 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {asElementData, asTextData, DebugContext, directiveDef, elementDef, NodeFlags, QueryValueType, Services, textDef} from '@angular/core/src/view/index';\n-\n-import {compViewDef, createAndGetRootNodes} from './helper';\n-\n-{\n-  describe('View Services', () => {\n-    describe('DebugContext', () => {\n-      class AComp {}\n-\n-      class AService {}\n-\n-      function createViewWithData() {\n-        const {view} = createAndGetRootNodes(compViewDef([\n-          elementDef(\n-              0, NodeFlags.None, null, null, 1, 'div', null, null, null, null,\n-              () => compViewDef([\n-                elementDef(\n-                    0, NodeFlags.None, [['ref', QueryValueType.ElementRef]], null, 2, 'span'),\n-                directiveDef(1, NodeFlags.None, null, 0, AService, []), textDef(2, null, ['a'])\n-              ])),\n-          directiveDef(1, NodeFlags.Component, null, 0, AComp, []),\n-        ]));\n-        return view;\n-      }\n-\n-      it('should provide data for elements', () => {\n-        const view = createViewWithData();\n-        const compView = asElementData(view, 0).componentView;\n-\n-        const debugCtx = Services.createDebugContext(compView, 0);\n-\n-        expect(debugCtx.componentRenderElement).toBe(asElementData(view, 0).renderElement);\n-        expect(debugCtx.renderNode).toBe(asElementData(compView, 0).renderElement);\n-        expect(debugCtx.injector.get(AComp)).toBe(compView.component);\n-        expect(debugCtx.component).toBe(compView.component);\n-        expect(debugCtx.context).toBe(compView.context);\n-        expect(debugCtx.providerTokens).toEqual([AService]);\n-        expect(debugCtx.references['ref'].nativeElement)\n-            .toBe(asElementData(compView, 0).renderElement);\n-      });\n-\n-      it('should provide data for text nodes', () => {\n-        const view = createViewWithData();\n-        const compView = asElementData(view, 0).componentView;\n-\n-        const debugCtx = Services.createDebugContext(compView, 2);\n-\n-        expect(debugCtx.componentRenderElement).toBe(asElementData(view, 0).renderElement);\n-        expect(debugCtx.renderNode).toBe(asTextData(compView, 2).renderText);\n-        expect(debugCtx.injector.get(AComp)).toBe(compView.component);\n-        expect(debugCtx.component).toBe(compView.component);\n-        expect(debugCtx.context).toBe(compView.context);\n-      });\n-\n-      it('should provide data for other nodes based on the nearest element parent', () => {\n-        const view = createViewWithData();\n-        const compView = asElementData(view, 0).componentView;\n-\n-        const debugCtx = Services.createDebugContext(compView, 1);\n-\n-        expect(debugCtx.renderNode).toBe(asElementData(compView, 0).renderElement);\n-      });\n-    });\n-  });\n-}"
        },
        {
            "sha": "a1a6970e9191658f1386db23d4456040bf224e3d",
            "filename": "packages/core/test/view/text_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 68,
            "changes": 68,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Ftext_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Ftext_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fview%2Ftext_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,68 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ɵgetDOM as getDOM} from '@angular/common';\n-import {getDebugNode} from '@angular/core';\n-import {asTextData, elementDef, NodeFlags, Services, textDef} from '@angular/core/src/view/index';\n-\n-import {ARG_TYPE_VALUES, checkNodeInlineOrDynamic, compViewDef, createAndGetRootNodes} from './helper';\n-\n-{\n-  describe(`View Text`, () => {\n-    describe('create', () => {\n-      it('should create text nodes without parents', () => {\n-        const rootNodes = createAndGetRootNodes(compViewDef([textDef(0, null, ['a'])])).rootNodes;\n-        expect(rootNodes.length).toBe(1);\n-        expect(rootNodes[0].textContent).toBe('a');\n-      });\n-\n-      it('should create views with multiple root text nodes', () => {\n-        const rootNodes = createAndGetRootNodes(compViewDef([\n-                            textDef(0, null, ['a']),\n-                            textDef(1, null, ['b']),\n-                          ])).rootNodes;\n-        expect(rootNodes.length).toBe(2);\n-      });\n-\n-      it('should create text nodes with parents', () => {\n-        const rootNodes = createAndGetRootNodes(compViewDef([\n-                            elementDef(0, NodeFlags.None, null, null, 1, 'div'),\n-                            textDef(1, null, ['a']),\n-                          ])).rootNodes;\n-        expect(rootNodes.length).toBe(1);\n-        const textNode = rootNodes[0].firstChild;\n-        expect(textNode.textContent).toBe('a');\n-      });\n-\n-      it('should add debug information to the renderer', () => {\n-        const someContext = {};\n-        const {view, rootNodes} =\n-            createAndGetRootNodes(compViewDef([textDef(0, null, ['a'])]), someContext);\n-        expect(getDebugNode(rootNodes[0])!.nativeNode).toBe(asTextData(view, 0).renderText);\n-      });\n-    });\n-\n-    describe('change text', () => {\n-      ARG_TYPE_VALUES.forEach((inlineDynamic) => {\n-        it(`should update via strategy ${inlineDynamic}`, () => {\n-          const {view, rootNodes} = createAndGetRootNodes(compViewDef(\n-              [\n-                textDef(0, null, ['0', '1', '2']),\n-              ],\n-              null!, (check, view) => {\n-                checkNodeInlineOrDynamic(check, view, 0, inlineDynamic, ['a', 'b']);\n-              }));\n-\n-          Services.checkAndUpdateView(view);\n-\n-          expect(rootNodes[0].textContent).toBe('0a1b2');\n-        });\n-      });\n-    });\n-  });\n-}"
        },
        {
            "sha": "fb45d742e2f874ba1cf4e46553aacee27235ff65",
            "filename": "packages/core/test/view/view_def_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 217,
            "changes": 217,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fview_def_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftest%2Fview%2Fview_def_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fview%2Fview_def_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,217 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {anchorDef, directiveDef, elementDef, NodeFlags, QueryValueType, textDef, viewDef, ViewDefinition, ViewFlags} from '@angular/core/src/view/index';\n-import {filterQueryId} from '@angular/core/src/view/util';\n-\n-{\n-  describe('viewDef', () => {\n-    describe('parent', () => {\n-      function parents(viewDef: ViewDefinition): (number|null)[] {\n-        return viewDef.nodes.map(node => node.parent ? node.parent.nodeIndex : null);\n-      }\n-\n-      it('should calculate parents for one level', () => {\n-        const vd = viewDef(ViewFlags.None, [\n-          elementDef(0, NodeFlags.None, null, null, 2, 'span'),\n-          textDef(1, null, ['a']),\n-          textDef(2, null, ['a']),\n-        ]);\n-\n-        expect(parents(vd)).toEqual([null, 0, 0]);\n-      });\n-\n-      it('should calculate parents for one level, multiple roots', () => {\n-        const vd = viewDef(ViewFlags.None, [\n-          elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-          textDef(1, null, ['a']),\n-          elementDef(2, NodeFlags.None, null, null, 1, 'span'),\n-          textDef(3, null, ['a']),\n-          textDef(4, null, ['a']),\n-        ]);\n-\n-        expect(parents(vd)).toEqual([null, 0, null, 2, null]);\n-      });\n-\n-      it('should calculate parents for multiple levels', () => {\n-        const vd = viewDef(ViewFlags.None, [\n-          elementDef(0, NodeFlags.None, null, null, 2, 'span'),\n-          elementDef(1, NodeFlags.None, null, null, 1, 'span'),\n-          textDef(2, null, ['a']),\n-          elementDef(3, NodeFlags.None, null, null, 1, 'span'),\n-          textDef(4, null, ['a']),\n-          textDef(5, null, ['a']),\n-        ]);\n-\n-        expect(parents(vd)).toEqual([null, 0, 1, null, 3, null]);\n-      });\n-    });\n-\n-    describe('childFlags', () => {\n-      function childFlags(viewDef: ViewDefinition): number[] {\n-        return viewDef.nodes.map(node => node.childFlags);\n-      }\n-\n-      function directChildFlags(viewDef: ViewDefinition): number[] {\n-        return viewDef.nodes.map(node => node.directChildFlags);\n-      }\n-\n-      it('should calculate childFlags for one level', () => {\n-        const vd = viewDef(ViewFlags.None, [\n-          elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-          directiveDef(1, NodeFlags.AfterContentChecked, null, 0, AService, [])\n-        ]);\n-\n-        expect(childFlags(vd)).toEqual([\n-          NodeFlags.TypeDirective | NodeFlags.AfterContentChecked, NodeFlags.None\n-        ]);\n-\n-        expect(directChildFlags(vd)).toEqual([\n-          NodeFlags.TypeDirective | NodeFlags.AfterContentChecked, NodeFlags.None\n-        ]);\n-      });\n-\n-      it('should calculate childFlags for two levels', () => {\n-        const vd = viewDef(ViewFlags.None, [\n-          elementDef(0, NodeFlags.None, null, null, 2, 'span'),\n-          elementDef(1, NodeFlags.None, null, null, 1, 'span'),\n-          directiveDef(2, NodeFlags.AfterContentChecked, null, 0, AService, [])\n-        ]);\n-\n-        expect(childFlags(vd)).toEqual([\n-          NodeFlags.TypeElement | NodeFlags.TypeDirective | NodeFlags.AfterContentChecked,\n-          NodeFlags.TypeDirective | NodeFlags.AfterContentChecked, NodeFlags.None\n-        ]);\n-\n-        expect(directChildFlags(vd)).toEqual([\n-          NodeFlags.TypeElement, NodeFlags.TypeDirective | NodeFlags.AfterContentChecked,\n-          NodeFlags.None\n-        ]);\n-      });\n-\n-      it('should calculate childFlags for one level, multiple roots', () => {\n-        const vd = viewDef(ViewFlags.None, [\n-          elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-          directiveDef(1, NodeFlags.AfterContentChecked, null, 0, AService, []),\n-          elementDef(2, NodeFlags.None, null, null, 2, 'span'),\n-          directiveDef(3, NodeFlags.AfterContentInit, null, 0, AService, []),\n-          directiveDef(4, NodeFlags.AfterViewChecked, null, 0, AService, []),\n-        ]);\n-\n-        expect(childFlags(vd)).toEqual([\n-          NodeFlags.TypeDirective | NodeFlags.AfterContentChecked, NodeFlags.None,\n-          NodeFlags.TypeDirective | NodeFlags.AfterContentInit | NodeFlags.AfterViewChecked,\n-          NodeFlags.None, NodeFlags.None\n-        ]);\n-\n-        expect(directChildFlags(vd)).toEqual([\n-          NodeFlags.TypeDirective | NodeFlags.AfterContentChecked, NodeFlags.None,\n-          NodeFlags.TypeDirective | NodeFlags.AfterContentInit | NodeFlags.AfterViewChecked,\n-          NodeFlags.None, NodeFlags.None\n-        ]);\n-      });\n-\n-      it('should calculate childFlags for multiple levels', () => {\n-        const vd = viewDef(ViewFlags.None, [\n-          elementDef(0, NodeFlags.None, null, null, 2, 'span'),\n-          elementDef(1, NodeFlags.None, null, null, 1, 'span'),\n-          directiveDef(2, NodeFlags.AfterContentChecked, null!, 0, AService, []),\n-          elementDef(3, NodeFlags.None, null, null, 2, 'span'),\n-          directiveDef(4, NodeFlags.AfterContentInit, null, 0, AService, []),\n-          directiveDef(5, NodeFlags.AfterViewInit, null, 0, AService, []),\n-        ]);\n-\n-        expect(childFlags(vd)).toEqual([\n-          NodeFlags.TypeElement | NodeFlags.TypeDirective | NodeFlags.AfterContentChecked,\n-          NodeFlags.TypeDirective | NodeFlags.AfterContentChecked, NodeFlags.None,\n-          NodeFlags.TypeDirective | NodeFlags.AfterContentInit | NodeFlags.AfterViewInit,\n-          NodeFlags.None, NodeFlags.None\n-        ]);\n-\n-        expect(directChildFlags(vd)).toEqual([\n-          NodeFlags.TypeElement, NodeFlags.TypeDirective | NodeFlags.AfterContentChecked,\n-          NodeFlags.None,\n-          NodeFlags.TypeDirective | NodeFlags.AfterContentInit | NodeFlags.AfterViewInit,\n-          NodeFlags.None, NodeFlags.None\n-        ]);\n-      });\n-    });\n-\n-    describe('childMatchedQueries', () => {\n-      function childMatchedQueries(viewDef: ViewDefinition): number[] {\n-        return viewDef.nodes.map(node => node.childMatchedQueries);\n-      }\n-\n-      it('should calculate childMatchedQueries for one level', () => {\n-        const vd = viewDef(ViewFlags.None, [\n-          elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-          directiveDef(1, NodeFlags.None, [[1, QueryValueType.Provider]], 0, AService, [])\n-        ]);\n-\n-        expect(childMatchedQueries(vd)).toEqual([filterQueryId(1), 0]);\n-      });\n-\n-      it('should calculate childMatchedQueries for two levels', () => {\n-        const vd = viewDef(ViewFlags.None, [\n-          elementDef(0, NodeFlags.None, null, null, 2, 'span'),\n-          elementDef(1, NodeFlags.None, null, null, 1, 'span'),\n-          directiveDef(2, NodeFlags.None, [[1, QueryValueType.Provider]], 0, AService, [])\n-        ]);\n-\n-        expect(childMatchedQueries(vd)).toEqual([filterQueryId(1), filterQueryId(1), 0]);\n-      });\n-\n-      it('should calculate childMatchedQueries for one level, multiple roots', () => {\n-        const vd = viewDef(ViewFlags.None, [\n-          elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-          directiveDef(1, NodeFlags.None, [[1, QueryValueType.Provider]], 0, AService, []),\n-          elementDef(2, NodeFlags.None, null, null, 2, 'span'),\n-          directiveDef(3, NodeFlags.None, [[2, QueryValueType.Provider]], 0, AService, []),\n-          directiveDef(4, NodeFlags.None, [[3, QueryValueType.Provider]], 0, AService, []),\n-        ]);\n-\n-        expect(childMatchedQueries(vd)).toEqual([\n-          filterQueryId(1), 0, filterQueryId(2) | filterQueryId(3), 0, 0\n-        ]);\n-      });\n-\n-      it('should calculate childMatchedQueries for multiple levels', () => {\n-        const vd = viewDef(ViewFlags.None, [\n-          elementDef(0, NodeFlags.None, null, null, 2, 'span'),\n-          elementDef(1, NodeFlags.None, null, null, 1, 'span'),\n-          directiveDef(2, NodeFlags.None, [[1, QueryValueType.Provider]], 0, AService, []),\n-          elementDef(3, NodeFlags.None, null, null, 2, 'span'),\n-          directiveDef(4, NodeFlags.None, [[2, QueryValueType.Provider]], 0, AService, []),\n-          directiveDef(5, NodeFlags.None, [[3, QueryValueType.Provider]], 0, AService, []),\n-        ]);\n-\n-        expect(childMatchedQueries(vd)).toEqual([\n-          filterQueryId(1), filterQueryId(1), 0, filterQueryId(2) | filterQueryId(3), 0, 0\n-        ]);\n-      });\n-\n-      it('should included embedded views into childMatchedQueries', () => {\n-        const vd = viewDef(ViewFlags.None, [\n-          elementDef(0, NodeFlags.None, null, null, 1, 'span'),\n-          anchorDef(\n-              NodeFlags.None, null, null, 0, null,\n-              () => viewDef(\n-                  ViewFlags.None,\n-                  [\n-                    elementDef(0, NodeFlags.None, [[1, QueryValueType.Provider]], null, 0, 'span'),\n-                  ]))\n-        ]);\n-\n-        // Note: the template will become a sibling to the anchor once stamped out,\n-        expect(childMatchedQueries(vd)).toEqual([filterQueryId(1), 0]);\n-      });\n-    });\n-  });\n-}\n-\n-class AService {}"
        },
        {
            "sha": "8a6e4c8b03b66f30dcd7de46001243b315e2ba96",
            "filename": "packages/core/testing/src/private_export_testing.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 9,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftesting%2Fsrc%2Fprivate_export_testing.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftesting%2Fsrc%2Fprivate_export_testing.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftesting%2Fsrc%2Fprivate_export_testing.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,9 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-export {TestingCompiler as ɵTestingCompiler, TestingCompilerFactory as ɵTestingCompilerFactory} from './test_compiler';"
        },
        {
            "sha": "0d825325ad362e0ef09506b8e4b7fe001fbfaa4a",
            "filename": "packages/core/testing/src/test_bed.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftesting%2Fsrc%2Ftest_bed.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftesting%2Fsrc%2Ftest_bed.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftesting%2Fsrc%2Ftest_bed.ts?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -12,8 +12,8 @@ import {ComponentFixture} from './component_fixture';\n import {MetadataOverride} from './metadata_override';\n import {_getTestBedRender3, TestBedRender3} from './r3_test_bed';\n import {ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, ModuleTeardownOptions, TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT, TestBedStatic, TestComponentRenderer, TestEnvironmentOptions, TestModuleMetadata} from './test_bed_common';\n-import {TestingCompiler, TestingCompilerFactory} from './test_compiler';\n \n+const TestingCompiler: any = null;\n \n let _nextRootElementId = 0;\n \n@@ -275,7 +275,7 @@ export class TestBedViewEngine implements TestBed {\n \n   private _instantiated: boolean = false;\n \n-  private _compiler: TestingCompiler = null!;\n+  private _compiler: any = null!;\n   private _moduleRef: NgModuleRef<any>|null = null;\n   private _moduleFactory: NgModuleFactory<any>|null = null;\n   private _pendingModuleFactory: Type<unknown>|null = null;\n@@ -416,7 +416,7 @@ export class TestBedViewEngine implements TestBed {\n \n     const moduleType = this._createCompilerAndModule();\n     this._pendingModuleFactory = moduleType;\n-    return this._compiler.compileModuleAndAllComponentsAsync(moduleType).then(result => {\n+    return this._compiler.compileModuleAndAllComponentsAsync(moduleType).then((result: any) => {\n       // If the module mismatches by the time the promise resolves, it means that the module has\n       // already been destroyed and a new compilation has started. If that's the case, avoid\n       // overwriting the module factory, because it can cause downstream errors.\n@@ -460,9 +460,9 @@ export class TestBedViewEngine implements TestBed {\n     const ngZoneInjector = Injector.create({\n       providers: providers,\n       parent: this.platform.injector,\n-      name: this._moduleFactory.moduleType.name\n+      name: this._moduleFactory!.moduleType.name\n     });\n-    this._moduleRef = this._moduleFactory.create(ngZoneInjector);\n+    this._moduleRef = this._moduleFactory!.create(ngZoneInjector);\n     // ApplicationInitStatus.runInitializers() is marked @internal to core. So casting to any\n     // before accessing it.\n     try {\n@@ -499,7 +499,7 @@ export class TestBedViewEngine implements TestBed {\n     class DynamicTestModule {\n     }\n \n-    const compilerFactory = this.platform.injector.get(TestingCompilerFactory);\n+    const compilerFactory = this.platform.injector.get(null!) as any;\n     this._compiler = compilerFactory.createTestingCompiler(this._compilerOptions);\n     for (const summary of [this._testEnvAotSummaries, ...this._aotSummaries]) {\n       this._compiler.loadAotSummaries(summary);"
        },
        {
            "sha": "0f14bb1a4fd5235b45cd59d8352d9fa6a6b153f2",
            "filename": "packages/core/testing/src/test_compiler.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 72,
            "changes": 72,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftesting%2Fsrc%2Ftest_compiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fcore%2Ftesting%2Fsrc%2Ftest_compiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftesting%2Fsrc%2Ftest_compiler.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723",
            "patch": "@@ -1,72 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Compiler, CompilerOptions, Component, ComponentFactory, Directive, Injectable, Injector, NgModule, Pipe, Type} from '@angular/core';\n-\n-import {MetadataOverride} from './metadata_override';\n-\n-function unimplemented(): any {\n-  throw Error('unimplemented');\n-}\n-\n-/**\n- * Special interface to the compiler only used by testing\n- *\n- * @publicApi\n- */\n-@Injectable()\n-export class TestingCompiler extends Compiler {\n-  get injector(): Injector {\n-    throw unimplemented();\n-  }\n-  overrideModule(module: Type<any>, overrides: MetadataOverride<NgModule>): void {\n-    throw unimplemented();\n-  }\n-  overrideDirective(directive: Type<any>, overrides: MetadataOverride<Directive>): void {\n-    throw unimplemented();\n-  }\n-  overrideComponent(component: Type<any>, overrides: MetadataOverride<Component>): void {\n-    throw unimplemented();\n-  }\n-  overridePipe(directive: Type<any>, overrides: MetadataOverride<Pipe>): void {\n-    throw unimplemented();\n-  }\n-  /**\n-   * Allows to pass the compile summary from AOT compilation to the JIT compiler,\n-   * so that it can use the code generated by AOT.\n-   */\n-  loadAotSummaries(summaries: () => any[]) {\n-    throw unimplemented();\n-  }\n-\n-  /**\n-   * Gets the component factory for the given component.\n-   * This assumes that the component has been compiled before calling this call using\n-   * `compileModuleAndAllComponents*`.\n-   */\n-  getComponentFactory<T>(component: Type<T>): ComponentFactory<T> {\n-    throw unimplemented();\n-  }\n-\n-  /**\n-   * Returns the component type that is stored in the given error.\n-   * This can be used for errors created by compileModule...\n-   */\n-  getComponentFromError(error: Error): Type<any>|null {\n-    throw unimplemented();\n-  }\n-}\n-\n-/**\n- * A factory for creating a Compiler\n- *\n- * @publicApi\n- */\n-export abstract class TestingCompilerFactory {\n-  abstract createTestingCompiler(options?: CompilerOptions[]): TestingCompiler;\n-}"
        },
        {
            "sha": "00a76b3fe633dbabb3504a4c9ef213264ef990d7",
            "filename": "packages/core/testing/src/testing.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftesting%2Fsrc%2Ftesting.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fcore%2Ftesting%2Fsrc%2Ftesting.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftesting%2Fsrc%2Ftesting.ts?ref=bb9ff6003c620b3cf00232189d60097395382802",
            "patch": "@@ -20,4 +20,3 @@ export {TestComponentRenderer, ComponentFixtureAutoDetect, ComponentFixtureNoNgZ\n export * from './test_hooks';\n export * from './metadata_override';\n export {MetadataOverrider as ɵMetadataOverrider} from './metadata_overrider';\n-export * from './private_export_testing';"
        },
        {
            "sha": "c5ee94af71219565070a71091389825deff779bc",
            "filename": "packages/language-service/test/completions_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Flanguage-service%2Ftest%2Fcompletions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Flanguage-service%2Ftest%2Fcompletions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fcompletions_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723"
        },
        {
            "sha": "145d8a3d1fb328d855089658bdcdd61f4b61f725",
            "filename": "packages/language-service/test/definitions_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 215,
            "changes": 215,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Flanguage-service%2Ftest%2Fdefinitions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Flanguage-service%2Ftest%2Fdefinitions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fdefinitions_spec.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723"
        },
        {
            "sha": "4d83bb72155296f3e61a894296a90b872237135d",
            "filename": "packages/platform-browser-dynamic/testing/BUILD.bazel",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fplatform-browser-dynamic%2Ftesting%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fplatform-browser-dynamic%2Ftesting%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser-dynamic%2Ftesting%2FBUILD.bazel?ref=bb9ff6003c620b3cf00232189d60097395382802"
        },
        {
            "sha": "c25a15af5b58ec3a1ceac0f51c93347553b5edff",
            "filename": "packages/platform-browser-dynamic/testing/src/compiler_factory.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 116,
            "changes": 116,
            "blob_url": "https://github.com/angular/angular/blob/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fplatform-browser-dynamic%2Ftesting%2Fsrc%2Fcompiler_factory.ts",
            "raw_url": "https://github.com/angular/angular/raw/f44cb57c12c29e76167272c675c0ce23838ce723/packages%2Fplatform-browser-dynamic%2Ftesting%2Fsrc%2Fcompiler_factory.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser-dynamic%2Ftesting%2Fsrc%2Fcompiler_factory.ts?ref=f44cb57c12c29e76167272c675c0ce23838ce723"
        },
        {
            "sha": "f01c3d9a91b53dd2e8f5f0fc4bd7781c09e13ecc",
            "filename": "packages/platform-browser-dynamic/testing/src/platform_core_dynamic_testing.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 11,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fplatform-browser-dynamic%2Ftesting%2Fsrc%2Fplatform_core_dynamic_testing.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fplatform-browser-dynamic%2Ftesting%2Fsrc%2Fplatform_core_dynamic_testing.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser-dynamic%2Ftesting%2Fsrc%2Fplatform_core_dynamic_testing.ts?ref=bb9ff6003c620b3cf00232189d60097395382802"
        },
        {
            "sha": "3788a907267d58642a078b635f8bda868e3ea988",
            "filename": "packages/private/testing/BUILD.bazel",
            "status": "modified",
            "additions": 2,
            "deletions": 16,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fprivate%2Ftesting%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fprivate%2Ftesting%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fprivate%2Ftesting%2FBUILD.bazel?ref=bb9ff6003c620b3cf00232189d60097395382802"
        },
        {
            "sha": "8a2caba0da1e128a2a307fc893d7b629e28b8e32",
            "filename": "packages/private/testing/src/angular_ivy_enabled.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fprivate%2Ftesting%2Fsrc%2Fangular_ivy_enabled.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fprivate%2Ftesting%2Fsrc%2Fangular_ivy_enabled.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fprivate%2Ftesting%2Fsrc%2Fangular_ivy_enabled.ts?ref=bb9ff6003c620b3cf00232189d60097395382802"
        },
        {
            "sha": "31d3e2303441247ff514fe24e15fe55eb6c84fbb",
            "filename": "packages/private/testing/src/ivy_test_selectors.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fprivate%2Ftesting%2Fsrc%2Fivy_test_selectors.ts",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/packages%2Fprivate%2Ftesting%2Fsrc%2Fivy_test_selectors.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fprivate%2Ftesting%2Fsrc%2Fivy_test_selectors.ts?ref=bb9ff6003c620b3cf00232189d60097395382802"
        },
        {
            "sha": "dd591d6c0fdc4a1905b1dcffabbeb2141cf3e7bb",
            "filename": "tools/saucelabs/README.md",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/bb9ff6003c620b3cf00232189d60097395382802/tools%2Fsaucelabs%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/bb9ff6003c620b3cf00232189d60097395382802/tools%2Fsaucelabs%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/tools%2Fsaucelabs%2FREADME.md?ref=bb9ff6003c620b3cf00232189d60097395382802"
        }
    ],
    "stats": {
        "total": 20940,
        "additions": 184,
        "deletions": 20756
    }
}