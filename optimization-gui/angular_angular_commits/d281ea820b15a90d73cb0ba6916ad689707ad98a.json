{
    "author": "JoostK",
    "message": "perf(compiler): use raw bytes to represent utf-8 encoded strings (#39694)\n\nThe result of utf-8 encoding a string was represented in a string, where\neach individual character represented a single byte according to its\ncharacter code. All usages of this data were interested in the byte\nitself, so this required conversion from a character back to its code.\nThis commit simply stores the individual bytes in array to avoid the\nconversion. This yields a ~10% performance improvement for i18n message\nID computation.\n\nPR Close #39694",
    "sha": "d281ea820b15a90d73cb0ba6916ad689707ad98a",
    "files": [
        {
            "sha": "85a6d629bce0bdd14c7cb5fb500fc2d0d66eebb1",
            "filename": "packages/compiler/src/i18n/digest.ts",
            "status": "modified",
            "additions": 28,
            "deletions": 28,
            "changes": 56,
            "blob_url": "https://github.com/angular/angular/blob/d281ea820b15a90d73cb0ba6916ad689707ad98a/packages%2Fcompiler%2Fsrc%2Fi18n%2Fdigest.ts",
            "raw_url": "https://github.com/angular/angular/raw/d281ea820b15a90d73cb0ba6916ad689707ad98a/packages%2Fcompiler%2Fsrc%2Fi18n%2Fdigest.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fi18n%2Fdigest.ts?ref=d281ea820b15a90d73cb0ba6916ad689707ad98a",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {newArray, utf8Encode} from '../util';\n+import {Byte, newArray, utf8Encode} from '../util';\n import {BigIntExponentiation} from './big_integer';\n \n import * as i18n from './i18n_ast';\n@@ -110,7 +110,7 @@ class _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {\n  */\n export function sha1(str: string): string {\n   const utf8 = utf8Encode(str);\n-  const words32 = stringToWords32(utf8, Endian.Big);\n+  const words32 = bytesToWords32(utf8, Endian.Big);\n   const len = utf8.length * 8;\n \n   const w = newArray(80);\n@@ -146,7 +146,7 @@ export function sha1(str: string): string {\n     e = add32(e, h4);\n   }\n \n-  return byteStringToHexString(words32ToByteString([a, b, c, d, e]));\n+  return bytesToHexString(words32ToByteString([a, b, c, d, e]));\n }\n \n function fk(index: number, b: number, c: number, d: number): [number, number] {\n@@ -201,25 +201,25 @@ export function computeMsgId(msg: string, meaning: string = ''): string {\n   return wordsToDecimalString(hi & 0x7fffffff, lo);\n }\n \n-function hash32(str: string, c: number): number {\n+function hash32(bytes: Byte[], c: number): number {\n   let a = 0x9e3779b9, b = 0x9e3779b9;\n   let i: number;\n \n-  const len = str.length;\n+  const len = bytes.length;\n \n   for (i = 0; i + 12 <= len; i += 12) {\n-    a = add32(a, wordAt(str, i, Endian.Little));\n-    b = add32(b, wordAt(str, i + 4, Endian.Little));\n-    c = add32(c, wordAt(str, i + 8, Endian.Little));\n+    a = add32(a, wordAt(bytes, i, Endian.Little));\n+    b = add32(b, wordAt(bytes, i + 4, Endian.Little));\n+    c = add32(c, wordAt(bytes, i + 8, Endian.Little));\n     const res = mix(a, b, c);\n     a = res[0], b = res[1], c = res[2];\n   }\n \n-  a = add32(a, wordAt(str, i, Endian.Little));\n-  b = add32(b, wordAt(str, i + 4, Endian.Little));\n+  a = add32(a, wordAt(bytes, i, Endian.Little));\n+  b = add32(b, wordAt(bytes, i + 4, Endian.Little));\n   // the first byte of c is reserved for the length\n   c = add32(c, len);\n-  c = add32(c, wordAt(str, i + 8, Endian.Little) << 8);\n+  c = add32(c, wordAt(bytes, i + 8, Endian.Little) << 8);\n \n   return mix(a, b, c)[2];\n }\n@@ -285,51 +285,51 @@ function rol64(num: [number, number], count: number): [number, number] {\n   return [h, l];\n }\n \n-function stringToWords32(str: string, endian: Endian): number[] {\n-  const size = (str.length + 3) >>> 2;\n+function bytesToWords32(bytes: Byte[], endian: Endian): number[] {\n+  const size = (bytes.length + 3) >>> 2;\n   const words32 = [];\n \n   for (let i = 0; i < size; i++) {\n-    words32[i] = wordAt(str, i * 4, endian);\n+    words32[i] = wordAt(bytes, i * 4, endian);\n   }\n \n   return words32;\n }\n \n-function byteAt(str: string, index: number): number {\n-  return index >= str.length ? 0 : str.charCodeAt(index) & 0xff;\n+function byteAt(bytes: Byte[], index: number): Byte {\n+  return index >= bytes.length ? 0 : bytes[index];\n }\n \n-function wordAt(str: string, index: number, endian: Endian): number {\n+function wordAt(bytes: Byte[], index: number, endian: Endian): number {\n   let word = 0;\n   if (endian === Endian.Big) {\n     for (let i = 0; i < 4; i++) {\n-      word += byteAt(str, index + i) << (24 - 8 * i);\n+      word += byteAt(bytes, index + i) << (24 - 8 * i);\n     }\n   } else {\n     for (let i = 0; i < 4; i++) {\n-      word += byteAt(str, index + i) << 8 * i;\n+      word += byteAt(bytes, index + i) << 8 * i;\n     }\n   }\n   return word;\n }\n \n-function words32ToByteString(words32: number[]): string {\n-  return words32.reduce((str, word) => str + word32ToByteString(word), '');\n+function words32ToByteString(words32: number[]): Byte[] {\n+  return words32.reduce((bytes, word) => bytes.concat(word32ToByteString(word)), [] as Byte[]);\n }\n \n-function word32ToByteString(word: number): string {\n-  let str = '';\n+function word32ToByteString(word: number): Byte[] {\n+  let bytes: Byte[] = [];\n   for (let i = 0; i < 4; i++) {\n-    str += String.fromCharCode((word >>> 8 * (3 - i)) & 0xff);\n+    bytes.push((word >>> 8 * (3 - i)) & 0xff);\n   }\n-  return str;\n+  return bytes;\n }\n \n-function byteStringToHexString(str: string): string {\n+function bytesToHexString(bytes: Byte[]): string {\n   let hex: string = '';\n-  for (let i = 0; i < str.length; i++) {\n-    const b = byteAt(str, i);\n+  for (let i = 0; i < bytes.length; i++) {\n+    const b = byteAt(bytes, i);\n     hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);\n   }\n   return hex.toLowerCase();"
        },
        {
            "sha": "915f3ea4faf43e6886554db74b13fb49cdc9376c",
            "filename": "packages/compiler/src/output/source_map.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/d281ea820b15a90d73cb0ba6916ad689707ad98a/packages%2Fcompiler%2Fsrc%2Foutput%2Fsource_map.ts",
            "raw_url": "https://github.com/angular/angular/raw/d281ea820b15a90d73cb0ba6916ad689707ad98a/packages%2Fcompiler%2Fsrc%2Foutput%2Fsource_map.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Foutput%2Fsource_map.ts?ref=d281ea820b15a90d73cb0ba6916ad689707ad98a",
            "patch": "@@ -151,15 +151,15 @@ export class SourceMapGenerator {\n \n export function toBase64String(value: string): string {\n   let b64 = '';\n-  value = utf8Encode(value);\n-  for (let i = 0; i < value.length;) {\n-    const i1 = value.charCodeAt(i++);\n-    const i2 = value.charCodeAt(i++);\n-    const i3 = value.charCodeAt(i++);\n+  const encoded = utf8Encode(value);\n+  for (let i = 0; i < encoded.length;) {\n+    const i1 = encoded[i++];\n+    const i2 = i < encoded.length ? encoded[i++] : null;\n+    const i3 = i < encoded.length ? encoded[i++] : null;\n     b64 += toBase64Digit(i1 >> 2);\n-    b64 += toBase64Digit(((i1 & 3) << 4) | (isNaN(i2) ? 0 : i2 >> 4));\n-    b64 += isNaN(i2) ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 >> 6));\n-    b64 += isNaN(i2) || isNaN(i3) ? '=' : toBase64Digit(i3 & 63);\n+    b64 += toBase64Digit(((i1 & 3) << 4) | (i2 === null ? 0 : i2 >> 4));\n+    b64 += i2 === null ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 === null ? 0 : i3 >> 6));\n+    b64 += i2 === null || i3 === null ? '=' : toBase64Digit(i3 & 63);\n   }\n \n   return b64;"
        },
        {
            "sha": "8c62653f09b2dfe1f8d428556a7c209142291c51",
            "filename": "packages/compiler/src/util.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 6,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/d281ea820b15a90d73cb0ba6916ad689707ad98a/packages%2Fcompiler%2Fsrc%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/d281ea820b15a90d73cb0ba6916ad689707ad98a/packages%2Fcompiler%2Fsrc%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Futil.ts?ref=d281ea820b15a90d73cb0ba6916ad689707ad98a",
            "patch": "@@ -132,8 +132,10 @@ function isStrictStringMap(obj: any): boolean {\n   return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n }\n \n-export function utf8Encode(str: string): string {\n-  let encoded = '';\n+export type Byte = number;\n+\n+export function utf8Encode(str: string): Byte[] {\n+  let encoded: Byte[] = [];\n   for (let index = 0; index < str.length; index++) {\n     let codePoint = str.charCodeAt(index);\n \n@@ -148,14 +150,14 @@ export function utf8Encode(str: string): string {\n     }\n \n     if (codePoint <= 0x7f) {\n-      encoded += String.fromCharCode(codePoint);\n+      encoded.push(codePoint);\n     } else if (codePoint <= 0x7ff) {\n-      encoded += String.fromCharCode(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\n+      encoded.push(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\n     } else if (codePoint <= 0xffff) {\n-      encoded += String.fromCharCode(\n+      encoded.push(\n           (codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n     } else if (codePoint <= 0x1fffff) {\n-      encoded += String.fromCharCode(\n+      encoded.push(\n           ((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80,\n           ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n     }"
        },
        {
            "sha": "0a9d49a7200c319406fd7817d00ea82df5463d66",
            "filename": "packages/compiler/test/util_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/d281ea820b15a90d73cb0ba6916ad689707ad98a/packages%2Fcompiler%2Ftest%2Futil_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/d281ea820b15a90d73cb0ba6916ad689707ad98a/packages%2Fcompiler%2Ftest%2Futil_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Futil_spec.ts?ref=d281ea820b15a90d73cb0ba6916ad689707ad98a",
            "patch": "@@ -73,7 +73,7 @@ import {escapeRegExp, partitionArray, splitAtColon, stringify, utf8Encode} from\n           ['\\uDFFF', '\\xED\\xBF\\xBF'],\n         ];\n         tests.forEach(([input, output]) => {\n-          expect(utf8Encode(input)).toEqual(output);\n+          expect(utf8Encode(input).map(byte => String.fromCharCode(byte)).join('')).toEqual(output);\n         });\n       });\n     });"
        }
    ],
    "stats": {
        "total": 88,
        "additions": 45,
        "deletions": 43
    }
}