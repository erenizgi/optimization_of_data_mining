{
    "author": "gkalpak",
    "message": "fix(docs-infra): do not deploy as `archive` when major is not lower than stable (#39853)\n\nPreviously, a branch would be deployed as `archive` even if it had a\nmajor version that was equal/higher than that of the stable branch (as\nlong as it was not the RC branch - i.e. not the most recent minor\nbranch). For example, with `11.0.x` as the stable branch  and `12.0.x`\nas the RC branch, `11.1.x` would be deployed as archive.\n\nTheoretically, we should never find ourselves in such a situation.\nTypically, there will only be at most one minor branch most recent than\nthe stable one (and that branch will be the RC branch). However, it\nis possible under unusual circumstances.\n\nThis commit adds additional checks to guard against this problem. It\nalso refactors the code in preparation of fixing an issue with\n`rc.angular.io` redirects in the presence of a ServiceWorker, which will\nrequire identifying whether there is an active RC version or not.\nSee #39760 for more details.\n\nPR Close #39853",
    "sha": "1e39e493fb321913a748039d152b10c7a80e53fa",
    "files": [
        {
            "sha": "caba35ff19bd93f5c7db9f24311fecf2568c3b5f",
            "filename": "aio/scripts/deploy-to-firebase.js",
            "status": "modified",
            "additions": 64,
            "deletions": 35,
            "changes": 99,
            "blob_url": "https://github.com/angular/angular/blob/1e39e493fb321913a748039d152b10c7a80e53fa/aio%2Fscripts%2Fdeploy-to-firebase.js",
            "raw_url": "https://github.com/angular/angular/raw/1e39e493fb321913a748039d152b10c7a80e53fa/aio%2Fscripts%2Fdeploy-to-firebase.js",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fscripts%2Fdeploy-to-firebase.js?ref=1e39e493fb321913a748039d152b10c7a80e53fa",
            "patch": "@@ -18,6 +18,7 @@ module.exports = {\n   computeDeploymentsInfo,\n   computeInputVars,\n   getLatestCommit,\n+  getMostRecentMinorBranch,\n };\n \n // Run\n@@ -131,47 +132,58 @@ function computeDeploymentsInfo(\n     },\n   };\n \n+  // If the current branch is `master`, deploy as `next`.\n   if (currentBranch === 'master') {\n     return [deploymentInfoPerTarget.next];\n-  } else if (currentBranch === stableBranch) {\n+  }\n+\n+  // Determine if there is an active RC version by checking whether the most recent minor branch is\n+  // the stable branch or not.\n+  const mostRecentMinorBranch = getMostRecentMinorBranch();\n+  const rcBranch = (mostRecentMinorBranch !== stableBranch) ? mostRecentMinorBranch : null;\n+\n+  // If the current branch is the RC branch, deploy as `rc`.\n+  if (currentBranch === rcBranch) {\n+    return [deploymentInfoPerTarget.rc];\n+  }\n+\n+  // If the current branch is the stable branch, deploy as `stable`.\n+  if (currentBranch === stableBranch) {\n     return [deploymentInfoPerTarget.stable];\n-  } else {\n-    const stableBranchMajorVersion = computeMajorVersion(stableBranch);\n-\n-    // Find the branch that has highest minor version for the given `currentBranchMajorVersion`.\n-    const mostRecentMinorVersionBranch =\n-      // List the branches that start with the major version.\n-      getRemoteRefs(`refs/heads/${currentBranchMajorVersion}.*.x`)\n-          // Extract the version number.\n-          .map(line => line.split('/')[2])\n-          // Sort by the minor version.\n-          .sort((a, b) => a.split('.')[1] - b.split('.')[1])\n-          // Get the highest version.\n-          .pop();\n-\n-    // Do not deploy if it is not the latest branch for the given major version.\n-    // NOTE: At this point, we know the current branch is not the stable branch.\n-    if (currentBranch !== mostRecentMinorVersionBranch) {\n-      return [\n-        skipDeployment(\n-            `Skipping deploy of branch \"${currentBranch}\" to Firebase.\\n` +\n-            'There is a more recent branch with the same major version: ' +\n-            `\"${mostRecentMinorVersionBranch}\"`),\n-      ];\n-    }\n+  }\n+\n+  // If we get here, it means that the current branch is neither `master`, nor the RC or stable\n+  // branches. At this point, we may only deploy as `archive` and only if the following criteria are\n+  // met:\n+  //   1. The current branch must have the highest minor version among all branches with the same\n+  //      major version.\n+  //   2. The current branch must have a major version that is lower than the stable major version.\n+\n+  // Do not deploy if it is not the branch with the highest minor for the given major version.\n+  const mostRecentMinorBranchForMajor = getMostRecentMinorBranch(currentBranchMajorVersion);\n+  if (currentBranch !== mostRecentMinorBranchForMajor) {\n+    return [\n+      skipDeployment(\n+          `Skipping deploy of branch \"${currentBranch}\" to Firebase.\\n` +\n+          'There is a more recent branch with the same major version: ' +\n+          `\"${mostRecentMinorBranchForMajor}\"`),\n+    ];\n+  }\n \n-    return (currentBranchMajorVersion < stableBranchMajorVersion) ?\n-        // This is the latest minor version for a major that is less than the stable major version:\n-        // Deploy as `archive`.\n-        [deploymentInfoPerTarget.archive] :\n-        // This is the latest minor version for a major that is equal or greater than the stable\n-        // major version, but not the stable version itself:\n-        // Deploy as `rc`.\n-        [deploymentInfoPerTarget.rc];\n+  // Do not deploy if it does not have a lower major version than stable.\n+  const stableBranchMajorVersion = computeMajorVersion(stableBranch);\n+  if (currentBranchMajorVersion >= stableBranchMajorVersion) {\n+    return [\n+      skipDeployment(\n+          `Skipping deploy of branch \"${currentBranch}\" to Firebase.\\n` +\n+          'This branch has an equal or higher major version than the stable branch ' +\n+          `(\"${stableBranch}\") and is not the most recent minor branch.`),\n+    ];\n   }\n \n-  // We should never get here.\n-  throw new Error('Failed to determine deployment info.');\n+  // This is the highest minor version for a major that is lower than the stable major version:\n+  // Deploy as `archive`.\n+  return [deploymentInfoPerTarget.archive];\n }\n \n function computeInputVars({\n@@ -230,6 +242,23 @@ function getRemoteRefs(refOrPattern, remote = NG_REMOTE_URL) {\n   return exec(`git ls-remote ${remote} ${refOrPattern}`, {silent: true}).trim().split('\\n');\n }\n \n+function getMostRecentMinorBranch(major = '*') {\n+  // List the branches that start with the given major version (or any major if none given).\n+  return getRemoteRefs(`refs/heads/${major}.*.x`)\n+      // Extract the branch name.\n+      .map(line => line.split('/')[2])\n+      // Filter out branches that are not of the format `<number>.<number>.x`.\n+      .filter(name => /^\\d+\\.\\d+\\.x$/.test(name))\n+      // Sort by version.\n+      .sort((a, b) => {\n+        const [majorA, minorA] = a.split('.');\n+        const [majorB, minorB] = b.split('.');\n+        return (majorA - majorB) || (minorA - minorB);\n+      })\n+      // Get the branch corresponding to the highest version.\n+      .pop();\n+}\n+\n function getLatestCommit(branchName, remote = undefined) {\n   return getRemoteRefs(branchName, remote)[0].slice(0, 40);\n }"
        },
        {
            "sha": "f65b28bc50092530efd3a76c2306cbfb64b66fb8",
            "filename": "aio/scripts/deploy-to-firebase.spec.js",
            "status": "modified",
            "additions": 42,
            "deletions": 9,
            "changes": 51,
            "blob_url": "https://github.com/angular/angular/blob/1e39e493fb321913a748039d152b10c7a80e53fa/aio%2Fscripts%2Fdeploy-to-firebase.spec.js",
            "raw_url": "https://github.com/angular/angular/raw/1e39e493fb321913a748039d152b10c7a80e53fa/aio%2Fscripts%2Fdeploy-to-firebase.spec.js",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fscripts%2Fdeploy-to-firebase.spec.js?ref=1e39e493fb321913a748039d152b10c7a80e53fa",
            "patch": "@@ -2,18 +2,25 @@\n 'use strict';\n \n const {execSync} = require('child_process');\n-const {computeDeploymentsInfo, computeInputVars, getLatestCommit} = require('./deploy-to-firebase');\n+const {\n+  computeDeploymentsInfo,\n+  computeInputVars,\n+  getLatestCommit,\n+  getMostRecentMinorBranch,\n+} = require('./deploy-to-firebase');\n \n \n describe('deploy-to-firebase:', () => {\n-  // Pre-computed latest commits to avoid unnecessary re-computations.\n+  // Pre-computed values to avoid unnecessary re-computations.\n+  const mostRecentMinorBranch = getMostRecentMinorBranch();\n   const latestCommits = {\n     master: getLatestCommit('master'),\n     '2.1.x': getLatestCommit('2.1.x'),\n     '2.4.x': getLatestCommit('2.4.x'),\n     '4.3.x': getLatestCommit('4.3.x'),\n     '4.4.x': getLatestCommit('4.4.x'),\n     '9.1.x': getLatestCommit('9.1.x'),\n+    [mostRecentMinorBranch]: getLatestCommit(mostRecentMinorBranch),\n   };\n \n   // Helpers\n@@ -236,9 +243,9 @@ describe('deploy-to-firebase:', () => {\n       CI_REPO_OWNER: 'angular',\n       CI_REPO_NAME: 'angular',\n       CI_PULL_REQUEST: 'false',\n-      CI_BRANCH: '4.4.x',\n+      CI_BRANCH: mostRecentMinorBranch,\n       CI_STABLE_BRANCH: '2.2.x',\n-      CI_COMMIT: latestCommits['4.4.x'],\n+      CI_COMMIT: latestCommits[mostRecentMinorBranch],\n     })).toEqual([\n       {\n         deployEnv: 'rc',\n@@ -252,13 +259,20 @@ describe('deploy-to-firebase:', () => {\n   });\n \n   it('rc - deploy success - major same as stable, minor higher', () => {\n+    // Create a stable branch name that has the same major and lower minor than\n+    // `mostRecentMinorBranch`.\n+    // NOTE: Since `mostRecentMinorBranch` can have a minor version of `0`, we may end up with `-1`\n+    //       as the minor version for stable. This is a hack, but it works ¯\\_(ツ)_/¯\n+    const stableBranch = mostRecentMinorBranch.replace(\n+        /^(\\d+)\\.(\\d+)\\.x$/, (_, major, minor) => `${major}.${minor - 1}.x`);\n+\n     expect(getDeploymentsInfoFor({\n       CI_REPO_OWNER: 'angular',\n       CI_REPO_NAME: 'angular',\n       CI_PULL_REQUEST: 'false',\n-      CI_BRANCH: '2.4.x',\n-      CI_STABLE_BRANCH: '2.2.x',\n-      CI_COMMIT: latestCommits['2.4.x'],\n+      CI_BRANCH: mostRecentMinorBranch,\n+      CI_STABLE_BRANCH: stableBranch,\n+      CI_COMMIT: latestCommits[mostRecentMinorBranch],\n     })).toEqual([\n       {\n         deployEnv: 'rc',\n@@ -276,15 +290,15 @@ describe('deploy-to-firebase:', () => {\n       CI_REPO_OWNER: 'angular',\n       CI_REPO_NAME: 'angular',\n       CI_PULL_REQUEST: 'false',\n-      CI_BRANCH: '2.4.x',\n+      CI_BRANCH: mostRecentMinorBranch,\n       CI_STABLE_BRANCH: '2.2.x',\n       CI_COMMIT: 'DUMMY_TEST_COMMIT',\n     })).toEqual([\n       {\n         skipped: true,\n         reason:\n             'Skipping deploy because DUMMY_TEST_COMMIT is not the latest commit ' +\n-            `(${latestCommits['2.4.x']}).`,\n+            `(${latestCommits[mostRecentMinorBranch]}).`,\n       },\n     ]);\n   });\n@@ -325,6 +339,25 @@ describe('deploy-to-firebase:', () => {\n     ]);\n   });\n \n+  it('rc - skip deploy - major higher than stable but lower than most recent, minor latest', () => {\n+    expect(getDeploymentsInfoFor({\n+      CI_REPO_OWNER: 'angular',\n+      CI_REPO_NAME: 'angular',\n+      CI_PULL_REQUEST: 'false',\n+      CI_BRANCH: '4.4.x',\n+      CI_STABLE_BRANCH: '2.4.x',\n+      CI_COMMIT: latestCommits['4.4.x'],\n+    })).toEqual([\n+      {\n+        skipped: true,\n+        reason:\n+            'Skipping deploy of branch \"4.4.x\" to Firebase.\\n' +\n+            'This branch has an equal or higher major version than the stable branch (\"2.4.x\") ' +\n+            'and is not the most recent minor branch.',\n+      },\n+    ]);\n+  });\n+\n   it('integration - should run the main script without error', () => {\n     const cmd = `\"${process.execPath}\" \"${__dirname}/deploy-to-firebase\" --dry-run`;\n     const env = {"
        }
    ],
    "stats": {
        "total": 150,
        "additions": 106,
        "deletions": 44
    }
}