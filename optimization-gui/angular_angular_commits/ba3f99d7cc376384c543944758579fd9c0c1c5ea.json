{
    "author": "petebacondarwin",
    "message": "fix(compiler): support multiple `:host-context()` selectors (#40494)\n\nIn `ViewEncapsulation.Emulated` mode, the compiler must generate additional\ncombinations of selectors to handle the `:host-context()` pseudo-class function.\n\nPreviously, when there is was more than one `:host-context()` selector in a\nrule, the compiler was generating invalid selectors.\n\nThis commit generates all possible combinations of selectors needed to\nmatch the same elements as the native `:host-context()` selector.\n\nFixes #19199\n\nPR Close #40494",
    "sha": "ba3f99d7cc376384c543944758579fd9c0c1c5ea",
    "files": [
        {
            "sha": "0ca0858a254158fa64308728959c2280f68c002a",
            "filename": "packages/compiler/src/shadow_css.ts",
            "status": "modified",
            "additions": 93,
            "deletions": 34,
            "changes": 127,
            "blob_url": "https://github.com/angular/angular/blob/ba3f99d7cc376384c543944758579fd9c0c1c5ea/packages%2Fcompiler%2Fsrc%2Fshadow_css.ts",
            "raw_url": "https://github.com/angular/angular/raw/ba3f99d7cc376384c543944758579fd9c0c1c5ea/packages%2Fcompiler%2Fsrc%2Fshadow_css.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fshadow_css.ts?ref=ba3f99d7cc376384c543944758579fd9c0c1c5ea",
            "patch": "@@ -260,15 +260,29 @@ export class ShadowCss {\n    * .foo<scopeName> > .bar\n    */\n   private _convertColonHost(cssText: string): string {\n-    return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);\n+    return cssText.replace(_cssColonHostRe, (_, hostSelectors: string, otherSelectors: string) => {\n+      if (hostSelectors) {\n+        const convertedSelectors: string[] = [];\n+        const hostSelectorArray = hostSelectors.split(',').map(p => p.trim());\n+        for (const hostSelector of hostSelectorArray) {\n+          if (!hostSelector) break;\n+          const convertedSelector =\n+              _polyfillHostNoCombinator + hostSelector.replace(_polyfillHost, '') + otherSelectors;\n+          convertedSelectors.push(convertedSelector);\n+        }\n+        return convertedSelectors.join(',');\n+      } else {\n+        return _polyfillHostNoCombinator + otherSelectors;\n+      }\n+    });\n   }\n \n   /*\n    * convert a rule like :host-context(.foo) > .bar { }\n    *\n    * to\n    *\n-   * .foo<scopeName> > .bar, .foo scopeName > .bar { }\n+   * .foo<scopeName> > .bar, .foo <scopeName> > .bar { }\n    *\n    * and\n    *\n@@ -279,38 +293,29 @@ export class ShadowCss {\n    * .foo<scopeName> .bar { ... }\n    */\n   private _convertColonHostContext(cssText: string): string {\n-    return this._convertColonRule(\n-        cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);\n-  }\n-\n-  private _convertColonRule(cssText: string, regExp: RegExp, partReplacer: Function): string {\n-    // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule\n-    return cssText.replace(regExp, function(...m: string[]) {\n-      if (m[2]) {\n-        const parts = m[2].split(',');\n-        const r: string[] = [];\n-        for (let i = 0; i < parts.length; i++) {\n-          const p = parts[i].trim();\n-          if (!p) break;\n-          r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));\n+    return cssText.replace(_cssColonHostContextReGlobal, selectorText => {\n+      // We have captured a selector that contains a `:host-context` rule.\n+      // There may be more than one so `selectorText` could look like:\n+      // `:host-context(.one):host-context(.two)`.\n+\n+      const contextSelectors: string[] = [];\n+      let match: RegExpMatchArray|null;\n+\n+      // Execute `_cssColonHostContextRe` over and over until we have extracted all the\n+      // `:host-context` selectors from this selector.\n+      while (match = _cssColonHostContextRe.exec(selectorText)) {\n+        // `match` = [':host-context(<selectors>)<rest>', <selectors>, <rest>]\n+        const contextSelector = (match[1] ?? '').trim();\n+        if (contextSelector !== '') {\n+          contextSelectors.push(contextSelector);\n         }\n-        return r.join(',');\n-      } else {\n-        return _polyfillHostNoCombinator + m[3];\n+        selectorText = match[2];\n       }\n-    });\n-  }\n \n-  private _colonHostContextPartReplacer(host: string, part: string, suffix: string): string {\n-    if (part.indexOf(_polyfillHost) > -1) {\n-      return this._colonHostPartReplacer(host, part, suffix);\n-    } else {\n-      return host + part + suffix + ', ' + part + ' ' + host + suffix;\n-    }\n-  }\n-\n-  private _colonHostPartReplacer(host: string, part: string, suffix: string): string {\n-    return host + part.replace(_polyfillHost, '') + suffix;\n+      // The context selectors now must be combined with each other to capture all the possible\n+      // selectors that `:host-context` can match.\n+      return combineHostContextSelectors(_polyfillHostNoCombinator, contextSelectors, selectorText);\n+    });\n   }\n \n   /*\n@@ -534,11 +539,12 @@ const _cssContentUnscopedRuleRe =\n const _polyfillHost = '-shadowcsshost';\n // note: :host-context pre-processed to -shadowcsshostcontext.\n const _polyfillHostContext = '-shadowcsscontext';\n-const _parenSuffix = ')(?:\\\\((' +\n+const _parenSuffix = '(?:\\\\((' +\n     '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n     ')\\\\))?([^,{]*)';\n-const _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');\n-const _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');\n+const _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix, 'gim');\n+const _cssColonHostContextReGlobal = new RegExp(_polyfillHostContext + _parenSuffix, 'gim');\n+const _cssColonHostContextRe = new RegExp(_polyfillHostContext + _parenSuffix, 'im');\n const _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\n const _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\n const _shadowDOMSelectorsRe = [\n@@ -650,3 +656,56 @@ function escapeBlocks(\n   }\n   return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n }\n+\n+/**\n+ * Combine the `contextSelectors` with the `hostMarker` and the `otherSelectors`\n+ * to create a selector that matches the same as `:host-context()`.\n+ *\n+ * Given a single context selector `A` we need to output selectors that match on the host and as an\n+ * ancestor of the host:\n+ *\n+ * ```\n+ * A <hostMarker>, A<hostMarker> {}\n+ * ```\n+ *\n+ * When there is more than one context selector we also have to create combinations of those\n+ * selectors with each other. For example if there are `A` and `B` selectors the output is:\n+ *\n+ * ```\n+ * AB<hostMarker>, AB <hostMarker>, A B<hostMarker>,\n+ * B A<hostMarker>, A B <hostMarker>, B A <hostMarker> {}\n+ * ```\n+ *\n+ * And so on...\n+ *\n+ * @param hostMarker the string that selects the host element.\n+ * @param contextSelectors an array of context selectors that will be combined.\n+ * @param otherSelectors the rest of the selectors that are not context selectors.\n+ */\n+function combineHostContextSelectors(\n+    hostMarker: string, contextSelectors: string[], otherSelectors: string): string {\n+  // If there are no context selectors then just output a host marker\n+  if (contextSelectors.length === 0) {\n+    return hostMarker + otherSelectors;\n+  }\n+\n+  const combined: string[] = [contextSelectors.pop() || ''];\n+  while (contextSelectors.length > 0) {\n+    const length = combined.length;\n+    const contextSelector = contextSelectors.pop();\n+    for (let i = 0; i < length; i++) {\n+      const previousSelectors = combined[i];\n+      // Add the new selector as a descendant of the previous selectors\n+      combined[length * 2 + i] = previousSelectors + ' ' + contextSelector;\n+      // Add the new selector as an ancestor of the previous selectors\n+      combined[length + i] = contextSelector + ' ' + previousSelectors;\n+      // Add the new selector to act on the same element as the previous selectors\n+      combined[i] = contextSelector + previousSelectors;\n+    }\n+  }\n+  // Finally connect the selector to the `hostMarker`s: either acting directly on the host\n+  // (A<hostMarker>) or as an ancestor (A <hostMarker>).\n+  return combined\n+      .map(s => `${s}${hostMarker}${otherSelectors}, ${s} ${hostMarker}${otherSelectors}`)\n+      .join(',');\n+}"
        },
        {
            "sha": "f652706ec365a30a41dd8288a4d86b006c8bd8a0",
            "filename": "packages/compiler/test/shadow_css_spec.ts",
            "status": "modified",
            "additions": 50,
            "deletions": 0,
            "changes": 50,
            "blob_url": "https://github.com/angular/angular/blob/ba3f99d7cc376384c543944758579fd9c0c1c5ea/packages%2Fcompiler%2Ftest%2Fshadow_css_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/ba3f99d7cc376384c543944758579fd9c0c1c5ea/packages%2Fcompiler%2Ftest%2Fshadow_css_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fshadow_css_spec.ts?ref=ba3f99d7cc376384c543944758579fd9c0c1c5ea",
            "patch": "@@ -145,6 +145,10 @@ import {normalizeCSS} from '@angular/platform-browser/testing/src/browser_util';\n             .toEqual('ul[a-host] > .z[contenta], li[a-host] > .z[contenta] {}');\n       });\n \n+      it('should handle compound class selectors', () => {\n+        expect(s(':host(.a.b) {}', 'contenta', 'a-host')).toEqual('.a.b[a-host] {}');\n+      });\n+\n       it('should handle multiple class selectors', () => {\n         expect(s(':host(.x,.y) {}', 'contenta', 'a-host')).toEqual('.x[a-host], .y[a-host] {}');\n         expect(s(':host(.x,.y) > .z {}', 'contenta', 'a-host'))\n@@ -208,6 +212,52 @@ import {normalizeCSS} from '@angular/platform-browser/testing/src/browser_util';\n         expect(s(':host-context([a=b]) {}', 'contenta', 'a-host'))\n             .toEqual('[a=b][a-host], [a=\"b\"] [a-host] {}');\n       });\n+\n+      it('should handle multiple :host-context() selectors', () => {\n+        expect(s(':host-context(.one):host-context(.two) {}', 'contenta', 'a-host'))\n+            .toEqual(\n+                '.one.two[a-host], ' +    // `one` and `two` both on the host\n+                '.one.two [a-host], ' +   // `one` and `two` are both on the same ancestor\n+                '.one .two[a-host], ' +   // `one` is an ancestor and `two` is on the host\n+                '.one .two [a-host], ' +  // `one` and `two` are both ancestors (in that order)\n+                '.two .one[a-host], ' +   // `two` is an ancestor and `one` is on the host\n+                '.two .one [a-host]' +    // `two` and `one` are both ancestors (in that order)\n+                ' {}');\n+\n+        expect(s(':host-context(.X):host-context(.Y):host-context(.Z) {}', 'contenta', 'a-host')\n+                   .replace(/ \\{\\}$/, '')\n+                   .split(/\\,\\s+/))\n+            .toEqual([\n+              '.X.Y.Z[a-host]',\n+              '.X.Y.Z [a-host]',\n+              '.X.Y .Z[a-host]',\n+              '.X.Y .Z [a-host]',\n+              '.X.Z .Y[a-host]',\n+              '.X.Z .Y [a-host]',\n+              '.X .Y.Z[a-host]',\n+              '.X .Y.Z [a-host]',\n+              '.X .Y .Z[a-host]',\n+              '.X .Y .Z [a-host]',\n+              '.X .Z .Y[a-host]',\n+              '.X .Z .Y [a-host]',\n+              '.Y.Z .X[a-host]',\n+              '.Y.Z .X [a-host]',\n+              '.Y .Z .X[a-host]',\n+              '.Y .Z .X [a-host]',\n+              '.Z .Y .X[a-host]',\n+              '.Z .Y .X [a-host]',\n+            ]);\n+      });\n+\n+      // This test is checking backward compatibility.\n+      // It is not clear what the behaviour should be for a `:host-context` with no selectors.\n+      // Arguably it is actually an error that should be reported.\n+      it('should handle :host-context with no ancestor selectors', () => {\n+        expect(s('.outer :host-context .inner {}', 'contenta', 'a-host'))\n+            .toEqual('.outer [a-host] .inner[contenta] {}');\n+        expect(s('.outer :host-context() .inner {}', 'contenta', 'a-host'))\n+            .toEqual('.outer [a-host] .inner[contenta] {}');\n+      });\n     });\n \n     it('should support polyfill-next-selector', () => {"
        }
    ],
    "stats": {
        "total": 177,
        "additions": 143,
        "deletions": 34
    }
}