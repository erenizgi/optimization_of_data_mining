{
    "author": "JiaLiPassion",
    "message": "refactor(core): remove unused fakeAsyncFallback and asyncFallback (#37879)\n\n`zone.js` 0.8.25 introduces `zone-testing` bundle and move all `fakeAsync/async` logic\nfrom `@angular/core/testing` to `zone.js` package. But in case some user still using the old\nversion of `zone.js`, an old version of `fakeAsync/async` logic were still kept inside `@angular/core/testing`\npackage as `fallback` logic. Since now `Angular8+` already use `zone.js 0.9+`, so\nthose fallback logic is removed.\n\nPR Close #37879",
    "sha": "1cba56e11fc647a424aecfe4ab3213dbf9ad00d2",
    "files": [
        {
            "sha": "cce0a843093e2ab5fa71469664e5dedd1c46c309",
            "filename": "packages/core/test/render3/BUILD.bazel",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fcore%2Ftest%2Frender3%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fcore%2Ftest%2Frender3%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2FBUILD.bazel?ref=1cba56e11fc647a424aecfe4ab3213dbf9ad00d2",
            "patch": "@@ -76,7 +76,10 @@ ts_library(\n \n jasmine_node_test(\n     name = \"render3\",\n-    bootstrap = [\":domino_es5\"],\n+    bootstrap = [\n+        \":domino_es5\",\n+        \"//tools/testing:node_es5\",\n+    ],\n     deps = [\n         \":render3_node_lib\",\n         \"//packages/zone.js/lib\","
        },
        {
            "sha": "190f2e52d5b5595f0055005e2ab64e84b1b9bc83",
            "filename": "packages/core/test/render3/ivy/BUILD.bazel",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fcore%2Ftest%2Frender3%2Fivy%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fcore%2Ftest%2Frender3%2Fivy%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Fivy%2FBUILD.bazel?ref=1cba56e11fc647a424aecfe4ab3213dbf9ad00d2",
            "patch": "@@ -16,7 +16,10 @@ ts_library(\n \n jasmine_node_test(\n     name = \"ivy\",\n-    bootstrap = [\"//packages/core/test/render3:domino_es5\"],\n+    bootstrap = [\n+        \"//packages/core/test/render3:domino_es5\",\n+        \"//tools/testing:node_es5\",\n+    ],\n     tags = [\n         \"ivy-only\",\n     ],"
        },
        {
            "sha": "7a53b9a7dd5cf0ba7c970316ee81f8023e55cb81",
            "filename": "packages/core/test/render3/load_domino.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fcore%2Ftest%2Frender3%2Fload_domino.ts",
            "raw_url": "https://github.com/angular/angular/raw/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fcore%2Ftest%2Frender3%2Fload_domino.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Fload_domino.ts?ref=1cba56e11fc647a424aecfe4ab3213dbf9ad00d2",
            "patch": "@@ -7,7 +7,6 @@\n  */\n \n // Needed to run animation tests\n-import 'zone.js/lib/node/rollup-main';\n import '@angular/compiler'; // For JIT mode. Must be in front of any other @angular/* imports.\n import {ÉµgetDOM as getDOM} from '@angular/common';\n import {DominoAdapter} from '@angular/platform-server/src/domino_adapter';"
        },
        {
            "sha": "a3ff66b3e22a7c86dc51c6b5f7ad58f374e5b72a",
            "filename": "packages/core/testing/src/async.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 7,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fcore%2Ftesting%2Fsrc%2Fasync.ts",
            "raw_url": "https://github.com/angular/angular/raw/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fcore%2Ftesting%2Fsrc%2Fasync.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftesting%2Fsrc%2Fasync.ts?ref=1cba56e11fc647a424aecfe4ab3213dbf9ad00d2",
            "patch": "@@ -5,9 +5,6 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-\n-import {asyncFallback} from './async_fallback';\n-\n /**\n  * Wraps a test function in an asynchronous test zone. The test will automatically\n  * complete when all asynchronous calls within this zone are done. Can be used\n@@ -38,10 +35,11 @@ export function waitForAsync(fn: Function): (done: any) => any {\n   if (typeof asyncTest === 'function') {\n     return asyncTest(fn);\n   }\n-  // not using new version of zone.js\n-  // TODO @JiaLiPassion, remove this after all library updated to\n-  // newest version of zone.js(0.8.25)\n-  return asyncFallback(fn);\n+  return function() {\n+    return Promise.reject(\n+        'zone-testing.js is needed for the async() test helper but could not be found. ' +\n+        'Please make sure that your environment includes zone.js/dist/zone-testing.js');\n+  };\n }\n \n /**"
        },
        {
            "sha": "10d3b47f78edff58348f6292204571da7e0d4b0d",
            "filename": "packages/core/testing/src/async_fallback.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 118,
            "changes": 118,
            "blob_url": "https://github.com/angular/angular/blob/66d863febebaa0ae772af1b2db343486232ad23c/packages%2Fcore%2Ftesting%2Fsrc%2Fasync_fallback.ts",
            "raw_url": "https://github.com/angular/angular/raw/66d863febebaa0ae772af1b2db343486232ad23c/packages%2Fcore%2Ftesting%2Fsrc%2Fasync_fallback.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftesting%2Fsrc%2Fasync_fallback.ts?ref=66d863febebaa0ae772af1b2db343486232ad23c",
            "patch": "@@ -1,118 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-/**\n- * async has been moved to zone.js\n- * this file is for fallback in case old version of zone.js is used\n- */\n-declare var global: any;\n-\n-const _global = <any>(typeof window === 'undefined' ? global : window);\n-\n-/**\n- * Wraps a test function in an asynchronous test zone. The test will automatically\n- * complete when all asynchronous calls within this zone are done. Can be used\n- * to wrap an {@link inject} call.\n- *\n- * Example:\n- *\n- * ```\n- * it('...', async(inject([AClass], (object) => {\n- *   object.doSomething.then(() => {\n- *     expect(...);\n- *   })\n- * });\n- * ```\n- *\n- *\n- */\n-export function asyncFallback(fn: Function): (done: any) => any {\n-  // If we're running using the Jasmine test framework, adapt to call the 'done'\n-  // function when asynchronous activity is finished.\n-  if (_global.jasmine) {\n-    // Not using an arrow function to preserve context passed from call site\n-    return function(this: unknown, done: any) {\n-      if (!done) {\n-        // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n-        // fake it here and assume sync.\n-        done = function() {};\n-        done.fail = function(e: any) {\n-          throw e;\n-        };\n-      }\n-      runInTestZone(fn, this, done, (err: any) => {\n-        if (typeof err === 'string') {\n-          return done.fail(new Error(err));\n-        } else {\n-          done.fail(err);\n-        }\n-      });\n-    };\n-  }\n-  // Otherwise, return a promise which will resolve when asynchronous activity\n-  // is finished. This will be correctly consumed by the Mocha framework with\n-  // it('...', async(myFn)); or can be used in a custom framework.\n-  // Not using an arrow function to preserve context passed from call site\n-  return function(this: unknown) {\n-    return new Promise<void>((finishCallback, failCallback) => {\n-      runInTestZone(fn, this, finishCallback, failCallback);\n-    });\n-  };\n-}\n-\n-function runInTestZone(\n-    fn: Function, context: any, finishCallback: Function, failCallback: Function) {\n-  const currentZone = Zone.current;\n-  const AsyncTestZoneSpec = (Zone as any)['AsyncTestZoneSpec'];\n-  if (AsyncTestZoneSpec === undefined) {\n-    throw new Error(\n-        'AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n-        'Please make sure that your environment includes zone.js/dist/async-test.js');\n-  }\n-  const ProxyZoneSpec = (Zone as any)['ProxyZoneSpec'] as {\n-    get(): {setDelegate(spec: ZoneSpec): void; getDelegate(): ZoneSpec;};\n-    assertPresent: () => void;\n-  };\n-  if (ProxyZoneSpec === undefined) {\n-    throw new Error(\n-        'ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n-        'Please make sure that your environment includes zone.js/dist/proxy.js');\n-  }\n-  const proxyZoneSpec = ProxyZoneSpec.get();\n-  ProxyZoneSpec.assertPresent();\n-  // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n-  // If we do it in ProxyZone then we will get to infinite recursion.\n-  const proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n-  const previousDelegate = proxyZoneSpec.getDelegate();\n-  proxyZone!.parent!.run(() => {\n-    const testZoneSpec: ZoneSpec = new AsyncTestZoneSpec(\n-        () => {\n-          // Need to restore the original zone.\n-          currentZone.run(() => {\n-            if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n-              // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n-              proxyZoneSpec.setDelegate(previousDelegate);\n-            }\n-            finishCallback();\n-          });\n-        },\n-        (error: any) => {\n-          // Need to restore the original zone.\n-          currentZone.run(() => {\n-            if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n-              // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n-              proxyZoneSpec.setDelegate(previousDelegate);\n-            }\n-            failCallback(error);\n-          });\n-        },\n-        'test');\n-    proxyZoneSpec.setDelegate(testZoneSpec);\n-  });\n-  return Zone.current.runGuarded(fn, context);\n-}"
        },
        {
            "sha": "1885f5418f0e6c446cdfc92e7a788df74f4c3876",
            "filename": "packages/core/testing/src/fake_async.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 14,
            "changes": 24,
            "blob_url": "https://github.com/angular/angular/blob/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fcore%2Ftesting%2Fsrc%2Ffake_async.ts",
            "raw_url": "https://github.com/angular/angular/raw/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fcore%2Ftesting%2Fsrc%2Ffake_async.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftesting%2Fsrc%2Ffake_async.ts?ref=1cba56e11fc647a424aecfe4ab3213dbf9ad00d2",
            "patch": "@@ -5,11 +5,13 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {discardPeriodicTasksFallback, fakeAsyncFallback, flushFallback, flushMicrotasksFallback, resetFakeAsyncZoneFallback, tickFallback} from './fake_async_fallback';\n-\n const _Zone: any = typeof Zone !== 'undefined' ? Zone : null;\n const fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\n \n+const fakeAsyncTestModuleNotLoadedErrorMessage =\n+    `zone-testing.js is needed for the async() test helper but could not be found.\n+        Please make sure that your environment includes zone.js/dist/zone-testing.js`;\n+\n /**\n  * Clears out the shared fake async zone for a test.\n  * To be called in a global `beforeEach`.\n@@ -19,9 +21,8 @@ const fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\n export function resetFakeAsyncZone(): void {\n   if (fakeAsyncTestModule) {\n     return fakeAsyncTestModule.resetFakeAsyncZone();\n-  } else {\n-    return resetFakeAsyncZoneFallback();\n   }\n+  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n }\n \n /**\n@@ -46,9 +47,8 @@ export function resetFakeAsyncZone(): void {\n export function fakeAsync(fn: Function): (...args: any[]) => any {\n   if (fakeAsyncTestModule) {\n     return fakeAsyncTestModule.fakeAsync(fn);\n-  } else {\n-    return fakeAsyncFallback(fn);\n   }\n+  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n }\n \n /**\n@@ -108,9 +108,8 @@ export function tick(\n     }): void {\n   if (fakeAsyncTestModule) {\n     return fakeAsyncTestModule.tick(millis, tickOptions);\n-  } else {\n-    return tickFallback(millis, tickOptions);\n   }\n+  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n }\n \n /**\n@@ -126,9 +125,8 @@ export function tick(\n export function flush(maxTurns?: number): number {\n   if (fakeAsyncTestModule) {\n     return fakeAsyncTestModule.flush(maxTurns);\n-  } else {\n-    return flushFallback(maxTurns);\n   }\n+  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n }\n \n /**\n@@ -139,9 +137,8 @@ export function flush(maxTurns?: number): number {\n export function discardPeriodicTasks(): void {\n   if (fakeAsyncTestModule) {\n     return fakeAsyncTestModule.discardPeriodicTasks();\n-  } else {\n-    discardPeriodicTasksFallback();\n   }\n+  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n }\n \n /**\n@@ -152,7 +149,6 @@ export function discardPeriodicTasks(): void {\n export function flushMicrotasks(): void {\n   if (fakeAsyncTestModule) {\n     return fakeAsyncTestModule.flushMicrotasks();\n-  } else {\n-    return flushMicrotasksFallback();\n   }\n+  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n }"
        },
        {
            "sha": "6026708ecebbbe7188e43324be12070a61cd917c",
            "filename": "packages/core/testing/src/fake_async_fallback.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 163,
            "changes": 163,
            "blob_url": "https://github.com/angular/angular/blob/66d863febebaa0ae772af1b2db343486232ad23c/packages%2Fcore%2Ftesting%2Fsrc%2Ffake_async_fallback.ts",
            "raw_url": "https://github.com/angular/angular/raw/66d863febebaa0ae772af1b2db343486232ad23c/packages%2Fcore%2Ftesting%2Fsrc%2Ffake_async_fallback.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftesting%2Fsrc%2Ffake_async_fallback.ts?ref=66d863febebaa0ae772af1b2db343486232ad23c",
            "patch": "@@ -1,163 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-/**\n- * fakeAsync has been moved to zone.js\n- * this file is for fallback in case old version of zone.js is used\n- */\n-const _Zone: any = typeof Zone !== 'undefined' ? Zone : null;\n-const FakeAsyncTestZoneSpec = _Zone && _Zone['FakeAsyncTestZoneSpec'];\n-type ProxyZoneSpec = {\n-  setDelegate(delegateSpec: ZoneSpec): void; getDelegate(): ZoneSpec; resetDelegate(): void;\n-};\n-const ProxyZoneSpec: {get(): ProxyZoneSpec; assertPresent: () => ProxyZoneSpec} =\n-    _Zone && _Zone['ProxyZoneSpec'];\n-\n-let _fakeAsyncTestZoneSpec: any = null;\n-\n-/**\n- * Clears out the shared fake async zone for a test.\n- * To be called in a global `beforeEach`.\n- *\n- * @publicApi\n- */\n-export function resetFakeAsyncZoneFallback() {\n-  if (_fakeAsyncTestZoneSpec) {\n-    _fakeAsyncTestZoneSpec.unlockDatePatch();\n-  }\n-  _fakeAsyncTestZoneSpec = null;\n-  // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n-  ProxyZoneSpec && ProxyZoneSpec.assertPresent().resetDelegate();\n-}\n-\n-let _inFakeAsyncCall = false;\n-\n-/**\n- * Wraps a function to be executed in the fakeAsync zone:\n- * - microtasks are manually executed by calling `flushMicrotasks()`,\n- * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n- *\n- * If there are any pending timers at the end of the function, an exception will be thrown.\n- *\n- * Can be used to wrap inject() calls.\n- *\n- * @usageNotes\n- * ### Example\n- *\n- * {@example core/testing/ts/fake_async.ts region='basic'}\n- *\n- * @param fn\n- * @returns The function wrapped to be executed in the fakeAsync zone\n- *\n- * @publicApi\n- */\n-export function fakeAsyncFallback(fn: Function): (...args: any[]) => any {\n-  // Not using an arrow function to preserve context passed from call site\n-  return function(this: unknown, ...args: any[]) {\n-    const proxyZoneSpec = ProxyZoneSpec.assertPresent();\n-    if (_inFakeAsyncCall) {\n-      throw new Error('fakeAsync() calls can not be nested');\n-    }\n-    _inFakeAsyncCall = true;\n-    try {\n-      if (!_fakeAsyncTestZoneSpec) {\n-        if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n-          throw new Error('fakeAsync() calls can not be nested');\n-        }\n-\n-        _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n-      }\n-\n-      let res: any;\n-      const lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n-      proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n-      _fakeAsyncTestZoneSpec.lockDatePatch();\n-      try {\n-        res = fn.apply(this, args);\n-        flushMicrotasksFallback();\n-      } finally {\n-        proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n-      }\n-\n-      if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n-        throw new Error(\n-            `${_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length} ` +\n-            `periodic timer(s) still in the queue.`);\n-      }\n-\n-      if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n-        throw new Error(\n-            `${_fakeAsyncTestZoneSpec.pendingTimers.length} timer(s) still in the queue.`);\n-      }\n-      return res;\n-    } finally {\n-      _inFakeAsyncCall = false;\n-      resetFakeAsyncZoneFallback();\n-    }\n-  };\n-}\n-\n-function _getFakeAsyncZoneSpec(): any {\n-  if (_fakeAsyncTestZoneSpec == null) {\n-    throw new Error('The code should be running in the fakeAsync zone to call this function');\n-  }\n-  return _fakeAsyncTestZoneSpec;\n-}\n-\n-/**\n- * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n- *\n- * The microtasks queue is drained at the very start of this function and after any timer callback\n- * has been executed.\n- *\n- * @usageNotes\n- * ### Example\n- *\n- * {@example core/testing/ts/fake_async.ts region='basic'}\n- *\n- * @publicApi\n- */\n-export function tickFallback(\n-    millis: number = 0, tickOptions: {processNewMacroTasksSynchronously: boolean} = {\n-      processNewMacroTasksSynchronously: true\n-    }): void {\n-  _getFakeAsyncZoneSpec().tick(millis, null, tickOptions);\n-}\n-\n-/**\n- * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n- * draining the macrotask queue until it is empty. The returned value is the milliseconds\n- * of time that would have been elapsed.\n- *\n- * @param maxTurns\n- * @returns The simulated time elapsed, in millis.\n- *\n- * @publicApi\n- */\n-export function flushFallback(maxTurns?: number): number {\n-  return _getFakeAsyncZoneSpec().flush(maxTurns);\n-}\n-\n-/**\n- * Discard all remaining periodic tasks.\n- *\n- * @publicApi\n- */\n-export function discardPeriodicTasksFallback(): void {\n-  const zoneSpec = _getFakeAsyncZoneSpec();\n-  zoneSpec.pendingPeriodicTimers.length = 0;\n-}\n-\n-/**\n- * Flush any pending microtasks.\n- *\n- * @publicApi\n- */\n-export function flushMicrotasksFallback(): void {\n-  _getFakeAsyncZoneSpec().flushMicrotasks();\n-}"
        },
        {
            "sha": "ac804808cdd92742a69be6bed497b88edb6444e3",
            "filename": "packages/zone.js/lib/testing/async-testing.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 97,
            "changes": 97,
            "blob_url": "https://github.com/angular/angular/blob/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fzone.js%2Flib%2Ftesting%2Fasync-testing.ts",
            "raw_url": "https://github.com/angular/angular/raw/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fzone.js%2Flib%2Ftesting%2Fasync-testing.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fzone.js%2Flib%2Ftesting%2Fasync-testing.ts?ref=1cba56e11fc647a424aecfe4ab3213dbf9ad00d2",
            "patch": "@@ -6,100 +6,3 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n import '../zone-spec/async-test';\n-\n-Zone.__load_patch('asynctest', (global: any, Zone: ZoneType, api: _ZonePrivate) => {\n-  /**\n-   * Wraps a test function in an asynchronous test zone. The test will automatically\n-   * complete when all asynchronous calls within this zone are done.\n-   */\n-  (Zone as any)[api.symbol('asyncTest')] = function asyncTest(fn: Function): (done: any) => any {\n-    // If we're running using the Jasmine test framework, adapt to call the 'done'\n-    // function when asynchronous activity is finished.\n-    if (global.jasmine) {\n-      // Not using an arrow function to preserve context passed from call site\n-      return function(this: unknown, done: any) {\n-        if (!done) {\n-          // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n-          // fake it here and assume sync.\n-          done = function() {};\n-          done.fail = function(e: any) {\n-            throw e;\n-          };\n-        }\n-        runInTestZone(fn, this, done, (err: any) => {\n-          if (typeof err === 'string') {\n-            return done.fail(new Error(err));\n-          } else {\n-            done.fail(err);\n-          }\n-        });\n-      };\n-    }\n-    // Otherwise, return a promise which will resolve when asynchronous activity\n-    // is finished. This will be correctly consumed by the Mocha framework with\n-    // it('...', async(myFn)); or can be used in a custom framework.\n-    // Not using an arrow function to preserve context passed from call site\n-    return function(this: unknown) {\n-      return new Promise<void>((finishCallback, failCallback) => {\n-        runInTestZone(fn, this, finishCallback, failCallback);\n-      });\n-    };\n-  };\n-\n-  function runInTestZone(\n-      fn: Function, context: any, finishCallback: Function, failCallback: Function) {\n-    const currentZone = Zone.current;\n-    const AsyncTestZoneSpec = (Zone as any)['AsyncTestZoneSpec'];\n-    if (AsyncTestZoneSpec === undefined) {\n-      throw new Error(\n-          'AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n-          'Please make sure that your environment includes zone.js/dist/async-test.js');\n-    }\n-    const ProxyZoneSpec = (Zone as any)['ProxyZoneSpec'] as {\n-      get(): {setDelegate(spec: ZoneSpec): void; getDelegate(): ZoneSpec;};\n-      assertPresent: () => void;\n-    };\n-    if (ProxyZoneSpec === undefined) {\n-      throw new Error(\n-          'ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n-          'Please make sure that your environment includes zone.js/dist/proxy.js');\n-    }\n-    const proxyZoneSpec = ProxyZoneSpec.get();\n-    ProxyZoneSpec.assertPresent();\n-    // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n-    // If we do it in ProxyZone then we will get to infinite recursion.\n-    const proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n-    const previousDelegate = proxyZoneSpec.getDelegate();\n-    proxyZone!.parent!.run(() => {\n-      const testZoneSpec: ZoneSpec = new AsyncTestZoneSpec(\n-          () => {\n-            // Need to restore the original zone.\n-            if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n-              // Only reset the zone spec if it's\n-              // sill this one. Otherwise, assume\n-              // it's OK.\n-              proxyZoneSpec.setDelegate(previousDelegate);\n-            }\n-            (testZoneSpec as any).unPatchPromiseForTest();\n-            currentZone.run(() => {\n-              finishCallback();\n-            });\n-          },\n-          (error: any) => {\n-            // Need to restore the original zone.\n-            if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n-              // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n-              proxyZoneSpec.setDelegate(previousDelegate);\n-            }\n-            (testZoneSpec as any).unPatchPromiseForTest();\n-            currentZone.run(() => {\n-              failCallback(error);\n-            });\n-          },\n-          'test');\n-      proxyZoneSpec.setDelegate(testZoneSpec);\n-      (testZoneSpec as any).patchPromiseForTest();\n-    });\n-    return Zone.current.runGuarded(fn, context);\n-  }\n-});"
        },
        {
            "sha": "acd661e8524df242ed2e7858a5ad8b8b229bb9d1",
            "filename": "packages/zone.js/lib/testing/fake-async.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 153,
            "changes": 153,
            "blob_url": "https://github.com/angular/angular/blob/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fzone.js%2Flib%2Ftesting%2Ffake-async.ts",
            "raw_url": "https://github.com/angular/angular/raw/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fzone.js%2Flib%2Ftesting%2Ffake-async.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fzone.js%2Flib%2Ftesting%2Ffake-async.ts?ref=1cba56e11fc647a424aecfe4ab3213dbf9ad00d2",
            "patch": "@@ -6,156 +6,3 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n import '../zone-spec/fake-async-test';\n-\n-Zone.__load_patch('fakeasync', (global: any, Zone: ZoneType, api: _ZonePrivate) => {\n-  const FakeAsyncTestZoneSpec = Zone && (Zone as any)['FakeAsyncTestZoneSpec'];\n-  type ProxyZoneSpec = {\n-    setDelegate(delegateSpec: ZoneSpec): void; getDelegate(): ZoneSpec; resetDelegate(): void;\n-  };\n-  const ProxyZoneSpec: {get(): ProxyZoneSpec; assertPresent: () => ProxyZoneSpec} =\n-      Zone && (Zone as any)['ProxyZoneSpec'];\n-\n-  let _fakeAsyncTestZoneSpec: any = null;\n-\n-  /**\n-   * Clears out the shared fake async zone for a test.\n-   * To be called in a global `beforeEach`.\n-   *\n-   * @experimental\n-   */\n-  function resetFakeAsyncZone() {\n-    if (_fakeAsyncTestZoneSpec) {\n-      _fakeAsyncTestZoneSpec.unlockDatePatch();\n-    }\n-    _fakeAsyncTestZoneSpec = null;\n-    // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n-    ProxyZoneSpec && ProxyZoneSpec.assertPresent().resetDelegate();\n-  }\n-\n-  /**\n-   * Wraps a function to be executed in the fakeAsync zone:\n-   * - microtasks are manually executed by calling `flushMicrotasks()`,\n-   * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n-   *\n-   * If there are any pending timers at the end of the function, an exception will be thrown.\n-   *\n-   * Can be used to wrap inject() calls.\n-   *\n-   * ## Example\n-   *\n-   * {@example core/testing/ts/fake_async.ts region='basic'}\n-   *\n-   * @param fn\n-   * @returns The function wrapped to be executed in the fakeAsync zone\n-   *\n-   * @experimental\n-   */\n-  function fakeAsync(fn: Function): (...args: any[]) => any {\n-    // Not using an arrow function to preserve context passed from call site\n-    const fakeAsyncFn: any = function(this: unknown, ...args: any[]) {\n-      const proxyZoneSpec = ProxyZoneSpec.assertPresent();\n-      if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n-        throw new Error('fakeAsync() calls can not be nested');\n-      }\n-      try {\n-        // in case jasmine.clock init a fakeAsyncTestZoneSpec\n-        if (!_fakeAsyncTestZoneSpec) {\n-          if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n-            throw new Error('fakeAsync() calls can not be nested');\n-          }\n-\n-          _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n-        }\n-\n-        let res: any;\n-        const lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n-        proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n-        _fakeAsyncTestZoneSpec.lockDatePatch();\n-        try {\n-          res = fn.apply(this, args);\n-          flushMicrotasks();\n-        } finally {\n-          proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n-        }\n-\n-        if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n-          throw new Error(\n-              `${_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length} ` +\n-              `periodic timer(s) still in the queue.`);\n-        }\n-\n-        if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n-          throw new Error(\n-              `${_fakeAsyncTestZoneSpec.pendingTimers.length} timer(s) still in the queue.`);\n-        }\n-        return res;\n-      } finally {\n-        resetFakeAsyncZone();\n-      }\n-    };\n-    (fakeAsyncFn as any).isFakeAsync = true;\n-    return fakeAsyncFn;\n-  }\n-\n-  function _getFakeAsyncZoneSpec(): any {\n-    if (_fakeAsyncTestZoneSpec == null) {\n-      _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n-      if (_fakeAsyncTestZoneSpec == null) {\n-        throw new Error('The code should be running in the fakeAsync zone to call this function');\n-      }\n-    }\n-    return _fakeAsyncTestZoneSpec;\n-  }\n-\n-  /**\n-   * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n-   *\n-   * The microtasks queue is drained at the very start of this function and after any timer callback\n-   * has been executed.\n-   *\n-   * ## Example\n-   *\n-   * {@example core/testing/ts/fake_async.ts region='basic'}\n-   *\n-   * @experimental\n-   */\n-  function tick(millis: number = 0, ignoreNestedTimeout = false): void {\n-    _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n-  }\n-\n-  /**\n-   * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n-   * draining the macrotask queue until it is empty. The returned value is the milliseconds\n-   * of time that would have been elapsed.\n-   *\n-   * @param maxTurns\n-   * @returns The simulated time elapsed, in millis.\n-   *\n-   * @experimental\n-   */\n-  function flush(maxTurns?: number): number {\n-    return _getFakeAsyncZoneSpec().flush(maxTurns);\n-  }\n-\n-  /**\n-   * Discard all remaining periodic tasks.\n-   *\n-   * @experimental\n-   */\n-  function discardPeriodicTasks(): void {\n-    const zoneSpec = _getFakeAsyncZoneSpec();\n-    const pendingTimers = zoneSpec.pendingPeriodicTimers;\n-    zoneSpec.pendingPeriodicTimers.length = 0;\n-  }\n-\n-  /**\n-   * Flush any pending microtasks.\n-   *\n-   * @experimental\n-   */\n-  function flushMicrotasks(): void {\n-    _getFakeAsyncZoneSpec().flushMicrotasks();\n-  }\n-  (Zone as any)[api.symbol('fakeAsyncTest')] =\n-      {resetFakeAsyncZone, flushMicrotasks, discardPeriodicTasks, tick, flush, fakeAsync};\n-});"
        },
        {
            "sha": "11cfeac7ae38c9a74be98ab5538b432667e14d85",
            "filename": "packages/zone.js/lib/zone-spec/async-test.ts",
            "status": "modified",
            "additions": 97,
            "deletions": 0,
            "changes": 97,
            "blob_url": "https://github.com/angular/angular/blob/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fzone.js%2Flib%2Fzone-spec%2Fasync-test.ts",
            "raw_url": "https://github.com/angular/angular/raw/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fzone.js%2Flib%2Fzone-spec%2Fasync-test.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fzone.js%2Flib%2Fzone-spec%2Fasync-test.ts?ref=1cba56e11fc647a424aecfe4ab3213dbf9ad00d2",
            "patch": "@@ -147,3 +147,100 @@ class AsyncTestZoneSpec implements ZoneSpec {\n // constructor params.\n (Zone as any)['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n })(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n+\n+Zone.__load_patch('asynctest', (global: any, Zone: ZoneType, api: _ZonePrivate) => {\n+  /**\n+   * Wraps a test function in an asynchronous test zone. The test will automatically\n+   * complete when all asynchronous calls within this zone are done.\n+   */\n+  (Zone as any)[api.symbol('asyncTest')] = function asyncTest(fn: Function): (done: any) => any {\n+    // If we're running using the Jasmine test framework, adapt to call the 'done'\n+    // function when asynchronous activity is finished.\n+    if (global.jasmine) {\n+      // Not using an arrow function to preserve context passed from call site\n+      return function(this: unknown, done: any) {\n+        if (!done) {\n+          // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n+          // fake it here and assume sync.\n+          done = function() {};\n+          done.fail = function(e: any) {\n+            throw e;\n+          };\n+        }\n+        runInTestZone(fn, this, done, (err: any) => {\n+          if (typeof err === 'string') {\n+            return done.fail(new Error(err));\n+          } else {\n+            done.fail(err);\n+          }\n+        });\n+      };\n+    }\n+    // Otherwise, return a promise which will resolve when asynchronous activity\n+    // is finished. This will be correctly consumed by the Mocha framework with\n+    // it('...', async(myFn)); or can be used in a custom framework.\n+    // Not using an arrow function to preserve context passed from call site\n+    return function(this: unknown) {\n+      return new Promise<void>((finishCallback, failCallback) => {\n+        runInTestZone(fn, this, finishCallback, failCallback);\n+      });\n+    };\n+  };\n+\n+  function runInTestZone(\n+      fn: Function, context: any, finishCallback: Function, failCallback: Function) {\n+    const currentZone = Zone.current;\n+    const AsyncTestZoneSpec = (Zone as any)['AsyncTestZoneSpec'];\n+    if (AsyncTestZoneSpec === undefined) {\n+      throw new Error(\n+          'AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n+          'Please make sure that your environment includes zone.js/dist/async-test.js');\n+    }\n+    const ProxyZoneSpec = (Zone as any)['ProxyZoneSpec'] as {\n+      get(): {setDelegate(spec: ZoneSpec): void; getDelegate(): ZoneSpec;};\n+      assertPresent: () => void;\n+    };\n+    if (!ProxyZoneSpec) {\n+      throw new Error(\n+          'ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n+          'Please make sure that your environment includes zone.js/dist/proxy.js');\n+    }\n+    const proxyZoneSpec = ProxyZoneSpec.get();\n+    ProxyZoneSpec.assertPresent();\n+    // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n+    // If we do it in ProxyZone then we will get to infinite recursion.\n+    const proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n+    const previousDelegate = proxyZoneSpec.getDelegate();\n+    proxyZone!.parent!.run(() => {\n+      const testZoneSpec: ZoneSpec = new AsyncTestZoneSpec(\n+          () => {\n+            // Need to restore the original zone.\n+            if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n+              // Only reset the zone spec if it's\n+              // sill this one. Otherwise, assume\n+              // it's OK.\n+              proxyZoneSpec.setDelegate(previousDelegate);\n+            }\n+            (testZoneSpec as any).unPatchPromiseForTest();\n+            currentZone.run(() => {\n+              finishCallback();\n+            });\n+          },\n+          (error: any) => {\n+            // Need to restore the original zone.\n+            if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n+              // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n+              proxyZoneSpec.setDelegate(previousDelegate);\n+            }\n+            (testZoneSpec as any).unPatchPromiseForTest();\n+            currentZone.run(() => {\n+              failCallback(error);\n+            });\n+          },\n+          'test');\n+      proxyZoneSpec.setDelegate(testZoneSpec);\n+      (testZoneSpec as any).patchPromiseForTest();\n+    });\n+    return Zone.current.runGuarded(fn, context);\n+  }\n+});"
        },
        {
            "sha": "0872189674d95512bbeb1de37d32f415bfb9c691",
            "filename": "packages/zone.js/lib/zone-spec/fake-async-test.ts",
            "status": "modified",
            "additions": 161,
            "deletions": 0,
            "changes": 161,
            "blob_url": "https://github.com/angular/angular/blob/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fzone.js%2Flib%2Fzone-spec%2Ffake-async-test.ts",
            "raw_url": "https://github.com/angular/angular/raw/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fzone.js%2Flib%2Fzone-spec%2Ffake-async-test.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fzone.js%2Flib%2Fzone-spec%2Ffake-async-test.ts?ref=1cba56e11fc647a424aecfe4ab3213dbf9ad00d2",
            "patch": "@@ -703,3 +703,164 @@ class FakeAsyncTestZoneSpec implements ZoneSpec {\n // constructor params.\n (Zone as any)['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n+\n+Zone.__load_patch('fakeasync', (global: any, Zone: ZoneType, api: _ZonePrivate) => {\n+  const FakeAsyncTestZoneSpec = Zone && (Zone as any)['FakeAsyncTestZoneSpec'];\n+  type ProxyZoneSpecType = {\n+    setDelegate(delegateSpec: ZoneSpec): void; getDelegate(): ZoneSpec; resetDelegate(): void;\n+  };\n+\n+  function getProxyZoneSpec(): {get(): ProxyZoneSpecType; assertPresent: () => ProxyZoneSpecType} {\n+    return Zone && (Zone as any)['ProxyZoneSpec'];\n+  }\n+\n+  let _fakeAsyncTestZoneSpec: any = null;\n+\n+  /**\n+   * Clears out the shared fake async zone for a test.\n+   * To be called in a global `beforeEach`.\n+   *\n+   * @experimental\n+   */\n+  function resetFakeAsyncZone() {\n+    if (_fakeAsyncTestZoneSpec) {\n+      _fakeAsyncTestZoneSpec.unlockDatePatch();\n+    }\n+    _fakeAsyncTestZoneSpec = null;\n+    // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n+    getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();\n+  }\n+\n+  /**\n+   * Wraps a function to be executed in the fakeAsync zone:\n+   * - microtasks are manually executed by calling `flushMicrotasks()`,\n+   * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n+   *\n+   * If there are any pending timers at the end of the function, an exception will be thrown.\n+   *\n+   * Can be used to wrap inject() calls.\n+   *\n+   * ## Example\n+   *\n+   * {@example core/testing/ts/fake_async.ts region='basic'}\n+   *\n+   * @param fn\n+   * @returns The function wrapped to be executed in the fakeAsync zone\n+   *\n+   * @experimental\n+   */\n+  function fakeAsync(fn: Function): (...args: any[]) => any {\n+    // Not using an arrow function to preserve context passed from call site\n+    const fakeAsyncFn: any = function(this: unknown, ...args: any[]) {\n+      const ProxyZoneSpec = getProxyZoneSpec();\n+      if (!ProxyZoneSpec) {\n+        throw new Error(\n+            'ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n+            'Please make sure that your environment includes zone.js/dist/proxy.js');\n+      }\n+      const proxyZoneSpec = ProxyZoneSpec.assertPresent();\n+      if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n+        throw new Error('fakeAsync() calls can not be nested');\n+      }\n+      try {\n+        // in case jasmine.clock init a fakeAsyncTestZoneSpec\n+        if (!_fakeAsyncTestZoneSpec) {\n+          if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n+            throw new Error('fakeAsync() calls can not be nested');\n+          }\n+\n+          _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n+        }\n+\n+        let res: any;\n+        const lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n+        proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n+        _fakeAsyncTestZoneSpec.lockDatePatch();\n+        try {\n+          res = fn.apply(this, args);\n+          flushMicrotasks();\n+        } finally {\n+          proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n+        }\n+\n+        if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n+          throw new Error(\n+              `${_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length} ` +\n+              `periodic timer(s) still in the queue.`);\n+        }\n+\n+        if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n+          throw new Error(\n+              `${_fakeAsyncTestZoneSpec.pendingTimers.length} timer(s) still in the queue.`);\n+        }\n+        return res;\n+      } finally {\n+        resetFakeAsyncZone();\n+      }\n+    };\n+    (fakeAsyncFn as any).isFakeAsync = true;\n+    return fakeAsyncFn;\n+  }\n+\n+  function _getFakeAsyncZoneSpec(): any {\n+    if (_fakeAsyncTestZoneSpec == null) {\n+      _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n+      if (_fakeAsyncTestZoneSpec == null) {\n+        throw new Error('The code should be running in the fakeAsync zone to call this function');\n+      }\n+    }\n+    return _fakeAsyncTestZoneSpec;\n+  }\n+\n+  /**\n+   * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n+   *\n+   * The microtasks queue is drained at the very start of this function and after any timer callback\n+   * has been executed.\n+   *\n+   * ## Example\n+   *\n+   * {@example core/testing/ts/fake_async.ts region='basic'}\n+   *\n+   * @experimental\n+   */\n+  function tick(millis: number = 0, ignoreNestedTimeout = false): void {\n+    _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n+  }\n+\n+  /**\n+   * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n+   * draining the macrotask queue until it is empty. The returned value is the milliseconds\n+   * of time that would have been elapsed.\n+   *\n+   * @param maxTurns\n+   * @returns The simulated time elapsed, in millis.\n+   *\n+   * @experimental\n+   */\n+  function flush(maxTurns?: number): number {\n+    return _getFakeAsyncZoneSpec().flush(maxTurns);\n+  }\n+\n+  /**\n+   * Discard all remaining periodic tasks.\n+   *\n+   * @experimental\n+   */\n+  function discardPeriodicTasks(): void {\n+    const zoneSpec = _getFakeAsyncZoneSpec();\n+    const pendingTimers = zoneSpec.pendingPeriodicTimers;\n+    zoneSpec.pendingPeriodicTimers.length = 0;\n+  }\n+\n+  /**\n+   * Flush any pending microtasks.\n+   *\n+   * @experimental\n+   */\n+  function flushMicrotasks(): void {\n+    _getFakeAsyncZoneSpec().flushMicrotasks();\n+  }\n+  (Zone as any)[api.symbol('fakeAsyncTest')] =\n+      {resetFakeAsyncZone, flushMicrotasks, discardPeriodicTasks, tick, flush, fakeAsync};\n+}, true);"
        },
        {
            "sha": "92bd2f2bbf7db3cd63c3ff3dcc2c86a5ee0b53c4",
            "filename": "packages/zone.js/lib/zone.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fzone.js%2Flib%2Fzone.ts",
            "raw_url": "https://github.com/angular/angular/raw/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/packages%2Fzone.js%2Flib%2Fzone.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fzone.js%2Flib%2Fzone.ts?ref=1cba56e11fc647a424aecfe4ab3213dbf9ad00d2",
            "patch": "@@ -313,7 +313,7 @@ interface ZoneType {\n    * load patch for specified native module, allow user to\n    * define their own patch, user can use this API after loading zone.js\n    */\n-  __load_patch(name: string, fn: _PatchFn): void;\n+  __load_patch(name: string, fn: _PatchFn, ignoreDuplicate?: boolean): void;\n \n   /**\n    * Zone symbol API to generate a string with __zone_symbol__ prefix\n@@ -745,9 +745,12 @@ const Zone: ZoneType = (function(global: any) {\n     }\n \n     // tslint:disable-next-line:require-internal-with-underscore\n-    static __load_patch(name: string, fn: _PatchFn): void {\n+    static __load_patch(name: string, fn: _PatchFn, ignoreDuplicate = false): void {\n       if (patches.hasOwnProperty(name)) {\n-        if (checkDuplicate) {\n+        // `checkDuplicate` option is defined from global variable\n+        // so it works for all modules.\n+        // `ignoreDuplicate` can work for the specified module\n+        if (!ignoreDuplicate && checkDuplicate) {\n           throw Error('Already loaded patch: ' + name);\n         }\n       } else if (!global['__Zone_disable_' + name]) {"
        },
        {
            "sha": "f78cf3a9aa1f528b018e075150373e145699a666",
            "filename": "tools/testing/init_node_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/tools%2Ftesting%2Finit_node_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/1cba56e11fc647a424aecfe4ab3213dbf9ad00d2/tools%2Ftesting%2Finit_node_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/tools%2Ftesting%2Finit_node_spec.ts?ref=1cba56e11fc647a424aecfe4ab3213dbf9ad00d2",
            "patch": "@@ -11,8 +11,8 @@ import 'zone.js/lib/zone-spec/long-stack-trace';\n import 'zone.js/lib/zone-spec/task-tracking';\n import 'zone.js/lib/zone-spec/proxy';\n import 'zone.js/lib/zone-spec/sync-test';\n-import 'zone.js/lib/zone-spec/async-test';\n-import 'zone.js/lib/zone-spec/fake-async-test';\n+import 'zone.js/lib/testing/async-testing';\n+import 'zone.js/lib/testing/fake-async';\n import 'reflect-metadata/Reflect';\n \n // Initialize jasmine with @bazel/jasmine boot() function. This will initialize"
        }
    ],
    "stats": {
        "total": 849,
        "additions": 289,
        "deletions": 560
    }
}