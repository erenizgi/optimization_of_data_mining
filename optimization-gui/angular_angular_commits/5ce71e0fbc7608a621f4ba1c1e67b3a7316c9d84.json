{
    "author": "crisbeto",
    "message": "feat(core): add automated migration to replace async with waitForAsync (#39212)\n\nAdds a migration that finds all imports and calls to the deprecated `async` function from\n`@angular/core/testing` and replaces them with `waitForAsync`.\n\nThese changes also move a bit of code out of the `Renderer2` migration so that it can be reused.\n\nPR Close #39212",
    "sha": "5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84",
    "files": [
        {
            "sha": "2817d90c8be60252d02bc91f62d832b98d84949a",
            "filename": "packages/core/schematics/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2FBUILD.bazel?ref=5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84",
            "patch": "@@ -23,5 +23,6 @@ pkg_npm(\n         \"//packages/core/schematics/migrations/template-var-assignment\",\n         \"//packages/core/schematics/migrations/undecorated-classes-with-decorated-fields\",\n         \"//packages/core/schematics/migrations/undecorated-classes-with-di\",\n+        \"//packages/core/schematics/migrations/wait-for-async\",\n     ],\n )"
        },
        {
            "sha": "60c47e1e6aad5a65e0402299bd42f23f9823fcd5",
            "filename": "packages/core/schematics/migrations.json",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations.json",
            "raw_url": "https://github.com/angular/angular/raw/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations.json?ref=5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84",
            "patch": "@@ -64,6 +64,11 @@\n       \"version\": \"11.0.0-beta\",\n       \"description\": \"ViewEncapsulation.Native has been removed as of Angular version 11. This migration replaces any usages with ViewEncapsulation.ShadowDom.\",\n       \"factory\": \"./migrations/native-view-encapsulation/index\"\n+    },\n+    \"migration-v11-wait-for-async\": {\n+      \"version\": \"11.0.0-beta\",\n+      \"description\": \"`async` to `waitForAsync` migration. The `async` testing function has been renamed to `waitForAsync` to avoid confusion with the native `async` keyword.\",\n+      \"factory\": \"./migrations/wait-for-async/index\"\n     }\n   }\n }"
        },
        {
            "sha": "651de6e76e6036e40b6724bfaf38c83b52a74c94",
            "filename": "packages/core/schematics/migrations/google3/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FBUILD.bazel?ref=5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84",
            "patch": "@@ -17,6 +17,7 @@ ts_library(\n         \"//packages/core/schematics/migrations/template-var-assignment\",\n         \"//packages/core/schematics/migrations/undecorated-classes-with-decorated-fields\",\n         \"//packages/core/schematics/migrations/undecorated-classes-with-decorated-fields/google3\",\n+        \"//packages/core/schematics/migrations/wait-for-async\",\n         \"//packages/core/schematics/utils\",\n         \"//packages/core/schematics/utils/tslint\",\n         \"@npm//tslint\","
        },
        {
            "sha": "0155066eb79f7ce12c9d264b6a54c5fc3ec38160",
            "filename": "packages/core/schematics/migrations/google3/rendererToRenderer2Rule.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FrendererToRenderer2Rule.ts",
            "raw_url": "https://github.com/angular/angular/raw/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FrendererToRenderer2Rule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FrendererToRenderer2Rule.ts?ref=5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84",
            "patch": "@@ -8,11 +8,12 @@\n \n import {Replacement, RuleFailure, Rules} from 'tslint';\n import * as ts from 'typescript';\n-import {getImportSpecifier} from '../../utils/typescript/imports';\n \n+import {getImportSpecifier, replaceImport} from '../../utils/typescript/imports';\n+import {closestNode} from '../../utils/typescript/nodes';\n import {getHelper, HelperFunction} from '../renderer-to-renderer2/helpers';\n-import {migrateExpression, replaceImport} from '../renderer-to-renderer2/migration';\n-import {findRendererReferences, getNamedImports} from '../renderer-to-renderer2/util';\n+import {migrateExpression} from '../renderer-to-renderer2/migration';\n+import {findRendererReferences} from '../renderer-to-renderer2/util';\n \n /**\n  * TSLint rule that migrates from `Renderer` to `Renderer2`. More information on how it works:\n@@ -24,8 +25,9 @@ export class Rule extends Rules.TypedRule {\n     const printer = ts.createPrinter();\n     const failures: RuleFailure[] = [];\n     const rendererImportSpecifier = getImportSpecifier(sourceFile, '@angular/core', 'Renderer');\n-    const rendererImport =\n-        rendererImportSpecifier ? getNamedImports(rendererImportSpecifier) : null;\n+    const rendererImport = rendererImportSpecifier ?\n+        closestNode<ts.NamedImports>(rendererImportSpecifier, ts.SyntaxKind.NamedImports) :\n+        null;\n \n     // If there are no imports for the `Renderer`, we can exit early.\n     if (!rendererImportSpecifier || !rendererImport) {\n@@ -36,8 +38,7 @@ export class Rule extends Rules.TypedRule {\n         findRendererReferences(sourceFile, typeChecker, rendererImportSpecifier);\n     const helpersToAdd = new Set<HelperFunction>();\n \n-    failures.push(\n-        this._getNamedImportsFailure(rendererImport, rendererImportSpecifier, sourceFile, printer));\n+    failures.push(this._getNamedImportsFailure(rendererImport, sourceFile, printer));\n     typedNodes.forEach(node => failures.push(this._getTypedNodeFailure(node, sourceFile)));\n     forwardRefs.forEach(node => failures.push(this._getIdentifierNodeFailure(node, sourceFile)));\n \n@@ -65,10 +66,9 @@ export class Rule extends Rules.TypedRule {\n \n   /** Gets a failure for an import of the Renderer. */\n   private _getNamedImportsFailure(\n-      node: ts.NamedImports, importSpecifier: ts.ImportSpecifier, sourceFile: ts.SourceFile,\n-      printer: ts.Printer): RuleFailure {\n+      node: ts.NamedImports, sourceFile: ts.SourceFile, printer: ts.Printer): RuleFailure {\n     const replacementText = printer.printNode(\n-        ts.EmitHint.Unspecified, replaceImport(node, importSpecifier, 'Renderer2'), sourceFile);\n+        ts.EmitHint.Unspecified, replaceImport(node, 'Renderer', 'Renderer2'), sourceFile);\n \n     return new RuleFailure(\n         sourceFile, node.getStart(), node.getEnd(),"
        },
        {
            "sha": "44f374d60d10894fe35fad48dac731055dcae40d",
            "filename": "packages/core/schematics/migrations/google3/waitForAsyncRule.ts",
            "status": "added",
            "additions": 65,
            "deletions": 0,
            "changes": 65,
            "blob_url": "https://github.com/angular/angular/blob/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FwaitForAsyncRule.ts",
            "raw_url": "https://github.com/angular/angular/raw/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FwaitForAsyncRule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FwaitForAsyncRule.ts?ref=5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84",
            "patch": "@@ -0,0 +1,65 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {Replacement, RuleFailure, Rules} from 'tslint';\n+import * as ts from 'typescript';\n+\n+import {findAsyncReferences} from '../../migrations/wait-for-async/util';\n+import {getImportSpecifier, replaceImport} from '../../utils/typescript/imports';\n+import {closestNode} from '../../utils/typescript/nodes';\n+\n+/** Name of the deprecated function that we're removing. */\n+const deprecatedFunction = 'async';\n+\n+/** Name of the function that will replace the deprecated one. */\n+const newFunction = 'waitForAsync';\n+\n+/** TSLint rule that migrates from `async` to `waitForAsync`. */\n+export class Rule extends Rules.TypedRule {\n+  applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): RuleFailure[] {\n+    const failures: RuleFailure[] = [];\n+    const asyncImportSpecifier =\n+        getImportSpecifier(sourceFile, '@angular/core/testing', deprecatedFunction);\n+    const asyncImport = asyncImportSpecifier ?\n+        closestNode<ts.NamedImports>(asyncImportSpecifier, ts.SyntaxKind.NamedImports) :\n+        null;\n+\n+    // If there are no imports of `async`, we can exit early.\n+    if (asyncImportSpecifier && asyncImport) {\n+      const typeChecker = program.getTypeChecker();\n+      const printer = ts.createPrinter();\n+      failures.push(this._getNamedImportsFailure(asyncImport, sourceFile, printer));\n+      findAsyncReferences(sourceFile, typeChecker, asyncImportSpecifier)\n+          .forEach(node => failures.push(this._getIdentifierNodeFailure(node, sourceFile)));\n+    }\n+\n+    return failures;\n+  }\n+\n+  /** Gets a failure for an import of the `async` function. */\n+  private _getNamedImportsFailure(\n+      node: ts.NamedImports, sourceFile: ts.SourceFile, printer: ts.Printer): RuleFailure {\n+    const replacementText = printer.printNode(\n+        ts.EmitHint.Unspecified, replaceImport(node, deprecatedFunction, newFunction), sourceFile);\n+\n+    return new RuleFailure(\n+        sourceFile, node.getStart(), node.getEnd(),\n+        `Imports of the deprecated ${deprecatedFunction} function are not allowed. Use ${\n+            newFunction} instead.`,\n+        this.ruleName, new Replacement(node.getStart(), node.getWidth(), replacementText));\n+  }\n+\n+  /** Gets a failure for an identifier node. */\n+  private _getIdentifierNodeFailure(node: ts.Identifier, sourceFile: ts.SourceFile): RuleFailure {\n+    return new RuleFailure(\n+        sourceFile, node.getStart(), node.getEnd(),\n+        `References to the deprecated ${deprecatedFunction} function are not allowed. Use ${\n+            newFunction} instead.`,\n+        this.ruleName, new Replacement(node.getStart(), node.getWidth(), newFunction));\n+  }\n+}"
        },
        {
            "sha": "79bf08a4cfb616c1a3b89bc27cf7e329db13677d",
            "filename": "packages/core/schematics/migrations/renderer-to-renderer2/index.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 7,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Findex.ts?ref=5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84",
            "patch": "@@ -12,11 +12,12 @@ import * as ts from 'typescript';\n \n import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n import {createMigrationProgram} from '../../utils/typescript/compiler_host';\n-import {getImportSpecifier} from '../../utils/typescript/imports';\n+import {getImportSpecifier, replaceImport} from '../../utils/typescript/imports';\n+import {closestNode} from '../../utils/typescript/nodes';\n \n import {getHelper, HelperFunction} from './helpers';\n-import {migrateExpression, replaceImport} from './migration';\n-import {findRendererReferences, getNamedImports} from './util';\n+import {migrateExpression} from './migration';\n+import {findRendererReferences} from './util';\n \n const MODULE_AUGMENTATION_FILENAME = 'ɵɵRENDERER_MIGRATION_CORE_AUGMENTATION.d.ts';\n \n@@ -63,8 +64,9 @@ function runRendererToRenderer2Migration(tree: Tree, tsconfigPath: string, baseP\n \n   sourceFiles.forEach(sourceFile => {\n     const rendererImportSpecifier = getImportSpecifier(sourceFile, '@angular/core', 'Renderer');\n-    const rendererImport =\n-        rendererImportSpecifier ? getNamedImports(rendererImportSpecifier) : null;\n+    const rendererImport = rendererImportSpecifier ?\n+        closestNode<ts.NamedImports>(rendererImportSpecifier, ts.SyntaxKind.NamedImports) :\n+        null;\n \n     // If there are no imports for the `Renderer`, we can exit early.\n     if (!rendererImportSpecifier || !rendererImport) {\n@@ -81,8 +83,8 @@ function runRendererToRenderer2Migration(tree: Tree, tsconfigPath: string, baseP\n     update.insertRight(\n         rendererImport.getStart(),\n         printer.printNode(\n-            ts.EmitHint.Unspecified,\n-            replaceImport(rendererImport, rendererImportSpecifier, 'Renderer2'), sourceFile));\n+            ts.EmitHint.Unspecified, replaceImport(rendererImport, 'Renderer', 'Renderer2'),\n+            sourceFile));\n \n     // Change the method parameter and property types to `Renderer2`.\n     typedNodes.forEach(node => {"
        },
        {
            "sha": "2711309f4a66290eb77b0a18f91614cbd49e57c0",
            "filename": "packages/core/schematics/migrations/renderer-to-renderer2/migration.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 21,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Fmigration.ts",
            "raw_url": "https://github.com/angular/angular/raw/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Fmigration.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Fmigration.ts?ref=5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84",
            "patch": "@@ -13,27 +13,6 @@ import {HelperFunction} from './helpers';\n /** A call expression that is based on a property access. */\n type PropertyAccessCallExpression = ts.CallExpression&{expression: ts.PropertyAccessExpression};\n \n-/** Replaces an import inside an import statement with a different one. */\n-export function replaceImport(\n-    node: ts.NamedImports, existingImport: ts.ImportSpecifier, newImportName: string) {\n-  const isAlreadyImported = node.elements.find(element => {\n-    const {name, propertyName} = element;\n-    return propertyName ? propertyName.text === newImportName : name.text === newImportName;\n-  });\n-\n-  if (isAlreadyImported) {\n-    return node;\n-  }\n-\n-  return ts.updateNamedImports(node, [\n-    ...node.elements.filter(current => current !== existingImport),\n-    // Create a new import while trying to preserve the alias of the old one.\n-    ts.createImportSpecifier(\n-        existingImport.propertyName ? ts.createIdentifier(newImportName) : undefined,\n-        existingImport.propertyName ? existingImport.name : ts.createIdentifier(newImportName))\n-  ]);\n-}\n-\n /**\n  * Migrates a function call expression from `Renderer` to `Renderer2`.\n  * Returns null if the expression should be dropped."
        },
        {
            "sha": "3987cb64d55af08eb6ac605f0bfd7f60f20ae626",
            "filename": "packages/core/schematics/migrations/renderer-to-renderer2/util.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 14,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Futil.ts?ref=5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84",
            "patch": "@@ -54,20 +54,6 @@ export function findRendererReferences(\n   return {typedNodes, methodCalls, forwardRefs};\n }\n \n-/** Gets the closest `NamedImports` to an `ImportSpecifier`. */\n-export function getNamedImports(specifier: ts.ImportSpecifier): ts.NamedImports|null {\n-  let current: ts.Node = specifier;\n-\n-  while (current && !ts.isSourceFile(current)) {\n-    if (ts.isNamedImports(current)) {\n-      return current;\n-    }\n-    current = current.parent;\n-  }\n-\n-  return null;\n-}\n-\n /** Finds the identifier referring to the `Renderer` inside a `forwardRef` call expression. */\n function findRendererIdentifierInForwardRef(\n     typeChecker: ts.TypeChecker, node: ts.CallExpression,"
        },
        {
            "sha": "18cf7800c80ef9c6d107d428b2898e0671792e16",
            "filename": "packages/core/schematics/migrations/wait-for-async/BUILD.bazel",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2FBUILD.bazel?ref=5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84",
            "patch": "@@ -0,0 +1,18 @@\n+load(\"//tools:defaults.bzl\", \"ts_library\")\n+\n+ts_library(\n+    name = \"wait-for-async\",\n+    srcs = glob([\"**/*.ts\"]),\n+    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n+    visibility = [\n+        \"//packages/core/schematics:__pkg__\",\n+        \"//packages/core/schematics/migrations/google3:__pkg__\",\n+        \"//packages/core/schematics/test:__pkg__\",\n+    ],\n+    deps = [\n+        \"//packages/core/schematics/utils\",\n+        \"@npm//@angular-devkit/schematics\",\n+        \"@npm//@types/node\",\n+        \"@npm//typescript\",\n+    ],\n+)"
        },
        {
            "sha": "468fb934966a6503483a4b2cf2c7272700210606",
            "filename": "packages/core/schematics/migrations/wait-for-async/README.md",
            "status": "added",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2FREADME.md?ref=5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84",
            "patch": "@@ -0,0 +1,21 @@\n+## async -> waitForAsync migration\n+\n+Automatically migrates from `async` to `waitForAsync` by changing function calls and renaming imports.\n+\n+#### Before\n+```ts\n+import { async } from '@angular/core/testing';\n+\n+it('should work', async(() => {\n+  // async testing logic\n+}));\n+```\n+\n+#### After\n+```ts\n+import { waitForAsync } from '@angular/core/testing';\n+\n+it('should work', waitForAsync(() => {\n+  // async testing logic\n+}));\n+```"
        },
        {
            "sha": "28254c5f7af1e8d3fba6821c0fc5de8e2ec3635c",
            "filename": "packages/core/schematics/migrations/wait-for-async/index.ts",
            "status": "added",
            "additions": 92,
            "deletions": 0,
            "changes": 92,
            "blob_url": "https://github.com/angular/angular/blob/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2Findex.ts?ref=5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84",
            "patch": "@@ -0,0 +1,92 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\n+import {relative} from 'path';\n+import * as ts from 'typescript';\n+\n+import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n+import {createMigrationProgram} from '../../utils/typescript/compiler_host';\n+import {getImportSpecifier, replaceImport} from '../../utils/typescript/imports';\n+import {closestNode} from '../../utils/typescript/nodes';\n+\n+import {findAsyncReferences} from './util';\n+\n+const MODULE_AUGMENTATION_FILENAME = 'ɵɵASYNC_MIGRATION_CORE_AUGMENTATION.d.ts';\n+\n+/** Migration that switches from `async` to `waitForAsync`. */\n+export default function(): Rule {\n+  return (tree: Tree) => {\n+    const {buildPaths, testPaths} = getProjectTsConfigPaths(tree);\n+    const basePath = process.cwd();\n+    const allPaths = [...buildPaths, ...testPaths];\n+\n+    if (!allPaths.length) {\n+      throw new SchematicsException(\n+          'Could not find any tsconfig file. Cannot migrate async usages to waitForAsync.');\n+    }\n+\n+    for (const tsconfigPath of allPaths) {\n+      runWaitForAsyncMigration(tree, tsconfigPath, basePath);\n+    }\n+  };\n+}\n+\n+function runWaitForAsyncMigration(tree: Tree, tsconfigPath: string, basePath: string) {\n+  const {program} = createMigrationProgram(tree, tsconfigPath, basePath, fileName => {\n+    // In case the module augmentation file has been requested, we return a source file that\n+    // augments \"@angular/core/testing\" to include a named export called \"async\". This ensures that\n+    // we can rely on the type checker for this migration after `async` has been removed.\n+    if (fileName === MODULE_AUGMENTATION_FILENAME) {\n+      return `\n+        import '@angular/core/testing';\n+        declare module \"@angular/core/testing\" {\n+          function async(fn: Function): any;\n+        }\n+      `;\n+    }\n+    return null;\n+  }, [MODULE_AUGMENTATION_FILENAME]);\n+  const typeChecker = program.getTypeChecker();\n+  const printer = ts.createPrinter();\n+  const sourceFiles = program.getSourceFiles().filter(\n+      f => !f.isDeclarationFile && !program.isSourceFileFromExternalLibrary(f));\n+  const deprecatedFunction = 'async';\n+  const newFunction = 'waitForAsync';\n+\n+  sourceFiles.forEach(sourceFile => {\n+    const asyncImportSpecifier =\n+        getImportSpecifier(sourceFile, '@angular/core/testing', deprecatedFunction);\n+    const asyncImport = asyncImportSpecifier ?\n+        closestNode<ts.NamedImports>(asyncImportSpecifier, ts.SyntaxKind.NamedImports) :\n+        null;\n+\n+    // If there are no imports for `async`, we can exit early.\n+    if (!asyncImportSpecifier || !asyncImport) {\n+      return;\n+    }\n+\n+    const update = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n+\n+    // Change the `async` import to `waitForAsync`.\n+    update.remove(asyncImport.getStart(), asyncImport.getWidth());\n+    update.insertRight(\n+        asyncImport.getStart(),\n+        printer.printNode(\n+            ts.EmitHint.Unspecified, replaceImport(asyncImport, deprecatedFunction, newFunction),\n+            sourceFile));\n+\n+    // Change `async` calls to `waitForAsync`.\n+    findAsyncReferences(sourceFile, typeChecker, asyncImportSpecifier).forEach(node => {\n+      update.remove(node.getStart(), node.getWidth());\n+      update.insertRight(node.getStart(), newFunction);\n+    });\n+\n+    tree.commitUpdate(update);\n+  });\n+}"
        },
        {
            "sha": "bea02d986315c7df366ea66aa33ca5977817d4f2",
            "filename": "packages/core/schematics/migrations/wait-for-async/util.ts",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/angular/angular/blob/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2Futil.ts?ref=5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84",
            "patch": "@@ -0,0 +1,30 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as ts from 'typescript';\n+\n+import {isReferenceToImport} from '../../utils/typescript/symbol';\n+\n+/** Finds calls to the `async` function. */\n+export function findAsyncReferences(\n+    sourceFile: ts.SourceFile, typeChecker: ts.TypeChecker,\n+    asyncImportSpecifier: ts.ImportSpecifier) {\n+  const results = new Set<ts.Identifier>();\n+\n+  ts.forEachChild(sourceFile, function visitNode(node: ts.Node) {\n+    if (ts.isCallExpression(node) && ts.isIdentifier(node.expression) &&\n+        node.expression.text === 'async' &&\n+        isReferenceToImport(typeChecker, node.expression, asyncImportSpecifier)) {\n+      results.add(node.expression);\n+    }\n+\n+    ts.forEachChild(node, visitNode);\n+  });\n+\n+  return results;\n+}"
        },
        {
            "sha": "e03a2c20ffbe53329fca8692724f66917aa2bdf1",
            "filename": "packages/core/schematics/test/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel?ref=5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84",
            "patch": "@@ -21,6 +21,7 @@ ts_library(\n         \"//packages/core/schematics/migrations/template-var-assignment\",\n         \"//packages/core/schematics/migrations/undecorated-classes-with-decorated-fields\",\n         \"//packages/core/schematics/migrations/undecorated-classes-with-di\",\n+        \"//packages/core/schematics/migrations/wait-for-async\",\n         \"//packages/core/schematics/utils\",\n         \"@npm//@angular-devkit/core\",\n         \"@npm//@angular-devkit/schematics\","
        },
        {
            "sha": "d68f202988402b3299c716975a28f07434a34223",
            "filename": "packages/core/schematics/test/google3/wait_for_async_spec.ts",
            "status": "added",
            "additions": 181,
            "deletions": 0,
            "changes": 181,
            "blob_url": "https://github.com/angular/angular/blob/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fwait_for_async_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fwait_for_async_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fwait_for_async_spec.ts?ref=5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84",
            "patch": "@@ -0,0 +1,181 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {readFileSync, writeFileSync} from 'fs';\n+import {dirname, join} from 'path';\n+import * as shx from 'shelljs';\n+import {Configuration, Linter} from 'tslint';\n+\n+describe('Google3 waitForAsync TSLint rule', () => {\n+  const rulesDirectory = dirname(require.resolve('../../migrations/google3/waitForAsyncRule'));\n+\n+  let tmpDir: string;\n+\n+  beforeEach(() => {\n+    tmpDir = join(process.env['TEST_TMPDIR']!, 'google3-test');\n+    shx.mkdir('-p', tmpDir);\n+\n+    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n+    writeFile('testing.d.ts', `\n+      export declare function async(fn: Function): any;\n+    `);\n+\n+    writeFile('tsconfig.json', JSON.stringify({\n+      compilerOptions: {\n+        module: 'es2015',\n+        baseUrl: './',\n+        paths: {\n+          '@angular/core/testing': ['testing.d.ts'],\n+        }\n+      },\n+    }));\n+  });\n+\n+  afterEach(() => shx.rm('-r', tmpDir));\n+\n+  function runTSLint(fix: boolean) {\n+    const program = Linter.createProgram(join(tmpDir, 'tsconfig.json'));\n+    const linter = new Linter({fix, rulesDirectory: [rulesDirectory]}, program);\n+    const config = Configuration.parseConfigFile({rules: {'wait-for-async': true}});\n+\n+    program.getRootFileNames().forEach(fileName => {\n+      linter.lint(fileName, program.getSourceFile(fileName)!.getFullText(), config);\n+    });\n+\n+    return linter;\n+  }\n+\n+  function writeFile(fileName: string, content: string) {\n+    writeFileSync(join(tmpDir, fileName), content);\n+  }\n+\n+  function getFile(fileName: string) {\n+    return readFileSync(join(tmpDir, fileName), 'utf8');\n+  }\n+\n+  it('should flag async imports and usages', () => {\n+    writeFile('/index.ts', `\n+      import { async, inject } from '@angular/core/testing';\n+\n+      it('should work', async(() => {\n+        expect(inject('foo')).toBe('foo');\n+      }));\n+\n+      it('should also work', async(() => {\n+        expect(inject('bar')).toBe('bar');\n+      }));\n+    `);\n+\n+    const linter = runTSLint(false);\n+    const failures = linter.getResult().failures.map(failure => failure.getFailure());\n+    expect(failures.length).toBe(3);\n+    expect(failures[0]).toMatch(/Imports of the deprecated async function are not allowed/);\n+    expect(failures[1]).toMatch(/References to the deprecated async function are not allowed/);\n+    expect(failures[2]).toMatch(/References to the deprecated async function are not allowed/);\n+  });\n+\n+  it('should change async imports to waitForAsync', () => {\n+    writeFile('/index.ts', `\n+      import { async, inject } from '@angular/core/testing';\n+\n+      it('should work', async(() => {\n+        expect(inject('foo')).toBe('foo');\n+      }));\n+    `);\n+\n+    runTSLint(true);\n+    expect(getFile('/index.ts'))\n+        .toContain(`import { inject, waitForAsync } from '@angular/core/testing';`);\n+  });\n+\n+  it('should change aliased async imports to waitForAsync', () => {\n+    writeFile('/index.ts', `\n+      import { async as renamedAsync, inject } from '@angular/core/testing';\n+\n+      it('should work', renamedAsync(() => {\n+        expect(inject('foo')).toBe('foo');\n+      }));\n+    `);\n+\n+    runTSLint(true);\n+    expect(getFile('/index.ts'))\n+        .toContain(`import { inject, waitForAsync as renamedAsync } from '@angular/core/testing';`);\n+  });\n+\n+  it('should not change async imports if they are not from @angular/core/testing', () => {\n+    writeFile('/index.ts', `\n+      import { inject } from '@angular/core/testing';\n+      import { async } from './my-test-library';\n+\n+      it('should work', async(() => {\n+        expect(inject('foo')).toBe('foo');\n+      }));\n+    `);\n+\n+    runTSLint(true);\n+    const content = getFile('/index.ts');\n+    expect(content).toContain(`import { inject } from '@angular/core/testing';`);\n+    expect(content).toContain(`import { async } from './my-test-library';`);\n+  });\n+\n+  it('should not change imports if waitForAsync was already imported', () => {\n+    writeFile('/index.ts', `\n+      import { async, inject, waitForAsync } from '@angular/core/testing';\n+\n+      it('should work', async(() => {\n+        expect(inject('foo')).toBe('foo');\n+      }));\n+\n+      it('should also work', waitForAsync(() => {\n+        expect(inject('bar')).toBe('bar');\n+      }));\n+    `);\n+\n+    runTSLint(true);\n+    expect(getFile('/index.ts'))\n+        .toContain(`import { async, inject, waitForAsync } from '@angular/core/testing';`);\n+  });\n+\n+  it('should change calls from `async` to `waitForAsync`', () => {\n+    writeFile('/index.ts', `\n+      import { async, inject } from '@angular/core/testing';\n+\n+      it('should work', async(() => {\n+        expect(inject('foo')).toBe('foo');\n+      }));\n+\n+      it('should also work', async(() => {\n+        expect(inject('bar')).toBe('bar');\n+      }));\n+    `);\n+\n+    runTSLint(true);\n+\n+    const content = getFile('/index.ts');\n+    expect(content).toContain(`import { inject, waitForAsync } from '@angular/core/testing';`);\n+    expect(content).toContain(`it('should work', waitForAsync(() => {`);\n+    expect(content).toContain(`it('should also work', waitForAsync(() => {`);\n+  });\n+\n+  it('should not change aliased calls', () => {\n+    writeFile('/index.ts', `\n+      import { async as renamedAsync, inject } from '@angular/core/testing';\n+\n+      it('should work', renamedAsync(() => {\n+        expect(inject('foo')).toBe('foo');\n+      }));\n+    `);\n+\n+    runTSLint(true);\n+\n+    const content = getFile('/index.ts');\n+    expect(content).toContain(\n+        `import { inject, waitForAsync as renamedAsync } from '@angular/core/testing';`);\n+    expect(content).toContain(`it('should work', renamedAsync(() => {`);\n+  });\n+});"
        },
        {
            "sha": "ef0a47fc68a4becfb2fb8c3430af282ffca8a12d",
            "filename": "packages/core/schematics/test/wait_for_async_migration_spec.ts",
            "status": "added",
            "additions": 161,
            "deletions": 0,
            "changes": 161,
            "blob_url": "https://github.com/angular/angular/blob/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Ftest%2Fwait_for_async_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Ftest%2Fwait_for_async_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fwait_for_async_migration_spec.ts?ref=5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84",
            "patch": "@@ -0,0 +1,161 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n+import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n+import {HostTree} from '@angular-devkit/schematics';\n+import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n+import * as shx from 'shelljs';\n+\n+describe('waitForAsync migration', () => {\n+  let runner: SchematicTestRunner;\n+  let host: TempScopedNodeJsSyncHost;\n+  let tree: UnitTestTree;\n+  let tmpDirPath: string;\n+  let previousWorkingDir: string;\n+\n+  beforeEach(() => {\n+    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n+    host = new TempScopedNodeJsSyncHost();\n+    tree = new UnitTestTree(new HostTree(host));\n+\n+    writeFile('/tsconfig.json', JSON.stringify({\n+      compilerOptions: {\n+        lib: ['es2015'],\n+        strictNullChecks: true,\n+      },\n+    }));\n+    writeFile('/angular.json', JSON.stringify({\n+      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n+    }));\n+    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n+    writeFile('/node_modules/@angular/core/testing/index.d.ts', `\n+      export declare function async(fn: Function): any;\n+    `);\n+\n+    previousWorkingDir = shx.pwd();\n+    tmpDirPath = getSystemPath(host.root);\n+\n+    // Switch into the temporary directory path. This allows us to run\n+    // the schematic against our custom unit test tree.\n+    shx.cd(tmpDirPath);\n+  });\n+\n+  afterEach(() => {\n+    shx.cd(previousWorkingDir);\n+    shx.rm('-r', tmpDirPath);\n+  });\n+\n+  it('should change async imports to waitForAsync', async () => {\n+    writeFile('/index.ts', `\n+      import { async, inject } from '@angular/core/testing';\n+\n+      it('should work', async(() => {\n+        expect(inject('foo')).toBe('foo');\n+      }));\n+    `);\n+\n+    await runMigration();\n+    expect(tree.readContent('/index.ts'))\n+        .toContain(`import { inject, waitForAsync } from '@angular/core/testing';`);\n+  });\n+\n+  it('should change aliased async imports to waitForAsync', async () => {\n+    writeFile('/index.ts', `\n+      import { async as renamedAsync, inject } from '@angular/core/testing';\n+\n+      it('should work', renamedAsync(() => {\n+        expect(inject('foo')).toBe('foo');\n+      }));\n+    `);\n+\n+    await runMigration();\n+    expect(tree.readContent('/index.ts'))\n+        .toContain(`import { inject, waitForAsync as renamedAsync } from '@angular/core/testing';`);\n+  });\n+\n+  it('should not change async imports if they are not from @angular/core/testing', async () => {\n+    writeFile('/index.ts', `\n+      import { inject } from '@angular/core/testing';\n+      import { async } from './my-test-library';\n+\n+      it('should work', async(() => {\n+        expect(inject('foo')).toBe('foo');\n+      }));\n+    `);\n+\n+    await runMigration();\n+    const content = tree.readContent('/index.ts');\n+    expect(content).toContain(`import { inject } from '@angular/core/testing';`);\n+    expect(content).toContain(`import { async } from './my-test-library';`);\n+  });\n+\n+  it('should not change imports if waitForAsync was already imported', async () => {\n+    writeFile('/index.ts', `\n+      import { async, inject, waitForAsync } from '@angular/core/testing';\n+\n+      it('should work', async(() => {\n+        expect(inject('foo')).toBe('foo');\n+      }));\n+\n+      it('should also work', waitForAsync(() => {\n+        expect(inject('bar')).toBe('bar');\n+      }));\n+    `);\n+\n+    await runMigration();\n+    expect(tree.readContent('/index.ts'))\n+        .toContain(`import { async, inject, waitForAsync } from '@angular/core/testing';`);\n+  });\n+\n+  it('should change calls from `async` to `waitForAsync`', async () => {\n+    writeFile('/index.ts', `\n+      import { async, inject } from '@angular/core/testing';\n+\n+      it('should work', async(() => {\n+        expect(inject('foo')).toBe('foo');\n+      }));\n+\n+      it('should also work', async(() => {\n+        expect(inject('bar')).toBe('bar');\n+      }));\n+    `);\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/index.ts');\n+    expect(content).toContain(`import { inject, waitForAsync } from '@angular/core/testing';`);\n+    expect(content).toContain(`it('should work', waitForAsync(() => {`);\n+    expect(content).toContain(`it('should also work', waitForAsync(() => {`);\n+  });\n+\n+  it('should not change aliased calls', async () => {\n+    writeFile('/index.ts', `\n+      import { async as renamedAsync, inject } from '@angular/core/testing';\n+\n+      it('should work', renamedAsync(() => {\n+        expect(inject('foo')).toBe('foo');\n+      }));\n+    `);\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/index.ts');\n+    expect(content).toContain(\n+        `import { inject, waitForAsync as renamedAsync } from '@angular/core/testing';`);\n+    expect(content).toContain(`it('should work', renamedAsync(() => {`);\n+  });\n+\n+  function writeFile(filePath: string, contents: string) {\n+    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n+  }\n+\n+  function runMigration() {\n+    return runner.runSchematicAsync('migration-v11-wait-for-async', {}, tree).toPromise();\n+  }\n+});"
        },
        {
            "sha": "ba11c35a3d76d85fdaf3e36fb456813dbeb27a39",
            "filename": "packages/core/schematics/tsconfig.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Ftsconfig.json",
            "raw_url": "https://github.com/angular/angular/raw/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Ftsconfig.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftsconfig.json?ref=5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84",
            "patch": "@@ -4,7 +4,7 @@\n     \"noFallthroughCasesInSwitch\": true,\n     \"strict\": true,\n     \"lib\": [\"es2015\"],\n-    \"types\": [],\n+    \"types\": [\"jasmine\"],\n     \"baseUrl\": \".\",\n     \"paths\": {\n       \"@angular/core\": [\"../\"],"
        },
        {
            "sha": "ccfe75aadd90cdce2f4e8fabb4a65ab963e01810",
            "filename": "packages/core/schematics/utils/typescript/imports.ts",
            "status": "modified",
            "additions": 40,
            "deletions": 5,
            "changes": 45,
            "blob_url": "https://github.com/angular/angular/blob/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Futils%2Ftypescript%2Fimports.ts",
            "raw_url": "https://github.com/angular/angular/raw/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Futils%2Ftypescript%2Fimports.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Futils%2Ftypescript%2Fimports.ts?ref=5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84",
            "patch": "@@ -68,11 +68,7 @@ export function getImportSpecifier(\n         node.moduleSpecifier.text === moduleName) {\n       const namedBindings = node.importClause && node.importClause.namedBindings;\n       if (namedBindings && ts.isNamedImports(namedBindings)) {\n-        const match = namedBindings.elements.find(element => {\n-          const {name, propertyName} = element;\n-          return propertyName ? propertyName.text === specifierName : name.text === specifierName;\n-        });\n-\n+        const match = findImportSpecifier(namedBindings.elements, specifierName);\n         if (match) {\n           return match;\n         }\n@@ -82,3 +78,42 @@ export function getImportSpecifier(\n \n   return null;\n }\n+\n+\n+/**\n+ * Replaces an import inside a named imports node with a different one.\n+ * @param node Node that contains the imports.\n+ * @param existingImport Import that should be replaced.\n+ * @param newImportName Import that should be inserted.\n+ */\n+export function replaceImport(\n+    node: ts.NamedImports, existingImport: string, newImportName: string) {\n+  const isAlreadyImported = findImportSpecifier(node.elements, newImportName);\n+  if (isAlreadyImported) {\n+    return node;\n+  }\n+\n+  const existingImportNode = findImportSpecifier(node.elements, existingImport);\n+  if (!existingImportNode) {\n+    return node;\n+  }\n+\n+  return ts.updateNamedImports(node, [\n+    ...node.elements.filter(current => current !== existingImportNode),\n+    // Create a new import while trying to preserve the alias of the old one.\n+    ts.createImportSpecifier(\n+        existingImportNode.propertyName ? ts.createIdentifier(newImportName) : undefined,\n+        existingImportNode.propertyName ? existingImportNode.name :\n+                                          ts.createIdentifier(newImportName))\n+  ]);\n+}\n+\n+\n+/** Finds an import specifier with a particular name. */\n+function findImportSpecifier(\n+    nodes: ts.NodeArray<ts.ImportSpecifier>, specifierName: string): ts.ImportSpecifier|undefined {\n+  return nodes.find(element => {\n+    const {name, propertyName} = element;\n+    return propertyName ? propertyName.text === specifierName : name.text === specifierName;\n+  });\n+}"
        },
        {
            "sha": "f6b5a3eb0a2fca062beeeb9afb9f083c84f9e360",
            "filename": "packages/core/schematics/utils/typescript/nodes.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Futils%2Ftypescript%2Fnodes.ts",
            "raw_url": "https://github.com/angular/angular/raw/5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84/packages%2Fcore%2Fschematics%2Futils%2Ftypescript%2Fnodes.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Futils%2Ftypescript%2Fnodes.ts?ref=5ce71e0fbc7608a621f4ba1c1e67b3a7316c9d84",
            "patch": "@@ -12,3 +12,17 @@ import * as ts from 'typescript';\n export function hasModifier(node: ts.Node, modifierKind: ts.SyntaxKind) {\n   return !!node.modifiers && node.modifiers.some(m => m.kind === modifierKind);\n }\n+\n+/** Find the closest parent node of a particular kind. */\n+export function closestNode<T extends ts.Node>(node: ts.Node, kind: ts.SyntaxKind): T|null {\n+  let current: ts.Node = node;\n+\n+  while (current && !ts.isSourceFile(current)) {\n+    if (current.kind === kind) {\n+      return current as T;\n+    }\n+    current = current.parent;\n+  }\n+\n+  return null;\n+}"
        }
    ],
    "stats": {
        "total": 708,
        "additions": 650,
        "deletions": 58
    }
}