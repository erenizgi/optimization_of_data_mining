{
    "author": "mgechev",
    "message": "perf(core): add private hooks around user code executed by the runtime (#41255)\n\nIntroduces an **internal**, **experimental** `profiler` function, which\nthe runtime invokes around user code, including before and after:\n- Running the template function of a component\n- Executing a lifecycle hook\n- Evaluating an output handler\n\nThe `profiler` function invokes a callback set with the global\n`ng.ɵsetProfiler`. This API is **private** and **experimental** and\ncould be removed or changed at any time.\n\nThis implementation is cheap and available in production. It's cheap\nbecause the `profiler` function is simple, which allows the JiT compiler\nto inline it in the callsites. It also doesn't add up much to the\nproduction bundle.\n\nTo listen for profiler events:\n\n```ts\nng.ɵsetProfiler((event, ...args) => {\n  // monitor user code execution\n});\n```\n\nPR Close #41255",
    "sha": "520ff69854ac0e10236e9f70557d31c97c20153f",
    "files": [
        {
            "sha": "917d0775ba3918343193075ead9cdee202ed02f8",
            "filename": "goldens/size-tracking/integration-payloads.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/520ff69854ac0e10236e9f70557d31c97c20153f/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "raw_url": "https://github.com/angular/angular/raw/520ff69854ac0e10236e9f70557d31c97c20153f/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fsize-tracking%2Fintegration-payloads.json?ref=520ff69854ac0e10236e9f70557d31c97c20153f",
            "patch": "@@ -39,7 +39,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 2285,\n-        \"main-es2015\": 240874,\n+        \"main-es2015\": 240883,\n         \"polyfills-es2015\": 36975,\n         \"5-es2015\": 753\n       }"
        },
        {
            "sha": "bae931b12cefff27ca2f52c2552c307431d3f34f",
            "filename": "packages/core/src/core_render3_private_export.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/520ff69854ac0e10236e9f70557d31c97c20153f/packages%2Fcore%2Fsrc%2Fcore_render3_private_export.ts",
            "raw_url": "https://github.com/angular/angular/raw/520ff69854ac0e10236e9f70557d31c97c20153f/packages%2Fcore%2Fsrc%2Fcore_render3_private_export.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Fcore_render3_private_export.ts?ref=520ff69854ac0e10236e9f70557d31c97c20153f",
            "patch": "@@ -279,6 +279,7 @@ export {\n export {\n   compilePipe as ɵcompilePipe,\n } from './render3/jit/pipe';\n+export { Profiler as ɵProfiler, ProfilerEvent as ɵProfilerEvent } from './render3/profiler';\n export {\n   publishDefaultGlobalUtils as ɵpublishDefaultGlobalUtils\n ,"
        },
        {
            "sha": "55fb0363bffc360ef411f301d6bb47890d41f74a",
            "filename": "packages/core/src/render3/hooks.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 2,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/520ff69854ac0e10236e9f70557d31c97c20153f/packages%2Fcore%2Fsrc%2Frender3%2Fhooks.ts",
            "raw_url": "https://github.com/angular/angular/raw/520ff69854ac0e10236e9f70557d31c97c20153f/packages%2Fcore%2Fsrc%2Frender3%2Fhooks.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fhooks.ts?ref=520ff69854ac0e10236e9f70557d31c97c20153f",
            "patch": "@@ -13,6 +13,7 @@ import {NgOnChangesFeatureImpl} from './features/ng_onchanges_feature';\n import {DirectiveDef} from './interfaces/definition';\n import {TNode} from './interfaces/node';\n import {FLAGS, HookData, InitPhaseState, LView, LViewFlags, PREORDER_HOOK_FLAGS, PreOrderHookFlags, TView} from './interfaces/view';\n+import {profiler, ProfilerEvent} from './profiler';\n import {isInCheckNoChangesMode} from './state';\n \n \n@@ -256,9 +257,19 @@ function callHook(currentView: LView, initPhase: InitPhaseState, arr: HookData,\n             (currentView[PREORDER_HOOK_FLAGS] >> PreOrderHookFlags.NumberOfInitHooksCalledShift) &&\n         (currentView[FLAGS] & LViewFlags.InitPhaseStateMask) === initPhase) {\n       currentView[FLAGS] += LViewFlags.IndexWithinInitPhaseIncrementer;\n-      hook.call(directive);\n+      profiler(ProfilerEvent.LifecycleHookStart, directive, hook);\n+      try {\n+        hook.call(directive);\n+      } finally {\n+        profiler(ProfilerEvent.LifecycleHookEnd, directive, hook);\n+      }\n     }\n   } else {\n-    hook.call(directive);\n+    profiler(ProfilerEvent.LifecycleHookStart, directive, hook);\n+    try {\n+      hook.call(directive);\n+    } finally {\n+      profiler(ProfilerEvent.LifecycleHookEnd, directive, hook);\n+    }\n   }\n }"
        },
        {
            "sha": "c469fd8ecee37d301c63eef055d50db6d6212b79",
            "filename": "packages/core/src/render3/instructions/listener.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 8,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/520ff69854ac0e10236e9f70557d31c97c20153f/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Flistener.ts",
            "raw_url": "https://github.com/angular/angular/raw/520ff69854ac0e10236e9f70557d31c97c20153f/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Flistener.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Flistener.ts?ref=520ff69854ac0e10236e9f70557d31c97c20153f",
            "patch": "@@ -14,8 +14,9 @@ import {PropertyAliasValue, TNode, TNodeFlags, TNodeType} from '../interfaces/no\n import {GlobalTargetResolver, isProceduralRenderer, Renderer3} from '../interfaces/renderer';\n import {RElement} from '../interfaces/renderer_dom';\n import {isDirectiveHost} from '../interfaces/type_checks';\n-import {CLEANUP, FLAGS, LView, LViewFlags, RENDERER, TView} from '../interfaces/view';\n+import {CLEANUP, CONTEXT, FLAGS, LView, LViewFlags, RENDERER, TView} from '../interfaces/view';\n import {assertTNodeType} from '../node_assert';\n+import {profiler, ProfilerEvent} from '../profiler';\n import {getCurrentDirectiveDef, getCurrentTNode, getLView, getTView} from '../state';\n import {getComponentLViewByIndex, getNativeByTNode, unwrapRNode} from '../util/view_utils';\n \n@@ -121,6 +122,7 @@ function listenerInternal(\n   const isTNodeDirectiveHost = isDirectiveHost(tNode);\n   const firstCreatePass = tView.firstCreatePass;\n   const tCleanup: false|any[] = firstCreatePass && getOrCreateTViewCleanup(tView);\n+  const context = lView[CONTEXT];\n \n   // When the ɵɵlistener instruction was generated and is executed we know that there is either a\n   // native listener or a directive output on this element. As such we we know that we will have to\n@@ -177,7 +179,7 @@ function listenerInternal(\n         // The first argument of `listen` function in Procedural Renderer is:\n         // - either a target name (as a string) in case of global target (window, document, body)\n         // - or element reference (in all other cases)\n-        listenerFn = wrapListener(tNode, lView, listenerFn, false /** preventDefault */);\n+        listenerFn = wrapListener(tNode, lView, context, listenerFn, false /** preventDefault */);\n         const cleanupFn = renderer.listen(resolved.name || target, eventName, listenerFn);\n         ngDevMode && ngDevMode.rendererAddEventListener++;\n \n@@ -186,7 +188,7 @@ function listenerInternal(\n       }\n \n     } else {\n-      listenerFn = wrapListener(tNode, lView, listenerFn, true /** preventDefault */);\n+      listenerFn = wrapListener(tNode, lView, context, listenerFn, true /** preventDefault */);\n       target.addEventListener(eventName, listenerFn, useCapture);\n       ngDevMode && ngDevMode.rendererAddEventListener++;\n \n@@ -196,7 +198,7 @@ function listenerInternal(\n   } else {\n     // Even if there is no native listener to add, we still need to wrap the listener so that OnPush\n     // ancestors are marked dirty when an event occurs.\n-    listenerFn = wrapListener(tNode, lView, listenerFn, false /** preventDefault */);\n+    listenerFn = wrapListener(tNode, lView, context, listenerFn, false /** preventDefault */);\n   }\n \n   // subscribe to directive outputs\n@@ -227,13 +229,16 @@ function listenerInternal(\n }\n \n function executeListenerWithErrorHandling(\n-    lView: LView, listenerFn: (e?: any) => any, e: any): boolean {\n+    lView: LView, context: {}|null, listenerFn: (e?: any) => any, e: any): boolean {\n   try {\n+    profiler(ProfilerEvent.OutputStart, context, listenerFn);\n     // Only explicitly returning false from a listener should preventDefault\n     return listenerFn(e) !== false;\n   } catch (error) {\n     handleError(lView, error);\n     return false;\n+  } finally {\n+    profiler(ProfilerEvent.OutputEnd, context, listenerFn);\n   }\n }\n \n@@ -248,7 +253,7 @@ function executeListenerWithErrorHandling(\n  * (the procedural renderer does this already, so in those cases, we should skip)\n  */\n function wrapListener(\n-    tNode: TNode, lView: LView, listenerFn: (e?: any) => any,\n+    tNode: TNode, lView: LView, context: {}|null, listenerFn: (e?: any) => any,\n     wrapWithPreventDefault: boolean): EventListener {\n   // Note: we are performing most of the work in the listener function itself\n   // to optimize listener registration.\n@@ -270,13 +275,13 @@ function wrapListener(\n       markViewDirty(startView);\n     }\n \n-    let result = executeListenerWithErrorHandling(lView, listenerFn, e);\n+    let result = executeListenerWithErrorHandling(lView, context, listenerFn, e);\n     // A just-invoked listener function might have coalesced listeners so we need to check for\n     // their presence and invoke as needed.\n     let nextListenerFn = (<any>wrapListenerIn_markDirtyAndPreventDefault).__ngNextListenerFn__;\n     while (nextListenerFn) {\n       // We should prevent default if any of the listeners explicitly return false\n-      result = executeListenerWithErrorHandling(lView, nextListenerFn, e) && result;\n+      result = executeListenerWithErrorHandling(lView, context, nextListenerFn, e) && result;\n       nextListenerFn = (<any>nextListenerFn).__ngNextListenerFn__;\n     }\n "
        },
        {
            "sha": "34d6ef6daf871be1a77772831c33179b96765184",
            "filename": "packages/core/src/render3/instructions/shared.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 1,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/520ff69854ac0e10236e9f70557d31c97c20153f/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fshared.ts",
            "raw_url": "https://github.com/angular/angular/raw/520ff69854ac0e10236e9f70557d31c97c20153f/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fshared.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fshared.ts?ref=520ff69854ac0e10236e9f70557d31c97c20153f",
            "patch": "@@ -37,6 +37,7 @@ import {CHILD_HEAD, CHILD_TAIL, CLEANUP, CONTEXT, DECLARATION_COMPONENT_VIEW, DE\n import {assertPureTNodeType, assertTNodeType} from '../node_assert';\n import {updateTextNode} from '../node_manipulation';\n import {isInlineTemplate, isNodeMatchingSelectorList} from '../node_selector_matcher';\n+import {profiler, ProfilerEvent} from '../profiler';\n import {enterView, getBindingsEnabled, getCurrentDirectiveIndex, getCurrentParentTNode, getCurrentTNode, getCurrentTNodePlaceholderOk, getSelectedIndex, isCurrentTNodeParent, isInCheckNoChangesMode, isInI18nBlock, leaveView, setBindingIndex, setBindingRootForHostBindings, setCurrentDirectiveIndex, setCurrentQueryIndex, setCurrentTNode, setIsInCheckNoChangesMode, setSelectedIndex} from '../state';\n import {NO_CHANGE} from '../tokens';\n import {isAnimationProp, mergeHostAttrs} from '../util/attrs_utils';\n@@ -501,16 +502,25 @@ export function renderComponentOrTemplate<T>(\n function executeTemplate<T>(\n     tView: TView, lView: LView, templateFn: ComponentTemplate<T>, rf: RenderFlags, context: T) {\n   const prevSelectedIndex = getSelectedIndex();\n+  const isUpdatePhase = rf & RenderFlags.Update;\n   try {\n     setSelectedIndex(-1);\n-    if (rf & RenderFlags.Update && lView.length > HEADER_OFFSET) {\n+    if (isUpdatePhase && lView.length > HEADER_OFFSET) {\n       // When we're updating, inherently select 0 so we don't\n       // have to generate that instruction for most update blocks.\n       selectIndexInternal(tView, lView, HEADER_OFFSET, isInCheckNoChangesMode());\n     }\n+\n+    const preHookType =\n+        isUpdatePhase ? ProfilerEvent.TemplateUpdateStart : ProfilerEvent.TemplateCreateStart;\n+    profiler(preHookType, context);\n     templateFn(rf, context);\n   } finally {\n     setSelectedIndex(prevSelectedIndex);\n+\n+    const postHookType =\n+        isUpdatePhase ? ProfilerEvent.TemplateUpdateEnd : ProfilerEvent.TemplateCreateEnd;\n+    profiler(postHookType, context);\n   }\n }\n "
        },
        {
            "sha": "ba16dcf3c95a391e3689c615b666182df3275696",
            "filename": "packages/core/src/render3/interfaces/view.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/520ff69854ac0e10236e9f70557d31c97c20153f/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fview.ts",
            "raw_url": "https://github.com/angular/angular/raw/520ff69854ac0e10236e9f70557d31c97c20153f/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fview.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fview.ts?ref=520ff69854ac0e10236e9f70557d31c97c20153f",
            "patch": "@@ -1157,4 +1157,4 @@ export interface NodeInjectorDebug {\n    * Location of the parent `TNode`.\n    */\n   parentInjectorIndex: number;\n-}\n\\ No newline at end of file\n+}"
        },
        {
            "sha": "fd908f5db07f0012b3395a48eb10e021f749c4f7",
            "filename": "packages/core/src/render3/profiler.ts",
            "status": "added",
            "additions": 101,
            "deletions": 0,
            "changes": 101,
            "blob_url": "https://github.com/angular/angular/blob/520ff69854ac0e10236e9f70557d31c97c20153f/packages%2Fcore%2Fsrc%2Frender3%2Fprofiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/520ff69854ac0e10236e9f70557d31c97c20153f/packages%2Fcore%2Fsrc%2Frender3%2Fprofiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fprofiler.ts?ref=520ff69854ac0e10236e9f70557d31c97c20153f",
            "patch": "@@ -0,0 +1,101 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+/**\n+ * Profiler events is an enum used by the profiler to distinguish between different calls of user\n+ * code invoked throughout the application lifecycle.\n+ */\n+export const enum ProfilerEvent {\n+  /**\n+   * Corresponds to the point in time before the runtime has called the template function of a\n+   * component with `RenderFlags.Create`.\n+   */\n+  TemplateCreateStart,\n+\n+  /**\n+   * Corresponds to the point in time after the runtime has called the template function of a\n+   * component with `RenderFlags.Create`.\n+   */\n+  TemplateCreateEnd,\n+\n+  /**\n+   * Corresponds to the point in time before the runtime has called the template function of a\n+   * component with `RenderFlags.Update`.\n+   */\n+  TemplateUpdateStart,\n+\n+  /**\n+   * Corresponds to the point in time after the runtime has called the template function of a\n+   * component with `RenderFlags.Update`.\n+   */\n+  TemplateUpdateEnd,\n+\n+  /**\n+   * Corresponds to the point in time before the runtime has called a lifecycle hook of a component\n+   * or directive.\n+   */\n+  LifecycleHookStart,\n+\n+  /**\n+   * Corresponds to the point in time after the runtime has called a lifecycle hook of a component\n+   * or directive.\n+   */\n+  LifecycleHookEnd,\n+\n+  /**\n+   * Corresponds to the point in time before the runtime has evaluated an expression associated with\n+   * an event or an output.\n+   */\n+  OutputStart,\n+\n+  /**\n+   * Corresponds to the point in time after the runtime has evaluated an expression associated with\n+   * an event or an output.\n+   */\n+  OutputEnd,\n+}\n+\n+/**\n+ * Profiler function which the runtime will invoke before and after user code.\n+ */\n+export interface Profiler {\n+  (event: ProfilerEvent, instance: {}|null, hookOrListener?: (e?: any) => any): void;\n+}\n+\n+\n+let profilerCallback: Profiler|null = null;\n+\n+/**\n+ * Sets the callback function which will be invoked before and after performing certain actions at\n+ * runtime (for example, before and after running change detection).\n+ *\n+ * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\n+ * The contract of the function might be changed in any release and/or the function can be removed\n+ * completely.\n+ *\n+ * @param profiler function provided by the caller or null value to disable profiling.\n+ */\n+export const setProfiler = (profiler: Profiler|null) => {\n+  profilerCallback = profiler;\n+};\n+\n+/**\n+ * Profiler function which wraps user code executed by the runtime.\n+ *\n+ * @param event ProfilerEvent corresponding to the execution context\n+ * @param instance component instance\n+ * @param hookOrListener lifecycle hook function or output listener. The value depends on the\n+ *  execution context\n+ * @returns\n+ */\n+export const profiler: Profiler = function(\n+    event: ProfilerEvent, instance: {}|null, hookOrListener?: (e?: any) => any) {\n+  if (profilerCallback != null /* both `null` and `undefined` */) {\n+    profilerCallback(event, instance, hookOrListener);\n+  }\n+};"
        },
        {
            "sha": "9e488d3f1a9b83046ac47a51e276ffdb836e39e6",
            "filename": "packages/core/src/render3/util/global_utils.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/520ff69854ac0e10236e9f70557d31c97c20153f/packages%2Fcore%2Fsrc%2Frender3%2Futil%2Fglobal_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/520ff69854ac0e10236e9f70557d31c97c20153f/packages%2Fcore%2Fsrc%2Frender3%2Futil%2Fglobal_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Futil%2Fglobal_utils.ts?ref=520ff69854ac0e10236e9f70557d31c97c20153f",
            "patch": "@@ -7,6 +7,7 @@\n  */\n import {assertDefined} from '../../util/assert';\n import {global} from '../../util/global';\n+import {setProfiler} from '../profiler';\n import {applyChanges} from './change_detection_utils';\n import {getComponent, getContext, getDirectives, getHostElement, getInjector, getListeners, getOwningComponent, getRootComponents} from './discovery_utils';\n \n@@ -40,6 +41,13 @@ let _published = false;\n export function publishDefaultGlobalUtils() {\n   if (!_published) {\n     _published = true;\n+\n+    /**\n+     * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\n+     * The contract of the function might be changed in any release and/or the function can be\n+     * removed completely.\n+     */\n+    publishGlobalUtil('ɵsetProfiler', setProfiler);\n     publishGlobalUtil('getComponent', getComponent);\n     publishGlobalUtil('getContext', getContext);\n     publishGlobalUtil('getListeners', getListeners);"
        },
        {
            "sha": "bec91977d415038d41db3409a9cf3fa89c72f4ed",
            "filename": "packages/core/test/acceptance/profiler_spec.ts",
            "status": "added",
            "additions": 320,
            "deletions": 0,
            "changes": 320,
            "blob_url": "https://github.com/angular/angular/blob/520ff69854ac0e10236e9f70557d31c97c20153f/packages%2Fcore%2Ftest%2Facceptance%2Fprofiler_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/520ff69854ac0e10236e9f70557d31c97c20153f/packages%2Fcore%2Ftest%2Facceptance%2Fprofiler_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fprofiler_spec.ts?ref=520ff69854ac0e10236e9f70557d31c97c20153f",
            "patch": "@@ -0,0 +1,320 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {ProfilerEvent, setProfiler} from '@angular/core/src/render3/profiler';\n+import {TestBed} from '@angular/core/testing';\n+import {expect} from '@angular/core/testing/src/testing_internal';\n+import {onlyInIvy} from '@angular/private/testing';\n+\n+import {AfterContentChecked, AfterContentInit, AfterViewChecked, AfterViewInit, Component, DoCheck, ErrorHandler, EventEmitter, Input, OnChanges, OnInit, Output, ViewChild} from '../../src/core';\n+\n+\n+onlyInIvy('Ivy-specific functionality').describe('profiler', () => {\n+  class Profiler {\n+    profile() {}\n+  }\n+\n+  let profilerSpy: jasmine.Spy;\n+\n+  beforeEach(() => {\n+    const profiler = new Profiler();\n+    profilerSpy = spyOn(profiler, 'profile').and.callThrough();\n+    setProfiler(profiler.profile);\n+  });\n+\n+  afterAll(() => setProfiler(null));\n+\n+  function findProfilerCall(condition: ProfilerEvent|((args: any[]) => boolean)) {\n+    let predicate: (args: any[]) => boolean = _ => true;\n+    if (typeof condition !== 'function') {\n+      predicate = (args: any[]) => args[0] === condition;\n+    } else {\n+      predicate = condition;\n+    }\n+    return profilerSpy.calls.all().map((call: any) => call.args).find(predicate);\n+  }\n+\n+  describe('change detection hooks', () => {\n+    it('should call the profiler for creation and change detection', () => {\n+      @Component({selector: 'my-comp', template: '<button (click)=\"onClick()\"></button>'})\n+      class MyComponent {\n+        onClick() {}\n+      }\n+\n+      TestBed.configureTestingModule({declarations: [MyComponent]});\n+      const fixture = TestBed.createComponent(MyComponent);\n+\n+      expect(profilerSpy).toHaveBeenCalled();\n+\n+      const templateCreateStart = findProfilerCall(\n+          (args: any[]) => args[0] === ProfilerEvent.TemplateCreateStart &&\n+              args[1] === fixture.componentInstance);\n+      const templateCreateEnd = findProfilerCall(\n+          (args: any[]) =>\n+              args[0] === ProfilerEvent.TemplateCreateEnd && args[1] === fixture.componentInstance);\n+\n+      expect(templateCreateStart).toBeTruthy();\n+      expect(templateCreateEnd).toBeTruthy();\n+\n+      fixture.detectChanges();\n+\n+      const templateUpdateStart = findProfilerCall(\n+          (args: any[]) => args[0] === ProfilerEvent.TemplateUpdateStart &&\n+              args[1] === fixture.componentInstance);\n+      const templateUpdateEnd = findProfilerCall(\n+          (args: any[]) =>\n+              args[0] === ProfilerEvent.TemplateUpdateEnd && args[1] === fixture.componentInstance);\n+\n+      expect(templateUpdateStart).toBeTruthy();\n+      expect(templateUpdateEnd).toBeTruthy();\n+    });\n+\n+    it('should invoke the profiler when the template throws', () => {\n+      @Component({selector: 'my-comp', template: '{{ throw() }}'})\n+      class MyComponent {\n+        throw() {\n+          throw new Error();\n+        }\n+      }\n+\n+      TestBed.configureTestingModule({declarations: [MyComponent]});\n+\n+      let myComp: MyComponent;\n+      expect(() => {\n+        const fixture = TestBed.createComponent(MyComponent);\n+        myComp = fixture.componentInstance;\n+        fixture.detectChanges();\n+      }).toThrow();\n+\n+      expect(profilerSpy).toHaveBeenCalled();\n+\n+      const templateCreateStart = findProfilerCall(\n+          (args: any[]) => args[0] === ProfilerEvent.TemplateCreateStart && args[1] === myComp);\n+      const templateCreateEnd = findProfilerCall(\n+          (args: any[]) => args[0] === ProfilerEvent.TemplateCreateEnd && args[1] === myComp);\n+\n+      expect(templateCreateStart).toBeTruthy();\n+      expect(templateCreateEnd).toBeTruthy();\n+    });\n+  });\n+\n+  describe('outputs and events', () => {\n+    it('should invoke the profiler on event handler', () => {\n+      @Component({selector: 'my-comp', template: '<button (click)=\"onClick()\"></button>'})\n+      class MyComponent {\n+        onClick() {}\n+      }\n+\n+      TestBed.configureTestingModule({declarations: [MyComponent]});\n+      const fixture = TestBed.createComponent(MyComponent);\n+      const myComp = fixture.componentInstance;\n+\n+      const clickSpy = spyOn(myComp, 'onClick');\n+      const button = fixture.nativeElement.querySelector('button')!;\n+\n+      button.click();\n+\n+      expect(clickSpy).toHaveBeenCalled();\n+\n+      const outputStart = findProfilerCall(ProfilerEvent.OutputStart);\n+      const outputEnd = findProfilerCall(ProfilerEvent.OutputEnd);\n+\n+      expect(outputStart[1]).toEqual(myComp!);\n+      expect(outputEnd[1]).toEqual(myComp!);\n+    });\n+\n+    it('should invoke the profiler on event handler even when it throws', () => {\n+      @Component({selector: 'my-comp', template: '<button (click)=\"onClick()\"></button>'})\n+      class MyComponent {\n+        onClick() {\n+          throw new Error();\n+        }\n+      }\n+\n+      const handler = new ErrorHandler();\n+      const errorSpy = spyOn(handler, 'handleError');\n+\n+      TestBed.configureTestingModule(\n+          {declarations: [MyComponent], providers: [{provide: ErrorHandler, useValue: handler}]});\n+\n+      const fixture = TestBed.createComponent(MyComponent);\n+      const myComp = fixture.componentInstance;\n+      const button = fixture.nativeElement.querySelector('button')!;\n+\n+      button.click();\n+\n+      expect(errorSpy).toHaveBeenCalled();\n+\n+      const outputStart = findProfilerCall(ProfilerEvent.OutputStart);\n+      const outputEnd = findProfilerCall(ProfilerEvent.OutputEnd);\n+\n+      expect(outputStart[1]).toEqual(myComp!);\n+      expect(outputEnd[1]).toEqual(myComp!);\n+    });\n+\n+    it('should invoke the profiler on output handler execution', async () => {\n+      @Component({selector: 'child', template: ''})\n+      class Child {\n+        @Output() childEvent = new EventEmitter();\n+      }\n+\n+      @Component({selector: 'my-comp', template: '<child (childEvent)=\"onEvent()\"></child>'})\n+      class MyComponent {\n+        @ViewChild(Child) child!: Child;\n+        onEvent() {}\n+      }\n+\n+      TestBed.configureTestingModule({declarations: [MyComponent, Child]});\n+      const fixture = TestBed.createComponent(MyComponent);\n+      const myComp = fixture.componentInstance;\n+\n+      fixture.detectChanges();\n+\n+      myComp.child!.childEvent.emit();\n+\n+      const outputStart = findProfilerCall(ProfilerEvent.OutputStart);\n+      const outputEnd = findProfilerCall(ProfilerEvent.OutputEnd);\n+\n+      expect(outputStart[1]).toEqual(myComp!);\n+      expect(outputEnd[1]).toEqual(myComp!);\n+    });\n+  });\n+\n+  describe('lifecycle hooks', () => {\n+    it('should call the profiler on lifecycle execution', () => {\n+      @Component({selector: 'my-comp', template: '{{prop}}'})\n+      class MyComponent implements OnInit, AfterViewInit, AfterViewChecked, AfterContentInit,\n+                                   AfterContentChecked, OnChanges, DoCheck {\n+        @Input() prop = 1;\n+\n+        ngOnInit() {}\n+        ngDoCheck() {}\n+        ngOnChanges() {}\n+        ngAfterViewInit() {}\n+        ngAfterViewChecked() {}\n+        ngAfterContentInit() {}\n+        ngAfterContentChecked() {}\n+      }\n+\n+      @Component({selector: 'my-parent', template: '<my-comp [prop]=\"prop\"></my-comp>'})\n+      class MyParent {\n+        prop = 1;\n+        @ViewChild(MyComponent) child!: MyComponent;\n+      }\n+\n+      TestBed.configureTestingModule({declarations: [MyParent, MyComponent]});\n+      const fixture = TestBed.createComponent(MyParent);\n+\n+      fixture.detectChanges();\n+\n+      const myParent = fixture.componentInstance;\n+      const myComp = fixture.componentInstance.child;\n+\n+      const ngOnInitStart = findProfilerCall(\n+          (args: any[]) =>\n+              args[0] === ProfilerEvent.LifecycleHookStart && args[2] === myComp.ngOnInit);\n+      const ngOnInitEnd = findProfilerCall(\n+          (args: any[]) =>\n+              args[0] === ProfilerEvent.LifecycleHookEnd && args[2] === myComp.ngOnInit);\n+\n+      expect(ngOnInitStart).toBeTruthy();\n+      expect(ngOnInitEnd).toBeTruthy();\n+\n+      const ngOnDoCheckStart = findProfilerCall(\n+          (args: any[]) =>\n+              args[0] === ProfilerEvent.LifecycleHookStart && args[2] === myComp.ngDoCheck);\n+      const ngOnDoCheckEnd = findProfilerCall(\n+          (args: any[]) =>\n+              args[0] === ProfilerEvent.LifecycleHookEnd && args[2] === myComp.ngDoCheck);\n+\n+      expect(ngOnDoCheckStart).toBeTruthy();\n+      expect(ngOnDoCheckEnd).toBeTruthy();\n+\n+      const ngAfterViewInitStart = findProfilerCall(\n+          (args: any[]) =>\n+              args[0] === ProfilerEvent.LifecycleHookStart && args[2] === myComp.ngAfterViewInit);\n+      const ngAfterViewInitEnd = findProfilerCall(\n+          (args: any[]) =>\n+              args[0] === ProfilerEvent.LifecycleHookEnd && args[2] === myComp.ngAfterViewInit);\n+\n+      expect(ngAfterViewInitStart).toBeTruthy();\n+      expect(ngAfterViewInitEnd).toBeTruthy();\n+\n+      const ngAfterViewCheckedStart = findProfilerCall(\n+          (args: any[]) => args[0] === ProfilerEvent.LifecycleHookStart &&\n+              args[2] === myComp.ngAfterViewChecked);\n+      const ngAfterViewCheckedEnd = findProfilerCall(\n+          (args: any[]) =>\n+              args[0] === ProfilerEvent.LifecycleHookEnd && args[2] === myComp.ngAfterViewChecked);\n+\n+      expect(ngAfterViewCheckedStart).toBeTruthy();\n+      expect(ngAfterViewCheckedEnd).toBeTruthy();\n+\n+      const ngAfterContentInitStart = findProfilerCall(\n+          (args: any[]) => args[0] === ProfilerEvent.LifecycleHookStart &&\n+              args[2] === myComp.ngAfterContentInit);\n+      const ngAfterContentInitEnd = findProfilerCall(\n+          (args: any[]) =>\n+              args[0] === ProfilerEvent.LifecycleHookEnd && args[2] === myComp.ngAfterContentInit);\n+\n+      expect(ngAfterContentInitStart).toBeTruthy();\n+      expect(ngAfterContentInitEnd).toBeTruthy();\n+\n+      const ngAfterContentCheckedStart = findProfilerCall(\n+          (args: any[]) => args[0] === ProfilerEvent.LifecycleHookStart &&\n+              args[2] === myComp.ngAfterContentChecked);\n+      const ngAfterContentChecked = findProfilerCall(\n+          (args: any[]) => args[0] === ProfilerEvent.LifecycleHookEnd &&\n+              args[2] === myComp.ngAfterContentChecked);\n+\n+      expect(ngAfterContentCheckedStart).toBeTruthy();\n+      expect(ngAfterContentChecked).toBeTruthy();\n+\n+\n+      // Verify we call `ngOnChanges` and the corresponding profiler hooks\n+      const onChangesSpy = spyOn(myComp, 'ngOnChanges');\n+      profilerSpy.calls.reset();\n+\n+      myParent.prop = 2;\n+      fixture.detectChanges();\n+\n+      const ngOnChangesStart = findProfilerCall(\n+          (args: any[]) => args[0] === ProfilerEvent.LifecycleHookStart && args[2] &&\n+              args[2].name && args[2].name.indexOf('OnChangesHook') >= 0);\n+      const ngOnChangesEnd = findProfilerCall(\n+          (args: any[]) => args[0] === ProfilerEvent.LifecycleHookEnd && args[2] && args[2].name &&\n+              args[2].name.indexOf('OnChangesHook') >= 0);\n+\n+      expect(onChangesSpy).toHaveBeenCalled();\n+      expect(ngOnChangesStart).toBeTruthy();\n+      expect(ngOnChangesEnd).toBeTruthy();\n+    });\n+  });\n+\n+  it('should call the profiler on lifecycle execution even after error', () => {\n+    @Component({selector: 'my-comp', template: ''})\n+    class MyComponent implements OnInit {\n+      ngOnInit() {\n+        throw new Error();\n+      }\n+    }\n+\n+    TestBed.configureTestingModule({declarations: [MyComponent]});\n+    const fixture = TestBed.createComponent(MyComponent);\n+\n+    expect(() => {\n+      fixture.detectChanges();\n+    }).toThrow();\n+\n+    const lifecycleStart = findProfilerCall(ProfilerEvent.LifecycleHookStart);\n+    const lifecycleEnd = findProfilerCall(ProfilerEvent.LifecycleHookEnd);\n+\n+    expect(lifecycleStart).toBeTruthy();\n+    expect(lifecycleEnd).toBeTruthy();\n+  });\n+});"
        },
        {
            "sha": "ea19965a1d6fffced76d3bcaf53614ca083973c3",
            "filename": "packages/core/test/render3/global_utils_spec.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/520ff69854ac0e10236e9f70557d31c97c20153f/packages%2Fcore%2Ftest%2Frender3%2Fglobal_utils_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/520ff69854ac0e10236e9f70557d31c97c20153f/packages%2Fcore%2Ftest%2Frender3%2Fglobal_utils_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Fglobal_utils_spec.ts?ref=520ff69854ac0e10236e9f70557d31c97c20153f",
            "patch": "@@ -6,6 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n+import {setProfiler} from '@angular/core/src/render3/profiler';\n import {applyChanges} from '../../src/render3/util/change_detection_utils';\n import {getComponent, getContext, getDirectives, getHostElement, getInjector, getListeners, getOwningComponent, getRootComponents} from '../../src/render3/util/discovery_utils';\n import {GLOBAL_PUBLISH_EXPANDO_KEY, GlobalDevModeContainer, publishDefaultGlobalUtils, publishGlobalUtil} from '../../src/render3/util/global_utils';\n@@ -60,6 +61,10 @@ describe('global utils', () => {\n     it('should publish applyChanges', () => {\n       assertPublished('applyChanges', applyChanges);\n     });\n+\n+    it('should publish ɵsetProfiler', () => {\n+      assertPublished('ɵsetProfiler', setProfiler);\n+    });\n   });\n });\n "
        }
    ],
    "stats": {
        "total": 487,
        "additions": 474,
        "deletions": 13
    }
}