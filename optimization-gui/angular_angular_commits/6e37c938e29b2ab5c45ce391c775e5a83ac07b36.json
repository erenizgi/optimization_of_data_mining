{
    "author": "gkalpak",
    "message": "fix(ngcc): support alternate UMD layout when adding new imports (#43931)\n\nIn #43879, `UmdReflectionHost` was updated to deal with the new UMD\nformat used by Rollup, where the parenthesis is around the wrapper\nfunction and not the wrapper function call.\nFor reference, this caused failures in the `ngcc-validation` repo\n([example 1][1], [example 2][2]).\n\nThis commit updates `UmdRenderingFormatter` to also handle both UMD\nformats. In order to validate the change, this commit also updates the\n`UmdRenderingFormatter` tests to run against both UMD formats.\n\n[1]: https://circleci.com/gh/angular/ngcc-validation/65916\n[2]: https://circleci.com/gh/angular/ngcc-validation/65758\n\nPR Close #43931",
    "sha": "6e37c938e29b2ab5c45ce391c775e5a83ac07b36",
    "files": [
        {
            "sha": "ebbc3e0b3dd70283b21a51f5b84a7ba9695f729d",
            "filename": "packages/compiler-cli/ngcc/src/rendering/umd_rendering_formatter.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 19,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/6e37c938e29b2ab5c45ce391c775e5a83ac07b36/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fumd_rendering_formatter.ts",
            "raw_url": "https://github.com/angular/angular/raw/6e37c938e29b2ab5c45ce391c775e5a83ac07b36/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fumd_rendering_formatter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fumd_rendering_formatter.ts?ref=6e37c938e29b2ab5c45ce391c775e5a83ac07b36",
            "patch": "@@ -61,13 +61,13 @@ export class UmdRenderingFormatter extends Esm5RenderingFormatter {\n       return;\n     }\n \n-    const wrapperFunction = umdModule.wrapperFn;\n+    const {wrapperFn, factoryFn} = umdModule;\n \n     // We need to add new `require()` calls for each import in the CommonJS initializer\n-    renderCommonJsDependencies(output, wrapperFunction, imports);\n-    renderAmdDependencies(output, wrapperFunction, imports);\n-    renderGlobalDependencies(output, wrapperFunction, imports);\n-    renderFactoryParameters(output, wrapperFunction, imports);\n+    renderCommonJsDependencies(output, wrapperFn, imports);\n+    renderAmdDependencies(output, wrapperFn, imports);\n+    renderGlobalDependencies(output, wrapperFn, imports);\n+    renderFactoryParameters(output, factoryFn, imports);\n   }\n \n   /**\n@@ -210,20 +210,7 @@ function renderGlobalDependencies(\n  * Add dependency parameters to the UMD factory function.\n  */\n function renderFactoryParameters(\n-    output: MagicString, wrapperFunction: ts.FunctionExpression, imports: Import[]) {\n-  const wrapperCall = wrapperFunction.parent as ts.CallExpression;\n-  const secondArgument = wrapperCall.arguments[1];\n-  if (!secondArgument) {\n-    return;\n-  }\n-\n-  // Be resilient to the factory being inside parentheses\n-  const factoryFunction =\n-      ts.isParenthesizedExpression(secondArgument) ? secondArgument.expression : secondArgument;\n-  if (!ts.isFunctionExpression(factoryFunction)) {\n-    return;\n-  }\n-\n+    output: MagicString, factoryFunction: ts.FunctionExpression, imports: Import[]) {\n   const parameters = factoryFunction.parameters;\n   const parameterString = imports.map(i => i.qualifier.text).join(',');\n   if (parameters.length > 0) {"
        },
        {
            "sha": "f4e16656947e4574a4698c49cdf6b6e095c2edb5",
            "filename": "packages/compiler-cli/ngcc/test/rendering/umd_rendering_formatter_spec.ts",
            "status": "modified",
            "additions": 564,
            "deletions": 492,
            "changes": 1056,
            "blob_url": "https://github.com/angular/angular/blob/6e37c938e29b2ab5c45ce391c775e5a83ac07b36/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Frendering%2Fumd_rendering_formatter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/6e37c938e29b2ab5c45ce391c775e5a83ac07b36/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Frendering%2Fumd_rendering_formatter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Frendering%2Fumd_rendering_formatter_spec.ts?ref=6e37c938e29b2ab5c45ce391c775e5a83ac07b36",
            "patch": "@@ -22,6 +22,10 @@ import {UmdReflectionHost} from '../../src/host/umd_host';\n import {UmdRenderingFormatter} from '../../src/rendering/umd_rendering_formatter';\n import {makeTestEntryPointBundle} from '../helpers/utils';\n \n+interface TestFileSpec extends Omit<TestFile, 'contents'> {\n+  contents: {preamble?: string; wrapperFunction: string; wrapperCallArguments: string;};\n+}\n+\n function setup(file: TestFile) {\n   loadTestFiles([file]);\n   const fs = getFileSystem();\n@@ -50,32 +54,55 @@ function setup(file: TestFile) {\n runInEachFileSystem(() => {\n   describe('UmdRenderingFormatter', () => {\n     let _: typeof absoluteFrom;\n-    let PROGRAM: TestFile;\n-    let PROGRAM_DECORATE_HELPER: TestFile;\n-    let PROGRAM_WITH_GLOBAL_INITIALIZER: TestFile;\n+    let PROGRAM_FILE_SPEC: TestFileSpec;\n+    let PROGRAM_DECORATE_HELPER_FILE_SPEC: TestFileSpec;\n+    let PROGRAM_WITH_GLOBAL_INITIALIZER_FILE_SPEC: TestFileSpec;\n+\n+    // Factories for creating a `TestFile` from a `TestFileSpec` for different UMD formats.\n+    const umdFormatFactories: Record<string, (spec: TestFileSpec) => TestFile> = {\n+      // Old format (parenthesis around call expression): `(function (...) { ... }(...))`\n+      'old format': spec => ({\n+        ...spec,\n+        contents: `${spec.contents.preamble ?? ''}\\n` +\n+            `(${spec.contents.wrapperFunction}(${spec.contents.wrapperCallArguments}));`,\n+      }),\n+\n+      // New format (parenthesis around function expression): `(function (...) { ... })(...)`\n+      'new format': spec => ({\n+        ...spec,\n+        contents: `${spec.contents.preamble ?? ''}\\n` +\n+            `(${spec.contents.wrapperFunction})(${spec.contents.wrapperCallArguments});`,\n+      }),\n+    };\n \n     beforeEach(() => {\n       _ = absoluteFrom;\n \n-      PROGRAM_WITH_GLOBAL_INITIALIZER = {\n+      PROGRAM_WITH_GLOBAL_INITIALIZER_FILE_SPEC = {\n         name: _('/node_modules/test-package/some/file.js'),\n-        contents: `\n-        (function (global, factory) {\n-          typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports,require('some-side-effect'),require('/local-dep'),require('@angular/core')) :\n-          typeof define === 'function' && define.amd ? define('file', ['exports','some-side-effect','/local-dep','@angular/core'], factory) :\n-          (global = global || self, factory(global.file,global.someSideEffect,global.localDep,global.ng.core));\n-          }(this, (function (exports,someSideEffect,localDep,core) {'use strict'; })));`\n+        contents: {\n+          wrapperFunction: `function (global, factory) {\n+  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports,require('some-side-effect'),require('/local-dep'),require('@angular/core')) :\n+  typeof define === 'function' && define.amd ? define('file', ['exports','some-side-effect','/local-dep','@angular/core'], factory) :\n+  (global = global || self, factory(global.file,global.someSideEffect,global.localDep,global.ng.core));\n+  }`,\n+          wrapperCallArguments:\n+              `this, (function (exports,someSideEffect,localDep,core) {'use strict'; })`,\n+        },\n       };\n \n-      PROGRAM = {\n+      PROGRAM_FILE_SPEC = {\n         name: _('/node_modules/test-package/some/file.js'),\n-        contents: `\n-/* A copyright notice */\n-(function (global, factory) {\n+        contents: {\n+          preamble: `\n+/* A copyright notice */`,\n+          wrapperFunction: `function (global, factory) {\n typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports,require('some-side-effect'),require('/local-dep'),require('@angular/core')) :\n typeof define === 'function' && define.amd ? define('file', ['exports','some-side-effect','/local-dep','@angular/core'], factory) :\n (factory(global.file,global.someSideEffect,global.localDep,global.ng.core));\n-}(this, (function (exports,someSideEffect,localDep,core) {'use strict';\n+}`,\n+          wrapperCallArguments:\n+              `this, (function (exports,someSideEffect,localDep,core) {'use strict';\n var A = (function() {\n   function A() {}\n   A.decorators = [\n@@ -132,19 +159,22 @@ exports.B = B;\n exports.C = C;\n exports.NoIife = NoIife;\n exports.BadIife = BadIife;\n-})));`,\n+})`,\n+        },\n       };\n \n \n-      PROGRAM_DECORATE_HELPER = {\n+      PROGRAM_DECORATE_HELPER_FILE_SPEC = {\n         name: _('/node_modules/test-package/some/file.js'),\n-        contents: `\n-/* A copyright notice */\n-(function (global, factory) {\n+        contents: {\n+          preamble: `\n+/* A copyright notice */`,\n+          wrapperFunction: `function (global, factory) {\n typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports,require('tslib'),require('@angular/core')) :\n typeof define === 'function' && define.amd ? define('file', ['exports','/tslib','@angular/core'], factory) :\n (factory(global.file,global.tslib,global.ng.core));\n-}(this, (function (exports,tslib,core) {'use strict';\n+}`,\n+          wrapperCallArguments: `this, (function (exports,tslib,core) {'use strict';\n   var OtherA = function () { return function (node) { }; };\n   var OtherB = function () { return function (node) { }; };\n   var A = /** @class */ (function () {\n@@ -188,216 +218,246 @@ typeof define === 'function' && define.amd ? define('file', ['exports','/tslib',\n   }());\n   exports.D = D;\n   // Some other content\n-})));`\n+})`,\n+        },\n       };\n     });\n \n-    describe('addImports', () => {\n-      it('should append the given imports into the CommonJS factory call', () => {\n-        const {renderer, program} = setup(PROGRAM);\n-        const file = getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n-        const output = new MagicString(PROGRAM.contents);\n-        renderer.addImports(\n-            output,\n-            [\n-              {specifier: '@angular/core', qualifier: ts.createIdentifier('i0')},\n-              {specifier: '@angular/common', qualifier: ts.createIdentifier('i1')}\n-            ],\n-            file);\n-        expect(output.toString())\n-            .toContain(\n-                `typeof exports === 'object' && typeof module !== 'undefined' ? ` +\n-                `factory(require('@angular/core'),require('@angular/common'),exports,require('some-side-effect'),require('/local-dep'),require('@angular/core')) :`);\n-      });\n-\n-      it('should append the given imports into the AMD initialization', () => {\n-        const {renderer, program} = setup(PROGRAM);\n-        const file = getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n-        const output = new MagicString(PROGRAM.contents);\n-        renderer.addImports(\n-            output,\n-            [\n-              {specifier: '@angular/core', qualifier: ts.createIdentifier('i0')},\n-              {specifier: '@angular/common', qualifier: ts.createIdentifier('i1')}\n-            ],\n-            file);\n-        expect(output.toString())\n-            .toContain(\n-                `typeof define === 'function' && define.amd ? define('file', ['@angular/core','@angular/common','exports','some-side-effect','/local-dep','@angular/core'], factory) :`);\n-      });\n-\n-      it('should append the given imports into the global initialization', () => {\n-        const {renderer, program} = setup(PROGRAM);\n-        const file = getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n-        const output = new MagicString(PROGRAM.contents);\n-        renderer.addImports(\n-            output,\n-            [\n-              {specifier: '@angular/core', qualifier: ts.createIdentifier('i0')},\n-              {specifier: '@angular/common', qualifier: ts.createIdentifier('i1')}\n-            ],\n-            file);\n-        expect(output.toString())\n-            .toContain(\n-                `(factory(global.ng.core,global.ng.common,global.file,global.someSideEffect,global.localDep,global.ng.core));`);\n-      });\n-\n-      it('should remap import identifiers to valid global properties', () => {\n-        const {renderer, program} = setup(PROGRAM);\n-        const file = getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n-        const output = new MagicString(PROGRAM.contents);\n-        renderer.addImports(\n-            output,\n-            [\n-              {specifier: '@ngrx/store', qualifier: ts.createIdentifier('i0')}, {\n-                specifier: '@angular/platform-browser-dynamic',\n-                qualifier: ts.createIdentifier('i1')\n+    Object.entries(umdFormatFactories).forEach(([formatLabel, formatFactory]) => {\n+      describe(`(when dealing with ${formatLabel})`, () => {\n+        let PROGRAM: TestFile;\n+        let PROGRAM_DECORATE_HELPER: TestFile;\n+        let PROGRAM_WITH_GLOBAL_INITIALIZER: TestFile;\n+\n+        beforeEach(() => {\n+          PROGRAM = formatFactory(PROGRAM_FILE_SPEC);\n+          PROGRAM_DECORATE_HELPER = formatFactory(PROGRAM_DECORATE_HELPER_FILE_SPEC);\n+          PROGRAM_WITH_GLOBAL_INITIALIZER =\n+              formatFactory(PROGRAM_WITH_GLOBAL_INITIALIZER_FILE_SPEC);\n+        });\n+\n+        describe('addImports', () => {\n+          it('should append the given imports into the CommonJS factory call', () => {\n+            const {renderer, program} = setup(PROGRAM);\n+            const file =\n+                getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n+            const output = new MagicString(PROGRAM.contents);\n+            renderer.addImports(\n+                output,\n+                [\n+                  {specifier: '@angular/core', qualifier: ts.createIdentifier('i0')},\n+                  {specifier: '@angular/common', qualifier: ts.createIdentifier('i1')}\n+                ],\n+                file);\n+            expect(output.toString())\n+                .toContain(\n+                    `typeof exports === 'object' && typeof module !== 'undefined' ? ` +\n+                    `factory(require('@angular/core'),require('@angular/common'),exports,require('some-side-effect'),require('/local-dep'),require('@angular/core')) :`);\n+          });\n+\n+          it('should append the given imports into the AMD initialization', () => {\n+            const {renderer, program} = setup(PROGRAM);\n+            const file =\n+                getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n+            const output = new MagicString(PROGRAM.contents);\n+            renderer.addImports(\n+                output,\n+                [\n+                  {specifier: '@angular/core', qualifier: ts.createIdentifier('i0')},\n+                  {specifier: '@angular/common', qualifier: ts.createIdentifier('i1')}\n+                ],\n+                file);\n+            expect(output.toString())\n+                .toContain(\n+                    `typeof define === 'function' && define.amd ? define('file', ['@angular/core','@angular/common','exports','some-side-effect','/local-dep','@angular/core'], factory) :`);\n+          });\n+\n+          it('should append the given imports into the global initialization', () => {\n+            const {renderer, program} = setup(PROGRAM);\n+            const file =\n+                getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n+            const output = new MagicString(PROGRAM.contents);\n+            renderer.addImports(\n+                output,\n+                [\n+                  {specifier: '@angular/core', qualifier: ts.createIdentifier('i0')},\n+                  {specifier: '@angular/common', qualifier: ts.createIdentifier('i1')}\n+                ],\n+                file);\n+            expect(output.toString())\n+                .toContain(\n+                    `(factory(global.ng.core,global.ng.common,global.file,global.someSideEffect,global.localDep,global.ng.core));`);\n+          });\n+\n+          it('should remap import identifiers to valid global properties', () => {\n+            const {renderer, program} = setup(PROGRAM);\n+            const file =\n+                getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n+            const output = new MagicString(PROGRAM.contents);\n+            renderer.addImports(\n+                output,\n+                [\n+                  {specifier: '@ngrx/store', qualifier: ts.createIdentifier('i0')}, {\n+                    specifier: '@angular/platform-browser-dynamic',\n+                    qualifier: ts.createIdentifier('i1')\n+                  },\n+                  {specifier: '@angular/common/testing', qualifier: ts.createIdentifier('i2')},\n+                  {specifier: '@angular-foo/package', qualifier: ts.createIdentifier('i3')}\n+                ],\n+                file);\n+            expect(output.toString())\n+                .toContain(\n+                    `(factory(` +\n+                    `global.ngrx.store,global.ng.platformBrowserDynamic,global.ng.common.testing,global.angularFoo.package,` +\n+                    `global.file,global.someSideEffect,global.localDep,global.ng.core));`);\n+          });\n+\n+          it('should append the given imports into the global initialization, if it has a global/self initializer',\n+             () => {\n+               const {renderer, program} = setup(PROGRAM_WITH_GLOBAL_INITIALIZER);\n+               const file =\n+                   getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n+               const output = new MagicString(file.text);\n+               renderer.addImports(\n+                   output,\n+                   [\n+                     {specifier: '@angular/core', qualifier: ts.createIdentifier('i0')},\n+                     {specifier: '@angular/common', qualifier: ts.createIdentifier('i1')}\n+                   ],\n+                   file);\n+               expect(output.toString())\n+                   .toContain(\n+                       `(global = global || self, factory(global.ng.core,global.ng.common,global.file,global.someSideEffect,global.localDep,global.ng.core));`);\n+             });\n+\n+          it('should append the given imports as parameters into the factory function definition',\n+             () => {\n+               const {renderer, program} = setup(PROGRAM);\n+               const file =\n+                   getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n+               const output = new MagicString(PROGRAM.contents);\n+               renderer.addImports(\n+                   output,\n+                   [\n+                     {specifier: '@angular/core', qualifier: ts.createIdentifier('i0')},\n+                     {specifier: '@angular/common', qualifier: ts.createIdentifier('i1')}\n+                   ],\n+                   file);\n+               expect(output.toString())\n+                   .toContain(\n+                       `(function (i0,i1,exports,someSideEffect,localDep,core) {'use strict';`);\n+             });\n+\n+          it('should handle the case where there were no prior imports nor exports', () => {\n+            const PROGRAM = formatFactory({\n+              name: _('/node_modules/test-package/some/file.js'),\n+              contents: {\n+                preamble: `\n+                  /* A copyright notice */`,\n+                wrapperFunction: `function (global, factory) {\n+                    typeof exports === 'object' && typeof module !== 'undefined' ? factory() :\n+                    typeof define === 'function' && define.amd ? define('file', factory) :\n+                    (factory());\n+                  }`,\n+                wrapperCallArguments: `this, (function () {'use strict';\n+                    var index = '';\n+                    return index;\n+                  })`,\n               },\n-              {specifier: '@angular/common/testing', qualifier: ts.createIdentifier('i2')},\n-              {specifier: '@angular-foo/package', qualifier: ts.createIdentifier('i3')}\n-            ],\n-            file);\n-        expect(output.toString())\n-            .toContain(\n-                `(factory(` +\n-                `global.ngrx.store,global.ng.platformBrowserDynamic,global.ng.common.testing,global.angularFoo.package,` +\n-                `global.file,global.someSideEffect,global.localDep,global.ng.core));`);\n-      });\n-\n-      it('should append the given imports into the global initialization, if it has a global/self initializer',\n-         () => {\n-           const {renderer, program} = setup(PROGRAM_WITH_GLOBAL_INITIALIZER);\n-           const file = getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n-           const output = new MagicString(file.text);\n-           renderer.addImports(\n-               output,\n-               [\n-                 {specifier: '@angular/core', qualifier: ts.createIdentifier('i0')},\n-                 {specifier: '@angular/common', qualifier: ts.createIdentifier('i1')}\n-               ],\n-               file);\n-           expect(output.toString())\n-               .toContain(\n-                   `(global = global || self, factory(global.ng.core,global.ng.common,global.file,global.someSideEffect,global.localDep,global.ng.core));`);\n-         });\n-\n-      it('should append the given imports as parameters into the factory function definition',\n-         () => {\n-           const {renderer, program} = setup(PROGRAM);\n-           const file = getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n-           const output = new MagicString(PROGRAM.contents);\n-           renderer.addImports(\n-               output,\n-               [\n-                 {specifier: '@angular/core', qualifier: ts.createIdentifier('i0')},\n-                 {specifier: '@angular/common', qualifier: ts.createIdentifier('i1')}\n-               ],\n-               file);\n-           expect(output.toString())\n-               .toContain(`(function (i0,i1,exports,someSideEffect,localDep,core) {'use strict';`);\n-         });\n-\n-      it('should handle the case where there were no prior imports nor exports', () => {\n-        const PROGRAM: TestFile = {\n-          name: _('/node_modules/test-package/some/file.js'),\n-          contents: `\n-          /* A copyright notice */\n-          (function (global, factory) {\n-          typeof exports === 'object' && typeof module !== 'undefined' ? factory() :\n-          typeof define === 'function' && define.amd ? define('file', factory) :\n-          (factory());\n-          }(this, (function () {'use strict';\n-            var index = '';\n-            return index;\n-          })));`,\n-        };\n-        const {renderer, program} = setup(PROGRAM);\n-        const file = getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n-        const output = new MagicString(PROGRAM.contents);\n-        renderer.addImports(\n-            output,\n-            [\n-              {specifier: '@angular/core', qualifier: ts.createIdentifier('i0')},\n-              {specifier: '@angular/common', qualifier: ts.createIdentifier('i1')}\n-            ],\n-            file);\n-        const outputSrc = output.toString();\n-\n-        expect(outputSrc).toContain(\n-            `typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('@angular/common')) :`);\n-        expect(outputSrc).toContain(\n-            `typeof define === 'function' && define.amd ? define('file',['@angular/core','@angular/common'], factory) :`);\n-        expect(outputSrc).toContain(`(factory(global.ng.core,global.ng.common));`);\n-        expect(outputSrc).toContain(`(function (i0,i1) {'use strict';`);\n-      });\n-\n-      it('should leave the file unchanged if there are no imports to add', () => {\n-        const {renderer, program} = setup(PROGRAM);\n-        const file = getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n-        const output = new MagicString(PROGRAM.contents);\n-        const contentsBefore = output.toString();\n-\n-        renderer.addImports(output, [], file);\n-        const contentsAfter = output.toString();\n-\n-        expect(contentsAfter).toBe(contentsBefore);\n-      });\n-\n-      it('should handle the case where not all dependencies are used by the factory', () => {\n-        const PROGRAM: TestFile = {\n-          name: _('/node_modules/test-package/some/file.js'),\n-          contents: `\n-          /* A copyright notice */\n-          /* A copyright notice */\n-          (function (global, factory) {\n-          typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports,require('/local-dep'),require('@angular/core'),require('some-side-effect')) :\n-          typeof define === 'function' && define.amd ? define('file', ['exports','/local-dep','@angular/core','some-side-effect'], factory) :\n-          (factory(global.file,global.localDep,global.ng.core,global.someSideEffect));\n-          }(this, (function (exports,localDep,core) {'use strict';\n-            // Note that someSideEffect is not in the factory function parameter list\n-          })));`,\n-        };\n-        const {renderer, program} = setup(PROGRAM);\n-        const file = getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n-        const output = new MagicString(PROGRAM.contents);\n-        renderer.addImports(\n-            output,\n-            [\n-              {specifier: '@angular/core', qualifier: ts.createIdentifier('i0')},\n-              {specifier: '@angular/common', qualifier: ts.createIdentifier('i1')}\n-            ],\n-            file);\n-        const outputSrc = output.toString();\n-\n-        expect(outputSrc).toContain(\n-            `typeof exports === 'object' && typeof module !== 'undefined' ? ` +\n-            `factory(require('@angular/core'),require('@angular/common'),exports,require('/local-dep'),require('@angular/core'),require('some-side-effect')) :`);\n-        expect(outputSrc).toContain(\n-            `typeof define === 'function' && define.amd ? define('file', ` +\n-            `['@angular/core','@angular/common','exports','/local-dep','@angular/core','some-side-effect'], factory) :`);\n-        expect(outputSrc).toContain(\n-            `(factory(global.ng.core,global.ng.common,global.file,global.localDep,global.ng.core,global.someSideEffect));`);\n-        expect(outputSrc).toContain(`(function (i0,i1,exports,localDep,core) {'use strict';`);\n-      });\n-    });\n-\n-    describe('addExports', () => {\n-      it('should insert the given exports at the end of the source file', () => {\n-        const {importManager, renderer, sourceFile} = setup(PROGRAM);\n-        const output = new MagicString(PROGRAM.contents);\n-        const generateNamedImportSpy =\n-            spyOn(importManager, 'generateNamedImport').and.callThrough();\n-        renderer.addExports(\n-            output, PROGRAM.name.replace(/\\.js$/, ''),\n-            [\n-              {from: _('/node_modules/test-package/some/a.js'), identifier: 'ComponentA1'},\n-              {from: _('/node_modules/test-package/some/a.js'), identifier: 'ComponentA2'},\n-              {from: _('/node_modules/test-package/some/foo/b.js'), identifier: 'ComponentB'},\n-              {from: PROGRAM.name, identifier: 'TopLevelComponent'},\n-            ],\n-            importManager, sourceFile);\n-\n-        expect(output.toString()).toContain(`\n+            });\n+            const {renderer, program} = setup(PROGRAM);\n+            const file =\n+                getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n+            const output = new MagicString(PROGRAM.contents);\n+            renderer.addImports(\n+                output,\n+                [\n+                  {specifier: '@angular/core', qualifier: ts.createIdentifier('i0')},\n+                  {specifier: '@angular/common', qualifier: ts.createIdentifier('i1')}\n+                ],\n+                file);\n+            const outputSrc = output.toString();\n+\n+            expect(outputSrc).toContain(\n+                `typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('@angular/common')) :`);\n+            expect(outputSrc).toContain(\n+                `typeof define === 'function' && define.amd ? define('file',['@angular/core','@angular/common'], factory) :`);\n+            expect(outputSrc).toContain(`(factory(global.ng.core,global.ng.common));`);\n+            expect(outputSrc).toContain(`(function (i0,i1) {'use strict';`);\n+          });\n+\n+          it('should leave the file unchanged if there are no imports to add', () => {\n+            const {renderer, program} = setup(PROGRAM);\n+            const file =\n+                getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n+            const output = new MagicString(PROGRAM.contents);\n+            const contentsBefore = output.toString();\n+\n+            renderer.addImports(output, [], file);\n+            const contentsAfter = output.toString();\n+\n+            expect(contentsAfter).toBe(contentsBefore);\n+          });\n+\n+          it('should handle the case where not all dependencies are used by the factory', () => {\n+            const PROGRAM = formatFactory({\n+              name: _('/node_modules/test-package/some/file.js'),\n+              contents: {\n+                preamble: `\n+                  /* A copyright notice */\n+                  /* A copyright notice */`,\n+                wrapperFunction: `function (global, factory) {\n+                    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports,require('/local-dep'),require('@angular/core'),require('some-side-effect')) :\n+                    typeof define === 'function' && define.amd ? define('file', ['exports','/local-dep','@angular/core','some-side-effect'], factory) :\n+                    (factory(global.file,global.localDep,global.ng.core,global.someSideEffect));\n+                  }`,\n+                wrapperCallArguments: `this, (function (exports,localDep,core) {'use strict';\n+                    // Note that someSideEffect is not in the factory function parameter list\n+                  })`,\n+              },\n+            });\n+            const {renderer, program} = setup(PROGRAM);\n+            const file =\n+                getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n+            const output = new MagicString(PROGRAM.contents);\n+            renderer.addImports(\n+                output,\n+                [\n+                  {specifier: '@angular/core', qualifier: ts.createIdentifier('i0')},\n+                  {specifier: '@angular/common', qualifier: ts.createIdentifier('i1')}\n+                ],\n+                file);\n+            const outputSrc = output.toString();\n+\n+            expect(outputSrc).toContain(\n+                `typeof exports === 'object' && typeof module !== 'undefined' ? ` +\n+                `factory(require('@angular/core'),require('@angular/common'),exports,require('/local-dep'),require('@angular/core'),require('some-side-effect')) :`);\n+            expect(outputSrc).toContain(\n+                `typeof define === 'function' && define.amd ? define('file', ` +\n+                `['@angular/core','@angular/common','exports','/local-dep','@angular/core','some-side-effect'], factory) :`);\n+            expect(outputSrc).toContain(\n+                `(factory(global.ng.core,global.ng.common,global.file,global.localDep,global.ng.core,global.someSideEffect));`);\n+            expect(outputSrc).toContain(`(function (i0,i1,exports,localDep,core) {'use strict';`);\n+          });\n+        });\n+\n+        describe('addExports', () => {\n+          it('should insert the given exports at the end of the source file', () => {\n+            const {importManager, renderer, sourceFile} = setup(PROGRAM);\n+            const output = new MagicString(PROGRAM.contents);\n+            const generateNamedImportSpy =\n+                spyOn(importManager, 'generateNamedImport').and.callThrough();\n+            renderer.addExports(\n+                output, PROGRAM.name.replace(/\\.js$/, ''),\n+                [\n+                  {from: _('/node_modules/test-package/some/a.js'), identifier: 'ComponentA1'},\n+                  {from: _('/node_modules/test-package/some/a.js'), identifier: 'ComponentA2'},\n+                  {from: _('/node_modules/test-package/some/foo/b.js'), identifier: 'ComponentB'},\n+                  {from: PROGRAM.name, identifier: 'TopLevelComponent'},\n+                ],\n+                importManager, sourceFile);\n+\n+            expect(output.toString()).toContain(`\n exports.A = A;\n exports.B = B;\n exports.C = C;\n@@ -407,284 +467,296 @@ exports.ComponentA1 = i0.ComponentA1;\n exports.ComponentA2 = i0.ComponentA2;\n exports.ComponentB = i1.ComponentB;\n exports.TopLevelComponent = TopLevelComponent;\n-})));`);\n-\n-        expect(generateNamedImportSpy).toHaveBeenCalledWith('./a', 'ComponentA1');\n-        expect(generateNamedImportSpy).toHaveBeenCalledWith('./a', 'ComponentA2');\n-        expect(generateNamedImportSpy).toHaveBeenCalledWith('./foo/b', 'ComponentB');\n-      });\n-    });\n-\n-    describe('addConstants', () => {\n-      it('should insert the given constants after imports in the source file', () => {\n-        const {renderer, program} = setup(PROGRAM);\n-        const file = getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n-        const output = new MagicString(PROGRAM.contents);\n-        renderer.addConstants(output, 'var x = 3;', file);\n-        expect(output.toString()).toContain(`\n-}(this, (function (exports,someSideEffect,localDep,core) {\n+}))`);\n+\n+            expect(generateNamedImportSpy).toHaveBeenCalledWith('./a', 'ComponentA1');\n+            expect(generateNamedImportSpy).toHaveBeenCalledWith('./a', 'ComponentA2');\n+            expect(generateNamedImportSpy).toHaveBeenCalledWith('./foo/b', 'ComponentB');\n+          });\n+        });\n+\n+        describe('addConstants', () => {\n+          it('should insert the given constants after imports in the source file', () => {\n+            const {renderer, program} = setup(PROGRAM);\n+            const file =\n+                getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n+            const output = new MagicString(PROGRAM.contents);\n+            renderer.addConstants(output, 'var x = 3;', file);\n+            expect(output.toString())\n+                .toContain(`(this, (function (exports,someSideEffect,localDep,core) {\n var x = 3;\n 'use strict';\n var A = (function() {`);\n-      });\n-\n-      it('should insert constants after inserted imports',\n-         () => {\n-             // This test (from ESM5) is not needed as constants go in the body\n-             // of the UMD IIFE, so cannot come before imports.\n-         });\n-    });\n-\n-    describe('rewriteSwitchableDeclarations', () => {\n-      it('should switch marked declaration initializers', () => {\n-        const {renderer, program, sourceFile, switchMarkerAnalyses} = setup(PROGRAM);\n-        const file = getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n-        const output = new MagicString(PROGRAM.contents);\n-        renderer.rewriteSwitchableDeclarations(\n-            output, file, switchMarkerAnalyses.get(sourceFile)!.declarations);\n-        expect(output.toString())\n-            .not.toContain(`var compileNgModuleFactory = compileNgModuleFactory__PRE_R3__;`);\n-        expect(output.toString())\n-            .toContain(`var badlyFormattedVariable = __PRE_R3__badlyFormattedVariable;`);\n-        expect(output.toString())\n-            .toContain(`var compileNgModuleFactory = compileNgModuleFactory__POST_R3__;`);\n-        expect(output.toString())\n-            .toContain(\n-                `function compileNgModuleFactory__PRE_R3__(injector, options, moduleType) {`);\n-        expect(output.toString())\n-            .toContain(\n-                `function compileNgModuleFactory__POST_R3__(injector, options, moduleType) {`);\n-      });\n-    });\n-\n-    describe('addDefinitions', () => {\n-      it('should insert the definitions directly before the return statement of the class IIFE',\n-         () => {\n-           const {renderer, decorationAnalyses, sourceFile} = setup(PROGRAM);\n-           const output = new MagicString(PROGRAM.contents);\n-           const compiledClass =\n-               decorationAnalyses.get(sourceFile)!.compiledClasses.find(c => c.name === 'A')!;\n-           renderer.addDefinitions(output, compiledClass, 'SOME DEFINITION TEXT');\n-           expect(output.toString()).toContain(`\n+          });\n+\n+          it('should insert constants after inserted imports',\n+             () => {\n+                 // This test (from ESM5) is not needed as constants go in the body\n+                 // of the UMD IIFE, so cannot come before imports.\n+             });\n+        });\n+\n+        describe('rewriteSwitchableDeclarations', () => {\n+          it('should switch marked declaration initializers', () => {\n+            const {renderer, program, sourceFile, switchMarkerAnalyses} = setup(PROGRAM);\n+            const file =\n+                getSourceFileOrError(program, _('/node_modules/test-package/some/file.js'));\n+            const output = new MagicString(PROGRAM.contents);\n+            renderer.rewriteSwitchableDeclarations(\n+                output, file, switchMarkerAnalyses.get(sourceFile)!.declarations);\n+            expect(output.toString())\n+                .not.toContain(`var compileNgModuleFactory = compileNgModuleFactory__PRE_R3__;`);\n+            expect(output.toString())\n+                .toContain(`var badlyFormattedVariable = __PRE_R3__badlyFormattedVariable;`);\n+            expect(output.toString())\n+                .toContain(`var compileNgModuleFactory = compileNgModuleFactory__POST_R3__;`);\n+            expect(output.toString())\n+                .toContain(\n+                    `function compileNgModuleFactory__PRE_R3__(injector, options, moduleType) {`);\n+            expect(output.toString())\n+                .toContain(\n+                    `function compileNgModuleFactory__POST_R3__(injector, options, moduleType) {`);\n+          });\n+        });\n+\n+        describe('addDefinitions', () => {\n+          it('should insert the definitions directly before the return statement of the class IIFE',\n+             () => {\n+               const {renderer, decorationAnalyses, sourceFile} = setup(PROGRAM);\n+               const output = new MagicString(PROGRAM.contents);\n+               const compiledClass =\n+                   decorationAnalyses.get(sourceFile)!.compiledClasses.find(c => c.name === 'A')!;\n+               renderer.addDefinitions(output, compiledClass, 'SOME DEFINITION TEXT');\n+               expect(output.toString()).toContain(`\n   A.prototype.ngDoCheck = function() {\n     //\n   };\n SOME DEFINITION TEXT\n   return A;\n `);\n-         });\n-\n-      it('should error if the compiledClass is not valid', () => {\n-        const {renderer, sourceFile, program} = setup(PROGRAM);\n-        const output = new MagicString(PROGRAM.contents);\n-\n-        const noIifeDeclaration = getDeclaration(\n-            program, absoluteFromSourceFile(sourceFile), 'NoIife', ts.isFunctionDeclaration);\n-        const mockNoIifeClass: any = {declaration: noIifeDeclaration, name: 'NoIife'};\n-        expect(() => renderer.addDefinitions(output, mockNoIifeClass, 'SOME DEFINITION TEXT'))\n-            .toThrowError(\n-                `Compiled class \"NoIife\" in \"${\n-                    _('/node_modules/test-package/some/file.js')}\" does not have a valid syntax.\\n` +\n-                `Expected an ES5 IIFE wrapped function. But got:\\n` +\n-                `function NoIife() {}`);\n-\n-        const badIifeDeclaration = getDeclaration(\n-            program, absoluteFromSourceFile(sourceFile), 'BadIife', ts.isVariableDeclaration);\n-        const mockBadIifeClass: any = {declaration: badIifeDeclaration, name: 'BadIife'};\n-        expect(() => renderer.addDefinitions(output, mockBadIifeClass, 'SOME DEFINITION TEXT'))\n-            .toThrowError(\n-                `Compiled class wrapper IIFE does not have a return statement: BadIife in ${\n-                    _('/node_modules/test-package/some/file.js')}`);\n-      });\n-    });\n-\n-    describe('addAdjacentStatements', () => {\n-      const contents = `(function (global, factory) {\\n` +\n-          `  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports,require('tslib'),require('@angular/core')) :\\n` +\n-          `  typeof define === 'function' && define.amd ? define('file', ['exports','/tslib','@angular/core'], factory) :\\n` +\n-          `  (factory(global.file,global.tslib,global.ng.core));\\n` +\n-          `  }(this, (function (exports,tslib,core) {'use strict';\\n` +\n-          `\\n` +\n-          `  var SomeDirective = /** @class **/ (function () {\\n` +\n-          `    function SomeDirective(zone, cons) {}\\n` +\n-          `    SomeDirective.prototype.method = function() {}\\n` +\n-          `    SomeDirective.decorators = [\\n` +\n-          `      { type: core.Directive, args: [{ selector: '[a]' }] },\\n` +\n-          `      { type: OtherA }\\n` +\n-          `    ];\\n` +\n-          `    SomeDirective.ctorParameters = function() { return [\\n` +\n-          `      { type: core.NgZone },\\n` +\n-          `      { type: core.Console }\\n` +\n-          `    ]; };\\n` +\n-          `    return SomeDirective;\\n` +\n-          `  }());\\n` +\n-          `  exports.SomeDirective = SomeDirective;\\n` +\n-          `})));`;\n-\n-      it('should insert the statements after all the static methods of the class', () => {\n-        const program = {name: _('/node_modules/test-package/some/file.js'), contents};\n-        const {renderer, decorationAnalyses, sourceFile} = setup(program);\n-        const output = new MagicString(contents);\n-        const compiledClass = decorationAnalyses.get(sourceFile)!.compiledClasses.find(\n-            c => c.name === 'SomeDirective')!;\n-        renderer.addAdjacentStatements(output, compiledClass, 'SOME STATEMENTS');\n-        expect(output.toString())\n-            .toContain(\n+             });\n+\n+          it('should error if the compiledClass is not valid', () => {\n+            const {renderer, sourceFile, program} = setup(PROGRAM);\n+            const output = new MagicString(PROGRAM.contents);\n+\n+            const noIifeDeclaration = getDeclaration(\n+                program, absoluteFromSourceFile(sourceFile), 'NoIife', ts.isFunctionDeclaration);\n+            const mockNoIifeClass: any = {declaration: noIifeDeclaration, name: 'NoIife'};\n+            expect(() => renderer.addDefinitions(output, mockNoIifeClass, 'SOME DEFINITION TEXT'))\n+                .toThrowError(\n+                    `Compiled class \"NoIife\" in \"${\n+                        _('/node_modules/test-package/some/file.js')}\" does not have a valid syntax.\\n` +\n+                    `Expected an ES5 IIFE wrapped function. But got:\\n` +\n+                    `function NoIife() {}`);\n+\n+            const badIifeDeclaration = getDeclaration(\n+                program, absoluteFromSourceFile(sourceFile), 'BadIife', ts.isVariableDeclaration);\n+            const mockBadIifeClass: any = {declaration: badIifeDeclaration, name: 'BadIife'};\n+            expect(() => renderer.addDefinitions(output, mockBadIifeClass, 'SOME DEFINITION TEXT'))\n+                .toThrowError(\n+                    `Compiled class wrapper IIFE does not have a return statement: BadIife in ${\n+                        _('/node_modules/test-package/some/file.js')}`);\n+          });\n+        });\n+\n+        describe('addAdjacentStatements', () => {\n+          const contents: TestFileSpec['contents'] = {\n+            wrapperFunction: `function (global, factory) {\\n` +\n+                `  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports,require('tslib'),require('@angular/core')) :\\n` +\n+                `  typeof define === 'function' && define.amd ? define('file', ['exports','/tslib','@angular/core'], factory) :\\n` +\n+                `  (factory(global.file,global.tslib,global.ng.core));\\n` +\n+                `  }`,\n+            wrapperCallArguments: `this, (function (exports,tslib,core) {'use strict';\\n` +\n+                `\\n` +\n+                `  var SomeDirective = /** @class **/ (function () {\\n` +\n+                `    function SomeDirective(zone, cons) {}\\n` +\n+                `    SomeDirective.prototype.method = function() {}\\n` +\n+                `    SomeDirective.decorators = [\\n` +\n+                `      { type: core.Directive, args: [{ selector: '[a]' }] },\\n` +\n+                `      { type: OtherA }\\n` +\n+                `    ];\\n` +\n                 `    SomeDirective.ctorParameters = function() { return [\\n` +\n                 `      { type: core.NgZone },\\n` +\n                 `      { type: core.Console }\\n` +\n                 `    ]; };\\n` +\n-                `SOME STATEMENTS\\n` +\n-                `    return SomeDirective;\\n`);\n-      });\n-\n-      it('should insert the statements after any definitions', () => {\n-        const program = {name: _('/node_modules/test-package/some/file.js'), contents};\n-        const {renderer, decorationAnalyses, sourceFile} = setup(program);\n-        const output = new MagicString(contents);\n-        const compiledClass = decorationAnalyses.get(sourceFile)!.compiledClasses.find(\n-            c => c.name === 'SomeDirective')!;\n-        renderer.addDefinitions(output, compiledClass, 'SOME DEFINITIONS');\n-        renderer.addAdjacentStatements(output, compiledClass, 'SOME STATEMENTS');\n-        const definitionsPosition = output.toString().indexOf('SOME DEFINITIONS');\n-        const statementsPosition = output.toString().indexOf('SOME STATEMENTS');\n-        expect(definitionsPosition).not.toEqual(-1, 'definitions should exist');\n-        expect(statementsPosition).not.toEqual(-1, 'statements should exist');\n-        expect(statementsPosition).toBeGreaterThan(definitionsPosition);\n-      });\n-    });\n-\n-    describe('removeDecorators', () => {\n-      it('should delete the decorator (and following comma) that was matched in the analysis',\n-         () => {\n-           const {renderer, decorationAnalyses, sourceFile} = setup(PROGRAM);\n-           const output = new MagicString(PROGRAM.contents);\n-           const compiledClass =\n-               decorationAnalyses.get(sourceFile)!.compiledClasses.find(c => c.name === 'A')!;\n-           const decorator = compiledClass.decorators![0];\n-           const decoratorsToRemove = new Map<ts.Node, ts.Node[]>();\n-           decoratorsToRemove.set(decorator.node!.parent!, [decorator.node!]);\n-           renderer.removeDecorators(output, decoratorsToRemove);\n-           expect(output.toString())\n-               .not.toContain(`{ type: core.Directive, args: [{ selector: '[a]' }] },`);\n-           expect(output.toString()).toContain(`{ type: OtherA }`);\n-           expect(output.toString())\n-               .toContain(`{ type: core.Directive, args: [{ selector: '[b]' }] }`);\n-           expect(output.toString()).toContain(`{ type: OtherB }`);\n-           expect(output.toString())\n-               .toContain(`{ type: core.Directive, args: [{ selector: '[c]' }] }`);\n-         });\n-\n-\n-      it('should delete the decorator (but cope with no trailing comma) that was matched in the analysis',\n-         () => {\n-           const {renderer, decorationAnalyses, sourceFile} = setup(PROGRAM);\n-           const output = new MagicString(PROGRAM.contents);\n-           const compiledClass =\n-               decorationAnalyses.get(sourceFile)!.compiledClasses.find(c => c.name === 'B')!;\n-           const decorator = compiledClass.decorators![0];\n-           const decoratorsToRemove = new Map<ts.Node, ts.Node[]>();\n-           decoratorsToRemove.set(decorator.node!.parent!, [decorator.node!]);\n-           renderer.removeDecorators(output, decoratorsToRemove);\n-           expect(output.toString())\n-               .toContain(`{ type: core.Directive, args: [{ selector: '[a]' }] },`);\n-           expect(output.toString()).toContain(`{ type: OtherA }`);\n-           expect(output.toString())\n-               .not.toContain(`{ type: core.Directive, args: [{ selector: '[b]' }] }`);\n-           expect(output.toString()).toContain(`{ type: OtherB }`);\n-           expect(output.toString())\n-               .toContain(`{ type: core.Directive, args: [{ selector: '[c]' }] }`);\n-         });\n-\n-\n-      it('should delete the decorator (and its container if there are not other decorators left) that was matched in the analysis',\n-         () => {\n-           const {renderer, decorationAnalyses, sourceFile} = setup(PROGRAM);\n-           const output = new MagicString(PROGRAM.contents);\n-           const compiledClass =\n-               decorationAnalyses.get(sourceFile)!.compiledClasses.find(c => c.name === 'C')!;\n-           const decorator = compiledClass.decorators![0];\n-           const decoratorsToRemove = new Map<ts.Node, ts.Node[]>();\n-           decoratorsToRemove.set(decorator.node!.parent!, [decorator.node!]);\n-           renderer.removeDecorators(output, decoratorsToRemove);\n-           renderer.addDefinitions(output, compiledClass, 'SOME DEFINITION TEXT');\n-           expect(output.toString())\n-               .toContain(`{ type: core.Directive, args: [{ selector: '[a]' }] },`);\n-           expect(output.toString()).toContain(`{ type: OtherA }`);\n-           expect(output.toString())\n-               .toContain(`{ type: core.Directive, args: [{ selector: '[b]' }] }`);\n-           expect(output.toString()).toContain(`{ type: OtherB }`);\n-           expect(output.toString()).not.toContain(`C.decorators`);\n-         });\n-    });\n-\n-    describe('[__decorate declarations]', () => {\n-      it('should delete the decorator (and following comma) that was matched in the analysis',\n-         () => {\n-           const {renderer, decorationAnalyses, sourceFile} = setup(PROGRAM_DECORATE_HELPER);\n-           const output = new MagicString(PROGRAM_DECORATE_HELPER.contents);\n-           const compiledClass =\n-               decorationAnalyses.get(sourceFile)!.compiledClasses.find(c => c.name === 'A')!;\n-           const decorator = compiledClass.decorators!.find(d => d.name === 'Directive')!;\n-           const decoratorsToRemove = new Map<ts.Node, ts.Node[]>();\n-           decoratorsToRemove.set(decorator.node!.parent!, [decorator.node!]);\n-           renderer.removeDecorators(output, decoratorsToRemove);\n-           expect(output.toString()).not.toContain(`core.Directive({ selector: '[a]' }),`);\n-           expect(output.toString()).toContain(`OtherA()`);\n-           expect(output.toString()).toContain(`core.Directive({ selector: '[b]' })`);\n-           expect(output.toString()).toContain(`OtherB()`);\n-           expect(output.toString()).toContain(`core.Directive({ selector: '[c]' })`);\n-         });\n-\n-      it('should delete the decorator (but cope with no trailing comma) that was matched in the analysis',\n-         () => {\n-           const {renderer, decorationAnalyses, sourceFile} = setup(PROGRAM_DECORATE_HELPER);\n-           const output = new MagicString(PROGRAM_DECORATE_HELPER.contents);\n-           const compiledClass =\n-               decorationAnalyses.get(sourceFile)!.compiledClasses.find(c => c.name === 'B')!;\n-           const decorator = compiledClass.decorators!.find(d => d.name === 'Directive')!;\n-           const decoratorsToRemove = new Map<ts.Node, ts.Node[]>();\n-           decoratorsToRemove.set(decorator.node!.parent!, [decorator.node!]);\n-           renderer.removeDecorators(output, decoratorsToRemove);\n-           expect(output.toString()).toContain(`core.Directive({ selector: '[a]' }),`);\n-           expect(output.toString()).toContain(`OtherA()`);\n-           expect(output.toString()).not.toContain(`core.Directive({ selector: '[b]' })`);\n-           expect(output.toString()).toContain(`OtherB()`);\n-           expect(output.toString()).toContain(`core.Directive({ selector: '[c]' })`);\n-         });\n-\n-\n-      it('should delete the decorator (and its container if there are no other decorators left) that was matched in the analysis',\n-         () => {\n-           const {renderer, decorationAnalyses, sourceFile} = setup(PROGRAM_DECORATE_HELPER);\n-           const output = new MagicString(PROGRAM_DECORATE_HELPER.contents);\n-           const compiledClass =\n-               decorationAnalyses.get(sourceFile)!.compiledClasses.find(c => c.name === 'C')!;\n-           const decorator = compiledClass.decorators!.find(d => d.name === 'Directive')!;\n-           const decoratorsToRemove = new Map<ts.Node, ts.Node[]>();\n-           decoratorsToRemove.set(decorator.node!.parent!, [decorator.node!]);\n-           renderer.removeDecorators(output, decoratorsToRemove);\n-           expect(output.toString()).toContain(`core.Directive({ selector: '[a]' }),`);\n-           expect(output.toString()).toContain(`OtherA()`);\n-           expect(output.toString()).toContain(`core.Directive({ selector: '[b]' })`);\n-           expect(output.toString()).toContain(`OtherB()`);\n-           expect(output.toString()).not.toContain(`core.Directive({ selector: '[c]' })`);\n-           expect(output.toString()).not.toContain(`C = tslib_1.__decorate([`);\n-           expect(output.toString()).toContain(`function C() {\\n      }\\n      return C;`);\n-         });\n-    });\n-\n-    describe('printStatement', () => {\n-      it('should transpile code to ES5', () => {\n-        const {renderer, sourceFile, importManager} = setup(PROGRAM);\n-\n-        const stmt1 = new DeclareVarStmt('foo', new LiteralExpr(42), null, [StmtModifier.Static]);\n-        const stmt2 = new DeclareVarStmt('bar', new LiteralExpr(true));\n-        const stmt3 = new DeclareVarStmt('baz', new LiteralExpr('qux'), undefined, []);\n-\n-        expect(renderer.printStatement(stmt1, sourceFile, importManager)).toBe('var foo = 42;');\n-        expect(renderer.printStatement(stmt2, sourceFile, importManager)).toBe('var bar = true;');\n-        expect(renderer.printStatement(stmt3, sourceFile, importManager)).toBe('var baz = \"qux\";');\n+                `    return SomeDirective;\\n` +\n+                `  }());\\n` +\n+                `  exports.SomeDirective = SomeDirective;\\n` +\n+                `})`,\n+          };\n+\n+          it('should insert the statements after all the static methods of the class', () => {\n+            const program =\n+                formatFactory({name: _('/node_modules/test-package/some/file.js'), contents});\n+            const {renderer, decorationAnalyses, sourceFile} = setup(program);\n+            const output = new MagicString(program.contents);\n+            const compiledClass = decorationAnalyses.get(sourceFile)!.compiledClasses.find(\n+                c => c.name === 'SomeDirective')!;\n+            renderer.addAdjacentStatements(output, compiledClass, 'SOME STATEMENTS');\n+            expect(output.toString())\n+                .toContain(\n+                    `    SomeDirective.ctorParameters = function() { return [\\n` +\n+                    `      { type: core.NgZone },\\n` +\n+                    `      { type: core.Console }\\n` +\n+                    `    ]; };\\n` +\n+                    `SOME STATEMENTS\\n` +\n+                    `    return SomeDirective;\\n`);\n+          });\n+\n+          it('should insert the statements after any definitions', () => {\n+            const program =\n+                formatFactory({name: _('/node_modules/test-package/some/file.js'), contents});\n+            const {renderer, decorationAnalyses, sourceFile} = setup(program);\n+            const output = new MagicString(program.contents);\n+            const compiledClass = decorationAnalyses.get(sourceFile)!.compiledClasses.find(\n+                c => c.name === 'SomeDirective')!;\n+            renderer.addDefinitions(output, compiledClass, 'SOME DEFINITIONS');\n+            renderer.addAdjacentStatements(output, compiledClass, 'SOME STATEMENTS');\n+            const definitionsPosition = output.toString().indexOf('SOME DEFINITIONS');\n+            const statementsPosition = output.toString().indexOf('SOME STATEMENTS');\n+            expect(definitionsPosition).not.toEqual(-1, 'definitions should exist');\n+            expect(statementsPosition).not.toEqual(-1, 'statements should exist');\n+            expect(statementsPosition).toBeGreaterThan(definitionsPosition);\n+          });\n+        });\n+\n+        describe('removeDecorators', () => {\n+          it('should delete the decorator (and following comma) that was matched in the analysis',\n+             () => {\n+               const {renderer, decorationAnalyses, sourceFile} = setup(PROGRAM);\n+               const output = new MagicString(PROGRAM.contents);\n+               const compiledClass =\n+                   decorationAnalyses.get(sourceFile)!.compiledClasses.find(c => c.name === 'A')!;\n+               const decorator = compiledClass.decorators![0];\n+               const decoratorsToRemove = new Map<ts.Node, ts.Node[]>();\n+               decoratorsToRemove.set(decorator.node!.parent!, [decorator.node!]);\n+               renderer.removeDecorators(output, decoratorsToRemove);\n+               expect(output.toString())\n+                   .not.toContain(`{ type: core.Directive, args: [{ selector: '[a]' }] },`);\n+               expect(output.toString()).toContain(`{ type: OtherA }`);\n+               expect(output.toString())\n+                   .toContain(`{ type: core.Directive, args: [{ selector: '[b]' }] }`);\n+               expect(output.toString()).toContain(`{ type: OtherB }`);\n+               expect(output.toString())\n+                   .toContain(`{ type: core.Directive, args: [{ selector: '[c]' }] }`);\n+             });\n+\n+\n+          it('should delete the decorator (but cope with no trailing comma) that was matched in the analysis',\n+             () => {\n+               const {renderer, decorationAnalyses, sourceFile} = setup(PROGRAM);\n+               const output = new MagicString(PROGRAM.contents);\n+               const compiledClass =\n+                   decorationAnalyses.get(sourceFile)!.compiledClasses.find(c => c.name === 'B')!;\n+               const decorator = compiledClass.decorators![0];\n+               const decoratorsToRemove = new Map<ts.Node, ts.Node[]>();\n+               decoratorsToRemove.set(decorator.node!.parent!, [decorator.node!]);\n+               renderer.removeDecorators(output, decoratorsToRemove);\n+               expect(output.toString())\n+                   .toContain(`{ type: core.Directive, args: [{ selector: '[a]' }] },`);\n+               expect(output.toString()).toContain(`{ type: OtherA }`);\n+               expect(output.toString())\n+                   .not.toContain(`{ type: core.Directive, args: [{ selector: '[b]' }] }`);\n+               expect(output.toString()).toContain(`{ type: OtherB }`);\n+               expect(output.toString())\n+                   .toContain(`{ type: core.Directive, args: [{ selector: '[c]' }] }`);\n+             });\n+\n+\n+          it('should delete the decorator (and its container if there are not other decorators left) that was matched in the analysis',\n+             () => {\n+               const {renderer, decorationAnalyses, sourceFile} = setup(PROGRAM);\n+               const output = new MagicString(PROGRAM.contents);\n+               const compiledClass =\n+                   decorationAnalyses.get(sourceFile)!.compiledClasses.find(c => c.name === 'C')!;\n+               const decorator = compiledClass.decorators![0];\n+               const decoratorsToRemove = new Map<ts.Node, ts.Node[]>();\n+               decoratorsToRemove.set(decorator.node!.parent!, [decorator.node!]);\n+               renderer.removeDecorators(output, decoratorsToRemove);\n+               renderer.addDefinitions(output, compiledClass, 'SOME DEFINITION TEXT');\n+               expect(output.toString())\n+                   .toContain(`{ type: core.Directive, args: [{ selector: '[a]' }] },`);\n+               expect(output.toString()).toContain(`{ type: OtherA }`);\n+               expect(output.toString())\n+                   .toContain(`{ type: core.Directive, args: [{ selector: '[b]' }] }`);\n+               expect(output.toString()).toContain(`{ type: OtherB }`);\n+               expect(output.toString()).not.toContain(`C.decorators`);\n+             });\n+        });\n+\n+        describe('[__decorate declarations]', () => {\n+          it('should delete the decorator (and following comma) that was matched in the analysis',\n+             () => {\n+               const {renderer, decorationAnalyses, sourceFile} = setup(PROGRAM_DECORATE_HELPER);\n+               const output = new MagicString(PROGRAM_DECORATE_HELPER.contents);\n+               const compiledClass =\n+                   decorationAnalyses.get(sourceFile)!.compiledClasses.find(c => c.name === 'A')!;\n+               const decorator = compiledClass.decorators!.find(d => d.name === 'Directive')!;\n+               const decoratorsToRemove = new Map<ts.Node, ts.Node[]>();\n+               decoratorsToRemove.set(decorator.node!.parent!, [decorator.node!]);\n+               renderer.removeDecorators(output, decoratorsToRemove);\n+               expect(output.toString()).not.toContain(`core.Directive({ selector: '[a]' }),`);\n+               expect(output.toString()).toContain(`OtherA()`);\n+               expect(output.toString()).toContain(`core.Directive({ selector: '[b]' })`);\n+               expect(output.toString()).toContain(`OtherB()`);\n+               expect(output.toString()).toContain(`core.Directive({ selector: '[c]' })`);\n+             });\n+\n+          it('should delete the decorator (but cope with no trailing comma) that was matched in the analysis',\n+             () => {\n+               const {renderer, decorationAnalyses, sourceFile} = setup(PROGRAM_DECORATE_HELPER);\n+               const output = new MagicString(PROGRAM_DECORATE_HELPER.contents);\n+               const compiledClass =\n+                   decorationAnalyses.get(sourceFile)!.compiledClasses.find(c => c.name === 'B')!;\n+               const decorator = compiledClass.decorators!.find(d => d.name === 'Directive')!;\n+               const decoratorsToRemove = new Map<ts.Node, ts.Node[]>();\n+               decoratorsToRemove.set(decorator.node!.parent!, [decorator.node!]);\n+               renderer.removeDecorators(output, decoratorsToRemove);\n+               expect(output.toString()).toContain(`core.Directive({ selector: '[a]' }),`);\n+               expect(output.toString()).toContain(`OtherA()`);\n+               expect(output.toString()).not.toContain(`core.Directive({ selector: '[b]' })`);\n+               expect(output.toString()).toContain(`OtherB()`);\n+               expect(output.toString()).toContain(`core.Directive({ selector: '[c]' })`);\n+             });\n+\n+\n+          it('should delete the decorator (and its container if there are no other decorators left) that was matched in the analysis',\n+             () => {\n+               const {renderer, decorationAnalyses, sourceFile} = setup(PROGRAM_DECORATE_HELPER);\n+               const output = new MagicString(PROGRAM_DECORATE_HELPER.contents);\n+               const compiledClass =\n+                   decorationAnalyses.get(sourceFile)!.compiledClasses.find(c => c.name === 'C')!;\n+               const decorator = compiledClass.decorators!.find(d => d.name === 'Directive')!;\n+               const decoratorsToRemove = new Map<ts.Node, ts.Node[]>();\n+               decoratorsToRemove.set(decorator.node!.parent!, [decorator.node!]);\n+               renderer.removeDecorators(output, decoratorsToRemove);\n+               expect(output.toString()).toContain(`core.Directive({ selector: '[a]' }),`);\n+               expect(output.toString()).toContain(`OtherA()`);\n+               expect(output.toString()).toContain(`core.Directive({ selector: '[b]' })`);\n+               expect(output.toString()).toContain(`OtherB()`);\n+               expect(output.toString()).not.toContain(`core.Directive({ selector: '[c]' })`);\n+               expect(output.toString()).not.toContain(`C = tslib_1.__decorate([`);\n+               expect(output.toString()).toContain(`function C() {\\n      }\\n      return C;`);\n+             });\n+        });\n+\n+        describe('printStatement', () => {\n+          it('should transpile code to ES5', () => {\n+            const {renderer, sourceFile, importManager} = setup(PROGRAM);\n+\n+            const stmt1 =\n+                new DeclareVarStmt('foo', new LiteralExpr(42), null, [StmtModifier.Static]);\n+            const stmt2 = new DeclareVarStmt('bar', new LiteralExpr(true));\n+            const stmt3 = new DeclareVarStmt('baz', new LiteralExpr('qux'), undefined, []);\n+\n+            expect(renderer.printStatement(stmt1, sourceFile, importManager)).toBe('var foo = 42;');\n+            expect(renderer.printStatement(stmt2, sourceFile, importManager))\n+                .toBe('var bar = true;');\n+            expect(renderer.printStatement(stmt3, sourceFile, importManager))\n+                .toBe('var baz = \"qux\";');\n+          });\n+        });\n       });\n     });\n   });"
        }
    ],
    "stats": {
        "total": 1081,
        "additions": 570,
        "deletions": 511
    }
}