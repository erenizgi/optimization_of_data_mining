{
    "author": "alxhub",
    "message": "fix(compiler-cli): use '' for the source map URL of indirect templates (#41973)\n\nIndirect templates are templates produced by a non-literal expression value\nof the `template` field in `@Component`. The compiler can statically\ndetermine the template string, but there is not guaranteed to be a physical\nfile which contains the bytes of the template string. For example, the\ntemplate string may be computed by a concatenation expression: 'a' + 'b'.\n\nPreviously, the compiler would use the TS file path as the source map path\nfor indirect templates. This is incorrect, however, and breaks source\nmapping for such templates, since the offsets within the template string do\nnot correspond to bytes of the TS file.\n\nThis commit returns the compiler to its old behavior for indirect templates,\nwhich is to use `''` as the source map URL for such templates.\n\nFixes #40854\n\nPR Close #41973",
    "sha": "cd252b99fe04bcde2a31e2314f9eb920b2d38e49",
    "files": [
        {
            "sha": "2deec129a9ec4f40dfd6dcb0720a165e060840e5",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/component.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 9,
            "changes": 26,
            "blob_url": "https://github.com/angular/angular/blob/cd252b99fe04bcde2a31e2314f9eb920b2d38e49/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/cd252b99fe04bcde2a31e2314f9eb920b2d38e49/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts?ref=cd252b99fe04bcde2a31e2314f9eb920b2d38e49",
            "patch": "@@ -1069,6 +1069,7 @@ export class ComponentDecoratorHandler implements\n       let templateContent: string;\n       let sourceMapping: TemplateSourceMapping;\n       let escapedString = false;\n+      let sourceMapUrl: string|null;\n       // We only support SourceMaps for inline templates that are simple string literals.\n       if (ts.isStringLiteral(template.expression) ||\n           ts.isNoSubstitutionTemplateLiteral(template.expression)) {\n@@ -1082,6 +1083,7 @@ export class ComponentDecoratorHandler implements\n           type: 'direct',\n           node: template.expression,\n         };\n+        sourceMapUrl = template.potentialSourceMapUrl;\n       } else {\n         const resolvedTemplate = this.evaluator.evaluate(template.expression);\n         if (typeof resolvedTemplate !== 'string') {\n@@ -1098,10 +1100,15 @@ export class ComponentDecoratorHandler implements\n           componentClass: node,\n           template: templateContent,\n         };\n+\n+        // Indirect templates cannot be mapped to a particular byte range of any input file, since\n+        // they're computed by expressions that may span many files. Don't attempt to map them back\n+        // to a given file.\n+        sourceMapUrl = null;\n       }\n \n       return {\n-        ...this._parseTemplate(template, sourceStr, sourceParseRange, escapedString),\n+        ...this._parseTemplate(template, sourceStr, sourceParseRange, escapedString, sourceMapUrl),\n         content: templateContent,\n         sourceMapping,\n         declaration: template,\n@@ -1116,7 +1123,8 @@ export class ComponentDecoratorHandler implements\n       return {\n         ...this._parseTemplate(\n             template, /* sourceStr */ templateContent, /* sourceParseRange */ null,\n-            /* escapedString */ false),\n+            /* escapedString */ false,\n+            /* sourceMapUrl */ template.potentialSourceMapUrl),\n         content: templateContent,\n         sourceMapping: {\n           type: 'external',\n@@ -1134,11 +1142,11 @@ export class ComponentDecoratorHandler implements\n \n   private _parseTemplate(\n       template: TemplateDeclaration, sourceStr: string, sourceParseRange: LexerRange|null,\n-      escapedString: boolean): ParsedComponentTemplate {\n+      escapedString: boolean, sourceMapUrl: string|null): ParsedComponentTemplate {\n     // We always normalize line endings if the template has been escaped (i.e. is inline).\n     const i18nNormalizeLineEndingsInICUs = escapedString || this.i18nNormalizeLineEndingsInICUs;\n \n-    const parsedTemplate = parseTemplate(sourceStr, template.sourceMapUrl, {\n+    const parsedTemplate = parseTemplate(sourceStr, sourceMapUrl ?? '', {\n       preserveWhitespaces: template.preserveWhitespaces,\n       interpolationConfig: template.interpolationConfig,\n       range: sourceParseRange ?? undefined,\n@@ -1163,7 +1171,7 @@ export class ComponentDecoratorHandler implements\n     // In order to guarantee the correctness of diagnostics, templates are parsed a second time\n     // with the above options set to preserve source mappings.\n \n-    const {nodes: diagNodes} = parseTemplate(sourceStr, template.sourceMapUrl, {\n+    const {nodes: diagNodes} = parseTemplate(sourceStr, sourceMapUrl ?? '', {\n       preserveWhitespaces: true,\n       preserveLineEndings: true,\n       interpolationConfig: template.interpolationConfig,\n@@ -1178,7 +1186,7 @@ export class ComponentDecoratorHandler implements\n     return {\n       ...parsedTemplate,\n       diagNodes,\n-      file: new ParseSourceFile(sourceStr, template.resolvedTemplateUrl),\n+      file: new ParseSourceFile(sourceStr, sourceMapUrl ?? ''),\n     };\n   }\n \n@@ -1223,7 +1231,7 @@ export class ComponentDecoratorHandler implements\n           templateUrl,\n           templateUrlExpression: templateUrlExpr,\n           resolvedTemplateUrl: resourceUrl,\n-          sourceMapUrl: sourceMapUrl(resourceUrl),\n+          potentialSourceMapUrl: sourceMapUrl(resourceUrl),\n         };\n       } catch (e) {\n         throw this.makeResourceNotFoundError(\n@@ -1237,7 +1245,7 @@ export class ComponentDecoratorHandler implements\n         expression: component.get('template')!,\n         templateUrl: containingFile,\n         resolvedTemplateUrl: containingFile,\n-        sourceMapUrl: containingFile,\n+        potentialSourceMapUrl: containingFile,\n       };\n     } else {\n       throw new FatalDiagnosticError(\n@@ -1398,7 +1406,7 @@ interface CommonTemplateDeclaration {\n   interpolationConfig: InterpolationConfig;\n   templateUrl: string;\n   resolvedTemplateUrl: string;\n-  sourceMapUrl: string;\n+  potentialSourceMapUrl: string;\n }\n \n /**"
        },
        {
            "sha": "0422821be1c8169ad40d3fadd81ef396ccd66bea",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/test/component_spec.ts",
            "status": "modified",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/angular/angular/blob/cd252b99fe04bcde2a31e2314f9eb920b2d38e49/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fcomponent_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/cd252b99fe04bcde2a31e2314f9eb920b2d38e49/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fcomponent_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fcomponent_spec.ts?ref=cd252b99fe04bcde2a31e2314f9eb920b2d38e49",
            "patch": "@@ -229,6 +229,36 @@ runInEachFileSystem(() => {\n       expect(analysis?.resources.styles.size).toBe(3);\n     });\n \n+    it('should use an empty source map URL for an indirect template', () => {\n+      const template = '<span>indirect</span>';\n+      const {program, options, host} = makeProgram([\n+        {\n+          name: _('/node_modules/@angular/core/index.d.ts'),\n+          contents: 'export const Component: any;',\n+        },\n+        {\n+          name: _('/entry.ts'),\n+          contents: `\n+          import {Component} from '@angular/core';\n+\n+          const TEMPLATE = '${template}';\n+\n+          @Component({\n+            template: TEMPLATE,\n+          }) class TestCmp {}\n+      `\n+        },\n+      ]);\n+      const {reflectionHost, handler} = setup(program, options, host);\n+      const TestCmp = getDeclaration(program, _('/entry.ts'), 'TestCmp', isNamedClassDeclaration);\n+      const detected = handler.detect(TestCmp, reflectionHost.getDecoratorsOfDeclaration(TestCmp));\n+      if (detected === undefined) {\n+        return fail('Failed to recognize @Component');\n+      }\n+      const {analysis} = handler.analyze(TestCmp, detected.metadata);\n+      expect(analysis?.template.file?.url).toEqual('');\n+    });\n+\n     it('does not emit a program with template parse errors', () => {\n       const template = '{{x ? y }}';\n       const {program, options, host} = makeProgram(["
        }
    ],
    "stats": {
        "total": 56,
        "additions": 47,
        "deletions": 9
    }
}