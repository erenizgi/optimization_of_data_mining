{
    "author": "mhevery",
    "message": "refactor(core): break `i18n.ts` into smaller files (#38368)\n\nThis commit contains no changes to code. It only breaks `i18n.ts` file\ninto `i18n.ts` + `i18n_apply.ts` + `i18n_parse.ts` +\n`i18n_postprocess.ts` for easier maintenance.\n\nPR Close #38368",
    "sha": "250e299dc32de91b4b94f7f43be84bfd6968b020",
    "files": [
        {
            "sha": "1da0721b05c6c46511984bdf272f7c93c94c1766",
            "filename": "goldens/circular-deps/packages.json",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/250e299dc32de91b4b94f7f43be84bfd6968b020/goldens%2Fcircular-deps%2Fpackages.json",
            "raw_url": "https://github.com/angular/angular/raw/250e299dc32de91b4b94f7f43be84bfd6968b020/goldens%2Fcircular-deps%2Fpackages.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fcircular-deps%2Fpackages.json?ref=250e299dc32de91b4b94f7f43be84bfd6968b020",
            "patch": "@@ -1758,9 +1758,10 @@\n     \"packages/core/src/render3/index.ts\"\n   ],\n   [\n-    \"packages/core/src/render3/i18n.ts\",\n+    \"packages/core/src/render3/i18n/i18n_apply.ts\",\n     \"packages/core/src/render3/interfaces/type_checks.ts\",\n-    \"packages/core/src/render3/index.ts\"\n+    \"packages/core/src/render3/index.ts\",\n+    \"packages/core/src/render3/instructions/i18n.ts\"\n   ],\n   [\n     \"packages/core/src/render3/interfaces/container.ts\","
        },
        {
            "sha": "5e0e6dd3eea5b7e2f3b42737cbbaa150c1236991",
            "filename": "goldens/size-tracking/integration-payloads.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/250e299dc32de91b4b94f7f43be84bfd6968b020/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "raw_url": "https://github.com/angular/angular/raw/250e299dc32de91b4b94f7f43be84bfd6968b020/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fsize-tracking%2Fintegration-payloads.json?ref=250e299dc32de91b4b94f7f43be84bfd6968b020",
            "patch": "@@ -62,7 +62,7 @@\n         \"bundle\": \"TODO(i): we should define ngDevMode to false in Closure, but --define only works in the global scope.\",\n         \"bundle\": \"TODO(i): (FW-2164) TS 3.9 new class shape seems to have broken Closure in big ways. The size went from 169991 to 252338\",\n         \"bundle\": \"TODO(i): after removal of tsickle from ngc-wrapped / ng_package, we had to switch to SIMPLE optimizations which increased the size from 252338 to 1198917, see PR#37221 and PR#37317 for more info\",\n-        \"bundle\": 1213769\n+        \"bundle\": 1214317\n       }\n     }\n   }"
        },
        {
            "sha": "b5eedcede56f8ba48949d1ec4355715e6a17601a",
            "filename": "packages/core/src/application_module.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Fapplication_module.ts",
            "raw_url": "https://github.com/angular/angular/raw/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Fapplication_module.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Fapplication_module.ts?ref=250e299dc32de91b4b94f7f43be84bfd6968b020",
            "patch": "@@ -21,7 +21,7 @@ import {ComponentFactoryResolver} from './linker';\n import {Compiler} from './linker/compiler';\n import {NgModule} from './metadata';\n import {SCHEDULER} from './render3/component_ref';\n-import {setLocaleId} from './render3/i18n';\n+import {setLocaleId} from './render3/i18n/i18n_locale_id';\n import {NgZone} from './zone';\n \n declare const $localize: {locale?: string};"
        },
        {
            "sha": "172ad182e482d617d4e4f39b85bc48e8bdfb7086",
            "filename": "packages/core/src/application_ref.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Fapplication_ref.ts",
            "raw_url": "https://github.com/angular/angular/raw/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Fapplication_ref.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Fapplication_ref.ts?ref=250e299dc32de91b4b94f7f43be84bfd6968b020",
            "patch": "@@ -30,7 +30,7 @@ import {InternalViewRef, ViewRef} from './linker/view_ref';\n import {isComponentResourceResolutionQueueEmpty, resolveComponentResources} from './metadata/resource_loading';\n import {assertNgModuleType} from './render3/assert';\n import {ComponentFactory as R3ComponentFactory} from './render3/component_ref';\n-import {setLocaleId} from './render3/i18n';\n+import {setLocaleId} from './render3/i18n/i18n_locale_id';\n import {setJitOptions} from './render3/jit/jit_options';\n import {NgModuleFactory as R3NgModuleFactory} from './render3/ng_module_ref';\n import {publishDefaultGlobalUtils as _publishDefaultGlobalUtils} from './render3/util/global_utils';"
        },
        {
            "sha": "e7da73a2647a638fbc4df57f2ca2d09e2da03a85",
            "filename": "packages/core/src/render3/i18n.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 1516,
            "changes": 1516,
            "blob_url": "https://github.com/angular/angular/blob/8f708b561cbd288845d1500463e9f4e84197f2a9/packages%2Fcore%2Fsrc%2Frender3%2Fi18n.ts",
            "raw_url": "https://github.com/angular/angular/raw/8f708b561cbd288845d1500463e9f4e84197f2a9/packages%2Fcore%2Fsrc%2Frender3%2Fi18n.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fi18n.ts?ref=8f708b561cbd288845d1500463e9f4e84197f2a9",
            "patch": "@@ -1,1516 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import '../util/ng_i18n_closure_mode';\n-import '../util/ng_dev_mode';\n-\n-import {DEFAULT_LOCALE_ID, getPluralCase} from '../i18n/localization';\n-import {getTemplateContent, SRCSET_ATTRS, URI_ATTRS, VALID_ATTRS, VALID_ELEMENTS} from '../sanitization/html_sanitizer';\n-import {getInertBodyHelper} from '../sanitization/inert_body';\n-import {_sanitizeUrl, sanitizeSrcset} from '../sanitization/url_sanitizer';\n-import {addAllToArray} from '../util/array_utils';\n-import {assertDefined, assertEqual, assertGreaterThan, assertIndexInRange} from '../util/assert';\n-\n-import {bindingUpdated} from './bindings';\n-import {attachPatchData} from './context_discovery';\n-import {i18nMutateOpCodesToString, i18nUpdateOpCodesToString} from './i18n_debug';\n-import {setDelayProjection} from './instructions/all';\n-import {allocExpando, elementAttributeInternal, elementPropertyInternal, getOrCreateTNode, setInputsForProperty, setNgReflectProperties, textBindingInternal as applyTextBinding} from './instructions/shared';\n-import {LContainer, NATIVE} from './interfaces/container';\n-import {getDocument} from './interfaces/document';\n-import {COMMENT_MARKER, ELEMENT_MARKER, I18nMutateOpCode, I18nMutateOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, IcuType, TI18n, TIcu} from './interfaces/i18n';\n-import {TElementNode, TIcuContainerNode, TNode, TNodeFlags, TNodeType, TProjectionNode} from './interfaces/node';\n-import {RComment, RElement, RText} from './interfaces/renderer';\n-import {SanitizerFn} from './interfaces/sanitization';\n-import {isLContainer} from './interfaces/type_checks';\n-import {HEADER_OFFSET, LView, RENDERER, T_HOST, TVIEW, TView} from './interfaces/view';\n-import {appendChild, applyProjection, createTextNode, nativeRemoveNode} from './node_manipulation';\n-import {getBindingIndex, getIsParent, getLView, getPreviousOrParentTNode, getTView, nextBindingIndex, setIsNotParent, setPreviousOrParentTNode} from './state';\n-import {attachDebugGetter} from './util/debug_utils';\n-import {renderStringify} from './util/misc_utils';\n-import {getNativeByIndex, getNativeByTNode, getTNode, load} from './util/view_utils';\n-\n-\n-const MARKER = `�`;\n-const ICU_BLOCK_REGEXP = /^\\s*(�\\d+:?\\d*�)\\s*,\\s*(select|plural)\\s*,/;\n-const SUBTEMPLATE_REGEXP = /�\\/?\\*(\\d+:\\d+)�/gi;\n-const PH_REGEXP = /�(\\/?[#*!]\\d+):?\\d*�/gi;\n-const BINDING_REGEXP = /�(\\d+):?\\d*�/gi;\n-const ICU_REGEXP = /({\\s*�\\d+:?\\d*�\\s*,\\s*\\S{6}\\s*,[\\s\\S]*})/gi;\n-const enum TagType {\n-  ELEMENT = '#',\n-  TEMPLATE = '*',\n-  PROJECTION = '!',\n-}\n-\n-// i18nPostprocess consts\n-const ROOT_TEMPLATE_ID = 0;\n-const PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]/;\n-const PP_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]|(�\\/?\\*\\d+:\\d+�)/g;\n-const PP_ICU_VARS_REGEXP = /({\\s*)(VAR_(PLURAL|SELECT)(_\\d+)?)(\\s*,)/g;\n-const PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;\n-const PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\\d+)?)�/g;\n-const PP_CLOSE_TEMPLATE_REGEXP = /\\/\\*/;\n-const PP_TEMPLATE_ID_REGEXP = /\\d+\\:(\\d+)/;\n-\n-// Parsed placeholder structure used in postprocessing (within `i18nPostprocess` function)\n-// Contains the following fields: [templateId, isCloseTemplateTag, placeholder]\n-type PostprocessPlaceholder = [number, boolean, string];\n-\n-interface IcuExpression {\n-  type: IcuType;\n-  mainBinding: number;\n-  cases: string[];\n-  values: (string|IcuExpression)[][];\n-}\n-\n-interface IcuCase {\n-  /**\n-   * Number of slots to allocate in expando for this case.\n-   *\n-   * This is the max number of DOM elements which will be created by this i18n + ICU blocks. When\n-   * the DOM elements are being created they are stored in the EXPANDO, so that update OpCodes can\n-   * write into them.\n-   */\n-  vars: number;\n-\n-  /**\n-   * An optional array of child/sub ICUs.\n-   */\n-  childIcus: number[];\n-\n-  /**\n-   * A set of OpCodes to apply in order to build up the DOM render tree for the ICU\n-   */\n-  create: I18nMutateOpCodes;\n-\n-  /**\n-   * A set of OpCodes to apply in order to destroy the DOM render tree for the ICU.\n-   */\n-  remove: I18nMutateOpCodes;\n-\n-  /**\n-   * A set of OpCodes to apply in order to update the DOM render tree for the ICU bindings.\n-   */\n-  update: I18nUpdateOpCodes;\n-}\n-\n-/**\n- * Breaks pattern into strings and top level {...} blocks.\n- * Can be used to break a message into text and ICU expressions, or to break an ICU expression into\n- * keys and cases.\n- * Original code from closure library, modified for Angular.\n- *\n- * @param pattern (sub)Pattern to be broken.\n- *\n- */\n-function extractParts(pattern: string): (string|IcuExpression)[] {\n-  if (!pattern) {\n-    return [];\n-  }\n-\n-  let prevPos = 0;\n-  const braceStack = [];\n-  const results: (string|IcuExpression)[] = [];\n-  const braces = /[{}]/g;\n-  // lastIndex doesn't get set to 0 so we have to.\n-  braces.lastIndex = 0;\n-\n-  let match;\n-  while (match = braces.exec(pattern)) {\n-    const pos = match.index;\n-    if (match[0] == '}') {\n-      braceStack.pop();\n-\n-      if (braceStack.length == 0) {\n-        // End of the block.\n-        const block = pattern.substring(prevPos, pos);\n-        if (ICU_BLOCK_REGEXP.test(block)) {\n-          results.push(parseICUBlock(block));\n-        } else {\n-          results.push(block);\n-        }\n-\n-        prevPos = pos + 1;\n-      }\n-    } else {\n-      if (braceStack.length == 0) {\n-        const substring = pattern.substring(prevPos, pos);\n-        results.push(substring);\n-        prevPos = pos + 1;\n-      }\n-      braceStack.push('{');\n-    }\n-  }\n-\n-  const substring = pattern.substring(prevPos);\n-  results.push(substring);\n-  return results;\n-}\n-\n-/**\n- * Parses text containing an ICU expression and produces a JSON object for it.\n- * Original code from closure library, modified for Angular.\n- *\n- * @param pattern Text containing an ICU expression that needs to be parsed.\n- *\n- */\n-function parseICUBlock(pattern: string): IcuExpression {\n-  const cases = [];\n-  const values: (string|IcuExpression)[][] = [];\n-  let icuType = IcuType.plural;\n-  let mainBinding = 0;\n-  pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str: string, binding: string, type: string) {\n-    if (type === 'select') {\n-      icuType = IcuType.select;\n-    } else {\n-      icuType = IcuType.plural;\n-    }\n-    mainBinding = parseInt(binding.substr(1), 10);\n-    return '';\n-  });\n-\n-  const parts = extractParts(pattern) as string[];\n-  // Looking for (key block)+ sequence. One of the keys has to be \"other\".\n-  for (let pos = 0; pos < parts.length;) {\n-    let key = parts[pos++].trim();\n-    if (icuType === IcuType.plural) {\n-      // Key can be \"=x\", we just want \"x\"\n-      key = key.replace(/\\s*(?:=)?(\\w+)\\s*/, '$1');\n-    }\n-    if (key.length) {\n-      cases.push(key);\n-    }\n-\n-    const blocks = extractParts(parts[pos++]) as string[];\n-    if (cases.length > values.length) {\n-      values.push(blocks);\n-    }\n-  }\n-\n-  // TODO(ocombe): support ICU expressions in attributes, see #21615\n-  return {type: icuType, mainBinding: mainBinding, cases, values};\n-}\n-\n-/**\n- * Removes everything inside the sub-templates of a message.\n- */\n-function removeInnerTemplateTranslation(message: string): string {\n-  let match;\n-  let res = '';\n-  let index = 0;\n-  let inTemplate = false;\n-  let tagMatched;\n-\n-  while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {\n-    if (!inTemplate) {\n-      res += message.substring(index, match.index + match[0].length);\n-      tagMatched = match[1];\n-      inTemplate = true;\n-    } else {\n-      if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {\n-        index = match.index;\n-        inTemplate = false;\n-      }\n-    }\n-  }\n-\n-  ngDevMode &&\n-      assertEqual(\n-          inTemplate, false,\n-          `Tag mismatch: unable to find the end of the sub-template in the translation \"${\n-              message}\"`);\n-\n-  res += message.substr(index);\n-  return res;\n-}\n-\n-/**\n- * Extracts a part of a message and removes the rest.\n- *\n- * This method is used for extracting a part of the message associated with a template. A translated\n- * message can span multiple templates.\n- *\n- * Example:\n- * ```\n- * <div i18n>Translate <span *ngIf>me</span>!</div>\n- * ```\n- *\n- * @param message The message to crop\n- * @param subTemplateIndex Index of the sub-template to extract. If undefined it returns the\n- * external template and removes all sub-templates.\n- */\n-export function getTranslationForTemplate(message: string, subTemplateIndex?: number) {\n-  if (isRootTemplateMessage(subTemplateIndex)) {\n-    // We want the root template message, ignore all sub-templates\n-    return removeInnerTemplateTranslation(message);\n-  } else {\n-    // We want a specific sub-template\n-    const start =\n-        message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;\n-    const end = message.search(new RegExp(`${MARKER}\\\\/\\\\*\\\\d+:${subTemplateIndex}${MARKER}`));\n-    return removeInnerTemplateTranslation(message.substring(start, end));\n-  }\n-}\n-\n-/**\n- * Generate the OpCodes to update the bindings of a string.\n- *\n- * @param str The string containing the bindings.\n- * @param destinationNode Index of the destination node which will receive the binding.\n- * @param attrName Name of the attribute, if the string belongs to an attribute.\n- * @param sanitizeFn Sanitization function used to sanitize the string after update, if necessary.\n- */\n-function generateBindingUpdateOpCodes(\n-    str: string, destinationNode: number, attrName?: string,\n-    sanitizeFn: SanitizerFn|null = null): I18nUpdateOpCodes {\n-  const updateOpCodes: I18nUpdateOpCodes = [null, null];  // Alloc space for mask and size\n-  if (ngDevMode) {\n-    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n-  }\n-  const textParts = str.split(BINDING_REGEXP);\n-  let mask = 0;\n-\n-  for (let j = 0; j < textParts.length; j++) {\n-    const textValue = textParts[j];\n-\n-    if (j & 1) {\n-      // Odd indexes are bindings\n-      const bindingIndex = parseInt(textValue, 10);\n-      updateOpCodes.push(-1 - bindingIndex);\n-      mask = mask | toMaskBit(bindingIndex);\n-    } else if (textValue !== '') {\n-      // Even indexes are text\n-      updateOpCodes.push(textValue);\n-    }\n-  }\n-\n-  updateOpCodes.push(\n-      destinationNode << I18nUpdateOpCode.SHIFT_REF |\n-      (attrName ? I18nUpdateOpCode.Attr : I18nUpdateOpCode.Text));\n-  if (attrName) {\n-    updateOpCodes.push(attrName, sanitizeFn);\n-  }\n-  updateOpCodes[0] = mask;\n-  updateOpCodes[1] = updateOpCodes.length - 2;\n-  return updateOpCodes;\n-}\n-\n-function getBindingMask(icuExpression: IcuExpression, mask = 0): number {\n-  mask = mask | toMaskBit(icuExpression.mainBinding);\n-  let match;\n-  for (let i = 0; i < icuExpression.values.length; i++) {\n-    const valueArr = icuExpression.values[i];\n-    for (let j = 0; j < valueArr.length; j++) {\n-      const value = valueArr[j];\n-      if (typeof value === 'string') {\n-        while (match = BINDING_REGEXP.exec(value)) {\n-          mask = mask | toMaskBit(parseInt(match[1], 10));\n-        }\n-      } else {\n-        mask = getBindingMask(value as IcuExpression, mask);\n-      }\n-    }\n-  }\n-  return mask;\n-}\n-\n-const i18nIndexStack: number[] = [];\n-let i18nIndexStackPointer = -1;\n-\n-/**\n- * Convert binding index to mask bit.\n- *\n- * Each index represents a single bit on the bit-mask. Because bit-mask only has 32 bits, we make\n- * the 32nd bit share all masks for all bindings higher than 32. Since it is extremely rare to have\n- * more than 32 bindings this will be hit very rarely. The downside of hitting this corner case is\n- * that we will execute binding code more often than necessary. (penalty of performance)\n- */\n-function toMaskBit(bindingIndex: number): number {\n-  return 1 << Math.min(bindingIndex, 31);\n-}\n-\n-const parentIndexStack: number[] = [];\n-\n-/**\n- * Marks a block of text as translatable.\n- *\n- * The instructions `i18nStart` and `i18nEnd` mark the translation block in the template.\n- * The translation `message` is the value which is locale specific. The translation string may\n- * contain placeholders which associate inner elements and sub-templates within the translation.\n- *\n- * The translation `message` placeholders are:\n- * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n- *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n- *   `block` that matches the sub-template in which it was declared.\n- * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n- *   and end of DOM element that were embedded in the original translation block. The placeholder\n- *   `index` points to the element index in the template instructions set. An optional `block` that\n- *   matches the sub-template in which it was declared.\n- * - `�!{index}(:{block})�`/`�/!{index}(:{block})�`: *Projection Placeholder*:  Marks the\n- *   beginning and end of <ng-content> that was embedded in the original translation block.\n- *   The placeholder `index` points to the element index in the template instructions set.\n- *   An optional `block` that matches the sub-template in which it was declared.\n- * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n- *   split up and translated separately in each angular template function. The `index` points to the\n- *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n- *\n- * @param index A unique index of the translation in the static block.\n- * @param message The translation message.\n- * @param subTemplateIndex Optional sub-template index in the `message`.\n- *\n- * @codeGenApi\n- */\n-export function ɵɵi18nStart(index: number, message: string, subTemplateIndex?: number): void {\n-  const tView = getTView();\n-  ngDevMode && assertDefined(tView, `tView should be defined`);\n-  i18nIndexStack[++i18nIndexStackPointer] = index;\n-  // We need to delay projections until `i18nEnd`\n-  setDelayProjection(true);\n-  if (tView.firstCreatePass && tView.data[index + HEADER_OFFSET] === null) {\n-    i18nStartFirstPass(getLView(), tView, index, message, subTemplateIndex);\n-  }\n-}\n-\n-// Count for the number of vars that will be allocated for each i18n block.\n-// It is global because this is used in multiple functions that include loops and recursive calls.\n-// This is reset to 0 when `i18nStartFirstPass` is called.\n-let i18nVarsCount: number;\n-\n-function allocNodeIndex(startIndex: number): number {\n-  return startIndex + i18nVarsCount++;\n-}\n-\n-/**\n- * See `i18nStart` above.\n- */\n-function i18nStartFirstPass(\n-    lView: LView, tView: TView, index: number, message: string, subTemplateIndex?: number) {\n-  const startIndex = tView.blueprint.length - HEADER_OFFSET;\n-  i18nVarsCount = 0;\n-  const previousOrParentTNode = getPreviousOrParentTNode();\n-  const parentTNode =\n-      getIsParent() ? previousOrParentTNode : previousOrParentTNode && previousOrParentTNode.parent;\n-  let parentIndex =\n-      parentTNode && parentTNode !== lView[T_HOST] ? parentTNode.index - HEADER_OFFSET : index;\n-  let parentIndexPointer = 0;\n-  parentIndexStack[parentIndexPointer] = parentIndex;\n-  const createOpCodes: I18nMutateOpCodes = [];\n-  if (ngDevMode) {\n-    attachDebugGetter(createOpCodes, i18nMutateOpCodesToString);\n-  }\n-  // If the previous node wasn't the direct parent then we have a translation without top level\n-  // element and we need to keep a reference of the previous element if there is one. We should also\n-  // keep track whether an element was a parent node or not, so that the logic that consumes\n-  // the generated `I18nMutateOpCode`s can leverage this information to properly set TNode state\n-  // (whether it's a parent or sibling).\n-  if (index > 0 && previousOrParentTNode !== parentTNode) {\n-    let previousTNodeIndex = previousOrParentTNode.index - HEADER_OFFSET;\n-    // If current TNode is a sibling node, encode it using a negative index. This information is\n-    // required when the `Select` action is processed (see the `readCreateOpCodes` function).\n-    if (!getIsParent()) {\n-      previousTNodeIndex = ~previousTNodeIndex;\n-    }\n-    // Create an OpCode to select the previous TNode\n-    createOpCodes.push(previousTNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Select);\n-  }\n-  const updateOpCodes: I18nUpdateOpCodes = [];\n-  if (ngDevMode) {\n-    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n-  }\n-  const icuExpressions: TIcu[] = [];\n-\n-  if (message === '' && isRootTemplateMessage(subTemplateIndex)) {\n-    // If top level translation is an empty string, do not invoke additional processing\n-    // and just create op codes for empty text node instead.\n-    createOpCodes.push(\n-        message, allocNodeIndex(startIndex),\n-        parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n-  } else {\n-    const templateTranslation = getTranslationForTemplate(message, subTemplateIndex);\n-    const msgParts = replaceNgsp(templateTranslation).split(PH_REGEXP);\n-    for (let i = 0; i < msgParts.length; i++) {\n-      let value = msgParts[i];\n-      if (i & 1) {\n-        // Odd indexes are placeholders (elements and sub-templates)\n-        if (value.charAt(0) === '/') {\n-          // It is a closing tag\n-          if (value.charAt(1) === TagType.ELEMENT) {\n-            const phIndex = parseInt(value.substr(2), 10);\n-            parentIndex = parentIndexStack[--parentIndexPointer];\n-            createOpCodes.push(phIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.ElementEnd);\n-          }\n-        } else {\n-          const phIndex = parseInt(value.substr(1), 10);\n-          const isElement = value.charAt(0) === TagType.ELEMENT;\n-          // The value represents a placeholder that we move to the designated index.\n-          // Note: positive indicies indicate that a TNode with a given index should also be marked\n-          // as parent while executing `Select` instruction.\n-          createOpCodes.push(\n-              (isElement ? phIndex : ~phIndex) << I18nMutateOpCode.SHIFT_REF |\n-                  I18nMutateOpCode.Select,\n-              parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n-\n-          if (isElement) {\n-            parentIndexStack[++parentIndexPointer] = parentIndex = phIndex;\n-          }\n-        }\n-      } else {\n-        // Even indexes are text (including bindings & ICU expressions)\n-        const parts = extractParts(value);\n-        for (let j = 0; j < parts.length; j++) {\n-          if (j & 1) {\n-            // Odd indexes are ICU expressions\n-            const icuExpression = parts[j] as IcuExpression;\n-\n-            // Verify that ICU expression has the right shape. Translations might contain invalid\n-            // constructions (while original messages were correct), so ICU parsing at runtime may\n-            // not succeed (thus `icuExpression` remains a string).\n-            if (typeof icuExpression !== 'object') {\n-              throw new Error(\n-                  `Unable to parse ICU expression in \"${templateTranslation}\" message.`);\n-            }\n-\n-            // Create the comment node that will anchor the ICU expression\n-            const icuNodeIndex = allocNodeIndex(startIndex);\n-            createOpCodes.push(\n-                COMMENT_MARKER, ngDevMode ? `ICU ${icuNodeIndex}` : '', icuNodeIndex,\n-                parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n-\n-            // Update codes for the ICU expression\n-            const mask = getBindingMask(icuExpression);\n-            icuStart(icuExpressions, icuExpression, icuNodeIndex, icuNodeIndex);\n-            // Since this is recursive, the last TIcu that was pushed is the one we want\n-            const tIcuIndex = icuExpressions.length - 1;\n-            updateOpCodes.push(\n-                toMaskBit(icuExpression.mainBinding),  // mask of the main binding\n-                3,                                     // skip 3 opCodes if not changed\n-                -1 - icuExpression.mainBinding,\n-                icuNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuSwitch, tIcuIndex,\n-                mask,  // mask of all the bindings of this ICU expression\n-                2,     // skip 2 opCodes if not changed\n-                icuNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuUpdate, tIcuIndex);\n-          } else if (parts[j] !== '') {\n-            const text = parts[j] as string;\n-            // Even indexes are text (including bindings)\n-            const hasBinding = text.match(BINDING_REGEXP);\n-            // Create text nodes\n-            const textNodeIndex = allocNodeIndex(startIndex);\n-            createOpCodes.push(\n-                // If there is a binding, the value will be set during update\n-                hasBinding ? '' : text, textNodeIndex,\n-                parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n-\n-            if (hasBinding) {\n-              addAllToArray(generateBindingUpdateOpCodes(text, textNodeIndex), updateOpCodes);\n-            }\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  if (i18nVarsCount > 0) {\n-    allocExpando(tView, lView, i18nVarsCount);\n-  }\n-\n-  // NOTE: local var needed to properly assert the type of `TI18n`.\n-  const tI18n: TI18n = {\n-    vars: i18nVarsCount,\n-    create: createOpCodes,\n-    update: updateOpCodes,\n-    icus: icuExpressions.length ? icuExpressions : null,\n-  };\n-\n-  tView.data[index + HEADER_OFFSET] = tI18n;\n-}\n-\n-function appendI18nNode(\n-    tView: TView, tNode: TNode, parentTNode: TNode, previousTNode: TNode|null,\n-    lView: LView): TNode {\n-  ngDevMode && ngDevMode.rendererMoveNode++;\n-  const nextNode = tNode.next;\n-  if (!previousTNode) {\n-    previousTNode = parentTNode;\n-  }\n-\n-  // Re-organize node tree to put this node in the correct position.\n-  if (previousTNode === parentTNode && tNode !== parentTNode.child) {\n-    tNode.next = parentTNode.child;\n-    parentTNode.child = tNode;\n-  } else if (previousTNode !== parentTNode && tNode !== previousTNode.next) {\n-    tNode.next = previousTNode.next;\n-    previousTNode.next = tNode;\n-  } else {\n-    tNode.next = null;\n-  }\n-\n-  if (parentTNode !== lView[T_HOST]) {\n-    tNode.parent = parentTNode as TElementNode;\n-  }\n-\n-  // If tNode was moved around, we might need to fix a broken link.\n-  let cursor: TNode|null = tNode.next;\n-  while (cursor) {\n-    if (cursor.next === tNode) {\n-      cursor.next = nextNode;\n-    }\n-    cursor = cursor.next;\n-  }\n-\n-  // If the placeholder to append is a projection, we need to move the projected nodes instead\n-  if (tNode.type === TNodeType.Projection) {\n-    applyProjection(tView, lView, tNode as TProjectionNode);\n-    return tNode;\n-  }\n-\n-  appendChild(tView, lView, getNativeByTNode(tNode, lView), tNode);\n-\n-  const slotValue = lView[tNode.index];\n-  if (tNode.type !== TNodeType.Container && isLContainer(slotValue)) {\n-    // Nodes that inject ViewContainerRef also have a comment node that should be moved\n-    appendChild(tView, lView, slotValue[NATIVE], tNode);\n-  }\n-  return tNode;\n-}\n-\n-function isRootTemplateMessage(subTemplateIndex: number|undefined): subTemplateIndex is undefined {\n-  return subTemplateIndex === undefined;\n-}\n-\n-/**\n- * Handles message string post-processing for internationalization.\n- *\n- * Handles message string post-processing by transforming it from intermediate\n- * format (that might contain some markers that we need to replace) to the final\n- * form, consumable by i18nStart instruction. Post processing steps include:\n- *\n- * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n- * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n- * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n- * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n- *    in case multiple ICUs have the same placeholder name\n- *\n- * @param message Raw translation string for post processing\n- * @param replacements Set of replacements that should be applied\n- *\n- * @returns Transformed string that can be consumed by i18nStart instruction\n- *\n- * @codeGenApi\n- */\n-export function ɵɵi18nPostprocess(\n-    message: string, replacements: {[key: string]: (string|string[])} = {}): string {\n-  /**\n-   * Step 1: resolve all multi-value placeholders like [�#5�|�*1:1��#2:1�|�#4:1�]\n-   *\n-   * Note: due to the way we process nested templates (BFS), multi-value placeholders are typically\n-   * grouped by templates, for example: [�#5�|�#6�|�#1:1�|�#3:2�] where �#5� and �#6� belong to root\n-   * template, �#1:1� belong to nested template with index 1 and �#1:2� - nested template with index\n-   * 3. However in real templates the order might be different: i.e. �#1:1� and/or �#3:2� may go in\n-   * front of �#6�. The post processing step restores the right order by keeping track of the\n-   * template id stack and looks for placeholders that belong to the currently active template.\n-   */\n-  let result: string = message;\n-  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {\n-    const matches: {[key: string]: PostprocessPlaceholder[]} = {};\n-    const templateIdsStack: number[] = [ROOT_TEMPLATE_ID];\n-    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m: any, phs: string, tmpl: string): string => {\n-      const content = phs || tmpl;\n-      const placeholders: PostprocessPlaceholder[] = matches[content] || [];\n-      if (!placeholders.length) {\n-        content.split('|').forEach((placeholder: string) => {\n-          const match = placeholder.match(PP_TEMPLATE_ID_REGEXP);\n-          const templateId = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;\n-          const isCloseTemplateTag = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);\n-          placeholders.push([templateId, isCloseTemplateTag, placeholder]);\n-        });\n-        matches[content] = placeholders;\n-      }\n-\n-      if (!placeholders.length) {\n-        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);\n-      }\n-\n-      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];\n-      let idx = 0;\n-      // find placeholder index that matches current template id\n-      for (let i = 0; i < placeholders.length; i++) {\n-        if (placeholders[i][0] === currentTemplateId) {\n-          idx = i;\n-          break;\n-        }\n-      }\n-      // update template id stack based on the current tag extracted\n-      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];\n-      if (isCloseTemplateTag) {\n-        templateIdsStack.pop();\n-      } else if (currentTemplateId !== templateId) {\n-        templateIdsStack.push(templateId);\n-      }\n-      // remove processed tag from the list\n-      placeholders.splice(idx, 1);\n-      return placeholder;\n-    });\n-  }\n-\n-  // return current result if no replacements specified\n-  if (!Object.keys(replacements).length) {\n-    return result;\n-  }\n-\n-  /**\n-   * Step 2: replace all ICU vars (like \"VAR_PLURAL\")\n-   */\n-  result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end): string => {\n-    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;\n-  });\n-\n-  /**\n-   * Step 3: replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n-   */\n-  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key): string => {\n-    return replacements.hasOwnProperty(key) ? replacements[key] as string : match;\n-  });\n-\n-  /**\n-   * Step 4: replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�) in case\n-   * multiple ICUs have the same placeholder name\n-   */\n-  result = result.replace(PP_ICUS_REGEXP, (match, key): string => {\n-    if (replacements.hasOwnProperty(key)) {\n-      const list = replacements[key] as string[];\n-      if (!list.length) {\n-        throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);\n-      }\n-      return list.shift()!;\n-    }\n-    return match;\n-  });\n-\n-  return result;\n-}\n-\n-/**\n- * Translates a translation block marked by `i18nStart` and `i18nEnd`. It inserts the text/ICU nodes\n- * into the render tree, moves the placeholder nodes and removes the deleted nodes.\n- *\n- * @codeGenApi\n- */\n-export function ɵɵi18nEnd(): void {\n-  const lView = getLView();\n-  const tView = getTView();\n-  ngDevMode && assertDefined(tView, `tView should be defined`);\n-  i18nEndFirstPass(tView, lView);\n-  // Stop delaying projections\n-  setDelayProjection(false);\n-}\n-\n-/**\n- * See `i18nEnd` above.\n- */\n-function i18nEndFirstPass(tView: TView, lView: LView) {\n-  ngDevMode &&\n-      assertEqual(\n-          getBindingIndex(), tView.bindingStartIndex,\n-          'i18nEnd should be called before any binding');\n-\n-  const rootIndex = i18nIndexStack[i18nIndexStackPointer--];\n-  const tI18n = tView.data[rootIndex + HEADER_OFFSET] as TI18n;\n-  ngDevMode && assertDefined(tI18n, `You should call i18nStart before i18nEnd`);\n-\n-  // Find the last node that was added before `i18nEnd`\n-  const lastCreatedNode = getPreviousOrParentTNode();\n-\n-  // Read the instructions to insert/move/remove DOM elements\n-  const visitedNodes = applyCreateOpCodes(tView, rootIndex, tI18n.create, lView);\n-\n-  // Remove deleted nodes\n-  let index = rootIndex + 1;\n-  while (index <= lastCreatedNode.index - HEADER_OFFSET) {\n-    if (visitedNodes.indexOf(index) === -1) {\n-      removeNode(tView, lView, index, /* markAsDetached */ true);\n-    }\n-    // Check if an element has any local refs and skip them\n-    const tNode = getTNode(tView, index);\n-    if (tNode &&\n-        (tNode.type === TNodeType.Container || tNode.type === TNodeType.Element ||\n-         tNode.type === TNodeType.ElementContainer) &&\n-        tNode.localNames !== null) {\n-      // Divide by 2 to get the number of local refs,\n-      // since they are stored as an array that also includes directive indexes,\n-      // i.e. [\"localRef\", directiveIndex, ...]\n-      index += tNode.localNames.length >> 1;\n-    }\n-    index++;\n-  }\n-}\n-\n-/**\n- * Creates and stores the dynamic TNode, and unhooks it from the tree for now.\n- */\n-function createDynamicNodeAtIndex(\n-    tView: TView, lView: LView, index: number, type: TNodeType, native: RElement|RText|null,\n-    name: string|null): TElementNode|TIcuContainerNode {\n-  const previousOrParentTNode = getPreviousOrParentTNode();\n-  ngDevMode && assertIndexInRange(lView, index + HEADER_OFFSET);\n-  lView[index + HEADER_OFFSET] = native;\n-  // FIXME(misko): Why does this create A TNode??? I would not expect this to be here.\n-  const tNode = getOrCreateTNode(tView, lView[T_HOST], index, type as any, name, null);\n-\n-  // We are creating a dynamic node, the previous tNode might not be pointing at this node.\n-  // We will link ourselves into the tree later with `appendI18nNode`.\n-  if (previousOrParentTNode && previousOrParentTNode.next === tNode) {\n-    previousOrParentTNode.next = null;\n-  }\n-\n-  return tNode;\n-}\n-\n-/**\n- * Apply `I18nMutateOpCodes` OpCodes.\n- *\n- * @param tView Current `TView`\n- * @param rootIndex Pointer to the root (parent) tNode for the i18n.\n- * @param createOpCodes OpCodes to process\n- * @param lView Current `LView`\n- */\n-function applyCreateOpCodes(\n-    tView: TView, rootindex: number, createOpCodes: I18nMutateOpCodes, lView: LView): number[] {\n-  const renderer = lView[RENDERER];\n-  let currentTNode: TNode|null = null;\n-  let previousTNode: TNode|null = null;\n-  const visitedNodes: number[] = [];\n-  for (let i = 0; i < createOpCodes.length; i++) {\n-    const opCode = createOpCodes[i];\n-    if (typeof opCode == 'string') {\n-      const textRNode = createTextNode(opCode, renderer);\n-      const textNodeIndex = createOpCodes[++i] as number;\n-      ngDevMode && ngDevMode.rendererCreateTextNode++;\n-      previousTNode = currentTNode;\n-      currentTNode =\n-          createDynamicNodeAtIndex(tView, lView, textNodeIndex, TNodeType.Element, textRNode, null);\n-      visitedNodes.push(textNodeIndex);\n-      setIsNotParent();\n-    } else if (typeof opCode == 'number') {\n-      switch (opCode & I18nMutateOpCode.MASK_INSTRUCTION) {\n-        case I18nMutateOpCode.AppendChild:\n-          const destinationNodeIndex = opCode >>> I18nMutateOpCode.SHIFT_PARENT;\n-          let destinationTNode: TNode;\n-          if (destinationNodeIndex === rootindex) {\n-            // If the destination node is `i18nStart`, we don't have a\n-            // top-level node and we should use the host node instead\n-            destinationTNode = lView[T_HOST]!;\n-          } else {\n-            destinationTNode = getTNode(tView, destinationNodeIndex);\n-          }\n-          ngDevMode &&\n-              assertDefined(\n-                  currentTNode!,\n-                  `You need to create or select a node before you can insert it into the DOM`);\n-          previousTNode =\n-              appendI18nNode(tView, currentTNode!, destinationTNode, previousTNode, lView);\n-          break;\n-        case I18nMutateOpCode.Select:\n-          // Negative indices indicate that a given TNode is a sibling node, not a parent node\n-          // (see `i18nStartFirstPass` for additional information).\n-          const isParent = opCode >= 0;\n-          // FIXME(misko): This SHIFT_REF looks suspect as it does not have mask.\n-          const nodeIndex = (isParent ? opCode : ~opCode) >>> I18nMutateOpCode.SHIFT_REF;\n-          visitedNodes.push(nodeIndex);\n-          previousTNode = currentTNode;\n-          currentTNode = getTNode(tView, nodeIndex);\n-          if (currentTNode) {\n-            setPreviousOrParentTNode(currentTNode, isParent);\n-          }\n-          break;\n-        case I18nMutateOpCode.ElementEnd:\n-          const elementIndex = opCode >>> I18nMutateOpCode.SHIFT_REF;\n-          previousTNode = currentTNode = getTNode(tView, elementIndex);\n-          setPreviousOrParentTNode(currentTNode, false);\n-          break;\n-        case I18nMutateOpCode.Attr:\n-          const elementNodeIndex = opCode >>> I18nMutateOpCode.SHIFT_REF;\n-          const attrName = createOpCodes[++i] as string;\n-          const attrValue = createOpCodes[++i] as string;\n-          // This code is used for ICU expressions only, since we don't support\n-          // directives/components in ICUs, we don't need to worry about inputs here\n-          elementAttributeInternal(\n-              getTNode(tView, elementNodeIndex), lView, attrName, attrValue, null, null);\n-          break;\n-        default:\n-          throw new Error(`Unable to determine the type of mutate operation for \"${opCode}\"`);\n-      }\n-    } else {\n-      switch (opCode) {\n-        case COMMENT_MARKER:\n-          const commentValue = createOpCodes[++i] as string;\n-          const commentNodeIndex = createOpCodes[++i] as number;\n-          ngDevMode &&\n-              assertEqual(\n-                  typeof commentValue, 'string',\n-                  `Expected \"${commentValue}\" to be a comment node value`);\n-          const commentRNode = renderer.createComment(commentValue);\n-          ngDevMode && ngDevMode.rendererCreateComment++;\n-          previousTNode = currentTNode;\n-          currentTNode = createDynamicNodeAtIndex(\n-              tView, lView, commentNodeIndex, TNodeType.IcuContainer, commentRNode, null);\n-          visitedNodes.push(commentNodeIndex);\n-          attachPatchData(commentRNode, lView);\n-          // We will add the case nodes later, during the update phase\n-          setIsNotParent();\n-          break;\n-        case ELEMENT_MARKER:\n-          const tagNameValue = createOpCodes[++i] as string;\n-          const elementNodeIndex = createOpCodes[++i] as number;\n-          ngDevMode &&\n-              assertEqual(\n-                  typeof tagNameValue, 'string',\n-                  `Expected \"${tagNameValue}\" to be an element node tag name`);\n-          const elementRNode = renderer.createElement(tagNameValue);\n-          ngDevMode && ngDevMode.rendererCreateElement++;\n-          previousTNode = currentTNode;\n-          currentTNode = createDynamicNodeAtIndex(\n-              tView, lView, elementNodeIndex, TNodeType.Element, elementRNode, tagNameValue);\n-          visitedNodes.push(elementNodeIndex);\n-          break;\n-        default:\n-          throw new Error(`Unable to determine the type of mutate operation for \"${opCode}\"`);\n-      }\n-    }\n-  }\n-\n-  setIsNotParent();\n-\n-  return visitedNodes;\n-}\n-\n-/**\n- * Apply `I18nUpdateOpCodes` OpCodes\n- *\n- * @param tView Current `TView`\n- * @param tIcus If ICUs present than this contains them.\n- * @param lView Current `LView`\n- * @param updateOpCodes OpCodes to process\n- * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n- * @param changeMask Each bit corresponds to a `ɵɵi18nExp` (Counting backwards from\n- *     `bindingsStartIndex`)\n- */\n-function applyUpdateOpCodes(\n-    tView: TView, tIcus: TIcu[]|null, lView: LView, updateOpCodes: I18nUpdateOpCodes,\n-    bindingsStartIndex: number, changeMask: number) {\n-  let caseCreated = false;\n-  for (let i = 0; i < updateOpCodes.length; i++) {\n-    // bit code to check if we should apply the next update\n-    const checkBit = updateOpCodes[i] as number;\n-    // Number of opCodes to skip until next set of update codes\n-    const skipCodes = updateOpCodes[++i] as number;\n-    if (checkBit & changeMask) {\n-      // The value has been updated since last checked\n-      let value = '';\n-      for (let j = i + 1; j <= (i + skipCodes); j++) {\n-        const opCode = updateOpCodes[j];\n-        if (typeof opCode == 'string') {\n-          value += opCode;\n-        } else if (typeof opCode == 'number') {\n-          if (opCode < 0) {\n-            // Negative opCode represent `i18nExp` values offset.\n-            value += renderStringify(lView[bindingsStartIndex - opCode]);\n-          } else {\n-            const nodeIndex = opCode >>> I18nUpdateOpCode.SHIFT_REF;\n-            switch (opCode & I18nUpdateOpCode.MASK_OPCODE) {\n-              case I18nUpdateOpCode.Attr:\n-                const propName = updateOpCodes[++j] as string;\n-                const sanitizeFn = updateOpCodes[++j] as SanitizerFn | null;\n-                elementPropertyInternal(\n-                    tView, getTNode(tView, nodeIndex), lView, propName, value, lView[RENDERER],\n-                    sanitizeFn, false);\n-                break;\n-              case I18nUpdateOpCode.Text:\n-                applyTextBinding(lView, nodeIndex, value);\n-                break;\n-              case I18nUpdateOpCode.IcuSwitch:\n-                caseCreated =\n-                    applyIcuSwitchCase(tView, tIcus!, updateOpCodes[++j] as number, lView, value);\n-                break;\n-              case I18nUpdateOpCode.IcuUpdate:\n-                applyIcuUpdateCase(\n-                    tView, tIcus!, updateOpCodes[++j] as number, bindingsStartIndex, lView,\n-                    caseCreated);\n-                break;\n-            }\n-          }\n-        }\n-      }\n-    }\n-    i += skipCodes;\n-  }\n-}\n-\n-/**\n- * Apply OpCodes associated with updating an existing ICU.\n- *\n- * @param tView Current `TView`\n- * @param tIcus tIcus ICUs active at this location them.\n- * @param tIcuIndex Index into `tIcus` to process.\n- * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n- * @param lView Current `LView`\n- * @param changeMask Each bit corresponds to a `ɵɵi18nExp` (Counting backwards from\n- *     `bindingsStartIndex`)\n- */\n-function applyIcuUpdateCase(\n-    tView: TView, tIcus: TIcu[], tIcuIndex: number, bindingsStartIndex: number, lView: LView,\n-    caseCreated: boolean) {\n-  ngDevMode && assertIndexInRange(tIcus, tIcuIndex);\n-  const tIcu = tIcus[tIcuIndex];\n-  ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);\n-  const activeCaseIndex = lView[tIcu.currentCaseLViewIndex];\n-  if (activeCaseIndex !== null) {\n-    const mask = caseCreated ?\n-        -1 :  // -1 is same as all bits on, which simulates creation since it marks all bits dirty\n-        changeMask;\n-    applyUpdateOpCodes(tView, tIcus, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);\n-  }\n-}\n-\n-/**\n- * Apply OpCodes associated with switching a case on ICU.\n- *\n- * This involves tearing down existing case and than building up a new case.\n- *\n- * @param tView Current `TView`\n- * @param tIcus ICUs active at this location.\n- * @param tIcuIndex Index into `tIcus` to process.\n- * @param lView Current `LView`\n- * @param value Value of the case to update to.\n- * @returns true if a new case was created (needed so that the update executes regardless of the\n- *     bitmask)\n- */\n-function applyIcuSwitchCase(\n-    tView: TView, tIcus: TIcu[], tIcuIndex: number, lView: LView, value: string): boolean {\n-  applyIcuSwitchCaseRemove(tView, tIcus, tIcuIndex, lView);\n-\n-  // Rebuild a new case for this ICU\n-  let caseCreated = false;\n-  ngDevMode && assertIndexInRange(tIcus, tIcuIndex);\n-  const tIcu = tIcus[tIcuIndex];\n-  const caseIndex = getCaseIndex(tIcu, value);\n-  lView[tIcu.currentCaseLViewIndex] = caseIndex !== -1 ? caseIndex : null;\n-  if (caseIndex > -1) {\n-    // Add the nodes for the new case\n-    applyCreateOpCodes(\n-        tView, -1,  // -1 means we don't have parent node\n-        tIcu.create[caseIndex], lView);\n-    caseCreated = true;\n-  }\n-  return caseCreated;\n-}\n-\n-/**\n- * Apply OpCodes associated with tearing down of DOM.\n- *\n- * This involves tearing down existing case and than building up a new case.\n- *\n- * @param tView Current `TView`\n- * @param tIcus ICUs active at this location.\n- * @param tIcuIndex Index into `tIcus` to process.\n- * @param lView Current `LView`\n- * @returns true if a new case was created (needed so that the update executes regardless of the\n- *     bitmask)\n- */\n-function applyIcuSwitchCaseRemove(tView: TView, tIcus: TIcu[], tIcuIndex: number, lView: LView) {\n-  ngDevMode && assertIndexInRange(tIcus, tIcuIndex);\n-  const tIcu = tIcus[tIcuIndex];\n-  const activeCaseIndex = lView[tIcu.currentCaseLViewIndex];\n-  if (activeCaseIndex !== null) {\n-    const removeCodes = tIcu.remove[activeCaseIndex];\n-    for (let k = 0; k < removeCodes.length; k++) {\n-      const removeOpCode = removeCodes[k] as number;\n-      const nodeOrIcuIndex = removeOpCode >>> I18nMutateOpCode.SHIFT_REF;\n-      switch (removeOpCode & I18nMutateOpCode.MASK_INSTRUCTION) {\n-        case I18nMutateOpCode.Remove:\n-          // FIXME(misko): this comment is wrong!\n-          // Remove DOM element, but do *not* mark TNode as detached, since we are\n-          // just switching ICU cases (while keeping the same TNode), so a DOM element\n-          // representing a new ICU case will be re-created.\n-          removeNode(tView, lView, nodeOrIcuIndex, /* markAsDetached */ false);\n-          break;\n-        case I18nMutateOpCode.RemoveNestedIcu:\n-          applyIcuSwitchCaseRemove(tView, tIcus, nodeOrIcuIndex, lView);\n-          break;\n-      }\n-    }\n-  }\n-}\n-\n-function removeNode(tView: TView, lView: LView, index: number, markAsDetached: boolean) {\n-  const removedPhTNode = getTNode(tView, index);\n-  const removedPhRNode = getNativeByIndex(index, lView);\n-  if (removedPhRNode) {\n-    nativeRemoveNode(lView[RENDERER], removedPhRNode);\n-  }\n-\n-  const slotValue = load(lView, index) as RElement | RComment | LContainer;\n-  if (isLContainer(slotValue)) {\n-    const lContainer = slotValue as LContainer;\n-    if (removedPhTNode.type !== TNodeType.Container) {\n-      nativeRemoveNode(lView[RENDERER], lContainer[NATIVE]);\n-    }\n-  }\n-\n-  if (markAsDetached) {\n-    // Define this node as detached to avoid projecting it later\n-    removedPhTNode.flags |= TNodeFlags.isDetached;\n-  }\n-  ngDevMode && ngDevMode.rendererRemoveNode++;\n-}\n-\n-/**\n- *\n- * Use this instruction to create a translation block that doesn't contain any placeholder.\n- * It calls both {@link i18nStart} and {@link i18nEnd} in one instruction.\n- *\n- * The translation `message` is the value which is locale specific. The translation string may\n- * contain placeholders which associate inner elements and sub-templates within the translation.\n- *\n- * The translation `message` placeholders are:\n- * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n- *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n- *   `block` that matches the sub-template in which it was declared.\n- * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n- *   and end of DOM element that were embedded in the original translation block. The placeholder\n- *   `index` points to the element index in the template instructions set. An optional `block` that\n- *   matches the sub-template in which it was declared.\n- * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n- *   split up and translated separately in each angular template function. The `index` points to the\n- *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n- *\n- * @param index A unique index of the translation in the static block.\n- * @param message The translation message.\n- * @param subTemplateIndex Optional sub-template index in the `message`.\n- *\n- * @codeGenApi\n- */\n-export function ɵɵi18n(index: number, message: string, subTemplateIndex?: number): void {\n-  ɵɵi18nStart(index, message, subTemplateIndex);\n-  ɵɵi18nEnd();\n-}\n-\n-/**\n- * Marks a list of attributes as translatable.\n- *\n- * @param index A unique index in the static block\n- * @param values\n- *\n- * @codeGenApi\n- */\n-export function ɵɵi18nAttributes(index: number, values: string[]): void {\n-  const lView = getLView();\n-  const tView = getTView();\n-  ngDevMode && assertDefined(tView, `tView should be defined`);\n-  i18nAttributesFirstPass(lView, tView, index, values);\n-}\n-\n-/**\n- * See `i18nAttributes` above.\n- */\n-function i18nAttributesFirstPass(lView: LView, tView: TView, index: number, values: string[]) {\n-  const previousElement = getPreviousOrParentTNode();\n-  const previousElementIndex = previousElement.index - HEADER_OFFSET;\n-  const updateOpCodes: I18nUpdateOpCodes = [];\n-  if (ngDevMode) {\n-    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n-  }\n-  for (let i = 0; i < values.length; i += 2) {\n-    const attrName = values[i];\n-    const message = values[i + 1];\n-    const parts = message.split(ICU_REGEXP);\n-    for (let j = 0; j < parts.length; j++) {\n-      const value = parts[j];\n-\n-      if (j & 1) {\n-        // Odd indexes are ICU expressions\n-        // TODO(ocombe): support ICU expressions in attributes\n-        throw new Error('ICU expressions are not yet supported in attributes');\n-      } else if (value !== '') {\n-        // Even indexes are text (including bindings)\n-        const hasBinding = !!value.match(BINDING_REGEXP);\n-        if (hasBinding) {\n-          if (tView.firstCreatePass && tView.data[index + HEADER_OFFSET] === null) {\n-            addAllToArray(\n-                generateBindingUpdateOpCodes(value, previousElementIndex, attrName), updateOpCodes);\n-          }\n-        } else {\n-          const tNode = getTNode(tView, previousElementIndex);\n-          // Set attributes for Elements only, for other types (like ElementContainer),\n-          // only set inputs below\n-          if (tNode.type === TNodeType.Element) {\n-            elementAttributeInternal(tNode, lView, attrName, value, null, null);\n-          }\n-          // Check if that attribute is a directive input\n-          const dataValue = tNode.inputs !== null && tNode.inputs[attrName];\n-          if (dataValue) {\n-            setInputsForProperty(tView, lView, dataValue, attrName, value);\n-            if (ngDevMode) {\n-              const element = getNativeByIndex(previousElementIndex, lView) as RElement | RComment;\n-              setNgReflectProperties(lView, element, tNode.type, dataValue, value);\n-            }\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  if (tView.firstCreatePass && tView.data[index + HEADER_OFFSET] === null) {\n-    tView.data[index + HEADER_OFFSET] = updateOpCodes;\n-  }\n-}\n-\n-let changeMask = 0b0;\n-let shiftsCounter = 0;\n-\n-/**\n- * Stores the values of the bindings during each update cycle in order to determine if we need to\n- * update the translated nodes.\n- *\n- * @param value The binding's value\n- * @returns This function returns itself so that it may be chained\n- * (e.g. `i18nExp(ctx.name)(ctx.title)`)\n- *\n- * @codeGenApi\n- */\n-export function ɵɵi18nExp<T>(value: T): typeof ɵɵi18nExp {\n-  const lView = getLView();\n-  if (bindingUpdated(lView, nextBindingIndex(), value)) {\n-    changeMask = changeMask | (1 << shiftsCounter);\n-  }\n-  shiftsCounter++;\n-  return ɵɵi18nExp;\n-}\n-\n-/**\n- * Updates a translation block or an i18n attribute when the bindings have changed.\n- *\n- * @param index Index of either {@link i18nStart} (translation block) or {@link i18nAttributes}\n- * (i18n attribute) on which it should update the content.\n- *\n- * @codeGenApi\n- */\n-export function ɵɵi18nApply(index: number) {\n-  if (shiftsCounter) {\n-    const tView = getTView();\n-    ngDevMode && assertDefined(tView, `tView should be defined`);\n-    const tI18n = tView.data[index + HEADER_OFFSET] as TI18n | I18nUpdateOpCodes;\n-    let updateOpCodes: I18nUpdateOpCodes;\n-    let tIcus: TIcu[]|null = null;\n-    if (Array.isArray(tI18n)) {\n-      updateOpCodes = tI18n as I18nUpdateOpCodes;\n-    } else {\n-      updateOpCodes = (tI18n as TI18n).update;\n-      tIcus = (tI18n as TI18n).icus;\n-    }\n-    const bindingsStartIndex = getBindingIndex() - shiftsCounter - 1;\n-    const lView = getLView();\n-    applyUpdateOpCodes(tView, tIcus, lView, updateOpCodes, bindingsStartIndex, changeMask);\n-\n-    // Reset changeMask & maskBit to default for the next update cycle\n-    changeMask = 0b0;\n-    shiftsCounter = 0;\n-  }\n-}\n-\n-/**\n- * Returns the index of the current case of an ICU expression depending on the main binding value\n- *\n- * @param icuExpression\n- * @param bindingValue The value of the main binding used by this ICU expression\n- */\n-function getCaseIndex(icuExpression: TIcu, bindingValue: string): number {\n-  let index = icuExpression.cases.indexOf(bindingValue);\n-  if (index === -1) {\n-    switch (icuExpression.type) {\n-      case IcuType.plural: {\n-        const resolvedCase = getPluralCase(bindingValue, getLocaleId());\n-        index = icuExpression.cases.indexOf(resolvedCase);\n-        if (index === -1 && resolvedCase !== 'other') {\n-          index = icuExpression.cases.indexOf('other');\n-        }\n-        break;\n-      }\n-      case IcuType.select: {\n-        index = icuExpression.cases.indexOf('other');\n-        break;\n-      }\n-    }\n-  }\n-  return index;\n-}\n-\n-/**\n- * Generate the OpCodes for ICU expressions.\n- *\n- * @param tIcus\n- * @param icuExpression\n- * @param startIndex\n- * @param expandoStartIndex\n- */\n-function icuStart(\n-    tIcus: TIcu[], icuExpression: IcuExpression, startIndex: number,\n-    expandoStartIndex: number): void {\n-  const createCodes: I18nMutateOpCodes[] = [];\n-  const removeCodes: I18nMutateOpCodes[] = [];\n-  const updateCodes: I18nUpdateOpCodes[] = [];\n-  const vars = [];\n-  const childIcus: number[][] = [];\n-  const values = icuExpression.values;\n-  for (let i = 0; i < values.length; i++) {\n-    // Each value is an array of strings & other ICU expressions\n-    const valueArr = values[i];\n-    const nestedIcus: IcuExpression[] = [];\n-    for (let j = 0; j < valueArr.length; j++) {\n-      const value = valueArr[j];\n-      if (typeof value !== 'string') {\n-        // It is an nested ICU expression\n-        const icuIndex = nestedIcus.push(value as IcuExpression) - 1;\n-        // Replace nested ICU expression by a comment node\n-        valueArr[j] = `<!--�${icuIndex}�-->`;\n-      }\n-    }\n-    const icuCase: IcuCase =\n-        parseIcuCase(valueArr.join(''), startIndex, nestedIcus, tIcus, expandoStartIndex);\n-    createCodes.push(icuCase.create);\n-    removeCodes.push(icuCase.remove);\n-    updateCodes.push(icuCase.update);\n-    vars.push(icuCase.vars);\n-    childIcus.push(icuCase.childIcus);\n-  }\n-  const tIcu: TIcu = {\n-    type: icuExpression.type,\n-    vars,\n-    currentCaseLViewIndex: HEADER_OFFSET +\n-        expandoStartIndex  // expandoStartIndex does not include the header so add it.\n-        + 1,               // The first item stored is the `<!--ICU #-->` anchor so skip it.\n-    childIcus,\n-    cases: icuExpression.cases,\n-    create: createCodes,\n-    remove: removeCodes,\n-    update: updateCodes\n-  };\n-  tIcus.push(tIcu);\n-  // Adding the maximum possible of vars needed (based on the cases with the most vars)\n-  i18nVarsCount += Math.max(...vars);\n-}\n-\n-/**\n- * Transforms a string template into an HTML template and a list of instructions used to update\n- * attributes or nodes that contain bindings.\n- *\n- * @param unsafeHtml The string to parse\n- * @param parentIndex\n- * @param nestedIcus\n- * @param tIcus\n- * @param expandoStartIndex\n- */\n-function parseIcuCase(\n-    unsafeHtml: string, parentIndex: number, nestedIcus: IcuExpression[], tIcus: TIcu[],\n-    expandoStartIndex: number): IcuCase {\n-  const inertBodyHelper = getInertBodyHelper(getDocument());\n-  const inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n-  if (!inertBodyElement) {\n-    throw new Error('Unable to generate inert body element');\n-  }\n-  const wrapper = getTemplateContent(inertBodyElement!) as Element || inertBodyElement;\n-  const opCodes: IcuCase = {\n-    vars: 1,  // allocate space for `TIcu.currentCaseLViewIndex`\n-    childIcus: [],\n-    create: [],\n-    remove: [],\n-    update: []\n-  };\n-  if (ngDevMode) {\n-    attachDebugGetter(opCodes.create, i18nMutateOpCodesToString);\n-    attachDebugGetter(opCodes.remove, i18nMutateOpCodesToString);\n-    attachDebugGetter(opCodes.update, i18nUpdateOpCodesToString);\n-  }\n-  parseNodes(wrapper.firstChild, opCodes, parentIndex, nestedIcus, tIcus, expandoStartIndex);\n-  return opCodes;\n-}\n-\n-const NESTED_ICU = /�(\\d+)�/;\n-\n-/**\n- * Parses a node, its children and its siblings, and generates the mutate & update OpCodes.\n- *\n- * @param currentNode The first node to parse\n- * @param icuCase The data for the ICU expression case that contains those nodes\n- * @param parentIndex Index of the current node's parent\n- * @param nestedIcus Data for the nested ICU expressions that this case contains\n- * @param tIcus Data for all ICU expressions of the current message\n- * @param expandoStartIndex Expando start index for the current ICU expression\n- */\n-function parseNodes(\n-    currentNode: Node|null, icuCase: IcuCase, parentIndex: number, nestedIcus: IcuExpression[],\n-    tIcus: TIcu[], expandoStartIndex: number) {\n-  if (currentNode) {\n-    const nestedIcusToCreate: [IcuExpression, number][] = [];\n-    while (currentNode) {\n-      const nextNode: Node|null = currentNode.nextSibling;\n-      const newIndex = expandoStartIndex + ++icuCase.vars;\n-      switch (currentNode.nodeType) {\n-        case Node.ELEMENT_NODE:\n-          const element = currentNode as Element;\n-          const tagName = element.tagName.toLowerCase();\n-          if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\n-            // This isn't a valid element, we won't create an element for it\n-            icuCase.vars--;\n-          } else {\n-            icuCase.create.push(\n-                ELEMENT_MARKER, tagName, newIndex,\n-                parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n-            const elAttrs = element.attributes;\n-            for (let i = 0; i < elAttrs.length; i++) {\n-              const attr = elAttrs.item(i)!;\n-              const lowerAttrName = attr.name.toLowerCase();\n-              const hasBinding = !!attr.value.match(BINDING_REGEXP);\n-              // we assume the input string is safe, unless it's using a binding\n-              if (hasBinding) {\n-                if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {\n-                  if (URI_ATTRS[lowerAttrName]) {\n-                    addAllToArray(\n-                        generateBindingUpdateOpCodes(attr.value, newIndex, attr.name, _sanitizeUrl),\n-                        icuCase.update);\n-                  } else if (SRCSET_ATTRS[lowerAttrName]) {\n-                    addAllToArray(\n-                        generateBindingUpdateOpCodes(\n-                            attr.value, newIndex, attr.name, sanitizeSrcset),\n-                        icuCase.update);\n-                  } else {\n-                    addAllToArray(\n-                        generateBindingUpdateOpCodes(attr.value, newIndex, attr.name),\n-                        icuCase.update);\n-                  }\n-                } else {\n-                  ngDevMode &&\n-                      console.warn(`WARNING: ignoring unsafe attribute value ${\n-                          lowerAttrName} on element ${tagName} (see http://g.co/ng/security#xss)`);\n-                }\n-              } else {\n-                icuCase.create.push(\n-                    newIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Attr, attr.name,\n-                    attr.value);\n-              }\n-            }\n-            // Parse the children of this node (if any)\n-            parseNodes(\n-                currentNode.firstChild, icuCase, newIndex, nestedIcus, tIcus, expandoStartIndex);\n-            // Remove the parent node after the children\n-            icuCase.remove.push(newIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove);\n-          }\n-          break;\n-        case Node.TEXT_NODE:\n-          const value = currentNode.textContent || '';\n-          const hasBinding = value.match(BINDING_REGEXP);\n-          icuCase.create.push(\n-              hasBinding ? '' : value, newIndex,\n-              parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n-          icuCase.remove.push(newIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove);\n-          if (hasBinding) {\n-            addAllToArray(generateBindingUpdateOpCodes(value, newIndex), icuCase.update);\n-          }\n-          break;\n-        case Node.COMMENT_NODE:\n-          // Check if the comment node is a placeholder for a nested ICU\n-          const match = NESTED_ICU.exec(currentNode.textContent || '');\n-          if (match) {\n-            const nestedIcuIndex = parseInt(match[1], 10);\n-            const newLocal = ngDevMode ? `nested ICU ${nestedIcuIndex}` : '';\n-            // Create the comment node that will anchor the ICU expression\n-            icuCase.create.push(\n-                COMMENT_MARKER, newLocal, newIndex,\n-                parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n-            const nestedIcu = nestedIcus[nestedIcuIndex];\n-            nestedIcusToCreate.push([nestedIcu, newIndex]);\n-          } else {\n-            // We do not handle any other type of comment\n-            icuCase.vars--;\n-          }\n-          break;\n-        default:\n-          // We do not handle any other type of element\n-          icuCase.vars--;\n-      }\n-      currentNode = nextNode!;\n-    }\n-\n-    for (let i = 0; i < nestedIcusToCreate.length; i++) {\n-      const nestedIcu = nestedIcusToCreate[i][0];\n-      const nestedIcuNodeIndex = nestedIcusToCreate[i][1];\n-      icuStart(tIcus, nestedIcu, nestedIcuNodeIndex, expandoStartIndex + icuCase.vars);\n-      // Since this is recursive, the last TIcu that was pushed is the one we want\n-      const nestTIcuIndex = tIcus.length - 1;\n-      icuCase.vars += Math.max(...tIcus[nestTIcuIndex].vars);\n-      icuCase.childIcus.push(nestTIcuIndex);\n-      const mask = getBindingMask(nestedIcu);\n-      icuCase.update.push(\n-          toMaskBit(nestedIcu.mainBinding),  // mask of the main binding\n-          3,                                 // skip 3 opCodes if not changed\n-          -1 - nestedIcu.mainBinding,\n-          nestedIcuNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuSwitch,\n-          // FIXME(misko): Index should be part of the opcode\n-          nestTIcuIndex,\n-          mask,  // mask of all the bindings of this ICU expression\n-          2,     // skip 2 opCodes if not changed\n-          nestedIcuNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuUpdate,\n-          nestTIcuIndex);\n-      icuCase.remove.push(\n-          nestTIcuIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.RemoveNestedIcu,\n-          // FIXME(misko): Index should be part of the opcode\n-          nestedIcuNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove);\n-    }\n-  }\n-}\n-\n-/**\n- * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\n- * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\n- * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n- * and later on replaced by a space. We are re-implementing the same idea here, since translations\n- * might contain this special character.\n- */\n-const NGSP_UNICODE_REGEXP = /\\uE500/g;\n-function replaceNgsp(value: string): string {\n-  return value.replace(NGSP_UNICODE_REGEXP, ' ');\n-}\n-\n-/**\n- * The locale id that the application is currently using (for translations and ICU expressions).\n- * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n- * but is now defined as a global value.\n- */\n-let LOCALE_ID = DEFAULT_LOCALE_ID;\n-\n-/**\n- * Sets the locale id that will be used for translations and ICU expressions.\n- * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n- * but is now defined as a global value.\n- *\n- * @param localeId\n- */\n-export function setLocaleId(localeId: string) {\n-  assertDefined(localeId, `Expected localeId to be defined`);\n-  if (typeof localeId === 'string') {\n-    LOCALE_ID = localeId.toLowerCase().replace(/_/g, '-');\n-  }\n-}\n-\n-/**\n- * Gets the locale id that will be used for translations and ICU expressions.\n- * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n- * but is now defined as a global value.\n- */\n-export function getLocaleId(): string {\n-  return LOCALE_ID;\n-}"
        },
        {
            "sha": "f58e4587d6db02b23ca59ef8f81c640532f6091d",
            "filename": "packages/core/src/render3/i18n/i18n.md",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/angular/angular/blob/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n.md",
            "raw_url": "https://github.com/angular/angular/raw/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n.md?ref=250e299dc32de91b4b94f7f43be84bfd6968b020",
            "previous_filename": "packages/core/src/render3/i18n.md"
        },
        {
            "sha": "af7728decd1227318d577920ab41ba8c8374629f",
            "filename": "packages/core/src/render3/i18n/i18n_apply.ts",
            "status": "added",
            "additions": 503,
            "deletions": 0,
            "changes": 503,
            "blob_url": "https://github.com/angular/angular/blob/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_apply.ts",
            "raw_url": "https://github.com/angular/angular/raw/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_apply.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_apply.ts?ref=250e299dc32de91b4b94f7f43be84bfd6968b020",
            "patch": "@@ -0,0 +1,503 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {getPluralCase} from '../../i18n/localization';\n+import {assertDefined, assertEqual, assertIndexInRange} from '../../util/assert';\n+import {attachPatchData} from '../context_discovery';\n+import {elementAttributeInternal, elementPropertyInternal, getOrCreateTNode, textBindingInternal} from '../instructions/shared';\n+import {LContainer, NATIVE} from '../interfaces/container';\n+import {COMMENT_MARKER, ELEMENT_MARKER, I18nMutateOpCode, I18nMutateOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, IcuType, TI18n, TIcu} from '../interfaces/i18n';\n+import {TElementNode, TIcuContainerNode, TNode, TNodeFlags, TNodeType, TProjectionNode} from '../interfaces/node';\n+import {RComment, RElement, RText} from '../interfaces/renderer';\n+import {SanitizerFn} from '../interfaces/sanitization';\n+import {isLContainer} from '../interfaces/type_checks';\n+import {HEADER_OFFSET, LView, RENDERER, T_HOST, TView} from '../interfaces/view';\n+import {appendChild, applyProjection, createTextNode, nativeRemoveNode} from '../node_manipulation';\n+import {getBindingIndex, getLView, getPreviousOrParentTNode, getTView, setIsNotParent, setPreviousOrParentTNode} from '../state';\n+import {renderStringify} from '../util/misc_utils';\n+import {getNativeByIndex, getNativeByTNode, getTNode, load} from '../util/view_utils';\n+import {getLocaleId} from './i18n_locale_id';\n+\n+\n+const i18nIndexStack: number[] = [];\n+let i18nIndexStackPointer = -1;\n+\n+function popI18nIndex() {\n+  return i18nIndexStack[i18nIndexStackPointer--];\n+}\n+\n+export function pushI18nIndex(index: number) {\n+  i18nIndexStack[++i18nIndexStackPointer] = index;\n+}\n+\n+let changeMask = 0b0;\n+let shiftsCounter = 0;\n+\n+export function setMaskBit(bit: boolean) {\n+  if (bit) {\n+    changeMask = changeMask | (1 << shiftsCounter);\n+  }\n+  shiftsCounter++;\n+}\n+\n+export function applyI18n(tView: TView, lView: LView, index: number) {\n+  if (shiftsCounter > 0) {\n+    ngDevMode && assertDefined(tView, `tView should be defined`);\n+    const tI18n = tView.data[index + HEADER_OFFSET] as TI18n | I18nUpdateOpCodes;\n+    let updateOpCodes: I18nUpdateOpCodes;\n+    let tIcus: TIcu[]|null = null;\n+    if (Array.isArray(tI18n)) {\n+      updateOpCodes = tI18n as I18nUpdateOpCodes;\n+    } else {\n+      updateOpCodes = (tI18n as TI18n).update;\n+      tIcus = (tI18n as TI18n).icus;\n+    }\n+    const bindingsStartIndex = getBindingIndex() - shiftsCounter - 1;\n+    applyUpdateOpCodes(tView, tIcus, lView, updateOpCodes, bindingsStartIndex, changeMask);\n+\n+    // Reset changeMask & maskBit to default for the next update cycle\n+    changeMask = 0b0;\n+    shiftsCounter = 0;\n+  }\n+}\n+\n+/**\n+ * Apply `I18nMutateOpCodes` OpCodes.\n+ *\n+ * @param tView Current `TView`\n+ * @param rootIndex Pointer to the root (parent) tNode for the i18n.\n+ * @param createOpCodes OpCodes to process\n+ * @param lView Current `LView`\n+ */\n+export function applyCreateOpCodes(\n+    tView: TView, rootindex: number, createOpCodes: I18nMutateOpCodes, lView: LView): number[] {\n+  const renderer = lView[RENDERER];\n+  let currentTNode: TNode|null = null;\n+  let previousTNode: TNode|null = null;\n+  const visitedNodes: number[] = [];\n+  for (let i = 0; i < createOpCodes.length; i++) {\n+    const opCode = createOpCodes[i];\n+    if (typeof opCode == 'string') {\n+      const textRNode = createTextNode(opCode, renderer);\n+      const textNodeIndex = createOpCodes[++i] as number;\n+      ngDevMode && ngDevMode.rendererCreateTextNode++;\n+      previousTNode = currentTNode;\n+      currentTNode =\n+          createDynamicNodeAtIndex(tView, lView, textNodeIndex, TNodeType.Element, textRNode, null);\n+      visitedNodes.push(textNodeIndex);\n+      setIsNotParent();\n+    } else if (typeof opCode == 'number') {\n+      switch (opCode & I18nMutateOpCode.MASK_INSTRUCTION) {\n+        case I18nMutateOpCode.AppendChild:\n+          const destinationNodeIndex = opCode >>> I18nMutateOpCode.SHIFT_PARENT;\n+          let destinationTNode: TNode;\n+          if (destinationNodeIndex === rootindex) {\n+            // If the destination node is `i18nStart`, we don't have a\n+            // top-level node and we should use the host node instead\n+            destinationTNode = lView[T_HOST]!;\n+          } else {\n+            destinationTNode = getTNode(tView, destinationNodeIndex);\n+          }\n+          ngDevMode &&\n+              assertDefined(\n+                  currentTNode!,\n+                  `You need to create or select a node before you can insert it into the DOM`);\n+          previousTNode =\n+              appendI18nNode(tView, currentTNode!, destinationTNode, previousTNode, lView);\n+          break;\n+        case I18nMutateOpCode.Select:\n+          // Negative indices indicate that a given TNode is a sibling node, not a parent node\n+          // (see `i18nStartFirstPass` for additional information).\n+          const isParent = opCode >= 0;\n+          // FIXME(misko): This SHIFT_REF looks suspect as it does not have mask.\n+          const nodeIndex = (isParent ? opCode : ~opCode) >>> I18nMutateOpCode.SHIFT_REF;\n+          visitedNodes.push(nodeIndex);\n+          previousTNode = currentTNode;\n+          currentTNode = getTNode(tView, nodeIndex);\n+          if (currentTNode) {\n+            setPreviousOrParentTNode(currentTNode, isParent);\n+          }\n+          break;\n+        case I18nMutateOpCode.ElementEnd:\n+          const elementIndex = opCode >>> I18nMutateOpCode.SHIFT_REF;\n+          previousTNode = currentTNode = getTNode(tView, elementIndex);\n+          setPreviousOrParentTNode(currentTNode, false);\n+          break;\n+        case I18nMutateOpCode.Attr:\n+          const elementNodeIndex = opCode >>> I18nMutateOpCode.SHIFT_REF;\n+          const attrName = createOpCodes[++i] as string;\n+          const attrValue = createOpCodes[++i] as string;\n+          // This code is used for ICU expressions only, since we don't support\n+          // directives/components in ICUs, we don't need to worry about inputs here\n+          elementAttributeInternal(\n+              getTNode(tView, elementNodeIndex), lView, attrName, attrValue, null, null);\n+          break;\n+        default:\n+          throw new Error(`Unable to determine the type of mutate operation for \"${opCode}\"`);\n+      }\n+    } else {\n+      switch (opCode) {\n+        case COMMENT_MARKER:\n+          const commentValue = createOpCodes[++i] as string;\n+          const commentNodeIndex = createOpCodes[++i] as number;\n+          ngDevMode &&\n+              assertEqual(\n+                  typeof commentValue, 'string',\n+                  `Expected \"${commentValue}\" to be a comment node value`);\n+          const commentRNode = renderer.createComment(commentValue);\n+          ngDevMode && ngDevMode.rendererCreateComment++;\n+          previousTNode = currentTNode;\n+          currentTNode = createDynamicNodeAtIndex(\n+              tView, lView, commentNodeIndex, TNodeType.IcuContainer, commentRNode, null);\n+          visitedNodes.push(commentNodeIndex);\n+          attachPatchData(commentRNode, lView);\n+          // We will add the case nodes later, during the update phase\n+          setIsNotParent();\n+          break;\n+        case ELEMENT_MARKER:\n+          const tagNameValue = createOpCodes[++i] as string;\n+          const elementNodeIndex = createOpCodes[++i] as number;\n+          ngDevMode &&\n+              assertEqual(\n+                  typeof tagNameValue, 'string',\n+                  `Expected \"${tagNameValue}\" to be an element node tag name`);\n+          const elementRNode = renderer.createElement(tagNameValue);\n+          ngDevMode && ngDevMode.rendererCreateElement++;\n+          previousTNode = currentTNode;\n+          currentTNode = createDynamicNodeAtIndex(\n+              tView, lView, elementNodeIndex, TNodeType.Element, elementRNode, tagNameValue);\n+          visitedNodes.push(elementNodeIndex);\n+          break;\n+        default:\n+          throw new Error(`Unable to determine the type of mutate operation for \"${opCode}\"`);\n+      }\n+    }\n+  }\n+\n+  setIsNotParent();\n+\n+  return visitedNodes;\n+}\n+\n+\n+/**\n+ * Apply `I18nUpdateOpCodes` OpCodes\n+ *\n+ * @param tView Current `TView`\n+ * @param tIcus If ICUs present than this contains them.\n+ * @param lView Current `LView`\n+ * @param updateOpCodes OpCodes to process\n+ * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n+ * @param changeMask Each bit corresponds to a `ɵɵi18nExp` (Counting backwards from\n+ *     `bindingsStartIndex`)\n+ */\n+export function applyUpdateOpCodes(\n+    tView: TView, tIcus: TIcu[]|null, lView: LView, updateOpCodes: I18nUpdateOpCodes,\n+    bindingsStartIndex: number, changeMask: number) {\n+  let caseCreated = false;\n+  for (let i = 0; i < updateOpCodes.length; i++) {\n+    // bit code to check if we should apply the next update\n+    const checkBit = updateOpCodes[i] as number;\n+    // Number of opCodes to skip until next set of update codes\n+    const skipCodes = updateOpCodes[++i] as number;\n+    if (checkBit & changeMask) {\n+      // The value has been updated since last checked\n+      let value = '';\n+      for (let j = i + 1; j <= (i + skipCodes); j++) {\n+        const opCode = updateOpCodes[j];\n+        if (typeof opCode == 'string') {\n+          value += opCode;\n+        } else if (typeof opCode == 'number') {\n+          if (opCode < 0) {\n+            // Negative opCode represent `i18nExp` values offset.\n+            value += renderStringify(lView[bindingsStartIndex - opCode]);\n+          } else {\n+            const nodeIndex = opCode >>> I18nUpdateOpCode.SHIFT_REF;\n+            switch (opCode & I18nUpdateOpCode.MASK_OPCODE) {\n+              case I18nUpdateOpCode.Attr:\n+                const propName = updateOpCodes[++j] as string;\n+                const sanitizeFn = updateOpCodes[++j] as SanitizerFn | null;\n+                elementPropertyInternal(\n+                    tView, getTNode(tView, nodeIndex), lView, propName, value, lView[RENDERER],\n+                    sanitizeFn, false);\n+                break;\n+              case I18nUpdateOpCode.Text:\n+                textBindingInternal(lView, nodeIndex, value);\n+                break;\n+              case I18nUpdateOpCode.IcuSwitch:\n+                caseCreated =\n+                    applyIcuSwitchCase(tView, tIcus!, updateOpCodes[++j] as number, lView, value);\n+                break;\n+              case I18nUpdateOpCode.IcuUpdate:\n+                applyIcuUpdateCase(\n+                    tView, tIcus!, updateOpCodes[++j] as number, bindingsStartIndex, lView,\n+                    caseCreated);\n+                break;\n+            }\n+          }\n+        }\n+      }\n+    }\n+    i += skipCodes;\n+  }\n+}\n+\n+/**\n+ * Apply OpCodes associated with updating an existing ICU.\n+ *\n+ * @param tView Current `TView`\n+ * @param tIcus ICUs active at this location.\n+ * @param tIcuIndex Index into `tIcus` to process.\n+ * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n+ * @param lView Current `LView`\n+ * @param changeMask Each bit corresponds to a `ɵɵi18nExp` (Counting backwards from\n+ *     `bindingsStartIndex`)\n+ */\n+function applyIcuUpdateCase(\n+    tView: TView, tIcus: TIcu[], tIcuIndex: number, bindingsStartIndex: number, lView: LView,\n+    caseCreated: boolean) {\n+  ngDevMode && assertIndexInRange(tIcus, tIcuIndex);\n+  const tIcu = tIcus[tIcuIndex];\n+  ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);\n+  const activeCaseIndex = lView[tIcu.currentCaseLViewIndex];\n+  if (activeCaseIndex !== null) {\n+    const mask = caseCreated ?\n+        -1 :  // -1 is same as all bits on, which simulates creation since it marks all bits dirty\n+        changeMask;\n+    applyUpdateOpCodes(tView, tIcus, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);\n+  }\n+}\n+\n+/**\n+ * Apply OpCodes associated with switching a case on ICU.\n+ *\n+ * This involves tearing down existing case and than building up a new case.\n+ *\n+ * @param tView Current `TView`\n+ * @param tIcus ICUs active at this location.\n+ * @param tICuIndex Index into `tIcus` to process.\n+ * @param lView Current `LView`\n+ * @param value Value of the case to update to.\n+ * @returns true if a new case was created (needed so that the update executes regardless of the\n+ *     bitmask)\n+ */\n+function applyIcuSwitchCase(\n+    tView: TView, tIcus: TIcu[], tICuIndex: number, lView: LView, value: string): boolean {\n+  applyIcuSwitchCaseRemove(tView, tIcus, tICuIndex, lView);\n+\n+  // Rebuild a new case for this ICU\n+  let caseCreated = false;\n+  const tIcu = tIcus[tICuIndex];\n+  const caseIndex = getCaseIndex(tIcu, value);\n+  lView[tIcu.currentCaseLViewIndex] = caseIndex !== -1 ? caseIndex : null;\n+  if (caseIndex > -1) {\n+    // Add the nodes for the new case\n+    applyCreateOpCodes(\n+        tView, -1,  // -1 means we don't have parent node\n+        tIcu.create[caseIndex], lView);\n+    caseCreated = true;\n+  }\n+  return caseCreated;\n+}\n+\n+/**\n+ * Apply OpCodes associated with tearing down of DOM.\n+ *\n+ * This involves tearing down existing case and than building up a new case.\n+ *\n+ * @param tView Current `TView`\n+ * @param tIcus ICUs active at this location.\n+ * @param tIcuIndex Index into `tIcus` to process.\n+ * @param lView Current `LView`\n+ * @returns true if a new case was created (needed so that the update executes regardless of the\n+ *     bitmask)\n+ */\n+function applyIcuSwitchCaseRemove(tView: TView, tIcus: TIcu[], tIcuIndex: number, lView: LView) {\n+  ngDevMode && assertIndexInRange(tIcus, tIcuIndex);\n+  const tIcu = tIcus[tIcuIndex];\n+  const activeCaseIndex = lView[tIcu.currentCaseLViewIndex];\n+  if (activeCaseIndex !== null) {\n+    const removeCodes = tIcu.remove[activeCaseIndex];\n+    for (let k = 0; k < removeCodes.length; k++) {\n+      const removeOpCode = removeCodes[k] as number;\n+      const nodeOrIcuIndex = removeOpCode >>> I18nMutateOpCode.SHIFT_REF;\n+      switch (removeOpCode & I18nMutateOpCode.MASK_INSTRUCTION) {\n+        case I18nMutateOpCode.Remove:\n+          // FIXME(misko): this comment is wrong!\n+          // Remove DOM element, but do *not* mark TNode as detached, since we are\n+          // just switching ICU cases (while keeping the same TNode), so a DOM element\n+          // representing a new ICU case will be re-created.\n+          removeNode(tView, lView, nodeOrIcuIndex, /* markAsDetached */ false);\n+          break;\n+        case I18nMutateOpCode.RemoveNestedIcu:\n+          applyIcuSwitchCaseRemove(tView, tIcus, nodeOrIcuIndex, lView);\n+          break;\n+      }\n+    }\n+  }\n+}\n+\n+function appendI18nNode(\n+    tView: TView, tNode: TNode, parentTNode: TNode, previousTNode: TNode|null,\n+    lView: LView): TNode {\n+  ngDevMode && ngDevMode.rendererMoveNode++;\n+  const nextNode = tNode.next;\n+  if (!previousTNode) {\n+    previousTNode = parentTNode;\n+  }\n+\n+  // Re-organize node tree to put this node in the correct position.\n+  if (previousTNode === parentTNode && tNode !== parentTNode.child) {\n+    tNode.next = parentTNode.child;\n+    parentTNode.child = tNode;\n+  } else if (previousTNode !== parentTNode && tNode !== previousTNode.next) {\n+    tNode.next = previousTNode.next;\n+    previousTNode.next = tNode;\n+  } else {\n+    tNode.next = null;\n+  }\n+\n+  if (parentTNode !== lView[T_HOST]) {\n+    tNode.parent = parentTNode as TElementNode;\n+  }\n+\n+  // If tNode was moved around, we might need to fix a broken link.\n+  let cursor: TNode|null = tNode.next;\n+  while (cursor) {\n+    if (cursor.next === tNode) {\n+      cursor.next = nextNode;\n+    }\n+    cursor = cursor.next;\n+  }\n+\n+  // If the placeholder to append is a projection, we need to move the projected nodes instead\n+  if (tNode.type === TNodeType.Projection) {\n+    applyProjection(tView, lView, tNode as TProjectionNode);\n+    return tNode;\n+  }\n+\n+  appendChild(tView, lView, getNativeByTNode(tNode, lView), tNode);\n+\n+  const slotValue = lView[tNode.index];\n+  if (tNode.type !== TNodeType.Container && isLContainer(slotValue)) {\n+    // Nodes that inject ViewContainerRef also have a comment node that should be moved\n+    appendChild(tView, lView, slotValue[NATIVE], tNode);\n+  }\n+  return tNode;\n+}\n+\n+/**\n+ * See `i18nEnd` above.\n+ */\n+export function i18nEndFirstPass(tView: TView, lView: LView) {\n+  ngDevMode &&\n+      assertEqual(\n+          getBindingIndex(), tView.bindingStartIndex,\n+          'i18nEnd should be called before any binding');\n+\n+  const rootIndex = popI18nIndex();\n+  const tI18n = tView.data[rootIndex + HEADER_OFFSET] as TI18n;\n+  ngDevMode && assertDefined(tI18n, `You should call i18nStart before i18nEnd`);\n+\n+  // Find the last node that was added before `i18nEnd`\n+  const lastCreatedNode = getPreviousOrParentTNode();\n+\n+  // Read the instructions to insert/move/remove DOM elements\n+  const visitedNodes = applyCreateOpCodes(tView, rootIndex, tI18n.create, lView);\n+\n+  // Remove deleted nodes\n+  let index = rootIndex + 1;\n+  while (index <= lastCreatedNode.index - HEADER_OFFSET) {\n+    if (visitedNodes.indexOf(index) === -1) {\n+      removeNode(tView, lView, index, /* markAsDetached */ true);\n+    }\n+    // Check if an element has any local refs and skip them\n+    const tNode = getTNode(tView, index);\n+    if (tNode &&\n+        (tNode.type === TNodeType.Container || tNode.type === TNodeType.Element ||\n+         tNode.type === TNodeType.ElementContainer) &&\n+        tNode.localNames !== null) {\n+      // Divide by 2 to get the number of local refs,\n+      // since they are stored as an array that also includes directive indexes,\n+      // i.e. [\"localRef\", directiveIndex, ...]\n+      index += tNode.localNames.length >> 1;\n+    }\n+    index++;\n+  }\n+}\n+\n+function removeNode(tView: TView, lView: LView, index: number, markAsDetached: boolean) {\n+  const removedPhTNode = getTNode(tView, index);\n+  const removedPhRNode = getNativeByIndex(index, lView);\n+  if (removedPhRNode) {\n+    nativeRemoveNode(lView[RENDERER], removedPhRNode);\n+  }\n+\n+  const slotValue = load(lView, index) as RElement | RComment | LContainer;\n+  if (isLContainer(slotValue)) {\n+    const lContainer = slotValue as LContainer;\n+    if (removedPhTNode.type !== TNodeType.Container) {\n+      nativeRemoveNode(lView[RENDERER], lContainer[NATIVE]);\n+    }\n+  }\n+\n+  if (markAsDetached) {\n+    // Define this node as detached to avoid projecting it later\n+    removedPhTNode.flags |= TNodeFlags.isDetached;\n+  }\n+  ngDevMode && ngDevMode.rendererRemoveNode++;\n+}\n+\n+/**\n+ * Creates and stores the dynamic TNode, and unhooks it from the tree for now.\n+ */\n+function createDynamicNodeAtIndex(\n+    tView: TView, lView: LView, index: number, type: TNodeType, native: RElement|RText|null,\n+    name: string|null): TElementNode|TIcuContainerNode {\n+  const previousOrParentTNode = getPreviousOrParentTNode();\n+  ngDevMode && assertIndexInRange(lView, index + HEADER_OFFSET);\n+  lView[index + HEADER_OFFSET] = native;\n+  // FIXME(misko): Why does this create A TNode??? I would not expect this to be here.\n+  const tNode = getOrCreateTNode(tView, lView[T_HOST], index, type as any, name, null);\n+\n+  // We are creating a dynamic node, the previous tNode might not be pointing at this node.\n+  // We will link ourselves into the tree later with `appendI18nNode`.\n+  if (previousOrParentTNode && previousOrParentTNode.next === tNode) {\n+    previousOrParentTNode.next = null;\n+  }\n+\n+  return tNode;\n+}\n+\n+\n+/**\n+ * Returns the index of the current case of an ICU expression depending on the main binding value\n+ *\n+ * @param icuExpression\n+ * @param bindingValue The value of the main binding used by this ICU expression\n+ */\n+function getCaseIndex(icuExpression: TIcu, bindingValue: string): number {\n+  let index = icuExpression.cases.indexOf(bindingValue);\n+  if (index === -1) {\n+    switch (icuExpression.type) {\n+      case IcuType.plural: {\n+        const resolvedCase = getPluralCase(bindingValue, getLocaleId());\n+        index = icuExpression.cases.indexOf(resolvedCase);\n+        if (index === -1 && resolvedCase !== 'other') {\n+          index = icuExpression.cases.indexOf('other');\n+        }\n+        break;\n+      }\n+      case IcuType.select: {\n+        index = icuExpression.cases.indexOf('other');\n+        break;\n+      }\n+    }\n+  }\n+  return index;\n+}"
        },
        {
            "sha": "9c89b86e66eb3b7a44f7491194335d6bf49a1050",
            "filename": "packages/core/src/render3/i18n/i18n_debug.ts",
            "status": "renamed",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_debug.ts",
            "raw_url": "https://github.com/angular/angular/raw/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_debug.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_debug.ts?ref=250e299dc32de91b4b94f7f43be84bfd6968b020",
            "patch": "@@ -6,9 +6,9 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {assertNumber, assertString} from '../util/assert';\n+import {assertNumber, assertString} from '../../util/assert';\n \n-import {COMMENT_MARKER, ELEMENT_MARKER, getInstructionFromI18nMutateOpCode, getParentFromI18nMutateOpCode, getRefFromI18nMutateOpCode, I18nMutateOpCode, I18nMutateOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes} from './interfaces/i18n';\n+import {COMMENT_MARKER, ELEMENT_MARKER, getInstructionFromI18nMutateOpCode, getParentFromI18nMutateOpCode, getRefFromI18nMutateOpCode, I18nMutateOpCode, I18nMutateOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes} from '../interfaces/i18n';\n \n /**\n  * Converts `I18nUpdateOpCodes` array into a human readable format.",
            "previous_filename": "packages/core/src/render3/i18n_debug.ts"
        },
        {
            "sha": "66d90748542566c51efe4d051b8bac9976a34e05",
            "filename": "packages/core/src/render3/i18n/i18n_locale_id.ts",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/angular/angular/blob/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_locale_id.ts",
            "raw_url": "https://github.com/angular/angular/raw/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_locale_id.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_locale_id.ts?ref=250e299dc32de91b4b94f7f43be84bfd6968b020",
            "patch": "@@ -0,0 +1,41 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {DEFAULT_LOCALE_ID} from '../../i18n/localization';\n+import {assertDefined} from '../../util/assert';\n+\n+\n+/**\n+ * The locale id that the application is currently using (for translations and ICU expressions).\n+ * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n+ * but is now defined as a global value.\n+ */\n+let LOCALE_ID = DEFAULT_LOCALE_ID;\n+\n+/**\n+ * Sets the locale id that will be used for translations and ICU expressions.\n+ * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n+ * but is now defined as a global value.\n+ *\n+ * @param localeId\n+ */\n+export function setLocaleId(localeId: string) {\n+  assertDefined(localeId, `Expected localeId to be defined`);\n+  if (typeof localeId === 'string') {\n+    LOCALE_ID = localeId.toLowerCase().replace(/_/g, '-');\n+  }\n+}\n+\n+/**\n+ * Gets the locale id that will be used for translations and ICU expressions.\n+ * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n+ * but is now defined as a global value.\n+ */\n+export function getLocaleId(): string {\n+  return LOCALE_ID;\n+}"
        },
        {
            "sha": "37949652438cbf0dc8c2891f5b6443c00bf83dec",
            "filename": "packages/core/src/render3/i18n/i18n_parse.ts",
            "status": "added",
            "additions": 733,
            "deletions": 0,
            "changes": 733,
            "blob_url": "https://github.com/angular/angular/blob/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_parse.ts",
            "raw_url": "https://github.com/angular/angular/raw/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_parse.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_parse.ts?ref=250e299dc32de91b4b94f7f43be84bfd6968b020",
            "patch": "@@ -0,0 +1,733 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import '../../util/ng_dev_mode';\n+import '../../util/ng_i18n_closure_mode';\n+\n+import {getTemplateContent, SRCSET_ATTRS, URI_ATTRS, VALID_ATTRS, VALID_ELEMENTS} from '../../sanitization/html_sanitizer';\n+import {getInertBodyHelper} from '../../sanitization/inert_body';\n+import {_sanitizeUrl, sanitizeSrcset} from '../../sanitization/url_sanitizer';\n+import {addAllToArray} from '../../util/array_utils';\n+import {assertEqual} from '../../util/assert';\n+import {allocExpando, elementAttributeInternal, setInputsForProperty, setNgReflectProperties} from '../instructions/shared';\n+import {getDocument} from '../interfaces/document';\n+import {COMMENT_MARKER, ELEMENT_MARKER, I18nMutateOpCode, I18nMutateOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, IcuCase, IcuExpression, IcuType, TI18n, TIcu} from '../interfaces/i18n';\n+import {TNodeType} from '../interfaces/node';\n+import {RComment, RElement} from '../interfaces/renderer';\n+import {SanitizerFn} from '../interfaces/sanitization';\n+import {HEADER_OFFSET, LView, T_HOST, TView} from '../interfaces/view';\n+import {getIsParent, getPreviousOrParentTNode} from '../state';\n+import {attachDebugGetter} from '../util/debug_utils';\n+import {getNativeByIndex, getTNode} from '../util/view_utils';\n+\n+import {i18nMutateOpCodesToString, i18nUpdateOpCodesToString} from './i18n_debug';\n+\n+\n+\n+const BINDING_REGEXP = /�(\\d+):?\\d*�/gi;\n+const ICU_REGEXP = /({\\s*�\\d+:?\\d*�\\s*,\\s*\\S{6}\\s*,[\\s\\S]*})/gi;\n+const NESTED_ICU = /�(\\d+)�/;\n+const ICU_BLOCK_REGEXP = /^\\s*(�\\d+:?\\d*�)\\s*,\\s*(select|plural)\\s*,/;\n+\n+\n+// Count for the number of vars that will be allocated for each i18n block.\n+// It is global because this is used in multiple functions that include loops and recursive calls.\n+// This is reset to 0 when `i18nStartFirstPass` is called.\n+let i18nVarsCount: number;\n+\n+const parentIndexStack: number[] = [];\n+\n+const MARKER = `�`;\n+const SUBTEMPLATE_REGEXP = /�\\/?\\*(\\d+:\\d+)�/gi;\n+const PH_REGEXP = /�(\\/?[#*!]\\d+):?\\d*�/gi;\n+const enum TagType {\n+  ELEMENT = '#',\n+  TEMPLATE = '*',\n+  PROJECTION = '!',\n+}\n+\n+/**\n+ * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\n+ * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\n+ * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n+ * and later on replaced by a space. We are re-implementing the same idea here, since translations\n+ * might contain this special character.\n+ */\n+const NGSP_UNICODE_REGEXP = /\\uE500/g;\n+function replaceNgsp(value: string): string {\n+  return value.replace(NGSP_UNICODE_REGEXP, ' ');\n+}\n+\n+\n+/**\n+ * See `i18nStart` above.\n+ */\n+export function i18nStartFirstPass(\n+    lView: LView, tView: TView, index: number, message: string, subTemplateIndex?: number) {\n+  const startIndex = tView.blueprint.length - HEADER_OFFSET;\n+  i18nVarsCount = 0;\n+  const previousOrParentTNode = getPreviousOrParentTNode();\n+  const parentTNode =\n+      getIsParent() ? previousOrParentTNode : previousOrParentTNode && previousOrParentTNode.parent;\n+  let parentIndex =\n+      parentTNode && parentTNode !== lView[T_HOST] ? parentTNode.index - HEADER_OFFSET : index;\n+  let parentIndexPointer = 0;\n+  parentIndexStack[parentIndexPointer] = parentIndex;\n+  const createOpCodes: I18nMutateOpCodes = [];\n+  if (ngDevMode) {\n+    attachDebugGetter(createOpCodes, i18nMutateOpCodesToString);\n+  }\n+  // If the previous node wasn't the direct parent then we have a translation without top level\n+  // element and we need to keep a reference of the previous element if there is one. We should also\n+  // keep track whether an element was a parent node or not, so that the logic that consumes\n+  // the generated `I18nMutateOpCode`s can leverage this information to properly set TNode state\n+  // (whether it's a parent or sibling).\n+  if (index > 0 && previousOrParentTNode !== parentTNode) {\n+    let previousTNodeIndex = previousOrParentTNode.index - HEADER_OFFSET;\n+    // If current TNode is a sibling node, encode it using a negative index. This information is\n+    // required when the `Select` action is processed (see the `readCreateOpCodes` function).\n+    if (!getIsParent()) {\n+      previousTNodeIndex = ~previousTNodeIndex;\n+    }\n+    // Create an OpCode to select the previous TNode\n+    createOpCodes.push(previousTNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Select);\n+  }\n+  const updateOpCodes: I18nUpdateOpCodes = [];\n+  if (ngDevMode) {\n+    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n+  }\n+  const icuExpressions: TIcu[] = [];\n+\n+  if (message === '' && isRootTemplateMessage(subTemplateIndex)) {\n+    // If top level translation is an empty string, do not invoke additional processing\n+    // and just create op codes for empty text node instead.\n+    createOpCodes.push(\n+        message, allocNodeIndex(startIndex),\n+        parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n+  } else {\n+    const templateTranslation = getTranslationForTemplate(message, subTemplateIndex);\n+    const msgParts = replaceNgsp(templateTranslation).split(PH_REGEXP);\n+    for (let i = 0; i < msgParts.length; i++) {\n+      let value = msgParts[i];\n+      if (i & 1) {\n+        // Odd indexes are placeholders (elements and sub-templates)\n+        if (value.charAt(0) === '/') {\n+          // It is a closing tag\n+          if (value.charAt(1) === TagType.ELEMENT) {\n+            const phIndex = parseInt(value.substr(2), 10);\n+            parentIndex = parentIndexStack[--parentIndexPointer];\n+            createOpCodes.push(phIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.ElementEnd);\n+          }\n+        } else {\n+          const phIndex = parseInt(value.substr(1), 10);\n+          const isElement = value.charAt(0) === TagType.ELEMENT;\n+          // The value represents a placeholder that we move to the designated index.\n+          // Note: positive indicies indicate that a TNode with a given index should also be marked\n+          // as parent while executing `Select` instruction.\n+          createOpCodes.push(\n+              (isElement ? phIndex : ~phIndex) << I18nMutateOpCode.SHIFT_REF |\n+                  I18nMutateOpCode.Select,\n+              parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n+\n+          if (isElement) {\n+            parentIndexStack[++parentIndexPointer] = parentIndex = phIndex;\n+          }\n+        }\n+      } else {\n+        // Even indexes are text (including bindings & ICU expressions)\n+        const parts = extractParts(value);\n+        for (let j = 0; j < parts.length; j++) {\n+          if (j & 1) {\n+            // Odd indexes are ICU expressions\n+            const icuExpression = parts[j] as IcuExpression;\n+\n+            // Verify that ICU expression has the right shape. Translations might contain invalid\n+            // constructions (while original messages were correct), so ICU parsing at runtime may\n+            // not succeed (thus `icuExpression` remains a string).\n+            if (typeof icuExpression !== 'object') {\n+              throw new Error(\n+                  `Unable to parse ICU expression in \"${templateTranslation}\" message.`);\n+            }\n+\n+            // Create the comment node that will anchor the ICU expression\n+            const icuNodeIndex = allocNodeIndex(startIndex);\n+            createOpCodes.push(\n+                COMMENT_MARKER, ngDevMode ? `ICU ${icuNodeIndex}` : '', icuNodeIndex,\n+                parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n+\n+            // Update codes for the ICU expression\n+            const mask = getBindingMask(icuExpression);\n+            icuStart(icuExpressions, icuExpression, icuNodeIndex, icuNodeIndex);\n+            // Since this is recursive, the last TIcu that was pushed is the one we want\n+            const tIcuIndex = icuExpressions.length - 1;\n+            updateOpCodes.push(\n+                toMaskBit(icuExpression.mainBinding),  // mask of the main binding\n+                3,                                     // skip 3 opCodes if not changed\n+                -1 - icuExpression.mainBinding,\n+                icuNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuSwitch, tIcuIndex,\n+                mask,  // mask of all the bindings of this ICU expression\n+                2,     // skip 2 opCodes if not changed\n+                icuNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuUpdate, tIcuIndex);\n+          } else if (parts[j] !== '') {\n+            const text = parts[j] as string;\n+            // Even indexes are text (including bindings)\n+            const hasBinding = text.match(BINDING_REGEXP);\n+            // Create text nodes\n+            const textNodeIndex = allocNodeIndex(startIndex);\n+            createOpCodes.push(\n+                // If there is a binding, the value will be set during update\n+                hasBinding ? '' : text, textNodeIndex,\n+                parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n+\n+            if (hasBinding) {\n+              addAllToArray(generateBindingUpdateOpCodes(text, textNodeIndex), updateOpCodes);\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  if (i18nVarsCount > 0) {\n+    allocExpando(tView, lView, i18nVarsCount);\n+  }\n+\n+  // NOTE: local var needed to properly assert the type of `TI18n`.\n+  const tI18n: TI18n = {\n+    vars: i18nVarsCount,\n+    create: createOpCodes,\n+    update: updateOpCodes,\n+    icus: icuExpressions.length ? icuExpressions : null,\n+  };\n+\n+  tView.data[index + HEADER_OFFSET] = tI18n;\n+}\n+\n+/**\n+ * See `i18nAttributes` above.\n+ */\n+export function i18nAttributesFirstPass(\n+    lView: LView, tView: TView, index: number, values: string[]) {\n+  const previousElement = getPreviousOrParentTNode();\n+  const previousElementIndex = previousElement.index - HEADER_OFFSET;\n+  const updateOpCodes: I18nUpdateOpCodes = [];\n+  if (ngDevMode) {\n+    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n+  }\n+  for (let i = 0; i < values.length; i += 2) {\n+    const attrName = values[i];\n+    const message = values[i + 1];\n+    const parts = message.split(ICU_REGEXP);\n+    for (let j = 0; j < parts.length; j++) {\n+      const value = parts[j];\n+\n+      if (j & 1) {\n+        // Odd indexes are ICU expressions\n+        // TODO(ocombe): support ICU expressions in attributes\n+        throw new Error('ICU expressions are not yet supported in attributes');\n+      } else if (value !== '') {\n+        // Even indexes are text (including bindings)\n+        const hasBinding = !!value.match(BINDING_REGEXP);\n+        if (hasBinding) {\n+          if (tView.firstCreatePass && tView.data[index + HEADER_OFFSET] === null) {\n+            addAllToArray(\n+                generateBindingUpdateOpCodes(value, previousElementIndex, attrName), updateOpCodes);\n+          }\n+        } else {\n+          const tNode = getTNode(tView, previousElementIndex);\n+          // Set attributes for Elements only, for other types (like ElementContainer),\n+          // only set inputs below\n+          if (tNode.type === TNodeType.Element) {\n+            elementAttributeInternal(tNode, lView, attrName, value, null, null);\n+          }\n+          // Check if that attribute is a directive input\n+          const dataValue = tNode.inputs !== null && tNode.inputs[attrName];\n+          if (dataValue) {\n+            setInputsForProperty(tView, lView, dataValue, attrName, value);\n+            if (ngDevMode) {\n+              const element = getNativeByIndex(previousElementIndex, lView) as RElement | RComment;\n+              setNgReflectProperties(lView, element, tNode.type, dataValue, value);\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  if (tView.firstCreatePass && tView.data[index + HEADER_OFFSET] === null) {\n+    tView.data[index + HEADER_OFFSET] = updateOpCodes;\n+  }\n+}\n+\n+\n+/**\n+ * Generate the OpCodes to update the bindings of a string.\n+ *\n+ * @param str The string containing the bindings.\n+ * @param destinationNode Index of the destination node which will receive the binding.\n+ * @param attrName Name of the attribute, if the string belongs to an attribute.\n+ * @param sanitizeFn Sanitization function used to sanitize the string after update, if necessary.\n+ */\n+export function generateBindingUpdateOpCodes(\n+    str: string, destinationNode: number, attrName?: string,\n+    sanitizeFn: SanitizerFn|null = null): I18nUpdateOpCodes {\n+  const updateOpCodes: I18nUpdateOpCodes = [null, null];  // Alloc space for mask and size\n+  if (ngDevMode) {\n+    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n+  }\n+  const textParts = str.split(BINDING_REGEXP);\n+  let mask = 0;\n+\n+  for (let j = 0; j < textParts.length; j++) {\n+    const textValue = textParts[j];\n+\n+    if (j & 1) {\n+      // Odd indexes are bindings\n+      const bindingIndex = parseInt(textValue, 10);\n+      updateOpCodes.push(-1 - bindingIndex);\n+      mask = mask | toMaskBit(bindingIndex);\n+    } else if (textValue !== '') {\n+      // Even indexes are text\n+      updateOpCodes.push(textValue);\n+    }\n+  }\n+\n+  updateOpCodes.push(\n+      destinationNode << I18nUpdateOpCode.SHIFT_REF |\n+      (attrName ? I18nUpdateOpCode.Attr : I18nUpdateOpCode.Text));\n+  if (attrName) {\n+    updateOpCodes.push(attrName, sanitizeFn);\n+  }\n+  updateOpCodes[0] = mask;\n+  updateOpCodes[1] = updateOpCodes.length - 2;\n+  return updateOpCodes;\n+}\n+\n+function getBindingMask(icuExpression: IcuExpression, mask = 0): number {\n+  mask = mask | toMaskBit(icuExpression.mainBinding);\n+  let match;\n+  for (let i = 0; i < icuExpression.values.length; i++) {\n+    const valueArr = icuExpression.values[i];\n+    for (let j = 0; j < valueArr.length; j++) {\n+      const value = valueArr[j];\n+      if (typeof value === 'string') {\n+        while (match = BINDING_REGEXP.exec(value)) {\n+          mask = mask | toMaskBit(parseInt(match[1], 10));\n+        }\n+      } else {\n+        mask = getBindingMask(value as IcuExpression, mask);\n+      }\n+    }\n+  }\n+  return mask;\n+}\n+\n+function allocNodeIndex(startIndex: number): number {\n+  return startIndex + i18nVarsCount++;\n+}\n+\n+\n+/**\n+ * Convert binding index to mask bit.\n+ *\n+ * Each index represents a single bit on the bit-mask. Because bit-mask only has 32 bits, we make\n+ * the 32nd bit share all masks for all bindings higher than 32. Since it is extremely rare to have\n+ * more than 32 bindings this will be hit very rarely. The downside of hitting this corner case is\n+ * that we will execute binding code more often than necessary. (penalty of performance)\n+ */\n+function toMaskBit(bindingIndex: number): number {\n+  return 1 << Math.min(bindingIndex, 31);\n+}\n+\n+export function isRootTemplateMessage(subTemplateIndex: number|\n+                                      undefined): subTemplateIndex is undefined {\n+  return subTemplateIndex === undefined;\n+}\n+\n+\n+/**\n+ * Removes everything inside the sub-templates of a message.\n+ */\n+function removeInnerTemplateTranslation(message: string): string {\n+  let match;\n+  let res = '';\n+  let index = 0;\n+  let inTemplate = false;\n+  let tagMatched;\n+\n+  while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {\n+    if (!inTemplate) {\n+      res += message.substring(index, match.index + match[0].length);\n+      tagMatched = match[1];\n+      inTemplate = true;\n+    } else {\n+      if (match[0] === `${MARKER}/*${tagMatched}${MARKER}`) {\n+        index = match.index;\n+        inTemplate = false;\n+      }\n+    }\n+  }\n+\n+  ngDevMode &&\n+      assertEqual(\n+          inTemplate, false,\n+          `Tag mismatch: unable to find the end of the sub-template in the translation \"${\n+              message}\"`);\n+\n+  res += message.substr(index);\n+  return res;\n+}\n+\n+\n+/**\n+ * Extracts a part of a message and removes the rest.\n+ *\n+ * This method is used for extracting a part of the message associated with a template. A translated\n+ * message can span multiple templates.\n+ *\n+ * Example:\n+ * ```\n+ * <div i18n>Translate <span *ngIf>me</span>!</div>\n+ * ```\n+ *\n+ * @param message The message to crop\n+ * @param subTemplateIndex Index of the sub-template to extract. If undefined it returns the\n+ * external template and removes all sub-templates.\n+ */\n+export function getTranslationForTemplate(message: string, subTemplateIndex?: number) {\n+  if (isRootTemplateMessage(subTemplateIndex)) {\n+    // We want the root template message, ignore all sub-templates\n+    return removeInnerTemplateTranslation(message);\n+  } else {\n+    // We want a specific sub-template\n+    const start =\n+        message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;\n+    const end = message.search(new RegExp(`${MARKER}\\\\/\\\\*\\\\d+:${subTemplateIndex}${MARKER}`));\n+    return removeInnerTemplateTranslation(message.substring(start, end));\n+  }\n+}\n+\n+/**\n+ * Generate the OpCodes for ICU expressions.\n+ *\n+ * @param tIcus\n+ * @param icuExpression\n+ * @param startIndex\n+ * @param expandoStartIndex\n+ */\n+export function icuStart(\n+    tIcus: TIcu[], icuExpression: IcuExpression, startIndex: number,\n+    expandoStartIndex: number): void {\n+  const createCodes: I18nMutateOpCodes[] = [];\n+  const removeCodes: I18nMutateOpCodes[] = [];\n+  const updateCodes: I18nUpdateOpCodes[] = [];\n+  const vars = [];\n+  const childIcus: number[][] = [];\n+  const values = icuExpression.values;\n+  for (let i = 0; i < values.length; i++) {\n+    // Each value is an array of strings & other ICU expressions\n+    const valueArr = values[i];\n+    const nestedIcus: IcuExpression[] = [];\n+    for (let j = 0; j < valueArr.length; j++) {\n+      const value = valueArr[j];\n+      if (typeof value !== 'string') {\n+        // It is an nested ICU expression\n+        const icuIndex = nestedIcus.push(value as IcuExpression) - 1;\n+        // Replace nested ICU expression by a comment node\n+        valueArr[j] = `<!--�${icuIndex}�-->`;\n+      }\n+    }\n+    const icuCase: IcuCase =\n+        parseIcuCase(valueArr.join(''), startIndex, nestedIcus, tIcus, expandoStartIndex);\n+    createCodes.push(icuCase.create);\n+    removeCodes.push(icuCase.remove);\n+    updateCodes.push(icuCase.update);\n+    vars.push(icuCase.vars);\n+    childIcus.push(icuCase.childIcus);\n+  }\n+  const tIcu: TIcu = {\n+    type: icuExpression.type,\n+    vars,\n+    currentCaseLViewIndex: HEADER_OFFSET +\n+        expandoStartIndex  // expandoStartIndex does not include the header so add it.\n+        + 1,               // The first item stored is the `<!--ICU #-->` anchor so skip it.\n+    childIcus,\n+    cases: icuExpression.cases,\n+    create: createCodes,\n+    remove: removeCodes,\n+    update: updateCodes\n+  };\n+  tIcus.push(tIcu);\n+  // Adding the maximum possible of vars needed (based on the cases with the most vars)\n+  i18nVarsCount += Math.max(...vars);\n+}\n+\n+/**\n+ * Parses text containing an ICU expression and produces a JSON object for it.\n+ * Original code from closure library, modified for Angular.\n+ *\n+ * @param pattern Text containing an ICU expression that needs to be parsed.\n+ *\n+ */\n+export function parseICUBlock(pattern: string): IcuExpression {\n+  const cases = [];\n+  const values: (string|IcuExpression)[][] = [];\n+  let icuType = IcuType.plural;\n+  let mainBinding = 0;\n+  pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str: string, binding: string, type: string) {\n+    if (type === 'select') {\n+      icuType = IcuType.select;\n+    } else {\n+      icuType = IcuType.plural;\n+    }\n+    mainBinding = parseInt(binding.substr(1), 10);\n+    return '';\n+  });\n+\n+  const parts = extractParts(pattern) as string[];\n+  // Looking for (key block)+ sequence. One of the keys has to be \"other\".\n+  for (let pos = 0; pos < parts.length;) {\n+    let key = parts[pos++].trim();\n+    if (icuType === IcuType.plural) {\n+      // Key can be \"=x\", we just want \"x\"\n+      key = key.replace(/\\s*(?:=)?(\\w+)\\s*/, '$1');\n+    }\n+    if (key.length) {\n+      cases.push(key);\n+    }\n+\n+    const blocks = extractParts(parts[pos++]) as string[];\n+    if (cases.length > values.length) {\n+      values.push(blocks);\n+    }\n+  }\n+\n+  // TODO(ocombe): support ICU expressions in attributes, see #21615\n+  return {type: icuType, mainBinding: mainBinding, cases, values};\n+}\n+\n+\n+/**\n+ * Transforms a string template into an HTML template and a list of instructions used to update\n+ * attributes or nodes that contain bindings.\n+ *\n+ * @param unsafeHtml The string to parse\n+ * @param parentIndex\n+ * @param nestedIcus\n+ * @param tIcus\n+ * @param expandoStartIndex\n+ */\n+function parseIcuCase(\n+    unsafeHtml: string, parentIndex: number, nestedIcus: IcuExpression[], tIcus: TIcu[],\n+    expandoStartIndex: number): IcuCase {\n+  const inertBodyHelper = getInertBodyHelper(getDocument());\n+  const inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n+  if (!inertBodyElement) {\n+    throw new Error('Unable to generate inert body element');\n+  }\n+  const wrapper = getTemplateContent(inertBodyElement!) as Element || inertBodyElement;\n+  const opCodes: IcuCase = {\n+    vars: 1,  // allocate space for `TIcu.currentCaseLViewIndex`\n+    childIcus: [],\n+    create: [],\n+    remove: [],\n+    update: []\n+  };\n+  if (ngDevMode) {\n+    attachDebugGetter(opCodes.create, i18nMutateOpCodesToString);\n+    attachDebugGetter(opCodes.remove, i18nMutateOpCodesToString);\n+    attachDebugGetter(opCodes.update, i18nUpdateOpCodesToString);\n+  }\n+  parseNodes(wrapper.firstChild, opCodes, parentIndex, nestedIcus, tIcus, expandoStartIndex);\n+  return opCodes;\n+}\n+\n+/**\n+ * Breaks pattern into strings and top level {...} blocks.\n+ * Can be used to break a message into text and ICU expressions, or to break an ICU expression into\n+ * keys and cases.\n+ * Original code from closure library, modified for Angular.\n+ *\n+ * @param pattern (sub)Pattern to be broken.\n+ *\n+ */\n+function extractParts(pattern: string): (string|IcuExpression)[] {\n+  if (!pattern) {\n+    return [];\n+  }\n+\n+  let prevPos = 0;\n+  const braceStack = [];\n+  const results: (string|IcuExpression)[] = [];\n+  const braces = /[{}]/g;\n+  // lastIndex doesn't get set to 0 so we have to.\n+  braces.lastIndex = 0;\n+\n+  let match;\n+  while (match = braces.exec(pattern)) {\n+    const pos = match.index;\n+    if (match[0] == '}') {\n+      braceStack.pop();\n+\n+      if (braceStack.length == 0) {\n+        // End of the block.\n+        const block = pattern.substring(prevPos, pos);\n+        if (ICU_BLOCK_REGEXP.test(block)) {\n+          results.push(parseICUBlock(block));\n+        } else {\n+          results.push(block);\n+        }\n+\n+        prevPos = pos + 1;\n+      }\n+    } else {\n+      if (braceStack.length == 0) {\n+        const substring = pattern.substring(prevPos, pos);\n+        results.push(substring);\n+        prevPos = pos + 1;\n+      }\n+      braceStack.push('{');\n+    }\n+  }\n+\n+  const substring = pattern.substring(prevPos);\n+  results.push(substring);\n+  return results;\n+}\n+\n+\n+/**\n+ * Parses a node, its children and its siblings, and generates the mutate & update OpCodes.\n+ *\n+ * @param currentNode The first node to parse\n+ * @param icuCase The data for the ICU expression case that contains those nodes\n+ * @param parentIndex Index of the current node's parent\n+ * @param nestedIcus Data for the nested ICU expressions that this case contains\n+ * @param tIcus Data for all ICU expressions of the current message\n+ * @param expandoStartIndex Expando start index for the current ICU expression\n+ */\n+export function parseNodes(\n+    currentNode: Node|null, icuCase: IcuCase, parentIndex: number, nestedIcus: IcuExpression[],\n+    tIcus: TIcu[], expandoStartIndex: number) {\n+  if (currentNode) {\n+    const nestedIcusToCreate: [IcuExpression, number][] = [];\n+    while (currentNode) {\n+      const nextNode: Node|null = currentNode.nextSibling;\n+      const newIndex = expandoStartIndex + ++icuCase.vars;\n+      switch (currentNode.nodeType) {\n+        case Node.ELEMENT_NODE:\n+          const element = currentNode as Element;\n+          const tagName = element.tagName.toLowerCase();\n+          if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\n+            // This isn't a valid element, we won't create an element for it\n+            icuCase.vars--;\n+          } else {\n+            icuCase.create.push(\n+                ELEMENT_MARKER, tagName, newIndex,\n+                parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n+            const elAttrs = element.attributes;\n+            for (let i = 0; i < elAttrs.length; i++) {\n+              const attr = elAttrs.item(i)!;\n+              const lowerAttrName = attr.name.toLowerCase();\n+              const hasBinding = !!attr.value.match(BINDING_REGEXP);\n+              // we assume the input string is safe, unless it's using a binding\n+              if (hasBinding) {\n+                if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {\n+                  if (URI_ATTRS[lowerAttrName]) {\n+                    addAllToArray(\n+                        generateBindingUpdateOpCodes(attr.value, newIndex, attr.name, _sanitizeUrl),\n+                        icuCase.update);\n+                  } else if (SRCSET_ATTRS[lowerAttrName]) {\n+                    addAllToArray(\n+                        generateBindingUpdateOpCodes(\n+                            attr.value, newIndex, attr.name, sanitizeSrcset),\n+                        icuCase.update);\n+                  } else {\n+                    addAllToArray(\n+                        generateBindingUpdateOpCodes(attr.value, newIndex, attr.name),\n+                        icuCase.update);\n+                  }\n+                } else {\n+                  ngDevMode &&\n+                      console.warn(`WARNING: ignoring unsafe attribute value ${\n+                          lowerAttrName} on element ${tagName} (see http://g.co/ng/security#xss)`);\n+                }\n+              } else {\n+                icuCase.create.push(\n+                    newIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Attr, attr.name,\n+                    attr.value);\n+              }\n+            }\n+            // Parse the children of this node (if any)\n+            parseNodes(\n+                currentNode.firstChild, icuCase, newIndex, nestedIcus, tIcus, expandoStartIndex);\n+            // Remove the parent node after the children\n+            icuCase.remove.push(newIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove);\n+          }\n+          break;\n+        case Node.TEXT_NODE:\n+          const value = currentNode.textContent || '';\n+          const hasBinding = value.match(BINDING_REGEXP);\n+          icuCase.create.push(\n+              hasBinding ? '' : value, newIndex,\n+              parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n+          icuCase.remove.push(newIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove);\n+          if (hasBinding) {\n+            addAllToArray(generateBindingUpdateOpCodes(value, newIndex), icuCase.update);\n+          }\n+          break;\n+        case Node.COMMENT_NODE:\n+          // Check if the comment node is a placeholder for a nested ICU\n+          const match = NESTED_ICU.exec(currentNode.textContent || '');\n+          if (match) {\n+            const nestedIcuIndex = parseInt(match[1], 10);\n+            const newLocal = ngDevMode ? `nested ICU ${nestedIcuIndex}` : '';\n+            // Create the comment node that will anchor the ICU expression\n+            icuCase.create.push(\n+                COMMENT_MARKER, newLocal, newIndex,\n+                parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n+            const nestedIcu = nestedIcus[nestedIcuIndex];\n+            nestedIcusToCreate.push([nestedIcu, newIndex]);\n+          } else {\n+            // We do not handle any other type of comment\n+            icuCase.vars--;\n+          }\n+          break;\n+        default:\n+          // We do not handle any other type of element\n+          icuCase.vars--;\n+      }\n+      currentNode = nextNode!;\n+    }\n+\n+    for (let i = 0; i < nestedIcusToCreate.length; i++) {\n+      const nestedIcu = nestedIcusToCreate[i][0];\n+      const nestedIcuNodeIndex = nestedIcusToCreate[i][1];\n+      icuStart(tIcus, nestedIcu, nestedIcuNodeIndex, expandoStartIndex + icuCase.vars);\n+      // Since this is recursive, the last TIcu that was pushed is the one we want\n+      const nestTIcuIndex = tIcus.length - 1;\n+      icuCase.vars += Math.max(...tIcus[nestTIcuIndex].vars);\n+      icuCase.childIcus.push(nestTIcuIndex);\n+      const mask = getBindingMask(nestedIcu);\n+      icuCase.update.push(\n+          toMaskBit(nestedIcu.mainBinding),  // mask of the main binding\n+          3,                                 // skip 3 opCodes if not changed\n+          -1 - nestedIcu.mainBinding,\n+          nestedIcuNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuSwitch,\n+          // FIXME(misko): Index should be part of the opcode\n+          nestTIcuIndex,\n+          mask,  // mask of all the bindings of this ICU expression\n+          2,     // skip 2 opCodes if not changed\n+          nestedIcuNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuUpdate,\n+          nestTIcuIndex);\n+      icuCase.remove.push(\n+          nestTIcuIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.RemoveNestedIcu,\n+          // FIXME(misko): Index should be part of the opcode\n+          nestedIcuNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove);\n+    }\n+  }\n+}"
        },
        {
            "sha": "10ecf87f092dc1d6d5c23e06c771c01a0cce9735",
            "filename": "packages/core/src/render3/i18n/i18n_postprocess.ts",
            "status": "added",
            "additions": 134,
            "deletions": 0,
            "changes": 134,
            "blob_url": "https://github.com/angular/angular/blob/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_postprocess.ts",
            "raw_url": "https://github.com/angular/angular/raw/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_postprocess.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_postprocess.ts?ref=250e299dc32de91b4b94f7f43be84bfd6968b020",
            "patch": "@@ -0,0 +1,134 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+// i18nPostprocess consts\n+const ROOT_TEMPLATE_ID = 0;\n+const PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]/;\n+const PP_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]|(�\\/?\\*\\d+:\\d+�)/g;\n+const PP_ICU_VARS_REGEXP = /({\\s*)(VAR_(PLURAL|SELECT)(_\\d+)?)(\\s*,)/g;\n+const PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;\n+const PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\\d+)?)�/g;\n+const PP_CLOSE_TEMPLATE_REGEXP = /\\/\\*/;\n+const PP_TEMPLATE_ID_REGEXP = /\\d+\\:(\\d+)/;\n+\n+// Parsed placeholder structure used in postprocessing (within `i18nPostprocess` function)\n+// Contains the following fields: [templateId, isCloseTemplateTag, placeholder]\n+type PostprocessPlaceholder = [number, boolean, string];\n+\n+\n+/**\n+ * Handles message string post-processing for internationalization.\n+ *\n+ * Handles message string post-processing by transforming it from intermediate\n+ * format (that might contain some markers that we need to replace) to the final\n+ * form, consumable by i18nStart instruction. Post processing steps include:\n+ *\n+ * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n+ * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n+ * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n+ * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n+ *    in case multiple ICUs have the same placeholder name\n+ *\n+ * @param message Raw translation string for post processing\n+ * @param replacements Set of replacements that should be applied\n+ *\n+ * @returns Transformed string that can be consumed by i18nStart instruction\n+ *\n+ * @codeGenApi\n+ */\n+export function i18nPostprocess(\n+    message: string, replacements: {[key: string]: (string|string[])} = {}): string {\n+  /**\n+   * Step 1: resolve all multi-value placeholders like [�#5�|�*1:1��#2:1�|�#4:1�]\n+   *\n+   * Note: due to the way we process nested templates (BFS), multi-value placeholders are typically\n+   * grouped by templates, for example: [�#5�|�#6�|�#1:1�|�#3:2�] where �#5� and �#6� belong to root\n+   * template, �#1:1� belong to nested template with index 1 and �#1:2� - nested template with index\n+   * 3. However in real templates the order might be different: i.e. �#1:1� and/or �#3:2� may go in\n+   * front of �#6�. The post processing step restores the right order by keeping track of the\n+   * template id stack and looks for placeholders that belong to the currently active template.\n+   */\n+  let result: string = message;\n+  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {\n+    const matches: {[key: string]: PostprocessPlaceholder[]} = {};\n+    const templateIdsStack: number[] = [ROOT_TEMPLATE_ID];\n+    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m: any, phs: string, tmpl: string): string => {\n+      const content = phs || tmpl;\n+      const placeholders: PostprocessPlaceholder[] = matches[content] || [];\n+      if (!placeholders.length) {\n+        content.split('|').forEach((placeholder: string) => {\n+          const match = placeholder.match(PP_TEMPLATE_ID_REGEXP);\n+          const templateId = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;\n+          const isCloseTemplateTag = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);\n+          placeholders.push([templateId, isCloseTemplateTag, placeholder]);\n+        });\n+        matches[content] = placeholders;\n+      }\n+\n+      if (!placeholders.length) {\n+        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);\n+      }\n+\n+      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];\n+      let idx = 0;\n+      // find placeholder index that matches current template id\n+      for (let i = 0; i < placeholders.length; i++) {\n+        if (placeholders[i][0] === currentTemplateId) {\n+          idx = i;\n+          break;\n+        }\n+      }\n+      // update template id stack based on the current tag extracted\n+      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];\n+      if (isCloseTemplateTag) {\n+        templateIdsStack.pop();\n+      } else if (currentTemplateId !== templateId) {\n+        templateIdsStack.push(templateId);\n+      }\n+      // remove processed tag from the list\n+      placeholders.splice(idx, 1);\n+      return placeholder;\n+    });\n+  }\n+\n+  // return current result if no replacements specified\n+  if (!Object.keys(replacements).length) {\n+    return result;\n+  }\n+\n+  /**\n+   * Step 2: replace all ICU vars (like \"VAR_PLURAL\")\n+   */\n+  result = result.replace(PP_ICU_VARS_REGEXP, (match, start, key, _type, _idx, end): string => {\n+    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match;\n+  });\n+\n+  /**\n+   * Step 3: replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n+   */\n+  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match, key): string => {\n+    return replacements.hasOwnProperty(key) ? replacements[key] as string : match;\n+  });\n+\n+  /**\n+   * Step 4: replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�) in case\n+   * multiple ICUs have the same placeholder name\n+   */\n+  result = result.replace(PP_ICUS_REGEXP, (match, key): string => {\n+    if (replacements.hasOwnProperty(key)) {\n+      const list = replacements[key] as string[];\n+      if (!list.length) {\n+        throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);\n+      }\n+      return list.shift()!;\n+    }\n+    return match;\n+  });\n+\n+  return result;\n+}"
        },
        {
            "sha": "4374446383e1927ec895483dc1909bf1c84f25ea",
            "filename": "packages/core/src/render3/index.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Findex.ts?ref=250e299dc32de91b4b94f7f43be84bfd6968b020",
            "patch": "@@ -16,7 +16,7 @@ import {getComponent, getDirectives, getHostElement, getRenderedText} from './ut\n \n export {ComponentFactory, ComponentFactoryResolver, ComponentRef, injectComponentFactoryResolver} from './component_ref';\n export {ɵɵgetFactoryOf, ɵɵgetInheritedFactory} from './di';\n-export {getLocaleId, setLocaleId, ɵɵi18n, ɵɵi18nApply, ɵɵi18nAttributes, ɵɵi18nEnd, ɵɵi18nExp, ɵɵi18nPostprocess, ɵɵi18nStart,} from './i18n';\n+export {getLocaleId, setLocaleId} from './i18n/i18n_locale_id';\n // clang-format off\n export {\n   detectChanges,\n@@ -129,6 +129,7 @@ export {\n   ɵɵtextInterpolate8,\n   ɵɵtextInterpolateV,\n } from './instructions/all';\n+export {ɵɵi18n, ɵɵi18nApply, ɵɵi18nAttributes, ɵɵi18nEnd, ɵɵi18nExp,ɵɵi18nPostprocess, ɵɵi18nStart} from './instructions/i18n';\n export {RenderFlags} from './interfaces/definition';\n export {\n   AttributeMarker"
        },
        {
            "sha": "bcc865e8d277a74ec5c0a594fdbd1cca616db952",
            "filename": "packages/core/src/render3/instructions/i18n.ts",
            "status": "added",
            "additions": 176,
            "deletions": 0,
            "changes": 176,
            "blob_url": "https://github.com/angular/angular/blob/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fi18n.ts",
            "raw_url": "https://github.com/angular/angular/raw/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fi18n.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fi18n.ts?ref=250e299dc32de91b4b94f7f43be84bfd6968b020",
            "patch": "@@ -0,0 +1,176 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import '../../util/ng_dev_mode';\n+import '../../util/ng_i18n_closure_mode';\n+\n+import {assertDefined} from '../../util/assert';\n+import {bindingUpdated} from '../bindings';\n+import {applyI18n, i18nEndFirstPass, pushI18nIndex, setMaskBit} from '../i18n/i18n_apply';\n+import {i18nAttributesFirstPass, i18nStartFirstPass} from '../i18n/i18n_parse';\n+import {i18nPostprocess} from '../i18n/i18n_postprocess';\n+import {HEADER_OFFSET} from '../interfaces/view';\n+import {getLView, getTView, nextBindingIndex} from '../state';\n+\n+import {setDelayProjection} from './all';\n+\n+/**\n+ * Marks a block of text as translatable.\n+ *\n+ * The instructions `i18nStart` and `i18nEnd` mark the translation block in the template.\n+ * The translation `message` is the value which is locale specific. The translation string may\n+ * contain placeholders which associate inner elements and sub-templates within the translation.\n+ *\n+ * The translation `message` placeholders are:\n+ * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n+ *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n+ *   `block` that matches the sub-template in which it was declared.\n+ * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n+ *   and end of DOM element that were embedded in the original translation block. The placeholder\n+ *   `index` points to the element index in the template instructions set. An optional `block` that\n+ *   matches the sub-template in which it was declared.\n+ * - `�!{index}(:{block})�`/`�/!{index}(:{block})�`: *Projection Placeholder*:  Marks the\n+ *   beginning and end of <ng-content> that was embedded in the original translation block.\n+ *   The placeholder `index` points to the element index in the template instructions set.\n+ *   An optional `block` that matches the sub-template in which it was declared.\n+ * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n+ *   split up and translated separately in each angular template function. The `index` points to the\n+ *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n+ *\n+ * @param index A unique index of the translation in the static block.\n+ * @param message The translation message.\n+ * @param subTemplateIndex Optional sub-template index in the `message`.\n+ *\n+ * @codeGenApi\n+ */\n+export function ɵɵi18nStart(index: number, message: string, subTemplateIndex?: number): void {\n+  const tView = getTView();\n+  ngDevMode && assertDefined(tView, `tView should be defined`);\n+  pushI18nIndex(index);\n+  // We need to delay projections until `i18nEnd`\n+  setDelayProjection(true);\n+  if (tView.firstCreatePass && tView.data[index + HEADER_OFFSET] === null) {\n+    i18nStartFirstPass(getLView(), tView, index, message, subTemplateIndex);\n+  }\n+}\n+\n+\n+\n+/**\n+ * Translates a translation block marked by `i18nStart` and `i18nEnd`. It inserts the text/ICU nodes\n+ * into the render tree, moves the placeholder nodes and removes the deleted nodes.\n+ *\n+ * @codeGenApi\n+ */\n+export function ɵɵi18nEnd(): void {\n+  const lView = getLView();\n+  const tView = getTView();\n+  ngDevMode && assertDefined(tView, `tView should be defined`);\n+  i18nEndFirstPass(tView, lView);\n+  // Stop delaying projections\n+  setDelayProjection(false);\n+}\n+\n+/**\n+ *\n+ * Use this instruction to create a translation block that doesn't contain any placeholder.\n+ * It calls both {@link i18nStart} and {@link i18nEnd} in one instruction.\n+ *\n+ * The translation `message` is the value which is locale specific. The translation string may\n+ * contain placeholders which associate inner elements and sub-templates within the translation.\n+ *\n+ * The translation `message` placeholders are:\n+ * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be\n+ *   interpolated into. The placeholder `index` points to the expression binding index. An optional\n+ *   `block` that matches the sub-template in which it was declared.\n+ * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning\n+ *   and end of DOM element that were embedded in the original translation block. The placeholder\n+ *   `index` points to the element index in the template instructions set. An optional `block` that\n+ *   matches the sub-template in which it was declared.\n+ * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n+ *   split up and translated separately in each angular template function. The `index` points to the\n+ *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n+ *\n+ * @param index A unique index of the translation in the static block.\n+ * @param message The translation message.\n+ * @param subTemplateIndex Optional sub-template index in the `message`.\n+ *\n+ * @codeGenApi\n+ */\n+export function ɵɵi18n(index: number, message: string, subTemplateIndex?: number): void {\n+  ɵɵi18nStart(index, message, subTemplateIndex);\n+  ɵɵi18nEnd();\n+}\n+\n+/**\n+ * Marks a list of attributes as translatable.\n+ *\n+ * @param index A unique index in the static block\n+ * @param values\n+ *\n+ * @codeGenApi\n+ */\n+export function ɵɵi18nAttributes(index: number, values: string[]): void {\n+  const lView = getLView();\n+  const tView = getTView();\n+  ngDevMode && assertDefined(tView, `tView should be defined`);\n+  i18nAttributesFirstPass(lView, tView, index, values);\n+}\n+\n+\n+/**\n+ * Stores the values of the bindings during each update cycle in order to determine if we need to\n+ * update the translated nodes.\n+ *\n+ * @param value The binding's value\n+ * @returns This function returns itself so that it may be chained\n+ * (e.g. `i18nExp(ctx.name)(ctx.title)`)\n+ *\n+ * @codeGenApi\n+ */\n+export function ɵɵi18nExp<T>(value: T): typeof ɵɵi18nExp {\n+  const lView = getLView();\n+  setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));\n+  return ɵɵi18nExp;\n+}\n+\n+/**\n+ * Updates a translation block or an i18n attribute when the bindings have changed.\n+ *\n+ * @param index Index of either {@link i18nStart} (translation block) or {@link i18nAttributes}\n+ * (i18n attribute) on which it should update the content.\n+ *\n+ * @codeGenApi\n+ */\n+export function ɵɵi18nApply(index: number) {\n+  applyI18n(getTView(), getLView(), index);\n+}\n+\n+/**\n+ * Handles message string post-processing for internationalization.\n+ *\n+ * Handles message string post-processing by transforming it from intermediate\n+ * format (that might contain some markers that we need to replace) to the final\n+ * form, consumable by i18nStart instruction. Post processing steps include:\n+ *\n+ * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])\n+ * 2. Replace all ICU vars (like \"VAR_PLURAL\")\n+ * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}\n+ * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)\n+ *    in case multiple ICUs have the same placeholder name\n+ *\n+ * @param message Raw translation string for post processing\n+ * @param replacements Set of replacements that should be applied\n+ *\n+ * @returns Transformed string that can be consumed by i18nStart instruction\n+ *\n+ * @codeGenApi\n+ */\n+export function ɵɵi18nPostprocess(\n+    message: string, replacements: {[key: string]: (string|string[])} = {}): string {\n+  return i18nPostprocess(message, replacements);\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "7270e0ece9f2f71238e0517d3e6e56b17e3bfc9b",
            "filename": "packages/core/src/render3/interfaces/i18n.ts",
            "status": "modified",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/angular/angular/blob/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fi18n.ts",
            "raw_url": "https://github.com/angular/angular/raw/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fi18n.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fi18n.ts?ref=250e299dc32de91b4b94f7f43be84bfd6968b020",
            "patch": "@@ -411,3 +411,41 @@ export interface TIcu {\n // Note: This hack is necessary so we don't erroneously get a circular dependency\n // failure based on types.\n export const unusedValueExportToPlacateAjd = 1;\n+\n+export interface IcuExpression {\n+  type: IcuType;\n+  mainBinding: number;\n+  cases: string[];\n+  values: (string|IcuExpression)[][];\n+}\n+\n+export interface IcuCase {\n+  /**\n+   * Number of slots to allocate in expando for this case.\n+   *\n+   * This is the max number of DOM elements which will be created by this i18n + ICU blocks. When\n+   * the DOM elements are being created they are stored in the EXPANDO, so that update OpCodes can\n+   * write into them.\n+   */\n+  vars: number;\n+\n+  /**\n+   * An optional array of child/sub ICUs.\n+   */\n+  childIcus: number[];\n+\n+  /**\n+   * A set of OpCodes to apply in order to build up the DOM render tree for the ICU\n+   */\n+  create: I18nMutateOpCodes;\n+\n+  /**\n+   * A set of OpCodes to apply in order to destroy the DOM render tree for the ICU.\n+   */\n+  remove: I18nMutateOpCodes;\n+\n+  /**\n+   * A set of OpCodes to apply in order to update the DOM render tree for the ICU bindings.\n+   */\n+  update: I18nUpdateOpCodes;\n+}"
        },
        {
            "sha": "4cb7227c6fb4a204f2bed98732f3ecb950d22814",
            "filename": "packages/core/src/render3/ng_module_ref.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Fng_module_ref.ts",
            "raw_url": "https://github.com/angular/angular/raw/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Fsrc%2Frender3%2Fng_module_ref.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fng_module_ref.ts?ref=250e299dc32de91b4b94f7f43be84bfd6968b020",
            "patch": "@@ -20,7 +20,7 @@ import {stringify} from '../util/stringify';\n \n import {ComponentFactoryResolver} from './component_ref';\n import {getNgLocaleIdDef, getNgModuleDef} from './definition';\n-import {setLocaleId} from './i18n';\n+import {setLocaleId} from './i18n/i18n_locale_id';\n import {maybeUnwrapFn} from './util/misc_utils';\n \n export interface NgModuleType<T = any> extends Type<T> {"
        },
        {
            "sha": "68fceaf27bb3ad0f1fb44efd753e4d0d22525dc5",
            "filename": "packages/core/test/render3/i18n_debug_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Ftest%2Frender3%2Fi18n_debug_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Ftest%2Frender3%2Fi18n_debug_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Fi18n_debug_spec.ts?ref=250e299dc32de91b4b94f7f43be84bfd6968b020",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {i18nMutateOpCodesToString, i18nUpdateOpCodesToString} from '@angular/core/src/render3/i18n_debug';\n+import {i18nMutateOpCodesToString, i18nUpdateOpCodesToString} from '@angular/core/src/render3/i18n/i18n_debug';\n import {COMMENT_MARKER, ELEMENT_MARKER, I18nMutateOpCode, I18nUpdateOpCode} from '@angular/core/src/render3/interfaces/i18n';\n \n describe('i18n debug', () => {"
        },
        {
            "sha": "249a18ffc790a0f2b414fce330827829d8a14801",
            "filename": "packages/core/test/render3/i18n_spec.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Ftest%2Frender3%2Fi18n_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/250e299dc32de91b4b94f7f43be84bfd6968b020/packages%2Fcore%2Ftest%2Frender3%2Fi18n_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Fi18n_spec.ts?ref=250e299dc32de91b4b94f7f43be84bfd6968b020",
            "patch": "@@ -6,12 +6,15 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n+import {ɵɵi18nAttributes, ɵɵi18nPostprocess, ɵɵi18nStart} from '@angular/core';\n+import {getTranslationForTemplate} from '@angular/core/src/render3/i18n/i18n_parse';\n+\n import {noop} from '../../../compiler/src/render3/view/util';\n-import {getTranslationForTemplate, ɵɵi18nAttributes, ɵɵi18nPostprocess, ɵɵi18nStart} from '../../src/render3/i18n';\n import {setDelayProjection, ɵɵelementEnd, ɵɵelementStart} from '../../src/render3/instructions/all';\n import {I18nUpdateOpCodes, TI18n, TIcu} from '../../src/render3/interfaces/i18n';\n import {HEADER_OFFSET, LView, TVIEW} from '../../src/render3/interfaces/view';\n import {getNativeByIndex} from '../../src/render3/util/view_utils';\n+\n import {TemplateFixture} from './render_util';\n import {debugMatch} from './utils';\n "
        }
    ],
    "stats": {
        "total": 3168,
        "additions": 1641,
        "deletions": 1527
    }
}