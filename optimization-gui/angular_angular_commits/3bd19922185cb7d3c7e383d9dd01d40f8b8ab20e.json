{
    "author": "AndrewKushnir",
    "message": "perf(forms): avoid direct references to the `Validators` class (#41189)\n\nCurrently the `Validators` class contains a number of static methods that represent different validators as well as some helper methods. Since class methods are not tree-shakable, any reference to the `Validator` class retains all of its methods (even if you've used just one).\n\nThis commit refactors the code to extract the logic into standalone functions and use these functions in the code instead of referencing them via `Validators` class. That should make the code more tree-shakable. The `Validators` class still retains its structure and calls these standalone methods internally to keep this change backwards-compatible.\n\nPR Close #41189",
    "sha": "3bd19922185cb7d3c7e383d9dd01d40f8b8ab20e",
    "files": [
        {
            "sha": "4095f9eeb9a5861d9883dbd44024043a90d89922",
            "filename": "packages/core/test/bundling/forms_reactive/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/3bd19922185cb7d3c7e383d9dd01d40f8b8ab20e/packages%2Fcore%2Ftest%2Fbundling%2Fforms_reactive%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/3bd19922185cb7d3c7e383d9dd01d40f8b8ab20e/packages%2Fcore%2Ftest%2Fbundling%2Fforms_reactive%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Fforms_reactive%2Fbundle.golden_symbols.json?ref=3bd19922185cb7d3c7e383d9dd01d40f8b8ab20e",
            "patch": "@@ -728,6 +728,12 @@\n   {\n     \"name\": \"collectStylingFromTAttrs\"\n   },\n+  {\n+    \"name\": \"compose\"\n+  },\n+  {\n+    \"name\": \"composeAsync\"\n+  },\n   {\n     \"name\": \"composeAsyncValidators\"\n   },\n@@ -1343,6 +1349,9 @@\n   {\n     \"name\": \"notFoundValueOrThrow\"\n   },\n+  {\n+    \"name\": \"nullValidator\"\n+  },\n   {\n     \"name\": \"observable\"\n   },"
        },
        {
            "sha": "ca569af0597c05e3862d60cea43dca54362c4d88",
            "filename": "packages/core/test/bundling/forms_template_driven/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 0,
            "deletions": 12,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/3bd19922185cb7d3c7e383d9dd01d40f8b8ab20e/packages%2Fcore%2Ftest%2Fbundling%2Fforms_template_driven%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/3bd19922185cb7d3c7e383d9dd01d40f8b8ab20e/packages%2Fcore%2Ftest%2Fbundling%2Fforms_template_driven%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Fforms_template_driven%2Fbundle.golden_symbols.json?ref=3bd19922185cb7d3c7e383d9dd01d40f8b8ab20e",
            "patch": "@@ -167,9 +167,6 @@\n   {\n     \"name\": \"DomSharedStylesHost\"\n   },\n-  {\n-    \"name\": \"EMAIL_REGEXP\"\n-  },\n   {\n     \"name\": \"EMPTY_ARRAY\"\n   },\n@@ -563,9 +560,6 @@\n   {\n     \"name\": \"VE_ViewContainerRef\"\n   },\n-  {\n-    \"name\": \"Validators\"\n-  },\n   {\n     \"name\": \"Version\"\n   },\n@@ -1046,9 +1040,6 @@\n   {\n     \"name\": \"hasTagAndTypeMatch\"\n   },\n-  {\n-    \"name\": \"hasValidLength\"\n-  },\n   {\n     \"name\": \"hostReportError\"\n   },\n@@ -1130,9 +1121,6 @@\n   {\n     \"name\": \"isDirectiveHost\"\n   },\n-  {\n-    \"name\": \"isEmptyInputValue\"\n-  },\n   {\n     \"name\": \"isForwardRef\"\n   },"
        },
        {
            "sha": "eff697b1286e11d5ec9e1d8a84aa5b582b9abcf3",
            "filename": "packages/forms/src/directives/validators.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 13,
            "changes": 26,
            "blob_url": "https://github.com/angular/angular/blob/3bd19922185cb7d3c7e383d9dd01d40f8b8ab20e/packages%2Fforms%2Fsrc%2Fdirectives%2Fvalidators.ts",
            "raw_url": "https://github.com/angular/angular/raw/3bd19922185cb7d3c7e383d9dd01d40f8b8ab20e/packages%2Fforms%2Fsrc%2Fdirectives%2Fvalidators.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Fsrc%2Fdirectives%2Fvalidators.ts?ref=3bd19922185cb7d3c7e383d9dd01d40f8b8ab20e",
            "patch": "@@ -10,7 +10,7 @@ import {Directive, forwardRef, Input, OnChanges, SimpleChanges, StaticProvider}\n import {Observable} from 'rxjs';\n \n import {AbstractControl} from '../model';\n-import {NG_VALIDATORS, Validators} from '../validators';\n+import {emailValidator, maxLengthValidator, maxValidator, minLengthValidator, minValidator, NG_VALIDATORS, nullValidator, patternValidator, requiredTrueValidator, requiredValidator} from '../validators';\n \n \n /**\n@@ -77,7 +77,7 @@ export interface Validator {\n  */\n @Directive()\n abstract class AbstractValidatorDirective implements Validator {\n-  private _validator: ValidatorFn = Validators.nullValidator;\n+  private _validator: ValidatorFn = nullValidator;\n   private _onChange!: () => void;\n \n   /**\n@@ -180,7 +180,7 @@ export class MaxValidator extends AbstractValidatorDirective implements OnChange\n   /** @internal */\n   normalizeInput = (input: string): number => parseInt(input, 10);\n   /** @internal */\n-  createValidator = (max: number): ValidatorFn => Validators.max(max);\n+  createValidator = (max: number): ValidatorFn => maxValidator(max);\n   /**\n    * Declare `ngOnChanges` lifecycle hook at the main directive level (vs keeping it in base class)\n    * to avoid differences in handling inheritance of lifecycle hooks between Ivy and ViewEngine in\n@@ -240,7 +240,7 @@ export class MinValidator extends AbstractValidatorDirective implements OnChange\n   /** @internal */\n   normalizeInput = (input: string): number => parseInt(input, 10);\n   /** @internal */\n-  createValidator = (min: number): ValidatorFn => Validators.min(min);\n+  createValidator = (min: number): ValidatorFn => minValidator(min);\n   /**\n    * Declare `ngOnChanges` lifecycle hook at the main directive level (vs keeping it in base class)\n    * to avoid differences in handling inheritance of lifecycle hooks between Ivy and ViewEngine in\n@@ -364,7 +364,7 @@ export class RequiredValidator implements Validator {\n    * @nodoc\n    */\n   validate(control: AbstractControl): ValidationErrors|null {\n-    return this.required ? Validators.required(control) : null;\n+    return this.required ? requiredValidator(control) : null;\n   }\n \n   /**\n@@ -411,7 +411,7 @@ export class CheckboxRequiredValidator extends RequiredValidator {\n    * @nodoc\n    */\n   validate(control: AbstractControl): ValidationErrors|null {\n-    return this.required ? Validators.requiredTrue(control) : null;\n+    return this.required ? requiredTrueValidator(control) : null;\n   }\n }\n \n@@ -472,7 +472,7 @@ export class EmailValidator implements Validator {\n    * @nodoc\n    */\n   validate(control: AbstractControl): ValidationErrors|null {\n-    return this._enabled ? Validators.email(control) : null;\n+    return this._enabled ? emailValidator(control) : null;\n   }\n \n   /**\n@@ -543,7 +543,7 @@ export const MIN_LENGTH_VALIDATOR: any = {\n   host: {'[attr.minlength]': 'minlength ? minlength : null'}\n })\n export class MinLengthValidator implements Validator, OnChanges {\n-  private _validator: ValidatorFn = Validators.nullValidator;\n+  private _validator: ValidatorFn = nullValidator;\n   private _onChange?: () => void;\n \n   /**\n@@ -579,7 +579,7 @@ export class MinLengthValidator implements Validator, OnChanges {\n   }\n \n   private _createValidator(): void {\n-    this._validator = Validators.minLength(\n+    this._validator = minLengthValidator(\n         typeof this.minlength === 'number' ? this.minlength : parseInt(this.minlength, 10));\n   }\n }\n@@ -621,7 +621,7 @@ export const MAX_LENGTH_VALIDATOR: any = {\n   host: {'[attr.maxlength]': 'maxlength ? maxlength : null'}\n })\n export class MaxLengthValidator implements Validator, OnChanges {\n-  private _validator: ValidatorFn = Validators.nullValidator;\n+  private _validator: ValidatorFn = nullValidator;\n   private _onChange?: () => void;\n \n   /**\n@@ -656,7 +656,7 @@ export class MaxLengthValidator implements Validator, OnChanges {\n   }\n \n   private _createValidator(): void {\n-    this._validator = Validators.maxLength(\n+    this._validator = maxLengthValidator(\n         typeof this.maxlength === 'number' ? this.maxlength : parseInt(this.maxlength, 10));\n   }\n }\n@@ -701,7 +701,7 @@ export const PATTERN_VALIDATOR: any = {\n   host: {'[attr.pattern]': 'pattern ? pattern : null'}\n })\n export class PatternValidator implements Validator, OnChanges {\n-  private _validator: ValidatorFn = Validators.nullValidator;\n+  private _validator: ValidatorFn = nullValidator;\n   private _onChange?: () => void;\n \n   /**\n@@ -736,6 +736,6 @@ export class PatternValidator implements Validator, OnChanges {\n   }\n \n   private _createValidator(): void {\n-    this._validator = Validators.pattern(this.pattern);\n+    this._validator = patternValidator(this.pattern);\n   }\n }"
        },
        {
            "sha": "009dbde39e7db680d67126379c8b51c05ae5fcad",
            "filename": "packages/forms/src/validators.ts",
            "status": "modified",
            "additions": 179,
            "deletions": 93,
            "changes": 272,
            "blob_url": "https://github.com/angular/angular/blob/3bd19922185cb7d3c7e383d9dd01d40f8b8ab20e/packages%2Fforms%2Fsrc%2Fvalidators.ts",
            "raw_url": "https://github.com/angular/angular/raw/3bd19922185cb7d3c7e383d9dd01d40f8b8ab20e/packages%2Fforms%2Fsrc%2Fvalidators.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Fsrc%2Fvalidators.ts?ref=3bd19922185cb7d3c7e383d9dd01d40f8b8ab20e",
            "patch": "@@ -113,7 +113,6 @@ export class Validators {\n   /**\n    * @description\n    * Validator that requires the control's value to be greater than or equal to the provided number.\n-   * The validator exists only as a function and not as a directive.\n    *\n    * @usageNotes\n    *\n@@ -132,21 +131,12 @@ export class Validators {\n    *\n    */\n   static min(min: number): ValidatorFn {\n-    return (control: AbstractControl): ValidationErrors|null => {\n-      if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {\n-        return null;  // don't validate empty values to allow optional controls\n-      }\n-      const value = parseFloat(control.value);\n-      // Controls with NaN values after parsing should be treated as not having a\n-      // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min\n-      return !isNaN(value) && value < min ? {'min': {'min': min, 'actual': control.value}} : null;\n-    };\n+    return minValidator(min);\n   }\n \n   /**\n    * @description\n    * Validator that requires the control's value to be less than or equal to the provided number.\n-   * The validator exists only as a function and not as a directive.\n    *\n    * @usageNotes\n    *\n@@ -165,15 +155,7 @@ export class Validators {\n    *\n    */\n   static max(max: number): ValidatorFn {\n-    return (control: AbstractControl): ValidationErrors|null => {\n-      if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {\n-        return null;  // don't validate empty values to allow optional controls\n-      }\n-      const value = parseFloat(control.value);\n-      // Controls with NaN values after parsing should be treated as not having a\n-      // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max\n-      return !isNaN(value) && value > max ? {'max': {'max': max, 'actual': control.value}} : null;\n-    };\n+    return maxValidator(max);\n   }\n \n   /**\n@@ -197,7 +179,7 @@ export class Validators {\n    *\n    */\n   static required(control: AbstractControl): ValidationErrors|null {\n-    return isEmptyInputValue(control.value) ? {'required': true} : null;\n+    return requiredValidator(control);\n   }\n \n   /**\n@@ -222,7 +204,7 @@ export class Validators {\n    *\n    */\n   static requiredTrue(control: AbstractControl): ValidationErrors|null {\n-    return control.value === true ? null : {'required': true};\n+    return requiredTrueValidator(control);\n   }\n \n   /**\n@@ -262,10 +244,7 @@ export class Validators {\n    *\n    */\n   static email(control: AbstractControl): ValidationErrors|null {\n-    if (isEmptyInputValue(control.value)) {\n-      return null;  // don't validate empty values to allow optional controls\n-    }\n-    return EMAIL_REGEXP.test(control.value) ? null : {'email': true};\n+    return emailValidator(control);\n   }\n \n   /**\n@@ -299,17 +278,7 @@ export class Validators {\n    *\n    */\n   static minLength(minLength: number): ValidatorFn {\n-    return (control: AbstractControl): ValidationErrors|null => {\n-      if (isEmptyInputValue(control.value) || !hasValidLength(control.value)) {\n-        // don't validate empty values to allow optional controls\n-        // don't validate values without `length` property\n-        return null;\n-      }\n-\n-      return control.value.length < minLength ?\n-          {'minlength': {'requiredLength': minLength, 'actualLength': control.value.length}} :\n-          null;\n-    };\n+    return minLengthValidator(minLength);\n   }\n \n   /**\n@@ -340,11 +309,7 @@ export class Validators {\n    *\n    */\n   static maxLength(maxLength: number): ValidatorFn {\n-    return (control: AbstractControl): ValidationErrors|null => {\n-      return hasValidLength(control.value) && control.value.length > maxLength ?\n-          {'maxlength': {'requiredLength': maxLength, 'actualLength': control.value.length}} :\n-          null;\n-    };\n+    return maxLengthValidator(maxLength);\n   }\n \n   /**\n@@ -397,31 +362,7 @@ export class Validators {\n    *\n    */\n   static pattern(pattern: string|RegExp): ValidatorFn {\n-    if (!pattern) return Validators.nullValidator;\n-    let regex: RegExp;\n-    let regexStr: string;\n-    if (typeof pattern === 'string') {\n-      regexStr = '';\n-\n-      if (pattern.charAt(0) !== '^') regexStr += '^';\n-\n-      regexStr += pattern;\n-\n-      if (pattern.charAt(pattern.length - 1) !== '$') regexStr += '$';\n-\n-      regex = new RegExp(regexStr);\n-    } else {\n-      regexStr = pattern.toString();\n-      regex = pattern;\n-    }\n-    return (control: AbstractControl): ValidationErrors|null => {\n-      if (isEmptyInputValue(control.value)) {\n-        return null;  // don't validate empty values to allow optional controls\n-      }\n-      const value: string = control.value;\n-      return regex.test(value) ? null :\n-                                 {'pattern': {'requiredPattern': regexStr, 'actualValue': value}};\n-    };\n+    return patternValidator(pattern);\n   }\n \n   /**\n@@ -432,7 +373,7 @@ export class Validators {\n    *\n    */\n   static nullValidator(control: AbstractControl): ValidationErrors|null {\n-    return null;\n+    return nullValidator(control);\n   }\n \n   /**\n@@ -449,13 +390,7 @@ export class Validators {\n   static compose(validators: null): null;\n   static compose(validators: (ValidatorFn|null|undefined)[]): ValidatorFn|null;\n   static compose(validators: (ValidatorFn|null|undefined)[]|null): ValidatorFn|null {\n-    if (!validators) return null;\n-    const presentValidators: ValidatorFn[] = validators.filter(isPresent) as any;\n-    if (presentValidators.length == 0) return null;\n-\n-    return function(control: AbstractControl) {\n-      return mergeErrors(executeValidators<ValidatorFn>(control, presentValidators));\n-    };\n+    return compose(validators);\n   }\n \n   /**\n@@ -470,16 +405,137 @@ export class Validators {\n    *\n    */\n   static composeAsync(validators: (AsyncValidatorFn|null)[]): AsyncValidatorFn|null {\n-    if (!validators) return null;\n-    const presentValidators: AsyncValidatorFn[] = validators.filter(isPresent) as any;\n-    if (presentValidators.length == 0) return null;\n-\n-    return function(control: AbstractControl) {\n-      const observables =\n-          executeValidators<AsyncValidatorFn>(control, presentValidators).map(toObservable);\n-      return forkJoin(observables).pipe(map(mergeErrors));\n-    };\n+    return composeAsync(validators);\n+  }\n+}\n+\n+/**\n+ * Validator that requires the control's value to be greater than or equal to the provided number.\n+ * See `Validators.min` for additional information.\n+ */\n+export function minValidator(min: number): ValidatorFn {\n+  return (control: AbstractControl): ValidationErrors|null => {\n+    if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {\n+      return null;  // don't validate empty values to allow optional controls\n+    }\n+    const value = parseFloat(control.value);\n+    // Controls with NaN values after parsing should be treated as not having a\n+    // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min\n+    return !isNaN(value) && value < min ? {'min': {'min': min, 'actual': control.value}} : null;\n+  };\n+}\n+\n+/**\n+ * Validator that requires the control's value to be less than or equal to the provided number.\n+ * See `Validators.max` for additional information.\n+ */\n+export function maxValidator(max: number): ValidatorFn {\n+  return (control: AbstractControl): ValidationErrors|null => {\n+    if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {\n+      return null;  // don't validate empty values to allow optional controls\n+    }\n+    const value = parseFloat(control.value);\n+    // Controls with NaN values after parsing should be treated as not having a\n+    // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max\n+    return !isNaN(value) && value > max ? {'max': {'max': max, 'actual': control.value}} : null;\n+  };\n+}\n+\n+/**\n+ * Validator that requires the control have a non-empty value.\n+ * See `Validators.required` for additional information.\n+ */\n+export function requiredValidator(control: AbstractControl): ValidationErrors|null {\n+  return isEmptyInputValue(control.value) ? {'required': true} : null;\n+}\n+\n+/**\n+ * Validator that requires the control's value be true. This validator is commonly\n+ * used for required checkboxes.\n+ * See `Validators.requiredTrue` for additional information.\n+ */\n+export function requiredTrueValidator(control: AbstractControl): ValidationErrors|null {\n+  return control.value === true ? null : {'required': true};\n+}\n+\n+/**\n+ * Validator that requires the control's value pass an email validation test.\n+ * See `Validators.email` for additional information.\n+ */\n+export function emailValidator(control: AbstractControl): ValidationErrors|null {\n+  if (isEmptyInputValue(control.value)) {\n+    return null;  // don't validate empty values to allow optional controls\n+  }\n+  return EMAIL_REGEXP.test(control.value) ? null : {'email': true};\n+}\n+\n+/**\n+ * Validator that requires the length of the control's value to be greater than or equal\n+ * to the provided minimum length. See `Validators.minLength` for additional information.\n+ */\n+export function minLengthValidator(minLength: number): ValidatorFn {\n+  return (control: AbstractControl): ValidationErrors|null => {\n+    if (isEmptyInputValue(control.value) || !hasValidLength(control.value)) {\n+      // don't validate empty values to allow optional controls\n+      // don't validate values without `length` property\n+      return null;\n+    }\n+\n+    return control.value.length < minLength ?\n+        {'minlength': {'requiredLength': minLength, 'actualLength': control.value.length}} :\n+        null;\n+  };\n+}\n+\n+/**\n+ * Validator that requires the length of the control's value to be less than or equal\n+ * to the provided maximum length. See `Validators.maxLength` for additional information.\n+ */\n+export function maxLengthValidator(maxLength: number): ValidatorFn {\n+  return (control: AbstractControl): ValidationErrors|null => {\n+    return hasValidLength(control.value) && control.value.length > maxLength ?\n+        {'maxlength': {'requiredLength': maxLength, 'actualLength': control.value.length}} :\n+        null;\n+  };\n+}\n+\n+/**\n+ * Validator that requires the control's value to match a regex pattern.\n+ * See `Validators.pattern` for additional information.\n+ */\n+export function patternValidator(pattern: string|RegExp): ValidatorFn {\n+  if (!pattern) return nullValidator;\n+  let regex: RegExp;\n+  let regexStr: string;\n+  if (typeof pattern === 'string') {\n+    regexStr = '';\n+\n+    if (pattern.charAt(0) !== '^') regexStr += '^';\n+\n+    regexStr += pattern;\n+\n+    if (pattern.charAt(pattern.length - 1) !== '$') regexStr += '$';\n+\n+    regex = new RegExp(regexStr);\n+  } else {\n+    regexStr = pattern.toString();\n+    regex = pattern;\n   }\n+  return (control: AbstractControl): ValidationErrors|null => {\n+    if (isEmptyInputValue(control.value)) {\n+      return null;  // don't validate empty values to allow optional controls\n+    }\n+    const value: string = control.value;\n+    return regex.test(value) ? null :\n+                               {'pattern': {'requiredPattern': regexStr, 'actualValue': value}};\n+  };\n+}\n+\n+/**\n+ * Function that has `ValidatorFn` shape, but performs no operation.\n+ */\n+export function nullValidator(control: AbstractControl): ValidationErrors|null {\n+  return null;\n }\n \n function isPresent(o: any): boolean {\n@@ -534,23 +590,53 @@ export function normalizeValidators<V>(validators: (V|Validator|AsyncValidator)[\n }\n \n /**\n- * Merges synchronous validators into a single validator function (combined using\n- * `Validators.compose`).\n+ * Merges synchronous validators into a single validator function.\n+ * See `Validators.compose` for additional information.\n+ */\n+function compose(validators: (ValidatorFn|null|undefined)[]|null): ValidatorFn|null {\n+  if (!validators) return null;\n+  const presentValidators: ValidatorFn[] = validators.filter(isPresent) as any;\n+  if (presentValidators.length == 0) return null;\n+\n+  return function(control: AbstractControl) {\n+    return mergeErrors(executeValidators<ValidatorFn>(control, presentValidators));\n+  };\n+}\n+\n+/**\n+ * Accepts a list of validators of different possible shapes (`Validator` and `ValidatorFn`),\n+ * normalizes the list (converts everything to `ValidatorFn`) and merges them into a single\n+ * validator function.\n  */\n export function composeValidators(validators: Array<Validator|ValidatorFn>): ValidatorFn|null {\n-  return validators != null ? Validators.compose(normalizeValidators<ValidatorFn>(validators)) :\n-                              null;\n+  return validators != null ? compose(normalizeValidators<ValidatorFn>(validators)) : null;\n+}\n+\n+/**\n+ * Merges asynchronous validators into a single validator function.\n+ * See `Validators.composeAsync` for additional information.\n+ */\n+function composeAsync(validators: (AsyncValidatorFn|null)[]): AsyncValidatorFn|null {\n+  if (!validators) return null;\n+  const presentValidators: AsyncValidatorFn[] = validators.filter(isPresent) as any;\n+  if (presentValidators.length == 0) return null;\n+\n+  return function(control: AbstractControl) {\n+    const observables =\n+        executeValidators<AsyncValidatorFn>(control, presentValidators).map(toObservable);\n+    return forkJoin(observables).pipe(map(mergeErrors));\n+  };\n }\n \n /**\n- * Merges asynchronous validators into a single validator function (combined using\n- * `Validators.composeAsync`).\n+ * Accepts a list of async validators of different possible shapes (`AsyncValidator` and\n+ * `AsyncValidatorFn`), normalizes the list (converts everything to `AsyncValidatorFn`) and merges\n+ * them into a single validator function.\n  */\n export function composeAsyncValidators(validators: Array<AsyncValidator|AsyncValidatorFn>):\n     AsyncValidatorFn|null {\n-  return validators != null ?\n-      Validators.composeAsync(normalizeValidators<AsyncValidatorFn>(validators)) :\n-      null;\n+  return validators != null ? composeAsync(normalizeValidators<AsyncValidatorFn>(validators)) :\n+                              null;\n }\n \n /**"
        }
    ],
    "stats": {
        "total": 319,
        "additions": 201,
        "deletions": 118
    }
}