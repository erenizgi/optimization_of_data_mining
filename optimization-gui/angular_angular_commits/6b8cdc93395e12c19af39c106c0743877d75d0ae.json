{
    "author": "alan-agius4",
    "message": "docs: update `creating libraries` guide (#43982)\n\nWe update the `creating libraries` guide to remove View Engine references. This is because in version 13 users are no longer able to build libraries using View Engine.\n\nIn addition to the above, we also remove references to `npm link`. As this is actually not a recommended workflow, and was mostly needed in older versions of the CLI prior to version 6, were multi-projects workspaces were introduced.\n\nCloses #43949\n\nPR Close #43982",
    "sha": "6b8cdc93395e12c19af39c106c0743877d75d0ae",
    "files": [
        {
            "sha": "c13f3451b564a18d4900effefbd640c6be5612f0",
            "filename": "aio/content/guide/creating-libraries.md",
            "status": "modified",
            "additions": 21,
            "deletions": 105,
            "changes": 126,
            "blob_url": "https://github.com/angular/angular/blob/6b8cdc93395e12c19af39c106c0743877d75d0ae/aio%2Fcontent%2Fguide%2Fcreating-libraries.md",
            "raw_url": "https://github.com/angular/angular/raw/6b8cdc93395e12c19af39c106c0743877d75d0ae/aio%2Fcontent%2Fguide%2Fcreating-libraries.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Fcreating-libraries.md?ref=6b8cdc93395e12c19af39c106c0743877d75d0ae",
            "patch": "@@ -10,7 +10,7 @@ A simple example might be a button that sends users to your company website, tha\n Use the Angular CLI to generate a new library skeleton in a new workspace with the following commands.\n \n <code-example language=\"bash\">\n- ng new my-workspace --create-application=false\n+ ng new my-workspace --no-create-application\n  cd my-workspace\n  ng generate library my-lib\n </code-example>\n@@ -71,9 +71,9 @@ Use an NgModule to expose services and components.\n \n Your library should supply documentation (typically a README file) for installation and maintenance.\n \n-## Refactoring parts of an app into a library\n+## Refactoring parts of an application into a library\n \n-To make your solution reusable, you need to adjust it so that it does not depend on app-specific code.\n+To make your solution reusable, you need to adjust it so that it does not depend on application-specific code.\n Here are some things to consider in migrating application functionality to a library.\n \n * Declarations such as components and pipes should be designed as stateless, meaning they donâ€™t rely on or alter external variables. If you do rely on state, you need to evaluate every case and decide whether it is application state or state that the library would manage.\n@@ -122,7 +122,7 @@ If that form needs additional customization by the developer who is using your l\n However, if the form will always be the same and not need much customization by developers, then you could create a dynamic component that takes the configuration and generates the form.\n In general, the more complex the customization, the more useful the schematic approach.\n \n-To learn more, see [Schematics Overview](guide/schematics) and [Schematics for Libraries](guide/schematics-for-libraries).\n+For more information, see [Schematics Overview](guide/schematics) and [Schematics for Libraries](guide/schematics-for-libraries).\n \n ## Publishing your library\n \n@@ -149,56 +149,19 @@ npm publish\n \n ## Managing assets in a library\n \n-Starting with version 9.x of the [ng-packagr](https://github.com/ng-packagr/ng-packagr/blob/master/README.md) tool, you can configure the tool to automatically copy assets into your library package as part of the build process.\n-Use this feature when your library needs to publish optional theming files, Sass mixins, or documentation (like a changelog).\n-\n-* Learn how to [copy assets into your library as part of the build](https://github.com/ng-packagr/ng-packagr/blob/master/docs/copy-assets.md).\n-\n-* Learn more about how to use the tool to [embed assets in CSS](https://github.com/ng-packagr/ng-packagr/blob/master/docs/embed-assets-css.md).\n-\n-## Linked libraries\n-\n-While working on a published library, use [npm link](https://docs.npmjs.com/cli/link) to avoid reinstalling the library on every build.\n-\n-The library must be rebuilt on every change.\n-When linking a library, make sure that the build step runs in watch mode, and that the library's `package.json` configuration points at the correct entry points.\n-For example, `main` should point at a JavaScript file, not a TypeScript file.\n-\n-### Use TypeScript path mapping for peer dependencies\n+In your Angular library, the distributable can include additional assets like theming files, Sass mixins, or documentation (like a changelog).\n+For more information [copy assets into your library as part of the build](https://github.com/ng-packagr/ng-packagr/blob/master/docs/copy-assets.md) and [embed assets in component styles](https://github.com/ng-packagr/ng-packagr/blob/master/docs/embed-assets-css.md).\n \n+## Peer dependencies\n Angular libraries should list any `@angular/*` dependencies the library depends on as peer dependencies.\n This ensures that when modules ask for Angular, they all get the exact same module.\n If a library lists `@angular/core` in `dependencies` instead of `peerDependencies`, it might get a different Angular module instead, which would cause your application to break.\n \n-While developing a library, you must install all peer dependencies through `devDependencies` to ensure that the library compiles properly.\n-A linked library then has its own set of Angular libraries that it uses for building, located in its `node_modules` folder.\n-However, this can cause problems while building or running your application.\n-\n-To get around this problem use TypeScript path mapping to tell TypeScript that it should load some modules from a specific location.\n-List all the peer dependencies that your library uses in the workspace TypeScript configuration file `./tsconfig.json`, and point them at the local copy in the application's `node_modules` folder.\n-\n-```\n-{\n-  \"compilerOptions\": {\n-    // ...\n-    // paths are relative to `baseUrl` path.\n-    \"paths\": {\n-      \"@angular/*\": [\n-        \"./node_modules/@angular/*\"\n-      ]\n-    }\n-  }\n-}\n-```\n-\n-This mapping ensures that your library always loads the local copies of the modules it needs.\n-\n+## Using your own library in applications\n \n-## Using your own library in apps\n+You don't have to publish your library to the npm package manager to use it the same workspace, but you do have to build it first.\n \n-You don't have to publish your library to the npm package manager to use it in your own applications, but you do have to build it first.\n-\n-To use your own library in an app:\n+To use your own library in an application:\n \n * Build the library. You cannot use a library before it is built.\n  <code-example language=\"bash\">\n@@ -217,15 +180,17 @@ For instance, if you clone your git repository and run `npm install`, your edito\n \n <div class=\"alert is-helpful\">\n \n-When you import something from a library in an Angular app, Angular looks for a mapping between the library name and a location on disk.\n+When you import something from a library in an Angular application, Angular looks for a mapping between the library name and a location on disk.\n When you install a library package, the mapping is in the `node_modules` folder. When you build your own library, it has to find the mapping in your `tsconfig` paths.\n \n Generating a library with the Angular CLI automatically adds its path to the `tsconfig` file.\n The Angular CLI uses the `tsconfig` paths to tell the build system where to find the library.\n \n+For more information, see [Path mapping overview](https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping).\n+\n </div>\n \n-If you find that changes to your library are not reflected in your application, your app is probably using an old build of the library.\n+If you find that changes to your library are not reflected in your application, your application is probably using an old build of the library.\n \n You can rebuild your library whenever you make changes to it, but this extra step takes time.\n *Incremental builds* functionality improves the library-development experience.\n@@ -254,83 +219,32 @@ TypeScript path mappings should *not* point to the library source `.ts` files.\n \n {@a ivy-libraries}\n \n-## Building libraries with Ivy\n+## Publishing libraries\n \n-There are three distribution formats to use when publishing a library:\n+There are two distribution formats to use when publishing a library:\n \n-* View Engine _(deprecated)_&mdash;legacy format, slated for removal in Angular version 13.\n-  Only use this format if you must support View Engine applications.\n * partial-Ivy **(recommended)**&mdash;contains portable code that can be consumed by Ivy applications built with any version of Angular from v12 onwards.\n * full-Ivy&mdash;contains private Angular Ivy instructions, which are not guaranteed to work across different versions of Angular. This format requires that the library and application are built with the _exact_ same version of Angular. This format is useful for environments where all library and application code is built directly from source.\n \n-New libraries created with Angular CLI default to partial-Ivy format.\n-If you are creating a new library with `ng generate library`, Angular uses Ivy by default with no further action on your part.\n-\n-### Transitioning libraries to partial-Ivy format\n-\n-Existing libraries, which are configured to generate the View Engine format, do not change when upgrading to later versions of Angular that use Ivy.\n-\n-If you intend to publish your library to npm, compile with partial-Ivy code by setting `\"compilationMode\": \"partial\"` in `tsconfig.prod.json`.\n-\n-A library that uses View Engine, rather than Ivy, has a `tsconfig.prod.json` file that contains the following:\n-\n-<code-example>\n-\n-\"angularCompilerOptions\": {\n-  \"enableIvy\": false\n-}\n-\n-</code-example>\n-\n-To convert such libraries to use the partial-Ivy format, change the `tsconfig.prod.json` file by removing the `enableIvy` option and adding the `compilationMode` option.\n-\n-Enable partial-Ivy compilation by replacing `\"enableIvy\": false` with `\"compilationMode\": \"partial\"` as follows:\n-\n-<code-example>\n-\n-\"angularCompilerOptions\": {\n-  \"compilationMode\": \"partial\"\n-}\n-\n-</code-example>\n-\n For publishing to npm use the partial-Ivy format as it is stable between patch versions of Angular.\n \n Avoid compiling libraries with full-Ivy code if you are publishing to npm because the generated Ivy instructions are not part of Angular's public API, and so might change between patch versions.\n \n-Partial-Ivy code is not backward compatible with View Engine.\n-If you use the library in a View Engine application, you must compile the library into the View Engine format by setting `\"enableIvy\": false` in the `tsconfig.json` file.\n-\n-Ivy applications can still consume the View Engine format because the Angular compatibility compiler, or `ngcc`, can convert it to Ivy.\n-\n ## Ensuring library version compatibility\n \n The Angular version used to build an application should always be the same or greater than the Angular versions used to build any of its dependent libraries.\n-For example, if you had a library using Angular version 12, the application that depends on that library should use Angular version 12 or later.\n+For example, if you had a library using Angular version 13, the application that depends on that library should use Angular version 13 or later.\n Angular does not support using an earlier version for the application.\n \n-<div class=\"alert is-helpful\">\n-\n-The Angular CLI uses Ivy to build applications and no longer uses View Engine.\n-A library or an application built with View Engine cannot consume a partial-Ivy library.\n-\n-</div>\n-\n-Because this process happens during the application build, it uses the same version of the Angular compiler, ensuring that the application and all of its libraries use a single version of Angular.\n \n If you intend to publish your library to npm, compile with partial-Ivy code by setting `\"compilationMode\": \"partial\"` in `tsconfig.prod.json`.\n-This partial format is stable between different versions of Angular, so is safe to publish to npm.\n+This partial format is stable between different versions of Angular, so is safe to publish to npm. Code with this format is processed during the application build using the same version of the Angular compiler, ensuring that the application and all of its libraries use a single version of Angular.\n \n-Avoid compiling libraries with full-Ivy code if you are publishing to npm because the generated Ivy instructions are not part of Angular's public API, and so might change between patch versions.\n-\n-Partial-Ivy code is not backward compatible with View Engine.\n-If you use the library in a View Engine application, you must compile the library into the View Engine format by setting `\"enableIvy\": false` in the `tsconfig.json` file.\n \n-Ivy applications can still consume the View Engine format because the Angular compatibility compiler, or `ngcc`, can convert it to Ivy in the Angular CLI.\n+Avoid compiling libraries with full-Ivy code if you are publishing to npm because the generated Ivy instructions are not part of Angular's public API, and so might change between patch versions.\n \n If you've never published a package in npm before, you must create a user account. Read more in [Publishing npm Packages](https://docs.npmjs.com/getting-started/publishing-npm-packages).\n \n-\n ## Consuming partial-Ivy code outside the Angular CLI\n \n An application installs many Angular libraries from npm into its `node_modules` directory.\n@@ -351,3 +265,5 @@ The Angular linker Babel plugin supports build caching, meaning that libraries o\n The Angular CLI integrates the linker plugin automatically, so if consumers of your library are using the CLI, they can install Ivy-native libraries from npm without any additional configuration.\n \n </div>\n+\n+@reviewed 2021-10-29"
        }
    ],
    "stats": {
        "total": 126,
        "additions": 21,
        "deletions": 105
    }
}