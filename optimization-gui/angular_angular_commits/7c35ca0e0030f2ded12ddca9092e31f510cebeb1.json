{
    "author": "ivanwonder",
    "message": "feat(language-service): support autocomplete string literal union types in templates (#42729)\n\nThe native TS language service has the ability to provide autocompletions for\nstring literal union types. This pr is for Angular to do the same in templates.\n\nFixes https://github.com/angular/vscode-ng-language-service/issues/1096\n\nPR Close #42729",
    "sha": "7c35ca0e0030f2ded12ddca9092e31f510cebeb1",
    "files": [
        {
            "sha": "c8b60f410dc93cdfddef16817a01040df06a34c4",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/checker.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 1,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/7c35ca0e0030f2ded12ddca9092e31f510cebeb1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/7c35ca0e0030f2ded12ddca9092e31f510cebeb1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts?ref=7c35ca0e0030f2ded12ddca9092e31f510cebeb1",
            "patch": "@@ -6,8 +6,9 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, MethodCall, ParseError, ParseSourceSpan, PropertyRead, SafeMethodCall, SafePropertyRead, TmplAstElement, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n+import {AST, LiteralPrimitive, MethodCall, ParseError, ParseSourceSpan, PropertyRead, SafeMethodCall, SafePropertyRead, TmplAstElement, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n import {AbsoluteFsPath} from '@angular/compiler-cli/src/ngtsc/file_system';\n+import {TextAttribute} from '@angular/compiler/src/render3/r3_ast';\n import * as ts from 'typescript';\n import {ErrorCode} from '../../diagnostics';\n \n@@ -119,6 +120,14 @@ export interface TemplateTypeChecker {\n       expr: PropertyRead|SafePropertyRead|MethodCall|SafeMethodCall,\n       component: ts.ClassDeclaration): ShimLocation|null;\n \n+  /**\n+   * For the given node represents a `LiteralPrimitive`(the `TextAttribute` represents a string\n+   * literal), retrieve a `ShimLocation` that can be used to perform autocompletion at that point in\n+   * the node, if such a location exists.\n+   */\n+  getLiteralCompletionLocation(\n+      strNode: LiteralPrimitive|TextAttribute, component: ts.ClassDeclaration): ShimLocation|null;\n+\n   /**\n    * Get basic metadata on the directives which are in scope for the given component.\n    */"
        },
        {
            "sha": "504314d6bf195e1e8e0c811102a996a6915137af",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 1,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/7c35ca0e0030f2ded12ddca9092e31f510cebeb1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/7c35ca0e0030f2ded12ddca9092e31f510cebeb1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts?ref=7c35ca0e0030f2ded12ddca9092e31f510cebeb1",
            "patch": "@@ -6,7 +6,8 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, CssSelector, DomElementSchemaRegistry, MethodCall, ParseError, ParseSourceSpan, parseTemplate, PropertyRead, SafeMethodCall, SafePropertyRead, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\n+import {AST, CssSelector, DomElementSchemaRegistry, LiteralPrimitive, MethodCall, ParseError, ParseSourceSpan, parseTemplate, PropertyRead, SafeMethodCall, SafePropertyRead, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\n+import {TextAttribute} from '@angular/compiler/src/render3/r3_ast';\n import * as ts from 'typescript';\n import {ErrorCode} from '../../diagnostics';\n \n@@ -280,6 +281,16 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n         PerfPhase.TtcAutocompletion, () => engine.getExpressionCompletionLocation(ast));\n   }\n \n+  getLiteralCompletionLocation(\n+      node: LiteralPrimitive|TextAttribute, component: ts.ClassDeclaration): ShimLocation|null {\n+    const engine = this.getOrCreateCompletionEngine(component);\n+    if (engine === null) {\n+      return null;\n+    }\n+    return this.perf.inPhase(\n+        PerfPhase.TtcAutocompletion, () => engine.getLiteralCompletionLocation(node));\n+  }\n+\n   invalidateClass(clazz: ts.ClassDeclaration): void {\n     this.completionCache.delete(clazz);\n     this.symbolBuilderCache.delete(clazz);"
        },
        {
            "sha": "645a628967f5d7da1c7aecde9aca3fea6e516c63",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/completion.ts",
            "status": "modified",
            "additions": 45,
            "deletions": 3,
            "changes": 48,
            "blob_url": "https://github.com/angular/angular/blob/7c35ca0e0030f2ded12ddca9092e31f510cebeb1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcompletion.ts",
            "raw_url": "https://github.com/angular/angular/raw/7c35ca0e0030f2ded12ddca9092e31f510cebeb1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcompletion.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcompletion.ts?ref=7c35ca0e0030f2ded12ddca9092e31f510cebeb1",
            "patch": "@@ -7,7 +7,8 @@\n  */\n \n import {TmplAstReference, TmplAstTemplate} from '@angular/compiler';\n-import {AST, EmptyExpr, MethodCall, PropertyRead, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstNode} from '@angular/compiler/src/compiler';\n+import {AST, EmptyExpr, LiteralPrimitive, MethodCall, PropertyRead, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstNode} from '@angular/compiler/src/compiler';\n+import {TextAttribute} from '@angular/compiler/src/render3/r3_ast';\n import * as ts from 'typescript';\n \n import {AbsoluteFsPath} from '../../file_system';\n@@ -32,8 +33,9 @@ export class CompletionEngine {\n   private templateContextCache =\n       new Map<TmplAstTemplate|null, Map<string, ReferenceCompletion|VariableCompletion>>();\n \n-  private expressionCompletionCache =\n-      new Map<PropertyRead|SafePropertyRead|MethodCall|SafeMethodCall, ShimLocation>();\n+  private expressionCompletionCache = new Map<\n+      PropertyRead|SafePropertyRead|MethodCall|SafeMethodCall|LiteralPrimitive|TextAttribute,\n+      ShimLocation>();\n \n \n   constructor(private tcb: ts.Node, private data: TemplateData, private shimPath: AbsoluteFsPath) {\n@@ -144,6 +146,46 @@ export class CompletionEngine {\n     return res;\n   }\n \n+  getLiteralCompletionLocation(expr: LiteralPrimitive|TextAttribute): ShimLocation|null {\n+    if (this.expressionCompletionCache.has(expr)) {\n+      return this.expressionCompletionCache.get(expr)!;\n+    }\n+\n+    let tsExpr: ts.StringLiteral|ts.NumericLiteral|null = null;\n+\n+    if (expr instanceof TextAttribute) {\n+      const strNode = findFirstMatchingNode(this.tcb, {\n+        filter: ts.isParenthesizedExpression,\n+        withSpan: expr.sourceSpan,\n+      });\n+      if (strNode !== null && ts.isStringLiteral(strNode.expression)) {\n+        tsExpr = strNode.expression;\n+      }\n+    } else {\n+      tsExpr = findFirstMatchingNode(this.tcb, {\n+        filter: (n: ts.Node): n is ts.NumericLiteral | ts.StringLiteral =>\n+            ts.isStringLiteral(n) || ts.isNumericLiteral(n),\n+        withSpan: expr.sourceSpan,\n+      });\n+    }\n+\n+    if (tsExpr === null) {\n+      return null;\n+    }\n+\n+    let positionInShimFile = tsExpr.getEnd();\n+    if (ts.isStringLiteral(tsExpr)) {\n+      // In the shimFile, if `tsExpr` is a string, the position should be in the quotes.\n+      positionInShimFile -= 1;\n+    }\n+    const res: ShimLocation = {\n+      shimPath: this.shimPath,\n+      positionInShimFile,\n+    };\n+    this.expressionCompletionCache.set(expr, res);\n+    return res;\n+  }\n+\n   /**\n    * Get global completions within the given template context - either a `TmplAstTemplate` embedded\n    * view, or `null` for the root context."
        },
        {
            "sha": "af42275ecccbd9e13cd71ac15addf36b831a8282",
            "filename": "packages/language-service/ivy/completions.ts",
            "status": "modified",
            "additions": 65,
            "deletions": 1,
            "changes": 66,
            "blob_url": "https://github.com/angular/angular/blob/7c35ca0e0030f2ded12ddca9092e31f510cebeb1/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "raw_url": "https://github.com/angular/angular/raw/7c35ca0e0030f2ded12ddca9092e31f510cebeb1/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fcompletions.ts?ref=7c35ca0e0030f2ded12ddca9092e31f510cebeb1",
            "patch": "@@ -9,7 +9,7 @@\n import {AST, BindingPipe, EmptyExpr, ImplicitReceiver, LiteralPrimitive, MethodCall, ParseSourceSpan, PropertyRead, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstText, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n import {CompletionKind, DirectiveInScope, TemplateDeclarationSymbol} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n-import {BoundEvent} from '@angular/compiler/src/render3/r3_ast';\n+import {BoundEvent, TextAttribute} from '@angular/compiler/src/render3/r3_ast';\n import * as ts from 'typescript';\n \n import {addAttributeCompletionEntries, AttributeCompletionKind, buildAttributeCompletionTable, getAttributeCompletionSymbol} from './attribute_completions';\n@@ -26,6 +26,8 @@ type ElementAttributeCompletionBuilder =\n \n type PipeCompletionBuilder = CompletionBuilder<BindingPipe>;\n \n+type LiteralCompletionBuilder = CompletionBuilder<LiteralPrimitive|TextAttribute>;\n+\n export enum CompletionNodeContext {\n   None,\n   ElementTag,\n@@ -72,11 +74,71 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n       return this.getElementAttributeCompletions();\n     } else if (this.isPipeCompletion()) {\n       return this.getPipeCompletions();\n+    } else if (this.isLiteralCompletion()) {\n+      return this.getLiteralCompletions(options);\n     } else {\n       return undefined;\n     }\n   }\n \n+  private isLiteralCompletion(): this is LiteralCompletionBuilder {\n+    return this.node instanceof LiteralPrimitive ||\n+        (this.node instanceof TextAttribute &&\n+         this.nodeContext === CompletionNodeContext.ElementAttributeValue);\n+  }\n+\n+  private getLiteralCompletions(\n+      this: LiteralCompletionBuilder, options: ts.GetCompletionsAtPositionOptions|undefined):\n+      ts.WithMetadata<ts.CompletionInfo>|undefined {\n+    const location = this.compiler.getTemplateTypeChecker().getLiteralCompletionLocation(\n+        this.node, this.component);\n+    if (location === null) {\n+      return undefined;\n+    }\n+    const tsResults =\n+        this.tsLS.getCompletionsAtPosition(location.shimPath, location.positionInShimFile, options);\n+    if (tsResults === undefined) {\n+      return undefined;\n+    }\n+\n+    let replacementSpan: ts.TextSpan|undefined;\n+    if (this.node instanceof TextAttribute && this.node.value.length > 0 && this.node.valueSpan) {\n+      replacementSpan = {\n+        start: this.node.valueSpan.start.offset,\n+        length: this.node.value.length,\n+      };\n+    }\n+    if (this.node instanceof LiteralPrimitive) {\n+      if (typeof this.node.value === 'string' && this.node.value.length > 0) {\n+        replacementSpan = {\n+          // The sourceSpan of `LiteralPrimitive` includes the open quote and the completion entries\n+          // don't, so skip the open quote here.\n+          start: this.node.sourceSpan.start + 1,\n+          length: this.node.value.length,\n+        };\n+      } else if (typeof this.node.value === 'number') {\n+        replacementSpan = {\n+          start: this.node.sourceSpan.start,\n+          length: this.node.value.toString().length,\n+        };\n+      }\n+    }\n+\n+    let ngResults: ts.CompletionEntry[] = [];\n+    for (const result of tsResults.entries) {\n+      if (this.isValidNodeContextCompletion(result)) {\n+        ngResults.push({\n+          ...result,\n+          replacementSpan,\n+        });\n+      }\n+    }\n+    return {\n+      ...tsResults,\n+      entries: ngResults,\n+    };\n+  }\n+\n   /**\n    * Analogue for `ts.LanguageService.getCompletionEntryDetails`.\n    */\n@@ -749,6 +811,8 @@ function nodeContextFromTarget(target: TargetContext): CompletionNodeContext {\n     case TargetNodeKind.AttributeInValueContext:\n       if (target.node instanceof TmplAstBoundEvent) {\n         return CompletionNodeContext.EventValue;\n+      } else if (target.node instanceof TextAttribute) {\n+        return CompletionNodeContext.ElementAttributeValue;\n       } else {\n         return CompletionNodeContext.None;\n       }"
        },
        {
            "sha": "6a2a05b806af2f2ed9f76976bb2302971d656234",
            "filename": "packages/language-service/ivy/test/completions_spec.ts",
            "status": "modified",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/angular/angular/blob/7c35ca0e0030f2ded12ddca9092e31f510cebeb1/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7c35ca0e0030f2ded12ddca9092e31f510cebeb1/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts?ref=7c35ca0e0030f2ded12ddca9092e31f510cebeb1",
            "patch": "@@ -116,6 +116,19 @@ const SOME_PIPE = {\n    `\n };\n \n+const UNION_TYPE_PIPE = {\n+  'UnionTypePipe': `\n+    @Pipe({\n+      name: 'unionTypePipe',\n+    })\n+    export class UnionTypePipe {\n+      transform(value: string, config: 'foo' | 'bar'): string {\n+        return value;\n+      }\n+    }\n+   `\n+};\n+\n describe('completions', () => {\n   beforeEach(() => {\n     initMockFileSystem('Native');\n@@ -749,6 +762,50 @@ describe('completions', () => {\n       expect(completions?.entries.length).toBe(0);\n     });\n   });\n+\n+  describe('literal primitive scope', () => {\n+    it('should complete a string union types in square brackets binding', () => {\n+      const {templateFile} = setup(`<input dir [myInput]=\"'foo'\">`, '', DIR_WITH_UNION_TYPE_INPUT);\n+      templateFile.moveCursorToText(`[myInput]=\"'foo¦'\"`);\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(completions, ts.ScriptElementKind.string, ['foo']);\n+      expectReplacementText(completions, templateFile.contents, 'foo');\n+    });\n+\n+    it('should complete a string union types in binding without brackets', () => {\n+      const {templateFile} = setup(`<input dir myInput=\"foo\">`, '', DIR_WITH_UNION_TYPE_INPUT);\n+      templateFile.moveCursorToText('myInput=\"foo¦\"');\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(completions, ts.ScriptElementKind.string, ['foo']);\n+      expectReplacementText(completions, templateFile.contents, 'foo');\n+    });\n+\n+    it('should complete a string union types in binding without brackets when the cursor at the start of the string',\n+       () => {\n+         const {templateFile} = setup(`<input dir myInput=\"foo\">`, '', DIR_WITH_UNION_TYPE_INPUT);\n+         templateFile.moveCursorToText('myInput=\"¦foo\"');\n+         const completions = templateFile.getCompletionsAtPosition();\n+         expectContain(completions, ts.ScriptElementKind.string, ['foo']);\n+         expectReplacementText(completions, templateFile.contents, 'foo');\n+       });\n+\n+    it('should complete a string union types in pipe', () => {\n+      const {templateFile} =\n+          setup(`<input dir [myInput]=\"'foo'|unionTypePipe:'bar'\">`, '', UNION_TYPE_PIPE);\n+      templateFile.moveCursorToText(`[myInput]=\"'foo'|unionTypePipe:'bar¦'\"`);\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(completions, ts.ScriptElementKind.string, ['bar']);\n+      expectReplacementText(completions, templateFile.contents, 'bar');\n+    });\n+\n+    it('should complete a number union types', () => {\n+      const {templateFile} = setup(`<input dir [myInput]=\"42\">`, '', DIR_WITH_UNION_TYPE_INPUT);\n+      templateFile.moveCursorToText(`[myInput]=\"42¦\"`);\n+      const completions = templateFile.getCompletionsAtPosition();\n+      expectContain(completions, ts.ScriptElementKind.string, ['42']);\n+      expectReplacementText(completions, templateFile.contents, '42');\n+    });\n+  });\n });\n \n function expectContain("
        }
    ],
    "stats": {
        "total": 195,
        "additions": 189,
        "deletions": 6
    }
}