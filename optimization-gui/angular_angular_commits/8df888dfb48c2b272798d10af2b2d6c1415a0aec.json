{
    "author": "remackgeek",
    "message": "fix(elements): run strategy methods in correct zone (#37814)\n\nDefault change detection fails in some cases for @angular/elements where\ncomponent events are called from the wrong zone.\n\nThis fixes the issue by running all ComponentNgElementStrategy methods\nin the same zone it was created in.\n\nFixes #24181\n\nPR Close #37814",
    "sha": "8df888dfb48c2b272798d10af2b2d6c1415a0aec",
    "files": [
        {
            "sha": "9d240aea2fcb2392eaa5a2c3024261a500b10593",
            "filename": "goldens/size-tracking/aio-payloads.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/8df888dfb48c2b272798d10af2b2d6c1415a0aec/goldens%2Fsize-tracking%2Faio-payloads.json",
            "raw_url": "https://github.com/angular/angular/raw/8df888dfb48c2b272798d10af2b2d6c1415a0aec/goldens%2Fsize-tracking%2Faio-payloads.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fsize-tracking%2Faio-payloads.json?ref=8df888dfb48c2b272798d10af2b2d6c1415a0aec",
            "patch": "@@ -12,7 +12,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 2987,\n-        \"main-es2015\": 450301,\n+        \"main-es2015\": 450596,\n         \"polyfills-es2015\": 52630\n       }\n     }\n@@ -21,7 +21,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 3097,\n-        \"main-es2015\": 429200,\n+        \"main-es2015\": 429885,\n         \"polyfills-es2015\": 52195\n       }\n     }"
        },
        {
            "sha": "35db08958a62bc97fa6ac249832b676d52dd1e34",
            "filename": "packages/elements/src/component-factory-strategy.ts",
            "status": "modified",
            "additions": 61,
            "deletions": 40,
            "changes": 101,
            "blob_url": "https://github.com/angular/angular/blob/8df888dfb48c2b272798d10af2b2d6c1415a0aec/packages%2Felements%2Fsrc%2Fcomponent-factory-strategy.ts",
            "raw_url": "https://github.com/angular/angular/raw/8df888dfb48c2b272798d10af2b2d6c1415a0aec/packages%2Felements%2Fsrc%2Fcomponent-factory-strategy.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Felements%2Fsrc%2Fcomponent-factory-strategy.ts?ref=8df888dfb48c2b272798d10af2b2d6c1415a0aec",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {ApplicationRef, ComponentFactory, ComponentFactoryResolver, ComponentRef, EventEmitter, Injector, OnChanges, SimpleChange, SimpleChanges, Type} from '@angular/core';\n+import {ApplicationRef, ComponentFactory, ComponentFactoryResolver, ComponentRef, EventEmitter, Injector, NgZone, OnChanges, SimpleChange, SimpleChanges, Type} from '@angular/core';\n import {merge, Observable, ReplaySubject} from 'rxjs';\n import {map, switchMap} from 'rxjs/operators';\n \n@@ -73,78 +73,94 @@ export class ComponentNgElementStrategy implements NgElementStrategy {\n    */\n   private readonly unchangedInputs = new Set<string>();\n \n+  /** Service for setting zone context. */\n+  private readonly ngZone = this.injector.get<NgZone>(NgZone);\n+\n+  /** The zone the element was created in or `null` if Zone.js is not loaded. */\n+  private readonly elementZone =\n+      (typeof Zone === 'undefined') ? null : this.ngZone.run(() => Zone.current);\n+\n   constructor(private componentFactory: ComponentFactory<any>, private injector: Injector) {}\n \n   /**\n    * Initializes a new component if one has not yet been created and cancels any scheduled\n    * destruction.\n    */\n   connect(element: HTMLElement) {\n-    // If the element is marked to be destroyed, cancel the task since the component was reconnected\n-    if (this.scheduledDestroyFn !== null) {\n-      this.scheduledDestroyFn();\n-      this.scheduledDestroyFn = null;\n-      return;\n-    }\n+    this.runInZone(() => {\n+      // If the element is marked to be destroyed, cancel the task since the component was\n+      // reconnected\n+      if (this.scheduledDestroyFn !== null) {\n+        this.scheduledDestroyFn();\n+        this.scheduledDestroyFn = null;\n+        return;\n+      }\n \n-    if (this.componentRef === null) {\n-      this.initializeComponent(element);\n-    }\n+      if (this.componentRef === null) {\n+        this.initializeComponent(element);\n+      }\n+    });\n   }\n \n   /**\n    * Schedules the component to be destroyed after some small delay in case the element is just\n    * being moved across the DOM.\n    */\n   disconnect() {\n-    // Return if there is no componentRef or the component is already scheduled for destruction\n-    if (this.componentRef === null || this.scheduledDestroyFn !== null) {\n-      return;\n-    }\n-\n-    // Schedule the component to be destroyed after a small timeout in case it is being\n-    // moved elsewhere in the DOM\n-    this.scheduledDestroyFn = scheduler.schedule(() => {\n-      if (this.componentRef !== null) {\n-        this.componentRef.destroy();\n-        this.componentRef = null;\n+    this.runInZone(() => {\n+      // Return if there is no componentRef or the component is already scheduled for destruction\n+      if (this.componentRef === null || this.scheduledDestroyFn !== null) {\n+        return;\n       }\n-    }, DESTROY_DELAY);\n+\n+      // Schedule the component to be destroyed after a small timeout in case it is being\n+      // moved elsewhere in the DOM\n+      this.scheduledDestroyFn = scheduler.schedule(() => {\n+        if (this.componentRef !== null) {\n+          this.componentRef.destroy();\n+          this.componentRef = null;\n+        }\n+      }, DESTROY_DELAY);\n+    });\n   }\n \n   /**\n    * Returns the component property value. If the component has not yet been created, the value is\n    * retrieved from the cached initialization values.\n    */\n   getInputValue(property: string): any {\n-    if (this.componentRef === null) {\n-      return this.initialInputValues.get(property);\n-    }\n+    return this.runInZone(() => {\n+      if (this.componentRef === null) {\n+        return this.initialInputValues.get(property);\n+      }\n \n-    return this.componentRef.instance[property];\n+      return this.componentRef.instance[property];\n+    });\n   }\n \n   /**\n    * Sets the input value for the property. If the component has not yet been created, the value is\n    * cached and set when the component is created.\n    */\n   setInputValue(property: string, value: any): void {\n-    if (this.componentRef === null) {\n-      this.initialInputValues.set(property, value);\n-      return;\n-    }\n+    this.runInZone(() => {\n+      if (this.componentRef === null) {\n+        this.initialInputValues.set(property, value);\n+        return;\n+      }\n \n-    // Ignore the value if it is strictly equal to the current value, except if it is `undefined`\n-    // and this is the first change to the value (because an explicit `undefined` _is_ strictly\n-    // equal to not having a value set at all, but we still need to record this as a change).\n-    if (strictEquals(value, this.getInputValue(property)) &&\n-        !((value === undefined) && this.unchangedInputs.has(property))) {\n-      return;\n-    }\n+      // Ignore the value if it is strictly equal to the current value, except if it is `undefined`\n+      // and this is the first change to the value (because an explicit `undefined` _is_ strictly\n+      // equal to not having a value set at all, but we still need to record this as a change).\n+      if (strictEquals(value, this.getInputValue(property)) &&\n+          !((value === undefined) && this.unchangedInputs.has(property))) {\n+        return;\n+      }\n \n-    this.recordInputChange(property, value);\n-    this.componentRef.instance[property] = value;\n-    this.scheduleDetectChanges();\n+      this.recordInputChange(property, value);\n+      this.componentRef.instance[property] = value;\n+      this.scheduleDetectChanges();\n+    });\n   }\n \n   /**\n@@ -264,4 +280,9 @@ export class ComponentNgElementStrategy implements NgElementStrategy {\n     this.callNgOnChanges(this.componentRef);\n     this.componentRef.changeDetectorRef.detectChanges();\n   }\n+\n+  /** Runs in the angular zone, if present. */\n+  private runInZone(fn: () => unknown) {\n+    return (this.elementZone && Zone.current !== this.elementZone) ? this.ngZone.run(fn) : fn();\n+  }\n }"
        },
        {
            "sha": "577392fff2a9fe8aadf8a58c07925f18c1960dea",
            "filename": "packages/elements/test/component-factory-strategy_spec.ts",
            "status": "modified",
            "additions": 45,
            "deletions": 3,
            "changes": 48,
            "blob_url": "https://github.com/angular/angular/blob/8df888dfb48c2b272798d10af2b2d6c1415a0aec/packages%2Felements%2Ftest%2Fcomponent-factory-strategy_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/8df888dfb48c2b272798d10af2b2d6c1415a0aec/packages%2Felements%2Ftest%2Fcomponent-factory-strategy_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Felements%2Ftest%2Fcomponent-factory-strategy_spec.ts?ref=8df888dfb48c2b272798d10af2b2d6c1415a0aec",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {ComponentFactory, ComponentRef, Injector, NgModuleRef, SimpleChange, SimpleChanges, Type} from '@angular/core';\n+import {ApplicationRef, ComponentFactory, ComponentFactoryResolver, ComponentRef, Injector, NgModuleRef, NgZone, SimpleChange, SimpleChanges, Type} from '@angular/core';\n import {fakeAsync, tick} from '@angular/core/testing';\n import {Subject} from 'rxjs';\n \n@@ -20,22 +20,40 @@ describe('ComponentFactoryNgElementStrategy', () => {\n   let injector: any;\n   let componentRef: any;\n   let applicationRef: any;\n+  let ngZone: any;\n+\n+  let injectables: Map<unknown, unknown>;\n \n   beforeEach(() => {\n     factory = new FakeComponentFactory();\n     componentRef = factory.componentRef;\n \n     applicationRef = jasmine.createSpyObj('applicationRef', ['attachView']);\n+\n+    ngZone = jasmine.createSpyObj('ngZone', ['run']);\n+    ngZone.run.and.callFake((fn: () => unknown) => fn());\n+\n     injector = jasmine.createSpyObj('injector', ['get']);\n-    injector.get.and.returnValue(applicationRef);\n+    injector.get.and.callFake((token: unknown) => {\n+      if (!injectables.has(token)) {\n+        throw new Error(`Failed to get injectable from mock injector: ${token}`);\n+      }\n+      return injectables.get(token);\n+    });\n+\n+    injectables = new Map<unknown, unknown>([\n+      [ApplicationRef, applicationRef],\n+      [NgZone, ngZone],\n+    ]);\n \n     strategy = new ComponentNgElementStrategy(factory, injector);\n+    ngZone.run.calls.reset();\n   });\n \n   it('should create a new strategy from the factory', () => {\n     const factoryResolver = jasmine.createSpyObj('factoryResolver', ['resolveComponentFactory']);\n     factoryResolver.resolveComponentFactory.and.returnValue(factory);\n-    injector.get.and.returnValue(factoryResolver);\n+    injectables.set(ComponentFactoryResolver, factoryResolver);\n \n     const strategyFactory = new ComponentNgElementStrategyFactory(FakeComponent, injector);\n     expect(strategyFactory.create(injector)).toBeTruthy();\n@@ -266,6 +284,30 @@ describe('ComponentFactoryNgElementStrategy', () => {\n          expect(componentRef.destroy).toHaveBeenCalledTimes(1);\n        }));\n   });\n+\n+  describe('runInZone', () => {\n+    const param = 'foofoo';\n+    const fn = () => param;\n+\n+    it('should run the callback directly when invoked in element\\'s zone', () => {\n+      expect(strategy['runInZone'](fn)).toEqual('foofoo');\n+      expect(ngZone.run).not.toHaveBeenCalled();\n+    });\n+\n+    it('should run the callback inside the element\\'s zone when invoked in a different zone',\n+       () => {\n+         expect(Zone.root.run(() => (strategy['runInZone'](fn)))).toEqual('foofoo');\n+         expect(ngZone.run).toHaveBeenCalledWith(fn);\n+       });\n+\n+    it('should run the callback directly when called without zone.js loaded', () => {\n+      // simulate no zone.js loaded\n+      (strategy as any)['elementZone'] = null;\n+\n+      expect(Zone.root.run(() => (strategy['runInZone'](fn)))).toEqual('foofoo');\n+      expect(ngZone.run).not.toHaveBeenCalled();\n+    });\n+  });\n });\n \n export class FakeComponentWithoutNgOnChanges {"
        }
    ],
    "stats": {
        "total": 153,
        "additions": 108,
        "deletions": 45
    }
}