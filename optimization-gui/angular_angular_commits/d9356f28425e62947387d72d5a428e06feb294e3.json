{
    "author": "josephperrott",
    "message": "feat(dev-infra): close pull requests on merge which do not target master branch (#39979)\n\nPreviously, when a PR which does not target the master branch in the Github UI was\nmerged it would not close automatically.  This change detects when this case occurs\nand closes the PR via the Github API.\n\nFor example:\n\n  A PR which targets the 11.0.x branch in the Github UI has the `target: patch` label\n\nThis PR is only pushed into the 11.0.x branch, which does not trigger Github's\nreference based actions to close the PR.\n\nPR Close #39979",
    "sha": "d9356f28425e62947387d72d5a428e06feb294e3",
    "files": [
        {
            "sha": "04d29d95014a587b5a5b57d0be67dba420c29fbf",
            "filename": "dev-infra/ng-dev.js",
            "status": "modified",
            "additions": 44,
            "deletions": 27,
            "changes": 71,
            "blob_url": "https://github.com/angular/angular/blob/d9356f28425e62947387d72d5a428e06feb294e3/dev-infra%2Fng-dev.js",
            "raw_url": "https://github.com/angular/angular/raw/d9356f28425e62947387d72d5a428e06feb294e3/dev-infra%2Fng-dev.js",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fng-dev.js?ref=d9356f28425e62947387d72d5a428e06feb294e3",
            "patch": "@@ -3900,35 +3900,52 @@ var AutosquashMergeStrategy = /** @class */ (function (_super) {\n      */\n     AutosquashMergeStrategy.prototype.merge = function (pullRequest) {\n         return tslib.__awaiter(this, void 0, void 0, function () {\n-            var prNumber, targetBranches, requiredBaseSha, needsCommitMessageFixup, baseSha, revisionRange, branchOrRevisionBeforeRebase, rebaseEnv, failedBranches;\n+            var prNumber, targetBranches, requiredBaseSha, needsCommitMessageFixup, githubTargetBranch, baseSha, revisionRange, branchOrRevisionBeforeRebase, rebaseEnv, failedBranches, localBranch, sha;\n             return tslib.__generator(this, function (_a) {\n-                prNumber = pullRequest.prNumber, targetBranches = pullRequest.targetBranches, requiredBaseSha = pullRequest.requiredBaseSha, needsCommitMessageFixup = pullRequest.needsCommitMessageFixup;\n-                // In case a required base is specified for this pull request, check if the pull\n-                // request contains the given commit. If not, return a pull request failure. This\n-                // check is useful for enforcing that PRs are rebased on top of a given commit. e.g.\n-                // a commit that changes the codeowner ship validation. PRs which are not rebased\n-                // could bypass new codeowner ship rules.\n-                if (requiredBaseSha && !this.git.hasCommit(TEMP_PR_HEAD_BRANCH, requiredBaseSha)) {\n-                    return [2 /*return*/, PullRequestFailure.unsatisfiedBaseSha()];\n-                }\n-                baseSha = this.git.run(['rev-parse', this.getPullRequestBaseRevision(pullRequest)]).stdout.trim();\n-                revisionRange = baseSha + \"..\" + TEMP_PR_HEAD_BRANCH;\n-                branchOrRevisionBeforeRebase = this.git.getCurrentBranchOrRevision();\n-                rebaseEnv = needsCommitMessageFixup ? undefined : tslib.__assign(tslib.__assign({}, process.env), { GIT_SEQUENCE_EDITOR: 'true' });\n-                this.git.run(['rebase', '--interactive', '--autosquash', baseSha, TEMP_PR_HEAD_BRANCH], { stdio: 'inherit', env: rebaseEnv });\n-                // Update pull requests commits to reference the pull request. This matches what\n-                // Github does when pull requests are merged through the Web UI. The motivation is\n-                // that it should be easy to determine which pull request contained a given commit.\n-                // Note: The filter-branch command relies on the working tree, so we want to make sure\n-                // that we are on the initial branch or revision where the merge script has been invoked.\n-                this.git.run(['checkout', '-f', branchOrRevisionBeforeRebase]);\n-                this.git.run(['filter-branch', '-f', '--msg-filter', MSG_FILTER_SCRIPT + \" \" + prNumber, revisionRange]);\n-                failedBranches = this.cherryPickIntoTargetBranches(revisionRange, targetBranches);\n-                if (failedBranches.length) {\n-                    return [2 /*return*/, PullRequestFailure.mergeConflicts(failedBranches)];\n+                switch (_a.label) {\n+                    case 0:\n+                        prNumber = pullRequest.prNumber, targetBranches = pullRequest.targetBranches, requiredBaseSha = pullRequest.requiredBaseSha, needsCommitMessageFixup = pullRequest.needsCommitMessageFixup, githubTargetBranch = pullRequest.githubTargetBranch;\n+                        // In case a required base is specified for this pull request, check if the pull\n+                        // request contains the given commit. If not, return a pull request failure. This\n+                        // check is useful for enforcing that PRs are rebased on top of a given commit. e.g.\n+                        // a commit that changes the codeowner ship validation. PRs which are not rebased\n+                        // could bypass new codeowner ship rules.\n+                        if (requiredBaseSha && !this.git.hasCommit(TEMP_PR_HEAD_BRANCH, requiredBaseSha)) {\n+                            return [2 /*return*/, PullRequestFailure.unsatisfiedBaseSha()];\n+                        }\n+                        baseSha = this.git.run(['rev-parse', this.getPullRequestBaseRevision(pullRequest)]).stdout.trim();\n+                        revisionRange = baseSha + \"..\" + TEMP_PR_HEAD_BRANCH;\n+                        branchOrRevisionBeforeRebase = this.git.getCurrentBranchOrRevision();\n+                        rebaseEnv = needsCommitMessageFixup ? undefined : tslib.__assign(tslib.__assign({}, process.env), { GIT_SEQUENCE_EDITOR: 'true' });\n+                        this.git.run(['rebase', '--interactive', '--autosquash', baseSha, TEMP_PR_HEAD_BRANCH], { stdio: 'inherit', env: rebaseEnv });\n+                        // Update pull requests commits to reference the pull request. This matches what\n+                        // Github does when pull requests are merged through the Web UI. The motivation is\n+                        // that it should be easy to determine which pull request contained a given commit.\n+                        // Note: The filter-branch command relies on the working tree, so we want to make sure\n+                        // that we are on the initial branch or revision where the merge script has been invoked.\n+                        this.git.run(['checkout', '-f', branchOrRevisionBeforeRebase]);\n+                        this.git.run(['filter-branch', '-f', '--msg-filter', MSG_FILTER_SCRIPT + \" \" + prNumber, revisionRange]);\n+                        failedBranches = this.cherryPickIntoTargetBranches(revisionRange, targetBranches);\n+                        if (failedBranches.length) {\n+                            return [2 /*return*/, PullRequestFailure.mergeConflicts(failedBranches)];\n+                        }\n+                        this.pushTargetBranchesUpstream(targetBranches);\n+                        if (!(githubTargetBranch !== 'master')) return [3 /*break*/, 3];\n+                        localBranch = this.getLocalTargetBranchName(githubTargetBranch);\n+                        sha = this.git.run(['rev-parse', localBranch]).stdout.trim();\n+                        // Create a comment saying the PR was closed by the SHA.\n+                        return [4 /*yield*/, this.git.github.issues.createComment(tslib.__assign(tslib.__assign({}, this.git.remoteParams), { issue_number: pullRequest.prNumber, body: \"Closed by commit \" + sha }))];\n+                    case 1:\n+                        // Create a comment saying the PR was closed by the SHA.\n+                        _a.sent();\n+                        // Actually close the PR.\n+                        return [4 /*yield*/, this.git.github.pulls.update(tslib.__assign(tslib.__assign({}, this.git.remoteParams), { pull_number: pullRequest.prNumber, state: 'closed' }))];\n+                    case 2:\n+                        // Actually close the PR.\n+                        _a.sent();\n+                        _a.label = 3;\n+                    case 3: return [2 /*return*/, null];\n                 }\n-                this.pushTargetBranchesUpstream(targetBranches);\n-                return [2 /*return*/, null];\n             });\n         });\n     };"
        },
        {
            "sha": "f4d72c46806ae7dd3cec895aac4d828e1aec3bf3",
            "filename": "dev-infra/pr/merge/strategies/autosquash-merge.ts",
            "status": "modified",
            "additions": 26,
            "deletions": 1,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/d9356f28425e62947387d72d5a428e06feb294e3/dev-infra%2Fpr%2Fmerge%2Fstrategies%2Fautosquash-merge.ts",
            "raw_url": "https://github.com/angular/angular/raw/d9356f28425e62947387d72d5a428e06feb294e3/dev-infra%2Fpr%2Fmerge%2Fstrategies%2Fautosquash-merge.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fpr%2Fmerge%2Fstrategies%2Fautosquash-merge.ts?ref=d9356f28425e62947387d72d5a428e06feb294e3",
            "patch": "@@ -32,7 +32,8 @@ export class AutosquashMergeStrategy extends MergeStrategy {\n    * @returns A pull request failure or null in case of success.\n    */\n   async merge(pullRequest: PullRequest): Promise<PullRequestFailure|null> {\n-    const {prNumber, targetBranches, requiredBaseSha, needsCommitMessageFixup} = pullRequest;\n+    const {prNumber, targetBranches, requiredBaseSha, needsCommitMessageFixup, githubTargetBranch} =\n+        pullRequest;\n     // In case a required base is specified for this pull request, check if the pull\n     // request contains the given commit. If not, return a pull request failure. This\n     // check is useful for enforcing that PRs are rebased on top of a given commit. e.g.\n@@ -83,6 +84,30 @@ export class AutosquashMergeStrategy extends MergeStrategy {\n     }\n \n     this.pushTargetBranchesUpstream(targetBranches);\n+\n+    // For PRs which do not target the `master` branch on Github, Github does not automatically\n+    // close the PR when its commit is pushed into the repository.  To ensure these PRs are\n+    // correctly marked as closed, we must detect this situation and close the PR via the API after\n+    // the upstream pushes are completed.\n+    if (githubTargetBranch !== 'master') {\n+      /** The local branch name of the github targeted branch. */\n+      const localBranch = this.getLocalTargetBranchName(githubTargetBranch);\n+      /** The SHA of the commit pushed to github which represents closing the PR. */\n+      const sha = this.git.run(['rev-parse', localBranch]).stdout.trim();\n+      // Create a comment saying the PR was closed by the SHA.\n+      await this.git.github.issues.createComment({\n+        ...this.git.remoteParams,\n+        issue_number: pullRequest.prNumber,\n+        body: `Closed by commit ${sha}`\n+      });\n+      // Actually close the PR.\n+      await this.git.github.pulls.update({\n+        ...this.git.remoteParams,\n+        pull_number: pullRequest.prNumber,\n+        state: 'closed',\n+      });\n+    }\n+\n     return null;\n   }\n }"
        }
    ],
    "stats": {
        "total": 98,
        "additions": 70,
        "deletions": 28
    }
}