{
    "author": "JoostK",
    "message": "refactor(compiler-cli): dismantle View Engine implementation of ngc (#44269)\n\nThis commit does a first-pass removal of the View Engine infrastructure\nin compiler-cli. A more in-depth cleanup is necessary and large parts\nof the View Engine compiler infrastructure remain within\n`@angular/compiler`, this is just a first cleanup step.\n\nPR Close #44269",
    "sha": "192203278647bae1864db2a5109efaae1bba53c4",
    "files": [
        {
            "sha": "3d4a0df2b0889a81d5e9916e22f436d93f47a20c",
            "filename": "goldens/circular-deps/packages.json",
            "status": "modified",
            "additions": 0,
            "deletions": 22,
            "changes": 22,
            "blob_url": "https://github.com/angular/angular/blob/192203278647bae1864db2a5109efaae1bba53c4/goldens%2Fcircular-deps%2Fpackages.json",
            "raw_url": "https://github.com/angular/angular/raw/192203278647bae1864db2a5109efaae1bba53c4/goldens%2Fcircular-deps%2Fpackages.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fcircular-deps%2Fpackages.json?ref=192203278647bae1864db2a5109efaae1bba53c4",
            "patch": "@@ -7,28 +7,6 @@\n     \"packages/compiler-cli/ngcc/src/packages/configuration.ts\",\n     \"packages/compiler-cli/ngcc/src/packages/entry_point.ts\"\n   ],\n-  [\n-    \"packages/compiler-cli/src/metadata/bundle_index_host.ts\",\n-    \"packages/compiler-cli/src/transformers/metadata_cache.ts\",\n-    \"packages/compiler-cli/src/metadata/index.ts\"\n-  ],\n-  [\n-    \"packages/compiler-cli/src/metadata/bundle_index_host.ts\",\n-    \"packages/compiler-cli/src/transformers/metadata_cache.ts\",\n-    \"packages/compiler-cli/src/transformers/compiler_host.ts\",\n-    \"packages/compiler-cli/src/metadata/index.ts\"\n-  ],\n-  [\n-    \"packages/compiler-cli/src/metadata/bundle_index_host.ts\",\n-    \"packages/compiler-cli/src/transformers/metadata_cache.ts\",\n-    \"packages/compiler-cli/src/transformers/compiler_host.ts\",\n-    \"packages/compiler-cli/src/transformers/metadata_reader.ts\",\n-    \"packages/compiler-cli/src/metadata/index.ts\"\n-  ],\n-  [\n-    \"packages/compiler-cli/src/metadata/collector.ts\",\n-    \"packages/compiler-cli/src/metadata/evaluator.ts\"\n-  ],\n   [\n     \"packages/compiler-cli/src/ngtsc/partial_evaluator/src/interface.ts\",\n     \"packages/compiler-cli/src/ngtsc/partial_evaluator/src/interpreter.ts\""
        },
        {
            "sha": "2bb68b1e84fa3e1860a6cab1fb4c48d15ef84149",
            "filename": "packages/compiler-cli/index.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/192203278647bae1864db2a5109efaae1bba53c4/packages%2Fcompiler-cli%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/192203278647bae1864db2a5109efaae1bba53c4/packages%2Fcompiler-cli%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Findex.ts?ref=192203278647bae1864db2a5109efaae1bba53c4",
            "patch": "@@ -8,10 +8,8 @@\n import {NodeJSFileSystem, setFileSystem} from './src/ngtsc/file_system';\n \n export {AotCompilerHost, AotCompilerHost as StaticReflectorHost, StaticReflector, StaticSymbol} from '@angular/compiler';\n-\n export {VERSION} from './src/version';\n \n-export * from './src/metadata';\n export * from './src/transformers/api';\n export * from './src/transformers/entry_points';\n "
        },
        {
            "sha": "2aad0852211c6745d938dd2f9bfaccb1001f6f01",
            "filename": "packages/compiler-cli/src/diagnostics/translate_diagnostics.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 59,
            "changes": 59,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Fdiagnostics%2Ftranslate_diagnostics.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Fdiagnostics%2Ftranslate_diagnostics.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fdiagnostics%2Ftranslate_diagnostics.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,59 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ParseSourceSpan} from '@angular/compiler';\n-import ts from 'typescript';\n-\n-import {DEFAULT_ERROR_CODE, Diagnostic, SOURCE} from '../transformers/api';\n-import {GENERATED_FILES} from '../transformers/util';\n-\n-export interface TypeCheckHost {\n-  parseSourceSpanOf(fileName: string, line: number, character: number): ParseSourceSpan|null;\n-}\n-\n-export function translateDiagnostics(\n-    host: TypeCheckHost, untranslatedDiagnostics: ReadonlyArray<ts.Diagnostic>):\n-    {ts: ts.Diagnostic[], ng: Diagnostic[]} {\n-  const ts: ts.Diagnostic[] = [];\n-  const ng: Diagnostic[] = [];\n-\n-  untranslatedDiagnostics.forEach((diagnostic) => {\n-    if (diagnostic.file && diagnostic.start && GENERATED_FILES.test(diagnostic.file.fileName)) {\n-      // We need to filter out diagnostics about unused functions as\n-      // they are in fact referenced by nobody and only serve to surface\n-      // type check errors.\n-      if (diagnostic.code === /* ... is declared but never used */ 6133) {\n-        return;\n-      }\n-      const span = sourceSpanOf(host, diagnostic.file, diagnostic.start);\n-      if (span) {\n-        const fileName = span.start.file.url;\n-        ng.push({\n-          messageText: diagnosticMessageToString(diagnostic.messageText),\n-          category: diagnostic.category,\n-          span,\n-          source: SOURCE,\n-          code: DEFAULT_ERROR_CODE\n-        });\n-      }\n-    } else {\n-      ts.push(diagnostic);\n-    }\n-  });\n-  return {ts, ng};\n-}\n-\n-function sourceSpanOf(host: TypeCheckHost, source: ts.SourceFile, start: number): ParseSourceSpan|\n-    null {\n-  const {line, character} = ts.getLineAndCharacterOfPosition(source, start);\n-  return host.parseSourceSpanOf(source.fileName, line, character);\n-}\n-\n-function diagnosticMessageToString(message: ts.DiagnosticMessageChain|string): string {\n-  return ts.flattenDiagnosticMessageText(message, '\\n');\n-}"
        },
        {
            "sha": "4ad5958ac9c7f6a32ed51da57af8784fea2fae20",
            "filename": "packages/compiler-cli/src/language_services.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 19,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Flanguage_services.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Flanguage_services.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Flanguage_services.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,19 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-/*\n-\n-The API from compiler-cli that language-service can see.\n-It is important that none the exported modules require anything other than\n-Angular modules and Typescript as this will indirectly add a dependency\n-to the language service.\n-\n-*/\n-export {MetadataCollector, ModuleMetadata} from './metadata';\n-export {CompilerOptions} from './transformers/api';\n-export {createMetadataReaderCache, MetadataReaderCache, MetadataReaderHost, readMetadata} from './transformers/metadata_reader';"
        },
        {
            "sha": "86d4071ca766e2b106b49fd2e7e96c10d9578edb",
            "filename": "packages/compiler-cli/src/metadata/bundle_index_host.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 131,
            "changes": 131,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Fbundle_index_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Fbundle_index_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Fbundle_index_host.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,131 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as fs from 'fs';\n-import * as path from 'path';\n-import ts from 'typescript';\n-\n-import {CompilerOptions} from '../transformers/api';\n-import {MetadataCache} from '../transformers/metadata_cache';\n-\n-import {CompilerHostAdapter, MetadataBundler} from './bundler';\n-import {privateEntriesToIndex} from './index_writer';\n-\n-const DTS = /\\.d\\.ts$/;\n-const JS_EXT = /(\\.js|)$/;\n-\n-function createSyntheticIndexHost<H extends ts.CompilerHost>(\n-    delegate: H, syntheticIndex: {name: string, content: string, getMetadata: () => string}): H {\n-  const normalSyntheticIndexName = path.normalize(syntheticIndex.name);\n-\n-  const newHost = Object.create(delegate);\n-  newHost.fileExists = (fileName: string): boolean => {\n-    return path.normalize(fileName) == normalSyntheticIndexName || delegate.fileExists(fileName);\n-  };\n-\n-  newHost.readFile = (fileName: string) => {\n-    return path.normalize(fileName) == normalSyntheticIndexName ? syntheticIndex.content :\n-                                                                  delegate.readFile(fileName);\n-  };\n-\n-  newHost.getSourceFile =\n-      (fileName: string, languageVersion: ts.ScriptTarget, onError?: (message: string) => void) => {\n-        if (path.normalize(fileName) == normalSyntheticIndexName) {\n-          const sf = ts.createSourceFile(fileName, syntheticIndex.content, languageVersion, true);\n-          if ((delegate as any).fileNameToModuleName) {\n-            sf.moduleName = (delegate as any).fileNameToModuleName(fileName);\n-          }\n-          return sf;\n-        }\n-        return delegate.getSourceFile(fileName, languageVersion, onError);\n-      };\n-\n-  newHost.writeFile =\n-      (fileName: string, data: string, writeByteOrderMark: boolean,\n-       onError: ((message: string) => void)|undefined, sourceFiles: Readonly<ts.SourceFile>[]) => {\n-        delegate.writeFile(fileName, data, writeByteOrderMark, onError, sourceFiles);\n-        if (fileName.match(DTS) && sourceFiles && sourceFiles.length == 1 &&\n-            path.normalize(sourceFiles[0].fileName) === normalSyntheticIndexName) {\n-          // If we are writing the synthetic index, write the metadata along side.\n-          const metadataName = fileName.replace(DTS, '.metadata.json');\n-          const indexMetadata = syntheticIndex.getMetadata();\n-          delegate.writeFile(metadataName, indexMetadata, writeByteOrderMark, onError, []);\n-        }\n-      };\n-  return newHost;\n-}\n-\n-export function createBundleIndexHost<H extends ts.CompilerHost>(\n-    ngOptions: CompilerOptions, rootFiles: ReadonlyArray<string>, host: H,\n-    getMetadataCache: () =>\n-        MetadataCache): {host: H, indexName?: string, errors?: ts.Diagnostic[]} {\n-  const files = rootFiles.filter(f => !DTS.test(f));\n-  let indexFile: string|undefined;\n-  if (files.length === 1) {\n-    indexFile = files[0];\n-  } else {\n-    for (const f of files) {\n-      // Assume the shortest file path called index.ts is the entry point. Note that we\n-      // need to use the posix path delimiter here because TypeScript internally only\n-      // passes posix paths.\n-      if (f.endsWith('/index.ts')) {\n-        if (!indexFile || indexFile.length > f.length) {\n-          indexFile = f;\n-        }\n-      }\n-    }\n-  }\n-  if (!indexFile) {\n-    return {\n-      host,\n-      errors: [{\n-        file: null as any as ts.SourceFile,\n-        start: null as any as number,\n-        length: null as any as number,\n-        messageText:\n-            'Angular compiler option \"flatModuleIndex\" requires one and only one .ts file in the \"files\" field.',\n-        category: ts.DiagnosticCategory.Error,\n-        code: 0\n-      }]\n-    };\n-  }\n-\n-  const indexModule = indexFile.replace(/\\.ts$/, '');\n-\n-  // The operation of producing a metadata bundle happens twice - once during setup and once during\n-  // the emit phase. The first time, the bundle is produced without a metadata cache, to compute the\n-  // contents of the flat module index. The bundle produced during emit does use the metadata cache\n-  // with associated transforms, so the metadata will have lowered expressions, resource inlining,\n-  // etc.\n-  const getMetadataBundle = (cache: MetadataCache|null) => {\n-    const bundler = new MetadataBundler(\n-        indexModule, ngOptions.flatModuleId, new CompilerHostAdapter(host, cache, ngOptions),\n-        ngOptions.flatModulePrivateSymbolPrefix);\n-    return bundler.getMetadataBundle();\n-  };\n-\n-  // First, produce the bundle with no MetadataCache.\n-  const metadataBundle = getMetadataBundle(/* MetadataCache */ null);\n-  const name =\n-      path.join(path.dirname(indexModule), ngOptions.flatModuleOutFile!.replace(JS_EXT, '.ts'));\n-  const libraryIndex = `./${path.basename(indexModule)}`;\n-  const content = privateEntriesToIndex(libraryIndex, metadataBundle.privates);\n-\n-  host = createSyntheticIndexHost(host, {\n-    name,\n-    content,\n-    getMetadata: () => {\n-      // The second metadata bundle production happens on-demand, and uses the getMetadataCache\n-      // closure to retrieve an up-to-date MetadataCache which is configured with whatever metadata\n-      // transforms were used to produce the JS output.\n-      const metadataBundle = getMetadataBundle(getMetadataCache());\n-      return JSON.stringify(metadataBundle.metadata);\n-    }\n-  });\n-  return {host, indexName: name};\n-}"
        },
        {
            "sha": "68d4a1da6bd7092a2edb6de1394811791d42ad8c",
            "filename": "packages/compiler-cli/src/metadata/bundler.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 680,
            "changes": 680,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Fbundler.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Fbundler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Fbundler.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,680 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import * as path from 'path';\n-import ts from 'typescript';\n-\n-import {MetadataCache} from '../transformers/metadata_cache';\n-\n-import {MetadataCollector} from './collector';\n-import {ClassMetadata, ConstructorMetadata, FunctionMetadata, isClassMetadata, isConstructorMetadata, isFunctionMetadata, isInterfaceMetadata, isMetadataError, isMetadataGlobalReferenceExpression, isMetadataImportedSymbolReferenceExpression, isMetadataModuleReferenceExpression, isMetadataSymbolicCallExpression, isMetadataSymbolicExpression, isMethodMetadata, MemberMetadata, METADATA_VERSION, MetadataEntry, MetadataError, MetadataMap, MetadataObject, MetadataSymbolicExpression, MetadataSymbolicReferenceExpression, MetadataValue, MethodMetadata, ModuleExportMetadata, ModuleMetadata} from './schema';\n-\n-\n-\n-// The character set used to produce private names.\n-const PRIVATE_NAME_CHARS = 'abcdefghijklmnopqrstuvwxyz';\n-\n-interface Symbol {\n-  module: string;\n-  name: string;\n-\n-  // Produced by indirectly by exportAll() for symbols re-export another symbol.\n-  exports?: Symbol;\n-\n-  // Produced by indirectly by exportAll() for symbols are re-exported by another symbol.\n-  reexportedAs?: Symbol;\n-\n-  // Produced by canonicalizeSymbols() for all symbols. A symbol is private if it is not\n-  // exported by the index.\n-  isPrivate?: boolean;\n-\n-  // Produced by canonicalizeSymbols() for all symbols. This is the one symbol that\n-  // respresents all other symbols and is the only symbol that, among all the re-exported\n-  // aliases, whose fields can be trusted to contain the correct information.\n-  // For private symbols this is the declaration symbol. For public symbols this is the\n-  // symbol that is exported.\n-  canonicalSymbol?: Symbol;\n-\n-  // Produced by canonicalizeSymbols() for all symbols. This the symbol that originally\n-  // declared the value and should be used to fetch the value.\n-  declaration?: Symbol;\n-\n-  // A symbol is referenced if it is exported from index or referenced by the value of\n-  // a referenced symbol's value.\n-  referenced?: boolean;\n-\n-  // A symbol is marked as a re-export the symbol was rexported from a module that is\n-  // not part of the flat module bundle.\n-  reexport?: boolean;\n-\n-  // Only valid for referenced canonical symbols. Produces by convertSymbols().\n-  value?: MetadataEntry;\n-\n-  // Only valid for referenced private symbols. It is the name to use to import the symbol from\n-  // the bundle index. Produce by assignPrivateNames();\n-  privateName?: string;\n-}\n-\n-export interface BundleEntries {\n-  [name: string]: MetadataEntry;\n-}\n-\n-export interface BundlePrivateEntry {\n-  privateName: string;\n-  name: string;\n-  module: string;\n-}\n-\n-export interface BundledModule {\n-  metadata: ModuleMetadata;\n-  privates: BundlePrivateEntry[];\n-}\n-\n-export interface MetadataBundlerHost {\n-  getMetadataFor(moduleName: string, containingFile: string): ModuleMetadata|undefined;\n-}\n-\n-type StaticsMetadata = {\n-  [name: string]: MetadataValue|FunctionMetadata;\n-};\n-\n-export class MetadataBundler {\n-  private symbolMap = new Map<string, Symbol>();\n-  private metadataCache = new Map<string, ModuleMetadata|undefined>();\n-  private exports = new Map<string, Symbol[]>();\n-  private rootModule: string;\n-  private privateSymbolPrefix: string;\n-  // TODO(issue/24571): remove '!'.\n-  private exported!: Set<Symbol>;\n-\n-  constructor(\n-      private root: string, private importAs: string|undefined, private host: MetadataBundlerHost,\n-      privateSymbolPrefix?: string) {\n-    this.rootModule = `./${path.basename(root)}`;\n-    this.privateSymbolPrefix = (privateSymbolPrefix || '').replace(/\\W/g, '_');\n-  }\n-\n-  getMetadataBundle(): BundledModule {\n-    // Export the root module. This also collects the transitive closure of all values referenced by\n-    // the exports.\n-    const exportedSymbols = this.exportAll(this.rootModule);\n-    this.canonicalizeSymbols(exportedSymbols);\n-    // TODO: exports? e.g. a module re-exports a symbol from another bundle\n-    const metadata = this.getEntries(exportedSymbols);\n-    const privates = Array.from(this.symbolMap.values())\n-                         .filter(s => s.referenced && s.isPrivate)\n-                         .map(s => ({\n-                                privateName: s.privateName!,\n-                                name: s.declaration!.name,\n-                                module: s.declaration!.module\n-                              }));\n-    const origins = Array.from(this.symbolMap.values())\n-                        .filter(s => s.referenced && !s.reexport)\n-                        .reduce<{[name: string]: string}>((p, s) => {\n-                          p[s.isPrivate ? s.privateName! : s.name] = s.declaration!.module;\n-                          return p;\n-                        }, {});\n-    const exports = this.getReExports(exportedSymbols);\n-    return {\n-      metadata: {\n-        __symbolic: 'module',\n-        version: METADATA_VERSION,\n-        exports: exports.length ? exports : undefined,\n-        metadata,\n-        origins,\n-        importAs: this.importAs!\n-      },\n-      privates\n-    };\n-  }\n-\n-  static resolveModule(importName: string, from: string): string {\n-    return resolveModule(importName, from);\n-  }\n-\n-  private getMetadata(moduleName: string): ModuleMetadata|undefined {\n-    let result = this.metadataCache.get(moduleName);\n-    if (!result) {\n-      if (moduleName.startsWith('.')) {\n-        const fullModuleName = resolveModule(moduleName, this.root);\n-        result = this.host.getMetadataFor(fullModuleName, this.root);\n-      }\n-      this.metadataCache.set(moduleName, result);\n-    }\n-    return result;\n-  }\n-\n-  private exportAll(moduleName: string): Symbol[] {\n-    const module = this.getMetadata(moduleName);\n-    let result = this.exports.get(moduleName);\n-\n-    if (result) {\n-      return result;\n-    }\n-\n-    result = [];\n-\n-    const exportSymbol = (exportedSymbol: Symbol, exportAs: string) => {\n-      const symbol = this.symbolOf(moduleName, exportAs);\n-      result!.push(symbol);\n-      exportedSymbol.reexportedAs = symbol;\n-      symbol.exports = exportedSymbol;\n-    };\n-\n-    // Export all the symbols defined in this module.\n-    if (module && module.metadata) {\n-      for (let key in module.metadata) {\n-        const data = module.metadata[key];\n-        if (isMetadataImportedSymbolReferenceExpression(data)) {\n-          // This is a re-export of an imported symbol. Record this as a re-export.\n-          const exportFrom = resolveModule(data.module, moduleName);\n-          this.exportAll(exportFrom);\n-          const symbol = this.symbolOf(exportFrom, data.name);\n-          exportSymbol(symbol, key);\n-        } else {\n-          // Record that this symbol is exported by this module.\n-          result.push(this.symbolOf(moduleName, key));\n-        }\n-      }\n-    }\n-\n-    // Export all the re-exports from this module\n-    if (module && module.exports) {\n-      let unnamedModuleExportsIdx = 0;\n-      for (const exportDeclaration of module.exports) {\n-        const exportFrom = resolveModule(exportDeclaration.from, moduleName);\n-        // Record all the exports from the module even if we don't use it directly.\n-        const exportedSymbols = this.exportAll(exportFrom);\n-        if (exportDeclaration.export) {\n-          // Re-export all the named exports from a module.\n-          for (const exportItem of exportDeclaration.export) {\n-            const name = typeof exportItem == 'string' ? exportItem : exportItem.name;\n-            const exportAs = typeof exportItem == 'string' ? exportItem : exportItem.as;\n-            const symbol = this.symbolOf(exportFrom, name);\n-            if (exportedSymbols && exportedSymbols.length == 1 && exportedSymbols[0].reexport &&\n-                exportedSymbols[0].name == '*') {\n-              // This is a named export from a module we have no metadata about. Record the named\n-              // export as a re-export.\n-              symbol.reexport = true;\n-            }\n-            exportSymbol(this.symbolOf(exportFrom, name), exportAs);\n-          }\n-        } else {\n-          // Re-export all the symbols from the module\n-          const exportedSymbols = this.exportAll(exportFrom);\n-          for (const exportedSymbol of exportedSymbols) {\n-            // In case the exported symbol does not have a name, we need to give it an unique\n-            // name for the current module. This is necessary because there can be multiple\n-            // unnamed re-exports in a given module.\n-            const name = exportedSymbol.name === '*' ?\n-                `unnamed_reexport_${unnamedModuleExportsIdx++}` :\n-                exportedSymbol.name;\n-            exportSymbol(exportedSymbol, name);\n-          }\n-        }\n-      }\n-    }\n-\n-    if (!module) {\n-      // If no metadata is found for this import then it is considered external to the\n-      // library and should be recorded as a re-export in the final metadata if it is\n-      // eventually re-exported.\n-      const symbol = this.symbolOf(moduleName, '*');\n-      symbol.reexport = true;\n-      result.push(symbol);\n-    }\n-    this.exports.set(moduleName, result);\n-\n-    return result;\n-  }\n-\n-  /**\n-   * Fill in the canonicalSymbol which is the symbol that should be imported by factories.\n-   * The canonical symbol is the one exported by the index file for the bundle or definition\n-   * symbol for private symbols that are not exported by bundle index.\n-   */\n-  private canonicalizeSymbols(exportedSymbols: Symbol[]) {\n-    const symbols = Array.from(this.symbolMap.values());\n-    this.exported = new Set(exportedSymbols);\n-    symbols.forEach(this.canonicalizeSymbol, this);\n-  }\n-\n-  private canonicalizeSymbol(symbol: Symbol) {\n-    const rootExport = getRootExport(symbol);\n-    const declaration = getSymbolDeclaration(symbol);\n-    const isPrivate = !this.exported.has(rootExport);\n-    const canonicalSymbol = isPrivate ? declaration : rootExport;\n-    symbol.isPrivate = isPrivate;\n-    symbol.declaration = declaration;\n-    symbol.canonicalSymbol = canonicalSymbol;\n-    symbol.reexport = declaration.reexport;\n-  }\n-\n-  private getEntries(exportedSymbols: Symbol[]): BundleEntries {\n-    const result: BundleEntries = {};\n-\n-    const exportedNames = new Set(exportedSymbols.map(s => s.name));\n-    let privateName = 0;\n-\n-    function newPrivateName(prefix: string): string {\n-      while (true) {\n-        let digits: string[] = [];\n-        let index = privateName++;\n-        let base = PRIVATE_NAME_CHARS;\n-        while (!digits.length || index > 0) {\n-          digits.unshift(base[index % base.length]);\n-          index = Math.floor(index / base.length);\n-        }\n-        const result = `\\u0275${prefix}${digits.join('')}`;\n-        if (!exportedNames.has(result)) return result;\n-      }\n-    }\n-\n-    exportedSymbols.forEach(symbol => this.convertSymbol(symbol));\n-\n-    const symbolsMap = new Map<string, string[]>();\n-    Array.from(this.symbolMap.values()).forEach(symbol => {\n-      if (symbol.referenced && !symbol.reexport) {\n-        let name = symbol.name;\n-        const identifier = `${symbol.declaration!.module}:${symbol.declaration!.name}`;\n-        if (symbol.isPrivate && !symbol.privateName) {\n-          name = newPrivateName(this.privateSymbolPrefix);\n-          symbol.privateName = name;\n-        }\n-        if (symbolsMap.has(identifier)) {\n-          const names = symbolsMap.get(identifier);\n-          names!.push(name);\n-        } else {\n-          symbolsMap.set(identifier, [name]);\n-        }\n-        result[name] = symbol.value!;\n-      }\n-    });\n-\n-    // check for duplicated entries\n-    symbolsMap.forEach((names: string[], identifier: string) => {\n-      if (names.length > 1) {\n-        const [module, declaredName] = identifier.split(':');\n-        // prefer the export that uses the declared name (if any)\n-        let reference = names.indexOf(declaredName);\n-        if (reference === -1) {\n-          reference = 0;\n-        }\n-\n-        // keep one entry and replace the others by references\n-        names.forEach((name: string, i: number) => {\n-          if (i !== reference) {\n-            result[name] = {__symbolic: 'reference', name: names[reference]};\n-          }\n-        });\n-      }\n-    });\n-\n-    return result;\n-  }\n-\n-  private getReExports(exportedSymbols: Symbol[]): ModuleExportMetadata[] {\n-    type ExportClause = {name: string, as: string}[];\n-    const modules = new Map<string, ExportClause>();\n-    const exportAlls = new Set<string>();\n-    for (const symbol of exportedSymbols) {\n-      if (symbol.reexport) {\n-        // symbol.declaration is guaranteed to be defined during the phase this method is called.\n-        const declaration = symbol.declaration!;\n-        const module = declaration.module;\n-        if (declaration!.name == '*') {\n-          // Reexport all the symbols.\n-          exportAlls.add(declaration.module);\n-        } else {\n-          // Re-export the symbol as the exported name.\n-          let entry = modules.get(module);\n-          if (!entry) {\n-            entry = [];\n-            modules.set(module, entry);\n-          }\n-          const as = symbol.name;\n-          const name = declaration.name;\n-          entry.push({name, as});\n-        }\n-      }\n-    }\n-    return [\n-      ...Array.from(exportAlls.values()).map(from => ({from})),\n-      ...Array.from(modules.entries()).map(([from, exports]) => ({export: exports, from}))\n-    ];\n-  }\n-\n-  private convertSymbol(symbol: Symbol) {\n-    // canonicalSymbol is ensured to be defined before this is called.\n-    const canonicalSymbol = symbol.canonicalSymbol!;\n-\n-    if (!canonicalSymbol.referenced) {\n-      canonicalSymbol.referenced = true;\n-      // declaration is ensured to be definded before this method is called.\n-      const declaration = canonicalSymbol.declaration!;\n-      const module = this.getMetadata(declaration.module);\n-      if (module) {\n-        const value = module.metadata[declaration.name];\n-        if (value && !declaration.name.startsWith('___')) {\n-          canonicalSymbol.value = this.convertEntry(declaration.module, value);\n-        }\n-      }\n-    }\n-  }\n-\n-  private convertEntry(moduleName: string, value: MetadataEntry): MetadataEntry {\n-    if (isClassMetadata(value)) {\n-      return this.convertClass(moduleName, value);\n-    }\n-    if (isFunctionMetadata(value)) {\n-      return this.convertFunction(moduleName, value);\n-    }\n-    if (isInterfaceMetadata(value)) {\n-      return value;\n-    }\n-    return this.convertValue(moduleName, value);\n-  }\n-\n-  private convertClass(moduleName: string, value: ClassMetadata): ClassMetadata {\n-    return {\n-      __symbolic: 'class',\n-      arity: value.arity,\n-      extends: this.convertExpression(moduleName, value.extends) !,\n-      decorators:\n-          value.decorators && value.decorators.map(d => this.convertExpression(moduleName, d) !),\n-      members: this.convertMembers(moduleName, value.members !),\n-      statics: value.statics && this.convertStatics(moduleName, value.statics)\n-    };\n-  }\n-\n-  private convertMembers(moduleName: string, members: MetadataMap): MetadataMap {\n-    const result: MetadataMap = {};\n-    for (const name in members) {\n-      const value = members[name];\n-      result[name] = value.map(v => this.convertMember(moduleName, v));\n-    }\n-    return result;\n-  }\n-\n-  private convertMember(moduleName: string, member: MemberMetadata) {\n-    const result: MemberMetadata = {__symbolic: member.__symbolic};\n-    result.decorators =\n-        member.decorators && member.decorators.map(d => this.convertExpression(moduleName, d)!);\n-    if (isMethodMetadata(member)) {\n-      (result as MethodMetadata).parameterDecorators = member.parameterDecorators &&\n-          member.parameterDecorators.map(\n-              d => d && d.map(p => this.convertExpression(moduleName, p)!));\n-      if (isConstructorMetadata(member)) {\n-        if (member.parameters) {\n-          (result as ConstructorMetadata).parameters =\n-              member.parameters.map(p => this.convertExpression(moduleName, p));\n-        }\n-      }\n-    }\n-    return result;\n-  }\n-\n-  private convertStatics(moduleName: string, statics: StaticsMetadata): StaticsMetadata {\n-    let result: StaticsMetadata = {};\n-    for (const key in statics) {\n-      const value = statics[key];\n-\n-      if (isFunctionMetadata(value)) {\n-        result[key] = this.convertFunction(moduleName, value);\n-      } else if (isMetadataSymbolicCallExpression(value)) {\n-        // Class members can also contain static members that call a function with module\n-        // references. e.g. \"static ɵprov = ɵɵdefineInjectable(..)\". We also need to\n-        // convert these module references because otherwise these resolve to non-existent files.\n-        result[key] = this.convertValue(moduleName, value);\n-      } else {\n-        result[key] = value;\n-      }\n-    }\n-    return result;\n-  }\n-\n-  private convertFunction(moduleName: string, value: FunctionMetadata): FunctionMetadata {\n-    return {\n-      __symbolic: 'function',\n-      parameters: value.parameters,\n-      defaults: value.defaults && value.defaults.map(v => this.convertValue(moduleName, v)),\n-      value: this.convertValue(moduleName, value.value)\n-    };\n-  }\n-\n-  private convertValue(moduleName: string, value: MetadataValue): MetadataValue {\n-    if (isPrimitive(value)) {\n-      return value;\n-    }\n-    if (isMetadataError(value)) {\n-      return this.convertError(moduleName, value);\n-    }\n-    if (isMetadataSymbolicExpression(value)) {\n-      return this.convertExpression(moduleName, value)!;\n-    }\n-    if (Array.isArray(value)) {\n-      return value.map(v => this.convertValue(moduleName, v));\n-    }\n-\n-    // Otherwise it is a metadata object.\n-    const object = value as MetadataObject;\n-    const result: MetadataObject = {};\n-    for (const key in object) {\n-      result[key] = this.convertValue(moduleName, object[key]);\n-    }\n-    return result;\n-  }\n-\n-  private convertExpression(\n-      moduleName: string, value: MetadataSymbolicExpression|MetadataError|null|undefined):\n-      MetadataSymbolicExpression|MetadataError|undefined|null {\n-    if (value) {\n-      switch (value.__symbolic) {\n-        case 'error':\n-          return this.convertError(moduleName, value as MetadataError);\n-        case 'reference':\n-          return this.convertReference(moduleName, value as MetadataSymbolicReferenceExpression);\n-        default:\n-          return this.convertExpressionNode(moduleName, value);\n-      }\n-    }\n-    return value;\n-  }\n-\n-  private convertError(module: string, value: MetadataError): MetadataError {\n-    return {\n-      __symbolic: 'error',\n-      message: value.message,\n-      line: value.line,\n-      character: value.character,\n-      context: value.context,\n-      module\n-    };\n-  }\n-\n-  private convertReference(moduleName: string, value: MetadataSymbolicReferenceExpression):\n-      MetadataSymbolicReferenceExpression|MetadataError|undefined {\n-    const createReference = (symbol: Symbol): MetadataSymbolicReferenceExpression => {\n-      const declaration = symbol.declaration!;\n-      if (declaration.module.startsWith('.')) {\n-        // Reference to a symbol defined in the module. Ensure it is converted then return a\n-        // references to the final symbol.\n-        this.convertSymbol(symbol);\n-        return {\n-          __symbolic: 'reference',\n-          get name() {\n-            // Resolved lazily because private names are assigned late.\n-            const canonicalSymbol = symbol.canonicalSymbol!;\n-            if (canonicalSymbol.isPrivate == null) {\n-              throw Error('Invalid state: isPrivate was not initialized');\n-            }\n-            return canonicalSymbol.isPrivate ? canonicalSymbol.privateName! : canonicalSymbol.name;\n-          }\n-        };\n-      } else {\n-        // The symbol was a re-exported symbol from another module. Return a reference to the\n-        // original imported symbol.\n-        return {__symbolic: 'reference', name: declaration.name, module: declaration.module};\n-      }\n-    };\n-\n-    if (isMetadataGlobalReferenceExpression(value)) {\n-      const metadata = this.getMetadata(moduleName);\n-      if (metadata && metadata.metadata && metadata.metadata[value.name]) {\n-        // Reference to a symbol defined in the module\n-        return createReference(this.canonicalSymbolOf(moduleName, value.name));\n-      }\n-\n-      // If a reference has arguments, the arguments need to be converted.\n-      if (value.arguments) {\n-        return {\n-          __symbolic: 'reference',\n-          name: value.name,\n-          arguments: value.arguments.map(a => this.convertValue(moduleName, a))\n-        };\n-      }\n-\n-      // Global references without arguments (such as to Math or JSON) are unmodified.\n-      return value;\n-    }\n-\n-    if (isMetadataImportedSymbolReferenceExpression(value)) {\n-      // References to imported symbols are separated into two, references to bundled modules and\n-      // references to modules external to the bundle. If the module reference is relative it is\n-      // assumed to be in the bundle. If it is Global it is assumed to be outside the bundle.\n-      // References to symbols outside the bundle are left unmodified. References to symbol inside\n-      // the bundle need to be converted to a bundle import reference reachable from the bundle\n-      // index.\n-\n-      if (value.module.startsWith('.')) {\n-        // Reference is to a symbol defined inside the module. Convert the reference to a reference\n-        // to the canonical symbol.\n-        const referencedModule = resolveModule(value.module, moduleName);\n-        const referencedName = value.name;\n-        return createReference(this.canonicalSymbolOf(referencedModule, referencedName));\n-      }\n-\n-      // Value is a reference to a symbol defined outside the module.\n-      if (value.arguments) {\n-        // If a reference has arguments the arguments need to be converted.\n-        return {\n-          __symbolic: 'reference',\n-          name: value.name,\n-          module: value.module,\n-          arguments: value.arguments.map(a => this.convertValue(moduleName, a))\n-        };\n-      }\n-      return value;\n-    }\n-\n-    if (isMetadataModuleReferenceExpression(value)) {\n-      // Cannot support references to bundled modules as the internal modules of a bundle are erased\n-      // by the bundler.\n-      if (value.module.startsWith('.')) {\n-        return {\n-          __symbolic: 'error',\n-          message: 'Unsupported bundled module reference',\n-          context: {module: value.module}\n-        };\n-      }\n-\n-      // References to unbundled modules are unmodified.\n-      return value;\n-    }\n-  }\n-\n-  private convertExpressionNode(moduleName: string, value: MetadataSymbolicExpression):\n-      MetadataSymbolicExpression {\n-    const result: MetadataSymbolicExpression = {__symbolic: value.__symbolic} as any;\n-    for (const key in value) {\n-      (result as any)[key] = this.convertValue(moduleName, (value as any)[key]);\n-    }\n-    return result;\n-  }\n-\n-  private symbolOf(module: string, name: string): Symbol {\n-    const symbolKey = `${module}:${name}`;\n-    let symbol = this.symbolMap.get(symbolKey);\n-    if (!symbol) {\n-      symbol = {module, name};\n-      this.symbolMap.set(symbolKey, symbol);\n-    }\n-    return symbol;\n-  }\n-\n-  private canonicalSymbolOf(module: string, name: string): Symbol {\n-    // Ensure the module has been seen.\n-    this.exportAll(module);\n-    const symbol = this.symbolOf(module, name);\n-    if (!symbol.canonicalSymbol) {\n-      this.canonicalizeSymbol(symbol);\n-    }\n-    return symbol;\n-  }\n-}\n-\n-export class CompilerHostAdapter implements MetadataBundlerHost {\n-  private collector = new MetadataCollector();\n-\n-  constructor(\n-      private host: ts.CompilerHost, private cache: MetadataCache|null,\n-      private options: ts.CompilerOptions) {}\n-\n-  getMetadataFor(fileName: string, containingFile: string): ModuleMetadata|undefined {\n-    const {resolvedModule} =\n-        ts.resolveModuleName(fileName, containingFile, this.options, this.host);\n-\n-    let sourceFile: ts.SourceFile|undefined;\n-    if (resolvedModule) {\n-      let {resolvedFileName} = resolvedModule;\n-      if (resolvedModule.extension !== '.ts') {\n-        resolvedFileName = resolvedFileName.replace(/(\\.d\\.ts|\\.js)$/, '.ts');\n-      }\n-      sourceFile = this.host.getSourceFile(resolvedFileName, ts.ScriptTarget.Latest);\n-    } else {\n-      // If typescript is unable to resolve the file, fallback on old behavior\n-      if (!this.host.fileExists(fileName + '.ts')) return undefined;\n-      sourceFile = this.host.getSourceFile(fileName + '.ts', ts.ScriptTarget.Latest);\n-    }\n-\n-    // If there is a metadata cache, use it to get the metadata for this source file. Otherwise,\n-    // fall back on the locally created MetadataCollector.\n-    if (!sourceFile) {\n-      return undefined;\n-    } else if (this.cache) {\n-      return this.cache.getMetadata(sourceFile);\n-    } else {\n-      return this.collector.getMetadata(sourceFile);\n-    }\n-  }\n-}\n-\n-function resolveModule(importName: string, from: string): string {\n-  if (importName.startsWith('.') && from) {\n-    let normalPath = path.normalize(path.join(path.dirname(from), importName));\n-    if (!normalPath.startsWith('.') && from.startsWith('.')) {\n-      // path.normalize() preserves leading '../' but not './'. This adds it back.\n-      normalPath = `.${path.sep}${normalPath}`;\n-    }\n-    // Replace windows path delimiters with forward-slashes. Otherwise the paths are not\n-    // TypeScript compatible when building the bundle.\n-    return normalPath.replace(/\\\\/g, '/');\n-  }\n-  return importName;\n-}\n-\n-function isPrimitive(o: any): o is boolean|string|number {\n-  return o === null || (typeof o !== 'function' && typeof o !== 'object');\n-}\n-\n-function getRootExport(symbol: Symbol): Symbol {\n-  return symbol.reexportedAs ? getRootExport(symbol.reexportedAs) : symbol;\n-}\n-\n-function getSymbolDeclaration(symbol: Symbol): Symbol {\n-  return symbol.exports ? getSymbolDeclaration(symbol.exports) : symbol;\n-}"
        },
        {
            "sha": "8bee925b50d19b8ee7c9b2757a76b78aca10060f",
            "filename": "packages/compiler-cli/src/metadata/collector.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 781,
            "changes": 781,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Fcollector.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Fcollector.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Fcollector.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,781 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {errorSymbol, Evaluator, recordMapEntry} from './evaluator';\n-import {ClassMetadata, ConstructorMetadata, FunctionMetadata, InterfaceMetadata, isClassMetadata, isConstructorMetadata, isFunctionMetadata, isMetadataError, isMetadataGlobalReferenceExpression, isMetadataImportDefaultReference, isMetadataImportedSymbolReferenceExpression, isMetadataSymbolicExpression, isMetadataSymbolicReferenceExpression, isMetadataSymbolicSelectExpression, isMethodMetadata, MemberMetadata, METADATA_VERSION, MetadataEntry, MetadataError, MetadataMap, MetadataSymbolicBinaryExpression, MetadataSymbolicCallExpression, MetadataSymbolicExpression, MetadataSymbolicIfExpression, MetadataSymbolicIndexExpression, MetadataSymbolicPrefixExpression, MetadataSymbolicReferenceExpression, MetadataSymbolicSelectExpression, MetadataSymbolicSpreadExpression, MetadataValue, MethodMetadata, ModuleExportMetadata, ModuleMetadata} from './schema';\n-import {Symbols} from './symbols';\n-\n-const isStatic = (node: ts.Declaration) =>\n-    ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Static;\n-\n-/**\n- * A set of collector options to use when collecting metadata.\n- */\n-export interface CollectorOptions {\n-  /**\n-   * Version of the metadata to collect.\n-   */\n-  version?: number;\n-\n-  /**\n-   * Collect a hidden field \"$quoted$\" in objects literals that record when the key was quoted in\n-   * the source.\n-   */\n-  quotedNames?: boolean;\n-\n-  /**\n-   * Do not simplify invalid expressions.\n-   */\n-  verboseInvalidExpression?: boolean;\n-\n-  /**\n-   * An expression substitution callback.\n-   */\n-  substituteExpression?: (value: MetadataValue, node: ts.Node) => MetadataValue;\n-}\n-\n-/**\n- * Collect decorator metadata from a TypeScript module.\n- */\n-export class MetadataCollector {\n-  constructor(private options: CollectorOptions = {}) {}\n-\n-  /**\n-   * Returns a JSON.stringify friendly form describing the decorators of the exported classes from\n-   * the source file that is expected to correspond to a module.\n-   */\n-  public getMetadata(\n-      sourceFile: ts.SourceFile, strict: boolean = false,\n-      substituteExpression?: (value: MetadataValue, node: ts.Node) => MetadataValue): ModuleMetadata\n-      |undefined {\n-    const locals = new Symbols(sourceFile);\n-    const nodeMap =\n-        new Map<MetadataValue|ClassMetadata|InterfaceMetadata|FunctionMetadata, ts.Node>();\n-    const composedSubstituter = substituteExpression && this.options.substituteExpression ?\n-        (value: MetadataValue, node: ts.Node) =>\n-            this.options.substituteExpression!(substituteExpression(value, node), node) :\n-        substituteExpression;\n-    const evaluatorOptions = substituteExpression ?\n-        {...this.options, substituteExpression: composedSubstituter} :\n-        this.options;\n-    let metadata: {[name: string]: MetadataValue|ClassMetadata|FunctionMetadata}|undefined;\n-    const evaluator = new Evaluator(locals, nodeMap, evaluatorOptions, (name, value) => {\n-      if (!metadata) metadata = {};\n-      metadata[name] = value;\n-    });\n-    let exports: ModuleExportMetadata[]|undefined = undefined;\n-\n-    function objFromDecorator(decoratorNode: ts.Decorator): MetadataSymbolicExpression {\n-      return <MetadataSymbolicExpression>evaluator.evaluateNode(decoratorNode.expression);\n-    }\n-\n-    function recordEntry<T extends MetadataEntry>(entry: T, node: ts.Node): T {\n-      if (composedSubstituter) {\n-        entry = composedSubstituter(entry as MetadataValue, node) as T;\n-      }\n-      return recordMapEntry(entry, node, nodeMap, sourceFile);\n-    }\n-\n-    function errorSym(\n-        message: string, node?: ts.Node, context?: {[name: string]: string}): MetadataError {\n-      return errorSymbol(message, node, context, sourceFile);\n-    }\n-\n-    function maybeGetSimpleFunction(functionDeclaration: ts.FunctionDeclaration|\n-                                    ts.MethodDeclaration): {func: FunctionMetadata, name: string}|\n-        undefined {\n-      if (functionDeclaration.name && functionDeclaration.name.kind == ts.SyntaxKind.Identifier) {\n-        const nameNode = <ts.Identifier>functionDeclaration.name;\n-        const functionName = nameNode.text;\n-        const functionBody = functionDeclaration.body;\n-        if (functionBody && functionBody.statements.length == 1) {\n-          const statement = functionBody.statements[0];\n-          if (statement.kind === ts.SyntaxKind.ReturnStatement) {\n-            const returnStatement = <ts.ReturnStatement>statement;\n-            if (returnStatement.expression) {\n-              const func: FunctionMetadata = {\n-                __symbolic: 'function',\n-                parameters: namesOf(functionDeclaration.parameters),\n-                value: evaluator.evaluateNode(returnStatement.expression)\n-              };\n-              if (functionDeclaration.parameters.some(p => p.initializer != null)) {\n-                func.defaults = functionDeclaration.parameters.map(\n-                    p => p.initializer && evaluator.evaluateNode(p.initializer));\n-              }\n-              return recordEntry({func, name: functionName}, functionDeclaration);\n-            }\n-          }\n-        }\n-      }\n-    }\n-\n-    function classMetadataOf(classDeclaration: ts.ClassDeclaration): ClassMetadata {\n-      const result: ClassMetadata = {__symbolic: 'class'};\n-\n-      function getDecorators(decorators: ReadonlyArray<ts.Decorator>|\n-                             undefined): MetadataSymbolicExpression[]|undefined {\n-        if (decorators && decorators.length)\n-          return decorators.map(decorator => objFromDecorator(decorator));\n-        return undefined;\n-      }\n-\n-      function referenceFrom(node: ts.Node): MetadataSymbolicReferenceExpression|MetadataError|\n-          MetadataSymbolicSelectExpression {\n-        const result = evaluator.evaluateNode(node);\n-        if (isMetadataError(result) || isMetadataSymbolicReferenceExpression(result) ||\n-            isMetadataSymbolicSelectExpression(result)) {\n-          return result;\n-        } else {\n-          return errorSym('Symbol reference expected', node);\n-        }\n-      }\n-\n-      // Add class parents\n-      if (classDeclaration.heritageClauses) {\n-        classDeclaration.heritageClauses.forEach((hc) => {\n-          if (hc.token === ts.SyntaxKind.ExtendsKeyword && hc.types) {\n-            hc.types.forEach(type => result.extends = referenceFrom(type.expression));\n-          }\n-        });\n-      }\n-\n-      // Add arity if the type is generic\n-      const typeParameters = classDeclaration.typeParameters;\n-      if (typeParameters && typeParameters.length) {\n-        result.arity = typeParameters.length;\n-      }\n-\n-      // Add class decorators\n-      if (classDeclaration.decorators) {\n-        result.decorators = getDecorators(classDeclaration.decorators);\n-      }\n-\n-      // member decorators\n-      let members: MetadataMap|null = null;\n-      function recordMember(name: string, metadata: MemberMetadata) {\n-        if (!members) members = {};\n-        const data = members.hasOwnProperty(name) ? members[name] : [];\n-        data.push(metadata);\n-        members[name] = data;\n-      }\n-\n-      // static member\n-      let statics: {[name: string]: MetadataValue|FunctionMetadata}|null = null;\n-      function recordStaticMember(name: string, value: MetadataValue|FunctionMetadata) {\n-        if (!statics) statics = {};\n-        statics[name] = value;\n-      }\n-\n-      for (const member of classDeclaration.members) {\n-        let isConstructor = false;\n-        switch (member.kind) {\n-          case ts.SyntaxKind.Constructor:\n-          case ts.SyntaxKind.MethodDeclaration:\n-            isConstructor = member.kind === ts.SyntaxKind.Constructor;\n-            const method = <ts.MethodDeclaration|ts.ConstructorDeclaration>member;\n-            if (isStatic(method)) {\n-              const maybeFunc = maybeGetSimpleFunction(<ts.MethodDeclaration>method);\n-              if (maybeFunc) {\n-                recordStaticMember(maybeFunc.name, maybeFunc.func);\n-              }\n-              continue;\n-            }\n-            const methodDecorators = getDecorators(method.decorators);\n-            const parameters = method.parameters;\n-            const parameterDecoratorData: ((MetadataSymbolicExpression | MetadataError)[]|\n-                                           undefined)[] = [];\n-            const parametersData: (MetadataSymbolicReferenceExpression|MetadataError|\n-                                   MetadataSymbolicSelectExpression|null)[] = [];\n-            let hasDecoratorData: boolean = false;\n-            let hasParameterData: boolean = false;\n-            for (const parameter of parameters) {\n-              const parameterData = getDecorators(parameter.decorators);\n-              parameterDecoratorData.push(parameterData);\n-              hasDecoratorData = hasDecoratorData || !!parameterData;\n-              if (isConstructor) {\n-                if (parameter.type) {\n-                  parametersData.push(referenceFrom(parameter.type));\n-                } else {\n-                  parametersData.push(null);\n-                }\n-                hasParameterData = true;\n-              }\n-            }\n-            const data: MethodMetadata = {__symbolic: isConstructor ? 'constructor' : 'method'};\n-            const name = isConstructor ? '__ctor__' : evaluator.nameOf(member.name);\n-            if (methodDecorators) {\n-              data.decorators = methodDecorators;\n-            }\n-            if (hasDecoratorData) {\n-              data.parameterDecorators = parameterDecoratorData;\n-            }\n-            if (hasParameterData) {\n-              (<ConstructorMetadata>data).parameters = parametersData;\n-            }\n-            if (!isMetadataError(name)) {\n-              recordMember(name, data);\n-            }\n-            break;\n-          case ts.SyntaxKind.PropertyDeclaration:\n-          case ts.SyntaxKind.GetAccessor:\n-          case ts.SyntaxKind.SetAccessor:\n-            const property = <ts.PropertyDeclaration>member;\n-            if (isStatic(property)) {\n-              const name = evaluator.nameOf(property.name);\n-              if (!isMetadataError(name) && !shouldIgnoreStaticMember(name)) {\n-                if (property.initializer) {\n-                  const value = evaluator.evaluateNode(property.initializer);\n-                  recordStaticMember(name, value);\n-                } else {\n-                  recordStaticMember(name, errorSym('Variable not initialized', property.name));\n-                }\n-              }\n-            }\n-            const propertyDecorators = getDecorators(property.decorators);\n-            if (propertyDecorators) {\n-              const name = evaluator.nameOf(property.name);\n-              if (!isMetadataError(name)) {\n-                recordMember(name, {__symbolic: 'property', decorators: propertyDecorators});\n-              }\n-            }\n-            break;\n-        }\n-      }\n-      if (members) {\n-        result.members = members;\n-      }\n-      if (statics) {\n-        result.statics = statics;\n-      }\n-\n-      return recordEntry(result, classDeclaration);\n-    }\n-\n-    // Collect all exported symbols from an exports clause.\n-    const exportMap = new Map<string, string>();\n-    ts.forEachChild(sourceFile, node => {\n-      switch (node.kind) {\n-        case ts.SyntaxKind.ExportDeclaration:\n-          const exportDeclaration = <ts.ExportDeclaration>node;\n-          const {moduleSpecifier, exportClause} = exportDeclaration;\n-\n-          if (!moduleSpecifier && exportClause && ts.isNamedExports(exportClause)) {\n-            // If there is a module specifier there is also an exportClause\n-            exportClause.elements.forEach(spec => {\n-              const exportedAs = spec.name.text;\n-              const name = (spec.propertyName || spec.name).text;\n-              exportMap.set(name, exportedAs);\n-            });\n-          }\n-      }\n-    });\n-\n-    const isExport = (node: ts.Node) => sourceFile.isDeclarationFile ||\n-        ts.getCombinedModifierFlags(node as ts.Declaration) & ts.ModifierFlags.Export;\n-    const isExportedIdentifier = (identifier?: ts.Identifier) =>\n-        identifier && exportMap.has(identifier.text);\n-    const isExported = (node: ts.FunctionDeclaration|ts.ClassDeclaration|ts.TypeAliasDeclaration|\n-                        ts.InterfaceDeclaration|ts.EnumDeclaration) =>\n-        isExport(node) || isExportedIdentifier(node.name);\n-    const exportedIdentifierName = (identifier?: ts.Identifier) =>\n-        identifier && (exportMap.get(identifier.text) || identifier.text);\n-    const exportedName = (node: ts.FunctionDeclaration|ts.ClassDeclaration|\n-                          ts.InterfaceDeclaration|ts.TypeAliasDeclaration|ts.EnumDeclaration) =>\n-        exportedIdentifierName(node.name);\n-\n-\n-    // Pre-declare classes and functions\n-    ts.forEachChild(sourceFile, node => {\n-      switch (node.kind) {\n-        case ts.SyntaxKind.ClassDeclaration:\n-          const classDeclaration = <ts.ClassDeclaration>node;\n-          if (classDeclaration.name) {\n-            const className = classDeclaration.name.text;\n-            if (isExported(classDeclaration)) {\n-              locals.define(\n-                  className, {__symbolic: 'reference', name: exportedName(classDeclaration)});\n-            } else {\n-              locals.define(\n-                  className, errorSym('Reference to non-exported class', node, {className}));\n-            }\n-          }\n-          break;\n-\n-        case ts.SyntaxKind.InterfaceDeclaration:\n-          const interfaceDeclaration = <ts.InterfaceDeclaration>node;\n-          if (interfaceDeclaration.name) {\n-            const interfaceName = interfaceDeclaration.name.text;\n-            // All references to interfaces should be converted to references to `any`.\n-            locals.define(interfaceName, {__symbolic: 'reference', name: 'any'});\n-          }\n-          break;\n-\n-        case ts.SyntaxKind.FunctionDeclaration:\n-          const functionDeclaration = <ts.FunctionDeclaration>node;\n-          if (!isExported(functionDeclaration)) {\n-            // Report references to this function as an error.\n-            const nameNode = functionDeclaration.name;\n-            if (nameNode && nameNode.text) {\n-              locals.define(\n-                  nameNode.text,\n-                  errorSym(\n-                      'Reference to a non-exported function', nameNode, {name: nameNode.text}));\n-            }\n-          }\n-          break;\n-      }\n-    });\n-\n-    ts.forEachChild(sourceFile, node => {\n-      switch (node.kind) {\n-        case ts.SyntaxKind.ExportDeclaration:\n-          // Record export declarations\n-          const exportDeclaration = <ts.ExportDeclaration>node;\n-          const {moduleSpecifier, exportClause} = exportDeclaration;\n-\n-          if (!moduleSpecifier) {\n-            // no module specifier -> export {propName as name};\n-            if (exportClause && ts.isNamedExports(exportClause)) {\n-              exportClause.elements.forEach(spec => {\n-                const name = spec.name.text;\n-                // If the symbol was not already exported, export a reference since it is a\n-                // reference to an import\n-                if (!metadata || !metadata[name]) {\n-                  const propNode = spec.propertyName || spec.name;\n-                  const value: MetadataValue = evaluator.evaluateNode(propNode);\n-                  if (!metadata) metadata = {};\n-                  metadata[name] = recordEntry(value, node);\n-                }\n-              });\n-            }\n-          }\n-\n-          if (moduleSpecifier && moduleSpecifier.kind == ts.SyntaxKind.StringLiteral) {\n-            // Ignore exports that don't have string literals as exports.\n-            // This is allowed by the syntax but will be flagged as an error by the type checker.\n-            const from = (<ts.StringLiteral>moduleSpecifier).text;\n-            const moduleExport: ModuleExportMetadata = {from};\n-            if (exportClause && ts.isNamedExports(exportClause)) {\n-              moduleExport.export = exportClause.elements.map(\n-                  spec => spec.propertyName ? {name: spec.propertyName.text, as: spec.name.text} :\n-                                              spec.name.text);\n-            }\n-            if (!exports) exports = [];\n-            exports.push(moduleExport);\n-          }\n-          break;\n-        case ts.SyntaxKind.ClassDeclaration:\n-          const classDeclaration = <ts.ClassDeclaration>node;\n-          if (classDeclaration.name) {\n-            if (isExported(classDeclaration)) {\n-              const name = exportedName(classDeclaration);\n-              if (name) {\n-                if (!metadata) metadata = {};\n-                metadata[name] = classMetadataOf(classDeclaration);\n-              }\n-            }\n-          }\n-          // Otherwise don't record metadata for the class.\n-          break;\n-\n-        case ts.SyntaxKind.TypeAliasDeclaration:\n-          const typeDeclaration = <ts.TypeAliasDeclaration>node;\n-          if (typeDeclaration.name && isExported(typeDeclaration)) {\n-            const name = exportedName(typeDeclaration);\n-            if (name) {\n-              if (!metadata) metadata = {};\n-              metadata[name] = {__symbolic: 'interface'};\n-            }\n-          }\n-          break;\n-\n-        case ts.SyntaxKind.InterfaceDeclaration:\n-          const interfaceDeclaration = <ts.InterfaceDeclaration>node;\n-          if (interfaceDeclaration.name && isExported(interfaceDeclaration)) {\n-            const name = exportedName(interfaceDeclaration);\n-            if (name) {\n-              if (!metadata) metadata = {};\n-              metadata[name] = {__symbolic: 'interface'};\n-            }\n-          }\n-          break;\n-\n-        case ts.SyntaxKind.FunctionDeclaration:\n-          // Record functions that return a single value. Record the parameter\n-          // names substitution will be performed by the StaticReflector.\n-          const functionDeclaration = <ts.FunctionDeclaration>node;\n-          if (isExported(functionDeclaration) && functionDeclaration.name) {\n-            const name = exportedName(functionDeclaration);\n-            const maybeFunc = maybeGetSimpleFunction(functionDeclaration);\n-            if (name) {\n-              if (!metadata) metadata = {};\n-              // TODO(alxhub): The literal here is not valid FunctionMetadata.\n-              metadata[name] =\n-                  maybeFunc ? recordEntry(maybeFunc.func, node) : ({__symbolic: 'function'} as any);\n-            }\n-          }\n-          break;\n-\n-        case ts.SyntaxKind.EnumDeclaration:\n-          const enumDeclaration = <ts.EnumDeclaration>node;\n-          if (isExported(enumDeclaration)) {\n-            const enumValueHolder: {[name: string]: MetadataValue} = {};\n-            const enumName = exportedName(enumDeclaration);\n-            let nextDefaultValue: MetadataValue = 0;\n-            let writtenMembers = 0;\n-            for (const member of enumDeclaration.members) {\n-              let enumValue: MetadataValue;\n-              if (!member.initializer) {\n-                enumValue = nextDefaultValue;\n-              } else {\n-                enumValue = evaluator.evaluateNode(member.initializer);\n-              }\n-              let name: string|undefined = undefined;\n-              if (member.name.kind == ts.SyntaxKind.Identifier) {\n-                const identifier = <ts.Identifier>member.name;\n-                name = identifier.text;\n-                enumValueHolder[name] = enumValue;\n-                writtenMembers++;\n-              }\n-              if (typeof enumValue === 'number') {\n-                nextDefaultValue = enumValue + 1;\n-              } else if (name) {\n-                // TODO(alxhub): 'left' here has a name propery which is not valid for\n-                // MetadataSymbolicSelectExpression.\n-                nextDefaultValue = {\n-                  __symbolic: 'binary',\n-                  operator: '+',\n-                  left: {\n-                    __symbolic: 'select',\n-                    expression: recordEntry({__symbolic: 'reference', name: enumName}, node),\n-                    name\n-                  },\n-                } as any;\n-              } else {\n-                nextDefaultValue =\n-                    recordEntry(errorSym('Unsupported enum member name', member.name), node);\n-              }\n-            }\n-            if (writtenMembers) {\n-              if (enumName) {\n-                if (!metadata) metadata = {};\n-                metadata[enumName] = recordEntry(enumValueHolder, node);\n-              }\n-            }\n-          }\n-          break;\n-\n-        case ts.SyntaxKind.VariableStatement:\n-          const variableStatement = <ts.VariableStatement>node;\n-          for (const variableDeclaration of variableStatement.declarationList.declarations) {\n-            if (variableDeclaration.name.kind == ts.SyntaxKind.Identifier) {\n-              const nameNode = <ts.Identifier>variableDeclaration.name;\n-              let varValue: MetadataValue;\n-              if (variableDeclaration.initializer) {\n-                varValue = evaluator.evaluateNode(variableDeclaration.initializer);\n-              } else {\n-                varValue = recordEntry(errorSym('Variable not initialized', nameNode), nameNode);\n-              }\n-              let exported = false;\n-              if (isExport(variableStatement) || isExport(variableDeclaration) ||\n-                  isExportedIdentifier(nameNode)) {\n-                const name = exportedIdentifierName(nameNode);\n-                if (name) {\n-                  if (!metadata) metadata = {};\n-                  metadata[name] = recordEntry(varValue, node);\n-                }\n-                exported = true;\n-              }\n-              if (typeof varValue == 'string' || typeof varValue == 'number' ||\n-                  typeof varValue == 'boolean') {\n-                locals.define(nameNode.text, varValue);\n-                if (exported) {\n-                  locals.defineReference(\n-                      nameNode.text, {__symbolic: 'reference', name: nameNode.text});\n-                }\n-              } else if (!exported) {\n-                if (varValue && !isMetadataError(varValue)) {\n-                  locals.define(nameNode.text, recordEntry(varValue, node));\n-                } else {\n-                  locals.define(\n-                      nameNode.text,\n-                      recordEntry(\n-                          errorSym('Reference to a local symbol', nameNode, {name: nameNode.text}),\n-                          node));\n-                }\n-              }\n-            } else {\n-              // Destructuring (or binding) declarations are not supported,\n-              // var {<identifier>[, <identifier>]+} = <expression>;\n-              //   or\n-              // var [<identifier>[, <identifier}+] = <expression>;\n-              // are not supported.\n-              const report: (nameNode: ts.Node) => void = (nameNode: ts.Node) => {\n-                switch (nameNode.kind) {\n-                  case ts.SyntaxKind.Identifier:\n-                    const name = <ts.Identifier>nameNode;\n-                    const varValue = errorSym('Destructuring not supported', name);\n-                    locals.define(name.text, varValue);\n-                    if (isExport(node)) {\n-                      if (!metadata) metadata = {};\n-                      metadata[name.text] = varValue;\n-                    }\n-                    break;\n-                  case ts.SyntaxKind.BindingElement:\n-                    const bindingElement = <ts.BindingElement>nameNode;\n-                    report(bindingElement.name);\n-                    break;\n-                  case ts.SyntaxKind.ObjectBindingPattern:\n-                  case ts.SyntaxKind.ArrayBindingPattern:\n-                    const bindings = <ts.BindingPattern>nameNode;\n-                    (bindings as any).elements.forEach(report);\n-                    break;\n-                }\n-              };\n-              report(variableDeclaration.name);\n-            }\n-          }\n-          break;\n-      }\n-    });\n-\n-    if (metadata || exports) {\n-      if (!metadata)\n-        metadata = {};\n-      else if (strict) {\n-        validateMetadata(sourceFile, nodeMap, metadata);\n-      }\n-      const result: ModuleMetadata = {\n-        __symbolic: 'module',\n-        version: this.options.version || METADATA_VERSION,\n-        metadata\n-      };\n-      if (sourceFile.moduleName) result.importAs = sourceFile.moduleName;\n-      if (exports) result.exports = exports;\n-      return result;\n-    }\n-  }\n-}\n-\n-// This will throw if the metadata entry given contains an error node.\n-function validateMetadata(\n-    sourceFile: ts.SourceFile, nodeMap: Map<MetadataEntry, ts.Node>,\n-    metadata: {[name: string]: MetadataEntry}) {\n-  let locals: Set<string> = new Set(['Array', 'Object', 'Set', 'Map', 'string', 'number', 'any']);\n-\n-  function validateExpression(expression: MetadataValue|MetadataSymbolicExpression|MetadataError) {\n-    if (!expression) {\n-      return;\n-    } else if (Array.isArray(expression)) {\n-      expression.forEach(validateExpression);\n-    } else if (typeof expression === 'object' && !expression.hasOwnProperty('__symbolic')) {\n-      Object.getOwnPropertyNames(expression).forEach(v => validateExpression((<any>expression)[v]));\n-    } else if (isMetadataError(expression)) {\n-      reportError(expression);\n-    } else if (isMetadataGlobalReferenceExpression(expression)) {\n-      if (!locals.has(expression.name)) {\n-        const reference = <MetadataValue>metadata[expression.name];\n-        if (reference) {\n-          validateExpression(reference);\n-        }\n-      }\n-    } else if (isFunctionMetadata(expression)) {\n-      validateFunction(<any>expression);\n-    } else if (isMetadataSymbolicExpression(expression)) {\n-      switch (expression.__symbolic) {\n-        case 'binary':\n-          const binaryExpression = <MetadataSymbolicBinaryExpression>expression;\n-          validateExpression(binaryExpression.left);\n-          validateExpression(binaryExpression.right);\n-          break;\n-        case 'call':\n-        case 'new':\n-          const callExpression = <MetadataSymbolicCallExpression>expression;\n-          validateExpression(callExpression.expression);\n-          if (callExpression.arguments) callExpression.arguments.forEach(validateExpression);\n-          break;\n-        case 'index':\n-          const indexExpression = <MetadataSymbolicIndexExpression>expression;\n-          validateExpression(indexExpression.expression);\n-          validateExpression(indexExpression.index);\n-          break;\n-        case 'pre':\n-          const prefixExpression = <MetadataSymbolicPrefixExpression>expression;\n-          validateExpression(prefixExpression.operand);\n-          break;\n-        case 'select':\n-          const selectExpression = <MetadataSymbolicSelectExpression>expression;\n-          validateExpression(selectExpression.expression);\n-          break;\n-        case 'spread':\n-          const spreadExpression = <MetadataSymbolicSpreadExpression>expression;\n-          validateExpression(spreadExpression.expression);\n-          break;\n-        case 'if':\n-          const ifExpression = <MetadataSymbolicIfExpression>expression;\n-          validateExpression(ifExpression.condition);\n-          validateExpression(ifExpression.elseExpression);\n-          validateExpression(ifExpression.thenExpression);\n-          break;\n-      }\n-    }\n-  }\n-\n-  function validateMember(classData: ClassMetadata, member: MemberMetadata) {\n-    if (member.decorators) {\n-      member.decorators.forEach(validateExpression);\n-    }\n-    if (isMethodMetadata(member) && member.parameterDecorators) {\n-      member.parameterDecorators.forEach(validateExpression);\n-    }\n-    // Only validate parameters of classes for which we know that are used with our DI\n-    if (classData.decorators && isConstructorMetadata(member) && member.parameters) {\n-      member.parameters.forEach(validateExpression);\n-    }\n-  }\n-\n-  function validateClass(classData: ClassMetadata) {\n-    if (classData.decorators) {\n-      classData.decorators.forEach(validateExpression);\n-    }\n-    if (classData.members) {\n-      Object.getOwnPropertyNames(classData.members)\n-          .forEach(name => classData.members![name].forEach((m) => validateMember(classData, m)));\n-    }\n-    if (classData.statics) {\n-      Object.getOwnPropertyNames(classData.statics).forEach(name => {\n-        const staticMember = classData.statics![name];\n-        if (isFunctionMetadata(staticMember)) {\n-          validateExpression(staticMember.value);\n-        } else {\n-          validateExpression(staticMember);\n-        }\n-      });\n-    }\n-  }\n-\n-  function validateFunction(functionDeclaration: FunctionMetadata) {\n-    if (functionDeclaration.value) {\n-      const oldLocals = locals;\n-      if (functionDeclaration.parameters) {\n-        locals = new Set(oldLocals.values());\n-        if (functionDeclaration.parameters)\n-          functionDeclaration.parameters.forEach(n => locals.add(n));\n-      }\n-      validateExpression(functionDeclaration.value);\n-      locals = oldLocals;\n-    }\n-  }\n-\n-  function shouldReportNode(node: ts.Node|undefined) {\n-    if (node) {\n-      const nodeStart = node.getStart();\n-      return !(\n-          node.pos != nodeStart &&\n-          sourceFile.text.substring(node.pos, nodeStart).indexOf('@dynamic') >= 0);\n-    }\n-    return true;\n-  }\n-\n-  function reportError(error: MetadataError) {\n-    const node = nodeMap.get(error);\n-    if (shouldReportNode(node)) {\n-      const lineInfo = error.line != undefined ? error.character != undefined ?\n-                                                 `:${error.line + 1}:${error.character + 1}` :\n-                                                 `:${error.line + 1}` :\n-                                                 '';\n-      throw new Error(`${sourceFile.fileName}${\n-          lineInfo}: Metadata collected contains an error that will be reported at runtime: ${\n-          expandedMessage(error)}.\\n  ${JSON.stringify(error)}`);\n-    }\n-  }\n-\n-  Object.getOwnPropertyNames(metadata).forEach(name => {\n-    const entry = metadata[name];\n-    try {\n-      if (isClassMetadata(entry)) {\n-        validateClass(entry);\n-      }\n-    } catch (e) {\n-      const node = nodeMap.get(entry);\n-      if (shouldReportNode(node)) {\n-        if (node) {\n-          const {line, character} = sourceFile.getLineAndCharacterOfPosition(node.getStart());\n-          throw new Error(`${sourceFile.fileName}:${line + 1}:${\n-              character + 1}: Error encountered in metadata generated for exported symbol '${\n-              name}': \\n ${e.message}`);\n-        }\n-        throw new Error(\n-            `Error encountered in metadata generated for exported symbol ${name}: \\n ${e.message}`);\n-      }\n-    }\n-  });\n-}\n-\n-// Collect parameter names from a function.\n-function namesOf(parameters: ts.NodeArray<ts.ParameterDeclaration>): string[] {\n-  const result: string[] = [];\n-\n-  function addNamesOf(name: ts.Identifier|ts.BindingPattern) {\n-    if (name.kind == ts.SyntaxKind.Identifier) {\n-      const identifier = <ts.Identifier>name;\n-      result.push(identifier.text);\n-    } else {\n-      const bindingPattern = <ts.BindingPattern>name;\n-      for (const element of bindingPattern.elements) {\n-        const name = (element as any).name;\n-        if (name) {\n-          addNamesOf(name);\n-        }\n-      }\n-    }\n-  }\n-\n-  for (const parameter of parameters) {\n-    addNamesOf(parameter.name);\n-  }\n-\n-  return result;\n-}\n-\n-function shouldIgnoreStaticMember(memberName: string): boolean {\n-  return memberName.startsWith('ngAcceptInputType_') || memberName.startsWith('ngTemplateGuard_');\n-}\n-\n-function expandedMessage(error: any): string {\n-  switch (error.message) {\n-    case 'Reference to non-exported class':\n-      if (error.context && error.context.className) {\n-        return `Reference to a non-exported class ${\n-            error.context.className}. Consider exporting the class`;\n-      }\n-      break;\n-    case 'Variable not initialized':\n-      return 'Only initialized variables and constants can be referenced because the value of this variable is needed by the template compiler';\n-    case 'Destructuring not supported':\n-      return 'Referencing an exported destructured variable or constant is not supported by the template compiler. Consider simplifying this to avoid destructuring';\n-    case 'Could not resolve type':\n-      if (error.context && error.context.typeName) {\n-        return `Could not resolve type ${error.context.typeName}`;\n-      }\n-      break;\n-    case 'Function call not supported':\n-      let prefix =\n-          error.context && error.context.name ? `Calling function '${error.context.name}', f` : 'F';\n-      return prefix +\n-          'unction calls are not supported. Consider replacing the function or lambda with a reference to an exported function';\n-    case 'Reference to a local symbol':\n-      if (error.context && error.context.name) {\n-        return `Reference to a local (non-exported) symbol '${\n-            error.context.name}'. Consider exporting the symbol`;\n-      }\n-  }\n-  return error.message;\n-}"
        },
        {
            "sha": "635165d9da5f527d29fdf6bc6192f2ad670b0e65",
            "filename": "packages/compiler-cli/src/metadata/evaluator.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 697,
            "changes": 697,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Fevaluator.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Fevaluator.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Fevaluator.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,697 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {CollectorOptions} from './collector';\n-import {ClassMetadata, FunctionMetadata, InterfaceMetadata, isMetadataError, isMetadataGlobalReferenceExpression, isMetadataImportDefaultReference, isMetadataImportedSymbolReferenceExpression, isMetadataModuleReferenceExpression, isMetadataSymbolicReferenceExpression, isMetadataSymbolicSpreadExpression, MetadataEntry, MetadataError, MetadataImportedSymbolReferenceExpression, MetadataSourceLocationInfo, MetadataSymbolicCallExpression, MetadataValue} from './schema';\n-import {Symbols} from './symbols';\n-\n-\n-\n-// In TypeScript 2.1 the spread element kind was renamed.\n-const spreadElementSyntaxKind: ts.SyntaxKind =\n-    (ts.SyntaxKind as any).SpreadElement || (ts.SyntaxKind as any).SpreadElementExpression;\n-\n-function isMethodCallOf(callExpression: ts.CallExpression, memberName: string): boolean {\n-  const expression = callExpression.expression;\n-  if (expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n-    const propertyAccessExpression = <ts.PropertyAccessExpression>expression;\n-    const name = propertyAccessExpression.name;\n-    if (name.kind == ts.SyntaxKind.Identifier) {\n-      return name.text === memberName;\n-    }\n-  }\n-  return false;\n-}\n-\n-function isCallOf(callExpression: ts.CallExpression, ident: string): boolean {\n-  const expression = callExpression.expression;\n-  if (expression.kind === ts.SyntaxKind.Identifier) {\n-    const identifier = <ts.Identifier>expression;\n-    return identifier.text === ident;\n-  }\n-  return false;\n-}\n-\n-/* @internal */\n-export function recordMapEntry<T extends MetadataEntry>(\n-    entry: T, node: ts.Node,\n-    nodeMap: Map<MetadataValue|ClassMetadata|InterfaceMetadata|FunctionMetadata, ts.Node>,\n-    sourceFile?: ts.SourceFile) {\n-  if (!nodeMap.has(entry)) {\n-    nodeMap.set(entry, node);\n-    if (node &&\n-        (isMetadataImportedSymbolReferenceExpression(entry) ||\n-         isMetadataImportDefaultReference(entry)) &&\n-        entry.line == null) {\n-      const info = sourceInfo(node, sourceFile);\n-      if (info.line != null) entry.line = info.line;\n-      if (info.character != null) entry.character = info.character;\n-    }\n-  }\n-  return entry;\n-}\n-\n-/**\n- * ts.forEachChild stops iterating children when the callback return a truthy value.\n- * This method inverts this to implement an `every` style iterator. It will return\n- * true if every call to `cb` returns `true`.\n- */\n-function everyNodeChild(node: ts.Node, cb: (node: ts.Node) => boolean) {\n-  return !ts.forEachChild(node, node => !cb(node));\n-}\n-\n-export function isPrimitive(value: any): boolean {\n-  return Object(value) !== value;\n-}\n-\n-function isDefined(obj: any): boolean {\n-  return obj !== undefined;\n-}\n-\n-// import {propertyName as name} from 'place'\n-// import {name} from 'place'\n-export interface ImportSpecifierMetadata {\n-  name: string;\n-  propertyName?: string;\n-}\n-export interface ImportMetadata {\n-  defaultName?: string;                      // import d from 'place'\n-  namespace?: string;                        // import * as d from 'place'\n-  namedImports?: ImportSpecifierMetadata[];  // import {a} from 'place'\n-  from: string;                              // from 'place'\n-}\n-\n-\n-function getSourceFileOfNode(node: ts.Node|undefined): ts.SourceFile {\n-  while (node && node.kind != ts.SyntaxKind.SourceFile) {\n-    node = node.parent;\n-  }\n-  return <ts.SourceFile>node;\n-}\n-\n-/* @internal */\n-export function sourceInfo(\n-    node: ts.Node|undefined, sourceFile: ts.SourceFile|undefined): MetadataSourceLocationInfo {\n-  if (node) {\n-    sourceFile = sourceFile || getSourceFileOfNode(node);\n-    if (sourceFile) {\n-      return ts.getLineAndCharacterOfPosition(sourceFile, node.getStart(sourceFile));\n-    }\n-  }\n-  return {};\n-}\n-\n-/* @internal */\n-export function errorSymbol(\n-    message: string, node?: ts.Node, context?: {[name: string]: string},\n-    sourceFile?: ts.SourceFile): MetadataError {\n-  const result: MetadataError = {__symbolic: 'error', message, ...sourceInfo(node, sourceFile)};\n-  if (context) {\n-    result.context = context;\n-  }\n-  return result;\n-}\n-\n-/**\n- * Produce a symbolic representation of an expression folding values into their final value when\n- * possible.\n- */\n-export class Evaluator {\n-  constructor(\n-      private symbols: Symbols, private nodeMap: Map<MetadataEntry, ts.Node>,\n-      private options: CollectorOptions = {},\n-      private recordExport?: (name: string, value: MetadataValue) => void) {}\n-\n-  nameOf(node: ts.Node|undefined): string|MetadataError {\n-    if (node && node.kind == ts.SyntaxKind.Identifier) {\n-      return (<ts.Identifier>node).text;\n-    }\n-    const result = node && this.evaluateNode(node);\n-    if (isMetadataError(result) || typeof result === 'string') {\n-      return result;\n-    } else {\n-      return errorSymbol(\n-          'Name expected', node, {received: (node && node.getText()) || '<missing>'});\n-    }\n-  }\n-\n-  /**\n-   * Returns true if the expression represented by `node` can be folded into a literal expression.\n-   *\n-   * For example, a literal is always foldable. This means that literal expressions such as `1.2`\n-   * `\"Some value\"` `true` `false` are foldable.\n-   *\n-   * - An object literal is foldable if all the properties in the literal are foldable.\n-   * - An array literal is foldable if all the elements are foldable.\n-   * - A call is foldable if it is a call to a Array.prototype.concat or a call to CONST_EXPR.\n-   * - A property access is foldable if the object is foldable.\n-   * - A array index is foldable if index expression is foldable and the array is foldable.\n-   * - Binary operator expressions are foldable if the left and right expressions are foldable and\n-   *   it is one of '+', '-', '*', '/', '%', '||', and '&&'.\n-   * - An identifier is foldable if a value can be found for its symbol in the evaluator symbol\n-   *   table.\n-   */\n-  public isFoldable(node: ts.Node): boolean {\n-    return this.isFoldableWorker(node, new Map<ts.Node, boolean>());\n-  }\n-\n-  private isFoldableWorker(node: ts.Node|undefined, folding: Map<ts.Node, boolean>): boolean {\n-    if (node) {\n-      switch (node.kind) {\n-        case ts.SyntaxKind.ObjectLiteralExpression:\n-          return everyNodeChild(node, child => {\n-            if (child.kind === ts.SyntaxKind.PropertyAssignment) {\n-              const propertyAssignment = <ts.PropertyAssignment>child;\n-              return this.isFoldableWorker(propertyAssignment.initializer, folding);\n-            }\n-            return false;\n-          });\n-        case ts.SyntaxKind.ArrayLiteralExpression:\n-          return everyNodeChild(node, child => this.isFoldableWorker(child, folding));\n-        case ts.SyntaxKind.CallExpression:\n-          const callExpression = <ts.CallExpression>node;\n-          // We can fold a <array>.concat(<v>).\n-          if (isMethodCallOf(callExpression, 'concat') &&\n-              arrayOrEmpty(callExpression.arguments).length === 1) {\n-            const arrayNode = (<ts.PropertyAccessExpression>callExpression.expression).expression;\n-            if (this.isFoldableWorker(arrayNode, folding) &&\n-                this.isFoldableWorker(callExpression.arguments[0], folding)) {\n-              // It needs to be an array.\n-              const arrayValue = this.evaluateNode(arrayNode);\n-              if (arrayValue && Array.isArray(arrayValue)) {\n-                return true;\n-              }\n-            }\n-          }\n-\n-          // We can fold a call to CONST_EXPR\n-          if (isCallOf(callExpression, 'CONST_EXPR') &&\n-              arrayOrEmpty(callExpression.arguments).length === 1)\n-            return this.isFoldableWorker(callExpression.arguments[0], folding);\n-          return false;\n-        case ts.SyntaxKind.NoSubstitutionTemplateLiteral:\n-        case ts.SyntaxKind.StringLiteral:\n-        case ts.SyntaxKind.NumericLiteral:\n-        case ts.SyntaxKind.NullKeyword:\n-        case ts.SyntaxKind.TrueKeyword:\n-        case ts.SyntaxKind.FalseKeyword:\n-        case ts.SyntaxKind.TemplateHead:\n-        case ts.SyntaxKind.TemplateMiddle:\n-        case ts.SyntaxKind.TemplateTail:\n-          return true;\n-        case ts.SyntaxKind.ParenthesizedExpression:\n-          const parenthesizedExpression = <ts.ParenthesizedExpression>node;\n-          return this.isFoldableWorker(parenthesizedExpression.expression, folding);\n-        case ts.SyntaxKind.BinaryExpression:\n-          const binaryExpression = <ts.BinaryExpression>node;\n-          switch (binaryExpression.operatorToken.kind) {\n-            case ts.SyntaxKind.PlusToken:\n-            case ts.SyntaxKind.MinusToken:\n-            case ts.SyntaxKind.AsteriskToken:\n-            case ts.SyntaxKind.SlashToken:\n-            case ts.SyntaxKind.PercentToken:\n-            case ts.SyntaxKind.AmpersandAmpersandToken:\n-            case ts.SyntaxKind.BarBarToken:\n-              return this.isFoldableWorker(binaryExpression.left, folding) &&\n-                  this.isFoldableWorker(binaryExpression.right, folding);\n-            default:\n-              return false;\n-          }\n-        case ts.SyntaxKind.PropertyAccessExpression:\n-          const propertyAccessExpression = <ts.PropertyAccessExpression>node;\n-          return this.isFoldableWorker(propertyAccessExpression.expression, folding);\n-        case ts.SyntaxKind.ElementAccessExpression:\n-          const elementAccessExpression = <ts.ElementAccessExpression>node;\n-          return this.isFoldableWorker(elementAccessExpression.expression, folding) &&\n-              this.isFoldableWorker(elementAccessExpression.argumentExpression, folding);\n-        case ts.SyntaxKind.Identifier:\n-          let identifier = <ts.Identifier>node;\n-          let reference = this.symbols.resolve(identifier.text);\n-          if (reference !== undefined && isPrimitive(reference)) {\n-            return true;\n-          }\n-          break;\n-        case ts.SyntaxKind.TemplateExpression:\n-          const templateExpression = <ts.TemplateExpression>node;\n-          return templateExpression.templateSpans.every(\n-              span => this.isFoldableWorker(span.expression, folding));\n-      }\n-    }\n-    return false;\n-  }\n-\n-  /**\n-   * Produce a JSON serialiable object representing `node`. The foldable values in the expression\n-   * tree are folded. For example, a node representing `1 + 2` is folded into `3`.\n-   */\n-  public evaluateNode(node: ts.Node, preferReference?: boolean): MetadataValue {\n-    const t = this;\n-    let error: MetadataError|undefined;\n-\n-    function recordEntry(entry: MetadataValue, node: ts.Node): MetadataValue {\n-      if (t.options.substituteExpression) {\n-        const newEntry = t.options.substituteExpression(entry, node);\n-        if (t.recordExport && newEntry != entry && isMetadataGlobalReferenceExpression(newEntry)) {\n-          t.recordExport(newEntry.name, entry);\n-        }\n-        entry = newEntry;\n-      }\n-      return recordMapEntry(entry, node, t.nodeMap);\n-    }\n-\n-    function isFoldableError(value: any): value is MetadataError {\n-      return !t.options.verboseInvalidExpression && isMetadataError(value);\n-    }\n-\n-    const resolveName = (name: string, preferReference?: boolean): MetadataValue => {\n-      const reference = this.symbols.resolve(name, preferReference);\n-      if (reference === undefined) {\n-        // Encode as a global reference. StaticReflector will check the reference.\n-        return recordEntry({__symbolic: 'reference', name}, node);\n-      }\n-      if (reference && isMetadataSymbolicReferenceExpression(reference)) {\n-        return recordEntry({...reference}, node);\n-      }\n-      return reference;\n-    };\n-\n-    switch (node.kind) {\n-      case ts.SyntaxKind.ObjectLiteralExpression:\n-        let obj: {[name: string]: any} = {};\n-        let quoted: string[] = [];\n-        ts.forEachChild(node, child => {\n-          switch (child.kind) {\n-            case ts.SyntaxKind.ShorthandPropertyAssignment:\n-            case ts.SyntaxKind.PropertyAssignment:\n-              const assignment = <ts.PropertyAssignment|ts.ShorthandPropertyAssignment>child;\n-              if (assignment.name.kind == ts.SyntaxKind.StringLiteral) {\n-                const name = (assignment.name as ts.StringLiteral).text;\n-                quoted.push(name);\n-              }\n-              const propertyName = this.nameOf(assignment.name);\n-              if (isFoldableError(propertyName)) {\n-                error = propertyName;\n-                return true;\n-              }\n-              const propertyValue = isPropertyAssignment(assignment) ?\n-                  this.evaluateNode(assignment.initializer, /* preferReference */ true) :\n-                  resolveName(propertyName, /* preferReference */ true);\n-              if (isFoldableError(propertyValue)) {\n-                error = propertyValue;\n-                return true;  // Stop the forEachChild.\n-              } else {\n-                obj[propertyName] = isPropertyAssignment(assignment) ?\n-                    recordEntry(propertyValue, assignment.initializer) :\n-                    propertyValue;\n-              }\n-          }\n-        });\n-        if (error) return error;\n-        if (this.options.quotedNames && quoted.length) {\n-          obj['$quoted$'] = quoted;\n-        }\n-        return recordEntry(obj, node);\n-      case ts.SyntaxKind.ArrayLiteralExpression:\n-        let arr: MetadataValue[] = [];\n-        ts.forEachChild(node, child => {\n-          const value = this.evaluateNode(child, /* preferReference */ true);\n-\n-          // Check for error\n-          if (isFoldableError(value)) {\n-            error = value;\n-            return true;  // Stop the forEachChild.\n-          }\n-\n-          // Handle spread expressions\n-          if (isMetadataSymbolicSpreadExpression(value)) {\n-            if (Array.isArray(value.expression)) {\n-              for (const spreadValue of value.expression) {\n-                arr.push(spreadValue);\n-              }\n-              return;\n-            }\n-          }\n-\n-          arr.push(value);\n-        });\n-        if (error) return error;\n-        return recordEntry(arr, node);\n-      case spreadElementSyntaxKind:\n-        let spreadExpression = this.evaluateNode((node as any).expression);\n-        return recordEntry({__symbolic: 'spread', expression: spreadExpression}, node);\n-      case ts.SyntaxKind.CallExpression:\n-        const callExpression = <ts.CallExpression>node;\n-        if (isCallOf(callExpression, 'forwardRef') &&\n-            arrayOrEmpty(callExpression.arguments).length === 1) {\n-          const firstArgument = callExpression.arguments[0];\n-          if (firstArgument.kind == ts.SyntaxKind.ArrowFunction) {\n-            const arrowFunction = <ts.ArrowFunction>firstArgument;\n-            return recordEntry(this.evaluateNode(arrowFunction.body), node);\n-          }\n-        }\n-        const args = arrayOrEmpty(callExpression.arguments).map(arg => this.evaluateNode(arg));\n-        if (this.isFoldable(callExpression)) {\n-          if (isMethodCallOf(callExpression, 'concat')) {\n-            const arrayValue = <MetadataValue[]>this.evaluateNode(\n-                (<ts.PropertyAccessExpression>callExpression.expression).expression);\n-            if (isFoldableError(arrayValue)) return arrayValue;\n-            return arrayValue.concat(args[0]);\n-          }\n-        }\n-        // Always fold a CONST_EXPR even if the argument is not foldable.\n-        if (isCallOf(callExpression, 'CONST_EXPR') &&\n-            arrayOrEmpty(callExpression.arguments).length === 1) {\n-          return recordEntry(args[0], node);\n-        }\n-        const expression = this.evaluateNode(callExpression.expression);\n-        if (isFoldableError(expression)) {\n-          return recordEntry(expression, node);\n-        }\n-        let result: MetadataSymbolicCallExpression = {__symbolic: 'call', expression: expression};\n-        if (args && args.length) {\n-          result.arguments = args;\n-        }\n-        return recordEntry(result, node);\n-      case ts.SyntaxKind.NewExpression:\n-        const newExpression = <ts.NewExpression>node;\n-        const newArgs = arrayOrEmpty(newExpression.arguments).map(arg => this.evaluateNode(arg));\n-        const newTarget = this.evaluateNode(newExpression.expression);\n-        if (isMetadataError(newTarget)) {\n-          return recordEntry(newTarget, node);\n-        }\n-        const call: MetadataSymbolicCallExpression = {__symbolic: 'new', expression: newTarget};\n-        if (newArgs.length) {\n-          call.arguments = newArgs;\n-        }\n-        return recordEntry(call, node);\n-      case ts.SyntaxKind.PropertyAccessExpression: {\n-        const propertyAccessExpression = <ts.PropertyAccessExpression>node;\n-        const expression = this.evaluateNode(propertyAccessExpression.expression);\n-        if (isFoldableError(expression)) {\n-          return recordEntry(expression, node);\n-        }\n-        const member = this.nameOf(propertyAccessExpression.name);\n-        if (isFoldableError(member)) {\n-          return recordEntry(member, node);\n-        }\n-        if (expression && this.isFoldable(propertyAccessExpression.expression))\n-          return (<any>expression)[member];\n-        if (isMetadataModuleReferenceExpression(expression)) {\n-          // A select into a module reference and be converted into a reference to the symbol\n-          // in the module\n-          return recordEntry(\n-              {__symbolic: 'reference', module: expression.module, name: member}, node);\n-        }\n-        return recordEntry({__symbolic: 'select', expression, member}, node);\n-      }\n-      case ts.SyntaxKind.ElementAccessExpression: {\n-        const elementAccessExpression = <ts.ElementAccessExpression>node;\n-        const expression = this.evaluateNode(elementAccessExpression.expression);\n-        if (isFoldableError(expression)) {\n-          return recordEntry(expression, node);\n-        }\n-        if (!elementAccessExpression.argumentExpression) {\n-          return recordEntry(errorSymbol('Expression form not supported', node), node);\n-        }\n-        const index = this.evaluateNode(elementAccessExpression.argumentExpression);\n-        if (isFoldableError(expression)) {\n-          return recordEntry(expression, node);\n-        }\n-        if (this.isFoldable(elementAccessExpression.expression) &&\n-            this.isFoldable(elementAccessExpression.argumentExpression))\n-          return (<any>expression)[<string|number>index];\n-        return recordEntry({__symbolic: 'index', expression, index}, node);\n-      }\n-      case ts.SyntaxKind.Identifier:\n-        const identifier = <ts.Identifier>node;\n-        const name = identifier.text;\n-        return resolveName(name, preferReference);\n-      case ts.SyntaxKind.TypeReference:\n-        const typeReferenceNode = <ts.TypeReferenceNode>node;\n-        const typeNameNode = typeReferenceNode.typeName;\n-        const getReference: (typeNameNode: ts.Identifier|ts.QualifiedName) => MetadataValue =\n-            node => {\n-              if (typeNameNode.kind === ts.SyntaxKind.QualifiedName) {\n-                const qualifiedName = <ts.QualifiedName>node;\n-                const left = this.evaluateNode(qualifiedName.left);\n-                if (isMetadataModuleReferenceExpression(left)) {\n-                  return recordEntry(\n-                      <MetadataImportedSymbolReferenceExpression>{\n-                        __symbolic: 'reference',\n-                        module: left.module,\n-                        name: qualifiedName.right.text\n-                      },\n-                      node);\n-                }\n-                // Record a type reference to a declared type as a select.\n-                return {__symbolic: 'select', expression: left, member: qualifiedName.right.text};\n-              } else {\n-                const identifier = <ts.Identifier>typeNameNode;\n-                const symbol = this.symbols.resolve(identifier.text);\n-                if (isFoldableError(symbol) || isMetadataSymbolicReferenceExpression(symbol)) {\n-                  return recordEntry(symbol, node);\n-                }\n-                return recordEntry(\n-                    errorSymbol('Could not resolve type', node, {typeName: identifier.text}), node);\n-              }\n-            };\n-        const typeReference = getReference(typeNameNode);\n-        if (isFoldableError(typeReference)) {\n-          return recordEntry(typeReference, node);\n-        }\n-        if (!isMetadataModuleReferenceExpression(typeReference) &&\n-            typeReferenceNode.typeArguments && typeReferenceNode.typeArguments.length) {\n-          const args = typeReferenceNode.typeArguments.map(element => this.evaluateNode(element));\n-          // TODO: Remove typecast when upgraded to 2.0 as it will be correctly inferred.\n-          // Some versions of 1.9 do not infer this correctly.\n-          (<MetadataImportedSymbolReferenceExpression>typeReference).arguments = args;\n-        }\n-        return recordEntry(typeReference, node);\n-      case ts.SyntaxKind.UnionType:\n-        const unionType = <ts.UnionTypeNode>node;\n-        // Remove null and undefined from the list of unions.\n-        const references =\n-            unionType.types\n-                .filter(\n-                    n => n.kind !== ts.SyntaxKind.UndefinedKeyword &&\n-                        !(ts.isLiteralTypeNode(n) && n.literal.kind === ts.SyntaxKind.NullKeyword))\n-                .map(n => this.evaluateNode(n));\n-\n-        // The remmaining reference must be the same. If two have type arguments consider them\n-        // different even if the type arguments are the same.\n-        let candidate: any = null;\n-        for (let i = 0; i < references.length; i++) {\n-          const reference = references[i];\n-          if (isMetadataSymbolicReferenceExpression(reference)) {\n-            if (candidate) {\n-              if ((reference as any).name == candidate.name &&\n-                  (reference as any).module == candidate.module && !(reference as any).arguments) {\n-                candidate = reference;\n-              }\n-            } else {\n-              candidate = reference;\n-            }\n-          } else {\n-            return reference;\n-          }\n-        }\n-        if (candidate) return candidate;\n-        break;\n-      case ts.SyntaxKind.NoSubstitutionTemplateLiteral:\n-      case ts.SyntaxKind.StringLiteral:\n-      case ts.SyntaxKind.TemplateHead:\n-      case ts.SyntaxKind.TemplateTail:\n-      case ts.SyntaxKind.TemplateMiddle:\n-        return (<ts.LiteralLikeNode>node).text;\n-      case ts.SyntaxKind.NumericLiteral:\n-        return parseFloat((<ts.LiteralExpression>node).text);\n-      case ts.SyntaxKind.AnyKeyword:\n-        return recordEntry({__symbolic: 'reference', name: 'any'}, node);\n-      case ts.SyntaxKind.StringKeyword:\n-        return recordEntry({__symbolic: 'reference', name: 'string'}, node);\n-      case ts.SyntaxKind.NumberKeyword:\n-        return recordEntry({__symbolic: 'reference', name: 'number'}, node);\n-      case ts.SyntaxKind.BooleanKeyword:\n-        return recordEntry({__symbolic: 'reference', name: 'boolean'}, node);\n-      case ts.SyntaxKind.ArrayType:\n-        const arrayTypeNode = <ts.ArrayTypeNode>node;\n-        return recordEntry(\n-            {\n-              __symbolic: 'reference',\n-              name: 'Array',\n-              arguments: [this.evaluateNode(arrayTypeNode.elementType)]\n-            },\n-            node);\n-      case ts.SyntaxKind.NullKeyword:\n-        return null;\n-      case ts.SyntaxKind.TrueKeyword:\n-        return true;\n-      case ts.SyntaxKind.FalseKeyword:\n-        return false;\n-      case ts.SyntaxKind.ParenthesizedExpression:\n-        const parenthesizedExpression = <ts.ParenthesizedExpression>node;\n-        return this.evaluateNode(parenthesizedExpression.expression);\n-      case ts.SyntaxKind.TypeAssertionExpression:\n-        const typeAssertion = <ts.TypeAssertion>node;\n-        return this.evaluateNode(typeAssertion.expression);\n-      case ts.SyntaxKind.PrefixUnaryExpression:\n-        const prefixUnaryExpression = <ts.PrefixUnaryExpression>node;\n-        const operand = this.evaluateNode(prefixUnaryExpression.operand);\n-        if (isDefined(operand) && isPrimitive(operand)) {\n-          switch (prefixUnaryExpression.operator) {\n-            case ts.SyntaxKind.PlusToken:\n-              return +(operand as any);\n-            case ts.SyntaxKind.MinusToken:\n-              return -(operand as any);\n-            case ts.SyntaxKind.TildeToken:\n-              return ~(operand as any);\n-            case ts.SyntaxKind.ExclamationToken:\n-              return !operand;\n-          }\n-        }\n-        let operatorText: '+'|'-'|'~'|'!';\n-        switch (prefixUnaryExpression.operator) {\n-          case ts.SyntaxKind.PlusToken:\n-            operatorText = '+';\n-            break;\n-          case ts.SyntaxKind.MinusToken:\n-            operatorText = '-';\n-            break;\n-          case ts.SyntaxKind.TildeToken:\n-            operatorText = '~';\n-            break;\n-          case ts.SyntaxKind.ExclamationToken:\n-            operatorText = '!';\n-            break;\n-          default:\n-            return undefined;\n-        }\n-        return recordEntry({__symbolic: 'pre', operator: operatorText, operand: operand}, node);\n-      case ts.SyntaxKind.BinaryExpression:\n-        const binaryExpression = <ts.BinaryExpression>node;\n-        const left = this.evaluateNode(binaryExpression.left);\n-        const right = this.evaluateNode(binaryExpression.right);\n-        if (isDefined(left) && isDefined(right)) {\n-          if (isPrimitive(left) && isPrimitive(right))\n-            switch (binaryExpression.operatorToken.kind) {\n-              case ts.SyntaxKind.BarBarToken:\n-                return <any>left || <any>right;\n-              case ts.SyntaxKind.AmpersandAmpersandToken:\n-                return <any>left && <any>right;\n-              case ts.SyntaxKind.AmpersandToken:\n-                return <any>left & <any>right;\n-              case ts.SyntaxKind.BarToken:\n-                return <any>left | <any>right;\n-              case ts.SyntaxKind.CaretToken:\n-                return <any>left ^ <any>right;\n-              case ts.SyntaxKind.EqualsEqualsToken:\n-                return <any>left == <any>right;\n-              case ts.SyntaxKind.ExclamationEqualsToken:\n-                return <any>left != <any>right;\n-              case ts.SyntaxKind.EqualsEqualsEqualsToken:\n-                return <any>left === <any>right;\n-              case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n-                return <any>left !== <any>right;\n-              case ts.SyntaxKind.LessThanToken:\n-                return <any>left < <any>right;\n-              case ts.SyntaxKind.GreaterThanToken:\n-                return <any>left > <any>right;\n-              case ts.SyntaxKind.LessThanEqualsToken:\n-                return <any>left <= <any>right;\n-              case ts.SyntaxKind.GreaterThanEqualsToken:\n-                return <any>left >= <any>right;\n-              case ts.SyntaxKind.LessThanLessThanToken:\n-                return (<any>left) << (<any>right);\n-              case ts.SyntaxKind.GreaterThanGreaterThanToken:\n-                return <any>left >> <any>right;\n-              case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:\n-                return <any>left >>> <any>right;\n-              case ts.SyntaxKind.PlusToken:\n-                return <any>left + <any>right;\n-              case ts.SyntaxKind.MinusToken:\n-                return <any>left - <any>right;\n-              case ts.SyntaxKind.AsteriskToken:\n-                return <any>left * <any>right;\n-              case ts.SyntaxKind.SlashToken:\n-                return <any>left / <any>right;\n-              case ts.SyntaxKind.PercentToken:\n-                return <any>left % <any>right;\n-            }\n-          return recordEntry(\n-              {\n-                __symbolic: 'binop',\n-                operator: binaryExpression.operatorToken.getText(),\n-                left: left,\n-                right: right\n-              },\n-              node);\n-        }\n-        break;\n-      case ts.SyntaxKind.ConditionalExpression:\n-        const conditionalExpression = <ts.ConditionalExpression>node;\n-        const condition = this.evaluateNode(conditionalExpression.condition);\n-        const thenExpression = this.evaluateNode(conditionalExpression.whenTrue);\n-        const elseExpression = this.evaluateNode(conditionalExpression.whenFalse);\n-        if (isPrimitive(condition)) {\n-          return condition ? thenExpression : elseExpression;\n-        }\n-        return recordEntry({__symbolic: 'if', condition, thenExpression, elseExpression}, node);\n-      case ts.SyntaxKind.FunctionExpression:\n-      case ts.SyntaxKind.ArrowFunction:\n-        return recordEntry(errorSymbol('Lambda not supported', node), node);\n-      case ts.SyntaxKind.TaggedTemplateExpression:\n-        return recordEntry(\n-            errorSymbol('Tagged template expressions are not supported in metadata', node), node);\n-      case ts.SyntaxKind.TemplateExpression:\n-        const templateExpression = <ts.TemplateExpression>node;\n-        if (this.isFoldable(node)) {\n-          return templateExpression.templateSpans.reduce(\n-              (previous, current) => previous + <string>this.evaluateNode(current.expression) +\n-                  <string>this.evaluateNode(current.literal),\n-              this.evaluateNode(templateExpression.head));\n-        } else {\n-          return templateExpression.templateSpans.reduce((previous, current) => {\n-            const expr = this.evaluateNode(current.expression);\n-            const literal = this.evaluateNode(current.literal);\n-            if (isFoldableError(expr)) return expr;\n-            if (isFoldableError(literal)) return literal;\n-            if (typeof previous === 'string' && typeof expr === 'string' &&\n-                typeof literal === 'string') {\n-              return previous + expr + literal;\n-            }\n-            let result = expr;\n-            if (previous !== '') {\n-              result = {__symbolic: 'binop', operator: '+', left: previous, right: expr};\n-            }\n-            if (literal != '') {\n-              result = {__symbolic: 'binop', operator: '+', left: result, right: literal};\n-            }\n-            return result;\n-          }, this.evaluateNode(templateExpression.head));\n-        }\n-      case ts.SyntaxKind.AsExpression:\n-        const asExpression = <ts.AsExpression>node;\n-        return this.evaluateNode(asExpression.expression);\n-      case ts.SyntaxKind.ClassExpression:\n-        return {__symbolic: 'class'};\n-    }\n-    return recordEntry(errorSymbol('Expression form not supported', node), node);\n-  }\n-}\n-\n-function isPropertyAssignment(node: ts.Node): node is ts.PropertyAssignment {\n-  return node.kind == ts.SyntaxKind.PropertyAssignment;\n-}\n-\n-const empty = ts.createNodeArray<any>();\n-\n-function arrayOrEmpty<T extends ts.Node>(v: ts.NodeArray<T>|undefined): ts.NodeArray<T> {\n-  return v || empty;\n-}"
        },
        {
            "sha": "58eb3e7161cf27920b833e173f69dd6dfa639502",
            "filename": "packages/compiler-cli/src/metadata/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 11,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Findex.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,11 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-export * from './collector';\n-export * from './schema';\n-export * from './bundle_index_host';"
        },
        {
            "sha": "e845b719639e9e6c50bc08dff0dd2aa073239b95",
            "filename": "packages/compiler-cli/src/metadata/index_writer.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 58,
            "changes": 58,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Findex_writer.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Findex_writer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Findex_writer.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,58 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {BundlePrivateEntry} from './bundler';\n-\n-const INDEX_HEADER = `/**\n- * Generated bundle index. Do not edit.\n- */\n-`;\n-\n-type MapEntry = [string, BundlePrivateEntry[]];\n-\n-export function privateEntriesToIndex(index: string, privates: BundlePrivateEntry[]): string {\n-  const results: string[] = [INDEX_HEADER];\n-\n-  // Export all of the index symbols.\n-  results.push(`export * from '${index}';`, '');\n-\n-  // Simplify the exports\n-  const exports = new Map<string, BundlePrivateEntry[]>();\n-\n-  for (const entry of privates) {\n-    let entries = exports.get(entry.module);\n-    if (!entries) {\n-      entries = [];\n-      exports.set(entry.module, entries);\n-    }\n-    entries.push(entry);\n-  }\n-\n-\n-  const compareEntries = compare((e: BundlePrivateEntry) => e.name);\n-  const compareModules = compare((e: MapEntry) => e[0]);\n-  const orderedExports =\n-      Array.from(exports)\n-          .map(([module, entries]) => <MapEntry>[module, entries.sort(compareEntries)])\n-          .sort(compareModules);\n-\n-  for (const [module, entries] of orderedExports) {\n-    let symbols = entries.map(e => `${e.name} as ${e.privateName}`);\n-    results.push(`export {${symbols}} from '${module}';`);\n-  }\n-\n-  return results.join('\\n');\n-}\n-\n-function compare<E, T>(select: (e: E) => T): (a: E, b: E) => number {\n-  return (a, b) => {\n-    const ak = select(a);\n-    const bk = select(b);\n-    return ak > bk ? 1 : ak < bk ? -1 : 0;\n-  };\n-}"
        },
        {
            "sha": "c6413da7a7fe163818a71b0c3ee95dfc619f8c5a",
            "filename": "packages/compiler-cli/src/metadata/schema.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 303,
            "changes": 303,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Fschema.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Fschema.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Fschema.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,303 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-// Metadata Schema\n-\n-// If you make a backwards incompatible change to the schema, increment the METADTA_VERSION number.\n-\n-// If you make a backwards compatible change to the metadata (such as adding an option field) then\n-// leave METADATA_VERSION the same. If possible, supply as many versions of the metadata that can\n-// represent the semantics of the file in an array. For example, when generating a version 2 file,\n-// if version 1 can accurately represent the metadata, generate both version 1 and version 2 in\n-// an array.\n-\n-export const METADATA_VERSION = 4;\n-\n-export type MetadataEntry = ClassMetadata|InterfaceMetadata|FunctionMetadata|MetadataValue;\n-\n-export interface ModuleMetadata {\n-  __symbolic: 'module';\n-  version: number;\n-  exports?: ModuleExportMetadata[];\n-  importAs?: string;\n-  metadata: {[name: string]: MetadataEntry};\n-  origins?: {[name: string]: string};\n-}\n-export function isModuleMetadata(value: any): value is ModuleMetadata {\n-  return value && value.__symbolic === 'module';\n-}\n-\n-export interface ModuleExportMetadata {\n-  export?: (string|{name: string, as: string})[];\n-  from: string;\n-}\n-\n-export interface ClassMetadata {\n-  __symbolic: 'class';\n-  extends?: MetadataSymbolicExpression|MetadataError;\n-  arity?: number;\n-  decorators?: (MetadataSymbolicExpression|MetadataError)[];\n-  members?: MetadataMap;\n-  statics?: {[name: string]: MetadataValue|FunctionMetadata};\n-}\n-export function isClassMetadata(value: any): value is ClassMetadata {\n-  return value && value.__symbolic === 'class';\n-}\n-\n-export interface InterfaceMetadata {\n-  __symbolic: 'interface';\n-}\n-export function isInterfaceMetadata(value: any): value is InterfaceMetadata {\n-  return value && value.__symbolic === 'interface';\n-}\n-\n-export interface MetadataMap {\n-  [name: string]: MemberMetadata[];\n-}\n-\n-export interface MemberMetadata {\n-  __symbolic: 'constructor'|'method'|'property';\n-  decorators?: (MetadataSymbolicExpression|MetadataError)[];\n-  parameters?: (MetadataSymbolicExpression|MetadataError|null|undefined)[];\n-}\n-export function isMemberMetadata(value: any): value is MemberMetadata {\n-  if (value) {\n-    switch (value.__symbolic) {\n-      case 'constructor':\n-      case 'method':\n-      case 'property':\n-        return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-export interface MethodMetadata extends MemberMetadata {\n-  __symbolic: 'constructor'|'method';\n-  parameterDecorators?: ((MetadataSymbolicExpression | MetadataError)[]|undefined)[];\n-}\n-export function isMethodMetadata(value: any): value is MethodMetadata {\n-  return value && (value.__symbolic === 'constructor' || value.__symbolic === 'method');\n-}\n-\n-export interface ConstructorMetadata extends MethodMetadata {\n-  __symbolic: 'constructor';\n-  parameters?: (MetadataSymbolicExpression|MetadataError|null|undefined)[];\n-}\n-export function isConstructorMetadata(value: any): value is ConstructorMetadata {\n-  return value && value.__symbolic === 'constructor';\n-}\n-\n-export interface FunctionMetadata {\n-  __symbolic: 'function';\n-  parameters: string[];\n-  defaults?: MetadataValue[];\n-  value: MetadataValue;\n-}\n-export function isFunctionMetadata(value: any): value is FunctionMetadata {\n-  return value && value.__symbolic === 'function';\n-}\n-\n-export type MetadataValue = string|number|boolean|undefined|null|MetadataObject|MetadataArray|\n-    MetadataSymbolicExpression|MetadataSymbolicReferenceExpression|MetadataSymbolicBinaryExpression|\n-    MetadataSymbolicIndexExpression|MetadataSymbolicCallExpression|MetadataSymbolicPrefixExpression|\n-    MetadataSymbolicIfExpression|MetadataSymbolicSpreadExpression|MetadataSymbolicSelectExpression|\n-    MetadataError;\n-\n-export interface MetadataObject {\n-  [name: string]: MetadataValue;\n-}\n-\n-export interface MetadataArray {\n-  [name: number]: MetadataValue;\n-}\n-\n-export type MetadataSymbolicExpression = MetadataSymbolicBinaryExpression|\n-    MetadataSymbolicIndexExpression|MetadataSymbolicIndexExpression|MetadataSymbolicCallExpression|\n-    MetadataSymbolicCallExpression|MetadataSymbolicPrefixExpression|MetadataSymbolicIfExpression|\n-    MetadataGlobalReferenceExpression|MetadataModuleReferenceExpression|\n-    MetadataImportedSymbolReferenceExpression|MetadataImportedDefaultReferenceExpression|\n-    MetadataSymbolicSelectExpression|MetadataSymbolicSpreadExpression;\n-\n-export function isMetadataSymbolicExpression(value: any): value is MetadataSymbolicExpression {\n-  if (value) {\n-    switch (value.__symbolic) {\n-      case 'binary':\n-      case 'call':\n-      case 'index':\n-      case 'new':\n-      case 'pre':\n-      case 'reference':\n-      case 'select':\n-      case 'spread':\n-      case 'if':\n-        return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-export interface MetadataSymbolicBinaryExpression {\n-  __symbolic: 'binary';\n-  operator: '&&'|'||'|'|'|'^'|'&'|'=='|'!='|'==='|'!=='|'<'|'>'|'<='|'>='|'instanceof'|'in'|'as'|\n-      '<<'|'>>'|'>>>'|'+'|'-'|'*'|'/'|'%'|'**'|'??';\n-  left: MetadataValue;\n-  right: MetadataValue;\n-}\n-export function isMetadataSymbolicBinaryExpression(value: any):\n-    value is MetadataSymbolicBinaryExpression {\n-  return value && value.__symbolic === 'binary';\n-}\n-\n-export interface MetadataSymbolicIndexExpression {\n-  __symbolic: 'index';\n-  expression: MetadataValue;\n-  index: MetadataValue;\n-}\n-export function isMetadataSymbolicIndexExpression(value: any):\n-    value is MetadataSymbolicIndexExpression {\n-  return value && value.__symbolic === 'index';\n-}\n-\n-export interface MetadataSymbolicCallExpression {\n-  __symbolic: 'call'|'new';\n-  expression: MetadataValue;\n-  arguments?: MetadataValue[];\n-}\n-export function isMetadataSymbolicCallExpression(value: any):\n-    value is MetadataSymbolicCallExpression {\n-  return value && (value.__symbolic === 'call' || value.__symbolic === 'new');\n-}\n-\n-export interface MetadataSymbolicPrefixExpression {\n-  __symbolic: 'pre';\n-  operator: '+'|'-'|'~'|'!';\n-  operand: MetadataValue;\n-}\n-export function isMetadataSymbolicPrefixExpression(value: any):\n-    value is MetadataSymbolicPrefixExpression {\n-  return value && value.__symbolic === 'pre';\n-}\n-\n-export interface MetadataSymbolicIfExpression {\n-  __symbolic: 'if';\n-  condition: MetadataValue;\n-  thenExpression: MetadataValue;\n-  elseExpression: MetadataValue;\n-}\n-export function isMetadataSymbolicIfExpression(value: any): value is MetadataSymbolicIfExpression {\n-  return value && value.__symbolic === 'if';\n-}\n-\n-export interface MetadataSourceLocationInfo {\n-  /**\n-   * The line number of the error in the .ts file the metadata was created for.\n-   */\n-  line?: number;\n-\n-  /**\n-   * The number of utf8 code-units from the beginning of the file of the error.\n-   */\n-  character?: number;\n-}\n-\n-export interface MetadataGlobalReferenceExpression extends MetadataSourceLocationInfo {\n-  __symbolic: 'reference';\n-  name: string;\n-  arguments?: MetadataValue[];\n-}\n-export function isMetadataGlobalReferenceExpression(value: any):\n-    value is MetadataGlobalReferenceExpression {\n-  return value && value.name && !value.module && isMetadataSymbolicReferenceExpression(value);\n-}\n-\n-export interface MetadataModuleReferenceExpression extends MetadataSourceLocationInfo {\n-  __symbolic: 'reference';\n-  module: string;\n-}\n-export function isMetadataModuleReferenceExpression(value: any):\n-    value is MetadataModuleReferenceExpression {\n-  return value && value.module && !value.name && !value.default &&\n-      isMetadataSymbolicReferenceExpression(value);\n-}\n-\n-export interface MetadataImportedSymbolReferenceExpression extends MetadataSourceLocationInfo {\n-  __symbolic: 'reference';\n-  module: string;\n-  name: string;\n-  arguments?: MetadataValue[];\n-}\n-export function isMetadataImportedSymbolReferenceExpression(value: any):\n-    value is MetadataImportedSymbolReferenceExpression {\n-  return value && value.module && !!value.name && isMetadataSymbolicReferenceExpression(value);\n-}\n-\n-export interface MetadataImportedDefaultReferenceExpression extends MetadataSourceLocationInfo {\n-  __symbolic: 'reference';\n-  module: string;\n-  default: boolean;\n-  arguments?: MetadataValue[];\n-}\n-export function isMetadataImportDefaultReference(value: any):\n-    value is MetadataImportedDefaultReferenceExpression {\n-  return value && value.module && value.default && isMetadataSymbolicReferenceExpression(value);\n-}\n-\n-export type MetadataSymbolicReferenceExpression =\n-    MetadataGlobalReferenceExpression|MetadataModuleReferenceExpression|\n-    MetadataImportedSymbolReferenceExpression|MetadataImportedDefaultReferenceExpression;\n-export function isMetadataSymbolicReferenceExpression(value: any):\n-    value is MetadataSymbolicReferenceExpression {\n-  return value && value.__symbolic === 'reference';\n-}\n-\n-export interface MetadataSymbolicSelectExpression {\n-  __symbolic: 'select';\n-  expression: MetadataValue;\n-  member: string;\n-}\n-export function isMetadataSymbolicSelectExpression(value: any):\n-    value is MetadataSymbolicSelectExpression {\n-  return value && value.__symbolic === 'select';\n-}\n-\n-export interface MetadataSymbolicSpreadExpression {\n-  __symbolic: 'spread';\n-  expression: MetadataValue;\n-}\n-export function isMetadataSymbolicSpreadExpression(value: any):\n-    value is MetadataSymbolicSpreadExpression {\n-  return value && value.__symbolic === 'spread';\n-}\n-\n-export interface MetadataError extends MetadataSourceLocationInfo {\n-  __symbolic: 'error';\n-\n-  /**\n-   * This message should be short and relatively discriptive and should be fixed once it is created.\n-   * If the reader doesn't recognize the message, it will display the message unmodified. If the\n-   * reader recognizes the error message is it free to use substitute message the is more\n-   * descriptive and/or localized.\n-   */\n-  message: string;\n-\n-  /**\n-   * The module of the error (only used in bundled metadata)\n-   */\n-  module?: string;\n-\n-  /**\n-   * Context information that can be used to generate a more descriptive error message. The content\n-   * of the context is dependent on the error message.\n-   */\n-  context?: {[name: string]: string};\n-}\n-\n-export function isMetadataError(value: any): value is MetadataError {\n-  return value && value.__symbolic === 'error';\n-}"
        },
        {
            "sha": "7d0589000816a31daa92c1ae6da26519ca19da81",
            "filename": "packages/compiler-cli/src/metadata/symbols.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 135,
            "changes": 135,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Fsymbols.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Fsymbols.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fmetadata%2Fsymbols.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,135 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {MetadataSymbolicReferenceExpression, MetadataValue} from './schema';\n-\n-export class Symbols {\n-  // TODO(issue/24571): remove '!'.\n-  private _symbols!: Map<string, MetadataValue>;\n-  private references = new Map<string, MetadataSymbolicReferenceExpression>();\n-\n-  constructor(private sourceFile: ts.SourceFile) {}\n-\n-  resolve(name: string, preferReference?: boolean): MetadataValue|undefined {\n-    return (preferReference && this.references.get(name)) || this.symbols.get(name);\n-  }\n-\n-  define(name: string, value: MetadataValue) {\n-    this.symbols.set(name, value);\n-  }\n-  defineReference(name: string, value: MetadataSymbolicReferenceExpression) {\n-    this.references.set(name, value);\n-  }\n-\n-  has(name: string): boolean {\n-    return this.symbols.has(name);\n-  }\n-\n-  private get symbols(): Map<string, MetadataValue> {\n-    let result = this._symbols;\n-    if (!result) {\n-      result = this._symbols = new Map<string, MetadataValue>();\n-      populateBuiltins(result);\n-      this.buildImports();\n-    }\n-    return result;\n-  }\n-\n-  private buildImports(): void {\n-    const symbols = this._symbols;\n-    // Collect the imported symbols into this.symbols\n-    const stripQuotes = (s: string) => s.replace(/^['\"]|['\"]$/g, '');\n-    const visit = (node: ts.Node) => {\n-      switch (node.kind) {\n-        case ts.SyntaxKind.ImportEqualsDeclaration:\n-          const importEqualsDeclaration = <ts.ImportEqualsDeclaration>node;\n-          if (importEqualsDeclaration.moduleReference.kind ===\n-              ts.SyntaxKind.ExternalModuleReference) {\n-            const externalReference =\n-                <ts.ExternalModuleReference>importEqualsDeclaration.moduleReference;\n-            if (externalReference.expression) {\n-              // An `import <identifier> = require(<module-specifier>);\n-              if (!externalReference.expression.parent) {\n-                // The `parent` field of a node is set by the TypeScript binder (run as\n-                // part of the type checker). Setting it here allows us to call `getText()`\n-                // even if the `SourceFile` was not type checked (which looks for `SourceFile`\n-                // in the parent chain). This doesn't damage the node as the binder unconditionally\n-                // sets the parent.\n-                (externalReference.expression.parent as ts.Node) = externalReference;\n-                (externalReference.parent as ts.Node) = this.sourceFile;\n-              }\n-              const from = stripQuotes(externalReference.expression.getText());\n-              symbols.set(\n-                  importEqualsDeclaration.name.text, {__symbolic: 'reference', module: from});\n-              break;\n-            }\n-          }\n-          symbols.set(\n-              importEqualsDeclaration.name.text,\n-              {__symbolic: 'error', message: `Unsupported import syntax`});\n-          break;\n-        case ts.SyntaxKind.ImportDeclaration:\n-          const importDecl = <ts.ImportDeclaration>node;\n-          if (!importDecl.importClause) {\n-            // An `import <module-specifier>` clause which does not bring symbols into scope.\n-            break;\n-          }\n-          if (!importDecl.moduleSpecifier.parent) {\n-            // See note above in the `ImportEqualDeclaration` case.\n-            (importDecl.moduleSpecifier.parent as ts.Node) = importDecl;\n-            (importDecl.parent as ts.Node) = this.sourceFile;\n-          }\n-          const from = stripQuotes(importDecl.moduleSpecifier.getText());\n-          if (importDecl.importClause.name) {\n-            // An `import <identifier> form <module-specifier>` clause. Record the default symbol.\n-            symbols.set(\n-                importDecl.importClause.name.text,\n-                {__symbolic: 'reference', module: from, default: true});\n-          }\n-          const bindings = importDecl.importClause.namedBindings;\n-          if (bindings) {\n-            switch (bindings.kind) {\n-              case ts.SyntaxKind.NamedImports:\n-                // An `import { [<identifier> [, <identifier>] } from <module-specifier>` clause\n-                for (const binding of (<ts.NamedImports>bindings).elements) {\n-                  symbols.set(binding.name.text, {\n-                    __symbolic: 'reference',\n-                    module: from,\n-                    name: binding.propertyName ? binding.propertyName.text : binding.name.text\n-                  });\n-                }\n-                break;\n-              case ts.SyntaxKind.NamespaceImport:\n-                // An `input * as <identifier> from <module-specifier>` clause.\n-                symbols.set(\n-                    (<ts.NamespaceImport>bindings).name.text,\n-                    {__symbolic: 'reference', module: from});\n-                break;\n-            }\n-          }\n-          break;\n-      }\n-      ts.forEachChild(node, visit);\n-    };\n-    if (this.sourceFile) {\n-      ts.forEachChild(this.sourceFile, visit);\n-    }\n-  }\n-}\n-\n-function populateBuiltins(symbols: Map<string, MetadataValue>) {\n-  // From lib.core.d.ts (all \"define const\")\n-  ['Object', 'Function', 'String', 'Number', 'Array', 'Boolean', 'Map', 'NaN', 'Infinity', 'Math',\n-   'Date', 'RegExp', 'Error', 'Error', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError',\n-   'TypeError', 'URIError', 'JSON', 'ArrayBuffer', 'DataView', 'Int8Array', 'Uint8Array',\n-   'Uint8ClampedArray', 'Uint16Array', 'Int16Array', 'Int32Array', 'Uint32Array', 'Float32Array',\n-   'Float64Array']\n-      .forEach(name => symbols.set(name, {__symbolic: 'reference', name}));\n-}"
        },
        {
            "sha": "f718309b3ce9217c0ab2a5a34bfcc3076132d7f7",
            "filename": "packages/compiler-cli/src/transformers/compiler_host.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 671,
            "changes": 672,
            "blob_url": "https://github.com/angular/angular/blob/192203278647bae1864db2a5109efaae1bba53c4/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fcompiler_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/192203278647bae1864db2a5109efaae1bba53c4/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fcompiler_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fcompiler_host.ts?ref=192203278647bae1864db2a5109efaae1bba53c4",
            "patch": "@@ -6,22 +6,9 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AotCompilerHost, collectExternalReferences, EmitterVisitorContext, GeneratedFile, ParseSourceSpan, syntaxError, TypeScriptEmitter} from '@angular/compiler';\n-import fs from 'fs';\n-import * as path from 'path';\n import ts from 'typescript';\n \n-import {TypeCheckHost} from '../diagnostics/translate_diagnostics';\n-import {ModuleMetadata} from '../metadata/index';\n-import {join} from '../ngtsc/file_system';\n-\n-import {CompilerHost, CompilerOptions, LibrarySummary} from './api';\n-import {createMetadataReaderCache, MetadataReaderHost, readMetadata} from './metadata_reader';\n-import {DTS, GENERATED_FILES, isInRootDir, relativeToRootDirs} from './util';\n-\n-const NODE_MODULES_PACKAGE_NAME = /node_modules\\/((\\w|-|\\.)+|(@(\\w|-|\\.)+\\/(\\w|-|\\.)+))/;\n-const EXT = /(\\.ts|\\.d\\.ts|\\.js|\\.jsx|\\.tsx)$/;\n-const CSS_PREPROCESSOR_EXT = /(\\.scss|\\.sass|\\.less|\\.styl)$/;\n+import {CompilerHost, CompilerOptions} from './api';\n \n let wrapHostForTest: ((host: ts.CompilerHost) => ts.CompilerHost)|null = null;\n \n@@ -38,660 +25,3 @@ export function createCompilerHost(\n   }\n   return tsHost;\n }\n-\n-export interface MetadataProvider {\n-  getMetadata(sourceFile: ts.SourceFile): ModuleMetadata|undefined;\n-}\n-\n-interface GenSourceFile {\n-  externalReferences: Set<string>;\n-  sourceFile: ts.SourceFile;\n-  emitCtx: EmitterVisitorContext;\n-}\n-\n-export interface CodeGenerator {\n-  generateFile(genFileName: string, baseFileName?: string): GeneratedFile;\n-  findGeneratedFileNames(fileName: string): string[];\n-}\n-\n-function assert<T>(condition: T|null|undefined) {\n-  if (!condition) {\n-    // TODO(chuckjaz): do the right thing\n-  }\n-  return condition!;\n-}\n-\n-/**\n- * Implements the following hosts based on an api.CompilerHost:\n- * - ts.CompilerHost to be consumed by a ts.Program\n- * - AotCompilerHost for @angular/compiler\n- * - TypeCheckHost for mapping ts errors to ng errors (via translateDiagnostics)\n- */\n-export class TsCompilerAotCompilerTypeCheckHostAdapter implements ts.CompilerHost, AotCompilerHost,\n-                                                                  TypeCheckHost {\n-  private metadataReaderCache = createMetadataReaderCache();\n-  private fileNameToModuleNameCache = new Map<string, string>();\n-  private flatModuleIndexCache = new Map<string, boolean>();\n-  private flatModuleIndexNames = new Set<string>();\n-  private flatModuleIndexRedirectNames = new Set<string>();\n-  private rootDirs: string[];\n-  private moduleResolutionCache: ts.ModuleResolutionCache;\n-  private originalSourceFiles = new Map<string, ts.SourceFile|null>();\n-  private originalFileExistsCache = new Map<string, boolean>();\n-  private generatedSourceFiles = new Map<string, GenSourceFile>();\n-  private generatedCodeFor = new Map<string, string[]>();\n-  private emitter = new TypeScriptEmitter();\n-  private metadataReaderHost: MetadataReaderHost;\n-\n-  // TODO(issue/24571): remove '!'.\n-  getCancellationToken!: () => ts.CancellationToken;\n-  // TODO(issue/24571): remove '!'.\n-  getDefaultLibLocation!: () => string;\n-  // TODO(issue/24571): remove '!'.\n-  trace!: (s: string) => void;\n-  // TODO(issue/24571): remove '!'.\n-  getDirectories!: (path: string) => string[];\n-  resolveTypeReferenceDirectives?:\n-      (names: string[], containingFile: string) => ts.ResolvedTypeReferenceDirective[];\n-  directoryExists?: (directoryName: string) => boolean;\n-\n-  constructor(\n-      private rootFiles: ReadonlyArray<string>, private options: CompilerOptions,\n-      private context: CompilerHost, private metadataProvider: MetadataProvider,\n-      private codeGenerator: CodeGenerator,\n-      private librarySummaries = new Map<string, LibrarySummary>()) {\n-    this.moduleResolutionCache = ts.createModuleResolutionCache(\n-        this.context.getCurrentDirectory!(), this.context.getCanonicalFileName.bind(this.context));\n-    const basePath = this.options.basePath!;\n-    this.rootDirs =\n-        (this.options.rootDirs || [this.options.basePath!]).map(p => path.resolve(basePath, p));\n-    if (context.getDirectories) {\n-      this.getDirectories = path => context.getDirectories!(path);\n-    }\n-    if (context.directoryExists) {\n-      this.directoryExists = directoryName => context.directoryExists!(directoryName);\n-    }\n-    if (context.getCancellationToken) {\n-      this.getCancellationToken = () => context.getCancellationToken!();\n-    }\n-    if (context.getDefaultLibLocation) {\n-      this.getDefaultLibLocation = () => context.getDefaultLibLocation!();\n-    }\n-    if (context.resolveTypeReferenceDirectives) {\n-      // Backward compatibility with TypeScript 2.9 and older since return\n-      // type has changed from (ts.ResolvedTypeReferenceDirective | undefined)[]\n-      // to ts.ResolvedTypeReferenceDirective[] in Typescript 3.0\n-      type ts3ResolveTypeReferenceDirectives = (names: string[], containingFile: string) =>\n-          ts.ResolvedTypeReferenceDirective[];\n-      this.resolveTypeReferenceDirectives = (names: string[], containingFile: string) =>\n-          (context.resolveTypeReferenceDirectives as ts3ResolveTypeReferenceDirectives)!\n-          (names, containingFile);\n-    }\n-    if (context.trace) {\n-      this.trace = s => context.trace!(s);\n-    }\n-    if (context.fileNameToModuleName) {\n-      this.fileNameToModuleName = context.fileNameToModuleName.bind(context);\n-    }\n-    // Note: don't copy over context.moduleNameToFileName as we first\n-    // normalize undefined containingFile to a filled containingFile.\n-    if (context.resourceNameToFileName) {\n-      this.resourceNameToFileName = context.resourceNameToFileName.bind(context);\n-    }\n-    if (context.toSummaryFileName) {\n-      this.toSummaryFileName = context.toSummaryFileName.bind(context);\n-    }\n-    if (context.fromSummaryFileName) {\n-      this.fromSummaryFileName = context.fromSummaryFileName.bind(context);\n-    }\n-    this.metadataReaderHost = {\n-      cacheMetadata: () => true,\n-      getSourceFileMetadata: (filePath) => {\n-        const sf = this.getOriginalSourceFile(filePath);\n-        return sf ? this.metadataProvider.getMetadata(sf) : undefined;\n-      },\n-      fileExists: (filePath) => this.originalFileExists(filePath),\n-      readFile: (filePath) => assert(this.context.readFile(filePath)),\n-    };\n-  }\n-\n-  private resolveModuleName(moduleName: string, containingFile: string): ts.ResolvedModule\n-      |undefined {\n-    const rm = ts.resolveModuleName(\n-                     moduleName, containingFile.replace(/\\\\/g, '/'), this.options, this,\n-                     this.moduleResolutionCache)\n-                   .resolvedModule;\n-    if (rm && this.isSourceFile(rm.resolvedFileName) && DTS.test(rm.resolvedFileName)) {\n-      // Case: generateCodeForLibraries = true and moduleName is\n-      // a .d.ts file in a node_modules folder.\n-      // Need to set isExternalLibraryImport to false so that generated files for that file\n-      // are emitted.\n-      rm.isExternalLibraryImport = false;\n-    }\n-    return rm;\n-  }\n-\n-  // Note: We implement this method so that TypeScript and Angular share the same\n-  // ts.ModuleResolutionCache\n-  // and that we can tell ts.Program about our different opinion about\n-  // ResolvedModule.isExternalLibraryImport\n-  // (see our isSourceFile method).\n-  resolveModuleNames(moduleNames: string[], containingFile: string): ts.ResolvedModule[] {\n-    // TODO(tbosch): this seems to be a typing error in TypeScript,\n-    // as it contains assertions that the result contains the same number of entries\n-    // as the given module names.\n-    return <ts.ResolvedModule[]>moduleNames.map(\n-        moduleName => this.resolveModuleName(moduleName, containingFile));\n-  }\n-\n-  moduleNameToFileName(m: string, containingFile?: string): string|null {\n-    if (!containingFile) {\n-      if (m.indexOf('.') === 0) {\n-        throw new Error('Resolution of relative paths requires a containing file.');\n-      }\n-      // Any containing file gives the same result for absolute imports\n-      containingFile = this.rootFiles[0];\n-    }\n-    if (this.context.moduleNameToFileName) {\n-      return this.context.moduleNameToFileName(m, containingFile);\n-    }\n-    const resolved = this.resolveModuleName(m, containingFile);\n-    return resolved ? resolved.resolvedFileName : null;\n-  }\n-\n-  /**\n-   * We want a moduleId that will appear in import statements in the generated code\n-   * which will be written to `containingFile`.\n-   *\n-   * Note that we also generate files for files in node_modules, as libraries\n-   * only ship .metadata.json files but not the generated code.\n-   *\n-   * Logic:\n-   * 1. if the importedFile and the containingFile are from the project sources\n-   *    or from the same node_modules package, use a relative path\n-   * 2. if the importedFile is in a node_modules package,\n-   *    use a path that starts with the package name.\n-   * 3. Error if the containingFile is in the node_modules package\n-   *    and the importedFile is in the project soures,\n-   *    as that is a violation of the principle that node_modules packages cannot\n-   *    import project sources.\n-   */\n-  fileNameToModuleName(importedFile: string, containingFile: string): string {\n-    const cacheKey = `${importedFile}:${containingFile}`;\n-    let moduleName = this.fileNameToModuleNameCache.get(cacheKey);\n-    if (moduleName != null) {\n-      return moduleName;\n-    }\n-\n-    const originalImportedFile = importedFile;\n-    if (this.options.traceResolution) {\n-      console.error(\n-          'fileNameToModuleName from containingFile', containingFile, 'to importedFile',\n-          importedFile);\n-    }\n-\n-    // drop extension\n-    importedFile = importedFile.replace(EXT, '');\n-    const importedFilePackageName = getPackageName(importedFile);\n-    const containingFilePackageName = getPackageName(containingFile);\n-\n-    if (importedFilePackageName === containingFilePackageName ||\n-        GENERATED_FILES.test(originalImportedFile)) {\n-      const rootedContainingFile = relativeToRootDirs(containingFile, this.rootDirs);\n-      const rootedImportedFile = relativeToRootDirs(importedFile, this.rootDirs);\n-\n-      if (rootedContainingFile !== containingFile && rootedImportedFile !== importedFile) {\n-        // if both files are contained in the `rootDirs`, then strip the rootDirs\n-        containingFile = rootedContainingFile;\n-        importedFile = rootedImportedFile;\n-      }\n-      moduleName = dotRelative(path.dirname(containingFile), importedFile);\n-    } else if (importedFilePackageName) {\n-      moduleName = stripNodeModulesPrefix(importedFile);\n-      if (originalImportedFile.endsWith('.d.ts')) {\n-        // the moduleName for these typings could be shortented to the npm package name\n-        // if the npm package typings matches the importedFile\n-        try {\n-          const modulePath = importedFile.substring(0, importedFile.length - moduleName.length) +\n-              importedFilePackageName;\n-          const packageJson =\n-              JSON.parse(fs.readFileSync(modulePath + '/package.json', 'utf8')) as any;\n-          const packageTypings = join(modulePath, packageJson.typings);\n-          if (packageTypings === originalImportedFile) {\n-            moduleName = importedFilePackageName;\n-          }\n-        } catch {\n-          // the above require() will throw if there is no package.json file\n-          // and this is safe to ignore and correct to keep the longer\n-          // moduleName in this case\n-        }\n-      }\n-    } else {\n-      throw new Error(`Trying to import a source file from a node_modules package: import ${\n-          originalImportedFile} from ${containingFile}`);\n-    }\n-\n-    this.fileNameToModuleNameCache.set(cacheKey, moduleName);\n-    return moduleName;\n-  }\n-\n-  resourceNameToFileName(resourceName: string, containingFile: string): string|null {\n-    // Note: we convert package paths into relative paths to be compatible with the the\n-    // previous implementation of UrlResolver.\n-    const firstChar = resourceName[0];\n-    if (firstChar === '/') {\n-      resourceName = resourceName.slice(1);\n-    } else if (firstChar !== '.') {\n-      resourceName = `./${resourceName}`;\n-    }\n-    let filePathWithNgResource =\n-        this.moduleNameToFileName(addNgResourceSuffix(resourceName), containingFile);\n-    // If the user specified styleUrl pointing to *.scss, but the Sass compiler was run before\n-    // Angular, then the resource may have been generated as *.css. Simply try the resolution again.\n-    if (!filePathWithNgResource && CSS_PREPROCESSOR_EXT.test(resourceName)) {\n-      const fallbackResourceName = resourceName.replace(CSS_PREPROCESSOR_EXT, '.css');\n-      filePathWithNgResource =\n-          this.moduleNameToFileName(addNgResourceSuffix(fallbackResourceName), containingFile);\n-    }\n-    const result = filePathWithNgResource ? stripNgResourceSuffix(filePathWithNgResource) : null;\n-    // Used under Bazel to report more specific error with remediation advice\n-    if (!result && (this.context as any).reportMissingResource) {\n-      (this.context as any).reportMissingResource(resourceName);\n-    }\n-    return result;\n-  }\n-\n-  toSummaryFileName(fileName: string, referringSrcFileName: string): string {\n-    return this.fileNameToModuleName(fileName, referringSrcFileName);\n-  }\n-\n-  fromSummaryFileName(fileName: string, referringLibFileName: string): string {\n-    const resolved = this.moduleNameToFileName(fileName, referringLibFileName);\n-    if (!resolved) {\n-      throw new Error(`Could not resolve ${fileName} from ${referringLibFileName}`);\n-    }\n-    return resolved;\n-  }\n-\n-  parseSourceSpanOf(fileName: string, line: number, character: number): ParseSourceSpan|null {\n-    const data = this.generatedSourceFiles.get(fileName);\n-    if (data && data.emitCtx) {\n-      return data.emitCtx.spanOf(line, character);\n-    }\n-    return null;\n-  }\n-\n-  private getOriginalSourceFile(\n-      filePath: string, languageVersion?: ts.ScriptTarget,\n-      onError?: ((message: string) => void)|undefined): ts.SourceFile|null {\n-    // Note: we need the explicit check via `has` as we also cache results\n-    // that were null / undefined.\n-    if (this.originalSourceFiles.has(filePath)) {\n-      return this.originalSourceFiles.get(filePath)!;\n-    }\n-    if (!languageVersion) {\n-      languageVersion = this.options.target || ts.ScriptTarget.Latest;\n-    }\n-    // Note: This can also return undefined,\n-    // as the TS typings are not correct!\n-    const sf = this.context.getSourceFile(filePath, languageVersion, onError) || null;\n-    this.originalSourceFiles.set(filePath, sf);\n-    return sf;\n-  }\n-\n-  updateGeneratedFile(genFile: GeneratedFile): ts.SourceFile {\n-    if (!genFile.stmts) {\n-      throw new Error(\n-          `Invalid Argument: Expected a GenerateFile with statements. ${genFile.genFileUrl}`);\n-    }\n-    const oldGenFile = this.generatedSourceFiles.get(genFile.genFileUrl);\n-    if (!oldGenFile) {\n-      throw new Error(`Illegal State: previous GeneratedFile not found for ${genFile.genFileUrl}.`);\n-    }\n-    const newRefs = genFileExternalReferences(genFile);\n-    const oldRefs = oldGenFile.externalReferences;\n-    let refsAreEqual = oldRefs.size === newRefs.size;\n-    if (refsAreEqual) {\n-      newRefs.forEach(r => refsAreEqual = refsAreEqual && oldRefs.has(r));\n-    }\n-    if (!refsAreEqual) {\n-      throw new Error(`Illegal State: external references changed in ${genFile.genFileUrl}.\\nOld: ${\n-          Array.from(oldRefs)}.\\nNew: ${Array.from(newRefs)}`);\n-    }\n-    return this.addGeneratedFile(genFile, newRefs);\n-  }\n-\n-  private addGeneratedFile(genFile: GeneratedFile, externalReferences: Set<string>): ts.SourceFile {\n-    if (!genFile.stmts) {\n-      throw new Error(\n-          `Invalid Argument: Expected a GenerateFile with statements. ${genFile.genFileUrl}`);\n-    }\n-    const {sourceText, context} = this.emitter.emitStatementsAndContext(\n-        genFile.genFileUrl, genFile.stmts, /* preamble */ '',\n-        /* emitSourceMaps */ false);\n-    const sf = ts.createSourceFile(\n-        genFile.genFileUrl, sourceText, this.options.target || ts.ScriptTarget.Latest);\n-    if (this.options.module === ts.ModuleKind.AMD || this.options.module === ts.ModuleKind.UMD) {\n-      if (this.context.amdModuleName) {\n-        const moduleName = this.context.amdModuleName(sf);\n-        if (moduleName) sf.moduleName = moduleName;\n-      } else if (/node_modules/.test(genFile.genFileUrl)) {\n-        // If we are generating an ngModule file under node_modules, we know the right module name\n-        // We don't need the host to supply a function in this case.\n-        sf.moduleName = stripNodeModulesPrefix(genFile.genFileUrl.replace(EXT, ''));\n-      }\n-    }\n-    this.generatedSourceFiles.set(genFile.genFileUrl, {\n-      sourceFile: sf,\n-      emitCtx: context,\n-      externalReferences,\n-    });\n-    return sf;\n-  }\n-\n-  shouldGenerateFile(fileName: string): {generate: boolean, baseFileName?: string} {\n-    // TODO(tbosch): allow generating files that are not in the rootDir\n-    // See https://github.com/angular/angular/issues/19337\n-    if (!isInRootDir(fileName, this.options)) {\n-      return {generate: false};\n-    }\n-    const genMatch = GENERATED_FILES.exec(fileName);\n-    if (!genMatch) {\n-      return {generate: false};\n-    }\n-    const [, base, genSuffix, suffix] = genMatch;\n-    if (suffix !== 'ts' && suffix !== 'tsx') {\n-      return {generate: false};\n-    }\n-    let baseFileName: string|undefined;\n-    if (genSuffix.indexOf('ngstyle') >= 0) {\n-      // Note: ngstyle files have names like `afile.css.ngstyle.ts`\n-      if (!this.originalFileExists(base)) {\n-        return {generate: false};\n-      }\n-    } else {\n-      // Note: on-the-fly generated files always have a `.ts` suffix,\n-      // but the file from which we generated it can be a `.ts`/ `.tsx`/ `.d.ts`\n-      // (see options.generateCodeForLibraries).\n-      baseFileName = [`${base}.ts`, `${base}.tsx`, `${base}.d.ts`].find(\n-          baseFileName => this.isSourceFile(baseFileName) && this.originalFileExists(baseFileName));\n-      if (!baseFileName) {\n-        return {generate: false};\n-      }\n-    }\n-    return {generate: true, baseFileName};\n-  }\n-\n-  shouldGenerateFilesFor(fileName: string) {\n-    // TODO(tbosch): allow generating files that are not in the rootDir\n-    // See https://github.com/angular/angular/issues/19337\n-    return !GENERATED_FILES.test(fileName) && this.isSourceFile(fileName) &&\n-        isInRootDir(fileName, this.options);\n-  }\n-\n-  getSourceFile(\n-      fileName: string, languageVersion: ts.ScriptTarget,\n-      onError?: ((message: string) => void)|undefined): ts.SourceFile {\n-    // Note: Don't exit early in this method to make sure\n-    // we always have up to date references on the file!\n-    let genFileNames: string[] = [];\n-    let sf = this.getGeneratedFile(fileName);\n-    if (!sf) {\n-      const summary = this.librarySummaries.get(fileName);\n-      if (summary) {\n-        if (!summary.sourceFile) {\n-          summary.sourceFile = ts.createSourceFile(\n-              fileName, summary.text, this.options.target || ts.ScriptTarget.Latest);\n-        }\n-        sf = summary.sourceFile;\n-        // TypeScript doesn't allow returning redirect source files. To avoid unforseen errors we\n-        // return the original source file instead of the redirect target.\n-        const redirectInfo = (sf as any).redirectInfo;\n-        if (redirectInfo !== undefined) {\n-          sf = redirectInfo.unredirected;\n-        }\n-        genFileNames = [];\n-      }\n-    }\n-    if (!sf) {\n-      sf = this.getOriginalSourceFile(fileName);\n-      const cachedGenFiles = this.generatedCodeFor.get(fileName);\n-      if (cachedGenFiles) {\n-        genFileNames = cachedGenFiles;\n-      } else {\n-        if (!this.options.noResolve && this.shouldGenerateFilesFor(fileName)) {\n-          genFileNames = this.codeGenerator.findGeneratedFileNames(fileName).filter(\n-              fileName => this.shouldGenerateFile(fileName).generate);\n-        }\n-        this.generatedCodeFor.set(fileName, genFileNames);\n-      }\n-    }\n-    if (sf) {\n-      addReferencesToSourceFile(sf, genFileNames);\n-    }\n-    // TODO(tbosch): TypeScript's typings for getSourceFile are incorrect,\n-    // as it can very well return undefined.\n-    return sf!;\n-  }\n-\n-  private getGeneratedFile(fileName: string): ts.SourceFile|null {\n-    const genSrcFile = this.generatedSourceFiles.get(fileName);\n-    if (genSrcFile) {\n-      return genSrcFile.sourceFile;\n-    }\n-    const {generate, baseFileName} = this.shouldGenerateFile(fileName);\n-    if (generate) {\n-      const genFile = this.codeGenerator.generateFile(fileName, baseFileName);\n-      return this.addGeneratedFile(genFile, genFileExternalReferences(genFile));\n-    }\n-    return null;\n-  }\n-\n-  private originalFileExists(fileName: string): boolean {\n-    let fileExists = this.originalFileExistsCache.get(fileName);\n-    if (fileExists == null) {\n-      fileExists = this.context.fileExists(fileName);\n-      this.originalFileExistsCache.set(fileName, fileExists);\n-    }\n-    return fileExists;\n-  }\n-\n-  fileExists(fileName: string): boolean {\n-    fileName = stripNgResourceSuffix(fileName);\n-    if (this.librarySummaries.has(fileName) || this.generatedSourceFiles.has(fileName)) {\n-      return true;\n-    }\n-    if (this.shouldGenerateFile(fileName).generate) {\n-      return true;\n-    }\n-    return this.originalFileExists(fileName);\n-  }\n-\n-  loadSummary(filePath: string): string|null {\n-    const summary = this.librarySummaries.get(filePath);\n-    if (summary) {\n-      return summary.text;\n-    }\n-    if (this.originalFileExists(filePath)) {\n-      return assert(this.context.readFile(filePath));\n-    }\n-    return null;\n-  }\n-\n-  isSourceFile(filePath: string): boolean {\n-    // Don't generate any files nor typecheck them\n-    // if skipTemplateCodegen is set and fullTemplateTypeCheck is not yet set,\n-    // for backwards compatibility.\n-    if (this.options.skipTemplateCodegen && !this.options.fullTemplateTypeCheck) {\n-      return false;\n-    }\n-    // If we have a summary from a previous compilation,\n-    // treat the file never as a source file.\n-    if (this.librarySummaries.has(filePath)) {\n-      return false;\n-    }\n-    if (GENERATED_FILES.test(filePath)) {\n-      return false;\n-    }\n-    if (this.options.generateCodeForLibraries === false && DTS.test(filePath)) {\n-      return false;\n-    }\n-    if (DTS.test(filePath)) {\n-      // Check for a bundle index.\n-      if (this.hasBundleIndex(filePath)) {\n-        const normalFilePath = path.normalize(filePath);\n-        return this.flatModuleIndexNames.has(normalFilePath) ||\n-            this.flatModuleIndexRedirectNames.has(normalFilePath);\n-      }\n-    }\n-    return true;\n-  }\n-\n-  readFile(fileName: string) {\n-    const summary = this.librarySummaries.get(fileName);\n-    if (summary) {\n-      return summary.text;\n-    }\n-    return this.context.readFile(fileName);\n-  }\n-\n-  getMetadataFor(filePath: string): ModuleMetadata[]|undefined {\n-    return readMetadata(filePath, this.metadataReaderHost, this.metadataReaderCache);\n-  }\n-\n-  loadResource(filePath: string): Promise<string>|string {\n-    if (this.context.readResource) return this.context.readResource(filePath);\n-    if (!this.originalFileExists(filePath)) {\n-      throw syntaxError(`Error: Resource file not found: ${filePath}`);\n-    }\n-    return assert(this.context.readFile(filePath));\n-  }\n-\n-  getOutputName(filePath: string): string {\n-    return path.relative(this.getCurrentDirectory(), filePath);\n-  }\n-\n-  private hasBundleIndex(filePath: string): boolean {\n-    const checkBundleIndex = (directory: string): boolean => {\n-      let result = this.flatModuleIndexCache.get(directory);\n-      if (result == null) {\n-        if (path.basename(directory) == 'node_module') {\n-          // Don't look outside the node_modules this package is installed in.\n-          result = false;\n-        } else {\n-          // A bundle index exists if the typings .d.ts file has a metadata.json that has an\n-          // importAs.\n-          try {\n-            const packageFile = path.join(directory, 'package.json');\n-            if (this.originalFileExists(packageFile)) {\n-              // Once we see a package.json file, assume false until it we find the bundle index.\n-              result = false;\n-              const packageContent =\n-                  JSON.parse(assert(this.context.readFile(packageFile))) as {typings: string};\n-              if (packageContent.typings) {\n-                const typings = path.normalize(path.join(directory, packageContent.typings));\n-                if (DTS.test(typings)) {\n-                  const metadataFile = typings.replace(DTS, '.metadata.json');\n-                  if (this.originalFileExists(metadataFile)) {\n-                    const metadata = JSON.parse(assert(this.context.readFile(metadataFile))) as\n-                        {flatModuleIndexRedirect: string, importAs: string};\n-                    if (metadata.flatModuleIndexRedirect) {\n-                      this.flatModuleIndexRedirectNames.add(typings);\n-                      // Note: don't set result = true,\n-                      // as this would mark this folder\n-                      // as having a bundleIndex too early without\n-                      // filling the bundleIndexNames.\n-                    } else if (metadata.importAs) {\n-                      this.flatModuleIndexNames.add(typings);\n-                      result = true;\n-                    }\n-                  }\n-                }\n-              }\n-            } else {\n-              const parent = path.dirname(directory);\n-              if (parent != directory) {\n-                // Try the parent directory.\n-                result = checkBundleIndex(parent);\n-              } else {\n-                result = false;\n-              }\n-            }\n-          } catch {\n-            // If we encounter any errors assume we this isn't a bundle index.\n-            result = false;\n-          }\n-        }\n-        this.flatModuleIndexCache.set(directory, result);\n-      }\n-      return result;\n-    };\n-\n-    return checkBundleIndex(path.dirname(filePath));\n-  }\n-\n-  getDefaultLibFileName = (options: ts.CompilerOptions) =>\n-      this.context.getDefaultLibFileName(options)\n-  getCurrentDirectory = () => this.context.getCurrentDirectory();\n-  getCanonicalFileName = (fileName: string) => this.context.getCanonicalFileName(fileName);\n-  useCaseSensitiveFileNames = () => this.context.useCaseSensitiveFileNames();\n-  getNewLine = () => this.context.getNewLine();\n-  // Make sure we do not `host.realpath()` from TS as we do not want to resolve symlinks.\n-  // https://github.com/Microsoft/TypeScript/issues/9552\n-  realpath = (p: string) => p;\n-  writeFile = this.context.writeFile.bind(this.context);\n-}\n-\n-function genFileExternalReferences(genFile: GeneratedFile): Set<string> {\n-  return new Set(collectExternalReferences(genFile.stmts!).map(er => er.moduleName!));\n-}\n-\n-function addReferencesToSourceFile(sf: ts.SourceFile, genFileNames: string[]) {\n-  // Note: as we modify ts.SourceFiles we need to keep the original\n-  // value for `referencedFiles` around in cache the original host is caching ts.SourceFiles.\n-  // Note: cloning the ts.SourceFile is expensive as the nodes in have parent pointers,\n-  // i.e. we would also need to clone and adjust all nodes.\n-  let originalReferencedFiles: ReadonlyArray<ts.FileReference> =\n-      (sf as any).originalReferencedFiles;\n-  if (!originalReferencedFiles) {\n-    originalReferencedFiles = sf.referencedFiles;\n-    (sf as any).originalReferencedFiles = originalReferencedFiles;\n-  }\n-  const newReferencedFiles = [...originalReferencedFiles];\n-  genFileNames.forEach(gf => newReferencedFiles.push({fileName: gf, pos: 0, end: 0}));\n-  sf.referencedFiles = newReferencedFiles;\n-}\n-\n-export function getOriginalReferences(sourceFile: ts.SourceFile): ts.FileReference[]|undefined {\n-  return sourceFile && (sourceFile as any).originalReferencedFiles;\n-}\n-\n-function dotRelative(from: string, to: string): string {\n-  const rPath: string = path.relative(from, to).replace(/\\\\/g, '/');\n-  return rPath.startsWith('.') ? rPath : './' + rPath;\n-}\n-\n-/**\n- * Moves the path into `genDir` folder while preserving the `node_modules` directory.\n- */\n-function getPackageName(filePath: string): string|null {\n-  const match = NODE_MODULES_PACKAGE_NAME.exec(filePath);\n-  return match ? match[1] : null;\n-}\n-\n-function stripNodeModulesPrefix(filePath: string): string {\n-  return filePath.replace(/.*node_modules\\//, '');\n-}\n-\n-function getNodeModulesPrefix(filePath: string): string|null {\n-  const match = /.*node_modules\\//.exec(filePath);\n-  return match ? match[1] : null;\n-}\n-\n-function stripNgResourceSuffix(fileName: string): string {\n-  return fileName.replace(/\\.\\$ngresource\\$.*/, '');\n-}\n-\n-function addNgResourceSuffix(fileName: string): string {\n-  return `${fileName}.$ngresource$`;\n-}"
        },
        {
            "sha": "fe04b0f0010a415c977c6bfa8524150f9728a99a",
            "filename": "packages/compiler-cli/src/transformers/inline_resources.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 332,
            "changes": 332,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Finline_resources.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Finline_resources.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Finline_resources.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,332 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {isClassMetadata, isMetadataImportedSymbolReferenceExpression, isMetadataSymbolicCallExpression, MetadataObject, MetadataValue} from '../metadata/index';\n-\n-import {MetadataTransformer, ValueTransform} from './metadata_cache';\n-\n-const PRECONDITIONS_TEXT =\n-    'angularCompilerOptions.enableResourceInlining requires all resources to be statically resolvable.';\n-\n-/** A subset of members from AotCompilerHost */\n-export type ResourcesHost = {\n-  resourceNameToFileName(resourceName: string, containingFileName: string): string|null;\n-  loadResource(path: string): Promise<string>| string;\n-};\n-\n-export type StaticResourceLoader = {\n-  get(url: string|MetadataValue): string;\n-};\n-\n-function getResourceLoader(host: ResourcesHost, containingFileName: string): StaticResourceLoader {\n-  return {\n-    get(url: string|MetadataValue): string {\n-      if (typeof url !== 'string') {\n-        throw new Error('templateUrl and stylesUrl must be string literals. ' + PRECONDITIONS_TEXT);\n-      }\n-      const fileName = host.resourceNameToFileName(url, containingFileName);\n-      if (fileName) {\n-        const content = host.loadResource(fileName);\n-        if (typeof content !== 'string') {\n-          throw new Error('Cannot handle async resource. ' + PRECONDITIONS_TEXT);\n-        }\n-        return content;\n-      }\n-      throw new Error(`Failed to resolve ${url} from ${containingFileName}. ${PRECONDITIONS_TEXT}`);\n-    }\n-  };\n-}\n-\n-export class InlineResourcesMetadataTransformer implements MetadataTransformer {\n-  constructor(private host: ResourcesHost) {}\n-\n-  start(sourceFile: ts.SourceFile): ValueTransform|undefined {\n-    const loader = getResourceLoader(this.host, sourceFile.fileName);\n-    return (value: MetadataValue, node: ts.Node): MetadataValue => {\n-      if (isClassMetadata(value) && ts.isClassDeclaration(node) && value.decorators) {\n-        value.decorators.forEach(d => {\n-          if (isMetadataSymbolicCallExpression(d) &&\n-              isMetadataImportedSymbolReferenceExpression(d.expression) &&\n-              d.expression.module === '@angular/core' && d.expression.name === 'Component' &&\n-              d.arguments) {\n-            // Arguments to an @Component that was compiled successfully are always\n-            // MetadataObject(s).\n-            d.arguments = (d.arguments as MetadataObject[])\n-                              .map(this.updateDecoratorMetadata.bind(this, loader));\n-          }\n-        });\n-      }\n-      return value;\n-    };\n-  }\n-\n-  updateDecoratorMetadata(loader: StaticResourceLoader, arg: MetadataObject): MetadataObject {\n-    if (arg['templateUrl']) {\n-      arg['template'] = loader.get(arg['templateUrl']);\n-      delete arg['templateUrl'];\n-    }\n-\n-    const styles = arg['styles'] || [];\n-    const styleUrls = arg['styleUrls'] || [];\n-    if (!Array.isArray(styles)) throw new Error('styles should be an array');\n-    if (!Array.isArray(styleUrls)) throw new Error('styleUrls should be an array');\n-\n-    styles.push(...styleUrls.map(styleUrl => loader.get(styleUrl)));\n-    if (styles.length > 0) {\n-      arg['styles'] = styles;\n-      delete arg['styleUrls'];\n-    }\n-\n-    return arg;\n-  }\n-}\n-\n-export function getInlineResourcesTransformFactory(\n-    program: ts.Program, host: ResourcesHost): ts.TransformerFactory<ts.SourceFile> {\n-  return (context: ts.TransformationContext) => (sourceFile: ts.SourceFile) => {\n-    const loader = getResourceLoader(host, sourceFile.fileName);\n-    const visitor: ts.Visitor = node => {\n-      // Components are always classes; skip any other node\n-      if (!ts.isClassDeclaration(node)) {\n-        return node;\n-      }\n-\n-      // Decorator case - before or without decorator downleveling\n-      // @Component()\n-      const newDecorators = ts.visitNodes(node.decorators, (node: ts.Node) => {\n-        if (ts.isDecorator(node) && isComponentDecorator(node, program.getTypeChecker())) {\n-          return updateDecorator(node, loader);\n-        }\n-        return node;\n-      });\n-\n-      // Annotation case - after decorator downleveling\n-      // static decorators: {type: Function, args?: any[]}[]\n-      const newMembers = ts.visitNodes(node.members, (node: ts.Node) => {\n-        if (ts.isClassElement(node)) {\n-          return updateAnnotations(node, loader, program.getTypeChecker());\n-        } else {\n-          return node;\n-        }\n-      });\n-\n-      // Create a new AST subtree with our modifications\n-      return ts.updateClassDeclaration(\n-          node, newDecorators, node.modifiers, node.name, node.typeParameters,\n-          node.heritageClauses || [], newMembers);\n-    };\n-\n-    return ts.visitEachChild(sourceFile, visitor, context);\n-  };\n-}\n-\n-/**\n- * Update a Decorator AST node to inline the resources\n- * @param node the @Component decorator\n- * @param loader provides access to load resources\n- */\n-function updateDecorator(node: ts.Decorator, loader: StaticResourceLoader): ts.Decorator {\n-  if (!ts.isCallExpression(node.expression)) {\n-    // User will get an error somewhere else with bare @Component\n-    return node;\n-  }\n-  const expr = node.expression;\n-  const newArguments = updateComponentProperties(expr.arguments, loader);\n-  return ts.updateDecorator(\n-      node, ts.updateCall(expr, expr.expression, expr.typeArguments, newArguments));\n-}\n-\n-/**\n- * Update an Annotations AST node to inline the resources\n- * @param node the static decorators property\n- * @param loader provides access to load resources\n- * @param typeChecker provides access to symbol table\n- */\n-function updateAnnotations(\n-    node: ts.ClassElement, loader: StaticResourceLoader,\n-    typeChecker: ts.TypeChecker): ts.ClassElement {\n-  // Looking for a member of this shape:\n-  // PropertyDeclaration called decorators, with static modifier\n-  // Initializer is ArrayLiteralExpression\n-  // One element is the Component type, its initializer is the @angular/core Component symbol\n-  // One element is the component args, its initializer is the Component arguments to change\n-  // e.g.\n-  //   static decorators: {type: Function, args?: any[]}[] =\n-  //   [{\n-  //     type: Component,\n-  //     args: [{\n-  //       templateUrl: './my.component.html',\n-  //       styleUrls: ['./my.component.css'],\n-  //     }],\n-  //   }];\n-  if (!ts.isPropertyDeclaration(node) ||  // ts.ModifierFlags.Static &&\n-      !ts.isIdentifier(node.name) || node.name.text !== 'decorators' || !node.initializer ||\n-      !ts.isArrayLiteralExpression(node.initializer)) {\n-    return node;\n-  }\n-\n-  const newAnnotations = node.initializer.elements.map(annotation => {\n-    // No-op if there's a non-object-literal mixed in the decorators values\n-    if (!ts.isObjectLiteralExpression(annotation)) return annotation;\n-\n-    const decoratorType = annotation.properties.find(p => isIdentifierNamed(p, 'type'));\n-\n-    // No-op if there's no 'type' property, or if it's not initialized to the Component symbol\n-    if (!decoratorType || !ts.isPropertyAssignment(decoratorType) ||\n-        !ts.isIdentifier(decoratorType.initializer) ||\n-        !isComponentSymbol(decoratorType.initializer, typeChecker)) {\n-      return annotation;\n-    }\n-\n-    const newAnnotation = annotation.properties.map(prop => {\n-      // No-op if this isn't the 'args' property or if it's not initialized to an array\n-      if (!isIdentifierNamed(prop, 'args') || !ts.isPropertyAssignment(prop) ||\n-          !ts.isArrayLiteralExpression(prop.initializer))\n-        return prop;\n-\n-      const newDecoratorArgs = ts.updatePropertyAssignment(\n-          prop, prop.name,\n-          ts.createArrayLiteral(updateComponentProperties(prop.initializer.elements, loader)));\n-\n-      return newDecoratorArgs;\n-    });\n-\n-    return ts.updateObjectLiteral(annotation, newAnnotation);\n-  });\n-\n-  return ts.updateProperty(\n-      node, node.decorators, node.modifiers, node.name, node.questionToken, node.type,\n-      ts.updateArrayLiteral(node.initializer, newAnnotations));\n-}\n-\n-function isIdentifierNamed(p: ts.ObjectLiteralElementLike, name: string): boolean {\n-  return !!p.name && ts.isIdentifier(p.name) && p.name.text === name;\n-}\n-\n-/**\n- * Check that the node we are visiting is the actual Component decorator defined in @angular/core.\n- */\n-function isComponentDecorator(node: ts.Decorator, typeChecker: ts.TypeChecker): boolean {\n-  if (!ts.isCallExpression(node.expression)) {\n-    return false;\n-  }\n-  const callExpr = node.expression;\n-\n-  let identifier: ts.Node;\n-\n-  if (ts.isIdentifier(callExpr.expression)) {\n-    identifier = callExpr.expression;\n-  } else {\n-    return false;\n-  }\n-  return isComponentSymbol(identifier, typeChecker);\n-}\n-\n-function isComponentSymbol(identifier: ts.Node, typeChecker: ts.TypeChecker) {\n-  // Only handle identifiers, not expressions\n-  if (!ts.isIdentifier(identifier)) return false;\n-\n-  // NOTE: resolver.getReferencedImportDeclaration would work as well but is internal\n-  const symbol = typeChecker.getSymbolAtLocation(identifier);\n-\n-  if (!symbol || !symbol.declarations || !symbol.declarations.length) {\n-    console.error(\n-        `Unable to resolve symbol '${identifier.text}' in the program, does it type-check?`);\n-    return false;\n-  }\n-\n-  const declaration = symbol.declarations[0];\n-\n-  if (!declaration || !ts.isImportSpecifier(declaration)) {\n-    return false;\n-  }\n-\n-  const name = (declaration.propertyName || declaration.name).text;\n-  // We know that parent pointers are set because we created the SourceFile ourselves.\n-  // The number of parent references here match the recursion depth at this point.\n-  const moduleId = (declaration.parent!.parent!.parent!.moduleSpecifier as ts.StringLiteral).text;\n-  return moduleId === '@angular/core' && name === 'Component';\n-}\n-\n-/**\n- * For each property in the object literal, if it's templateUrl or styleUrls, replace it\n- * with content.\n- * @param node the arguments to @Component() or args property of decorators: [{type:Component}]\n- * @param loader provides access to the loadResource method of the host\n- * @returns updated arguments\n- */\n-function updateComponentProperties(\n-    args: ts.NodeArray<ts.Expression>, loader: StaticResourceLoader): ts.NodeArray<ts.Expression> {\n-  if (args.length !== 1) {\n-    // User should have gotten a type-check error because @Component takes one argument\n-    return args;\n-  }\n-  const componentArg = args[0];\n-  if (!ts.isObjectLiteralExpression(componentArg)) {\n-    // User should have gotten a type-check error because @Component takes an object literal\n-    // argument\n-    return args;\n-  }\n-\n-  const newProperties: ts.ObjectLiteralElementLike[] = [];\n-  const newStyleExprs: ts.Expression[] = [];\n-  componentArg.properties.forEach(prop => {\n-    if (!ts.isPropertyAssignment(prop) || ts.isComputedPropertyName(prop.name)) {\n-      newProperties.push(prop);\n-      return;\n-    }\n-\n-    switch (prop.name.text) {\n-      case 'styles':\n-        if (!ts.isArrayLiteralExpression(prop.initializer)) {\n-          throw new Error('styles takes an array argument');\n-        }\n-        newStyleExprs.push(...prop.initializer.elements);\n-        break;\n-\n-      case 'styleUrls':\n-        if (!ts.isArrayLiteralExpression(prop.initializer)) {\n-          throw new Error('styleUrls takes an array argument');\n-        }\n-        newStyleExprs.push(...prop.initializer.elements.map((expr: ts.Expression) => {\n-          if (!ts.isStringLiteral(expr) && !ts.isNoSubstitutionTemplateLiteral(expr)) {\n-            throw new Error(\n-                'Can only accept string literal arguments to styleUrls. ' + PRECONDITIONS_TEXT);\n-          }\n-          const styles = loader.get(expr.text);\n-          return ts.createLiteral(styles);\n-        }));\n-        break;\n-\n-      case 'templateUrl':\n-        if (!ts.isStringLiteral(prop.initializer) &&\n-            !ts.isNoSubstitutionTemplateLiteral(prop.initializer)) {\n-          throw new Error(\n-              'Can only accept a string literal argument to templateUrl. ' + PRECONDITIONS_TEXT);\n-        }\n-        const template = loader.get(prop.initializer.text);\n-        newProperties.push(ts.updatePropertyAssignment(\n-            prop, ts.createIdentifier('template'), ts.createLiteral(template)));\n-        break;\n-\n-      default:\n-        newProperties.push(prop);\n-    }\n-  });\n-\n-  // Add the non-inline styles\n-  if (newStyleExprs.length > 0) {\n-    const newStyles = ts.createPropertyAssignment(\n-        ts.createIdentifier('styles'), ts.createArrayLiteral(newStyleExprs));\n-    newProperties.push(newStyles);\n-  }\n-\n-  return ts.createNodeArray([ts.updateObjectLiteral(componentArg, newProperties)]);\n-}"
        },
        {
            "sha": "f4482443e729ca289956b9eef873c632208bfca8",
            "filename": "packages/compiler-cli/src/transformers/lower_expressions.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 420,
            "changes": 420,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Flower_expressions.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Flower_expressions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Flower_expressions.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,420 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {createLoweredSymbol, isLoweredSymbol} from '@angular/compiler';\n-import ts from 'typescript';\n-\n-import {CollectorOptions, isMetadataGlobalReferenceExpression, MetadataCollector, MetadataValue, ModuleMetadata} from '../metadata/index';\n-import {createExportSpecifier} from '../ngtsc/util/src/typescript';\n-\n-import {MetadataCache, MetadataTransformer, ValueTransform} from './metadata_cache';\n-\n-export interface LoweringRequest {\n-  kind: ts.SyntaxKind;\n-  location: number;\n-  end: number;\n-  name: string;\n-}\n-\n-export type RequestLocationMap = Map<number, LoweringRequest>;\n-\n-const enum DeclarationOrder {\n-  BeforeStmt,\n-  AfterStmt\n-}\n-\n-interface Declaration {\n-  name: string;\n-  node: ts.Node;\n-  order: DeclarationOrder;\n-}\n-\n-interface DeclarationInsert {\n-  declarations: Declaration[];\n-  relativeTo: ts.Node;\n-}\n-\n-function toMap<T, K>(items: T[], select: (item: T) => K): Map<K, T> {\n-  return new Map(items.map<[K, T]>(i => [select(i), i]));\n-}\n-\n-// We will never lower expressions in a nested lexical scope so avoid entering them.\n-// This also avoids a bug in TypeScript 2.3 where the lexical scopes get out of sync\n-// when using visitEachChild.\n-function isLexicalScope(node: ts.Node): boolean {\n-  switch (node.kind) {\n-    case ts.SyntaxKind.ArrowFunction:\n-    case ts.SyntaxKind.FunctionExpression:\n-    case ts.SyntaxKind.FunctionDeclaration:\n-    case ts.SyntaxKind.ClassExpression:\n-    case ts.SyntaxKind.ClassDeclaration:\n-    case ts.SyntaxKind.FunctionType:\n-    case ts.SyntaxKind.TypeLiteral:\n-    case ts.SyntaxKind.ArrayType:\n-      return true;\n-  }\n-  return false;\n-}\n-\n-function transformSourceFile(\n-    sourceFile: ts.SourceFile, requests: RequestLocationMap,\n-    context: ts.TransformationContext): ts.SourceFile {\n-  const inserts: DeclarationInsert[] = [];\n-\n-  // Calculate the range of interesting locations. The transform will only visit nodes in this\n-  // range to improve the performance on large files.\n-  const locations = Array.from(requests.keys());\n-  const min = Math.min(...locations);\n-  const max = Math.max(...locations);\n-\n-  // Visit nodes matching the request and synthetic nodes added by tsickle\n-  function shouldVisit(pos: number, end: number): boolean {\n-    return (pos <= max && end >= min) || pos == -1;\n-  }\n-\n-  function visitSourceFile(sourceFile: ts.SourceFile): ts.SourceFile {\n-    function topLevelStatement(node: ts.Statement): ts.Statement {\n-      const declarations: Declaration[] = [];\n-\n-      function visitNode(node: ts.Node): ts.Node {\n-        // Get the original node before tsickle\n-        const {pos, end, kind, parent: originalParent} = ts.getOriginalNode(node);\n-        const nodeRequest = requests.get(pos);\n-        if (nodeRequest && nodeRequest.kind == kind && nodeRequest.end == end) {\n-          // This node is requested to be rewritten as a reference to the exported name.\n-          if (originalParent && originalParent.kind === ts.SyntaxKind.VariableDeclaration) {\n-            // As the value represents the whole initializer of a variable declaration,\n-            // just refer to that variable. This e.g. helps to preserve closure comments\n-            // at the right place.\n-            const varParent = originalParent as ts.VariableDeclaration;\n-            if (varParent.name.kind === ts.SyntaxKind.Identifier) {\n-              const varName = varParent.name.text;\n-              const exportName = nodeRequest.name;\n-              declarations.push({\n-                name: exportName,\n-                node: ts.createIdentifier(varName),\n-                order: DeclarationOrder.AfterStmt\n-              });\n-              return node;\n-            }\n-          }\n-          // Record that the node needs to be moved to an exported variable with the given name\n-          const exportName = nodeRequest.name;\n-          declarations.push({name: exportName, node, order: DeclarationOrder.BeforeStmt});\n-          return ts.createIdentifier(exportName);\n-        }\n-        let result = node;\n-        if (shouldVisit(pos, end) && !isLexicalScope(node)) {\n-          result = ts.visitEachChild(node, visitNode, context);\n-        }\n-        return result;\n-      }\n-\n-      // Get the original node before tsickle\n-      const {pos, end} = ts.getOriginalNode(node);\n-      let resultStmt: ts.Statement;\n-      if (shouldVisit(pos, end)) {\n-        resultStmt = ts.visitEachChild(node, visitNode, context);\n-      } else {\n-        resultStmt = node;\n-      }\n-\n-      if (declarations.length) {\n-        inserts.push({relativeTo: resultStmt, declarations});\n-      }\n-      return resultStmt;\n-    }\n-\n-    let newStatements = sourceFile.statements.map(topLevelStatement);\n-\n-    if (inserts.length) {\n-      // Insert the declarations relative to the rewritten statement that references them.\n-      const insertMap = toMap(inserts, i => i.relativeTo);\n-      const tmpStatements: ts.Statement[] = [];\n-      newStatements.forEach(statement => {\n-        const insert = insertMap.get(statement);\n-        if (insert) {\n-          const before = insert.declarations.filter(d => d.order === DeclarationOrder.BeforeStmt);\n-          if (before.length) {\n-            tmpStatements.push(createVariableStatementForDeclarations(before));\n-          }\n-          tmpStatements.push(statement);\n-          const after = insert.declarations.filter(d => d.order === DeclarationOrder.AfterStmt);\n-          if (after.length) {\n-            tmpStatements.push(createVariableStatementForDeclarations(after));\n-          }\n-        } else {\n-          tmpStatements.push(statement);\n-        }\n-      });\n-\n-      // Insert an exports clause to export the declarations\n-      tmpStatements.push(ts.createExportDeclaration(\n-          /* decorators */ undefined,\n-          /* modifiers */ undefined,\n-          ts.createNamedExports(\n-              inserts\n-                  .reduce(\n-                      (accumulator, insert) => [...accumulator, ...insert.declarations],\n-                      [] as Declaration[])\n-                  .map(\n-                      declaration => createExportSpecifier(\n-                          /* propertyName */ undefined, declaration.name)))));\n-\n-      newStatements = tmpStatements;\n-    }\n-\n-    const newSf = ts.updateSourceFileNode(\n-        sourceFile, ts.setTextRange(ts.createNodeArray(newStatements), sourceFile.statements));\n-    if (!(sourceFile.flags & ts.NodeFlags.Synthesized)) {\n-      (newSf.flags as ts.NodeFlags) &= ~ts.NodeFlags.Synthesized;\n-    }\n-\n-    return newSf;\n-  }\n-\n-  return visitSourceFile(sourceFile);\n-}\n-\n-function createVariableStatementForDeclarations(declarations: Declaration[]): ts.VariableStatement {\n-  const varDecls = declarations.map(\n-      i => ts.createVariableDeclaration(i.name, /* type */ undefined, i.node as ts.Expression));\n-  return ts.createVariableStatement(\n-      /* modifiers */ undefined, ts.createVariableDeclarationList(varDecls, ts.NodeFlags.Const));\n-}\n-\n-export function getExpressionLoweringTransformFactory(\n-    requestsMap: RequestsMap, program: ts.Program): (context: ts.TransformationContext) =>\n-    (sourceFile: ts.SourceFile) => ts.SourceFile {\n-  // Return the factory\n-  return (context: ts.TransformationContext) => (sourceFile: ts.SourceFile): ts.SourceFile => {\n-    // We need to use the original SourceFile for reading metadata, and not the transformed one.\n-    const originalFile = program.getSourceFile(sourceFile.fileName);\n-    if (originalFile) {\n-      const requests = requestsMap.getRequests(originalFile);\n-      if (requests && requests.size) {\n-        return transformSourceFile(sourceFile, requests, context);\n-      }\n-    }\n-    return sourceFile;\n-  };\n-}\n-\n-export interface RequestsMap {\n-  getRequests(sourceFile: ts.SourceFile): RequestLocationMap;\n-}\n-\n-function isEligibleForLowering(node: ts.Node|undefined): boolean {\n-  if (node) {\n-    switch (node.kind) {\n-      case ts.SyntaxKind.SourceFile:\n-      case ts.SyntaxKind.Decorator:\n-        // Lower expressions that are local to the module scope or\n-        // in a decorator.\n-        return true;\n-      case ts.SyntaxKind.ClassDeclaration:\n-      case ts.SyntaxKind.InterfaceDeclaration:\n-      case ts.SyntaxKind.EnumDeclaration:\n-      case ts.SyntaxKind.FunctionDeclaration:\n-        // Don't lower expressions in a declaration.\n-        return false;\n-      case ts.SyntaxKind.VariableDeclaration:\n-        const isExported = (ts.getCombinedModifierFlags(node as ts.VariableDeclaration) &\n-                            ts.ModifierFlags.Export) == 0;\n-        // This might be unnecessary, as the variable might be exported and only used as a reference\n-        // in another expression. However, the variable also might be involved in provider\n-        // definitions. If that's the case, there is a specific token (`ROUTES`) which the compiler\n-        // attempts to understand deeply. Sub-expressions within that token (`loadChildren` for\n-        // example) might also require lowering even if the top-level declaration is already\n-        // properly exported.\n-        const varNode = node as ts.VariableDeclaration;\n-        return isExported ||\n-            (varNode.initializer !== undefined &&\n-             (ts.isObjectLiteralExpression(varNode.initializer) ||\n-              ts.isArrayLiteralExpression(varNode.initializer) ||\n-              ts.isCallExpression(varNode.initializer)));\n-    }\n-    return isEligibleForLowering(node.parent);\n-  }\n-  return true;\n-}\n-\n-function isPrimitive(value: any): boolean {\n-  return Object(value) !== value;\n-}\n-\n-function isRewritten(value: any): boolean {\n-  return isMetadataGlobalReferenceExpression(value) && isLoweredSymbol(value.name);\n-}\n-\n-function isLiteralFieldNamed(node: ts.Node, names: Set<string>): boolean {\n-  if (node.parent && node.parent.kind == ts.SyntaxKind.PropertyAssignment) {\n-    const property = node.parent as ts.PropertyAssignment;\n-    if (property.parent && property.parent.kind == ts.SyntaxKind.ObjectLiteralExpression &&\n-        property.name && property.name.kind == ts.SyntaxKind.Identifier) {\n-      const propertyName = property.name as ts.Identifier;\n-      return names.has(propertyName.text);\n-    }\n-  }\n-  return false;\n-}\n-\n-export class LowerMetadataTransform implements RequestsMap, MetadataTransformer {\n-  // TODO(issue/24571): remove '!'.\n-  private cache!: MetadataCache;\n-  private requests = new Map<string, RequestLocationMap>();\n-  private lowerableFieldNames: Set<string>;\n-\n-  constructor(lowerableFieldNames: string[]) {\n-    this.lowerableFieldNames = new Set<string>(lowerableFieldNames);\n-  }\n-\n-  // RequestMap\n-  getRequests(sourceFile: ts.SourceFile): RequestLocationMap {\n-    let result = this.requests.get(sourceFile.fileName);\n-    if (!result) {\n-      // Force the metadata for this source file to be collected which\n-      // will recursively call start() populating the request map;\n-      this.cache.getMetadata(sourceFile);\n-\n-      // If we still don't have the requested metadata, the file is not a module\n-      // or is a declaration file so return an empty map.\n-      result = this.requests.get(sourceFile.fileName) || new Map<number, LoweringRequest>();\n-    }\n-    return result;\n-  }\n-\n-  // MetadataTransformer\n-  connect(cache: MetadataCache): void {\n-    this.cache = cache;\n-  }\n-\n-  start(sourceFile: ts.SourceFile): ValueTransform|undefined {\n-    let identNumber = 0;\n-    const freshIdent = () => createLoweredSymbol(identNumber++);\n-    const requests = new Map<number, LoweringRequest>();\n-    this.requests.set(sourceFile.fileName, requests);\n-\n-    const replaceNode = (node: ts.Node) => {\n-      const name = freshIdent();\n-      requests.set(node.pos, {name, kind: node.kind, location: node.pos, end: node.end});\n-      return {__symbolic: 'reference', name};\n-    };\n-\n-    const isExportedSymbol = (() => {\n-      let exportTable: Set<string>;\n-      return (node: ts.Node) => {\n-        if (node.kind == ts.SyntaxKind.Identifier) {\n-          const ident = node as ts.Identifier;\n-\n-          if (!exportTable) {\n-            exportTable = createExportTableFor(sourceFile);\n-          }\n-          return exportTable.has(ident.text);\n-        }\n-        return false;\n-      };\n-    })();\n-\n-    const isExportedPropertyAccess = (node: ts.Node) => {\n-      if (node.kind === ts.SyntaxKind.PropertyAccessExpression) {\n-        const pae = node as ts.PropertyAccessExpression;\n-        if (isExportedSymbol(pae.expression)) {\n-          return true;\n-        }\n-      }\n-      return false;\n-    };\n-\n-    const hasLowerableParentCache = new Map<ts.Node, boolean>();\n-\n-    const shouldBeLowered = (node: ts.Node|undefined): boolean => {\n-      if (node === undefined) {\n-        return false;\n-      }\n-      let lowerable: boolean = false;\n-      if ((node.kind === ts.SyntaxKind.ArrowFunction ||\n-           node.kind === ts.SyntaxKind.FunctionExpression) &&\n-          isEligibleForLowering(node)) {\n-        lowerable = true;\n-      } else if (\n-          isLiteralFieldNamed(node, this.lowerableFieldNames) && isEligibleForLowering(node) &&\n-          !isExportedSymbol(node) && !isExportedPropertyAccess(node)) {\n-        lowerable = true;\n-      }\n-      return lowerable;\n-    };\n-\n-    const hasLowerableParent = (node: ts.Node|undefined): boolean => {\n-      if (node === undefined) {\n-        return false;\n-      }\n-      if (!hasLowerableParentCache.has(node)) {\n-        hasLowerableParentCache.set(\n-            node, shouldBeLowered(node.parent) || hasLowerableParent(node.parent));\n-      }\n-      return hasLowerableParentCache.get(node)!;\n-    };\n-\n-    const isLowerable = (node: ts.Node|undefined): boolean => {\n-      if (node === undefined) {\n-        return false;\n-      }\n-      return shouldBeLowered(node) && !hasLowerableParent(node);\n-    };\n-\n-    return (value: MetadataValue, node: ts.Node): MetadataValue => {\n-      if (!isPrimitive(value) && !isRewritten(value) && isLowerable(node)) {\n-        return replaceNode(node);\n-      }\n-      return value;\n-    };\n-  }\n-}\n-\n-function createExportTableFor(sourceFile: ts.SourceFile): Set<string> {\n-  const exportTable = new Set<string>();\n-  // Lazily collect all the exports from the source file\n-  ts.forEachChild(sourceFile, function scan(node) {\n-    switch (node.kind) {\n-      case ts.SyntaxKind.ClassDeclaration:\n-      case ts.SyntaxKind.FunctionDeclaration:\n-      case ts.SyntaxKind.InterfaceDeclaration:\n-        if ((ts.getCombinedModifierFlags(node as ts.Declaration) & ts.ModifierFlags.Export) != 0) {\n-          const classDeclaration =\n-              node as (ts.ClassDeclaration | ts.FunctionDeclaration | ts.InterfaceDeclaration);\n-          const name = classDeclaration.name;\n-          if (name) exportTable.add(name.text);\n-        }\n-        break;\n-      case ts.SyntaxKind.VariableStatement:\n-        const variableStatement = node as ts.VariableStatement;\n-        for (const declaration of variableStatement.declarationList.declarations) {\n-          scan(declaration);\n-        }\n-        break;\n-      case ts.SyntaxKind.VariableDeclaration:\n-        const variableDeclaration = node as ts.VariableDeclaration;\n-        if ((ts.getCombinedModifierFlags(variableDeclaration) & ts.ModifierFlags.Export) != 0 &&\n-            variableDeclaration.name.kind == ts.SyntaxKind.Identifier) {\n-          const name = variableDeclaration.name as ts.Identifier;\n-          exportTable.add(name.text);\n-        }\n-        break;\n-      case ts.SyntaxKind.ExportDeclaration:\n-        const exportDeclaration = node as ts.ExportDeclaration;\n-        const {moduleSpecifier, exportClause} = exportDeclaration;\n-        if (!moduleSpecifier && exportClause && ts.isNamedExports(exportClause)) {\n-          exportClause.elements.forEach(spec => {\n-            exportTable.add(spec.name.text);\n-          });\n-        }\n-    }\n-  });\n-  return exportTable;\n-}"
        },
        {
            "sha": "4134cadc1eb3b2cff622cbec581efa1fa7efebc0",
            "filename": "packages/compiler-cli/src/transformers/metadata_cache.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 68,
            "changes": 68,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fmetadata_cache.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fmetadata_cache.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fmetadata_cache.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,68 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {MetadataCollector, MetadataValue, ModuleMetadata} from '../metadata/index';\n-\n-import {MetadataProvider} from './compiler_host';\n-import {TS} from './util';\n-\n-export type ValueTransform = (value: MetadataValue, node: ts.Node) => MetadataValue;\n-\n-export interface MetadataTransformer {\n-  connect?(cache: MetadataCache): void;\n-  start(sourceFile: ts.SourceFile): ValueTransform|undefined;\n-}\n-\n-/**\n- * Cache, and potentially transform, metadata as it is being collected.\n- */\n-export class MetadataCache implements MetadataProvider {\n-  private metadataCache = new Map<string, ModuleMetadata|undefined>();\n-\n-  constructor(\n-      private collector: MetadataCollector, private readonly strict: boolean,\n-      private transformers: MetadataTransformer[]) {\n-    for (let transformer of transformers) {\n-      if (transformer.connect) {\n-        transformer.connect(this);\n-      }\n-    }\n-  }\n-\n-  getMetadata(sourceFile: ts.SourceFile): ModuleMetadata|undefined {\n-    if (this.metadataCache.has(sourceFile.fileName)) {\n-      return this.metadataCache.get(sourceFile.fileName);\n-    }\n-    let substitute: ValueTransform|undefined = undefined;\n-\n-    // Only process transformers on modules that are not declaration files.\n-    const declarationFile = sourceFile.isDeclarationFile;\n-    const moduleFile = ts.isExternalModule(sourceFile);\n-    if (!declarationFile && moduleFile) {\n-      for (let transform of this.transformers) {\n-        const transformSubstitute = transform.start(sourceFile);\n-        if (transformSubstitute) {\n-          if (substitute) {\n-            const previous: ValueTransform = substitute;\n-            substitute = (value: MetadataValue, node: ts.Node) =>\n-                transformSubstitute(previous(value, node), node);\n-          } else {\n-            substitute = transformSubstitute;\n-          }\n-        }\n-      }\n-    }\n-\n-    const isTsFile = TS.test(sourceFile.fileName);\n-    const result = this.collector.getMetadata(sourceFile, this.strict && isTsFile, substitute);\n-    this.metadataCache.set(sourceFile.fileName, result);\n-    return result;\n-  }\n-}"
        },
        {
            "sha": "2515b293a3df2a2bc4133560c84889eb432352d5",
            "filename": "packages/compiler-cli/src/transformers/metadata_reader.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 130,
            "changes": 130,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fmetadata_reader.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fmetadata_reader.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fmetadata_reader.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,130 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {METADATA_VERSION, ModuleMetadata} from '../metadata';\n-\n-import {DTS} from './util';\n-\n-export interface MetadataReaderHost {\n-  getSourceFileMetadata(filePath: string): ModuleMetadata|undefined;\n-  cacheMetadata?(fileName: string): boolean;\n-  fileExists(filePath: string): boolean;\n-  readFile(filePath: string): string;\n-}\n-\n-export interface MetadataReaderCache {\n-  /**\n-   * @internal\n-   */\n-  data: Map<string, ModuleMetadata[]|undefined>;\n-}\n-\n-export function createMetadataReaderCache(): MetadataReaderCache {\n-  const data = new Map<string, ModuleMetadata[]|undefined>();\n-  return {data};\n-}\n-\n-export function readMetadata(\n-    filePath: string, host: MetadataReaderHost, cache?: MetadataReaderCache): ModuleMetadata[]|\n-    undefined {\n-  let metadatas = cache && cache.data.get(filePath);\n-  if (metadatas) {\n-    return metadatas;\n-  }\n-  if (host.fileExists(filePath)) {\n-    // If the file doesn't exists then we cannot return metadata for the file.\n-    // This will occur if the user referenced a declared module for which no file\n-    // exists for the module (i.e. jQuery or angularjs).\n-    if (DTS.test(filePath)) {\n-      metadatas = readMetadataFile(host, filePath);\n-      if (!metadatas) {\n-        // If there is a .d.ts file but no metadata file we need to produce a\n-        // metadata from the .d.ts file as metadata files capture reexports\n-        // (starting with v3).\n-        metadatas = [upgradeMetadataWithDtsData(\n-            host, {'__symbolic': 'module', 'version': 1, 'metadata': {}}, filePath)];\n-      }\n-    } else {\n-      const metadata = host.getSourceFileMetadata(filePath);\n-      metadatas = metadata ? [metadata] : [];\n-    }\n-  }\n-  if (cache && (!host.cacheMetadata || host.cacheMetadata(filePath))) {\n-    cache.data.set(filePath, metadatas);\n-  }\n-  return metadatas;\n-}\n-\n-\n-function readMetadataFile(host: MetadataReaderHost, dtsFilePath: string): ModuleMetadata[]|\n-    undefined {\n-  const metadataPath = dtsFilePath.replace(DTS, '.metadata.json');\n-  if (!host.fileExists(metadataPath)) {\n-    return undefined;\n-  }\n-  try {\n-    const metadataOrMetadatas =\n-        JSON.parse(host.readFile(metadataPath)) as ModuleMetadata | ModuleMetadata[] | undefined;\n-    const metadatas = metadataOrMetadatas ?\n-        (Array.isArray(metadataOrMetadatas) ? metadataOrMetadatas : [metadataOrMetadatas]) :\n-        [];\n-    if (metadatas.length) {\n-      let maxMetadata = metadatas.reduce((p, c) => p.version > c.version ? p : c);\n-      if (maxMetadata.version < METADATA_VERSION) {\n-        metadatas.push(upgradeMetadataWithDtsData(host, maxMetadata, dtsFilePath));\n-      }\n-    }\n-    return metadatas;\n-  } catch (e) {\n-    console.error(`Failed to read JSON file ${metadataPath}`);\n-    throw e;\n-  }\n-}\n-\n-function upgradeMetadataWithDtsData(\n-    host: MetadataReaderHost, oldMetadata: ModuleMetadata, dtsFilePath: string): ModuleMetadata {\n-  // patch v1 to v3 by adding exports and the `extends` clause.\n-  // patch v3 to v4 by adding `interface` symbols for TypeAlias\n-  let newMetadata: ModuleMetadata = {\n-    '__symbolic': 'module',\n-    'version': METADATA_VERSION,\n-    'metadata': {...oldMetadata.metadata},\n-  };\n-  if (oldMetadata.exports) {\n-    newMetadata.exports = oldMetadata.exports;\n-  }\n-  if (oldMetadata.importAs) {\n-    newMetadata.importAs = oldMetadata.importAs;\n-  }\n-  if (oldMetadata.origins) {\n-    newMetadata.origins = oldMetadata.origins;\n-  }\n-  const dtsMetadata = host.getSourceFileMetadata(dtsFilePath);\n-  if (dtsMetadata) {\n-    for (let prop in dtsMetadata.metadata) {\n-      if (!newMetadata.metadata[prop]) {\n-        newMetadata.metadata[prop] = dtsMetadata.metadata[prop];\n-      }\n-    }\n-    if (dtsMetadata['importAs']) newMetadata['importAs'] = dtsMetadata['importAs'];\n-\n-    // Only copy exports from exports from metadata prior to version 3.\n-    // Starting with version 3 the collector began collecting exports and\n-    // this should be redundant. Also, with bundler will rewrite the exports\n-    // which will hoist the exports from modules referenced indirectly causing\n-    // the imports to be different than the .d.ts files and using the .d.ts file\n-    // exports would cause the StaticSymbolResolver to redirect symbols to the\n-    // incorrect location.\n-    if ((!oldMetadata.version || oldMetadata.version < 3) && dtsMetadata.exports) {\n-      newMetadata.exports = dtsMetadata.exports;\n-    }\n-  }\n-  return newMetadata;\n-}"
        },
        {
            "sha": "c2fa9151df56f7f2c6a5e45ccd50e5e100921d77",
            "filename": "packages/compiler-cli/src/transformers/node_emitter.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 771,
            "changes": 771,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fnode_emitter.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fnode_emitter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fnode_emitter.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,771 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {AssertNotNull, BinaryOperator, BinaryOperatorExpr, BuiltinMethod, BuiltinVar, CastExpr, ClassStmt, CommaExpr, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, ExpressionStatement, ExpressionVisitor, ExternalExpr, ExternalReference, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, LeadingComment, leadingComment, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, LocalizedString, NotExpr, ParseSourceFile, ParseSourceSpan, PartialModule, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, Statement, StatementVisitor, StmtModifier, TaggedTemplateExpr, ThrowStmt, TryCatchStmt, TypeofExpr, UnaryOperator, UnaryOperatorExpr, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr} from '@angular/compiler';\n-import ts from 'typescript';\n-\n-import {attachComments} from '../ngtsc/translator';\n-import {createExportSpecifier} from '../ngtsc/util/src/typescript';\n-\n-import {error} from './util';\n-\n-export interface Node {\n-  sourceSpan: ParseSourceSpan|null;\n-}\n-\n-const METHOD_THIS_NAME = 'this';\n-const CATCH_ERROR_NAME = 'error';\n-const CATCH_STACK_NAME = 'stack';\n-const _VALID_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\n-\n-export class TypeScriptNodeEmitter {\n-  constructor(private annotateForClosureCompiler: boolean) {}\n-\n-  updateSourceFile(sourceFile: ts.SourceFile, stmts: Statement[], preamble?: string):\n-      [ts.SourceFile, Map<ts.Node, Node>] {\n-    const converter = new NodeEmitterVisitor(this.annotateForClosureCompiler);\n-    // [].concat flattens the result so that each `visit...` method can also return an array of\n-    // stmts.\n-    const statements: any[] = [].concat(\n-        ...stmts.map(stmt => stmt.visitStatement(converter, null)).filter(stmt => stmt != null));\n-    const sourceStatements =\n-        [...converter.getReexports(), ...converter.getImports(), ...statements];\n-    if (preamble) {\n-      // We always attach the preamble comment to a `NotEmittedStatement` node, because tsickle uses\n-      // this node type as a marker of the preamble to ensure that it adds its own new nodes after\n-      // the preamble.\n-      const preambleCommentHolder = ts.createNotEmittedStatement(sourceFile);\n-      // Preamble comments are passed through as-is, which means that they must already contain a\n-      // leading `*` if they should be a JSDOC comment.\n-      ts.addSyntheticLeadingComment(\n-          preambleCommentHolder, ts.SyntaxKind.MultiLineCommentTrivia, preamble,\n-          /* hasTrailingNewline */ true);\n-      sourceStatements.unshift(preambleCommentHolder);\n-    }\n-\n-    converter.updateSourceMap(sourceStatements);\n-    const newSourceFile = ts.updateSourceFileNode(sourceFile, sourceStatements);\n-    return [newSourceFile, converter.getNodeMap()];\n-  }\n-}\n-\n-/**\n- * Update the given source file to include the changes specified in module.\n- *\n- * The module parameter is treated as a partial module meaning that the statements are added to\n- * the module instead of replacing the module. Also, any classes are treated as partial classes\n- * and the included members are added to the class with the same name instead of a new class\n- * being created.\n- */\n-export function updateSourceFile(\n-    sourceFile: ts.SourceFile, module: PartialModule,\n-    annotateForClosureCompiler: boolean): [ts.SourceFile, Map<ts.Node, Node>] {\n-  const converter = new NodeEmitterVisitor(annotateForClosureCompiler);\n-  converter.loadExportedVariableIdentifiers(sourceFile);\n-\n-  const prefixStatements = module.statements.filter(statement => !(statement instanceof ClassStmt));\n-  const classes =\n-      module.statements.filter(statement => statement instanceof ClassStmt) as ClassStmt[];\n-  const classMap = new Map(\n-      classes.map<[string, ClassStmt]>(classStatement => [classStatement.name, classStatement]));\n-  const classNames = new Set(classes.map(classStatement => classStatement.name));\n-\n-  const prefix: ts.Statement[] =\n-      prefixStatements.map(statement => statement.visitStatement(converter, sourceFile));\n-\n-  // Add static methods to all the classes referenced in module.\n-  let newStatements = sourceFile.statements.map(node => {\n-    if (node.kind == ts.SyntaxKind.ClassDeclaration) {\n-      const classDeclaration = node as ts.ClassDeclaration;\n-      const name = classDeclaration.name;\n-      if (name) {\n-        const classStatement = classMap.get(name.text);\n-        if (classStatement) {\n-          classNames.delete(name.text);\n-          const classMemberHolder =\n-              converter.visitDeclareClassStmt(classStatement) as ts.ClassDeclaration;\n-          const newMethods =\n-              classMemberHolder.members.filter(member => member.kind !== ts.SyntaxKind.Constructor);\n-          const newMembers = [...classDeclaration.members, ...newMethods];\n-\n-          return ts.updateClassDeclaration(\n-              classDeclaration,\n-              /* decorators */ classDeclaration.decorators,\n-              /* modifiers */ classDeclaration.modifiers,\n-              /* name */ classDeclaration.name,\n-              /* typeParameters */ classDeclaration.typeParameters,\n-              /* heritageClauses */ classDeclaration.heritageClauses || [],\n-              /* members */ newMembers);\n-        }\n-      }\n-    }\n-    return node;\n-  });\n-\n-  // Validate that all the classes have been generated\n-  classNames.size == 0 ||\n-      error(`${classNames.size == 1 ? 'Class' : 'Classes'} \"${\n-          Array.from(classNames.keys()).join(', ')}\" not generated`);\n-\n-  // Add imports to the module required by the new methods\n-  const imports = converter.getImports();\n-  if (imports && imports.length) {\n-    // Find where the new imports should go\n-    const index = firstAfter(\n-        newStatements,\n-        statement => statement.kind === ts.SyntaxKind.ImportDeclaration ||\n-            statement.kind === ts.SyntaxKind.ImportEqualsDeclaration);\n-    newStatements =\n-        [...newStatements.slice(0, index), ...imports, ...prefix, ...newStatements.slice(index)];\n-  } else {\n-    newStatements = [...prefix, ...newStatements];\n-  }\n-\n-  converter.updateSourceMap(newStatements);\n-  const newSourceFile = ts.updateSourceFileNode(sourceFile, newStatements);\n-\n-  return [newSourceFile, converter.getNodeMap()];\n-}\n-\n-// Return the index after the first value in `a` that doesn't match the predicate after a value that\n-// does or 0 if no values match.\n-function firstAfter<T>(a: T[], predicate: (value: T) => boolean) {\n-  let index = 0;\n-  const len = a.length;\n-  for (; index < len; index++) {\n-    const value = a[index];\n-    if (predicate(value)) break;\n-  }\n-  if (index >= len) return 0;\n-  for (; index < len; index++) {\n-    const value = a[index];\n-    if (!predicate(value)) break;\n-  }\n-  return index;\n-}\n-\n-// A recorded node is a subtype of the node that is marked as being recorded. This is used\n-// to ensure that NodeEmitterVisitor.record has been called on all nodes returned by the\n-// NodeEmitterVisitor\n-export type RecordedNode<T extends ts.Node = ts.Node> = (T&{\n-  __recorded: any;\n-})|null;\n-\n-function escapeLiteral(value: string): string {\n-  return value.replace(/(\\\"|\\\\)/g, '\\\\$1').replace(/(\\n)|(\\r)/g, function(v, n, r) {\n-    return n ? '\\\\n' : '\\\\r';\n-  });\n-}\n-\n-function createLiteral(value: any) {\n-  if (value === null) {\n-    return ts.createNull();\n-  } else if (value === undefined) {\n-    return ts.createIdentifier('undefined');\n-  } else {\n-    const result = ts.createLiteral(value);\n-    if (ts.isStringLiteral(result) && result.text.indexOf('\\\\') >= 0) {\n-      // Hack to avoid problems cause indirectly by:\n-      //    https://github.com/Microsoft/TypeScript/issues/20192\n-      // This avoids the string escaping normally performed for a string relying on that\n-      // TypeScript just emits the text raw for a numeric literal.\n-      (result as any).kind = ts.SyntaxKind.NumericLiteral;\n-      result.text = `\"${escapeLiteral(result.text)}\"`;\n-    }\n-    return result;\n-  }\n-}\n-\n-function isExportTypeStatement(statement: ts.Statement): boolean {\n-  return !!statement.modifiers &&\n-      statement.modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword);\n-}\n-\n-/**\n- * Visits an output ast and produces the corresponding TypeScript synthetic nodes.\n- */\n-export class NodeEmitterVisitor implements StatementVisitor, ExpressionVisitor {\n-  private _nodeMap = new Map<ts.Node, Node>();\n-  private _importsWithPrefixes = new Map<string, string>();\n-  private _reexports = new Map<string, {name: string, as: string}[]>();\n-  private _templateSources = new Map<ParseSourceFile, ts.SourceMapSource>();\n-  private _exportedVariableIdentifiers = new Map<string, ts.Identifier>();\n-\n-  constructor(private annotateForClosureCompiler: boolean) {}\n-\n-  /**\n-   * Process the source file and collect exported identifiers that refer to variables.\n-   *\n-   * Only variables are collected because exported classes still exist in the module scope in\n-   * CommonJS, whereas variables have their declarations moved onto the `exports` object, and all\n-   * references are updated accordingly.\n-   */\n-  loadExportedVariableIdentifiers(sourceFile: ts.SourceFile): void {\n-    sourceFile.statements.forEach(statement => {\n-      if (ts.isVariableStatement(statement) && isExportTypeStatement(statement)) {\n-        statement.declarationList.declarations.forEach(declaration => {\n-          if (ts.isIdentifier(declaration.name)) {\n-            this._exportedVariableIdentifiers.set(declaration.name.text, declaration.name);\n-          }\n-        });\n-      }\n-    });\n-  }\n-\n-  getReexports(): ts.Statement[] {\n-    return Array.from(this._reexports.entries())\n-        .map(\n-            ([exportedFilePath, reexports]) => ts.createExportDeclaration(\n-                /* decorators */ undefined,\n-                /* modifiers */ undefined,\n-                ts.createNamedExports(\n-                    reexports.map(({name, as}) => createExportSpecifier(name, as))),\n-                /* moduleSpecifier */ createLiteral(exportedFilePath)));\n-  }\n-\n-  getImports(): ts.Statement[] {\n-    return Array.from(this._importsWithPrefixes.entries())\n-        .map(\n-            ([namespace, prefix]) => ts.createImportDeclaration(\n-                /* decorators */ undefined,\n-                /* modifiers */ undefined,\n-                /* importClause */\n-                ts.createImportClause(\n-                    /* name */<ts.Identifier>(undefined as any),\n-                    ts.createNamespaceImport(ts.createIdentifier(prefix))),\n-                /* moduleSpecifier */ createLiteral(namespace)));\n-  }\n-\n-  getNodeMap() {\n-    return this._nodeMap;\n-  }\n-\n-  updateSourceMap(statements: ts.Statement[]) {\n-    let lastRangeStartNode: ts.Node|undefined = undefined;\n-    let lastRangeEndNode: ts.Node|undefined = undefined;\n-    let lastRange: ts.SourceMapRange|undefined = undefined;\n-\n-    const recordLastSourceRange = () => {\n-      if (lastRange && lastRangeStartNode && lastRangeEndNode) {\n-        if (lastRangeStartNode == lastRangeEndNode) {\n-          ts.setSourceMapRange(lastRangeEndNode, lastRange);\n-        } else {\n-          ts.setSourceMapRange(lastRangeStartNode, lastRange);\n-          // Only emit the pos for the first node emitted in the range.\n-          ts.setEmitFlags(lastRangeStartNode, ts.EmitFlags.NoTrailingSourceMap);\n-          ts.setSourceMapRange(lastRangeEndNode, lastRange);\n-          // Only emit emit end for the last node emitted in the range.\n-          ts.setEmitFlags(lastRangeEndNode, ts.EmitFlags.NoLeadingSourceMap);\n-        }\n-      }\n-    };\n-\n-    const visitNode = (tsNode: ts.Node) => {\n-      const ngNode = this._nodeMap.get(tsNode);\n-      if (ngNode) {\n-        const range = this.sourceRangeOf(ngNode);\n-        if (range) {\n-          if (!lastRange || range.source != lastRange.source || range.pos != lastRange.pos ||\n-              range.end != lastRange.end) {\n-            recordLastSourceRange();\n-            lastRangeStartNode = tsNode;\n-            lastRange = range;\n-          }\n-          lastRangeEndNode = tsNode;\n-        }\n-      }\n-      ts.forEachChild(tsNode, visitNode);\n-    };\n-    statements.forEach(visitNode);\n-    recordLastSourceRange();\n-  }\n-\n-  private postProcess<T extends ts.Node>(ngNode: Node, tsNode: T|null): RecordedNode<T> {\n-    if (tsNode && !this._nodeMap.has(tsNode)) {\n-      this._nodeMap.set(tsNode, ngNode);\n-    }\n-    if (tsNode !== null && ngNode instanceof Statement && ngNode.leadingComments !== undefined) {\n-      attachComments(tsNode as unknown as ts.Statement, ngNode.leadingComments);\n-    }\n-    return tsNode as RecordedNode<T>;\n-  }\n-\n-  private sourceRangeOf(node: Node): ts.SourceMapRange|null {\n-    if (node.sourceSpan) {\n-      const span = node.sourceSpan;\n-      if (span.start.file == span.end.file) {\n-        const file = span.start.file;\n-        if (file.url) {\n-          let source = this._templateSources.get(file);\n-          if (!source) {\n-            source = ts.createSourceMapSource(file.url, file.content, pos => pos);\n-            this._templateSources.set(file, source);\n-          }\n-          return {pos: span.start.offset, end: span.end.offset, source};\n-        }\n-      }\n-    }\n-    return null;\n-  }\n-\n-  private getModifiers(stmt: Statement) {\n-    let modifiers: ts.Modifier[] = [];\n-    if (stmt.hasModifier(StmtModifier.Exported)) {\n-      modifiers.push(ts.createToken(ts.SyntaxKind.ExportKeyword));\n-    }\n-    return modifiers;\n-  }\n-\n-  // StatementVisitor\n-  visitDeclareVarStmt(stmt: DeclareVarStmt) {\n-    if (stmt.hasModifier(StmtModifier.Exported) && stmt.value instanceof ExternalExpr &&\n-        !stmt.type) {\n-      // check for a reexport\n-      const {name, moduleName} = stmt.value.value;\n-      if (moduleName) {\n-        let reexports = this._reexports.get(moduleName);\n-        if (!reexports) {\n-          reexports = [];\n-          this._reexports.set(moduleName, reexports);\n-        }\n-        reexports.push({name: name!, as: stmt.name});\n-        return null;\n-      }\n-    }\n-\n-    const varDeclList = ts.createVariableDeclarationList([ts.createVariableDeclaration(\n-        ts.createIdentifier(stmt.name),\n-        /* type */ undefined,\n-        (stmt.value && stmt.value.visitExpression(this, null)) || undefined)]);\n-\n-    if (stmt.hasModifier(StmtModifier.Exported)) {\n-      // Note: We need to add an explicit variable and export declaration so that\n-      // the variable can be referred in the same file as well.\n-      const tsVarStmt =\n-          this.postProcess(stmt, ts.createVariableStatement(/* modifiers */[], varDeclList));\n-      const exportStmt = this.postProcess(\n-          stmt,\n-          ts.createExportDeclaration(\n-              /*decorators*/ undefined, /*modifiers*/ undefined,\n-              ts.createNamedExports([createExportSpecifier(stmt.name, stmt.name)])));\n-      return [tsVarStmt, exportStmt];\n-    }\n-    return this.postProcess(stmt, ts.createVariableStatement(this.getModifiers(stmt), varDeclList));\n-  }\n-\n-  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt) {\n-    return this.postProcess(\n-        stmt,\n-        ts.createFunctionDeclaration(\n-            /* decorators */ undefined, this.getModifiers(stmt),\n-            /* asteriskToken */ undefined, stmt.name, /* typeParameters */ undefined,\n-            stmt.params.map(\n-                p => ts.createParameter(\n-                    /* decorators */ undefined, /* modifiers */ undefined,\n-                    /* dotDotDotToken */ undefined, p.name)),\n-            /* type */ undefined, this._visitStatements(stmt.statements)));\n-  }\n-\n-  visitExpressionStmt(stmt: ExpressionStatement) {\n-    return this.postProcess(stmt, ts.createStatement(stmt.expr.visitExpression(this, null)));\n-  }\n-\n-  visitReturnStmt(stmt: ReturnStatement) {\n-    return this.postProcess(\n-        stmt, ts.createReturn(stmt.value ? stmt.value.visitExpression(this, null) : undefined));\n-  }\n-\n-  visitDeclareClassStmt(stmt: ClassStmt) {\n-    const modifiers = this.getModifiers(stmt);\n-    const fields = stmt.fields.map(field => {\n-      const property = ts.createProperty(\n-          /* decorators */ undefined, /* modifiers */ translateModifiers(field.modifiers),\n-          field.name,\n-          /* questionToken */ undefined,\n-          /* type */ undefined,\n-          field.initializer == null ? ts.createNull() :\n-                                      field.initializer.visitExpression(this, null));\n-\n-      if (this.annotateForClosureCompiler) {\n-        // Closure compiler transforms the form `Service.ɵprov = X` into `Service$ɵprov = X`. To\n-        // prevent this transformation, such assignments need to be annotated with @nocollapse.\n-        // Note that tsickle is typically responsible for adding such annotations, however it\n-        // doesn't yet handle synthetic fields added during other transformations.\n-        ts.addSyntheticLeadingComment(\n-            property, ts.SyntaxKind.MultiLineCommentTrivia, '* @nocollapse ',\n-            /* hasTrailingNewLine */ false);\n-      }\n-\n-      return property;\n-    });\n-    const getters = stmt.getters.map(\n-        getter => ts.createGetAccessor(\n-            /* decorators */ undefined, /* modifiers */ undefined, getter.name, /* parameters */[],\n-            /* type */ undefined, this._visitStatements(getter.body)));\n-\n-    const constructor =\n-        (stmt.constructorMethod && [ts.createConstructor(\n-                                       /* decorators */ undefined,\n-                                       /* modifiers */ undefined,\n-                                       /* parameters */\n-                                       stmt.constructorMethod.params.map(\n-                                           p => ts.createParameter(\n-                                               /* decorators */ undefined,\n-                                               /* modifiers */ undefined,\n-                                               /* dotDotDotToken */ undefined, p.name)),\n-                                       this._visitStatements(stmt.constructorMethod.body))]) ||\n-        [];\n-\n-    // TODO {chuckj}: Determine what should be done for a method with a null name.\n-    const methods = stmt.methods.filter(method => method.name)\n-                        .map(\n-                            method => ts.createMethod(\n-                                /* decorators */ undefined,\n-                                /* modifiers */ translateModifiers(method.modifiers),\n-                                /* astriskToken */ undefined, method.name!/* guarded by filter */,\n-                                /* questionToken */ undefined, /* typeParameters */ undefined,\n-                                method.params.map(\n-                                    p => ts.createParameter(\n-                                        /* decorators */ undefined, /* modifiers */ undefined,\n-                                        /* dotDotDotToken */ undefined, p.name)),\n-                                /* type */ undefined, this._visitStatements(method.body)));\n-    return this.postProcess(\n-        stmt,\n-        ts.createClassDeclaration(\n-            /* decorators */ undefined, modifiers, stmt.name, /* typeParameters*/ undefined,\n-            stmt.parent &&\n-                    [ts.createHeritageClause(\n-                        ts.SyntaxKind.ExtendsKeyword, [stmt.parent.visitExpression(this, null)])] ||\n-                [],\n-            [...fields, ...getters, ...constructor, ...methods]));\n-  }\n-\n-  visitIfStmt(stmt: IfStmt) {\n-    return this.postProcess(\n-        stmt,\n-        ts.createIf(\n-            stmt.condition.visitExpression(this, null), this._visitStatements(stmt.trueCase),\n-            stmt.falseCase && stmt.falseCase.length && this._visitStatements(stmt.falseCase) ||\n-                undefined));\n-  }\n-\n-  visitTryCatchStmt(stmt: TryCatchStmt): RecordedNode<ts.TryStatement> {\n-    return this.postProcess(\n-        stmt,\n-        ts.createTry(\n-            this._visitStatements(stmt.bodyStmts),\n-            ts.createCatchClause(\n-                CATCH_ERROR_NAME,\n-                this._visitStatementsPrefix(\n-                    [ts.createVariableStatement(\n-                        /* modifiers */ undefined,\n-                        [ts.createVariableDeclaration(\n-                            CATCH_STACK_NAME, /* type */ undefined,\n-                            ts.createPropertyAccess(\n-                                ts.createIdentifier(CATCH_ERROR_NAME),\n-                                ts.createIdentifier(CATCH_STACK_NAME)))])],\n-                    stmt.catchStmts)),\n-            /* finallyBlock */ undefined));\n-  }\n-\n-  visitThrowStmt(stmt: ThrowStmt) {\n-    return this.postProcess(stmt, ts.createThrow(stmt.error.visitExpression(this, null)));\n-  }\n-\n-  // ExpressionVisitor\n-  visitWrappedNodeExpr(expr: WrappedNodeExpr<any>) {\n-    return this.postProcess(expr, expr.node);\n-  }\n-\n-  visitTypeofExpr(expr: TypeofExpr) {\n-    const typeOf = ts.createTypeOf(expr.expr.visitExpression(this, null));\n-    return this.postProcess(expr, typeOf);\n-  }\n-\n-  // ExpressionVisitor\n-  visitReadVarExpr(expr: ReadVarExpr) {\n-    switch (expr.builtin) {\n-      case BuiltinVar.This:\n-        return this.postProcess(expr, ts.createIdentifier(METHOD_THIS_NAME));\n-      case BuiltinVar.CatchError:\n-        return this.postProcess(expr, ts.createIdentifier(CATCH_ERROR_NAME));\n-      case BuiltinVar.CatchStack:\n-        return this.postProcess(expr, ts.createIdentifier(CATCH_STACK_NAME));\n-      case BuiltinVar.Super:\n-        return this.postProcess(expr, ts.createSuper());\n-    }\n-    if (expr.name) {\n-      return this.postProcess(expr, ts.createIdentifier(expr.name));\n-    }\n-    throw Error(`Unexpected ReadVarExpr form`);\n-  }\n-\n-  visitWriteVarExpr(expr: WriteVarExpr): RecordedNode<ts.BinaryExpression> {\n-    return this.postProcess(\n-        expr,\n-        ts.createAssignment(\n-            ts.createIdentifier(expr.name), expr.value.visitExpression(this, null)));\n-  }\n-\n-  visitWriteKeyExpr(expr: WriteKeyExpr): RecordedNode<ts.BinaryExpression> {\n-    return this.postProcess(\n-        expr,\n-        ts.createAssignment(\n-            ts.createElementAccess(\n-                expr.receiver.visitExpression(this, null), expr.index.visitExpression(this, null)),\n-            expr.value.visitExpression(this, null)));\n-  }\n-\n-  visitWritePropExpr(expr: WritePropExpr): RecordedNode<ts.BinaryExpression> {\n-    return this.postProcess(\n-        expr,\n-        ts.createAssignment(\n-            ts.createPropertyAccess(expr.receiver.visitExpression(this, null), expr.name),\n-            expr.value.visitExpression(this, null)));\n-  }\n-\n-  visitInvokeFunctionExpr(expr: InvokeFunctionExpr): RecordedNode<ts.CallExpression> {\n-    return this.postProcess(\n-        expr,\n-        ts.createCall(\n-            expr.fn.visitExpression(this, null), /* typeArguments */ undefined,\n-            expr.args.map(arg => arg.visitExpression(this, null))));\n-  }\n-\n-  visitTaggedTemplateExpr(expr: TaggedTemplateExpr): RecordedNode<ts.TaggedTemplateExpression> {\n-    throw new Error('tagged templates are not supported in pre-ivy mode.');\n-  }\n-\n-  visitInstantiateExpr(expr: InstantiateExpr): RecordedNode<ts.NewExpression> {\n-    return this.postProcess(\n-        expr,\n-        ts.createNew(\n-            expr.classExpr.visitExpression(this, null), /* typeArguments */ undefined,\n-            expr.args.map(arg => arg.visitExpression(this, null))));\n-  }\n-\n-  visitLiteralExpr(expr: LiteralExpr) {\n-    return this.postProcess(expr, createLiteral(expr.value));\n-  }\n-\n-  visitLocalizedString(expr: LocalizedString, context: any) {\n-    throw new Error('localized strings are not supported in pre-ivy mode.');\n-  }\n-\n-  visitExternalExpr(expr: ExternalExpr) {\n-    return this.postProcess(expr, this._visitIdentifier(expr.value));\n-  }\n-\n-  visitConditionalExpr(expr: ConditionalExpr): RecordedNode<ts.ParenthesizedExpression> {\n-    // TODO {chuckj}: Review use of ! on falseCase. Should it be non-nullable?\n-    return this.postProcess(\n-        expr,\n-        ts.createParen(ts.createConditional(\n-            expr.condition.visitExpression(this, null), expr.trueCase.visitExpression(this, null),\n-            expr.falseCase!.visitExpression(this, null))));\n-  }\n-\n-  visitNotExpr(expr: NotExpr): RecordedNode<ts.PrefixUnaryExpression> {\n-    return this.postProcess(\n-        expr,\n-        ts.createPrefix(\n-            ts.SyntaxKind.ExclamationToken, expr.condition.visitExpression(this, null)));\n-  }\n-\n-  visitAssertNotNullExpr(expr: AssertNotNull): RecordedNode<ts.Expression> {\n-    return expr.condition.visitExpression(this, null);\n-  }\n-\n-  visitCastExpr(expr: CastExpr): RecordedNode<ts.Expression> {\n-    return expr.value.visitExpression(this, null);\n-  }\n-\n-  visitFunctionExpr(expr: FunctionExpr) {\n-    return this.postProcess(\n-        expr,\n-        ts.createFunctionExpression(\n-            /* modifiers */ undefined, /* astriskToken */ undefined,\n-            /* name */ expr.name || undefined,\n-            /* typeParameters */ undefined,\n-            expr.params.map(\n-                p => ts.createParameter(\n-                    /* decorators */ undefined, /* modifiers */ undefined,\n-                    /* dotDotDotToken */ undefined, p.name)),\n-            /* type */ undefined, this._visitStatements(expr.statements)));\n-  }\n-\n-  visitUnaryOperatorExpr(expr: UnaryOperatorExpr):\n-      RecordedNode<ts.UnaryExpression|ts.ParenthesizedExpression> {\n-    let unaryOperator: ts.BinaryOperator;\n-    switch (expr.operator) {\n-      case UnaryOperator.Minus:\n-        unaryOperator = ts.SyntaxKind.MinusToken;\n-        break;\n-      case UnaryOperator.Plus:\n-        unaryOperator = ts.SyntaxKind.PlusToken;\n-        break;\n-      default:\n-        throw new Error(`Unknown operator: ${expr.operator}`);\n-    }\n-    const binary = ts.createPrefix(unaryOperator, expr.expr.visitExpression(this, null));\n-    return this.postProcess(expr, expr.parens ? ts.createParen(binary) : binary);\n-  }\n-\n-  visitBinaryOperatorExpr(expr: BinaryOperatorExpr):\n-      RecordedNode<ts.BinaryExpression|ts.ParenthesizedExpression> {\n-    let binaryOperator: ts.BinaryOperator;\n-    switch (expr.operator) {\n-      case BinaryOperator.And:\n-        binaryOperator = ts.SyntaxKind.AmpersandAmpersandToken;\n-        break;\n-      case BinaryOperator.BitwiseAnd:\n-        binaryOperator = ts.SyntaxKind.AmpersandToken;\n-        break;\n-      case BinaryOperator.Bigger:\n-        binaryOperator = ts.SyntaxKind.GreaterThanToken;\n-        break;\n-      case BinaryOperator.BiggerEquals:\n-        binaryOperator = ts.SyntaxKind.GreaterThanEqualsToken;\n-        break;\n-      case BinaryOperator.Divide:\n-        binaryOperator = ts.SyntaxKind.SlashToken;\n-        break;\n-      case BinaryOperator.Equals:\n-        binaryOperator = ts.SyntaxKind.EqualsEqualsToken;\n-        break;\n-      case BinaryOperator.Identical:\n-        binaryOperator = ts.SyntaxKind.EqualsEqualsEqualsToken;\n-        break;\n-      case BinaryOperator.Lower:\n-        binaryOperator = ts.SyntaxKind.LessThanToken;\n-        break;\n-      case BinaryOperator.LowerEquals:\n-        binaryOperator = ts.SyntaxKind.LessThanEqualsToken;\n-        break;\n-      case BinaryOperator.Minus:\n-        binaryOperator = ts.SyntaxKind.MinusToken;\n-        break;\n-      case BinaryOperator.Modulo:\n-        binaryOperator = ts.SyntaxKind.PercentToken;\n-        break;\n-      case BinaryOperator.Multiply:\n-        binaryOperator = ts.SyntaxKind.AsteriskToken;\n-        break;\n-      case BinaryOperator.NotEquals:\n-        binaryOperator = ts.SyntaxKind.ExclamationEqualsToken;\n-        break;\n-      case BinaryOperator.NotIdentical:\n-        binaryOperator = ts.SyntaxKind.ExclamationEqualsEqualsToken;\n-        break;\n-      case BinaryOperator.Or:\n-        binaryOperator = ts.SyntaxKind.BarBarToken;\n-        break;\n-      case BinaryOperator.NullishCoalesce:\n-        binaryOperator = ts.SyntaxKind.QuestionQuestionToken;\n-        break;\n-      case BinaryOperator.Plus:\n-        binaryOperator = ts.SyntaxKind.PlusToken;\n-        break;\n-      default:\n-        throw new Error(`Unknown operator: ${expr.operator}`);\n-    }\n-    const binary = ts.createBinary(\n-        expr.lhs.visitExpression(this, null), binaryOperator, expr.rhs.visitExpression(this, null));\n-    return this.postProcess(expr, expr.parens ? ts.createParen(binary) : binary);\n-  }\n-\n-  visitReadPropExpr(expr: ReadPropExpr): RecordedNode<ts.PropertyAccessExpression> {\n-    return this.postProcess(\n-        expr, ts.createPropertyAccess(expr.receiver.visitExpression(this, null), expr.name));\n-  }\n-\n-  visitReadKeyExpr(expr: ReadKeyExpr): RecordedNode<ts.ElementAccessExpression> {\n-    return this.postProcess(\n-        expr,\n-        ts.createElementAccess(\n-            expr.receiver.visitExpression(this, null), expr.index.visitExpression(this, null)));\n-  }\n-\n-  visitLiteralArrayExpr(expr: LiteralArrayExpr): RecordedNode<ts.ArrayLiteralExpression> {\n-    return this.postProcess(\n-        expr, ts.createArrayLiteral(expr.entries.map(entry => entry.visitExpression(this, null))));\n-  }\n-\n-  visitLiteralMapExpr(expr: LiteralMapExpr): RecordedNode<ts.ObjectLiteralExpression> {\n-    return this.postProcess(\n-        expr,\n-        ts.createObjectLiteral(expr.entries.map(\n-            entry => ts.createPropertyAssignment(\n-                entry.quoted || !_VALID_IDENTIFIER_RE.test(entry.key) ?\n-                    ts.createLiteral(entry.key) :\n-                    entry.key,\n-                entry.value.visitExpression(this, null)))));\n-  }\n-\n-  visitCommaExpr(expr: CommaExpr): RecordedNode<ts.Expression> {\n-    return this.postProcess(\n-        expr,\n-        expr.parts.map(e => e.visitExpression(this, null))\n-            .reduce<ts.Expression|null>(\n-                (left, right) =>\n-                    left ? ts.createBinary(left, ts.SyntaxKind.CommaToken, right) : right,\n-                null));\n-  }\n-\n-  private _visitStatements(statements: Statement[]): ts.Block {\n-    return this._visitStatementsPrefix([], statements);\n-  }\n-\n-  private _visitStatementsPrefix(prefix: ts.Statement[], statements: Statement[]) {\n-    return ts.createBlock([\n-      ...prefix, ...statements.map(stmt => stmt.visitStatement(this, null)).filter(f => f != null)\n-    ]);\n-  }\n-\n-  private _visitIdentifier(value: ExternalReference): ts.Expression {\n-    // name can only be null during JIT which never executes this code.\n-    const moduleName = value.moduleName, name = value.name!;\n-    let prefixIdent: ts.Identifier|null = null;\n-    if (moduleName) {\n-      let prefix = this._importsWithPrefixes.get(moduleName);\n-      if (prefix == null) {\n-        prefix = `i${this._importsWithPrefixes.size}`;\n-        this._importsWithPrefixes.set(moduleName, prefix);\n-      }\n-      prefixIdent = ts.createIdentifier(prefix);\n-    }\n-    if (prefixIdent) {\n-      return ts.createPropertyAccess(prefixIdent, name);\n-    } else {\n-      const id = ts.createIdentifier(name);\n-      if (this._exportedVariableIdentifiers.has(name)) {\n-        // In order for this new identifier node to be properly rewritten in CommonJS output,\n-        // it must have its original node set to a parsed instance of the same identifier.\n-        ts.setOriginalNode(id, this._exportedVariableIdentifiers.get(name));\n-      }\n-      return id;\n-    }\n-  }\n-}\n-\n-function modifierFromModifier(modifier: StmtModifier): ts.Modifier {\n-  switch (modifier) {\n-    case StmtModifier.Exported:\n-      return ts.createToken(ts.SyntaxKind.ExportKeyword);\n-    case StmtModifier.Final:\n-      return ts.createToken(ts.SyntaxKind.ConstKeyword);\n-    case StmtModifier.Private:\n-      return ts.createToken(ts.SyntaxKind.PrivateKeyword);\n-    case StmtModifier.Static:\n-      return ts.createToken(ts.SyntaxKind.StaticKeyword);\n-  }\n-}\n-\n-function translateModifiers(modifiers: StmtModifier[]|null): ts.Modifier[]|undefined {\n-  return modifiers == null ? undefined : modifiers!.map(modifierFromModifier);\n-}"
        },
        {
            "sha": "41bc9a782a4b8738ef4d2af2c8f28f0b5dcb70b1",
            "filename": "packages/compiler-cli/src/transformers/node_emitter_transform.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 80,
            "changes": 80,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fnode_emitter_transform.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fnode_emitter_transform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fnode_emitter_transform.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,80 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {GeneratedFile} from '@angular/compiler';\n-import ts from 'typescript';\n-\n-import {TypeScriptNodeEmitter} from './node_emitter';\n-import {GENERATED_FILES, stripComment} from './util';\n-\n-function getPreamble(original: string) {\n-  return `*\n- * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n- * ${original}\n- * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes,extraRequire}\n- * tslint:disable\n- `;\n-}\n-\n-/**\n- * Returns a transformer that does two things for generated files (ngfactory etc):\n- * - adds a fileoverview JSDoc comment containing Closure Compiler specific \"suppress\"ions in JSDoc.\n- *   The new comment will contain any fileoverview comment text from the original source file this\n- *   file was generated from.\n- * - updates generated files that are not in the given map of generatedFiles to have an empty\n- *   list of statements as their body.\n- */\n-export function getAngularEmitterTransformFactory(\n-    generatedFiles: Map<string, GeneratedFile>, program: ts.Program,\n-    annotateForClosureCompiler: boolean): () => (sourceFile: ts.SourceFile) => ts.SourceFile {\n-  return function() {\n-    const emitter = new TypeScriptNodeEmitter(annotateForClosureCompiler);\n-    return function(sourceFile: ts.SourceFile): ts.SourceFile {\n-      const g = generatedFiles.get(sourceFile.fileName);\n-      const orig = g && program.getSourceFile(g.srcFileUrl);\n-      let originalComment = '';\n-      if (orig) originalComment = getFileoverviewComment(orig);\n-      const preamble = getPreamble(originalComment);\n-      if (g && g.stmts) {\n-        const [newSourceFile] = emitter.updateSourceFile(sourceFile, g.stmts, preamble);\n-        return newSourceFile;\n-      } else if (GENERATED_FILES.test(sourceFile.fileName)) {\n-        // The file should be empty, but emitter.updateSourceFile would still add imports\n-        // and various minutiae.\n-        // Clear out the source file entirely, only including the preamble comment, so that\n-        // ngc produces an empty .js file.\n-        const commentStmt = ts.createNotEmittedStatement(sourceFile);\n-        ts.addSyntheticLeadingComment(\n-            commentStmt, ts.SyntaxKind.MultiLineCommentTrivia, preamble,\n-            /* hasTrailingNewline */ true);\n-        return ts.updateSourceFileNode(sourceFile, [commentStmt]);\n-      }\n-      return sourceFile;\n-    };\n-  };\n-}\n-\n-/**\n- * Parses and returns the comment text (without start and end markers) of a \\@fileoverview comment\n- * in the given source file. Returns the empty string if no such comment can be found.\n- */\n-function getFileoverviewComment(sourceFile: ts.SourceFile): string {\n-  const trivia = sourceFile.getFullText().substring(0, sourceFile.getStart());\n-  const leadingComments = ts.getLeadingCommentRanges(trivia, 0);\n-  if (!leadingComments || leadingComments.length === 0) return '';\n-  const comment = leadingComments[0];\n-  if (comment.kind !== ts.SyntaxKind.MultiLineCommentTrivia) return '';\n-  // Only comments separated with a \\n\\n from the file contents are considered file-level comments\n-  // in TypeScript.\n-  if (sourceFile.getFullText().substring(comment.end, comment.end + 2) !== '\\n\\n') return '';\n-  const commentText = sourceFile.getFullText().substring(comment.pos, comment.end);\n-  // Closure Compiler ignores @suppress and similar if the comment contains @license.\n-  if (commentText.indexOf('@license') !== -1) return '';\n-  // Also remove any leading `* ` from the first line in case it was a JSDOC comment\n-  return stripComment(commentText).replace(/^\\*\\s+/, '');\n-}"
        },
        {
            "sha": "8c546a81c77fd7fc0edc7c157e112e5f7702de42",
            "filename": "packages/compiler-cli/src/transformers/program.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1049,
            "changes": 1051,
            "blob_url": "https://github.com/angular/angular/blob/192203278647bae1864db2a5109efaae1bba53c4/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fprogram.ts",
            "raw_url": "https://github.com/angular/angular/raw/192203278647bae1864db2a5109efaae1bba53c4/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fprogram.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fprogram.ts?ref=192203278647bae1864db2a5109efaae1bba53c4",
            "patch": "@@ -7,36 +7,9 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AotCompiler, AotCompilerOptions, core, createAotCompiler, FormattedMessageChain, GeneratedFile, getMissingNgModuleMetadataErrorData, getParseErrors, isFormattedError, isSyntaxError, MessageBundle, NgAnalyzedFileWithInjectables, NgAnalyzedModules, ParseSourceSpan, PartialModule} from '@angular/compiler';\n-import * as fs from 'fs';\n-import * as path from 'path';\n-import ts from 'typescript';\n-\n-import {translateDiagnostics} from '../diagnostics/translate_diagnostics';\n-import {createBundleIndexHost, MetadataCollector} from '../metadata';\n-import {isAngularCorePackage} from '../ngtsc/core/src/compiler';\n import {NgtscProgram} from '../ngtsc/program';\n-import {TypeScriptReflectionHost} from '../ngtsc/reflection';\n-import {verifySupportedTypeScriptVersion} from '../typescript_support';\n-\n-import {CompilerHost, CompilerOptions, CustomTransformers, DEFAULT_ERROR_CODE, Diagnostic, DiagnosticMessageChain, EmitFlags, LazyRoute, LibrarySummary, Program, SOURCE, TsEmitCallback, TsMergeEmitResultsCallback} from './api';\n-import {CodeGenerator, getOriginalReferences, TsCompilerAotCompilerTypeCheckHostAdapter} from './compiler_host';\n-import {getDownlevelDecoratorsTransform} from './downlevel_decorators_transform/index';\n-import {i18nExtract} from './i18n';\n-import {getInlineResourcesTransformFactory, InlineResourcesMetadataTransformer} from './inline_resources';\n-import {getExpressionLoweringTransformFactory, LowerMetadataTransform} from './lower_expressions';\n-import {MetadataCache, MetadataTransformer} from './metadata_cache';\n-import {getAngularEmitterTransformFactory} from './node_emitter_transform';\n-import {PartialModuleMetadataTransformer} from './r3_metadata_transform';\n-import {getAngularClassTransformerFactory} from './r3_transform';\n-import {createMessageDiagnostic, DTS, GENERATED_FILES, isInRootDir, ngToTsDiagnostic, StructureIsReused, TS, tsStructureIsReused} from './util';\n-\n \n-/**\n- * Maximum number of files that are emitable via calling ts.Program.emit\n- * passing individual targetSourceFiles.\n- */\n-const MAX_FILE_COUNT_FOR_SINGLE_FILE_EMIT = 20;\n+import {CompilerHost, CompilerOptions, Program} from './api';\n \n /** Error message to show when attempting to build View Engine. */\n const VE_DISABLED_MESSAGE = `\n@@ -45,781 +18,6 @@ and is being removed. Please upgrade to the Ivy compiler by switching to \\`Ngtsc\n https://angular.io/guide/ivy for more information.\n `.trim().split('\\n').join(' ');\n \n-/**\n- * Fields to lower within metadata in render2 mode.\n- */\n-const LOWER_FIELDS = ['useValue', 'useFactory', 'data', 'id', 'loadChildren'];\n-\n-/**\n- * Fields to lower within metadata in render3 mode.\n- */\n-const R3_LOWER_FIELDS = [...LOWER_FIELDS, 'providers', 'imports', 'exports'];\n-\n-/**\n- * Installs a handler for testing purposes to allow inspection of the temporary program.\n- */\n-let tempProgramHandlerForTest: ((program: ts.Program) => void)|null = null;\n-export function setTempProgramHandlerForTest(handler: (program: ts.Program) => void): void {\n-  tempProgramHandlerForTest = handler;\n-}\n-export function resetTempProgramHandlerForTest(): void {\n-  tempProgramHandlerForTest = null;\n-}\n-\n-const emptyModules: NgAnalyzedModules = {\n-  ngModules: [],\n-  ngModuleByPipeOrDirective: new Map(),\n-  files: []\n-};\n-\n-const defaultEmitCallback: TsEmitCallback = ({\n-  program,\n-  targetSourceFile,\n-  writeFile,\n-  cancellationToken,\n-  emitOnlyDtsFiles,\n-  customTransformers\n-}) =>\n-    program.emit(\n-        targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers);\n-\n-class AngularCompilerProgram implements Program {\n-  private rootNames: string[];\n-  private metadataCache: MetadataCache;\n-  // Metadata cache used exclusively for the flat module index\n-  // TODO(issue/24571): remove '!'.\n-  private flatModuleMetadataCache!: MetadataCache;\n-  private loweringMetadataTransform: LowerMetadataTransform;\n-  private oldProgramLibrarySummaries: Map<string, LibrarySummary>|undefined;\n-  private oldProgramEmittedGeneratedFiles: Map<string, GeneratedFile>|undefined;\n-  private oldProgramEmittedSourceFiles: Map<string, ts.SourceFile>|undefined;\n-  // Note: This will be cleared out as soon as we create the _tsProgram\n-  private oldTsProgram: ts.Program|undefined;\n-  private emittedLibrarySummaries: LibrarySummary[]|undefined;\n-  private emittedGeneratedFiles: GeneratedFile[]|undefined;\n-  private emittedSourceFiles: ts.SourceFile[]|undefined;\n-\n-  // Lazily initialized fields\n-  // TODO(issue/24571): remove '!'.\n-  private _compiler!: AotCompiler;\n-  // TODO(issue/24571): remove '!'.\n-  private _hostAdapter!: TsCompilerAotCompilerTypeCheckHostAdapter;\n-  // TODO(issue/24571): remove '!'.\n-  private _tsProgram!: ts.Program;\n-  private _analyzedModules: NgAnalyzedModules|undefined;\n-  private _analyzedInjectables: NgAnalyzedFileWithInjectables[]|undefined;\n-  private _structuralDiagnostics: Diagnostic[]|undefined;\n-  private _programWithStubs: ts.Program|undefined;\n-  private _optionsDiagnostics: Diagnostic[] = [];\n-  private _transformTsDiagnostics: ts.Diagnostic[] = [];\n-\n-  constructor(\n-      rootNames: ReadonlyArray<string>, private options: CompilerOptions,\n-      private host: CompilerHost, oldProgram?: Program) {\n-    if (true as boolean) {\n-      throw new Error(VE_DISABLED_MESSAGE);\n-    }\n-\n-    this.rootNames = [...rootNames];\n-\n-    if (!options.disableTypeScriptVersionCheck) {\n-      verifySupportedTypeScriptVersion();\n-    }\n-\n-    this.oldTsProgram = oldProgram ? oldProgram.getTsProgram() : undefined;\n-    if (oldProgram) {\n-      this.oldProgramLibrarySummaries = oldProgram.getLibrarySummaries();\n-      this.oldProgramEmittedGeneratedFiles = oldProgram.getEmittedGeneratedFiles();\n-      this.oldProgramEmittedSourceFiles = oldProgram.getEmittedSourceFiles();\n-    }\n-\n-    if (options.flatModuleOutFile) {\n-      const {host: bundleHost, indexName, errors} =\n-          createBundleIndexHost(options, this.rootNames, host, () => this.flatModuleMetadataCache);\n-      if (errors) {\n-        this._optionsDiagnostics.push(...errors.map(e => ({\n-                                                      category: e.category,\n-                                                      messageText: e.messageText as string,\n-                                                      source: SOURCE,\n-                                                      code: DEFAULT_ERROR_CODE\n-                                                    })));\n-      } else {\n-        this.rootNames.push(indexName!);\n-        this.host = bundleHost;\n-      }\n-    }\n-\n-    this.loweringMetadataTransform =\n-        new LowerMetadataTransform(options.enableIvy !== false ? R3_LOWER_FIELDS : LOWER_FIELDS);\n-    this.metadataCache = this.createMetadataCache([this.loweringMetadataTransform]);\n-  }\n-\n-  private createMetadataCache(transformers: MetadataTransformer[]) {\n-    return new MetadataCache(\n-        new MetadataCollector({quotedNames: true}), !!this.options.strictMetadataEmit,\n-        transformers);\n-  }\n-\n-  getLibrarySummaries(): Map<string, LibrarySummary> {\n-    const result = new Map<string, LibrarySummary>();\n-    if (this.oldProgramLibrarySummaries) {\n-      this.oldProgramLibrarySummaries.forEach((summary, fileName) => result.set(fileName, summary));\n-    }\n-    if (this.emittedLibrarySummaries) {\n-      this.emittedLibrarySummaries.forEach(\n-          (summary, fileName) => result.set(summary.fileName, summary));\n-    }\n-    return result;\n-  }\n-\n-  getEmittedGeneratedFiles(): Map<string, GeneratedFile> {\n-    const result = new Map<string, GeneratedFile>();\n-    if (this.oldProgramEmittedGeneratedFiles) {\n-      this.oldProgramEmittedGeneratedFiles.forEach(\n-          (genFile, fileName) => result.set(fileName, genFile));\n-    }\n-    if (this.emittedGeneratedFiles) {\n-      this.emittedGeneratedFiles.forEach((genFile) => result.set(genFile.genFileUrl, genFile));\n-    }\n-    return result;\n-  }\n-\n-  getEmittedSourceFiles(): Map<string, ts.SourceFile> {\n-    const result = new Map<string, ts.SourceFile>();\n-    if (this.oldProgramEmittedSourceFiles) {\n-      this.oldProgramEmittedSourceFiles.forEach((sf, fileName) => result.set(fileName, sf));\n-    }\n-    if (this.emittedSourceFiles) {\n-      this.emittedSourceFiles.forEach((sf) => result.set(sf.fileName, sf));\n-    }\n-    return result;\n-  }\n-\n-  getTsProgram(): ts.Program {\n-    return this.tsProgram;\n-  }\n-\n-  getTsOptionDiagnostics(cancellationToken?: ts.CancellationToken) {\n-    return this.tsProgram.getOptionsDiagnostics(cancellationToken);\n-  }\n-\n-  getNgOptionDiagnostics(cancellationToken?: ts.CancellationToken): ReadonlyArray<Diagnostic> {\n-    return [...this._optionsDiagnostics, ...getNgOptionDiagnostics(this.options)];\n-  }\n-\n-  getTsSyntacticDiagnostics(sourceFile?: ts.SourceFile, cancellationToken?: ts.CancellationToken):\n-      ReadonlyArray<ts.Diagnostic> {\n-    return this.tsProgram.getSyntacticDiagnostics(sourceFile, cancellationToken);\n-  }\n-\n-  getNgStructuralDiagnostics(cancellationToken?: ts.CancellationToken): ReadonlyArray<Diagnostic> {\n-    return this.structuralDiagnostics;\n-  }\n-\n-  getTsSemanticDiagnostics(sourceFile?: ts.SourceFile, cancellationToken?: ts.CancellationToken):\n-      ReadonlyArray<ts.Diagnostic> {\n-    const sourceFiles = sourceFile ? [sourceFile] : this.tsProgram.getSourceFiles();\n-    let diags: ts.Diagnostic[] = [];\n-    sourceFiles.forEach(sf => {\n-      if (!GENERATED_FILES.test(sf.fileName)) {\n-        diags.push(...this.tsProgram.getSemanticDiagnostics(sf, cancellationToken));\n-      }\n-    });\n-    return diags;\n-  }\n-\n-  getNgSemanticDiagnostics(fileName?: string, cancellationToken?: ts.CancellationToken):\n-      ReadonlyArray<Diagnostic> {\n-    let diags: ts.Diagnostic[] = [];\n-    this.tsProgram.getSourceFiles().forEach(sf => {\n-      if (GENERATED_FILES.test(sf.fileName) && !sf.isDeclarationFile) {\n-        diags.push(...this.tsProgram.getSemanticDiagnostics(sf, cancellationToken));\n-      }\n-    });\n-    const {ng} = translateDiagnostics(this.hostAdapter, diags);\n-    return ng;\n-  }\n-\n-  loadNgStructureAsync(): Promise<void> {\n-    if (this._analyzedModules) {\n-      throw new Error('Angular structure already loaded');\n-    }\n-    return Promise.resolve()\n-        .then(() => {\n-          const {tmpProgram, sourceFiles, tsFiles, rootNames} = this._createProgramWithBasicStubs();\n-          return this.compiler.loadFilesAsync(sourceFiles, tsFiles)\n-              .then(({analyzedModules, analyzedInjectables}) => {\n-                if (this._analyzedModules) {\n-                  throw new Error('Angular structure loaded both synchronously and asynchronously');\n-                }\n-                this._updateProgramWithTypeCheckStubs(\n-                    tmpProgram, analyzedModules, analyzedInjectables, rootNames);\n-              });\n-        })\n-        .catch(e => this._createProgramOnError(e));\n-  }\n-\n-  listLazyRoutes(route?: string): LazyRoute[] {\n-    return [];\n-  }\n-\n-  emit(parameters: {\n-    emitFlags?: EmitFlags,\n-    cancellationToken?: ts.CancellationToken,\n-    customTransformers?: CustomTransformers,\n-    emitCallback?: TsEmitCallback,\n-    mergeEmitResultsCallback?: TsMergeEmitResultsCallback,\n-  } = {}): ts.EmitResult {\n-    if (this.options.enableIvy !== false) {\n-      throw new Error('Cannot run legacy compiler in ngtsc mode');\n-    }\n-    return this._emitRender2(parameters);\n-  }\n-\n-  private _emitRender2({\n-    emitFlags = EmitFlags.Default,\n-    cancellationToken,\n-    customTransformers,\n-    emitCallback = defaultEmitCallback,\n-    mergeEmitResultsCallback = mergeEmitResults,\n-  }: {\n-    emitFlags?: EmitFlags,\n-    cancellationToken?: ts.CancellationToken,\n-    customTransformers?: CustomTransformers,\n-    emitCallback?: TsEmitCallback,\n-    mergeEmitResultsCallback?: TsMergeEmitResultsCallback,\n-  } = {}): ts.EmitResult {\n-    const emitStart = Date.now();\n-    if (emitFlags & EmitFlags.I18nBundle) {\n-      const locale = this.options.i18nOutLocale || null;\n-      const file = this.options.i18nOutFile || null;\n-      const format = this.options.i18nOutFormat || null;\n-      const bundle = this.compiler.emitMessageBundle(this.analyzedModules, locale);\n-      i18nExtract(format, file, this.host, this.options, bundle);\n-    }\n-    if ((emitFlags & (EmitFlags.JS | EmitFlags.DTS | EmitFlags.Metadata | EmitFlags.Codegen)) ===\n-        0) {\n-      return {emitSkipped: true, diagnostics: [], emittedFiles: []};\n-    }\n-    let {genFiles, genDiags} = this.generateFilesForEmit(emitFlags);\n-    if (genDiags.length) {\n-      return {\n-        diagnostics: genDiags,\n-        emitSkipped: true,\n-        emittedFiles: [],\n-      };\n-    }\n-    this.emittedGeneratedFiles = genFiles;\n-    const outSrcMapping: Array<{sourceFile: ts.SourceFile, outFileName: string}> = [];\n-    const genFileByFileName = new Map<string, GeneratedFile>();\n-    genFiles.forEach(genFile => genFileByFileName.set(genFile.genFileUrl, genFile));\n-    this.emittedLibrarySummaries = [];\n-    this._transformTsDiagnostics = [];\n-    const emittedSourceFiles = [] as ts.SourceFile[];\n-    const writeTsFile: ts.WriteFileCallback =\n-        (outFileName, outData, writeByteOrderMark, onError?, sourceFiles?) => {\n-          const sourceFile = sourceFiles && sourceFiles.length == 1 ? sourceFiles[0] : null;\n-          let genFile: GeneratedFile|undefined;\n-          if (sourceFile) {\n-            outSrcMapping.push({outFileName: outFileName, sourceFile});\n-            genFile = genFileByFileName.get(sourceFile.fileName);\n-            if (!sourceFile.isDeclarationFile && !GENERATED_FILES.test(sourceFile.fileName)) {\n-              // Note: sourceFile is the transformed sourcefile, not the original one!\n-              const originalFile = this.tsProgram.getSourceFile(sourceFile.fileName);\n-              if (originalFile) {\n-                emittedSourceFiles.push(originalFile);\n-              }\n-            }\n-          }\n-          this.writeFile(outFileName, outData, writeByteOrderMark, onError, genFile, sourceFiles);\n-        };\n-\n-    const modules = this._analyzedInjectables &&\n-        this.compiler.emitAllPartialModules2(this._analyzedInjectables);\n-\n-    const tsCustomTransformers =\n-        this.calculateTransforms(genFileByFileName, modules, customTransformers);\n-    const emitOnlyDtsFiles = (emitFlags & (EmitFlags.DTS | EmitFlags.JS)) == EmitFlags.DTS;\n-    // Restore the original references before we emit so TypeScript doesn't emit\n-    // a reference to the .d.ts file.\n-    const augmentedReferences = new Map<ts.SourceFile, ReadonlyArray<ts.FileReference>>();\n-    for (const sourceFile of this.tsProgram.getSourceFiles()) {\n-      const originalReferences = getOriginalReferences(sourceFile);\n-      if (originalReferences) {\n-        augmentedReferences.set(sourceFile, sourceFile.referencedFiles);\n-        sourceFile.referencedFiles = originalReferences;\n-      }\n-    }\n-    const genTsFiles: GeneratedFile[] = [];\n-    const genJsonFiles: GeneratedFile[] = [];\n-    genFiles.forEach(gf => {\n-      if (gf.stmts) {\n-        genTsFiles.push(gf);\n-      }\n-      if (gf.source) {\n-        genJsonFiles.push(gf);\n-      }\n-    });\n-    let emitResult: ts.EmitResult;\n-    let emittedUserTsCount: number;\n-    try {\n-      const sourceFilesToEmit = this.getSourceFilesForEmit();\n-      if (sourceFilesToEmit &&\n-          (sourceFilesToEmit.length + genTsFiles.length) < MAX_FILE_COUNT_FOR_SINGLE_FILE_EMIT) {\n-        const fileNamesToEmit =\n-            [...sourceFilesToEmit.map(sf => sf.fileName), ...genTsFiles.map(gf => gf.genFileUrl)];\n-        emitResult = mergeEmitResultsCallback(\n-            fileNamesToEmit.map((fileName) => emitResult = emitCallback({\n-                                  program: this.tsProgram,\n-                                  host: this.host,\n-                                  options: this.options,\n-                                  writeFile: writeTsFile,\n-                                  emitOnlyDtsFiles,\n-                                  customTransformers: tsCustomTransformers,\n-                                  targetSourceFile: this.tsProgram.getSourceFile(fileName),\n-                                })));\n-        emittedUserTsCount = sourceFilesToEmit.length;\n-      } else {\n-        emitResult = emitCallback({\n-          program: this.tsProgram,\n-          host: this.host,\n-          options: this.options,\n-          writeFile: writeTsFile,\n-          emitOnlyDtsFiles,\n-          customTransformers: tsCustomTransformers\n-        });\n-        emittedUserTsCount = this.tsProgram.getSourceFiles().length - genTsFiles.length;\n-      }\n-    } finally {\n-      // Restore the references back to the augmented value to ensure that the\n-      // checks that TypeScript makes for project structure reuse will succeed.\n-      for (const [sourceFile, references] of Array.from(augmentedReferences)) {\n-        // TODO(chuckj): Remove any cast after updating build to 2.6\n-        (sourceFile as any).referencedFiles = references;\n-      }\n-    }\n-    this.emittedSourceFiles = emittedSourceFiles;\n-\n-    // Match behavior of tsc: only produce emit diagnostics if it would block\n-    // emit. If noEmitOnError is false, the emit will happen in spite of any\n-    // errors, so we should not report them.\n-    if (emitResult && this.options.noEmitOnError === true) {\n-      // translate the diagnostics in the emitResult as well.\n-      const translatedEmitDiags = translateDiagnostics(this.hostAdapter, emitResult.diagnostics);\n-      emitResult.diagnostics = translatedEmitDiags.ts.concat(\n-          this.structuralDiagnostics.concat(translatedEmitDiags.ng).map(ngToTsDiagnostic));\n-    }\n-\n-    if (emitResult && !outSrcMapping.length) {\n-      // if no files were emitted by TypeScript, also don't emit .json files\n-      emitResult.diagnostics =\n-          emitResult.diagnostics.concat([createMessageDiagnostic(`Emitted no files.`)]);\n-      return emitResult;\n-    }\n-\n-    let sampleSrcFileName: string|undefined;\n-    let sampleOutFileName: string|undefined;\n-    if (outSrcMapping.length) {\n-      sampleSrcFileName = outSrcMapping[0].sourceFile.fileName;\n-      sampleOutFileName = outSrcMapping[0].outFileName;\n-    }\n-    const srcToOutPath =\n-        createSrcToOutPathMapper(this.options.outDir, sampleSrcFileName, sampleOutFileName);\n-    if (emitFlags & EmitFlags.Codegen) {\n-      genJsonFiles.forEach(gf => {\n-        const outFileName = srcToOutPath(gf.genFileUrl);\n-        this.writeFile(outFileName, gf.source!, false, undefined, gf);\n-      });\n-    }\n-    let metadataJsonCount = 0;\n-    if (emitFlags & EmitFlags.Metadata) {\n-      this.tsProgram.getSourceFiles().forEach(sf => {\n-        if (!sf.isDeclarationFile && !GENERATED_FILES.test(sf.fileName)) {\n-          metadataJsonCount++;\n-          const metadata = this.metadataCache.getMetadata(sf);\n-          if (metadata) {\n-            const metadataText = JSON.stringify([metadata]);\n-            const outFileName = srcToOutPath(sf.fileName.replace(/\\.tsx?$/, '.metadata.json'));\n-            this.writeFile(outFileName, metadataText, false, undefined, undefined, [sf]);\n-          }\n-        }\n-      });\n-    }\n-    const emitEnd = Date.now();\n-    if (emitResult && this.options.diagnostics) {\n-      emitResult.diagnostics = emitResult.diagnostics.concat([createMessageDiagnostic([\n-        `Emitted in ${emitEnd - emitStart}ms`,\n-        `- ${emittedUserTsCount} user ts files`,\n-        `- ${genTsFiles.length} generated ts files`,\n-        `- ${genJsonFiles.length + metadataJsonCount} generated json files`,\n-      ].join('\\n'))]);\n-    }\n-\n-    return emitResult;\n-  }\n-\n-  // Private members\n-  private get compiler(): AotCompiler {\n-    if (!this._compiler) {\n-      this._createCompiler();\n-    }\n-    return this._compiler!;\n-  }\n-\n-  private get hostAdapter(): TsCompilerAotCompilerTypeCheckHostAdapter {\n-    if (!this._hostAdapter) {\n-      this._createCompiler();\n-    }\n-    return this._hostAdapter!;\n-  }\n-\n-  private get analyzedModules(): NgAnalyzedModules {\n-    if (!this._analyzedModules) {\n-      this.initSync();\n-    }\n-    return this._analyzedModules!;\n-  }\n-\n-  private get structuralDiagnostics(): ReadonlyArray<Diagnostic> {\n-    let diagnostics = this._structuralDiagnostics;\n-    if (!diagnostics) {\n-      this.initSync();\n-      diagnostics = (this._structuralDiagnostics = this._structuralDiagnostics || []);\n-    }\n-    return diagnostics;\n-  }\n-\n-  private get tsProgram(): ts.Program {\n-    if (!this._tsProgram) {\n-      this.initSync();\n-    }\n-    return this._tsProgram!;\n-  }\n-\n-  /** Whether the program is compiling the Angular core package. */\n-  private get isCompilingAngularCore(): boolean {\n-    if (this._isCompilingAngularCore !== null) {\n-      return this._isCompilingAngularCore;\n-    }\n-    return this._isCompilingAngularCore = isAngularCorePackage(this.tsProgram);\n-  }\n-  private _isCompilingAngularCore: boolean|null = null;\n-\n-  private calculateTransforms(\n-      genFiles: Map<string, GeneratedFile>|undefined, partialModules: PartialModule[]|undefined,\n-      customTransformers?: CustomTransformers): ts.CustomTransformers {\n-    const beforeTs: Array<ts.TransformerFactory<ts.SourceFile>> = [];\n-    const metadataTransforms: MetadataTransformer[] = [];\n-    const flatModuleMetadataTransforms: MetadataTransformer[] = [];\n-    const annotateForClosureCompiler = this.options.annotateForClosureCompiler || false;\n-\n-    if (this.options.enableResourceInlining) {\n-      beforeTs.push(getInlineResourcesTransformFactory(this.tsProgram, this.hostAdapter));\n-      const transformer = new InlineResourcesMetadataTransformer(this.hostAdapter);\n-      metadataTransforms.push(transformer);\n-      flatModuleMetadataTransforms.push(transformer);\n-    }\n-\n-    if (!this.options.disableExpressionLowering) {\n-      beforeTs.push(\n-          getExpressionLoweringTransformFactory(this.loweringMetadataTransform, this.tsProgram));\n-      metadataTransforms.push(this.loweringMetadataTransform);\n-    }\n-    if (genFiles) {\n-      beforeTs.push(getAngularEmitterTransformFactory(\n-          genFiles, this.getTsProgram(), annotateForClosureCompiler));\n-    }\n-    if (partialModules) {\n-      beforeTs.push(getAngularClassTransformerFactory(partialModules, annotateForClosureCompiler));\n-\n-      // If we have partial modules, the cached metadata might be incorrect as it doesn't reflect\n-      // the partial module transforms.\n-      const transformer = new PartialModuleMetadataTransformer(partialModules);\n-      metadataTransforms.push(transformer);\n-      flatModuleMetadataTransforms.push(transformer);\n-    }\n-\n-    if (customTransformers && customTransformers.beforeTs) {\n-      beforeTs.push(...customTransformers.beforeTs);\n-    }\n-\n-    // If decorators should be converted to static fields (enabled by default), we set up\n-    // the decorator downlevel transform. Note that we set it up as last transform as that\n-    // allows custom transformers to strip Angular decorators without having to deal with\n-    // identifying static properties. e.g. it's more difficult handling `<..>.decorators`\n-    // or `<..>.ctorParameters` compared to the `ts.Decorator` AST nodes.\n-    if (this.options.annotationsAs !== 'decorators') {\n-      const typeChecker = this.getTsProgram().getTypeChecker();\n-      const reflectionHost = new TypeScriptReflectionHost(typeChecker);\n-      // Similarly to how we handled tsickle decorator downleveling in the past, we just\n-      // ignore diagnostics that have been collected by the transformer. These are\n-      // non-significant failures that shouldn't prevent apps from compiling.\n-      beforeTs.push(getDownlevelDecoratorsTransform(\n-          typeChecker, reflectionHost, [], this.isCompilingAngularCore, annotateForClosureCompiler,\n-          /* skipClassDecorators */ false));\n-    }\n-\n-    if (metadataTransforms.length > 0) {\n-      this.metadataCache = this.createMetadataCache(metadataTransforms);\n-    }\n-    if (flatModuleMetadataTransforms.length > 0) {\n-      this.flatModuleMetadataCache = this.createMetadataCache(flatModuleMetadataTransforms);\n-    }\n-    const afterTs = customTransformers ? customTransformers.afterTs : undefined;\n-    return {before: beforeTs, after: afterTs};\n-  }\n-\n-  private initSync() {\n-    if (this._analyzedModules) {\n-      return;\n-    }\n-    try {\n-      const {tmpProgram, sourceFiles, tsFiles, rootNames} = this._createProgramWithBasicStubs();\n-      const {analyzedModules, analyzedInjectables} =\n-          this.compiler.loadFilesSync(sourceFiles, tsFiles);\n-      this._updateProgramWithTypeCheckStubs(\n-          tmpProgram, analyzedModules, analyzedInjectables, rootNames);\n-    } catch (e) {\n-      this._createProgramOnError(e);\n-    }\n-  }\n-\n-  private _createCompiler() {\n-    const codegen: CodeGenerator = {\n-      generateFile: (genFileName, baseFileName) =>\n-          this._compiler.emitBasicStub(genFileName, baseFileName),\n-      findGeneratedFileNames: (fileName) => this._compiler.findGeneratedFileNames(fileName),\n-    };\n-\n-    this._hostAdapter = new TsCompilerAotCompilerTypeCheckHostAdapter(\n-        this.rootNames, this.options, this.host, this.metadataCache, codegen,\n-        this.oldProgramLibrarySummaries);\n-    const aotOptions = getAotCompilerOptions(this.options);\n-    const errorCollector = (this.options.collectAllErrors || this.options.fullTemplateTypeCheck) ?\n-        (err: any) => this._addStructuralDiagnostics(err) :\n-        undefined;\n-    this._compiler = createAotCompiler(this._hostAdapter, aotOptions, errorCollector).compiler;\n-  }\n-\n-  private _createProgramWithBasicStubs(): {\n-    tmpProgram: ts.Program,\n-    rootNames: string[],\n-    sourceFiles: string[],\n-    tsFiles: string[],\n-  } {\n-    if (this._analyzedModules) {\n-      throw new Error(`Internal Error: already initialized!`);\n-    }\n-    // Note: This is important to not produce a memory leak!\n-    const oldTsProgram = this.oldTsProgram;\n-    this.oldTsProgram = undefined;\n-\n-    const codegen: CodeGenerator = {\n-      generateFile: (genFileName, baseFileName) =>\n-          this.compiler.emitBasicStub(genFileName, baseFileName),\n-      findGeneratedFileNames: (fileName) => this.compiler.findGeneratedFileNames(fileName),\n-    };\n-\n-\n-    let rootNames = [...this.rootNames];\n-    if (this.options.generateCodeForLibraries !== false) {\n-      // if we should generateCodeForLibraries, never include\n-      // generated files in the program as otherwise we will\n-      // overwrite them and typescript will report the error\n-      // TS5055: Cannot write file ... because it would overwrite input file.\n-      rootNames = rootNames.filter(fn => !GENERATED_FILES.test(fn));\n-    }\n-    if (this.options.noResolve) {\n-      this.rootNames.forEach(rootName => {\n-        if (this.hostAdapter.shouldGenerateFilesFor(rootName)) {\n-          rootNames.push(...this.compiler.findGeneratedFileNames(rootName));\n-        }\n-      });\n-    }\n-\n-    const tmpProgram = ts.createProgram(rootNames, this.options, this.hostAdapter, oldTsProgram);\n-    if (tempProgramHandlerForTest !== null) {\n-      tempProgramHandlerForTest(tmpProgram);\n-    }\n-    const sourceFiles: string[] = [];\n-    const tsFiles: string[] = [];\n-    tmpProgram.getSourceFiles().forEach(sf => {\n-      if (this.hostAdapter.isSourceFile(sf.fileName)) {\n-        sourceFiles.push(sf.fileName);\n-      }\n-      if (TS.test(sf.fileName) && !DTS.test(sf.fileName)) {\n-        tsFiles.push(sf.fileName);\n-      }\n-    });\n-    return {tmpProgram, sourceFiles, tsFiles, rootNames};\n-  }\n-\n-  private _updateProgramWithTypeCheckStubs(\n-      tmpProgram: ts.Program, analyzedModules: NgAnalyzedModules,\n-      analyzedInjectables: NgAnalyzedFileWithInjectables[], rootNames: string[]) {\n-    this._analyzedModules = analyzedModules;\n-    this._analyzedInjectables = analyzedInjectables;\n-    tmpProgram.getSourceFiles().forEach(sf => {\n-      if (sf.fileName.endsWith('.ngfactory.ts')) {\n-        const {generate, baseFileName} = this.hostAdapter.shouldGenerateFile(sf.fileName);\n-        if (generate) {\n-          // Note: ! is ok as hostAdapter.shouldGenerateFile will always return a baseFileName\n-          // for .ngfactory.ts files.\n-          const genFile = this.compiler.emitTypeCheckStub(sf.fileName, baseFileName!);\n-          if (genFile) {\n-            this.hostAdapter.updateGeneratedFile(genFile);\n-          }\n-        }\n-      }\n-    });\n-    this._tsProgram = ts.createProgram(rootNames, this.options, this.hostAdapter, tmpProgram);\n-    // Note: the new ts program should be completely reusable by TypeScript as:\n-    // - we cache all the files in the hostAdapter\n-    // - new new stubs use the exactly same imports/exports as the old once (we assert that in\n-    // hostAdapter.updateGeneratedFile).\n-    if (tsStructureIsReused(this._tsProgram) !== StructureIsReused.Completely) {\n-      throw new Error(`Internal Error: The structure of the program changed during codegen.`);\n-    }\n-  }\n-\n-  private _createProgramOnError(e: any) {\n-    // Still fill the analyzedModules and the tsProgram\n-    // so that we don't cause other errors for users who e.g. want to emit the ngProgram.\n-    this._analyzedModules = emptyModules;\n-    this.oldTsProgram = undefined;\n-    this._hostAdapter.isSourceFile = () => false;\n-    this._tsProgram = ts.createProgram(this.rootNames, this.options, this.hostAdapter);\n-    if (isSyntaxError(e)) {\n-      this._addStructuralDiagnostics(e);\n-      return;\n-    }\n-    throw e;\n-  }\n-\n-  private _addStructuralDiagnostics(error: Error) {\n-    const diagnostics = this._structuralDiagnostics || (this._structuralDiagnostics = []);\n-    if (isSyntaxError(error)) {\n-      diagnostics.push(...syntaxErrorToDiagnostics(error, this.tsProgram));\n-    } else {\n-      diagnostics.push({\n-        messageText: error.toString(),\n-        category: ts.DiagnosticCategory.Error,\n-        source: SOURCE,\n-        code: DEFAULT_ERROR_CODE\n-      });\n-    }\n-  }\n-\n-  // Note: this returns a ts.Diagnostic so that we\n-  // can return errors in a ts.EmitResult\n-  private generateFilesForEmit(emitFlags: EmitFlags):\n-      {genFiles: GeneratedFile[], genDiags: ts.Diagnostic[]} {\n-    try {\n-      if (!(emitFlags & EmitFlags.Codegen)) {\n-        return {genFiles: [], genDiags: []};\n-      }\n-      // TODO(tbosch): allow generating files that are not in the rootDir\n-      // See https://github.com/angular/angular/issues/19337\n-      let genFiles = this.compiler.emitAllImpls(this.analyzedModules)\n-                         .filter(genFile => isInRootDir(genFile.genFileUrl, this.options));\n-      if (this.oldProgramEmittedGeneratedFiles) {\n-        const oldProgramEmittedGeneratedFiles = this.oldProgramEmittedGeneratedFiles;\n-        genFiles = genFiles.filter(genFile => {\n-          const oldGenFile = oldProgramEmittedGeneratedFiles.get(genFile.genFileUrl);\n-          return !oldGenFile || !genFile.isEquivalent(oldGenFile);\n-        });\n-      }\n-      return {genFiles, genDiags: []};\n-    } catch (e) {\n-      // TODO(tbosch): check whether we can actually have syntax errors here,\n-      // as we already parsed the metadata and templates before to create the type check block.\n-      if (isSyntaxError(e)) {\n-        const genDiags: ts.Diagnostic[] = [{\n-          file: undefined,\n-          start: undefined,\n-          length: undefined,\n-          messageText: e.message,\n-          category: ts.DiagnosticCategory.Error,\n-          source: SOURCE,\n-          code: DEFAULT_ERROR_CODE\n-        }];\n-        return {genFiles: [], genDiags};\n-      }\n-      throw e;\n-    }\n-  }\n-\n-  /**\n-   * Returns undefined if all files should be emitted.\n-   */\n-  private getSourceFilesForEmit(): ts.SourceFile[]|undefined {\n-    // TODO(tbosch): if one of the files contains a `const enum`\n-    // always emit all files -> return undefined!\n-    let sourceFilesToEmit = this.tsProgram.getSourceFiles().filter(sf => {\n-      return !sf.isDeclarationFile && !GENERATED_FILES.test(sf.fileName);\n-    });\n-    if (this.oldProgramEmittedSourceFiles) {\n-      sourceFilesToEmit = sourceFilesToEmit.filter(sf => {\n-        const oldFile = this.oldProgramEmittedSourceFiles!.get(sf.fileName);\n-        return sf !== oldFile;\n-      });\n-    }\n-    return sourceFilesToEmit;\n-  }\n-\n-  private writeFile(\n-      outFileName: string, outData: string, writeByteOrderMark: boolean,\n-      onError?: (message: string) => void, genFile?: GeneratedFile,\n-      sourceFiles?: ReadonlyArray<ts.SourceFile>) {\n-    // collect emittedLibrarySummaries\n-    let baseFile: ts.SourceFile|undefined;\n-    if (genFile) {\n-      baseFile = this.tsProgram.getSourceFile(genFile.srcFileUrl);\n-      if (baseFile) {\n-        if (!this.emittedLibrarySummaries) {\n-          this.emittedLibrarySummaries = [];\n-        }\n-        if (genFile.genFileUrl.endsWith('.ngsummary.json') && baseFile.fileName.endsWith('.d.ts')) {\n-          this.emittedLibrarySummaries.push({\n-            fileName: baseFile.fileName,\n-            text: baseFile.text,\n-            sourceFile: baseFile,\n-          });\n-          this.emittedLibrarySummaries.push({fileName: genFile.genFileUrl, text: outData});\n-          if (!this.options.declaration) {\n-            // If we don't emit declarations, still record an empty .ngfactory.d.ts file,\n-            // as we might need it later on for resolving module names from summaries.\n-            const ngFactoryDts =\n-                genFile.genFileUrl.substring(0, genFile.genFileUrl.length - 15) + '.ngfactory.d.ts';\n-            this.emittedLibrarySummaries.push({fileName: ngFactoryDts, text: ''});\n-          }\n-        } else if (outFileName.endsWith('.d.ts') && baseFile.fileName.endsWith('.d.ts')) {\n-          const dtsSourceFilePath = genFile.genFileUrl.replace(/\\.ts$/, '.d.ts');\n-          // Note: Don't use sourceFiles here as the created .d.ts has a path in the outDir,\n-          // but we need one that is next to the .ts file\n-          this.emittedLibrarySummaries.push({fileName: dtsSourceFilePath, text: outData});\n-        }\n-      }\n-    }\n-    // Filter out generated files for which we didn't generate code.\n-    // This can happen as the stub calculation is not completely exact.\n-    // Note: sourceFile refers to the .ngfactory.ts / .ngsummary.ts file\n-    // node_emitter_transform already set the file contents to be empty,\n-    //  so this code only needs to skip the file if !allowEmptyCodegenFiles.\n-    const isGenerated = GENERATED_FILES.test(outFileName);\n-    if (isGenerated && !this.options.allowEmptyCodegenFiles &&\n-        (!genFile || !genFile.stmts || genFile.stmts.length === 0)) {\n-      return;\n-    }\n-    if (baseFile) {\n-      sourceFiles = sourceFiles ? [...sourceFiles, baseFile] : [baseFile];\n-    }\n-    // TODO: remove any when TS 2.4 support is removed.\n-    this.host.writeFile(outFileName, outData, writeByteOrderMark, onError, sourceFiles as any);\n-  }\n-}\n-\n-\n export function createProgram({rootNames, options, host, oldProgram}: {\n   rootNames: ReadonlyArray<string>,\n   options: CompilerOptions,\n@@ -829,251 +27,6 @@ export function createProgram({rootNames, options, host, oldProgram}: {\n   if (options.enableIvy !== false) {\n     return new NgtscProgram(rootNames, options, host, oldProgram as NgtscProgram | undefined);\n   } else {\n-    return new AngularCompilerProgram(rootNames, options, host, oldProgram);\n-  }\n-}\n-\n-// Compute the AotCompiler options\n-function getAotCompilerOptions(options: CompilerOptions): AotCompilerOptions {\n-  let missingTranslation = core.MissingTranslationStrategy.Warning;\n-\n-  switch (options.i18nInMissingTranslations) {\n-    case 'ignore':\n-      missingTranslation = core.MissingTranslationStrategy.Ignore;\n-      break;\n-    case 'error':\n-      missingTranslation = core.MissingTranslationStrategy.Error;\n-      break;\n-  }\n-\n-  let translations: string = '';\n-\n-  if (options.i18nInFile) {\n-    if (!options.i18nInLocale) {\n-      throw new Error(`The translation file (${options.i18nInFile}) locale must be provided.`);\n-    }\n-    translations = fs.readFileSync(options.i18nInFile, 'utf8');\n-  } else {\n-    // No translations are provided, ignore any errors\n-    // We still go through i18n to remove i18n attributes\n-    missingTranslation = core.MissingTranslationStrategy.Ignore;\n-  }\n-\n-  return {\n-    locale: options.i18nInLocale,\n-    i18nFormat: options.i18nInFormat || options.i18nOutFormat,\n-    i18nUseExternalIds: options.i18nUseExternalIds,\n-    translations,\n-    missingTranslation,\n-    enableSummariesForJit: options.enableSummariesForJit,\n-    preserveWhitespaces: options.preserveWhitespaces,\n-    fullTemplateTypeCheck: options.fullTemplateTypeCheck,\n-    allowEmptyCodegenFiles: options.allowEmptyCodegenFiles,\n-    enableIvy: options.enableIvy,\n-    createExternalSymbolFactoryReexports: options.createExternalSymbolFactoryReexports,\n-  };\n-}\n-\n-function getNgOptionDiagnostics(options: CompilerOptions): ReadonlyArray<Diagnostic> {\n-  if (options.annotationsAs) {\n-    switch (options.annotationsAs) {\n-      case 'decorators':\n-      case 'static fields':\n-        break;\n-      default:\n-        return [{\n-          messageText:\n-              'Angular compiler options \"annotationsAs\" only supports \"static fields\" and \"decorators\"',\n-          category: ts.DiagnosticCategory.Error,\n-          source: SOURCE,\n-          code: DEFAULT_ERROR_CODE\n-        }];\n-    }\n-  }\n-  return [];\n-}\n-\n-function normalizeSeparators(path: string): string {\n-  return path.replace(/\\\\/g, '/');\n-}\n-\n-/**\n- * Returns a function that can adjust a path from source path to out path,\n- * based on an existing mapping from source to out path.\n- *\n- * TODO(tbosch): talk to the TypeScript team to expose their logic for calculating the `rootDir`\n- * if none was specified.\n- *\n- * Note: This function works on normalized paths from typescript but should always return\n- * POSIX normalized paths for output paths.\n- */\n-export function createSrcToOutPathMapper(\n-    outDir: string|undefined, sampleSrcFileName: string|undefined,\n-    sampleOutFileName: string|undefined, host: {\n-      dirname: typeof path.dirname,\n-      resolve: typeof path.resolve,\n-      relative: typeof path.relative\n-    } = path): (srcFileName: string) => string {\n-  if (outDir) {\n-    let path: {} = {};  // Ensure we error if we use `path` instead of `host`.\n-    if (sampleSrcFileName == null || sampleOutFileName == null) {\n-      throw new Error(`Can't calculate the rootDir without a sample srcFileName / outFileName. `);\n-    }\n-    const srcFileDir = normalizeSeparators(host.dirname(sampleSrcFileName));\n-    const outFileDir = normalizeSeparators(host.dirname(sampleOutFileName));\n-    if (srcFileDir === outFileDir) {\n-      return (srcFileName) => srcFileName;\n-    }\n-    // calculate the common suffix, stopping\n-    // at `outDir`.\n-    const srcDirParts = srcFileDir.split('/');\n-    const outDirParts = normalizeSeparators(host.relative(outDir, outFileDir)).split('/');\n-    let i = 0;\n-    while (i < Math.min(srcDirParts.length, outDirParts.length) &&\n-           srcDirParts[srcDirParts.length - 1 - i] === outDirParts[outDirParts.length - 1 - i])\n-      i++;\n-    const rootDir = srcDirParts.slice(0, srcDirParts.length - i).join('/');\n-    return (srcFileName) => {\n-      // Note: Before we return the mapped output path, we need to normalize the path delimiters\n-      // because the output path is usually passed to TypeScript which sometimes only expects\n-      // posix normalized paths (e.g. if a custom compiler host is used)\n-      return normalizeSeparators(host.resolve(outDir, host.relative(rootDir, srcFileName)));\n-    };\n-  } else {\n-    // Note: Before we return the output path, we need to normalize the path delimiters because\n-    // the output path is usually passed to TypeScript which only passes around posix\n-    // normalized paths (e.g. if a custom compiler host is used)\n-    return (srcFileName) => normalizeSeparators(srcFileName);\n-  }\n-}\n-\n-function mergeEmitResults(emitResults: ts.EmitResult[]): ts.EmitResult {\n-  const diagnostics: ts.Diagnostic[] = [];\n-  let emitSkipped = false;\n-  const emittedFiles: string[] = [];\n-  for (const er of emitResults) {\n-    diagnostics.push(...er.diagnostics);\n-    emitSkipped = emitSkipped || er.emitSkipped;\n-    emittedFiles.push(...(er.emittedFiles || []));\n-  }\n-  return {diagnostics, emitSkipped, emittedFiles};\n-}\n-\n-function diagnosticSourceOfSpan(span: ParseSourceSpan): ts.SourceFile {\n-  // For diagnostics, TypeScript only uses the fileName and text properties.\n-  // The redundant '()' are here is to avoid having clang-format breaking the line incorrectly.\n-  return ({fileName: span.start.file.url, text: span.start.file.content} as any);\n-}\n-\n-function diagnosticSourceOfFileName(fileName: string, program: ts.Program): ts.SourceFile {\n-  const sourceFile = program.getSourceFile(fileName);\n-  if (sourceFile) return sourceFile;\n-\n-  // If we are reporting diagnostics for a source file that is not in the project then we need\n-  // to fake a source file so the diagnostic formatting routines can emit the file name.\n-  // The redundant '()' are here is to avoid having clang-format breaking the line incorrectly.\n-  return ({fileName, text: ''} as any);\n-}\n-\n-\n-function diagnosticChainFromFormattedDiagnosticChain(chain: FormattedMessageChain):\n-    DiagnosticMessageChain {\n-  return {\n-    messageText: chain.message,\n-    next: chain.next && chain.next.map(diagnosticChainFromFormattedDiagnosticChain),\n-    position: chain.position\n-  };\n-}\n-\n-function syntaxErrorToDiagnostics(error: Error, program: ts.Program): Diagnostic[] {\n-  const parserErrors = getParseErrors(error);\n-  if (parserErrors && parserErrors.length) {\n-    return parserErrors.map<Diagnostic>(e => ({\n-                                          messageText: e.contextualMessage(),\n-                                          file: diagnosticSourceOfSpan(e.span),\n-                                          start: e.span.start.offset,\n-                                          length: e.span.end.offset - e.span.start.offset,\n-                                          category: ts.DiagnosticCategory.Error,\n-                                          source: SOURCE,\n-                                          code: DEFAULT_ERROR_CODE\n-                                        }));\n-  } else if (isFormattedError(error)) {\n-    return [{\n-      messageText: error.message,\n-      chain: error.chain && diagnosticChainFromFormattedDiagnosticChain(error.chain),\n-      category: ts.DiagnosticCategory.Error,\n-      source: SOURCE,\n-      code: DEFAULT_ERROR_CODE,\n-      position: error.position\n-    }];\n-  }\n-\n-  const ngModuleErrorData = getMissingNgModuleMetadataErrorData(error);\n-  if (ngModuleErrorData !== null) {\n-    // This error represents the import or export of an `NgModule` that didn't have valid metadata.\n-    // This _might_ happen because the NgModule in question is an Ivy-compiled library, and we want\n-    // to show a more useful error if that's the case.\n-    const ngModuleClass =\n-        getDtsClass(program, ngModuleErrorData.fileName, ngModuleErrorData.className);\n-    if (ngModuleClass !== null && isIvyNgModule(ngModuleClass)) {\n-      return [{\n-        messageText: `The NgModule '${ngModuleErrorData.className}' in '${\n-            ngModuleErrorData\n-                .fileName}' is imported by this compilation, but appears to be part of a library compiled for Angular Ivy. This may occur because:\n-\n-  1) the library was processed with 'ngcc'. Removing and reinstalling node_modules may fix this problem.\n-\n-  2) the library was published for Angular Ivy and v12+ applications only. Check its peer dependencies carefully and ensure that you're using a compatible version of Angular.\n-\n-See https://angular.io/errors/NG6999 for more information.\n-`,\n-        category: ts.DiagnosticCategory.Error,\n-        code: DEFAULT_ERROR_CODE,\n-        source: SOURCE,\n-      }];\n-    }\n-  }\n-\n-  // Produce a Diagnostic anyway since we know for sure `error` is a SyntaxError\n-  return [{\n-    messageText: error.message,\n-    category: ts.DiagnosticCategory.Error,\n-    code: DEFAULT_ERROR_CODE,\n-    source: SOURCE,\n-  }];\n-}\n-\n-function getDtsClass(program: ts.Program, fileName: string, className: string): ts.ClassDeclaration|\n-    null {\n-  const sf = program.getSourceFile(fileName);\n-  if (sf === undefined || !sf.isDeclarationFile) {\n-    return null;\n-  }\n-  for (const stmt of sf.statements) {\n-    if (!ts.isClassDeclaration(stmt)) {\n-      continue;\n-    }\n-    if (stmt.name === undefined || stmt.name.text !== className) {\n-      continue;\n-    }\n-\n-    return stmt;\n+    throw new Error(VE_DISABLED_MESSAGE);\n   }\n-\n-  // No classes found that matched the given name.\n-  return null;\n-}\n-\n-function isIvyNgModule(clazz: ts.ClassDeclaration): boolean {\n-  for (const member of clazz.members) {\n-    if (!ts.isPropertyDeclaration(member)) {\n-      continue;\n-    }\n-    if (ts.isIdentifier(member.name) && member.name.text === 'ɵmod') {\n-      return true;\n-    }\n-  }\n-\n-  // No Ivy 'ɵmod' property found.\n-  return false;\n }"
        },
        {
            "sha": "336e778ecb0542149f5b2d832279fad54c296dbe",
            "filename": "packages/compiler-cli/src/transformers/r3_metadata_transform.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 55,
            "changes": 55,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fr3_metadata_transform.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fr3_metadata_transform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fr3_metadata_transform.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,55 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ClassStmt, PartialModule, Statement, StmtModifier} from '@angular/compiler';\n-import ts from 'typescript';\n-\n-import {isClassMetadata, MetadataCollector, MetadataValue, ModuleMetadata} from '../metadata/index';\n-\n-import {MetadataTransformer, ValueTransform} from './metadata_cache';\n-\n-export class PartialModuleMetadataTransformer implements MetadataTransformer {\n-  private moduleMap: Map<string, PartialModule>;\n-\n-  constructor(modules: PartialModule[]) {\n-    this.moduleMap = new Map(modules.map<[string, PartialModule]>(m => [m.fileName, m]));\n-  }\n-\n-  start(sourceFile: ts.SourceFile): ValueTransform|undefined {\n-    const partialModule = this.moduleMap.get(sourceFile.fileName);\n-    if (partialModule) {\n-      const classMap = new Map<string, ClassStmt>(\n-          partialModule.statements.filter(isClassStmt).map<[string, ClassStmt]>(s => [s.name, s]));\n-      if (classMap.size > 0) {\n-        return (value: MetadataValue, node: ts.Node): MetadataValue => {\n-          // For class metadata that is going to be transformed to have a static method ensure the\n-          // metadata contains a static declaration the new static method.\n-          if (isClassMetadata(value) && node.kind === ts.SyntaxKind.ClassDeclaration) {\n-            const classDeclaration = node as ts.ClassDeclaration;\n-            if (classDeclaration.name) {\n-              const partialClass = classMap.get(classDeclaration.name.text);\n-              if (partialClass) {\n-                for (const field of partialClass.fields) {\n-                  if (field.name && field.modifiers &&\n-                      field.modifiers.some(modifier => modifier === StmtModifier.Static)) {\n-                    value.statics = {...(value.statics || {}), [field.name]: {}};\n-                  }\n-                }\n-              }\n-            }\n-          }\n-          return value;\n-        };\n-      }\n-    }\n-  }\n-}\n-\n-function isClassStmt(v: Statement): v is ClassStmt {\n-  return v instanceof ClassStmt;\n-}"
        },
        {
            "sha": "d08f641eb24760f924c89e9311b366aae044e41e",
            "filename": "packages/compiler-cli/src/transformers/r3_transform.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 37,
            "changes": 37,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fr3_transform.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fr3_transform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fr3_transform.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,37 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {PartialModule, Statement, StaticSymbol} from '@angular/compiler';\n-import ts from 'typescript';\n-\n-import {updateSourceFile} from './node_emitter';\n-\n-export type Transformer = (sourceFile: ts.SourceFile) => ts.SourceFile;\n-export type TransformerFactory = (context: ts.TransformationContext) => Transformer;\n-\n-/**\n- * Returns a transformer that adds the requested static methods specified by modules.\n- */\n-export function getAngularClassTransformerFactory(\n-    modules: PartialModule[], annotateForClosureCompiler: boolean): TransformerFactory {\n-  if (modules.length === 0) {\n-    // If no modules are specified, just return an identity transform.\n-    return () => sf => sf;\n-  }\n-  const moduleMap = new Map(modules.map<[string, PartialModule]>(m => [m.fileName, m]));\n-  return function(context: ts.TransformationContext) {\n-    return function(sourceFile: ts.SourceFile): ts.SourceFile {\n-      const module = moduleMap.get(sourceFile.fileName);\n-      if (module && module.statements.length > 0) {\n-        const [newSourceFile] = updateSourceFile(sourceFile, module, annotateForClosureCompiler);\n-        return newSourceFile;\n-      }\n-      return sourceFile;\n-    };\n-  };\n-}"
        },
        {
            "sha": "977250b60fcbedd07ebc3fa63f83cd521d6d2e83",
            "filename": "packages/compiler-cli/src/transformers/util.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 49,
            "changes": 50,
            "blob_url": "https://github.com/angular/angular/blob/192203278647bae1864db2a5109efaae1bba53c4/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/192203278647bae1864db2a5109efaae1bba53c4/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Futil.ts?ref=192203278647bae1864db2a5109efaae1bba53c4",
            "patch": "@@ -6,35 +6,16 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {syntaxError} from '@angular/compiler';\n-import * as path from 'path';\n import ts from 'typescript';\n \n-import {CompilerOptions, DEFAULT_ERROR_CODE, Diagnostic, SOURCE} from './api';\n+import {DEFAULT_ERROR_CODE, Diagnostic, SOURCE} from './api';\n \n export const GENERATED_FILES = /(.*?)\\.(ngfactory|shim\\.ngstyle|ngstyle|ngsummary)\\.(js|d\\.ts|ts)$/;\n-export const DTS = /\\.d\\.ts$/;\n-export const TS = /^(?!.*\\.d\\.ts$).*\\.ts$/;\n-\n-export const enum StructureIsReused {\n-  Not = 0,\n-  SafeModules = 1,\n-  Completely = 2\n-}\n-\n-// Note: This is an internal property in TypeScript. Use it only for assertions and tests.\n-export function tsStructureIsReused(program: ts.Program): StructureIsReused {\n-  return (program as any).structureIsReused;\n-}\n \n export function error(msg: string): never {\n   throw new Error(`Internal error: ${msg}`);\n }\n \n-export function userError(msg: string): never {\n-  throw syntaxError(msg);\n-}\n-\n export function createMessageDiagnostic(messageText: string): ts.Diagnostic&Diagnostic {\n   return {\n     file: undefined,\n@@ -47,26 +28,6 @@ export function createMessageDiagnostic(messageText: string): ts.Diagnostic&Diag\n   };\n }\n \n-export function isInRootDir(fileName: string, options: CompilerOptions) {\n-  return !options.rootDir || pathStartsWithPrefix(options.rootDir, fileName);\n-}\n-\n-export function relativeToRootDirs(filePath: string, rootDirs: string[]): string {\n-  if (!filePath) return filePath;\n-  for (const dir of rootDirs || []) {\n-    const rel = pathStartsWithPrefix(dir, filePath);\n-    if (rel) {\n-      return rel;\n-    }\n-  }\n-  return filePath;\n-}\n-\n-function pathStartsWithPrefix(prefix: string, fullPath: string): string|null {\n-  const rel = path.relative(prefix, fullPath);\n-  return rel.startsWith('..') ? null : rel;\n-}\n-\n /**\n  * Converts a ng.Diagnostic into a ts.Diagnostic.\n  * This looses some information, and also uses an incomplete object as `file`.\n@@ -94,12 +55,3 @@ export function ngToTsDiagnostic(ng: Diagnostic): ts.Diagnostic {\n     length,\n   };\n }\n-\n-/**\n- * Strip multiline comment start and end markers from the `commentText` string.\n- *\n- * This will also strip the JSDOC comment start marker (`/**`).\n- */\n-export function stripComment(commentText: string): string {\n-  return commentText.replace(/^\\/\\*\\*?/, '').replace(/\\*\\/$/, '').trim();\n-}"
        },
        {
            "sha": "7e6179d4ccbdd03a1480b03e1f8f46059c420ed9",
            "filename": "packages/compiler-cli/test/diagnostics/check_types_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 926,
            "changes": 926,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Ftest%2Fdiagnostics%2Fcheck_types_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Ftest%2Fdiagnostics%2Fcheck_types_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fdiagnostics%2Fcheck_types_spec.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,926 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-/// <reference types=\"node\" />\n-import * as ng from '@angular/compiler-cli';\n-import * as fs from 'fs';\n-import * as os from 'os';\n-import * as path from 'path';\n-import ts from 'typescript';\n-\n-import {expectNoDiagnostics, setup, TestSupport} from '../test_support';\n-\n-type MockFiles = {\n-  [fileName: string]: string\n-};\n-\n-describe('ng type checker', () => {\n-  let errorSpy: jasmine.Spy&((s: string) => void);\n-  let testSupport: TestSupport;\n-\n-  function compileAndCheck(\n-      mockDirs: MockFiles[], overrideOptions: ng.CompilerOptions = {}): ng.Diagnostics {\n-    testSupport.writeFiles(...mockDirs);\n-    const fileNames: string[] = [];\n-    mockDirs.forEach((dir) => {\n-      Object.keys(dir).forEach((fileName) => {\n-        if (fileName.endsWith('.ts')) {\n-          fileNames.push(path.resolve(testSupport.basePath, fileName));\n-        }\n-      });\n-    });\n-    const options = testSupport.createCompilerOptions(overrideOptions);\n-    const {diagnostics} = ng.performCompilation({rootNames: fileNames, options});\n-    return diagnostics;\n-  }\n-\n-  beforeEach(() => {\n-    errorSpy = jasmine.createSpy('consoleError').and.callFake(console.error);\n-    testSupport = setup();\n-  });\n-\n-  function accept(files: MockFiles = {}, overrideOptions: ng.CompilerOptions = {}) {\n-    expectNoDiagnostics({}, compileAndCheck([QUICKSTART, files], overrideOptions));\n-  }\n-\n-  function reject(\n-      message: string|RegExp, location: RegExp|null, files: MockFiles,\n-      overrideOptions: ng.CompilerOptions = {}) {\n-    const diagnostics = compileAndCheck([QUICKSTART, files], overrideOptions);\n-    if (!diagnostics || !diagnostics.length) {\n-      throw new Error('Expected a diagnostic error message');\n-    } else {\n-      const matches: (d: ng.Diagnostic|ts.Diagnostic) => boolean = typeof message === 'string' ?\n-          d => ng.isNgDiagnostic(d)&& d.messageText == message :\n-          d => ng.isNgDiagnostic(d) && message.test(d.messageText);\n-      const matchingDiagnostics = diagnostics.filter(matches) as ng.Diagnostic[];\n-      if (!matchingDiagnostics || !matchingDiagnostics.length) {\n-        throw new Error(`Expected a diagnostics matching ${message}, received\\n  ${\n-            diagnostics.map(d => d.messageText).join('\\n  ')}`);\n-      }\n-\n-      if (location) {\n-        const span = matchingDiagnostics[0].span;\n-        if (!span) {\n-          throw new Error('Expected a sourceSpan');\n-        }\n-        expect(`${span.start.file.url}@${span.start.line}:${span.start.offset}`).toMatch(location);\n-      }\n-    }\n-  }\n-\n-  it('should accept unmodified QuickStart', () => {\n-    accept();\n-  });\n-\n-  it('should accept unmodified QuickStart with tests for unused variables', () => {\n-    accept({}, {\n-      strict: true,\n-      noUnusedLocals: true,\n-      noUnusedParameters: true,\n-    });\n-  });\n-\n-  describe('type narrowing', () => {\n-    const a = (files: MockFiles, options: ng.AngularCompilerOptions = {}) => {\n-      accept(files, {fullTemplateTypeCheck: true, ...options});\n-    };\n-\n-    it('should narrow an *ngIf like directive', () => {\n-      a({\n-        'src/app.component.ts': '',\n-        'src/lib.ts': '',\n-        'src/app.module.ts': `\n-        import {NgModule, Component, Directive, HostListener, TemplateRef, Input} from '@angular/core';\n-\n-        export interface Person {\n-          name: string;\n-        }\n-\n-        @Component({\n-          selector: 'comp',\n-          template: '<div *myIf=\"person\"> {{person.name}} </div>'\n-        })\n-        export class MainComp {\n-          person?: Person;\n-        }\n-\n-        export class MyIfContext {\n-          public $implicit: any = null;\n-          public myIf: any = null;\n-        }\n-\n-        @Directive({selector: '[myIf]'})\n-        export class MyIf {\n-          constructor(templateRef: TemplateRef<MyIfContext>) {}\n-\n-          @Input()\n-          set myIf(condition: any) {}\n-\n-          static myIfTypeGuard: <T>(v: T | null | undefined | false) => v is T;\n-        }\n-\n-        @NgModule({\n-          declarations: [MainComp, MyIf],\n-        })\n-        export class MainModule {}`\n-      });\n-    });\n-\n-    it('should narrow a renamed *ngIf like directive', () => {\n-      a({\n-        'src/app.component.ts': '',\n-        'src/lib.ts': '',\n-        'src/app.module.ts': `\n-        import {NgModule, Component, Directive, HostListener, TemplateRef, Input} from '@angular/core';\n-\n-        export interface Person {\n-          name: string;\n-        }\n-\n-        @Component({\n-          selector: 'comp',\n-          template: '<div *my-if=\"person\"> {{person.name}} </div>'\n-        })\n-        export class MainComp {\n-          person?: Person;\n-        }\n-\n-        export class MyIfContext {\n-          public $implicit: any = null;\n-          public myIf: any = null;\n-        }\n-\n-        @Directive({selector: '[my-if]'})\n-        export class MyIf {\n-          constructor(templateRef: TemplateRef<MyIfContext>) {}\n-\n-          @Input('my-if')\n-          set myIf(condition: any) {}\n-\n-          static myIfTypeGuard: <T>(v: T | null | undefined | false) => v is T;\n-        }\n-\n-        @NgModule({\n-          declarations: [MainComp, MyIf],\n-        })\n-        export class MainModule {}`\n-      });\n-    });\n-\n-    it('should narrow a type in a nested *ngIf like directive', () => {\n-      a({\n-        'src/app.component.ts': '',\n-        'src/lib.ts': '',\n-        'src/app.module.ts': `\n-        import {NgModule, Component, Directive, HostListener, TemplateRef, Input} from '@angular/core';\n-\n-        export interface Address {\n-          street: string;\n-        }\n-\n-        export interface Person {\n-          name: string;\n-          address?: Address;\n-        }\n-\n-\n-        @Component({\n-          selector: 'comp',\n-          template: '<div *myIf=\"person\"> {{person.name}} <span *myIf=\"person.address\">{{person.address.street}}</span></div>'\n-        })\n-        export class MainComp {\n-          person?: Person;\n-        }\n-\n-        export class MyIfContext {\n-          public $implicit: any = null;\n-          public myIf: any = null;\n-        }\n-\n-        @Directive({selector: '[myIf]'})\n-        export class MyIf {\n-          constructor(templateRef: TemplateRef<MyIfContext>) {}\n-\n-          @Input()\n-          set myIf(condition: any) {}\n-\n-          static myIfTypeGuard: <T>(v: T | null | undefined | false) => v is T;\n-        }\n-\n-        @NgModule({\n-          declarations: [MainComp, MyIf],\n-        })\n-        export class MainModule {}`\n-      });\n-    });\n-\n-    it('should narrow an *ngIf like directive with UseIf', () => {\n-      a({\n-        'src/app.component.ts': '',\n-        'src/lib.ts': '',\n-        'src/app.module.ts': `\n-        import {NgModule, Component, Directive, HostListener, TemplateRef, Input} from '@angular/core';\n-\n-        export interface Person {\n-          name: string;\n-        }\n-\n-        @Component({\n-          selector: 'comp',\n-          template: '<div *myIf=\"person\"> {{person.name}} </div>'\n-        })\n-        export class MainComp {\n-          person?: Person;\n-        }\n-\n-        export class MyIfContext {\n-          public $implicit: any = null;\n-          public myIf: any = null;\n-        }\n-\n-        @Directive({selector: '[myIf]'})\n-        export class MyIf {\n-          constructor(templateRef: TemplateRef<MyIfContext>) {}\n-\n-          @Input()\n-          set myIf(condition: any) {}\n-\n-          static myIfUseIfTypeGuard: void;\n-        }\n-\n-        @NgModule({\n-          declarations: [MainComp, MyIf],\n-        })\n-        export class MainModule {}`\n-      });\n-    });\n-\n-    it('should narrow a renamed *ngIf like directive with UseIf', () => {\n-      a({\n-        'src/app.component.ts': '',\n-        'src/lib.ts': '',\n-        'src/app.module.ts': `\n-        import {NgModule, Component, Directive, HostListener, TemplateRef, Input} from '@angular/core';\n-\n-        export interface Person {\n-          name: string;\n-        }\n-\n-        @Component({\n-          selector: 'comp',\n-          template: '<div *my-if=\"person\"> {{person.name}} </div>'\n-        })\n-        export class MainComp {\n-          person?: Person;\n-        }\n-\n-        export class MyIfContext {\n-          public $implicit: any = null;\n-          public myIf: any = null;\n-        }\n-\n-        @Directive({selector: '[my-if]'})\n-        export class MyIf {\n-          constructor(templateRef: TemplateRef<MyIfContext>) {}\n-\n-          @Input('my-if')\n-          set myIf(condition: any) {}\n-\n-          static myIfUseIfTypeGuard: void;\n-        }\n-\n-        @NgModule({\n-          declarations: [MainComp, MyIf],\n-        })\n-        export class MainModule {}`\n-      });\n-    });\n-\n-    it('should narrow a type in a nested *ngIf like directive with UseIf', () => {\n-      a({\n-        'src/app.component.ts': '',\n-        'src/lib.ts': '',\n-        'src/app.module.ts': `\n-        import {NgModule, Component, Directive, HostListener, TemplateRef, Input} from '@angular/core';\n-\n-        export interface Address {\n-          street: string;\n-        }\n-\n-        export interface Person {\n-          name: string;\n-          address?: Address;\n-        }\n-\n-\n-        @Component({\n-          selector: 'comp',\n-          template: '<div *myIf=\"person\"> {{person.name}} <span *myIf=\"person.address\">{{person.address.street}}</span></div>'\n-        })\n-        export class MainComp {\n-          person?: Person;\n-        }\n-\n-        export class MyIfContext {\n-          public $implicit: any = null;\n-          public myIf: any = null;\n-        }\n-\n-        @Directive({selector: '[myIf]'})\n-        export class MyIf {\n-          constructor(templateRef: TemplateRef<MyIfContext>) {}\n-\n-          @Input()\n-          set myIf(condition: any) {}\n-\n-          static myIfUseIfTypeGuard: void;\n-        }\n-\n-        @NgModule({\n-          declarations: [MainComp, MyIf],\n-        })\n-        export class MainModule {}`\n-      });\n-    });\n-\n-    it('should narrow an *ngIf like directive with UseIf and &&', () => {\n-      a({\n-        'src/app.component.ts': '',\n-        'src/lib.ts': '',\n-        'src/app.module.ts': `\n-        import {NgModule, Component, Directive, HostListener, TemplateRef, Input} from '@angular/core';\n-\n-        export interface Address {\n-          street: string;\n-        }\n-\n-        export interface Person {\n-          name: string;\n-        }\n-\n-        @Component({\n-          selector: 'comp',\n-          template: '<div *myIf=\"person && address\"> {{person.name}} lives at {{address.street}} </div>'\n-        })\n-        export class MainComp {\n-          person?: Person;\n-          address?: Address;\n-        }\n-\n-        export class MyIfContext {\n-          public $implicit: any = null;\n-          public myIf: any = null;\n-        }\n-\n-        @Directive({selector: '[myIf]'})\n-        export class MyIf {\n-          constructor(templateRef: TemplateRef<MyIfContext>) {}\n-\n-          @Input()\n-          set myIf(condition: any) {}\n-\n-          static myIfUseIfTypeGuard: void;\n-        }\n-\n-        @NgModule({\n-          declarations: [MainComp, MyIf],\n-        })\n-        export class MainModule {}`\n-      });\n-    });\n-\n-    it('should narrow an *ngIf like directive with UseIf and !!', () => {\n-      a({\n-        'src/app.component.ts': '',\n-        'src/lib.ts': '',\n-        'src/app.module.ts': `\n-        import {NgModule, Component, Directive, HostListener, TemplateRef, Input} from '@angular/core';\n-\n-        export interface Person {\n-          name: string;\n-        }\n-\n-        @Component({\n-          selector: 'comp',\n-          template: '<div *myIf=\"!!person\"> {{person.name}} </div>'\n-        })\n-        export class MainComp {\n-          person?: Person;\n-        }\n-\n-        export class MyIfContext {\n-          public $implicit: any = null;\n-          public myIf: any = null;\n-        }\n-\n-        @Directive({selector: '[myIf]'})\n-        export class MyIf {\n-          constructor(templateRef: TemplateRef<MyIfContext>) {}\n-\n-          @Input()\n-          set myIf(condition: any) {}\n-\n-          static myIfUseIfTypeGuard: void;\n-        }\n-\n-        @NgModule({\n-          declarations: [MainComp, MyIf],\n-        })\n-        export class MainModule {}`\n-      });\n-    });\n-\n-    it('should narrow an *ngIf like directive with UseIf and != null', () => {\n-      a({\n-        'src/app.component.ts': '',\n-        'src/lib.ts': '',\n-        'src/app.module.ts': `\n-        import {NgModule, Component, Directive, HostListener, TemplateRef, Input} from '@angular/core';\n-\n-        export interface Person {\n-          name: string;\n-        }\n-\n-        @Component({\n-          selector: 'comp',\n-          template: '<div *myIf=\"person != null\"> {{person.name}} </div>'\n-        })\n-        export class MainComp {\n-          person: Person | null = null;\n-        }\n-\n-        export class MyIfContext {\n-          public $implicit: any = null;\n-          public myIf: any = null;\n-        }\n-\n-        @Directive({selector: '[myIf]'})\n-        export class MyIf {\n-          constructor(templateRef: TemplateRef<MyIfContext>) {}\n-\n-          @Input()\n-          set myIf(condition: any) {}\n-\n-          static myIfUseIfTypeGuard: void;\n-        }\n-\n-        @NgModule({\n-          declarations: [MainComp, MyIf],\n-        })\n-        export class MainModule {}`\n-      });\n-    });\n-\n-    it('should narrow an *ngIf like directive with UseIf and != undefined', () => {\n-      a({\n-        'src/app.component.ts': '',\n-        'src/lib.ts': '',\n-        'src/app.module.ts': `\n-        import {NgModule, Component, Directive, HostListener, TemplateRef, Input} from '@angular/core';\n-\n-        export interface Person {\n-          name: string;\n-        }\n-\n-        @Component({\n-          selector: 'comp',\n-          template: '<div *myIf=\"person != undefined\"> {{person.name}} </div>'\n-        })\n-        export class MainComp {\n-          person?: Person;\n-        }\n-\n-        export class MyIfContext {\n-          public $implicit: any = null;\n-          public myIf: any = null;\n-        }\n-\n-        @Directive({selector: '[myIf]'})\n-        export class MyIf {\n-          constructor(templateRef: TemplateRef<MyIfContext>) {}\n-\n-          @Input()\n-          set myIf(condition: any) {}\n-\n-          static myIfUseIfTypeGuard: void;\n-        }\n-\n-        @NgModule({\n-          declarations: [MainComp, MyIf],\n-        })\n-        export class MainModule {}`\n-      });\n-    });\n-  });\n-\n-  describe('casting $any', () => {\n-    const a = (files: MockFiles, options: ng.AngularCompilerOptions = {}) => {\n-      accept(\n-          {'src/app.component.ts': '', 'src/lib.ts': '', ...files},\n-          {fullTemplateTypeCheck: true, ...options});\n-    };\n-\n-    const r =\n-        (message: string|RegExp, location: RegExp|null, files: MockFiles,\n-         options: ng.AngularCompilerOptions = {}) => {\n-          reject(\n-              message, location, {'src/app.component.ts': '', 'src/lib.ts': '', ...files},\n-              {fullTemplateTypeCheck: true, ...options});\n-        };\n-\n-    it('should allow member access of an expression', () => {\n-      a({\n-        'src/app.module.ts': `\n-        import {NgModule, Component} from '@angular/core';\n-\n-        export interface Person {\n-          name: string;\n-        }\n-\n-        @Component({\n-          selector: 'comp',\n-          template: ' {{$any(person).address}}'\n-        })\n-        export class MainComp {\n-          person: Person;\n-        }\n-\n-        @NgModule({\n-          declarations: [MainComp],\n-        })\n-        export class MainModule {\n-        }`\n-      });\n-    });\n-\n-    it('should allow invalid this.member access', () => {\n-      a({\n-        'src/app.module.ts': `\n-        import {NgModule, Component} from '@angular/core';\n-\n-        @Component({\n-          selector: 'comp',\n-          template: ' {{$any(this).missing}}'\n-        })\n-        export class MainComp { }\n-\n-        @NgModule({\n-          declarations: [MainComp],\n-        })\n-        export class MainModule {\n-        }`\n-      });\n-    });\n-\n-    it('should reject too few parameters to $any', () => {\n-      r(/Invalid call to \\$any, expected 1 argument but received none/, null, {\n-        'src/app.module.ts': `\n-        import {NgModule, Component} from '@angular/core';\n-\n-        @Component({\n-          selector: 'comp',\n-          template: ' {{$any().missing}}'\n-        })\n-        export class MainComp { }\n-\n-        @NgModule({\n-          declarations: [MainComp],\n-        })\n-        export class MainModule {\n-        }`\n-      });\n-    });\n-\n-    it('should reject too many parameters to $any', () => {\n-      r(/Invalid call to \\$any, expected 1 argument but received 2/, null, {\n-        'src/app.module.ts': `\n-        import {NgModule, Component} from '@angular/core';\n-\n-        export interface Person {\n-          name: string;\n-        }\n-\n-        @Component({\n-          selector: 'comp',\n-          template: ' {{$any(person, 12).missing}}'\n-        })\n-        export class MainComp {\n-          person: Person;\n-        }\n-\n-        @NgModule({\n-          declarations: [MainComp],\n-        })\n-        export class MainModule {\n-        }`\n-      });\n-    });\n-  });\n-\n-  describe('core', () => {\n-    const a = (files: MockFiles, options: ng.AngularCompilerOptions = {}) => {\n-      accept(files, {fullTemplateTypeCheck: true, ...options});\n-    };\n-\n-    // Regression #19905\n-    it('should accept an event binding', () => {\n-      a({\n-        'src/app.component.ts': '',\n-        'src/lib.ts': '',\n-        'src/app.module.ts': `\n-        import {NgModule, Component, Directive, HostListener} from '@angular/core';\n-\n-        @Component({\n-          selector: 'comp',\n-          template: '<div someDir></div>'\n-        })\n-        export class MainComp {}\n-\n-        @Directive({\n-          selector: '[someDir]'\n-        })\n-        export class SomeDirective {\n-          @HostListener('click', ['$event'])\n-          onClick(event: any) {}\n-        }\n-\n-        @NgModule({\n-          declarations: [MainComp, SomeDirective],\n-        })\n-        export class MainModule {}`\n-      });\n-    });\n-  });\n-\n-  describe('common', () => {\n-    const a = (files: MockFiles, options: ng.AngularCompilerOptions = {}) => {\n-      accept(files, {fullTemplateTypeCheck: true, ...options});\n-    };\n-\n-    // Regression #19905\n-    it('should accept a |undefined or |null parameter for async_pipe', () => {\n-      a({\n-        'src/app.component.ts': '',\n-        'src/lib.ts': '',\n-        'src/app.module.ts': `\n-        import {NgModule, Component} from '@angular/core';\n-        import {CommonModule} from '@angular/common';\n-\n-        @Component({\n-          selector: 'comp',\n-          template: '<div>{{ name | async}}</div>'\n-        })\n-        export class MainComp {\n-          name: Promise<string>|undefined;\n-        }\n-\n-\n-        @NgModule({\n-          declarations: [MainComp],\n-          imports: [CommonModule]\n-        })\n-        export class MainModule {}`\n-      });\n-    });\n-  });\n-\n-  describe('with modified quickstart (fullTemplateTypeCheck: false)', () => {\n-    addTests({fullTemplateTypeCheck: false});\n-  });\n-\n-  describe('with modified quickstart (fullTemplateTypeCheck: true)', () => {\n-    addTests({fullTemplateTypeCheck: true});\n-  });\n-\n-  describe('regressions', () => {\n-    // #19485\n-    it('should accept if else (TemplateRef)', () => {\n-      accept(\n-          {\n-            'src/app.component.html': `\n-              <div class=\"text-center\" *ngIf=\"!person; else e\">\n-                No person supplied.\n-              </div>\n-              <ng-template #e>\n-                Welcome {{person.name}}!\n-              <ng-template>`\n-          },\n-          {fullTemplateTypeCheck: true});\n-    });\n-  });\n-\n-  function addTests(config: {fullTemplateTypeCheck: boolean}) {\n-    function a(template: string) {\n-      accept({'src/app.component.html': template}, config);\n-    }\n-\n-    function r(template: string, message: string|RegExp, location: string) {\n-      reject(\n-          message, new RegExp(`app\\.component\\.html\\@${location}$`),\n-          {'src/app.component.html': template}, config);\n-    }\n-\n-    function rejectOnlyWithFullTemplateTypeCheck(\n-        template: string, message: string|RegExp, location: string) {\n-      if (config.fullTemplateTypeCheck) {\n-        r(template, message, location);\n-      } else {\n-        a(template);\n-      }\n-    }\n-\n-    it('should report an invalid field access', () => {\n-      r('<div>{{fame}}<div>', `Property 'fame' does not exist on type 'AppComponent'.`, '0:5');\n-    });\n-    it('should reject a reference to a field of a nullable', () => {\n-      r('<div>{{maybePerson.name}}</div>', `Object is possibly 'undefined'.`, '0:5');\n-    });\n-    it('should accept a reference to a field of a nullable using using non-null-assert', () => {\n-      a('{{maybePerson!.name}}');\n-    });\n-    it('should accept a safe property access of a nullable person', () => {\n-      a('{{maybePerson?.name}}');\n-    });\n-\n-    it('should accept using a library pipe', () => {\n-      a('{{1 | libPipe}}');\n-    });\n-    it('should accept using a library directive', () => {\n-      a('<div libDir #libDir=\"libDir\">{{libDir.name}}</div>');\n-    });\n-\n-    it('should accept a function call', () => {\n-      a('{{getName()}}');\n-    });\n-    it('should reject an invalid method', () => {\n-      r('<div>{{getFame()}}</div>',\n-        `Property 'getFame' does not exist on type 'AppComponent'. Did you mean 'getName'?`, '0:5');\n-    });\n-    it('should accept a field access of a method result', () => {\n-      a('{{getPerson().name}}');\n-    });\n-    it('should reject an invalid field reference of a method result', () => {\n-      r('<div>{{getPerson().fame}}</div>', `Property 'fame' does not exist on type 'Person'.`,\n-        '0:5');\n-    });\n-    it('should reject an access to a nullable field of a method result', () => {\n-      r('<div>{{getMaybePerson().name}}</div>', `Object is possibly 'undefined'.`, '0:5');\n-    });\n-    it('should accept a nullable assert of a nullable field references of a method result', () => {\n-      a('{{getMaybePerson()!.name}}');\n-    });\n-    it('should accept a safe property access of a nullable field reference of a method result',\n-       () => {\n-         a('{{getMaybePerson()?.name}}');\n-       });\n-\n-    it('should report an invalid field access inside of an ng-template', () => {\n-      rejectOnlyWithFullTemplateTypeCheck(\n-          '<ng-template>{{fame}}</ng-template>',\n-          `Property 'fame' does not exist on type 'AppComponent'.`, '0:13');\n-    });\n-    it('should report an invalid call to a pipe', () => {\n-      rejectOnlyWithFullTemplateTypeCheck(\n-          '<div>{{\"hello\" | aPipe}}</div>',\n-          `Argument of type 'string' is not assignable to parameter of type 'number'.`, '0:5');\n-    });\n-    it('should report an invalid property on an exportAs directive', () => {\n-      rejectOnlyWithFullTemplateTypeCheck(\n-          '<div aDir #aDir=\"aDir\">{{aDir.fname}}</div>',\n-          `Property 'fname' does not exist on type 'ADirective'. Did you mean 'name'?`, '0:23');\n-    });\n-  }\n-\n-  describe('with lowered expressions', () => {\n-    it('should not report lowered expressions as errors', () => {\n-      expectNoDiagnostics({}, compileAndCheck([LOWERING_QUICKSTART]));\n-    });\n-  });\n-});\n-\n-function appComponentSource(): string {\n-  return `\n-    import {Component, Pipe, Directive} from '@angular/core';\n-\n-    export interface Person {\n-      name: string;\n-      address: Address;\n-    }\n-\n-    export interface Address {\n-      street: string;\n-      city: string;\n-      state: string;\n-      zip: string;\n-    }\n-\n-    @Component({\n-      templateUrl: './app.component.html'\n-    })\n-    export class AppComponent {\n-      name = 'Angular';\n-      person: Person;\n-      people: Person[];\n-      maybePerson?: Person;\n-\n-      getName(): string { return this.name; }\n-      getPerson(): Person { return this.person; }\n-      getMaybePerson(): Person | undefined { return this.maybePerson; }\n-    }\n-\n-    @Pipe({\n-      name: 'aPipe',\n-    })\n-    export class APipe {\n-      transform(n: number): number { return n + 1; }\n-    }\n-\n-    @Directive({\n-      selector: '[aDir]',\n-      exportAs: 'aDir'\n-    })\n-    export class ADirective {\n-      name = 'ADirective';\n-    }\n-  `;\n-}\n-\n-const QUICKSTART = {\n-  'src/app.component.ts': appComponentSource(),\n-  'src/app.component.html': '<h1>Hello {{name}}</h1>',\n-  'src/lib.ts': `\n-    import {Pipe, Directive} from '@angular/core';\n-\n-    @Pipe({ name: 'libPipe' })\n-    export class LibPipe {\n-      transform(n: number): number { return n + 1; }\n-    }\n-\n-    @Directive({\n-      selector: '[libDir]',\n-      exportAs: 'libDir'\n-    })\n-    export class LibDirective {\n-      name: string;\n-    }\n-  `,\n-  'src/app.module.ts': `\n-    import { NgModule }      from '@angular/core';\n-    import { CommonModule }  from '@angular/common';\n-    import { AppComponent, APipe, ADirective }  from './app.component';\n-    import { LibDirective, LibPipe } from './lib';\n-\n-    @NgModule({\n-      declarations: [ LibPipe, LibDirective ],\n-      exports: [ LibPipe, LibDirective ],\n-    })\n-    export class LibModule { }\n-\n-    @NgModule({\n-      declarations: [ AppComponent, APipe, ADirective ],\n-      bootstrap:    [ AppComponent ],\n-      imports:      [ LibModule, CommonModule ]\n-    })\n-    export class AppModule { }\n-  `\n-};\n-\n-const LOWERING_QUICKSTART = {\n-  'src/app.component.ts': appComponentSource(),\n-  'src/app.component.html': '<h1>Hello {{name}}</h1>',\n-  'src/app.module.ts': `\n-    import { NgModule, Component }      from '@angular/core';\n-\n-    import { AppComponent, APipe, ADirective }  from './app.component';\n-\n-    class Foo {}\n-\n-    @Component({\n-      template: '',\n-      providers: [\n-        {provide: 'someToken', useFactory: () => new Foo()}\n-      ]\n-    })\n-    export class Bar {}\n-\n-    @NgModule({\n-      declarations: [ AppComponent, APipe, ADirective, Bar ],\n-      bootstrap:    [ AppComponent ]\n-    })\n-    export class AppModule { }\n-  `\n-};\n-\n-const tmpdir = process.env.TEST_TMPDIR || os.tmpdir();\n-\n-function makeTempDir(): string {\n-  const id = (Math.random() * 1000000).toFixed(0);\n-  const dir = path.join(tmpdir, `tmp.${id}`);\n-  fs.mkdirSync(dir);\n-  return dir;\n-}"
        },
        {
            "sha": "9217416353fce333d55faf7fed72f20f9b9bacb5",
            "filename": "packages/compiler-cli/test/metadata/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 26,
            "changes": 26,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2FBUILD.bazel?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,26 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"jasmine_node_test\", \"ts_library\")\n-\n-ts_library(\n-    name = \"test_lib\",\n-    testonly = True,\n-    srcs = glob([\"**/*.ts\"]),\n-    deps = [\n-        \"//packages:types\",\n-        \"//packages/compiler\",\n-        \"//packages/compiler-cli\",\n-        \"//packages/compiler-cli/test:test_utils\",\n-        \"//packages/core\",\n-        \"@npm//typescript\",\n-    ],\n-)\n-\n-jasmine_node_test(\n-    name = \"test\",\n-    bootstrap = [\"//tools/testing:node_es5\"],\n-    data = [\n-    ],\n-    deps = [\n-        \":test_lib\",\n-        \"//packages/core\",\n-    ],\n-)"
        },
        {
            "sha": "6de44bd706e33c41c456adc72718cf129a02aff6",
            "filename": "packages/compiler-cli/test/metadata/bundler_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 547,
            "changes": 547,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2Fbundler_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2Fbundler_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2Fbundler_spec.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,547 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as path from 'path';\n-import ts from 'typescript';\n-\n-import {CompilerHostAdapter, MetadataBundler, MetadataBundlerHost} from '../../src/metadata/bundler';\n-import {MetadataCollector} from '../../src/metadata/collector';\n-import {ClassMetadata, MetadataEntry, MetadataGlobalReferenceExpression, ModuleMetadata} from '../../src/metadata/schema';\n-import {Directory, MockAotContext, MockCompilerHost} from '../mocks';\n-\n-describe('compiler host adapter', () => {\n-  it('should retrieve metadata for an explicit index relative path reference', () => {\n-    const context = new MockAotContext('.', SIMPLE_LIBRARY);\n-    const host = new MockCompilerHost(context);\n-    const options: ts.CompilerOptions = {\n-      moduleResolution: ts.ModuleResolutionKind.NodeJs,\n-      module: ts.ModuleKind.CommonJS,\n-      target: ts.ScriptTarget.ES5,\n-    };\n-    const adapter = new CompilerHostAdapter(host, null, options);\n-    const metadata = adapter.getMetadataFor('./lib/src/two/index', '.');\n-\n-    expect(metadata).toBeDefined();\n-    expect(Object.keys(metadata!.metadata).sort()).toEqual([\n-      'PrivateTwo',\n-      'TWO_CLASSES',\n-      'Two',\n-      'TwoMore',\n-    ]);\n-  });\n-\n-  it('should retrieve metadata for an implied index relative path reference', () => {\n-    const context = new MockAotContext('.', SIMPLE_LIBRARY_WITH_IMPLIED_INDEX);\n-    const host = new MockCompilerHost(context);\n-    const options: ts.CompilerOptions = {\n-      moduleResolution: ts.ModuleResolutionKind.NodeJs,\n-      module: ts.ModuleKind.CommonJS,\n-      target: ts.ScriptTarget.ES5,\n-    };\n-    const adapter = new CompilerHostAdapter(host, null, options);\n-    const metadata = adapter.getMetadataFor('./lib/src/two', '.');\n-\n-    expect(metadata).toBeDefined();\n-    expect(Object.keys(metadata!.metadata).sort()).toEqual([\n-      'PrivateTwo',\n-      'TWO_CLASSES',\n-      'Two',\n-      'TwoMore',\n-    ]);\n-  });\n-\n-  it('should fail to retrieve metadata for an implied index with classic module resolution', () => {\n-    const context = new MockAotContext('.', SIMPLE_LIBRARY_WITH_IMPLIED_INDEX);\n-    const host = new MockCompilerHost(context);\n-    const options: ts.CompilerOptions = {\n-      moduleResolution: ts.ModuleResolutionKind.Classic,\n-      module: ts.ModuleKind.CommonJS,\n-      target: ts.ScriptTarget.ES5,\n-    };\n-    const adapter = new CompilerHostAdapter(host, null, options);\n-    const metadata = adapter.getMetadataFor('./lib/src/two', '.');\n-\n-    expect(metadata).toBeUndefined();\n-  });\n-\n-  it('should retrieve exports for an explicit index relative path reference', () => {\n-    const context = new MockAotContext('.', SIMPLE_LIBRARY);\n-    const host = new MockCompilerHost(context);\n-    const options: ts.CompilerOptions = {\n-      moduleResolution: ts.ModuleResolutionKind.NodeJs,\n-      module: ts.ModuleKind.CommonJS,\n-      target: ts.ScriptTarget.ES5,\n-    };\n-    const adapter = new CompilerHostAdapter(host, null, options);\n-    const metadata = adapter.getMetadataFor('./lib/src/index', '.');\n-\n-    expect(metadata).toBeDefined();\n-    expect(metadata!.exports!.map(e => e.export !)\n-               .reduce((prev, next) => prev.concat(next), [])\n-               .sort())\n-        .toEqual([\n-          'ONE_CLASSES',\n-          'One',\n-          'OneMore',\n-          'TWO_CLASSES',\n-          'Two',\n-          'TwoMore',\n-        ]);\n-  });\n-\n-  it('should look for .ts file when resolving metadata via a package.json \"main\" entry', () => {\n-    const files = {\n-      'lib': {\n-        'one.ts': `\n-          class One {}\n-          class OneMore extends One {}\n-          class PrivateOne {}\n-          const ONE_CLASSES = [One, OneMore, PrivateOne];\n-          export {One, OneMore, PrivateOne, ONE_CLASSES};\n-        `,\n-        'one.js': `\n-          // This will throw an error if the metadata collector tries to load one.js\n-        `,\n-        'package.json': `\n-        {\n-          \"main\": \"one\"\n-        }\n-        `\n-      }\n-    };\n-\n-    const context = new MockAotContext('.', files);\n-    const host = new MockCompilerHost(context);\n-    const options: ts.CompilerOptions = {\n-      moduleResolution: ts.ModuleResolutionKind.NodeJs,\n-      module: ts.ModuleKind.CommonJS,\n-      target: ts.ScriptTarget.ES5,\n-    };\n-    const adapter = new CompilerHostAdapter(host, null, options);\n-    const metadata = adapter.getMetadataFor('./lib', '.');\n-\n-    expect(metadata).toBeDefined();\n-    expect(Object.keys(metadata!.metadata).sort()).toEqual([\n-      'ONE_CLASSES',\n-      'One',\n-      'OneMore',\n-      'PrivateOne',\n-    ]);\n-    expect(Array.isArray(metadata!.metadata!['ONE_CLASSES'])).toBeTruthy();\n-  });\n-\n-  it('should look for non-declaration file when resolving metadata via a package.json \"types\" entry',\n-     () => {\n-       const files = {\n-         'lib': {\n-           'one.ts': `\n-          class One {}\n-          class OneMore extends One {}\n-          class PrivateOne {}\n-          const ONE_CLASSES = [One, OneMore, PrivateOne];\n-          export {One, OneMore, PrivateOne, ONE_CLASSES};\n-        `,\n-           'one.d.ts': `\n-          declare class One {\n-          }\n-          declare class OneMore extends One {\n-          }\n-          declare class PrivateOne {\n-          }\n-          declare const ONE_CLASSES: (typeof One)[];\n-          export { One, OneMore, PrivateOne, ONE_CLASSES };\n-        `,\n-           'one.js': `\n-          // This will throw an error if the metadata collector tries to load one.js\n-        `,\n-           'package.json': `\n-        {\n-          \"main\": \"one\",\n-          \"types\": \"one.d.ts\"\n-        }\n-        `\n-         }\n-       };\n-\n-       const context = new MockAotContext('.', files);\n-       const host = new MockCompilerHost(context);\n-       const options: ts.CompilerOptions = {\n-         moduleResolution: ts.ModuleResolutionKind.NodeJs,\n-         module: ts.ModuleKind.CommonJS,\n-         target: ts.ScriptTarget.ES5,\n-       };\n-       const adapter = new CompilerHostAdapter(host, null, options);\n-       const metadata = adapter.getMetadataFor('./lib', '.');\n-\n-       expect(metadata).toBeDefined();\n-       expect(Object.keys(metadata!.metadata).sort()).toEqual([\n-         'ONE_CLASSES',\n-         'One',\n-         'OneMore',\n-         'PrivateOne',\n-       ]);\n-       expect(Array.isArray(metadata!.metadata!['ONE_CLASSES'])).toBeTruthy();\n-     });\n-});\n-\n-describe('metadata bundler', () => {\n-  it('should be able to bundle a simple library', () => {\n-    const host = new MockStringBundlerHost('/', SIMPLE_LIBRARY);\n-    const bundler = new MetadataBundler('/lib/index', undefined, host, 'prfx_');\n-    const result = bundler.getMetadataBundle();\n-    expect(Object.keys(result.metadata.metadata).sort()).toEqual([\n-      'ONE_CLASSES', 'One', 'OneMore', 'TWO_CLASSES', 'Two', 'TwoMore', 'ɵprfx_a', 'ɵprfx_b'\n-    ]);\n-\n-    const originalOne = './src/one';\n-    const originalTwo = './src/two/index';\n-    expect(Object.keys(result.metadata.origins!)\n-               .sort()\n-               .map(name => ({name, value: result.metadata.origins![name]})))\n-        .toEqual([\n-          {name: 'ONE_CLASSES', value: originalOne}, {name: 'One', value: originalOne},\n-          {name: 'OneMore', value: originalOne}, {name: 'TWO_CLASSES', value: originalTwo},\n-          {name: 'Two', value: originalTwo}, {name: 'TwoMore', value: originalTwo},\n-          {name: 'ɵprfx_a', value: originalOne}, {name: 'ɵprfx_b', value: originalTwo}\n-        ]);\n-    expect(result.privates).toEqual([\n-      {privateName: 'ɵprfx_a', name: 'PrivateOne', module: originalOne},\n-      {privateName: 'ɵprfx_b', name: 'PrivateTwo', module: originalTwo}\n-    ]);\n-  });\n-\n-  it('should rewrite call expression references for static class members', () => {\n-    const host = new MockStringBundlerHost('/', {\n-      'lib': {\n-        'index.ts': `export * from './deep/index';`,\n-        'shared.ts': `\n-          export function sharedFn() {\n-            return {foo: true};\n-          }`,\n-        'deep': {\n-          'index.ts': `\n-            import {sharedFn} from '../shared';\n-\n-            export class MyClass {\n-              static ɵprov = sharedFn();\n-            }\n-          `,\n-        }\n-      }\n-    });\n-    const bundler = new MetadataBundler('/lib/index', undefined, host);\n-    const bundledMetadata = bundler.getMetadataBundle().metadata;\n-    const deepIndexMetadata = host.getMetadataFor('/lib/deep/index')!;\n-\n-    // The unbundled metadata should reference symbols using the relative module path.\n-    expect(deepIndexMetadata.metadata['MyClass']).toEqual(jasmine.objectContaining<MetadataEntry>({\n-      statics: {\n-        ɵprov: {\n-          __symbolic: 'call',\n-          expression: {\n-            __symbolic: 'reference',\n-            name: 'sharedFn',\n-            module: '../shared',\n-          }\n-        }\n-      }\n-    }));\n-\n-    // For the bundled metadata, the \"sharedFn\" symbol should not be referenced using the\n-    // relative module path (like for unbundled), because the metadata bundle can be stored\n-    // anywhere and it's not guaranteed that the relatively referenced files are present.\n-    expect(bundledMetadata.metadata['MyClass']).toEqual(jasmine.objectContaining<MetadataEntry>({\n-      statics: {\n-        ɵprov: {\n-          __symbolic: 'call',\n-          expression: {\n-            __symbolic: 'reference',\n-            name: 'ɵa',\n-          }\n-        }\n-      }\n-    }));\n-  });\n-\n-  it('should be able to bundle an oddly constructed library', () => {\n-    const host = new MockStringBundlerHost('/', {\n-      'lib': {\n-        'index.ts': `\n-          export * from './src/index';\n-        `,\n-        'src': {\n-          'index.ts': `\n-            export {One, OneMore, ONE_CLASSES} from './one';\n-            export {Two, TwoMore, TWO_CLASSES} from './two/index';\n-          `,\n-          'one.ts': `\n-            class One {}\n-            class OneMore extends One {}\n-            class PrivateOne {}\n-            const ONE_CLASSES = [One, OneMore, PrivateOne];\n-            export {One, OneMore, PrivateOne, ONE_CLASSES};\n-          `,\n-          'two': {\n-            'index.ts': `\n-              class Two {}\n-              class TwoMore extends Two {}\n-              class PrivateTwo {}\n-              const TWO_CLASSES = [Two, TwoMore, PrivateTwo];\n-              export {Two, TwoMore, PrivateTwo, TWO_CLASSES};\n-            `\n-          }\n-        }\n-      }\n-    });\n-    const bundler = new MetadataBundler('/lib/index', undefined, host);\n-    const result = bundler.getMetadataBundle();\n-    expect(Object.keys(result.metadata.metadata).sort()).toEqual([\n-      'ONE_CLASSES', 'One', 'OneMore', 'TWO_CLASSES', 'Two', 'TwoMore', 'ɵa', 'ɵb'\n-    ]);\n-    expect(result.privates).toEqual([\n-      {privateName: 'ɵa', name: 'PrivateOne', module: './src/one'},\n-      {privateName: 'ɵb', name: 'PrivateTwo', module: './src/two/index'}\n-    ]);\n-  });\n-\n-  it('should not output windows paths in metadata', () => {\n-    const host = new MockStringBundlerHost('/', {\n-      'index.ts': `\n-        export * from './exports/test';\n-      `,\n-      'exports': {'test.ts': `export class TestExport {}`}\n-    });\n-    const bundler = new MetadataBundler('/index', undefined, host);\n-    const result = bundler.getMetadataBundle();\n-\n-    expect(result.metadata.origins).toEqual({'TestExport': './exports/test'});\n-  });\n-\n-  it('should convert re-exported to the export', () => {\n-    const host = new MockStringBundlerHost('/', {\n-      'index.ts': `\n-        export * from './bar';\n-        export * from './foo';\n-      `,\n-      'bar.ts': `\n-        import {Foo} from './foo';\n-        export class Bar extends Foo {\n-\n-        }\n-      `,\n-      'foo.ts': `\n-        export {Foo} from 'foo';\n-      `\n-    });\n-    const bundler = new MetadataBundler('/index', undefined, host);\n-    const result = bundler.getMetadataBundle();\n-    // Expect the extends reference to refer to the imported module\n-    expect((result.metadata.metadata as any).Bar.extends.module).toEqual('foo');\n-    expect(result.privates).toEqual([]);\n-  });\n-\n-  it('should treat import then export as a simple export', () => {\n-    const host = new MockStringBundlerHost('/', {\n-      'index.ts': `\n-        export * from './a';\n-        export * from './c';\n-      `,\n-      'a.ts': `\n-        import { B } from './b';\n-        export { B };\n-      `,\n-      'b.ts': `\n-        export class B { }\n-      `,\n-      'c.ts': `\n-        import { B } from './b';\n-        export class C extends B { }\n-      `\n-    });\n-    const bundler = new MetadataBundler('/index', undefined, host);\n-    const result = bundler.getMetadataBundle();\n-    expect(Object.keys(result.metadata.metadata).sort()).toEqual(['B', 'C']);\n-    expect(result.privates).toEqual([]);\n-  });\n-\n-  it('should be able to bundle a private from a un-exported module', () => {\n-    const host = new MockStringBundlerHost('/', {\n-      'index.ts': `\n-        export * from './foo';\n-      `,\n-      'foo.ts': `\n-        import {Bar} from './bar';\n-        export class Foo extends Bar {\n-\n-        }\n-      `,\n-      'bar.ts': `\n-        export class Bar {}\n-      `\n-    });\n-    const bundler = new MetadataBundler('/index', undefined, host);\n-    const result = bundler.getMetadataBundle();\n-    expect(Object.keys(result.metadata.metadata).sort()).toEqual(['Foo', 'ɵa']);\n-    expect(result.privates).toEqual([{privateName: 'ɵa', name: 'Bar', module: './bar'}]);\n-  });\n-\n-  it('should be able to bundle a library with re-exported symbols', () => {\n-    const host = new MockStringBundlerHost('/', {\n-      'public-api.ts': `\n-        export * from './src/core';\n-        export * from './src/externals';\n-      `,\n-      'src': {\n-        'core.ts': `\n-          export class A {}\n-          export class B extends A {}\n-        `,\n-        'externals.ts': `\n-          export {E, F, G} from 'external_one';\n-          export * from 'external_two';\n-        `\n-      }\n-    });\n-\n-    const bundler = new MetadataBundler('/public-api', undefined, host);\n-    const result = bundler.getMetadataBundle();\n-    expect(result.metadata.exports).toEqual([\n-      {from: 'external_two'}, {\n-        export: [{name: 'E', as: 'E'}, {name: 'F', as: 'F'}, {name: 'G', as: 'G'}],\n-        from: 'external_one'\n-      }\n-    ]);\n-    expect(result.metadata.origins!['E']).toBeUndefined();\n-  });\n-\n-  it('should be able to bundle a library with multiple unnamed re-exports', () => {\n-    const host = new MockStringBundlerHost('/', {\n-      'public-api.ts': `\n-        export * from '@mypkg/secondary1';\n-        export * from '@mypkg/secondary2';\n-      `,\n-    });\n-\n-    const bundler = new MetadataBundler('/public-api', undefined, host);\n-    const result = bundler.getMetadataBundle();\n-    expect(result.metadata.exports).toEqual([\n-      {from: '@mypkg/secondary1'}, {from: '@mypkg/secondary2'}\n-    ]);\n-  });\n-\n-  it('should be able to de-duplicate symbols of re-exported modules', () => {\n-    const host = new MockStringBundlerHost('/', {\n-      'public-api.ts': `\n-        export {A as A2, A, B as B1, B as B2} from './src/core';\n-        export {A as A3} from './src/alternate';\n-      `,\n-      'src': {\n-        'core.ts': `\n-          export class A {}\n-          export class B {}\n-        `,\n-        'alternate.ts': `\n-          export class A {}\n-        `,\n-      }\n-    });\n-\n-    const bundler = new MetadataBundler('/public-api', undefined, host);\n-    const result = bundler.getMetadataBundle();\n-    const {A, A2, A3, B1, B2} = result.metadata.metadata as {\n-      A: ClassMetadata,\n-      A2: MetadataGlobalReferenceExpression,\n-      A3: ClassMetadata,\n-      B1: ClassMetadata,\n-      B2: MetadataGlobalReferenceExpression\n-    };\n-    expect(A.__symbolic).toEqual('class');\n-    expect(A2.__symbolic).toEqual('reference');\n-    expect(A2.name).toEqual('A');\n-    expect(A3.__symbolic).toEqual('class');\n-    expect(B1.__symbolic).toEqual('class');\n-    expect(B2.__symbolic).toEqual('reference');\n-    expect(B2.name).toEqual('B1');\n-  });\n-});\n-\n-export class MockStringBundlerHost implements MetadataBundlerHost {\n-  collector = new MetadataCollector();\n-  adapter: CompilerHostAdapter;\n-\n-  constructor(private dirName: string, directory: Directory) {\n-    const context = new MockAotContext(dirName, directory);\n-    const host = new MockCompilerHost(context);\n-    const options = {\n-      moduleResolution: ts.ModuleResolutionKind.NodeJs,\n-      module: ts.ModuleKind.CommonJS,\n-      target: ts.ScriptTarget.ES5,\n-    };\n-    this.adapter = new CompilerHostAdapter(host, null, options);\n-  }\n-\n-  getMetadataFor(moduleName: string): ModuleMetadata|undefined {\n-    return this.adapter.getMetadataFor(moduleName, this.dirName);\n-  }\n-}\n-\n-export const SIMPLE_LIBRARY = {\n-  'lib': {\n-    'index.ts': `\n-      export * from './src/index';\n-    `,\n-    'src': {\n-      'index.ts': `\n-        export {One, OneMore, ONE_CLASSES} from './one';\n-        export {Two, TwoMore, TWO_CLASSES} from './two/index';\n-      `,\n-      'one.ts': `\n-        export class One {}\n-        export class OneMore extends One {}\n-        export class PrivateOne {}\n-        export const ONE_CLASSES = [One, OneMore, PrivateOne];\n-      `,\n-      'two': {\n-        'index.ts': `\n-          export class Two {}\n-          export class TwoMore extends Two {}\n-          export class PrivateTwo {}\n-          export const TWO_CLASSES = [Two, TwoMore, PrivateTwo];\n-        `\n-      }\n-    }\n-  }\n-};\n-\n-export const SIMPLE_LIBRARY_WITH_IMPLIED_INDEX = {\n-  'lib': {\n-    'index.ts': `\n-      export * from './src';\n-    `,\n-    'src': {\n-      'index.ts': `\n-        export {One, OneMore, ONE_CLASSES} from './one';\n-        export {Two, TwoMore, TWO_CLASSES} from './two';\n-      `,\n-      'one.ts': `\n-        export class One {}\n-        export class OneMore extends One {}\n-        export class PrivateOne {}\n-        export const ONE_CLASSES = [One, OneMore, PrivateOne];\n-      `,\n-      'two': {\n-        'index.ts': `\n-          export class Two {}\n-          export class TwoMore extends Two {}\n-          export class PrivateTwo {}\n-          export const TWO_CLASSES = [Two, TwoMore, PrivateTwo];\n-        `\n-      }\n-    }\n-  }\n-};"
        },
        {
            "sha": "35b145b886d166ffae4b93b216069a0079dcf591",
            "filename": "packages/compiler-cli/test/metadata/collector_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 1674,
            "changes": 1674,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2Fcollector_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2Fcollector_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2Fcollector_spec.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,1674 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {MetadataCollector} from '../../src/metadata/collector';\n-import {ClassMetadata, ConstructorMetadata, isClassMetadata, isMetadataGlobalReferenceExpression, METADATA_VERSION, MetadataEntry, MetadataMap, MetadataSymbolicExpression, ModuleMetadata} from '../../src/metadata/schema';\n-\n-import {Directory, expectValidSources, Host} from './typescript.mocks';\n-\n-describe('Collector', () => {\n-  const documentRegistry = ts.createDocumentRegistry();\n-  let host: Host;\n-  let service: ts.LanguageService;\n-  let program: ts.Program;\n-  let collector: MetadataCollector;\n-\n-  beforeEach(() => {\n-    host = new Host(FILES, [\n-      '/app/app.component.ts',    '/app/cases-data.ts',\n-      '/app/error-cases.ts',      '/promise.ts',\n-      '/unsupported-1.ts',        '/unsupported-2.ts',\n-      '/unsupported-3.ts',        'class-arity.ts',\n-      'declarations.d.ts',        'import-star.ts',\n-      'exported-classes.ts',      'exported-functions.ts',\n-      'exported-enum.ts',         'exported-type.ts',\n-      'exported-consts.ts',       'local-symbol-ref.ts',\n-      'local-function-ref.ts',    'local-symbol-ref-func.ts',\n-      'private-enum.ts',          're-exports.ts',\n-      're-exports-2.ts',          'export-as.d.ts',\n-      'named-module.d.ts',        'static-field-reference.ts',\n-      'static-method.ts',         'static-method-call.ts',\n-      'static-method-with-if.ts', 'static-method-with-default.ts',\n-      'class-inheritance.ts',     'class-inheritance-parent.ts',\n-      'interface-reference.ts',   'static-type-check-members.ts',\n-    ]);\n-    service = ts.createLanguageService(host, documentRegistry);\n-    program = service.getProgram()!;\n-    collector = new MetadataCollector({quotedNames: true});\n-  });\n-\n-  it('should not have errors in test data', () => {\n-    expectValidSources(service, program);\n-  });\n-\n-  it('should return undefined for modules that have no metadata', () => {\n-    const sourceFile = program.getSourceFile('app/empty.ts')!;\n-    const metadata = collector.getMetadata(sourceFile);\n-    expect(metadata).toBeUndefined();\n-  });\n-\n-  it('should treat all symbols of .d.ts files as exported', () => {\n-    const sourceFile = program.getSourceFile('declarations.d.ts')!;\n-    const metadata = collector.getMetadata(sourceFile);\n-    expect(metadata).toEqual({\n-      __symbolic: 'module',\n-      version: METADATA_VERSION,\n-      metadata: {\n-        DeclaredClass: {__symbolic: 'class'},\n-        declaredFn: {__symbolic: 'function'} as any,\n-      }\n-    });\n-  });\n-\n-  it('should return an interface reference for types', () => {\n-    const sourceFile = program.getSourceFile('/exported-type.ts')!;\n-    const metadata = collector.getMetadata(sourceFile);\n-    expect(metadata).toEqual({\n-      __symbolic: 'module',\n-      version: METADATA_VERSION,\n-      metadata: {SomeType: {__symbolic: 'interface'}}\n-    });\n-  });\n-\n-  it('should return an interface reference for interfaces', () => {\n-    const sourceFile = program.getSourceFile('app/hero.ts')!;\n-    const metadata = collector.getMetadata(sourceFile);\n-    expect(metadata).toEqual({\n-      __symbolic: 'module',\n-      version: METADATA_VERSION,\n-      metadata: {Hero: {__symbolic: 'interface'}}\n-    });\n-  });\n-\n-  it('should preserve module names from TypeScript sources', () => {\n-    const sourceFile = program.getSourceFile('named-module.d.ts')!;\n-    const metadata = collector.getMetadata(sourceFile);\n-    expect(metadata!['importAs']).toEqual('some-named-module');\n-  });\n-\n-  it('should be able to collect a simple component\\'s metadata', () => {\n-    const sourceFile = program.getSourceFile('app/hero-detail.component.ts')!;\n-    const metadata = collector.getMetadata(sourceFile);\n-    expect(metadata).toEqual({\n-      __symbolic: 'module',\n-      version: METADATA_VERSION,\n-      metadata: {\n-        HeroDetailComponent: {\n-          __symbolic: 'class',\n-          decorators: [{\n-            __symbolic: 'call',\n-            expression: {\n-              __symbolic: 'reference',\n-              module: 'angular2/core',\n-              name: 'Component',\n-              line: 4,\n-              character: 7\n-            },\n-            arguments: [{\n-              selector: 'my-hero-detail',\n-              template: `\n-        <div *ngIf=\"hero\">\n-          <h2>{{hero.name}} details!</h2>\n-          <div><label>id: </label>{{hero.id}}</div>\n-          <div>\n-            <label>name: </label>\n-            <input [(ngModel)]=\"hero.name\" placeholder=\"name\"/>\n-          </div>\n-        </div>\n-      `\n-            }]\n-          }],\n-          members: {\n-            hero: [{\n-              __symbolic: 'property',\n-              decorators: [{\n-                __symbolic: 'call',\n-                expression: {\n-                  __symbolic: 'reference',\n-                  module: 'angular2/core',\n-                  name: 'Input',\n-                  line: 18,\n-                  character: 9\n-                }\n-              }]\n-            }]\n-          }\n-        }\n-      }\n-    });\n-  });\n-\n-  it('should be able to get a more complicated component\\'s metadata', () => {\n-    const sourceFile = program.getSourceFile('/app/app.component.ts')!;\n-    const metadata = collector.getMetadata(sourceFile);\n-    expect(metadata).toEqual({\n-      __symbolic: 'module',\n-      version: METADATA_VERSION,\n-      metadata: {\n-        AppComponent: {\n-          __symbolic: 'class',\n-          decorators: [{\n-            __symbolic: 'call',\n-            expression: {\n-              __symbolic: 'reference',\n-              module: 'angular2/core',\n-              name: 'Component',\n-              line: 9,\n-              character: 7\n-            },\n-            arguments: [{\n-              selector: 'my-app',\n-              template: `\n-        <h2>My Heroes</h2>\n-        <ul class=\"heroes\">\n-          <li *ngFor=\"#hero of heroes\"\n-            (click)=\"onSelect(hero)\"\n-            [class.selected]=\"hero === selectedHero\">\n-            <span class=\"badge\">{{hero.id | lowercase}}</span> {{hero.name | uppercase}}\n-          </li>\n-        </ul>\n-        <my-hero-detail [hero]=\"selectedHero\"></my-hero-detail>\n-        `,\n-              directives: [\n-                {\n-                  __symbolic: 'reference',\n-                  module: './hero-detail.component',\n-                  name: 'HeroDetailComponent',\n-                  line: 22,\n-                  character: 21\n-                },\n-                {\n-                  __symbolic: 'reference',\n-                  module: 'angular2/common',\n-                  name: 'NgFor',\n-                  line: 22,\n-                  character: 42\n-                }\n-              ],\n-              providers: [{\n-                __symbolic: 'reference',\n-                module: './hero.service',\n-                default: true,\n-                line: 23,\n-                character: 20\n-              }],\n-              pipes: [\n-                {\n-                  __symbolic: 'reference',\n-                  module: 'angular2/common',\n-                  name: 'LowerCasePipe',\n-                  line: 24,\n-                  character: 16\n-                },\n-                {\n-                  __symbolic: 'reference',\n-                  module: 'angular2/common',\n-                  name: 'UpperCasePipe',\n-                  line: 24,\n-                  character: 38\n-                }\n-              ]\n-            }]\n-          }],\n-          members: {\n-            __ctor__: [{\n-              __symbolic: 'constructor',\n-              parameters: [{\n-                __symbolic: 'reference',\n-                module: './hero.service',\n-                default: true,\n-                line: 31,\n-                character: 42\n-              }]\n-            }],\n-            onSelect: [{__symbolic: 'method'}],\n-            ngOnInit: [{__symbolic: 'method'}],\n-            getHeroes: [{__symbolic: 'method'}]\n-          }\n-        }\n-      }\n-    });\n-  });\n-\n-  it('should return the values of exported variables', () => {\n-    const sourceFile = program.getSourceFile('/app/mock-heroes.ts')!;\n-    const metadata = collector.getMetadata(sourceFile);\n-    expect(metadata).toEqual({\n-      __symbolic: 'module',\n-      version: METADATA_VERSION,\n-      metadata: {\n-        HEROES: [\n-          {'id': 11, 'name': 'Dr Nice', '$quoted$': ['id', 'name']},\n-          {'id': 12, 'name': 'Narco', '$quoted$': ['id', 'name']},\n-          {'id': 13, 'name': 'Bombasto', '$quoted$': ['id', 'name']},\n-          {'id': 14, 'name': 'Celeritas', '$quoted$': ['id', 'name']},\n-          {'id': 15, 'name': 'Magneta', '$quoted$': ['id', 'name']},\n-          {'id': 16, 'name': 'RubberMan', '$quoted$': ['id', 'name']},\n-          {'id': 17, 'name': 'Dynama', '$quoted$': ['id', 'name']},\n-          {'id': 18, 'name': 'Dr IQ', '$quoted$': ['id', 'name']},\n-          {'id': 19, 'name': 'Magma', '$quoted$': ['id', 'name']},\n-          {'id': 20, 'name': 'Tornado', '$quoted$': ['id', 'name']}\n-        ]\n-      }\n-    });\n-  });\n-\n-  let casesFile: ts.SourceFile;\n-  let casesMetadata: ModuleMetadata;\n-\n-  beforeEach(() => {\n-    casesFile = program.getSourceFile('/app/cases-data.ts')!;\n-    casesMetadata = collector.getMetadata(casesFile)!;\n-  });\n-\n-  it('should provide any reference for an any ctor parameter type', () => {\n-    const casesAny = <ClassMetadata>casesMetadata.metadata['CaseAny'];\n-    expect(casesAny).toBeTruthy();\n-    const ctorData = casesAny.members!['__ctor__'] as ConstructorMetadata[];\n-    expect(ctorData).toEqual([{\n-      __symbolic: 'constructor',\n-      parameters: [{__symbolic: 'reference', name: 'any'} as MetadataSymbolicExpression]\n-    }]);\n-  });\n-\n-  it('should record annotations on set and get declarations', () => {\n-    const propertyData = (line: number) => ({\n-      name: [{\n-        __symbolic: 'property',\n-        decorators: [{\n-          __symbolic: 'call',\n-          expression:\n-              {__symbolic: 'reference', module: 'angular2/core', name: 'Input', line, character: 9},\n-          arguments: ['firstName']\n-        }]\n-      }]\n-    } as any as MetadataMap);  // TODO: Review use of `any` here (#19904)\n-\n-    const caseGetProp = <ClassMetadata>casesMetadata.metadata['GetProp'];\n-    expect(caseGetProp.members).toEqual(propertyData(11));\n-    const caseSetProp = <ClassMetadata>casesMetadata.metadata['SetProp'];\n-    expect(caseSetProp.members).toEqual(propertyData(19));\n-    const caseFullProp = <ClassMetadata>casesMetadata.metadata['FullProp'];\n-    expect(caseFullProp.members).toEqual(propertyData(27));\n-  });\n-\n-  it('should record references to parameterized types', () => {\n-    const casesForIn = <ClassMetadata>casesMetadata.metadata['NgFor'];\n-    expect(casesForIn).toEqual({\n-      __symbolic: 'class',\n-      decorators: [{\n-        __symbolic: 'call',\n-        expression: {\n-          __symbolic: 'reference',\n-          module: 'angular2/core',\n-          name: 'Injectable',\n-          line: 40,\n-          character: 7\n-        }\n-      }],\n-      members: {\n-        __ctor__: [{\n-          __symbolic: 'constructor',\n-          parameters: [{\n-            __symbolic: 'reference',\n-            name: 'ClassReference',\n-            arguments: [{__symbolic: 'reference', name: 'NgForRow'}]\n-          }]\n-        }]\n-      }\n-    } as any as ClassMetadata);  // TODO: Review use of `any` here (#19904)\n-  });\n-\n-  it('should report errors for destructured imports', () => {\n-    const unsupported1 = program.getSourceFile('/unsupported-1.ts')!;\n-    const metadata = collector.getMetadata(unsupported1);\n-    expect(metadata).toEqual({\n-      __symbolic: 'module',\n-      version: METADATA_VERSION,\n-      metadata: {\n-        a: {__symbolic: 'error', message: 'Destructuring not supported', line: 1, character: 16},\n-        b: {__symbolic: 'error', message: 'Destructuring not supported', line: 1, character: 19},\n-        c: {__symbolic: 'error', message: 'Destructuring not supported', line: 2, character: 16},\n-        d: {__symbolic: 'error', message: 'Destructuring not supported', line: 2, character: 19},\n-        e: {__symbolic: 'error', message: 'Variable not initialized', line: 3, character: 15}\n-      }\n-    });\n-  });\n-\n-  it('should report an error for references to unexpected types', () => {\n-    const unsupported1 = program.getSourceFile('/unsupported-2.ts')!;\n-    const metadata = collector.getMetadata(unsupported1)!;\n-    const barClass = <ClassMetadata>metadata.metadata['Bar'];\n-    const ctor = <ConstructorMetadata>barClass.members!['__ctor__'][0];\n-    const parameter = ctor.parameters![0];\n-    expect(parameter).toEqual({\n-      __symbolic: 'error',\n-      message: 'Reference to non-exported class',\n-      line: 3,\n-      character: 4,\n-      context: {className: 'Foo'}\n-    });\n-  });\n-\n-  it('should be able to handle import star type references', () => {\n-    const importStar = program.getSourceFile('/import-star.ts')!;\n-    const metadata = collector.getMetadata(importStar)!;\n-    const someClass = <ClassMetadata>metadata.metadata['SomeClass'];\n-    const ctor = <ConstructorMetadata>someClass.members!['__ctor__'][0];\n-    const parameters = ctor.parameters;\n-    expect(parameters).toEqual([\n-      {__symbolic: 'reference', module: 'angular2/common', name: 'NgFor', line: 6, character: 29} as\n-      MetadataSymbolicExpression\n-    ]);\n-  });\n-\n-  it('should record all exported classes', () => {\n-    const sourceFile = program.getSourceFile('/exported-classes.ts')!;\n-    const metadata = collector.getMetadata(sourceFile);\n-    expect(metadata).toEqual({\n-      __symbolic: 'module',\n-      version: METADATA_VERSION,\n-      metadata: {\n-        SimpleClass: {__symbolic: 'class'},\n-        AbstractClass: {__symbolic: 'class'},\n-        DeclaredClass: {__symbolic: 'class'}\n-      }\n-    });\n-  });\n-\n-  it('should be able to record functions', () => {\n-    const exportedFunctions = program.getSourceFile('/exported-functions.ts')!;\n-    const metadata = collector.getMetadata(exportedFunctions);\n-    expect(metadata).toEqual({\n-      __symbolic: 'module',\n-      version: METADATA_VERSION,\n-      metadata: {\n-        one: {\n-          __symbolic: 'function',\n-          parameters: ['a', 'b', 'c'],\n-          value: {\n-            a: {__symbolic: 'reference', name: 'a'},\n-            b: {__symbolic: 'reference', name: 'b'},\n-            c: {__symbolic: 'reference', name: 'c'}\n-          }\n-        },\n-        two: {\n-          __symbolic: 'function',\n-          parameters: ['a', 'b', 'c'],\n-          value: {\n-            a: {__symbolic: 'reference', name: 'a'},\n-            b: {__symbolic: 'reference', name: 'b'},\n-            c: {__symbolic: 'reference', name: 'c'}\n-          }\n-        },\n-        three: {\n-          __symbolic: 'function',\n-          parameters: ['a', 'b', 'c'],\n-          value: [\n-            {__symbolic: 'reference', name: 'a'}, {__symbolic: 'reference', name: 'b'},\n-            {__symbolic: 'reference', name: 'c'}\n-          ]\n-        },\n-        supportsState: {\n-          __symbolic: 'function',\n-          parameters: [],\n-          value: {\n-            __symbolic: 'pre',\n-            operator: '!',\n-            operand: {\n-              __symbolic: 'pre',\n-              operator: '!',\n-              operand: {\n-                __symbolic: 'select',\n-                expression: {\n-                  __symbolic: 'select',\n-                  expression: {__symbolic: 'reference', name: 'window'},\n-                  member: 'history'\n-                },\n-                member: 'pushState'\n-              }\n-            }\n-          }\n-        },\n-        complexFn: {__symbolic: 'function'} as any,\n-        declaredFn: {__symbolic: 'function'} as any,\n-      }\n-    });\n-  });\n-\n-  it('should be able to handle import star type references', () => {\n-    const importStar = program.getSourceFile('/import-star.ts')!;\n-    const metadata = collector.getMetadata(importStar)!;\n-    const someClass = <ClassMetadata>metadata.metadata['SomeClass'];\n-    const ctor = <ConstructorMetadata>someClass.members!['__ctor__'][0];\n-    const parameters = ctor.parameters;\n-    expect(parameters).toEqual([\n-      {__symbolic: 'reference', module: 'angular2/common', name: 'NgFor', line: 6, character: 29} as\n-      MetadataSymbolicExpression\n-    ]);\n-  });\n-\n-  it('should be able to collect the value of an enum', () => {\n-    const enumSource = program.getSourceFile('/exported-enum.ts')!;\n-    const metadata = collector.getMetadata(enumSource)!;\n-    const someEnum: any = metadata.metadata['SomeEnum'];\n-    expect(someEnum).toEqual({A: 0, B: 1, C: 100, D: 101});\n-  });\n-\n-  it('should ignore a non-export enum', () => {\n-    const enumSource = program.getSourceFile('/private-enum.ts')!;\n-    const metadata = collector.getMetadata(enumSource)!;\n-    const publicEnum: any = metadata.metadata['PublicEnum'];\n-    const privateEnum: any = metadata.metadata['PrivateEnum'];\n-    expect(publicEnum).toEqual({a: 0, b: 1, c: 2});\n-    expect(privateEnum).toBeUndefined();\n-  });\n-\n-  it('should be able to collect enums initialized from consts', () => {\n-    const enumSource = program.getSourceFile('/exported-enum.ts')!;\n-    const metadata = collector.getMetadata(enumSource)!;\n-    const complexEnum: any = metadata.metadata['ComplexEnum'];\n-    expect(complexEnum).toEqual({\n-      A: 0,\n-      B: 1,\n-      C: 30,\n-      D: 40,\n-      E: {\n-        __symbolic: 'reference',\n-        module: './exported-consts',\n-        name: 'constValue',\n-        line: 5,\n-        character: 75\n-      }\n-    });\n-  });\n-\n-  it('should be able to collect a simple static method', () => {\n-    const staticSource = program.getSourceFile('/static-method.ts')!;\n-    const metadata = collector.getMetadata(staticSource)!;\n-    expect(metadata).toBeDefined();\n-    const classData = <ClassMetadata>metadata.metadata['MyModule'];\n-    expect(classData).toBeDefined();\n-    expect(classData.statics).toEqual({\n-      with: {\n-        __symbolic: 'function',\n-        parameters: ['comp'],\n-        value: [\n-          {__symbolic: 'reference', name: 'MyModule'},\n-          {provider: 'a', useValue: {__symbolic: 'reference', name: 'comp'}}\n-        ]\n-      }\n-    });\n-  });\n-\n-  it('should be able to collect a call to a static method', () => {\n-    const staticSource = program.getSourceFile('/static-method-call.ts')!;\n-    const metadata = collector.getMetadata(staticSource)!;\n-    expect(metadata).toBeDefined();\n-    const classData = <ClassMetadata>metadata.metadata['Foo'];\n-    expect(classData).toBeDefined();\n-    expect(classData.decorators).toEqual([\n-      {\n-        __symbolic: 'call',\n-        expression: {\n-          __symbolic: 'reference',\n-          module: 'angular2/core',\n-          name: 'Component',\n-          line: 4,\n-          character: 5\n-        },\n-        arguments: [{\n-          providers: {\n-            __symbolic: 'call',\n-            expression: {\n-              __symbolic: 'select',\n-              expression: {\n-                __symbolic: 'reference',\n-                module: './static-method',\n-                name: 'MyModule',\n-                line: 5,\n-                character: 17\n-              },\n-              member: 'with'\n-            },\n-            arguments: ['a']\n-          }\n-        }]\n-      }\n-    ] as any as MetadataSymbolicExpression[]);  // TODO: Review use of `any` here (#19904)\n-  });\n-\n-  it('should be able to collect a static field', () => {\n-    const staticSource = program.getSourceFile('/static-field.ts')!;\n-    const metadata = collector.getMetadata(staticSource)!;\n-    expect(metadata).toBeDefined();\n-    const classData = <ClassMetadata>metadata.metadata['MyModule'];\n-    expect(classData).toBeDefined();\n-    expect(classData.statics).toEqual({VALUE: 'Some string'});\n-  });\n-\n-  it('should ignore static type check members without a value', () => {\n-    const typeCheckMembers = program.getSourceFile('/static-type-check-members.ts')!;\n-    const metadata = collector.getMetadata(typeCheckMembers)!;\n-    const classData = <ClassMetadata>metadata.metadata['MyDirective'];\n-    expect(classData.statics).toEqual({\n-      foo: 'bar',\n-      declared: {__symbolic: 'error', message: 'Variable not initialized', line: 3, character: 13},\n-      ngTemplateContextGuard: {__symbolic: 'function', parameters: ['dir', 'ctx'], value: true},\n-      ngTemplateGuard_value: {__symbolic: 'function', parameters: ['dir', 'expr'], value: true},\n-    });\n-  });\n-\n-  it('should be able to collect a reference to a static field', () => {\n-    const staticSource = program.getSourceFile('/static-field-reference.ts')!;\n-    const metadata = collector.getMetadata(staticSource)!;\n-    expect(metadata).toBeDefined();\n-    const classData = <ClassMetadata>metadata.metadata['Foo'];\n-    expect(classData).toBeDefined();\n-    expect(classData.decorators).toEqual([\n-      {\n-        __symbolic: 'call',\n-        expression: {\n-          __symbolic: 'reference',\n-          module: 'angular2/core',\n-          name: 'Component',\n-          line: 4,\n-          character: 5\n-        },\n-        arguments: [{\n-          providers: [{\n-            provide: 'a',\n-            useValue: {\n-              __symbolic: 'select',\n-              expression: {\n-                __symbolic: 'reference',\n-                module: './static-field',\n-                name: 'MyModule',\n-                line: 5,\n-                character: 45\n-              },\n-              member: 'VALUE'\n-            }\n-          }]\n-        }]\n-      }\n-    ] as any as MetadataSymbolicExpression[]);  // TODO: Review use of `any` here (#19904)\n-  });\n-\n-  it('should be able to collect a method with a conditional expression', () => {\n-    const source = program.getSourceFile('/static-method-with-if.ts')!;\n-    const metadata = collector.getMetadata(source)!;\n-    expect(metadata).toBeDefined();\n-    const classData = <ClassMetadata>metadata.metadata['MyModule'];\n-    expect(classData).toBeDefined();\n-    expect(classData.statics).toEqual({\n-      with: {\n-        __symbolic: 'function',\n-        parameters: ['cond'],\n-        value: [\n-          {__symbolic: 'reference', name: 'MyModule'}, {\n-            provider: 'a',\n-            useValue: {\n-              __symbolic: 'if',\n-              condition: {__symbolic: 'reference', name: 'cond'},\n-              thenExpression: '1',\n-              elseExpression: '2'\n-            }\n-          }\n-        ]\n-      }\n-    });\n-  });\n-\n-  it('should be able to collect a method with a default parameter', () => {\n-    const source = program.getSourceFile('/static-method-with-default.ts')!;\n-    const metadata = collector.getMetadata(source)!;\n-    expect(metadata).toBeDefined();\n-    const classData = <ClassMetadata>metadata.metadata['MyModule'];\n-    expect(classData).toBeDefined();\n-    expect(classData.statics).toEqual({\n-      with: {\n-        __symbolic: 'function',\n-        parameters: ['comp', 'foo', 'bar'],\n-        defaults: [undefined, true, false],\n-        value: [\n-          {__symbolic: 'reference', name: 'MyModule'}, {\n-            __symbolic: 'if',\n-            condition: {__symbolic: 'reference', name: 'foo'},\n-            thenExpression: {provider: 'a', useValue: {__symbolic: 'reference', name: 'comp'}},\n-            elseExpression: {provider: 'b', useValue: {__symbolic: 'reference', name: 'comp'}}\n-          },\n-          {\n-            __symbolic: 'if',\n-            condition: {__symbolic: 'reference', name: 'bar'},\n-            thenExpression: {provider: 'c', useValue: {__symbolic: 'reference', name: 'comp'}},\n-            elseExpression: {provider: 'd', useValue: {__symbolic: 'reference', name: 'comp'}}\n-          }\n-        ]\n-      }\n-    });\n-  });\n-\n-  it('should be able to collect re-exported symbols', () => {\n-    const source = program.getSourceFile('/re-exports.ts')!;\n-    const metadata = collector.getMetadata(source)!;\n-    expect(metadata.exports).toEqual([\n-      {from: './static-field', export: ['MyModule']},\n-      {from: './static-field-reference', export: [{name: 'Foo', as: 'OtherModule'}]},\n-      {from: 'angular2/core'}\n-    ]);\n-  });\n-\n-  it('should be able to collect a export as symbol', () => {\n-    const source = program.getSourceFile('export-as.d.ts')!;\n-    const metadata = collector.getMetadata(source)!;\n-    expect(metadata.metadata).toEqual({SomeFunction: {__symbolic: 'function'}});\n-  });\n-\n-  it('should be able to collect exports with no module specifier', () => {\n-    const source = program.getSourceFile('/re-exports-2.ts')!;\n-    const metadata = collector.getMetadata(source)!;\n-    expect(metadata.metadata).toEqual({\n-      MyClass: Object({__symbolic: 'class'}),\n-      OtherModule: {\n-        __symbolic: 'reference',\n-        module: './static-field-reference',\n-        name: 'Foo',\n-        line: 4,\n-        character: 12\n-      },\n-      MyOtherModule: {\n-        __symbolic: 'reference',\n-        module: './static-field',\n-        name: 'MyModule',\n-        line: 4,\n-        character: 25\n-      }\n-    });\n-  });\n-\n-  it('should collect an error symbol if collecting a reference to a non-exported symbol', () => {\n-    const source = program.getSourceFile('/local-symbol-ref.ts')!;\n-    const metadata = collector.getMetadata(source)!;\n-    expect(metadata.metadata).toEqual({\n-      REQUIRED_VALIDATOR: {\n-        __symbolic: 'error',\n-        message: 'Reference to a local symbol',\n-        line: 3,\n-        character: 8,\n-        context: {name: 'REQUIRED'}\n-      },\n-      SomeComponent: {\n-        __symbolic: 'class',\n-        decorators: [{\n-          __symbolic: 'call',\n-          expression: {\n-            __symbolic: 'reference',\n-            module: 'angular2/core',\n-            name: 'Component',\n-            line: 11,\n-            character: 5\n-          },\n-          arguments: [{providers: [{__symbolic: 'reference', name: 'REQUIRED_VALIDATOR'}]}]\n-        }]\n-      }\n-    });\n-  });\n-\n-  it('should collect an error symbol if collecting a reference to a non-exported function', () => {\n-    const source = program.getSourceFile('/local-function-ref.ts')!;\n-    const metadata = collector.getMetadata(source)!;\n-    expect(metadata.metadata).toEqual({\n-      REQUIRED_VALIDATOR: {\n-        __symbolic: 'error',\n-        message: 'Reference to a non-exported function',\n-        line: 3,\n-        character: 13,\n-        context: {name: 'required'}\n-      },\n-      SomeComponent: {\n-        __symbolic: 'class',\n-        decorators: [{\n-          __symbolic: 'call',\n-          expression: {\n-            __symbolic: 'reference',\n-            module: 'angular2/core',\n-            name: 'Component',\n-            line: 11,\n-            character: 5\n-          },\n-          arguments: [{providers: [{__symbolic: 'reference', name: 'REQUIRED_VALIDATOR'}]}]\n-        }]\n-      }\n-    });\n-  });\n-\n-  it('should collect an error for a simple function that references a local variable', () => {\n-    const source = program.getSourceFile('/local-symbol-ref-func.ts')!;\n-    const metadata = collector.getMetadata(source)!;\n-    expect(metadata.metadata).toEqual({\n-      foo: {\n-        __symbolic: 'function',\n-        parameters: ['index'],\n-        value: {\n-          __symbolic: 'error',\n-          message: 'Reference to a local symbol',\n-          line: 1,\n-          character: 8,\n-          context: {name: 'localSymbol'}\n-        }\n-      }\n-    });\n-  });\n-\n-  it('should collect any for interface parameter reference', () => {\n-    const source = program.getSourceFile('/interface-reference.ts')!;\n-    const metadata = collector.getMetadata(source)!;\n-    expect((metadata.metadata['SomeClass'] as ClassMetadata).members).toEqual({\n-      __ctor__: [{\n-        __symbolic: 'constructor',\n-        parameterDecorators: [[{\n-          __symbolic: 'call',\n-          expression: {\n-            __symbolic: 'reference',\n-            module: 'angular2/core',\n-            name: 'Inject',\n-            line: 6,\n-            character: 19\n-          },\n-          arguments: ['a']\n-        }]],\n-        parameters: [{__symbolic: 'reference', name: 'any'}]\n-      }]\n-    } as any as MetadataMap);  // TODO: Review use of `any` here (#19904)\n-  });\n-\n-  describe('with interpolations', () => {\n-    function e(expr: string, prefix?: string) {\n-      const metadata = collectSource(`${prefix || ''} export let value = ${expr};`);\n-      return expect(metadata.metadata['value']);\n-    }\n-\n-    it('should be able to collect a raw interpolated string', () => {\n-      e('`simple value`').toBe('simple value');\n-    });\n-\n-    it('should be able to interpolate a single value', () => {\n-      e('`${foo}`', 'const foo = \"foo value\"').toBe('foo value');\n-    });\n-\n-    it('should be able to interpolate multiple values', () => {\n-      e('`foo:${foo}, bar:${bar}, end`', 'const foo = \"foo\"; const bar = \"bar\";')\n-          .toBe('foo:foo, bar:bar, end');\n-    });\n-\n-    it('should be able to interpolate with an imported reference', () => {\n-      e('`external:${external}`', 'import {external} from \"./external\";').toEqual({\n-        __symbolic: 'binop',\n-        operator: '+',\n-        left: 'external:',\n-        right: {\n-          __symbolic: 'reference',\n-          module: './external',\n-          name: 'external',\n-          line: 0,\n-          character: 68,\n-        }\n-      });\n-    });\n-\n-    it('should simplify a redundant template', () => {\n-      e('`${external}`', 'import {external} from \"./external\";').toEqual({\n-        __symbolic: 'reference',\n-        module: './external',\n-        name: 'external',\n-        line: 0,\n-        character: 59\n-      });\n-    });\n-\n-    it('should be able to collect complex template with imported references', () => {\n-      e('`foo:${foo}, bar:${bar}, end`', 'import {foo, bar} from \"./external\";').toEqual({\n-        __symbolic: 'binop',\n-        operator: '+',\n-        left: {\n-          __symbolic: 'binop',\n-          operator: '+',\n-          left: {\n-            __symbolic: 'binop',\n-            operator: '+',\n-            left: {\n-              __symbolic: 'binop',\n-              operator: '+',\n-              left: 'foo:',\n-              right: {\n-                __symbolic: 'reference',\n-                module: './external',\n-                name: 'foo',\n-                line: 0,\n-                character: 63\n-              }\n-            },\n-            right: ', bar:'\n-          },\n-          right:\n-              {__symbolic: 'reference', module: './external', name: 'bar', line: 0, character: 75}\n-        },\n-        right: ', end'\n-      });\n-    });\n-\n-    it('should reject a tagged literal', () => {\n-      e('tag`some value`').toEqual({\n-        __symbolic: 'error',\n-        message: 'Tagged template expressions are not supported in metadata',\n-        line: 0,\n-        character: 20\n-      });\n-    });\n-  });\n-\n-  it('should ignore |null or |undefined in type expressions', () => {\n-    const metadata = collectSource(`\n-      import {Foo} from './foo';\n-      export class SomeClass {\n-        constructor (a: Foo, b: Foo | null, c: Foo | undefined, d: Foo | undefined | null, e: Foo | undefined | null | Foo) {}\n-      }\n-    `);\n-    expect((metadata.metadata['SomeClass'] as ClassMetadata).members).toEqual({\n-      __ctor__: [{\n-        __symbolic: 'constructor',\n-        parameters: [\n-          {__symbolic: 'reference', module: './foo', name: 'Foo', line: 3, character: 24},\n-          {__symbolic: 'reference', module: './foo', name: 'Foo', line: 3, character: 24},\n-          {__symbolic: 'reference', module: './foo', name: 'Foo', line: 3, character: 24},\n-          {__symbolic: 'reference', module: './foo', name: 'Foo', line: 3, character: 24},\n-          {__symbolic: 'reference', module: './foo', name: 'Foo', line: 3, character: 24}\n-        ]\n-      }]\n-    } as any as MetadataMap);  // TODO: Review use of `any` here (#19904)\n-  });\n-\n-  it('should treat exported class expressions as a class', () => {\n-    const source = ts.createSourceFile(\n-        '', `\n-    export const InjectionToken: {new<T>(desc: string): InjectionToken<T>;} = class {\n-      constructor(protected _desc: string) {}\n-\n-      toString(): string { return \\`InjectionToken \\${this._desc}\\`; }\n-    } as any;`,\n-        ts.ScriptTarget.Latest, true);\n-    const metadata = collector.getMetadata(source)!;\n-    expect(metadata.metadata).toEqual({InjectionToken: {__symbolic: 'class'}});\n-  });\n-\n-  describe('in strict mode', () => {\n-    it('should throw if an error symbol is collecting a reference to a non-exported symbol', () => {\n-      const source = program.getSourceFile('/local-symbol-ref.ts')!;\n-      expect(() => collector.getMetadata(source, true)).toThrowError(/Reference to a local symbol/);\n-    });\n-\n-    it('should throw if an error if collecting a reference to a non-exported function', () => {\n-      const source = program.getSourceFile('/local-function-ref.ts')!;\n-      expect(() => collector.getMetadata(source, true))\n-          .toThrowError(/Reference to a non-exported function/);\n-    });\n-\n-    it('should throw for references to unexpected types', () => {\n-      const unsupported2 = program.getSourceFile('/unsupported-2.ts')!;\n-      expect(() => collector.getMetadata(unsupported2, true))\n-          .toThrowError(/Reference to non-exported class/);\n-    });\n-\n-    it('should throw for errors in a static method', () => {\n-      const unsupported3 = program.getSourceFile('/unsupported-3.ts')!;\n-      expect(() => collector.getMetadata(unsupported3, true))\n-          .toThrowError(/Reference to a non-exported class/);\n-    });\n-  });\n-\n-  describe('with invalid input', () => {\n-    it('should not throw with a class with no name', () => {\n-      const fileName = '/invalid-class.ts';\n-      override(fileName, 'export class');\n-      const invalidClass = program.getSourceFile(fileName)!;\n-      expect(() => collector.getMetadata(invalidClass)).not.toThrow();\n-    });\n-\n-    it('should not throw with a function with no name', () => {\n-      const fileName = '/invalid-function.ts';\n-      override(fileName, 'export function');\n-      const invalidFunction = program.getSourceFile(fileName)!;\n-      expect(() => collector.getMetadata(invalidFunction)).not.toThrow();\n-    });\n-  });\n-\n-  describe(\n-      'inheritance', () => {\n-        it('should record `extends` clauses for declared classes',\n-           () => {\n-             const metadata =\n-                 collector.getMetadata(program.getSourceFile('/class-inheritance.ts')!)!;\n-             expect(metadata.metadata['DeclaredChildClass'])\n-          .toEqual({__symbolic: 'class', extends: {__symbolic: 'reference', name: 'ParentClass'}});\n-           });\n-\n-        it('should record `extends` clauses for classes in the same file',\n-           () => {\n-             const metadata =\n-                 collector.getMetadata(program.getSourceFile('/class-inheritance.ts')!)!;\n-             expect(metadata.metadata['ChildClassSameFile'])\n-          .toEqual({__symbolic: 'class', extends: {__symbolic: 'reference', name: 'ParentClass'}});\n-           });\n-\n-        it('should record `extends` clauses for classes in a different file', () => {\n-          const metadata = collector.getMetadata(program.getSourceFile('/class-inheritance.ts')!)!;\n-          expect(metadata.metadata['ChildClassOtherFile']).toEqual({\n-        __symbolic: 'class',\n-        extends: {\n-          __symbolic: 'reference',\n-          module: './class-inheritance-parent',\n-          name: 'ParentClassFromOtherFile',\n-          line: 9,\n-          character: 45,\n-        }\n-      });\n-        });\n-\n-        function expectClass(entry: MetadataEntry): entry is ClassMetadata {\n-          const result = isClassMetadata(entry);\n-          expect(result).toBeTruthy();\n-          return result;\n-        }\n-\n-        it('should collect the correct arity for a class', () => {\n-          const metadata = collector.getMetadata(program.getSourceFile('/class-arity.ts')!)!;\n-\n-          const zero = metadata.metadata['Zero'];\n-          if (expectClass(zero)) expect(zero.arity).toBeUndefined();\n-          const one = metadata.metadata['One'];\n-          if (expectClass(one)) expect(one.arity).toBe(1);\n-          const two = metadata.metadata['Two'];\n-          if (expectClass(two)) expect(two.arity).toBe(2);\n-          const three = metadata.metadata['Three'];\n-          if (expectClass(three)) expect(three.arity).toBe(3);\n-          const nine = metadata.metadata['Nine'];\n-          if (expectClass(nine)) expect(nine.arity).toBe(9);\n-        });\n-      });\n-\n-  describe('regression', () => {\n-    it('should be able to collect a short-hand property value', () => {\n-      const metadata = collectSource(`\n-        const children = { f1: 1 };\n-        export const r = [\n-          {path: ':locale', children}\n-        ];\n-      `);\n-      expect(metadata.metadata).toEqual({r: [{path: ':locale', children: {f1: 1}}]});\n-    });\n-\n-    // #17518\n-    it('should skip a default function', () => {\n-      const metadata = collectSource(`\n-        export default function () {\n-\n-          const mainRoutes = [\n-            {name: 'a', abstract: true, component: 'main'},\n-\n-            {name: 'a.welcome', url: '/welcome', component: 'welcome'}\n-          ];\n-\n-          return mainRoutes;\n-\n-        }`);\n-      expect(metadata).toBeUndefined();\n-    });\n-\n-    it('should skip a named default export', () => {\n-      const metadata = collectSource(`\n-        function mainRoutes() {\n-\n-          const mainRoutes = [\n-            {name: 'a', abstract: true, component: 'main'},\n-\n-            {name: 'a.welcome', url: '/welcome', component: 'welcome'}\n-          ];\n-\n-          return mainRoutes;\n-\n-        }\n-\n-        exports = foo;\n-        `);\n-      expect(metadata).toBeUndefined();\n-    });\n-\n-    it('should collect type guards', () => {\n-      const metadata = collectSource(`\n-        import {Directive, Input, TemplateRef} from '@angular/core';\n-\n-        @Directive({selector: '[myIf]'})\n-        export class MyIf {\n-\n-          constructor(private templateRef: TemplateRef) {}\n-\n-          @Input() myIf: any;\n-\n-          static typeGuard: <T>(v: T | null | undefined): v is T;\n-        }\n-      `);\n-\n-      expect((metadata.metadata.MyIf as any).statics.typeGuard)\n-          .not.toBeUndefined('typeGuard was not collected');\n-    });\n-  });\n-\n-  describe('references', () => {\n-    beforeEach(() => {\n-      collector = new MetadataCollector({quotedNames: true});\n-    });\n-\n-    it('should record a reference to an exported field of a useValue', () => {\n-      const metadata = collectSource(`\n-        export var someValue = 1;\n-        export const v = {\n-          useValue: someValue\n-        };\n-      `);\n-      expect(metadata.metadata['someValue']).toEqual(1);\n-      expect(metadata.metadata['v']).toEqual({\n-        useValue: {__symbolic: 'reference', name: 'someValue'}\n-      });\n-    });\n-\n-    it('should leave external references in place in an object literal', () => {\n-      const metadata = collectSource(`\n-        export const myLambda = () => [1, 2, 3];\n-        const indirect = [{a: 1, b: 3: c: myLambda}];\n-        export const v = {\n-          v: {i: indirect}\n-        }\n-      `);\n-      expect(metadata.metadata['v']).toEqual({\n-        v: {i: [{a: 1, b: 3, c: {__symbolic: 'reference', name: 'myLambda'}}]}\n-      });\n-    });\n-\n-    it('should leave an external reference in place in an array literal', () => {\n-      const metadata = collectSource(`\n-        export const myLambda = () => [1, 2, 3];\n-        const indirect = [1, 3, myLambda}];\n-        export const v = {\n-          v: {i: indirect}\n-        }\n-      `);\n-      expect(metadata.metadata['v']).toEqual({\n-        v: {i: [1, 3, {__symbolic: 'reference', name: 'myLambda'}]}\n-      });\n-    });\n-  });\n-\n-  describe('substitutions', () => {\n-    const lambdaTemp = 'lambdaTemp';\n-\n-    it('should be able to substitute a lambda', () => {\n-      const source = createSource(`\n-        const b = 1;\n-        export const a = () => b;\n-      `);\n-      const metadata = collector.getMetadata(source, /* strict */ false, (value, node) => {\n-        if (node.kind === ts.SyntaxKind.ArrowFunction) {\n-          return {__symbolic: 'reference', name: lambdaTemp};\n-        }\n-        return value;\n-      });\n-      expect(metadata!.metadata['a']).toEqual({__symbolic: 'reference', name: lambdaTemp});\n-    });\n-\n-    it('should compose substitution functions', () => {\n-      const collector = new MetadataCollector({\n-        substituteExpression: (value, node) =>\n-            isMetadataGlobalReferenceExpression(value) && value.name == lambdaTemp ?\n-            {__symbolic: 'reference', name: value.name + '2'} :\n-            value\n-      });\n-      const source = createSource(`\n-        const b = 1;\n-        export const a = () => b;\n-      `);\n-      const metadata = collector.getMetadata(source, /* strict */ false, (value, node) => {\n-        if (node.kind === ts.SyntaxKind.ArrowFunction) {\n-          return {__symbolic: 'reference', name: lambdaTemp};\n-        }\n-        return value;\n-      });\n-      expect(metadata!.metadata['a']).toEqual({__symbolic: 'reference', name: lambdaTemp + '2'});\n-    });\n-  });\n-\n-  function override(fileName: string, content: string) {\n-    host.overrideFile(fileName, content);\n-    host.addFile(fileName);\n-    program = service.getProgram()!;\n-  }\n-\n-  function collectSource(content: string): ModuleMetadata {\n-    const sourceFile = createSource(content);\n-    return collector.getMetadata(sourceFile)!;\n-  }\n-});\n-\n-// TODO: Do not use \\` in a template literal as it confuses clang-format\n-const FILES: Directory = {\n-  'app': {\n-    'app.component.ts': `\n-      import {Component as MyComponent, OnInit} from 'angular2/core';\n-      import * as common from 'angular2/common';\n-      import {Hero} from './hero';\n-      import {HeroDetailComponent} from './hero-detail.component';\n-      import HeroService from './hero.service';\n-      // thrown away\n-      import 'angular2/core';\n-\n-      @MyComponent({\n-        selector: 'my-app',\n-        template:` +\n-        '`' +\n-        `\n-        <h2>My Heroes</h2>\n-        <ul class=\"heroes\">\n-          <li *ngFor=\"#hero of heroes\"\n-            (click)=\"onSelect(hero)\"\n-            [class.selected]=\"hero === selectedHero\">\n-            <span class=\"badge\">{{hero.id | lowercase}}</span> {{hero.name | uppercase}}\n-          </li>\n-        </ul>\n-        <my-hero-detail [hero]=\"selectedHero\"></my-hero-detail>\n-        ` +\n-        '`' +\n-        `,\n-        directives: [HeroDetailComponent, common.NgFor],\n-        providers: [HeroService],\n-        pipes: [common.LowerCasePipe, common.UpperCasePipe]\n-      })\n-      export class AppComponent implements OnInit {\n-        public title = 'Tour of Heroes';\n-        public heroes: Hero[];\n-        public selectedHero: Hero;\n-\n-        constructor(private _heroService: HeroService) { }\n-\n-        onSelect(hero: Hero) { this.selectedHero = hero; }\n-\n-        ngOnInit() {\n-            this.getHeroes()\n-        }\n-\n-        getHeroes() {\n-          this._heroService.getHeroesSlowly().then(heroes => this.heroes = heroes);\n-        }\n-      }`,\n-    'hero.ts': `\n-      export interface Hero {\n-        id: number;\n-        name: string;\n-      }`,\n-    'empty.ts': ``,\n-    'hero-detail.component.ts': `\n-      import {Component, Input} from 'angular2/core';\n-      import {Hero} from './hero';\n-\n-      @Component({\n-        selector: 'my-hero-detail',\n-        template: ` +\n-        '`' +\n-        `\n-        <div *ngIf=\"hero\">\n-          <h2>{{hero.name}} details!</h2>\n-          <div><label>id: </label>{{hero.id}}</div>\n-          <div>\n-            <label>name: </label>\n-            <input [(ngModel)]=\"hero.name\" placeholder=\"name\"/>\n-          </div>\n-        </div>\n-      ` +\n-        '`' +\n-        `,\n-      })\n-      export class HeroDetailComponent {\n-        @Input() public hero: Hero;\n-      }`,\n-    'mock-heroes.ts': `\n-      import {Hero as Hero} from './hero';\n-\n-      export const HEROES: Hero[] = [\n-          {\"id\": 11, \"name\": \"Dr Nice\"},\n-          {\"id\": 12, \"name\": \"Narco\"},\n-          {\"id\": 13, \"name\": \"Bombasto\"},\n-          {\"id\": 14, \"name\": \"Celeritas\"},\n-          {\"id\": 15, \"name\": \"Magneta\"},\n-          {\"id\": 16, \"name\": \"RubberMan\"},\n-          {\"id\": 17, \"name\": \"Dynama\"},\n-          {\"id\": 18, \"name\": \"Dr IQ\"},\n-          {\"id\": 19, \"name\": \"Magma\"},\n-          {\"id\": 20, \"name\": \"Tornado\"}\n-      ];`,\n-    'default-exporter.ts': `\n-      let a: string;\n-      export default a;\n-    `,\n-    'hero.service.ts': `\n-      import {Injectable} from 'angular2/core';\n-      import {HEROES} from './mock-heroes';\n-      import {Hero} from './hero';\n-\n-      @Injectable()\n-      class HeroService {\n-          getHeros() {\n-              return Promise.resolve(HEROES);\n-          }\n-\n-          getHeroesSlowly() {\n-              return new Promise<Hero[]>(resolve =>\n-                setTimeout(()=>resolve(HEROES), 2000)); // 2 seconds\n-          }\n-      }\n-      export default HeroService;`,\n-    'cases-data.ts': `\n-      import {Injectable, Input} from 'angular2/core';\n-\n-      @Injectable()\n-      export class CaseAny {\n-        constructor(param: any) {}\n-      }\n-\n-      @Injectable()\n-      export class GetProp {\n-        private _name: string;\n-        @Input('firstName') get name(): string {\n-          return this._name;\n-        }\n-      }\n-\n-      @Injectable()\n-      export class SetProp {\n-        private _name: string;\n-        @Input('firstName') set name(value: string) {\n-          this._name = value;\n-        }\n-      }\n-\n-      @Injectable()\n-      export class FullProp {\n-        private _name: string;\n-        @Input('firstName') get name(): string {\n-          return this._name;\n-        }\n-        set name(value: string) {\n-          this._name = value;\n-        }\n-      }\n-\n-      export class ClassReference<T> { }\n-      export class NgForRow {\n-\n-      }\n-\n-      @Injectable()\n-      export class NgFor {\n-        constructor (public ref: ClassReference<NgForRow>) {}\n-      }\n-     `,\n-    'error-cases.ts': `\n-      import HeroService from './hero.service';\n-\n-      export class CaseCtor {\n-        constructor(private _heroService: HeroService) { }\n-      }\n-    `\n-  },\n-  'promise.ts': `\n-    interface PromiseLike<T> {\n-        then<TResult>(onfulfilled?: (value: T) => TResult | PromiseLike<TResult>, onrejected?: (reason: any) => TResult | PromiseLike<TResult>): PromiseLike<TResult>;\n-        then<TResult>(onfulfilled?: (value: T) => TResult | PromiseLike<TResult>, onrejected?: (reason: any) => void): PromiseLike<TResult>;\n-    }\n-\n-    interface Promise<T> {\n-        then<TResult>(onfulfilled?: (value: T) => TResult | PromiseLike<TResult>, onrejected?: (reason: any) => TResult | PromiseLike<TResult>): Promise<TResult>;\n-        then<TResult>(onfulfilled?: (value: T) => TResult | PromiseLike<TResult>, onrejected?: (reason: any) => void): Promise<TResult>;\n-        catch(onrejected?: (reason: any) => T | PromiseLike<T>): Promise<T>;\n-        catch(onrejected?: (reason: any) => void): Promise<T>;\n-    }\n-\n-    interface PromiseConstructor {\n-        prototype: Promise<any>;\n-        new <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;\n-        reject(reason: any): Promise<void>;\n-        reject<T>(reason: any): Promise<T>;\n-        resolve<T>(value: T | PromiseLike<T>): Promise<T>;\n-        resolve(): Promise<void>;\n-    }\n-\n-    declare var Promise: PromiseConstructor;\n-  `,\n-  'class-arity.ts': `\n-    export class Zero {}\n-    export class One<T> {}\n-    export class Two<T, V> {}\n-    export class Three<T1, T2, T3> {}\n-    export class Nine<T1, T2, T3, T4, T5, T6, T7, T8, T9> {}\n-  `,\n-  'unsupported-1.ts': `\n-    export let {a, b} = {a: 1, b: 2};\n-    export let [c, d] = [1, 2];\n-    export let e;\n-  `,\n-  'unsupported-2.ts': `\n-    import {Injectable} from 'angular2/core';\n-\n-    class Foo {}\n-\n-    @Injectable()\n-    export class Bar {\n-      constructor(private f: Foo) {}\n-    }\n-  `,\n-  'unsupported-3.ts': `\n-    class Foo {}\n-\n-    export class SomeClass {\n-      static someStatic() {\n-        return Foo;\n-      }\n-    }\n-  `,\n-  'interface-reference.ts': `\n-    import {Injectable, Inject} from 'angular2/core';\n-    export interface Test {}\n-\n-    @Injectable()\n-    export class SomeClass {\n-      constructor(@Inject(\"a\") test: Test) {}\n-    }\n-  `,\n-  'import-star.ts': `\n-    import {Injectable} from 'angular2/core';\n-    import * as common from 'angular2/common';\n-\n-    @Injectable()\n-    export class SomeClass {\n-      constructor(private f: common.NgFor) {}\n-    }\n-  `,\n-  'declarations.d.ts': `\n-    declare class DeclaredClass {}\n-    declare function declaredFn();\n-  `,\n-  'exported-classes.ts': `\n-    export class SimpleClass {}\n-    export abstract class AbstractClass {}\n-    export declare class DeclaredClass {}\n-  `,\n-  'class-inheritance-parent.ts': `\n-    export class ParentClassFromOtherFile {}\n-  `,\n-  'class-inheritance.ts': `\n-    import {ParentClassFromOtherFile} from './class-inheritance-parent';\n-\n-    export class ParentClass {}\n-\n-    export declare class DeclaredChildClass extends ParentClass {}\n-\n-    export class ChildClassSameFile extends ParentClass {}\n-\n-    export class ChildClassOtherFile extends ParentClassFromOtherFile {}\n-  `,\n-  'exported-functions.ts': `\n-    export function one(a: string, b: string, c: string) {\n-      return {a: a, b: b, c: c};\n-    }\n-    export function two(a: string, b: string, c: string) {\n-      return {a, b, c};\n-    }\n-    export function three({a, b, c}: {a: string, b: string, c: string}) {\n-      return [a, b, c];\n-    }\n-    export function supportsState(): boolean {\n-     return !!window.history.pushState;\n-    }\n-    export function complexFn(x: any): boolean {\n-      if (x) {\n-        return true;\n-      } else {\n-        return false;\n-      }\n-    }\n-    export declare function declaredFn();\n-  `,\n-  'exported-type.ts': `\n-    export type SomeType = 'a' | 'b';\n-  `,\n-  'exported-enum.ts': `\n-    import {constValue} from './exported-consts';\n-\n-    export const someValue = 30;\n-    export enum SomeEnum { A, B, C = 100, D };\n-    export enum ComplexEnum { A, B, C = someValue, D = someValue + 10, E = constValue };\n-  `,\n-  'exported-consts.ts': `\n-    export const constValue = 100;\n-  `,\n-  'static-method.ts': `\n-    export class MyModule {\n-      static with(comp: any): any[] {\n-        return [\n-          MyModule,\n-          { provider: 'a', useValue: comp }\n-        ];\n-      }\n-    }\n-  `,\n-  'static-method-with-default.ts': `\n-    export class MyModule {\n-      static with(comp: any, foo: boolean = true, bar: boolean = false): any[] {\n-        return [\n-          MyModule,\n-          foo ? { provider: 'a', useValue: comp } : {provider: 'b', useValue: comp},\n-          bar ? { provider: 'c', useValue: comp } : {provider: 'd', useValue: comp}\n-        ];\n-      }\n-    }\n-  `,\n-  'static-method-call.ts': `\n-    import {Component} from 'angular2/core';\n-    import {MyModule} from './static-method';\n-\n-    @Component({\n-      providers: MyModule.with('a')\n-    })\n-    export class Foo { }\n-  `,\n-  'static-field.ts': `\n-    export class MyModule {\n-      static VALUE = 'Some string';\n-    }\n-  `,\n-  'static-type-check-members.ts': `\n-    export class MyDirective<T> {\n-      static foo = 'bar';\n-      static declared: string;\n-\n-      static ngAcceptInputType_disabled: boolean|string;\n-      static ngTemplateContextGuard(dir: any, ctx: any): any { return true; };\n-      static ngTemplateGuard_declared: 'binding';\n-      static ngTemplateGuard_value(dir: any, expr: any): any { return true; };\n-    }\n-  `,\n-  'static-field-reference.ts': `\n-    import {Component} from 'angular2/core';\n-    import {MyModule} from './static-field';\n-\n-    @Component({\n-      providers: [ { provide: 'a', useValue: MyModule.VALUE } ]\n-    })\n-    export class Foo { }\n-  `,\n-  'static-method-with-if.ts': `\n-    export class MyModule {\n-      static with(cond: boolean): any[] {\n-        return [\n-          MyModule,\n-          { provider: 'a', useValue: cond ? '1' : '2' }\n-        ];\n-      }\n-    }\n-  `,\n-  're-exports.ts': `\n-    export {MyModule} from './static-field';\n-    export {Foo as OtherModule} from './static-field-reference';\n-    export * from 'angular2/core';\n-  `,\n-  're-exports-2.ts': `\n-    import {MyModule} from './static-field';\n-    import {Foo as OtherModule} from './static-field-reference';\n-    class MyClass {}\n-    export {OtherModule, MyModule as MyOtherModule, MyClass};\n-  `,\n-  'export-as.d.ts': `\n-     declare function someFunction(): void;\n-     export { someFunction as SomeFunction };\n- `,\n-  'named-module.d.ts': `\n-    /// <amd-module name=\"some-named-module\" />\n-    export type SomeType = 'a';\n-  `,\n-  'local-symbol-ref.ts': `\n-    import {Component, Validators} from 'angular2/core';\n-\n-    var REQUIRED;\n-\n-    export const REQUIRED_VALIDATOR: any = {\n-      provide: 'SomeToken',\n-      useValue: REQUIRED,\n-      multi: true\n-    };\n-\n-    @Component({\n-      providers: [REQUIRED_VALIDATOR]\n-    })\n-    export class SomeComponent {}\n-  `,\n-  'private-enum.ts': `\n-    export enum PublicEnum { a, b, c }\n-    enum PrivateEnum { e, f, g }\n-  `,\n-  'local-function-ref.ts': `\n-    import {Component, Validators} from 'angular2/core';\n-\n-    function required() {}\n-\n-    export const REQUIRED_VALIDATOR: any = {\n-      provide: 'SomeToken',\n-      useValue: required,\n-      multi: true\n-    };\n-\n-    @Component({\n-      providers: [REQUIRED_VALIDATOR]\n-    })\n-    export class SomeComponent {}\n-  `,\n-  'local-symbol-ref-func.ts': `\n-    var localSymbol: any[];\n-\n-    export function foo(index: number): string {\n-      return localSymbol[index];\n-    }\n-  `,\n-  'node_modules': {\n-    'angular2': {\n-      'core.d.ts': `\n-          export interface Type extends Function { }\n-          export interface TypeDecorator {\n-              <T extends Type>(type: T): T;\n-              (target: Object, propertyKey?: string | symbol, parameterIndex?: number): void;\n-              annotations: any[];\n-          }\n-          export interface ComponentDecorator extends TypeDecorator { }\n-          export interface ComponentFactory {\n-              (obj: {\n-                  selector?: string;\n-                  inputs?: string[];\n-                  outputs?: string[];\n-                  properties?: string[];\n-                  events?: string[];\n-                  host?: {\n-                      [key: string]: string;\n-                  };\n-                  bindings?: any[];\n-                  providers?: any[];\n-                  exportAs?: string;\n-                  moduleId?: string;\n-                  queries?: {\n-                      [key: string]: any;\n-                  };\n-                  viewBindings?: any[];\n-                  viewProviders?: any[];\n-                  templateUrl?: string;\n-                  template?: string;\n-                  styleUrls?: string[];\n-                  styles?: string[];\n-                  directives?: Array<Type | any[]>;\n-                  pipes?: Array<Type | any[]>;\n-              }): ComponentDecorator;\n-          }\n-          export declare var Component: ComponentFactory;\n-          export interface InputFactory {\n-              (bindingPropertyName?: string): any;\n-              new (bindingPropertyName?: string): any;\n-          }\n-          export declare var Input: InputFactory;\n-          export interface InjectableFactory {\n-              (): any;\n-          }\n-          export declare var Injectable: InjectableFactory;\n-          export interface InjectFactory {\n-            (binding?: any): any;\n-            new (binding?: any): any;\n-          }\n-          export declare var Inject: InjectFactory;\n-          export interface OnInit {\n-              ngOnInit(): any;\n-          }\n-          export class Validators {\n-            static required(): void;\n-          }\n-      `,\n-      'common.d.ts': `\n-        export declare class NgFor {\n-            ngForOf: any;\n-            ngForTemplate: any;\n-            ngDoCheck(): void;\n-        }\n-        export declare class LowerCasePipe  {\n-          transform(value: string, args?: any[]): string;\n-        }\n-        export declare class UpperCasePipe {\n-            transform(value: string, args?: any[]): string;\n-        }\n-      `\n-    }\n-  }\n-};\n-\n-function createSource(text: string): ts.SourceFile {\n-  return ts.createSourceFile('', text, ts.ScriptTarget.Latest, true);\n-}"
        },
        {
            "sha": "2e73f144fb15e73fb04d7fcfcb5913781c838292",
            "filename": "packages/compiler-cli/test/metadata/evaluator_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 371,
            "changes": 371,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2Fevaluator_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2Fevaluator_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2Fevaluator_spec.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,371 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import ts from 'typescript';\n-\n-import {Evaluator} from '../../src/metadata/evaluator';\n-import {Symbols} from '../../src/metadata/symbols';\n-\n-import {Directory, expectNoDiagnostics, findVar, findVarInitializer, Host} from './typescript.mocks';\n-\n-describe('Evaluator', () => {\n-  const documentRegistry = ts.createDocumentRegistry();\n-  let host: ts.LanguageServiceHost;\n-  let service: ts.LanguageService;\n-  let program: ts.Program;\n-  let typeChecker: ts.TypeChecker;\n-  let symbols: Symbols;\n-  let evaluator: Evaluator;\n-\n-  beforeEach(() => {\n-    host = new Host(FILES, [\n-      'expressions.ts', 'consts.ts', 'const_expr.ts', 'forwardRef.ts', 'classes.ts',\n-      'newExpression.ts', 'errors.ts', 'declared.ts'\n-    ]);\n-    service = ts.createLanguageService(host, documentRegistry);\n-    program = service.getProgram()!;\n-    typeChecker = program.getTypeChecker();\n-    symbols = new Symbols(null as any as ts.SourceFile);\n-    evaluator = new Evaluator(symbols, new Map());\n-  });\n-\n-  it('should not have typescript errors in test data', () => {\n-    expectNoDiagnostics(service.getCompilerOptionsDiagnostics());\n-    for (const sourceFile of program.getSourceFiles()) {\n-      expectNoDiagnostics(service.getSyntacticDiagnostics(sourceFile.fileName));\n-      if (sourceFile.fileName != 'errors.ts') {\n-        // Skip errors.ts because we it has intentional semantic errors that we are testing for.\n-        expectNoDiagnostics(service.getSemanticDiagnostics(sourceFile.fileName));\n-      }\n-    }\n-  });\n-\n-  it('should be able to fold literal expressions', () => {\n-    const consts = program.getSourceFile('consts.ts')!;\n-    expect(evaluator.isFoldable(findVarInitializer(consts, 'someName'))).toBeTruthy();\n-    expect(evaluator.isFoldable(findVarInitializer(consts, 'someBool'))).toBeTruthy();\n-    expect(evaluator.isFoldable(findVarInitializer(consts, 'one'))).toBeTruthy();\n-    expect(evaluator.isFoldable(findVarInitializer(consts, 'two'))).toBeTruthy();\n-  });\n-\n-  it('should be able to fold expressions with foldable references', () => {\n-    const expressions = program.getSourceFile('expressions.ts')!;\n-    symbols.define('someName', 'some-name');\n-    symbols.define('someBool', true);\n-    symbols.define('one', 1);\n-    symbols.define('two', 2);\n-    expect(evaluator.isFoldable(findVarInitializer(expressions, 'three'))).toBeTruthy();\n-    expect(evaluator.isFoldable(findVarInitializer(expressions, 'four'))).toBeTruthy();\n-    symbols.define('three', 3);\n-    symbols.define('four', 4);\n-    expect(evaluator.isFoldable(findVarInitializer(expressions, 'obj'))).toBeTruthy();\n-    expect(evaluator.isFoldable(findVarInitializer(expressions, 'arr'))).toBeTruthy();\n-  });\n-\n-  it('should be able to evaluate literal expressions', () => {\n-    const consts = program.getSourceFile('consts.ts')!;\n-    expect(evaluator.evaluateNode(findVarInitializer(consts, 'someName'))).toBe('some-name');\n-    expect(evaluator.evaluateNode(findVarInitializer(consts, 'someBool'))).toBe(true);\n-    expect(evaluator.evaluateNode(findVarInitializer(consts, 'one'))).toBe(1);\n-    expect(evaluator.evaluateNode(findVarInitializer(consts, 'two'))).toBe(2);\n-  });\n-\n-  it('should be able to evaluate expressions', () => {\n-    const expressions = program.getSourceFile('expressions.ts')!;\n-    symbols.define('someName', 'some-name');\n-    symbols.define('someBool', true);\n-    symbols.define('one', 1);\n-    symbols.define('two', 2);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'three'))).toBe(3);\n-    symbols.define('three', 3);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'four'))).toBe(4);\n-    symbols.define('four', 4);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'obj')))\n-        .toEqual({one: 1, two: 2, three: 3, four: 4});\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'arr'))).toEqual([1, 2, 3, 4]);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bTrue'))).toEqual(true);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bFalse'))).toEqual(false);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bAnd'))).toEqual(true);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bOr'))).toEqual(true);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'nDiv'))).toEqual(2);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'nMod'))).toEqual(1);\n-\n-\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bLOr'))).toEqual(false || true);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bLAnd'))).toEqual(true && true);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bBOr'))).toEqual(0x11 | 0x22);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bBAnd'))).toEqual(0x11 & 0x03);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bXor'))).toEqual(0x11 ^ 0x21);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bEqual')))\n-        .toEqual(1 == <any>'1');\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bNotEqual')))\n-        .toEqual(1 != <any>'1');\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bIdentical')))\n-        .toEqual(1 === <any>'1');\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bNotIdentical')))\n-        .toEqual(1 !== <any>'1');\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bLessThan'))).toEqual(1 < 2);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bGreaterThan'))).toEqual(1 > 2);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bLessThanEqual')))\n-        .toEqual(1 <= 2);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bGreaterThanEqual')))\n-        .toEqual(1 >= 2);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bShiftLeft'))).toEqual(1 << 2);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bShiftRight'))).toEqual(-1 >> 2);\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'bShiftRightU')))\n-        .toEqual(-1 >>> 2);\n-  });\n-\n-  it('should report recursive references as symbolic', () => {\n-    const expressions = program.getSourceFile('expressions.ts')!;\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'recursiveA')))\n-        .toEqual({__symbolic: 'reference', name: 'recursiveB'});\n-    expect(evaluator.evaluateNode(findVarInitializer(expressions, 'recursiveB')))\n-        .toEqual({__symbolic: 'reference', name: 'recursiveA'});\n-  });\n-\n-  it('should correctly handle special cases for CONST_EXPR', () => {\n-    const const_expr = program.getSourceFile('const_expr.ts')!;\n-    expect(evaluator.evaluateNode(findVarInitializer(const_expr, 'bTrue'))).toEqual(true);\n-    expect(evaluator.evaluateNode(findVarInitializer(const_expr, 'bFalse'))).toEqual(false);\n-  });\n-\n-  it('should resolve a forwardRef', () => {\n-    const forwardRef = program.getSourceFile('forwardRef.ts')!;\n-    expect(evaluator.evaluateNode(findVarInitializer(forwardRef, 'bTrue'))).toEqual(true);\n-    expect(evaluator.evaluateNode(findVarInitializer(forwardRef, 'bFalse'))).toEqual(false);\n-  });\n-\n-  it('should return new expressions', () => {\n-    symbols.define('Value', {__symbolic: 'reference', module: './classes', name: 'Value'});\n-    evaluator = new Evaluator(symbols, new Map());\n-    const newExpression = program.getSourceFile('newExpression.ts')!;\n-    expect(evaluator.evaluateNode(findVarInitializer(newExpression, 'someValue'))).toEqual({\n-      __symbolic: 'new',\n-      expression:\n-          {__symbolic: 'reference', name: 'Value', module: './classes', line: 4, character: 33},\n-      arguments: ['name', 12]\n-    });\n-    expect(evaluator.evaluateNode(findVarInitializer(newExpression, 'complex'))).toEqual({\n-      __symbolic: 'new',\n-      expression:\n-          {__symbolic: 'reference', name: 'Value', module: './classes', line: 5, character: 42},\n-      arguments: ['name', 12]\n-    });\n-  });\n-\n-  it('should support reference to a declared module type', () => {\n-    const declared = program.getSourceFile('declared.ts')!;\n-    const aDecl = findVar(declared, 'a')!;\n-    expect(evaluator.evaluateNode(aDecl.type!)).toEqual({\n-      __symbolic: 'select',\n-      expression: {__symbolic: 'reference', name: 'Foo'},\n-      member: 'A'\n-    });\n-  });\n-\n-  it('should return errors for unsupported expressions', () => {\n-    const errors = program.getSourceFile('errors.ts')!;\n-    const fDecl = findVar(errors, 'f')!;\n-    expect(evaluator.evaluateNode(fDecl.initializer!))\n-        .toEqual({__symbolic: 'error', message: 'Lambda not supported', line: 1, character: 12});\n-    const eDecl = findVar(errors, 'e')!;\n-    expect(evaluator.evaluateNode(eDecl.type!)).toEqual({\n-      __symbolic: 'error',\n-      message: 'Could not resolve type',\n-      line: 2,\n-      character: 11,\n-      context: {typeName: 'NotFound'}\n-    });\n-    const sDecl = findVar(errors, 's')!;\n-    expect(evaluator.evaluateNode(sDecl.initializer!)).toEqual({\n-      __symbolic: 'error',\n-      message: 'Name expected',\n-      line: 3,\n-      character: 14,\n-      context: {received: '1'}\n-    });\n-    const tDecl = findVar(errors, 't')!;\n-    expect(evaluator.evaluateNode(tDecl.initializer!)).toEqual({\n-      __symbolic: 'error',\n-      message: 'Expression form not supported',\n-      line: 4,\n-      character: 12\n-    });\n-  });\n-\n-  it('should be able to fold an array spread', () => {\n-    const expressions = program.getSourceFile('expressions.ts')!;\n-    symbols.define('arr', [1, 2, 3, 4]);\n-    const arrSpread = findVar(expressions, 'arrSpread')!;\n-    expect(evaluator.evaluateNode(arrSpread.initializer!)).toEqual([0, 1, 2, 3, 4, 5]);\n-  });\n-\n-  it('should be able to produce a spread expression', () => {\n-    const expressions = program.getSourceFile('expressions.ts')!;\n-    const arrSpreadRef = findVar(expressions, 'arrSpreadRef')!;\n-    expect(evaluator.evaluateNode(arrSpreadRef.initializer!)).toEqual([\n-      0, {__symbolic: 'spread', expression: {__symbolic: 'reference', name: 'arrImport'}}, 5\n-    ]);\n-  });\n-\n-  it('should be able to handle a new expression with no arguments', () => {\n-    const source = sourceFileOf(`\n-      export var a = new f;\n-    `);\n-    const expr = findVar(source, 'a')!;\n-    expect(evaluator.evaluateNode(expr.initializer!))\n-        .toEqual({__symbolic: 'new', expression: {__symbolic: 'reference', name: 'f'}});\n-  });\n-\n-  describe('with substitution', () => {\n-    let evaluator: Evaluator;\n-    const lambdaTemp = 'lambdaTemp';\n-\n-    beforeEach(() => {\n-      evaluator = new Evaluator(symbols, new Map(), {\n-        substituteExpression: (value, node) => {\n-          if (node.kind == ts.SyntaxKind.ArrowFunction) {\n-            return {__symbolic: 'reference', name: lambdaTemp};\n-          }\n-          return value;\n-        }\n-      });\n-    });\n-\n-    it('should be able to substitute a lambda with a reference', () => {\n-      const source = sourceFileOf(`\n-        var b = 1;\n-        export var a = () => b;\n-      `);\n-      const expr = findVar(source, 'a');\n-      expect(evaluator.evaluateNode(expr!.initializer!))\n-          .toEqual({__symbolic: 'reference', name: lambdaTemp});\n-    });\n-\n-    it('should be able to substitute a lambda in an expression', () => {\n-      const source = sourceFileOf(`\n-        var b = 1;\n-        export var a = [\n-          { provide: 'someValue': useFactory: () => b }\n-        ];\n-      `);\n-      const expr = findVar(source, 'a');\n-      expect(evaluator.evaluateNode(expr!.initializer!)).toEqual([\n-        {provide: 'someValue', useFactory: {__symbolic: 'reference', name: lambdaTemp}}\n-      ]);\n-    });\n-  });\n-});\n-\n-function sourceFileOf(text: string): ts.SourceFile {\n-  return ts.createSourceFile('test.ts', text, ts.ScriptTarget.Latest, true);\n-}\n-\n-const FILES: Directory = {\n-  'directives.ts': `\n-    export function Pipe(options: { name?: string, pure?: boolean}) {\n-      return function(fn: Function) { }\n-    }\n-    `,\n-  'classes.ts': `\n-    export class Value {\n-      constructor(public name: string, public value: any) {}\n-    }\n-  `,\n-  'consts.ts': `\n-    export var someName = 'some-name';\n-    export var someBool = true;\n-    export var one = 1;\n-    export var two = 2;\n-    export var arrImport = [1, 2, 3, 4];\n-  `,\n-  'expressions.ts': `\n-    import {arrImport} from './consts';\n-\n-    export var someName = 'some-name';\n-    export var someBool = true;\n-    export var one = 1;\n-    export var two = 2;\n-\n-    export var three = one + two;\n-    export var four = two * two;\n-    export var obj = { one: one, two: two, three: three, four: four };\n-    export var arr = [one, two, three, four];\n-    export var bTrue = someBool;\n-    export var bFalse = !someBool;\n-    export var bAnd = someBool && someBool;\n-    export var bOr = someBool || someBool;\n-    export var nDiv = four / two;\n-    export var nMod = (four + one) % two;\n-\n-    export var bLOr = false || true;             // true\n-    export var bLAnd = true && true;             // true\n-    export var bBOr = 0x11 | 0x22;               // 0x33\n-    export var bBAnd = 0x11 & 0x03;              // 0x01\n-    export var bXor = 0x11 ^ 0x21;               // 0x20\n-    export var bEqual = 1 == <any>\"1\";           // true\n-    export var bNotEqual = 1 != <any>\"1\";        // false\n-    export var bIdentical = 1 === <any>\"1\";      // false\n-    export var bNotIdentical = 1 !== <any>\"1\";   // true\n-    export var bLessThan = 1 < 2;                // true\n-    export var bGreaterThan = 1 > 2;             // false\n-    export var bLessThanEqual = 1 <= 2;          // true\n-    export var bGreaterThanEqual = 1 >= 2;       // false\n-    export var bShiftLeft = 1 << 2;              // 0x04\n-    export var bShiftRight = -1 >> 2;            // -1\n-    export var bShiftRightU = -1 >>> 2;          // 0x3fffffff\n-\n-    export var arrSpread = [0, ...arr, 5];\n-\n-    export var arrSpreadRef = [0, ...arrImport, 5];\n-\n-    export var recursiveA = recursiveB;\n-    export var recursiveB = recursiveA;\n-  `,\n-  'A.ts': `\n-    import {Pipe} from './directives';\n-\n-    @Pipe({name: 'A', pure: false})\n-    export class A {}`,\n-  'B.ts': `\n-    import {Pipe} from './directives';\n-    import {someName, someBool} from './consts';\n-\n-    @Pipe({name: someName, pure: someBool})\n-    export class B {}`,\n-  'const_expr.ts': `\n-    function CONST_EXPR(value: any) { return value; }\n-    export var bTrue = CONST_EXPR(true);\n-    export var bFalse = CONST_EXPR(false);\n-  `,\n-  'forwardRef.ts': `\n-    function forwardRef(value: any) { return value; }\n-    export var bTrue = forwardRef(() => true);\n-    export var bFalse = forwardRef(() => false);\n-  `,\n-  'newExpression.ts': `\n-    import {Value} from './classes';\n-    function CONST_EXPR(value: any) { return value; }\n-    function forwardRef(value: any) { return value; }\n-    export const someValue = new Value(\"name\", 12);\n-    export const complex = CONST_EXPR(new Value(\"name\", forwardRef(() => 12)));\n-  `,\n-  'errors.ts': `\n-    let f = () => 1;\n-    let e: NotFound;\n-    let s = { 1: 1, 2: 2 };\n-    let t = typeof 12;\n-  `,\n-  'declared.ts': `\n-    declare namespace Foo {\n-      type A = string;\n-    }\n-\n-    let a: Foo.A = 'some value';\n-  `\n-};"
        },
        {
            "sha": "134926939757c3b7b70bd2c0001e398e4f2f4654",
            "filename": "packages/compiler-cli/test/metadata/index_writer_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 25,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2Findex_writer_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2Findex_writer_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2Findex_writer_spec.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,25 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {MetadataBundler} from '../../src/metadata/bundler';\n-import {MetadataCollector} from '../../src/metadata/collector';\n-import {privateEntriesToIndex} from '../../src/metadata/index_writer';\n-\n-import {MockStringBundlerHost, SIMPLE_LIBRARY} from './bundler_spec';\n-\n-describe('index_writer', () => {\n-  it('should be able to write the index of a simple library', () => {\n-    const host = new MockStringBundlerHost('/', SIMPLE_LIBRARY);\n-    const bundler = new MetadataBundler('/lib/index', undefined, host);\n-    const bundle = bundler.getMetadataBundle();\n-    const result = privateEntriesToIndex('./index', bundle.privates);\n-    expect(result).toContain(`export * from './index';`);\n-    expect(result).toContain(`export {PrivateOne as ɵa} from './src/one';`);\n-    expect(result).toContain(`export {PrivateTwo as ɵb} from './src/two/index';`);\n-  });\n-});"
        },
        {
            "sha": "ddb2fd922c5eaf04dce81e06710c5c5eec8f046f",
            "filename": "packages/compiler-cli/test/metadata/symbols_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 134,
            "changes": 134,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2Fsymbols_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2Fsymbols_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2Fsymbols_spec.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,134 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {isMetadataGlobalReferenceExpression} from '../../src/metadata/schema';\n-import {Symbols} from '../../src/metadata/symbols';\n-\n-import {Directory, expectNoDiagnostics, Host} from './typescript.mocks';\n-\n-describe('Symbols', () => {\n-  let symbols: Symbols;\n-  const someValue = 'some-value';\n-\n-  beforeEach(() => symbols = new Symbols(null as any as ts.SourceFile));\n-\n-  it('should be able to add a symbol', () => symbols.define('someSymbol', someValue));\n-\n-  beforeEach(() => symbols.define('someSymbol', someValue));\n-\n-  it('should be able to `has` a symbol', () => expect(symbols.has('someSymbol')).toBeTruthy());\n-  it('should be able to `get` a symbol value',\n-     () => expect(symbols.resolve('someSymbol')).toBe(someValue));\n-  it('should be able to `get` a symbol value',\n-     () => expect(symbols.resolve('someSymbol')).toBe(someValue));\n-  it('should be able to determine symbol is missing',\n-     () => expect(symbols.has('missingSymbol')).toBeFalsy());\n-  it('should return undefined from `get` for a missing symbol',\n-     () => expect(symbols.resolve('missingSymbol')).toBeUndefined());\n-\n-  let host: ts.LanguageServiceHost;\n-  let service: ts.LanguageService;\n-  let program: ts.Program;\n-  let expressions: ts.SourceFile;\n-  let imports: ts.SourceFile;\n-\n-  beforeEach(() => {\n-    host = new Host(FILES, ['consts.ts', 'expressions.ts', 'imports.ts']);\n-    service = ts.createLanguageService(host);\n-    program = service.getProgram()!;\n-    expressions = program.getSourceFile('expressions.ts')!;\n-    imports = program.getSourceFile('imports.ts')!;\n-  });\n-\n-  it('should not have syntax errors in the test sources', () => {\n-    expectNoDiagnostics(service.getCompilerOptionsDiagnostics());\n-    for (const sourceFile of program.getSourceFiles()) {\n-      expectNoDiagnostics(service.getSyntacticDiagnostics(sourceFile.fileName));\n-    }\n-  });\n-\n-  it('should be able to find the source files', () => {\n-    expect(expressions).toBeDefined();\n-    expect(imports).toBeDefined();\n-  });\n-\n-  it('should be able to create symbols for a source file', () => {\n-    const symbols = new Symbols(expressions);\n-    expect(symbols).toBeDefined();\n-  });\n-\n-\n-  it('should be able to find symbols in expression', () => {\n-    const symbols = new Symbols(expressions);\n-    expect(symbols.has('someName')).toBeTruthy();\n-    expect(symbols.resolve('someName'))\n-        .toEqual({__symbolic: 'reference', module: './consts', name: 'someName'});\n-    expect(symbols.has('someBool')).toBeTruthy();\n-    expect(symbols.resolve('someBool'))\n-        .toEqual({__symbolic: 'reference', module: './consts', name: 'someBool'});\n-  });\n-\n-  it('should be able to detect a * import', () => {\n-    const symbols = new Symbols(imports);\n-    expect(symbols.resolve('b')).toEqual({__symbolic: 'reference', module: 'b'});\n-  });\n-\n-  it('should be able to detect importing a default export', () => {\n-    const symbols = new Symbols(imports);\n-    expect(symbols.resolve('d')).toEqual({__symbolic: 'reference', module: 'd', default: true});\n-  });\n-\n-  it('should be able to import a renamed symbol', () => {\n-    const symbols = new Symbols(imports);\n-    expect(symbols.resolve('g')).toEqual({__symbolic: 'reference', name: 'f', module: 'f'});\n-  });\n-\n-  it('should be able to resolve any symbol in core global scope', () => {\n-    const core = (program.getSourceFiles() as ts.SourceFile[])\n-                     .find(source => source.fileName.endsWith('lib.d.ts'));\n-    expect(core).toBeDefined();\n-    const visit = (node: ts.Node): boolean => {\n-      switch (node.kind) {\n-        case ts.SyntaxKind.VariableStatement:\n-        case ts.SyntaxKind.VariableDeclarationList:\n-          return !!ts.forEachChild(node, visit);\n-        case ts.SyntaxKind.VariableDeclaration:\n-          const variableDeclaration = <ts.VariableDeclaration>node;\n-          const nameNode = <ts.Identifier>variableDeclaration.name;\n-          const name = nameNode.text;\n-          const result = symbols.resolve(name);\n-          expect(isMetadataGlobalReferenceExpression(result) && result.name).toEqual(name);\n-\n-          // Ignore everything after Float64Array as it is IE specific.\n-          return name === 'Float64Array';\n-      }\n-      return false;\n-    };\n-    ts.forEachChild(core!, visit);\n-  });\n-});\n-\n-const FILES: Directory = {\n-  'consts.ts': `\n-    export var someName = 'some-name';\n-    export var someBool = true;\n-    export var one = 1;\n-    export var two = 2;\n-  `,\n-  'expressions.ts': `\n-    import {someName, someBool, one, two} from './consts';\n-  `,\n-  'imports.ts': `\n-    import * as b from 'b';\n-    import 'c';\n-    import d from 'd';\n-    import {f as g} from 'f';\n-  `\n-};"
        },
        {
            "sha": "45431c47a82368d1e59e204a1a19031a47747576",
            "filename": "packages/compiler-cli/test/metadata/typescript.mocks.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 285,
            "changes": 285,
            "blob_url": "https://github.com/angular/angular/blob/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2Ftypescript.mocks.ts",
            "raw_url": "https://github.com/angular/angular/raw/4e6281f11494f1f866fb5005da6e43ca506626f0/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2Ftypescript.mocks.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fmetadata%2Ftypescript.mocks.ts?ref=4e6281f11494f1f866fb5005da6e43ca506626f0",
            "patch": "@@ -1,285 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as fs from 'fs';\n-import * as path from 'path';\n-import ts from 'typescript';\n-\n-export interface Directory {\n-  [name: string]: (Directory|string);\n-}\n-\n-export class Host implements ts.LanguageServiceHost {\n-  private overrides = new Map<string, string>();\n-  private version = 1;\n-\n-  constructor(private directory: Directory, private scripts: string[]) {}\n-\n-  getCompilationSettings(): ts.CompilerOptions {\n-    return {\n-      experimentalDecorators: true,\n-      module: ts.ModuleKind.CommonJS,\n-      target: ts.ScriptTarget.ES5\n-    };\n-  }\n-\n-  getScriptFileNames(): string[] {\n-    return this.scripts;\n-  }\n-\n-  getScriptVersion(fileName: string): string {\n-    return this.version.toString();\n-  }\n-\n-  getScriptSnapshot(fileName: string): ts.IScriptSnapshot|undefined {\n-    const content = this.getFileContent(fileName);\n-    if (content) return ts.ScriptSnapshot.fromString(content);\n-  }\n-\n-  fileExists(fileName: string): boolean {\n-    return this.getFileContent(fileName) != null;\n-  }\n-\n-  getCurrentDirectory(): string {\n-    return '/';\n-  }\n-\n-  getDefaultLibFileName(options: ts.CompilerOptions): string {\n-    return 'lib.d.ts';\n-  }\n-\n-  overrideFile(fileName: string, content: string) {\n-    this.overrides.set(fileName, content);\n-    this.version++;\n-  }\n-\n-  addFile(fileName: string) {\n-    this.scripts.push(fileName);\n-    this.version++;\n-  }\n-\n-  private getFileContent(fileName: string): string|undefined {\n-    if (this.overrides.has(fileName)) {\n-      return this.overrides.get(fileName);\n-    }\n-    if (/^lib(.*)\\.d\\.ts/.test(fileName)) {\n-      const libDirPath = path.dirname(ts.getDefaultLibFilePath(this.getCompilationSettings()));\n-      const libPath = path.join(libDirPath, fileName);\n-      return fs.readFileSync(libPath, 'utf8');\n-    }\n-    const current = open(this.directory, fileName);\n-    if (typeof current === 'string') return current;\n-  }\n-}\n-\n-export function open(directory: Directory, fileName: string): Directory|string|undefined {\n-  // Path might be normalized by the current node environment. But it could also happen that this\n-  // path directly comes from the compiler in POSIX format. Support both separators for development.\n-  const names = fileName.split(/[\\\\/]/);\n-  let current: Directory|string = directory;\n-  if (names.length && names[0] === '') names.shift();\n-  for (const name of names) {\n-    if (!current || typeof current === 'string') return undefined;\n-    current = current[name];\n-  }\n-  return current;\n-}\n-\n-export class MockNode implements ts.Node {\n-  decorators?: ts.NodeArray<ts.Decorator>;\n-  modifiers?: ts.NodeArray<ts.Modifier>;\n-  parent!: ts.Node;\n-  constructor(\n-      public kind: ts.SyntaxKind = ts.SyntaxKind.Identifier, public flags: ts.NodeFlags = 0,\n-      public pos: number = 0, public end: number = 0) {}\n-  getSourceFile(): ts.SourceFile {\n-    return null as any as ts.SourceFile;\n-  }\n-  getChildCount(sourceFile?: ts.SourceFile): number {\n-    return 0;\n-  }\n-  getChildAt(index: number, sourceFile?: ts.SourceFile): ts.Node {\n-    return null as any as ts.Node;\n-  }\n-  getChildren(sourceFile?: ts.SourceFile): ts.Node[] {\n-    return [];\n-  }\n-  getStart(sourceFile?: ts.SourceFile): number {\n-    return 0;\n-  }\n-  getFullStart(): number {\n-    return 0;\n-  }\n-  getEnd(): number {\n-    return 0;\n-  }\n-  getWidth(sourceFile?: ts.SourceFile): number {\n-    return 0;\n-  }\n-  getFullWidth(): number {\n-    return 0;\n-  }\n-  getLeadingTriviaWidth(sourceFile?: ts.SourceFile): number {\n-    return 0;\n-  }\n-  getFullText(sourceFile?: ts.SourceFile): string {\n-    return '';\n-  }\n-  getText(sourceFile?: ts.SourceFile): string {\n-    return '';\n-  }\n-  getFirstToken(sourceFile?: ts.SourceFile): ts.Node {\n-    return null as any as ts.Node;\n-  }\n-  getLastToken(sourceFile?: ts.SourceFile): ts.Node {\n-    return null as any as ts.Node;\n-  }\n-  forEachChild<T>(\n-      cbNode: (node: ts.Node) => T | undefined,\n-      cbNodeArray?: (nodes: ts.NodeArray<ts.Node>) => T | undefined): T|undefined {\n-    return undefined;\n-  }\n-}\n-\n-export class MockIdentifier extends MockNode implements ts.Identifier {\n-  originalKeywordKind?: ts.SyntaxKind;\n-  isInJSDocNamespace?: boolean;\n-  public text: string;\n-  // TODO(issue/24571): remove '!'.\n-  public escapedText!: ts.__String;\n-  // tslint:disable\n-  public _declarationBrand: any;\n-  public _primaryExpressionBrand: any;\n-  public _memberExpressionBrand: any;\n-  public _leftHandSideExpressionBrand: any;\n-  public _incrementExpressionBrand: any;\n-  public _unaryExpressionBrand: any;\n-  public _expressionBrand: any;\n-  public _updateExpressionBrand: any;\n-  // tslint:enable\n-\n-  constructor(\n-      public name: string,\n-      public override kind: ts.SyntaxKind.Identifier = ts.SyntaxKind.Identifier,\n-      flags: ts.NodeFlags = 0, pos: number = 0, end: number = 0) {\n-    super(kind, flags, pos, end);\n-    this.text = name;\n-  }\n-}\n-\n-export class MockVariableDeclaration extends MockNode implements ts.VariableDeclaration {\n-  override parent!: ts.VariableDeclarationList|ts.CatchClause;\n-  exclamationToken?: ts.Token<ts.SyntaxKind.ExclamationToken>;\n-  type?: ts.TypeNode;\n-  initializer?: ts.Expression;\n-  // tslint:disable-next-line\n-  public _declarationBrand: any;\n-\n-  constructor(\n-      public name: ts.Identifier,\n-      public override kind: ts.SyntaxKind.VariableDeclaration = ts.SyntaxKind.VariableDeclaration,\n-      flags: ts.NodeFlags = 0, pos: number = 0, end: number = 0) {\n-    super(kind, flags, pos, end);\n-  }\n-\n-  static of(name: string): MockVariableDeclaration {\n-    return new MockVariableDeclaration(new MockIdentifier(name));\n-  }\n-}\n-\n-export class MockSymbol implements ts.Symbol {\n-  declarations!: ts.Declaration[];\n-  valueDeclaration!: ts.Declaration;\n-  members?: ts.UnderscoreEscapedMap<ts.Symbol>;\n-  exports?: ts.UnderscoreEscapedMap<ts.Symbol>;\n-  globalExports?: ts.UnderscoreEscapedMap<ts.Symbol>;\n-  // TODO(issue/24571): remove '!'.\n-  public escapedName!: ts.__String;\n-  constructor(\n-      public name: string, private node: ts.Declaration = MockVariableDeclaration.of(name),\n-      public flags: ts.SymbolFlags = 0) {}\n-\n-  getFlags(): ts.SymbolFlags {\n-    return this.flags;\n-  }\n-  getName(): string {\n-    return this.name;\n-  }\n-  getEscapedName(): ts.__String {\n-    return this.escapedName;\n-  }\n-  getDeclarations(): ts.Declaration[] {\n-    return [this.node];\n-  }\n-  getDocumentationComment(): ts.SymbolDisplayPart[] {\n-    return [];\n-  }\n-  // TODO(vicb): removed in TS 2.2\n-  getJsDocTags(): any[] {\n-    return [];\n-  }\n-\n-  static of(name: string): MockSymbol {\n-    return new MockSymbol(name);\n-  }\n-}\n-\n-export function expectNoDiagnostics(diagnostics: ts.Diagnostic[]) {\n-  for (const diagnostic of diagnostics) {\n-    const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\\n');\n-    if (diagnostic.file && diagnostic.start) {\n-      const {line, character} = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);\n-      // tslint:disable-next-line:no-console\n-      console.log(`${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`);\n-    } else {\n-      // tslint:disable-next-line:no-console\n-      console.log(message);\n-    }\n-  }\n-  expect(diagnostics.length).toBe(0);\n-}\n-\n-export function expectValidSources(service: ts.LanguageService, program: ts.Program) {\n-  expectNoDiagnostics(service.getCompilerOptionsDiagnostics());\n-  for (const sourceFile of program.getSourceFiles()) {\n-    expectNoDiagnostics(service.getSyntacticDiagnostics(sourceFile.fileName));\n-    expectNoDiagnostics(service.getSemanticDiagnostics(sourceFile.fileName));\n-  }\n-}\n-\n-export function allChildren<T>(node: ts.Node, cb: (node: ts.Node) => T | undefined): T|undefined {\n-  return ts.forEachChild(node, child => cb(node) || allChildren(child, cb));\n-}\n-\n-export function findClass(sourceFile: ts.SourceFile, name: string): ts.ClassDeclaration|undefined {\n-  return ts.forEachChild(\n-      sourceFile, node => isClass(node) && isNamed(node.name, name) ? node : undefined);\n-}\n-\n-export function findVar(sourceFile: ts.SourceFile, name: string): ts.VariableDeclaration|undefined {\n-  return allChildren(\n-      sourceFile, node => isVar(node) && isNamed(node.name, name) ? node : undefined);\n-}\n-\n-export function findVarInitializer(sourceFile: ts.SourceFile, name: string): ts.Expression {\n-  const v = findVar(sourceFile, name);\n-  expect(v && v.initializer).toBeDefined();\n-  return v!.initializer!;\n-}\n-\n-export function isClass(node: ts.Node): node is ts.ClassDeclaration {\n-  return node.kind === ts.SyntaxKind.ClassDeclaration;\n-}\n-\n-export function isNamed(node: ts.Node|undefined, name: string): node is ts.Identifier {\n-  return !!node && node.kind === ts.SyntaxKind.Identifier && (<ts.Identifier>node).text === name;\n-}\n-\n-export function isVar(node: ts.Node): node is ts.VariableDeclaration {\n-  return node.kind === ts.SyntaxKind.VariableDeclaration;\n-}"
        },
        {
            "sha": "22a034f607d4d753dce49cc4d3b27c70ac5be59b",
            "filename": "packages/compiler-cli/tsconfig-build.json",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/192203278647bae1864db2a5109efaae1bba53c4/packages%2Fcompiler-cli%2Ftsconfig-build.json",
            "raw_url": "https://github.com/angular/angular/raw/192203278647bae1864db2a5109efaae1bba53c4/packages%2Fcompiler-cli%2Ftsconfig-build.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftsconfig-build.json?ref=192203278647bae1864db2a5109efaae1bba53c4",
            "patch": "@@ -31,7 +31,6 @@\n     \"index.ts\",\n     \"src/main.ts\",\n     \"src/extract_i18n.ts\",\n-    \"src/language_services.ts\",\n     \"../../node_modules/@types/node/index.d.ts\",\n     \"../../node_modules/@types/jasmine/index.d.ts\"\n   ]"
        }
    ],
    "stats": {
        "total": 10553,
        "additions": 4,
        "deletions": 10549
    }
}