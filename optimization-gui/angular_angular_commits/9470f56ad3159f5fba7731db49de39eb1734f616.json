{
    "author": "JoostK",
    "message": "fix(compiler-cli): handle directives that refer to a namespaced class in a type parameter bound (#43511)\n\nThe template type-checker has to emit type constructors for the\ndirectives that are used in a template, where a type constructor's\ndeclaration has to mirror the type parameter constraints as they were\noriginally declared. Therefore, the compiler analyzes whether a type\nparameter constraint can be recreated, e.g. by generating imports for\nany type references. Some type references cannot be recreated, in which\ncase the compiler has to fall back to a strategy where the type\nconstructor is created inline in the original source file (which comes\nwith a performance penalty).\n\nThere used to be an issue for type references to namespaced declarations.\nThe compiler is unable to emit such references such that an inline\ntype constructor should be used as fallback, but this did not happen.\nThis caused the attempt to emit the type reference to fail, as the\nnamespaced declaration cannot be located by the reference emitters.\n\nThis commit fixes the issue by using a stricter check to determine if a\ntype parameter requires an inline type constructor. The TypeScript\nreflection host's `isStaticallyExported` logic was expanded to work for\nany declaration instead of just classes, as e.g. type declarations can\nalso be referenced in a type parameter constraint.\n\nCloses #43383\n\nPR Close #43511",
    "sha": "9470f56ad3159f5fba7731db49de39eb1734f616",
    "files": [
        {
            "sha": "63361469ec49ff7d9f6af64d29619def7e56f619",
            "filename": "packages/compiler-cli/ngcc/src/host/delegating_host.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/9470f56ad3159f5fba7731db49de39eb1734f616/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fdelegating_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/9470f56ad3159f5fba7731db49de39eb1734f616/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fdelegating_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fdelegating_host.ts?ref=9470f56ad3159f5fba7731db49de39eb1734f616",
            "patch": "@@ -162,7 +162,7 @@ export class DelegatingReflectionHost implements NgccReflectionHost {\n     return this.ngccHost.detectKnownDeclaration(decl);\n   }\n \n-  isStaticallyExported(clazz: ClassDeclaration): boolean {\n-    return this.ngccHost.isStaticallyExported(clazz);\n+  isStaticallyExported(decl: ts.Node): boolean {\n+    return this.ngccHost.isStaticallyExported(decl);\n   }\n }"
        },
        {
            "sha": "9eb7df10e31518fb73b8122b9ca99af233434f6b",
            "filename": "packages/compiler-cli/src/ngtsc/reflection/src/host.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/9470f56ad3159f5fba7731db49de39eb1734f616/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Freflection%2Fsrc%2Fhost.ts",
            "raw_url": "https://github.com/angular/angular/raw/9470f56ad3159f5fba7731db49de39eb1734f616/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Freflection%2Fsrc%2Fhost.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Freflection%2Fsrc%2Fhost.ts?ref=9470f56ad3159f5fba7731db49de39eb1734f616",
            "patch": "@@ -858,12 +858,12 @@ export interface ReflectionHost {\n   getAdjacentNameOfClass(clazz: ClassDeclaration): ts.Identifier;\n \n   /**\n-   * Returns `true` if a class is exported from the module in which it's defined.\n+   * Returns `true` if a declaration is exported from the module in which it's defined.\n    *\n-   * Not all mechanisms by which a class is exported can be statically detected, especially when\n-   * processing already compiled JavaScript. A `false` result does not indicate that the class is\n-   * never visible outside its module, only that it was not exported via one of the export\n-   * mechanisms that the `ReflectionHost` is capable of statically checking.\n+   * Not all mechanisms by which a declaration is exported can be statically detected, especially\n+   * when processing already compiled JavaScript. A `false` result does not indicate that the\n+   * declaration is never visible outside its module, only that it was not exported via one of the\n+   * export mechanisms that the `ReflectionHost` is capable of statically checking.\n    */\n-  isStaticallyExported(clazz: ClassDeclaration): boolean;\n+  isStaticallyExported(decl: ts.Node): boolean;\n }"
        },
        {
            "sha": "22cb754abd52d958e632b8dc6d22b2b8e4bbac83",
            "filename": "packages/compiler-cli/src/ngtsc/reflection/src/typescript.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 19,
            "changes": 37,
            "blob_url": "https://github.com/angular/angular/blob/9470f56ad3159f5fba7731db49de39eb1734f616/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Freflection%2Fsrc%2Ftypescript.ts",
            "raw_url": "https://github.com/angular/angular/raw/9470f56ad3159f5fba7731db49de39eb1734f616/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Freflection%2Fsrc%2Ftypescript.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Freflection%2Fsrc%2Ftypescript.ts?ref=9470f56ad3159f5fba7731db49de39eb1734f616",
            "patch": "@@ -199,11 +199,11 @@ export class TypeScriptReflectionHost implements ReflectionHost {\n     return clazz.name;\n   }\n \n-  isStaticallyExported(clazz: ClassDeclaration): boolean {\n-    // First check if there's an `export` modifier directly on the class declaration.\n-    let topLevel: ts.Node = clazz;\n-    if (ts.isVariableDeclaration(clazz) && ts.isVariableDeclarationList(clazz.parent)) {\n-      topLevel = clazz.parent.parent;\n+  isStaticallyExported(decl: ts.Node): boolean {\n+    // First check if there's an `export` modifier directly on the declaration.\n+    let topLevel = decl;\n+    if (ts.isVariableDeclaration(decl) && ts.isVariableDeclarationList(decl.parent)) {\n+      topLevel = decl.parent.parent;\n     }\n     if (topLevel.modifiers !== undefined &&\n         topLevel.modifiers.some(modifier => modifier.kind === ts.SyntaxKind.ExportKeyword)) {\n@@ -224,8 +224,8 @@ export class TypeScriptReflectionHost implements ReflectionHost {\n       return false;\n     }\n \n-    const localExports = this.getLocalExportedClassesOfSourceFile(clazz.getSourceFile());\n-    return localExports.has(clazz);\n+    const localExports = this.getLocalExportedDeclarationsOfSourceFile(decl.getSourceFile());\n+    return localExports.has(decl as ts.Declaration);\n   }\n \n   protected getDirectImportOfIdentifier(id: ts.Identifier): Import|null {\n@@ -444,17 +444,17 @@ export class TypeScriptReflectionHost implements ReflectionHost {\n   }\n \n   /**\n-   * Get the set of classes declared in `file` which are exported.\n+   * Get the set of declarations declared in `file` which are exported.\n    */\n-  private getLocalExportedClassesOfSourceFile(file: ts.SourceFile): Set<ClassDeclaration> {\n+  private getLocalExportedDeclarationsOfSourceFile(file: ts.SourceFile): Set<ts.Declaration> {\n     const cacheSf: SourceFileWithCachedExports = file as SourceFileWithCachedExports;\n-    if (cacheSf[LocalExportedClasses] !== undefined) {\n+    if (cacheSf[LocalExportedDeclarations] !== undefined) {\n       // TS does not currently narrow symbol-keyed fields, hence the non-null assert is needed.\n-      return cacheSf[LocalExportedClasses]!;\n+      return cacheSf[LocalExportedDeclarations]!;\n     }\n \n-    const exportSet = new Set<ClassDeclaration>();\n-    cacheSf[LocalExportedClasses] = exportSet;\n+    const exportSet = new Set<ts.Declaration>();\n+    cacheSf[LocalExportedDeclarations] = exportSet;\n \n     const sfSymbol = this.checker.getSymbolAtLocation(cacheSf);\n \n@@ -485,8 +485,7 @@ export class TypeScriptReflectionHost implements ReflectionHost {\n       }\n \n       if (exportedSymbol.valueDeclaration !== undefined &&\n-          exportedSymbol.valueDeclaration.getSourceFile() === file &&\n-          this.isClass(exportedSymbol.valueDeclaration)) {\n+          exportedSymbol.valueDeclaration.getSourceFile() === file) {\n         exportSet.add(exportedSymbol.valueDeclaration);\n       }\n       item = iter.next();\n@@ -677,10 +676,10 @@ function getExportedName(decl: ts.Declaration, originalId: ts.Identifier): strin\n       originalId.text;\n }\n \n-const LocalExportedClasses = Symbol('LocalExportedClasses');\n+const LocalExportedDeclarations = Symbol('LocalExportedDeclarations');\n \n /**\n- * A `ts.SourceFile` expando which includes a cached `Set` of local `ClassDeclarations` that are\n+ * A `ts.SourceFile` expando which includes a cached `Set` of local `ts.Declaration`s that are\n  * exported either directly (`export class ...`) or indirectly (via `export {...}`).\n  *\n  * This cache does not cause memory leaks as:\n@@ -694,8 +693,8 @@ const LocalExportedClasses = Symbol('LocalExportedClasses');\n  */\n interface SourceFileWithCachedExports extends ts.SourceFile {\n   /**\n-   * Cached `Set` of `ClassDeclaration`s which are locally declared in this file and are exported\n+   * Cached `Set` of `ts.Declaration`s which are locally declared in this file and are exported\n    * either directly or indirectly.\n    */\n-  [LocalExportedClasses]?: Set<ClassDeclaration>;\n+  [LocalExportedDeclarations]?: Set<ts.Declaration>;\n }"
        },
        {
            "sha": "84ff67ee7b6a8b336ac25a623c7ba757b48bb2b1",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_parameter_emitter.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 5,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/9470f56ad3159f5fba7731db49de39eb1734f616/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_parameter_emitter.ts",
            "raw_url": "https://github.com/angular/angular/raw/9470f56ad3159f5fba7731db49de39eb1734f616/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_parameter_emitter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_parameter_emitter.ts?ref=9470f56ad3159f5fba7731db49de39eb1734f616",
            "patch": "@@ -8,7 +8,7 @@\n import * as ts from 'typescript';\n \n import {OwningModule, Reference} from '../../imports';\n-import {DeclarationNode, isNamedClassDeclaration, ReflectionHost} from '../../reflection';\n+import {DeclarationNode, ReflectionHost} from '../../reflection';\n \n import {canEmitType, ResolvedTypeReference, TypeEmitter} from './type_emitter';\n \n@@ -92,17 +92,23 @@ export class TypeParameterEmitter {\n       };\n     }\n \n-    // If no owning module is known, the reference needs to be exported to be able to emit an import\n+    // The declaration needs to be exported as a top-level export to be able to emit an import\n     // statement for it. If the declaration is not exported, null is returned to prevent emit.\n-    if (owningModule === null && !this.isStaticallyExported(declaration.node)) {\n+    if (!this.isTopLevelExport(declaration.node)) {\n       return null;\n     }\n \n     return new Reference(declaration.node, owningModule);\n   }\n \n-  private isStaticallyExported(decl: DeclarationNode): boolean {\n-    return isNamedClassDeclaration(decl) && this.reflector.isStaticallyExported(decl);\n+  private isTopLevelExport(decl: DeclarationNode): boolean {\n+    if (decl.parent === undefined || !ts.isSourceFile(decl.parent)) {\n+      // The declaration has to exist at the top-level, as the reference emitters are not capable of\n+      // generating imports to classes declared in a namespace.\n+      return false;\n+    }\n+\n+    return this.reflector.isStaticallyExported(decl);\n   }\n \n   private isLocalTypeParameter(decl: DeclarationNode): boolean {"
        },
        {
            "sha": "6179e4cb9920ee093c97127011f134bf23e891d5",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_parameter_emitter_spec.ts",
            "status": "modified",
            "additions": 56,
            "deletions": 0,
            "changes": 56,
            "blob_url": "https://github.com/angular/angular/blob/9470f56ad3159f5fba7731db49de39eb1734f616/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_parameter_emitter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/9470f56ad3159f5fba7731db49de39eb1734f616/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_parameter_emitter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_parameter_emitter_spec.ts?ref=9470f56ad3159f5fba7731db49de39eb1734f616",
            "patch": "@@ -203,6 +203,62 @@ runInEachFileSystem(() => {\n       expect(emit(emitter)).toEqual('<T extends test.Internal>');\n     });\n \n+    it('can emit references to exported classes imported using a namespace import', () => {\n+      const additionalFiles: TestFile[] = [{\n+        name: absoluteFrom('/internal.ts'),\n+        contents: `export class Internal {}`,\n+      }];\n+      const emitter = createEmitter(\n+          `\n+        import * as ns from './internal';\n+\n+        export class TestClass<T extends ns.Internal> {}`,\n+          additionalFiles);\n+\n+      expect(emitter.canEmit()).toBe(true);\n+      expect(emit(emitter)).toEqual('<T extends test.Internal>');\n+    });\n+\n+    it('cannot emit references to local classes exported within a namespace', () => {\n+      const additionalFiles: TestFile[] = [{\n+        name: absoluteFrom('/ns.ts'),\n+        contents: `\n+          export namespace ns {\n+            export class Nested {}\n+          }\n+        `,\n+      }];\n+      const emitter = createEmitter(\n+          `\n+          import {ns} from './ns';\n+\n+          export class TestClass<T extends ns.Nested> {}`,\n+          additionalFiles);\n+\n+      expect(emitter.canEmit()).toBe(false);\n+      expect(() => emit(emitter)).toThrowError('Unable to emit an unresolved reference');\n+    });\n+\n+    it('cannot emit references to external classes exported within a namespace', () => {\n+      const additionalFiles: TestFile[] = [{\n+        name: absoluteFrom('/node_modules/ns/index.d.ts'),\n+        contents: `\n+          export namespace ns {\n+            export declare class Nested {}\n+          }\n+        `,\n+      }];\n+      const emitter = createEmitter(\n+          `\n+          import {ns} from 'ns';\n+\n+          export class TestClass<T extends ns.Nested> {}`,\n+          additionalFiles);\n+\n+      expect(emitter.canEmit()).toBe(false);\n+      expect(() => emit(emitter)).toThrowError('Unable to emit an unresolved reference');\n+    });\n+\n     it('can emit references to interfaces', () => {\n       const additionalFiles: TestFile[] = [{\n         name: absoluteFrom('/node_modules/types/index.d.ts'),"
        }
    ],
    "stats": {
        "total": 125,
        "additions": 93,
        "deletions": 32
    }
}