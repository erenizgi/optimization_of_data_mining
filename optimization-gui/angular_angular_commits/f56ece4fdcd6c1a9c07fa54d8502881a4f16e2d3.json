{
    "author": "atscott",
    "message": "feat(compiler-cli): Add ability to get `Symbol` of AST expression in component template (#38618)\n\nAdds support to the `TemplateTypeChecker` to get a `Symbol` of an AST\nexpression in a component template.\nNot all expressions will have `ts.Symbol`s (e.g. there is no `ts.Symbol`\nassociated with the expression `a + b`, but there are for both the a and b\nnodes individually).\n\nPR Close #38618",
    "sha": "f56ece4fdcd6c1a9c07fa54d8502881a4f16e2d3",
    "files": [
        {
            "sha": "a6a123523fbc2392f3b20b0142f2cfba44a267dd",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder.ts",
            "status": "modified",
            "additions": 52,
            "deletions": 1,
            "changes": 53,
            "blob_url": "https://github.com/angular/angular/blob/f56ece4fdcd6c1a9c07fa54d8502881a4f16e2d3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "raw_url": "https://github.com/angular/angular/raw/f56ece4fdcd6c1a9c07fa54d8502881a4f16e2d3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts?ref=f56ece4fdcd6c1a9c07fa54d8502881a4f16e2d3",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n+import {AbsoluteSourceSpan, AST, ASTWithSource, BindingPipe, SafeMethodCall, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {AbsoluteFsPath} from '../../file_system';\n@@ -40,7 +40,10 @@ export class SymbolBuilder {\n       return this.getSymbolOfElement(node);\n     } else if (node instanceof TmplAstTemplate) {\n       return this.getSymbolOfAstTemplate(node);\n+    } else if (node instanceof AST) {\n+      return this.getSymbolOfTemplateExpression(node);\n     }\n+    // TODO(atscott): TmplAstContent, TmplAstIcu\n     return null;\n   }\n \n@@ -223,6 +226,54 @@ export class SymbolBuilder {\n     };\n   }\n \n+  private getSymbolOfTemplateExpression(expression: AST): ExpressionSymbol|null {\n+    if (expression instanceof ASTWithSource) {\n+      expression = expression.ast;\n+    }\n+\n+    let node = findFirstMatchingNode(\n+        this.typeCheckBlock,\n+        {withSpan: expression.sourceSpan, filter: (n: ts.Node): n is ts.Node => true});\n+    if (node === null) {\n+      return null;\n+    }\n+\n+    while (ts.isParenthesizedExpression(node)) {\n+      node = node.expression;\n+    }\n+\n+    // - If we have safe property read (\"a?.b\") we want to get the Symbol for b, the `whenTrue`\n+    // expression.\n+    // - If our expression is a pipe binding (\"a | test:b:c\"), we want the Symbol for the\n+    // `transform` on the pipe.\n+    // - Otherwise, we retrieve the symbol for the node itself with no special considerations\n+    if ((expression instanceof SafePropertyRead || expression instanceof SafeMethodCall) &&\n+        ts.isConditionalExpression(node)) {\n+      const whenTrueSymbol =\n+          (expression instanceof SafeMethodCall && ts.isCallExpression(node.whenTrue)) ?\n+          this.getSymbolOfTsNode(node.whenTrue.expression) :\n+          this.getSymbolOfTsNode(node.whenTrue);\n+      if (whenTrueSymbol === null) {\n+        return null;\n+      }\n+\n+      return {\n+        ...whenTrueSymbol,\n+        kind: SymbolKind.Expression,\n+        // Rather than using the type of only the `whenTrue` part of the expression, we should\n+        // still get the type of the whole conditional expression to include `|undefined`.\n+        tsType: this.typeChecker.getTypeAtLocation(node)\n+      };\n+    } else if (expression instanceof BindingPipe && ts.isCallExpression(node)) {\n+      // TODO(atscott): Create a PipeSymbol to include symbol for the Pipe class\n+      const symbolInfo = this.getSymbolOfTsNode(node.expression);\n+      return symbolInfo === null ? null : {...symbolInfo, kind: SymbolKind.Expression};\n+    } else {\n+      const symbolInfo = this.getSymbolOfTsNode(node);\n+      return symbolInfo === null ? null : {...symbolInfo, kind: SymbolKind.Expression};\n+    }\n+  }\n+\n   private getSymbolOfTsNode(node: ts.Node): TsNodeSymbolInfo|null {\n     while (ts.isParenthesizedExpression(node)) {\n       node = node.expression;"
        },
        {
            "sha": "52e77a3dcdc6dfd5c760491f0e3b73c5645a9b6e",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker__get_symbol_of_template_node_spec.ts",
            "status": "modified",
            "additions": 423,
            "deletions": 2,
            "changes": 425,
            "blob_url": "https://github.com/angular/angular/blob/f56ece4fdcd6c1a9c07fa54d8502881a4f16e2d3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f56ece4fdcd6c1a9c07fa54d8502881a4f16e2d3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts?ref=f56ece4fdcd6c1a9c07fa54d8502881a4f16e2d3",
            "patch": "@@ -6,18 +6,38 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {TmplAstBoundAttribute, TmplAstElement, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n+import {ASTWithSource, Binary, BindingPipe, Conditional, Interpolation, PropertyRead, TmplAstBoundAttribute, TmplAstBoundText, TmplAstElement, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {absoluteFrom, getSourceFileOrError} from '../../file_system';\n import {runInEachFileSystem} from '../../file_system/testing';\n import {ClassDeclaration} from '../../reflection';\n-import {DirectiveSymbol, ElementSymbol, InputBindingSymbol, OutputBindingSymbol, Symbol, SymbolKind, TemplateSymbol, TemplateTypeChecker, TypeCheckingConfig} from '../api';\n+import {DirectiveSymbol, ElementSymbol, ExpressionSymbol, InputBindingSymbol, OutputBindingSymbol, Symbol, SymbolKind, TemplateSymbol, TemplateTypeChecker, TypeCheckingConfig} from '../api';\n \n import {getClass, ngForDeclaration, ngForTypeCheckTarget, setup as baseTestSetup, TypeCheckingTarget} from './test_utils';\n \n runInEachFileSystem(() => {\n   describe('TemplateTypeChecker.getSymbolOfNode', () => {\n+    it('should not get a symbol for regular attributes', () => {\n+      const fileName = absoluteFrom('/main.ts');\n+      const templateString = `<div id=\"helloWorld\"></div>`;\n+      const {templateTypeChecker, program} = setup(\n+          [\n+            {\n+              fileName,\n+              templates: {'Cmp': templateString},\n+              source: `export class Cmp {}`,\n+            },\n+          ],\n+      );\n+      const sf = getSourceFileOrError(program, fileName);\n+      const cmp = getClass(sf, 'Cmp');\n+      const {attributes} = getAstElements(templateTypeChecker, cmp)[0];\n+\n+      const symbol = templateTypeChecker.getSymbolOfNode(attributes[0], cmp);\n+      expect(symbol).toBeNull();\n+    });\n+\n     describe('templates', () => {\n       describe('ng-templates', () => {\n         let templateTypeChecker: TemplateTypeChecker;\n@@ -67,6 +87,394 @@ runInEachFileSystem(() => {\n           expect(symbol.directives[0].tsSymbol.getName()).toBe('TestDir');\n         });\n       });\n+\n+      describe('structural directives', () => {\n+        let templateTypeChecker: TemplateTypeChecker;\n+        let cmp: ClassDeclaration<ts.ClassDeclaration>;\n+        let templateNode: TmplAstTemplate;\n+        let program: ts.Program;\n+\n+        beforeEach(() => {\n+          const fileName = absoluteFrom('/main.ts');\n+          const templateString = `\n+              <div *ngFor=\"let user of users; let i = index;\">\n+                {{user.name}} {{user.streetNumber}}\n+                <div [tabIndex]=\"i\"></div>\n+              </div>`;\n+          const testValues = setup([\n+            {\n+              fileName,\n+              templates: {'Cmp': templateString},\n+              source: `\n+            export interface User {\n+              name: string;\n+              streetNumber: number;\n+            }\n+            export class Cmp { users: User[]; }\n+            `,\n+              declarations: [ngForDeclaration()],\n+            },\n+            ngForTypeCheckTarget(),\n+          ]);\n+          templateTypeChecker = testValues.templateTypeChecker;\n+          program = testValues.program;\n+          const sf = getSourceFileOrError(testValues.program, fileName);\n+          cmp = getClass(sf, 'Cmp');\n+          templateNode = getAstTemplates(templateTypeChecker, cmp)[0];\n+        });\n+\n+        it('should retrieve a symbol for an expression inside structural binding', () => {\n+          const ngForOfBinding =\n+              templateNode.templateAttrs.find(a => a.name === 'ngForOf')! as TmplAstBoundAttribute;\n+          const symbol = templateTypeChecker.getSymbolOfNode(ngForOfBinding.value, cmp)!;\n+          assertExpressionSymbol(symbol);\n+          expect(program.getTypeChecker().symbolToString(symbol.tsSymbol!)).toEqual('users');\n+          expect(program.getTypeChecker().typeToString(symbol.tsType)).toEqual('Array<User>');\n+        });\n+\n+        it('should retrieve a symbol for property reads of implicit variable inside structural binding',\n+           () => {\n+             const boundText =\n+                 (templateNode.children[0] as TmplAstElement).children[0] as TmplAstBoundText;\n+             const interpolation = (boundText.value as ASTWithSource).ast as Interpolation;\n+             const namePropRead = interpolation.expressions[0] as PropertyRead;\n+             const streetNumberPropRead = interpolation.expressions[1] as PropertyRead;\n+\n+             const nameSymbol = templateTypeChecker.getSymbolOfNode(namePropRead, cmp)!;\n+             assertExpressionSymbol(nameSymbol);\n+             expect(program.getTypeChecker().symbolToString(nameSymbol.tsSymbol!)).toEqual('name');\n+             expect(program.getTypeChecker().typeToString(nameSymbol.tsType)).toEqual('string');\n+\n+             const streetSymbol = templateTypeChecker.getSymbolOfNode(streetNumberPropRead, cmp)!;\n+             assertExpressionSymbol(streetSymbol);\n+             expect(program.getTypeChecker().symbolToString(streetSymbol.tsSymbol!))\n+                 .toEqual('streetNumber');\n+             expect(program.getTypeChecker().typeToString(streetSymbol.tsType)).toEqual('number');\n+           });\n+      });\n+    });\n+\n+    describe('for expressions', () => {\n+      it('should get a symbol for a component property used in an input binding', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const templateString = `<div [inputA]=\"helloWorld\"></div>`;\n+        const {templateTypeChecker, program} = setup([\n+          {\n+            fileName,\n+            templates: {'Cmp': templateString},\n+            source: `export class Cmp {helloWorld?: boolean;}`,\n+          },\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+        const nodes = getAstElements(templateTypeChecker, cmp);\n+\n+        const symbol = templateTypeChecker.getSymbolOfNode(nodes[0].inputs[0].value, cmp)!;\n+        assertExpressionSymbol(symbol);\n+        expect(program.getTypeChecker().symbolToString(symbol.tsSymbol!)).toEqual('helloWorld');\n+        expect(program.getTypeChecker().typeToString(symbol.tsType))\n+            .toEqual('false | true | undefined');\n+      });\n+\n+      it('should get a symbol for properties several levels deep', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const templateString = `<div [inputA]=\"person.address.street\"></div>`;\n+        const {templateTypeChecker, program} = setup([\n+          {\n+            fileName,\n+            templates: {'Cmp': templateString},\n+            source: `\n+              interface Address {\n+                street: string;\n+              }\n+\n+              interface Person {\n+                address: Address;\n+              }\n+              export class Cmp {person?: Person;}\n+            `,\n+          },\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+        const nodes = getAstElements(templateTypeChecker, cmp);\n+\n+        const inputNode = nodes[0].inputs[0].value as ASTWithSource;\n+\n+        const symbol = templateTypeChecker.getSymbolOfNode(inputNode, cmp)!;\n+        assertExpressionSymbol(symbol);\n+        expect(program.getTypeChecker().symbolToString(symbol.tsSymbol!)).toEqual('street');\n+        expect((symbol.tsSymbol!.declarations[0] as ts.PropertyDeclaration).parent.name!.getText())\n+            .toEqual('Address');\n+        expect(program.getTypeChecker().typeToString(symbol.tsType)).toEqual('string');\n+\n+        const personSymbol = templateTypeChecker.getSymbolOfNode(\n+            ((inputNode.ast as PropertyRead).receiver as PropertyRead).receiver, cmp)!;\n+        assertExpressionSymbol(personSymbol);\n+        expect(program.getTypeChecker().symbolToString(personSymbol.tsSymbol!)).toEqual('person');\n+        expect(program.getTypeChecker().typeToString(personSymbol.tsType))\n+            .toEqual('Person | undefined');\n+      });\n+\n+      describe('should get symbols for conditionals', () => {\n+        let templateTypeChecker: TemplateTypeChecker;\n+        let cmp: ClassDeclaration<ts.ClassDeclaration>;\n+        let program: ts.Program;\n+        let templateString: string;\n+\n+        beforeEach(() => {\n+          const fileName = absoluteFrom('/main.ts');\n+          templateString = `\n+        <div [inputA]=\"person?.address?.street\"></div>\n+        <div [inputA]=\"person ? person.address : noPersonError\"></div>\n+        <div [inputA]=\"person?.speak()\"></div>\n+      `;\n+          const testValues = setup(\n+              [\n+                {\n+                  fileName,\n+                  templates: {'Cmp': templateString},\n+                  source: `\n+              interface Address {\n+                street: string;\n+              }\n+\n+              interface Person {\n+                address: Address;\n+                speak(): string;\n+              }\n+              export class Cmp {person?: Person; noPersonError = 'no person'}\n+            `,\n+                },\n+              ],\n+          );\n+          templateTypeChecker = testValues.templateTypeChecker;\n+          program = testValues.program;\n+          const sf = getSourceFileOrError(program, fileName);\n+          cmp = getClass(sf, 'Cmp');\n+        });\n+\n+        it('safe property reads', () => {\n+          const nodes = getAstElements(templateTypeChecker, cmp);\n+          const safePropertyRead = nodes[0].inputs[0].value as ASTWithSource;\n+          const propReadSymbol = templateTypeChecker.getSymbolOfNode(safePropertyRead, cmp)!;\n+          assertExpressionSymbol(propReadSymbol);\n+          expect(program.getTypeChecker().symbolToString(propReadSymbol.tsSymbol!))\n+              .toEqual('street');\n+          expect((propReadSymbol.tsSymbol!.declarations[0] as ts.PropertyDeclaration)\n+                     .parent.name!.getText())\n+              .toEqual('Address');\n+          expect(program.getTypeChecker().typeToString(propReadSymbol.tsType))\n+              .toEqual('string | undefined');\n+        });\n+\n+        it('safe method calls', () => {\n+          const nodes = getAstElements(templateTypeChecker, cmp);\n+          const safeMethodCall = nodes[2].inputs[0].value as ASTWithSource;\n+          const methodCallSymbol = templateTypeChecker.getSymbolOfNode(safeMethodCall, cmp)!;\n+          assertExpressionSymbol(methodCallSymbol);\n+          expect(program.getTypeChecker().symbolToString(methodCallSymbol.tsSymbol!))\n+              .toEqual('speak');\n+          expect((methodCallSymbol.tsSymbol!.declarations[0] as ts.PropertyDeclaration)\n+                     .parent.name!.getText())\n+              .toEqual('Person');\n+          expect(program.getTypeChecker().typeToString(methodCallSymbol.tsType))\n+              .toEqual('string | undefined');\n+        });\n+\n+        it('ternary expressions', () => {\n+          const nodes = getAstElements(templateTypeChecker, cmp);\n+\n+          const ternary = (nodes[1].inputs[0].value as ASTWithSource).ast as Conditional;\n+          const ternarySymbol = templateTypeChecker.getSymbolOfNode(ternary, cmp)!;\n+          assertExpressionSymbol(ternarySymbol);\n+          expect(ternarySymbol.tsSymbol).toBeNull();\n+          expect(program.getTypeChecker().typeToString(ternarySymbol.tsType))\n+              .toEqual('string | Address');\n+          const addrSymbol = templateTypeChecker.getSymbolOfNode(ternary.trueExp, cmp)!;\n+          assertExpressionSymbol(addrSymbol);\n+          expect(program.getTypeChecker().symbolToString(addrSymbol.tsSymbol!)).toEqual('address');\n+          expect(program.getTypeChecker().typeToString(addrSymbol.tsType)).toEqual('Address');\n+\n+          const noPersonSymbol = templateTypeChecker.getSymbolOfNode(ternary.falseExp, cmp)!;\n+          assertExpressionSymbol(noPersonSymbol);\n+          expect(program.getTypeChecker().symbolToString(noPersonSymbol.tsSymbol!))\n+              .toEqual('noPersonError');\n+          expect(program.getTypeChecker().typeToString(noPersonSymbol.tsType)).toEqual('string');\n+        });\n+      });\n+\n+      it('should get a symbol for function on a component used in an input binding', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const templateString = `<div [inputA]=\"helloWorld\"></div>`;\n+        const {templateTypeChecker, program} = setup([\n+          {\n+            fileName,\n+            templates: {'Cmp': templateString},\n+            source: `\n+            export class Cmp {\n+              helloWorld() { return ''; }\n+            }`,\n+          },\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+        const nodes = getAstElements(templateTypeChecker, cmp);\n+\n+        const symbol = templateTypeChecker.getSymbolOfNode(nodes[0].inputs[0].value, cmp)!;\n+        assertExpressionSymbol(symbol);\n+        expect(program.getTypeChecker().symbolToString(symbol.tsSymbol!)).toEqual('helloWorld');\n+        expect(program.getTypeChecker().typeToString(symbol.tsType)).toEqual('() => string');\n+      });\n+\n+      it('should get a symbol for binary expressions', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const templateString = `<div [inputA]=\"a + b\"></div>`;\n+        const {templateTypeChecker, program} = setup([\n+          {\n+            fileName,\n+            templates: {'Cmp': templateString},\n+            source: `\n+            export class Cmp {\n+              a!: string;\n+              b!: number;\n+            }`,\n+          },\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+        const nodes = getAstElements(templateTypeChecker, cmp);\n+\n+        const valueAssignment = nodes[0].inputs[0].value as ASTWithSource;\n+        const wholeExprSymbol = templateTypeChecker.getSymbolOfNode(valueAssignment, cmp)!;\n+        assertExpressionSymbol(wholeExprSymbol);\n+        expect(wholeExprSymbol.tsSymbol).toBeNull();\n+        expect(program.getTypeChecker().typeToString(wholeExprSymbol.tsType)).toEqual('string');\n+\n+        const aSymbol =\n+            templateTypeChecker.getSymbolOfNode((valueAssignment.ast as Binary).left, cmp)!;\n+        assertExpressionSymbol(aSymbol);\n+        expect(program.getTypeChecker().symbolToString(aSymbol.tsSymbol!)).toBe('a');\n+        expect(program.getTypeChecker().typeToString(aSymbol.tsType)).toEqual('string');\n+\n+        const bSymbol =\n+            templateTypeChecker.getSymbolOfNode((valueAssignment.ast as Binary).right, cmp)!;\n+        assertExpressionSymbol(bSymbol);\n+        expect(program.getTypeChecker().symbolToString(bSymbol.tsSymbol!)).toBe('b');\n+        expect(program.getTypeChecker().typeToString(bSymbol.tsType)).toEqual('number');\n+      });\n+\n+      describe('literals', () => {\n+        let templateTypeChecker: TemplateTypeChecker;\n+        let cmp: ClassDeclaration<ts.ClassDeclaration>;\n+        let interpolation: Interpolation;\n+        let program: ts.Program;\n+\n+        beforeEach(() => {\n+          const fileName = absoluteFrom('/main.ts');\n+          const templateString = `\n+          {{ [1, 2, 3] }}\n+          {{ { hello: \"world\" } }}`;\n+          const testValues = setup([\n+            {\n+              fileName,\n+              templates: {'Cmp': templateString},\n+              source: `export class Cmp {}`,\n+            },\n+          ]);\n+          templateTypeChecker = testValues.templateTypeChecker;\n+          program = testValues.program;\n+          const sf = getSourceFileOrError(testValues.program, fileName);\n+          cmp = getClass(sf, 'Cmp');\n+          interpolation = ((templateTypeChecker.getTemplate(cmp)![0] as TmplAstBoundText).value as\n+                           ASTWithSource)\n+                              .ast as Interpolation;\n+        });\n+\n+        it('literal array', () => {\n+          const literalArray = interpolation.expressions[0];\n+          const symbol = templateTypeChecker.getSymbolOfNode(literalArray, cmp)!;\n+          assertExpressionSymbol(symbol);\n+          expect(program.getTypeChecker().symbolToString(symbol.tsSymbol!)).toEqual('Array');\n+          expect(program.getTypeChecker().typeToString(symbol.tsType)).toEqual('Array<number>');\n+        });\n+\n+        it('literal map', () => {\n+          const literalMap = interpolation.expressions[1];\n+          const symbol = templateTypeChecker.getSymbolOfNode(literalMap, cmp)!;\n+          assertExpressionSymbol(symbol);\n+          expect(program.getTypeChecker().symbolToString(symbol.tsSymbol!)).toEqual('__object');\n+          expect(program.getTypeChecker().typeToString(symbol.tsType))\n+              .toEqual('{ hello: string; }');\n+        });\n+      });\n+\n+\n+      describe('pipes', () => {\n+        let templateTypeChecker: TemplateTypeChecker;\n+        let cmp: ClassDeclaration<ts.ClassDeclaration>;\n+        let binding: BindingPipe;\n+        let program: ts.Program;\n+\n+        beforeEach(() => {\n+          const fileName = absoluteFrom('/main.ts');\n+          const templateString = `<div [inputA]=\"a | test:b:c\"></div>`;\n+          const testValues = setup([\n+            {\n+              fileName,\n+              templates: {'Cmp': templateString},\n+              source: `\n+            export class Cmp { a: string; b: number; c: boolean }\n+            export class TestPipe {\n+              transform(value: string, repeat: number, commaSeparate: boolean): string[] {\n+              }\n+            }\n+            `,\n+              declarations: [{\n+                type: 'pipe',\n+                name: 'TestPipe',\n+                pipeName: 'test',\n+              }],\n+            },\n+          ]);\n+          program = testValues.program;\n+          templateTypeChecker = testValues.templateTypeChecker;\n+          const sf = getSourceFileOrError(testValues.program, fileName);\n+          cmp = getClass(sf, 'Cmp');\n+          binding =\n+              (getAstElements(templateTypeChecker, cmp)[0].inputs[0].value as ASTWithSource).ast as\n+              BindingPipe;\n+        });\n+\n+        it('should get symbol for pipe', () => {\n+          const pipeSymbol = templateTypeChecker.getSymbolOfNode(binding, cmp)!;\n+          assertExpressionSymbol(pipeSymbol);\n+          expect(program.getTypeChecker().symbolToString(pipeSymbol.tsSymbol!))\n+              .toEqual('transform');\n+          expect(\n+              (pipeSymbol.tsSymbol!.declarations[0].parent as ts.ClassDeclaration).name!.getText())\n+              .toEqual('TestPipe');\n+          expect(program.getTypeChecker().typeToString(pipeSymbol.tsType))\n+              .toEqual('(value: string, repeat: number, commaSeparate: boolean) => string[]');\n+        });\n+\n+        it('should get symbols for pipe expression and args', () => {\n+          const aSymbol = templateTypeChecker.getSymbolOfNode(binding.exp, cmp)!;\n+          assertExpressionSymbol(aSymbol);\n+          expect(program.getTypeChecker().symbolToString(aSymbol.tsSymbol!)).toEqual('a');\n+          expect(program.getTypeChecker().typeToString(aSymbol.tsType)).toEqual('string');\n+\n+          const bSymbol = templateTypeChecker.getSymbolOfNode(binding.args[0], cmp)!;\n+          assertExpressionSymbol(bSymbol);\n+          expect(program.getTypeChecker().symbolToString(bSymbol.tsSymbol!)).toEqual('b');\n+          expect(program.getTypeChecker().typeToString(bSymbol.tsType)).toEqual('number');\n+\n+          const cSymbol = templateTypeChecker.getSymbolOfNode(binding.args[1], cmp)!;\n+          assertExpressionSymbol(cSymbol);\n+          expect(program.getTypeChecker().symbolToString(cSymbol.tsSymbol!)).toEqual('c');\n+          expect(program.getTypeChecker().typeToString(cSymbol.tsType)).toEqual('boolean');\n+        });\n+      });\n     });\n \n     describe('input bindings', () => {\n@@ -627,6 +1035,15 @@ function onlyAstTemplates(nodes: TmplAstNode[]): TmplAstTemplate[] {\n   return nodes.filter((n): n is TmplAstTemplate => n instanceof TmplAstTemplate);\n }\n \n+function onlyAstElements(nodes: TmplAstNode[]): TmplAstElement[] {\n+  return nodes.filter((n): n is TmplAstElement => n instanceof TmplAstElement);\n+}\n+\n+function getAstElements(\n+    templateTypeChecker: TemplateTypeChecker, cmp: ts.ClassDeclaration&{name: ts.Identifier}) {\n+  return onlyAstElements(templateTypeChecker.getTemplate(cmp)!);\n+}\n+\n function getAstTemplates(\n     templateTypeChecker: TemplateTypeChecker, cmp: ts.ClassDeclaration&{name: ts.Identifier}) {\n   return onlyAstTemplates(templateTypeChecker.getTemplate(cmp)!);\n@@ -648,6 +1065,10 @@ function assertTemplateSymbol(tSymbol: Symbol): asserts tSymbol is TemplateSymbo\n   expect(tSymbol.kind).toEqual(SymbolKind.Template);\n }\n \n+function assertExpressionSymbol(tSymbol: Symbol): asserts tSymbol is ExpressionSymbol {\n+  expect(tSymbol.kind).toEqual(SymbolKind.Expression);\n+}\n+\n function assertElementSymbol(tSymbol: Symbol): asserts tSymbol is ElementSymbol {\n   expect(tSymbol.kind).toEqual(SymbolKind.Element);\n }"
        }
    ],
    "stats": {
        "total": 478,
        "additions": 475,
        "deletions": 3
    }
}