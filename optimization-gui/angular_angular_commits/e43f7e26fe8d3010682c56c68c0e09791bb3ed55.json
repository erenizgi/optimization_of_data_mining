{
    "author": "atscott",
    "message": "fix(router): apply redirects should match named outlets with empty path parents (#40029)\n\nThere are two parts to this commit:\n1. Revert the changes from #38379. This change had an incomplete view of\nhow things worked and also diverged the implementations of\n`applyRedirects` and `recognize` even more.\n2. Apply the fixes from the `recognize` algorithm to ensure that named\noutlets with empty path parents can be matched. This change also passes\nall the tests that were added in #38379 with the added benefit of being\na more complete fix that stays in-line with the `recognize` algorithm.\nThis was made possible by using the same approach for `split` by\nalways creating segments for empty path matches (previously, this was\nonly done in `applyRedirects` if there was a `redirectTo` value). At the\nend of the expansions, we need to squash all empty segments so that\nserializing the final `UrlTree` returns the same result as before.\n\nFixes #39952\nFixes #10726\nCloses #30410\n\nPR Close #40029",
    "sha": "e43f7e26fe8d3010682c56c68c0e09791bb3ed55",
    "files": [
        {
            "sha": "b198268033d5207d50a79e6c9ab5e6321ed951d6",
            "filename": "goldens/size-tracking/integration-payloads.json",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/e43f7e26fe8d3010682c56c68c0e09791bb3ed55/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "raw_url": "https://github.com/angular/angular/raw/e43f7e26fe8d3010682c56c68c0e09791bb3ed55/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fsize-tracking%2Fintegration-payloads.json?ref=e43f7e26fe8d3010682c56c68c0e09791bb3ed55",
            "patch": "@@ -39,7 +39,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 2285,\n-        \"main-es2015\": 241837,\n+        \"main-es2015\": 240909,\n         \"polyfills-es2015\": 36709,\n         \"5-es2015\": 745\n       }\n@@ -49,7 +49,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 2289,\n-        \"main-es2015\": 218507,\n+        \"main-es2015\": 217591,\n         \"polyfills-es2015\": 36723,\n         \"5-es2015\": 781\n       }\n@@ -66,4 +66,4 @@\n       }\n     }\n   }\n-}\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "bef5f35ee1fcd7640e7405b508d06dc9a4d863cf",
            "filename": "packages/core/test/bundling/router/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 23,
            "deletions": 8,
            "changes": 31,
            "blob_url": "https://github.com/angular/angular/blob/e43f7e26fe8d3010682c56c68c0e09791bb3ed55/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/e43f7e26fe8d3010682c56c68c0e09791bb3ed55/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json?ref=e43f7e26fe8d3010682c56c68c0e09791bb3ed55",
            "patch": "@@ -1457,6 +1457,9 @@\n   {\n     \"name\": \"handleError\"\n   },\n+  {\n+    \"name\": \"hasEmptyPathConfig\"\n+  },\n   {\n     \"name\": \"hasParentInjector\"\n   },\n@@ -1542,13 +1545,13 @@\n     \"name\": \"isDirectiveHost\"\n   },\n   {\n-    \"name\": \"isEmptyPathRedirect\"\n+    \"name\": \"isFunction\"\n   },\n   {\n     \"name\": \"isFunction\"\n   },\n   {\n-    \"name\": \"isFunction\"\n+    \"name\": \"isImmediateMatch\"\n   },\n   {\n     \"name\": \"isInCheckNoChangesMode\"\n@@ -1646,9 +1649,6 @@\n   {\n     \"name\": \"map\"\n   },\n-  {\n-    \"name\": \"mapChildrenIntoArray\"\n-  },\n   {\n     \"name\": \"markAsComponentHost\"\n   },\n@@ -1682,9 +1682,6 @@\n   {\n     \"name\": \"mergeMap\"\n   },\n-  {\n-    \"name\": \"mergeTrivialChildren\"\n-  },\n   {\n     \"name\": \"modules\"\n   },\n@@ -1706,6 +1703,9 @@\n   {\n     \"name\": \"navigationCancelingError\"\n   },\n+  {\n+    \"name\": \"newObservableError\"\n+  },\n   {\n     \"name\": \"nextBindingIndex\"\n   },\n@@ -1715,6 +1715,12 @@\n   {\n     \"name\": \"ngOnChangesSetInput\"\n   },\n+  {\n+    \"name\": \"noLeftoversInUrl\"\n+  },\n+  {\n+    \"name\": \"noMatch\"\n+  },\n   {\n     \"name\": \"noMatch\"\n   },\n@@ -1838,6 +1844,9 @@\n   {\n     \"name\": \"saveNameToExportMap\"\n   },\n+  {\n+    \"name\": \"scan\"\n+  },\n   {\n     \"name\": \"scheduleArray\"\n   },\n@@ -1910,9 +1919,15 @@\n   {\n     \"name\": \"shouldSearchParent\"\n   },\n+  {\n+    \"name\": \"sortByMatchingOutlets\"\n+  },\n   {\n     \"name\": \"split\"\n   },\n+  {\n+    \"name\": \"squashSegmentGroup\"\n+  },\n   {\n     \"name\": \"standardizeConfig\"\n   },"
        },
        {
            "sha": "22228b1290821059966343bbc48343c2fb4cd49b",
            "filename": "packages/router/src/apply_redirects.ts",
            "status": "modified",
            "additions": 72,
            "deletions": 68,
            "changes": 140,
            "blob_url": "https://github.com/angular/angular/blob/e43f7e26fe8d3010682c56c68c0e09791bb3ed55/packages%2Frouter%2Fsrc%2Fapply_redirects.ts",
            "raw_url": "https://github.com/angular/angular/raw/e43f7e26fe8d3010682c56c68c0e09791bb3ed55/packages%2Frouter%2Fsrc%2Fapply_redirects.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Fapply_redirects.ts?ref=e43f7e26fe8d3010682c56c68c0e09791bb3ed55",
            "patch": "@@ -8,17 +8,17 @@\n \n import {Injector, NgModuleRef} from '@angular/core';\n import {EmptyError, from, Observable, Observer, of} from 'rxjs';\n-import {catchError, combineAll, concatMap, first, map, mergeMap, tap} from 'rxjs/operators';\n+import {catchError, concatMap, first, last, map, mergeMap, scan, tap} from 'rxjs/operators';\n \n import {LoadedRouterConfig, Route, Routes} from './config';\n import {CanLoadFn} from './interfaces';\n import {prioritizedGuardValue} from './operators/prioritized_guard_value';\n import {RouterConfigLoader} from './router_config_loader';\n import {navigationCancelingError, Params, PRIMARY_OUTLET} from './shared';\n import {UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\n-import {forEach, waitForMap, wrapIntoObservable} from './utils/collection';\n-import {getOutlet, groupRoutesByOutlet} from './utils/config';\n-import {match, noLeftoversInUrl, split} from './utils/config_matching';\n+import {forEach, wrapIntoObservable} from './utils/collection';\n+import {getOutlet, sortByMatchingOutlets} from './utils/config';\n+import {isImmediateMatch, match, noLeftoversInUrl, split} from './utils/config_matching';\n import {isCanLoad, isFunction, isUrlTree} from './utils/type_guards';\n \n class NoMatch {\n@@ -78,8 +78,17 @@ class ApplyRedirects {\n   }\n \n   apply(): Observable<UrlTree> {\n+    const splitGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;\n+    // TODO(atscott): creating a new segment removes the _sourceSegment _segmentIndexShift, which is\n+    // only necessary to prevent failures in tests which assert exact object matches. The `split` is\n+    // now shared between `applyRedirects` and `recognize` but only the `recognize` step needs these\n+    // properties. Before the implementations were merged, the `applyRedirects` would not assign\n+    // them. We should be able to remove this logic as a \"breaking change\" but should do some more\n+    // investigation into the failures first.\n+    const rootSegmentGroup = new UrlSegmentGroup(splitGroup.segments, splitGroup.children);\n+\n     const expanded$ =\n-        this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, PRIMARY_OUTLET);\n+        this.expandSegmentGroup(this.ngModule, this.config, rootSegmentGroup, PRIMARY_OUTLET);\n     const urlTrees$ = expanded$.pipe(map((rootSegmentGroup: UrlSegmentGroup) => {\n       return this.createUrlTree(\n           squashSegmentGroup(rootSegmentGroup), this.urlTree.queryParams, this.urlTree.fragment!);\n@@ -143,74 +152,73 @@ class ApplyRedirects {\n   private expandChildren(\n       ngModule: NgModuleRef<any>, routes: Route[],\n       segmentGroup: UrlSegmentGroup): Observable<{[name: string]: UrlSegmentGroup}> {\n-    return waitForMap(\n-        segmentGroup.children,\n-        (childOutlet, child) => this.expandSegmentGroup(ngModule, routes, child, childOutlet));\n+    // Expand outlets one at a time, starting with the primary outlet. We need to do it this way\n+    // because an absolute redirect from the primary outlet takes precedence.\n+    const childOutlets: string[] = [];\n+    for (const child of Object.keys(segmentGroup.children)) {\n+      if (child === 'primary') {\n+        childOutlets.unshift(child);\n+      } else {\n+        childOutlets.push(child);\n+      }\n+    }\n+\n+    return from(childOutlets)\n+        .pipe(\n+            concatMap(childOutlet => {\n+              const child = segmentGroup.children[childOutlet];\n+              // Sort the routes so routes with outlets that match the the segment appear\n+              // first, followed by routes for other outlets, which might match if they have an\n+              // empty path.\n+              const sortedRoutes = sortByMatchingOutlets(routes, childOutlet);\n+              return this.expandSegmentGroup(ngModule, sortedRoutes, child, childOutlet)\n+                  .pipe(map(s => ({segment: s, outlet: childOutlet})));\n+            }),\n+            scan(\n+                (children, expandedChild) => {\n+                  children[expandedChild.outlet] = expandedChild.segment;\n+                  return children;\n+                },\n+                {} as {[outlet: string]: UrlSegmentGroup}),\n+            last(),\n+        );\n   }\n \n   private expandSegment(\n       ngModule: NgModuleRef<any>, segmentGroup: UrlSegmentGroup, routes: Route[],\n       segments: UrlSegment[], outlet: string,\n       allowRedirects: boolean): Observable<UrlSegmentGroup> {\n-    // We need to expand each outlet group independently to ensure that we not only load modules\n-    // for routes matching the given `outlet`, but also those which will be activated because\n-    // their path is empty string. This can result in multiple outlets being activated at once.\n-    const routesByOutlet: Map<string, Route[]> = groupRoutesByOutlet(routes);\n-    if (!routesByOutlet.has(outlet)) {\n-      routesByOutlet.set(outlet, []);\n-    }\n-\n-    const expandRoutes = (routes: Route[]) => {\n-      return from(routes).pipe(\n-          concatMap((r: Route) => {\n-            const expanded$ = this.expandSegmentAgainstRoute(\n-                ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);\n-            return expanded$.pipe(catchError(e => {\n-              if (e instanceof NoMatch) {\n-                return of(null);\n-              }\n-              throw e;\n-            }));\n-          }),\n-          first((s: UrlSegmentGroup|null): s is UrlSegmentGroup => s !== null),\n-          catchError(e => {\n-            if (e instanceof EmptyError || e.name === 'EmptyError') {\n-              if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n-                return of(new UrlSegmentGroup([], {}));\n-              }\n-              throw new NoMatch(segmentGroup);\n+    return from(routes).pipe(\n+        concatMap((r: any) => {\n+          const expanded$ = this.expandSegmentAgainstRoute(\n+              ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);\n+          return expanded$.pipe(catchError((e: any) => {\n+            if (e instanceof NoMatch) {\n+              return of(null);\n             }\n             throw e;\n-          }),\n-      );\n-    };\n-\n-    const expansions = Array.from(routesByOutlet.entries()).map(([routeOutlet, routes]) => {\n-      const expanded = expandRoutes(routes);\n-      // Map all results from outlets we aren't activating to `null` so they can be ignored later\n-      return routeOutlet === outlet ? expanded :\n-                                      expanded.pipe(map(() => null), catchError(() => of(null)));\n-    });\n-    return from(expansions)\n-        .pipe(\n-            combineAll(),\n-            first(),\n-            // Return only the expansion for the route outlet we are trying to activate.\n-            map(results => results.find(result => result !== null)!),\n-        );\n+          }));\n+        }),\n+        first((s): s is UrlSegmentGroup => !!s), catchError((e: any, _: any) => {\n+          if (e instanceof EmptyError || e.name === 'EmptyError') {\n+            if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n+              return of(new UrlSegmentGroup([], {}));\n+            }\n+            throw new NoMatch(segmentGroup);\n+          }\n+          throw e;\n+        }));\n   }\n \n   private expandSegmentAgainstRoute(\n       ngModule: NgModuleRef<any>, segmentGroup: UrlSegmentGroup, routes: Route[], route: Route,\n       paths: UrlSegment[], outlet: string, allowRedirects: boolean): Observable<UrlSegmentGroup> {\n-    // Empty string segments are special because multiple outlets can match a single path, i.e.\n-    // `[{path: '', component: B}, {path: '', loadChildren: () => {}, outlet: \"about\"}]`\n-    if (getOutlet(route) !== outlet && route.path !== '') {\n+    if (!isImmediateMatch(route, segmentGroup, paths, outlet)) {\n       return noMatch(segmentGroup);\n     }\n \n     if (route.redirectTo === undefined) {\n-      return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths);\n+      return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths, outlet);\n     }\n \n     if (allowRedirects && this.allowRedirects) {\n@@ -269,7 +277,7 @@ class ApplyRedirects {\n \n   private matchSegmentAgainstRoute(\n       ngModule: NgModuleRef<any>, rawSegmentGroup: UrlSegmentGroup, route: Route,\n-      segments: UrlSegment[]): Observable<UrlSegmentGroup> {\n+      segments: UrlSegment[], outlet: string): Observable<UrlSegmentGroup> {\n     if (route.path === '**') {\n       if (route.loadChildren) {\n         return this.configLoader.load(ngModule.injector, route)\n@@ -292,16 +300,11 @@ class ApplyRedirects {\n       const childModule = routerConfig.module;\n       const childConfig = routerConfig.routes;\n \n-      const {segmentGroup, slicedSegments} =\n+      const {segmentGroup: splitSegmentGroup, slicedSegments} =\n           split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig);\n-      // TODO(atscott): clearing the source segment and segment index shift is only necessary to\n-      // prevent failures in tests which assert exact object matches. The `split` is now shared\n-      // between applyRedirects and recognize and only the `recognize` step needs these properties.\n-      // Before the implementations were merged, the applyRedirects would not assign them.\n-      // We should be able to remove this logic as a \"breaking change\" but should do some more\n-      // investigation into the failures first.\n-      segmentGroup._sourceSegment = undefined;\n-      segmentGroup._segmentIndexShift = undefined;\n+      // See comment on the other call to `split` about why this is necessary.\n+      const segmentGroup =\n+          new UrlSegmentGroup(splitSegmentGroup.segments, splitSegmentGroup.children);\n \n       if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n         const expanded$ = this.expandChildren(childModule, childConfig, segmentGroup);\n@@ -313,8 +316,10 @@ class ApplyRedirects {\n         return of(new UrlSegmentGroup(consumedSegments, {}));\n       }\n \n+      const matchedOnOutlet = getOutlet(route) === outlet;\n       const expanded$ = this.expandSegment(\n-          childModule, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);\n+          childModule, segmentGroup, childConfig, slicedSegments,\n+          matchedOnOutlet ? PRIMARY_OUTLET : outlet, true);\n       return expanded$.pipe(\n           map((cs: UrlSegmentGroup) =>\n                   new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children)));\n@@ -473,7 +478,6 @@ class ApplyRedirects {\n   }\n }\n \n-\n /**\n  * When possible, merges the primary outlet child into the parent `UrlSegmentGroup`.\n  *"
        },
        {
            "sha": "a3568d1b1c469101e23d8496c58cd4569e8dc08c",
            "filename": "packages/router/src/recognize.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 9,
            "changes": 22,
            "blob_url": "https://github.com/angular/angular/blob/e43f7e26fe8d3010682c56c68c0e09791bb3ed55/packages%2Frouter%2Fsrc%2Frecognize.ts",
            "raw_url": "https://github.com/angular/angular/raw/e43f7e26fe8d3010682c56c68c0e09791bb3ed55/packages%2Frouter%2Fsrc%2Frecognize.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frecognize.ts?ref=e43f7e26fe8d3010682c56c68c0e09791bb3ed55",
            "patch": "@@ -14,7 +14,7 @@ import {ActivatedRouteSnapshot, inheritedParamsDataResolve, ParamsInheritanceStr\n import {PRIMARY_OUTLET} from './shared';\n import {UrlSegment, UrlSegmentGroup, UrlTree} from './url_tree';\n import {last} from './utils/collection';\n-import {getOutlet} from './utils/config';\n+import {getOutlet, sortByMatchingOutlets} from './utils/config';\n import {isImmediateMatch, match, noLeftoversInUrl, split} from './utils/config_matching';\n import {TreeNode} from './utils/tree';\n \n@@ -64,6 +64,8 @@ export class Recognizer {\n       return null;\n     }\n \n+    // Use Object.freeze to prevent readers of the Router state from modifying it outside of a\n+    // navigation, resulting in the router being out of sync with the browser.\n     const root = new ActivatedRouteSnapshot(\n         [], Object.freeze({}), Object.freeze({...this.urlTree.queryParams}), this.urlTree.fragment!,\n         {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});\n@@ -108,8 +110,7 @@ export class Recognizer {\n       const child = segmentGroup.children[childOutlet];\n       // Sort the config so that routes with outlets that match the one being activated appear\n       // first, followed by routes for other outlets, which might match if they have an empty path.\n-      const sortedConfig = config.filter(r => getOutlet(r) === childOutlet);\n-      sortedConfig.push(...config.filter(r => getOutlet(r) !== childOutlet));\n+      const sortedConfig = sortByMatchingOutlets(config, childOutlet);\n       const outletChildren = this.processSegmentGroup(sortedConfig, child, childOutlet);\n       if (outletChildren === null) {\n         // Configs must match all segment children so because we did not find a match for this\n@@ -182,6 +183,9 @@ export class Recognizer {\n \n     const {segmentGroup, slicedSegments} = split(\n         rawSegment, consumedSegments, rawSlicedSegments,\n+        // Filter out routes with redirectTo because we are trying to create activated route\n+        // snapshots and don't handle redirects here. That should have been done in\n+        // `applyRedirects`.\n         childConfig.filter(c => c.redirectTo === undefined), this.relativeLinkResolution);\n \n     if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n@@ -234,6 +238,11 @@ function getChildConfig(route: Route): Route[] {\n   return [];\n }\n \n+function hasEmptyPathConfig(node: TreeNode<ActivatedRouteSnapshot>) {\n+  const config = node.value.routeConfig;\n+  return config && config.path === '' && config.redirectTo === undefined;\n+}\n+\n /**\n  * Finds `TreeNode`s with matching empty path route configs and merges them into `TreeNode` with the\n  * children from each duplicate. This is necessary because different outlets can match a single\n@@ -243,13 +252,8 @@ function mergeEmptyPathMatches(nodes: Array<TreeNode<ActivatedRouteSnapshot>>):\n     Array<TreeNode<ActivatedRouteSnapshot>> {\n   const result: Array<TreeNode<ActivatedRouteSnapshot>> = [];\n \n-  function hasEmptyConfig(node: TreeNode<ActivatedRouteSnapshot>) {\n-    const config = node.value.routeConfig;\n-    return config && config.path === '' && config.redirectTo === undefined;\n-  }\n-\n   for (const node of nodes) {\n-    if (!hasEmptyConfig(node)) {\n+    if (!hasEmptyPathConfig(node)) {\n       result.push(node);\n       continue;\n     }"
        },
        {
            "sha": "6c4991910b2e1585c4d4cd9d86b8a1b5445a9b89",
            "filename": "packages/router/src/utils/collection.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 26,
            "changes": 26,
            "blob_url": "https://github.com/angular/angular/blob/e43f7e26fe8d3010682c56c68c0e09791bb3ed55/packages%2Frouter%2Fsrc%2Futils%2Fcollection.ts",
            "raw_url": "https://github.com/angular/angular/raw/e43f7e26fe8d3010682c56c68c0e09791bb3ed55/packages%2Frouter%2Fsrc%2Futils%2Fcollection.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Futils%2Fcollection.ts?ref=e43f7e26fe8d3010682c56c68c0e09791bb3ed55",
            "patch": "@@ -83,32 +83,6 @@ export function forEach<K, V>(map: {[key: string]: V}, callback: (v: V, k: strin\n   }\n }\n \n-export function waitForMap<A, B>(\n-    obj: {[k: string]: A}, fn: (k: string, a: A) => Observable<B>): Observable<{[k: string]: B}> {\n-  if (Object.keys(obj).length === 0) {\n-    return of({});\n-  }\n-\n-  const waitHead: Observable<B>[] = [];\n-  const waitTail: Observable<B>[] = [];\n-  const res: {[k: string]: B} = {};\n-\n-  forEach(obj, (a: A, k: string) => {\n-    const mapped = fn(k, a).pipe(map((r: B) => res[k] = r));\n-    if (k === PRIMARY_OUTLET) {\n-      waitHead.push(mapped);\n-    } else {\n-      waitTail.push(mapped);\n-    }\n-  });\n-\n-  // Closure compiler has problem with using spread operator here. So we use \"Array.concat\".\n-  // Note that we also need to cast the new promise because TypeScript cannot infer the type\n-  // when calling the \"of\" function through \"Function.apply\"\n-  return (of.apply(null, waitHead.concat(waitTail)) as Observable<Observable<B>>)\n-      .pipe(concatAll(), lastValue(), map(() => res));\n-}\n-\n export function wrapIntoObservable<T>(value: T|Promise<T>|Observable<T>): Observable<T> {\n   if (isObservable(value)) {\n     return value;"
        },
        {
            "sha": "fd284e5b4de0675cc7a3fd5e8f29b7d019c49e7d",
            "filename": "packages/router/src/utils/config.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 13,
            "changes": 23,
            "blob_url": "https://github.com/angular/angular/blob/e43f7e26fe8d3010682c56c68c0e09791bb3ed55/packages%2Frouter%2Fsrc%2Futils%2Fconfig.ts",
            "raw_url": "https://github.com/angular/angular/raw/e43f7e26fe8d3010682c56c68c0e09791bb3ed55/packages%2Frouter%2Fsrc%2Futils%2Fconfig.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Futils%2Fconfig.ts?ref=e43f7e26fe8d3010682c56c68c0e09791bb3ed55",
            "patch": "@@ -123,20 +123,17 @@ export function standardizeConfig(r: Route): Route {\n   return c;\n }\n \n-/** Returns of `Map` of outlet names to the `Route`s for that outlet. */\n-export function groupRoutesByOutlet(routes: Route[]): Map<string, Route[]> {\n-  return routes.reduce((map, route) => {\n-    const routeOutlet = getOutlet(route);\n-    if (map.has(routeOutlet)) {\n-      map.get(routeOutlet)!.push(route);\n-    } else {\n-      map.set(routeOutlet, [route]);\n-    }\n-    return map;\n-  }, new Map<string, Route[]>());\n-}\n-\n /** Returns the `route.outlet` or PRIMARY_OUTLET if none exists. */\n export function getOutlet(route: Route): string {\n   return route.outlet || PRIMARY_OUTLET;\n }\n+\n+/**\n+ * Sorts the `routes` such that the ones with an outlet matching `outletName` come first.\n+ * The order of the configs is otherwise preserved.\n+ */\n+export function sortByMatchingOutlets(routes: Routes, outletName: string): Routes {\n+  const sortedConfig = routes.filter(r => getOutlet(r) === outletName);\n+  sortedConfig.push(...routes.filter(r => getOutlet(r) !== outletName));\n+  return sortedConfig;\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "52e625e8a3c81b035b29de54cbf5b7aa3ef85736",
            "filename": "packages/router/src/utils/config_matching.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/e43f7e26fe8d3010682c56c68c0e09791bb3ed55/packages%2Frouter%2Fsrc%2Futils%2Fconfig_matching.ts",
            "raw_url": "https://github.com/angular/angular/raw/e43f7e26fe8d3010682c56c68c0e09791bb3ed55/packages%2Frouter%2Fsrc%2Futils%2Fconfig_matching.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Futils%2Fconfig_matching.ts?ref=e43f7e26fe8d3010682c56c68c0e09791bb3ed55",
            "patch": "@@ -21,7 +21,7 @@ export interface MatchResult {\n   positionalParamSegments: {[k: string]: UrlSegment};\n }\n \n-const noMatch = {\n+const noMatch: MatchResult = {\n   matched: false,\n   consumedSegments: [],\n   lastChild: 0,\n@@ -183,9 +183,8 @@ export function isImmediateMatch(\n   }\n   if (route.path === '**') {\n     return true;\n-  } else {\n-    return match(rawSegment, route, segments).matched;\n   }\n+  return match(rawSegment, route, segments).matched;\n }\n \n export function noLeftoversInUrl("
        },
        {
            "sha": "18dcf9718f53140200cc1caa62ab2cbe0b33bcfd",
            "filename": "packages/router/test/apply_redirects.spec.ts",
            "status": "modified",
            "additions": 138,
            "deletions": 6,
            "changes": 144,
            "blob_url": "https://github.com/angular/angular/blob/e43f7e26fe8d3010682c56c68c0e09791bb3ed55/packages%2Frouter%2Ftest%2Fapply_redirects.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e43f7e26fe8d3010682c56c68c0e09791bb3ed55/packages%2Frouter%2Ftest%2Fapply_redirects.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fapply_redirects.spec.ts?ref=e43f7e26fe8d3010682c56c68c0e09791bb3ed55",
            "patch": "@@ -8,6 +8,8 @@\n \n import {NgModuleRef} from '@angular/core';\n import {fakeAsync, TestBed, tick} from '@angular/core/testing';\n+import {ActivatedRouteSnapshot} from '@angular/router';\n+import {TreeNode} from '@angular/router/src/utils/tree';\n import {Observable, of} from 'rxjs';\n import {delay, tap} from 'rxjs/operators';\n \n@@ -504,10 +506,11 @@ describe('applyRedirects', () => {\n              [{path: '', loadChildren: 'root'}, {path: '', loadChildren: 'aux', outlet: 'popup'}];\n \n          applyRedirects(testModule.injector, <any>loader, serializer, tree(''), config).subscribe();\n-         expect(loadCalls).toBe(2);\n+         expect(loadCalls).toBe(1);\n          tick(100);\n          expect(loaded).toEqual(['root']);\n-         tick(100);\n+         expect(loadCalls).toBe(2);\n+         tick(200);\n          expect(loaded).toEqual(['root', 'aux']);\n        }));\n \n@@ -560,9 +563,8 @@ describe('applyRedirects', () => {\n          applyRedirects(testModule.injector, <any>loader, serializer, tree('(popup:modal)'), config)\n              .subscribe();\n          tick(auxDelay);\n-         expect(loaded).toEqual(['aux']);\n          tick(rootDelay);\n-         expect(loaded).toEqual(['aux', 'root']);\n+         expect(loaded.sort()).toEqual(['aux', 'root'].sort());\n        }));\n   });\n \n@@ -681,6 +683,108 @@ describe('applyRedirects', () => {\n       });\n     });\n \n+    describe('aux split after empty path parent', () => {\n+      it('should work with non-empty auxiliary path', () => {\n+        checkRedirect(\n+            [{\n+              path: '',\n+              children: [\n+                {path: 'a', component: ComponentA},\n+                {path: 'c', component: ComponentC, outlet: 'aux'},\n+                {path: 'b', redirectTo: 'c', outlet: 'aux'}\n+              ]\n+            }],\n+            '(aux:b)', (t: UrlTree) => {\n+              expectTreeToBe(t, '(aux:c)');\n+            });\n+      });\n+\n+      it('should work with empty auxiliary path', () => {\n+        checkRedirect(\n+            [{\n+              path: '',\n+              children: [\n+                {path: 'a', component: ComponentA},\n+                {path: 'c', component: ComponentC, outlet: 'aux'},\n+                {path: '', redirectTo: 'c', outlet: 'aux'}\n+              ]\n+            }],\n+            '', (t: UrlTree) => {\n+              expectTreeToBe(t, '(aux:c)');\n+            });\n+      });\n+\n+      it('should work with empty auxiliary path and matching primary', () => {\n+        checkRedirect(\n+            [{\n+              path: '',\n+              children: [\n+                {path: 'a', component: ComponentA},\n+                {path: 'c', component: ComponentC, outlet: 'aux'},\n+                {path: '', redirectTo: 'c', outlet: 'aux'}\n+              ]\n+            }],\n+            'a', (t: UrlTree) => {\n+              expect(t.toString()).toEqual('/a(aux:c)');\n+            });\n+      });\n+\n+      it('should work with aux outlets adjacent to and children of empty path at once', () => {\n+        checkRedirect(\n+            [\n+              {\n+                path: '',\n+                component: ComponentA,\n+                children: [{path: 'b', outlet: 'b', component: ComponentB}]\n+              },\n+              {path: 'c', outlet: 'c', component: ComponentC}\n+            ],\n+            '(b:b//c:c)', (t: UrlTree) => {\n+              expect(t.toString()).toEqual('/(b:b//c:c)');\n+            });\n+      });\n+\n+\n+      it('should work with children outlets within two levels of empty parents', () => {\n+        checkRedirect(\n+            [{\n+              path: '',\n+              component: ComponentA,\n+              children: [{\n+                path: '',\n+                component: ComponentB,\n+                children: [\n+                  {path: 'd', outlet: 'aux', redirectTo: 'c'},\n+                  {path: 'c', outlet: 'aux', component: ComponentC}\n+                ]\n+              }]\n+            }],\n+            '(aux:d)', (t: UrlTree) => {\n+              expect(t.toString()).toEqual('/(aux:c)');\n+            });\n+      });\n+\n+      it('does not persist a primary segment beyond the boundary of a named outlet match', () => {\n+        const config: Routes = [\n+          {\n+            path: '',\n+            component: ComponentA,\n+            outlet: 'aux',\n+            children: [{path: 'b', component: ComponentB, redirectTo: '/c'}]\n+          },\n+          {path: 'c', component: ComponentC}\n+        ];\n+        applyRedirects(testModule.injector, null!, serializer, tree('/b'), config)\n+            .subscribe(\n+                (_) => {\n+                  throw 'Should not be reached';\n+                },\n+                e => {\n+                  expect(e.message).toEqual(`Cannot match any routes. URL Segment: 'b'`);\n+                });\n+      });\n+    });\n+\n     describe('split at the end (no right child)', () => {\n       it('should create a new child (non-terminal)', () => {\n         checkRedirect(\n@@ -844,21 +948,49 @@ describe('applyRedirects', () => {\n             {\n               path: '',\n               children: [\n-                {path: '', component: ComponentA, outlet: 'aux'},\n+                {path: '', outlet: 'aux', redirectTo: 'b'},\n+                {path: 'b', component: ComponentA, outlet: 'aux'},\n                 {path: '', redirectTo: 'b', pathMatch: 'full'},\n                 {path: 'b', component: ComponentB},\n               ],\n             },\n           ])\n           .subscribe(\n               (tree: UrlTree) => {\n-                expect(tree.toString()).toEqual('/b');\n+                expect(tree.toString()).toEqual('/b(aux:b)');\n+                expect(tree.root.children['primary'].toString()).toEqual('b');\n+                expect(tree.root.children['aux']).toBeDefined();\n+                expect(tree.root.children['aux'].toString()).toEqual('b');\n               },\n               () => {\n                 fail('should not be reached');\n               });\n     });\n \n+    it('should prevent empty named outlets from appearing in leaves, resulting in odd tree url',\n+       () => {\n+         applyRedirects(\n+             testModule.injector, null!, serializer, tree(''),\n+             [\n+               {\n+                 path: '',\n+                 children: [\n+                   {path: '', component: ComponentA, outlet: 'aux'},\n+                   {path: '', redirectTo: 'b', pathMatch: 'full'},\n+                   {path: 'b', component: ComponentB},\n+                 ],\n+               },\n+             ])\n+             .subscribe(\n+                 (tree: UrlTree) => {\n+                   expect(tree.toString()).toEqual('/b');\n+                 },\n+                 () => {\n+                   fail('should not be reached');\n+                 });\n+       });\n+\n+\n     it('should work when entry point is named outlet', () => {\n       applyRedirects(\n           testModule.injector, null!, serializer, tree('(popup:modal)'),"
        },
        {
            "sha": "038626f9338295fd390db163ca9f4fc1fd05a8af",
            "filename": "packages/router/test/integration.spec.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 2,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/e43f7e26fe8d3010682c56c68c0e09791bb3ed55/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e43f7e26fe8d3010682c56c68c0e09791bb3ed55/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fintegration.spec.ts?ref=e43f7e26fe8d3010682c56c68c0e09791bb3ed55",
            "patch": "@@ -1095,6 +1095,22 @@ describe('Integration', () => {\n        expect(fixture.nativeElement).toHaveText('team 22 [ user victor, right: simple ]');\n      })));\n \n+  it('should support secondary routes as child of empty path parent',\n+     fakeAsync(inject([Router], (router: Router) => {\n+       const fixture = createRoot(router, RootCmp);\n+\n+       router.resetConfig([{\n+         path: '',\n+         component: TeamCmp,\n+         children: [{path: 'simple', component: SimpleCmp, outlet: 'right'}]\n+       }]);\n+\n+       router.navigateByUrl('/(right:simple)');\n+       advance(fixture);\n+\n+       expect(fixture.nativeElement).toHaveText('team  [ , right: simple ]');\n+     })));\n+\n   it('should deactivate outlets', fakeAsync(inject([Router], (router: Router) => {\n        const fixture = createRoot(router, RootCmp);\n \n@@ -1688,13 +1704,14 @@ describe('Integration', () => {\n            data: {one: 1},\n            resolve: {two: 'resolveTwo'},\n            children: [\n-             {path: '', data: {three: 3}, resolve: {four: 'resolveFour'}, component: RouteCmp}, {\n+             {path: '', data: {three: 3}, resolve: {four: 'resolveFour'}, component: RouteCmp},\n+             {\n                path: '',\n                data: {five: 5},\n                resolve: {six: 'resolveSix'},\n                component: RouteCmp,\n                outlet: 'right'\n-             }\n+             },\n            ]\n          }]);\n "
        }
    ],
    "stats": {
        "total": 418,
        "additions": 280,
        "deletions": 138
    }
}