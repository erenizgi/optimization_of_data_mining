{
    "author": "AndrewKushnir",
    "message": "fix(forms): handle standalone `<form>` tag correctly in `NgControlStatusGroup` directive (#40344)\n\nThe `NgControlStatusGroup` directive is shared between template-driven and reactive form modules. In cases when\nonly reactive forms module is present, the `NgControlStatusGroup` directive is still activated on all `<form>`\nelements, but if there is no other reactive directive applied (such as `formGroup`), corresponding `ControlContainer`\ntoken is missing, thus causing exceptions (since `NgControlStatusGroup` directive relies on it to determine the\nstatus). This commit updates the logic to handle the case when no `ControlContainer` is present (effectively making\ndirective logic a noop in this case).\n\nAlternative approach (more risky) worth considering in the future is to split the `NgControlStatusGroup` into\n2 directives with different set of selectors and include them into template-driven and reactive modules separately.\nThe downside is that these directives might be activated simultaneously on the same element (e.g. `<form>`),\neffectively doing the work twice.\n\nResolves #38391.\n\nPR Close #40344",
    "sha": "fdbd3cae8a54af22b032fd619efb4f08e154f86b",
    "files": [
        {
            "sha": "41aad8646de084eca65f0cd9b0a3140cae44f084",
            "filename": "packages/forms/src/directives/ng_control_status.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/angular/angular/blob/fdbd3cae8a54af22b032fd619efb4f08e154f86b/packages%2Fforms%2Fsrc%2Fdirectives%2Fng_control_status.ts",
            "raw_url": "https://github.com/angular/angular/raw/fdbd3cae8a54af22b032fd619efb4f08e154f86b/packages%2Fforms%2Fsrc%2Fdirectives%2Fng_control_status.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Fsrc%2Fdirectives%2Fng_control_status.ts?ref=fdbd3cae8a54af22b032fd619efb4f08e154f86b",
            "patch": "@@ -6,39 +6,39 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {Directive, Self} from '@angular/core';\n+import {Directive, Optional, Self} from '@angular/core';\n \n import {AbstractControlDirective} from './abstract_control_directive';\n import {ControlContainer} from './control_container';\n import {NgControl} from './ng_control';\n \n export class AbstractControlStatus {\n-  private _cd: AbstractControlDirective;\n+  private _cd: AbstractControlDirective|null;\n \n-  constructor(cd: AbstractControlDirective) {\n+  constructor(cd: AbstractControlDirective|null) {\n     this._cd = cd;\n   }\n \n   get ngClassUntouched(): boolean {\n-    return this._cd.control ? this._cd.control.untouched : false;\n+    return this._cd?.control?.untouched ?? false;\n   }\n   get ngClassTouched(): boolean {\n-    return this._cd.control ? this._cd.control.touched : false;\n+    return this._cd?.control?.touched ?? false;\n   }\n   get ngClassPristine(): boolean {\n-    return this._cd.control ? this._cd.control.pristine : false;\n+    return this._cd?.control?.pristine ?? false;\n   }\n   get ngClassDirty(): boolean {\n-    return this._cd.control ? this._cd.control.dirty : false;\n+    return this._cd?.control?.dirty ?? false;\n   }\n   get ngClassValid(): boolean {\n-    return this._cd.control ? this._cd.control.valid : false;\n+    return this._cd?.control?.valid ?? false;\n   }\n   get ngClassInvalid(): boolean {\n-    return this._cd.control ? this._cd.control.invalid : false;\n+    return this._cd?.control?.invalid ?? false;\n   }\n   get ngClassPending(): boolean {\n-    return this._cd.control ? this._cd.control.pending : false;\n+    return this._cd?.control?.pending ?? false;\n   }\n }\n \n@@ -99,7 +99,7 @@ export class NgControlStatus extends AbstractControlStatus {\n   host: ngControlStatusHost\n })\n export class NgControlStatusGroup extends AbstractControlStatus {\n-  constructor(@Self() cd: ControlContainer) {\n+  constructor(@Optional() @Self() cd: ControlContainer) {\n     super(cd);\n   }\n }"
        },
        {
            "sha": "ceb64250600d3c7b8f5362e03cda9c2fc01c2613",
            "filename": "packages/forms/test/reactive_integration_spec.ts",
            "status": "modified",
            "additions": 50,
            "deletions": 0,
            "changes": 50,
            "blob_url": "https://github.com/angular/angular/blob/fdbd3cae8a54af22b032fd619efb4f08e154f86b/packages%2Fforms%2Ftest%2Freactive_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fdbd3cae8a54af22b032fd619efb4f08e154f86b/packages%2Fforms%2Ftest%2Freactive_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Freactive_integration_spec.ts?ref=fdbd3cae8a54af22b032fd619efb4f08e154f86b",
            "patch": "@@ -94,6 +94,13 @@ const ValueAccessorB = createControlValueAccessor('[cva-b]');\n       return TestBed.createComponent(component);\n     }\n \n+    function initReactiveFormsTest<T>(\n+        component: Type<T>, ...directives: Type<any>[]): ComponentFixture<T> {\n+      TestBed.configureTestingModule(\n+          {declarations: [component, ...directives], imports: [ReactiveFormsModule]});\n+      return TestBed.createComponent(component);\n+    }\n+\n     // Helper method that attaches a spy to a `validate` function on a Validator class.\n     function validatorSpyOn(validatorClass: any) {\n       return spyOn(validatorClass.prototype, 'validate').and.callThrough();\n@@ -773,6 +780,49 @@ const ValueAccessorB = createControlValueAccessor('[cva-b]');\n     });\n \n     describe('setting status classes', () => {\n+      it('should not assign status on standalone <form> element', () => {\n+        @Component({\n+          selector: 'form-comp',\n+          template: `\n+            <form></form>\n+          `\n+        })\n+        class FormComp {\n+        }\n+\n+        const fixture = initReactiveFormsTest(FormComp);\n+        fixture.detectChanges();\n+\n+        const form = fixture.debugElement.query(By.css('form')).nativeElement;\n+        // Expect no classes added to the <form> element since it has no\n+        // reactive directives attached and only ReactiveForms module is used.\n+        expect(sortedClassList(form)).toEqual([]);\n+      });\n+\n+      it('should not assign status on standalone <form> element with form control inside', () => {\n+        @Component({\n+          selector: 'form-comp',\n+          template: `\n+            <form>\n+              <input type=\"text\" [formControl]=\"control\">\n+            </form>\n+          `\n+        })\n+        class FormComp {\n+          control = new FormControl('abc');\n+        }\n+        const fixture = initReactiveFormsTest(FormComp);\n+        fixture.detectChanges();\n+\n+        const form = fixture.debugElement.query(By.css('form')).nativeElement;\n+        // Expect no classes added to the <form> element since it has no\n+        // reactive directives attached and only ReactiveForms module is used.\n+        expect(sortedClassList(form)).toEqual([]);\n+\n+        const input = fixture.debugElement.query(By.css('input')).nativeElement;\n+        expect(sortedClassList(input)).toEqual(['ng-pristine', 'ng-untouched', 'ng-valid']);\n+      });\n+\n       it('should work with single fields', () => {\n         const fixture = initTest(FormControlComp);\n         const control = new FormControl('', Validators.required);"
        }
    ],
    "stats": {
        "total": 72,
        "additions": 61,
        "deletions": 11
    }
}