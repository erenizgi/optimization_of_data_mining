{
    "author": "dario-piotrowicz",
    "message": "refactor(animations): improve some animations comments (#44203)\n\nFix various typos and also improve sentences (by making them more clear\nor grammatically correct) present in comments inside the animations package\n\nPR Close #44203",
    "sha": "155742e305cad4b367267c03250d465ce9339587",
    "files": [
        {
            "sha": "a48aa02d1c3cfc4eca1b70d6f83c1bf7f533df8f",
            "filename": "packages/animations/browser/src/dsl/animation_ast_builder.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/155742e305cad4b367267c03250d465ce9339587/packages%2Fanimations%2Fbrowser%2Fsrc%2Fdsl%2Fanimation_ast_builder.ts",
            "raw_url": "https://github.com/angular/angular/raw/155742e305cad4b367267c03250d465ce9339587/packages%2Fanimations%2Fbrowser%2Fsrc%2Fdsl%2Fanimation_ast_builder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fanimations%2Fbrowser%2Fsrc%2Fdsl%2Fanimation_ast_builder.ts?ref=155742e305cad4b367267c03250d465ce9339587",
            "patch": "@@ -487,7 +487,8 @@ function normalizeSelector(selector: string): [string, boolean] {\n     selector = selector.replace(SELF_TOKEN_REGEX, '');\n   }\n \n-  // the :enter and :leave selectors are filled in at runtime during timeline building\n+  // Note: the :enter and :leave aren't normalized here since those\n+  // selectors are filled in at runtime during timeline building\n   selector = selector.replace(/@\\*/g, NG_TRIGGER_SELECTOR)\n                  .replace(/@\\w+/g, match => NG_TRIGGER_SELECTOR + '-' + match.substr(1))\n                  .replace(/:animating/g, NG_ANIMATING_SELECTOR);"
        },
        {
            "sha": "55d829e381ee800bb82dfdfbcaec0a2df2210d5c",
            "filename": "packages/animations/browser/src/dsl/animation_timeline_builder.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/155742e305cad4b367267c03250d465ce9339587/packages%2Fanimations%2Fbrowser%2Fsrc%2Fdsl%2Fanimation_timeline_builder.ts",
            "raw_url": "https://github.com/angular/angular/raw/155742e305cad4b367267c03250d465ce9339587/packages%2Fanimations%2Fbrowser%2Fsrc%2Fdsl%2Fanimation_timeline_builder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fanimations%2Fbrowser%2Fsrc%2Fdsl%2Fanimation_timeline_builder.ts?ref=155742e305cad4b367267c03250d465ce9339587",
            "patch": "@@ -57,14 +57,14 @@ const LEAVE_TOKEN_REGEX = new RegExp(LEAVE_TOKEN, 'g');\n  * [TimelineBuilder]\n  * This class is responsible for tracking the styles and building a series of keyframe objects for a\n  * timeline between a start and end time. The builder starts off with an initial timeline and each\n- * time the AST comes across a `group()`, `keyframes()` or a combination of the two wihtin a\n+ * time the AST comes across a `group()`, `keyframes()` or a combination of the two within a\n  * `sequence()` then it will generate a sub timeline for each step as well as a new one after\n  * they are complete.\n  *\n  * As the AST is traversed, the timing state on each of the timelines will be incremented. If a sub\n  * timeline was created (based on one of the cases above) then the parent timeline will attempt to\n  * merge the styles used within the sub timelines into itself (only with group() this will happen).\n- * This happens with a merge operation (much like how the merge works in mergesort) and it will only\n+ * This happens with a merge operation (much like how the merge works in mergeSort) and it will only\n  * copy the most recently used styles from the sub timelines into the parent timeline. This ensures\n  * that if the styles are used later on in another phase of the animation then they will be the most\n  * up-to-date values.\n@@ -89,7 +89,7 @@ const LEAVE_TOKEN_REGEX = new RegExp(LEAVE_TOKEN, 'g');\n  * from all previous keyframes up until where it is first used. For the timeline keyframe generation\n  * to properly fill in the style it will place the previous value (the value from the parent\n  * timeline) or a default value of `*` into the backFill object. Given that each of the keyframe\n- * styles are objects that prototypically inhert from the backFill object, this means that if a\n+ * styles are objects that prototypically inherits from the backFill object, this means that if a\n  * value is added into the backFill then it will automatically propagate any missing values to all\n  * keyframes. Therefore the missing `height` value will be properly filled into the already\n  * processed keyframes.\n@@ -228,7 +228,7 @@ export class AnimationTimelineBuilderVisitor implements AstVisitor {\n     if (ast.steps.length) {\n       ast.steps.forEach(s => visitDslNode(this, s, ctx));\n \n-      // this is here just incase the inner steps only contain or end with a style() call\n+      // this is here just in case the inner steps only contain or end with a style() call\n       ctx.currentTimeline.applyStylesToKeyframe();\n \n       // this means that some animation function within the sequence\n@@ -567,7 +567,7 @@ export class AnimationTimelineContext {\n     if (includeSelf) {\n       results.push(this.element);\n     }\n-    if (selector.length > 0) {  // if :self is only used then the selector is empty\n+    if (selector.length > 0) {  // only if :self is used then the selector can be empty\n       selector = selector.replace(ENTER_TOKEN_REGEX, '.' + this._enterClassName);\n       selector = selector.replace(LEAVE_TOKEN_REGEX, '.' + this._leaveClassName);\n       const multi = limit != 1;\n@@ -857,7 +857,7 @@ class SubTimelineBuilder extends TimelineBuilder {\n         When the keyframe is stretched then it means that the delay before the animation\n         starts is gone. Instead the first keyframe is placed at the start of the animation\n         and it is then copied to where it starts when the original delay is over. This basically\n-        means nothing animates during that delay, but the styles are still renderered. For this\n+        means nothing animates during that delay, but the styles are still rendered. For this\n         to work the original offset values that exist in the original keyframes must be \"warped\"\n         so that they can take the new keyframe + delay into account.\n "
        },
        {
            "sha": "eb993c811ae6e4f7420c0112df11b83462347a3e",
            "filename": "packages/animations/browser/src/render/transition_animation_engine.ts",
            "status": "modified",
            "additions": 24,
            "deletions": 23,
            "changes": 47,
            "blob_url": "https://github.com/angular/angular/blob/155742e305cad4b367267c03250d465ce9339587/packages%2Fanimations%2Fbrowser%2Fsrc%2Frender%2Ftransition_animation_engine.ts",
            "raw_url": "https://github.com/angular/angular/raw/155742e305cad4b367267c03250d465ce9339587/packages%2Fanimations%2Fbrowser%2Fsrc%2Frender%2Ftransition_animation_engine.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fanimations%2Fbrowser%2Fsrc%2Frender%2Ftransition_animation_engine.ts?ref=155742e305cad4b367267c03250d465ce9339587",
            "patch": "@@ -244,7 +244,7 @@ export class AnimationTransitionNamespace {\n       // only remove the player if it is queued on the EXACT same trigger/namespace\n       // we only also deal with queued players here because if the animation has\n       // started then we want to keep the player alive until the flush happens\n-      // (which is where the previousPlayers are passed into the new palyer)\n+      // (which is where the previousPlayers are passed into the new player)\n       if (player.namespaceId == this.id && player.triggerName == triggerName && player.queued) {\n         player.destroy();\n       }\n@@ -579,7 +579,7 @@ export class TransitionAnimationEngine {\n       // the namespace list\n       this.newHostElements.set(hostElement, ns);\n \n-      // given that this host element is apart of the animation code, it\n+      // given that this host element is a part of the animation code, it\n       // may or may not be inserted by a parent node that is of an\n       // animation renderer type. If this happens then we can still have\n       // access to this item when we query for :enter nodes. If the parent\n@@ -652,8 +652,8 @@ export class TransitionAnimationEngine {\n     // normally there should only be one namespace per element, however\n     // if @triggers are placed on both the component element and then\n     // its host element (within the component code) then there will be\n-    // two namespaces returned. We use a set here to simply the dedupe\n-    // of namespaces incase there are multiple triggers both the elm and host\n+    // two namespaces returned. We use a set here to simply deduplicate\n+    // the namespaces in case (for the reason described above) there are multiple triggers\n     const namespaces = new Set<AnimationTransitionNamespace>();\n     const elementStates = this.statesByElement.get(element);\n     if (elementStates) {\n@@ -1008,31 +1008,32 @@ export class TransitionAnimationEngine {\n           return;\n         }\n \n-        // even though the element may not be apart of the DOM, it may\n-        // still be added at a later point (due to the mechanics of content\n+        // even though the element may not be in the DOM, it may still\n+        // be added at a later point (due to the mechanics of content\n         // projection and/or dynamic component insertion) therefore it's\n-        // important we still style the element.\n+        // important to still style the element.\n         if (nodeIsOrphaned) {\n           player.onStart(() => eraseStyles(element, instruction.fromStyles));\n           player.onDestroy(() => setStyles(element, instruction.toStyles));\n           skippedPlayers.push(player);\n           return;\n         }\n \n-        // if a unmatched transition is queued to go then it SHOULD NOT render\n-        // an animation and cancel the previously running animations.\n+        // if an unmatched transition is queued and ready to go\n+        // then it SHOULD NOT render an animation and cancel the\n+        // previously running animations.\n         if (entry.isFallbackTransition) {\n           player.onStart(() => eraseStyles(element, instruction.fromStyles));\n           player.onDestroy(() => setStyles(element, instruction.toStyles));\n           skippedPlayers.push(player);\n           return;\n         }\n \n-        // this means that if a parent animation uses this animation as a sub trigger\n-        // then it will instruct the timeline builder to not add a player delay, but\n-        // instead stretch the first keyframe gap up until the animation starts. The\n-        // reason this is important is to prevent extra initialization styles from being\n-        // required by the user in the animation.\n+        // this means that if a parent animation uses this animation as a sub-trigger\n+        // then it will instruct the timeline builder not to add a player delay, but\n+        // instead stretch the first keyframe gap until the animation starts. This is\n+        // important in order to prevent extra initialization styles from being\n+        // required by the user for the animation.\n         instruction.timelines.forEach(tl => tl.stretchStartingKeyframe = true);\n \n         subTimelines.append(element, instruction.timelines);\n@@ -1078,10 +1079,10 @@ export class TransitionAnimationEngine {\n     }\n \n     const allPreviousPlayersMap = new Map<any, TransitionAnimationPlayer[]>();\n-    // this map works to tell which element in the DOM tree is contained by\n-    // which animation. Further down below this map will get populated once\n-    // the players are built and in doing so it can efficiently figure out\n-    // if a sub player is skipped due to a parent player having priority.\n+    // this map tells us which element in the DOM tree is contained by\n+    // which animation. Further down this map will get populated once\n+    // the players are built and in doing so we can use it to efficiently\n+    // figure out if a sub player is skipped due to a parent player having priority.\n     const animationElementMap = new Map<any, any>();\n     queuedInstructions.forEach(entry => {\n       const element = entry.element;\n@@ -1102,13 +1103,13 @@ export class TransitionAnimationEngine {\n       });\n     });\n \n-    // this is a special case for nodes that will be removed (either by)\n+    // this is a special case for nodes that will be removed either by\n     // having their own leave animations or by being queried in a container\n     // that will be removed once a parent animation is complete. The idea\n     // here is that * styles must be identical to ! styles because of\n     // backwards compatibility (* is also filled in by default in many places).\n-    // Otherwise * styles will return an empty value or auto since the element\n-    // that is being getComputedStyle'd will not be visible (since * = destination)\n+    // Otherwise * styles will return an empty value or \"auto\" since the element\n+    // passed to getComputedStyle will not be visible (since * === destination)\n     const replaceNodes = allLeaveNodes.filter(node => {\n       return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);\n     });\n@@ -1202,9 +1203,9 @@ export class TransitionAnimationEngine {\n       }\n     });\n \n-    // find all of the sub players' corresponding inner animation player\n+    // find all of the sub players' corresponding inner animation players\n     subPlayers.forEach(player => {\n-      // even if any players are not found for a sub animation then it\n+      // even if no players are found for a sub animation it\n       // will still complete itself after the next tick since it's Noop\n       const playersForElement = skippedPlayersMap.get(player.element);\n       if (playersForElement && playersForElement.length) {"
        },
        {
            "sha": "5c193a7811bf463e755978211a83fbf03fd842a4",
            "filename": "packages/animations/src/animation_metadata.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/155742e305cad4b367267c03250d465ce9339587/packages%2Fanimations%2Fsrc%2Fanimation_metadata.ts",
            "raw_url": "https://github.com/angular/angular/raw/155742e305cad4b367267c03250d465ce9339587/packages%2Fanimations%2Fsrc%2Fanimation_metadata.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fanimations%2Fsrc%2Fanimation_metadata.ts?ref=155742e305cad4b367267c03250d465ce9339587",
            "patch": "@@ -884,7 +884,7 @@ export function keyframes(steps: AnimationStyleMetadata[]): AnimationKeyframesSe\n  * The animation steps run when the expression evaluates to true.\n  *\n  * - A state-change string takes the form \"state1 => state2\", where each side is a defined animation\n- * state, or an asterix (*) to refer to a dynamic start or end state.\n+ * state, or an asterisk (*) to refer to a dynamic start or end state.\n  *   - The expression string can contain multiple comma-separated statements;\n  * for example \"state1 => state2, state3 => state4\".\n  *   - Special values `:enter` and `:leave` initiate a transition on the entry and exit states,"
        },
        {
            "sha": "3635441d9df4edd93db10462fa0207fbc0f3f7df",
            "filename": "packages/core/test/animation/animation_integration_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/155742e305cad4b367267c03250d465ce9339587/packages%2Fcore%2Ftest%2Fanimation%2Fanimation_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/155742e305cad4b367267c03250d465ce9339587/packages%2Fcore%2Ftest%2Fanimation%2Fanimation_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fanimation%2Fanimation_integration_spec.ts?ref=155742e305cad4b367267c03250d465ce9339587",
            "patch": "@@ -19,7 +19,7 @@ const DEFAULT_NAMESPACE_ID = 'id';\n const DEFAULT_COMPONENT_ID = '1';\n \n (function() {\n-// these tests are only mean't to be run within the DOM (for now)\n+// these tests are only meant to be run within the DOM (for now)\n if (isNode) return;\n \n describe('animation tests', function() {\n@@ -3622,7 +3622,7 @@ describe('animation tests', function() {\n       ]);\n     });\n \n-    it('should convert hyphenated properties to camelcase by default that are auto/pre style properties',\n+    it('should convert hyphenated properties to camelCase by default that are auto/pre style properties',\n        () => {\n          @Component({\n            selector: 'cmp',"
        },
        {
            "sha": "a7e8cd27cd478081b1b62293721659d405f148ed",
            "filename": "packages/platform-browser/animations/src/animation_renderer.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/155742e305cad4b367267c03250d465ce9339587/packages%2Fplatform-browser%2Fanimations%2Fsrc%2Fanimation_renderer.ts",
            "raw_url": "https://github.com/angular/angular/raw/155742e305cad4b367267c03250d465ce9339587/packages%2Fplatform-browser%2Fanimations%2Fsrc%2Fanimation_renderer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser%2Fanimations%2Fsrc%2Fanimation_renderer.ts?ref=155742e305cad4b367267c03250d465ce9339587",
            "patch": "@@ -30,8 +30,8 @@ export class AnimationRendererFactory implements RendererFactory2 {\n   constructor(\n       private delegate: RendererFactory2, private engine: AnimationEngine, private _zone: NgZone) {\n     engine.onRemovalComplete = (element: any, delegate: Renderer2) => {\n-      // Note: if an component element has a leave animation, and the component\n-      // a host leave animation, the view engine will call `removeChild` for the parent\n+      // Note: if a component element has a leave animation, and a host leave animation,\n+      // the view engine will call `removeChild` for the parent\n       // component renderer as well as for the child component renderer.\n       // Therefore, we need to check if we already removed the element.\n       const parentNode = delegate?.parentNode(element);"
        },
        {
            "sha": "39c4be856dd736aa3c283340e81e510871e41161",
            "filename": "packages/platform-browser/animations/test/animation_renderer_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/155742e305cad4b367267c03250d465ce9339587/packages%2Fplatform-browser%2Fanimations%2Ftest%2Fanimation_renderer_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/155742e305cad4b367267c03250d465ce9339587/packages%2Fplatform-browser%2Fanimations%2Ftest%2Fanimation_renderer_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser%2Fanimations%2Ftest%2Fanimation_renderer_spec.ts?ref=155742e305cad4b367267c03250d465ce9339587",
            "patch": "@@ -132,7 +132,7 @@ describe('AnimationRenderer', () => {\n   });\n \n   describe('flushing animations', () => {\n-    // these tests are only mean't to be run within the DOM\n+    // these tests are only meant to be run within the DOM\n     if (isNode) return;\n \n     it('should flush and fire callbacks when the zone becomes stable', (async) => {"
        }
    ],
    "stats": {
        "total": 74,
        "additions": 38,
        "deletions": 36
    }
}