{
    "author": "petebacondarwin",
    "message": "build(docs-infra): associate `providedIn` injectables with their NgModule (#41960)\n\nSuch injectables were not appearing in the providers lists of their NgModule.\nThis commit updates the doc-gen to support associating these automatically.\nFurther, it also allows developers to mark other injectables that are provided\nin an NgModule with a reference to the NgModule where they are provided.\n\nThe commit also does a refactoring of the `processNgModuleDocs` dgeni\nprocessor code, to make it easier to maintain.\n\nFixes #41203\n\nPR Close #41960",
    "sha": "85f5cb45d25daf178eed3ff130fc7608e7ca5e58",
    "files": [
        {
            "sha": "933c640fe800566e209610a785de9a9909c3cd4c",
            "filename": "aio/tools/transforms/angular-api-package/processors/processNgModuleDocs.js",
            "status": "modified",
            "additions": 193,
            "deletions": 48,
            "changes": 241,
            "blob_url": "https://github.com/angular/angular/blob/85f5cb45d25daf178eed3ff130fc7608e7ca5e58/aio%2Ftools%2Ftransforms%2Fangular-api-package%2Fprocessors%2FprocessNgModuleDocs.js",
            "raw_url": "https://github.com/angular/angular/raw/85f5cb45d25daf178eed3ff130fc7608e7ca5e58/aio%2Ftools%2Ftransforms%2Fangular-api-package%2Fprocessors%2FprocessNgModuleDocs.js",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Ftools%2Ftransforms%2Fangular-api-package%2Fprocessors%2FprocessNgModuleDocs.js?ref=85f5cb45d25daf178eed3ff130fc7608e7ca5e58",
            "patch": "@@ -5,77 +5,222 @@ module.exports = function processNgModuleDocs(getDocFromAlias, createDocMessage,\n     exportDocTypes: ['directive', 'pipe'],\n     skipAbstractDirectives: true,\n     $process(docs) {\n-      // Match all the directives/pipes to their module\n       const errors = [];\n-      docs.forEach(doc => {\n-        if (this.exportDocTypes.indexOf(doc.docType) !== -1) {\n-          const options = doc[`${doc.docType}Options`];\n \n-          // Directives without a selector are considered abstract and do\n-          // not need to be part of any `@NgModule`.\n-          if (this.skipAbstractDirectives && doc.docType === 'directive' && !options.selector) {\n-            return;\n-          }\n+      for (const doc of docs) {\n+        if (this.exportDocTypes.indexOf(doc.docType) !== -1) {\n+          // Match all the directives/pipes to their module\n+          this.processNgModuleExportDoc(doc, errors);\n+        }\n \n-          if (!doc.ngModules || doc.ngModules.length === 0) {\n-            errors.push(createDocMessage(`\"${doc.id}\" has no @ngModule tag. Docs of type \"${doc.docType}\" must have this tag.`, doc));\n-            return;\n-          }\n+        if (doc.docType === 'class') {\n+          this.processInjectableDoc(doc, errors);\n+        }\n+      }\n \n-          doc.ngModules.forEach((ngModule, index) => {\n+      if (errors.length) {\n+        errors.forEach(error => log.error(error));\n+        throw new Error('Failed to process NgModule relationships.');\n+      }\n \n-            const ngModuleDocs = getDocFromAlias(ngModule, doc);\n+      // Update the NgModule docs after we have associated the directives/pipes/injectables docs.\n+      for (const doc of docs) {\n+        if (doc.docType === 'ngmodule') {\n+          convertAllPropertiesToArrays(doc.ngmoduleOptions);\n+          this.sortExportDocContainers(doc);\n+          this.processNgModuleProviders(doc);\n+        }\n+      }\n+    },\n \n-            if (ngModuleDocs.length === 0) {\n-              errors.push(createDocMessage(`\"@ngModule ${ngModule}\" does not match a public NgModule`, doc));\n-              return;\n-            }\n+    /**\n+     * Associate the `exportDoc` that is expected to have been exported from an `NgModule` with its\n+     * `NgModule` doc.\n+     */\n+    processNgModuleExportDoc(exportDoc, errors) {\n+      const options = exportDoc[`${exportDoc.docType}Options`];\n \n-            if (ngModuleDocs.length > 1) {\n-              errors.push(createDocMessage(`\"@ngModule ${ngModule}\" is ambiguous. Matches: ${ngModuleDocs.map(d => d.id).join(', ')}`, doc));\n-              return;\n-            }\n+      // Directives without a selector are considered abstract and do not need to be part of\n+      // any `@NgModule`.\n+      if (this.skipAbstractDirectives && exportDoc.docType === 'directive' && !options.selector) {\n+        return;\n+      }\n \n-            const ngModuleDoc = ngModuleDocs[0];\n-            const containerName = getContainerName(doc.docType);\n-            const container = ngModuleDoc[containerName] = ngModuleDoc[containerName] || [];\n-            container.push(doc);\n+      if (!exportDoc.ngModules || exportDoc.ngModules.length === 0) {\n+        errors.push(createDocMessage(\n+          `\"${exportDoc.id}\" has no @ngModule tag. Docs of type \"${exportDoc.docType}\" must have this tag.`,\n+          exportDoc));\n+        return;\n+      }\n \n-            doc.ngModules[index] = ngModuleDoc;\n-          });\n+      exportDoc.ngModules.forEach((ngModule, index) => {\n+        const ngModuleDoc = getNgModule(ngModule, exportDoc, errors);\n+        if (ngModuleDoc !== null) {\n+          const containerName = getContainerName(exportDoc.docType);\n+          const container = ngModuleDoc[containerName] = ngModuleDoc[containerName] || [];\n+          container.push(exportDoc);\n+          exportDoc.ngModules[index] = ngModuleDoc;\n         }\n       });\n+    },\n \n-      if (errors.length) {\n-        errors.forEach(error => log.error(error));\n-        throw new Error('Failed to process NgModule relationships.');\n+    /**\n+     * Associate the given `injectableDoc` with an NgModule doc if it is provided on an `NgModule`.\n+     */\n+    processInjectableDoc(injectableDoc, errors) {\n+      const ngModules = [];\n+\n+      if (Array.isArray(injectableDoc.ngModules)) {\n+        for (const ngModule of injectableDoc.ngModules) {\n+          if (isWrappedInQuotes(ngModule)) {\n+            // `ngModule` is wrapped in quotes, so it will be one of `'any'`, `'root'` or `'platform'`\n+            // and is not associated with a specific NgModule. So just use the string.\n+            ngModules.push(ngModule.slice(1, -1));\n+            continue;\n+          }\n+          // Convert any `@ngModule` JSDOC tags to actual NgModule docs.\n+          // Don't add this doc to the NgModule doc, since this should already be in the `providers`\n+          // property of the `@NgModule()` decorator.\n+          const ngModuleDoc = getNgModule(ngModule, injectableDoc, errors);\n+          if (ngModuleDoc !== null) {\n+            ngModules.push(ngModuleDoc);\n+          }\n+        }\n       }\n \n-      docs.forEach(doc => {\n-        if (doc.docType === 'ngmodule') {\n-          Object.keys(doc.ngmoduleOptions).forEach(key => {\n-            const value = doc.ngmoduleOptions[key];\n-            if (value && !Array.isArray(value)) {\n-              doc.ngmoduleOptions[key] = [value];\n-            }\n-          });\n-          this.exportDocTypes.forEach(type => {\n-            const containerName = getContainerName(type);\n-            const container = doc[containerName];\n-            if (container) {\n-              container.sort(byId);\n-            }\n-          });\n+      // Check for `providedIn` property on `@Injectable()`.\n+      for (const decorator of injectableDoc.decorators || []) {\n+        if (decorator.name === 'Injectable' && decorator.argumentInfo[0]) {\n+          const providedIn = decorator.argumentInfo[0].providedIn;\n+          this.processProvidedIn(providedIn, injectableDoc, ngModules, errors);\n         }\n-      });\n+      }\n+\n+      // Check for `providedIn` property on an `ɵprov` static property\n+      if (injectableDoc.symbol?.exports.has('ɵprov')) {\n+        const declaration = injectableDoc.symbol?.exports.get('ɵprov')?.valueDeclaration;\n+        const properties = declaration?.initializer?.arguments?.[0]?.properties;\n+        const providedInProp = properties?.find(prop => prop.name.text === 'providedIn');\n+        const providedInNode = providedInProp?.initializer;\n+        if (providedInNode) {\n+          const providedIn = providedInNode.getSourceFile().text.slice(providedInNode.pos, providedInNode.end).trim();\n+          this.processProvidedIn(providedIn, injectableDoc, ngModules, errors);\n+        }\n+      }\n+\n+      if (ngModules.length > 0) {\n+        injectableDoc.ngModules = ngModules;\n+      }\n+    },\n+\n+    processProvidedIn(providedIn, injectableDoc, ngModules, errors) {\n+      if (typeof providedIn !== 'string') {\n+        // `providedIn` is not a string, which means that this is not a tree-shakable provider\n+        // that needs associating with an NgModule.\n+        return;\n+      }\n+      if (isWrappedInQuotes(providedIn)) {\n+        // `providedIn` is wrapped in quotes, so it will be one of `'root'` or `'platform'` and\n+        // is not associated with a specific NgModule. So just use the string.\n+        ngModules.push(providedIn.slice(1, -1));\n+        return;\n+      }\n+\n+      // `providedIn` ought to reference a public NgModule\n+      const ngModuleDoc = getNgModule(providedIn, injectableDoc, errors);\n+      if (ngModuleDoc === null) {\n+        return;\n+      }\n+\n+      const container = ngModuleDoc.providers = ngModuleDoc.providers || [];\n+      container.push(injectableDoc);\n+      ngModules.push(ngModuleDoc);\n+    },\n+\n+    /**\n+     * Ensure that the arrays containing the docs exported from the `ngModuleDoc` are sorted.\n+     */\n+    sortExportDocContainers(ngModuleDoc) {\n+      for (const type of this.exportDocTypes) {\n+        const container = ngModuleDoc[getContainerName(type)];\n+        if (Array.isArray(container)) {\n+          container.sort(byId);\n+        }\n+      }\n+    },\n+\n+    /**\n+     * Process the providers of the `ngModuleDoc`.\n+     *\n+     * Some providers come from the `@NgModule({providers: ...})` decoration.\n+     * Other providers come from the `@Injectable({providedIn: ...})` decoration.\n+     */\n+    processNgModuleProviders(ngModuleDoc) {\n+      // Add providers from the NgModule decorator.\n+      const providers = ngModuleDoc.ngmoduleOptions.providers || [];\n+      // And also add those associated via the `Injectable` `providedIn` property.\n+      if (Array.isArray(ngModuleDoc.providers)) {\n+        for (const provider of ngModuleDoc.providers) {\n+          providers.push(`{ provide: ${provider.name}, useClass: ${provider.name} }`);\n+        }\n+      }\n+\n+      if (providers.length > 0) {\n+        ngModuleDoc.providers = providers;\n+      }\n     }\n   };\n+\n+  function getNgModule(ngModuleId, doc, errors) {\n+    const ngModuleDocs = getDocFromAlias(ngModuleId, doc);\n+\n+    if (ngModuleDocs.length === 0) {\n+      errors.push(\n+        createDocMessage(`The referenced \"${ngModuleId}\" does not match a public NgModule`, doc));\n+      return null;\n+    }\n+\n+    if (ngModuleDocs.length > 1) {\n+      errors.push(createDocMessage(\n+        `The referenced \"${ngModuleId}\" is ambiguous. Matches: ${ngModuleDocs.map(d => d.id).join(', ')}`,\n+        doc));\n+      return null;\n+    }\n+\n+    return ngModuleDocs[0];\n+  }\n };\n \n+/**\n+ * Compute the name of the array that will hold items of this type in the NgModule document.\n+ */\n function getContainerName(docType) {\n   return docType + 's';\n }\n \n+/**\n+ * Comparison function for sorting docs associated with an NgModule.\n+ *\n+ * This is used to sort docs by their id.\n+ */\n function byId(a, b) {\n   return a.id > b.id ? 1 : -1;\n }\n+\n+/**\n+ * Convert all the values of properties on the `obj` to arrays, if not already.\n+ */\n+function convertAllPropertiesToArrays(obj) {\n+  for (const [key, value] of Object.entries(obj)) {\n+    if (value && !Array.isArray(value)) {\n+      obj[key] = [value];\n+    }\n+  }\n+}\n+\n+/**\n+ * Returns true if the `str` is wrapped in single or double quotes.\n+ */\n+function isWrappedInQuotes(str) {\n+  return /^['\"].+['\"]$/.test(str);\n+}"
        },
        {
            "sha": "4bcefc37d6062e624c33d427f09040a1aa2089fc",
            "filename": "aio/tools/transforms/angular-api-package/processors/processNgModuleDocs.spec.js",
            "status": "modified",
            "additions": 167,
            "deletions": 24,
            "changes": 191,
            "blob_url": "https://github.com/angular/angular/blob/85f5cb45d25daf178eed3ff130fc7608e7ca5e58/aio%2Ftools%2Ftransforms%2Fangular-api-package%2Fprocessors%2FprocessNgModuleDocs.spec.js",
            "raw_url": "https://github.com/angular/angular/raw/85f5cb45d25daf178eed3ff130fc7608e7ca5e58/aio%2Ftools%2Ftransforms%2Fangular-api-package%2Fprocessors%2FprocessNgModuleDocs.spec.js",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Ftools%2Ftransforms%2Fangular-api-package%2Fprocessors%2FprocessNgModuleDocs.spec.js?ref=85f5cb45d25daf178eed3ff130fc7608e7ca5e58",
            "patch": "@@ -22,7 +22,7 @@ describe('processNgModuleDocs processor', () => {\n     expect(processor.$runAfter).toEqual(['extractDecoratedClassesProcessor', 'computeIdsProcessor']);\n   });\n \n-  it('should non-arrayNgModule options to arrays', () => {\n+  it('should convert non-array NgModule options to arrays', () => {\n     const docs = [{\n       docType: 'ngmodule',\n       ngmoduleOptions: {\n@@ -39,15 +39,15 @@ describe('processNgModuleDocs processor', () => {\n \n   it('should link directive/pipe docs with their NgModule docs (sorted by id)', () => {\n     const aliasMap = injector.get('aliasMap');\n-    const directiveOptions = {selector: 'some-selector'};\n-    const ngModule1 = { docType: 'ngmodule', id: 'NgModule1', aliases: ['NgModule1'], ngmoduleOptions: {}};\n-    const ngModule2 = { docType: 'ngmodule', id: 'NgModule2', aliases: ['NgModule2'], ngmoduleOptions: {}};\n-    const directive1 = { docType: 'directive', id: 'Directive1', ngModules: ['NgModule1'], directiveOptions};\n-    const directive2 = { docType: 'directive', id: 'Directive2', ngModules: ['NgModule2'], directiveOptions};\n-    const directive3 = { docType: 'directive', id: 'Directive3', ngModules: ['NgModule1', 'NgModule2'], directiveOptions};\n-    const pipe1 = { docType: 'pipe', id: 'Pipe1', ngModules: ['NgModule1']};\n-    const pipe2 = { docType: 'pipe', id: 'Pipe2', ngModules: ['NgModule2']};\n-    const pipe3 = { docType: 'pipe', id: 'Pipe3', ngModules: ['NgModule1', 'NgModule2']};\n+    const directiveOptions = { selector: 'some-selector' };\n+    const ngModule1 = { docType: 'ngmodule', id: 'NgModule1', aliases: ['NgModule1'], ngmoduleOptions: {} };\n+    const ngModule2 = { docType: 'ngmodule', id: 'NgModule2', aliases: ['NgModule2'], ngmoduleOptions: {} };\n+    const directive1 = { docType: 'directive', id: 'Directive1', ngModules: ['NgModule1'], directiveOptions };\n+    const directive2 = { docType: 'directive', id: 'Directive2', ngModules: ['NgModule2'], directiveOptions };\n+    const directive3 = { docType: 'directive', id: 'Directive3', ngModules: ['NgModule1', 'NgModule2'], directiveOptions };\n+    const pipe1 = { docType: 'pipe', id: 'Pipe1', ngModules: ['NgModule1'] };\n+    const pipe2 = { docType: 'pipe', id: 'Pipe2', ngModules: ['NgModule2'] };\n+    const pipe3 = { docType: 'pipe', id: 'Pipe3', ngModules: ['NgModule1', 'NgModule2'] };\n \n     aliasMap.addDoc(ngModule1);\n     aliasMap.addDoc(ngModule2);\n@@ -67,22 +67,138 @@ describe('processNgModuleDocs processor', () => {\n     expect(pipe3.ngModules).toEqual([ngModule1, ngModule2]);\n   });\n \n-  it('should not error if an abstract directove does not have a `@ngModule` tag', () => {\n+  it('should link classes that have a `providedIn` property on an @Injectable decorator that references a known NgModule doc', () => {\n+    const ngModule1 = { docType: 'ngmodule', id: 'NgModule1', aliases: ['NgModule1'], ngmoduleOptions: {} };\n+    const ngModule2 = { docType: 'ngmodule', id: 'NgModule2', aliases: ['NgModule2'], ngmoduleOptions: {} };\n+    const injectable1 = { docType: 'class', name: 'Injectable1', decorators: [{ name: 'Injectable', argumentInfo: [{ providedIn: '\\'root\\'' }] }] };\n+    const injectable2 = { docType: 'class', name: 'Injectable2', decorators: [{ name: 'Injectable', argumentInfo: [{ providedIn: '\\'platform\\'' }] }] };\n+    const injectable3 = { docType: 'class', name: 'Injectable3', decorators: [{ name: 'Injectable', argumentInfo: [{ providedIn: '\"root\"' }] }] };\n+    const injectable4 = { docType: 'class', name: 'Injectable4', decorators: [{ name: 'Injectable', argumentInfo: [{ providedIn: '\"platform\"' }] }] };\n+    const injectable5 = { docType: 'class', name: 'Injectable5', decorators: [{ name: 'Injectable', argumentInfo: [{ providedIn: 'NgModule1' }] }] };\n+    const injectable6 = { docType: 'class', name: 'Injectable6', decorators: [{ name: 'Injectable', argumentInfo: [{ providedIn: 'NgModule2' }] }] };\n+    const injectable7 = { docType: 'class', name: 'Injectable7' };\n+    const nonInjectable = { docType: 'class', name: 'nonInjectable' };\n+\n+    const aliasMap = injector.get('aliasMap');\n+    aliasMap.addDoc(ngModule1);\n+    aliasMap.addDoc(ngModule2);\n+    processor.$process([ngModule1, ngModule2, injectable1, injectable2, injectable3, injectable4, injectable5, injectable6, injectable7, nonInjectable]);\n+\n+    expect(ngModule1.providers).toEqual(['{ provide: Injectable5, useClass: Injectable5 }']);\n+    expect(ngModule2.providers).toEqual(['{ provide: Injectable6, useClass: Injectable6 }']);\n+\n+    expect(injectable1.ngModules).toEqual(['root']);\n+    expect(injectable2.ngModules).toEqual(['platform']);\n+    expect(injectable3.ngModules).toEqual(['root']);\n+    expect(injectable4.ngModules).toEqual(['platform']);\n+    expect(injectable5.ngModules).toEqual([ngModule1]);\n+    expect(injectable6.ngModules).toEqual([ngModule2]);\n+    expect(injectable7.ngModules).toBeUndefined();\n+    expect(nonInjectable.ngModules).toBeUndefined();\n+  });\n+\n+  it('should link classes that have a `providedIn` property on a ɵprov static that references a known NgModule doc', () => {\n+    const ngModule1 = { docType: 'ngmodule', id: 'NgModule1', aliases: ['NgModule1'], ngmoduleOptions: {} };\n+    const ngModule2 = { docType: 'ngmodule', id: 'NgModule2', aliases: ['NgModule2'], ngmoduleOptions: {} };\n+    const injectable1 = { docType: 'class', name: 'Injectable1', symbol: createSymbolWithProvider('\\'root\\'') };\n+    const injectable2 = { docType: 'class', name: 'Injectable2', symbol: createSymbolWithProvider('\\'platform\\'') };\n+    const injectable3 = { docType: 'class', name: 'Injectable3', symbol: createSymbolWithProvider('\"root\"') };\n+    const injectable4 = { docType: 'class', name: 'Injectable4', symbol: createSymbolWithProvider('\"platform\"') };\n+    const injectable5 = { docType: 'class', name: 'Injectable5', symbol: createSymbolWithProvider('NgModule1') };\n+    const injectable6 = { docType: 'class', name: 'Injectable6', symbol: createSymbolWithProvider('NgModule2') };\n+    const injectable7 = { docType: 'class', name: 'Injectable7' };\n+    const nonInjectable = { docType: 'class', name: 'nonInjectable' };\n+\n+    const aliasMap = injector.get('aliasMap');\n+    aliasMap.addDoc(ngModule1);\n+    aliasMap.addDoc(ngModule2);\n+    processor.$process([ngModule1, ngModule2, injectable1, injectable2, injectable3, injectable4, injectable5, injectable6, injectable7, nonInjectable]);\n+\n+    expect(ngModule1.providers).toEqual(['{ provide: Injectable5, useClass: Injectable5 }']);\n+    expect(ngModule2.providers).toEqual(['{ provide: Injectable6, useClass: Injectable6 }']);\n+\n+    expect(injectable1.ngModules).toEqual(['root']);\n+    expect(injectable2.ngModules).toEqual(['platform']);\n+    expect(injectable3.ngModules).toEqual(['root']);\n+    expect(injectable4.ngModules).toEqual(['platform']);\n+    expect(injectable5.ngModules).toEqual([ngModule1]);\n+    expect(injectable6.ngModules).toEqual([ngModule2]);\n+    expect(injectable7.ngModules).toBeUndefined();\n+    expect(nonInjectable.ngModules).toBeUndefined();\n+  });\n+\n+  it('should link injectables that are marked with `@ngModule` JSDOC tags', () => {\n+    const ngModule1 = { docType: 'ngmodule', id: 'NgModule1', aliases: ['NgModule1'], ngmoduleOptions: {} };\n+    const ngModule2 = { docType: 'ngmodule', id: 'NgModule2', aliases: ['NgModule2'], ngmoduleOptions: { providers: ['PROVIDER'] } };\n+    const injectable1 = { docType: 'class', name: 'Injectable1', ngModules: ['NgModule1'] };\n+    const injectable2 = { docType: 'class', name: 'Injectable2', ngModules: ['NgModule2'] };\n+    const injectable3 = { docType: 'class', name: 'Injectable3' };\n+    const nonInjectable = { docType: 'class', name: 'nonInjectable' };\n+\n+    const aliasMap = injector.get('aliasMap');\n+    aliasMap.addDoc(ngModule1);\n+    aliasMap.addDoc(ngModule2);\n+    processor.$process([ngModule1, ngModule2, injectable1, injectable2, injectable3, nonInjectable]);\n+\n+    // Should not update the NgModule docs in this case.\n+    expect(ngModule1.providers).toBeUndefined();\n+    expect(ngModule2.providers).toEqual(['PROVIDER']);\n+\n+    expect(injectable1.ngModules).toEqual([ngModule1]);\n+    expect(injectable2.ngModules).toEqual([ngModule2]);\n+    expect(injectable3.ngModules).toBeUndefined();\n+    expect(nonInjectable.ngModules).toBeUndefined();\n+  });\n+\n+  it('should error if an injectable that has a `providedIn` property that references an unknown NgModule doc', () => {\n+    const log = injector.get('log');\n+    const injectable = { docType: 'class', name: 'Injectable1', decorators: [{ name: 'Injectable', argumentInfo: [{ providedIn: 'NgModuleRef' }] }] };\n+\n+    expect(() => {\n+      processor.$process([injectable]);\n+    }).toThrowError('Failed to process NgModule relationships.');\n+    expect(log.error).toHaveBeenCalledWith(\n+      'The referenced \"NgModuleRef\" does not match a public NgModule - doc \"Injectable1\" (class) ');\n+  });\n+\n+  it('should error if an injectable that has a `providedIn` property that references an ambiguous NgModule doc', () => {\n+    const log = injector.get('log');\n+\n+    const ngModule1 = { docType: 'ngmodule', id: 'NgModule1', aliases: ['NgModuleRef'], ngmoduleOptions: {} };\n+    const ngModule2 = { docType: 'ngmodule', id: 'NgModule2', aliases: ['NgModuleRef'], ngmoduleOptions: {} };\n+    const injectable = { docType: 'class', name: 'Injectable1', decorators: [{ name: 'Injectable', argumentInfo: [{ providedIn: 'NgModuleRef' }] }] };\n+\n+    const aliasMap = injector.get('aliasMap');\n+    aliasMap.addDoc(ngModule1);\n+    aliasMap.addDoc(ngModule2);\n+\n+    expect(() => {\n+      processor.$process([injectable]);\n+    }).toThrowError('Failed to process NgModule relationships.');\n+    expect(log.error).toHaveBeenCalledWith(\n+      'The referenced \"NgModuleRef\" is ambiguous. Matches: NgModule1, NgModule2 - doc \"Injectable1\" (class) ');\n+  });\n+\n+  it('should not error if an abstract directive does not have a `@ngModule` tag', () => {\n     expect(() => {\n       processor.$process([{ docType: 'directive', id: 'AbstractDir', directiveOptions: {} }]);\n     }).not.toThrow();\n \n     expect(() => {\n-      processor.$process([{ docType: 'directive', id: 'AbstractDir',\n-        directiveOptions: {selector: undefined} }]);\n+      processor.$process([{\n+        docType: 'directive', id: 'AbstractDir',\n+        directiveOptions: { selector: undefined }\n+      }]);\n     }).not.toThrow();\n   });\n \n   it('should error if a pipe/directive does not have a `@ngModule` tag', () => {\n     const log = injector.get('log');\n     expect(() => {\n-      processor.$process([{ docType: 'directive', id: 'Directive1',\n-        directiveOptions: {selector: 'dir1'} }]);\n+      processor.$process([{\n+        docType: 'directive', id: 'Directive1',\n+        directiveOptions: { selector: 'dir1' }\n+      }]);\n     }).toThrowError('Failed to process NgModule relationships.');\n     expect(log.error).toHaveBeenCalledWith(\n       '\"Directive1\" has no @ngModule tag. Docs of type \"directive\" must have this tag. - doc \"Directive1\" (directive) ');\n@@ -97,39 +213,66 @@ describe('processNgModuleDocs processor', () => {\n   it('should error if a pipe/directive has an @ngModule tag that does not match an NgModule doc', () => {\n     const log = injector.get('log');\n     expect(() => {\n-      processor.$process([{ docType: 'directive', id: 'Directive1', ngModules: ['MissingNgModule'],\n-        directiveOptions: {selector: 'dir1'} }]);\n+      processor.$process([{\n+        docType: 'directive', id: 'Directive1', ngModules: ['MissingNgModule'],\n+        directiveOptions: { selector: 'dir1' }\n+      }]);\n     }).toThrowError('Failed to process NgModule relationships.');\n     expect(log.error).toHaveBeenCalledWith(\n-      '\"@ngModule MissingNgModule\" does not match a public NgModule - doc \"Directive1\" (directive) ');\n+      'The referenced \"MissingNgModule\" does not match a public NgModule - doc \"Directive1\" (directive) ');\n \n     expect(() => {\n       processor.$process([{ docType: 'pipe', id: 'Pipe1', ngModules: ['MissingNgModule'] }]);\n     }).toThrowError('Failed to process NgModule relationships.');\n     expect(log.error).toHaveBeenCalledWith(\n-      '\"@ngModule MissingNgModule\" does not match a public NgModule - doc \"Pipe1\" (pipe) ');\n+      'The referenced \"MissingNgModule\" does not match a public NgModule - doc \"Pipe1\" (pipe) ');\n   });\n \n   it('should error if a pipe/directive has an @ngModule tag that matches more than one NgModule doc', () => {\n     const aliasMap = injector.get('aliasMap');\n     const log = injector.get('log');\n-    const ngModule1 = { docType: 'ngmodule', id: 'NgModule1', aliases: ['NgModuleAlias'], ngmoduleOptions: {}};\n-    const ngModule2 = { docType: 'ngmodule', id: 'NgModule2', aliases: ['NgModuleAlias'], ngmoduleOptions: {}};\n+    const ngModule1 = { docType: 'ngmodule', id: 'NgModule1', aliases: ['NgModuleAlias'], ngmoduleOptions: {} };\n+    const ngModule2 = { docType: 'ngmodule', id: 'NgModule2', aliases: ['NgModuleAlias'], ngmoduleOptions: {} };\n     aliasMap.addDoc(ngModule1);\n     aliasMap.addDoc(ngModule2);\n \n     expect(() => {\n       processor.$process([{\n         docType: 'directive', id: 'Directive1', ngModules: ['NgModuleAlias'],\n-        directiveOptions: {selector: 'dir1'} }]);\n+        directiveOptions: { selector: 'dir1' }\n+      }]);\n     }).toThrowError('Failed to process NgModule relationships.');\n     expect(log.error).toHaveBeenCalledWith(\n-      '\"@ngModule NgModuleAlias\" is ambiguous. Matches: NgModule1, NgModule2 - doc \"Directive1\" (directive) ');\n+      'The referenced \"NgModuleAlias\" is ambiguous. Matches: NgModule1, NgModule2 - doc \"Directive1\" (directive) ');\n \n     expect(() => {\n       processor.$process([{ docType: 'pipe', id: 'Pipe1', ngModules: ['NgModuleAlias'] }]);\n     }).toThrowError('Failed to process NgModule relationships.');\n     expect(log.error).toHaveBeenCalledWith(\n-      '\"@ngModule NgModuleAlias\" is ambiguous. Matches: NgModule1, NgModule2 - doc \"Pipe1\" (pipe) ');\n+      'The referenced \"NgModuleAlias\" is ambiguous. Matches: NgModule1, NgModule2 - doc \"Pipe1\" (pipe) ');\n   });\n });\n+\n+/**\n+ * This function simulates a TS AST node for the code:\n+ *\n+ * ```\n+ * static ɵprov = ɵɵdefineInjectable({\n+ *   providedIn: 'xxxx',\n+ * });\n+ * ```\n+ *\n+ */\n+function createSymbolWithProvider(providedIn) {\n+  const initializer = {\n+    pos: 0,\n+    end: providedIn.length,\n+    getSourceFile()  {\n+      return { text: providedIn };\n+    }\n+  };\n+  const valueDeclaration = { initializer: { arguments: [{ properties: [ { name: { text: 'providedIn' }, initializer } ] } ] } };\n+  const exportMap = new Map();\n+  exportMap.set('ɵprov', {valueDeclaration});\n+  return {exports: exportMap};\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "5c22b539790ff323da1f672a288f77747777371b",
            "filename": "aio/tools/transforms/templates/api/class.template.html",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/85f5cb45d25daf178eed3ff130fc7608e7ca5e58/aio%2Ftools%2Ftransforms%2Ftemplates%2Fapi%2Fclass.template.html",
            "raw_url": "https://github.com/angular/angular/raw/85f5cb45d25daf178eed3ff130fc7608e7ca5e58/aio%2Ftools%2Ftransforms%2Ftemplates%2Fapi%2Fclass.template.html",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Ftools%2Ftransforms%2Ftemplates%2Fapi%2Fclass.template.html?ref=85f5cb45d25daf178eed3ff130fc7608e7ca5e58",
            "patch": "@@ -1,9 +1,11 @@\n+{% import \"lib/ngmodule.html\" as ngModuleHelpers -%}\n {% extends 'export-base.template.html' -%}\n \n {% block overview %}\n   {% include \"includes/class-overview.html\" %}\n {% endblock %}\n {% block details %}\n+  {$ ngModuleHelpers.ngModuleList(doc.ngModules, 'Provided in') $}\n   {% include \"includes/description.html\" %}\n   {% include \"includes/class-members.html\" %}\n {% endblock %}"
        },
        {
            "sha": "0d40b440c1ea007a8a648f04f148a22336051d45",
            "filename": "aio/tools/transforms/templates/api/directive.template.html",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/85f5cb45d25daf178eed3ff130fc7608e7ca5e58/aio%2Ftools%2Ftransforms%2Ftemplates%2Fapi%2Fdirective.template.html",
            "raw_url": "https://github.com/angular/angular/raw/85f5cb45d25daf178eed3ff130fc7608e7ca5e58/aio%2Ftools%2Ftransforms%2Ftemplates%2Fapi%2Fdirective.template.html",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Ftools%2Ftransforms%2Ftemplates%2Fapi%2Fdirective.template.html?ref=85f5cb45d25daf178eed3ff130fc7608e7ca5e58",
            "patch": "@@ -1,10 +1,11 @@\n {% import \"lib/memberHelpers.html\" as memberHelpers -%}\n+{% import \"lib/ngmodule.html\" as ngModuleHelpers -%}\n {% extends 'class.template.html' -%}\n \n {% block overview %}{% endblock %}\n \n {% block details -%}\n-  {% include \"includes/ngmodule.html\" %}\n+  {$ ngModuleHelpers.ngModuleList(doc.ngModules, 'Exported from') $}\n   {% include \"includes/selectors.html\" %}\n \n   {$ memberHelpers.renderDirectiveProperties(doc, 'Properties') $}"
        },
        {
            "sha": "fb4674a2b2325aa72baa63b7eeb7d4bcf62b8d46",
            "filename": "aio/tools/transforms/templates/api/includes/ngmodule.html",
            "status": "removed",
            "additions": 0,
            "deletions": 11,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/23f6b76d1a58684af46bb6938f2a2f38617c5ee0/aio%2Ftools%2Ftransforms%2Ftemplates%2Fapi%2Fincludes%2Fngmodule.html",
            "raw_url": "https://github.com/angular/angular/raw/23f6b76d1a58684af46bb6938f2a2f38617c5ee0/aio%2Ftools%2Ftransforms%2Ftemplates%2Fapi%2Fincludes%2Fngmodule.html",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Ftools%2Ftransforms%2Ftemplates%2Fapi%2Fincludes%2Fngmodule.html?ref=23f6b76d1a58684af46bb6938f2a2f38617c5ee0",
            "patch": "@@ -1,11 +0,0 @@\n-{% if doc.ngModules.length == 1 %}<h2>NgModule</h2>{% else %}<h2>NgModules</h2>{% endif %}\n-<ul class=\"ngmodule-list\">\n-{% for ngModule in doc.ngModules %}\n-  <li>\n-    <a href=\"{$ ngModule.path $}\">\n-      <code-example language=\"ts\" hideCopy=\"true\" class=\"no-box\">{$ ngModule.name | escape $}</code-example>\n-    </a>\n-  </li>\n-  {% endfor %}\n-</ul>\n-"
        },
        {
            "sha": "1b82f05cf89c87c73a70e1d62b4103abdd4a6024",
            "filename": "aio/tools/transforms/templates/api/includes/pipe-overview.html",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/85f5cb45d25daf178eed3ff130fc7608e7ca5e58/aio%2Ftools%2Ftransforms%2Ftemplates%2Fapi%2Fincludes%2Fpipe-overview.html",
            "raw_url": "https://github.com/angular/angular/raw/85f5cb45d25daf178eed3ff130fc7608e7ca5e58/aio%2Ftools%2Ftransforms%2Ftemplates%2Fapi%2Fincludes%2Fpipe-overview.html",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Ftools%2Ftransforms%2Ftemplates%2Fapi%2Fincludes%2Fpipe-overview.html?ref=85f5cb45d25daf178eed3ff130fc7608e7ca5e58",
            "patch": "@@ -1,4 +1,5 @@\n {% import \"lib/memberHelpers.html\" as memberHelpers -%}\n+{% import \"lib/ngmodule.html\" as ngModuleHelpers -%}\n {% import \"lib/paramList.html\" as params -%}\n \n <section class=\"{$ doc.docType $}-overview\">\n@@ -10,7 +11,7 @@\n       {%- if param.isOptional or param.defaultValue !== undefined %} ]{% endif %}\n     {%- endfor %} }}</code-example>\n \n-  {% include \"includes/ngmodule.html\" %}\n+  {$ ngModuleHelpers.ngModuleList(doc.ngModules, 'Exported from') $}\n \n   {% if doc.valueParam.type %}\n   <h2>Input value</h2>"
        },
        {
            "sha": "4c65ebc37e3e9be14b3bfa109cff2412dce928ac",
            "filename": "aio/tools/transforms/templates/api/lib/ngmodule.html",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/85f5cb45d25daf178eed3ff130fc7608e7ca5e58/aio%2Ftools%2Ftransforms%2Ftemplates%2Fapi%2Flib%2Fngmodule.html",
            "raw_url": "https://github.com/angular/angular/raw/85f5cb45d25daf178eed3ff130fc7608e7ca5e58/aio%2Ftools%2Ftransforms%2Ftemplates%2Fapi%2Flib%2Fngmodule.html",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Ftools%2Ftransforms%2Ftemplates%2Fapi%2Flib%2Fngmodule.html?ref=85f5cb45d25daf178eed3ff130fc7608e7ca5e58",
            "patch": "@@ -0,0 +1,18 @@\n+{% macro ngModuleList(ngModules, heading) %}\n+{% if ngModules and ngModules.length > 0 %}\n+<h2>{$ heading $}</h2>\n+<ul>\n+{% for ngModule in ngModules %}\n+  <li>\n+    {% if ngModule.path %}\n+    <a href=\"{$ ngModule.path $}\">\n+      <code-example language=\"ts\" hideCopy=\"true\" class=\"no-box\">{$ ngModule.name | escape $}</code-example>\n+    </a>\n+    {% else %}\n+      <code-example language=\"ts\" hideCopy=\"true\" class=\"no-box\">'{$ ngModule | escape $}'</code-example>\n+    {% endif %}\n+  </li>\n+{% endfor %}\n+</ul>\n+{% endif %}\n+{% endmacro %}\n\\ No newline at end of file"
        },
        {
            "sha": "3bb84bbabb1fc3d8d31a6a870614c38f6370cf5d",
            "filename": "aio/tools/transforms/templates/api/ngmodule.template.html",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/85f5cb45d25daf178eed3ff130fc7608e7ca5e58/aio%2Ftools%2Ftransforms%2Ftemplates%2Fapi%2Fngmodule.template.html",
            "raw_url": "https://github.com/angular/angular/raw/85f5cb45d25daf178eed3ff130fc7608e7ca5e58/aio%2Ftools%2Ftransforms%2Ftemplates%2Fapi%2Fngmodule.template.html",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Ftools%2Ftransforms%2Ftemplates%2Fapi%2Fngmodule.template.html?ref=85f5cb45d25daf178eed3ff130fc7608e7ca5e58",
            "patch": "@@ -69,8 +69,8 @@ <h2>Constructor</h2>\n \n   {$ memberHelpers.renderMethodDetails(versionInfo, doc.methods, 'instance-methods', 'instance-method', 'Methods') $}\n \n-  {% if doc.ngmoduleOptions.providers %}\n-  {$ renderTable(doc.ngmoduleOptions.providers, 'providers', 'Providers', 'Provider') $}\n+  {% if doc.providers %}\n+  {$ renderTable(doc.providers, 'providers', 'Providers', 'Provider') $}\n   {% endif %}\n \n   {% if doc.directives.length %}"
        }
    ],
    "stats": {
        "total": 473,
        "additions": 386,
        "deletions": 87
    }
}