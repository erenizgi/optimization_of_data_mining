{
    "author": "zarend",
    "message": "fix(compiler-cli): add support for partially evaluating types (#41661)\n\nAdd support to the partial evaluator for evaluating literal types and\ntuples.\n\nresolves #41338\n\nPR Close #41661",
    "sha": "37a740c6590b7725053f8578d39e53ecba4f5727",
    "files": [
        {
            "sha": "17af7e00f66cf135b0566281e31bb354d50d17a6",
            "filename": "packages/compiler-cli/src/ngtsc/partial_evaluator/src/diagnostics.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/37a740c6590b7725053f8578d39e53ecba4f5727/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Fsrc%2Fdiagnostics.ts",
            "raw_url": "https://github.com/angular/angular/raw/37a740c6590b7725053f8578d39e53ecba4f5727/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Fsrc%2Fdiagnostics.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Fsrc%2Fdiagnostics.ts?ref=37a740c6590b7725053f8578d39e53ecba4f5727",
            "patch": "@@ -127,6 +127,10 @@ class TraceDynamicValueVisitor implements DynamicValueVisitor<ts.DiagnosticRelat\n     return [makeRelatedInformation(value.node, 'Unknown reference.')];\n   }\n \n+  visitDynamicType(value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n+    return [makeRelatedInformation(value.node, 'Dynamic type.')];\n+  }\n+\n   visitUnsupportedSyntax(value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n     return [makeRelatedInformation(value.node, 'This syntax is not supported.')];\n   }"
        },
        {
            "sha": "a9a6c940e2d0df058a14f1e3f85d3613d70eb46f",
            "filename": "packages/compiler-cli/src/ngtsc/partial_evaluator/src/dynamic.ts",
            "status": "modified",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/37a740c6590b7725053f8578d39e53ecba4f5727/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Fsrc%2Fdynamic.ts",
            "raw_url": "https://github.com/angular/angular/raw/37a740c6590b7725053f8578d39e53ecba4f5727/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Fsrc%2Fdynamic.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Fsrc%2Fdynamic.ts?ref=37a740c6590b7725053f8578d39e53ecba4f5727",
            "patch": "@@ -61,6 +61,22 @@ export const enum DynamicValueReason {\n    */\n   COMPLEX_FUNCTION_CALL,\n \n+  /**\n+   * A value that could not be determined because it contains type information that cannot be\n+   * statically evaluated. This happens when producing a value from type information, but the value\n+   * of the given type cannot be determined statically.\n+   *\n+   * E.g. evaluating a tuple.\n+   *\n+   *   `declare const foo: [string];`\n+   *\n+   *  Evaluating `foo` gives a DynamicValue wrapped in an array with a reason of DYNAMIC_TYPE. This\n+   * is because the static evaluator has a `string` type for the first element of this tuple, and\n+   * the value of that string cannot be determined statically. The type `string` permits it to be\n+   * 'foo', 'bar' or any arbitrary string, so we evaluate it to a DynamicValue.\n+   */\n+  DYNAMIC_TYPE,\n+\n   /**\n    * A value could not be determined statically for any reason other the above.\n    */\n@@ -104,6 +120,10 @@ export class DynamicValue<R = unknown> {\n     return new DynamicValue(node, fn, DynamicValueReason.COMPLEX_FUNCTION_CALL);\n   }\n \n+  static fromDynamicType(node: ts.TypeNode): DynamicValue {\n+    return new DynamicValue(node, undefined, DynamicValueReason.DYNAMIC_TYPE);\n+  }\n+\n   static fromUnknown(node: ts.Node): DynamicValue {\n     return new DynamicValue(node, undefined, DynamicValueReason.UNKNOWN);\n   }\n@@ -136,6 +156,10 @@ export class DynamicValue<R = unknown> {\n     return this.code === DynamicValueReason.COMPLEX_FUNCTION_CALL;\n   }\n \n+  isFromDynamicType(this: DynamicValue<R>): this is DynamicValue {\n+    return this.code === DynamicValueReason.DYNAMIC_TYPE;\n+  }\n+\n   isFromUnknown(this: DynamicValue<R>): this is DynamicValue {\n     return this.code === DynamicValueReason.UNKNOWN;\n   }\n@@ -158,6 +182,8 @@ export class DynamicValue<R = unknown> {\n       case DynamicValueReason.COMPLEX_FUNCTION_CALL:\n         return visitor.visitComplexFunctionCall(\n             this as unknown as DynamicValue<FunctionDefinition>);\n+      case DynamicValueReason.DYNAMIC_TYPE:\n+        return visitor.visitDynamicType(this);\n       case DynamicValueReason.UNKNOWN:\n         return visitor.visitUnknown(this);\n     }\n@@ -172,5 +198,6 @@ export interface DynamicValueVisitor<R> {\n   visitUnknownIdentifier(value: DynamicValue): R;\n   visitInvalidExpressionType(value: DynamicValue): R;\n   visitComplexFunctionCall(value: DynamicValue<FunctionDefinition>): R;\n+  visitDynamicType(value: DynamicValue): R;\n   visitUnknown(value: DynamicValue): R;\n }"
        },
        {
            "sha": "44868a6b52fded6441d25fad553cf5e6bf4fef1d",
            "filename": "packages/compiler-cli/src/ngtsc/partial_evaluator/src/interpreter.ts",
            "status": "modified",
            "additions": 39,
            "deletions": 1,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/37a740c6590b7725053f8578d39e53ecba4f5727/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Fsrc%2Finterpreter.ts",
            "raw_url": "https://github.com/angular/angular/raw/37a740c6590b7725053f8578d39e53ecba4f5727/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Fsrc%2Finterpreter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Fsrc%2Finterpreter.ts?ref=37a740c6590b7725053f8578d39e53ecba4f5727",
            "patch": "@@ -276,12 +276,28 @@ export class StaticInterpreter {\n       return this.getReference(node, context);\n     }\n   }\n-\n   private visitVariableDeclaration(node: ts.VariableDeclaration, context: Context): ResolvedValue {\n     const value = this.host.getVariableValue(node);\n     if (value !== null) {\n       return this.visitExpression(value, context);\n     } else if (isVariableDeclarationDeclared(node)) {\n+      // If the declaration has a literal type that can be statically reduced to a value, resolve to\n+      // that value. If not, the historical behavior for variable declarations is to return a\n+      // `Reference` to the variable, as the consumer could use it in a context where knowing its\n+      // static value is not necessary.\n+      //\n+      // Arguably, since the value cannot be statically determined, we should return a\n+      // `DynamicValue`. This returns a `Reference` because it's the same behavior as before\n+      // `visitType` was introduced.\n+      //\n+      // TODO(zarend): investigate switching to a `DynamicValue` and verify this won't break any\n+      // use cases, especially in ngcc\n+      if (node.type !== undefined) {\n+        const evaluatedType = this.visitType(node.type, context);\n+        if (!(evaluatedType instanceof DynamicValue)) {\n+          return evaluatedType;\n+        }\n+      }\n       return this.getReference(node, context);\n     } else {\n       return undefined;\n@@ -681,6 +697,28 @@ export class StaticInterpreter {\n   private getReference<T extends DeclarationNode>(node: T, context: Context): Reference<T> {\n     return new Reference(node, owningModule(context));\n   }\n+\n+  private visitType(node: ts.TypeNode, context: Context): ResolvedValue {\n+    if (ts.isLiteralTypeNode(node)) {\n+      return this.visitExpression(node.literal, context);\n+    } else if (ts.isTupleTypeNode(node)) {\n+      return this.visitTupleType(node, context);\n+    } else if (ts.isNamedTupleMember(node)) {\n+      return this.visitType(node.type, context);\n+    }\n+\n+    return DynamicValue.fromDynamicType(node);\n+  }\n+\n+  private visitTupleType(node: ts.TupleTypeNode, context: Context): ResolvedValueArray {\n+    const res: ResolvedValueArray = [];\n+\n+    for (const elem of node.elements) {\n+      res.push(this.visitType(elem, context));\n+    }\n+\n+    return res;\n+  }\n }\n \n function isFunctionOrMethodReference(ref: Reference<ts.Node>):"
        },
        {
            "sha": "7582aaebcfbc106cc1fac0645935d59ce6e09961",
            "filename": "packages/compiler-cli/src/ngtsc/partial_evaluator/test/evaluator_spec.ts",
            "status": "modified",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/angular/angular/blob/37a740c6590b7725053f8578d39e53ecba4f5727/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Ftest%2Fevaluator_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/37a740c6590b7725053f8578d39e53ecba4f5727/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Ftest%2Fevaluator_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Ftest%2Fevaluator_spec.ts?ref=37a740c6590b7725053f8578d39e53ecba4f5727",
            "patch": "@@ -357,6 +357,30 @@ runInEachFileSystem(() => {\n       expect(value.reason.node.getText()).toEqual('window: any');\n     });\n \n+    it('supports declarations of primitive constant types', () => {\n+      expect(evaluate(`declare const x: 'foo';`, `x`)).toEqual('foo');\n+      expect(evaluate(`declare const x: 42;`, `x`)).toEqual(42);\n+      expect(evaluate(`declare const x: null;`, `x`)).toEqual(null);\n+      expect(evaluate(`declare const x: true;`, `x`)).toEqual(true);\n+    });\n+\n+    it('supports declarations of tuples', () => {\n+      expect(evaluate(`declare const x: ['foo', 42, null, true];`, `x`)).toEqual([\n+        'foo', 42, null, true\n+      ]);\n+      expect(evaluate(`declare const x: ['bar'];`, `[...x]`)).toEqual(['bar']);\n+    });\n+\n+    it('evaluates tuple elements it cannot understand to DynamicValue', () => {\n+      const value = evaluate(`declare const x: ['foo', string];`, `x`) as [string, DynamicValue];\n+\n+      expect(Array.isArray(value)).toBeTrue();\n+      expect(value[0]).toEqual('foo');\n+      expect(value[1] instanceof DynamicValue).toBeTrue();\n+      expect(value[1].isFromDynamicType()).toBe(true);\n+    });\n+\n+\n     it('imports work', () => {\n       const {program} = makeProgram([\n         {name: _('/second.ts'), contents: 'export function foo(bar) { return bar; }'},"
        }
    ],
    "stats": {
        "total": 95,
        "additions": 94,
        "deletions": 1
    }
}