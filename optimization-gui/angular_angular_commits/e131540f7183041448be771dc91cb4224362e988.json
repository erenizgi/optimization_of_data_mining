{
    "author": "gkalpak",
    "message": "fix(service-worker): do not unassign clients from a broken version (#43518)\n\nPreviously, when a version was found to be broken, any clients assigned\nto that version were unassigned (and either assigned to the latest\nversion or to none if the latest version was the broken one). A version\ncould be considered broken for several reasons, but most often it is a\nresponse for a hashed asset that eiher does not exist or contains\ndifferent content than the SW expects. See\nhttps://github.com/angular/angular/issues/28114#issuecomment-923122967\nfor more details.\n\nHowever, assigning a client to a different version (or the network) in\nthe middle of a session, turned out to be more risky than keeping it on\nthe same version. For angular.io, for example, it has led to #28114.\n\nThis commit avoids making things worse when identifying a broken version\nby keeping existing clients to their assigned version (but ensuring that\nno new clients are assigned to the broken version).\n\nNOTE:\nReloading the page generates a new client ID, so it is like a new client\nfor the SW, even if the tab and URL are the same.\n\nPR Close #43518",
    "sha": "e131540f7183041448be771dc91cb4224362e988",
    "files": [
        {
            "sha": "565cd509f40f68ba3663c1c3831f728d9dae3516",
            "filename": "packages/service-worker/worker/src/driver.ts",
            "status": "modified",
            "additions": 20,
            "deletions": 23,
            "changes": 43,
            "blob_url": "https://github.com/angular/angular/blob/e131540f7183041448be771dc91cb4224362e988/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdriver.ts",
            "raw_url": "https://github.com/angular/angular/raw/e131540f7183041448be771dc91cb4224362e988/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdriver.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdriver.ts?ref=e131540f7183041448be771dc91cb4224362e988",
            "patch": "@@ -481,7 +481,8 @@ export class Driver implements Debuggable, UpdateSource {\n             await this.notifyClientsAboutUnrecoverableState(appVersion, err.message);\n           }\n           if (err.isCritical) {\n-            // Something went wrong with the activation of this version.\n+            // Something went wrong with handling the request from this version.\n+            this.debugger.log(err, `Driver.handleFetch(version: ${appVersion.manifestHash})`);\n             await this.versionFailed(appVersion, err);\n             return this.safeFetch(event.request);\n           }\n@@ -800,36 +801,32 @@ export class Driver implements Debuggable, UpdateSource {\n     }\n \n     const brokenHash = broken[0];\n-    const affectedClients = Array.from(this.clientVersionMap.entries())\n-                                .filter(([clientId, hash]) => hash === brokenHash)\n-                                .map(([clientId]) => clientId);\n+\n+    // The specified version is broken and new clients should not be served from it. However, it is\n+    // deemed even riskier to switch the existing clients to a different version or to the network.\n+    // Therefore, we keep clients on their current version (even if broken) and ensure that no new\n+    // clients will be assigned to it.\n \n     // TODO: notify affected apps.\n \n     // The action taken depends on whether the broken manifest is the active (latest) or not.\n-    // If so, the SW cannot accept new clients, but can continue to service old ones.\n+    // - If the broken version is not the latest, no further action is necessary, since new clients\n+    //   will be assigned to the latest version anyway.\n+    // - If the broken version is the latest, the SW cannot accept new clients (but can continue to\n+    //   service old ones).\n     if (this.latestHash === brokenHash) {\n-      // The latest manifest is broken. This means that new clients are at the mercy of the\n-      // network, but caches continue to be valid for previous versions. This is\n-      // unfortunate but unavoidable.\n+      // The latest manifest is broken. This means that new clients are at the mercy of the network,\n+      // but caches continue to be valid for previous versions. This is unfortunate but unavoidable.\n       this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;\n       this.stateMessage = `Degraded due to: ${errorToString(err)}`;\n \n-      // Cancel the binding for the affected clients.\n-      affectedClients.forEach(clientId => this.clientVersionMap.delete(clientId));\n-    } else {\n-      // The latest version is viable, but this older version isn't. The only\n-      // possible remedy is to stop serving the older version and go to the network.\n-      // Put the affected clients on the latest version.\n-      affectedClients.forEach(clientId => this.clientVersionMap.set(clientId, this.latestHash!));\n-    }\n-\n-    try {\n-      await this.sync();\n-    } catch (err2) {\n-      // We are already in a bad state. No need to make things worse.\n-      // Just log the error and move on.\n-      this.debugger.log(err2, `Driver.versionFailed(${err.message || err})`);\n+      try {\n+        await this.sync();\n+      } catch (err2) {\n+        // We are already in a bad state. No need to make things worse.\n+        // Just log the error and move on.\n+        this.debugger.log(err2, `Driver.versionFailed(${err.message || err})`);\n+      }\n     }\n   }\n "
        },
        {
            "sha": "3314bf06ec0809b2e766f8606f5adac7a00db555",
            "filename": "packages/service-worker/worker/test/happy_spec.ts",
            "status": "modified",
            "additions": 59,
            "deletions": 2,
            "changes": 61,
            "blob_url": "https://github.com/angular/angular/blob/e131540f7183041448be771dc91cb4224362e988/packages%2Fservice-worker%2Fworker%2Ftest%2Fhappy_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e131540f7183041448be771dc91cb4224362e988/packages%2Fservice-worker%2Fworker%2Ftest%2Fhappy_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Ftest%2Fhappy_spec.ts?ref=e131540f7183041448be771dc91cb4224362e988",
            "patch": "@@ -2048,16 +2048,73 @@ describe('Driver', () => {\n       brokenLazyServer.assertSawRequestFor('/bar.txt');\n       brokenLazyServer.clearRequests();\n \n-      // `client1` should now be served from the network.\n+      // `client1` should still be served from the latest (broken) version.\n       expect(await makeRequest(scope, '/foo.txt', 'client1')).toBe('this is foo (broken)');\n-      brokenLazyServer.assertSawRequestFor('/foo.txt');\n+      brokenLazyServer.assertNoOtherRequests();\n \n       // `client2` should still be served from the old version (since it never updated).\n       expect(await makeRequest(scope, '/foo.txt', 'client2')).toBe('this is foo');\n       server.assertNoOtherRequests();\n       brokenLazyServer.assertNoOtherRequests();\n+\n+      // New clients should be served from the network.\n+      expect(await makeRequest(scope, '/foo.txt', 'client3')).toBe('this is foo (broken)');\n+      brokenLazyServer.assertSawRequestFor('/foo.txt');\n     });\n \n+    it('enters does not enter degraded mode when something goes wrong with an older version',\n+       async () => {\n+         await driver.initialized;\n+\n+         // Three clients on initial version.\n+         expect(await makeRequest(scope, '/foo.txt', 'client1')).toBe('this is foo');\n+         expect(await makeRequest(scope, '/foo.txt', 'client2')).toBe('this is foo');\n+         expect(await makeRequest(scope, '/foo.txt', 'client3')).toBe('this is foo');\n+\n+         // Install a broken version (`bar.txt` has invalid hash).\n+         scope.updateServerState(brokenLazyServer);\n+         await driver.checkForUpdate();\n+\n+         // Update `client1` and `client2` but not `client3`.\n+         await makeNavigationRequest(scope, '/', 'client1');\n+         await makeNavigationRequest(scope, '/', 'client2');\n+         server.clearRequests();\n+         brokenLazyServer.clearRequests();\n+\n+         expect(await makeRequest(scope, '/foo.txt', 'client1')).toBe('this is foo (broken)');\n+         expect(await makeRequest(scope, '/foo.txt', 'client2')).toBe('this is foo (broken)');\n+         expect(await makeRequest(scope, '/foo.txt', 'client3')).toBe('this is foo');\n+         server.assertNoOtherRequests();\n+         brokenLazyServer.assertNoOtherRequests();\n+\n+         // Install a newer, non-broken version.\n+         scope.updateServerState(serverUpdate);\n+         await driver.checkForUpdate();\n+\n+         // Update `client1` bot not `client2` or `client3`.\n+         await makeNavigationRequest(scope, '/', 'client1');\n+         expect(await makeRequest(scope, '/foo.txt', 'client1')).toBe('this is foo v2');\n+\n+         // Trying to fetch `bar.txt` (which has an invalid hash on the broken version) from\n+         // `client2` should invalidate that particular version (which is not the latest one).\n+         // (NOTE: Since the file is not cached locally, it is fetched from the server.)\n+         expect(await makeRequest(scope, '/bar.txt', 'client2')).toBe('this is bar');\n+         expect(driver.state).toBe(DriverReadyState.NORMAL);\n+         serverUpdate.clearRequests();\n+\n+         // Existing clients should still be served from their assigned versions.\n+         expect(await makeRequest(scope, '/foo.txt', 'client1')).toBe('this is foo v2');\n+         expect(await makeRequest(scope, '/foo.txt', 'client2')).toBe('this is foo (broken)');\n+         expect(await makeRequest(scope, '/foo.txt', 'client3')).toBe('this is foo');\n+         server.assertNoOtherRequests();\n+         brokenLazyServer.assertNoOtherRequests();\n+         serverUpdate.assertNoOtherRequests();\n+\n+         // New clients should be served from the latest version.\n+         expect(await makeRequest(scope, '/foo.txt', 'client4')).toBe('this is foo v2');\n+         serverUpdate.assertNoOtherRequests();\n+       });\n+\n     it('recovers from degraded `EXISTING_CLIENTS_ONLY` mode as soon as there is a valid update',\n        async () => {\n          await driver.initialized;"
        }
    ],
    "stats": {
        "total": 104,
        "additions": 79,
        "deletions": 25
    }
}