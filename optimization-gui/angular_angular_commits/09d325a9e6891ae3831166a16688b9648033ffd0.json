{
    "author": "atscott",
    "message": "test(router): refactor tests to not use deprecated loadChildren (#43578)\n\nMany of the tests in the router code use the deprecated loadChildren as a string. This\nhas been deprecated for years and can easily be changed to just a function that\nreturns the module.\n\nPR Close #43578",
    "sha": "09d325a9e6891ae3831166a16688b9648033ffd0",
    "files": [
        {
            "sha": "8e17162120e4b96acc439e4373f1b50bbead4492",
            "filename": "aio/content/examples/testing/src/app/app.component.router.spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 7,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/09d325a9e6891ae3831166a16688b9648033ffd0/aio%2Fcontent%2Fexamples%2Ftesting%2Fsrc%2Fapp%2Fapp.component.router.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/09d325a9e6891ae3831166a16688b9648033ffd0/aio%2Fcontent%2Fexamples%2Ftesting%2Fsrc%2Fapp%2Fapp.component.router.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fexamples%2Ftesting%2Fsrc%2Fapp%2Fapp.component.router.spec.ts?ref=09d325a9e6891ae3831166a16688b9648033ffd0",
            "patch": "@@ -81,14 +81,10 @@ describe('AppComponent & RouterTestingModule', () => {\n \n \n ///////////////\n-import { NgModuleFactoryLoader } from '@angular/core';\n-import { SpyNgModuleFactoryLoader } from '@angular/router/testing';\n \n import { HeroModule } from './hero/hero.module';  // should be lazy loaded\n import { HeroListComponent } from './hero/hero-list.component';\n \n-let loader: SpyNgModuleFactoryLoader;\n-\n ///////// Can't get lazy loaded Heroes to work yet\n xdescribe('AppComponent & Lazy Loading (not working yet)', () => {\n   beforeEach(waitForAsync(() => {\n@@ -104,9 +100,7 @@ xdescribe('AppComponent & Lazy Loading (not working yet)', () => {\n \n   beforeEach(fakeAsync(() => {\n     createComponent();\n-    loader = TestBed.inject(NgModuleFactoryLoader) as SpyNgModuleFactoryLoader;\n-    loader.stubbedModules = {expected: HeroModule};\n-    router.resetConfig([{path: 'heroes', loadChildren: 'expected'}]);\n+    router.resetConfig([{path: 'heroes', loadChildren: () => HeroModule}]);\n   }));\n \n   it('should navigate to \"Heroes\" on click', waitForAsync(() => {"
        },
        {
            "sha": "f5776ca6c5f830c9c2d1fe5dd7fd6fdbba675859",
            "filename": "packages/router/test/apply_redirects.spec.ts",
            "status": "modified",
            "additions": 74,
            "deletions": 40,
            "changes": 114,
            "blob_url": "https://github.com/angular/angular/blob/09d325a9e6891ae3831166a16688b9648033ffd0/packages%2Frouter%2Ftest%2Fapply_redirects.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/09d325a9e6891ae3831166a16688b9648033ffd0/packages%2Frouter%2Ftest%2Fapply_redirects.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fapply_redirects.spec.ts?ref=09d325a9e6891ae3831166a16688b9648033ffd0",
            "patch": "@@ -199,7 +199,8 @@ describe('applyRedirects', () => {\n           return of(loadedConfig);\n         }\n       };\n-      const config: Routes = [{path: 'a', component: ComponentA, loadChildren: 'children'}];\n+      const config: Routes =\n+          [{path: 'a', component: ComponentA, loadChildren: jasmine.createSpy('children')}];\n \n       applyRedirects(testModule.injector, <any>loader, serializer, tree('a/b'), config)\n           .forEach(r => {\n@@ -212,7 +213,8 @@ describe('applyRedirects', () => {\n       const loader = {\n         load: (p: any) => new Observable<any>((obs: any) => obs.error(new Error('Loading Error')))\n       };\n-      const config = [{path: 'a', component: ComponentA, loadChildren: 'children'}];\n+      const config =\n+          [{path: 'a', component: ComponentA, loadChildren: jasmine.createSpy('children')}];\n \n       applyRedirects(testModule.injector, <any>loader, serializer, tree('a/b'), config)\n           .subscribe(() => {}, (e) => {\n@@ -229,9 +231,12 @@ describe('applyRedirects', () => {\n         get: (token: any) => token === 'guard1' || token === 'guard2' ? guard : {injector}\n       };\n \n-      const config = [\n-        {path: 'a', component: ComponentA, canLoad: ['guard1', 'guard2'], loadChildren: 'children'}\n-      ];\n+      const config = [{\n+        path: 'a',\n+        component: ComponentA,\n+        canLoad: ['guard1', 'guard2'],\n+        loadChildren: jasmine.createSpy('children')\n+      }];\n \n       applyRedirects(<any>injector, <any>loader, serializer, tree('a/b'), config).forEach(r => {\n         expectTreeToBe(r, '/a/b');\n@@ -257,9 +262,12 @@ describe('applyRedirects', () => {\n         }\n       };\n \n-      const config = [\n-        {path: 'a', component: ComponentA, canLoad: ['guard1', 'guard2'], loadChildren: 'children'}\n-      ];\n+      const config = [{\n+        path: 'a',\n+        component: ComponentA,\n+        canLoad: ['guard1', 'guard2'],\n+        loadChildren: jasmine.createSpy('children')\n+      }];\n \n       applyRedirects(<any>injector, <any>loader, serializer, tree('a/b'), config)\n           .subscribe(\n@@ -291,9 +299,12 @@ describe('applyRedirects', () => {\n         }\n       };\n \n-      const config = [\n-        {path: 'a', component: ComponentA, canLoad: ['guard1', 'guard2'], loadChildren: 'children'}\n-      ];\n+      const config = [{\n+        path: 'a',\n+        component: ComponentA,\n+        canLoad: ['guard1', 'guard2'],\n+        loadChildren: jasmine.createSpy('children')\n+      }];\n \n       applyRedirects(<any>injector, <any>loader, serializer, tree('a/b'), config)\n           .subscribe(\n@@ -312,8 +323,12 @@ describe('applyRedirects', () => {\n       const guard = {canLoad: () => Promise.resolve(true)};\n       const injector = {get: (token: any) => token === 'guard' ? guard : {injector}};\n \n-      const config =\n-          [{path: 'a', component: ComponentA, canLoad: ['guard'], loadChildren: 'children'}];\n+      const config = [{\n+        path: 'a',\n+        component: ComponentA,\n+        canLoad: ['guard'],\n+        loadChildren: jasmine.createSpy('children')\n+      }];\n \n       applyRedirects(<any>injector, <any>loader, serializer, tree('a/b'), config)\n           .subscribe(\n@@ -337,8 +352,12 @@ describe('applyRedirects', () => {\n       };\n       const injector = {get: (token: any) => token === 'guard' ? guard : {injector}};\n \n-      const config =\n-          [{path: 'a', component: ComponentA, canLoad: ['guard'], loadChildren: 'children'}];\n+      const config = [{\n+        path: 'a',\n+        component: ComponentA,\n+        canLoad: ['guard'],\n+        loadChildren: jasmine.createSpy('children')\n+      }];\n \n       applyRedirects(<any>injector, <any>loader, serializer, tree('a/b'), config)\n           .subscribe(\n@@ -367,8 +386,12 @@ describe('applyRedirects', () => {\n       };\n       const injector = {get: (token: any) => token === 'guard' ? guard : {injector}};\n \n-      const config =\n-          [{path: 'a', component: ComponentA, canLoad: ['guard'], loadChildren: 'children'}];\n+      const config = [{\n+        path: 'a',\n+        component: ComponentA,\n+        canLoad: ['guard'],\n+        loadChildren: jasmine.createSpy('children')\n+      }];\n \n       applyRedirects(<any>injector, <any>loader, serializer, tree('a/b'), config)\n           .subscribe(\n@@ -388,8 +411,10 @@ describe('applyRedirects', () => {\n \n       const loader = {load: (injector: any, p: any) => of(loadedConfig)};\n \n-      const config: Routes =\n-          [{path: '', pathMatch: 'full', redirectTo: '/a'}, {path: 'a', loadChildren: 'children'}];\n+      const config: Routes = [\n+        {path: '', pathMatch: 'full', redirectTo: '/a'},\n+        {path: 'a', loadChildren: jasmine.createSpy('children')}\n+      ];\n \n       applyRedirects(testModule.injector, <any>loader, serializer, tree(''), config).forEach(r => {\n         expectTreeToBe(r, 'a');\n@@ -409,7 +434,7 @@ describe('applyRedirects', () => {\n         }\n       };\n \n-      const config: Routes = [{path: 'a', loadChildren: 'children'}];\n+      const config: Routes = [{path: 'a', loadChildren: jasmine.createSpy('children')}];\n \n       applyRedirects(testModule.injector, <any>loader, serializer, tree('a?k1'), config)\n           .subscribe(r => {});\n@@ -430,7 +455,7 @@ describe('applyRedirects', () => {\n \n       const loader = {load: (injector: any, p: any) => of(loadedConfig)};\n \n-      const config: Routes = [{path: '**', loadChildren: 'children'}];\n+      const config: Routes = [{path: '**', loadChildren: jasmine.createSpy('children')}];\n \n       applyRedirects(testModule.injector, <any>loader, serializer, tree('xyz'), config)\n           .forEach(r => {\n@@ -445,14 +470,14 @@ describe('applyRedirects', () => {\n       loader.load.and.returnValue(of(loadedConfig).pipe(delay(0)));\n \n       const config: Routes = [\n-        {path: '', loadChildren: 'matchChildren'},\n-        {path: '**', loadChildren: 'children'},\n+        {path: '', loadChildren: jasmine.createSpy('matchChildren')},\n+        {path: '**', loadChildren: jasmine.createSpy('children')},\n       ];\n \n       applyRedirects(testModule.injector, <any>loader, serializer, tree(''), config).forEach(r => {\n         expect(loader.load.calls.count()).toEqual(1);\n         expect(loader.load.calls.first().args).not.toContain(jasmine.objectContaining({\n-          loadChildren: 'children'\n+          loadChildren: jasmine.createSpy('children')\n         }));\n       });\n     });\n@@ -462,8 +487,10 @@ describe('applyRedirects', () => {\n \n       const loader = {load: (injector: any, p: any) => of(loadedConfig)};\n \n-      const config: Routes =\n-          [{path: 'not-found', loadChildren: 'children'}, {path: '**', redirectTo: 'not-found'}];\n+      const config: Routes = [\n+        {path: 'not-found', loadChildren: jasmine.createSpy('children')},\n+        {path: '**', redirectTo: 'not-found'}\n+      ];\n \n       applyRedirects(testModule.injector, <any>loader, serializer, tree('xyz'), config)\n           .forEach(r => {\n@@ -476,8 +503,10 @@ describe('applyRedirects', () => {\n \n       const loader = {load: (injector: any, p: any) => of(loadedConfig)};\n \n-      const config: Routes =\n-          [{path: 'not-found', loadChildren: 'children'}, {path: '**', redirectTo: '/not-found'}];\n+      const config: Routes = [\n+        {path: 'not-found', loadChildren: jasmine.createSpy('children')},\n+        {path: '**', redirectTo: '/not-found'}\n+      ];\n \n       applyRedirects(testModule.injector, <any>loader, serializer, tree('xyz'), config)\n           .forEach(r => {\n@@ -497,13 +526,15 @@ describe('applyRedirects', () => {\n              return of(loadedConfig)\n                  .pipe(\n                      delay(100 * loadCalls),\n-                     tap(() => loaded.push(p.loadChildren! as string)),\n+                     tap(() => loaded.push((p.loadChildren as jasmine.Spy).and.identity)),\n                  );\n            }\n          };\n \n-         const config: Routes =\n-             [{path: '', loadChildren: 'root'}, {path: '', loadChildren: 'aux', outlet: 'popup'}];\n+         const config: Routes = [\n+           {path: '', loadChildren: jasmine.createSpy('root')},\n+           {path: '', loadChildren: jasmine.createSpy('aux'), outlet: 'popup'}\n+         ];\n \n          applyRedirects(testModule.injector, <any>loader, serializer, tree(''), config).subscribe();\n          expect(loadCalls).toBe(1);\n@@ -526,13 +557,13 @@ describe('applyRedirects', () => {\n              return of(loadedConfig)\n                  .pipe(\n                      delay(100 * loadCalls),\n-                     tap(() => loaded.push(p.loadChildren! as string)),\n+                     tap(() => loaded.push((p.loadChildren as jasmine.Spy).and.identity)),\n                  );\n            }\n          };\n \n          const config: Routes = [\n-           {path: '**', loadChildren: 'children'},\n+           {path: '**', loadChildren: jasmine.createSpy('children')},\n          ];\n \n          applyRedirects(testModule.injector, <any>loader, serializer, tree('xyz/a'), config)\n@@ -562,13 +593,15 @@ describe('applyRedirects', () => {\n           loadCalls++;\n           return of(loadedConfig)\n               .pipe(\n-                  tap(() => loaded.push(p.loadChildren! as string)),\n+                  tap(() => loaded.push((p.loadChildren as jasmine.Spy).and.identity)),\n               );\n         }\n       };\n \n-      const config: Routes =\n-          [{path: 'a', loadChildren: 'first'}, {path: 'a', loadChildren: 'second'}];\n+      const config: Routes = [\n+        {path: 'a', loadChildren: jasmine.createSpy('first')},\n+        {path: 'a', loadChildren: jasmine.createSpy('second')}\n+      ];\n \n       applyRedirects(testModule.injector, <any>loader, serializer, tree('a'), config).subscribe();\n       expect(loadCalls).toBe(1);\n@@ -584,19 +617,20 @@ describe('applyRedirects', () => {\n          const auxDelay = 1;\n          const loader = {\n            load: (injector: any, p: Route) => {\n-             const delayMs = p.loadChildren! as string === 'aux' ? auxDelay : rootDelay;\n+             const delayMs =\n+                 (p.loadChildren! as jasmine.Spy).and.identity === 'aux' ? auxDelay : rootDelay;\n              return of(loadedConfig)\n                  .pipe(\n                      delay(delayMs),\n-                     tap(() => loaded.push(p.loadChildren! as string)),\n+                     tap(() => loaded.push((p.loadChildren as jasmine.Spy).and.identity)),\n                  );\n            }\n          };\n \n          const config: Routes = [\n            // Define aux route first so it matches before the primary outlet\n-           {path: 'modal', loadChildren: 'aux', outlet: 'popup'},\n-           {path: '', loadChildren: 'root'},\n+           {path: 'modal', loadChildren: jasmine.createSpy('aux'), outlet: 'popup'},\n+           {path: '', loadChildren: jasmine.createSpy('root')},\n          ];\n \n          applyRedirects(testModule.injector, <any>loader, serializer, tree('(popup:modal)'), config)"
        },
        {
            "sha": "0b63781ee774fcdcc75bdd2cf26fa2f11dcafbde",
            "filename": "packages/router/test/config.spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/09d325a9e6891ae3831166a16688b9648033ffd0/packages%2Frouter%2Ftest%2Fconfig.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/09d325a9e6891ae3831166a16688b9648033ffd0/packages%2Frouter%2Ftest%2Fconfig.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fconfig.spec.ts?ref=09d325a9e6891ae3831166a16688b9648033ffd0",
            "patch": "@@ -76,15 +76,15 @@ describe('config', () => {\n \n     it('should throw when redirectTo and loadChildren are used together', () => {\n       expect(() => {\n-        validateConfig([{path: 'a', redirectTo: 'b', loadChildren: 'value'}]);\n+        validateConfig([{path: 'a', redirectTo: 'b', loadChildren: jasmine.createSpy('value')}]);\n       })\n           .toThrowError(\n               `Invalid configuration of route 'a': redirectTo and loadChildren cannot be used together`);\n     });\n \n     it('should throw when children and loadChildren are used together', () => {\n       expect(() => {\n-        validateConfig([{path: 'a', children: [], loadChildren: 'value'}]);\n+        validateConfig([{path: 'a', children: [], loadChildren: jasmine.createSpy('value')}]);\n       })\n           .toThrowError(\n               `Invalid configuration of route 'a': children and loadChildren cannot be used together`);\n@@ -168,7 +168,7 @@ describe('config', () => {\n         validateConfig([{path: 'a', outlet: 'aux', children: []}]);\n       }).not.toThrow();\n       expect(() => {\n-        validateConfig([{path: 'a', outlet: 'aux', loadChildren: 'child'}]);\n+        validateConfig([{path: 'a', outlet: 'aux', loadChildren: jasmine.createSpy('child')}]);\n       }).not.toThrow();\n     });\n   });"
        },
        {
            "sha": "62455eea7c4d4f196deb026fd58f3c022296c973",
            "filename": "packages/router/test/integration.spec.ts",
            "status": "modified",
            "additions": 700,
            "deletions": 787,
            "changes": 1487,
            "blob_url": "https://github.com/angular/angular/blob/09d325a9e6891ae3831166a16688b9648033ffd0/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/09d325a9e6891ae3831166a16688b9648033ffd0/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fintegration.spec.ts?ref=09d325a9e6891ae3831166a16688b9648033ffd0",
            "patch": "@@ -8,7 +8,7 @@\n \n import {APP_BASE_HREF, CommonModule, HashLocationStrategy, Location, LOCATION_INITIALIZED, LocationStrategy, PlatformLocation} from '@angular/common';\n import {SpyLocation} from '@angular/common/testing';\n-import {ChangeDetectionStrategy, Component, EventEmitter, Injectable, NgModule, NgModuleFactoryLoader, NgModuleRef, NgZone, OnDestroy, ViewChild, ɵConsole as Console, ɵNoopNgZone as NoopNgZone} from '@angular/core';\n+import {ChangeDetectionStrategy, Component, EventEmitter, Injectable, NgModule, NgModuleRef, NgZone, OnDestroy, ViewChild, ɵConsole as Console, ɵNoopNgZone as NoopNgZone} from '@angular/core';\n import {ComponentFixture, fakeAsync, inject, TestBed, tick} from '@angular/core/testing';\n import {By} from '@angular/platform-browser/src/dom/debug/by';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n@@ -19,7 +19,7 @@ import {delay, filter, first, map, mapTo, tap} from 'rxjs/operators';\n import {RouterInitializer} from '../src/router_module';\n import {forEach} from '../src/utils/collection';\n import {isUrlTree} from '../src/utils/type_guards';\n-import {RouterTestingModule, SpyNgModuleFactoryLoader} from '../testing';\n+import {RouterTestingModule} from '../testing';\n \n describe('Integration', () => {\n   const noopConsole: Console = {log() {}, warn() {}};\n@@ -1744,8 +1744,11 @@ describe('Integration', () => {\n        const fixture = createRoot(router, RootCmp);\n \n        router.resetConfig([\n-         {path: 'simple', component: SimpleCmp},\n-         {path: 'throwing', loadChildren: 'doesnotmatter', canLoad: ['returnsFalse']}\n+         {path: 'simple', component: SimpleCmp}, {\n+           path: 'throwing',\n+           loadChildren: jasmine.createSpy('doesnotmatter'),\n+           canLoad: ['returnsFalse']\n+         }\n        ]);\n \n        router.navigateByUrl('/simple');\n@@ -2128,96 +2131,89 @@ describe('Integration', () => {\n        })));\n \n     it('should not navigate when all resolvers for a child route from forChild() returns empty result',\n-       fakeAsync(inject(\n-           [Router, Location, NgModuleFactoryLoader],\n-           (router: Router, location: Location, loader: SpyNgModuleFactoryLoader) => {\n-             const fixture = createRoot(router, RootCmp);\n+       fakeAsync(inject([Router], (router: Router) => {\n+         const fixture = createRoot(router, RootCmp);\n \n-             @Component({selector: 'lazy-cmp', template: 'lazy-loaded-1'})\n-             class LazyComponent1 {\n-             }\n+         @Component({selector: 'lazy-cmp', template: 'lazy-loaded-1'})\n+         class LazyComponent1 {\n+         }\n \n-             router.resetConfig([{path: 'lazy', loadChildren: 'expected1'}]);\n-\n-             @NgModule({\n-               declarations: [LazyComponent1],\n-               imports: [\n-                 RouterModule.forChild([{\n-                   path: 'loaded',\n-                   component: LazyComponent1,\n-                   resolve: {e1: 'resolveEmpty', e2: 'resolveEmpty'}\n-                 }]),\n-               ],\n-             })\n-             class LoadedModule {\n-             }\n \n-             loader.stubbedModules = {expected1: LoadedModule};\n+         @NgModule({\n+           declarations: [LazyComponent1],\n+           imports: [\n+             RouterModule.forChild([{\n+               path: 'loaded',\n+               component: LazyComponent1,\n+               resolve: {e1: 'resolveEmpty', e2: 'resolveEmpty'}\n+             }]),\n+           ],\n+         })\n+         class LoadedModule {\n+         }\n \n-             const recordedEvents: any[] = [];\n-             router.events.subscribe(e => e instanceof RouterEvent && recordedEvents.push(e));\n+         router.resetConfig([{path: 'lazy', loadChildren: () => LoadedModule}]);\n \n-             let e: any = null;\n-             router.navigateByUrl('lazy/loaded').catch(error => e = error);\n-             advance(fixture);\n+         const recordedEvents: any[] = [];\n+         router.events.subscribe(e => e instanceof RouterEvent && recordedEvents.push(e));\n \n-             expectEvents(recordedEvents, [\n-               [NavigationStart, '/lazy/loaded'],\n-               [RoutesRecognized, '/lazy/loaded'],\n-               [GuardsCheckStart, '/lazy/loaded'],\n-               [GuardsCheckEnd, '/lazy/loaded'],\n-               [ResolveStart, '/lazy/loaded'],\n-               [NavigationCancel, '/lazy/loaded'],\n-             ]);\n+         let e: any = null;\n+         router.navigateByUrl('lazy/loaded').catch(error => e = error);\n+         advance(fixture);\n \n-             expect(e).toEqual(null);\n-           })));\n+         expectEvents(recordedEvents, [\n+           [NavigationStart, '/lazy/loaded'],\n+           [RoutesRecognized, '/lazy/loaded'],\n+           [GuardsCheckStart, '/lazy/loaded'],\n+           [GuardsCheckEnd, '/lazy/loaded'],\n+           [ResolveStart, '/lazy/loaded'],\n+           [NavigationCancel, '/lazy/loaded'],\n+         ]);\n+\n+         expect(e).toEqual(null);\n+       })));\n \n     it('should not navigate when at least one resolver for a child route from forChild() returns empty result',\n-       fakeAsync(inject(\n-           [Router, Location, NgModuleFactoryLoader],\n-           (router: Router, location: Location, loader: SpyNgModuleFactoryLoader) => {\n-             const fixture = createRoot(router, RootCmp);\n+       fakeAsync(inject([Router], (router: Router) => {\n+         const fixture = createRoot(router, RootCmp);\n \n-             @Component({selector: 'lazy-cmp', template: 'lazy-loaded-1'})\n-             class LazyComponent1 {\n-             }\n+         @Component({selector: 'lazy-cmp', template: 'lazy-loaded-1'})\n+         class LazyComponent1 {\n+         }\n \n-             router.resetConfig([{path: 'lazy', loadChildren: 'expected1'}]);\n-\n-             @NgModule({\n-               declarations: [LazyComponent1],\n-               imports: [\n-                 RouterModule.forChild([{\n-                   path: 'loaded',\n-                   component: LazyComponent1,\n-                   resolve: {e1: 'resolveTwo', e2: 'resolveEmpty'}\n-                 }]),\n-               ],\n-             })\n-             class LoadedModule {\n-             }\n+         @NgModule({\n+           declarations: [LazyComponent1],\n+           imports: [\n+             RouterModule.forChild([{\n+               path: 'loaded',\n+               component: LazyComponent1,\n+               resolve: {e1: 'resolveTwo', e2: 'resolveEmpty'}\n+             }]),\n+           ],\n+         })\n+         class LoadedModule {\n+         }\n \n-             loader.stubbedModules = {expected1: LoadedModule};\n+         router.resetConfig([{path: 'lazy', loadChildren: () => LoadedModule}]);\n \n-             const recordedEvents: any[] = [];\n-             router.events.subscribe(e => e instanceof RouterEvent && recordedEvents.push(e));\n+         const recordedEvents: any[] = [];\n+         router.events.subscribe(e => e instanceof RouterEvent && recordedEvents.push(e));\n \n-             let e: any = null;\n-             router.navigateByUrl('lazy/loaded').catch(error => e = error);\n-             advance(fixture);\n+         let e: any = null;\n+         router.navigateByUrl('lazy/loaded').catch(error => e = error);\n+         advance(fixture);\n \n-             expectEvents(recordedEvents, [\n-               [NavigationStart, '/lazy/loaded'],\n-               [RoutesRecognized, '/lazy/loaded'],\n-               [GuardsCheckStart, '/lazy/loaded'],\n-               [GuardsCheckEnd, '/lazy/loaded'],\n-               [ResolveStart, '/lazy/loaded'],\n-               [NavigationCancel, '/lazy/loaded'],\n-             ]);\n+         expectEvents(recordedEvents, [\n+           [NavigationStart, '/lazy/loaded'],\n+           [RoutesRecognized, '/lazy/loaded'],\n+           [GuardsCheckStart, '/lazy/loaded'],\n+           [GuardsCheckEnd, '/lazy/loaded'],\n+           [ResolveStart, '/lazy/loaded'],\n+           [NavigationCancel, '/lazy/loaded'],\n+         ]);\n \n-             expect(e).toEqual(null);\n-           })));\n+         expect(e).toEqual(null);\n+       })));\n \n     it('should preserve resolved data', fakeAsync(inject([Router], (router: Router) => {\n          const fixture = createRoot(router, RootCmp);\n@@ -3707,45 +3703,42 @@ describe('Integration', () => {\n       });\n \n       it('should use correct component to deactivate forChild route',\n-         fakeAsync(inject(\n-             [Router, Location, NgModuleFactoryLoader],\n-             (router: Router, location: Location, loader: SpyNgModuleFactoryLoader) => {\n-               @Component({selector: 'admin', template: ''})\n-               class AdminComponent {\n-               }\n-\n-               @NgModule({\n-                 declarations: [AdminComponent],\n-                 imports: [RouterModule.forChild([{\n-                   path: '',\n-                   component: AdminComponent,\n-                   canDeactivate: ['RecordingDeactivate'],\n-                 }])],\n-               })\n-               class LazyLoadedModule {\n-               }\n+         fakeAsync(inject([Router], (router: Router) => {\n+           @Component({selector: 'admin', template: ''})\n+           class AdminComponent {\n+           }\n \n-               loader.stubbedModules = {lazy: LazyLoadedModule};\n-               const fixture = createRoot(router, RootCmp);\n+           @NgModule({\n+             declarations: [AdminComponent],\n+             imports: [RouterModule.forChild([{\n+               path: '',\n+               component: AdminComponent,\n+               canDeactivate: ['RecordingDeactivate'],\n+             }])],\n+           })\n+           class LazyLoadedModule {\n+           }\n \n-               router.resetConfig([\n-                 {\n-                   path: 'a',\n-                   component: WrapperCmp,\n-                   children: [\n-                     {path: '', pathMatch: 'full', loadChildren: 'lazy'},\n-                   ]\n-                 },\n-                 {path: 'b', component: SimpleCmp},\n-               ]);\n+           const fixture = createRoot(router, RootCmp);\n \n-               router.navigateByUrl('/a');\n-               advance(fixture);\n-               router.navigateByUrl('/b');\n-               advance(fixture);\n+           router.resetConfig([\n+             {\n+               path: 'a',\n+               component: WrapperCmp,\n+               children: [\n+                 {path: '', pathMatch: 'full', loadChildren: () => LazyLoadedModule},\n+               ]\n+             },\n+             {path: 'b', component: SimpleCmp},\n+           ]);\n \n-               expect(log[0].component).toBeAnInstanceOf(AdminComponent);\n-             })));\n+           router.navigateByUrl('/a');\n+           advance(fixture);\n+           router.navigateByUrl('/b');\n+           advance(fixture);\n+\n+           expect(log[0].component).toBeAnInstanceOf(AdminComponent);\n+         })));\n \n       it('should not create a route state if navigation is canceled',\n          fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n@@ -3985,44 +3978,41 @@ describe('Integration', () => {\n       });\n \n       it('should find the guard provided in lazy loaded module',\n-         fakeAsync(inject(\n-             [Router, Location, NgModuleFactoryLoader],\n-             (router: Router, location: Location, loader: SpyNgModuleFactoryLoader) => {\n-               @Component({selector: 'admin', template: '<router-outlet></router-outlet>'})\n-               class AdminComponent {\n-               }\n-\n-               @Component({selector: 'lazy', template: 'lazy-loaded'})\n-               class LazyLoadedComponent {\n-               }\n-\n-               @NgModule({\n-                 declarations: [AdminComponent, LazyLoadedComponent],\n-                 imports: [RouterModule.forChild([{\n-                   path: '',\n-                   component: AdminComponent,\n-                   children: [{\n-                     path: '',\n-                     canActivateChild: ['alwaysTrue'],\n-                     children: [{path: '', component: LazyLoadedComponent}]\n-                   }]\n-                 }])],\n-                 providers: [{provide: 'alwaysTrue', useValue: () => true}],\n-               })\n-               class LazyLoadedModule {\n-               }\n+         fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+           @Component({selector: 'admin', template: '<router-outlet></router-outlet>'})\n+           class AdminComponent {\n+           }\n \n-               loader.stubbedModules = {lazy: LazyLoadedModule};\n-               const fixture = createRoot(router, RootCmp);\n+           @Component({selector: 'lazy', template: 'lazy-loaded'})\n+           class LazyLoadedComponent {\n+           }\n+\n+           @NgModule({\n+             declarations: [AdminComponent, LazyLoadedComponent],\n+             imports: [RouterModule.forChild([{\n+               path: '',\n+               component: AdminComponent,\n+               children: [{\n+                 path: '',\n+                 canActivateChild: ['alwaysTrue'],\n+                 children: [{path: '', component: LazyLoadedComponent}]\n+               }]\n+             }])],\n+             providers: [{provide: 'alwaysTrue', useValue: () => true}],\n+           })\n+           class LazyLoadedModule {\n+           }\n \n-               router.resetConfig([{path: 'admin', loadChildren: 'lazy'}]);\n+           const fixture = createRoot(router, RootCmp);\n \n-               router.navigateByUrl('/admin');\n-               advance(fixture);\n+           router.resetConfig([{path: 'admin', loadChildren: () => LazyLoadedModule}]);\n \n-               expect(location.path()).toEqual('/admin');\n-               expect(fixture.nativeElement).toHaveText('lazy-loaded');\n-             })));\n+           router.navigateByUrl('/admin');\n+           advance(fixture);\n+\n+           expect(location.path()).toEqual('/admin');\n+           expect(fixture.nativeElement).toHaveText('lazy-loaded');\n+         })));\n     });\n \n     describe('CanLoad', () => {\n@@ -4059,80 +4049,80 @@ describe('Integration', () => {\n       });\n \n       it('should not load children when CanLoad returns false',\n-         fakeAsync(inject(\n-             [Router, Location, NgModuleFactoryLoader],\n-             (router: Router, location: Location, loader: SpyNgModuleFactoryLoader) => {\n-               @Component({selector: 'lazy', template: 'lazy-loaded'})\n-               class LazyLoadedComponent {\n-               }\n-\n-               @NgModule({\n-                 declarations: [LazyLoadedComponent],\n-                 imports:\n-                     [RouterModule.forChild([{path: 'loaded', component: LazyLoadedComponent}])]\n-               })\n-               class LoadedModule {\n-               }\n-\n-               loader.stubbedModules = {lazyFalse: LoadedModule, lazyTrue: LoadedModule};\n-               const fixture = createRoot(router, RootCmp);\n+         fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+           @Component({selector: 'lazy', template: 'lazy-loaded'})\n+           class LazyLoadedComponent {\n+           }\n \n-               router.resetConfig([\n-                 {path: 'lazyFalse', canLoad: ['alwaysFalse'], loadChildren: 'lazyFalse'},\n-                 {path: 'lazyTrue', canLoad: ['alwaysTrue'], loadChildren: 'lazyTrue'}\n-               ]);\n+           @NgModule({\n+             declarations: [LazyLoadedComponent],\n+             imports: [RouterModule.forChild([{path: 'loaded', component: LazyLoadedComponent}])]\n+           })\n+           class LoadedModule {\n+           }\n \n-               const recordedEvents: any[] = [];\n-               router.events.forEach(e => recordedEvents.push(e));\n+           const fixture = createRoot(router, RootCmp);\n \n+           router.resetConfig([\n+             {path: 'lazyFalse', canLoad: ['alwaysFalse'], loadChildren: () => LoadedModule},\n+             {path: 'lazyTrue', canLoad: ['alwaysTrue'], loadChildren: () => LoadedModule}\n+           ]);\n \n-               // failed navigation\n-               router.navigateByUrl('/lazyFalse/loaded');\n-               advance(fixture);\n+           const recordedEvents: any[] = [];\n+           router.events.forEach(e => recordedEvents.push(e));\n \n-               expect(location.path()).toEqual('/');\n \n-               expectEvents(recordedEvents, [\n-                 [NavigationStart, '/lazyFalse/loaded'],\n-                 //  [GuardsCheckStart, '/lazyFalse/loaded'],\n-                 [NavigationCancel, '/lazyFalse/loaded'],\n-               ]);\n+           // failed navigation\n+           router.navigateByUrl('/lazyFalse/loaded');\n+           advance(fixture);\n \n-               recordedEvents.splice(0);\n+           expect(location.path()).toEqual('/');\n \n-               // successful navigation\n-               router.navigateByUrl('/lazyTrue/loaded');\n-               advance(fixture);\n+           expectEvents(recordedEvents, [\n+             [NavigationStart, '/lazyFalse/loaded'],\n+             //  [GuardsCheckStart, '/lazyFalse/loaded'],\n+             [NavigationCancel, '/lazyFalse/loaded'],\n+           ]);\n \n-               expect(location.path()).toEqual('/lazyTrue/loaded');\n-\n-               expectEvents(recordedEvents, [\n-                 [NavigationStart, '/lazyTrue/loaded'],\n-                 [RouteConfigLoadStart],\n-                 [RouteConfigLoadEnd],\n-                 [RoutesRecognized, '/lazyTrue/loaded'],\n-                 [GuardsCheckStart, '/lazyTrue/loaded'],\n-                 [ChildActivationStart],\n-                 [ActivationStart],\n-                 [ChildActivationStart],\n-                 [ActivationStart],\n-                 [GuardsCheckEnd, '/lazyTrue/loaded'],\n-                 [ResolveStart, '/lazyTrue/loaded'],\n-                 [ResolveEnd, '/lazyTrue/loaded'],\n-                 [ActivationEnd],\n-                 [ChildActivationEnd],\n-                 [ActivationEnd],\n-                 [ChildActivationEnd],\n-                 [NavigationEnd, '/lazyTrue/loaded'],\n-               ]);\n-             })));\n+           recordedEvents.splice(0);\n+\n+           // successful navigation\n+           router.navigateByUrl('/lazyTrue/loaded');\n+           advance(fixture);\n+\n+           expect(location.path()).toEqual('/lazyTrue/loaded');\n+\n+           expectEvents(recordedEvents, [\n+             [NavigationStart, '/lazyTrue/loaded'],\n+             [RouteConfigLoadStart],\n+             [RouteConfigLoadEnd],\n+             [RoutesRecognized, '/lazyTrue/loaded'],\n+             [GuardsCheckStart, '/lazyTrue/loaded'],\n+             [ChildActivationStart],\n+             [ActivationStart],\n+             [ChildActivationStart],\n+             [ActivationStart],\n+             [GuardsCheckEnd, '/lazyTrue/loaded'],\n+             [ResolveStart, '/lazyTrue/loaded'],\n+             [ResolveEnd, '/lazyTrue/loaded'],\n+             [ActivationEnd],\n+             [ChildActivationEnd],\n+             [ActivationEnd],\n+             [ChildActivationEnd],\n+             [NavigationEnd, '/lazyTrue/loaded'],\n+           ]);\n+         })));\n \n       it('should support navigating from within the guard',\n          fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n            const fixture = createRoot(router, RootCmp);\n \n            router.resetConfig([\n-             {path: 'lazyFalse', canLoad: ['returnFalseAndNavigate'], loadChildren: 'lazyFalse'},\n+             {\n+               path: 'lazyFalse',\n+               canLoad: ['returnFalseAndNavigate'],\n+               loadChildren: jasmine.createSpy('lazyFalse')\n+             },\n              {path: 'blank', component: BlankCmp}\n            ]);\n \n@@ -4163,7 +4153,11 @@ describe('Integration', () => {\n            const fixture = createRoot(router, RootCmp);\n \n            router.resetConfig([\n-             {path: 'lazyFalse', canLoad: ['returnUrlTree'], loadChildren: 'lazyFalse'},\n+             {\n+               path: 'lazyFalse',\n+               canLoad: ['returnUrlTree'],\n+               loadChildren: jasmine.createSpy('lazyFalse')\n+             },\n              {path: 'blank', component: BlankCmp}\n            ]);\n \n@@ -4192,79 +4186,72 @@ describe('Integration', () => {\n       // Regression where navigateByUrl with false CanLoad no longer resolved `false` value on\n       // navigateByUrl promise: https://github.com/angular/angular/issues/26284\n       it('should resolve navigateByUrl promise after CanLoad executes',\n-         fakeAsync(inject(\n-             [Router, Location, NgModuleFactoryLoader],\n-             (router: Router, location: Location, loader: SpyNgModuleFactoryLoader) => {\n-               @Component({selector: 'lazy', template: 'lazy-loaded'})\n-               class LazyLoadedComponent {\n-               }\n-\n-               @NgModule({\n-                 declarations: [LazyLoadedComponent],\n-                 imports:\n-                     [RouterModule.forChild([{path: 'loaded', component: LazyLoadedComponent}])]\n-               })\n-               class LazyLoadedModule {\n-               }\n-\n-               loader.stubbedModules = {lazy: LazyLoadedModule};\n-               const fixture = createRoot(router, RootCmp);\n+         fakeAsync(inject([Router], (router: Router) => {\n+           @Component({selector: 'lazy', template: 'lazy-loaded'})\n+           class LazyLoadedComponent {\n+           }\n \n-               router.resetConfig([\n-                 {path: 'lazy-false', canLoad: ['alwaysFalse'], loadChildren: 'lazy'},\n-                 {path: 'lazy-true', canLoad: ['alwaysTrue'], loadChildren: 'lazy'},\n-               ]);\n+           @NgModule({\n+             declarations: [LazyLoadedComponent],\n+             imports: [RouterModule.forChild([{path: 'loaded', component: LazyLoadedComponent}])]\n+           })\n+           class LazyLoadedModule {\n+           }\n \n-               let navFalseResult: any;\n-               let navTrueResult: any;\n-               router.navigateByUrl('/lazy-false').then(v => {\n-                 navFalseResult = v;\n-               });\n-               advance(fixture);\n-               router.navigateByUrl('/lazy-true').then(v => {\n-                 navTrueResult = v;\n-               });\n-               advance(fixture);\n+           const fixture = createRoot(router, RootCmp);\n \n-               expect(navFalseResult).toBe(false);\n-               expect(navTrueResult).toBe(true);\n-             })));\n+           router.resetConfig([\n+             {path: 'lazy-false', canLoad: ['alwaysFalse'], loadChildren: () => LazyLoadedModule},\n+             {path: 'lazy-true', canLoad: ['alwaysTrue'], loadChildren: () => LazyLoadedModule},\n+           ]);\n+\n+           let navFalseResult: any;\n+           let navTrueResult: any;\n+           router.navigateByUrl('/lazy-false').then(v => {\n+             navFalseResult = v;\n+           });\n+           advance(fixture);\n+           router.navigateByUrl('/lazy-true').then(v => {\n+             navTrueResult = v;\n+           });\n+           advance(fixture);\n+\n+           expect(navFalseResult).toBe(false);\n+           expect(navTrueResult).toBe(true);\n+         })));\n \n       it('should execute CanLoad only once',\n-         fakeAsync(inject(\n-             [Router, Location, NgModuleFactoryLoader],\n-             (router: Router, location: Location, loader: SpyNgModuleFactoryLoader) => {\n-               @Component({selector: 'lazy', template: 'lazy-loaded'})\n-               class LazyLoadedComponent {\n-               }\n-\n-               @NgModule({\n-                 declarations: [LazyLoadedComponent],\n-                 imports:\n-                     [RouterModule.forChild([{path: 'loaded', component: LazyLoadedComponent}])]\n-               })\n-               class LazyLoadedModule {\n-               }\n-\n-               loader.stubbedModules = {lazy: LazyLoadedModule};\n-               const fixture = createRoot(router, RootCmp);\n+         fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+           @Component({selector: 'lazy', template: 'lazy-loaded'})\n+           class LazyLoadedComponent {\n+           }\n+\n+           @NgModule({\n+             declarations: [LazyLoadedComponent],\n+             imports: [RouterModule.forChild([{path: 'loaded', component: LazyLoadedComponent}])]\n+           })\n+           class LazyLoadedModule {\n+           }\n \n-               router.resetConfig([{path: 'lazy', canLoad: ['alwaysTrue'], loadChildren: 'lazy'}]);\n+           const fixture = createRoot(router, RootCmp);\n \n-               router.navigateByUrl('/lazy/loaded');\n-               advance(fixture);\n-               expect(location.path()).toEqual('/lazy/loaded');\n-               expect(canLoadRunCount).toEqual(1);\n+           router.resetConfig(\n+               [{path: 'lazy', canLoad: ['alwaysTrue'], loadChildren: () => LazyLoadedModule}]);\n \n-               router.navigateByUrl('/');\n-               advance(fixture);\n-               expect(location.path()).toEqual('/');\n+           router.navigateByUrl('/lazy/loaded');\n+           advance(fixture);\n+           expect(location.path()).toEqual('/lazy/loaded');\n+           expect(canLoadRunCount).toEqual(1);\n \n-               router.navigateByUrl('/lazy/loaded');\n-               advance(fixture);\n-               expect(location.path()).toEqual('/lazy/loaded');\n-               expect(canLoadRunCount).toEqual(1);\n-             })));\n+           router.navigateByUrl('/');\n+           advance(fixture);\n+           expect(location.path()).toEqual('/');\n+\n+           router.navigateByUrl('/lazy/loaded');\n+           advance(fixture);\n+           expect(location.path()).toEqual('/lazy/loaded');\n+           expect(canLoadRunCount).toEqual(1);\n+         })));\n     });\n \n     describe('should run CanLoad guards concurrently', () => {\n@@ -4339,63 +4326,50 @@ describe('Integration', () => {\n            expect(log).toEqual(['guard1']);\n          }));\n \n-      it('should execute canLoad guards',\n-         fakeAsync(inject(\n-             [Router, NgModuleFactoryLoader],\n-             (router: Router, loader: SpyNgModuleFactoryLoader) => {\n-               loader.stubbedModules = {expected: LoadedModule};\n-\n-               router.resetConfig(\n-                   [{path: 'lazy', canLoad: ['guard1', 'guard2'], loadChildren: 'expected'}]);\n+      it('should execute canLoad guards', fakeAsync(inject([Router], (router: Router) => {\n+           router.resetConfig(\n+               [{path: 'lazy', canLoad: ['guard1', 'guard2'], loadChildren: () => LoadedModule}]);\n \n-               router.navigateByUrl('/lazy');\n-               tick(5);\n+           router.navigateByUrl('/lazy');\n+           tick(5);\n \n-               expect(log.length).toEqual(2);\n-               expect(log).toEqual(['guard2', 'guard1']);\n-             })));\n+           expect(log.length).toEqual(2);\n+           expect(log).toEqual(['guard2', 'guard1']);\n+         })));\n \n       it('should redirect with UrlTree if higher priority guards have resolved',\n-         fakeAsync(inject(\n-             [Router, NgModuleFactoryLoader, Location],\n-             (router: Router, loader: SpyNgModuleFactoryLoader, location: Location) => {\n-               loader.stubbedModules = {expected: LoadedModule};\n-\n-               router.resetConfig([\n-                 {\n-                   path: 'lazy',\n-                   canLoad: ['returnUrlTree', 'guard1', 'guard2'],\n-                   loadChildren: 'expected'\n-                 },\n-                 {path: 'redirected', component: SimpleCmp}\n-               ]);\n+         fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+           router.resetConfig([\n+             {\n+               path: 'lazy',\n+               canLoad: ['returnUrlTree', 'guard1', 'guard2'],\n+               loadChildren: () => LoadedModule\n+             },\n+             {path: 'redirected', component: SimpleCmp}\n+           ]);\n \n-               router.navigateByUrl('/lazy');\n-               tick(15);\n+           router.navigateByUrl('/lazy');\n+           tick(15);\n \n-               expect(log.length).toEqual(3);\n-               expect(log).toEqual(['guard2', 'guard1', 'returnUrlTree']);\n-               expect(location.path()).toEqual('/redirected');\n-             })));\n+           expect(log.length).toEqual(3);\n+           expect(log).toEqual(['guard2', 'guard1', 'returnUrlTree']);\n+           expect(location.path()).toEqual('/redirected');\n+         })));\n \n       it('should redirect with UrlTree if UrlTree is lower priority',\n-         fakeAsync(inject(\n-             [Router, NgModuleFactoryLoader, Location],\n-             (router: Router, loader: SpyNgModuleFactoryLoader, location: Location) => {\n-               loader.stubbedModules = {expected: LoadedModule};\n-\n-               router.resetConfig([\n-                 {path: 'lazy', canLoad: ['guard1', 'returnUrlTree'], loadChildren: 'expected'},\n-                 {path: 'redirected', component: SimpleCmp}\n-               ]);\n+         fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+           router.resetConfig([\n+             {path: 'lazy', canLoad: ['guard1', 'returnUrlTree'], loadChildren: () => LoadedModule},\n+             {path: 'redirected', component: SimpleCmp}\n+           ]);\n \n-               router.navigateByUrl('/lazy');\n-               tick(15);\n+           router.navigateByUrl('/lazy');\n+           tick(15);\n \n-               expect(log.length).toEqual(2);\n-               expect(log).toEqual(['guard1', 'returnUrlTree']);\n-               expect(location.path()).toEqual('/redirected');\n-             })));\n+           expect(log.length).toEqual(2);\n+           expect(log).toEqual(['guard1', 'returnUrlTree']);\n+           expect(location.path()).toEqual('/redirected');\n+         })));\n     });\n \n     describe('order', () => {\n@@ -4811,412 +4785,374 @@ describe('Integration', () => {\n   });\n \n   describe('lazy loading', () => {\n-    it('works',\n-       fakeAsync(inject(\n-           [Router, Location, NgModuleFactoryLoader],\n-           (router: Router, location: Location, loader: SpyNgModuleFactoryLoader) => {\n-             @Component({\n-               selector: 'lazy',\n-               template: 'lazy-loaded-parent [<router-outlet></router-outlet>]'\n-             })\n-             class ParentLazyLoadedComponent {\n-             }\n-\n-             @Component({selector: 'lazy', template: 'lazy-loaded-child'})\n-             class ChildLazyLoadedComponent {\n-             }\n-\n-             @NgModule({\n-               declarations: [ParentLazyLoadedComponent, ChildLazyLoadedComponent],\n-               imports: [RouterModule.forChild([{\n-                 path: 'loaded',\n-                 component: ParentLazyLoadedComponent,\n-                 children: [{path: 'child', component: ChildLazyLoadedComponent}]\n-               }])]\n-             })\n-             class LoadedModule {\n-             }\n+    it('works', fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+         @Component(\n+             {selector: 'lazy', template: 'lazy-loaded-parent [<router-outlet></router-outlet>]'})\n+         class ParentLazyLoadedComponent {\n+         }\n \n+         @Component({selector: 'lazy', template: 'lazy-loaded-child'})\n+         class ChildLazyLoadedComponent {\n+         }\n \n-             loader.stubbedModules = {expected: LoadedModule};\n+         @NgModule({\n+           declarations: [ParentLazyLoadedComponent, ChildLazyLoadedComponent],\n+           imports: [RouterModule.forChild([{\n+             path: 'loaded',\n+             component: ParentLazyLoadedComponent,\n+             children: [{path: 'child', component: ChildLazyLoadedComponent}]\n+           }])]\n+         })\n+         class LoadedModule {\n+         }\n \n-             const fixture = createRoot(router, RootCmp);\n+         const fixture = createRoot(router, RootCmp);\n \n-             router.resetConfig([{path: 'lazy', loadChildren: 'expected'}]);\n+         router.resetConfig([{path: 'lazy', loadChildren: () => LoadedModule}]);\n \n-             router.navigateByUrl('/lazy/loaded/child');\n-             advance(fixture);\n+         router.navigateByUrl('/lazy/loaded/child');\n+         advance(fixture);\n \n-             expect(location.path()).toEqual('/lazy/loaded/child');\n-             expect(fixture.nativeElement).toHaveText('lazy-loaded-parent [lazy-loaded-child]');\n-           })));\n+         expect(location.path()).toEqual('/lazy/loaded/child');\n+         expect(fixture.nativeElement).toHaveText('lazy-loaded-parent [lazy-loaded-child]');\n+       })));\n \n     it('should have 2 injector trees: module and element',\n-       fakeAsync(inject(\n-           [Router, Location, NgModuleFactoryLoader],\n-           (router: Router, location: Location, loader: SpyNgModuleFactoryLoader) => {\n-             @Component({\n-               selector: 'lazy',\n-               template: 'parent[<router-outlet></router-outlet>]',\n-               viewProviders: [\n-                 {provide: 'shadow', useValue: 'from parent component'},\n-               ],\n-             })\n-             class Parent {\n-             }\n-\n-             @Component({selector: 'lazy', template: 'child'})\n-             class Child {\n-             }\n+       fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+         @Component({\n+           selector: 'lazy',\n+           template: 'parent[<router-outlet></router-outlet>]',\n+           viewProviders: [\n+             {provide: 'shadow', useValue: 'from parent component'},\n+           ],\n+         })\n+         class Parent {\n+         }\n \n-             @NgModule({\n-               declarations: [Parent],\n-               imports: [RouterModule.forChild([{\n-                 path: 'parent',\n-                 component: Parent,\n-                 children: [\n-                   {path: 'child', loadChildren: 'child'},\n-                 ]\n-               }])],\n-               providers: [\n-                 {provide: 'moduleName', useValue: 'parent'},\n-                 {provide: 'fromParent', useValue: 'from parent'},\n-               ],\n-             })\n-             class ParentModule {\n-             }\n+         @Component({selector: 'lazy', template: 'child'})\n+         class Child {\n+         }\n \n-             @NgModule({\n-               declarations: [Child],\n-               imports: [RouterModule.forChild([{path: '', component: Child}])],\n-               providers: [\n-                 {provide: 'moduleName', useValue: 'child'},\n-                 {provide: 'fromChild', useValue: 'from child'},\n-                 {provide: 'shadow', useValue: 'from child module'},\n-               ],\n-             })\n-             class ChildModule {\n-             }\n+         @NgModule({\n+           declarations: [Parent],\n+           imports: [RouterModule.forChild([{\n+             path: 'parent',\n+             component: Parent,\n+             children: [\n+               {path: 'child', loadChildren: () => ChildModule},\n+             ]\n+           }])],\n+           providers: [\n+             {provide: 'moduleName', useValue: 'parent'},\n+             {provide: 'fromParent', useValue: 'from parent'},\n+           ],\n+         })\n+         class ParentModule {\n+         }\n \n-             loader.stubbedModules = {\n-               parent: ParentModule,\n-               child: ChildModule,\n-             };\n+         @NgModule({\n+           declarations: [Child],\n+           imports: [RouterModule.forChild([{path: '', component: Child}])],\n+           providers: [\n+             {provide: 'moduleName', useValue: 'child'},\n+             {provide: 'fromChild', useValue: 'from child'},\n+             {provide: 'shadow', useValue: 'from child module'},\n+           ],\n+         })\n+         class ChildModule {\n+         }\n \n-             const fixture = createRoot(router, RootCmp);\n-             router.resetConfig([{path: 'lazy', loadChildren: 'parent'}]);\n-             router.navigateByUrl('/lazy/parent/child');\n-             advance(fixture);\n-             expect(location.path()).toEqual('/lazy/parent/child');\n-             expect(fixture.nativeElement).toHaveText('parent[child]');\n-\n-             const pInj = fixture.debugElement.query(By.directive(Parent)).injector!;\n-             const cInj = fixture.debugElement.query(By.directive(Child)).injector!;\n-\n-             expect(pInj.get('moduleName')).toEqual('parent');\n-             expect(pInj.get('fromParent')).toEqual('from parent');\n-             expect(pInj.get(Parent)).toBeAnInstanceOf(Parent);\n-             expect(pInj.get('fromChild', null)).toEqual(null);\n-             expect(pInj.get(Child, null)).toEqual(null);\n-\n-             expect(cInj.get('moduleName')).toEqual('child');\n-             expect(cInj.get('fromParent')).toEqual('from parent');\n-             expect(cInj.get('fromChild')).toEqual('from child');\n-             expect(cInj.get(Parent)).toBeAnInstanceOf(Parent);\n-             expect(cInj.get(Child)).toBeAnInstanceOf(Child);\n-             // The child module can not shadow the parent component\n-             expect(cInj.get('shadow')).toEqual('from parent component');\n-\n-             const pmInj = pInj.get(NgModuleRef).injector;\n-             const cmInj = cInj.get(NgModuleRef).injector;\n-\n-             expect(pmInj.get('moduleName')).toEqual('parent');\n-             expect(cmInj.get('moduleName')).toEqual('child');\n-\n-             expect(pmInj.get(Parent, '-')).toEqual('-');\n-             expect(cmInj.get(Parent, '-')).toEqual('-');\n-             expect(pmInj.get(Child, '-')).toEqual('-');\n-             expect(cmInj.get(Child, '-')).toEqual('-');\n-           })));\n+         const fixture = createRoot(router, RootCmp);\n+         router.resetConfig([{path: 'lazy', loadChildren: () => ParentModule}]);\n+         router.navigateByUrl('/lazy/parent/child');\n+         advance(fixture);\n+         expect(location.path()).toEqual('/lazy/parent/child');\n+         expect(fixture.nativeElement).toHaveText('parent[child]');\n+\n+         const pInj = fixture.debugElement.query(By.directive(Parent)).injector!;\n+         const cInj = fixture.debugElement.query(By.directive(Child)).injector!;\n+\n+         expect(pInj.get('moduleName')).toEqual('parent');\n+         expect(pInj.get('fromParent')).toEqual('from parent');\n+         expect(pInj.get(Parent)).toBeAnInstanceOf(Parent);\n+         expect(pInj.get('fromChild', null)).toEqual(null);\n+         expect(pInj.get(Child, null)).toEqual(null);\n+\n+         expect(cInj.get('moduleName')).toEqual('child');\n+         expect(cInj.get('fromParent')).toEqual('from parent');\n+         expect(cInj.get('fromChild')).toEqual('from child');\n+         expect(cInj.get(Parent)).toBeAnInstanceOf(Parent);\n+         expect(cInj.get(Child)).toBeAnInstanceOf(Child);\n+         // The child module can not shadow the parent component\n+         expect(cInj.get('shadow')).toEqual('from parent component');\n+\n+         const pmInj = pInj.get(NgModuleRef).injector;\n+         const cmInj = cInj.get(NgModuleRef).injector;\n+\n+         expect(pmInj.get('moduleName')).toEqual('parent');\n+         expect(cmInj.get('moduleName')).toEqual('child');\n+\n+         expect(pmInj.get(Parent, '-')).toEqual('-');\n+         expect(cmInj.get(Parent, '-')).toEqual('-');\n+         expect(pmInj.get(Child, '-')).toEqual('-');\n+         expect(cmInj.get(Child, '-')).toEqual('-');\n+       })));\n \n     // https://github.com/angular/angular/issues/12889\n     it('should create a single instance of lazy-loaded modules',\n-       fakeAsync(inject(\n-           [Router, Location, NgModuleFactoryLoader],\n-           (router: Router, location: Location, loader: SpyNgModuleFactoryLoader) => {\n-             @Component({\n-               selector: 'lazy',\n-               template: 'lazy-loaded-parent [<router-outlet></router-outlet>]'\n-             })\n-             class ParentLazyLoadedComponent {\n-             }\n+       fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+         @Component(\n+             {selector: 'lazy', template: 'lazy-loaded-parent [<router-outlet></router-outlet>]'})\n+         class ParentLazyLoadedComponent {\n+         }\n \n-             @Component({selector: 'lazy', template: 'lazy-loaded-child'})\n-             class ChildLazyLoadedComponent {\n-             }\n+         @Component({selector: 'lazy', template: 'lazy-loaded-child'})\n+         class ChildLazyLoadedComponent {\n+         }\n \n-             @NgModule({\n-               declarations: [ParentLazyLoadedComponent, ChildLazyLoadedComponent],\n-               imports: [RouterModule.forChild([{\n-                 path: 'loaded',\n-                 component: ParentLazyLoadedComponent,\n-                 children: [{path: 'child', component: ChildLazyLoadedComponent}]\n-               }])]\n-             })\n-             class LoadedModule {\n-               static instances = 0;\n-               constructor() {\n-                 LoadedModule.instances++;\n-               }\n-             }\n+         @NgModule({\n+           declarations: [ParentLazyLoadedComponent, ChildLazyLoadedComponent],\n+           imports: [RouterModule.forChild([{\n+             path: 'loaded',\n+             component: ParentLazyLoadedComponent,\n+             children: [{path: 'child', component: ChildLazyLoadedComponent}]\n+           }])]\n+         })\n+         class LoadedModule {\n+           static instances = 0;\n+           constructor() {\n+             LoadedModule.instances++;\n+           }\n+         }\n \n-             loader.stubbedModules = {expected: LoadedModule};\n-             const fixture = createRoot(router, RootCmp);\n-             router.resetConfig([{path: 'lazy', loadChildren: 'expected'}]);\n-             router.navigateByUrl('/lazy/loaded/child');\n-             advance(fixture);\n-             expect(fixture.nativeElement).toHaveText('lazy-loaded-parent [lazy-loaded-child]');\n-             expect(LoadedModule.instances).toEqual(1);\n-           })));\n+         const fixture = createRoot(router, RootCmp);\n+         router.resetConfig([{path: 'lazy', loadChildren: () => LoadedModule}]);\n+         router.navigateByUrl('/lazy/loaded/child');\n+         advance(fixture);\n+         expect(fixture.nativeElement).toHaveText('lazy-loaded-parent [lazy-loaded-child]');\n+         expect(LoadedModule.instances).toEqual(1);\n+       })));\n \n     // https://github.com/angular/angular/issues/13870\n     it('should create a single instance of guards for lazy-loaded modules',\n-       fakeAsync(inject(\n-           [Router, Location, NgModuleFactoryLoader],\n-           (router: Router, location: Location, loader: SpyNgModuleFactoryLoader) => {\n-             @Injectable()\n-             class Service {\n-             }\n+       fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+         @Injectable()\n+         class Service {\n+         }\n \n-             @Injectable()\n-             class Resolver implements Resolve<Service> {\n-               constructor(public service: Service) {}\n-               resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {\n-                 return this.service;\n-               }\n-             }\n+         @Injectable()\n+         class Resolver implements Resolve<Service> {\n+           constructor(public service: Service) {}\n+           resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {\n+             return this.service;\n+           }\n+         }\n \n-             @Component({selector: 'lazy', template: 'lazy'})\n-             class LazyLoadedComponent {\n-               resolvedService: Service;\n-               constructor(public injectedService: Service, route: ActivatedRoute) {\n-                 this.resolvedService = route.snapshot.data['service'];\n-               }\n-             }\n+         @Component({selector: 'lazy', template: 'lazy'})\n+         class LazyLoadedComponent {\n+           resolvedService: Service;\n+           constructor(public injectedService: Service, route: ActivatedRoute) {\n+             this.resolvedService = route.snapshot.data['service'];\n+           }\n+         }\n \n-             @NgModule({\n-               declarations: [LazyLoadedComponent],\n-               providers: [Service, Resolver],\n-               imports: [\n-                 RouterModule.forChild([{\n-                   path: 'loaded',\n-                   component: LazyLoadedComponent,\n-                   resolve: {'service': Resolver},\n-                 }]),\n-               ]\n-             })\n-             class LoadedModule {\n-             }\n+         @NgModule({\n+           declarations: [LazyLoadedComponent],\n+           providers: [Service, Resolver],\n+           imports: [\n+             RouterModule.forChild([{\n+               path: 'loaded',\n+               component: LazyLoadedComponent,\n+               resolve: {'service': Resolver},\n+             }]),\n+           ]\n+         })\n+         class LoadedModule {\n+         }\n \n-             loader.stubbedModules = {expected: LoadedModule};\n-             const fixture = createRoot(router, RootCmp);\n-             router.resetConfig([{path: 'lazy', loadChildren: 'expected'}]);\n-             router.navigateByUrl('/lazy/loaded');\n-             advance(fixture);\n+         const fixture = createRoot(router, RootCmp);\n+         router.resetConfig([{path: 'lazy', loadChildren: () => LoadedModule}]);\n+         router.navigateByUrl('/lazy/loaded');\n+         advance(fixture);\n \n-             expect(fixture.nativeElement).toHaveText('lazy');\n-             const lzc =\n-                 fixture.debugElement.query(By.directive(LazyLoadedComponent)).componentInstance;\n-             expect(lzc.injectedService).toBe(lzc.resolvedService);\n-           })));\n+         expect(fixture.nativeElement).toHaveText('lazy');\n+         const lzc =\n+             fixture.debugElement.query(By.directive(LazyLoadedComponent)).componentInstance;\n+         expect(lzc.injectedService).toBe(lzc.resolvedService);\n+       })));\n \n \n     it('should emit RouteConfigLoadStart and RouteConfigLoadEnd event when route is lazy loaded',\n-       fakeAsync(inject(\n-           [Router, Location, NgModuleFactoryLoader],\n-           (router: Router, location: Location, loader: SpyNgModuleFactoryLoader) => {\n-             @Component({\n-               selector: 'lazy',\n-               template: 'lazy-loaded-parent [<router-outlet></router-outlet>]',\n-             })\n-             class ParentLazyLoadedComponent {\n-             }\n+       fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+         @Component({\n+           selector: 'lazy',\n+           template: 'lazy-loaded-parent [<router-outlet></router-outlet>]',\n+         })\n+         class ParentLazyLoadedComponent {\n+         }\n \n-             @Component({selector: 'lazy', template: 'lazy-loaded-child'})\n-             class ChildLazyLoadedComponent {\n-             }\n+         @Component({selector: 'lazy', template: 'lazy-loaded-child'})\n+         class ChildLazyLoadedComponent {\n+         }\n \n-             @NgModule({\n-               declarations: [ParentLazyLoadedComponent, ChildLazyLoadedComponent],\n-               imports: [RouterModule.forChild([{\n-                 path: 'loaded',\n-                 component: ParentLazyLoadedComponent,\n-                 children: [{path: 'child', component: ChildLazyLoadedComponent}],\n-               }])]\n-             })\n-             class LoadedModule {\n-             }\n+         @NgModule({\n+           declarations: [ParentLazyLoadedComponent, ChildLazyLoadedComponent],\n+           imports: [RouterModule.forChild([{\n+             path: 'loaded',\n+             component: ParentLazyLoadedComponent,\n+             children: [{path: 'child', component: ChildLazyLoadedComponent}],\n+           }])]\n+         })\n+         class LoadedModule {\n+         }\n \n-             const events: Array<RouteConfigLoadStart|RouteConfigLoadEnd> = [];\n+         const events: Array<RouteConfigLoadStart|RouteConfigLoadEnd> = [];\n \n-             router.events.subscribe(e => {\n-               if (e instanceof RouteConfigLoadStart || e instanceof RouteConfigLoadEnd) {\n-                 events.push(e);\n-               }\n-             });\n+         router.events.subscribe(e => {\n+           if (e instanceof RouteConfigLoadStart || e instanceof RouteConfigLoadEnd) {\n+             events.push(e);\n+           }\n+         });\n \n-             loader.stubbedModules = {expected: LoadedModule};\n-             const fixture = createRoot(router, RootCmp);\n-             router.resetConfig([{path: 'lazy', loadChildren: 'expected'}]);\n+         const fixture = createRoot(router, RootCmp);\n+         router.resetConfig([{path: 'lazy', loadChildren: () => LoadedModule}]);\n \n-             router.navigateByUrl('/lazy/loaded/child');\n-             advance(fixture);\n+         router.navigateByUrl('/lazy/loaded/child');\n+         advance(fixture);\n \n-             expect(events.length).toEqual(2);\n-             expect(events[0].toString()).toEqual('RouteConfigLoadStart(path: lazy)');\n-             expect(events[1].toString()).toEqual('RouteConfigLoadEnd(path: lazy)');\n-           })));\n+         expect(events.length).toEqual(2);\n+         expect(events[0].toString()).toEqual('RouteConfigLoadStart(path: lazy)');\n+         expect(events[1].toString()).toEqual('RouteConfigLoadEnd(path: lazy)');\n+       })));\n \n     it('throws an error when forRoot() is used in a lazy context',\n-       fakeAsync(inject(\n-           [Router, Location, NgModuleFactoryLoader],\n-           (router: Router, location: Location, loader: SpyNgModuleFactoryLoader) => {\n-             @Component({selector: 'lazy', template: 'should not show'})\n-             class LazyLoadedComponent {\n-             }\n-\n-             @NgModule({\n-               declarations: [LazyLoadedComponent],\n-               imports: [RouterModule.forRoot([{path: 'loaded', component: LazyLoadedComponent}])]\n-             })\n-             class LoadedModule {\n-             }\n+       fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+         @Component({selector: 'lazy', template: 'should not show'})\n+         class LazyLoadedComponent {\n+         }\n \n-             loader.stubbedModules = {expected: LoadedModule};\n+         @NgModule({\n+           declarations: [LazyLoadedComponent],\n+           imports: [RouterModule.forRoot([{path: 'loaded', component: LazyLoadedComponent}])]\n+         })\n+         class LoadedModule {\n+         }\n \n-             const fixture = createRoot(router, RootCmp);\n+         const fixture = createRoot(router, RootCmp);\n \n-             router.resetConfig([{path: 'lazy', loadChildren: 'expected'}]);\n+         router.resetConfig([{path: 'lazy', loadChildren: () => LoadedModule}]);\n \n-             let recordedError: any = null;\n-             router.navigateByUrl('/lazy/loaded')!.catch(err => recordedError = err);\n-             advance(fixture);\n-             expect(recordedError.message)\n-                 .toEqual(\n-                     `RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.`);\n-           })));\n+         let recordedError: any = null;\n+         router.navigateByUrl('/lazy/loaded')!.catch(err => recordedError = err);\n+         advance(fixture);\n+         expect(recordedError.message)\n+             .toEqual(\n+                 `RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.`);\n+       })));\n \n     it('should combine routes from multiple modules into a single configuration',\n-       fakeAsync(inject(\n-           [Router, Location, NgModuleFactoryLoader],\n-           (router: Router, location: Location, loader: SpyNgModuleFactoryLoader) => {\n-             @Component({selector: 'lazy', template: 'lazy-loaded-2'})\n-             class LazyComponent2 {\n-             }\n-\n-             @NgModule({\n-               declarations: [LazyComponent2],\n-               imports: [RouterModule.forChild([{path: 'loaded', component: LazyComponent2}])]\n-             })\n-             class SiblingOfLoadedModule {\n-             }\n+       fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+         @Component({selector: 'lazy', template: 'lazy-loaded-2'})\n+         class LazyComponent2 {\n+         }\n \n-             @Component({selector: 'lazy', template: 'lazy-loaded-1'})\n-             class LazyComponent1 {\n-             }\n+         @NgModule({\n+           declarations: [LazyComponent2],\n+           imports: [RouterModule.forChild([{path: 'loaded', component: LazyComponent2}])]\n+         })\n+         class SiblingOfLoadedModule {\n+         }\n \n-             @NgModule({\n-               declarations: [LazyComponent1],\n-               imports: [\n-                 RouterModule.forChild([{path: 'loaded', component: LazyComponent1}]),\n-                 SiblingOfLoadedModule\n-               ]\n-             })\n-             class LoadedModule {\n-             }\n+         @Component({selector: 'lazy', template: 'lazy-loaded-1'})\n+         class LazyComponent1 {\n+         }\n \n-             loader.stubbedModules = {expected1: LoadedModule, expected2: SiblingOfLoadedModule};\n+         @NgModule({\n+           declarations: [LazyComponent1],\n+           imports: [\n+             RouterModule.forChild([{path: 'loaded', component: LazyComponent1}]),\n+             SiblingOfLoadedModule\n+           ]\n+         })\n+         class LoadedModule {\n+         }\n \n-             const fixture = createRoot(router, RootCmp);\n+         const fixture = createRoot(router, RootCmp);\n \n-             router.resetConfig([\n-               {path: 'lazy1', loadChildren: 'expected1'},\n-               {path: 'lazy2', loadChildren: 'expected2'}\n-             ]);\n+         router.resetConfig([\n+           {path: 'lazy1', loadChildren: () => LoadedModule},\n+           {path: 'lazy2', loadChildren: () => SiblingOfLoadedModule}\n+         ]);\n \n-             router.navigateByUrl('/lazy1/loaded');\n-             advance(fixture);\n-             expect(location.path()).toEqual('/lazy1/loaded');\n+         router.navigateByUrl('/lazy1/loaded');\n+         advance(fixture);\n+         expect(location.path()).toEqual('/lazy1/loaded');\n \n-             router.navigateByUrl('/lazy2/loaded');\n-             advance(fixture);\n-             expect(location.path()).toEqual('/lazy2/loaded');\n-           })));\n+         router.navigateByUrl('/lazy2/loaded');\n+         advance(fixture);\n+         expect(location.path()).toEqual('/lazy2/loaded');\n+       })));\n \n     it('should allow lazy loaded module in named outlet',\n-       fakeAsync(inject(\n-           [Router, NgModuleFactoryLoader], (router: Router, loader: SpyNgModuleFactoryLoader) => {\n-             @Component({selector: 'lazy', template: 'lazy-loaded'})\n-             class LazyComponent {\n-             }\n-\n-             @NgModule({\n-               declarations: [LazyComponent],\n-               imports: [RouterModule.forChild([{path: '', component: LazyComponent}])]\n-             })\n-             class LazyLoadedModule {\n-             }\n+       fakeAsync(inject([Router], (router: Router) => {\n+         @Component({selector: 'lazy', template: 'lazy-loaded'})\n+         class LazyComponent {\n+         }\n \n-             loader.stubbedModules = {lazyModule: LazyLoadedModule};\n+         @NgModule({\n+           declarations: [LazyComponent],\n+           imports: [RouterModule.forChild([{path: '', component: LazyComponent}])]\n+         })\n+         class LazyLoadedModule {\n+         }\n \n-             const fixture = createRoot(router, RootCmp);\n+         const fixture = createRoot(router, RootCmp);\n \n-             router.resetConfig([{\n-               path: 'team/:id',\n-               component: TeamCmp,\n-               children: [\n-                 {path: 'user/:name', component: UserCmp},\n-                 {path: 'lazy', loadChildren: 'lazyModule', outlet: 'right'},\n-               ]\n-             }]);\n+         router.resetConfig([{\n+           path: 'team/:id',\n+           component: TeamCmp,\n+           children: [\n+             {path: 'user/:name', component: UserCmp},\n+             {path: 'lazy', loadChildren: () => LazyLoadedModule, outlet: 'right'},\n+           ]\n+         }]);\n \n \n-             router.navigateByUrl('/team/22/user/john');\n-             advance(fixture);\n+         router.navigateByUrl('/team/22/user/john');\n+         advance(fixture);\n \n-             expect(fixture.nativeElement).toHaveText('team 22 [ user john, right:  ]');\n+         expect(fixture.nativeElement).toHaveText('team 22 [ user john, right:  ]');\n \n-             router.navigateByUrl('/team/22/(user/john//right:lazy)');\n-             advance(fixture);\n+         router.navigateByUrl('/team/22/(user/john//right:lazy)');\n+         advance(fixture);\n \n-             expect(fixture.nativeElement).toHaveText('team 22 [ user john, right: lazy-loaded ]');\n-           })));\n+         expect(fixture.nativeElement).toHaveText('team 22 [ user john, right: lazy-loaded ]');\n+       })));\n \n     it('should allow componentless named outlet to render children',\n-       fakeAsync(inject(\n-           [Router, NgModuleFactoryLoader], (router: Router, loader: SpyNgModuleFactoryLoader) => {\n-             const fixture = createRoot(router, RootCmp);\n+       fakeAsync(inject([Router], (router: Router) => {\n+         const fixture = createRoot(router, RootCmp);\n \n-             router.resetConfig([{\n-               path: 'team/:id',\n-               component: TeamCmp,\n-               children: [\n-                 {path: 'user/:name', component: UserCmp},\n-                 {path: 'simple', outlet: 'right', children: [{path: '', component: SimpleCmp}]},\n-               ]\n-             }]);\n+         router.resetConfig([{\n+           path: 'team/:id',\n+           component: TeamCmp,\n+           children: [\n+             {path: 'user/:name', component: UserCmp},\n+             {path: 'simple', outlet: 'right', children: [{path: '', component: SimpleCmp}]},\n+           ]\n+         }]);\n \n \n-             router.navigateByUrl('/team/22/user/john');\n-             advance(fixture);\n+         router.navigateByUrl('/team/22/user/john');\n+         advance(fixture);\n \n-             expect(fixture.nativeElement).toHaveText('team 22 [ user john, right:  ]');\n+         expect(fixture.nativeElement).toHaveText('team 22 [ user john, right:  ]');\n \n-             router.navigateByUrl('/team/22/(user/john//right:simple)');\n-             advance(fixture);\n+         router.navigateByUrl('/team/22/(user/john//right:simple)');\n+         advance(fixture);\n \n-             expect(fixture.nativeElement).toHaveText('team 22 [ user john, right: simple ]');\n-           })));\n+         expect(fixture.nativeElement).toHaveText('team 22 [ user john, right: simple ]');\n+       })));\n \n     describe('should use the injector of the lazily-loaded configuration', () => {\n       class LazyLoadedServiceDefinedInModule {}\n@@ -5278,129 +5214,120 @@ describe('Integration', () => {\n       });\n \n       it('should use the injector of the lazily-loaded configuration',\n-         fakeAsync(inject(\n-             [Router, Location, NgModuleFactoryLoader],\n-             (router: Router, location: Location, loader: SpyNgModuleFactoryLoader) => {\n-               loader.stubbedModules = {expected: LoadedModule};\n-\n-               const fixture = createRoot(router, RootCmp);\n+         fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+           const fixture = createRoot(router, RootCmp);\n \n-               router.resetConfig([{\n-                 path: 'eager-parent',\n-                 component: EagerParentComponent,\n-                 children: [{path: 'lazy', loadChildren: 'expected'}]\n-               }]);\n+           router.resetConfig([{\n+             path: 'eager-parent',\n+             component: EagerParentComponent,\n+             children: [{path: 'lazy', loadChildren: () => LoadedModule}]\n+           }]);\n \n-               router.navigateByUrl('/eager-parent/lazy/lazy-parent/lazy-child');\n-               advance(fixture);\n+           router.navigateByUrl('/eager-parent/lazy/lazy-parent/lazy-child');\n+           advance(fixture);\n \n-               expect(location.path()).toEqual('/eager-parent/lazy/lazy-parent/lazy-child');\n-               expect(fixture.nativeElement).toHaveText('eager-parent lazy-parent lazy-child');\n-             })));\n+           expect(location.path()).toEqual('/eager-parent/lazy/lazy-parent/lazy-child');\n+           expect(fixture.nativeElement).toHaveText('eager-parent lazy-parent lazy-child');\n+         })));\n     });\n \n     it('works when given a callback',\n-       fakeAsync(inject(\n-           [Router, Location, NgModuleFactoryLoader], (router: Router, location: Location) => {\n-             @Component({selector: 'lazy', template: 'lazy-loaded'})\n-             class LazyLoadedComponent {\n-             }\n+       fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+         @Component({selector: 'lazy', template: 'lazy-loaded'})\n+         class LazyLoadedComponent {\n+         }\n \n-             @NgModule({\n-               declarations: [LazyLoadedComponent],\n-               imports: [RouterModule.forChild([{path: 'loaded', component: LazyLoadedComponent}])],\n-             })\n-             class LoadedModule {\n-             }\n+         @NgModule({\n+           declarations: [LazyLoadedComponent],\n+           imports: [RouterModule.forChild([{path: 'loaded', component: LazyLoadedComponent}])],\n+         })\n+         class LoadedModule {\n+         }\n \n-             const fixture = createRoot(router, RootCmp);\n+         const fixture = createRoot(router, RootCmp);\n \n-             router.resetConfig([{path: 'lazy', loadChildren: () => LoadedModule}]);\n+         router.resetConfig([{path: 'lazy', loadChildren: () => LoadedModule}]);\n \n-             router.navigateByUrl('/lazy/loaded');\n-             advance(fixture);\n+         router.navigateByUrl('/lazy/loaded');\n+         advance(fixture);\n \n-             expect(location.path()).toEqual('/lazy/loaded');\n-             expect(fixture.nativeElement).toHaveText('lazy-loaded');\n-           })));\n+         expect(location.path()).toEqual('/lazy/loaded');\n+         expect(fixture.nativeElement).toHaveText('lazy-loaded');\n+       })));\n \n     it('error emit an error when cannot load a config',\n-       fakeAsync(inject(\n-           [Router, Location, NgModuleFactoryLoader],\n-           (router: Router, location: Location, loader: SpyNgModuleFactoryLoader) => {\n-             loader.stubbedModules = {};\n-             const fixture = createRoot(router, RootCmp);\n+       fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+         const fixture = createRoot(router, RootCmp);\n \n-             router.resetConfig([{path: 'lazy', loadChildren: 'invalid'}]);\n+         router.resetConfig([{\n+           path: 'lazy',\n+           loadChildren: () => {\n+             throw new Error('invalid');\n+           }\n+         }]);\n \n-             const recordedEvents: any[] = [];\n-             router.events.forEach(e => recordedEvents.push(e));\n+         const recordedEvents: any[] = [];\n+         router.events.forEach(e => recordedEvents.push(e));\n \n-             router.navigateByUrl('/lazy/loaded')!.catch(s => {});\n-             advance(fixture);\n+         router.navigateByUrl('/lazy/loaded')!.catch(s => {});\n+         advance(fixture);\n \n-             expect(location.path()).toEqual('/');\n+         expect(location.path()).toEqual('/');\n \n-             expectEvents(recordedEvents, [\n-               [NavigationStart, '/lazy/loaded'],\n-               [RouteConfigLoadStart],\n-               [NavigationError, '/lazy/loaded'],\n-             ]);\n-           })));\n+         expectEvents(recordedEvents, [\n+           [NavigationStart, '/lazy/loaded'],\n+           [RouteConfigLoadStart],\n+           [NavigationError, '/lazy/loaded'],\n+         ]);\n+       })));\n \n     it('should work with complex redirect rules',\n-       fakeAsync(inject(\n-           [Router, Location, NgModuleFactoryLoader],\n-           (router: Router, location: Location, loader: SpyNgModuleFactoryLoader) => {\n-             @Component({selector: 'lazy', template: 'lazy-loaded'})\n-             class LazyLoadedComponent {\n-             }\n+       fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+         @Component({selector: 'lazy', template: 'lazy-loaded'})\n+         class LazyLoadedComponent {\n+         }\n \n-             @NgModule({\n-               declarations: [LazyLoadedComponent],\n-               imports: [RouterModule.forChild([{path: 'loaded', component: LazyLoadedComponent}])],\n-             })\n-             class LoadedModule {\n-             }\n+         @NgModule({\n+           declarations: [LazyLoadedComponent],\n+           imports: [RouterModule.forChild([{path: 'loaded', component: LazyLoadedComponent}])],\n+         })\n+         class LoadedModule {\n+         }\n \n-             loader.stubbedModules = {lazy: LoadedModule};\n-             const fixture = createRoot(router, RootCmp);\n+         const fixture = createRoot(router, RootCmp);\n \n-             router.resetConfig(\n-                 [{path: 'lazy', loadChildren: 'lazy'}, {path: '**', redirectTo: 'lazy'}]);\n+         router.resetConfig(\n+             [{path: 'lazy', loadChildren: () => LoadedModule}, {path: '**', redirectTo: 'lazy'}]);\n \n-             router.navigateByUrl('/lazy/loaded');\n-             advance(fixture);\n+         router.navigateByUrl('/lazy/loaded');\n+         advance(fixture);\n \n-             expect(location.path()).toEqual('/lazy/loaded');\n-           })));\n+         expect(location.path()).toEqual('/lazy/loaded');\n+       })));\n \n     it('should work with wildcard route',\n-       fakeAsync(inject(\n-           [Router, Location, NgModuleFactoryLoader],\n-           (router: Router, location: Location, loader: SpyNgModuleFactoryLoader) => {\n-             @Component({selector: 'lazy', template: 'lazy-loaded'})\n-             class LazyLoadedComponent {\n-             }\n+       fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+         @Component({selector: 'lazy', template: 'lazy-loaded'})\n+         class LazyLoadedComponent {\n+         }\n \n-             @NgModule({\n-               declarations: [LazyLoadedComponent],\n-               imports: [RouterModule.forChild([{path: '', component: LazyLoadedComponent}])],\n-             })\n-             class LazyLoadedModule {\n-             }\n+         @NgModule({\n+           declarations: [LazyLoadedComponent],\n+           imports: [RouterModule.forChild([{path: '', component: LazyLoadedComponent}])],\n+         })\n+         class LazyLoadedModule {\n+         }\n \n-             loader.stubbedModules = {lazy: LazyLoadedModule};\n-             const fixture = createRoot(router, RootCmp);\n+         const fixture = createRoot(router, RootCmp);\n \n-             router.resetConfig([{path: '**', loadChildren: 'lazy'}]);\n+         router.resetConfig([{path: '**', loadChildren: () => LazyLoadedModule}]);\n \n-             router.navigateByUrl('/lazy');\n-             advance(fixture);\n+         router.navigateByUrl('/lazy');\n+         advance(fixture);\n \n-             expect(location.path()).toEqual('/lazy');\n-             expect(fixture.nativeElement).toHaveText('lazy-loaded');\n-           })));\n+         expect(location.path()).toEqual('/lazy');\n+         expect(fixture.nativeElement).toHaveText('lazy-loaded');\n+       })));\n \n     describe('preloading', () => {\n       let log: string[] = [];\n@@ -5415,8 +5342,10 @@ describe('Integration', () => {\n       class LoadedModule2 {\n       }\n \n-      @NgModule(\n-          {imports: [RouterModule.forChild([{path: 'LoadedModule1', loadChildren: 'expected2'}])]})\n+      @NgModule({\n+        imports:\n+            [RouterModule.forChild([{path: 'LoadedModule1', loadChildren: () => LoadedModule2}])]\n+      })\n       class LoadedModule1 {\n       }\n \n@@ -5442,15 +5371,12 @@ describe('Integration', () => {\n       });\n \n       it('should work', fakeAsync(() => {\n-           (TestBed.inject(NgModuleFactoryLoader) as SpyNgModuleFactoryLoader).stubbedModules = {\n-             expected: LoadedModule1,\n-             expected2: LoadedModule2\n-           };\n            const router = TestBed.inject(Router);\n            const fixture = createRoot(router, RootCmp);\n \n-           router.resetConfig(\n-               [{path: 'blank', component: BlankCmp}, {path: 'lazy', loadChildren: 'expected'}]);\n+           router.resetConfig([\n+             {path: 'blank', component: BlankCmp}, {path: 'lazy', loadChildren: () => LoadedModule1}\n+           ]);\n \n            router.navigateByUrl('/blank');\n            advance(fixture);\n@@ -5467,16 +5393,12 @@ describe('Integration', () => {\n          }));\n \n       it('should not preload when canLoad is present and does not execute guard', fakeAsync(() => {\n-           (TestBed.inject(NgModuleFactoryLoader) as SpyNgModuleFactoryLoader).stubbedModules = {\n-             expected: LoadedModule1,\n-             expected2: LoadedModule2\n-           };\n            const router = TestBed.inject(Router);\n            const fixture = createRoot(router, RootCmp);\n \n            router.resetConfig([\n              {path: 'blank', component: BlankCmp},\n-             {path: 'lazy', loadChildren: 'expected', canLoad: ['loggingReturnsTrue']}\n+             {path: 'lazy', loadChildren: () => LoadedModule1, canLoad: ['loggingReturnsTrue']}\n            ]);\n \n            router.navigateByUrl('/blank');\n@@ -5490,13 +5412,10 @@ describe('Integration', () => {\n          }));\n \n       it('should allow navigation to modules with no routes', fakeAsync(() => {\n-           (TestBed.inject(NgModuleFactoryLoader) as SpyNgModuleFactoryLoader).stubbedModules = {\n-             empty: EmptyModule,\n-           };\n            const router = TestBed.inject(Router);\n            const fixture = createRoot(router, RootCmp);\n \n-           router.resetConfig([{path: 'lazy', loadChildren: 'empty'}]);\n+           router.resetConfig([{path: 'lazy', loadChildren: () => EmptyModule}]);\n \n            router.navigateByUrl('/lazy');\n            advance(fixture);\n@@ -5734,40 +5653,34 @@ describe('Integration', () => {\n       }\n \n       it('should not ignore empty path when in legacy mode',\n-         fakeAsync(inject(\n-             [Router, NgModuleFactoryLoader],\n-             (router: Router, loader: SpyNgModuleFactoryLoader) => {\n-               router.relativeLinkResolution = 'legacy';\n-               loader.stubbedModules = {expected: LazyLoadedModule};\n+         fakeAsync(inject([Router], (router: Router) => {\n+           router.relativeLinkResolution = 'legacy';\n \n-               const fixture = createRoot(router, RootCmp);\n+           const fixture = createRoot(router, RootCmp);\n \n-               router.resetConfig([{path: 'lazy', loadChildren: 'expected'}]);\n+           router.resetConfig([{path: 'lazy', loadChildren: () => LazyLoadedModule}]);\n \n-               router.navigateByUrl('/lazy/foo/bar');\n-               advance(fixture);\n+           router.navigateByUrl('/lazy/foo/bar');\n+           advance(fixture);\n \n-               const link = fixture.nativeElement.querySelector('a');\n-               expect(link.getAttribute('href')).toEqual('/lazy/foo/bar/simple');\n-             })));\n+           const link = fixture.nativeElement.querySelector('a');\n+           expect(link.getAttribute('href')).toEqual('/lazy/foo/bar/simple');\n+         })));\n \n       it('should ignore empty path when in corrected mode',\n-         fakeAsync(inject(\n-             [Router, NgModuleFactoryLoader],\n-             (router: Router, loader: SpyNgModuleFactoryLoader) => {\n-               router.relativeLinkResolution = 'corrected';\n-               loader.stubbedModules = {expected: LazyLoadedModule};\n+         fakeAsync(inject([Router], (router: Router) => {\n+           router.relativeLinkResolution = 'corrected';\n \n-               const fixture = createRoot(router, RootCmp);\n+           const fixture = createRoot(router, RootCmp);\n \n-               router.resetConfig([{path: 'lazy', loadChildren: 'expected'}]);\n+           router.resetConfig([{path: 'lazy', loadChildren: () => LazyLoadedModule}]);\n \n-               router.navigateByUrl('/lazy/foo/bar');\n-               advance(fixture);\n+           router.navigateByUrl('/lazy/foo/bar');\n+           advance(fixture);\n \n-               const link = fixture.nativeElement.querySelector('a');\n-               expect(link.getAttribute('href')).toEqual('/lazy/foo/simple');\n-             })));\n+           const link = fixture.nativeElement.querySelector('a');\n+           expect(link.getAttribute('href')).toEqual('/lazy/foo/simple');\n+         })));\n     });\n   });\n "
        },
        {
            "sha": "a37dbe5169613230bafddb54ce2e624108be6b55",
            "filename": "packages/router/test/router_preloader.spec.ts",
            "status": "modified",
            "additions": 49,
            "deletions": 71,
            "changes": 120,
            "blob_url": "https://github.com/angular/angular/blob/09d325a9e6891ae3831166a16688b9648033ffd0/packages%2Frouter%2Ftest%2Frouter_preloader.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/09d325a9e6891ae3831166a16688b9648033ffd0/packages%2Frouter%2Ftest%2Frouter_preloader.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Frouter_preloader.spec.ts?ref=09d325a9e6891ae3831166a16688b9648033ffd0",
            "patch": "@@ -27,7 +27,7 @@ describe('RouterPreloader', () => {\n     beforeEach(() => {\n       TestBed.configureTestingModule({\n         imports: [RouterTestingModule.withRoutes(\n-            [{path: 'lazy', loadChildren: 'expected', canLoad: ['someGuard']}])],\n+            [{path: 'lazy', loadChildren: jasmine.createSpy('expected'), canLoad: ['someGuard']}])],\n         providers: [{provide: PreloadingStrategy, useExisting: PreloadAllModules}]\n       });\n     });\n@@ -51,40 +51,37 @@ describe('RouterPreloader', () => {\n     beforeEach(() => {\n       TestBed.configureTestingModule({\n         imports: [RouterTestingModule.withRoutes(\n-            [{path: 'lazy', loadChildren: 'expected', canLoad: ['someGuard']}])],\n+            [{path: 'lazy', loadChildren: () => LoadedModule, canLoad: ['someGuard']}])],\n         providers: [{provide: PreloadingStrategy, useExisting: PreloadAllModules}]\n       });\n     });\n \n \n     it('should work',\n-       fakeAsync(inject(\n-           [NgModuleFactoryLoader, RouterPreloader, Router],\n-           (loader: SpyNgModuleFactoryLoader, preloader: RouterPreloader, router: Router) => {\n-             loader.stubbedModules = {expected: LoadedModule};\n-\n-             preloader.preload().subscribe(() => {});\n+       fakeAsync(inject([RouterPreloader, Router], (preloader: RouterPreloader, router: Router) => {\n+         preloader.preload().subscribe(() => {});\n \n-             tick();\n+         tick();\n \n-             const c = router.config;\n-             expect((c[0] as any)._loadedConfig).not.toBeDefined();\n-           })));\n+         const c = router.config;\n+         expect((c[0] as any)._loadedConfig).not.toBeDefined();\n+       })));\n   });\n \n   describe('should preload configurations', () => {\n+    let lazySpy: jasmine.Spy;\n     beforeEach(() => {\n+      lazySpy = jasmine.createSpy('expected');\n       TestBed.configureTestingModule({\n-        imports: [RouterTestingModule.withRoutes([{path: 'lazy', loadChildren: 'expected'}])],\n+        imports: [RouterTestingModule.withRoutes([{path: 'lazy', loadChildren: lazySpy}])],\n         providers: [{provide: PreloadingStrategy, useExisting: PreloadAllModules}]\n       });\n     });\n \n     it('should work',\n        fakeAsync(inject(\n-           [NgModuleFactoryLoader, RouterPreloader, Router, NgModuleRef],\n-           (loader: SpyNgModuleFactoryLoader, preloader: RouterPreloader, router: Router,\n-            testModule: NgModuleRef<any>) => {\n+           [RouterPreloader, Router, NgModuleRef],\n+           (preloader: RouterPreloader, router: Router, testModule: NgModuleRef<any>) => {\n              const events: Array<RouteConfigLoadStart|RouteConfigLoadEnd> = [];\n              @NgModule({\n                declarations: [LazyLoadedCmp],\n@@ -94,8 +91,8 @@ describe('RouterPreloader', () => {\n              }\n \n              @NgModule({\n-               imports:\n-                   [RouterModule.forChild([{path: 'LoadedModule1', loadChildren: 'expected2'}])]\n+               imports: [RouterModule.forChild(\n+                   [{path: 'LoadedModule1', loadChildren: () => LoadedModule2}])]\n              })\n              class LoadedModule1 {\n              }\n@@ -106,18 +103,12 @@ describe('RouterPreloader', () => {\n                }\n              });\n \n-             loader.stubbedModules = {\n-               expected: LoadedModule1,\n-               expected2: LoadedModule2,\n-             };\n-\n+             lazySpy.and.returnValue(LoadedModule1);\n              preloader.preload().subscribe(() => {});\n \n              tick();\n \n              const c = router.config;\n-             expect(c[0].loadChildren).toEqual('expected');\n-\n              const loadedConfig: LoadedRouterConfig = (c[0] as any)._loadedConfig!;\n              const module: any = loadedConfig.module;\n              expect(loadedConfig.routes[0].path).toEqual('LoadedModule1');\n@@ -139,18 +130,20 @@ describe('RouterPreloader', () => {\n   });\n \n   describe('should support modules that have already been loaded', () => {\n+    let lazySpy: jasmine.Spy;\n     beforeEach(() => {\n+      lazySpy = jasmine.createSpy('expected');\n       TestBed.configureTestingModule({\n-        imports: [RouterTestingModule.withRoutes([{path: 'lazy', loadChildren: 'expected'}])],\n+        imports: [RouterTestingModule.withRoutes([{path: 'lazy', loadChildren: lazySpy}])],\n         providers: [{provide: PreloadingStrategy, useExisting: PreloadAllModules}]\n       });\n     });\n \n     it('should work',\n        fakeAsync(inject(\n-           [NgModuleFactoryLoader, RouterPreloader, Router, NgModuleRef, Compiler],\n-           (loader: SpyNgModuleFactoryLoader, preloader: RouterPreloader, router: Router,\n-            testModule: NgModuleRef<any>, compiler: Compiler) => {\n+           [RouterPreloader, Router, NgModuleRef, Compiler],\n+           (preloader: RouterPreloader, router: Router, testModule: NgModuleRef<any>,\n+            compiler: Compiler) => {\n              @NgModule()\n              class LoadedModule2 {\n              }\n@@ -161,9 +154,9 @@ describe('RouterPreloader', () => {\n                imports: [RouterModule.forChild([\n                  <Route>{\n                    path: 'LoadedModule2',\n-                   loadChildren: 'no',\n+                   loadChildren: jasmine.createSpy('no'),\n                    _loadedConfig: {\n-                     routes: [{path: 'LoadedModule3', loadChildren: 'expected3'}],\n+                     routes: [{path: 'LoadedModule3', loadChildren: () => LoadedModule3}],\n                      module: module2,\n                    }\n                  },\n@@ -176,11 +169,7 @@ describe('RouterPreloader', () => {\n              class LoadedModule3 {\n              }\n \n-             loader.stubbedModules = {\n-               expected: LoadedModule1,\n-               expected3: LoadedModule3,\n-             };\n-\n+             lazySpy.and.returnValue(LoadedModule1);\n              preloader.preload().subscribe(() => {});\n \n              tick();\n@@ -516,27 +505,24 @@ describe('RouterPreloader', () => {\n     beforeEach(() => {\n       TestBed.configureTestingModule({\n         imports: [RouterTestingModule.withRoutes([\n-          {path: 'lazy1', loadChildren: 'expected1'}, {path: 'lazy2', loadChildren: 'expected2'}\n+          {path: 'lazy1', loadChildren: jasmine.createSpy('expected1')},\n+          {path: 'lazy2', loadChildren: () => LoadedModule}\n         ])],\n         providers: [{provide: PreloadingStrategy, useExisting: PreloadAllModules}]\n       });\n     });\n \n \n     it('should work',\n-       fakeAsync(inject(\n-           [NgModuleFactoryLoader, RouterPreloader, Router],\n-           (loader: SpyNgModuleFactoryLoader, preloader: RouterPreloader, router: Router) => {\n-             loader.stubbedModules = {expected2: LoadedModule};\n-\n-             preloader.preload().subscribe(() => {});\n+       fakeAsync(inject([RouterPreloader, Router], (preloader: RouterPreloader, router: Router) => {\n+         preloader.preload().subscribe(() => {});\n \n-             tick();\n+         tick();\n \n-             const c = router.config;\n-             expect((c[0] as any)._loadedConfig).not.toBeDefined();\n-             expect((c[1] as any)._loadedConfig).toBeDefined();\n-           })));\n+         const c = router.config;\n+         expect((c[0] as any)._loadedConfig).not.toBeDefined();\n+         expect((c[1] as any)._loadedConfig).toBeDefined();\n+       })));\n   });\n \n   describe('should copy loaded configs', () => {\n@@ -547,28 +533,25 @@ describe('RouterPreloader', () => {\n \n     beforeEach(() => {\n       TestBed.configureTestingModule({\n-        imports: [RouterTestingModule.withRoutes([{path: 'lazy1', loadChildren: 'expected'}])],\n+        imports:\n+            [RouterTestingModule.withRoutes([{path: 'lazy1', loadChildren: () => LoadedModule}])],\n         providers: [{provide: PreloadingStrategy, useExisting: PreloadAllModules}]\n       });\n     });\n \n \n     it('should work',\n-       fakeAsync(inject(\n-           [NgModuleFactoryLoader, RouterPreloader, Router],\n-           (loader: SpyNgModuleFactoryLoader, preloader: RouterPreloader, router: Router) => {\n-             loader.stubbedModules = {expected: LoadedModule};\n+       fakeAsync(inject([RouterPreloader, Router], (preloader: RouterPreloader, router: Router) => {\n+         preloader.preload().subscribe(() => {});\n \n-             preloader.preload().subscribe(() => {});\n-\n-             tick();\n+         tick();\n \n-             const c = router.config as {_loadedConfig: LoadedRouterConfig}[];\n-             expect(c[0]._loadedConfig).toBeDefined();\n-             expect(c[0]._loadedConfig!.routes).not.toBe(configs);\n-             expect(c[0]._loadedConfig!.routes[0]).not.toBe(configs[0]);\n-             expect(c[0]._loadedConfig!.routes[0].component).toBe(configs[0].component);\n-           })));\n+         const c = router.config as {_loadedConfig: LoadedRouterConfig}[];\n+         expect(c[0]._loadedConfig).toBeDefined();\n+         expect(c[0]._loadedConfig!.routes).not.toBe(configs);\n+         expect(c[0]._loadedConfig!.routes[0]).not.toBe(configs[0]);\n+         expect(c[0]._loadedConfig!.routes[0].component).toBe(configs[0].component);\n+       })));\n   });\n \n   describe(\n@@ -587,18 +570,13 @@ describe('RouterPreloader', () => {\n         beforeEach(() => {\n           TestBed.configureTestingModule({\n             imports: [RouterTestingModule.withRoutes(\n-                [{path: 'lazyEmptyModule', loadChildren: 'expected2'}])],\n+                [{path: 'lazyEmptyModule', loadChildren: () => EmptyModule}])],\n             providers: [{provide: PreloadingStrategy, useExisting: PreloadAllModules}]\n           });\n         });\n \n-        it('should work',\n-           fakeAsync(inject(\n-               [NgModuleFactoryLoader, RouterPreloader],\n-               (loader: SpyNgModuleFactoryLoader, preloader: RouterPreloader) => {\n-                 loader.stubbedModules = {expected2: EmptyModule};\n-\n-                 preloader.preload().subscribe();\n-               })));\n+        it('should work', fakeAsync(inject([RouterPreloader], (preloader: RouterPreloader) => {\n+             preloader.preload().subscribe();\n+           })));\n       });\n });"
        }
    ],
    "stats": {
        "total": 1735,
        "additions": 827,
        "deletions": 908
    }
}