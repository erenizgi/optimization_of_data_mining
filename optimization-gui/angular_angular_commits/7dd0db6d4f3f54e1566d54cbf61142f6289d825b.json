{
    "author": "petebacondarwin",
    "message": "refactor(compiler-cli): implement `BabelAstFactory` and `AstHost`s (#38866)\n\nThis commit adds the `AstHost` interface, along with implementations for\nboth Babel and TS.\n\nIt also implements the Babel vesion of the `AstFactory` interface, along\nwith a linker specific implementation of the `ImportGenerator` interface.\n\nThese classes will be used by the new \"ng-linker\" to transform prelinked\nlibrary code using a Babel plugin.\n\nPR Close #38866",
    "sha": "7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
    "files": [
        {
            "sha": "119787b86caca8cb11a4d1d418df747bb7949bab",
            "filename": ".github/angular-robot.yml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/.github%2Fangular-robot.yml",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/.github%2Fangular-robot.yml",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/.github%2Fangular-robot.yml?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -47,6 +47,7 @@ merge:\n       - \"packages/bazel/src/ng_package/**\"\n       - \"packages/bazel/src/protractor/**\"\n       - \"packages/bazel/src/schematics/**\"\n+      - \"packages/compiler-cli/linker/**\"\n       - \"packages/compiler-cli/ngcc/**\"\n       - \"packages/compiler-cli/src/ngtsc/sourcemaps/**\"\n       - \"packages/docs/**\""
        },
        {
            "sha": "9324fa61a92c1e957b9b98e20c90188d8be0f27d",
            "filename": "packages/compiler-cli/linker/BUILD.bazel",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2FBUILD.bazel?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -0,0 +1,18 @@\n+load(\"//tools:defaults.bzl\", \"ts_library\")\n+\n+package(default_visibility = [\"//visibility:public\"])\n+\n+ts_library(\n+    name = \"linker\",\n+    srcs = [\"index.ts\"] + glob([\n+        \"src/**/*.ts\",\n+    ]),\n+    deps = [\n+        \"//packages/compiler-cli/src/ngtsc/translator\",\n+        \"@npm//@babel/core\",\n+        \"@npm//@babel/types\",\n+        \"@npm//@types/babel__core\",\n+        \"@npm//@types/babel__traverse\",\n+        \"@npm//typescript\",\n+    ],\n+)"
        },
        {
            "sha": "823e9bf40a2144b88c8da9de2b4b57a583844a9c",
            "filename": "packages/compiler-cli/linker/index.ts",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Findex.ts?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -0,0 +1,7 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */"
        },
        {
            "sha": "70f55bb5d73df1836b8425ed12629d433706fd04",
            "filename": "packages/compiler-cli/linker/src/ast/ast_host.ts",
            "status": "added",
            "additions": 95,
            "deletions": 0,
            "changes": 95,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Fast_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Fast_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Fast_host.ts?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -0,0 +1,95 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+/**\n+ * An abstraction for getting information from an AST while being agnostic to the underlying AST\n+ * implementation.\n+ */\n+export interface AstHost<TExpression> {\n+  /**\n+   * Get the name of the symbol represented by the given expression node, or `null` if it is not a\n+   * symbol.\n+   */\n+  getSymbolName(node: TExpression): string|null;\n+\n+  /**\n+   * Return `true` if the given expression is a string literal, or false otherwise.\n+   */\n+  isStringLiteral(node: TExpression): boolean;\n+  /**\n+   * Parse the string value from the given expression, or throw if it is not a string literal.\n+   */\n+  parseStringLiteral(str: TExpression): string;\n+\n+  /**\n+   * Return `true` if the given expression is a numeric literal, or false otherwise.\n+   */\n+  isNumericLiteral(node: TExpression): boolean;\n+  /**\n+   * Parse the numeric value from the given expression, or throw if it is not a numeric literal.\n+   */\n+  parseNumericLiteral(num: TExpression): number;\n+\n+  /**\n+   * Return `true` if the given expression is a boolean literal, or false otherwise.\n+   */\n+  isBooleanLiteral(node: TExpression): boolean;\n+  /**\n+   * Parse the boolean value from the given expression, or throw if it is not a boolean literal.\n+   */\n+  parseBooleanLiteral(bool: TExpression): boolean;\n+\n+  /**\n+   * Return `true` if the given expression is an array literal, or false otherwise.\n+   */\n+  isArrayLiteral(node: TExpression): boolean;\n+  /**\n+   * Parse an array of expressions from the given expression, or throw if it is not an array\n+   * literal.\n+   */\n+  parseArrayLiteral(array: TExpression): TExpression[];\n+\n+  /**\n+   * Return `true` if the given expression is an object literal, or false otherwise.\n+   */\n+  isObjectLiteral(node: TExpression): boolean;\n+  /**\n+   * Parse the given expression into a map of object property names to property expressions, or\n+   * throw if it is not an object literal.\n+   */\n+  parseObjectLiteral(obj: TExpression): Map<string, TExpression>;\n+\n+  /**\n+   * Return `true` if the given expression is a function, or false otherwise.\n+   */\n+  isFunctionExpression(node: TExpression): boolean;\n+  /**\n+   * Compute the \"value\" of a function expression by parsing its body for a single `return`\n+   * statement, extracting the returned expression, or throw if it is not possible.\n+   */\n+  parseReturnValue(fn: TExpression): TExpression;\n+\n+  /**\n+   * Compute the location range of the expression in the source file, to be used for source-mapping.\n+   */\n+  getRange(node: TExpression): Range;\n+}\n+\n+/**\n+ * The location of the start and end of an expression in the original source file.\n+ */\n+export interface Range {\n+  /** 0-based character position of the range start in the source file text. */\n+  startPos: number;\n+  /** 0-based line index of the range start in the source file text. */\n+  startLine: number;\n+  /** 0-based column position of the range start in the source file text. */\n+  startCol: number;\n+  /** 0-based character position of the range end in the source file text. */\n+  endPos: number;\n+}"
        },
        {
            "sha": "60b3459fac6dbee52e774a19e2fdf962ecc9fea3",
            "filename": "packages/compiler-cli/linker/src/ast/babel/babel_ast_factory.ts",
            "status": "added",
            "additions": 165,
            "deletions": 0,
            "changes": 165,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Fbabel%2Fbabel_ast_factory.ts",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Fbabel%2Fbabel_ast_factory.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Fbabel%2Fbabel_ast_factory.ts?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -0,0 +1,165 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import * as t from '@babel/types';\n+\n+import {AstFactory, BinaryOperator, LeadingComment, ObjectLiteralProperty, SourceMapRange, TemplateLiteral, VariableDeclarationType} from '../../../../src/ngtsc/translator';\n+import {assert} from '../utils';\n+\n+export class BabelAstFactory implements AstFactory<t.Statement, t.Expression> {\n+  attachComments(statement: t.Statement, leadingComments: LeadingComment[]|undefined): t.Statement {\n+    if (leadingComments === undefined) {\n+      return statement;\n+    }\n+    // We must process the comments in reverse because `t.addComment()` will add new ones in front.\n+    for (let i = leadingComments.length - 1; i >= 0; i--) {\n+      const comment = leadingComments[i];\n+      t.addComment(statement, 'leading', comment.toString(), !comment.multiline);\n+    }\n+    return statement;\n+  }\n+\n+  createArrayLiteral = t.arrayExpression;\n+\n+  createAssignment(target: t.Expression, value: t.Expression): t.Expression {\n+    assert(target, isLExpression, 'must be a left hand side expression');\n+    return t.assignmentExpression('=', target, value);\n+  }\n+\n+  createBinaryExpression(\n+      leftOperand: t.Expression, operator: BinaryOperator,\n+      rightOperand: t.Expression): t.Expression {\n+    switch (operator) {\n+      case '&&':\n+      case '||':\n+        return t.logicalExpression(operator, leftOperand, rightOperand);\n+      default:\n+        return t.binaryExpression(operator, leftOperand, rightOperand);\n+    }\n+  }\n+\n+  createBlock = t.blockStatement;\n+\n+  createCallExpression(callee: t.Expression, args: t.Expression[], pure: boolean): t.Expression {\n+    const call = t.callExpression(callee, args);\n+    if (pure) {\n+      t.addComment(call, 'leading', ' @__PURE__ ', /* line */ false);\n+    }\n+    return call;\n+  }\n+\n+  createConditional = t.conditionalExpression;\n+\n+  createElementAccess(expression: t.Expression, element: t.Expression): t.Expression {\n+    return t.memberExpression(expression, element, /* computed */ true);\n+  }\n+\n+  createExpressionStatement = t.expressionStatement;\n+\n+  createFunctionDeclaration(functionName: string, parameters: string[], body: t.Statement):\n+      t.Statement {\n+    assert(body, t.isBlockStatement, 'a block');\n+    return t.functionDeclaration(\n+        t.identifier(functionName), parameters.map(param => t.identifier(param)), body);\n+  }\n+\n+  createFunctionExpression(functionName: string|null, parameters: string[], body: t.Statement):\n+      t.Expression {\n+    assert(body, t.isBlockStatement, 'a block');\n+    const name = functionName !== null ? t.identifier(functionName) : null;\n+    return t.functionExpression(name, parameters.map(param => t.identifier(param)), body);\n+  }\n+\n+  createIdentifier = t.identifier;\n+\n+  createIfStatement = t.ifStatement;\n+\n+  createLiteral(value: string|number|boolean|null|undefined): t.Expression {\n+    if (typeof value === 'string') {\n+      return t.stringLiteral(value);\n+    } else if (typeof value === 'number') {\n+      return t.numericLiteral(value);\n+    } else if (typeof value === 'boolean') {\n+      return t.booleanLiteral(value);\n+    } else if (value === undefined) {\n+      return t.identifier('undefined');\n+    } else if (value === null) {\n+      return t.nullLiteral();\n+    } else {\n+      throw new Error(`Invalid literal: ${value} (${typeof value})`);\n+    }\n+  }\n+\n+  createNewExpression = t.newExpression;\n+\n+  createObjectLiteral(properties: ObjectLiteralProperty<t.Expression>[]): t.Expression {\n+    return t.objectExpression(properties.map(prop => {\n+      const key =\n+          prop.quoted ? t.stringLiteral(prop.propertyName) : t.identifier(prop.propertyName);\n+      return t.objectProperty(key, prop.value);\n+    }));\n+  }\n+\n+  createParenthesizedExpression = t.parenthesizedExpression;\n+\n+  createPropertyAccess(expression: t.Expression, propertyName: string): t.Expression {\n+    return t.memberExpression(expression, t.identifier(propertyName), /* computed */ false);\n+  }\n+\n+  createReturnStatement = t.returnStatement;\n+\n+  createTaggedTemplate(tag: t.Expression, template: TemplateLiteral<t.Expression>): t.Expression {\n+    const elements = template.elements.map(\n+        (element, i) => this.setSourceMapRange(\n+            t.templateElement(element, i === template.elements.length - 1), element.range));\n+    return t.taggedTemplateExpression(tag, t.templateLiteral(elements, template.expressions));\n+  }\n+\n+  createThrowStatement = t.throwStatement;\n+\n+  createTypeOfExpression(expression: t.Expression): t.Expression {\n+    return t.unaryExpression('typeof', expression);\n+  }\n+\n+  createUnaryExpression = t.unaryExpression;\n+\n+  createVariableDeclaration(\n+      variableName: string, initializer: t.Expression|null,\n+      type: VariableDeclarationType): t.Statement {\n+    return t.variableDeclaration(\n+        type, [t.variableDeclarator(t.identifier(variableName), initializer)]);\n+  }\n+\n+  setSourceMapRange<T extends t.Statement|t.Expression|t.TemplateElement>(\n+      node: T, sourceMapRange: SourceMapRange|null): T {\n+    if (sourceMapRange === null) {\n+      return node;\n+    }\n+    // Note that the linker only works on a single file at a time, so there is no need to track the\n+    // filename. Babel will just use the current filename in the source-map.\n+    node.loc = {\n+      start: {\n+        line: sourceMapRange.start.line + 1,  // lines are 1-based in Babel.\n+        column: sourceMapRange.start.column,\n+      },\n+      end: {\n+        line: sourceMapRange.end.line + 1,  // lines are 1-based in Babel.\n+        column: sourceMapRange.end.column,\n+      },\n+    };\n+    node.start = sourceMapRange.start.offset;\n+    node.end = sourceMapRange.end.offset;\n+\n+    return node;\n+  }\n+}\n+\n+function isLExpression(expr: t.Expression): expr is Extract<t.LVal, t.Expression> {\n+  // Some LVal types are not expressions, which prevents us from using `t.isLVal()`\n+  // directly with `assert()`.\n+  return t.isLVal(expr);\n+}"
        },
        {
            "sha": "a31ba6a5368636a586e907aae2ca482d4f601d82",
            "filename": "packages/compiler-cli/linker/src/ast/babel/babel_ast_host.ts",
            "status": "added",
            "additions": 142,
            "deletions": 0,
            "changes": 142,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Fbabel%2Fbabel_ast_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Fbabel%2Fbabel_ast_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Fbabel%2Fbabel_ast_host.ts?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -0,0 +1,142 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as t from '@babel/types';\n+\n+import {FatalLinkerError} from '../../fatal_linker_error';\n+import {AstHost, Range} from '../ast_host';\n+import {assert} from '../utils';\n+\n+/**\n+ * This implementation of `AstHost` is able to get information from Babel AST nodes.\n+ */\n+export class BabelAstHost implements AstHost<t.Expression> {\n+  getSymbolName(node: t.Expression): string|null {\n+    if (t.isIdentifier(node)) {\n+      return node.name;\n+    } else if (t.isMemberExpression(node) && t.isIdentifier(node.property)) {\n+      return node.property.name;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  isStringLiteral = t.isStringLiteral;\n+\n+  parseStringLiteral(str: t.Expression): string {\n+    assert(str, t.isStringLiteral, 'a string literal');\n+    return str.value;\n+  }\n+\n+  isNumericLiteral = t.isNumericLiteral;\n+\n+  parseNumericLiteral(num: t.Expression): number {\n+    assert(num, t.isNumericLiteral, 'a numeric literal');\n+    return num.value;\n+  }\n+\n+  isBooleanLiteral = t.isBooleanLiteral;\n+\n+  parseBooleanLiteral(bool: t.Expression): boolean {\n+    assert(bool, t.isBooleanLiteral, 'a boolean literal');\n+    return bool.value;\n+  }\n+\n+  isArrayLiteral = t.isArrayExpression;\n+\n+  parseArrayLiteral(array: t.Expression): t.Expression[] {\n+    assert(array, t.isArrayExpression, 'an array literal');\n+    return array.elements.map(element => {\n+      assert(element, isNotEmptyElement, 'element in array not to be empty');\n+      assert(element, isNotSpreadElement, 'element in array not to use spread syntax');\n+      return element;\n+    });\n+  }\n+\n+  isObjectLiteral = t.isObjectExpression;\n+\n+  parseObjectLiteral(obj: t.Expression): Map<string, t.Expression> {\n+    assert(obj, t.isObjectExpression, 'an object literal');\n+\n+    const result = new Map<string, t.Expression>();\n+    for (const property of obj.properties) {\n+      assert(property, t.isObjectProperty, 'a property assignment');\n+      assert(property.value, t.isExpression, 'an expression');\n+      assert(property.key, isPropertyName, 'a property name');\n+      const key = t.isIdentifier(property.key) ? property.key.name : property.key.value;\n+      result.set(key, property.value);\n+    }\n+    return result;\n+  }\n+\n+  isFunctionExpression(node: t.Expression): node is Extract<t.Function, t.Expression> {\n+    return t.isFunction(node);\n+  }\n+\n+  parseReturnValue(fn: t.Expression): t.Expression {\n+    assert(fn, this.isFunctionExpression, 'a function');\n+    if (!t.isBlockStatement(fn.body)) {\n+      // it is a simple array function expression: `(...) => expr`\n+      return fn.body;\n+    }\n+\n+    // it is a function (arrow or normal) with a body. E.g.:\n+    // * `(...) => { stmt; ... }`\n+    // * `function(...) { stmt; ... }`\n+\n+    if (fn.body.body.length !== 1) {\n+      throw new FatalLinkerError(\n+          fn.body, 'Unsupported syntax, expected a function body with a single return statement.');\n+    }\n+    const stmt = fn.body.body[0];\n+    assert(stmt, t.isReturnStatement, 'a function body with a single return statement');\n+    if (stmt.argument === null) {\n+      throw new FatalLinkerError(stmt, 'Unsupported syntax, expected function to return a value.');\n+    }\n+\n+    return stmt.argument;\n+  }\n+\n+  getRange(node: t.Expression): Range {\n+    if (node.loc == null || node.start === null || node.end === null) {\n+      throw new FatalLinkerError(\n+          node, 'Unable to read range for node - it is missing location information.');\n+    }\n+    return {\n+      startLine: node.loc.start.line - 1,  // Babel lines are 1-based\n+      startCol: node.loc.start.column,\n+      startPos: node.start,\n+      endPos: node.end,\n+    };\n+  }\n+}\n+\n+/**\n+ * Return true if the expression does not represent an empty element in an array literal.\n+ * For example in `[,foo]` the first element is \"empty\".\n+ */\n+function isNotEmptyElement(e: t.Expression|t.SpreadElement|null): e is t.Expression|\n+    t.SpreadElement {\n+  return e !== null;\n+}\n+\n+/**\n+ * Return true if the expression is not a spread element of an array literal.\n+ * For example in `[x, ...rest]` the `...rest` expression is a spread element.\n+ */\n+function isNotSpreadElement(e: t.Expression|t.SpreadElement): e is t.Expression {\n+  return !t.isSpreadElement(e);\n+}\n+\n+\n+/**\n+ * Return true if the expression can be considered a text based property name.\n+ */\n+function isPropertyName(e: t.Expression): e is t.Identifier|t.StringLiteral|t.NumericLiteral {\n+  return t.isIdentifier(e) || t.isStringLiteral(e) || t.isNumericLiteral(e);\n+}"
        },
        {
            "sha": "582f5823a0189a026d97873bc8aa340a77d3be32",
            "filename": "packages/compiler-cli/linker/src/ast/typescript/typescript_ast_host.ts",
            "status": "added",
            "additions": 147,
            "deletions": 0,
            "changes": 147,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Ftypescript%2Ftypescript_ast_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Ftypescript%2Ftypescript_ast_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Ftypescript%2Ftypescript_ast_host.ts?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -0,0 +1,147 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as ts from 'typescript';\n+\n+import {FatalLinkerError} from '../../fatal_linker_error';\n+import {AstHost, Range} from '../ast_host';\n+import {assert} from '../utils';\n+\n+\n+/**\n+ * This implementation of `AstHost` is able to get information from TypeScript AST nodes.\n+ *\n+ * This host is not actually used at runtime in the current code.\n+ *\n+ * It is implemented here to ensure that the `AstHost` abstraction is not unfairly skewed towards\n+ * the Babel implementation. It could also provide a basis for a 3rd TypeScript compiler plugin to\n+ * do linking in the future.\n+ */\n+export class TypeScriptAstHost implements AstHost<ts.Expression> {\n+  getSymbolName(node: ts.Expression): string|null {\n+    if (ts.isIdentifier(node)) {\n+      return node.text;\n+    } else if (ts.isPropertyAccessExpression(node) && ts.isIdentifier(node.name)) {\n+      return node.name.text;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  isStringLiteral = ts.isStringLiteral;\n+\n+  parseStringLiteral(str: ts.Expression): string {\n+    assert(str, this.isStringLiteral, 'a string literal');\n+    return str.text;\n+  }\n+\n+  isNumericLiteral = ts.isNumericLiteral;\n+\n+  parseNumericLiteral(num: ts.Expression): number {\n+    assert(num, this.isNumericLiteral, 'a numeric literal');\n+    return parseInt(num.text);\n+  }\n+\n+  isBooleanLiteral(node: ts.Expression): node is ts.FalseLiteral|ts.TrueLiteral {\n+    return node.kind === ts.SyntaxKind.TrueKeyword || node.kind === ts.SyntaxKind.FalseKeyword;\n+  }\n+\n+  parseBooleanLiteral(bool: ts.Expression): boolean {\n+    assert(bool, this.isBooleanLiteral, 'a boolean literal');\n+    return bool.kind === ts.SyntaxKind.TrueKeyword;\n+  }\n+\n+  isArrayLiteral = ts.isArrayLiteralExpression;\n+\n+  parseArrayLiteral(array: ts.Expression): ts.Expression[] {\n+    assert(array, this.isArrayLiteral, 'an array literal');\n+    return array.elements.map(element => {\n+      assert(element, isNotEmptyElement, 'element in array not to be empty');\n+      assert(element, isNotSpreadElement, 'element in array not to use spread syntax');\n+      return element;\n+    });\n+  }\n+\n+  isObjectLiteral = ts.isObjectLiteralExpression;\n+\n+  parseObjectLiteral(obj: ts.Expression): Map<string, ts.Expression> {\n+    assert(obj, this.isObjectLiteral, 'an object literal');\n+\n+    const result = new Map<string, ts.Expression>();\n+    for (const property of obj.properties) {\n+      assert(property, ts.isPropertyAssignment, 'a property assignment');\n+      assert(property.name, isPropertyName, 'a property name');\n+      result.set(property.name.text, property.initializer);\n+    }\n+    return result;\n+  }\n+\n+  isFunctionExpression(node: ts.Expression): node is ts.FunctionExpression|ts.ArrowFunction {\n+    return ts.isFunctionExpression(node) || ts.isArrowFunction(node);\n+  }\n+\n+  parseReturnValue(fn: ts.Expression): ts.Expression {\n+    assert(fn, this.isFunctionExpression, 'a function');\n+    if (!ts.isBlock(fn.body)) {\n+      // it is a simple array function expression: `(...) => expr`\n+      return fn.body;\n+    }\n+\n+    // it is a function (arrow or normal) with a body. E.g.:\n+    // * `(...) => { stmt; ... }`\n+    // * `function(...) { stmt; ... }`\n+\n+    if (fn.body.statements.length !== 1) {\n+      throw new FatalLinkerError(\n+          fn.body, 'Unsupported syntax, expected a function body with a single return statement.');\n+    }\n+    const stmt = fn.body.statements[0];\n+    assert(stmt, ts.isReturnStatement, 'a function body with a single return statement');\n+    if (stmt.expression === undefined) {\n+      throw new FatalLinkerError(stmt, 'Unsupported syntax, expected function to return a value.');\n+    }\n+\n+    return stmt.expression;\n+  }\n+\n+  getRange(node: ts.Expression): Range {\n+    const file = node.getSourceFile();\n+    if (file === undefined) {\n+      throw new FatalLinkerError(\n+          node, 'Unable to read range for node - it is missing parent information.');\n+    }\n+    const startPos = node.getStart();\n+    const endPos = node.getEnd();\n+    const {line: startLine, character: startCol} = ts.getLineAndCharacterOfPosition(file, startPos);\n+    return {startLine, startCol, startPos, endPos};\n+  }\n+}\n+\n+/**\n+ * Return true if the expression does not represent an empty element in an array literal.\n+ * For example in `[,foo]` the first element is \"empty\".\n+ */\n+function isNotEmptyElement(e: ts.Expression|ts.SpreadElement|\n+                           ts.OmittedExpression): e is ts.Expression|ts.SpreadElement {\n+  return !ts.isOmittedExpression(e);\n+}\n+\n+/**\n+ * Return true if the expression is not a spread element of an array literal.\n+ * For example in `[x, ...rest]` the `...rest` expression is a spread element.\n+ */\n+function isNotSpreadElement(e: ts.Expression|ts.SpreadElement): e is ts.Expression {\n+  return !ts.isSpreadElement(e);\n+}\n+\n+/**\n+ * Return true if the expression can be considered a text based property name.\n+ */\n+function isPropertyName(e: ts.PropertyName): e is ts.Identifier|ts.StringLiteral|ts.NumericLiteral {\n+  return ts.isIdentifier(e) || ts.isStringLiteral(e) || ts.isNumericLiteral(e);\n+}"
        },
        {
            "sha": "2aa9437361f5cf5b91d9c3a82bc3e0d5dde8dcac",
            "filename": "packages/compiler-cli/linker/src/ast/utils.ts",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Futils.ts?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -0,0 +1,18 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {FatalLinkerError} from '../fatal_linker_error';\n+\n+/**\n+ * Assert that the given `node` is of the type guarded by the `predicate` function.\n+ */\n+export function assert<T, K extends T>(\n+    node: T, predicate: (node: T) => node is K, expected: string): asserts node is K {\n+  if (!predicate(node)) {\n+    throw new FatalLinkerError(node, `Unsupported syntax, expected ${expected}.`);\n+  }\n+}"
        },
        {
            "sha": "df494a8929231bad95a91428e8cd72ba58b130d7",
            "filename": "packages/compiler-cli/linker/src/fatal_linker_error.ts",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffatal_linker_error.ts",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffatal_linker_error.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffatal_linker_error.ts?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -0,0 +1,31 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+/**\n+ * An unrecoverable error during linking.\n+ */\n+export class FatalLinkerError extends Error {\n+  private readonly type = 'FatalLinkerError';\n+\n+  /**\n+   * Create a new FatalLinkerError.\n+   *\n+   * @param node The AST node where the error occurred.\n+   * @param message A description of the error.\n+   */\n+  constructor(public node: unknown, message: string) {\n+    super(message);\n+  }\n+}\n+\n+/**\n+ * Whether the given object `e` is a FatalLinkerError.\n+ */\n+export function isFatalLinkerError(e: any): e is FatalLinkerError {\n+  return e && e.type === 'FatalLinkerError';\n+}"
        },
        {
            "sha": "00d3bfbc332eb98ba011ea0bddbdb3b55bf32042",
            "filename": "packages/compiler-cli/linker/src/linker_import_generator.ts",
            "status": "added",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Flinker_import_generator.ts",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Flinker_import_generator.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Flinker_import_generator.ts?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -0,0 +1,37 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {ImportGenerator, NamedImport} from '../../src/ngtsc/translator';\n+\n+/**\n+ * A class that is used to generate imports when translating from Angular Output AST to an AST to\n+ * render, such as Babel.\n+ *\n+ * Note that, in the linker, there can only be imports from `@angular/core` and that these imports\n+ * must be achieved by property access on an `ng` namespace identifer, which is passed in via the\n+ * constructor.\n+ */\n+export class LinkerImportGenerator<TExpression> implements ImportGenerator<TExpression> {\n+  constructor(private ngImport: TExpression) {}\n+\n+  generateNamespaceImport(moduleName: string): TExpression {\n+    this.assertModuleName(moduleName);\n+    return this.ngImport;\n+  }\n+\n+  generateNamedImport(moduleName: string, originalSymbol: string): NamedImport<TExpression> {\n+    this.assertModuleName(moduleName);\n+    return {moduleImport: this.ngImport, symbol: originalSymbol};\n+  }\n+\n+  private assertModuleName(moduleName: string): void {\n+    if (moduleName !== '@angular/core') {\n+      throw new Error(`Unable to import from anything other than '@angular/core'`);\n+    }\n+  }\n+}"
        },
        {
            "sha": "83901dd4c1f06f9c48738313a1dbeaeec992f3ce",
            "filename": "packages/compiler-cli/linker/test/BUILD.bazel",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Ftest%2FBUILD.bazel?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -0,0 +1,33 @@\n+load(\"//tools:defaults.bzl\", \"jasmine_node_test\", \"ts_library\")\n+\n+package(default_visibility = [\"//visibility:public\"])\n+\n+ts_library(\n+    name = \"test_lib\",\n+    testonly = True,\n+    srcs = glob([\n+        \"**/*.ts\",\n+    ]),\n+    deps = [\n+        \"//packages:types\",\n+        \"//packages/compiler\",\n+        \"//packages/compiler-cli/linker\",\n+        \"@npm//@babel/core\",\n+        \"@npm//@babel/generator\",\n+        \"@npm//@babel/parser\",\n+        \"@npm//@babel/template\",\n+        \"@npm//@babel/types\",\n+        \"@npm//@types/babel__core\",\n+        \"@npm//@types/babel__generator\",\n+        \"@npm//@types/babel__template\",\n+        \"@npm//typescript\",\n+    ],\n+)\n+\n+jasmine_node_test(\n+    name = \"test\",\n+    bootstrap = [\"//tools/testing:node_no_angular_es5\"],\n+    deps = [\n+        \":test_lib\",\n+    ],\n+)"
        },
        {
            "sha": "106e2e70d2e347b4ccffeffebb937db53256db0e",
            "filename": "packages/compiler-cli/linker/test/ast/babel/babel_ast_factory_spec.ts",
            "status": "added",
            "additions": 382,
            "deletions": 0,
            "changes": 382,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Ftest%2Fast%2Fbabel%2Fbabel_ast_factory_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Ftest%2Fast%2Fbabel%2Fbabel_ast_factory_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Ftest%2Fast%2Fbabel%2Fbabel_ast_factory_spec.ts?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -0,0 +1,382 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {leadingComment} from '@angular/compiler';\n+import generate from '@babel/generator';\n+import {expression, statement} from '@babel/template';\n+import * as t from '@babel/types';\n+\n+import {BabelAstFactory} from '../../../src/ast/babel/babel_ast_factory';\n+\n+describe('BabelAstFactory', () => {\n+  let factory: BabelAstFactory;\n+  beforeEach(() => factory = new BabelAstFactory());\n+\n+  describe('attachComments()', () => {\n+    it('should add the comments to the given statement', () => {\n+      const stmt = statement.ast`x = 10;`;\n+      factory.attachComments(\n+          stmt, [leadingComment('comment 1', true), leadingComment('comment 2', false)]);\n+\n+      expect(generate(stmt).code).toEqual([\n+        '/* comment 1 */',\n+        '//comment 2',\n+        'x = 10;',\n+      ].join('\\n'));\n+    });\n+  });\n+\n+  describe('createArrayLiteral()', () => {\n+    it('should create an array node containing the provided expressions', () => {\n+      const expr1 = expression.ast`42`;\n+      const expr2 = expression.ast`\"moo\"`;\n+\n+      const array = factory.createArrayLiteral([expr1, expr2]);\n+      expect(generate(array).code).toEqual('[42, \"moo\"]');\n+    });\n+  });\n+\n+  describe('createAssignment()', () => {\n+    it('should create an assignment node using the target and value expressions', () => {\n+      const target = expression.ast`x`;\n+      const value = expression.ast`42`;\n+      const assignment = factory.createAssignment(target, value);\n+      expect(generate(assignment).code).toEqual('x = 42');\n+    });\n+  });\n+\n+  describe('createBinaryExpression()', () => {\n+    it('should create a binary operation node using the left and right expressions', () => {\n+      const left = expression.ast`17`;\n+      const right = expression.ast`42`;\n+      const expr = factory.createBinaryExpression(left, '+', right);\n+      expect(generate(expr).code).toEqual('17 + 42');\n+    });\n+\n+    it('should create a binary operation node for logical operators', () => {\n+      const left = expression.ast`17`;\n+      const right = expression.ast`42`;\n+      const expr = factory.createBinaryExpression(left, '&&', right);\n+      expect(t.isLogicalExpression(expr)).toBe(true);\n+      expect(generate(expr).code).toEqual('17 && 42');\n+    });\n+  });\n+\n+  describe('createBlock()', () => {\n+    it('should create a block statement containing the given statements', () => {\n+      const stmt1 = statement.ast`x = 10`;\n+      const stmt2 = statement.ast`y = 20`;\n+      const block = factory.createBlock([stmt1, stmt2]);\n+      expect(generate(block).code).toEqual([\n+        '{',\n+        '  x = 10;',\n+        '  y = 20;',\n+        '}',\n+      ].join('\\n'));\n+    });\n+  });\n+\n+  describe('createCallExpression()', () => {\n+    it('should create a call on the `callee` with the given `args`', () => {\n+      const callee = expression.ast`foo`;\n+      const arg1 = expression.ast`42`;\n+      const arg2 = expression.ast`\"moo\"`;\n+      const call = factory.createCallExpression(callee, [arg1, arg2], false);\n+      expect(generate(call).code).toEqual('foo(42, \"moo\")');\n+    });\n+\n+    it('should create a call marked with a PURE comment if `pure` is true', () => {\n+      const callee = expression.ast`foo`;\n+      const arg1 = expression.ast`42`;\n+      const arg2 = expression.ast`\"moo\"`;\n+      const call = factory.createCallExpression(callee, [arg1, arg2], true);\n+      expect(generate(call).code).toEqual(['/* @__PURE__ */', 'foo(42, \"moo\")'].join('\\n'));\n+    });\n+  });\n+\n+  describe('createConditional()', () => {\n+    it('should create a condition expression', () => {\n+      const test = expression.ast`!test`;\n+      const thenExpr = expression.ast`42`;\n+      const elseExpr = expression.ast`\"moo\"`;\n+      const conditional = factory.createConditional(test, thenExpr, elseExpr);\n+      expect(generate(conditional).code).toEqual('!test ? 42 : \"moo\"');\n+    });\n+  });\n+\n+  describe('createElementAccess()', () => {\n+    it('should create an expression accessing the element of an array/object', () => {\n+      const expr = expression.ast`obj`;\n+      const element = expression.ast`\"moo\"`;\n+      const access = factory.createElementAccess(expr, element);\n+      expect(generate(access).code).toEqual('obj[\"moo\"]');\n+    });\n+  });\n+\n+  describe('createExpressionStatement()', () => {\n+    it('should create a statement node from the given expression', () => {\n+      const expr = expression.ast`x = 10`;\n+      const stmt = factory.createExpressionStatement(expr);\n+      expect(t.isStatement(stmt)).toBe(true);\n+      expect(generate(stmt).code).toEqual('x = 10;');\n+    });\n+  });\n+\n+  describe('createFunctionDeclaration()', () => {\n+    it('should create a function declaration node with the given name, parameters and body statements',\n+       () => {\n+         const stmts = statement.ast`{x = 10; y = 20;}`;\n+         const fn = factory.createFunctionDeclaration('foo', ['arg1', 'arg2'], stmts);\n+         expect(generate(fn).code).toEqual([\n+           'function foo(arg1, arg2) {',\n+           '  x = 10;',\n+           '  y = 20;',\n+           '}',\n+         ].join('\\n'));\n+       });\n+  });\n+\n+  describe('createFunctionExpression()', () => {\n+    it('should create a function expression node with the given name, parameters and body statements',\n+       () => {\n+         const stmts = statement.ast`{x = 10; y = 20;}`;\n+         const fn = factory.createFunctionExpression('foo', ['arg1', 'arg2'], stmts);\n+         expect(t.isStatement(fn)).toBe(false);\n+         expect(generate(fn).code).toEqual([\n+           'function foo(arg1, arg2) {',\n+           '  x = 10;',\n+           '  y = 20;',\n+           '}',\n+         ].join('\\n'));\n+       });\n+\n+    it('should create an anonymous function expression node if the name is null', () => {\n+      const stmts = statement.ast`{x = 10; y = 20;}`;\n+      const fn = factory.createFunctionExpression(null, ['arg1', 'arg2'], stmts);\n+      expect(generate(fn).code).toEqual([\n+        'function (arg1, arg2) {',\n+        '  x = 10;',\n+        '  y = 20;',\n+        '}',\n+      ].join('\\n'));\n+    });\n+  });\n+\n+  describe('createIdentifier()', () => {\n+    it('should create an identifier with the given name', () => {\n+      const id = factory.createIdentifier('someId') as t.Identifier;\n+      expect(t.isIdentifier(id)).toBe(true);\n+      expect(id.name).toEqual('someId');\n+    });\n+  });\n+\n+  describe('createIfStatement()', () => {\n+    it('should create an if-else statement', () => {\n+      const test = expression.ast`!test`;\n+      const thenStmt = statement.ast`x = 10;`;\n+      const elseStmt = statement.ast`x = 42;`;\n+      const ifStmt = factory.createIfStatement(test, thenStmt, elseStmt);\n+      expect(generate(ifStmt).code).toEqual('if (!test) x = 10;else x = 42;');\n+    });\n+\n+    it('should create an if statement if the else expression is null', () => {\n+      const test = expression.ast`!test`;\n+      const thenStmt = statement.ast`x = 10;`;\n+      const ifStmt = factory.createIfStatement(test, thenStmt, null);\n+      expect(generate(ifStmt).code).toEqual('if (!test) x = 10;');\n+    });\n+  });\n+\n+  describe('createLiteral()', () => {\n+    it('should create a string literal', () => {\n+      const literal = factory.createLiteral('moo');\n+      expect(t.isStringLiteral(literal)).toBe(true);\n+      expect(generate(literal).code).toEqual('\"moo\"');\n+    });\n+\n+    it('should create a number literal', () => {\n+      const literal = factory.createLiteral(42);\n+      expect(t.isNumericLiteral(literal)).toBe(true);\n+      expect(generate(literal).code).toEqual('42');\n+    });\n+\n+    it('should create a number literal for `NaN`', () => {\n+      const literal = factory.createLiteral(NaN);\n+      expect(t.isNumericLiteral(literal)).toBe(true);\n+      expect(generate(literal).code).toEqual('NaN');\n+    });\n+\n+    it('should create a boolean literal', () => {\n+      const literal = factory.createLiteral(true);\n+      expect(t.isBooleanLiteral(literal)).toBe(true);\n+      expect(generate(literal).code).toEqual('true');\n+    });\n+\n+    it('should create an `undefined` literal', () => {\n+      const literal = factory.createLiteral(undefined);\n+      expect(t.isIdentifier(literal)).toBe(true);\n+      expect(generate(literal).code).toEqual('undefined');\n+    });\n+\n+    it('should create a null literal', () => {\n+      const literal = factory.createLiteral(null);\n+      expect(t.isNullLiteral(literal)).toBe(true);\n+      expect(generate(literal).code).toEqual('null');\n+    });\n+  });\n+\n+  describe('createNewExpression()', () => {\n+    it('should create a `new` operation on the constructor `expression` with the given `args`',\n+       () => {\n+         const expr = expression.ast`Foo`;\n+         const arg1 = expression.ast`42`;\n+         const arg2 = expression.ast`\"moo\"`;\n+         const call = factory.createNewExpression(expr, [arg1, arg2]);\n+         expect(generate(call).code).toEqual('new Foo(42, \"moo\")');\n+       });\n+  });\n+\n+  describe('createObjectLiteral()', () => {\n+    it('should create an object literal node, with the given properties', () => {\n+      const prop1 = expression.ast`42`;\n+      const prop2 = expression.ast`\"moo\"`;\n+      const obj = factory.createObjectLiteral([\n+        {propertyName: 'prop1', value: prop1, quoted: false},\n+        {propertyName: 'prop2', value: prop2, quoted: true},\n+      ]);\n+      expect(generate(obj).code).toEqual([\n+        '{',\n+        '  prop1: 42,',\n+        '  \"prop2\": \"moo\"',\n+        '}',\n+      ].join('\\n'));\n+    });\n+  });\n+\n+  describe('createParenthesizedExpression()', () => {\n+    it('should add parentheses around the given expression', () => {\n+      const expr = expression.ast`a + b`;\n+      const paren = factory.createParenthesizedExpression(expr);\n+      expect(generate(paren).code).toEqual('(a + b)');\n+    });\n+  });\n+\n+  describe('createPropertyAccess()', () => {\n+    it('should create a property access expression node', () => {\n+      const expr = expression.ast`obj`;\n+      const access = factory.createPropertyAccess(expr, 'moo');\n+      expect(generate(access).code).toEqual('obj.moo');\n+    });\n+  });\n+\n+  describe('createReturnStatement()', () => {\n+    it('should create a return statement returning the given expression', () => {\n+      const expr = expression.ast`42`;\n+      const returnStmt = factory.createReturnStatement(expr);\n+      expect(generate(returnStmt).code).toEqual('return 42;');\n+    });\n+\n+    it('should create a void return statement if the expression is null', () => {\n+      const returnStmt = factory.createReturnStatement(null);\n+      expect(generate(returnStmt).code).toEqual('return;');\n+    });\n+  });\n+\n+  describe('createTaggedTemplate()', () => {\n+    it('should create a tagged template node from the tag, elements and expressions', () => {\n+      const elements = [\n+        {raw: 'raw1', cooked: 'cooked1', range: null},\n+        {raw: 'raw2', cooked: 'cooked2', range: null},\n+        {raw: 'raw3', cooked: 'cooked3', range: null},\n+      ];\n+      const expressions = [\n+        expression.ast`42`,\n+        expression.ast`\"moo\"`,\n+      ];\n+      const tag = expression.ast`tagFn`;\n+      const template = factory.createTaggedTemplate(tag, {elements, expressions});\n+      expect(generate(template).code).toEqual('tagFn`raw1${42}raw2${\"moo\"}raw3`');\n+    });\n+  });\n+\n+  describe('createThrowStatement()', () => {\n+    it('should create a throw statement, throwing the given expression', () => {\n+      const expr = expression.ast`new Error(\"bad\")`;\n+      const throwStmt = factory.createThrowStatement(expr);\n+      expect(generate(throwStmt).code).toEqual('throw new Error(\"bad\");');\n+    });\n+  });\n+\n+  describe('createTypeOfExpression()', () => {\n+    it('should create a typeof expression node', () => {\n+      const expr = expression.ast`42`;\n+      const typeofExpr = factory.createTypeOfExpression(expr);\n+      expect(generate(typeofExpr).code).toEqual('typeof 42');\n+    });\n+  });\n+\n+  describe('createUnaryExpression()', () => {\n+    it('should create a unary expression with the operator and operand', () => {\n+      const expr = expression.ast`value`;\n+      const unaryExpr = factory.createUnaryExpression('!', expr);\n+      expect(generate(unaryExpr).code).toEqual('!value');\n+    });\n+  });\n+\n+  describe('createVariableDeclaration()', () => {\n+    it('should create a variable declaration statement node for the given variable name and initializer',\n+       () => {\n+         const initializer = expression.ast`42`;\n+         const varDecl = factory.createVariableDeclaration('foo', initializer, 'let');\n+         expect(generate(varDecl).code).toEqual('let foo = 42;');\n+       });\n+\n+    it('should create a constant declaration statement node for the given variable name and initializer',\n+       () => {\n+         const initializer = expression.ast`42`;\n+         const varDecl = factory.createVariableDeclaration('foo', initializer, 'const');\n+         expect(generate(varDecl).code).toEqual('const foo = 42;');\n+       });\n+\n+    it('should create a downleveled variable declaration statement node for the given variable name and initializer',\n+       () => {\n+         const initializer = expression.ast`42`;\n+         const varDecl = factory.createVariableDeclaration('foo', initializer, 'var');\n+         expect(generate(varDecl).code).toEqual('var foo = 42;');\n+       });\n+\n+    it('should create an uninitialized variable declaration statement node for the given variable name and a null initializer',\n+       () => {\n+         const varDecl = factory.createVariableDeclaration('foo', null, 'let');\n+         expect(generate(varDecl).code).toEqual('let foo;');\n+       });\n+  });\n+\n+  describe('setSourceMapRange()', () => {\n+    it('should attach the `sourceMapRange` to the given `node`', () => {\n+      const expr = expression.ast`42`;\n+      expect(expr.loc).toBeUndefined();\n+      expect(expr.start).toBeUndefined();\n+      expect(expr.end).toBeUndefined();\n+\n+      factory.setSourceMapRange(expr, {\n+        start: {line: 0, column: 1, offset: 1},\n+        end: {line: 2, column: 3, offset: 15},\n+        content: '-****\\n*****\\n****',\n+        url: 'original.ts'\n+      });\n+\n+      // Lines are 1-based in Babel.\n+      expect(expr.loc).toEqual({\n+        start: {line: 1, column: 1},\n+        end: {line: 3, column: 3},\n+      });\n+      expect(expr.start).toEqual(1);\n+      expect(expr.end).toEqual(15);\n+    });\n+  });\n+});"
        },
        {
            "sha": "2c371c10bf528275f4aa5a16c92a562e5d60d02b",
            "filename": "packages/compiler-cli/linker/test/ast/babel/babel_ast_host_spec.ts",
            "status": "added",
            "additions": 305,
            "deletions": 0,
            "changes": 305,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Ftest%2Fast%2Fbabel%2Fbabel_ast_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Ftest%2Fast%2Fbabel%2Fbabel_ast_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Ftest%2Fast%2Fbabel%2Fbabel_ast_host_spec.ts?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -0,0 +1,305 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import * as t from '@babel/types';\n+import template from '@babel/template';\n+import {parse} from '@babel/parser';\n+import {BabelAstHost} from '../../../src/ast/babel/babel_ast_host';\n+\n+describe('BabelAstHost', () => {\n+  let host: BabelAstHost;\n+  beforeEach(() => host = new BabelAstHost());\n+\n+  describe('getSymbolName()', () => {\n+    it('should return the name of an identifier', () => {\n+      expect(host.getSymbolName(expr('someIdentifier'))).toEqual('someIdentifier');\n+    });\n+\n+    it('should return the name of an identifier at the end of a property access chain', () => {\n+      expect(host.getSymbolName(expr('a.b.c.someIdentifier'))).toEqual('someIdentifier');\n+    });\n+\n+    it('should return null if the expression has no identifier', () => {\n+      expect(host.getSymbolName(expr('42'))).toBe(null);\n+    });\n+  });\n+\n+  describe('isStringLiteral()', () => {\n+    it('should return true if the expression is a string literal', () => {\n+      expect(host.isStringLiteral(expr('\"moo\"'))).toBe(true);\n+      expect(host.isStringLiteral(expr('\\'moo\\''))).toBe(true);\n+    });\n+\n+    it('should return false if the expression is not a string literal', () => {\n+      expect(host.isStringLiteral(expr('true'))).toBe(false);\n+      expect(host.isStringLiteral(expr('someIdentifier'))).toBe(false);\n+      expect(host.isStringLiteral(expr('42'))).toBe(false);\n+      expect(host.isStringLiteral(expr('{}'))).toBe(false);\n+      expect(host.isStringLiteral(expr('[]'))).toBe(false);\n+      expect(host.isStringLiteral(expr('null'))).toBe(false);\n+      expect(host.isStringLiteral(expr('\\'a\\' + \\'b\\''))).toBe(false);\n+    });\n+\n+    it('should return false if the expression is a template string', () => {\n+      expect(host.isStringLiteral(expr('\\`moo\\`'))).toBe(false);\n+    });\n+  });\n+\n+  describe('parseStringLiteral()', () => {\n+    it('should extract the string value', () => {\n+      expect(host.parseStringLiteral(expr('\"moo\"'))).toEqual('moo');\n+      expect(host.parseStringLiteral(expr('\\'moo\\''))).toEqual('moo');\n+    });\n+\n+    it('should error if the value is not a string literal', () => {\n+      expect(() => host.parseStringLiteral(expr('42')))\n+          .toThrowError('Unsupported syntax, expected a string literal.');\n+    });\n+  });\n+\n+  describe('isNumericLiteral()', () => {\n+    it('should return true if the expression is a number literal', () => {\n+      expect(host.isNumericLiteral(expr('42'))).toBe(true);\n+    });\n+\n+    it('should return false if the expression is not a number literal', () => {\n+      expect(host.isStringLiteral(expr('true'))).toBe(false);\n+      expect(host.isNumericLiteral(expr('\"moo\"'))).toBe(false);\n+      expect(host.isNumericLiteral(expr('\\'moo\\''))).toBe(false);\n+      expect(host.isNumericLiteral(expr('someIdentifier'))).toBe(false);\n+      expect(host.isNumericLiteral(expr('{}'))).toBe(false);\n+      expect(host.isNumericLiteral(expr('[]'))).toBe(false);\n+      expect(host.isNumericLiteral(expr('null'))).toBe(false);\n+      expect(host.isNumericLiteral(expr('\\'a\\' + \\'b\\''))).toBe(false);\n+      expect(host.isNumericLiteral(expr('\\`moo\\`'))).toBe(false);\n+    });\n+  });\n+\n+  describe('parseNumericLiteral()', () => {\n+    it('should extract the number value', () => {\n+      expect(host.parseNumericLiteral(expr('42'))).toEqual(42);\n+    });\n+\n+    it('should error if the value is not a numeric literal', () => {\n+      expect(() => host.parseNumericLiteral(expr('\"moo\"')))\n+          .toThrowError('Unsupported syntax, expected a numeric literal.');\n+    });\n+  });\n+\n+  describe('isBooleanLiteral()', () => {\n+    it('should return true if the expression is a boolean literal', () => {\n+      expect(host.isBooleanLiteral(expr('true'))).toBe(true);\n+      expect(host.isBooleanLiteral(expr('false'))).toBe(true);\n+    });\n+\n+    it('should return false if the expression is not a boolean literal', () => {\n+      expect(host.isBooleanLiteral(expr('\"moo\"'))).toBe(false);\n+      expect(host.isBooleanLiteral(expr('\\'moo\\''))).toBe(false);\n+      expect(host.isBooleanLiteral(expr('someIdentifier'))).toBe(false);\n+      expect(host.isBooleanLiteral(expr('42'))).toBe(false);\n+      expect(host.isBooleanLiteral(expr('{}'))).toBe(false);\n+      expect(host.isBooleanLiteral(expr('[]'))).toBe(false);\n+      expect(host.isBooleanLiteral(expr('null'))).toBe(false);\n+      expect(host.isBooleanLiteral(expr('\\'a\\' + \\'b\\''))).toBe(false);\n+      expect(host.isBooleanLiteral(expr('\\`moo\\`'))).toBe(false);\n+    });\n+  });\n+\n+  describe('parseBooleanLiteral()', () => {\n+    it('should extract the boolean value', () => {\n+      expect(host.parseBooleanLiteral(expr('true'))).toEqual(true);\n+      expect(host.parseBooleanLiteral(expr('false'))).toEqual(false);\n+    });\n+\n+    it('should error if the value is not a boolean literal', () => {\n+      expect(() => host.parseBooleanLiteral(expr('\"moo\"')))\n+          .toThrowError('Unsupported syntax, expected a boolean literal.');\n+    });\n+  });\n+\n+  describe('isArrayLiteral()', () => {\n+    it('should return true if the expression is an array literal', () => {\n+      expect(host.isArrayLiteral(expr('[]'))).toBe(true);\n+      expect(host.isArrayLiteral(expr('[1, 2, 3]'))).toBe(true);\n+      expect(host.isArrayLiteral(expr('[[], []]'))).toBe(true);\n+    });\n+\n+    it('should return false if the expression is not an array literal', () => {\n+      expect(host.isArrayLiteral(expr('\"moo\"'))).toBe(false);\n+      expect(host.isArrayLiteral(expr('\\'moo\\''))).toBe(false);\n+      expect(host.isArrayLiteral(expr('someIdentifier'))).toBe(false);\n+      expect(host.isArrayLiteral(expr('42'))).toBe(false);\n+      expect(host.isArrayLiteral(expr('{}'))).toBe(false);\n+      expect(host.isArrayLiteral(expr('null'))).toBe(false);\n+      expect(host.isArrayLiteral(expr('\\'a\\' + \\'b\\''))).toBe(false);\n+      expect(host.isArrayLiteral(expr('\\`moo\\`'))).toBe(false);\n+    });\n+  });\n+\n+  describe('parseArrayLiteral()', () => {\n+    it('should extract the expressions in the array', () => {\n+      const moo = expr('\\'moo\\'');\n+      expect(host.parseArrayLiteral(expr('[]'))).toEqual([]);\n+      expect(host.parseArrayLiteral(expr('[\\'moo\\']'))).toEqual([moo]);\n+    });\n+\n+    it('should error if there is an empty item', () => {\n+      expect(() => host.parseArrayLiteral(expr('[,]')))\n+          .toThrowError('Unsupported syntax, expected element in array not to be empty.');\n+    });\n+\n+    it('should error if there is a spread element', () => {\n+      expect(() => host.parseArrayLiteral(expr('[...[0,1]]')))\n+          .toThrowError('Unsupported syntax, expected element in array not to use spread syntax.');\n+    });\n+  });\n+\n+  describe('isObjectLiteral()', () => {\n+    it('should return true if the expression is an object literal', () => {\n+      expect(host.isObjectLiteral(rhs('x = {}'))).toBe(true);\n+      expect(host.isObjectLiteral(rhs('x = { foo: \\'bar\\' }'))).toBe(true);\n+    });\n+\n+    it('should return false if the expression is not an object literal', () => {\n+      expect(host.isObjectLiteral(rhs('x = \"moo\"'))).toBe(false);\n+      expect(host.isObjectLiteral(rhs('x = \\'moo\\''))).toBe(false);\n+      expect(host.isObjectLiteral(rhs('x = someIdentifier'))).toBe(false);\n+      expect(host.isObjectLiteral(rhs('x = 42'))).toBe(false);\n+      expect(host.isObjectLiteral(rhs('x = []'))).toBe(false);\n+      expect(host.isObjectLiteral(rhs('x = null'))).toBe(false);\n+      expect(host.isObjectLiteral(rhs('x = \\'a\\' + \\'b\\''))).toBe(false);\n+      expect(host.isObjectLiteral(rhs('x = \\`moo\\`'))).toBe(false);\n+    });\n+  });\n+\n+  describe('parseObjectLiteral()', () => {\n+    it('should extract the properties from the object', () => {\n+      const moo = expr('\\'moo\\'');\n+      expect(host.parseObjectLiteral(rhs('x = {}'))).toEqual(new Map());\n+      expect(host.parseObjectLiteral(rhs('x = {a: \\'moo\\'}'))).toEqual(new Map([['a', moo]]));\n+    });\n+\n+    it('should error if there is a method', () => {\n+      expect(() => host.parseObjectLiteral(rhs('x = { foo() {} }')))\n+          .toThrowError('Unsupported syntax, expected a property assignment.');\n+    });\n+\n+    it('should error if there is a spread element', () => {\n+      expect(() => host.parseObjectLiteral(rhs('x = {...{a:\\'moo\\'}}')))\n+          .toThrowError('Unsupported syntax, expected a property assignment.');\n+    });\n+  });\n+\n+  describe('isFunctionExpression()', () => {\n+    it('should return true if the expression is a function', () => {\n+      expect(host.isFunctionExpression(rhs('x = function() {}'))).toBe(true);\n+      expect(host.isFunctionExpression(rhs('x = function foo() {}'))).toBe(true);\n+      expect(host.isFunctionExpression(rhs('x = () => {}'))).toBe(true);\n+      expect(host.isFunctionExpression(rhs('x = () => true'))).toBe(true);\n+    });\n+\n+    it('should return false if the expression is a function declaration', () => {\n+      expect(host.isFunctionExpression(expr('function foo() {}'))).toBe(false);\n+    });\n+\n+    it('should return false if the expression is not a function expression', () => {\n+      expect(host.isFunctionExpression(expr('[]'))).toBe(false);\n+      expect(host.isFunctionExpression(expr('\"moo\"'))).toBe(false);\n+      expect(host.isFunctionExpression(expr('\\'moo\\''))).toBe(false);\n+      expect(host.isFunctionExpression(expr('someIdentifier'))).toBe(false);\n+      expect(host.isFunctionExpression(expr('42'))).toBe(false);\n+      expect(host.isFunctionExpression(expr('{}'))).toBe(false);\n+      expect(host.isFunctionExpression(expr('null'))).toBe(false);\n+      expect(host.isFunctionExpression(expr('\\'a\\' + \\'b\\''))).toBe(false);\n+      expect(host.isFunctionExpression(expr('\\`moo\\`'))).toBe(false);\n+    });\n+  });\n+\n+  describe('parseReturnValue()', () => {\n+    it('should extract the return value of a function', () => {\n+      const moo = expr('\\'moo\\'');\n+      expect(host.parseReturnValue(rhs('x = function() { return \\'moo\\'; }'))).toEqual(moo);\n+    });\n+\n+    it('should extract the value of a simple arrow function', () => {\n+      const moo = expr('\\'moo\\'');\n+      expect(host.parseReturnValue(rhs('x = () => \\'moo\\''))).toEqual(moo);\n+    });\n+\n+    it('should extract the return value of an arrow function', () => {\n+      const moo = expr('\\'moo\\'');\n+      expect(host.parseReturnValue(rhs('x = () => { return \\'moo\\' }'))).toEqual(moo);\n+    });\n+\n+    it('should error if the body has 0 statements', () => {\n+      expect(() => host.parseReturnValue(rhs('x = function () { }')))\n+          .toThrowError(\n+              'Unsupported syntax, expected a function body with a single return statement.');\n+      expect(() => host.parseReturnValue(rhs('x = () => { }')))\n+          .toThrowError(\n+              'Unsupported syntax, expected a function body with a single return statement.');\n+    });\n+\n+    it('should error if the body has more than 1 statement', () => {\n+      expect(() => host.parseReturnValue(rhs('x = function () { const x = 10; return x; }')))\n+          .toThrowError(\n+              'Unsupported syntax, expected a function body with a single return statement.');\n+      expect(() => host.parseReturnValue(rhs('x = () => { const x = 10; return x; }')))\n+          .toThrowError(\n+              'Unsupported syntax, expected a function body with a single return statement.');\n+    });\n+\n+    it('should error if the single statement is not a return statement', () => {\n+      expect(() => host.parseReturnValue(rhs('x = function () { const x = 10; }')))\n+          .toThrowError(\n+              'Unsupported syntax, expected a function body with a single return statement.');\n+      expect(() => host.parseReturnValue(rhs('x = () => { const x = 10; }')))\n+          .toThrowError(\n+              'Unsupported syntax, expected a function body with a single return statement.');\n+    });\n+  });\n+\n+  describe('getRange()', () => {\n+    it('should extract the range from the expression', () => {\n+      const file = parse('// preamble\\nx = \\'moo\\';');\n+      const stmt = file.program.body[0];\n+      assertExpressionStatement(stmt);\n+      assertAssignmentExpression(stmt.expression);\n+      expect(host.getRange(stmt.expression.right))\n+          .toEqual({startLine: 1, startCol: 4, startPos: 16, endPos: 21});\n+    });\n+\n+    it('should error if there is no range information', () => {\n+      const moo = rhs('// preamble\\nx = \\'moo\\';');\n+      expect(() => host.getRange(moo))\n+          .toThrowError('Unable to read range for node - it is missing location information.');\n+    });\n+  });\n+});\n+\n+function expr(code: string): t.Expression {\n+  const stmt = template.ast(code);\n+  return (stmt as t.ExpressionStatement).expression;\n+}\n+\n+function rhs(code: string): t.Expression {\n+  const e = expr(code);\n+  assertAssignmentExpression(e);\n+  return e.right;\n+}\n+\n+function assertExpressionStatement(e: t.Node): asserts e is t.ExpressionStatement {\n+  if (!t.isExpressionStatement(e)) {\n+    throw new Error('Bad test - expected an expression statement');\n+  }\n+}\n+\n+function assertAssignmentExpression(e: t.Expression): asserts e is t.AssignmentExpression {\n+  if (!t.isAssignmentExpression(e)) {\n+    throw new Error('Bad test - expected an assignment expression');\n+  }\n+}"
        },
        {
            "sha": "68dd6ad9b4827e647166266934128b067a999ce4",
            "filename": "packages/compiler-cli/linker/test/ast/typescript/typescript_ast_host_spec.ts",
            "status": "added",
            "additions": 289,
            "deletions": 0,
            "changes": 289,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Ftest%2Fast%2Ftypescript%2Ftypescript_ast_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Ftest%2Fast%2Ftypescript%2Ftypescript_ast_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Ftest%2Fast%2Ftypescript%2Ftypescript_ast_host_spec.ts?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -0,0 +1,289 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import * as ts from 'typescript';\n+import {TypeScriptAstHost} from '../../../src/ast/typescript/typescript_ast_host';\n+\n+describe('TypeScriptAstHost', () => {\n+  let host: TypeScriptAstHost;\n+  beforeEach(() => host = new TypeScriptAstHost());\n+\n+  describe('getSymbolName()', () => {\n+    it('should return the name of an identifier', () => {\n+      expect(host.getSymbolName(expr('someIdentifier'))).toEqual('someIdentifier');\n+    });\n+\n+    it('should return the name of an identifier at the end of a property access chain', () => {\n+      expect(host.getSymbolName(expr('a.b.c.someIdentifier'))).toEqual('someIdentifier');\n+    });\n+\n+    it('should return null if the expression has no identifier', () => {\n+      expect(host.getSymbolName(expr('42'))).toBe(null);\n+    });\n+  });\n+\n+  describe('isStringLiteral()', () => {\n+    it('should return true if the expression is a string literal', () => {\n+      expect(host.isStringLiteral(expr('\"moo\"'))).toBe(true);\n+      expect(host.isStringLiteral(expr('\\'moo\\''))).toBe(true);\n+    });\n+\n+    it('should return false if the expression is not a string literal', () => {\n+      expect(host.isStringLiteral(expr('true'))).toBe(false);\n+      expect(host.isStringLiteral(expr('someIdentifier'))).toBe(false);\n+      expect(host.isStringLiteral(expr('42'))).toBe(false);\n+      expect(host.isStringLiteral(rhs('x = {}'))).toBe(false);\n+      expect(host.isStringLiteral(expr('[]'))).toBe(false);\n+      expect(host.isStringLiteral(expr('null'))).toBe(false);\n+      expect(host.isStringLiteral(expr('\\'a\\' + \\'b\\''))).toBe(false);\n+    });\n+\n+    it('should return false if the expression is a template string', () => {\n+      expect(host.isStringLiteral(expr('\\`moo\\`'))).toBe(false);\n+    });\n+  });\n+\n+  describe('parseStringLiteral()', () => {\n+    it('should extract the string value', () => {\n+      expect(host.parseStringLiteral(expr('\"moo\"'))).toEqual('moo');\n+      expect(host.parseStringLiteral(expr('\\'moo\\''))).toEqual('moo');\n+    });\n+\n+    it('should error if the value is not a string literal', () => {\n+      expect(() => host.parseStringLiteral(expr('42')))\n+          .toThrowError('Unsupported syntax, expected a string literal.');\n+    });\n+  });\n+\n+  describe('isNumericLiteral()', () => {\n+    it('should return true if the expression is a number literal', () => {\n+      expect(host.isNumericLiteral(expr('42'))).toBe(true);\n+    });\n+\n+    it('should return false if the expression is not a number literal', () => {\n+      expect(host.isStringLiteral(expr('true'))).toBe(false);\n+      expect(host.isNumericLiteral(expr('\"moo\"'))).toBe(false);\n+      expect(host.isNumericLiteral(expr('\\'moo\\''))).toBe(false);\n+      expect(host.isNumericLiteral(expr('someIdentifier'))).toBe(false);\n+      expect(host.isNumericLiteral(rhs('x = {}'))).toBe(false);\n+      expect(host.isNumericLiteral(expr('[]'))).toBe(false);\n+      expect(host.isNumericLiteral(expr('null'))).toBe(false);\n+      expect(host.isNumericLiteral(expr('\\'a\\' + \\'b\\''))).toBe(false);\n+      expect(host.isNumericLiteral(expr('\\`moo\\`'))).toBe(false);\n+    });\n+  });\n+\n+  describe('parseNumericLiteral()', () => {\n+    it('should extract the number value', () => {\n+      expect(host.parseNumericLiteral(expr('42'))).toEqual(42);\n+    });\n+\n+    it('should error if the value is not a numeric literal', () => {\n+      expect(() => host.parseNumericLiteral(expr('\"moo\"')))\n+          .toThrowError('Unsupported syntax, expected a numeric literal.');\n+    });\n+  });\n+\n+  describe('isBooleanLiteral()', () => {\n+    it('should return true if the expression is a boolean literal', () => {\n+      expect(host.isBooleanLiteral(expr('true'))).toBe(true);\n+      expect(host.isBooleanLiteral(expr('false'))).toBe(true);\n+    });\n+\n+    it('should return false if the expression is not a boolean literal', () => {\n+      expect(host.isBooleanLiteral(expr('\"moo\"'))).toBe(false);\n+      expect(host.isBooleanLiteral(expr('\\'moo\\''))).toBe(false);\n+      expect(host.isBooleanLiteral(expr('someIdentifier'))).toBe(false);\n+      expect(host.isBooleanLiteral(expr('42'))).toBe(false);\n+      expect(host.isBooleanLiteral(rhs('x = {}'))).toBe(false);\n+      expect(host.isBooleanLiteral(expr('[]'))).toBe(false);\n+      expect(host.isBooleanLiteral(expr('null'))).toBe(false);\n+      expect(host.isBooleanLiteral(expr('\\'a\\' + \\'b\\''))).toBe(false);\n+      expect(host.isBooleanLiteral(expr('\\`moo\\`'))).toBe(false);\n+    });\n+  });\n+\n+  describe('parseBooleanLiteral()', () => {\n+    it('should extract the boolean value', () => {\n+      expect(host.parseBooleanLiteral(expr('true'))).toEqual(true);\n+      expect(host.parseBooleanLiteral(expr('false'))).toEqual(false);\n+    });\n+\n+    it('should error if the value is not a boolean literal', () => {\n+      expect(() => host.parseBooleanLiteral(expr('\"moo\"')))\n+          .toThrowError('Unsupported syntax, expected a boolean literal.');\n+    });\n+  });\n+\n+  describe('isArrayLiteral()', () => {\n+    it('should return true if the expression is an array literal', () => {\n+      expect(host.isArrayLiteral(expr('[]'))).toBe(true);\n+      expect(host.isArrayLiteral(expr('[1, 2, 3]'))).toBe(true);\n+      expect(host.isArrayLiteral(expr('[[], []]'))).toBe(true);\n+    });\n+\n+    it('should return false if the expression is not an array literal', () => {\n+      expect(host.isArrayLiteral(expr('\"moo\"'))).toBe(false);\n+      expect(host.isArrayLiteral(expr('\\'moo\\''))).toBe(false);\n+      expect(host.isArrayLiteral(expr('someIdentifier'))).toBe(false);\n+      expect(host.isArrayLiteral(expr('42'))).toBe(false);\n+      expect(host.isArrayLiteral(rhs('x = {}'))).toBe(false);\n+      expect(host.isArrayLiteral(expr('null'))).toBe(false);\n+      expect(host.isArrayLiteral(expr('\\'a\\' + \\'b\\''))).toBe(false);\n+      expect(host.isArrayLiteral(expr('\\`moo\\`'))).toBe(false);\n+    });\n+  });\n+\n+  describe('parseArrayLiteral()', () => {\n+    it('should extract the expressions in the array', () => {\n+      const moo = jasmine.objectContaining({text: 'moo', kind: ts.SyntaxKind.StringLiteral});\n+      expect(host.parseArrayLiteral(expr('[]'))).toEqual([]);\n+      expect(host.parseArrayLiteral(expr('[\\'moo\\']'))).toEqual([moo]);\n+    });\n+\n+    it('should error if there is an empty item', () => {\n+      expect(() => host.parseArrayLiteral(expr('[,]')))\n+          .toThrowError('Unsupported syntax, expected element in array not to be empty.');\n+    });\n+\n+    it('should error if there is a spread element', () => {\n+      expect(() => host.parseArrayLiteral(expr('[...[0,1]]')))\n+          .toThrowError('Unsupported syntax, expected element in array not to use spread syntax.');\n+    });\n+  });\n+\n+  describe('isObjectLiteral()', () => {\n+    it('should return true if the expression is an object literal', () => {\n+      expect(host.isObjectLiteral(rhs('x = {}'))).toBe(true);\n+      expect(host.isObjectLiteral(rhs('x = { foo: \\'bar\\' }'))).toBe(true);\n+    });\n+\n+    it('should return false if the expression is not an object literal', () => {\n+      expect(host.isObjectLiteral(rhs('x = \"moo\"'))).toBe(false);\n+      expect(host.isObjectLiteral(rhs('x = \\'moo\\''))).toBe(false);\n+      expect(host.isObjectLiteral(rhs('x = someIdentifier'))).toBe(false);\n+      expect(host.isObjectLiteral(rhs('x = 42'))).toBe(false);\n+      expect(host.isObjectLiteral(rhs('x = []'))).toBe(false);\n+      expect(host.isObjectLiteral(rhs('x = null'))).toBe(false);\n+      expect(host.isObjectLiteral(rhs('x = \\'a\\' + \\'b\\''))).toBe(false);\n+      expect(host.isObjectLiteral(rhs('x = \\`moo\\`'))).toBe(false);\n+    });\n+  });\n+\n+  describe('parseObjectLiteral()', () => {\n+    it('should extract the properties from the object', () => {\n+      const moo = jasmine.objectContaining({text: 'moo', kind: ts.SyntaxKind.StringLiteral});\n+      expect(host.parseObjectLiteral(rhs('x = {}'))).toEqual(new Map());\n+      expect(host.parseObjectLiteral(rhs('x = {a: \\'moo\\'}'))).toEqual(new Map([['a', moo]]));\n+    });\n+\n+    it('should error if there is a method', () => {\n+      expect(() => host.parseObjectLiteral(rhs('x = { foo() {} }')))\n+          .toThrowError('Unsupported syntax, expected a property assignment.');\n+    });\n+\n+    it('should error if there is a spread element', () => {\n+      expect(() => host.parseObjectLiteral(rhs('x = {...{ a: \\'moo\\' }}')))\n+          .toThrowError('Unsupported syntax, expected a property assignment.');\n+    });\n+  });\n+\n+  describe('isFunctionExpression()', () => {\n+    it('should return true if the expression is a function', () => {\n+      expect(host.isFunctionExpression(rhs('x = function() {}'))).toBe(true);\n+      expect(host.isFunctionExpression(rhs('x = function foo() {}'))).toBe(true);\n+      expect(host.isFunctionExpression(rhs('x = () => {}'))).toBe(true);\n+      expect(host.isFunctionExpression(rhs('x = () => true'))).toBe(true);\n+    });\n+\n+    it('should return false if the expression is not a function', () => {\n+      expect(host.isFunctionExpression(expr('[]'))).toBe(false);\n+      expect(host.isFunctionExpression(expr('\"moo\"'))).toBe(false);\n+      expect(host.isFunctionExpression(expr('\\'moo\\''))).toBe(false);\n+      expect(host.isFunctionExpression(expr('someIdentifier'))).toBe(false);\n+      expect(host.isFunctionExpression(expr('42'))).toBe(false);\n+      expect(host.isFunctionExpression(rhs('x = {}'))).toBe(false);\n+      expect(host.isFunctionExpression(expr('null'))).toBe(false);\n+      expect(host.isFunctionExpression(expr('\\'a\\' + \\'b\\''))).toBe(false);\n+      expect(host.isFunctionExpression(expr('\\`moo\\`'))).toBe(false);\n+    });\n+  });\n+\n+  describe('parseReturnValue()', () => {\n+    it('should extract the return value of a function', () => {\n+      const moo = jasmine.objectContaining({text: 'moo', kind: ts.SyntaxKind.StringLiteral});\n+      expect(host.parseReturnValue(rhs('x = function() { return \\'moo\\'; }'))).toEqual(moo);\n+    });\n+\n+    it('should extract the value of a simple arrow function', () => {\n+      const moo = jasmine.objectContaining({text: 'moo', kind: ts.SyntaxKind.StringLiteral});\n+      expect(host.parseReturnValue(rhs('x = () => \\'moo\\''))).toEqual(moo);\n+    });\n+\n+    it('should extract the return value of an arrow function', () => {\n+      const moo = jasmine.objectContaining({text: 'moo', kind: ts.SyntaxKind.StringLiteral});\n+      expect(host.parseReturnValue(rhs('x = () => { return \\'moo\\' }'))).toEqual(moo);\n+    });\n+\n+    it('should error if the body has 0 statements', () => {\n+      expect(() => host.parseReturnValue(rhs('x = function () { }')))\n+          .toThrowError(\n+              'Unsupported syntax, expected a function body with a single return statement.');\n+      expect(() => host.parseReturnValue(rhs('x = () => { }')))\n+          .toThrowError(\n+              'Unsupported syntax, expected a function body with a single return statement.');\n+    });\n+\n+    it('should error if the body has more than 1 statement', () => {\n+      expect(() => host.parseReturnValue(rhs('x = function () { const x = 10; return x; }')))\n+          .toThrowError(\n+              'Unsupported syntax, expected a function body with a single return statement.');\n+      expect(() => host.parseReturnValue(rhs('x = () => { const x = 10; return x; }')))\n+          .toThrowError(\n+              'Unsupported syntax, expected a function body with a single return statement.');\n+    });\n+\n+    it('should error if the single statement is not a return statement', () => {\n+      expect(() => host.parseReturnValue(rhs('x = function () { const x = 10; }')))\n+          .toThrowError(\n+              'Unsupported syntax, expected a function body with a single return statement.');\n+      expect(() => host.parseReturnValue(rhs('x = () => { const x = 10; }')))\n+          .toThrowError(\n+              'Unsupported syntax, expected a function body with a single return statement.');\n+    });\n+  });\n+\n+  describe('getRange()', () => {\n+    it('should extract the range from the expression', () => {\n+      const moo = rhs('// preamble\\nx = \\'moo\\';');\n+      expect(host.getRange(moo)).toEqual({startLine: 1, startCol: 4, startPos: 16, endPos: 21});\n+    });\n+\n+    it('should error if the nodes do not have attached parents', () => {\n+      const moo = rhs('// preamble\\nx = \\'moo\\';', false);\n+      expect(() => host.getRange(moo))\n+          .toThrowError('Unable to read range for node - it is missing parent information.');\n+    });\n+  });\n+});\n+\n+function stmt(code: string, attachParents = true): ts.Statement {\n+  const sf = ts.createSourceFile('test.ts', code, ts.ScriptTarget.ES2015, attachParents);\n+  return sf.statements[0];\n+}\n+\n+function expr(code: string, attachParents = true): ts.Expression {\n+  return (stmt(code, attachParents) as ts.ExpressionStatement).expression;\n+}\n+\n+function rhs(code: string, attachParents = true): ts.Expression {\n+  const e = expr(code, attachParents);\n+  if (!ts.isBinaryExpression(e)) {\n+    throw new Error('Bad test - expected a binary expression');\n+  }\n+  return e.right;\n+}"
        },
        {
            "sha": "1b4572fff86fdc9a66d142fd565d1b450a07b5aa",
            "filename": "packages/compiler-cli/linker/test/fatal_linker_error_spec.ts",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffatal_linker_error_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffatal_linker_error_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffatal_linker_error_spec.ts?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -0,0 +1,29 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {FatalLinkerError, isFatalLinkerError} from '../src/fatal_linker_error';\n+\n+describe('FatalLinkerError', () => {\n+  it('should expose the `node` and `message`', () => {\n+    const node = {};\n+    expect(new FatalLinkerError(node, 'Some message'))\n+        .toEqual(jasmine.objectContaining({node, message: 'Some message'}));\n+  });\n+});\n+\n+describe('isFatalLinkerError()', () => {\n+  it('should return true if the error is of type `FatalLinkerError`', () => {\n+    const error = new FatalLinkerError({}, 'Some message');\n+    expect(isFatalLinkerError(error)).toBe(true);\n+  });\n+\n+  it('should return false if the error is not of type `FatalLinkerError`', () => {\n+    const error = new Error('Some message');\n+    expect(isFatalLinkerError(error)).toBe(false);\n+  });\n+});"
        },
        {
            "sha": "bb4af55fbe9b5b17aac9a85a44724eec058e456e",
            "filename": "packages/compiler-cli/linker/test/linker_import_generator_spec.ts",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Ftest%2Flinker_import_generator_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Flinker%2Ftest%2Flinker_import_generator_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Ftest%2Flinker_import_generator_spec.ts?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -0,0 +1,41 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {LinkerImportGenerator} from '../src/linker_import_generator';\n+\n+const ngImport = {\n+  type: 'ngImport'\n+};\n+\n+describe('LinkerImportGenerator<TExpression>', () => {\n+  describe('generateNamespaceImport()', () => {\n+    it('should error if the import is not `@angular/core`', () => {\n+      const generator = new LinkerImportGenerator(ngImport);\n+      expect(() => generator.generateNamespaceImport('other/import'))\n+          .toThrowError(`Unable to import from anything other than '@angular/core'`);\n+    });\n+\n+    it('should return the ngImport expression for `@angular/core`', () => {\n+      const generator = new LinkerImportGenerator(ngImport);\n+      expect(generator.generateNamespaceImport('@angular/core')).toBe(ngImport);\n+    });\n+  });\n+\n+  describe('generateNamedImport()', () => {\n+    it('should error if the import is not `@angular/core`', () => {\n+      const generator = new LinkerImportGenerator(ngImport);\n+      expect(() => generator.generateNamedImport('other/import', 'someSymbol'))\n+          .toThrowError(`Unable to import from anything other than '@angular/core'`);\n+    });\n+\n+    it('should return a `NamedImport` object containing the ngImport expression', () => {\n+      const generator = new LinkerImportGenerator(ngImport);\n+      expect(generator.generateNamedImport('@angular/core', 'someSymbol'))\n+          .toEqual({moduleImport: ngImport, symbol: 'someSymbol'});\n+    });\n+  });\n+});"
        },
        {
            "sha": "dbe7308d9525c5ee4ac4f924bf3a02a65a5b667d",
            "filename": "packages/compiler-cli/package.json",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Fpackage.json",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fpackage.json?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -11,6 +11,8 @@\n     \"ng-xi18n\": \"./src/extract_i18n.js\"\n   },\n   \"dependencies\": {\n+    \"@babel/core\": \"^7.8.6\",\n+    \"@babel/types\": \"^7.8.6\",\n     \"reflect-metadata\": \"^0.1.2\",\n     \"minimist\": \"^1.2.0\",\n     \"canonical-path\": \"1.0.0\",\n@@ -52,4 +54,4 @@\n   \"publishConfig\": {\n     \"registry\": \"https://wombat-dressing-room.appspot.com\"\n   }\n-}\n\\ No newline at end of file\n+}"
        },
        {
            "sha": "81e21a189aa87147b91b629f1545f6d997ec20c3",
            "filename": "packages/compiler-cli/src/ngtsc/translator/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Findex.ts?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-export {AstFactory, BinaryOperator, LeadingComment, ObjectLiteralProperty, SourceMapLocation, SourceMapRange, TemplateElement, TemplateLiteral, UnaryOperator} from './src/api/ast_factory';\n+export {AstFactory, BinaryOperator, LeadingComment, ObjectLiteralProperty, SourceMapLocation, SourceMapRange, TemplateElement, TemplateLiteral, UnaryOperator, VariableDeclarationType} from './src/api/ast_factory';\n export {Import, ImportGenerator, NamedImport} from './src/api/import_generator';\n export {ImportManager} from './src/import_manager';\n export {RecordWrappedNodeExprFn} from './src/translator';"
        },
        {
            "sha": "fb4325dd6d6189b0542c36f22087a94497d4551f",
            "filename": "packages/compiler-cli/src/ngtsc/translator/src/api/ast_factory.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Fapi%2Fast_factory.ts",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Fapi%2Fast_factory.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Fapi%2Fast_factory.ts?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -21,7 +21,7 @@ export interface AstFactory<TStatement, TExpression> {\n    * @param leadingComments the comments to attach.\n    * @returns the node passed in as `statement` with the comments attached.\n    */\n-  attachComments(statement: TStatement, leadingComments?: LeadingComment[]): TStatement;\n+  attachComments(statement: TStatement, leadingComments: LeadingComment[]|undefined): TStatement;\n \n   /**\n    * Create a literal array expresion (e.g. `[expr1, expr2]`)."
        },
        {
            "sha": "aa0204daddc31b084968167e0b8d1f6038cae2bb",
            "filename": "packages/compiler-cli/src/ngtsc/translator/src/typescript_ast_factory.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftypescript_ast_factory.ts",
            "raw_url": "https://github.com/angular/angular/raw/7dd0db6d4f3f54e1566d54cbf61142f6289d825b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftypescript_ast_factory.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftypescript_ast_factory.ts?ref=7dd0db6d4f3f54e1566d54cbf61142f6289d825b",
            "patch": "@@ -235,7 +235,7 @@ export function createTemplateTail(cooked: string, raw: string): ts.TemplateTail\n  * @param leadingComments The comments to attach to the statement.\n  */\n export function attachComments<T extends ts.Statement>(\n-    statement: T, leadingComments?: LeadingComment[]): T {\n+    statement: T, leadingComments: LeadingComment[]|undefined): T {\n   if (leadingComments === undefined) {\n     return statement;\n   }"
        }
    ],
    "stats": {
        "total": 1750,
        "additions": 1746,
        "deletions": 4
    }
}