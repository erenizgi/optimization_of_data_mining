{
    "author": "atscott",
    "message": "refactor(router): restore history in a consistent way on canceled navigations (#43651)\n\nThe Router code currently has special-case handling around when and how\nthe internal state is reset. Specifically, it only resets the internal\ntracking of the state when an error is thrown, which does not happen\nwhen guards reject or resolvers return `EMPTY`. Other than the\nnavigation URL not matching a config, guards rejecting would be the main\ncause of a navigation being turned down.\n\nThis change updates the router code to always reset the internal state\nin the same way, regardless of the reason for navigation cancellation.\n\nIn the end, this will only affect _very_ specific use-cases with\n`UrlHandlingStrategy`. Because the internal state is not updated until\nthe end of the transition pipe, the state reset generally doesn't do\nanything at all. However, because the `rawUrlTree` is reset by calling\n`urlHandlingStrategy.merge` with the _attempted_ `rawUrl` that failed,\nthe resulting browser URL reset could be different than before (but will\nnow be consistent with how the URL is reset in other scenarios, like a\nURL not matching a `Route` config).\n\nPR Close #43651",
    "sha": "a268c4471f2e1dcaffe3304236d506222adab44c",
    "files": [
        {
            "sha": "20e5736e8c78b783f4888b652bf629ca20643511",
            "filename": "packages/router/src/router.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 12,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/a268c4471f2e1dcaffe3304236d506222adab44c/packages%2Frouter%2Fsrc%2Frouter.ts",
            "raw_url": "https://github.com/angular/angular/raw/a268c4471f2e1dcaffe3304236d506222adab44c/packages%2Frouter%2Fsrc%2Frouter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frouter.ts?ref=a268c4471f2e1dcaffe3304236d506222adab44c",
            "patch": "@@ -952,7 +952,7 @@ export class Router {\n                            // This is only applicable with initial navigation, so setting\n                            // `navigated` only when not redirecting resolves this scenario.\n                            this.navigated = true;\n-                           this.restoreHistory(t, true);\n+                           this.restoreHistory(t);\n                          }\n                          const navCancel = new NavigationCancel(\n                              t.id, this.serializeUrl(t.extractedUrl), e.message);\n@@ -989,7 +989,7 @@ export class Router {\n                          /* All other errors should reset to the router's internal URL reference to\n                           * the pre-error state. */\n                        } else {\n-                         this.restoreHistory(t, true);\n+                         this.restoreHistory(t);\n                          const navError =\n                              new NavigationError(t.id, this.serializeUrl(t.extractedUrl), e);\n                          eventsSubject.next(navError);\n@@ -1454,7 +1454,7 @@ export class Router {\n    * Performs the necessary rollback action to restore the browser URL to the\n    * state before the transition.\n    */\n-  private restoreHistory(t: NavigationTransition, restoringFromCaughtError = false) {\n+  private restoreHistory(t: NavigationTransition) {\n     if (this.canceledNavigationResolution === 'computed') {\n       const targetPagePosition = this.currentPageId - t.targetPageId;\n       // The navigator change the location before triggered the browser event,\n@@ -1476,20 +1476,12 @@ export class Router {\n         // TODO(atscott): resetting the `browserUrlTree` should really be done in `resetState`.\n         // Investigate if this can be done by running TGP.\n         this.browserUrlTree = t.currentUrlTree;\n-        this.resetUrlToCurrentUrlTree();\n       } else {\n         // The browser URL and router state was not updated before the navigation cancelled so\n         // there's no restoration needed.\n       }\n     } else if (this.canceledNavigationResolution === 'replace') {\n-      // TODO(atscott): It seems like we should _always_ reset the state here. It would be a no-op\n-      // for `deferred` navigations that haven't change the internal state yet because guards\n-      // reject. For 'eager' navigations, it seems like we also really should reset the state\n-      // because the navigation was cancelled. Investigate if this can be done by running TGP.\n-      if (restoringFromCaughtError) {\n-        this.resetState(t);\n-      }\n-      this.resetUrlToCurrentUrlTree();\n+      this.resetState(t);\n     }\n   }\n \n@@ -1502,6 +1494,7 @@ export class Router {\n     // addition, the URLHandlingStrategy may be configured to specifically preserve parts of the URL\n     // when merging, such as the query params so they are not lost on a refresh.\n     this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl);\n+    this.resetUrlToCurrentUrlTree();\n   }\n \n   private resetUrlToCurrentUrlTree(): void {"
        }
    ],
    "stats": {
        "total": 17,
        "additions": 5,
        "deletions": 12
    }
}