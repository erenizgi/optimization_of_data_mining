{
    "author": "petebacondarwin",
    "message": "style(docs-infra): reformat ScrollService file (#30630)\n\nPre-empting code formatting changes when the\ncode is updated in a subsequent commit.\n\nPR Close #30630",
    "sha": "8227b56f9e052f33f3ba0d4aaac39590d4d123ec",
    "files": [
        {
            "sha": "fd694f693011e73062b8a089cc43869ac4ad2517",
            "filename": "aio/src/app/shared/scroll.service.spec.ts",
            "status": "modified",
            "additions": 125,
            "deletions": 129,
            "changes": 254,
            "blob_url": "https://github.com/angular/angular/blob/8227b56f9e052f33f3ba0d4aaac39590d4d123ec/aio%2Fsrc%2Fapp%2Fshared%2Fscroll.service.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/8227b56f9e052f33f3ba0d4aaac39590d4d123ec/aio%2Fsrc%2Fapp%2Fshared%2Fscroll.service.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fsrc%2Fapp%2Fshared%2Fscroll.service.spec.ts?ref=8227b56f9e052f33f3ba0d4aaac39590d4d123ec",
            "patch": "@@ -1,10 +1,10 @@\n-import { ReflectiveInjector } from '@angular/core';\n-import { Location, LocationStrategy, PlatformLocation, ViewportScroller } from '@angular/common';\n-import { DOCUMENT } from '@angular/common';\n-import { MockLocationStrategy, SpyLocation } from '@angular/common/testing';\n-import { fakeAsync, tick } from '@angular/core/testing';\n+import {Location, LocationStrategy, PlatformLocation, ViewportScroller} from '@angular/common';\n+import {DOCUMENT} from '@angular/common';\n+import {MockLocationStrategy, SpyLocation} from '@angular/common/testing';\n+import {ReflectiveInjector} from '@angular/core';\n+import {fakeAsync, tick} from '@angular/core/testing';\n \n-import { ScrollService, topMargin } from './scroll.service';\n+import {ScrollService, topMargin} from './scroll.service';\n \n describe('ScrollService', () => {\n   const scrollServiceInstances: ScrollService[] = [];\n@@ -32,27 +32,25 @@ describe('ScrollService', () => {\n   }\n \n   class MockElement {\n-    getBoundingClientRect = jasmine.createSpy('Element getBoundingClientRect')\n-                                   .and.returnValue({top: 0});\n+    getBoundingClientRect =\n+        jasmine.createSpy('Element getBoundingClientRect').and.returnValue({top: 0});\n     scrollIntoView = jasmine.createSpy('Element scrollIntoView');\n   }\n \n-  const viewportScrollerStub = jasmine.createSpyObj(\n-    'viewportScroller',\n-    ['getScrollPosition', 'scrollToPosition']);\n+  const viewportScrollerStub =\n+      jasmine.createSpyObj('viewportScroller', ['getScrollPosition', 'scrollToPosition']);\n \n   beforeEach(() => {\n     injector = ReflectiveInjector.resolveAndCreate([\n-        {\n-          provide: ScrollService,\n-          useFactory: createScrollService,\n-          deps: [DOCUMENT, PlatformLocation, ViewportScroller, Location],\n-        },\n-        { provide: Location, useClass: SpyLocation },\n-        { provide: DOCUMENT, useClass: MockDocument },\n-        { provide: PlatformLocation, useClass: MockPlatformLocation },\n-        { provide: ViewportScroller, useValue: viewportScrollerStub },\n-        { provide: LocationStrategy, useClass: MockLocationStrategy }\n+      {\n+        provide: ScrollService,\n+        useFactory: createScrollService,\n+        deps: [DOCUMENT, PlatformLocation, ViewportScroller, Location],\n+      },\n+      {provide: Location, useClass: SpyLocation}, {provide: DOCUMENT, useClass: MockDocument},\n+      {provide: PlatformLocation, useClass: MockPlatformLocation},\n+      {provide: ViewportScroller, useValue: viewportScrollerStub},\n+      {provide: LocationStrategy, useClass: MockLocationStrategy}\n     ]);\n     platformLocation = injector.get(PlatformLocation);\n     document = injector.get(DOCUMENT);\n@@ -68,18 +66,19 @@ describe('ScrollService', () => {\n   });\n \n   it('should debounce `updateScrollPositonInHistory()`', fakeAsync(() => {\n-    const updateScrollPositionInHistorySpy = spyOn(scrollService, 'updateScrollPositionInHistory');\n-\n-    window.dispatchEvent(new Event('scroll'));\n-    tick(249);\n-    window.dispatchEvent(new Event('scroll'));\n-    tick(249);\n-    window.dispatchEvent(new Event('scroll'));\n-    tick(249);\n-    expect(updateScrollPositionInHistorySpy).not.toHaveBeenCalled();\n-    tick(1);\n-    expect(updateScrollPositionInHistorySpy).toHaveBeenCalledTimes(1);\n-  }));\n+       const updateScrollPositionInHistorySpy =\n+           spyOn(scrollService, 'updateScrollPositionInHistory');\n+\n+       window.dispatchEvent(new Event('scroll'));\n+       tick(249);\n+       window.dispatchEvent(new Event('scroll'));\n+       tick(249);\n+       window.dispatchEvent(new Event('scroll'));\n+       tick(249);\n+       expect(updateScrollPositionInHistorySpy).not.toHaveBeenCalled();\n+       tick(1);\n+       expect(updateScrollPositionInHistorySpy).toHaveBeenCalledTimes(1);\n+     }));\n \n   it('should set `scrollRestoration` to `manual` if supported', () => {\n     if (scrollService.supportManualScrollRestoration) {\n@@ -96,7 +95,9 @@ describe('ScrollService', () => {\n       try {\n         // Simulate `window.sessionStorage` being inaccessible, when cookies are disabled.\n         Object.defineProperty(window, 'sessionStorage', {\n-          get() { throw new Error('The operation is insecure'); },\n+          get() {\n+            throw new Error('The operation is insecure');\n+          },\n         });\n \n         const platformLoc = platformLocation as PlatformLocation;\n@@ -198,8 +199,7 @@ describe('ScrollService', () => {\n       platformLocation.hash = '';\n \n       const topOfPage = new MockElement();\n-      document.getElementById.and\n-              .callFake((id: string) => id === 'top-of-page' ? topOfPage : null);\n+      document.getElementById.and.callFake((id: string) => id === 'top-of-page' ? topOfPage : null);\n \n       scrollService.scroll();\n       expect(topOfPage.scrollIntoView).toHaveBeenCalled();\n@@ -227,7 +227,7 @@ describe('ScrollService', () => {\n \n     it('should scroll to the element whose id matches the hash with encoded characters', () => {\n       const element = new MockElement();\n-      platformLocation.hash = '%F0%9F%91%8D'; // ðŸ‘\n+      platformLocation.hash = '%F0%9F%91%8D';  // ðŸ‘\n       document.getElementById.and.returnValue(element);\n \n       scrollService.scroll();\n@@ -289,8 +289,7 @@ describe('ScrollService', () => {\n     it('should scroll to top', () => {\n       const topOfPageElement = new MockElement() as any as Element;\n       document.getElementById.and.callFake(\n-        (id: string) => id === 'top-of-page' ? topOfPageElement : null\n-      );\n+          (id: string) => id === 'top-of-page' ? topOfPageElement : null);\n \n       scrollService.scrollToTop();\n       expect(topOfPageElement.scrollIntoView).toHaveBeenCalled();\n@@ -312,58 +311,55 @@ describe('ScrollService', () => {\n \n   describe('#needToFixScrollPosition', async () => {\n     it('should return true when popState event was fired after a back navigation if the browser supports ' +\n-      'scrollRestoration`. Otherwise, needToFixScrollPosition() returns false', () => {\n-\n-      if (scrollService.supportManualScrollRestoration) {\n-        location.go('/initial-url1');\n-        // We simulate a scroll down\n-        location.replaceState('/initial-url1', 'hack', {scrollPosition: [2000, 0]});\n-        location.go('/initial-url2');\n-        location.back();\n-\n-        expect(scrollService.poppedStateScrollPosition).toEqual([2000, 0]);\n-        expect(scrollService.needToFixScrollPosition()).toBe(true);\n-      } else {\n-        location.go('/initial-url1');\n-        location.go('/initial-url2');\n-        location.back();\n-\n-        expect(scrollService.poppedStateScrollPosition).toBe(null);\n-        expect(scrollService.needToFixScrollPosition()).toBe(false);\n-      }\n-\n-    });\n+           'scrollRestoration`. Otherwise, needToFixScrollPosition() returns false',\n+       () => {\n+         if (scrollService.supportManualScrollRestoration) {\n+           location.go('/initial-url1');\n+           // We simulate a scroll down\n+           location.replaceState('/initial-url1', 'hack', {scrollPosition: [2000, 0]});\n+           location.go('/initial-url2');\n+           location.back();\n+\n+           expect(scrollService.poppedStateScrollPosition).toEqual([2000, 0]);\n+           expect(scrollService.needToFixScrollPosition()).toBe(true);\n+         } else {\n+           location.go('/initial-url1');\n+           location.go('/initial-url2');\n+           location.back();\n+\n+           expect(scrollService.poppedStateScrollPosition).toBe(null);\n+           expect(scrollService.needToFixScrollPosition()).toBe(false);\n+         }\n+       });\n \n     it('should return true when popState event was fired after a forward navigation if the browser supports ' +\n-      'scrollRestoration`. Otherwise, needToFixScrollPosition() returns false', () => {\n-\n-      if (scrollService.supportManualScrollRestoration) {\n-        location.go('/initial-url1');\n-        location.go('/initial-url2');\n-        // We simulate a scroll down\n-        location.replaceState('/initial-url1', 'hack', {scrollPosition: [2000, 0]});\n-\n-        location.back();\n-        scrollService.poppedStateScrollPosition = [0, 0];\n-        location.forward();\n-\n-        expect(scrollService.poppedStateScrollPosition).toEqual([2000, 0]);\n-        expect(scrollService.needToFixScrollPosition()).toBe(true);\n-      } else {\n-        location.go('/initial-url1');\n-        location.go('/initial-url2');\n-        location.back();\n-        location.forward();\n-\n-        expect(scrollService.poppedStateScrollPosition).toBe(null);\n-        expect(scrollService.needToFixScrollPosition()).toBe(false);\n-      }\n-\n-    });\n+           'scrollRestoration`. Otherwise, needToFixScrollPosition() returns false',\n+       () => {\n+         if (scrollService.supportManualScrollRestoration) {\n+           location.go('/initial-url1');\n+           location.go('/initial-url2');\n+           // We simulate a scroll down\n+           location.replaceState('/initial-url1', 'hack', {scrollPosition: [2000, 0]});\n+\n+           location.back();\n+           scrollService.poppedStateScrollPosition = [0, 0];\n+           location.forward();\n+\n+           expect(scrollService.poppedStateScrollPosition).toEqual([2000, 0]);\n+           expect(scrollService.needToFixScrollPosition()).toBe(true);\n+         } else {\n+           location.go('/initial-url1');\n+           location.go('/initial-url2');\n+           location.back();\n+           location.forward();\n+\n+           expect(scrollService.poppedStateScrollPosition).toBe(null);\n+           expect(scrollService.needToFixScrollPosition()).toBe(false);\n+         }\n+       });\n   });\n \n   describe('#scrollAfterRender', async () => {\n-\n     let scrollSpy: jasmine.Spy;\n     let scrollToTopSpy: jasmine.Spy;\n     let needToFixScrollPositionSpy: jasmine.Spy;\n@@ -383,69 +379,69 @@ describe('ScrollService', () => {\n \n \n     it('should call `scroll` when we navigate to a location with anchor', fakeAsync(() => {\n-      needToFixScrollPositionSpy.and.returnValue(false);\n-      getStoredScrollPositionSpy.and.returnValue(null);\n-      isLocationWithHashSpy.and.returnValue(true);\n+         needToFixScrollPositionSpy.and.returnValue(false);\n+         getStoredScrollPositionSpy.and.returnValue(null);\n+         isLocationWithHashSpy.and.returnValue(true);\n \n-      scrollService.scrollAfterRender(scrollDelay);\n+         scrollService.scrollAfterRender(scrollDelay);\n \n-      expect(scrollSpy).not.toHaveBeenCalled();\n-      tick(scrollDelay);\n-      expect(scrollSpy).toHaveBeenCalled();\n-    }));\n+         expect(scrollSpy).not.toHaveBeenCalled();\n+         tick(scrollDelay);\n+         expect(scrollSpy).toHaveBeenCalled();\n+       }));\n \n     it('should call `scrollToTop` when we navigate to a location without anchor', fakeAsync(() => {\n-      needToFixScrollPositionSpy.and.returnValue(false);\n-      getStoredScrollPositionSpy.and.returnValue(null);\n-      isLocationWithHashSpy.and.returnValue(false);\n+         needToFixScrollPositionSpy.and.returnValue(false);\n+         getStoredScrollPositionSpy.and.returnValue(null);\n+         isLocationWithHashSpy.and.returnValue(false);\n \n-      scrollService.scrollAfterRender(scrollDelay);\n+         scrollService.scrollAfterRender(scrollDelay);\n \n-      expect(scrollToTopSpy).toHaveBeenCalled();\n-      tick(scrollDelay);\n-      expect(scrollSpy).not.toHaveBeenCalled();\n-    }));\n+         expect(scrollToTopSpy).toHaveBeenCalled();\n+         tick(scrollDelay);\n+         expect(scrollSpy).not.toHaveBeenCalled();\n+       }));\n \n     it('should call `viewportScroller.scrollToPosition` when we reload a page', fakeAsync(() => {\n-      getStoredScrollPositionSpy.and.returnValue([0, 1000]);\n+         getStoredScrollPositionSpy.and.returnValue([0, 1000]);\n \n-      scrollService.scrollAfterRender(scrollDelay);\n+         scrollService.scrollAfterRender(scrollDelay);\n \n-      expect(viewportScrollerStub.scrollToPosition).toHaveBeenCalled();\n-      expect(getStoredScrollPositionSpy).toHaveBeenCalled();\n-    }));\n+         expect(viewportScrollerStub.scrollToPosition).toHaveBeenCalled();\n+         expect(getStoredScrollPositionSpy).toHaveBeenCalled();\n+       }));\n \n     it('should call `scrollToPosition` after a popState', fakeAsync(() => {\n-      needToFixScrollPositionSpy.and.returnValue(true);\n-      getStoredScrollPositionSpy.and.returnValue(null);\n-      scrollService.scrollAfterRender(scrollDelay);\n-      expect(scrollToPosition).toHaveBeenCalled();\n-      tick(scrollDelay);\n-      expect(scrollSpy).not.toHaveBeenCalled();\n-      expect(scrollToTopSpy).not.toHaveBeenCalled();\n-    }));\n+         needToFixScrollPositionSpy.and.returnValue(true);\n+         getStoredScrollPositionSpy.and.returnValue(null);\n+         scrollService.scrollAfterRender(scrollDelay);\n+         expect(scrollToPosition).toHaveBeenCalled();\n+         tick(scrollDelay);\n+         expect(scrollSpy).not.toHaveBeenCalled();\n+         expect(scrollToTopSpy).not.toHaveBeenCalled();\n+       }));\n   });\n \n   describe('once destroyed', () => {\n     it('should stop updating scroll position', fakeAsync(() => {\n-      const updateScrollPositionInHistorySpy =\n-          spyOn(scrollService, 'updateScrollPositionInHistory');\n+         const updateScrollPositionInHistorySpy =\n+             spyOn(scrollService, 'updateScrollPositionInHistory');\n \n-      window.dispatchEvent(new Event('scroll'));\n-      tick(250);\n-      expect(updateScrollPositionInHistorySpy).toHaveBeenCalledTimes(1);\n+         window.dispatchEvent(new Event('scroll'));\n+         tick(250);\n+         expect(updateScrollPositionInHistorySpy).toHaveBeenCalledTimes(1);\n \n-      window.dispatchEvent(new Event('scroll'));\n-      tick(250);\n-      expect(updateScrollPositionInHistorySpy).toHaveBeenCalledTimes(2);\n+         window.dispatchEvent(new Event('scroll'));\n+         tick(250);\n+         expect(updateScrollPositionInHistorySpy).toHaveBeenCalledTimes(2);\n \n-      updateScrollPositionInHistorySpy.calls.reset();\n-      scrollService.ngOnDestroy();\n+         updateScrollPositionInHistorySpy.calls.reset();\n+         scrollService.ngOnDestroy();\n \n-      window.dispatchEvent(new Event('scroll'));\n-      tick(250);\n-      expect(updateScrollPositionInHistorySpy).not.toHaveBeenCalled();\n-    }));\n+         window.dispatchEvent(new Event('scroll'));\n+         tick(250);\n+         expect(updateScrollPositionInHistorySpy).not.toHaveBeenCalled();\n+       }));\n \n     it('should stop updating the stored location href', () => {\n       const updateScrollLocationHrefSpy = spyOn(scrollService, 'updateScrollLocationHref');"
        },
        {
            "sha": "3664bbc13028a0d98074da97ccce52ff0235c9d0",
            "filename": "aio/src/app/shared/scroll.service.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 23,
            "changes": 44,
            "blob_url": "https://github.com/angular/angular/blob/8227b56f9e052f33f3ba0d4aaac39590d4d123ec/aio%2Fsrc%2Fapp%2Fshared%2Fscroll.service.ts",
            "raw_url": "https://github.com/angular/angular/raw/8227b56f9e052f33f3ba0d4aaac39590d4d123ec/aio%2Fsrc%2Fapp%2Fshared%2Fscroll.service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fsrc%2Fapp%2Fshared%2Fscroll.service.ts?ref=8227b56f9e052f33f3ba0d4aaac39590d4d123ec",
            "patch": "@@ -1,7 +1,7 @@\n-import { DOCUMENT, Location, PlatformLocation, PopStateEvent, ViewportScroller } from '@angular/common';\n-import { Injectable, Inject, OnDestroy } from '@angular/core';\n-import { fromEvent, Subject } from 'rxjs';\n-import { debounceTime, takeUntil } from 'rxjs/operators';\n+import {DOCUMENT, Location, PlatformLocation, PopStateEvent, ViewportScroller} from '@angular/common';\n+import {Inject, Injectable, OnDestroy} from '@angular/core';\n+import {fromEvent, Subject} from 'rxjs';\n+import {debounceTime, takeUntil} from 'rxjs/operators';\n \n type ScrollPosition = [number, number];\n interface ScrollPositionPopStateEvent extends PopStateEvent {\n@@ -15,18 +15,17 @@ export const topMargin = 16;\n  */\n @Injectable()\n export class ScrollService implements OnDestroy {\n-\n-  private _topOffset: number | null;\n+  private _topOffset: number|null;\n   private _topOfPageElement: Element;\n   private onDestroy = new Subject<void>();\n   private storage: Storage;\n \n   // The scroll position which has to be restored, after a `popstate` event.\n-  poppedStateScrollPosition: ScrollPosition | null = null;\n+  poppedStateScrollPosition: ScrollPosition|null = null;\n   // Whether the browser supports the necessary features for manual scroll restoration.\n-  supportManualScrollRestoration: boolean =\n-      !!window && ('scrollTo' in window) && ('scrollX' in window) && ('scrollY' in window) &&\n-      !!history && ('scrollRestoration' in history);\n+  supportManualScrollRestoration: boolean = !!window && ('scrollTo' in window) &&\n+      ('scrollX' in window) && ('scrollY' in window) && !!history &&\n+      ('scrollRestoration' in history);\n \n   // Offset from the top of the document to bottom of any static elements\n   // at the top (e.g. toolbar) + some margin\n@@ -46,10 +45,8 @@ export class ScrollService implements OnDestroy {\n   }\n \n   constructor(\n-      @Inject(DOCUMENT) private document: any,\n-      private platformLocation: PlatformLocation,\n-      private viewportScroller: ViewportScroller,\n-      private location: Location) {\n+      @Inject(DOCUMENT) private document: any, private platformLocation: PlatformLocation,\n+      private viewportScroller: ViewportScroller, private location: Location) {\n     try {\n       this.storage = window.sessionStorage;\n     } catch {\n@@ -118,9 +115,7 @@ export class ScrollService implements OnDestroy {\n    */\n   scroll() {\n     const hash = this.getCurrentHash();\n-    const element: HTMLElement = hash\n-        ? this.document.getElementById(hash)\n-        : this.topOfPageElement;\n+    const element: HTMLElement = hash ? this.document.getElementById(hash) : this.topOfPageElement;\n     this.scrollToElement(element);\n   }\n \n@@ -132,8 +127,8 @@ export class ScrollService implements OnDestroy {\n   }\n \n   /**\n-   * When we load a document, we have to scroll to the correct position depending on whether this is a new location,\n-   * a back/forward in the history, or a refresh\n+   * When we load a document, we have to scroll to the correct position depending on whether this is\n+   * a new location, a back/forward in the history, or a refresh\n    * @param delay before we scroll to the good position\n    */\n   scrollAfterRender(delay: number) {\n@@ -208,19 +203,22 @@ export class ScrollService implements OnDestroy {\n   updateScrollPositionInHistory() {\n     if (this.supportManualScrollRestoration) {\n       const currentScrollPosition = this.viewportScroller.getScrollPosition();\n-      this.location.replaceState(this.location.path(true), undefined, {scrollPosition: currentScrollPosition});\n+      this.location.replaceState(\n+          this.location.path(true), undefined, {scrollPosition: currentScrollPosition});\n       this.storage.setItem('scrollPosition', currentScrollPosition.join(','));\n     }\n   }\n \n-  getStoredScrollLocationHref(): string | null {\n+  getStoredScrollLocationHref(): string|null {\n     const href = this.storage.getItem('scrollLocationHref');\n     return href || null;\n   }\n \n-  getStoredScrollPosition(): ScrollPosition | null {\n+  getStoredScrollPosition(): ScrollPosition|null {\n     const position = this.storage.getItem('scrollPosition');\n-    if (!position) { return null; }\n+    if (!position) {\n+      return null;\n+    }\n \n     const [x, y] = position.split(',');\n     return [+x, +y];"
        }
    ],
    "stats": {
        "total": 298,
        "additions": 146,
        "deletions": 152
    }
}