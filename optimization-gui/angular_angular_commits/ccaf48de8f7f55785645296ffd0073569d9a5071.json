{
    "author": "alxhub",
    "message": "refactor(language-service): add context to template target system (#40032)\n\nThis commit extends the template targeting system, which determines the node\nbeing referenced given a template position, to return additional context if\nneeded about the particular aspect of the node to which the position refers.\nFor example, a position pointing to an element node may be pointing either\nto its tag name or to somewhere in the node body. This is the difference\nbetween `<div|>` and `<div foo | bar>`.\n\nPR Close #40032",
    "sha": "ccaf48de8f7f55785645296ffd0073569d9a5071",
    "files": [
        {
            "sha": "a06493bd2f094c2fddcc32c9498efbfffa9aec02",
            "filename": "packages/language-service/ivy/completions.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/ccaf48de8f7f55785645296ffd0073569d9a5071/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "raw_url": "https://github.com/angular/angular/raw/ccaf48de8f7f55785645296ffd0073569d9a5071/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fcompletions.ts?ref=ccaf48de8f7f55785645296ffd0073569d9a5071",
            "patch": "@@ -38,7 +38,7 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n       private readonly tsLS: ts.LanguageService, private readonly compiler: NgCompiler,\n       private readonly component: ts.ClassDeclaration, private readonly node: N,\n       private readonly nodeParent: TmplAstNode|AST|null,\n-      private readonly context: TmplAstTemplate|null) {}\n+      private readonly template: TmplAstTemplate|null) {}\n \n   /**\n    * Analogue for `ts.LanguageService.getCompletionsAtPosition`.\n@@ -185,7 +185,8 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n       this: PropertyExpressionCompletionBuilder,\n       options: ts.GetCompletionsAtPositionOptions|\n       undefined): ts.WithMetadata<ts.CompletionInfo>|undefined {\n-    const completions = this.templateTypeChecker.getGlobalCompletions(this.context, this.component);\n+    const completions =\n+        this.templateTypeChecker.getGlobalCompletions(this.template, this.component);\n     if (completions === null) {\n       return undefined;\n     }\n@@ -248,7 +249,8 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n       this: PropertyExpressionCompletionBuilder, entryName: string,\n       formatOptions: ts.FormatCodeOptions|ts.FormatCodeSettings|undefined,\n       preferences: ts.UserPreferences|undefined): ts.CompletionEntryDetails|undefined {\n-    const completions = this.templateTypeChecker.getGlobalCompletions(this.context, this.component);\n+    const completions =\n+        this.templateTypeChecker.getGlobalCompletions(this.template, this.component);\n     if (completions === null) {\n       return undefined;\n     }\n@@ -288,7 +290,8 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n    */\n   private getGlobalPropertyExpressionCompletionSymbol(\n       this: PropertyExpressionCompletionBuilder, entryName: string): ts.Symbol|undefined {\n-    const completions = this.templateTypeChecker.getGlobalCompletions(this.context, this.component);\n+    const completions =\n+        this.templateTypeChecker.getGlobalCompletions(this.template, this.component);\n     if (completions === null) {\n       return undefined;\n     }"
        },
        {
            "sha": "e6f66673868f11be52586f74b11c1060ba61ce73",
            "filename": "packages/language-service/ivy/definitions.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/ccaf48de8f7f55785645296ffd0073569d9a5071/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts",
            "raw_url": "https://github.com/angular/angular/raw/ccaf48de8f7f55785645296ffd0073569d9a5071/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts?ref=ccaf48de8f7f55785645296ffd0073569d9a5071",
            "patch": "@@ -226,13 +226,14 @@ export class DefinitionBuilder {\n     if (target === null) {\n       return undefined;\n     }\n-    const {node, parent} = target;\n+    const {nodeInContext, parent} = target;\n \n-    const symbol = this.compiler.getTemplateTypeChecker().getSymbolOfNode(node, component);\n+    const symbol =\n+        this.compiler.getTemplateTypeChecker().getSymbolOfNode(nodeInContext.node, component);\n     if (symbol === null) {\n       return undefined;\n     }\n-    return {node, parent, symbol};\n+    return {node: nodeInContext.node, parent, symbol};\n   }\n }\n "
        },
        {
            "sha": "6e01c8ea041d30c69c93419ec4a8ff73523212dc",
            "filename": "packages/language-service/ivy/language_service.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/ccaf48de8f7f55785645296ffd0073569d9a5071/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "raw_url": "https://github.com/angular/angular/raw/ccaf48de8f7f55785645296ffd0073569d9a5071/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts?ref=ccaf48de8f7f55785645296ffd0073569d9a5071",
            "patch": "@@ -105,7 +105,8 @@ export class LanguageService {\n       return undefined;\n     }\n     const results =\n-        new QuickInfoBuilder(this.tsLS, compiler, templateInfo.component, positionDetails.node)\n+        new QuickInfoBuilder(\n+            this.tsLS, compiler, templateInfo.component, positionDetails.nodeInContext.node)\n             .get();\n     this.compilerFactory.registerLastKnownProgram();\n     return results;\n@@ -131,8 +132,8 @@ export class LanguageService {\n       return null;\n     }\n     return new CompletionBuilder(\n-        this.tsLS, compiler, templateInfo.component, positionDetails.node, positionDetails.parent,\n-        positionDetails.context);\n+        this.tsLS, compiler, templateInfo.component, positionDetails.nodeInContext.node,\n+        positionDetails.parent, positionDetails.template);\n   }\n \n   getCompletionsAtPosition("
        },
        {
            "sha": "605cd7b7673a082ab663aa360f69843eec5ace17",
            "filename": "packages/language-service/ivy/references.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/ccaf48de8f7f55785645296ffd0073569d9a5071/packages%2Flanguage-service%2Fivy%2Freferences.ts",
            "raw_url": "https://github.com/angular/angular/raw/ccaf48de8f7f55785645296ffd0073569d9a5071/packages%2Flanguage-service%2Fivy%2Freferences.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Freferences.ts?ref=ccaf48de8f7f55785645296ffd0073569d9a5071",
            "patch": "@@ -37,8 +37,10 @@ export class ReferenceBuilder {\n       return undefined;\n     }\n \n+    const node = positionDetails.nodeInContext.node;\n+\n     // Get the information about the TCB at the template position.\n-    const symbol = this.ttc.getSymbolOfNode(positionDetails.node, component);\n+    const symbol = this.ttc.getSymbolOfNode(node, component);\n     if (symbol === null) {\n       return undefined;\n     }\n@@ -56,12 +58,11 @@ export class ReferenceBuilder {\n         // Dom bindings aren't currently type-checked (see `checkTypeOfDomBindings`) so they don't\n         // have a shim location. This means we can't match dom bindings to their lib.dom reference,\n         // but we can still see if they match to a directive.\n-        if (!(positionDetails.node instanceof TmplAstTextAttribute) &&\n-            !(positionDetails.node instanceof TmplAstBoundAttribute)) {\n+        if (!(node instanceof TmplAstTextAttribute) && !(node instanceof TmplAstBoundAttribute)) {\n           return undefined;\n         }\n         const directives = getDirectiveMatchesForAttribute(\n-            positionDetails.node.name, symbol.host.templateNode, symbol.host.directives);\n+            node.name, symbol.host.templateNode, symbol.host.directives);\n         return this.getReferencesForDirectives(directives);\n       }\n       case SymbolKind.Reference: {\n@@ -71,7 +72,7 @@ export class ReferenceBuilder {\n       case SymbolKind.Variable: {\n         const {positionInShimFile: initializerPosition, shimPath} = symbol.initializerLocation;\n         const localVarPosition = symbol.localVarLocation.positionInShimFile;\n-        const templateNode = positionDetails.node;\n+        const templateNode = positionDetails.nodeInContext.node;\n \n         if ((templateNode instanceof TmplAstVariable)) {\n           if (templateNode.valueSpan !== undefined && isWithin(position, templateNode.valueSpan)) {"
        },
        {
            "sha": "4209cd00c7b58a402eb9749097ba5c9239789de1",
            "filename": "packages/language-service/ivy/template_target.ts",
            "status": "modified",
            "additions": 90,
            "deletions": 3,
            "changes": 93,
            "blob_url": "https://github.com/angular/angular/blob/ccaf48de8f7f55785645296ffd0073569d9a5071/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "raw_url": "https://github.com/angular/angular/raw/ccaf48de8f7f55785645296ffd0073569d9a5071/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts?ref=ccaf48de8f7f55785645296ffd0073569d9a5071",
            "patch": "@@ -23,20 +23,74 @@ export interface TemplateTarget {\n   /**\n    * The template node (or AST expression) closest to the search position.\n    */\n-  node: t.Node|e.AST;\n+  nodeInContext: TargetNode;\n \n   /**\n    * The `t.Template` which contains the found node or expression (or `null` if in the root\n    * template).\n    */\n-  context: t.Template|null;\n+  template: t.Template|null;\n \n   /**\n    * The immediate parent node of the targeted node.\n    */\n   parent: t.Node|e.AST|null;\n }\n \n+/**\n+ * A node targeted at a given position in the template, including potential contextual information\n+ * about the specific aspect of the node being referenced.\n+ *\n+ * Some nodes have multiple interior contexts. For example, `t.Element` nodes have both a tag name\n+ * as well as a body, and a given position definitively points to one or the other. `TargetNode`\n+ * captures the node itself, as well as this additional contextual disambiguation.\n+ */\n+export type TargetNode = RawExpression|RawTemplateNode|ElementInBodyContext|ElementInTagContext;\n+\n+/**\n+ * Differentiates the various kinds of `TargetNode`s.\n+ */\n+export enum TargetNodeKind {\n+  RawExpression,\n+  RawTemplateNode,\n+  ElementInTagContext,\n+  ElementInBodyContext,\n+}\n+\n+/**\n+ * An `e.AST` expression that's targeted at a given position, with no additional context.\n+ */\n+export interface RawExpression {\n+  kind: TargetNodeKind.RawExpression;\n+  node: e.AST;\n+}\n+\n+/**\n+ * A `t.Node` template node that's targeted at a given position, with no additional context.\n+ */\n+export interface RawTemplateNode {\n+  kind: TargetNodeKind.RawTemplateNode;\n+  node: t.Node;\n+}\n+\n+/**\n+ * A `t.Element` (or `t.Template`) element node that's targeted, where the given position is within\n+ * the tag name.\n+ */\n+export interface ElementInTagContext {\n+  kind: TargetNodeKind.ElementInTagContext;\n+  node: t.Element|t.Template;\n+}\n+\n+/**\n+ * A `t.Element` (or `t.Template`) element node that's targeted, where the given position is within\n+ * the element body.\n+ */\n+export interface ElementInBodyContext {\n+  kind: TargetNodeKind.ElementInBodyContext;\n+  node: t.Element|t.Template;\n+}\n+\n /**\n  * Return the template AST node or expression AST node that most accurately\n  * represents the node at the specified cursor `position`.\n@@ -77,7 +131,40 @@ export function getTargetAtPosition(template: t.Node[], position: number): Templ\n     parent = path[path.length - 2];\n   }\n \n-  return {position, node: candidate, context, parent};\n+  // Given the candidate node, determine the full targeted context.\n+  let nodeInContext: TargetNode;\n+  if (candidate instanceof e.AST) {\n+    nodeInContext = {\n+      kind: TargetNodeKind.RawExpression,\n+      node: candidate,\n+    };\n+  } else if (candidate instanceof t.Element) {\n+    // Elements have two contexts: the tag context (position is within the element tag) or the\n+    // element body context (position is outside of the tag name, but still in the element).\n+\n+    // Calculate the end of the element tag name. Any position beyond this is in the element body.\n+    const tagEndPos =\n+        candidate.sourceSpan.start.offset + 1 /* '<' element open */ + candidate.name.length;\n+    if (position > tagEndPos) {\n+      // Position is within the element body\n+      nodeInContext = {\n+        kind: TargetNodeKind.ElementInBodyContext,\n+        node: candidate,\n+      };\n+    } else {\n+      nodeInContext = {\n+        kind: TargetNodeKind.ElementInTagContext,\n+        node: candidate,\n+      };\n+    }\n+  } else {\n+    nodeInContext = {\n+      kind: TargetNodeKind.RawTemplateNode,\n+      node: candidate,\n+    };\n+  }\n+\n+  return {position, nodeInContext, template: context, parent};\n }\n \n /**"
        },
        {
            "sha": "9fe85fcbb0ecf9306ef5ef6648ec7d77976f7cfa",
            "filename": "packages/language-service/ivy/test/legacy/template_target_spec.ts",
            "status": "modified",
            "additions": 155,
            "deletions": 71,
            "changes": 226,
            "blob_url": "https://github.com/angular/angular/blob/ccaf48de8f7f55785645296ffd0073569d9a5071/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/ccaf48de8f7f55785645296ffd0073569d9a5071/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts?ref=ccaf48de8f7f55785645296ffd0073569d9a5071",
            "patch": "@@ -10,7 +10,7 @@ import {ParseError, parseTemplate} from '@angular/compiler';\n import * as e from '@angular/compiler/src/expression_parser/ast';  // e for expression AST\n import * as t from '@angular/compiler/src/render3/r3_ast';         // t for template AST\n \n-import {getTargetAtPosition} from '../../template_target';\n+import {getTargetAtPosition, TargetNodeKind} from '../../template_target';\n import {isExpressionNode, isTemplateNode} from '../../utils';\n \n interface ParseResult {\n@@ -36,47 +36,53 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate element in opening tag', () => {\n     const {errors, nodes, position} = parse(`<di¦v></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate element in closing tag', () => {\n     const {errors, nodes, position} = parse(`<div></di¦v>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate element when cursor is at the beginning', () => {\n     const {errors, nodes, position} = parse(`<¦div></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate element when cursor is at the end', () => {\n     const {errors, nodes, position} = parse(`<div¦></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate attribute key', () => {\n     const {errors, nodes, position} = parse(`<div cla¦ss=\"foo\"></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.TextAttribute);\n   });\n \n   it('should locate attribute value', () => {\n     const {errors, nodes, position} = parse(`<div class=\"fo¦o\"></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     // TODO: Note that we do not have the ability to detect the RHS (yet)\n     expect(node).toBeInstanceOf(t.TextAttribute);\n@@ -85,15 +91,17 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate bound attribute key', () => {\n     const {errors, nodes, position} = parse(`<test-cmp [fo¦o]=\"bar\"></test-cmp>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n   });\n \n   it('should locate bound attribute value', () => {\n     const {errors, nodes, position} = parse(`<test-cmp [foo]=\"b¦ar\"></test-cmp>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n@@ -108,23 +116,26 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate bound event key', () => {\n     const {errors, nodes, position} = parse(`<test-cmp (fo¦o)=\"bar()\"></test-cmp>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundEvent);\n   });\n \n   it('should locate bound event value', () => {\n     const {errors, nodes, position} = parse(`<test-cmp (foo)=\"b¦ar()\"></test-cmp>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.MethodCall);\n   });\n \n   it('should locate element children', () => {\n     const {errors, nodes, position} = parse(`<div><sp¦an></span></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n     expect((node as t.Element).name).toBe('span');\n@@ -133,39 +144,44 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate element reference', () => {\n     const {errors, nodes, position} = parse(`<div #my¦div></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n   });\n \n   it('should locate template text attribute', () => {\n     const {errors, nodes, position} = parse(`<ng-template ng¦If></ng-template>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.TextAttribute);\n   });\n \n   it('should locate template bound attribute key', () => {\n     const {errors, nodes, position} = parse(`<ng-template [ng¦If]=\"foo\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n   });\n \n   it('should locate template bound attribute value', () => {\n     const {errors, nodes, position} = parse(`<ng-template [ngIf]=\"f¦oo\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n \n   it('should locate template bound attribute key in two-way binding', () => {\n     const {errors, nodes, position} = parse(`<ng-template [(f¦oo)]=\"bar\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n     expect((node as t.BoundAttribute).name).toBe('foo');\n@@ -174,7 +190,8 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate template bound attribute value in two-way binding', () => {\n     const {errors, nodes, position} = parse(`<ng-template [(foo)]=\"b¦ar\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('bar');\n@@ -183,30 +200,34 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate template bound event key', () => {\n     const {errors, nodes, position} = parse(`<ng-template (cl¦ick)=\"foo()\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundEvent);\n   });\n \n   it('should locate template bound event value', () => {\n     const {errors, nodes, position} = parse(`<ng-template (click)=\"f¦oo()\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(node).toBeInstanceOf(e.MethodCall);\n   });\n \n   it('should locate template attribute key', () => {\n     const {errors, nodes, position} = parse(`<ng-template i¦d=\"foo\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.TextAttribute);\n   });\n \n   it('should locate template attribute value', () => {\n     const {errors, nodes, position} = parse(`<ng-template id=\"f¦oo\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     // TODO: Note that we do not have the ability to detect the RHS (yet)\n     expect(node).toBeInstanceOf(t.TextAttribute);\n@@ -215,7 +236,8 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate template reference key via the # notation', () => {\n     const {errors, nodes, position} = parse(`<ng-template #f¦oo></ng-template>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n     expect((node as t.Reference).name).toBe('foo');\n@@ -224,7 +246,8 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate template reference key via the ref- notation', () => {\n     const {errors, nodes, position} = parse(`<ng-template ref-fo¦o></ng-template>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n     expect((node as t.Reference).name).toBe('foo');\n@@ -233,7 +256,8 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate template reference value via the # notation', () => {\n     const {errors, nodes, position} = parse(`<ng-template #foo=\"export¦As\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n     expect((node as t.Reference).value).toBe('exportAs');\n@@ -243,7 +267,8 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate template reference value via the ref- notation', () => {\n     const {errors, nodes, position} = parse(`<ng-template ref-foo=\"export¦As\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n     expect((node as t.Reference).value).toBe('exportAs');\n@@ -253,47 +278,53 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate template variable key', () => {\n     const {errors, nodes, position} = parse(`<ng-template let-f¦oo=\"bar\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);\n   });\n \n   it('should locate template variable value', () => {\n     const {errors, nodes, position} = parse(`<ng-template let-foo=\"b¦ar\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);\n   });\n \n   it('should locate template children', () => {\n     const {errors, nodes, position} = parse(`<ng-template><d¦iv></div></ng-template>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate ng-content', () => {\n     const {errors, nodes, position} = parse(`<ng-co¦ntent></ng-content>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Content);\n   });\n \n   it('should locate ng-content attribute key', () => {\n     const {errors, nodes, position} = parse('<ng-content cla¦ss=\"red\"></ng-content>');\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.TextAttribute);\n   });\n \n   it('should locate ng-content attribute value', () => {\n     const {errors, nodes, position} = parse('<ng-content class=\"r¦ed\"></ng-content>');\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     // TODO: Note that we do not have the ability to detect the RHS (yet)\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.TextAttribute);\n@@ -302,15 +333,17 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should not locate implicit receiver', () => {\n     const {errors, nodes, position} = parse(`<div [foo]=\"¦bar\"></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n \n   it('should locate bound attribute key in two-way binding', () => {\n     const {errors, nodes, position} = parse(`<cmp [(f¦oo)]=\"bar\"></cmp>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n     expect((node as t.BoundAttribute).name).toBe('foo');\n@@ -319,7 +352,8 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate bound attribute value in two-way binding', () => {\n     const {errors, nodes, position} = parse(`<cmp [(foo)]=\"b¦ar\"></cmp>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('bar');\n@@ -328,7 +362,8 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate switch value in ICUs', () => {\n     const {errors, nodes, position} = parse(`<span i18n>{sw¦itch, plural, other {text}}\"></span>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('switch');\n@@ -338,7 +373,8 @@ describe('getTargetAtPosition for template AST', () => {\n     const {errors, nodes, position} = parse(\n         `<span i18n>{expr, plural, other { {ne¦sted, plural, =1 { {{nestedInterpolation}} }} }}\"></span>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('nested');\n@@ -348,7 +384,8 @@ describe('getTargetAtPosition for template AST', () => {\n     const {errors, nodes, position} =\n         parse(`<span i18n>{expr, plural, other { {{ i¦nterpolation }} }}\"></span>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('interpolation');\n@@ -358,7 +395,8 @@ describe('getTargetAtPosition for template AST', () => {\n     const {errors, nodes, position} = parse(\n         `<span i18n>{expr, plural, other { {nested, plural, =1 { {{n¦estedInterpolation}} }} }}\"></span>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('nestedInterpolation');\n@@ -369,7 +407,8 @@ describe('getTargetAtPosition for expression AST', () => {\n   it('should not locate implicit receiver', () => {\n     const {errors, nodes, position} = parse(`{{ ¦title }}`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('title');\n@@ -378,7 +417,8 @@ describe('getTargetAtPosition for expression AST', () => {\n   it('should locate property read', () => {\n     const {errors, nodes, position} = parse(`{{ ti¦tle }}`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('title');\n@@ -387,7 +427,8 @@ describe('getTargetAtPosition for expression AST', () => {\n   it('should locate safe property read', () => {\n     const {errors, nodes, position} = parse(`{{ foo?¦.bar }}`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.SafePropertyRead);\n     expect((node as e.SafePropertyRead).name).toBe('bar');\n@@ -396,39 +437,44 @@ describe('getTargetAtPosition for expression AST', () => {\n   it('should locate keyed read', () => {\n     const {errors, nodes, position} = parse(`{{ foo['bar']¦ }}`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.KeyedRead);\n   });\n \n   it('should locate property write', () => {\n     const {errors, nodes, position} = parse(`<div (foo)=\"b¦ar=$event\"></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyWrite);\n   });\n \n   it('should locate keyed write', () => {\n     const {errors, nodes, position} = parse(`<div (foo)=\"bar['baz']¦=$event\"></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.KeyedWrite);\n   });\n \n   it('should locate binary', () => {\n     const {errors, nodes, position} = parse(`{{ 1 +¦ 2 }}`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.Binary);\n   });\n \n   it('should locate binding pipe with an identifier', () => {\n     const {errors, nodes, position} = parse(`{{ title | p¦ }}`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.BindingPipe);\n   });\n@@ -439,7 +485,8 @@ describe('getTargetAtPosition for expression AST', () => {\n     expect(errors![0].toString())\n         .toContain(\n             'Unexpected end of input, expected identifier or keyword at the end of the expression');\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     // TODO: We want this to be a BindingPipe.\n     expect(node).toBeInstanceOf(e.Interpolation);\n@@ -451,7 +498,7 @@ describe('getTargetAtPosition for expression AST', () => {\n          // parser throws an error. This case is important for autocomplete.\n          // const {errors, nodes, position} = parse(`{{ title | ¦ }}`);\n          // expect(errors).toBe(null);\n-         // const {node} = findNodeAtPosition(nodes, position)!;\n+         // const {nodeInContext} = findNodeAtPosition(nodes, position)!;\n          // expect(isExpressionNode(node!)).toBe(true);\n          // expect(node).toBeInstanceOf(e.BindingPipe);\n      });\n@@ -460,23 +507,26 @@ describe('getTargetAtPosition for expression AST', () => {\n   it('should locate method call', () => {\n     const {errors, nodes, position} = parse(`{{ title.toString(¦) }}`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.MethodCall);\n   });\n \n   it('should locate safe method call', () => {\n     const {errors, nodes, position} = parse(`{{ title?.toString(¦) }}`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.SafeMethodCall);\n   });\n \n   it('should locate literal primitive in interpolation', () => {\n     const {errors, nodes, position} = parse(`{{ title.indexOf('t¦') }}`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.LiteralPrimitive);\n     expect((node as e.LiteralPrimitive).value).toBe('t');\n@@ -485,7 +535,8 @@ describe('getTargetAtPosition for expression AST', () => {\n   it('should locate literal primitive in binding', () => {\n     const {errors, nodes, position} = parse(`<div [id]=\"'t¦'\"></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.LiteralPrimitive);\n     expect((node as e.LiteralPrimitive).value).toBe('t');\n@@ -494,31 +545,35 @@ describe('getTargetAtPosition for expression AST', () => {\n   it('should locate empty expression', () => {\n     const {errors, nodes, position} = parse(`<div [id]=\"¦\"></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.EmptyExpr);\n   });\n \n   it('should locate literal array', () => {\n     const {errors, nodes, position} = parse(`{{ [1, 2,¦ 3] }}`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.LiteralArray);\n   });\n \n   it('should locate literal map', () => {\n     const {errors, nodes, position} = parse(`{{ { hello:¦ \"world\" } }}`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.LiteralMap);\n   });\n \n   it('should locate conditional', () => {\n     const {errors, nodes, position} = parse(`{{ cond ?¦ true : false }}`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.Conditional);\n   });\n@@ -528,15 +583,17 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate template key', () => {\n     const {errors, nodes, position} = parse(`<div *ng¦If=\"foo\"></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n   });\n \n   it('should locate template value', () => {\n     const {errors, nodes, position} = parse(`<div *ngIf=\"f¦oo\"></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n@@ -546,7 +603,8 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n     // ngFor is a text attribute because the desugared form is\n     // <ng-template ngFor let-item [ngForOf]=\"items\">\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBeTrue();\n     expect(node).toBeInstanceOf(t.TextAttribute);\n     expect((node as t.TextAttribute).name).toBe('ngFor');\n@@ -562,7 +620,8 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate let variable', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let i¦tem of items\"></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);\n     expect((node as t.Variable).name).toBe('item');\n@@ -571,7 +630,8 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate bound attribute key', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let item o¦f items\"></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n     expect((node as t.BoundAttribute).name).toBe('ngForOf');\n@@ -580,8 +640,9 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate bound attribute key when cursor is at the start', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let item ¦of items\"></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n-    expect(isTemplateNode(node!)).toBe(true);\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const node = nodeInContext.node;\n+    expect(isTemplateNode(node)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n     expect((node as t.BoundAttribute).name).toBe('ngForOf');\n   });\n@@ -590,7 +651,8 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n     const {errors, nodes, position} =\n         parse(`<div *ngFor=\"let item of items; trac¦kBy: trackByFn\"></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n     expect((node as t.BoundAttribute).name).toBe('ngForTrackBy');\n@@ -603,7 +665,8 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n     const {errors, nodes, position} =\n         parse(`<div *ngFor=\"let item o¦f items; trackBy: trackByFn\"></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n     expect((node as t.BoundAttribute).name).toBe('ngForOf');\n@@ -612,7 +675,8 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate bound attribute value', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let item of it¦ems\"></div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('items');\n@@ -621,7 +685,8 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate template children', () => {\n     const {errors, nodes, position} = parse(`<di¦v *ngIf></div>`);\n     expect(errors).toBe(null);\n-    const {node, context} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext, template: context} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n     expect((node as t.Element).name).toBe('div');\n@@ -634,15 +699,17 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n         {{ i¦ }}\n       </div>`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n \n   it('should locate LHS of variable declaration', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let item of items; let i¦=index\">`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);\n     // TODO: Currently there is no way to distinguish LHS from RHS\n@@ -652,10 +719,27 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate RHS of variable declaration', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let item of items; let i=in¦dex\">`);\n     expect(errors).toBe(null);\n-    const {node} = getTargetAtPosition(nodes, position)!;\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    const {node} = nodeInContext;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);\n     // TODO: Currently there is no way to distinguish LHS from RHS\n     expect((node as t.Variable).value).toBe('index');\n   });\n+\n+  it('should locate an element in its tag context', () => {\n+    const {errors, nodes, position} = parse(`<div¦ attr></div>`);\n+    expect(errors).toBe(null);\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    expect(nodeInContext.kind).toBe(TargetNodeKind.ElementInTagContext);\n+    expect(nodeInContext.node).toBeInstanceOf(t.Element);\n+  });\n+\n+  it('should locate an element in its body context', () => {\n+    const {errors, nodes, position} = parse(`<div ¦ attr></div>`);\n+    expect(errors).toBe(null);\n+    const {nodeInContext} = getTargetAtPosition(nodes, position)!;\n+    expect(nodeInContext.kind).toBe(TargetNodeKind.ElementInBodyContext);\n+    expect(nodeInContext.node).toBeInstanceOf(t.Element);\n+  });\n });"
        }
    ],
    "stats": {
        "total": 355,
        "additions": 266,
        "deletions": 89
    }
}