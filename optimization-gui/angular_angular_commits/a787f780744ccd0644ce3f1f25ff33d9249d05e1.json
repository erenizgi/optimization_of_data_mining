{
    "author": "crisbeto",
    "message": "test: clean up internal testing utilities (#42177)\n\nWe have some internal proxies for all of the Jasmine functions, as well as some other helpers. This code hasn't been touched in more than 5 years, it can lead to confusion and it isn't really necessary since the same can be achieved using Jasmine.\n\nThese changes remove most of the code and clean up our existing unit tests.\n\nPR Close #42177",
    "sha": "a787f780744ccd0644ce3f1f25ff33d9249d05e1",
    "files": [
        {
            "sha": "bc3ab5ca3356b9be1ef7b2b2096dd4d87ffa536d",
            "filename": "packages/benchpress/test/metric/multi_metric_spec.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 22,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fmetric%2Fmulti_metric_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fmetric%2Fmulti_metric_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbenchpress%2Ftest%2Fmetric%2Fmulti_metric_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,8 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AsyncTestCompleter, describe, expect, inject, it} from '@angular/core/testing/src/testing_internal';\n-\n import {Injector, Metric, MultiMetric} from '../../index';\n \n (function() {\n@@ -22,29 +20,27 @@ function createMetric(ids: any[]) {\n }\n \n describe('multi metric', () => {\n-  it('should merge descriptions', inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-       createMetric(['m1', 'm2']).then((m) => {\n-         expect(m.describe()).toEqual({'m1': 'describe', 'm2': 'describe'});\n-         async.done();\n-       });\n-     }));\n+  it('should merge descriptions', done => {\n+    createMetric(['m1', 'm2']).then((m) => {\n+      expect(m.describe()).toEqual({'m1': 'describe', 'm2': 'describe'});\n+      done();\n+    });\n+  });\n \n-  it('should merge all beginMeasure calls',\n-     inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-       createMetric(['m1', 'm2']).then((m) => m.beginMeasure()).then((values) => {\n-         expect(values).toEqual(['m1_beginMeasure', 'm2_beginMeasure']);\n-         async.done();\n-       });\n-     }));\n+  it('should merge all beginMeasure calls', done => {\n+    createMetric(['m1', 'm2']).then((m) => m.beginMeasure()).then((values) => {\n+      expect(values).toEqual(['m1_beginMeasure', 'm2_beginMeasure']);\n+      done();\n+    });\n+  });\n \n   [false, true].forEach((restartFlag) => {\n-    it(`should merge all endMeasure calls for restart=${restartFlag}`,\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createMetric(['m1', 'm2']).then((m) => m.endMeasure(restartFlag)).then((values) => {\n-           expect(values).toEqual({'m1': {'restart': restartFlag}, 'm2': {'restart': restartFlag}});\n-           async.done();\n-         });\n-       }));\n+    it(`should merge all endMeasure calls for restart=${restartFlag}`, done => {\n+      createMetric(['m1', 'm2']).then((m) => m.endMeasure(restartFlag)).then((values) => {\n+        expect(values).toEqual({'m1': {'restart': restartFlag}, 'm2': {'restart': restartFlag}});\n+        done();\n+      });\n+    });\n   });\n });\n })();"
        },
        {
            "sha": "b93046ac89d538cb6a5bf857c4230a78a6578392",
            "filename": "packages/benchpress/test/metric/perflog_metric_spec.ts",
            "status": "modified",
            "additions": 456,
            "deletions": 503,
            "changes": 959,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fmetric%2Fperflog_metric_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fmetric%2Fperflog_metric_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbenchpress%2Ftest%2Fmetric%2Fperflog_metric_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -7,7 +7,6 @@\n  */\n \n import {StaticProvider} from '@angular/core';\n-import {AsyncTestCompleter, beforeEach, describe, expect, inject, it} from '@angular/core/testing/src/testing_internal';\n \n import {Injector, Metric, Options, PerfLogEvent, PerfLogFeatures, PerflogMetric, WebDriverExtension} from '../../index';\n import {TraceEventFactory} from '../trace_event_factory';\n@@ -130,152 +129,145 @@ describe('perflog metric', () => {\n   });\n \n   describe('beginMeasure', () => {\n-    it('should not force gc and mark the timeline',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const metric = createMetric([[]], null!);\n-         metric.beginMeasure().then((_) => {\n-           expect(commandLog).toEqual([['timeBegin', 'benchpress0']]);\n-\n-           async.done();\n-         });\n-       }));\n-\n-    it('should force gc and mark the timeline',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const metric = createMetric([[]], null!, {forceGc: true});\n-         metric.beginMeasure().then((_) => {\n-           expect(commandLog).toEqual([['gc'], ['timeBegin', 'benchpress0']]);\n-\n-           async.done();\n-         });\n-       }));\n+    it('should not force gc and mark the timeline', done => {\n+      const metric = createMetric([[]], null!);\n+      metric.beginMeasure().then((_) => {\n+        expect(commandLog).toEqual([['timeBegin', 'benchpress0']]);\n+\n+        done();\n+      });\n+    });\n+\n+    it('should force gc and mark the timeline', done => {\n+      const metric = createMetric([[]], null!, {forceGc: true});\n+      metric.beginMeasure().then((_) => {\n+        expect(commandLog).toEqual([['gc'], ['timeBegin', 'benchpress0']]);\n+\n+        done();\n+      });\n+    });\n   });\n \n   describe('endMeasure', () => {\n-    it('should mark and aggregate events in between the marks',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const events = [[\n-           eventFactory.markStart('benchpress0', 0), eventFactory.start('script', 4),\n-           eventFactory.end('script', 6), eventFactory.markEnd('benchpress0', 10)\n-         ]];\n-         const metric = createMetric(events, null!);\n-         metric.beginMeasure().then((_) => metric.endMeasure(false)).then((data) => {\n-           expect(commandLog).toEqual([\n-             ['timeBegin', 'benchpress0'], ['timeEnd', 'benchpress0', null], 'readPerfLog'\n-           ]);\n-           expect(data['scriptTime']).toBe(2);\n-\n-           async.done();\n-         });\n-       }));\n-\n-    it('should mark and aggregate events since navigationStart',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const events = [[\n-           eventFactory.markStart('benchpress0', 0), eventFactory.start('script', 4),\n-           eventFactory.end('script', 6), eventFactory.instant('navigationStart', 7),\n-           eventFactory.start('script', 8), eventFactory.end('script', 9),\n-           eventFactory.markEnd('benchpress0', 10)\n-         ]];\n-         const metric = createMetric(events, null!);\n-         metric.beginMeasure().then((_) => metric.endMeasure(false)).then((data) => {\n-           expect(data['scriptTime']).toBe(1);\n-\n-           async.done();\n-         });\n-       }));\n-\n-    it('should ignore navigationStart if ignoreNavigation is set',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const events = [[\n-           eventFactory.markStart('benchpress0', 0), eventFactory.start('script', 4),\n-           eventFactory.end('script', 6), eventFactory.instant('navigationStart', 7),\n-           eventFactory.start('script', 8), eventFactory.end('script', 9),\n-           eventFactory.markEnd('benchpress0', 10)\n-         ]];\n-         const metric = createMetric(events, null!, {ignoreNavigation: true});\n-         metric.beginMeasure().then((_) => metric.endMeasure(false)).then((data) => {\n-           expect(data['scriptTime']).toBe(3);\n-\n-           async.done();\n-         });\n-       }));\n-\n-    it('should restart timing', inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const events = [\n-           [\n-             eventFactory.markStart('benchpress0', 0),\n-             eventFactory.markEnd('benchpress0', 1),\n-             eventFactory.markStart('benchpress1', 2),\n-           ],\n-           [eventFactory.markEnd('benchpress1', 3)]\n-         ];\n-         const metric = createMetric(events, null!);\n-         metric.beginMeasure()\n-             .then((_) => metric.endMeasure(true))\n-             .then((_) => metric.endMeasure(true))\n-             .then((_) => {\n-               expect(commandLog).toEqual([\n-                 ['timeBegin', 'benchpress0'], ['timeEnd', 'benchpress0', 'benchpress1'],\n-                 'readPerfLog', ['timeEnd', 'benchpress1', 'benchpress2'], 'readPerfLog'\n-               ]);\n-\n-               async.done();\n-             });\n-       }));\n-\n-    it('should loop and aggregate until the end mark is present',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const events = [\n-           [eventFactory.markStart('benchpress0', 0), eventFactory.start('script', 1)],\n-           [eventFactory.end('script', 2)],\n-           [\n-             eventFactory.start('script', 3), eventFactory.end('script', 5),\n-             eventFactory.markEnd('benchpress0', 10)\n-           ]\n-         ];\n-         const metric = createMetric(events, null!);\n-         metric.beginMeasure().then((_) => metric.endMeasure(false)).then((data) => {\n-           expect(commandLog).toEqual([\n-             ['timeBegin', 'benchpress0'], ['timeEnd', 'benchpress0', null], 'readPerfLog',\n-             ['setTimeout', 100], 'readPerfLog', ['setTimeout', 100], 'readPerfLog'\n-           ]);\n-           expect(data['scriptTime']).toBe(3);\n-\n-           async.done();\n-         });\n-       }));\n-\n-    it('should store events after the end mark for the next call',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const events = [\n-           [\n-             eventFactory.markStart('benchpress0', 0), eventFactory.markEnd('benchpress0', 1),\n-             eventFactory.markStart('benchpress1', 1), eventFactory.start('script', 1),\n-             eventFactory.end('script', 2)\n-           ],\n-           [\n-             eventFactory.start('script', 3), eventFactory.end('script', 5),\n-             eventFactory.markEnd('benchpress1', 6)\n-           ]\n-         ];\n-         const metric = createMetric(events, null!);\n-         metric.beginMeasure()\n-             .then((_) => metric.endMeasure(true))\n-             .then((data) => {\n-               expect(data['scriptTime']).toBe(0);\n-               return metric.endMeasure(true);\n-             })\n-             .then((data) => {\n-               expect(commandLog).toEqual([\n-                 ['timeBegin', 'benchpress0'], ['timeEnd', 'benchpress0', 'benchpress1'],\n-                 'readPerfLog', ['timeEnd', 'benchpress1', 'benchpress2'], 'readPerfLog'\n-               ]);\n-               expect(data['scriptTime']).toBe(3);\n-\n-               async.done();\n-             });\n-       }));\n+    it('should mark and aggregate events in between the marks', done => {\n+      const events = [[\n+        eventFactory.markStart('benchpress0', 0), eventFactory.start('script', 4),\n+        eventFactory.end('script', 6), eventFactory.markEnd('benchpress0', 10)\n+      ]];\n+      const metric = createMetric(events, null!);\n+      metric.beginMeasure().then((_) => metric.endMeasure(false)).then((data) => {\n+        expect(commandLog).toEqual([\n+          ['timeBegin', 'benchpress0'], ['timeEnd', 'benchpress0', null], 'readPerfLog'\n+        ]);\n+        expect(data['scriptTime']).toBe(2);\n+\n+        done();\n+      });\n+    });\n+\n+    it('should mark and aggregate events since navigationStart', done => {\n+      const events = [[\n+        eventFactory.markStart('benchpress0', 0), eventFactory.start('script', 4),\n+        eventFactory.end('script', 6), eventFactory.instant('navigationStart', 7),\n+        eventFactory.start('script', 8), eventFactory.end('script', 9),\n+        eventFactory.markEnd('benchpress0', 10)\n+      ]];\n+      const metric = createMetric(events, null!);\n+      metric.beginMeasure().then((_) => metric.endMeasure(false)).then((data) => {\n+        expect(data['scriptTime']).toBe(1);\n+\n+        done();\n+      });\n+    });\n+\n+    it('should ignore navigationStart if ignoreNavigation is set', done => {\n+      const events = [[\n+        eventFactory.markStart('benchpress0', 0), eventFactory.start('script', 4),\n+        eventFactory.end('script', 6), eventFactory.instant('navigationStart', 7),\n+        eventFactory.start('script', 8), eventFactory.end('script', 9),\n+        eventFactory.markEnd('benchpress0', 10)\n+      ]];\n+      const metric = createMetric(events, null!, {ignoreNavigation: true});\n+      metric.beginMeasure().then((_) => metric.endMeasure(false)).then((data) => {\n+        expect(data['scriptTime']).toBe(3);\n+\n+        done();\n+      });\n+    });\n+\n+    it('should restart timing', done => {\n+      const events = [\n+        [\n+          eventFactory.markStart('benchpress0', 0),\n+          eventFactory.markEnd('benchpress0', 1),\n+          eventFactory.markStart('benchpress1', 2),\n+        ],\n+        [eventFactory.markEnd('benchpress1', 3)]\n+      ];\n+      const metric = createMetric(events, null!);\n+      metric.beginMeasure()\n+          .then((_) => metric.endMeasure(true))\n+          .then((_) => metric.endMeasure(true))\n+          .then((_) => {\n+            expect(commandLog).toEqual([\n+              ['timeBegin', 'benchpress0'], ['timeEnd', 'benchpress0', 'benchpress1'],\n+              'readPerfLog', ['timeEnd', 'benchpress1', 'benchpress2'], 'readPerfLog'\n+            ]);\n+\n+            done();\n+          });\n+    });\n+\n+    it('should loop and aggregate until the end mark is present', done => {\n+      const events = [\n+        [eventFactory.markStart('benchpress0', 0), eventFactory.start('script', 1)],\n+        [eventFactory.end('script', 2)],\n+        [\n+          eventFactory.start('script', 3), eventFactory.end('script', 5),\n+          eventFactory.markEnd('benchpress0', 10)\n+        ]\n+      ];\n+      const metric = createMetric(events, null!);\n+      metric.beginMeasure().then((_) => metric.endMeasure(false)).then((data) => {\n+        expect(commandLog).toEqual([\n+          ['timeBegin', 'benchpress0'], ['timeEnd', 'benchpress0', null], 'readPerfLog',\n+          ['setTimeout', 100], 'readPerfLog', ['setTimeout', 100], 'readPerfLog'\n+        ]);\n+        expect(data['scriptTime']).toBe(3);\n+\n+        done();\n+      });\n+    });\n+\n+    it('should store events after the end mark for the next call', done => {\n+      const events = [\n+        [\n+          eventFactory.markStart('benchpress0', 0), eventFactory.markEnd('benchpress0', 1),\n+          eventFactory.markStart('benchpress1', 1), eventFactory.start('script', 1),\n+          eventFactory.end('script', 2)\n+        ],\n+        [\n+          eventFactory.start('script', 3), eventFactory.end('script', 5),\n+          eventFactory.markEnd('benchpress1', 6)\n+        ]\n+      ];\n+      const metric = createMetric(events, null!);\n+      metric.beginMeasure()\n+          .then((_) => metric.endMeasure(true))\n+          .then((data) => {\n+            expect(data['scriptTime']).toBe(0);\n+            return metric.endMeasure(true);\n+          })\n+          .then((data) => {\n+            expect(commandLog).toEqual([\n+              ['timeBegin', 'benchpress0'], ['timeEnd', 'benchpress0', 'benchpress1'],\n+              'readPerfLog', ['timeEnd', 'benchpress1', 'benchpress2'], 'readPerfLog'\n+            ]);\n+            expect(data['scriptTime']).toBe(3);\n+\n+            done();\n+          });\n+    });\n \n     describe('with forced gc', () => {\n       let events: PerfLogEvent[][];\n@@ -290,29 +282,28 @@ describe('perflog metric', () => {\n         ]];\n       });\n \n-      it('should measure forced gc', inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           const metric = createMetric(events, null!, {forceGc: true});\n-           metric.beginMeasure().then((_) => metric.endMeasure(false)).then((data) => {\n-             expect(commandLog).toEqual([\n-               ['gc'], ['timeBegin', 'benchpress0'], ['timeEnd', 'benchpress0', 'benchpress1'],\n-               'readPerfLog', ['gc'], ['timeEnd', 'benchpress1', null], 'readPerfLog'\n-             ]);\n-             expect(data['forcedGcTime']).toBe(3);\n-             expect(data['forcedGcAmount']).toBe(1.5);\n-\n-             async.done();\n-           });\n-         }));\n-\n-      it('should restart after the forced gc if needed',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           const metric = createMetric(events, null!, {forceGc: true});\n-           metric.beginMeasure().then((_) => metric.endMeasure(true)).then((data) => {\n-             expect(commandLog[5]).toEqual(['timeEnd', 'benchpress1', 'benchpress2']);\n-\n-             async.done();\n-           });\n-         }));\n+      it('should measure forced gc', done => {\n+        const metric = createMetric(events, null!, {forceGc: true});\n+        metric.beginMeasure().then((_) => metric.endMeasure(false)).then((data) => {\n+          expect(commandLog).toEqual([\n+            ['gc'], ['timeBegin', 'benchpress0'], ['timeEnd', 'benchpress0', 'benchpress1'],\n+            'readPerfLog', ['gc'], ['timeEnd', 'benchpress1', null], 'readPerfLog'\n+          ]);\n+          expect(data['forcedGcTime']).toBe(3);\n+          expect(data['forcedGcAmount']).toBe(1.5);\n+\n+          done();\n+        });\n+      });\n+\n+      it('should restart after the forced gc if needed', done => {\n+        const metric = createMetric(events, null!, {forceGc: true});\n+        metric.beginMeasure().then((_) => metric.endMeasure(true)).then((data) => {\n+          expect(commandLog[5]).toEqual(['timeEnd', 'benchpress1', 'benchpress2']);\n+\n+          done();\n+        });\n+      });\n     });\n   });\n \n@@ -335,352 +326,314 @@ describe('perflog metric', () => {\n     }\n \n     describe('frame metrics', () => {\n-      it('should calculate mean frame time',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           aggregate(\n-               [\n-                 eventFactory.markStart('frameCapture', 0), eventFactory.instant('frame', 1),\n-                 eventFactory.instant('frame', 3), eventFactory.instant('frame', 4),\n-                 eventFactory.markEnd('frameCapture', 5)\n-               ],\n-               {captureFrames: true})\n-               .then((data) => {\n-                 expect(data['frameTime.mean']).toBe(((3 - 1) + (4 - 3)) / 2);\n-                 async.done();\n-               });\n-         }));\n-\n-      it('should throw if no start event',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           aggregate([eventFactory.instant('frame', 4), eventFactory.markEnd('frameCapture', 5)], {\n-             captureFrames: true\n-           }).catch((err): any => {\n-             expect(() => {\n-               throw err;\n-             }).toThrowError('missing start event for frame capture');\n-             async.done();\n-           });\n-         }));\n-\n-      it('should throw if no end event',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           aggregate(\n-               [eventFactory.markStart('frameCapture', 3), eventFactory.instant('frame', 4)],\n-               {captureFrames: true})\n-               .catch((err): any => {\n-                 expect(() => {\n-                   throw err;\n-                 }).toThrowError('missing end event for frame capture');\n-                 async.done();\n-               });\n-         }));\n-\n-      it('should throw if trying to capture twice',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           aggregate(\n-               [\n-                 eventFactory.markStart('frameCapture', 3),\n-                 eventFactory.markStart('frameCapture', 4)\n-               ],\n-               {captureFrames: true})\n-               .catch((err): any => {\n-                 expect(() => {\n-                   throw err;\n-                 }).toThrowError('can capture frames only once per benchmark run');\n-                 async.done();\n-               });\n-         }));\n-\n-      it('should throw if trying to capture when frame capture is disabled',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           aggregate([eventFactory.markStart('frameCapture', 3)]).catch((err) => {\n-             expect(() => {\n-               throw err;\n-             })\n-                 .toThrowError(\n-                     'found start event for frame capture, but frame capture was not requested in benchpress');\n-             async.done();\n-             return null;\n-           });\n-         }));\n-\n-      it('should throw if frame capture is enabled, but nothing is captured',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           aggregate([], {captureFrames: true}).catch((err): any => {\n-             expect(() => {\n-               throw err;\n-             }).toThrowError('frame capture requested in benchpress, but no start event was found');\n-             async.done();\n-           });\n-         }));\n-\n-      it('should calculate best and worst frame time',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           aggregate(\n-               [\n-                 eventFactory.markStart('frameCapture', 0), eventFactory.instant('frame', 1),\n-                 eventFactory.instant('frame', 9), eventFactory.instant('frame', 15),\n-                 eventFactory.instant('frame', 18), eventFactory.instant('frame', 28),\n-                 eventFactory.instant('frame', 32), eventFactory.markEnd('frameCapture', 10)\n-               ],\n-               {captureFrames: true})\n-               .then((data) => {\n-                 expect(data['frameTime.worst']).toBe(10);\n-                 expect(data['frameTime.best']).toBe(3);\n-                 async.done();\n-               });\n-         }));\n-\n-      it('should calculate percentage of smoothness to be good',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           aggregate(\n-               [\n-                 eventFactory.markStart('frameCapture', 0), eventFactory.instant('frame', 1),\n-                 eventFactory.instant('frame', 2), eventFactory.instant('frame', 3),\n-                 eventFactory.markEnd('frameCapture', 4)\n-               ],\n-               {captureFrames: true})\n-               .then((data) => {\n-                 expect(data['frameTime.smooth']).toBe(1.0);\n-                 async.done();\n-               });\n-         }));\n-\n-      it('should calculate percentage of smoothness to be bad',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           aggregate(\n-               [\n-                 eventFactory.markStart('frameCapture', 0), eventFactory.instant('frame', 1),\n-                 eventFactory.instant('frame', 2), eventFactory.instant('frame', 22),\n-                 eventFactory.instant('frame', 23), eventFactory.instant('frame', 24),\n-                 eventFactory.markEnd('frameCapture', 4)\n-               ],\n-               {captureFrames: true})\n-               .then((data) => {\n-                 expect(data['frameTime.smooth']).toBe(0.75);\n-                 async.done();\n-               });\n-         }));\n+      it('should calculate mean frame time', done => {\n+        aggregate(\n+            [\n+              eventFactory.markStart('frameCapture', 0), eventFactory.instant('frame', 1),\n+              eventFactory.instant('frame', 3), eventFactory.instant('frame', 4),\n+              eventFactory.markEnd('frameCapture', 5)\n+            ],\n+            {captureFrames: true})\n+            .then((data) => {\n+              expect(data['frameTime.mean']).toBe(((3 - 1) + (4 - 3)) / 2);\n+              done();\n+            });\n+      });\n+\n+      it('should throw if no start event', done => {\n+        aggregate([eventFactory.instant('frame', 4), eventFactory.markEnd('frameCapture', 5)], {\n+          captureFrames: true\n+        }).catch((err): any => {\n+          expect(() => {\n+            throw err;\n+          }).toThrowError('missing start event for frame capture');\n+          done();\n+        });\n+      });\n+\n+      it('should throw if no end event', done => {\n+        aggregate([eventFactory.markStart('frameCapture', 3), eventFactory.instant('frame', 4)], {\n+          captureFrames: true\n+        }).catch((err): any => {\n+          expect(() => {\n+            throw err;\n+          }).toThrowError('missing end event for frame capture');\n+          done();\n+        });\n+      });\n+\n+      it('should throw if trying to capture twice', done => {\n+        aggregate(\n+            [eventFactory.markStart('frameCapture', 3), eventFactory.markStart('frameCapture', 4)],\n+            {captureFrames: true})\n+            .catch((err): any => {\n+              expect(() => {\n+                throw err;\n+              }).toThrowError('can capture frames only once per benchmark run');\n+              done();\n+            });\n+      });\n+\n+      it('should throw if trying to capture when frame capture is disabled', done => {\n+        aggregate([eventFactory.markStart('frameCapture', 3)]).catch((err) => {\n+          expect(() => {\n+            throw err;\n+          })\n+              .toThrowError(\n+                  'found start event for frame capture, but frame capture was not requested in benchpress');\n+          done();\n+          return null;\n+        });\n+      });\n+\n+      it('should throw if frame capture is enabled, but nothing is captured', done => {\n+        aggregate([], {captureFrames: true}).catch((err): any => {\n+          expect(() => {\n+            throw err;\n+          }).toThrowError('frame capture requested in benchpress, but no start event was found');\n+          done();\n+        });\n+      });\n+\n+      it('should calculate best and worst frame time', done => {\n+        aggregate(\n+            [\n+              eventFactory.markStart('frameCapture', 0), eventFactory.instant('frame', 1),\n+              eventFactory.instant('frame', 9), eventFactory.instant('frame', 15),\n+              eventFactory.instant('frame', 18), eventFactory.instant('frame', 28),\n+              eventFactory.instant('frame', 32), eventFactory.markEnd('frameCapture', 10)\n+            ],\n+            {captureFrames: true})\n+            .then((data) => {\n+              expect(data['frameTime.worst']).toBe(10);\n+              expect(data['frameTime.best']).toBe(3);\n+              done();\n+            });\n+      });\n+\n+      it('should calculate percentage of smoothness to be good', done => {\n+        aggregate(\n+            [\n+              eventFactory.markStart('frameCapture', 0), eventFactory.instant('frame', 1),\n+              eventFactory.instant('frame', 2), eventFactory.instant('frame', 3),\n+              eventFactory.markEnd('frameCapture', 4)\n+            ],\n+            {captureFrames: true})\n+            .then((data) => {\n+              expect(data['frameTime.smooth']).toBe(1.0);\n+              done();\n+            });\n+      });\n+\n+      it('should calculate percentage of smoothness to be bad', done => {\n+        aggregate(\n+            [\n+              eventFactory.markStart('frameCapture', 0), eventFactory.instant('frame', 1),\n+              eventFactory.instant('frame', 2), eventFactory.instant('frame', 22),\n+              eventFactory.instant('frame', 23), eventFactory.instant('frame', 24),\n+              eventFactory.markEnd('frameCapture', 4)\n+            ],\n+            {captureFrames: true})\n+            .then((data) => {\n+              expect(data['frameTime.smooth']).toBe(0.75);\n+              done();\n+            });\n+      });\n+    });\n+\n+    it('should report a single interval', done => {\n+      aggregate([eventFactory.start('script', 0), eventFactory.end('script', 5)]).then((data) => {\n+        expect(data['scriptTime']).toBe(5);\n+        done();\n+      });\n+    });\n+\n+    it('should sum up multiple intervals', done => {\n+      aggregate([\n+        eventFactory.start('script', 0), eventFactory.end('script', 5),\n+        eventFactory.start('script', 10), eventFactory.end('script', 17)\n+      ]).then((data) => {\n+        expect(data['scriptTime']).toBe(12);\n+        done();\n+      });\n+    });\n+\n+    it('should ignore not started intervals', done => {\n+      aggregate([eventFactory.end('script', 10)]).then((data) => {\n+        expect(data['scriptTime']).toBe(0);\n+        done();\n+      });\n+    });\n+\n+    it('should ignore not ended intervals', done => {\n+      aggregate([eventFactory.start('script', 10)]).then((data) => {\n+        expect(data['scriptTime']).toBe(0);\n+        done();\n+      });\n+    });\n+\n+    it('should ignore nested intervals', done => {\n+      aggregate([\n+        eventFactory.start('script', 0), eventFactory.start('script', 5),\n+        eventFactory.end('script', 10), eventFactory.end('script', 17)\n+      ]).then((data) => {\n+        expect(data['scriptTime']).toBe(17);\n+        done();\n+      });\n+    });\n+\n+    it('should ignore events from different processed as the start mark', done => {\n+      const otherProcessEventFactory = new TraceEventFactory('timeline', 'pid1');\n+      const metric = createMetric(\n+          [[\n+            eventFactory.markStart('benchpress0', 0), eventFactory.start('script', 0, null),\n+            eventFactory.end('script', 5, null), otherProcessEventFactory.start('script', 10, null),\n+            otherProcessEventFactory.end('script', 17, null),\n+            eventFactory.markEnd('benchpress0', 20)\n+          ]],\n+          null!);\n+      metric.beginMeasure().then((_) => metric.endMeasure(false)).then((data) => {\n+        expect(data['scriptTime']).toBe(5);\n+        done();\n+      });\n+    });\n+\n+    it('should mark a run as invalid if the start and end marks are different', done => {\n+      const otherProcessEventFactory = new TraceEventFactory('timeline', 'pid1');\n+      const metric = createMetric(\n+          [[\n+            eventFactory.markStart('benchpress0', 0), eventFactory.start('script', 0, null),\n+            eventFactory.end('script', 5, null), otherProcessEventFactory.start('script', 10, null),\n+            otherProcessEventFactory.end('script', 17, null),\n+            otherProcessEventFactory.markEnd('benchpress0', 20)\n+          ]],\n+          null!);\n+      metric.beginMeasure().then((_) => metric.endMeasure(false)).then((data) => {\n+        expect(data['invalid']).toBe(1);\n+        done();\n+      });\n+    });\n+\n+    it('should support scriptTime metric', done => {\n+      aggregate([eventFactory.start('script', 0), eventFactory.end('script', 5)]).then((data) => {\n+        expect(data['scriptTime']).toBe(5);\n+        done();\n+      });\n+    });\n+\n+    it('should support renderTime metric', done => {\n+      aggregate([eventFactory.start('render', 0), eventFactory.end('render', 5)]).then((data) => {\n+        expect(data['renderTime']).toBe(5);\n+        done();\n+      });\n+    });\n+\n+    it('should support gcTime/gcAmount metric', done => {\n+      aggregate([\n+        eventFactory.start('gc', 0, {'usedHeapSize': 2500}),\n+        eventFactory.end('gc', 5, {'usedHeapSize': 1000})\n+      ]).then((data) => {\n+        expect(data['gcTime']).toBe(5);\n+        expect(data['gcAmount']).toBe(1.5);\n+        expect(data['majorGcTime']).toBe(0);\n+        done();\n+      });\n+    });\n+\n+    it('should support majorGcTime metric', done => {\n+      aggregate([\n+        eventFactory.start('gc', 0, {'usedHeapSize': 2500}),\n+        eventFactory.end('gc', 5, {'usedHeapSize': 1000, 'majorGc': true})\n+      ]).then((data) => {\n+        expect(data['gcTime']).toBe(5);\n+        expect(data['majorGcTime']).toBe(5);\n+        done();\n+      });\n     });\n \n-    it('should report a single interval',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         aggregate([\n-           eventFactory.start('script', 0), eventFactory.end('script', 5)\n-         ]).then((data) => {\n-           expect(data['scriptTime']).toBe(5);\n-           async.done();\n-         });\n-       }));\n-\n-    it('should sum up multiple intervals',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         aggregate([\n-           eventFactory.start('script', 0), eventFactory.end('script', 5),\n-           eventFactory.start('script', 10), eventFactory.end('script', 17)\n-         ]).then((data) => {\n-           expect(data['scriptTime']).toBe(12);\n-           async.done();\n-         });\n-       }));\n-\n-    it('should ignore not started intervals',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         aggregate([eventFactory.end('script', 10)]).then((data) => {\n-           expect(data['scriptTime']).toBe(0);\n-           async.done();\n-         });\n-       }));\n-\n-    it('should ignore not ended intervals',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         aggregate([eventFactory.start('script', 10)]).then((data) => {\n-           expect(data['scriptTime']).toBe(0);\n-           async.done();\n-         });\n-       }));\n-\n-    it('should ignore nested intervals',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         aggregate([\n-           eventFactory.start('script', 0), eventFactory.start('script', 5),\n-           eventFactory.end('script', 10), eventFactory.end('script', 17)\n-         ]).then((data) => {\n-           expect(data['scriptTime']).toBe(17);\n-           async.done();\n-         });\n-       }));\n-\n-    it('should ignore events from different processed as the start mark',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const otherProcessEventFactory = new TraceEventFactory('timeline', 'pid1');\n-         const metric = createMetric(\n-             [[\n-               eventFactory.markStart('benchpress0', 0), eventFactory.start('script', 0, null),\n-               eventFactory.end('script', 5, null),\n-               otherProcessEventFactory.start('script', 10, null),\n-               otherProcessEventFactory.end('script', 17, null),\n-               eventFactory.markEnd('benchpress0', 20)\n-             ]],\n-             null!);\n-         metric.beginMeasure().then((_) => metric.endMeasure(false)).then((data) => {\n-           expect(data['scriptTime']).toBe(5);\n-           async.done();\n-         });\n-       }));\n-\n-    it('should mark a run as invalid if the start and end marks are different',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const otherProcessEventFactory = new TraceEventFactory('timeline', 'pid1');\n-         const metric = createMetric(\n-             [[\n-               eventFactory.markStart('benchpress0', 0), eventFactory.start('script', 0, null),\n-               eventFactory.end('script', 5, null),\n-               otherProcessEventFactory.start('script', 10, null),\n-               otherProcessEventFactory.end('script', 17, null),\n-               otherProcessEventFactory.markEnd('benchpress0', 20)\n-             ]],\n-             null!);\n-         metric.beginMeasure().then((_) => metric.endMeasure(false)).then((data) => {\n-           expect(data['invalid']).toBe(1);\n-           async.done();\n-         });\n-       }));\n-\n-    it('should support scriptTime metric',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         aggregate([\n-           eventFactory.start('script', 0), eventFactory.end('script', 5)\n-         ]).then((data) => {\n-           expect(data['scriptTime']).toBe(5);\n-           async.done();\n-         });\n-       }));\n-\n-    it('should support renderTime metric',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         aggregate([\n-           eventFactory.start('render', 0), eventFactory.end('render', 5)\n-         ]).then((data) => {\n-           expect(data['renderTime']).toBe(5);\n-           async.done();\n-         });\n-       }));\n-\n-    it('should support gcTime/gcAmount metric',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         aggregate([\n-           eventFactory.start('gc', 0, {'usedHeapSize': 2500}),\n-           eventFactory.end('gc', 5, {'usedHeapSize': 1000})\n-         ]).then((data) => {\n-           expect(data['gcTime']).toBe(5);\n-           expect(data['gcAmount']).toBe(1.5);\n-           expect(data['majorGcTime']).toBe(0);\n-           async.done();\n-         });\n-       }));\n-\n-    it('should support majorGcTime metric',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         aggregate([\n-           eventFactory.start('gc', 0, {'usedHeapSize': 2500}),\n-           eventFactory.end('gc', 5, {'usedHeapSize': 1000, 'majorGc': true})\n-         ]).then((data) => {\n-           expect(data['gcTime']).toBe(5);\n-           expect(data['majorGcTime']).toBe(5);\n-           async.done();\n-         });\n-       }));\n-\n-    it('should support pureScriptTime = scriptTime-gcTime-renderTime',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         aggregate([\n-           eventFactory.start('script', 0), eventFactory.start('gc', 1, {'usedHeapSize': 1000}),\n-           eventFactory.end('gc', 4, {'usedHeapSize': 0}), eventFactory.start('render', 4),\n-           eventFactory.end('render', 5), eventFactory.end('script', 6)\n-         ]).then((data) => {\n-           expect(data['scriptTime']).toBe(6);\n-           expect(data['pureScriptTime']).toBe(2);\n-           async.done();\n-         });\n-       }));\n+    it('should support pureScriptTime = scriptTime-gcTime-renderTime', done => {\n+      aggregate([\n+        eventFactory.start('script', 0), eventFactory.start('gc', 1, {'usedHeapSize': 1000}),\n+        eventFactory.end('gc', 4, {'usedHeapSize': 0}), eventFactory.start('render', 4),\n+        eventFactory.end('render', 5), eventFactory.end('script', 6)\n+      ]).then((data) => {\n+        expect(data['scriptTime']).toBe(6);\n+        expect(data['pureScriptTime']).toBe(2);\n+        done();\n+      });\n+    });\n \n     describe('receivedData', () => {\n-      it('should report received data since last navigationStart',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           aggregate(\n-               [\n-                 eventFactory.instant('receivedData', 0, {'encodedDataLength': 1}),\n-                 eventFactory.instant('navigationStart', 1),\n-                 eventFactory.instant('receivedData', 2, {'encodedDataLength': 2}),\n-                 eventFactory.instant('navigationStart', 3),\n-                 eventFactory.instant('receivedData', 4, {'encodedDataLength': 4}),\n-                 eventFactory.instant('receivedData', 5, {'encodedDataLength': 8})\n-               ],\n-               {receivedData: true})\n-               .then((data) => {\n-                 expect(data['receivedData']).toBe(12);\n-                 async.done();\n-               });\n-         }));\n+      it('should report received data since last navigationStart', done => {\n+        aggregate(\n+            [\n+              eventFactory.instant('receivedData', 0, {'encodedDataLength': 1}),\n+              eventFactory.instant('navigationStart', 1),\n+              eventFactory.instant('receivedData', 2, {'encodedDataLength': 2}),\n+              eventFactory.instant('navigationStart', 3),\n+              eventFactory.instant('receivedData', 4, {'encodedDataLength': 4}),\n+              eventFactory.instant('receivedData', 5, {'encodedDataLength': 8})\n+            ],\n+            {receivedData: true})\n+            .then((data) => {\n+              expect(data['receivedData']).toBe(12);\n+              done();\n+            });\n+      });\n     });\n \n     describe('requestCount', () => {\n-      it('should report count of requests sent since last navigationStart',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           aggregate(\n-               [\n-                 eventFactory.instant('sendRequest', 0), eventFactory.instant('navigationStart', 1),\n-                 eventFactory.instant('sendRequest', 2), eventFactory.instant('navigationStart', 3),\n-                 eventFactory.instant('sendRequest', 4), eventFactory.instant('sendRequest', 5)\n-               ],\n-               {requestCount: true})\n-               .then((data) => {\n-                 expect(data['requestCount']).toBe(2);\n-                 async.done();\n-               });\n-         }));\n+      it('should report count of requests sent since last navigationStart', done => {\n+        aggregate(\n+            [\n+              eventFactory.instant('sendRequest', 0), eventFactory.instant('navigationStart', 1),\n+              eventFactory.instant('sendRequest', 2), eventFactory.instant('navigationStart', 3),\n+              eventFactory.instant('sendRequest', 4), eventFactory.instant('sendRequest', 5)\n+            ],\n+            {requestCount: true})\n+            .then((data) => {\n+              expect(data['requestCount']).toBe(2);\n+              done();\n+            });\n+      });\n     });\n \n     describe('microMetrics', () => {\n-      it('should report micro metrics',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           aggregate(\n-               [\n-                 eventFactory.markStart('mm1', 0),\n-                 eventFactory.markEnd('mm1', 5),\n-               ],\n-               {microMetrics: {'mm1': 'micro metric 1'}})\n-               .then((data) => {\n-                 expect(data['mm1']).toBe(5.0);\n-                 async.done();\n-               });\n-         }));\n-\n-      it('should ignore micro metrics that were not specified',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           aggregate([\n-             eventFactory.markStart('mm1', 0),\n-             eventFactory.markEnd('mm1', 5),\n-           ]).then((data) => {\n-             expect(data['mm1']).toBeFalsy();\n-             async.done();\n-           });\n-         }));\n-\n-      it('should report micro metric averages',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           aggregate(\n-               [\n-                 eventFactory.markStart('mm1*20', 0),\n-                 eventFactory.markEnd('mm1*20', 5),\n-               ],\n-               {microMetrics: {'mm1': 'micro metric 1'}})\n-               .then((data) => {\n-                 expect(data['mm1']).toBe(5 / 20);\n-                 async.done();\n-               });\n-         }));\n+      it('should report micro metrics', done => {\n+        aggregate(\n+            [\n+              eventFactory.markStart('mm1', 0),\n+              eventFactory.markEnd('mm1', 5),\n+            ],\n+            {microMetrics: {'mm1': 'micro metric 1'}})\n+            .then((data) => {\n+              expect(data['mm1']).toBe(5.0);\n+              done();\n+            });\n+      });\n+\n+      it('should ignore micro metrics that were not specified', done => {\n+        aggregate([\n+          eventFactory.markStart('mm1', 0),\n+          eventFactory.markEnd('mm1', 5),\n+        ]).then((data) => {\n+          expect(data['mm1']).toBeFalsy();\n+          done();\n+        });\n+      });\n+\n+      it('should report micro metric averages', done => {\n+        aggregate(\n+            [\n+              eventFactory.markStart('mm1*20', 0),\n+              eventFactory.markEnd('mm1*20', 5),\n+            ],\n+            {microMetrics: {'mm1': 'micro metric 1'}})\n+            .then((data) => {\n+              expect(data['mm1']).toBe(5 / 20);\n+              done();\n+            });\n+      });\n     });\n   });\n });"
        },
        {
            "sha": "419caca3d4951bf998e27a76c8a0292106882c72",
            "filename": "packages/benchpress/test/metric/user_metric_spec.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 17,
            "changes": 32,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fmetric%2Fuser_metric_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fmetric%2Fuser_metric_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbenchpress%2Ftest%2Fmetric%2Fuser_metric_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -7,7 +7,6 @@\n  */\n \n import {Injector, StaticProvider} from '@angular/core';\n-import {AsyncTestCompleter, describe, expect, inject, it} from '@angular/core/testing/src/testing_internal';\n \n import {Options, PerfLogEvent, PerfLogFeatures, UserMetric, WebDriverAdapter} from '../../index';\n \n@@ -42,23 +41,22 @@ describe('user metric', () => {\n   });\n \n   describe('endMeasure', () => {\n-    it('should stop measuring when all properties have numeric values',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const metric = createMetric(\n-             [[]], new PerfLogFeatures(),\n-             {userMetrics: {'loadTime': 'time to load', 'content': 'time to see content'}});\n-         metric.beginMeasure().then(() => metric.endMeasure(true)).then(values => {\n-           expect(values['loadTime']).toBe(25);\n-           expect(values['content']).toBe(250);\n-           async.done();\n-         });\n+    it('should stop measuring when all properties have numeric values', done => {\n+      const metric = createMetric(\n+          [[]], new PerfLogFeatures(),\n+          {userMetrics: {'loadTime': 'time to load', 'content': 'time to see content'}});\n+      metric.beginMeasure().then(() => metric.endMeasure(true)).then(values => {\n+        expect(values['loadTime']).toBe(25);\n+        expect(values['content']).toBe(250);\n+        done();\n+      });\n \n-         wdAdapter.data['loadTime'] = 25;\n-         // Wait before setting 2nd property.\n-         setTimeout(() => {\n-           wdAdapter.data['content'] = 250;\n-         }, 50);\n-       }), 600);\n+      wdAdapter.data['loadTime'] = 25;\n+      // Wait before setting 2nd property.\n+      setTimeout(() => {\n+        wdAdapter.data['content'] = 250;\n+      }, 50);\n+    }, 600);\n   });\n });\n })();"
        },
        {
            "sha": "c5cb5c98a8cbd453c7ce27bf3cf183e1015cbe6b",
            "filename": "packages/benchpress/test/reporter/console_reporter_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Freporter%2Fconsole_reporter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Freporter%2Fconsole_reporter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbenchpress%2Ftest%2Freporter%2Fconsole_reporter_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -7,7 +7,6 @@\n  */\n \n import {StaticProvider} from '@angular/core';\n-import {describe, expect, it} from '@angular/core/testing/src/testing_internal';\n \n import {ConsoleReporter, Injector, MeasureValues, SampleDescription} from '../../index';\n "
        },
        {
            "sha": "613991cc286f7a3ec1640e26c61c82664158ae1f",
            "filename": "packages/benchpress/test/reporter/json_file_reporter_spec.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 33,
            "changes": 62,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Freporter%2Fjson_file_reporter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Freporter%2Fjson_file_reporter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbenchpress%2Ftest%2Freporter%2Fjson_file_reporter_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,8 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AsyncTestCompleter, describe, expect, inject, it} from '@angular/core/testing/src/testing_internal';\n-\n import {Injector, JsonFileReporter, MeasureValues, Options, SampleDescription} from '../../index';\n \n {\n@@ -37,37 +35,35 @@ import {Injector, JsonFileReporter, MeasureValues, Options, SampleDescription} f\n       return Injector.create(providers).get<JsonFileReporter>(JsonFileReporter);\n     }\n \n-    it('should write all data into a file',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createReporter({\n-           sampleId: 'someId',\n-           descriptions: [{'a': 2}],\n-           path: 'somePath',\n-           metrics: {'a': 'script time', 'b': 'render time'}\n-         })\n-             .reportSample(\n-                 [mv(0, 0, {'a': 3, 'b': 6})],\n-                 [mv(0, 0, {'a': 3, 'b': 6}), mv(1, 1, {'a': 5, 'b': 9})]);\n-         const regExp = /somePath\\/someId_\\d+\\.json/;\n-         expect(loggedFile['filename'].match(regExp) != null).toBe(true);\n-         const parsedContent = JSON.parse(loggedFile['content']) as {[key: string]: any};\n-         expect(parsedContent).toEqual({\n-           'description': {\n-             'id': 'someId',\n-             'description': {'a': 2},\n-             'metrics': {'a': 'script time', 'b': 'render time'}\n-           },\n-           'stats': {'a': '4.00+-25%', 'b': '7.50+-20%'},\n-           'completeSample': [\n-             {'timeStamp': '1970-01-01T00:00:00.000Z', 'runIndex': 0, 'values': {'a': 3, 'b': 6}}\n-           ],\n-           'validSample': [\n-             {'timeStamp': '1970-01-01T00:00:00.000Z', 'runIndex': 0, 'values': {'a': 3, 'b': 6}},\n-             {'timeStamp': '1970-01-01T00:00:00.001Z', 'runIndex': 1, 'values': {'a': 5, 'b': 9}}\n-           ]\n-         });\n-         async.done();\n-       }));\n+    it('should write all data into a file', done => {\n+      createReporter({\n+        sampleId: 'someId',\n+        descriptions: [{'a': 2}],\n+        path: 'somePath',\n+        metrics: {'a': 'script time', 'b': 'render time'}\n+      })\n+          .reportSample(\n+              [mv(0, 0, {'a': 3, 'b': 6})],\n+              [mv(0, 0, {'a': 3, 'b': 6}), mv(1, 1, {'a': 5, 'b': 9})]);\n+      const regExp = /somePath\\/someId_\\d+\\.json/;\n+      expect(loggedFile['filename'].match(regExp) != null).toBe(true);\n+      const parsedContent = JSON.parse(loggedFile['content']) as {[key: string]: any};\n+      expect(parsedContent).toEqual({\n+        'description': {\n+          'id': 'someId',\n+          'description': {'a': 2},\n+          'metrics': {'a': 'script time', 'b': 'render time'}\n+        },\n+        'stats': {'a': '4.00+-25%', 'b': '7.50+-20%'},\n+        'completeSample':\n+            [{'timeStamp': '1970-01-01T00:00:00.000Z', 'runIndex': 0, 'values': {'a': 3, 'b': 6}}],\n+        'validSample': [\n+          {'timeStamp': '1970-01-01T00:00:00.000Z', 'runIndex': 0, 'values': {'a': 3, 'b': 6}},\n+          {'timeStamp': '1970-01-01T00:00:00.001Z', 'runIndex': 1, 'values': {'a': 5, 'b': 9}}\n+        ]\n+      });\n+      done();\n+    });\n   });\n }\n "
        },
        {
            "sha": "494d9098362e5fc1ee4a141bf03052d729444616",
            "filename": "packages/benchpress/test/reporter/multi_reporter_spec.ts",
            "status": "modified",
            "additions": 23,
            "deletions": 26,
            "changes": 49,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Freporter%2Fmulti_reporter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Freporter%2Fmulti_reporter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbenchpress%2Ftest%2Freporter%2Fmulti_reporter_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,8 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AsyncTestCompleter, describe, expect, inject, it} from '@angular/core/testing/src/testing_internal';\n-\n import {Injector, MeasureValues, MultiReporter, Reporter} from '../../index';\n \n (function() {\n@@ -22,30 +20,29 @@ function createReporters(ids: any[]) {\n }\n \n describe('multi reporter', () => {\n-  it('should reportMeasureValues to all',\n-     inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-       const mv = new MeasureValues(0, new Date(), {});\n-       createReporters(['m1', 'm2']).then((r) => r.reportMeasureValues(mv)).then((values) => {\n-         expect(values).toEqual([{'id': 'm1', 'values': mv}, {'id': 'm2', 'values': mv}]);\n-         async.done();\n-       });\n-     }));\n-\n-  it('should reportSample to call', inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-       const completeSample =\n-           [new MeasureValues(0, new Date(), {}), new MeasureValues(1, new Date(), {})];\n-       const validSample = [completeSample[1]];\n-\n-       createReporters(['m1', 'm2'])\n-           .then((r) => r.reportSample(completeSample, validSample))\n-           .then((values) => {\n-             expect(values).toEqual([\n-               {'id': 'm1', 'completeSample': completeSample, 'validSample': validSample},\n-               {'id': 'm2', 'completeSample': completeSample, 'validSample': validSample}\n-             ]);\n-             async.done();\n-           });\n-     }));\n+  it('should reportMeasureValues to all', done => {\n+    const mv = new MeasureValues(0, new Date(), {});\n+    createReporters(['m1', 'm2']).then((r) => r.reportMeasureValues(mv)).then((values) => {\n+      expect(values).toEqual([{'id': 'm1', 'values': mv}, {'id': 'm2', 'values': mv}]);\n+      done();\n+    });\n+  });\n+\n+  it('should reportSample to call', done => {\n+    const completeSample =\n+        [new MeasureValues(0, new Date(), {}), new MeasureValues(1, new Date(), {})];\n+    const validSample = [completeSample[1]];\n+\n+    createReporters(['m1', 'm2'])\n+        .then((r) => r.reportSample(completeSample, validSample))\n+        .then((values) => {\n+          expect(values).toEqual([\n+            {'id': 'm1', 'completeSample': completeSample, 'validSample': validSample},\n+            {'id': 'm2', 'completeSample': completeSample, 'validSample': validSample}\n+          ]);\n+          done();\n+        });\n+  });\n });\n })();\n "
        },
        {
            "sha": "d304fa356bdb0a17fdabf63ed3e023c7f8e378d3",
            "filename": "packages/benchpress/test/runner_spec.ts",
            "status": "modified",
            "additions": 63,
            "deletions": 73,
            "changes": 136,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Frunner_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Frunner_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbenchpress%2Ftest%2Frunner_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,8 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AsyncTestCompleter, describe, expect, inject, it} from '@angular/core/testing/src/testing_internal';\n-\n import {Injector, Metric, Options, Runner, SampleDescription, Sampler, SampleState, Validator, WebDriverAdapter} from '../index';\n \n {\n@@ -35,83 +33,75 @@ import {Injector, Metric, Options, Runner, SampleDescription, Sampler, SampleSta\n       return runner;\n     }\n \n-    it('should set SampleDescription.id',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createRunner()\n-             .sample({id: 'someId'})\n-             .then((_) => injector.get(SampleDescription))\n-             .then((desc) => {\n-               expect(desc.id).toBe('someId');\n-               async.done();\n-             });\n-       }));\n+    it('should set SampleDescription.id', done => {\n+      createRunner()\n+          .sample({id: 'someId'})\n+          .then((_) => injector.get(SampleDescription))\n+          .then((desc) => {\n+            expect(desc.id).toBe('someId');\n+            done();\n+          });\n+    });\n \n-    it('should merge SampleDescription.description',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createRunner([{provide: Options.DEFAULT_DESCRIPTION, useValue: {'a': 1}}])\n-             .sample({\n-               id: 'someId',\n-               providers: [{provide: Options.SAMPLE_DESCRIPTION, useValue: {'b': 2}}]\n-             })\n-             .then((_) => injector.get(SampleDescription))\n-             .then((desc) => {\n-               expect(desc.description)\n-                   .toEqual(\n-                       {'forceGc': false, 'userAgent': 'someUserAgent', 'a': 1, 'b': 2, 'v': 11});\n-               async.done();\n-             });\n-       }));\n+    it('should merge SampleDescription.description', done => {\n+      createRunner([{provide: Options.DEFAULT_DESCRIPTION, useValue: {'a': 1}}])\n+          .sample({\n+            id: 'someId',\n+            providers: [{provide: Options.SAMPLE_DESCRIPTION, useValue: {'b': 2}}]\n+          })\n+          .then((_) => injector.get(SampleDescription))\n+          .then((desc) => {\n+            expect(desc.description)\n+                .toEqual({'forceGc': false, 'userAgent': 'someUserAgent', 'a': 1, 'b': 2, 'v': 11});\n+            done();\n+          });\n+    });\n \n-    it('should fill SampleDescription.metrics from the Metric',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createRunner()\n-             .sample({id: 'someId'})\n-             .then((_) => injector.get(SampleDescription))\n-             .then((desc) => {\n-               expect(desc.metrics).toEqual({'m1': 'some metric'});\n-               async.done();\n-             });\n-       }));\n+    it('should fill SampleDescription.metrics from the Metric', done => {\n+      createRunner()\n+          .sample({id: 'someId'})\n+          .then((_) => injector.get(SampleDescription))\n+          .then((desc) => {\n+            expect(desc.metrics).toEqual({'m1': 'some metric'});\n+            done();\n+          });\n+    });\n \n-    it('should provide Options.EXECUTE',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const execute = () => {};\n-         createRunner().sample({id: 'someId', execute: execute}).then((_) => {\n-           expect(injector.get(Options.EXECUTE)).toEqual(execute);\n-           async.done();\n-         });\n-       }));\n+    it('should provide Options.EXECUTE', done => {\n+      const execute = () => {};\n+      createRunner().sample({id: 'someId', execute: execute}).then((_) => {\n+        expect(injector.get(Options.EXECUTE)).toEqual(execute);\n+        done();\n+      });\n+    });\n \n-    it('should provide Options.PREPARE',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const prepare = () => {};\n-         createRunner().sample({id: 'someId', prepare: prepare}).then((_) => {\n-           expect(injector.get(Options.PREPARE)).toEqual(prepare);\n-           async.done();\n-         });\n-       }));\n+    it('should provide Options.PREPARE', done => {\n+      const prepare = () => {};\n+      createRunner().sample({id: 'someId', prepare: prepare}).then((_) => {\n+        expect(injector.get(Options.PREPARE)).toEqual(prepare);\n+        done();\n+      });\n+    });\n \n-    it('should provide Options.MICRO_METRICS',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createRunner().sample({id: 'someId', microMetrics: {'a': 'b'}}).then((_) => {\n-           expect(injector.get(Options.MICRO_METRICS)).toEqual({'a': 'b'});\n-           async.done();\n-         });\n-       }));\n+    it('should provide Options.MICRO_METRICS', done => {\n+      createRunner().sample({id: 'someId', microMetrics: {'a': 'b'}}).then((_) => {\n+        expect(injector.get(Options.MICRO_METRICS)).toEqual({'a': 'b'});\n+        done();\n+      });\n+    });\n \n-    it('should overwrite providers per sample call',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createRunner([{provide: Options.DEFAULT_DESCRIPTION, useValue: {'a': 1}}])\n-             .sample({\n-               id: 'someId',\n-               providers: [{provide: Options.DEFAULT_DESCRIPTION, useValue: {'a': 2}}]\n-             })\n-             .then((_) => injector.get(SampleDescription))\n-             .then((desc) => {\n-               expect(desc.description['a']).toBe(2);\n-               async.done();\n-             });\n-       }));\n+    it('should overwrite providers per sample call', done => {\n+      createRunner([{provide: Options.DEFAULT_DESCRIPTION, useValue: {'a': 1}}])\n+          .sample({\n+            id: 'someId',\n+            providers: [{provide: Options.DEFAULT_DESCRIPTION, useValue: {'a': 2}}]\n+          })\n+          .then((_) => injector.get(SampleDescription))\n+          .then((desc) => {\n+            expect(desc.description['a']).toBe(2);\n+            done();\n+          });\n+    });\n   });\n }\n "
        },
        {
            "sha": "8ca4f2a06703416ef733241092a13ce8be0e1b04",
            "filename": "packages/benchpress/test/sampler_spec.ts",
            "status": "modified",
            "additions": 124,
            "deletions": 131,
            "changes": 255,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fsampler_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fsampler_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbenchpress%2Ftest%2Fsampler_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,8 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AsyncTestCompleter, describe, expect, inject, it} from '@angular/core/testing/src/testing_internal';\n-\n import {Injector, MeasureValues, Metric, Options, Reporter, Sampler, Validator, WebDriverAdapter} from '../index';\n \n {\n@@ -47,59 +45,57 @@ import {Injector, MeasureValues, Metric, Options, Reporter, Sampler, Validator,\n       sampler = Injector.create(providers).get(Sampler);\n     }\n \n-    it('should call the prepare and execute callbacks using WebDriverAdapter.waitFor',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const log: any[] = [];\n-         let count = 0;\n-         const driver = new MockDriverAdapter([], (callback: Function) => {\n-           const result = callback();\n-           log.push(result);\n-           return Promise.resolve(result);\n-         });\n-         createSampler({\n-           driver: driver,\n-           validator: createCountingValidator(2),\n-           prepare: () => count++,\n-           execute: () => count++,\n-         });\n-         sampler.sample().then((_) => {\n-           expect(count).toBe(4);\n-           expect(log).toEqual([0, 1, 2, 3]);\n-           async.done();\n-         });\n-       }));\n+    it('should call the prepare and execute callbacks using WebDriverAdapter.waitFor', done => {\n+      const log: any[] = [];\n+      let count = 0;\n+      const driver = new MockDriverAdapter([], (callback: Function) => {\n+        const result = callback();\n+        log.push(result);\n+        return Promise.resolve(result);\n+      });\n+      createSampler({\n+        driver: driver,\n+        validator: createCountingValidator(2),\n+        prepare: () => count++,\n+        execute: () => count++,\n+      });\n+      sampler.sample().then((_) => {\n+        expect(count).toBe(4);\n+        expect(log).toEqual([0, 1, 2, 3]);\n+        done();\n+      });\n+    });\n \n-    it('should call prepare, beginMeasure, execute, endMeasure for every iteration',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         let workCount = 0;\n-         const log: any[] = [];\n-         createSampler({\n-           metric: createCountingMetric(log),\n-           validator: createCountingValidator(2),\n-           prepare: () => {\n-             log.push(`p${workCount++}`);\n-           },\n-           execute: () => {\n-             log.push(`w${workCount++}`);\n-           }\n-         });\n-         sampler.sample().then((_) => {\n-           expect(log).toEqual([\n-             'p0',\n-             ['beginMeasure'],\n-             'w1',\n-             ['endMeasure', false, {'script': 0}],\n-             'p2',\n-             ['beginMeasure'],\n-             'w3',\n-             ['endMeasure', false, {'script': 1}],\n-           ]);\n-           async.done();\n-         });\n-       }));\n+    it('should call prepare, beginMeasure, execute, endMeasure for every iteration', done => {\n+      let workCount = 0;\n+      const log: any[] = [];\n+      createSampler({\n+        metric: createCountingMetric(log),\n+        validator: createCountingValidator(2),\n+        prepare: () => {\n+          log.push(`p${workCount++}`);\n+        },\n+        execute: () => {\n+          log.push(`w${workCount++}`);\n+        }\n+      });\n+      sampler.sample().then((_) => {\n+        expect(log).toEqual([\n+          'p0',\n+          ['beginMeasure'],\n+          'w1',\n+          ['endMeasure', false, {'script': 0}],\n+          'p2',\n+          ['beginMeasure'],\n+          'w3',\n+          ['endMeasure', false, {'script': 1}],\n+        ]);\n+        done();\n+      });\n+    });\n \n     it('should call execute, endMeasure for every iteration if there is no prepare callback',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n+       done => {\n          const log: any[] = [];\n          let workCount = 0;\n          createSampler({\n@@ -118,93 +114,90 @@ import {Injector, MeasureValues, Metric, Options, Reporter, Sampler, Validator,\n              'w1',\n              ['endMeasure', true, {'script': 1}],\n            ]);\n-           async.done();\n+           done();\n          });\n-       }));\n+       });\n \n-    it('should only collect metrics for execute and ignore metrics from prepare',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         let scriptTime = 0;\n-         let iterationCount = 1;\n-         createSampler({\n-           validator: createCountingValidator(2),\n-           metric: new MockMetric(\n-               [],\n-               () => {\n-                 const result = Promise.resolve({'script': scriptTime});\n-                 scriptTime = 0;\n-                 return result;\n-               }),\n-           prepare: () => {\n-             scriptTime = 1 * iterationCount;\n-           },\n-           execute: () => {\n-             scriptTime = 10 * iterationCount;\n-             iterationCount++;\n-           }\n-         });\n-         sampler.sample().then((state) => {\n-           expect(state.completeSample.length).toBe(2);\n-           expect(state.completeSample[0]).toEqual(mv(0, 1000, {'script': 10}));\n-           expect(state.completeSample[1]).toEqual(mv(1, 1001, {'script': 20}));\n-           async.done();\n-         });\n-       }));\n+    it('should only collect metrics for execute and ignore metrics from prepare', done => {\n+      let scriptTime = 0;\n+      let iterationCount = 1;\n+      createSampler({\n+        validator: createCountingValidator(2),\n+        metric: new MockMetric(\n+            [],\n+            () => {\n+              const result = Promise.resolve({'script': scriptTime});\n+              scriptTime = 0;\n+              return result;\n+            }),\n+        prepare: () => {\n+          scriptTime = 1 * iterationCount;\n+        },\n+        execute: () => {\n+          scriptTime = 10 * iterationCount;\n+          iterationCount++;\n+        }\n+      });\n+      sampler.sample().then((state) => {\n+        expect(state.completeSample.length).toBe(2);\n+        expect(state.completeSample[0]).toEqual(mv(0, 1000, {'script': 10}));\n+        expect(state.completeSample[1]).toEqual(mv(1, 1001, {'script': 20}));\n+        done();\n+      });\n+    });\n \n-    it('should call the validator for every execution and store the valid sample',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const log: any[] = [];\n-         const validSample = [mv(null!, null!, {})];\n+    it('should call the validator for every execution and store the valid sample', done => {\n+      const log: any[] = [];\n+      const validSample = [mv(null!, null!, {})];\n \n-         createSampler({\n-           metric: createCountingMetric(),\n-           validator: createCountingValidator(2, validSample, log),\n-           execute: EMPTY_EXECUTE\n-         });\n-         sampler.sample().then((state) => {\n-           expect(state.validSample).toBe(validSample);\n-           // TODO(tbosch): Why does this fail??\n-           // expect(log).toEqual([\n-           //   ['validate', [{'script': 0}], null],\n-           //   ['validate', [{'script': 0}, {'script': 1}], validSample]\n-           // ]);\n+      createSampler({\n+        metric: createCountingMetric(),\n+        validator: createCountingValidator(2, validSample, log),\n+        execute: EMPTY_EXECUTE\n+      });\n+      sampler.sample().then((state) => {\n+        expect(state.validSample).toBe(validSample);\n+        // TODO(tbosch): Why does this fail??\n+        // expect(log).toEqual([\n+        //   ['validate', [{'script': 0}], null],\n+        //   ['validate', [{'script': 0}, {'script': 1}], validSample]\n+        // ]);\n \n-           expect(log.length).toBe(2);\n-           expect(log[0]).toEqual(['validate', [mv(0, 1000, {'script': 0})], null]);\n-           expect(log[1]).toEqual(\n-               ['validate', [mv(0, 1000, {'script': 0}), mv(1, 1001, {'script': 1})], validSample]);\n+        expect(log.length).toBe(2);\n+        expect(log[0]).toEqual(['validate', [mv(0, 1000, {'script': 0})], null]);\n+        expect(log[1]).toEqual(\n+            ['validate', [mv(0, 1000, {'script': 0}), mv(1, 1001, {'script': 1})], validSample]);\n \n-           async.done();\n-         });\n-       }));\n+        done();\n+      });\n+    });\n \n-    it('should report the metric values',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const log: any[] = [];\n-         const validSample = [mv(null!, null!, {})];\n-         createSampler({\n-           validator: createCountingValidator(2, validSample),\n-           metric: createCountingMetric(),\n-           reporter: new MockReporter(log),\n-           execute: EMPTY_EXECUTE\n-         });\n-         sampler.sample().then((_) => {\n-           // TODO(tbosch): Why does this fail??\n-           // expect(log).toEqual([\n-           //   ['reportMeasureValues', 0, {'script': 0}],\n-           //   ['reportMeasureValues', 1, {'script': 1}],\n-           //   ['reportSample', [{'script': 0}, {'script': 1}], validSample]\n-           // ]);\n-           expect(log.length).toBe(3);\n-           expect(log[0]).toEqual(['reportMeasureValues', mv(0, 1000, {'script': 0})]);\n-           expect(log[1]).toEqual(['reportMeasureValues', mv(1, 1001, {'script': 1})]);\n-           expect(log[2]).toEqual([\n-             'reportSample', [mv(0, 1000, {'script': 0}), mv(1, 1001, {'script': 1})], validSample\n-           ]);\n+    it('should report the metric values', done => {\n+      const log: any[] = [];\n+      const validSample = [mv(null!, null!, {})];\n+      createSampler({\n+        validator: createCountingValidator(2, validSample),\n+        metric: createCountingMetric(),\n+        reporter: new MockReporter(log),\n+        execute: EMPTY_EXECUTE\n+      });\n+      sampler.sample().then((_) => {\n+        // TODO(tbosch): Why does this fail??\n+        // expect(log).toEqual([\n+        //   ['reportMeasureValues', 0, {'script': 0}],\n+        //   ['reportMeasureValues', 1, {'script': 1}],\n+        //   ['reportSample', [{'script': 0}, {'script': 1}], validSample]\n+        // ]);\n+        expect(log.length).toBe(3);\n+        expect(log[0]).toEqual(['reportMeasureValues', mv(0, 1000, {'script': 0})]);\n+        expect(log[1]).toEqual(['reportMeasureValues', mv(1, 1001, {'script': 1})]);\n+        expect(log[2]).toEqual([\n+          'reportSample', [mv(0, 1000, {'script': 0}), mv(1, 1001, {'script': 1})], validSample\n+        ]);\n \n-           async.done();\n-         });\n-       }));\n+        done();\n+      });\n+    });\n   });\n }\n "
        },
        {
            "sha": "b2f3fba7b593b0059b9d220d42d68f39e4c60836",
            "filename": "packages/benchpress/test/statistic_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fstatistic_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fstatistic_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbenchpress%2Ftest%2Fstatistic_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,7 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {describe, expect, it} from '@angular/core/testing/src/testing_internal';\n import {Statistic} from '../src/statistic';\n \n {"
        },
        {
            "sha": "7ea0969109670ce208e064e3eb3a9fed7e38e35c",
            "filename": "packages/benchpress/test/validator/regression_slope_validator_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fvalidator%2Fregression_slope_validator_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fvalidator%2Fregression_slope_validator_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbenchpress%2Ftest%2Fvalidator%2Fregression_slope_validator_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,8 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {describe, expect, it} from '@angular/core/testing/src/testing_internal';\n-\n import {Injector, MeasureValues, RegressionSlopeValidator} from '../../index';\n \n {"
        },
        {
            "sha": "852c7c57fc3f56e8026dfa6a1b6c394769642540",
            "filename": "packages/benchpress/test/validator/size_validator_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fvalidator%2Fsize_validator_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fvalidator%2Fsize_validator_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbenchpress%2Ftest%2Fvalidator%2Fsize_validator_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,8 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {describe, expect, it} from '@angular/core/testing/src/testing_internal';\n-\n import {Injector, MeasureValues, SizeValidator} from '../../index';\n \n {"
        },
        {
            "sha": "9303524c75cea3a1c706e0f810c1bbad9a7f1348",
            "filename": "packages/benchpress/test/web_driver_extension_spec.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 16,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fweb_driver_extension_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fweb_driver_extension_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbenchpress%2Ftest%2Fweb_driver_extension_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,8 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AsyncTestCompleter, describe, expect, inject, it} from '@angular/core/testing/src/testing_internal';\n-\n import {Injector, Options, WebDriverExtension} from '../index';\n \n (function() {\n@@ -28,21 +26,19 @@ function createExtension(ids: any[], caps: any) {\n }\n \n describe('WebDriverExtension.provideFirstSupported', () => {\n-  it('should provide the extension that matches the capabilities',\n-     inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-       createExtension(['m1', 'm2', 'm3'], {'browser': 'm2'}).then((m) => {\n-         expect(m.id).toEqual('m2');\n-         async.done();\n-       });\n-     }));\n+  it('should provide the extension that matches the capabilities', done => {\n+    createExtension(['m1', 'm2', 'm3'], {'browser': 'm2'}).then((m) => {\n+      expect(m.id).toEqual('m2');\n+      done();\n+    });\n+  });\n \n-  it('should throw if there is no match',\n-     inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-       createExtension(['m1'], {'browser': 'm2'}).catch((err) => {\n-         expect(err != null).toBe(true);\n-         async.done();\n-       });\n-     }));\n+  it('should throw if there is no match', done => {\n+    createExtension(['m1'], {'browser': 'm2'}).catch((err) => {\n+      expect(err != null).toBe(true);\n+      done();\n+    });\n+  });\n });\n })();\n "
        },
        {
            "sha": "f9da9e31e8c7596d10dea172938319adc051c053",
            "filename": "packages/benchpress/test/webdriver/chrome_driver_extension_spec.ts",
            "status": "modified",
            "additions": 296,
            "deletions": 319,
            "changes": 615,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fwebdriver%2Fchrome_driver_extension_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fwebdriver%2Fchrome_driver_extension_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbenchpress%2Ftest%2Fwebdriver%2Fchrome_driver_extension_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,8 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AsyncTestCompleter, describe, expect, fit, inject, it} from '@angular/core/testing/src/testing_internal';\n-\n import {ChromeDriverExtension, Injector, Options, WebDriverAdapter, WebDriverExtension} from '../../index';\n import {TraceEventFactory} from '../trace_event_factory';\n \n@@ -54,344 +52,323 @@ import {TraceEventFactory} from '../trace_event_factory';\n       return extension;\n     }\n \n-    it('should force gc via window.gc()',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createExtension().gc().then((_) => {\n-           expect(log).toEqual([['executeScript', 'window.gc()']]);\n-           async.done();\n-         });\n-       }));\n+    it('should force gc via window.gc()', done => {\n+      createExtension().gc().then((_) => {\n+        expect(log).toEqual([['executeScript', 'window.gc()']]);\n+        done();\n+      });\n+    });\n \n     it('should clear the perf logs and mark the timeline via performance.mark() on the first call',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n+       done => {\n          createExtension().timeBegin('someName').then(() => {\n            expect(log).toEqual([\n              ['logs', 'performance'], ['executeScript', `performance.mark('someName-bpstart');`]\n            ]);\n-           async.done();\n-         });\n-       }));\n-\n-    it('should mark the timeline via performance.mark() on the second call',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const ext = createExtension();\n-         ext.timeBegin('someName')\n-             .then((_) => {\n-               log.splice(0, log.length);\n-               ext.timeBegin('someName');\n-             })\n-             .then(() => {\n-               expect(log).toEqual([['executeScript', `performance.mark('someName-bpstart');`]]);\n-               async.done();\n-             });\n-       }));\n-\n-    it('should mark the timeline via performance.mark()',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createExtension().timeEnd('someName', null).then((_) => {\n-           expect(log).toEqual([['executeScript', `performance.mark('someName-bpend');`]]);\n-           async.done();\n+           done();\n          });\n-       }));\n+       });\n+\n+    it('should mark the timeline via performance.mark() on the second call', done => {\n+      const ext = createExtension();\n+      ext.timeBegin('someName')\n+          .then((_) => {\n+            log.splice(0, log.length);\n+            ext.timeBegin('someName');\n+          })\n+          .then(() => {\n+            expect(log).toEqual([['executeScript', `performance.mark('someName-bpstart');`]]);\n+            done();\n+          });\n+    });\n \n-    it('should mark the timeline via performance.mark() with start and end of a test',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createExtension().timeEnd('name1', 'name2').then((_) => {\n-           expect(log).toEqual([\n-             ['executeScript', `performance.mark('name1-bpend');performance.mark('name2-bpstart');`]\n-           ]);\n-           async.done();\n-         });\n-       }));\n-\n-    it('should normalize times to ms and forward ph and pid event properties',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createExtension([chromeTimelineV8Events.complete('FunctionCall', 1100, 5500, null)])\n-             .readPerfLog()\n-             .then((events) => {\n-               expect(events).toEqual([\n-                 normEvents.complete('script', 1.1, 5.5, null),\n-               ]);\n-               async.done();\n-             });\n-       }));\n-\n-    it('should normalize \"tdur\" to \"dur\"',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const event: any = chromeTimelineV8Events.create('X', 'FunctionCall', 1100, null);\n-         event['tdur'] = 5500;\n-         createExtension([event]).readPerfLog().then((events) => {\n-           expect(events).toEqual([\n-             normEvents.complete('script', 1.1, 5.5, null),\n-           ]);\n-           async.done();\n-         });\n-       }));\n-\n-    it('should report FunctionCall events as \"script\"',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createExtension([chromeTimelineV8Events.start('FunctionCall', 0)])\n-             .readPerfLog()\n-             .then((events) => {\n-               expect(events).toEqual([\n-                 normEvents.start('script', 0),\n-               ]);\n-               async.done();\n-             });\n-       }));\n-\n-    it('should report EvaluateScript events as \"script\"',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createExtension([chromeTimelineV8Events.start('EvaluateScript', 0)])\n-             .readPerfLog()\n-             .then((events) => {\n-               expect(events).toEqual([\n-                 normEvents.start('script', 0),\n-               ]);\n-               async.done();\n-             });\n-       }));\n-\n-    it('should report minor gc', inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createExtension([\n-           chromeTimelineV8Events.start('MinorGC', 1000, {'usedHeapSizeBefore': 1000}),\n-           chromeTimelineV8Events.end('MinorGC', 2000, {'usedHeapSizeAfter': 0}),\n-         ])\n-             .readPerfLog()\n-             .then((events) => {\n-               expect(events.length).toEqual(2);\n-               expect(events[0]).toEqual(\n-                   normEvents.start('gc', 1.0, {'usedHeapSize': 1000, 'majorGc': false}));\n-               expect(events[1]).toEqual(\n-                   normEvents.end('gc', 2.0, {'usedHeapSize': 0, 'majorGc': false}));\n-               async.done();\n-             });\n-       }));\n-\n-    it('should report major gc', inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createExtension(\n-             [\n-               chromeTimelineV8Events.start('MajorGC', 1000, {'usedHeapSizeBefore': 1000}),\n-               chromeTimelineV8Events.end('MajorGC', 2000, {'usedHeapSizeAfter': 0}),\n-             ],\n-             )\n-             .readPerfLog()\n-             .then((events) => {\n-               expect(events.length).toEqual(2);\n-               expect(events[0]).toEqual(\n-                   normEvents.start('gc', 1.0, {'usedHeapSize': 1000, 'majorGc': true}));\n-               expect(events[1]).toEqual(\n-                   normEvents.end('gc', 2.0, {'usedHeapSize': 0, 'majorGc': true}));\n-               async.done();\n-             });\n-       }));\n+    it('should mark the timeline via performance.mark()', done => {\n+      createExtension().timeEnd('someName', null).then((_) => {\n+        expect(log).toEqual([['executeScript', `performance.mark('someName-bpend');`]]);\n+        done();\n+      });\n+    });\n+\n+    it('should mark the timeline via performance.mark() with start and end of a test', done => {\n+      createExtension().timeEnd('name1', 'name2').then((_) => {\n+        expect(log).toEqual([\n+          ['executeScript', `performance.mark('name1-bpend');performance.mark('name2-bpstart');`]\n+        ]);\n+        done();\n+      });\n+    });\n+\n+    it('should normalize times to ms and forward ph and pid event properties', done => {\n+      createExtension([chromeTimelineV8Events.complete('FunctionCall', 1100, 5500, null)])\n+          .readPerfLog()\n+          .then((events) => {\n+            expect(events).toEqual([\n+              normEvents.complete('script', 1.1, 5.5, null),\n+            ]);\n+            done();\n+          });\n+    });\n+\n+    it('should normalize \"tdur\" to \"dur\"', done => {\n+      const event: any = chromeTimelineV8Events.create('X', 'FunctionCall', 1100, null);\n+      event['tdur'] = 5500;\n+      createExtension([event]).readPerfLog().then((events) => {\n+        expect(events).toEqual([\n+          normEvents.complete('script', 1.1, 5.5, null),\n+        ]);\n+        done();\n+      });\n+    });\n+\n+    it('should report FunctionCall events as \"script\"', done => {\n+      createExtension([chromeTimelineV8Events.start('FunctionCall', 0)])\n+          .readPerfLog()\n+          .then((events) => {\n+            expect(events).toEqual([\n+              normEvents.start('script', 0),\n+            ]);\n+            done();\n+          });\n+    });\n+\n+    it('should report EvaluateScript events as \"script\"', done => {\n+      createExtension([chromeTimelineV8Events.start('EvaluateScript', 0)])\n+          .readPerfLog()\n+          .then((events) => {\n+            expect(events).toEqual([\n+              normEvents.start('script', 0),\n+            ]);\n+            done();\n+          });\n+    });\n+\n+    it('should report minor gc', done => {\n+      createExtension([\n+        chromeTimelineV8Events.start('MinorGC', 1000, {'usedHeapSizeBefore': 1000}),\n+        chromeTimelineV8Events.end('MinorGC', 2000, {'usedHeapSizeAfter': 0}),\n+      ])\n+          .readPerfLog()\n+          .then((events) => {\n+            expect(events.length).toEqual(2);\n+            expect(events[0]).toEqual(\n+                normEvents.start('gc', 1.0, {'usedHeapSize': 1000, 'majorGc': false}));\n+            expect(events[1]).toEqual(\n+                normEvents.end('gc', 2.0, {'usedHeapSize': 0, 'majorGc': false}));\n+            done();\n+          });\n+    });\n+\n+    it('should report major gc', done => {\n+      createExtension(\n+          [\n+            chromeTimelineV8Events.start('MajorGC', 1000, {'usedHeapSizeBefore': 1000}),\n+            chromeTimelineV8Events.end('MajorGC', 2000, {'usedHeapSizeAfter': 0}),\n+          ],\n+          )\n+          .readPerfLog()\n+          .then((events) => {\n+            expect(events.length).toEqual(2);\n+            expect(events[0]).toEqual(\n+                normEvents.start('gc', 1.0, {'usedHeapSize': 1000, 'majorGc': true}));\n+            expect(events[1]).toEqual(\n+                normEvents.end('gc', 2.0, {'usedHeapSize': 0, 'majorGc': true}));\n+            done();\n+          });\n+    });\n \n     ['Layout', 'UpdateLayerTree', 'Paint'].forEach((recordType) => {\n-      it(`should report ${recordType} as \"render\"`,\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           createExtension(\n-               [\n-                 chrome45TimelineEvents.start(recordType, 1234),\n-                 chrome45TimelineEvents.end(recordType, 2345)\n-               ],\n-               )\n-               .readPerfLog()\n-               .then((events) => {\n-                 expect(events).toEqual([\n-                   normEvents.start('render', 1.234),\n-                   normEvents.end('render', 2.345),\n-                 ]);\n-                 async.done();\n-               });\n-         }));\n+      it(`should report ${recordType} as \"render\"`, done => {\n+        createExtension(\n+            [\n+              chrome45TimelineEvents.start(recordType, 1234),\n+              chrome45TimelineEvents.end(recordType, 2345)\n+            ],\n+            )\n+            .readPerfLog()\n+            .then((events) => {\n+              expect(events).toEqual([\n+                normEvents.start('render', 1.234),\n+                normEvents.end('render', 2.345),\n+              ]);\n+              done();\n+            });\n+      });\n     });\n \n-    it(`should report UpdateLayoutTree as \"render\"`,\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createExtension(\n-             [\n-               chromeBlinkTimelineEvents.start('UpdateLayoutTree', 1234),\n-               chromeBlinkTimelineEvents.end('UpdateLayoutTree', 2345)\n-             ],\n-             )\n-             .readPerfLog()\n-             .then((events) => {\n-               expect(events).toEqual([\n-                 normEvents.start('render', 1.234),\n-                 normEvents.end('render', 2.345),\n-               ]);\n-               async.done();\n-             });\n-       }));\n-\n-    it('should ignore FunctionCalls from webdriver',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createExtension([chromeTimelineV8Events.start(\n-                             'FunctionCall', 0, {'data': {'scriptName': 'InjectedScript'}})])\n-             .readPerfLog()\n-             .then((events) => {\n-               expect(events).toEqual([]);\n-               async.done();\n-             });\n-       }));\n-\n-    it('should ignore FunctionCalls with empty scriptName',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createExtension(\n-             [chromeTimelineV8Events.start('FunctionCall', 0, {'data': {'scriptName': ''}})])\n-             .readPerfLog()\n-             .then((events) => {\n-               expect(events).toEqual([]);\n-               async.done();\n-             });\n-       }));\n-\n-    it('should report navigationStart',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createExtension([chromeBlinkUserTimingEvents.instant('navigationStart', 1234)])\n-             .readPerfLog()\n-             .then((events) => {\n-               expect(events).toEqual([normEvents.instant('navigationStart', 1.234)]);\n-               async.done();\n-             });\n-       }));\n-\n-    it('should report receivedData', inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createExtension(\n-             [chrome45TimelineEvents.instant(\n-                 'ResourceReceivedData', 1234, {'data': {'encodedDataLength': 987}})],\n-             )\n-             .readPerfLog()\n-             .then((events) => {\n-               expect(events).toEqual(\n-                   [normEvents.instant('receivedData', 1.234, {'encodedDataLength': 987})]);\n-               async.done();\n-             });\n-       }));\n-\n-    it('should report sendRequest', inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createExtension(\n-             [chrome45TimelineEvents.instant(\n-                 'ResourceSendRequest', 1234,\n-                 {'data': {'url': 'http://here', 'requestMethod': 'GET'}})],\n-             )\n-             .readPerfLog()\n-             .then((events) => {\n-               expect(events).toEqual([normEvents.instant(\n-                   'sendRequest', 1.234, {'url': 'http://here', 'method': 'GET'})]);\n-               async.done();\n-             });\n-       }));\n+    it(`should report UpdateLayoutTree as \"render\"`, done => {\n+      createExtension(\n+          [\n+            chromeBlinkTimelineEvents.start('UpdateLayoutTree', 1234),\n+            chromeBlinkTimelineEvents.end('UpdateLayoutTree', 2345)\n+          ],\n+          )\n+          .readPerfLog()\n+          .then((events) => {\n+            expect(events).toEqual([\n+              normEvents.start('render', 1.234),\n+              normEvents.end('render', 2.345),\n+            ]);\n+            done();\n+          });\n+    });\n+\n+    it('should ignore FunctionCalls from webdriver', done => {\n+      createExtension([chromeTimelineV8Events.start(\n+                          'FunctionCall', 0, {'data': {'scriptName': 'InjectedScript'}})])\n+          .readPerfLog()\n+          .then((events) => {\n+            expect(events).toEqual([]);\n+            done();\n+          });\n+    });\n+\n+    it('should ignore FunctionCalls with empty scriptName', done => {\n+      createExtension(\n+          [chromeTimelineV8Events.start('FunctionCall', 0, {'data': {'scriptName': ''}})])\n+          .readPerfLog()\n+          .then((events) => {\n+            expect(events).toEqual([]);\n+            done();\n+          });\n+    });\n+\n+    it('should report navigationStart', done => {\n+      createExtension([chromeBlinkUserTimingEvents.instant('navigationStart', 1234)])\n+          .readPerfLog()\n+          .then((events) => {\n+            expect(events).toEqual([normEvents.instant('navigationStart', 1.234)]);\n+            done();\n+          });\n+    });\n+\n+    it('should report receivedData', done => {\n+      createExtension(\n+          [chrome45TimelineEvents.instant(\n+              'ResourceReceivedData', 1234, {'data': {'encodedDataLength': 987}})],\n+          )\n+          .readPerfLog()\n+          .then((events) => {\n+            expect(events).toEqual(\n+                [normEvents.instant('receivedData', 1.234, {'encodedDataLength': 987})]);\n+            done();\n+          });\n+    });\n+\n+    it('should report sendRequest', done => {\n+      createExtension(\n+          [chrome45TimelineEvents.instant(\n+              'ResourceSendRequest', 1234,\n+              {'data': {'url': 'http://here', 'requestMethod': 'GET'}})],\n+          )\n+          .readPerfLog()\n+          .then((events) => {\n+            expect(events).toEqual([normEvents.instant(\n+                'sendRequest', 1.234, {'url': 'http://here', 'method': 'GET'})]);\n+            done();\n+          });\n+    });\n \n     describe('readPerfLog (common)', () => {\n-      it('should execute a dummy script before reading them',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           // TODO(tbosch): This seems to be a bug in ChromeDriver:\n-           // Sometimes it does not report the newest events of the performance log\n-           // to the WebDriver client unless a script is executed...\n-           createExtension([]).readPerfLog().then((_) => {\n-             expect(log).toEqual([['executeScript', '1+1'], ['logs', 'performance']]);\n-             async.done();\n-           });\n-         }));\n+      it('should execute a dummy script before reading them', done => {\n+        // TODO(tbosch): This seems to be a bug in ChromeDriver:\n+        // Sometimes it does not report the newest events of the performance log\n+        // to the WebDriver client unless a script is executed...\n+        createExtension([]).readPerfLog().then((_) => {\n+          expect(log).toEqual([['executeScript', '1+1'], ['logs', 'performance']]);\n+          done();\n+        });\n+      });\n \n       ['Rasterize', 'CompositeLayers'].forEach((recordType) => {\n-        it(`should report ${recordType} as \"render\"`,\n-           inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-             createExtension(\n-                 [\n-                   chromeTimelineEvents.start(recordType, 1234),\n-                   chromeTimelineEvents.end(recordType, 2345)\n-                 ],\n-                 )\n-                 .readPerfLog()\n-                 .then((events) => {\n-                   expect(events).toEqual([\n-                     normEvents.start('render', 1.234),\n-                     normEvents.end('render', 2.345),\n-                   ]);\n-                   async.done();\n-                 });\n-           }));\n+        it(`should report ${recordType} as \"render\"`, done => {\n+          createExtension(\n+              [\n+                chromeTimelineEvents.start(recordType, 1234),\n+                chromeTimelineEvents.end(recordType, 2345)\n+              ],\n+              )\n+              .readPerfLog()\n+              .then((events) => {\n+                expect(events).toEqual([\n+                  normEvents.start('render', 1.234),\n+                  normEvents.end('render', 2.345),\n+                ]);\n+                done();\n+              });\n+        });\n       });\n \n       describe('frame metrics', () => {\n-        it('should report ImplThreadRenderingStats as frame event',\n-           inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-             createExtension([benchmarkEvents.instant(\n-                                 'BenchmarkInstrumentation::ImplThreadRenderingStats', 1100,\n-                                 {'data': {'frame_count': 1}})])\n-                 .readPerfLog()\n-                 .then((events) => {\n-                   expect(events).toEqual([\n-                     normEvents.instant('frame', 1.1),\n-                   ]);\n-                   async.done();\n-                 });\n-           }));\n-\n-        it('should not report ImplThreadRenderingStats with zero frames',\n-           inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-             createExtension([benchmarkEvents.instant(\n-                                 'BenchmarkInstrumentation::ImplThreadRenderingStats', 1100,\n-                                 {'data': {'frame_count': 0}})])\n-                 .readPerfLog()\n-                 .then((events) => {\n-                   expect(events).toEqual([]);\n-                   async.done();\n-                 });\n-           }));\n-\n-        it('should throw when ImplThreadRenderingStats contains more than one frame',\n-           inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-             createExtension([benchmarkEvents.instant(\n-                                 'BenchmarkInstrumentation::ImplThreadRenderingStats', 1100,\n-                                 {'data': {'frame_count': 2}})])\n-                 .readPerfLog()\n-                 .catch((err): any => {\n-                   expect(() => {\n-                     throw err;\n-                   }).toThrowError('multi-frame render stats not supported');\n-                   async.done();\n-                 });\n-           }));\n+        it('should report ImplThreadRenderingStats as frame event', done => {\n+          createExtension([benchmarkEvents.instant(\n+                              'BenchmarkInstrumentation::ImplThreadRenderingStats', 1100,\n+                              {'data': {'frame_count': 1}})])\n+              .readPerfLog()\n+              .then((events) => {\n+                expect(events).toEqual([\n+                  normEvents.instant('frame', 1.1),\n+                ]);\n+                done();\n+              });\n+        });\n+\n+        it('should not report ImplThreadRenderingStats with zero frames', done => {\n+          createExtension([benchmarkEvents.instant(\n+                              'BenchmarkInstrumentation::ImplThreadRenderingStats', 1100,\n+                              {'data': {'frame_count': 0}})])\n+              .readPerfLog()\n+              .then((events) => {\n+                expect(events).toEqual([]);\n+                done();\n+              });\n+        });\n+\n+        it('should throw when ImplThreadRenderingStats contains more than one frame', done => {\n+          createExtension([benchmarkEvents.instant(\n+                              'BenchmarkInstrumentation::ImplThreadRenderingStats', 1100,\n+                              {'data': {'frame_count': 2}})])\n+              .readPerfLog()\n+              .catch((err): any => {\n+                expect(() => {\n+                  throw err;\n+                }).toThrowError('multi-frame render stats not supported');\n+                done();\n+              });\n+        });\n       });\n \n-      it('should report begin timestamps',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           createExtension([blinkEvents.create('S', 'someName', 1000)])\n-               .readPerfLog()\n-               .then((events) => {\n-                 expect(events).toEqual([normEvents.markStart('someName', 1.0)]);\n-                 async.done();\n-               });\n-         }));\n-\n-      it('should report end timestamps',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           createExtension([blinkEvents.create('F', 'someName', 1000)])\n-               .readPerfLog()\n-               .then((events) => {\n-                 expect(events).toEqual([normEvents.markEnd('someName', 1.0)]);\n-                 async.done();\n-               });\n-         }));\n-\n-      it('should throw an error on buffer overflow',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           createExtension(\n-               [\n-                 chromeTimelineEvents.start('FunctionCall', 1234),\n-               ],\n-               CHROME45_USER_AGENT, 'Tracing.bufferUsage')\n-               .readPerfLog()\n-               .catch((err): any => {\n-                 expect(() => {\n-                   throw err;\n-                 }).toThrowError('The DevTools trace buffer filled during the test!');\n-                 async.done();\n-               });\n-         }));\n+      it('should report begin timestamps', done => {\n+        createExtension([blinkEvents.create('S', 'someName', 1000)])\n+            .readPerfLog()\n+            .then((events) => {\n+              expect(events).toEqual([normEvents.markStart('someName', 1.0)]);\n+              done();\n+            });\n+      });\n+\n+      it('should report end timestamps', done => {\n+        createExtension([blinkEvents.create('F', 'someName', 1000)])\n+            .readPerfLog()\n+            .then((events) => {\n+              expect(events).toEqual([normEvents.markEnd('someName', 1.0)]);\n+              done();\n+            });\n+      });\n+\n+      it('should throw an error on buffer overflow', done => {\n+        createExtension(\n+            [\n+              chromeTimelineEvents.start('FunctionCall', 1234),\n+            ],\n+            CHROME45_USER_AGENT, 'Tracing.bufferUsage')\n+            .readPerfLog()\n+            .catch((err): any => {\n+              expect(() => {\n+                throw err;\n+              }).toThrowError('The DevTools trace buffer filled during the test!');\n+              done();\n+            });\n+      });\n \n       it('should match chrome browsers', () => {\n         expect(createExtension().supports({'browserName': 'chrome'})).toBe(true);"
        },
        {
            "sha": "9d7b9c198b5b5f81e4836ba1deb54264b4a8abe6",
            "filename": "packages/benchpress/test/webdriver/ios_driver_extension_spec.ts",
            "status": "modified",
            "additions": 77,
            "deletions": 90,
            "changes": 167,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fwebdriver%2Fios_driver_extension_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fbenchpress%2Ftest%2Fwebdriver%2Fios_driver_extension_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbenchpress%2Ftest%2Fwebdriver%2Fios_driver_extension_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,8 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AsyncTestCompleter, describe, expect, inject, it} from '@angular/core/testing/src/testing_internal';\n-\n import {Injector, IOsDriverExtension, WebDriverAdapter, WebDriverExtension} from '../../index';\n import {TraceEventFactory} from '../trace_event_factory';\n \n@@ -37,102 +35,91 @@ import {TraceEventFactory} from '../trace_event_factory';\n       expect(() => createExtension().gc()).toThrowError('Force GC is not supported on iOS');\n     });\n \n-    it('should mark the timeline via console.time()',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createExtension().timeBegin('someName').then((_) => {\n-           expect(log).toEqual([['executeScript', `console.time('someName');`]]);\n-           async.done();\n-         });\n-       }));\n-\n-    it('should mark the timeline via console.timeEnd()',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createExtension().timeEnd('someName', null).then((_) => {\n-           expect(log).toEqual([['executeScript', `console.timeEnd('someName');`]]);\n-           async.done();\n-         });\n-       }));\n-\n-    it('should mark the timeline via console.time() and console.timeEnd()',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         createExtension().timeEnd('name1', 'name2').then((_) => {\n-           expect(log).toEqual(\n-               [['executeScript', `console.timeEnd('name1');console.time('name2');`]]);\n-           async.done();\n-         });\n-       }));\n+    it('should mark the timeline via console.time()', done => {\n+      createExtension().timeBegin('someName').then((_) => {\n+        expect(log).toEqual([['executeScript', `console.time('someName');`]]);\n+        done();\n+      });\n+    });\n+\n+    it('should mark the timeline via console.timeEnd()', done => {\n+      createExtension().timeEnd('someName', null).then((_) => {\n+        expect(log).toEqual([['executeScript', `console.timeEnd('someName');`]]);\n+        done();\n+      });\n+    });\n+\n+    it('should mark the timeline via console.time() and console.timeEnd()', done => {\n+      createExtension().timeEnd('name1', 'name2').then((_) => {\n+        expect(log).toEqual([['executeScript', `console.timeEnd('name1');console.time('name2');`]]);\n+        done();\n+      });\n+    });\n \n     describe('readPerfLog', () => {\n-      it('should execute a dummy script before reading them',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           // TODO(tbosch): This seems to be a bug in ChromeDriver:\n-           // Sometimes it does not report the newest events of the performance log\n-           // to the WebDriver client unless a script is executed...\n-           createExtension([]).readPerfLog().then((_) => {\n-             expect(log).toEqual([['executeScript', '1+1'], ['logs', 'performance']]);\n-             async.done();\n-           });\n-         }));\n-\n-      it('should report FunctionCall records as \"script\"',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           createExtension([durationRecord('FunctionCall', 1, 5)]).readPerfLog().then((events) => {\n-             expect(events).toEqual([normEvents.start('script', 1), normEvents.end('script', 5)]);\n-             async.done();\n-           });\n-         }));\n-\n-      it('should ignore FunctionCalls from webdriver',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           createExtension([internalScriptRecord(1, 5)]).readPerfLog().then((events) => {\n-             expect(events).toEqual([]);\n-             async.done();\n-           });\n-         }));\n-\n-      it('should report begin time', inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           createExtension([timeBeginRecord('someName', 12)]).readPerfLog().then((events) => {\n-             expect(events).toEqual([normEvents.markStart('someName', 12)]);\n-             async.done();\n-           });\n-         }));\n-\n-      it('should report end timestamps',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           createExtension([timeEndRecord('someName', 12)]).readPerfLog().then((events) => {\n-             expect(events).toEqual([normEvents.markEnd('someName', 12)]);\n-             async.done();\n-           });\n-         }));\n+      it('should execute a dummy script before reading them', done => {\n+        // TODO(tbosch): This seems to be a bug in ChromeDriver:\n+        // Sometimes it does not report the newest events of the performance log\n+        // to the WebDriver client unless a script is executed...\n+        createExtension([]).readPerfLog().then((_) => {\n+          expect(log).toEqual([['executeScript', '1+1'], ['logs', 'performance']]);\n+          done();\n+        });\n+      });\n+\n+      it('should report FunctionCall records as \"script\"', done => {\n+        createExtension([durationRecord('FunctionCall', 1, 5)]).readPerfLog().then((events) => {\n+          expect(events).toEqual([normEvents.start('script', 1), normEvents.end('script', 5)]);\n+          done();\n+        });\n+      });\n+\n+      it('should ignore FunctionCalls from webdriver', done => {\n+        createExtension([internalScriptRecord(1, 5)]).readPerfLog().then((events) => {\n+          expect(events).toEqual([]);\n+          done();\n+        });\n+      });\n+\n+      it('should report begin time', done => {\n+        createExtension([timeBeginRecord('someName', 12)]).readPerfLog().then((events) => {\n+          expect(events).toEqual([normEvents.markStart('someName', 12)]);\n+          done();\n+        });\n+      });\n+\n+      it('should report end timestamps', done => {\n+        createExtension([timeEndRecord('someName', 12)]).readPerfLog().then((events) => {\n+          expect(events).toEqual([normEvents.markEnd('someName', 12)]);\n+          done();\n+        });\n+      });\n \n       ['RecalculateStyles', 'Layout', 'UpdateLayerTree', 'Paint', 'Rasterize', 'CompositeLayers']\n           .forEach((recordType) => {\n-            it(`should report ${recordType}`,\n-               inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-                 createExtension([durationRecord(recordType, 0, 1)])\n-                     .readPerfLog()\n-                     .then((events) => {\n-                       expect(events).toEqual([\n-                         normEvents.start('render', 0),\n-                         normEvents.end('render', 1),\n-                       ]);\n-                       async.done();\n-                     });\n-               }));\n+            it(`should report ${recordType}`, done => {\n+              createExtension([durationRecord(recordType, 0, 1)]).readPerfLog().then((events) => {\n+                expect(events).toEqual([\n+                  normEvents.start('render', 0),\n+                  normEvents.end('render', 1),\n+                ]);\n+                done();\n+              });\n+            });\n           });\n \n \n-      it('should walk children', inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           createExtension([durationRecord('FunctionCall', 1, 5, [timeBeginRecord('someName', 2)])])\n-               .readPerfLog()\n-               .then((events) => {\n-                 expect(events).toEqual([\n-                   normEvents.start('script', 1), normEvents.markStart('someName', 2),\n-                   normEvents.end('script', 5)\n-                 ]);\n-                 async.done();\n-               });\n-         }));\n+      it('should walk children', done => {\n+        createExtension([durationRecord('FunctionCall', 1, 5, [timeBeginRecord('someName', 2)])])\n+            .readPerfLog()\n+            .then((events) => {\n+              expect(events).toEqual([\n+                normEvents.start('script', 1), normEvents.markStart('someName', 2),\n+                normEvents.end('script', 5)\n+              ]);\n+              done();\n+            });\n+      });\n \n       it('should match safari browsers', () => {\n         expect(createExtension().supports({'browserName': 'safari'})).toBe(true);"
        },
        {
            "sha": "fb0e3e7c13aeaded64a26473d52aabfc8ccbcf22",
            "filename": "packages/common/http/test/client_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Fhttp%2Ftest%2Fclient_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Fhttp%2Ftest%2Fclient_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Fhttp%2Ftest%2Fclient_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -9,7 +9,6 @@\n import {HttpClient} from '@angular/common/http/src/client';\n import {HttpErrorResponse, HttpEventType, HttpResponse, HttpStatusCode} from '@angular/common/http/src/response';\n import {HttpClientTestingBackend} from '@angular/common/http/testing/src/backend';\n-import {ddescribe, describe, fit, it} from '@angular/core/testing/src/testing_internal';\n import {toArray} from 'rxjs/operators';\n \n {"
        },
        {
            "sha": "0abcf88e2217e0abd4d4b638ae1923fcdb0d39f7",
            "filename": "packages/common/http/test/jsonp_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Fhttp%2Ftest%2Fjsonp_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Fhttp%2Ftest%2Fjsonp_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Fhttp%2Ftest%2Fjsonp_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -9,7 +9,6 @@\n import {JSONP_ERR_NO_CALLBACK, JSONP_ERR_WRONG_METHOD, JSONP_ERR_WRONG_RESPONSE_TYPE, JsonpClientBackend} from '@angular/common/http/src/jsonp';\n import {HttpRequest} from '@angular/common/http/src/request';\n import {HttpErrorResponse, HttpEventType} from '@angular/common/http/src/response';\n-import {ddescribe, describe, it} from '@angular/core/testing/src/testing_internal';\n import {toArray} from 'rxjs/operators';\n \n import {MockDocument} from './jsonp_mock';"
        },
        {
            "sha": "7fa9577f8ec9d6410c4d0c144134357c0c5df58c",
            "filename": "packages/common/http/test/request_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Fhttp%2Ftest%2Frequest_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Fhttp%2Ftest%2Frequest_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Fhttp%2Ftest%2Frequest_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -10,7 +10,6 @@ import {HttpContext} from '@angular/common/http/src/context';\n import {HttpHeaders} from '@angular/common/http/src/headers';\n import {HttpParams} from '@angular/common/http/src/params';\n import {HttpRequest} from '@angular/common/http/src/request';\n-import {ddescribe, describe, it} from '@angular/core/testing/src/testing_internal';\n \n const TEST_URL = 'https://angular.io/';\n const TEST_STRING = `I'm a body!`;"
        },
        {
            "sha": "0b1bb174826e0da7f5e567383062d179f36d5b3e",
            "filename": "packages/common/http/test/response_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Fhttp%2Ftest%2Fresponse_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Fhttp%2Ftest%2Fresponse_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Fhttp%2Ftest%2Fresponse_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -8,7 +8,6 @@\n \n import {HttpHeaders} from '@angular/common/http/src/headers';\n import {HttpResponse, HttpStatusCode} from '@angular/common/http/src/response';\n-import {describe, it} from '@angular/core/testing/src/testing_internal';\n \n {\n   describe('HttpResponse', () => {"
        },
        {
            "sha": "9c513f3f1bb46b7fae93a8228d7c97e2df7e47e4",
            "filename": "packages/common/http/test/xhr_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Fhttp%2Ftest%2Fxhr_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Fhttp%2Ftest%2Fxhr_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Fhttp%2Ftest%2Fxhr_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -9,7 +9,6 @@\n import {HttpRequest} from '@angular/common/http/src/request';\n import {HttpDownloadProgressEvent, HttpErrorResponse, HttpEvent, HttpEventType, HttpHeaderResponse, HttpResponse, HttpResponseBase, HttpStatusCode, HttpUploadProgressEvent} from '@angular/common/http/src/response';\n import {HttpXhrBackend} from '@angular/common/http/src/xhr';\n-import {describe, expect, it} from '@angular/core/testing/src/testing_internal';\n import {Observable} from 'rxjs';\n import {toArray} from 'rxjs/operators';\n "
        },
        {
            "sha": "132724700ef1c833d11ce4c3d80a340cc6fc7f7b",
            "filename": "packages/common/test/cookie_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Ftest%2Fcookie_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Ftest%2Fcookie_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Ftest%2Fcookie_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -17,7 +17,6 @@\n  */\n \n import {parseCookieValue} from '@angular/common/src/cookie';\n-import {describe, expect, it} from '@angular/core/testing/src/testing_internal';\n \n {\n   describe('cookies', () => {"
        },
        {
            "sha": "7043d4222480f49d020d3905bfd9d6e9936219de",
            "filename": "packages/common/test/i18n/format_number_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Ftest%2Fi18n%2Fformat_number_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Ftest%2Fi18n%2Fformat_number_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Ftest%2Fi18n%2Fformat_number_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -12,7 +12,6 @@ import localeEn from '@angular/common/locales/en';\n import localeEsUS from '@angular/common/locales/es-US';\n import localeFr from '@angular/common/locales/fr';\n import {DEFAULT_LOCALE_ID, registerLocaleData, unregisterLocaleData} from '@angular/core';\n-import {describe, expect, it} from '@angular/core/testing/src/testing_internal';\n \n describe('Format number', () => {\n   beforeAll(() => {"
        },
        {
            "sha": "ef511532407e6a71cfa0154884c225fcb3e0c58e",
            "filename": "packages/common/test/pipes/async_pipe_spec.ts",
            "status": "modified",
            "additions": 87,
            "deletions": 95,
            "changes": 182,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Ftest%2Fpipes%2Fasync_pipe_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Ftest%2Fpipes%2Fasync_pipe_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Ftest%2Fpipes%2Fasync_pipe_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -7,15 +7,16 @@\n  */\n \n import {AsyncPipe, getDOM as getDOM} from '@angular/common';\n-import {EventEmitter} from '@angular/core';\n-import {AsyncTestCompleter, beforeEach, describe, expect, inject, it} from '@angular/core/testing/src/testing_internal';\n+import {ChangeDetectorRef, EventEmitter} from '@angular/core';\n import {browserDetection} from '@angular/platform-browser/testing/src/browser_util';\n import {Subscribable, Unsubscribable} from 'rxjs';\n \n-import {SpyChangeDetectorRef} from '../spies';\n-\n {\n   describe('AsyncPipe', () => {\n+    function getChangeDetectorRefSpy() {\n+      return jasmine.createSpyObj('ChangeDetectorRef', ['markForCheck', 'detectChanges']);\n+    }\n+\n     describe('Observable', () => {\n       // only expose methods from the Subscribable interface, to ensure that\n       // the implementation does not rely on other methods:\n@@ -33,13 +34,13 @@ import {SpyChangeDetectorRef} from '../spies';\n       let emitter: EventEmitter<any>;\n       let subscribable: Subscribable<any>;\n       let pipe: AsyncPipe;\n-      let ref: any;\n+      let ref: ChangeDetectorRef&jasmine.SpyObj<ChangeDetectorRef>;\n       const message = {};\n \n       beforeEach(() => {\n         emitter = new EventEmitter();\n         subscribable = wrapSubscribable(emitter);\n-        ref = new SpyChangeDetectorRef();\n+        ref = getChangeDetectorRefSpy();\n         pipe = new AsyncPipe(ref);\n       });\n \n@@ -48,32 +49,30 @@ import {SpyChangeDetectorRef} from '../spies';\n           expect(pipe.transform(subscribable)).toBe(null);\n         });\n \n-        it('should return the latest available value',\n-           inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-             pipe.transform(subscribable);\n-             emitter.emit(message);\n+        it('should return the latest available value', done => {\n+          pipe.transform(subscribable);\n+          emitter.emit(message);\n \n-             setTimeout(() => {\n-               expect(pipe.transform(subscribable)).toEqual(message);\n-               async.done();\n-             }, 0);\n-           }));\n+          setTimeout(() => {\n+            expect(pipe.transform(subscribable)).toEqual(message);\n+            done();\n+          }, 0);\n+        });\n \n \n-        it('should return same value when nothing has changed since the last call',\n-           inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-             pipe.transform(subscribable);\n-             emitter.emit(message);\n+        it('should return same value when nothing has changed since the last call', done => {\n+          pipe.transform(subscribable);\n+          emitter.emit(message);\n \n-             setTimeout(() => {\n-               pipe.transform(subscribable);\n-               expect(pipe.transform(subscribable)).toBe(message);\n-               async.done();\n-             }, 0);\n-           }));\n+          setTimeout(() => {\n+            pipe.transform(subscribable);\n+            expect(pipe.transform(subscribable)).toBe(message);\n+            done();\n+          }, 0);\n+        });\n \n         it('should dispose of the existing subscription when subscribing to a new observable',\n-           inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n+           done => {\n              pipe.transform(subscribable);\n \n              const newEmitter = new EventEmitter();\n@@ -84,20 +83,19 @@ import {SpyChangeDetectorRef} from '../spies';\n              // this should not affect the pipe\n              setTimeout(() => {\n                expect(pipe.transform(newSubscribable)).toBe(null);\n-               async.done();\n+               done();\n              }, 0);\n-           }));\n+           });\n \n-        it('should request a change detection check upon receiving a new value',\n-           inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-             pipe.transform(subscribable);\n-             emitter.emit(message);\n+        it('should request a change detection check upon receiving a new value', done => {\n+          pipe.transform(subscribable);\n+          emitter.emit(message);\n \n-             setTimeout(() => {\n-               expect(ref.spy('markForCheck')).toHaveBeenCalled();\n-               async.done();\n-             }, 10);\n-           }));\n+          setTimeout(() => {\n+            expect(ref.markForCheck).toHaveBeenCalled();\n+            done();\n+          }, 10);\n+        });\n \n         it('should return value for unchanged NaN', () => {\n           emitter.emit(null);\n@@ -115,23 +113,22 @@ import {SpyChangeDetectorRef} from '../spies';\n           expect(() => pipe.ngOnDestroy()).not.toThrow();\n         });\n \n-        it('should dispose of the existing subscription',\n-           inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-             pipe.transform(subscribable);\n-             pipe.ngOnDestroy();\n-             emitter.emit(message);\n+        it('should dispose of the existing subscription', done => {\n+          pipe.transform(subscribable);\n+          pipe.ngOnDestroy();\n+          emitter.emit(message);\n \n-             setTimeout(() => {\n-               expect(pipe.transform(subscribable)).toBe(null);\n-               async.done();\n-             }, 0);\n-           }));\n+          setTimeout(() => {\n+            expect(pipe.transform(subscribable)).toBe(null);\n+            done();\n+          }, 0);\n+        });\n       });\n     });\n \n     describe('Subscribable', () => {\n       it('should infer the type from the subscribable', () => {\n-        const ref = new SpyChangeDetectorRef() as any;\n+        const ref = getChangeDetectorRefSpy();\n         const pipe = new AsyncPipe(ref);\n         const emitter = new EventEmitter<{name: 'T'}>();\n         // The following line will fail to compile if the type cannot be inferred.\n@@ -145,7 +142,7 @@ import {SpyChangeDetectorRef} from '../spies';\n       let resolve: (result: any) => void;\n       let reject: (error: any) => void;\n       let promise: Promise<any>;\n-      let ref: SpyChangeDetectorRef;\n+      let ref: any;\n       // adds longer timers for passing tests in IE\n       const timer = (getDOM() && browserDetection.isIE) ? 50 : 10;\n \n@@ -154,41 +151,39 @@ import {SpyChangeDetectorRef} from '../spies';\n           resolve = res;\n           reject = rej;\n         });\n-        ref = new SpyChangeDetectorRef();\n-        pipe = new AsyncPipe(ref as any);\n+        ref = getChangeDetectorRefSpy();\n+        pipe = new AsyncPipe(ref);\n       });\n \n       describe('transform', () => {\n         it('should return null when subscribing to a promise', () => {\n           expect(pipe.transform(promise)).toBe(null);\n         });\n \n-        it('should return the latest available value',\n-           inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-             pipe.transform(promise);\n+        it('should return the latest available value', done => {\n+          pipe.transform(promise);\n \n-             resolve(message);\n+          resolve(message);\n \n-             setTimeout(() => {\n-               expect(pipe.transform(promise)).toEqual(message);\n-               async.done();\n-             }, timer);\n-           }));\n+          setTimeout(() => {\n+            expect(pipe.transform(promise)).toEqual(message);\n+            done();\n+          }, timer);\n+        });\n \n-        it('should return value when nothing has changed since the last call',\n-           inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-             pipe.transform(promise);\n-             resolve(message);\n+        it('should return value when nothing has changed since the last call', done => {\n+          pipe.transform(promise);\n+          resolve(message);\n \n-             setTimeout(() => {\n-               pipe.transform(promise);\n-               expect(pipe.transform(promise)).toBe(message);\n-               async.done();\n-             }, timer);\n-           }));\n+          setTimeout(() => {\n+            pipe.transform(promise);\n+            expect(pipe.transform(promise)).toBe(message);\n+            done();\n+          }, timer);\n+        });\n \n         it('should dispose of the existing subscription when subscribing to a new promise',\n-           inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n+           done => {\n              pipe.transform(promise);\n \n              promise = new Promise<any>(() => {});\n@@ -198,41 +193,38 @@ import {SpyChangeDetectorRef} from '../spies';\n \n              setTimeout(() => {\n                expect(pipe.transform(promise)).toBe(null);\n-               async.done();\n+               done();\n              }, timer);\n-           }));\n+           });\n \n-        it('should request a change detection check upon receiving a new value',\n-           inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-             const markForCheck = ref.spy('markForCheck');\n-             pipe.transform(promise);\n-             resolve(message);\n+        it('should request a change detection check upon receiving a new value', done => {\n+          pipe.transform(promise);\n+          resolve(message);\n \n-             setTimeout(() => {\n-               expect(markForCheck).toHaveBeenCalled();\n-               async.done();\n-             }, timer);\n-           }));\n+          setTimeout(() => {\n+            expect(ref.markForCheck).toHaveBeenCalled();\n+            done();\n+          }, timer);\n+        });\n \n         describe('ngOnDestroy', () => {\n           it('should do nothing when no source', () => {\n             expect(() => pipe.ngOnDestroy()).not.toThrow();\n           });\n \n-          it('should dispose of the existing source',\n-             inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-               pipe.transform(promise);\n-               expect(pipe.transform(promise)).toBe(null);\n-               resolve(message);\n+          it('should dispose of the existing source', done => {\n+            pipe.transform(promise);\n+            expect(pipe.transform(promise)).toBe(null);\n+            resolve(message);\n \n \n-               setTimeout(() => {\n-                 expect(pipe.transform(promise)).toEqual(message);\n-                 pipe.ngOnDestroy();\n-                 expect(pipe.transform(promise)).toBe(null);\n-                 async.done();\n-               }, timer);\n-             }));\n+            setTimeout(() => {\n+              expect(pipe.transform(promise)).toEqual(message);\n+              pipe.ngOnDestroy();\n+              expect(pipe.transform(promise)).toBe(null);\n+              done();\n+            }, timer);\n+          });\n         });\n       });\n     });"
        },
        {
            "sha": "a78defb346fab879191e2875d22bf0346c9ee7a2",
            "filename": "packages/common/test/pipes/i18n_plural_pipe_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Ftest%2Fpipes%2Fi18n_plural_pipe_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Ftest%2Fpipes%2Fi18n_plural_pipe_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Ftest%2Fpipes%2Fi18n_plural_pipe_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -8,7 +8,6 @@\n \n import {I18nPluralPipe, NgLocalization} from '@angular/common';\n import {PipeResolver} from '@angular/compiler/src/pipe_resolver';\n-import {beforeEach, describe, expect, it} from '@angular/core/testing/src/testing_internal';\n import {JitReflector} from '@angular/platform-browser-dynamic/src/compiler_reflector';\n \n {"
        },
        {
            "sha": "fcef65caef8d8c5a11a681d383dd9bdd69710975",
            "filename": "packages/common/test/pipes/number_pipe_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Ftest%2Fpipes%2Fnumber_pipe_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Ftest%2Fpipes%2Fnumber_pipe_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Ftest%2Fpipes%2Fnumber_pipe_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -14,7 +14,6 @@ import localeEn from '@angular/common/locales/en';\n import localeEsUS from '@angular/common/locales/es-US';\n import localeFr from '@angular/common/locales/fr';\n import {registerLocaleData, unregisterLocaleData} from '@angular/core';\n-import {beforeEach, describe, expect, it} from '@angular/core/testing/src/testing_internal';\n \n {\n   describe('Number pipes', () => {"
        },
        {
            "sha": "1f5290bb456b14088e4dd837640430f4c51a7363",
            "filename": "packages/common/test/spies.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 23,
            "changes": 23,
            "blob_url": "https://github.com/angular/angular/blob/bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae/packages%2Fcommon%2Ftest%2Fspies.ts",
            "raw_url": "https://github.com/angular/angular/raw/bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae/packages%2Fcommon%2Ftest%2Fspies.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Ftest%2Fspies.ts?ref=bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae",
            "patch": "@@ -1,23 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ChangeDetectorRef} from '@angular/core/src/change_detection/change_detector_ref';\n-import {SpyObject} from '@angular/core/testing/src/testing_internal';\n-\n-export class SpyChangeDetectorRef extends SpyObject {\n-  constructor() {\n-    super(ChangeDetectorRef);\n-    this.spy('markForCheck');\n-  }\n-}\n-\n-export class SpyNgControl extends SpyObject {}\n-\n-export class SpyValueAccessor extends SpyObject {\n-  writeValue: any;\n-}"
        },
        {
            "sha": "404731f242dcac458eac3297ea8ff300c523c871",
            "filename": "packages/common/test/viewport_scroller_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Ftest%2Fviewport_scroller_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcommon%2Ftest%2Fviewport_scroller_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Ftest%2Fviewport_scroller_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,7 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {describe, expect, it} from '@angular/core/testing/src/testing_internal';\n import {browserDetection} from '@angular/platform-browser/testing/src/browser_util';\n import {BrowserViewportScroller, ViewportScroller} from '../src/viewport_scroller';\n "
        },
        {
            "sha": "63bfb6e0dd9dd4a0d64d83db17882184fe80c287",
            "filename": "packages/compiler/test/i18n/integration_common.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcompiler%2Ftest%2Fi18n%2Fintegration_common.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcompiler%2Ftest%2Fi18n%2Fintegration_common.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fi18n%2Fintegration_common.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -11,14 +11,13 @@ import {Serializer} from '@angular/compiler/src/i18n';\n import {MessageBundle} from '@angular/compiler/src/i18n/message_bundle';\n import {HtmlParser} from '@angular/compiler/src/ml_parser/html_parser';\n import {DEFAULT_INTERPOLATION_CONFIG} from '@angular/compiler/src/ml_parser/interpolation_config';\n+import {ResourceLoader} from '@angular/compiler/src/resource_loader';\n import {Component, DebugElement, TRANSLATIONS, TRANSLATIONS_FORMAT} from '@angular/core';\n import {ComponentFixture, TestBed} from '@angular/core/testing';\n import {By} from '@angular/platform-browser/src/dom/debug/by';\n import {stringifyElement} from '@angular/platform-browser/testing/src/browser_util';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n \n-import {SpyResourceLoader} from '../spies';\n-\n @Component({\n   selector: 'i18n-cmp',\n   template: '',\n@@ -180,7 +179,7 @@ export const HTML = `\n export async function configureCompiler(translationsToMerge: string, format: string) {\n   TestBed.configureCompiler({\n     providers: [\n-      SpyResourceLoader.PROVIDE,\n+      {provide: ResourceLoader, useValue: jasmine.createSpyObj('ResourceLoader', ['get'])},\n       FrLocalization.PROVIDE,\n       {provide: TRANSLATIONS, useValue: translationsToMerge},\n       {provide: TRANSLATIONS_FORMAT, useValue: format},"
        },
        {
            "sha": "487b7ed4e29380e9d4e4d9b8ee118c79de16e231",
            "filename": "packages/compiler/test/ng_module_resolver_mock_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcompiler%2Ftest%2Fng_module_resolver_mock_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcompiler%2Ftest%2Fng_module_resolver_mock_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fng_module_resolver_mock_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,8 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {Injector, NgModule} from '@angular/core';\n-import {beforeEach, describe, expect, inject, it} from '@angular/core/testing/src/testing_internal';\n+import {NgModule} from '@angular/core';\n import {JitReflector} from '@angular/platform-browser-dynamic/src/compiler_reflector';\n \n import {MockNgModuleResolver} from '../testing';\n@@ -16,9 +15,9 @@ import {MockNgModuleResolver} from '../testing';\n   describe('MockNgModuleResolver', () => {\n     let ngModuleResolver: MockNgModuleResolver;\n \n-    beforeEach(inject([Injector], (injector: Injector) => {\n+    beforeEach(() => {\n       ngModuleResolver = new MockNgModuleResolver(new JitReflector());\n-    }));\n+    });\n \n     describe('NgModule overriding', () => {\n       it('should fallback to the default NgModuleResolver when templates are not overridden',"
        },
        {
            "sha": "6723fa5d2e649e817b9b677d330a52f4b78b4d3b",
            "filename": "packages/compiler/test/resource_loader_mock_spec.ts",
            "status": "modified",
            "additions": 36,
            "deletions": 42,
            "changes": 78,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcompiler%2Ftest%2Fresource_loader_mock_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcompiler%2Ftest%2Fresource_loader_mock_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fresource_loader_mock_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -7,7 +7,6 @@\n  */\n \n import {MockResourceLoader} from '@angular/compiler/testing/src/resource_loader_mock';\n-import {AsyncTestCompleter, beforeEach, describe, expect, inject, it} from '@angular/core/testing/src/testing_internal';\n \n {\n   describe('MockResourceLoader', () => {\n@@ -42,41 +41,37 @@ import {AsyncTestCompleter, beforeEach, describe, expect, inject, it} from '@ang\n       request.then(onResponse, onError);\n     }\n \n-    it('should return a response from the definitions',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const url = '/foo';\n-         const response = 'bar';\n-         resourceLoader.when(url, response);\n-         expectResponse(resourceLoader.get(url), url, response, () => async.done());\n-         resourceLoader.flush();\n-       }));\n+    it('should return a response from the definitions', done => {\n+      const url = '/foo';\n+      const response = 'bar';\n+      resourceLoader.when(url, response);\n+      expectResponse(resourceLoader.get(url), url, response, () => done());\n+      resourceLoader.flush();\n+    });\n \n-    it('should return an error from the definitions',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const url = '/foo';\n-         const response: string = null!;\n-         resourceLoader.when(url, response);\n-         expectResponse(resourceLoader.get(url), url, response, () => async.done());\n-         resourceLoader.flush();\n-       }));\n+    it('should return an error from the definitions', done => {\n+      const url = '/foo';\n+      const response: string = null!;\n+      resourceLoader.when(url, response);\n+      expectResponse(resourceLoader.get(url), url, response, () => done());\n+      resourceLoader.flush();\n+    });\n \n-    it('should return a response from the expectations',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const url = '/foo';\n-         const response = 'bar';\n-         resourceLoader.expect(url, response);\n-         expectResponse(resourceLoader.get(url), url, response, () => async.done());\n-         resourceLoader.flush();\n-       }));\n+    it('should return a response from the expectations', done => {\n+      const url = '/foo';\n+      const response = 'bar';\n+      resourceLoader.expect(url, response);\n+      expectResponse(resourceLoader.get(url), url, response, () => done());\n+      resourceLoader.flush();\n+    });\n \n-    it('should return an error from the expectations',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const url = '/foo';\n-         const response: string = null!;\n-         resourceLoader.expect(url, response);\n-         expectResponse(resourceLoader.get(url), url, response, () => async.done());\n-         resourceLoader.flush();\n-       }));\n+    it('should return an error from the expectations', done => {\n+      const url = '/foo';\n+      const response: string = null!;\n+      resourceLoader.expect(url, response);\n+      expectResponse(resourceLoader.get(url), url, response, () => done());\n+      resourceLoader.flush();\n+    });\n \n     it('should not reuse expectations', () => {\n       const url = '/foo';\n@@ -89,15 +84,14 @@ import {AsyncTestCompleter, beforeEach, describe, expect, inject, it} from '@ang\n       }).toThrowError('Unexpected request /foo');\n     });\n \n-    it('should return expectations before definitions',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const url = '/foo';\n-         resourceLoader.when(url, 'when');\n-         resourceLoader.expect(url, 'expect');\n-         expectResponse(resourceLoader.get(url), url, 'expect');\n-         expectResponse(resourceLoader.get(url), url, 'when', () => async.done());\n-         resourceLoader.flush();\n-       }));\n+    it('should return expectations before definitions', done => {\n+      const url = '/foo';\n+      resourceLoader.when(url, 'when');\n+      resourceLoader.expect(url, 'expect');\n+      expectResponse(resourceLoader.get(url), url, 'expect');\n+      expectResponse(resourceLoader.get(url), url, 'when', () => done());\n+      resourceLoader.flush();\n+    });\n \n     it('should throw when there is no definitions or expectations', () => {\n       resourceLoader.get('/foo');"
        },
        {
            "sha": "c0fbe40cd7aa045ffd479feee772d40e50833a08",
            "filename": "packages/compiler/test/runtime_compiler_spec.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 12,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcompiler%2Ftest%2Fruntime_compiler_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcompiler%2Ftest%2Fruntime_compiler_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fruntime_compiler_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -13,8 +13,6 @@ import {expect} from '@angular/platform-browser/testing/src/matchers';\n \n import {MockDirectiveResolver} from '../testing';\n \n-import {SpyResourceLoader} from './spies';\n-\n @Component({selector: 'child-cmp'})\n class ChildComp {\n }\n@@ -91,22 +89,20 @@ class SomeCompWithUrlTemplate {\n \n   describe('RuntimeCompiler', () => {\n     let compiler: Compiler;\n-    let resourceLoader: SpyResourceLoader;\n+    let resourceLoader: {get: jasmine.Spy};\n     let dirResolver: MockDirectiveResolver;\n-    let injector: Injector;\n \n     beforeEach(() => {\n-      TestBed.configureCompiler({providers: [SpyResourceLoader.PROVIDE]});\n+      resourceLoader = jasmine.createSpyObj('ResourceLoader', ['get']);\n+      TestBed.configureCompiler({providers: [{provide: ResourceLoader, useValue: resourceLoader}]});\n     });\n \n     beforeEach(fakeAsync(inject(\n         [Compiler, ResourceLoader, DirectiveResolver, Injector],\n-        (_compiler: Compiler, _resourceLoader: SpyResourceLoader,\n-         _dirResolver: MockDirectiveResolver, _injector: Injector) => {\n+        (_compiler: Compiler, _resourceLoader: any, _dirResolver: MockDirectiveResolver) => {\n           compiler = _compiler;\n           resourceLoader = _resourceLoader;\n           dirResolver = _dirResolver;\n-          injector = _injector;\n         })));\n \n     describe('compileModuleAsync', () => {\n@@ -118,7 +114,7 @@ class SomeCompWithUrlTemplate {\n            class SomeModule {\n            }\n \n-           resourceLoader.spy('get').and.callFake(() => Promise.resolve('hello'));\n+           resourceLoader.get.and.callFake(() => Promise.resolve('hello'));\n            let ngModuleFactory: NgModuleFactory<any> = undefined!;\n            compiler.compileModuleAsync(SomeModule).then((f) => ngModuleFactory = f);\n            tick();\n@@ -133,7 +129,7 @@ class SomeCompWithUrlTemplate {\n         class SomeModule {\n         }\n \n-        resourceLoader.spy('get').and.callFake(() => Promise.resolve(''));\n+        resourceLoader.get.and.callFake(() => Promise.resolve(''));\n         expect(() => compiler.compileModuleSync(SomeModule))\n             .toThrowError(`Can't compile synchronously as ${\n                 stringify(SomeCompWithUrlTemplate)} is still being loaded!`);\n@@ -145,7 +141,7 @@ class SomeCompWithUrlTemplate {\n            class SomeModule {\n            }\n \n-           resourceLoader.spy('get').and.callFake(() => Promise.resolve(''));\n+           resourceLoader.get.and.callFake(() => Promise.resolve(''));\n            dirResolver.setDirective(SomeComp, new Component({selector: 'some-cmp', template: ''}));\n            dirResolver.setDirective(\n                ChildComp, new Component({selector: 'child-cmp', templateUrl: '/someTpl.html'}));\n@@ -163,7 +159,7 @@ class SomeCompWithUrlTemplate {\n            class SomeModule {\n            }\n \n-           resourceLoader.spy('get').and.callFake(() => Promise.resolve('hello'));\n+           resourceLoader.get.and.callFake(() => Promise.resolve('hello'));\n            compiler.compileModuleAsync(SomeModule);\n            tick();\n "
        },
        {
            "sha": "c4812c7b2474abe2444781e7c22ffa453863eede",
            "filename": "packages/compiler/test/schema/dom_element_schema_registry_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcompiler%2Ftest%2Fschema%2Fdom_element_schema_registry_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcompiler%2Ftest%2Fschema%2Fdom_element_schema_registry_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fschema%2Fdom_element_schema_registry_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -8,7 +8,6 @@\n \n import {DomElementSchemaRegistry} from '@angular/compiler/src/schema/dom_element_schema_registry';\n import {CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, SecurityContext} from '@angular/core';\n-import {beforeEach, describe, expect, it} from '@angular/core/testing/src/testing_internal';\n import {browserDetection} from '@angular/platform-browser/testing/src/browser_util';\n \n import {Element} from '../../src/ml_parser/ast';"
        },
        {
            "sha": "16504814a6f133e2fbe38f06af88d8778e6e0864",
            "filename": "packages/compiler/test/schema/trusted_types_sinks_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcompiler%2Ftest%2Fschema%2Ftrusted_types_sinks_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcompiler%2Ftest%2Fschema%2Ftrusted_types_sinks_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fschema%2Ftrusted_types_sinks_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -7,7 +7,6 @@\n  */\n \n import {isTrustedTypesSink} from '@angular/compiler/src/schema/trusted_types_sinks';\n-import {describe, expect, it} from '@angular/core/testing/src/testing_internal';\n \n {\n   describe('isTrustedTypesSink', () => {"
        },
        {
            "sha": "579981722692dab26686533aa6db440ab23c9c86",
            "filename": "packages/compiler/test/spies.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae/packages%2Fcompiler%2Ftest%2Fspies.ts",
            "raw_url": "https://github.com/angular/angular/raw/bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae/packages%2Fcompiler%2Ftest%2Fspies.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fspies.ts?ref=bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae",
            "patch": "@@ -1,18 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ResourceLoader} from '@angular/compiler/src/resource_loader';\n-\n-import {SpyObject} from '@angular/core/testing/src/testing_internal';\n-\n-export class SpyResourceLoader extends SpyObject {\n-  public static PROVIDE = {provide: ResourceLoader, useClass: SpyResourceLoader, deps: []};\n-  constructor() {\n-    super(ResourceLoader);\n-  }\n-}"
        },
        {
            "sha": "f07caa14fb357a9d1a29725087d0e3e529630857",
            "filename": "packages/compiler/test/template_parser/template_preparser_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Ftemplate_preparser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Ftemplate_preparser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Ftemplate_preparser_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {beforeEach, describe, expect, inject, it} from '../../../core/testing/src/testing_internal';\n+import {inject} from '../../../core/testing';\n import {Element} from '../../src/ml_parser/ast';\n import {HtmlParser} from '../../src/ml_parser/html_parser';\n import {PreparsedElement, PreparsedElementType, preparseElement} from '../../src/template_parser/template_preparser';"
        },
        {
            "sha": "ffbd0f4379410e41d1fa72373f8d782cc69bf489",
            "filename": "packages/compiler/test/url_resolver_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcompiler%2Ftest%2Furl_resolver_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcompiler%2Ftest%2Furl_resolver_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Furl_resolver_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,8 +6,8 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {createOfflineCompileUrlResolver, UrlResolver} from '@angular/compiler/src/url_resolver';\n-import {beforeEach, describe, expect, inject, it} from '@angular/core/testing/src/testing_internal';\n+import {UrlResolver} from '@angular/compiler/src/url_resolver';\n+import {inject} from '@angular/core/testing';\n \n {\n   describe('UrlResolver', () => {"
        },
        {
            "sha": "0f96eda3e0c6ecd96a18951d071acb24cc01f05c",
            "filename": "packages/core/test/acceptance/bootstrap_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Facceptance%2Fbootstrap_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Facceptance%2Fbootstrap_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fbootstrap_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -7,7 +7,6 @@\n  */\n \n import {ApplicationRef, COMPILER_OPTIONS, Component, destroyPlatform, NgModule, NgZone, TestabilityRegistry, ViewEncapsulation} from '@angular/core';\n-import {expect} from '@angular/core/testing/src/testing_internal';\n import {BrowserModule} from '@angular/platform-browser';\n import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';\n import {onlyInIvy, withBody} from '@angular/private/testing';"
        },
        {
            "sha": "513bb26065cc3efe433daa51bf6de866431055d6",
            "filename": "packages/core/test/acceptance/discover_utils_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Facceptance%2Fdiscover_utils_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Facceptance%2Fdiscover_utils_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fdiscover_utils_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -14,7 +14,6 @@ import {isLView} from '@angular/core/src/render3/interfaces/type_checks';\n import {CONTEXT} from '@angular/core/src/render3/interfaces/view';\n import {ComponentFixture, TestBed} from '@angular/core/testing';\n import {getElementStyles} from '@angular/core/testing/src/styling';\n-import {expect} from '@angular/core/testing/src/testing_internal';\n import {onlyInIvy} from '@angular/private/testing';\n \n import {getLContext} from '../../src/render3/context_discovery';"
        },
        {
            "sha": "1c07528cb5571e804860bb86ab620676145be7fa",
            "filename": "packages/core/test/acceptance/profiler_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Facceptance%2Fprofiler_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Facceptance%2Fprofiler_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fprofiler_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -8,7 +8,6 @@\n \n import {ProfilerEvent, setProfiler} from '@angular/core/src/render3/profiler';\n import {TestBed} from '@angular/core/testing';\n-import {expect} from '@angular/core/testing/src/testing_internal';\n import {onlyInIvy} from '@angular/private/testing';\n \n import {AfterContentChecked, AfterContentInit, AfterViewChecked, AfterViewInit, Component, DoCheck, ErrorHandler, EventEmitter, Input, OnChanges, OnDestroy, OnInit, Output, ViewChild} from '../../src/core';"
        },
        {
            "sha": "d4bf51945a06d0cd4e14e72639c822a769e00a48",
            "filename": "packages/core/test/application_module_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Fapplication_module_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Fapplication_module_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fapplication_module_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -7,12 +7,12 @@\n  */\n \n import {DEFAULT_CURRENCY_CODE, LOCALE_ID} from '@angular/core';\n+import {inject} from '@angular/core/testing';\n import {ivyEnabled} from '@angular/private/testing';\n \n import {getLocaleId} from '../src/render3';\n import {global} from '../src/util/global';\n import {TestBed} from '../testing';\n-import {describe, expect, inject, it} from '../testing/src/testing_internal';\n \n {\n   describe('Application module', () => {"
        },
        {
            "sha": "396d09b22990c184811970788b1f04aadbc221b8",
            "filename": "packages/core/test/change_detection/differs/iterable_differs_spec.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 10,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Fchange_detection%2Fdiffers%2Fiterable_differs_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Fchange_detection%2Fdiffers%2Fiterable_differs_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fchange_detection%2Fdiffers%2Fiterable_differs_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -9,18 +9,17 @@\n import {Injector, IterableDiffer, IterableDifferFactory, IterableDiffers, NgModule, TrackByFunction} from '@angular/core';\n import {TestBed} from '@angular/core/testing';\n \n-import {SpyIterableDifferFactory} from '../../spies';\n-\n {\n   describe('IterableDiffers', function() {\n     let factory1: any;\n     let factory2: any;\n     let factory3: any;\n \n     beforeEach(() => {\n-      factory1 = new SpyIterableDifferFactory();\n-      factory2 = new SpyIterableDifferFactory();\n-      factory3 = new SpyIterableDifferFactory();\n+      const getFactory = () => jasmine.createSpyObj('IterableDifferFactory', ['supports']);\n+      factory1 = getFactory();\n+      factory2 = getFactory();\n+      factory3 = getFactory();\n     });\n \n     it('should throw when no suitable implementation found', () => {\n@@ -30,17 +29,17 @@ import {SpyIterableDifferFactory} from '../../spies';\n     });\n \n     it('should return the first suitable implementation', () => {\n-      factory1.spy('supports').and.returnValue(false);\n-      factory2.spy('supports').and.returnValue(true);\n-      factory3.spy('supports').and.returnValue(true);\n+      factory1.supports.and.returnValue(false);\n+      factory2.supports.and.returnValue(true);\n+      factory3.supports.and.returnValue(true);\n \n       const differs = IterableDiffers.create(<any>[factory1, factory2, factory3]);\n       expect(differs.find('some object')).toBe(factory2);\n     });\n \n     it('should copy over differs from the parent repo', () => {\n-      factory1.spy('supports').and.returnValue(true);\n-      factory2.spy('supports').and.returnValue(false);\n+      factory1.supports.and.returnValue(true);\n+      factory2.supports.and.returnValue(false);\n \n       const parent = IterableDiffers.create(<any>[factory1]);\n       const child = IterableDiffers.create(<any>[factory2], parent);"
        },
        {
            "sha": "cc156bf6373e6d91b1c4ef2380bf051d2bcc0c13",
            "filename": "packages/core/test/di/forward_ref_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Fdi%2Fforward_ref_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Fdi%2Fforward_ref_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fdi%2Fforward_ref_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -8,7 +8,6 @@\n \n import {Type} from '@angular/core';\n import {forwardRef, resolveForwardRef} from '@angular/core/src/di';\n-import {describe, expect, it} from '@angular/core/testing/src/testing_internal';\n \n {\n   describe('forwardRef', function() {"
        },
        {
            "sha": "c72103b806df7848e55efa123262072f139b8a54",
            "filename": "packages/core/test/di/injector_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Fdi%2Finjector_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Fdi%2Finjector_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fdi%2Finjector_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -8,7 +8,6 @@\n \n \n import {Injector} from '@angular/core';\n-import {describe, expect, it} from '@angular/core/testing/src/testing_internal';\n \n {\n   describe('Injector.NULL', () => {"
        },
        {
            "sha": "97172b6c50c32177ad585470612fd86e18886275",
            "filename": "packages/core/test/dom/dom_adapter_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Fdom%2Fdom_adapter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Fdom%2Fdom_adapter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fdom%2Fdom_adapter_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -7,7 +7,6 @@\n  */\n \n import {getDOM as getDOM} from '@angular/common';\n-import {beforeEach, describe, expect, it} from '@angular/core/testing/src/testing_internal';\n import {isTextNode} from '@angular/platform-browser/testing/src/browser_util';\n \n {"
        },
        {
            "sha": "9f39856cef9005211278f4f2836a1bbc268d936b",
            "filename": "packages/core/test/dom/shim_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Fdom%2Fshim_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Fdom%2Fshim_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fdom%2Fshim_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,7 +6,9 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {describe, expect, it} from '@angular/core/testing/src/testing_internal';\n+// This isn't used for anything, but for some reason Bazel won't\n+// serve the file if there isn't at least one import.\n+import '@angular/core/testing';\n \n {\n   describe('Shim', () => {"
        },
        {
            "sha": "3715b0fc1b35ee992a4a139d5ca7500342a5016e",
            "filename": "packages/core/test/event_emitter_spec.ts",
            "status": "modified",
            "additions": 81,
            "deletions": 92,
            "changes": 173,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Fevent_emitter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Fevent_emitter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fevent_emitter_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,7 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AsyncTestCompleter, beforeEach, describe, expect, inject, it} from '@angular/core/testing/src/testing_internal';\n import {filter} from 'rxjs/operators';\n \n import {EventEmitter} from '../src/event_emitter';\n@@ -19,51 +18,47 @@ import {EventEmitter} from '../src/event_emitter';\n       emitter = new EventEmitter();\n     });\n \n-    it('should call the next callback',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         emitter.subscribe({\n-           next: (value: any) => {\n-             expect(value).toEqual(99);\n-             async.done();\n-           }\n-         });\n-         emitter.emit(99);\n-       }));\n-\n-    it('should call the throw callback',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         emitter.subscribe({\n-           next: () => {},\n-           error: (error: any) => {\n-             expect(error).toEqual('Boom');\n-             async.done();\n-           }\n-         });\n-         emitter.error('Boom');\n-       }));\n-\n-    it('should work when no throw callback is provided',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         emitter.subscribe({\n-           next: () => {},\n-           error: (_: any) => {\n-             async.done();\n-           }\n-         });\n-         emitter.error('Boom');\n-       }));\n-\n-    it('should call the return callback',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         emitter.subscribe({\n-           next: () => {},\n-           error: (_: any) => {},\n-           complete: () => {\n-             async.done();\n-           }\n-         });\n-         emitter.complete();\n-       }));\n+    it('should call the next callback', done => {\n+      emitter.subscribe({\n+        next: (value: any) => {\n+          expect(value).toEqual(99);\n+          done();\n+        }\n+      });\n+      emitter.emit(99);\n+    });\n+\n+    it('should call the throw callback', done => {\n+      emitter.subscribe({\n+        next: () => {},\n+        error: (error: any) => {\n+          expect(error).toEqual('Boom');\n+          done();\n+        }\n+      });\n+      emitter.error('Boom');\n+    });\n+\n+    it('should work when no throw callback is provided', done => {\n+      emitter.subscribe({\n+        next: () => {},\n+        error: (_: any) => {\n+          done();\n+        }\n+      });\n+      emitter.error('Boom');\n+    });\n+\n+    it('should call the return callback', done => {\n+      emitter.subscribe({\n+        next: () => {},\n+        error: (_: any) => {},\n+        complete: () => {\n+          done();\n+        }\n+      });\n+      emitter.complete();\n+    });\n \n     it('should subscribe to the wrapper synchronously', () => {\n       let called = false;\n@@ -77,27 +72,26 @@ import {EventEmitter} from '../src/event_emitter';\n       expect(called).toBe(true);\n     });\n \n-    it('delivers next and error events synchronously',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const log: any[] /** TODO #9100 */ = [];\n-\n-         emitter.subscribe({\n-           next: (x: any) => {\n-             log.push(x);\n-             expect(log).toEqual([1, 2]);\n-           },\n-           error: (err: any) => {\n-             log.push(err);\n-             expect(log).toEqual([1, 2, 3, 4]);\n-             async.done();\n-           }\n-         });\n-         log.push(1);\n-         emitter.emit(2);\n-         log.push(3);\n-         emitter.error(4);\n-         log.push(5);\n-       }));\n+    it('delivers next and error events synchronously', done => {\n+      const log: any[] /** TODO #9100 */ = [];\n+\n+      emitter.subscribe({\n+        next: (x: any) => {\n+          log.push(x);\n+          expect(log).toEqual([1, 2]);\n+        },\n+        error: (err: any) => {\n+          log.push(err);\n+          expect(log).toEqual([1, 2, 3, 4]);\n+          done();\n+        }\n+      });\n+      log.push(1);\n+      emitter.emit(2);\n+      log.push(3);\n+      emitter.error(4);\n+      log.push(5);\n+    });\n \n     it('delivers next and complete events synchronously', () => {\n       const log: any[] /** TODO #9100 */ = [];\n@@ -121,19 +115,18 @@ import {EventEmitter} from '../src/event_emitter';\n       expect(log).toEqual([1, 2, 3, 4, 5]);\n     });\n \n-    it('delivers events asynchronously when forced to async mode',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const e = new EventEmitter(true);\n-         const log: any[] /** TODO #9100 */ = [];\n-         e.subscribe((x: any) => {\n-           log.push(x);\n-           expect(log).toEqual([1, 3, 2]);\n-           async.done();\n-         });\n-         log.push(1);\n-         e.emit(2);\n-         log.push(3);\n-       }));\n+    it('delivers events asynchronously when forced to async mode', done => {\n+      const e = new EventEmitter(true);\n+      const log: any[] /** TODO #9100 */ = [];\n+      e.subscribe((x: any) => {\n+        log.push(x);\n+        expect(log).toEqual([1, 3, 2]);\n+        done();\n+      });\n+      log.push(1);\n+      e.emit(2);\n+      log.push(3);\n+    });\n \n     it('reports whether it has subscribers', () => {\n       const e = new EventEmitter(false);\n@@ -156,21 +149,17 @@ import {EventEmitter} from '../src/event_emitter';\n       expect(emitter.observers.length).toBe(0);\n     });\n \n-    it('unsubscribing a subscriber invokes the dispose method', () => {\n-      inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-        const sub = emitter.subscribe();\n-        sub.add(() => async.done());\n-        sub.unsubscribe();\n-      });\n+    it('unsubscribing a subscriber invokes the dispose method', done => {\n+      const sub = emitter.subscribe();\n+      sub.add(() => done());\n+      sub.unsubscribe();\n     });\n \n     it('unsubscribing a subscriber after applying operators with pipe() invokes the dispose method',\n-       () => {\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           const sub = emitter.pipe(filter(() => true)).subscribe();\n-           sub.add(() => async.done());\n-           sub.unsubscribe();\n-         });\n+       done => {\n+         const sub = emitter.pipe(filter(() => true)).subscribe();\n+         sub.add(() => done());\n+         sub.unsubscribe();\n        });\n \n     it('error thrown inside an Rx chain propagates to the error handler and disposes the chain',"
        },
        {
            "sha": "705d34669ca5e4d602ff5e32e7b9449d800ce7cb",
            "filename": "packages/core/test/fake_async_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Ffake_async_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Ffake_async_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Ffake_async_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,8 +6,8 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, tick} from '@angular/core/testing';\n-import {beforeEach, describe, inject, it, Log} from '@angular/core/testing/src/testing_internal';\n+import {discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, inject, tick} from '@angular/core/testing';\n+import {Log} from '@angular/core/testing/src/testing_internal';\n import {EventManager} from '@angular/platform-browser';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n "
        },
        {
            "sha": "a02b610d272e161e635267d49a56c191a81044c2",
            "filename": "packages/core/test/linker/inheritance_integration_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Flinker%2Finheritance_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Flinker%2Finheritance_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Finheritance_integration_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -8,7 +8,6 @@\n \n import {Component, Directive, HostBinding} from '@angular/core';\n import {TestBed} from '@angular/core/testing';\n-import {describe, expect, it} from '@angular/core/testing/src/testing_internal';\n import {modifiedInIvy, onlyInIvy} from '@angular/private/testing';\n \n @Directive({selector: '[directiveA]'})"
        },
        {
            "sha": "9acfaf7ac8f44c7839276a339002ef1da8806400",
            "filename": "packages/core/test/linker/query_list_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Flinker%2Fquery_list_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Flinker%2Fquery_list_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Fquery_list_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -10,7 +10,6 @@ import {getDOM as getDOM} from '@angular/common';\n import {iterateListLike} from '@angular/core/src/change_detection/change_detection_util';\n import {QueryList} from '@angular/core/src/linker/query_list';\n import {fakeAsync, tick} from '@angular/core/testing';\n-import {beforeEach, describe, expect, it} from '@angular/core/testing/src/testing_internal';\n \n {\n   describe('QueryList', () => {"
        },
        {
            "sha": "516be3006ca5f4b6f5938d3675cc8ab5b06810df",
            "filename": "packages/core/test/linker/system_ng_module_factory_loader_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Flinker%2Fsystem_ng_module_factory_loader_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Flinker%2Fsystem_ng_module_factory_loader_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Fsystem_ng_module_factory_loader_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -9,7 +9,6 @@\n import {Compiler, SystemJsNgModuleLoader} from '@angular/core';\n import {global} from '@angular/core/src/util/global';\n import {waitForAsync} from '@angular/core/testing';\n-import {afterEach, beforeEach, describe, expect, it} from '@angular/core/testing/src/testing_internal';\n import {modifiedInIvy, onlyInIvy} from '@angular/private/testing';\n \n function mockSystem(modules: {[module: string]: any}) {"
        },
        {
            "sha": "d3317471af6346c035d61ed0b25a4451e98453ec",
            "filename": "packages/core/test/render3/i18n/i18n_parse_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Frender3%2Fi18n%2Fi18n_parse_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Frender3%2Fi18n%2Fi18n_parse_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Fi18n%2Fi18n_parse_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -12,7 +12,6 @@ import {i18nStartFirstCreatePass} from '@angular/core/src/render3/i18n/i18n_pars\n import {getTIcu} from '@angular/core/src/render3/i18n/i18n_util';\n import {I18nUpdateOpCodes, IcuType, TI18n} from '@angular/core/src/render3/interfaces/i18n';\n import {HEADER_OFFSET, HOST} from '@angular/core/src/render3/interfaces/view';\n-import {expect} from '@angular/core/testing/src/testing_internal';\n import {matchTI18n, matchTIcu} from '../matchers';\n import {matchDebug} from '../utils';\n import {ViewFixture} from '../view_fixture';"
        },
        {
            "sha": "6e64cdab19ec1e3dd6327b99d9c73921e731e639",
            "filename": "packages/core/test/render3/instructions/styling_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Frender3%2Finstructions%2Fstyling_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Frender3%2Finstructions%2Fstyling_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Finstructions%2Fstyling_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -17,7 +17,6 @@ import {getNativeByIndex} from '@angular/core/src/render3/util/view_utils';\n import {keyValueArraySet} from '@angular/core/src/util/array_utils';\n import {ngDevModeResetPerfCounters} from '@angular/core/src/util/ng_dev_mode';\n import {getElementClasses, getElementStyles} from '@angular/core/testing/src/styling';\n-import {expect} from '@angular/core/testing/src/testing_internal';\n \n import {clearFirstUpdatePass, enterViewWithOneDiv, rewindBindingIndex} from './shared_spec';\n "
        },
        {
            "sha": "8502b9ffd96aaab23a9a4a450c05897b7f8f7f86",
            "filename": "packages/core/test/render3/util/attr_util_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Frender3%2Futil%2Fattr_util_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Frender3%2Futil%2Fattr_util_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Futil%2Fattr_util_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -9,7 +9,6 @@\n import {AttributeMarker} from '@angular/core/src/render3';\n import {TAttributes} from '@angular/core/src/render3/interfaces/node';\n import {mergeHostAttribute, mergeHostAttrs} from '@angular/core/src/render3/util/attrs_utils';\n-import {describe} from '@angular/core/testing/src/testing_internal';\n \n describe('attr_util', () => {\n   describe('mergeHostAttribute', () => {"
        },
        {
            "sha": "41330e631700b4853e35bd4f5915addc3504e9af",
            "filename": "packages/core/test/sanitization/url_sanitizer_spec.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 15,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Fsanitization%2Furl_sanitizer_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Fsanitization%2Furl_sanitizer_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fsanitization%2Furl_sanitizer_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,16 +6,14 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import * as t from '@angular/core/testing/src/testing_internal';\n-\n import {_sanitizeUrl, sanitizeSrcset} from '../../src/sanitization/url_sanitizer';\n \n {\n-  t.describe('URL sanitizer', () => {\n+  describe('URL sanitizer', () => {\n     let logMsgs: string[];\n     let originalLog: (msg: any) => any;\n \n-    t.beforeEach(() => {\n+    beforeEach(() => {\n       logMsgs = [];\n       originalLog = console.warn;  // Monkey patch DOM.log.\n       console.warn = (msg: any) => logMsgs.push(msg);\n@@ -25,12 +23,12 @@ import {_sanitizeUrl, sanitizeSrcset} from '../../src/sanitization/url_sanitizer\n       console.warn = originalLog;\n     });\n \n-    t.it('reports unsafe URLs', () => {\n-      t.expect(_sanitizeUrl('javascript:evil()')).toBe('unsafe:javascript:evil()');\n-      t.expect(logMsgs.join('\\n')).toMatch(/sanitizing unsafe URL value/);\n+    it('reports unsafe URLs', () => {\n+      expect(_sanitizeUrl('javascript:evil()')).toBe('unsafe:javascript:evil()');\n+      expect(logMsgs.join('\\n')).toMatch(/sanitizing unsafe URL value/);\n     });\n \n-    t.describe('valid URLs', () => {\n+    describe('valid URLs', () => {\n       const validUrls = [\n         '',\n         'http://abc',\n@@ -51,11 +49,11 @@ import {_sanitizeUrl, sanitizeSrcset} from '../../src/sanitization/url_sanitizer\n         'data:audio/opus;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/',\n       ];\n       for (const url of validUrls) {\n-        t.it(`valid ${url}`, () => t.expect(_sanitizeUrl(url)).toEqual(url));\n+        it(`valid ${url}`, () => expect(_sanitizeUrl(url)).toEqual(url));\n       }\n     });\n \n-    t.describe('invalid URLs', () => {\n+    describe('invalid URLs', () => {\n       const invalidUrls = [\n         'javascript:evil()',\n         'JavaScript:abc',\n@@ -75,11 +73,11 @@ import {_sanitizeUrl, sanitizeSrcset} from '../../src/sanitization/url_sanitizer\n         'data:application/x-msdownload;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/',\n       ];\n       for (const url of invalidUrls) {\n-        t.it(`valid ${url}`, () => t.expect(_sanitizeUrl(url)).toMatch(/^unsafe:/));\n+        it(`valid ${url}`, () => expect(_sanitizeUrl(url)).toMatch(/^unsafe:/));\n       }\n     });\n \n-    t.describe('valid srcsets', () => {\n+    describe('valid srcsets', () => {\n       const validSrcsets = [\n         '',\n         'http://angular.io/images/test.png',\n@@ -102,17 +100,17 @@ import {_sanitizeUrl, sanitizeSrcset} from '../../src/sanitization/url_sanitizer\n         'http://angular.io/images/test.png?maxage=234, http://angular.io/images/test.png?maxage=234',\n       ];\n       for (const srcset of validSrcsets) {\n-        t.it(`valid ${srcset}`, () => t.expect(sanitizeSrcset(srcset)).toEqual(srcset));\n+        it(`valid ${srcset}`, () => expect(sanitizeSrcset(srcset)).toEqual(srcset));\n       }\n     });\n \n-    t.describe('invalid srcsets', () => {\n+    describe('invalid srcsets', () => {\n       const invalidSrcsets = [\n         'ht:tp://angular.io/images/test.png',\n         'http://angular.io/images/test.png, ht:tp://angular.io/images/test.png',\n       ];\n       for (const srcset of invalidSrcsets) {\n-        t.it(`valid ${srcset}`, () => t.expect(sanitizeSrcset(srcset)).toMatch(/unsafe:/));\n+        it(`valid ${srcset}`, () => expect(sanitizeSrcset(srcset)).toMatch(/unsafe:/));\n       }\n     });\n   });"
        },
        {
            "sha": "557bf44fe89aa5eaf461bd9e372bfcb22e8309b8",
            "filename": "packages/core/test/spies.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 28,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae/packages%2Fcore%2Ftest%2Fspies.ts",
            "raw_url": "https://github.com/angular/angular/raw/bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae/packages%2Fcore%2Ftest%2Fspies.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fspies.ts?ref=bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae",
            "patch": "@@ -1,28 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {DomAdapter} from '@angular/common/src/dom_adapter';\n-import {ElementRef} from '@angular/core';\n-import {ChangeDetectorRef} from '@angular/core/src/change_detection/change_detection';\n-import {SpyObject} from '@angular/core/testing/src/testing_internal';\n-\n-export class SpyChangeDetectorRef extends SpyObject {\n-  constructor() {\n-    super(ChangeDetectorRef);\n-    this.spy('detectChanges');\n-    this.spy('checkNoChanges');\n-  }\n-}\n-\n-export class SpyIterableDifferFactory extends SpyObject {}\n-\n-export class SpyElementRef extends SpyObject {\n-  constructor() {\n-    super(ElementRef);\n-  }\n-}"
        },
        {
            "sha": "e4f11a90809a3a283478d79ea66c3aaaef2edc23",
            "filename": "packages/core/test/test_bed_async_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 21,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae/packages%2Fcore%2Ftest%2Ftest_bed_async_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae/packages%2Fcore%2Ftest%2Ftest_bed_async_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Ftest_bed_async_spec.ts?ref=bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae",
            "patch": "@@ -1,21 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {TestBed} from '@angular/core/testing/src/test_bed';\n-import {AsyncTestCompleter, ddescribe, describe, inject, it} from '@angular/core/testing/src/testing_internal';\n-\n-describe('TestBed with async processing', () => {\n-  beforeEach(() => {\n-    TestBed.resetTestingModule();\n-  });\n-\n-  it('should allow injecting AsyncTestCompleter',\n-     inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-       async.done();\n-     }));\n-});"
        },
        {
            "sha": "63dd0bffc89d58b542e7f715fb17eb08e3e56499",
            "filename": "packages/core/test/testability/testability_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Ftestability%2Ftestability_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Ftestability%2Ftestability_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Ftestability%2Ftestability_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -11,7 +11,6 @@ import {Injectable} from '@angular/core/src/di';\n import {PendingMacrotask, Testability, TestabilityRegistry} from '@angular/core/src/testability/testability';\n import {NgZone} from '@angular/core/src/zone/ng_zone';\n import {fakeAsync, flush, tick, waitForAsync} from '@angular/core/testing';\n-import {beforeEach, describe, expect, it, SpyObject} from '@angular/core/testing/src/testing_internal';\n \n import {scheduleMicroTask} from '../../src/util/microtask';\n \n@@ -58,9 +57,9 @@ class MockNgZone extends NgZone {\n     beforeEach(waitForAsync(() => {\n       ngZone = new MockNgZone();\n       testability = new Testability(ngZone);\n-      execute = new SpyObject().spy('execute');\n-      execute2 = new SpyObject().spy('execute');\n-      updateCallback = new SpyObject().spy('execute');\n+      execute = jasmine.createSpy('execute');\n+      execute2 = jasmine.createSpy('execute');\n+      updateCallback = jasmine.createSpy('execute');\n     }));\n \n     describe('Pending count logic', () => {"
        },
        {
            "sha": "b6252ad1649337d0e885b58fa48b4918ca6bfdb2",
            "filename": "packages/core/test/testing_internal_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 144,
            "changes": 144,
            "blob_url": "https://github.com/angular/angular/blob/bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae/packages%2Fcore%2Ftest%2Ftesting_internal_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae/packages%2Fcore%2Ftest%2Ftesting_internal_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Ftesting_internal_spec.ts?ref=bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae",
            "patch": "@@ -1,144 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {SpyObject} from '@angular/core/testing/src/testing_internal';\n-\n-class TestObj {\n-  prop: any;\n-  constructor(prop: any) {\n-    this.prop = prop;\n-  }\n-  someFunc(): number {\n-    return -1;\n-  }\n-  someComplexFunc(a: any) {\n-    return a;\n-  }\n-}\n-\n-{\n-  describe('testing', () => {\n-    describe('should respect custom equality tester', () => {\n-      beforeEach(() => {\n-        const equalIfMarried = (first: any, second: any) => {\n-          return first === 'kevin' && second === 'patricia';\n-        };\n-        jasmine.addCustomEqualityTester(equalIfMarried);\n-      });\n-\n-      it('for positive test', () => {\n-        expect('kevin').toEqual('patricia');\n-      });\n-\n-      it('for negative test', () => {\n-        expect('kevin').not.toEqual('kevin');\n-      });\n-    });\n-\n-    describe('equality', () => {\n-      it('should structurally compare objects', () => {\n-        const expected = new TestObj(new TestObj({'one': [1, 2]}));\n-        const actual = new TestObj(new TestObj({'one': [1, 2]}));\n-        const falseActual = new TestObj(new TestObj({'one': [1, 3]}));\n-\n-        expect(actual).toEqual(expected);\n-        expect(falseActual).not.toEqual(expected);\n-      });\n-    });\n-\n-    describe('toEqual for Maps', () => {\n-      it('should detect equality for same reference', () => {\n-        const m1: Map<string, number> = new Map();\n-        m1.set('a', 1);\n-        expect(m1).toEqual(m1);\n-      });\n-\n-      it('should detect equality for same content', () => {\n-        const m1: Map<string, number> = new Map();\n-        m1.set('a', 1);\n-        const m2: Map<string, number> = new Map();\n-        m2.set('a', 1);\n-        expect(m1).toEqual(m2);\n-      });\n-\n-      it('should detect missing entries', () => {\n-        const m1: Map<string, number> = new Map();\n-        m1.set('a', 1);\n-        const m2: Map<string, number> = new Map();\n-        expect(m1).not.toEqual(m2);\n-      });\n-\n-      it('should detect different values', () => {\n-        const m1: Map<string, number> = new Map();\n-        m1.set('a', 1);\n-        const m2: Map<string, number> = new Map();\n-        m2.set('a', 2);\n-        expect(m1).not.toEqual(m2);\n-      });\n-\n-      it('should detect additional entries', () => {\n-        const m1: Map<string, number> = new Map();\n-        m1.set('a', 1);\n-        const m2: Map<string, number> = new Map();\n-        m2.set('a', 1);\n-        m2.set('b', 2);\n-        expect(m1).not.toEqual(m2);\n-      });\n-    });\n-\n-    describe('spy objects', () => {\n-      let spyObj: any;\n-\n-      beforeEach(() => {\n-        spyObj = new SpyObject(TestObj);\n-      });\n-\n-      it('should return a new spy func with no calls', () => {\n-        expect(spyObj.spy('someFunc')).not.toHaveBeenCalled();\n-      });\n-\n-      it('should record function calls', () => {\n-        spyObj.spy('someFunc').and.callFake((a: any, b: any) => a + b);\n-\n-        expect(spyObj.someFunc(1, 2)).toEqual(3);\n-        expect(spyObj.spy('someFunc')).toHaveBeenCalledWith(1, 2);\n-      });\n-\n-      it('should match multiple function calls', () => {\n-        spyObj.spy('someFunc');\n-        spyObj.someFunc(1, 2);\n-        spyObj.someFunc(3, 4);\n-        expect(spyObj.spy('someFunc')).toHaveBeenCalledWith(1, 2);\n-        expect(spyObj.spy('someFunc')).toHaveBeenCalledWith(3, 4);\n-      });\n-\n-      it('should match null arguments', () => {\n-        spyObj.spy('someFunc');\n-        spyObj.someFunc(null, 'hello');\n-        expect(spyObj.spy('someFunc')).toHaveBeenCalledWith(null, 'hello');\n-      });\n-\n-      it('should match using deep equality', () => {\n-        spyObj.spy('someComplexFunc');\n-        spyObj.someComplexFunc([1]);\n-        expect(spyObj.spy('someComplexFunc')).toHaveBeenCalledWith([1]);\n-      });\n-\n-      it('should support stubs', () => {\n-        const s = SpyObject.stub({'a': 1}, {'b': 2});\n-        expect(s.a()).toEqual(1);\n-        expect(s.b()).toEqual(2);\n-      });\n-\n-      it('should create spys for all methods', () => {\n-        spyObj.spy('someFunc');\n-        expect(() => spyObj.someFunc()).not.toThrow();\n-      });\n-    });\n-  });\n-}"
        },
        {
            "sha": "2cfd8fe0f9d8e84dcc40c0a7d129b62ed9a503a3",
            "filename": "packages/core/test/zone/ng_zone_spec.ts",
            "status": "modified",
            "additions": 390,
            "deletions": 410,
            "changes": 800,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Fzone%2Fng_zone_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftest%2Fzone%2Fng_zone_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fzone%2Fng_zone_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -7,8 +7,8 @@\n  */\n \n import {EventEmitter, NgZone} from '@angular/core';\n-import {fakeAsync, flushMicrotasks, waitForAsync} from '@angular/core/testing';\n-import {AsyncTestCompleter, beforeEach, describe, expect, inject, it, Log, xit} from '@angular/core/testing/src/testing_internal';\n+import {fakeAsync, flushMicrotasks, inject, waitForAsync} from '@angular/core/testing';\n+import {Log} from '@angular/core/testing/src/testing_internal';\n import {browserDetection} from '@angular/platform-browser/testing/src/browser_util';\n \n import {global} from '../../src/util/global';\n@@ -18,7 +18,6 @@ import {NoopNgZone} from '../../src/zone/ng_zone';\n \n const needsLongerTimers = browserDetection.isSlow || browserDetection.isEdge;\n const resultTimer = 1000;\n-const testTimeout = browserDetection.isEdge ? 1200 : 500;\n // Schedules a macrotask (using a timer)\n function macroTask(fn: (...args: any[]) => void, timer = 1): void {\n   // adds longer timers for passing tests in IE and Edge\n@@ -88,55 +87,53 @@ function runNgZoneNoLog(fn: () => any) {\n \n       commonTests();\n \n-      it('should produce long stack traces',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           macroTask(() => {\n-             let resolve: (result: any) => void;\n-             const promise: Promise<any> = new Promise((res) => {\n-               resolve = res;\n-             });\n+      it('should produce long stack traces', done => {\n+        macroTask(() => {\n+          let resolve: (result: any) => void;\n+          const promise: Promise<any> = new Promise((res) => {\n+            resolve = res;\n+          });\n \n-             _zone.run(() => {\n-               setTimeout(() => {\n-                 setTimeout(() => {\n-                   resolve(null);\n-                   throw new Error('ccc');\n-                 }, 0);\n-               }, 0);\n-             });\n+          _zone.run(() => {\n+            setTimeout(() => {\n+              setTimeout(() => {\n+                resolve(null);\n+                throw new Error('ccc');\n+              }, 0);\n+            }, 0);\n+          });\n \n-             promise.then((_) => {\n-               expect(_traces.length).toBe(1);\n-               expect(_traces[0].length).toBeGreaterThan(1);\n-               async.done();\n-             });\n-           });\n-         }), testTimeout);\n+          promise.then((_) => {\n+            expect(_traces.length).toBe(1);\n+            expect(_traces[0].length).toBeGreaterThan(1);\n+            done();\n+          });\n+        });\n+      });\n \n-      it('should produce long stack traces (when using microtasks)',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           macroTask(() => {\n-             let resolve: (result: any) => void;\n-             const promise: Promise<any> = new Promise((res) => {\n-               resolve = res;\n-             });\n+      it('should produce long stack traces (when using microtasks)', done => {\n+        macroTask(() => {\n+          let resolve: (result: any) => void;\n+          const promise: Promise<any> = new Promise((res) => {\n+            resolve = res;\n+          });\n \n-             _zone.run(() => {\n-               scheduleMicroTask(() => {\n-                 scheduleMicroTask(() => {\n-                   resolve(null);\n-                   throw new Error('ddd');\n-                 });\n-               });\n-             });\n+          _zone.run(() => {\n+            scheduleMicroTask(() => {\n+              scheduleMicroTask(() => {\n+                resolve(null);\n+                throw new Error('ddd');\n+              });\n+            });\n+          });\n \n-             promise.then((_) => {\n-               expect(_traces.length).toBe(1);\n-               expect(_traces[0].length).toBeGreaterThan(1);\n-               async.done();\n-             });\n-           });\n-         }), testTimeout);\n+          promise.then((_) => {\n+            expect(_traces.length).toBe(1);\n+            expect(_traces[0].length).toBeGreaterThan(1);\n+            done();\n+          });\n+        });\n+      });\n     });\n \n     describe('short stack trace', () => {\n@@ -150,33 +147,32 @@ function runNgZoneNoLog(fn: () => any) {\n \n       commonTests();\n \n-      it('should disable long stack traces',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           macroTask(() => {\n-             let resolve: (result: any) => void;\n-             const promise: Promise<any> = new Promise((res) => {\n-               resolve = res;\n-             });\n+      it('should disable long stack traces', done => {\n+        macroTask(() => {\n+          let resolve: (result: any) => void;\n+          const promise: Promise<any> = new Promise((res) => {\n+            resolve = res;\n+          });\n \n-             _zone.run(() => {\n-               setTimeout(() => {\n-                 setTimeout(() => {\n-                   resolve(null);\n-                   throw new Error('ccc');\n-                 }, 0);\n-               }, 0);\n-             });\n+          _zone.run(() => {\n+            setTimeout(() => {\n+              setTimeout(() => {\n+                resolve(null);\n+                throw new Error('ccc');\n+              }, 0);\n+            }, 0);\n+          });\n \n-             promise.then((_) => {\n-               expect(_traces.length).toBe(1);\n-               if (_traces[0] != null) {\n-                 // some browsers don't have stack traces.\n-                 expect(_traces[0].indexOf('---')).toEqual(-1);\n-               }\n-               async.done();\n-             });\n-           });\n-         }), testTimeout);\n+          promise.then((_) => {\n+            expect(_traces.length).toBe(1);\n+            if (_traces[0] != null) {\n+              // some browsers don't have stack traces.\n+              expect(_traces[0].indexOf('---')).toEqual(-1);\n+            }\n+            done();\n+          });\n+        });\n+      });\n     });\n   });\n \n@@ -287,173 +283,164 @@ function commonTests() {\n       runNgZoneNoLog(() => {\n         expect(NgZone.isInAngularZone()).toEqual(true);\n       });\n-    }, testTimeout);\n+    });\n   });\n \n   describe('run', () => {\n-    it('should return the body return value from run',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         macroTask(() => {\n-           expect(_zone.run(() => 6)).toEqual(6);\n-         });\n+    it('should return the body return value from run', done => {\n+      macroTask(() => {\n+        expect(_zone.run(() => 6)).toEqual(6);\n+      });\n \n-         macroTask(() => {\n-           async.done();\n-         });\n-       }), testTimeout);\n+      macroTask(() => {\n+        done();\n+      });\n+    });\n \n-    it('should return the body return value from runTask',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         macroTask(() => {\n-           expect(_zone.runTask(() => 6)).toEqual(6);\n-         });\n+    it('should return the body return value from runTask', done => {\n+      macroTask(() => {\n+        expect(_zone.runTask(() => 6)).toEqual(6);\n+      });\n \n-         macroTask(() => {\n-           async.done();\n-         });\n-       }), testTimeout);\n+      macroTask(() => {\n+        done();\n+      });\n+    });\n \n-    it('should call onUnstable and onMicrotaskEmpty',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         runNgZoneNoLog(() => macroTask(_log.fn('run')));\n-         macroTask(() => {\n-           expect(_log.result()).toEqual('onUnstable; run; onMicrotaskEmpty; onStable');\n-           async.done();\n-         });\n-       }), testTimeout);\n+    it('should call onUnstable and onMicrotaskEmpty', done => {\n+      runNgZoneNoLog(() => macroTask(_log.fn('run')));\n+      macroTask(() => {\n+        expect(_log.result()).toEqual('onUnstable; run; onMicrotaskEmpty; onStable');\n+        done();\n+      });\n+    });\n \n-    it('should call onStable once at the end of event',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         // The test is set up in a way that causes the zone loop to run onMicrotaskEmpty twice\n-         // then verified that onStable is only called once at the end\n+    it('should call onStable once at the end of event', done => {\n+      // The test is set up in a way that causes the zone loop to run onMicrotaskEmpty twice\n+      // then verified that onStable is only called once at the end\n \n-         runNgZoneNoLog(() => macroTask(_log.fn('run')));\n+      runNgZoneNoLog(() => macroTask(_log.fn('run')));\n \n-         let times = 0;\n-         _zone.onMicrotaskEmpty.subscribe({\n-           next: () => {\n-             times++;\n-             _log.add(`onMicrotaskEmpty ${times}`);\n-             if (times < 2) {\n-               // Scheduling a microtask causes a second digest\n-               runNgZoneNoLog(() => {\n-                 scheduleMicroTask(() => {});\n-               });\n-             }\n-           }\n-         });\n+      let times = 0;\n+      _zone.onMicrotaskEmpty.subscribe({\n+        next: () => {\n+          times++;\n+          _log.add(`onMicrotaskEmpty ${times}`);\n+          if (times < 2) {\n+            // Scheduling a microtask causes a second digest\n+            runNgZoneNoLog(() => {\n+              scheduleMicroTask(() => {});\n+            });\n+          }\n+        }\n+      });\n \n-         macroTask(() => {\n-           expect(_log.result())\n-               .toEqual(\n-                   'onUnstable; run; onMicrotaskEmpty; onMicrotaskEmpty 1; ' +\n-                   'onMicrotaskEmpty; onMicrotaskEmpty 2; onStable');\n-           async.done();\n-         }, resultTimer);\n-       }), testTimeout);\n+      macroTask(() => {\n+        expect(_log.result())\n+            .toEqual(\n+                'onUnstable; run; onMicrotaskEmpty; onMicrotaskEmpty 1; ' +\n+                'onMicrotaskEmpty; onMicrotaskEmpty 2; onStable');\n+        done();\n+      }, resultTimer);\n+    });\n \n-    it('should call standalone onStable',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         runNgZoneNoLog(() => macroTask(_log.fn('run')));\n+    it('should call standalone onStable', done => {\n+      runNgZoneNoLog(() => macroTask(_log.fn('run')));\n \n-         macroTask(() => {\n-           expect(_log.result()).toEqual('onUnstable; run; onMicrotaskEmpty; onStable');\n-           async.done();\n-         }, resultTimer);\n-       }), testTimeout);\n-\n-    xit('should run subscriber listeners in the subscription zone (outside)',\n-        inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-          // Each subscriber fires a microtask outside the Angular zone. The test\n-          // then verifies that those microtasks do not cause additional digests.\n-\n-          let turnStart = false;\n-          _zone.onUnstable.subscribe({\n-            next: () => {\n-              if (turnStart) throw 'Should not call this more than once';\n-              _log.add('onUnstable');\n-              scheduleMicroTask(() => {});\n-              turnStart = true;\n-            }\n-          });\n+      macroTask(() => {\n+        expect(_log.result()).toEqual('onUnstable; run; onMicrotaskEmpty; onStable');\n+        done();\n+      }, resultTimer);\n+    });\n \n-          let turnDone = false;\n-          _zone.onMicrotaskEmpty.subscribe({\n-            next: () => {\n-              if (turnDone) throw 'Should not call this more than once';\n-              _log.add('onMicrotaskEmpty');\n-              scheduleMicroTask(() => {});\n-              turnDone = true;\n-            }\n-          });\n+    xit('should run subscriber listeners in the subscription zone (outside)', done => {\n+      // Each subscriber fires a microtask outside the Angular zone. The test\n+      // then verifies that those microtasks do not cause additional digests.\n+\n+      let turnStart = false;\n+      _zone.onUnstable.subscribe({\n+        next: () => {\n+          if (turnStart) throw 'Should not call this more than once';\n+          _log.add('onUnstable');\n+          scheduleMicroTask(() => {});\n+          turnStart = true;\n+        }\n+      });\n \n-          let eventDone = false;\n-          _zone.onStable.subscribe({\n-            next: () => {\n-              if (eventDone) throw 'Should not call this more than once';\n-              _log.add('onStable');\n-              scheduleMicroTask(() => {});\n-              eventDone = true;\n-            }\n-          });\n+      let turnDone = false;\n+      _zone.onMicrotaskEmpty.subscribe({\n+        next: () => {\n+          if (turnDone) throw 'Should not call this more than once';\n+          _log.add('onMicrotaskEmpty');\n+          scheduleMicroTask(() => {});\n+          turnDone = true;\n+        }\n+      });\n \n-          macroTask(() => {\n-            _zone.run(_log.fn('run'));\n-          });\n+      let eventDone = false;\n+      _zone.onStable.subscribe({\n+        next: () => {\n+          if (eventDone) throw 'Should not call this more than once';\n+          _log.add('onStable');\n+          scheduleMicroTask(() => {});\n+          eventDone = true;\n+        }\n+      });\n \n-          macroTask(() => {\n-            expect(_log.result()).toEqual('onUnstable; run; onMicrotaskEmpty; onStable');\n-            async.done();\n-          }, resultTimer);\n-        }), testTimeout);\n+      macroTask(() => {\n+        _zone.run(_log.fn('run'));\n+      });\n \n-    it('should run subscriber listeners in the subscription zone (inside)',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         runNgZoneNoLog(() => macroTask(_log.fn('run')));\n+      macroTask(() => {\n+        expect(_log.result()).toEqual('onUnstable; run; onMicrotaskEmpty; onStable');\n+        done();\n+      }, resultTimer);\n+    });\n \n-         // the only practical use-case to run a callback inside the zone is\n-         // change detection after \"onMicrotaskEmpty\". That's the only case tested.\n-         let turnDone = false;\n-         _zone.onMicrotaskEmpty.subscribe({\n-           next: () => {\n-             _log.add('onMyMicrotaskEmpty');\n-             if (turnDone) return;\n-             _zone.run(() => {\n-               scheduleMicroTask(() => {});\n-             });\n-             turnDone = true;\n-           }\n-         });\n+    it('should run subscriber listeners in the subscription zone (inside)', done => {\n+      runNgZoneNoLog(() => macroTask(_log.fn('run')));\n+\n+      // the only practical use-case to run a callback inside the zone is\n+      // change detection after \"onMicrotaskEmpty\". That's the only case tested.\n+      let turnDone = false;\n+      _zone.onMicrotaskEmpty.subscribe({\n+        next: () => {\n+          _log.add('onMyMicrotaskEmpty');\n+          if (turnDone) return;\n+          _zone.run(() => {\n+            scheduleMicroTask(() => {});\n+          });\n+          turnDone = true;\n+        }\n+      });\n \n-         macroTask(() => {\n-           expect(_log.result())\n-               .toEqual(\n-                   'onUnstable; run; onMicrotaskEmpty; onMyMicrotaskEmpty; ' +\n-                   'onMicrotaskEmpty; onMyMicrotaskEmpty; onStable');\n-           async.done();\n-         }, resultTimer);\n-       }), testTimeout);\n+      macroTask(() => {\n+        expect(_log.result())\n+            .toEqual(\n+                'onUnstable; run; onMicrotaskEmpty; onMyMicrotaskEmpty; ' +\n+                'onMicrotaskEmpty; onMyMicrotaskEmpty; onStable');\n+        done();\n+      }, resultTimer);\n+    });\n \n-    it('should run async tasks scheduled inside onStable outside Angular zone',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         runNgZoneNoLog(() => macroTask(_log.fn('run')));\n+    it('should run async tasks scheduled inside onStable outside Angular zone', done => {\n+      runNgZoneNoLog(() => macroTask(_log.fn('run')));\n \n-         _zone.onStable.subscribe({\n-           next: () => {\n-             NgZone.assertNotInAngularZone();\n-             _log.add('onMyTaskDone');\n-           }\n-         });\n+      _zone.onStable.subscribe({\n+        next: () => {\n+          NgZone.assertNotInAngularZone();\n+          _log.add('onMyTaskDone');\n+        }\n+      });\n \n-         macroTask(() => {\n-           expect(_log.result())\n-               .toEqual('onUnstable; run; onMicrotaskEmpty; onStable; onMyTaskDone');\n-           async.done();\n-         });\n-       }), testTimeout);\n+      macroTask(() => {\n+        expect(_log.result()).toEqual('onUnstable; run; onMicrotaskEmpty; onStable; onMyTaskDone');\n+        done();\n+      });\n+    });\n \n     it('should call onUnstable once before a turn and onMicrotaskEmpty once after the turn',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n+       done => {\n          runNgZoneNoLog(() => {\n            macroTask(() => {\n              _log.add('run start');\n@@ -466,33 +453,32 @@ function commonTests() {\n            // The microtask (async) is executed after the macrotask (run)\n            expect(_log.result())\n                .toEqual('onUnstable; run start; run end; async; onMicrotaskEmpty; onStable');\n-           async.done();\n+           done();\n          }, resultTimer);\n-       }), testTimeout);\n+       });\n \n-    it('should not run onUnstable and onMicrotaskEmpty for nested Zone.run',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         runNgZoneNoLog(() => {\n-           macroTask(() => {\n-             _log.add('start run');\n-             _zone.run(() => {\n-               _log.add('nested run');\n-               scheduleMicroTask(_log.fn('nested run microtask'));\n-             });\n-             _log.add('end run');\n-           });\n-         });\n+    it('should not run onUnstable and onMicrotaskEmpty for nested Zone.run', done => {\n+      runNgZoneNoLog(() => {\n+        macroTask(() => {\n+          _log.add('start run');\n+          _zone.run(() => {\n+            _log.add('nested run');\n+            scheduleMicroTask(_log.fn('nested run microtask'));\n+          });\n+          _log.add('end run');\n+        });\n+      });\n \n-         macroTask(() => {\n-           expect(_log.result())\n-               .toEqual(\n-                   'onUnstable; start run; nested run; end run; nested run microtask; onMicrotaskEmpty; onStable');\n-           async.done();\n-         }, resultTimer);\n-       }), testTimeout);\n+      macroTask(() => {\n+        expect(_log.result())\n+            .toEqual(\n+                'onUnstable; start run; nested run; end run; nested run microtask; onMicrotaskEmpty; onStable');\n+        done();\n+      }, resultTimer);\n+    });\n \n     it('should not run onUnstable and onMicrotaskEmpty for nested Zone.run invoked from onMicrotaskEmpty',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n+       done => {\n          runNgZoneNoLog(() => macroTask(_log.fn('start run')));\n \n          _zone.onMicrotaskEmpty.subscribe({\n@@ -507,74 +493,71 @@ function commonTests() {\n            expect(_log.result())\n                .toEqual(\n                    'onUnstable; start run; onMicrotaskEmpty; onMicrotaskEmpty:started; nested run; onMicrotaskEmpty:finished; onStable');\n-           async.done();\n-         }, resultTimer);\n-       }), testTimeout);\n-\n-    it('should call onUnstable and onMicrotaskEmpty before and after each top-level run',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         runNgZoneNoLog(() => macroTask(_log.fn('run1')));\n-         runNgZoneNoLog(() => macroTask(_log.fn('run2')));\n-\n-         macroTask(() => {\n-           expect(_log.result())\n-               .toEqual(\n-                   'onUnstable; run1; onMicrotaskEmpty; onStable; onUnstable; run2; onMicrotaskEmpty; onStable');\n-           async.done();\n+           done();\n          }, resultTimer);\n-       }), testTimeout);\n+       });\n+\n+    it('should call onUnstable and onMicrotaskEmpty before and after each top-level run', done => {\n+      runNgZoneNoLog(() => macroTask(_log.fn('run1')));\n+      runNgZoneNoLog(() => macroTask(_log.fn('run2')));\n+\n+      macroTask(() => {\n+        expect(_log.result())\n+            .toEqual(\n+                'onUnstable; run1; onMicrotaskEmpty; onStable; onUnstable; run2; onMicrotaskEmpty; onStable');\n+        done();\n+      }, resultTimer);\n+    });\n \n-    it('should call onUnstable and onMicrotaskEmpty before and after each turn',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         let aResolve: (result: string) => void;\n-         let aPromise: Promise<string>;\n-         let bResolve: (result: string) => void;\n-         let bPromise: Promise<string>;\n+    it('should call onUnstable and onMicrotaskEmpty before and after each turn', done => {\n+      let aResolve: (result: string) => void;\n+      let aPromise: Promise<string>;\n+      let bResolve: (result: string) => void;\n+      let bPromise: Promise<string>;\n \n-         runNgZoneNoLog(() => {\n-           macroTask(() => {\n-             aPromise = new Promise(res => {\n-               aResolve = res;\n-             });\n-             bPromise = new Promise(res => {\n-               bResolve = res;\n-             });\n+      runNgZoneNoLog(() => {\n+        macroTask(() => {\n+          aPromise = new Promise(res => {\n+            aResolve = res;\n+          });\n+          bPromise = new Promise(res => {\n+            bResolve = res;\n+          });\n \n-             _log.add('run start');\n-             aPromise.then(_log.fn('a then'));\n-             bPromise.then(_log.fn('b then'));\n-           });\n-         });\n+          _log.add('run start');\n+          aPromise.then(_log.fn('a then'));\n+          bPromise.then(_log.fn('b then'));\n+        });\n+      });\n \n-         runNgZoneNoLog(() => {\n-           macroTask(() => {\n-             aResolve('a');\n-             bResolve('b');\n-           });\n-         });\n+      runNgZoneNoLog(() => {\n+        macroTask(() => {\n+          aResolve('a');\n+          bResolve('b');\n+        });\n+      });\n \n-         macroTask(() => {\n-           expect(_log.result())\n-               .toEqual(\n-                   'onUnstable; run start; onMicrotaskEmpty; onStable; onUnstable; a then; b then; onMicrotaskEmpty; onStable');\n-           async.done();\n-         }, resultTimer);\n-       }), testTimeout);\n+      macroTask(() => {\n+        expect(_log.result())\n+            .toEqual(\n+                'onUnstable; run start; onMicrotaskEmpty; onStable; onUnstable; a then; b then; onMicrotaskEmpty; onStable');\n+        done();\n+      }, resultTimer);\n+    });\n \n-    it('should run a function outside of the angular zone',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         macroTask(() => {\n-           _zone.runOutsideAngular(_log.fn('run'));\n-         });\n+    it('should run a function outside of the angular zone', done => {\n+      macroTask(() => {\n+        _zone.runOutsideAngular(_log.fn('run'));\n+      });\n \n-         macroTask(() => {\n-           expect(_log.result()).toEqual('run');\n-           async.done();\n-         });\n-       }), testTimeout);\n+      macroTask(() => {\n+        expect(_log.result()).toEqual('run');\n+        done();\n+      });\n+    });\n \n     it('should call onUnstable and onMicrotaskEmpty when an inner microtask is scheduled from outside angular',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n+       done => {\n          let resolve: (result: string|null) => void;\n          let promise: Promise<string|null>;\n \n@@ -608,13 +591,13 @@ function commonTests() {\n                    // Third VM Turn => execute the microtask (inside angular)\n                    // No onUnstable;  because we don't own the task which started the turn.\n                    'executedMicrotask; onMicrotaskEmpty; onStable');\n-           async.done();\n+           done();\n          }, resultTimer);\n-       }), testTimeout);\n+       });\n \n     it('should call onUnstable only before executing a microtask scheduled in onMicrotaskEmpty ' +\n            'and not onMicrotaskEmpty after executing the task',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n+       done => {\n          runNgZoneNoLog(() => macroTask(_log.fn('run')));\n \n          let ran = false;\n@@ -642,13 +625,13 @@ function commonTests() {\n                    'onUnstable; run; onMicrotaskEmpty; onMicrotaskEmpty(begin); onMicrotaskEmpty(end); ' +\n                    // Second microtaskDrain Turn => microtask enqueued from onMicrotaskEmpty\n                    'executedMicrotask; onMicrotaskEmpty; onMicrotaskEmpty(begin); onMicrotaskEmpty(end); onStable');\n-           async.done();\n+           done();\n          }, resultTimer);\n-       }), testTimeout);\n+       });\n \n     it('should call onUnstable and onMicrotaskEmpty for a scheduleMicroTask in onMicrotaskEmpty triggered by ' +\n            'a scheduleMicroTask in run',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n+       done => {\n          runNgZoneNoLog(() => {\n            macroTask(() => {\n              _log.add('scheduleMicroTask');\n@@ -680,76 +663,75 @@ function commonTests() {\n                    'onUnstable; scheduleMicroTask; run(executeMicrotask); onMicrotaskEmpty; onMicrotaskEmpty(begin); onMicrotaskEmpty(scheduleMicroTask); onMicrotaskEmpty(end); ' +\n                    // Second VM Turn => the microtask enqueued from onMicrotaskEmpty\n                    'onMicrotaskEmpty(executeMicrotask); onMicrotaskEmpty; onMicrotaskEmpty(begin); onMicrotaskEmpty(end); onStable');\n-           async.done();\n+           done();\n          }, resultTimer);\n-       }), testTimeout);\n+       });\n \n-    it('should execute promises scheduled in onUnstable before promises scheduled in run',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         runNgZoneNoLog(() => {\n-           macroTask(() => {\n-             _log.add('run start');\n-             resolvedPromise\n-                 .then((_) => {\n-                   _log.add('promise then');\n-                   resolvedPromise.then(_log.fn('promise foo'));\n-                   return Promise.resolve(null);\n-                 })\n-                 .then(_log.fn('promise bar'));\n-             _log.add('run end');\n-           });\n-         });\n+    it('should execute promises scheduled in onUnstable before promises scheduled in run', done => {\n+      runNgZoneNoLog(() => {\n+        macroTask(() => {\n+          _log.add('run start');\n+          resolvedPromise\n+              .then((_) => {\n+                _log.add('promise then');\n+                resolvedPromise.then(_log.fn('promise foo'));\n+                return Promise.resolve(null);\n+              })\n+              .then(_log.fn('promise bar'));\n+          _log.add('run end');\n+        });\n+      });\n \n-         let donePromiseRan = false;\n-         let startPromiseRan = false;\n+      let donePromiseRan = false;\n+      let startPromiseRan = false;\n \n-         _zone.onUnstable.subscribe({\n-           next: () => {\n-             _log.add('onUnstable(begin)');\n-             if (!startPromiseRan) {\n-               _log.add('onUnstable(schedulePromise)');\n-               _zone.run(() => {\n-                 scheduleMicroTask(_log.fn('onUnstable(executePromise)'));\n-               });\n-               startPromiseRan = true;\n-             }\n-             _log.add('onUnstable(end)');\n-           }\n-         });\n+      _zone.onUnstable.subscribe({\n+        next: () => {\n+          _log.add('onUnstable(begin)');\n+          if (!startPromiseRan) {\n+            _log.add('onUnstable(schedulePromise)');\n+            _zone.run(() => {\n+              scheduleMicroTask(_log.fn('onUnstable(executePromise)'));\n+            });\n+            startPromiseRan = true;\n+          }\n+          _log.add('onUnstable(end)');\n+        }\n+      });\n \n-         _zone.onMicrotaskEmpty.subscribe({\n-           next: () => {\n-             _log.add('onMicrotaskEmpty(begin)');\n-             if (!donePromiseRan) {\n-               _log.add('onMicrotaskEmpty(schedulePromise)');\n-               _zone.run(() => {\n-                 scheduleMicroTask(_log.fn('onMicrotaskEmpty(executePromise)'));\n-               });\n-               donePromiseRan = true;\n-             }\n-             _log.add('onMicrotaskEmpty(end)');\n-           }\n-         });\n+      _zone.onMicrotaskEmpty.subscribe({\n+        next: () => {\n+          _log.add('onMicrotaskEmpty(begin)');\n+          if (!donePromiseRan) {\n+            _log.add('onMicrotaskEmpty(schedulePromise)');\n+            _zone.run(() => {\n+              scheduleMicroTask(_log.fn('onMicrotaskEmpty(executePromise)'));\n+            });\n+            donePromiseRan = true;\n+          }\n+          _log.add('onMicrotaskEmpty(end)');\n+        }\n+      });\n \n-         macroTask(() => {\n-           expect(_log.result())\n-               .toEqual(\n-                   // First VM turn: enqueue a microtask in onUnstable\n-                   'onUnstable; onUnstable(begin); onUnstable(schedulePromise); onUnstable(end); ' +\n-                   // First VM turn: execute the macrotask which enqueues microtasks\n-                   'run start; run end; ' +\n-                   // First VM turn: execute enqueued microtasks\n-                   'onUnstable(executePromise); promise then; promise foo; promise bar; onMicrotaskEmpty; ' +\n-                   // First VM turn: onTurnEnd, enqueue a microtask\n-                   'onMicrotaskEmpty(begin); onMicrotaskEmpty(schedulePromise); onMicrotaskEmpty(end); ' +\n-                   // Second VM turn: execute the microtask from onTurnEnd\n-                   'onMicrotaskEmpty(executePromise); onMicrotaskEmpty; onMicrotaskEmpty(begin); onMicrotaskEmpty(end); onStable');\n-           async.done();\n-         }, resultTimer);\n-       }), testTimeout);\n+      macroTask(() => {\n+        expect(_log.result())\n+            .toEqual(\n+                // First VM turn: enqueue a microtask in onUnstable\n+                'onUnstable; onUnstable(begin); onUnstable(schedulePromise); onUnstable(end); ' +\n+                // First VM turn: execute the macrotask which enqueues microtasks\n+                'run start; run end; ' +\n+                // First VM turn: execute enqueued microtasks\n+                'onUnstable(executePromise); promise then; promise foo; promise bar; onMicrotaskEmpty; ' +\n+                // First VM turn: onTurnEnd, enqueue a microtask\n+                'onMicrotaskEmpty(begin); onMicrotaskEmpty(schedulePromise); onMicrotaskEmpty(end); ' +\n+                // Second VM turn: execute the microtask from onTurnEnd\n+                'onMicrotaskEmpty(executePromise); onMicrotaskEmpty; onMicrotaskEmpty(begin); onMicrotaskEmpty(end); onStable');\n+        done();\n+      }, resultTimer);\n+    });\n \n     it('should call onUnstable and onMicrotaskEmpty before and after each turn, respectively',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n+       done => {\n          let aResolve: (result: string|null) => void;\n          let aPromise: Promise<string|null>;\n          let bResolve: (result: string|null) => void;\n@@ -790,12 +772,12 @@ function commonTests() {\n                    'onUnstable; a then; onMicrotaskEmpty; onStable; ' +\n                    // Third VM turn\n                    'onUnstable; b then; onMicrotaskEmpty; onStable');\n-           async.done();\n+           done();\n          }, resultTimer);\n-       }), testTimeout);\n+       });\n \n     it('should call onUnstable and onMicrotaskEmpty before and after (respectively) all turns in a chain',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n+       done => {\n          runNgZoneNoLog(() => {\n            macroTask(() => {\n              _log.add('run start');\n@@ -811,12 +793,12 @@ function commonTests() {\n            expect(_log.result())\n                .toEqual(\n                    'onUnstable; run start; run end; async1; async2; onMicrotaskEmpty; onStable');\n-           async.done();\n+           done();\n          }, resultTimer);\n-       }), testTimeout);\n+       });\n \n     it('should call onUnstable and onMicrotaskEmpty for promises created outside of run body',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n+       done => {\n          let promise: Promise<any>;\n \n          runNgZoneNoLog(() => {\n@@ -835,58 +817,56 @@ function commonTests() {\n                .toEqual(\n                    'onUnstable; zone run; onMicrotaskEmpty; onStable; ' +\n                    'onUnstable; promise then; onMicrotaskEmpty; onStable');\n-           async.done();\n+           done();\n          }, resultTimer);\n-       }), testTimeout);\n+       });\n   });\n \n   describe('exceptions', () => {\n-    it('should call the on error callback when it is invoked via zone.runGuarded',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         macroTask(() => {\n-           const exception = new Error('sync');\n+    it('should call the on error callback when it is invoked via zone.runGuarded', done => {\n+      macroTask(() => {\n+        const exception = new Error('sync');\n \n-           _zone.runGuarded(() => {\n-             throw exception;\n-           });\n+        _zone.runGuarded(() => {\n+          throw exception;\n+        });\n \n-           expect(_errors.length).toBe(1);\n-           expect(_errors[0]).toBe(exception);\n-           async.done();\n-         });\n-       }), testTimeout);\n+        expect(_errors.length).toBe(1);\n+        expect(_errors[0]).toBe(exception);\n+        done();\n+      });\n+    });\n \n     it('should not call the on error callback but rethrow when it is invoked via zone.run',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n+       done => {\n          macroTask(() => {\n            const exception = new Error('sync');\n            expect(() => _zone.run(() => {\n              throw exception;\n            })).toThrowError('sync');\n \n            expect(_errors.length).toBe(0);\n-           async.done();\n+           done();\n          });\n-       }), testTimeout);\n+       });\n \n-    it('should call onError for errors from microtasks',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const exception = new Error('async');\n+    it('should call onError for errors from microtasks', done => {\n+      const exception = new Error('async');\n \n-         macroTask(() => {\n-           _zone.run(() => {\n-             scheduleMicroTask(() => {\n-               throw exception;\n-             });\n-           });\n-         });\n+      macroTask(() => {\n+        _zone.run(() => {\n+          scheduleMicroTask(() => {\n+            throw exception;\n+          });\n+        });\n+      });\n \n-         macroTask(() => {\n-           expect(_errors.length).toBe(1);\n-           expect(_errors[0]).toEqual(exception);\n-           async.done();\n-         }, resultTimer);\n-       }), testTimeout);\n+      macroTask(() => {\n+        expect(_errors.length).toBe(1);\n+        expect(_errors[0]).toEqual(exception);\n+        done();\n+      }, resultTimer);\n+    });\n   });\n \n   describe('bugs', () => {\n@@ -1009,7 +989,7 @@ function commonTests() {\n         global.setImmediate = patchedImmediate;\n       });\n \n-      it('should run in requestAnimationFrame async', (done: DoneFn) => {\n+      it('should run in requestAnimationFrame async', done => {\n         let task: Task|undefined = undefined;\n         coalesceZone.run(() => {\n           task = Zone.current.scheduleEventTask('myEvent', () => {\n@@ -1025,7 +1005,7 @@ function commonTests() {\n       });\n \n       it('should only emit onMicroTaskEmpty once within the same event loop for multiple event tasks',\n-         (done: DoneFn) => {\n+         done => {\n            const tasks: Task[] = [];\n            coalesceZone.run(() => {\n              tasks.push(Zone.current.scheduleEventTask('myEvent', () => {\n@@ -1045,7 +1025,7 @@ function commonTests() {\n          });\n \n       it('should only emit onMicroTaskEmpty once within the same event loop for ngZone.run in onMicrotaskEmpty subscription',\n-         (done: DoneFn) => {\n+         done => {\n            const tasks: Task[] = [];\n            coalesceZone.onMicrotaskEmpty.subscribe(() => {\n              coalesceZone.run(() => {});\n@@ -1071,7 +1051,7 @@ function commonTests() {\n          });\n \n       it('should emit onMicroTaskEmpty once within the same event loop for not only event tasks, but event tasks are before other tasks',\n-         (done: DoneFn) => {\n+         done => {\n            const tasks: Task[] = [];\n            coalesceZone.run(() => {\n              tasks.push(Zone.current.scheduleEventTask('myEvent', () => {\n@@ -1094,7 +1074,7 @@ function commonTests() {\n          });\n \n       it('should emit multiple onMicroTaskEmpty within the same event loop for not only event tasks, but event tasks are after other tasks',\n-         (done: DoneFn) => {\n+         done => {\n            const tasks: Task[] = [];\n            coalesceZone.run(() => {\n              tasks.push(Zone.current.scheduleMacroTask('myMacro', () => {\n@@ -1148,7 +1128,7 @@ function commonTests() {\n         global.setImmediate = patchedImmediate;\n       });\n \n-      it('should run in requestAnimationFrame async', (done: DoneFn) => {\n+      it('should run in requestAnimationFrame async', done => {\n         coalesceZone.run(() => {});\n         expect(logs).toEqual([]);\n         nativeRequestAnimationFrame(() => {\n@@ -1158,7 +1138,7 @@ function commonTests() {\n       });\n \n       it('should only emit onMicroTaskEmpty once within the same event loop for multiple ngZone.run',\n-         (done: DoneFn) => {\n+         done => {\n            coalesceZone.run(() => {});\n            coalesceZone.run(() => {});\n            expect(logs).toEqual([]);\n@@ -1169,7 +1149,7 @@ function commonTests() {\n          });\n \n       it('should only emit onMicroTaskEmpty once within the same event loop for ngZone.run in onMicrotaskEmpty subscription',\n-         (done: DoneFn) => {\n+         done => {\n            coalesceZone.onMicrotaskEmpty.subscribe(() => {\n              coalesceZone.run(() => {});\n            });\n@@ -1183,7 +1163,7 @@ function commonTests() {\n          });\n \n       it('should only emit onMicroTaskEmpty once within the same event loop for multiple tasks',\n-         (done: DoneFn) => {\n+         done => {\n            const tasks: Task[] = [];\n            coalesceZone.run(() => {\n              tasks.push(Zone.current.scheduleMacroTask('myMacro', () => {"
        },
        {
            "sha": "2d2385a3debebc25ed603ea9a0cc7b0cc51029d0",
            "filename": "packages/core/testing/src/async_test_completer.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 32,
            "changes": 32,
            "blob_url": "https://github.com/angular/angular/blob/bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae/packages%2Fcore%2Ftesting%2Fsrc%2Fasync_test_completer.ts",
            "raw_url": "https://github.com/angular/angular/raw/bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae/packages%2Fcore%2Ftesting%2Fsrc%2Fasync_test_completer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftesting%2Fsrc%2Fasync_test_completer.ts?ref=bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae",
            "patch": "@@ -1,32 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-/**\n- * Injectable completer that allows signaling completion of an asynchronous test. Used internally.\n- */\n-export class AsyncTestCompleter {\n-  // TODO(issue/24571): remove '!'.\n-  private _resolve!: (result: any) => void;\n-  // TODO(issue/24571): remove '!'.\n-  private _reject!: (err: any) => void;\n-  private _promise: Promise<any> = new Promise((res, rej) => {\n-    this._resolve = res;\n-    this._reject = rej;\n-  });\n-  done(value?: any) {\n-    this._resolve(value);\n-  }\n-\n-  fail(error?: any, stackTrace?: string) {\n-    this._reject(error);\n-  }\n-\n-  get promise(): Promise<any> {\n-    return this._promise;\n-  }\n-}"
        },
        {
            "sha": "9859681c0771f80f3413403482d71af287c0d06e",
            "filename": "packages/core/testing/src/test_bed.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 23,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftesting%2Fsrc%2Ftest_bed.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftesting%2Fsrc%2Ftest_bed.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftesting%2Fsrc%2Ftest_bed.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -8,7 +8,6 @@\n \n import {ApplicationInitStatus, CompilerOptions, Component, Directive, InjectFlags, InjectionToken, Injector, NgModule, NgModuleFactory, NgModuleRef, NgZone, Optional, Pipe, PlatformRef, Provider, ProviderToken, SchemaMetadata, SkipSelf, StaticProvider, Type, clearOverrides as clearOverrides, DepFlags as DepFlags, getInjectableDef as getInjectableDef, INJECTOR_SCOPE as INJECTOR_SCOPE, ivyEnabled as ivyEnabled, NodeFlags as NodeFlags, overrideComponentView as overrideComponentView, overrideProvider as overrideProvider, stringify as stringify, InjectableDeclaration} from '@angular/core';\n \n-import {AsyncTestCompleter} from './async_test_completer';\n import {ComponentFixture} from './component_fixture';\n import {MetadataOverride} from './metadata_override';\n import {_getTestBedRender3, TestBedRender3} from './r3_test_bed';\n@@ -660,32 +659,14 @@ function _getTestBedViewEngine(): TestBedViewEngine {\n  * })\n  * ```\n  *\n- * Notes:\n- * - inject is currently a function because of some Traceur limitation the syntax should\n- * eventually\n- *   becomes `it('...', @Inject (object: AClass, async: AsyncTestCompleter) => { ... });`\n- *\n  * @publicApi\n  */\n export function inject(tokens: any[], fn: Function): () => any {\n   const testBed = getTestBed();\n-  if (tokens.indexOf(AsyncTestCompleter) >= 0) {\n-    // Not using an arrow function to preserve context passed from call site\n-    return function(this: unknown) {\n-      // Return an async test method that returns a Promise if AsyncTestCompleter is one of\n-      // the injected tokens.\n-      return testBed.compileComponents().then(() => {\n-        const completer = testBed.inject(AsyncTestCompleter);\n-        testBed.execute(tokens, fn, this);\n-        return completer.promise;\n-      });\n-    };\n-  } else {\n-    // Not using an arrow function to preserve context passed from call site\n-    return function(this: unknown) {\n-      return testBed.execute(tokens, fn, this);\n-    };\n-  }\n+  // Not using an arrow function to preserve context passed from call site\n+  return function(this: unknown) {\n+    return testBed.execute(tokens, fn, this);\n+  };\n }\n \n /**"
        },
        {
            "sha": "1307ecf157c43cae9f97a85e909004b4472e7bb7",
            "filename": "packages/core/testing/src/testing_internal.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 206,
            "changes": 206,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftesting%2Fsrc%2Ftesting_internal.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fcore%2Ftesting%2Fsrc%2Ftesting_internal.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftesting%2Fsrc%2Ftesting_internal.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,213 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {isPromise as isPromise} from '@angular/core';\n-import {global} from '@angular/core/src/util/global';\n-\n-import {AsyncTestCompleter} from './async_test_completer';\n-import {getTestBed, inject} from './test_bed';\n-\n-export {AsyncTestCompleter} from './async_test_completer';\n export {inject} from './test_bed';\n \n export * from './logger';\n export * from './ng_zone_mock';\n-\n-export const proxy: ClassDecorator = (t: any) => t;\n-\n-const _global = <any>(typeof window === 'undefined' ? global : window);\n-\n-export const afterEach: Function = _global.afterEach;\n-export const expect: <T>(actual: T) => jasmine.Matchers<T> = _global.expect;\n-\n-const jsmBeforeEach = _global.beforeEach;\n-const jsmDescribe = _global.describe;\n-const jsmDDescribe = _global.fdescribe;\n-const jsmXDescribe = _global.xdescribe;\n-const jsmIt = _global.it;\n-const jsmFIt = _global.fit;\n-const jsmXIt = _global.xit;\n-\n-const runnerStack: BeforeEachRunner[] = [];\n-jasmine.DEFAULT_TIMEOUT_INTERVAL = 3000;\n-const globalTimeOut = jasmine.DEFAULT_TIMEOUT_INTERVAL;\n-\n-const testBed = getTestBed();\n-\n-export type TestFn = ((done: DoneFn) => any)|(() => any);\n-\n-/**\n- * Mechanism to run `beforeEach()` functions of Angular tests.\n- *\n- * Note: Jasmine own `beforeEach` is used by this library to handle DI providers.\n- */\n-class BeforeEachRunner {\n-  private _fns: Array<Function> = [];\n-\n-  constructor(private _parent: BeforeEachRunner) {}\n-\n-  beforeEach(fn: Function): void {\n-    this._fns.push(fn);\n-  }\n-\n-  run(): void {\n-    if (this._parent) this._parent.run();\n-    this._fns.forEach((fn) => {\n-      fn();\n-    });\n-  }\n-}\n-\n-// Reset the test providers before each test\n-jsmBeforeEach(() => {\n-  testBed.resetTestingModule();\n-});\n-\n-function _describe(jsmFn: Function, ...args: any[]) {\n-  const parentRunner = runnerStack.length === 0 ? null : runnerStack[runnerStack.length - 1];\n-  const runner = new BeforeEachRunner(parentRunner!);\n-  runnerStack.push(runner);\n-  const suite = jsmFn(...args);\n-  runnerStack.pop();\n-  return suite;\n-}\n-\n-export function describe(...args: any[]): void {\n-  return _describe(jsmDescribe, ...args);\n-}\n-\n-export function ddescribe(...args: any[]): void {\n-  return _describe(jsmDDescribe, ...args);\n-}\n-\n-export function xdescribe(...args: any[]): void {\n-  return _describe(jsmXDescribe, ...args);\n-}\n-\n-export function beforeEach(fn: Function): void {\n-  if (runnerStack.length > 0) {\n-    // Inside a describe block, beforeEach() uses a BeforeEachRunner\n-    runnerStack[runnerStack.length - 1].beforeEach(fn);\n-  } else {\n-    // Top level beforeEach() are delegated to jasmine\n-    jsmBeforeEach(fn);\n-  }\n-}\n-\n-/**\n- * Allows overriding default providers defined in test_injector.js.\n- *\n- * The given function must return a list of DI providers.\n- *\n- * Example:\n- *\n- *   beforeEachProviders(() => [\n- *     {provide: Compiler, useClass: MockCompiler},\n- *     {provide: SomeToken, useValue: myValue},\n- *   ]);\n- */\n-export function beforeEachProviders(fn: Function): void {\n-  jsmBeforeEach(() => {\n-    const providers = fn();\n-    if (!providers) return;\n-    testBed.configureTestingModule({providers: providers});\n-  });\n-}\n-\n-\n-function _it(jsmFn: Function, testName: string, testFn: TestFn, testTimeout = 0): void {\n-  if (runnerStack.length == 0) {\n-    // This left here intentionally, as we should never get here, and it aids debugging.\n-    // tslint:disable-next-line\n-    debugger;\n-    throw new Error('Empty Stack!');\n-  }\n-  const runner = runnerStack[runnerStack.length - 1];\n-  const timeout = Math.max(globalTimeOut, testTimeout);\n-\n-  jsmFn(testName, (done: DoneFn) => {\n-    const completerProvider = {\n-      provide: AsyncTestCompleter,\n-      useFactory: () => {\n-        // Mark the test as async when an AsyncTestCompleter is injected in an it()\n-        return new AsyncTestCompleter();\n-      }\n-    };\n-    testBed.configureTestingModule({providers: [completerProvider]});\n-    runner.run();\n-\n-    if (testFn.length === 0) {\n-      // TypeScript doesn't infer the TestFn type without parameters here, so we\n-      // need to manually cast it.\n-      const retVal = (testFn as () => any)();\n-      if (isPromise(retVal)) {\n-        // Asynchronous test function that returns a Promise - wait for completion.\n-        retVal.then(done, done.fail);\n-      } else {\n-        // Synchronous test function - complete immediately.\n-        done();\n-      }\n-    } else {\n-      // Asynchronous test function that takes in 'done' parameter.\n-      testFn(done);\n-    }\n-  }, timeout);\n-}\n-\n-export function it(expectation: string, assertion: TestFn, timeout?: number): void {\n-  return _it(jsmIt, expectation, assertion, timeout);\n-}\n-\n-export function fit(expectation: string, assertion: TestFn, timeout?: number): void {\n-  return _it(jsmFIt, expectation, assertion, timeout);\n-}\n-\n-export function xit(expectation: string, assertion: TestFn, timeout?: number): void {\n-  return _it(jsmXIt, expectation, assertion, timeout);\n-}\n-\n-export class SpyObject {\n-  constructor(type?: any) {\n-    if (type) {\n-      for (const prop in type.prototype) {\n-        let m: any = null;\n-        try {\n-          m = type.prototype[prop];\n-        } catch {\n-          // As we are creating spys for abstract classes,\n-          // these classes might have getters that throw when they are accessed.\n-          // As we are only auto creating spys for methods, this\n-          // should not matter.\n-        }\n-        if (typeof m === 'function') {\n-          this.spy(prop);\n-        }\n-      }\n-    }\n-  }\n-\n-  spy(name: string) {\n-    if (!(this as any)[name]) {\n-      (this as any)[name] = jasmine.createSpy(name);\n-    }\n-    return (this as any)[name];\n-  }\n-\n-  prop(name: string, value: any) {\n-    (this as any)[name] = value;\n-  }\n-\n-  static stub(object: any = null, config: any = null, overrides: any = null) {\n-    if (!(object instanceof SpyObject)) {\n-      overrides = config;\n-      config = object;\n-      object = new SpyObject();\n-    }\n-\n-    const m = {...config, ...overrides};\n-    Object.keys(m).forEach(key => {\n-      object.spy(key).and.returnValue(m[key]);\n-    });\n-    return object;\n-  }\n-}"
        },
        {
            "sha": "0b94bdc02bdfc3c1112ea6dfec7d20ebeb8c2c95",
            "filename": "packages/forms/test/directives_spec.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 6,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fforms%2Ftest%2Fdirectives_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fforms%2Ftest%2Fdirectives_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Fdirectives_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -8,11 +8,9 @@\n \n import {SimpleChange} from '@angular/core';\n import {fakeAsync, flushMicrotasks, tick} from '@angular/core/testing';\n-import {beforeEach, describe, expect, it} from '@angular/core/testing/src/testing_internal';\n import {AbstractControl, CheckboxControlValueAccessor, ControlValueAccessor, DefaultValueAccessor, FormArray, FormArrayName, FormControl, FormControlDirective, FormControlName, FormGroup, FormGroupDirective, FormGroupName, NgControl, NgForm, NgModel, NgModelGroup, SelectControlValueAccessor, SelectMultipleControlValueAccessor, ValidationErrors, Validator, Validators} from '@angular/forms';\n import {selectValueAccessor} from '@angular/forms/src/directives/shared';\n import {composeValidators} from '@angular/forms/src/validators';\n-import {SpyNgControl, SpyValueAccessor} from './spies';\n import {asyncValidator} from './util';\n \n class DummyControlValueAccessor implements ControlValueAccessor {\n@@ -45,7 +43,7 @@ class CustomValidatorDirective implements Validator {\n         let dir: NgControl;\n \n         beforeEach(() => {\n-          dir = <any>new SpyNgControl();\n+          dir = {path: []} as any;\n         });\n \n         it('should throw when given an empty array', () => {\n@@ -90,23 +88,23 @@ class CustomValidatorDirective implements Validator {\n         });\n \n         it('should return custom accessor when provided', () => {\n-          const customAccessor: ControlValueAccessor = new SpyValueAccessor() as any;\n+          const customAccessor: ControlValueAccessor = {} as any;\n           const checkboxAccessor = new CheckboxControlValueAccessor(null!, null!);\n           expect(selectValueAccessor(dir, <any>[\n             defaultAccessor, customAccessor, checkboxAccessor\n           ])).toEqual(customAccessor);\n         });\n \n         it('should return custom accessor when provided with select multiple', () => {\n-          const customAccessor: ControlValueAccessor = new SpyValueAccessor() as any;\n+          const customAccessor: ControlValueAccessor = {} as any;\n           const selectMultipleAccessor = new SelectMultipleControlValueAccessor(null!, null!);\n           expect(selectValueAccessor(dir, <any>[\n             defaultAccessor, customAccessor, selectMultipleAccessor\n           ])).toEqual(customAccessor);\n         });\n \n         it('should throw when more than one custom accessor is provided', () => {\n-          const customAccessor: ControlValueAccessor = <any>new SpyValueAccessor();\n+          const customAccessor: ControlValueAccessor = {} as any;\n           expect(() => selectValueAccessor(dir, [customAccessor, customAccessor])).toThrowError();\n         });\n       });"
        },
        {
            "sha": "5097be662156977c89256038a9c9046e26e8995b",
            "filename": "packages/forms/test/form_array_spec.ts",
            "status": "modified",
            "additions": 44,
            "deletions": 49,
            "changes": 93,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fforms%2Ftest%2Fform_array_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fforms%2Ftest%2Fform_array_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Fform_array_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -7,7 +7,6 @@\n  */\n \n import {fakeAsync, tick} from '@angular/core/testing';\n-import {AsyncTestCompleter, beforeEach, describe, inject, it} from '@angular/core/testing/src/testing_internal';\n import {AbstractControl, FormArray, FormControl, FormGroup, ValidationErrors, ValidatorFn} from '@angular/forms';\n import {Validators} from '@angular/forms/src/validators';\n import {of} from 'rxjs';\n@@ -856,64 +855,60 @@ describe('FormArray', () => {\n       a = new FormArray([c1, c2]);\n     });\n \n-    it('should fire an event after the value has been updated',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         a.valueChanges.subscribe({\n-           next: (value: any) => {\n-             expect(a.value).toEqual(['new1', 'old2']);\n-             expect(value).toEqual(['new1', 'old2']);\n-             async.done();\n-           }\n-         });\n-         c1.setValue('new1');\n-       }));\n+    it('should fire an event after the value has been updated', done => {\n+      a.valueChanges.subscribe({\n+        next: (value: any) => {\n+          expect(a.value).toEqual(['new1', 'old2']);\n+          expect(value).toEqual(['new1', 'old2']);\n+          done();\n+        }\n+      });\n+      c1.setValue('new1');\n+    });\n \n-    it('should fire an event after the control\\'s observable fired an event',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         let controlCallbackIsCalled = false;\n+    it('should fire an event after the control\\'s observable fired an event', done => {\n+      let controlCallbackIsCalled = false;\n \n \n-         c1.valueChanges.subscribe({\n-           next: (value: any) => {\n-             controlCallbackIsCalled = true;\n-           }\n-         });\n+      c1.valueChanges.subscribe({\n+        next: (value: any) => {\n+          controlCallbackIsCalled = true;\n+        }\n+      });\n \n-         a.valueChanges.subscribe({\n-           next: (value: any) => {\n-             expect(controlCallbackIsCalled).toBe(true);\n-             async.done();\n-           }\n-         });\n+      a.valueChanges.subscribe({\n+        next: (value: any) => {\n+          expect(controlCallbackIsCalled).toBe(true);\n+          done();\n+        }\n+      });\n \n-         c1.setValue('new1');\n-       }));\n+      c1.setValue('new1');\n+    });\n \n-    it('should fire an event when a control is removed',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         a.valueChanges.subscribe({\n-           next: (value: any) => {\n-             expect(value).toEqual(['old1']);\n-             async.done();\n-           }\n-         });\n+    it('should fire an event when a control is removed', done => {\n+      a.valueChanges.subscribe({\n+        next: (value: any) => {\n+          expect(value).toEqual(['old1']);\n+          done();\n+        }\n+      });\n \n-         a.removeAt(1);\n-       }));\n+      a.removeAt(1);\n+    });\n \n-    it('should fire an event when a control is added',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         a.removeAt(1);\n+    it('should fire an event when a control is added', done => {\n+      a.removeAt(1);\n \n-         a.valueChanges.subscribe({\n-           next: (value: any) => {\n-             expect(value).toEqual(['old1', 'old2']);\n-             async.done();\n-           }\n-         });\n+      a.valueChanges.subscribe({\n+        next: (value: any) => {\n+          expect(value).toEqual(['old1', 'old2']);\n+          done();\n+        }\n+      });\n \n-         a.push(c2);\n-       }));\n+      a.push(c2);\n+    });\n   });\n \n   describe('get', () => {"
        },
        {
            "sha": "0e0e100ab95fef7491e73ba1e05aa34cb78c2d99",
            "filename": "packages/forms/test/form_builder_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fforms%2Ftest%2Fform_builder_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fforms%2Ftest%2Fform_builder_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Fform_builder_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,7 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n import {fakeAsync, tick} from '@angular/core/testing';\n-import {beforeEach, describe, expect, it} from '@angular/core/testing/src/testing_internal';\n import {FormBuilder, Validators} from '@angular/forms';\n import {of} from 'rxjs';\n "
        },
        {
            "sha": "d4344e8ce5f1cace200ac190e33e543216ca5457",
            "filename": "packages/forms/test/form_control_spec.ts",
            "status": "modified",
            "additions": 28,
            "deletions": 32,
            "changes": 60,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fforms%2Ftest%2Fform_control_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fforms%2Ftest%2Fform_control_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Fform_control_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -7,7 +7,6 @@\n  */\n \n import {fakeAsync, tick} from '@angular/core/testing';\n-import {AsyncTestCompleter, beforeEach, describe, inject, it} from '@angular/core/testing/src/testing_internal';\n import {FormControl, FormGroup, Validators} from '@angular/forms';\n \n import {FormArray} from '@angular/forms/src/model';\n@@ -857,17 +856,16 @@ describe('FormControl', () => {\n       c = new FormControl('old', Validators.required);\n     });\n \n-    it('should fire an event after the value has been updated',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         c.valueChanges.subscribe({\n-           next: (value: any) => {\n-             expect(c.value).toEqual('new');\n-             expect(value).toEqual('new');\n-             async.done();\n-           }\n-         });\n-         c.setValue('new');\n-       }));\n+    it('should fire an event after the value has been updated', done => {\n+      c.valueChanges.subscribe({\n+        next: (value: any) => {\n+          expect(c.value).toEqual('new');\n+          expect(value).toEqual('new');\n+          done();\n+        }\n+      });\n+      c.setValue('new');\n+    });\n \n     it('should fire an event after the status has been updated to invalid', fakeAsync(() => {\n          c.statusChanges.subscribe({\n@@ -911,27 +909,25 @@ describe('FormControl', () => {\n        }));\n \n     // TODO: remove the if statement after making observable delivery sync\n-    it('should update set errors and status before emitting an event',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         c.valueChanges.subscribe((value: any /** TODO #9100 */) => {\n-           expect(c.valid).toEqual(false);\n-           expect(c.errors).toEqual({'required': true});\n-           async.done();\n-         });\n-         c.setValue('');\n-       }));\n+    it('should update set errors and status before emitting an event', done => {\n+      c.valueChanges.subscribe((value: any /** TODO #9100 */) => {\n+        expect(c.valid).toEqual(false);\n+        expect(c.errors).toEqual({'required': true});\n+        done();\n+      });\n+      c.setValue('');\n+    });\n \n-    it('should return a cold observable',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         c.setValue('will be ignored');\n-         c.valueChanges.subscribe({\n-           next: (value: any) => {\n-             expect(value).toEqual('new');\n-             async.done();\n-           }\n-         });\n-         c.setValue('new');\n-       }));\n+    it('should return a cold observable', done => {\n+      c.setValue('will be ignored');\n+      c.valueChanges.subscribe({\n+        next: (value: any) => {\n+          expect(value).toEqual('new');\n+          done();\n+        }\n+      });\n+      c.setValue('new');\n+    });\n   });\n \n   describe('setErrors', () => {"
        },
        {
            "sha": "830a3ae587e3bb229a66984cf449a75b10f54863",
            "filename": "packages/forms/test/form_group_spec.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 15,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fforms%2Ftest%2Fform_group_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fforms%2Ftest%2Fform_group_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Fform_group_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -7,7 +7,6 @@\n  */\n \n import {fakeAsync, tick, waitForAsync} from '@angular/core/testing';\n-import {AsyncTestCompleter, beforeEach, describe, inject, it} from '@angular/core/testing/src/testing_internal';\n import {AbstractControl, FormArray, FormControl, FormGroup, ValidationErrors, Validators} from '@angular/forms';\n import {of} from 'rxjs';\n \n@@ -822,20 +821,19 @@ describe('FormGroup', () => {\n \n \n     // TODO(kara): update these tests to use fake Async\n-    it('should fire a statusChange if child has async validation change',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const loggedValues: string[] = [];\n-         group.statusChanges.subscribe({\n-           next: (status: string) => {\n-             loggedValues.push(status);\n-             if (loggedValues.length === 2) {\n-               expect(loggedValues).toEqual(['PENDING', 'INVALID']);\n-             }\n-             async.done();\n-           }\n-         });\n-         control.setValue('');\n-       }));\n+    it('should fire a statusChange if child has async validation change', done => {\n+      const loggedValues: string[] = [];\n+      group.statusChanges.subscribe({\n+        next: (status: string) => {\n+          loggedValues.push(status);\n+          if (loggedValues.length === 2) {\n+            expect(loggedValues).toEqual(['PENDING', 'INVALID']);\n+          }\n+          done();\n+        }\n+      });\n+      control.setValue('');\n+    });\n   });\n \n   describe('getError', () => {"
        },
        {
            "sha": "99de565ea266884cecd8ebd26a025856158d7cbd",
            "filename": "packages/forms/test/reactive_integration_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fforms%2Ftest%2Freactive_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fforms%2Ftest%2Freactive_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Freactive_integration_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -9,7 +9,6 @@\n import {getDOM as getDOM} from '@angular/common';\n import {Component, Directive, forwardRef, Input, NgModule, OnDestroy, Type} from '@angular/core';\n import {ComponentFixture, fakeAsync, TestBed, tick} from '@angular/core/testing';\n-import {expect} from '@angular/core/testing/src/testing_internal';\n import {AbstractControl, AsyncValidator, AsyncValidatorFn, COMPOSITION_BUFFER_MODE, ControlValueAccessor, DefaultValueAccessor, FormArray, FormControl, FormControlDirective, FormControlName, FormGroup, FormGroupDirective, FormsModule, MaxValidator, MinValidator, NG_ASYNC_VALIDATORS, NG_VALIDATORS, NG_VALUE_ACCESSOR, ReactiveFormsModule, Validator, Validators} from '@angular/forms';\n import {By} from '@angular/platform-browser/src/dom/debug/by';\n import {dispatchEvent, sortedClassList} from '@angular/platform-browser/testing/src/browser_util';\n@@ -5018,4 +5017,4 @@ class MinMaxFormControlComp {\n   form!: FormGroup;\n   min: number|string = 1;\n   max: number|string = 10;\n-}\n\\ No newline at end of file\n+}"
        },
        {
            "sha": "d90f06f324df3269ba134148564ec096701d9236",
            "filename": "packages/forms/test/spies.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 25,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae/packages%2Fforms%2Ftest%2Fspies.ts",
            "raw_url": "https://github.com/angular/angular/raw/bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae/packages%2Fforms%2Ftest%2Fspies.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Fspies.ts?ref=bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae",
            "patch": "@@ -1,25 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ChangeDetectorRef} from '@angular/core/src/change_detection/change_detector_ref';\n-import {SpyObject} from '@angular/core/testing/src/testing_internal';\n-\n-export class SpyChangeDetectorRef extends SpyObject {\n-  constructor() {\n-    super(ChangeDetectorRef);\n-    this.spy('markForCheck');\n-  }\n-}\n-\n-export class SpyNgControl extends SpyObject {\n-  path = [];\n-}\n-\n-export class SpyValueAccessor extends SpyObject {\n-  writeValue: any;\n-}"
        },
        {
            "sha": "c125836df16f643689bd6b812579e504850e7fe8",
            "filename": "packages/forms/test/validators_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fforms%2Ftest%2Fvalidators_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fforms%2Ftest%2Fvalidators_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Fvalidators_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -7,7 +7,6 @@\n  */\n \n import {fakeAsync, tick} from '@angular/core/testing';\n-import {describe, expect, it} from '@angular/core/testing/src/testing_internal';\n import {AbstractControl, AsyncValidator, AsyncValidatorFn, FormArray, FormControl, ValidationErrors, ValidatorFn, Validators} from '@angular/forms';\n import {Observable, of, timer} from 'rxjs';\n import {first, map} from 'rxjs/operators';"
        },
        {
            "sha": "e950c202d83625d288933582a858635bc94b20e9",
            "filename": "packages/platform-browser-dynamic/test/resource_loader/resource_loader_impl_spec.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 16,
            "changes": 29,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fplatform-browser-dynamic%2Ftest%2Fresource_loader%2Fresource_loader_impl_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fplatform-browser-dynamic%2Ftest%2Fresource_loader%2Fresource_loader_impl_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser-dynamic%2Ftest%2Fresource_loader%2Fresource_loader_impl_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,7 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AsyncTestCompleter, beforeEach, describe, expect, inject, it} from '@angular/core/testing/src/testing_internal';\n import {ResourceLoaderImpl} from '@angular/platform-browser-dynamic/src/resource_loader/resource_loader_impl';\n \n if (isBrowser) {\n@@ -26,21 +25,19 @@ if (isBrowser) {\n       resourceLoader = new ResourceLoaderImpl();\n     });\n \n-    it('should resolve the Promise with the file content on success',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         resourceLoader.get(url200).then((text) => {\n-           expect(text.trim()).toEqual('<p>hey</p>');\n-           async.done();\n-         });\n-       }), 10000);\n+    it('should resolve the Promise with the file content on success', done => {\n+      resourceLoader.get(url200).then((text) => {\n+        expect(text.trim()).toEqual('<p>hey</p>');\n+        done();\n+      });\n+    }, 10000);\n \n-    it('should reject the Promise on failure',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         resourceLoader.get(url404).catch((e) => {\n-           expect(e).toEqual(`Failed to load ${url404}`);\n-           async.done();\n-           return null;\n-         });\n-       }), 10000);\n+    it('should reject the Promise on failure', done => {\n+      resourceLoader.get(url404).catch((e) => {\n+        expect(e).toEqual(`Failed to load ${url404}`);\n+        done();\n+        return null;\n+      });\n+    }, 10000);\n   });\n }"
        },
        {
            "sha": "e8ae8b2b0bb6ce142f73726a045aaf8436d53a52",
            "filename": "packages/platform-browser/test/browser/bootstrap_spec.ts",
            "status": "modified",
            "additions": 268,
            "deletions": 307,
            "changes": 575,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fplatform-browser%2Ftest%2Fbrowser%2Fbootstrap_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fplatform-browser%2Ftest%2Fbrowser%2Fbootstrap_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser%2Ftest%2Fbrowser%2Fbootstrap_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -12,7 +12,8 @@ import {ApplicationRef, destroyPlatform} from '@angular/core/src/application_ref\n import {Console} from '@angular/core/src/console';\n import {ComponentRef} from '@angular/core/src/linker/component_factory';\n import {Testability, TestabilityRegistry} from '@angular/core/src/testability/testability';\n-import {afterEach, AsyncTestCompleter, beforeEach, beforeEachProviders, describe, inject, it, Log} from '@angular/core/testing/src/testing_internal';\n+import {inject, TestBed} from '@angular/core/testing';\n+import {Log} from '@angular/core/testing/src/testing_internal';\n import {BrowserModule} from '@angular/platform-browser';\n import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n@@ -61,10 +62,6 @@ class HelloRootCmp4 {\n   }\n }\n \n-@Component({selector: 'hello-app'})\n-class HelloRootMissingTemplate {\n-}\n-\n @Directive({selector: 'hello-app'})\n class HelloRootDirectiveIsNotCmp {\n }\n@@ -81,29 +78,6 @@ class HelloOnDestroyTickCmp implements OnDestroy {\n   }\n }\n \n-@Component({selector: 'hello-app', templateUrl: './sometemplate.html'})\n-class HelloUrlCmp {\n-  greeting = 'hello';\n-}\n-\n-@Directive({selector: '[someDir]', host: {'[title]': 'someDir'}})\n-class SomeDirective {\n-  // TODO(issue/24571): remove '!'.\n-  @Input() someDir!: string;\n-}\n-\n-@Pipe({name: 'somePipe'})\n-class SomePipe {\n-  transform(value: string): any {\n-    return `transformed ${value}`;\n-  }\n-}\n-\n-@Component({selector: 'hello-app', template: `<div  [someDir]=\"'someValue' | somePipe\"></div>`})\n-class HelloCmpUsingPlatformDirectiveAndPipe {\n-  show: boolean = false;\n-}\n-\n @Component({selector: 'hello-app', template: '<some-el [someProp]=\"true\">hello world!</some-el>'})\n class HelloCmpUsingCustomElement {\n }\n@@ -150,8 +124,8 @@ function bootstrap(\n     if (isNode) return;\n     let compilerConsole: DummyConsole;\n \n-    beforeEachProviders(() => {\n-      return [Log];\n+    beforeEach(() => {\n+      TestBed.configureTestingModule({providers: [Log]});\n     });\n \n     beforeEach(inject([DOCUMENT], (doc: any) => {\n@@ -175,35 +149,31 @@ function bootstrap(\n \n     afterEach(destroyPlatform);\n \n-    // TODO(misko): can't use `modifiedInIvy.it` because the `it` is somehow special here.\n-    modifiedInIvy('bootstrapping non-Component throws in View Engine').isEnabled &&\n-        it('should throw if bootstrapped Directive is not a Component',\n-           inject([AsyncTestCompleter], (done: AsyncTestCompleter) => {\n-             const logger = new MockConsole();\n-             const errorHandler = new ErrorHandler();\n-             (errorHandler as any)._console = logger as any;\n-             expect(\n-                 () => bootstrap(\n-                     HelloRootDirectiveIsNotCmp, [{provide: ErrorHandler, useValue: errorHandler}]))\n-                 .toThrowError(`HelloRootDirectiveIsNotCmp cannot be used as an entry component.`);\n-             done.done();\n-           }));\n-\n-    // TODO(misko): can't use `onlyInIvy.it` because the `it` is somehow special here.\n-    onlyInIvy('bootstrapping non-Component rejects Promise in Ivy').isEnabled &&\n-        it('should throw if bootstrapped Directive is not a Component',\n-           inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-             const logger = new MockConsole();\n-             const errorHandler = new ErrorHandler();\n-             (errorHandler as any)._console = logger as any;\n-             bootstrap(HelloRootDirectiveIsNotCmp, [\n-               {provide: ErrorHandler, useValue: errorHandler}\n-             ]).catch((error: Error) => {\n-               expect(error).toEqual(\n-                   new Error(`HelloRootDirectiveIsNotCmp cannot be used as an entry component.`));\n-               async.done();\n-             });\n-           }));\n+    modifiedInIvy('bootstrapping non-Component throws in View Engine')\n+        .it('should throw if bootstrapped Directive is not a Component', done => {\n+          const logger = new MockConsole();\n+          const errorHandler = new ErrorHandler();\n+          (errorHandler as any)._console = logger as any;\n+          expect(\n+              () => bootstrap(\n+                  HelloRootDirectiveIsNotCmp, [{provide: ErrorHandler, useValue: errorHandler}]))\n+              .toThrowError(`HelloRootDirectiveIsNotCmp cannot be used as an entry component.`);\n+          done();\n+        });\n+\n+    onlyInIvy('bootstrapping non-Component rejects Promise in Ivy')\n+        .it('should throw if bootstrapped Directive is not a Component', done => {\n+          const logger = new MockConsole();\n+          const errorHandler = new ErrorHandler();\n+          (errorHandler as any)._console = logger as any;\n+          bootstrap(HelloRootDirectiveIsNotCmp, [\n+            {provide: ErrorHandler, useValue: errorHandler}\n+          ]).catch((error: Error) => {\n+            expect(error).toEqual(\n+                new Error(`HelloRootDirectiveIsNotCmp cannot be used as an entry component.`));\n+            done();\n+          });\n+        });\n \n     it('should retrieve sanitizer', inject([Injector], (injector: Injector) => {\n          const sanitizer: Sanitizer|null = injector.get(Sanitizer, null);\n@@ -218,119 +188,114 @@ function bootstrap(\n          }\n        }));\n \n-    it('should throw if no element is found',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const logger = new MockConsole();\n-         const errorHandler = new ErrorHandler();\n-         (errorHandler as any)._console = logger as any;\n-         bootstrap(NonExistentComp, [\n-           {provide: ErrorHandler, useValue: errorHandler}\n-         ]).then(null, (reason) => {\n-           expect(reason.message)\n-               .toContain('The selector \"non-existent\" did not match any elements');\n-           async.done();\n-           return null;\n-         });\n-       }));\n+    it('should throw if no element is found', done => {\n+      const logger = new MockConsole();\n+      const errorHandler = new ErrorHandler();\n+      (errorHandler as any)._console = logger as any;\n+      bootstrap(NonExistentComp, [\n+        {provide: ErrorHandler, useValue: errorHandler}\n+      ]).then(null, (reason) => {\n+        expect(reason.message).toContain('The selector \"non-existent\" did not match any elements');\n+        done();\n+        return null;\n+      });\n+    });\n \n-    it('should throw if no provider', inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const logger = new MockConsole();\n-         const errorHandler = new ErrorHandler();\n-         (errorHandler as any)._console = logger as any;\n+    it('should throw if no provider', done => {\n+      const logger = new MockConsole();\n+      const errorHandler = new ErrorHandler();\n+      (errorHandler as any)._console = logger as any;\n \n-         class IDontExist {}\n+      class IDontExist {}\n \n-         @Component({selector: 'cmp', template: 'Cmp'})\n-         class CustomCmp {\n-           constructor(iDontExist: IDontExist) {}\n-         }\n+      @Component({selector: 'cmp', template: 'Cmp'})\n+      class CustomCmp {\n+        constructor(iDontExist: IDontExist) {}\n+      }\n \n-         @Component({\n-           selector: 'hello-app',\n-           template: '<cmp></cmp>',\n-         })\n-         class RootCmp {\n-         }\n+      @Component({\n+        selector: 'hello-app',\n+        template: '<cmp></cmp>',\n+      })\n+      class RootCmp {\n+      }\n \n-         @NgModule({declarations: [CustomCmp], exports: [CustomCmp]})\n-         class CustomModule {\n-         }\n+      @NgModule({declarations: [CustomCmp], exports: [CustomCmp]})\n+      class CustomModule {\n+      }\n \n-         bootstrap(RootCmp, [{provide: ErrorHandler, useValue: errorHandler}], [], [\n-           CustomModule\n-         ]).then(null, (e: Error) => {\n-           let errorMsg: string;\n-           if (ivyEnabled) {\n-             errorMsg = `R3InjectorError(TestModule)[IDontExist -> IDontExist -> IDontExist]: \\n`;\n-           } else {\n-             errorMsg = `StaticInjectorError(TestModule)[CustomCmp -> IDontExist]: \\n` +\n-                 '  StaticInjectorError(Platform: core)[CustomCmp -> IDontExist]: \\n' +\n-                 '    NullInjectorError: No provider for IDontExist!';\n-           }\n-           expect(e.message).toContain(errorMsg);\n-           async.done();\n-           return null;\n-         });\n-       }));\n+      bootstrap(RootCmp, [{provide: ErrorHandler, useValue: errorHandler}], [], [\n+        CustomModule\n+      ]).then(null, (e: Error) => {\n+        let errorMsg: string;\n+        if (ivyEnabled) {\n+          errorMsg = `R3InjectorError(TestModule)[IDontExist -> IDontExist -> IDontExist]: \\n`;\n+        } else {\n+          errorMsg = `StaticInjectorError(TestModule)[CustomCmp -> IDontExist]: \\n` +\n+              '  StaticInjectorError(Platform: core)[CustomCmp -> IDontExist]: \\n' +\n+              '    NullInjectorError: No provider for IDontExist!';\n+        }\n+        expect(e.message).toContain(errorMsg);\n+        done();\n+        return null;\n+      });\n+    });\n \n     if (getDOM().supportsDOMEvents) {\n-      it('should forward the error to promise when bootstrap fails',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           const logger = new MockConsole();\n-           const errorHandler = new ErrorHandler();\n-           (errorHandler as any)._console = logger as any;\n-\n-           const refPromise =\n-               bootstrap(NonExistentComp, [{provide: ErrorHandler, useValue: errorHandler}]);\n-           refPromise.then(null, (reason: any) => {\n-             expect(reason.message)\n-                 .toContain('The selector \"non-existent\" did not match any elements');\n-             async.done();\n-           });\n-         }));\n-\n-      it('should invoke the default exception handler when bootstrap fails',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           const logger = new MockConsole();\n-           const errorHandler = new ErrorHandler();\n-           (errorHandler as any)._console = logger as any;\n-\n-           const refPromise =\n-               bootstrap(NonExistentComp, [{provide: ErrorHandler, useValue: errorHandler}]);\n-           refPromise.then(null, (reason) => {\n-             expect(logger.res[0].join('#'))\n-                 .toContain('ERROR#Error: The selector \"non-existent\" did not match any elements');\n-             async.done();\n-             return null;\n-           });\n-         }));\n+      it('should forward the error to promise when bootstrap fails', done => {\n+        const logger = new MockConsole();\n+        const errorHandler = new ErrorHandler();\n+        (errorHandler as any)._console = logger as any;\n+\n+        const refPromise =\n+            bootstrap(NonExistentComp, [{provide: ErrorHandler, useValue: errorHandler}]);\n+        refPromise.then(null, (reason: any) => {\n+          expect(reason.message)\n+              .toContain('The selector \"non-existent\" did not match any elements');\n+          done();\n+        });\n+      });\n+\n+      it('should invoke the default exception handler when bootstrap fails', done => {\n+        const logger = new MockConsole();\n+        const errorHandler = new ErrorHandler();\n+        (errorHandler as any)._console = logger as any;\n+\n+        const refPromise =\n+            bootstrap(NonExistentComp, [{provide: ErrorHandler, useValue: errorHandler}]);\n+        refPromise.then(null, (reason) => {\n+          expect(logger.res[0].join('#'))\n+              .toContain('ERROR#Error: The selector \"non-existent\" did not match any elements');\n+          done();\n+          return null;\n+        });\n+      });\n     }\n \n     it('should create an injector promise', () => {\n       const refPromise = bootstrap(HelloRootCmp, testProviders);\n       expect(refPromise).toEqual(jasmine.any(Promise));\n     });\n \n-    it('should set platform name to browser',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const refPromise = bootstrap(HelloRootCmp, testProviders);\n-         refPromise.then((ref) => {\n-           expect(isPlatformBrowser(ref.injector.get(PLATFORM_ID))).toBe(true);\n-           async.done();\n-         });\n-       }));\n+    it('should set platform name to browser', done => {\n+      const refPromise = bootstrap(HelloRootCmp, testProviders);\n+      refPromise.then((ref) => {\n+        expect(isPlatformBrowser(ref.injector.get(PLATFORM_ID))).toBe(true);\n+        done();\n+      }, done.fail);\n+    });\n \n-    it('should display hello world', inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const refPromise = bootstrap(HelloRootCmp, testProviders);\n-         refPromise.then((ref) => {\n-           expect(el).toHaveText('hello world!');\n-           expect(el.getAttribute('ng-version')).toEqual(VERSION.full);\n-           async.done();\n-         });\n-       }));\n+    it('should display hello world', done => {\n+      const refPromise = bootstrap(HelloRootCmp, testProviders);\n+      refPromise.then((ref) => {\n+        expect(el).toHaveText('hello world!');\n+        expect(el.getAttribute('ng-version')).toEqual(VERSION.full);\n+        done();\n+      }, done.fail);\n+    });\n \n     it('should throw a descriptive error if BrowserModule is installed again via a lazily loaded module',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n+       done => {\n          @NgModule({imports: [BrowserModule]})\n          class AsyncModule {\n          }\n@@ -343,158 +308,155 @@ function bootstrap(\n                          `BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.`);\n                });\n              })\n-             .then(() => async.done(), err => async.fail(err));\n-       }));\n-\n-    it('should support multiple calls to bootstrap',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const refPromise1 = bootstrap(HelloRootCmp, testProviders);\n-         const refPromise2 = bootstrap(HelloRootCmp2, testProviders);\n-         Promise.all([refPromise1, refPromise2]).then((refs) => {\n-           expect(el).toHaveText('hello world!');\n-           expect(el2).toHaveText('hello world, again!');\n-           async.done();\n-         });\n-       }));\n+             .then(() => done(), err => done.fail(err));\n+       });\n+\n+    it('should support multiple calls to bootstrap', done => {\n+      const refPromise1 = bootstrap(HelloRootCmp, testProviders);\n+      const refPromise2 = bootstrap(HelloRootCmp2, testProviders);\n+      Promise.all([refPromise1, refPromise2]).then((refs) => {\n+        expect(el).toHaveText('hello world!');\n+        expect(el2).toHaveText('hello world, again!');\n+        done();\n+      }, done.fail);\n+    });\n \n     it('should not crash if change detection is invoked when the root component is disposed',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n+       done => {\n          bootstrap(HelloOnDestroyTickCmp, testProviders).then((ref) => {\n            expect(() => ref.destroy()).not.toThrow();\n-           async.done();\n-         });\n-       }));\n-\n-    it('should unregister change detectors when components are disposed',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         bootstrap(HelloRootCmp, testProviders).then((ref) => {\n-           const appRef = ref.injector.get(ApplicationRef);\n-           ref.destroy();\n-           expect(() => appRef.tick()).not.toThrow();\n-           async.done();\n+           done();\n          });\n-       }));\n+       });\n+\n+    it('should unregister change detectors when components are disposed', done => {\n+      bootstrap(HelloRootCmp, testProviders).then((ref) => {\n+        const appRef = ref.injector.get(ApplicationRef);\n+        ref.destroy();\n+        expect(() => appRef.tick()).not.toThrow();\n+        done();\n+      }, done.fail);\n+    });\n \n-    it('should make the provided bindings available to the application component',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const refPromise = bootstrap(\n-             HelloRootCmp3, [testProviders, {provide: 'appBinding', useValue: 'BoundValue'}]);\n+    it('should make the provided bindings available to the application component', done => {\n+      const refPromise = bootstrap(\n+          HelloRootCmp3, [testProviders, {provide: 'appBinding', useValue: 'BoundValue'}]);\n \n-         refPromise.then((ref) => {\n-           expect(ref.injector.get('appBinding')).toEqual('BoundValue');\n-           async.done();\n-         });\n-       }));\n+      refPromise.then((ref) => {\n+        expect(ref.injector.get('appBinding')).toEqual('BoundValue');\n+        done();\n+      }, done.fail);\n+    });\n \n-    it('should not override locale provided during bootstrap',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const refPromise =\n-             bootstrap(HelloRootCmp, [testProviders], [{provide: LOCALE_ID, useValue: 'fr-FR'}]);\n+    it('should not override locale provided during bootstrap', done => {\n+      const refPromise =\n+          bootstrap(HelloRootCmp, [testProviders], [{provide: LOCALE_ID, useValue: 'fr-FR'}]);\n \n-         refPromise.then(ref => {\n-           expect(ref.injector.get(LOCALE_ID)).toEqual('fr-FR');\n-           async.done();\n-         });\n-       }));\n+      refPromise.then(ref => {\n+        expect(ref.injector.get(LOCALE_ID)).toEqual('fr-FR');\n+        done();\n+      }, done.fail);\n+    });\n \n     it('should avoid cyclic dependencies when root component requires Lifecycle through DI',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n+       done => {\n          const refPromise = bootstrap(HelloRootCmp4, testProviders);\n \n          refPromise.then((ref) => {\n            const appRef = ref.injector.get(ApplicationRef);\n            expect(appRef).toBeDefined();\n-           async.done();\n-         });\n-       }));\n+           done();\n+         }, done.fail);\n+       });\n+\n+    it('should run platform initializers', done => {\n+      inject([Log], (log: Log) => {\n+        const p = createPlatformFactory(platformBrowserDynamic, 'someName', [\n+          {provide: PLATFORM_INITIALIZER, useValue: log.fn('platform_init1'), multi: true},\n+          {provide: PLATFORM_INITIALIZER, useValue: log.fn('platform_init2'), multi: true}\n+        ])();\n+\n+        @NgModule({\n+          imports: [BrowserModule],\n+          providers: [\n+            {provide: APP_INITIALIZER, useValue: log.fn('app_init1'), multi: true},\n+            {provide: APP_INITIALIZER, useValue: log.fn('app_init2'), multi: true}\n+          ]\n+        })\n+        class SomeModule {\n+          ngDoBootstrap() {}\n+        }\n \n-    it('should run platform initializers',\n-       inject([Log, AsyncTestCompleter], (log: Log, async: AsyncTestCompleter) => {\n-         const p = createPlatformFactory(platformBrowserDynamic, 'someName', [\n-           {provide: PLATFORM_INITIALIZER, useValue: log.fn('platform_init1'), multi: true},\n-           {provide: PLATFORM_INITIALIZER, useValue: log.fn('platform_init2'), multi: true}\n-         ])();\n-\n-         @NgModule({\n-           imports: [BrowserModule],\n-           providers: [\n-             {provide: APP_INITIALIZER, useValue: log.fn('app_init1'), multi: true},\n-             {provide: APP_INITIALIZER, useValue: log.fn('app_init2'), multi: true}\n-           ]\n-         })\n-         class SomeModule {\n-           ngDoBootstrap() {}\n-         }\n+        expect(log.result()).toEqual('platform_init1; platform_init2');\n+        log.clear();\n+        p.bootstrapModule(SomeModule).then(() => {\n+          expect(log.result()).toEqual('app_init1; app_init2');\n+          done();\n+        }, done.fail);\n+      })();\n+    });\n \n-         expect(log.result()).toEqual('platform_init1; platform_init2');\n-         log.clear();\n-         p.bootstrapModule(SomeModule).then(() => {\n-           expect(log.result()).toEqual('app_init1; app_init2');\n-           async.done();\n-         });\n-       }));\n+    it('should remove styles when transitioning from a server render', done => {\n+      @Component({\n+        selector: 'root',\n+        template: 'root',\n+      })\n+      class RootCmp {\n+      }\n \n-    it('should remove styles when transitioning from a server render',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         @Component({\n-           selector: 'root',\n-           template: 'root',\n-         })\n-         class RootCmp {\n-         }\n+      @NgModule({\n+        bootstrap: [RootCmp],\n+        declarations: [RootCmp],\n+        imports: [BrowserModule.withServerTransition({appId: 'my-app'})],\n+      })\n+      class TestModule {\n+      }\n \n-         @NgModule({\n-           bootstrap: [RootCmp],\n-           declarations: [RootCmp],\n-           imports: [BrowserModule.withServerTransition({appId: 'my-app'})],\n-         })\n-         class TestModule {\n-         }\n+      // First, set up styles to be removed.\n+      const dom = getDOM();\n+      const platform = platformBrowserDynamic();\n+      const document = platform.injector.get(DOCUMENT);\n+      const style = dom.createElement('style', document);\n+      style.setAttribute('ng-transition', 'my-app');\n+      document.head.appendChild(style);\n+\n+      const root = dom.createElement('root', document);\n+      document.body.appendChild(root);\n+\n+      platform.bootstrapModule(TestModule).then(() => {\n+        const styles: HTMLElement[] =\n+            Array.prototype.slice.apply(document.getElementsByTagName('style') || []);\n+        styles.forEach(style => {\n+          expect(style.getAttribute('ng-transition')).not.toBe('my-app');\n+        });\n+        done();\n+      }, done.fail);\n+    });\n \n-         // First, set up styles to be removed.\n-         const dom = getDOM();\n-         const platform = platformBrowserDynamic();\n-         const document = platform.injector.get(DOCUMENT);\n-         const style = dom.createElement('style', document);\n-         style.setAttribute('ng-transition', 'my-app');\n-         document.head.appendChild(style);\n-\n-         const root = dom.createElement('root', document);\n-         document.body.appendChild(root);\n-\n-         platform.bootstrapModule(TestModule).then(() => {\n-           const styles: HTMLElement[] =\n-               Array.prototype.slice.apply(document.getElementsByTagName('style') || []);\n-           styles.forEach(style => {\n-             expect(style.getAttribute('ng-transition')).not.toBe('my-app');\n-           });\n-           async.done();\n-         });\n-       }));\n+    it('should register each application with the testability registry', done => {\n+      const refPromise1: Promise<ComponentRef<any>> = bootstrap(HelloRootCmp, testProviders);\n+      const refPromise2: Promise<ComponentRef<any>> = bootstrap(HelloRootCmp2, testProviders);\n \n-    it('should register each application with the testability registry',\n-       inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         const refPromise1: Promise<ComponentRef<any>> = bootstrap(HelloRootCmp, testProviders);\n-         const refPromise2: Promise<ComponentRef<any>> = bootstrap(HelloRootCmp2, testProviders);\n-\n-         Promise.all([refPromise1, refPromise2]).then((refs: ComponentRef<any>[]) => {\n-           const registry = refs[0].injector.get(TestabilityRegistry);\n-           const testabilities =\n-               [refs[0].injector.get(Testability), refs[1].injector.get(Testability)];\n-           Promise.all(testabilities).then((testabilities: Testability[]) => {\n-             expect(registry.findTestabilityInTree(el)).toEqual(testabilities[0]);\n-             expect(registry.findTestabilityInTree(el2)).toEqual(testabilities[1]);\n-             async.done();\n-           });\n-         });\n-       }));\n+      Promise.all([refPromise1, refPromise2]).then((refs: ComponentRef<any>[]) => {\n+        const registry = refs[0].injector.get(TestabilityRegistry);\n+        const testabilities =\n+            [refs[0].injector.get(Testability), refs[1].injector.get(Testability)];\n \n-    it('should allow to pass schemas', inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-         bootstrap(HelloCmpUsingCustomElement, testProviders).then((compRef) => {\n-           expect(el).toHaveText('hello world!');\n-           async.done();\n-         });\n-       }));\n+        Promise.all(testabilities).then((testabilities: Testability[]) => {\n+          expect(registry.findTestabilityInTree(el)).toEqual(testabilities[0]);\n+          expect(registry.findTestabilityInTree(el2)).toEqual(testabilities[1]);\n+\n+          done();\n+        }, done.fail);\n+      }, done.fail);\n+    });\n+\n+    it('should allow to pass schemas', done => {\n+      bootstrap(HelloCmpUsingCustomElement, testProviders).then(() => {\n+        expect(el).toHaveText('hello world!');\n+        done();\n+      }, done.fail);\n+    });\n \n     describe('change detection', () => {\n       const log: string[] = [];\n@@ -529,7 +491,7 @@ function bootstrap(\n       }\n \n       it('should be triggered for all bootstrapped components in case change happens in one of them',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n+         done => {\n            @NgModule({\n              imports: [BrowserModule],\n              declarations: [CompA, CompB],\n@@ -551,31 +513,30 @@ function bootstrap(\n              expect(log).toContain('CompA:ngDoCheck');\n              expect(log).toContain('CompB:ngDoCheck');\n \n-             async.done();\n-           });\n-         }));\n-\n-\n-      it('should work in isolation for each component bootstrapped individually',\n-         inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-           const refPromise1 = bootstrap(CompA);\n-           const refPromise2 = bootstrap(CompB);\n-           Promise.all([refPromise1, refPromise2]).then((refs) => {\n-             log.length = 0;\n-             el.querySelectorAll('#button-a')[0].click();\n-             expect(log).toContain('CompA:onClick');\n-             expect(log).toContain('CompA:ngDoCheck');\n-             expect(log).not.toContain('CompB:ngDoCheck');\n+             done();\n+           }, done.fail);\n+         });\n \n-             log.length = 0;\n-             el2.querySelectorAll('#button-b')[0].click();\n-             expect(log).toContain('CompB:onClick');\n-             expect(log).toContain('CompB:ngDoCheck');\n-             expect(log).not.toContain('CompA:ngDoCheck');\n \n-             async.done();\n-           });\n-         }));\n+      it('should work in isolation for each component bootstrapped individually', done => {\n+        const refPromise1 = bootstrap(CompA);\n+        const refPromise2 = bootstrap(CompB);\n+        Promise.all([refPromise1, refPromise2]).then((refs) => {\n+          log.length = 0;\n+          el.querySelectorAll('#button-a')[0].click();\n+          expect(log).toContain('CompA:onClick');\n+          expect(log).toContain('CompA:ngDoCheck');\n+          expect(log).not.toContain('CompB:ngDoCheck');\n+\n+          log.length = 0;\n+          el2.querySelectorAll('#button-b')[0].click();\n+          expect(log).toContain('CompB:onClick');\n+          expect(log).toContain('CompB:ngDoCheck');\n+          expect(log).not.toContain('CompA:ngDoCheck');\n+\n+          done();\n+        }, done.fail);\n+      });\n     });\n   });\n }"
        },
        {
            "sha": "c7c3c0d47633a642dbfd2edd278d69a7fc9c05b7",
            "filename": "packages/platform-browser/test/browser/tools/spies.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 30,
            "changes": 30,
            "blob_url": "https://github.com/angular/angular/blob/bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae/packages%2Fplatform-browser%2Ftest%2Fbrowser%2Ftools%2Fspies.ts",
            "raw_url": "https://github.com/angular/angular/raw/bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae/packages%2Fplatform-browser%2Ftest%2Fbrowser%2Ftools%2Fspies.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser%2Ftest%2Fbrowser%2Ftools%2Fspies.ts?ref=bd51762d6ea96c93c4f9cba8b4fb47da4b0c18ae",
            "patch": "@@ -1,30 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Injector, global as global} from '@angular/core';\n-import {ApplicationRef} from '@angular/core/src/application_ref';\n-import {SpyObject} from '@angular/core/testing/src/testing_internal';\n-\n-export class SpyApplicationRef extends SpyObject {\n-  constructor() {\n-    super(ApplicationRef);\n-  }\n-}\n-\n-export class SpyComponentRef extends SpyObject {\n-  injector: any /** TODO #9100 */;\n-  constructor() {\n-    super();\n-    this.injector =\n-        Injector.create([{provide: ApplicationRef, useClass: SpyApplicationRef, deps: []}]);\n-  }\n-}\n-\n-export function callNgProfilerTimeChangeDetection(config?: any /** TODO #9100 */): void {\n-  (<any>global).ng.profiler.timeChangeDetection(config);\n-}"
        },
        {
            "sha": "8c078a81382d462395195cb92d973288e6679683",
            "filename": "packages/platform-browser/test/browser/tools/tools_spec.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 3,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fplatform-browser%2Ftest%2Fbrowser%2Ftools%2Ftools_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fplatform-browser%2Ftest%2Fbrowser%2Ftools%2Ftools_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser%2Ftest%2Fbrowser%2Ftools%2Ftools_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,15 +6,22 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n+import {ApplicationRef, Injector, global as global} from '@angular/core';\n import {disableDebugTools, enableDebugTools} from '@angular/platform-browser';\n \n-import {callNgProfilerTimeChangeDetection, SpyComponentRef} from './spies';\n-\n {\n   describe('profiler', () => {\n     if (isNode) return;\n+\n     beforeEach(() => {\n-      enableDebugTools((<any>new SpyComponentRef()));\n+      enableDebugTools({\n+        injector: Injector.create([{\n+          provide: ApplicationRef,\n+          useValue: jasmine.createSpyObj(\n+              'ApplicationRef', ['bootstrap', 'tick', 'attachView', 'detachView']),\n+          deps: []\n+        }])\n+      } as any);\n     });\n \n     afterEach(() => {\n@@ -30,3 +37,7 @@ import {callNgProfilerTimeChangeDetection, SpyComponentRef} from './spies';\n     });\n   });\n }\n+\n+export function callNgProfilerTimeChangeDetection(config?: any /** TODO #9100 */): void {\n+  (<any>global).ng.profiler.timeChangeDetection(config);\n+}"
        },
        {
            "sha": "24014ffb7c4bf0e3f52b267e43da9b4f0a466a49",
            "filename": "packages/platform-browser/test/dom/events/event_manager_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fplatform-browser%2Ftest%2Fdom%2Fevents%2Fevent_manager_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fplatform-browser%2Ftest%2Fdom%2Fevents%2Fevent_manager_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser%2Ftest%2Fdom%2Fevents%2Fevent_manager_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -8,7 +8,6 @@\n \n import {getDOM as getDOM} from '@angular/common';\n import {NgZone} from '@angular/core/src/zone/ng_zone';\n-import {beforeEach, describe, expect, it} from '@angular/core/testing/src/testing_internal';\n import {DomEventsPlugin} from '@angular/platform-browser/src/dom/events/dom_events';\n import {EventManager, EventManagerPlugin} from '@angular/platform-browser/src/dom/events/event_manager';\n import {createMouseEvent, el} from '../../../testing/src/browser_util';"
        },
        {
            "sha": "a6e1007c809e9c985929e7e0930d6a3ae2ef72c7",
            "filename": "packages/platform-browser/test/dom/events/hammer_gestures_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fplatform-browser%2Ftest%2Fdom%2Fevents%2Fhammer_gestures_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fplatform-browser%2Ftest%2Fdom%2Fevents%2Fhammer_gestures_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser%2Ftest%2Fdom%2Fevents%2Fhammer_gestures_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -7,7 +7,6 @@\n  */\n import {NgZone} from '@angular/core';\n import {fakeAsync, inject, tick} from '@angular/core/testing';\n-import {afterEach, beforeEach, describe, expect, it,} from '@angular/core/testing/src/testing_internal';\n import {EventManager} from '@angular/platform-browser';\n import {HammerGestureConfig, HammerGesturesPlugin,} from '@angular/platform-browser/src/dom/events/hammer_gestures';\n \n@@ -58,7 +57,7 @@ import {HammerGestureConfig, HammerGesturesPlugin,} from '@angular/platform-brow\n       let originalHammerGlobal: any;\n \n       // Fake Hammer instance (\"mc\") used to test the underlying event registration.\n-      let fakeHammerInstance: {on: () => void, off: () => void};\n+      let fakeHammerInstance: {on: jasmine.Spy, off: jasmine.Spy};\n \n       // Inject the NgZone so that we can make it available to the plugin through a fake\n       // EventManager."
        },
        {
            "sha": "b422577a6b9bc3208eda4fcfcc376e971c0ba8e3",
            "filename": "packages/platform-browser/test/dom/events/key_events_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fplatform-browser%2Ftest%2Fdom%2Fevents%2Fkey_events_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fplatform-browser%2Ftest%2Fdom%2Fevents%2Fkey_events_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser%2Ftest%2Fdom%2Fevents%2Fkey_events_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -6,7 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {describe, expect, it} from '@angular/core/testing/src/testing_internal';\n import {KeyEventsPlugin} from '@angular/platform-browser/src/dom/events/key_events';\n \n {"
        },
        {
            "sha": "2891d54ccdac74d1d216b2b518f46d0aad408f57",
            "filename": "packages/platform-browser/test/dom/shared_styles_host_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fplatform-browser%2Ftest%2Fdom%2Fshared_styles_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fplatform-browser%2Ftest%2Fdom%2Fshared_styles_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser%2Ftest%2Fdom%2Fshared_styles_host_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -7,7 +7,6 @@\n  */\n \n import {getDOM as getDOM} from '@angular/common';\n-import {beforeEach, describe, it} from '@angular/core/testing/src/testing_internal';\n import {DomSharedStylesHost} from '@angular/platform-browser/src/dom/shared_styles_host';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n "
        },
        {
            "sha": "147d0756a20637438c273fcd25b7d8bd95f1b13e",
            "filename": "packages/platform-browser/test/security/dom_sanitization_service_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fplatform-browser%2Ftest%2Fsecurity%2Fdom_sanitization_service_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fplatform-browser%2Ftest%2Fsecurity%2Fdom_sanitization_service_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser%2Ftest%2Fsecurity%2Fdom_sanitization_service_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -7,15 +7,14 @@\n  */\n \n import {SecurityContext} from '@angular/core';\n-import * as t from '@angular/core/testing/src/testing_internal';\n import {DomSanitizerImpl} from '@angular/platform-browser/src/security/dom_sanitization_service';\n \n {\n-  t.describe('DOM Sanitization Service', () => {\n-    t.it('accepts resource URL values for resource contexts', () => {\n+  describe('DOM Sanitization Service', () => {\n+    it('accepts resource URL values for resource contexts', () => {\n       const svc = new DomSanitizerImpl(null);\n       const resourceUrl = svc.bypassSecurityTrustResourceUrl('http://hello/world');\n-      t.expect(svc.sanitize(SecurityContext.URL, resourceUrl)).toBe('http://hello/world');\n+      expect(svc.sanitize(SecurityContext.URL, resourceUrl)).toBe('http://hello/world');\n     });\n   });\n }"
        },
        {
            "sha": "253507fbe333cbdbf7fc7df19ee25d2bf7d980a9",
            "filename": "packages/platform-browser/test/testing_public_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fplatform-browser%2Ftest%2Ftesting_public_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Fplatform-browser%2Ftest%2Ftesting_public_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser%2Ftest%2Ftesting_public_spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -335,9 +335,9 @@ const bTok = new InjectionToken<string>('b');\n       });\n \n       describe('components with template url', () => {\n-        beforeEach(waitForAsync(() => {\n+        beforeEach(waitForAsync(async () => {\n           TestBed.configureTestingModule({declarations: [CompWithUrlTemplate]});\n-          TestBed.compileComponents();\n+          await TestBed.compileComponents();\n         }));\n \n         isBrowser &&"
        },
        {
            "sha": "bd76ed543284c570b58abd5a988cfbe8ad6c5d11",
            "filename": "packages/router/test/integration.spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fintegration.spec.ts?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -10,7 +10,6 @@ import {CommonModule, Location} from '@angular/common';\n import {SpyLocation} from '@angular/common/testing';\n import {ChangeDetectionStrategy, Component, Injectable, NgModule, NgModuleFactoryLoader, NgModuleRef, NgZone, OnDestroy, ViewChild, Console as Console, NoopNgZone as NoopNgZone} from '@angular/core';\n import {ComponentFixture, fakeAsync, inject, TestBed, tick} from '@angular/core/testing';\n-import {describe} from '@angular/core/testing/src/testing_internal';\n import {By} from '@angular/platform-browser/src/dom/debug/by';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n import {ActivatedRoute, ActivatedRouteSnapshot, ActivationEnd, ActivationStart, CanActivate, CanDeactivate, ChildActivationEnd, ChildActivationStart, DefaultUrlSerializer, DetachedRouteHandle, Event, GuardsCheckEnd, GuardsCheckStart, Navigation, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, ParamMap, Params, PreloadAllModules, PreloadingStrategy, PRIMARY_OUTLET, Resolve, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, Router, RouteReuseStrategy, RouterEvent, RouterLink, RouterLinkWithHref, RouterModule, RouterPreloader, RouterStateSnapshot, RoutesRecognized, RunGuardsAndResolvers, UrlHandlingStrategy, UrlSegmentGroup, UrlSerializer, UrlTree} from '@angular/router';"
        },
        {
            "sha": "66f74c22d47ebb2240fc59e8fc55b27d64c8694d",
            "filename": "test-main.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/a787f780744ccd0644ce3f1f25ff33d9249d05e1/test-main.js",
            "raw_url": "https://github.com/angular/angular/raw/a787f780744ccd0644ce3f1f25ff33d9249d05e1/test-main.js",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/test-main.js?ref=a787f780744ccd0644ce3f1f25ff33d9249d05e1",
            "patch": "@@ -9,7 +9,7 @@\n // Tun on full stack traces in errors to help debugging\n Error.stackTraceLimit = Infinity;\n \n-jasmine.DEFAULT_TIMEOUT_INTERVAL = 100;\n+jasmine.DEFAULT_TIMEOUT_INTERVAL = 3000;\n \n // Cancel Karma's synchronous start,\n // we will call `__karma__.start()` later, once all the specs are loaded."
        }
    ],
    "stats": {
        "total": 5099,
        "additions": 2150,
        "deletions": 2949
    }
}