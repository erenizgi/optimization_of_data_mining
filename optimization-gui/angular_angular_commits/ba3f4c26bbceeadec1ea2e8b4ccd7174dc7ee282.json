{
    "author": "atscott",
    "message": "refactor(compiler): make `keySpan` available for `BoundAttributes` (#38898)\n\nThough we currently have the knowledge of where the `key` for an\nattribute binding appears during parsing, we do not propagate this\ninformation to the output AST. This means that once we produce the\ntemplate AST, we have no way of mapping a template position to the key\nspan alone. The best we can currently do is map back to the\n`sourceSpan`. This presents problems downstream, specifically for the\nlanguage service, where we cannot provide correct information about a\nposition in a template because the AST is not granular enough.\n\nPR Close #38898",
    "sha": "ba3f4c26bbceeadec1ea2e8b4ccd7174dc7ee282",
    "files": [
        {
            "sha": "2773a5458d18c518a589e9491aa237c1ce201563",
            "filename": "packages/compiler/src/expression_parser/ast.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/ba3f4c26bbceeadec1ea2e8b4ccd7174dc7ee282/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fast.ts",
            "raw_url": "https://github.com/angular/angular/raw/ba3f4c26bbceeadec1ea2e8b4ccd7174dc7ee282/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fast.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fast.ts?ref=ba3f4c26bbceeadec1ea2e8b4ccd7174dc7ee282",
            "patch": "@@ -841,7 +841,10 @@ export class ParsedProperty {\n \n   constructor(\n       public name: string, public expression: ASTWithSource, public type: ParsedPropertyType,\n-      public sourceSpan: ParseSourceSpan, public valueSpan?: ParseSourceSpan) {\n+      // TODO(atscott): `keySpan` should really be required but allows `undefined` so VE does\n+      // not need to be updated. Make `keySpan` required when VE is removed.\n+      public sourceSpan: ParseSourceSpan, readonly keySpan: ParseSourceSpan|undefined,\n+      public valueSpan: ParseSourceSpan|undefined) {\n     this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\n     this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\n   }\n@@ -896,5 +899,5 @@ export class BoundElementProperty {\n   constructor(\n       public name: string, public type: BindingType, public securityContext: SecurityContext,\n       public value: ASTWithSource, public unit: string|null, public sourceSpan: ParseSourceSpan,\n-      public valueSpan?: ParseSourceSpan) {}\n+      readonly keySpan: ParseSourceSpan|undefined, public valueSpan: ParseSourceSpan|undefined) {}\n }"
        },
        {
            "sha": "33a86c629bedb3ec5b04f6b700f5e8871bf1253c",
            "filename": "packages/compiler/src/render3/r3_ast.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 3,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/ba3f4c26bbceeadec1ea2e8b4ccd7174dc7ee282/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_ast.ts",
            "raw_url": "https://github.com/angular/angular/raw/ba3f4c26bbceeadec1ea2e8b4ccd7174dc7ee282/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_ast.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_ast.ts?ref=ba3f4c26bbceeadec1ea2e8b4ccd7174dc7ee282",
            "patch": "@@ -43,12 +43,18 @@ export class BoundAttribute implements Node {\n   constructor(\n       public name: string, public type: BindingType, public securityContext: SecurityContext,\n       public value: AST, public unit: string|null, public sourceSpan: ParseSourceSpan,\n-      public valueSpan?: ParseSourceSpan, public i18n?: I18nMeta) {}\n+      readonly keySpan: ParseSourceSpan, public valueSpan: ParseSourceSpan|undefined,\n+      public i18n: I18nMeta|undefined) {}\n \n-  static fromBoundElementProperty(prop: BoundElementProperty, i18n?: I18nMeta) {\n+  static fromBoundElementProperty(prop: BoundElementProperty, i18n?: I18nMeta): BoundAttribute {\n+    if (prop.keySpan === undefined) {\n+      throw new Error(\n+          `Unexpected state: keySpan must be defined for bound attributes but was not for ${\n+              prop.name}: ${prop.sourceSpan}`);\n+    }\n     return new BoundAttribute(\n         prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan,\n-        prop.valueSpan, i18n);\n+        prop.keySpan, prop.valueSpan, i18n);\n   }\n \n   visit<Result>(visitor: Visitor<Result>): Result {"
        },
        {
            "sha": "61feb3bf4a7e3f67a183a31c67eebf267357ac59",
            "filename": "packages/compiler/src/render3/r3_template_transform.ts",
            "status": "modified",
            "additions": 30,
            "deletions": 13,
            "changes": 43,
            "blob_url": "https://github.com/angular/angular/blob/ba3f4c26bbceeadec1ea2e8b4ccd7174dc7ee282/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_template_transform.ts",
            "raw_url": "https://github.com/angular/angular/raw/ba3f4c26bbceeadec1ea2e8b4ccd7174dc7ee282/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_template_transform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_template_transform.ts?ref=ba3f4c26bbceeadec1ea2e8b4ccd7174dc7ee282",
            "patch": "@@ -332,15 +332,26 @@ class HtmlAstToIvyAst implements html.Visitor {\n     const absoluteOffset =\n         attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;\n \n+    function createKeySpan(srcSpan: ParseSourceSpan, prefix: string, identifier: string) {\n+      // We need to adjust the start location for the keySpan to account for the removed 'data-'\n+      // prefix from `normalizeAttributeName`.\n+      const normalizationAdjustment = attribute.name.length - name.length;\n+      const keySpanStart = srcSpan.start.moveBy(prefix.length + normalizationAdjustment);\n+      const keySpanEnd = keySpanStart.moveBy(identifier.length);\n+      return new ParseSourceSpan(keySpanStart, keySpanEnd, identifier);\n+    }\n+\n     const bindParts = name.match(BIND_NAME_REGEXP);\n     let hasBinding = false;\n \n     if (bindParts) {\n       hasBinding = true;\n       if (bindParts[KW_BIND_IDX] != null) {\n+        const identifier = bindParts[IDENT_KW_IDX];\n+        const keySpan = createKeySpan(srcSpan, bindParts[KW_BIND_IDX], identifier);\n         this.bindingParser.parsePropertyBinding(\n-            bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attribute.valueSpan,\n-            matchableAttributes, parsedProperties);\n+            identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan,\n+            matchableAttributes, parsedProperties, keySpan);\n \n       } else if (bindParts[KW_LET_IDX]) {\n         if (isTemplateElement) {\n@@ -353,37 +364,41 @@ class HtmlAstToIvyAst implements html.Visitor {\n       } else if (bindParts[KW_REF_IDX]) {\n         const identifier = bindParts[IDENT_KW_IDX];\n         this.parseReference(identifier, value, srcSpan, attribute.valueSpan, references);\n-\n       } else if (bindParts[KW_ON_IDX]) {\n         const events: ParsedEvent[] = [];\n+        const identifier = bindParts[IDENT_KW_IDX];\n         this.bindingParser.parseEvent(\n-            bindParts[IDENT_KW_IDX], value, srcSpan, attribute.valueSpan || srcSpan,\n-            matchableAttributes, events);\n+            identifier, value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes,\n+            events);\n         addEvents(events, boundEvents);\n       } else if (bindParts[KW_BINDON_IDX]) {\n+        const identifier = bindParts[IDENT_KW_IDX];\n+        const keySpan = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX], identifier);\n         this.bindingParser.parsePropertyBinding(\n-            bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attribute.valueSpan,\n-            matchableAttributes, parsedProperties);\n+            identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan,\n+            matchableAttributes, parsedProperties, keySpan);\n         this.parseAssignmentEvent(\n-            bindParts[IDENT_KW_IDX], value, srcSpan, attribute.valueSpan, matchableAttributes,\n-            boundEvents);\n+            identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents);\n       } else if (bindParts[KW_AT_IDX]) {\n+        const keySpan = createKeySpan(srcSpan, '', name);\n         this.bindingParser.parseLiteralAttr(\n             name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes,\n-            parsedProperties);\n+            parsedProperties, keySpan);\n \n       } else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n+        const keySpan = createKeySpan(srcSpan, '[(', bindParts[IDENT_BANANA_BOX_IDX]);\n         this.bindingParser.parsePropertyBinding(\n             bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, absoluteOffset,\n-            attribute.valueSpan, matchableAttributes, parsedProperties);\n+            attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n         this.parseAssignmentEvent(\n             bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, attribute.valueSpan,\n             matchableAttributes, boundEvents);\n \n       } else if (bindParts[IDENT_PROPERTY_IDX]) {\n+        const keySpan = createKeySpan(srcSpan, '[', bindParts[IDENT_PROPERTY_IDX]);\n         this.bindingParser.parsePropertyBinding(\n             bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, absoluteOffset,\n-            attribute.valueSpan, matchableAttributes, parsedProperties);\n+            attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n \n       } else if (bindParts[IDENT_EVENT_IDX]) {\n         const events: ParsedEvent[] = [];\n@@ -393,8 +408,10 @@ class HtmlAstToIvyAst implements html.Visitor {\n         addEvents(events, boundEvents);\n       }\n     } else {\n+      const keySpan = createKeySpan(srcSpan, '' /* prefix */, name);\n       hasBinding = this.bindingParser.parsePropertyInterpolation(\n-          name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties);\n+          name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties,\n+          keySpan);\n     }\n \n     return hasBinding;"
        },
        {
            "sha": "790a14df236a386539009367ac5ebf2074fa3c2c",
            "filename": "packages/compiler/src/render3/view/compiler.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/ba3f4c26bbceeadec1ea2e8b4ccd7174dc7ee282/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/ba3f4c26bbceeadec1ea2e8b4ccd7174dc7ee282/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fcompiler.ts?ref=ba3f4c26bbceeadec1ea2e8b4ccd7174dc7ee282",
            "patch": "@@ -582,9 +582,8 @@ function createHostBindingsFunction(\n   // bindings with pipes. These calculates happen after this block.\n   let totalHostVarsCount = 0;\n   bindings && bindings.forEach((binding: ParsedProperty) => {\n-    const name = binding.name;\n-    const stylingInputWasSet =\n-        styleBuilder.registerInputBasedOnName(name, binding.expression, binding.sourceSpan);\n+    const stylingInputWasSet = styleBuilder.registerInputBasedOnName(\n+        binding.name, binding.expression, hostBindingSourceSpan);\n     if (stylingInputWasSet) {\n       totalHostVarsCount += MIN_STYLING_BINDING_SLOTS_REQUIRED;\n     } else {"
        },
        {
            "sha": "1cbe4530abd1d2ba8b248cd8ceaa24372ac10369",
            "filename": "packages/compiler/src/template_parser/binding_parser.ts",
            "status": "modified",
            "additions": 34,
            "deletions": 20,
            "changes": 54,
            "blob_url": "https://github.com/angular/angular/blob/ba3f4c26bbceeadec1ea2e8b4ccd7174dc7ee282/packages%2Fcompiler%2Fsrc%2Ftemplate_parser%2Fbinding_parser.ts",
            "raw_url": "https://github.com/angular/angular/raw/ba3f4c26bbceeadec1ea2e8b4ccd7174dc7ee282/packages%2Fcompiler%2Fsrc%2Ftemplate_parser%2Fbinding_parser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Ftemplate_parser%2Fbinding_parser.ts?ref=ba3f4c26bbceeadec1ea2e8b4ccd7174dc7ee282",
            "patch": "@@ -62,7 +62,13 @@ export class BindingParser {\n         if (typeof expression === 'string') {\n           this.parsePropertyBinding(\n               propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [],\n-              boundProps);\n+              // Use the `sourceSpan` for  `keySpan`. This isn't really accurate, but neither is the\n+              // sourceSpan, as it represents the sourceSpan of the host itself rather than the\n+              // source of the host binding (which doesn't exist in the template). Regardless,\n+              // neither of these values are used in Ivy but are only here to satisfy the function\n+              // signature. This should likely be refactored in the future so that `sourceSpan`\n+              // isn't being used inaccurately.\n+              boundProps, sourceSpan);\n         } else {\n           this._reportError(\n               `Value of the host property binding \"${\n@@ -155,14 +161,14 @@ export class BindingParser {\n       } else if (binding.value) {\n         const valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);\n         this._parsePropertyAst(\n-            key, binding.value, sourceSpan, valueSpan, targetMatchableAttrs, targetProps);\n+            key, binding.value, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n       } else {\n         targetMatchableAttrs.push([key, '' /* value */]);\n         // Since this is a literal attribute with no RHS, source span should be\n         // just the key span.\n         this.parseLiteralAttr(\n             key, null /* value */, keySpan, absoluteValueOffset, undefined /* valueSpan */,\n-            targetMatchableAttrs, targetProps);\n+            targetMatchableAttrs, targetProps, keySpan);\n       }\n     }\n   }\n@@ -206,7 +212,9 @@ export class BindingParser {\n   parseLiteralAttr(\n       name: string, value: string|null, sourceSpan: ParseSourceSpan, absoluteOffset: number,\n       valueSpan: ParseSourceSpan|undefined, targetMatchableAttrs: string[][],\n-      targetProps: ParsedProperty[]) {\n+      // TODO(atscott): keySpan is only optional here so VE template parser implementation does not\n+      // have to change This should be required when VE is removed.\n+      targetProps: ParsedProperty[], keySpan?: ParseSourceSpan) {\n     if (isAnimationLabel(name)) {\n       name = name.substring(1);\n       if (value) {\n@@ -216,18 +224,21 @@ export class BindingParser {\n             sourceSpan, ParseErrorLevel.ERROR);\n       }\n       this._parseAnimation(\n-          name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps);\n+          name, value, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs,\n+          targetProps);\n     } else {\n       targetProps.push(new ParsedProperty(\n           name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset),\n-          ParsedPropertyType.LITERAL_ATTR, sourceSpan, valueSpan));\n+          ParsedPropertyType.LITERAL_ATTR, sourceSpan, keySpan, valueSpan));\n     }\n   }\n \n   parsePropertyBinding(\n       name: string, expression: string, isHost: boolean, sourceSpan: ParseSourceSpan,\n       absoluteOffset: number, valueSpan: ParseSourceSpan|undefined,\n-      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n+      // TODO(atscott): keySpan is only optional here so VE template parser implementation does not\n+      // have to change This should be required when VE is removed.\n+      targetMatchableAttrs: string[][], targetProps: ParsedProperty[], keySpan?: ParseSourceSpan) {\n     if (name.length === 0) {\n       this._reportError(`Property name is missing in binding`, sourceSpan);\n     }\n@@ -243,40 +254,43 @@ export class BindingParser {\n \n     if (isAnimationProp) {\n       this._parseAnimation(\n-          name, expression, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs,\n+          name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs,\n           targetProps);\n     } else {\n       this._parsePropertyAst(\n           name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset),\n-          sourceSpan, valueSpan, targetMatchableAttrs, targetProps);\n+          sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n     }\n   }\n \n   parsePropertyInterpolation(\n       name: string, value: string, sourceSpan: ParseSourceSpan,\n       valueSpan: ParseSourceSpan|undefined, targetMatchableAttrs: string[][],\n-      targetProps: ParsedProperty[]): boolean {\n+      // TODO(atscott): keySpan is only optional here so VE template parser implementation does not\n+      // have to change This should be required when VE is removed.\n+      targetProps: ParsedProperty[], keySpan?: ParseSourceSpan): boolean {\n     const expr = this.parseInterpolation(value, valueSpan || sourceSpan);\n     if (expr) {\n-      this._parsePropertyAst(name, expr, sourceSpan, valueSpan, targetMatchableAttrs, targetProps);\n+      this._parsePropertyAst(\n+          name, expr, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n       return true;\n     }\n     return false;\n   }\n \n   private _parsePropertyAst(\n       name: string, ast: ASTWithSource, sourceSpan: ParseSourceSpan,\n-      valueSpan: ParseSourceSpan|undefined, targetMatchableAttrs: string[][],\n-      targetProps: ParsedProperty[]) {\n+      keySpan: ParseSourceSpan|undefined, valueSpan: ParseSourceSpan|undefined,\n+      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n     targetMatchableAttrs.push([name, ast.source!]);\n     targetProps.push(\n-        new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, valueSpan));\n+        new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, keySpan, valueSpan));\n   }\n \n   private _parseAnimation(\n       name: string, expression: string|null, sourceSpan: ParseSourceSpan, absoluteOffset: number,\n-      valueSpan: ParseSourceSpan|undefined, targetMatchableAttrs: string[][],\n-      targetProps: ParsedProperty[]) {\n+      keySpan: ParseSourceSpan|undefined, valueSpan: ParseSourceSpan|undefined,\n+      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n     if (name.length === 0) {\n       this._reportError('Animation trigger is missing', sourceSpan);\n     }\n@@ -287,8 +301,8 @@ export class BindingParser {\n     const ast = this._parseBinding(\n         expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);\n     targetMatchableAttrs.push([name, ast.source!]);\n-    targetProps.push(\n-        new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, valueSpan));\n+    targetProps.push(new ParsedProperty(\n+        name, ast, ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan));\n   }\n \n   private _parseBinding(\n@@ -317,7 +331,7 @@ export class BindingParser {\n     if (boundProp.isAnimation) {\n       return new BoundElementProperty(\n           boundProp.name, BindingType.Animation, SecurityContext.NONE, boundProp.expression, null,\n-          boundProp.sourceSpan, boundProp.valueSpan);\n+          boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n     }\n \n     let unit: string|null = null;\n@@ -370,7 +384,7 @@ export class BindingParser {\n \n     return new BoundElementProperty(\n         boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit,\n-        boundProp.sourceSpan, boundProp.valueSpan);\n+        boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n   }\n \n   parseEvent("
        },
        {
            "sha": "90268e5134b76c2d3dfa48ca51b041926177acfe",
            "filename": "packages/compiler/test/render3/r3_ast_spans_spec.ts",
            "status": "modified",
            "additions": 82,
            "deletions": 13,
            "changes": 95,
            "blob_url": "https://github.com/angular/angular/blob/ba3f4c26bbceeadec1ea2e8b4ccd7174dc7ee282/packages%2Fcompiler%2Ftest%2Frender3%2Fr3_ast_spans_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/ba3f4c26bbceeadec1ea2e8b4ccd7174dc7ee282/packages%2Fcompiler%2Ftest%2Frender3%2Fr3_ast_spans_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Frender3%2Fr3_ast_spans_spec.ts?ref=ba3f4c26bbceeadec1ea2e8b4ccd7174dc7ee282",
            "patch": "@@ -65,8 +65,10 @@ class R3AstSourceSpans implements t.Visitor<void> {\n   }\n \n   visitBoundAttribute(attribute: t.BoundAttribute) {\n-    this.result.push(\n-        ['BoundAttribute', humanizeSpan(attribute.sourceSpan), humanizeSpan(attribute.valueSpan)]);\n+    this.result.push([\n+      'BoundAttribute', humanizeSpan(attribute.sourceSpan), humanizeSpan(attribute.keySpan),\n+      humanizeSpan(attribute.valueSpan)\n+    ]);\n   }\n \n   visitBoundEvent(event: t.BoundEvent) {\n@@ -144,28 +146,35 @@ describe('R3 AST source spans', () => {\n     it('is correct for bound properties', () => {\n       expectFromHtml('<div [someProp]=\"v\"></div>').toEqual([\n         ['Element', '<div [someProp]=\"v\"></div>', '<div [someProp]=\"v\">', '</div>'],\n-        ['BoundAttribute', '[someProp]=\"v\"', 'v'],\n+        ['BoundAttribute', '[someProp]=\"v\"', 'someProp', 'v'],\n       ]);\n     });\n \n     it('is correct for bound properties without value', () => {\n       expectFromHtml('<div [someProp]></div>').toEqual([\n         ['Element', '<div [someProp]></div>', '<div [someProp]>', '</div>'],\n-        ['BoundAttribute', '[someProp]', '<empty>'],\n+        ['BoundAttribute', '[someProp]', 'someProp', '<empty>'],\n       ]);\n     });\n \n     it('is correct for bound properties via bind- ', () => {\n       expectFromHtml('<div bind-prop=\"v\"></div>').toEqual([\n         ['Element', '<div bind-prop=\"v\"></div>', '<div bind-prop=\"v\">', '</div>'],\n-        ['BoundAttribute', 'bind-prop=\"v\"', 'v'],\n+        ['BoundAttribute', 'bind-prop=\"v\"', 'prop', 'v'],\n       ]);\n     });\n \n     it('is correct for bound properties via {{...}}', () => {\n       expectFromHtml('<div prop=\"{{v}}\"></div>').toEqual([\n         ['Element', '<div prop=\"{{v}}\"></div>', '<div prop=\"{{v}}\">', '</div>'],\n-        ['BoundAttribute', 'prop=\"{{v}}\"', '{{v}}'],\n+        ['BoundAttribute', 'prop=\"{{v}}\"', 'prop', '{{v}}'],\n+      ]);\n+    });\n+\n+    it('is correct for bound properties via data-', () => {\n+      expectFromHtml('<div data-prop=\"{{v}}\"></div>').toEqual([\n+        ['Element', '<div data-prop=\"{{v}}\"></div>', '<div data-prop=\"{{v}}\">', '</div>'],\n+        ['BoundAttribute', 'data-prop=\"{{v}}\"', 'prop', '{{v}}'],\n       ]);\n     });\n   });\n@@ -208,6 +217,16 @@ describe('R3 AST source spans', () => {\n       ]);\n     });\n \n+    it('is correct for reference via data-ref-...', () => {\n+      expectFromHtml('<ng-template data-ref-a></ng-template>').toEqual([\n+        [\n+          'Template', '<ng-template data-ref-a></ng-template>', '<ng-template data-ref-a>',\n+          '</ng-template>'\n+        ],\n+        ['Reference', 'data-ref-a', '<empty>'],\n+      ]);\n+    });\n+\n     it('is correct for variables via let-...', () => {\n       expectFromHtml('<ng-template let-a=\"b\"></ng-template>').toEqual([\n         [\n@@ -218,6 +237,16 @@ describe('R3 AST source spans', () => {\n       ]);\n     });\n \n+    it('is correct for variables via data-let-...', () => {\n+      expectFromHtml('<ng-template data-let-a=\"b\"></ng-template>').toEqual([\n+        [\n+          'Template', '<ng-template data-let-a=\"b\"></ng-template>', '<ng-template data-let-a=\"b\">',\n+          '</ng-template>'\n+        ],\n+        ['Variable', 'data-let-a=\"b\"', 'b'],\n+      ]);\n+    });\n+\n     it('is correct for attributes', () => {\n       expectFromHtml('<ng-template k1=\"v1\"></ng-template>').toEqual([\n         [\n@@ -234,7 +263,7 @@ describe('R3 AST source spans', () => {\n           'Template', '<ng-template [k1]=\"v1\"></ng-template>', '<ng-template [k1]=\"v1\">',\n           '</ng-template>'\n         ],\n-        ['BoundAttribute', '[k1]=\"v1\"', 'v1'],\n+        ['BoundAttribute', '[k1]=\"v1\"', 'k1', 'v1'],\n       ]);\n     });\n   });\n@@ -252,7 +281,7 @@ describe('R3 AST source spans', () => {\n           '</div>'\n         ],\n         ['TextAttribute', 'ngFor', '<empty>'],\n-        ['BoundAttribute', '*ngFor=\"let item of items\"', 'items'],\n+        ['BoundAttribute', '*ngFor=\"let item of items\"', 'of', 'items'],\n         ['Variable', 'let item ', '<empty>'],\n         [\n           'Element', '<div *ngFor=\"let item of items\"></div>', '<div *ngFor=\"let item of items\">',\n@@ -270,10 +299,28 @@ describe('R3 AST source spans', () => {\n         [\n           'Template', '<div *ngFor=\"item of items\"></div>', '<div *ngFor=\"item of items\">', '</div>'\n         ],\n-        ['BoundAttribute', '*ngFor=\"item of items\"', 'item'],\n-        ['BoundAttribute', '*ngFor=\"item of items\"', 'items'],\n+        ['BoundAttribute', '*ngFor=\"item of items\"', 'ngFor', 'item'],\n+        ['BoundAttribute', '*ngFor=\"item of items\"', 'of', 'items'],\n         ['Element', '<div *ngFor=\"item of items\"></div>', '<div *ngFor=\"item of items\">', '</div>'],\n       ]);\n+\n+      expectFromHtml('<div *ngFor=\"let item of items; trackBy: trackByFn\"></div>').toEqual([\n+        [\n+          'Template', '<div *ngFor=\"let item of items; trackBy: trackByFn\"></div>',\n+          '<div *ngFor=\"let item of items; trackBy: trackByFn\">', '</div>'\n+        ],\n+        ['TextAttribute', 'ngFor', '<empty>'],\n+        ['BoundAttribute', '*ngFor=\"let item of items; trackBy: trackByFn\"', 'of', 'items'],\n+        [\n+          'BoundAttribute', '*ngFor=\"let item of items; trackBy: trackByFn\"', 'trackBy', 'trackByFn'\n+        ],\n+        ['Variable', 'let item ', '<empty>'],\n+        [\n+          'Element', '<div *ngFor=\"let item of items; trackBy: trackByFn\"></div>',\n+          '<div *ngFor=\"let item of items; trackBy: trackByFn\">', '</div>'\n+        ],\n+\n+      ]);\n     });\n \n     it('is correct for variables via let ...', () => {\n@@ -288,7 +335,7 @@ describe('R3 AST source spans', () => {\n     it('is correct for variables via as ...', () => {\n       expectFromHtml('<div *ngIf=\"expr as local\"></div>').toEqual([\n         ['Template', '<div *ngIf=\"expr as local\"></div>', '<div *ngIf=\"expr as local\">', '</div>'],\n-        ['BoundAttribute', '*ngIf=\"expr as local\"', 'expr'],\n+        ['BoundAttribute', '*ngIf=\"expr as local\"', 'ngIf', 'expr'],\n         ['Variable', 'ngIf=\"expr as local', 'ngIf'],\n         ['Element', '<div *ngIf=\"expr as local\"></div>', '<div *ngIf=\"expr as local\">', '</div>'],\n       ]);\n@@ -310,21 +357,36 @@ describe('R3 AST source spans', () => {\n       ]);\n     });\n \n+    it('is correct for bound events via data-on-', () => {\n+      expectFromHtml('<div data-on-event=\"v\"></div>').toEqual([\n+        ['Element', '<div data-on-event=\"v\"></div>', '<div data-on-event=\"v\">', '</div>'],\n+        ['BoundEvent', 'data-on-event=\"v\"', 'v'],\n+      ]);\n+    });\n+\n     it('is correct for bound events and properties via [(...)]', () => {\n       expectFromHtml('<div [(prop)]=\"v\"></div>').toEqual([\n         ['Element', '<div [(prop)]=\"v\"></div>', '<div [(prop)]=\"v\">', '</div>'],\n-        ['BoundAttribute', '[(prop)]=\"v\"', 'v'],\n+        ['BoundAttribute', '[(prop)]=\"v\"', 'prop', 'v'],\n         ['BoundEvent', '[(prop)]=\"v\"', 'v'],\n       ]);\n     });\n \n     it('is correct for bound events and properties via bindon-', () => {\n       expectFromHtml('<div bindon-prop=\"v\"></div>').toEqual([\n         ['Element', '<div bindon-prop=\"v\"></div>', '<div bindon-prop=\"v\">', '</div>'],\n-        ['BoundAttribute', 'bindon-prop=\"v\"', 'v'],\n+        ['BoundAttribute', 'bindon-prop=\"v\"', 'prop', 'v'],\n         ['BoundEvent', 'bindon-prop=\"v\"', 'v'],\n       ]);\n     });\n+\n+    it('is correct for bound events and properties via data-bindon-', () => {\n+      expectFromHtml('<div data-bindon-prop=\"v\"></div>').toEqual([\n+        ['Element', '<div data-bindon-prop=\"v\"></div>', '<div data-bindon-prop=\"v\">', '</div>'],\n+        ['BoundAttribute', 'data-bindon-prop=\"v\"', 'prop', 'v'],\n+        ['BoundEvent', 'data-bindon-prop=\"v\"', 'v'],\n+      ]);\n+    });\n   });\n \n   describe('references', () => {\n@@ -348,5 +410,12 @@ describe('R3 AST source spans', () => {\n         ['Reference', 'ref-a', '<empty>'],\n       ]);\n     });\n+\n+    it('is correct for references via data-ref-', () => {\n+      expectFromHtml('<div ref-a></div>').toEqual([\n+        ['Element', '<div ref-a></div>', '<div ref-a>', '</div>'],\n+        ['Reference', 'ref-a', '<empty>'],\n+      ]);\n+    });\n   });\n });"
        }
    ],
    "stats": {
        "total": 216,
        "additions": 162,
        "deletions": 54
    }
}