{
    "author": "gkalpak",
    "message": "test(docs-infra): fix `practical-observable-usage` docs example tests with RxJS v7 (#43880)\n\nDue to how `debounceTime()` works in RxJS v7, Jasmine's mock clock was\nnot enough to trigger it. This commit fixes it by providing a similar\nmock clock that is able to mock all of `Date.now()`, `setInterval()` and\n`setTimeout()`.\n\nPR Close #43880",
    "sha": "0fc4e66f6ede1ae897a38d560897c826cc938605",
    "files": [
        {
            "sha": "2b381184baad6f76fe5963547e129a9c0af6a24e",
            "filename": ".circleci/config.yml",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/0fc4e66f6ede1ae897a38d560897c826cc938605/.circleci%2Fconfig.yml",
            "raw_url": "https://github.com/angular/angular/raw/0fc4e66f6ede1ae897a38d560897c826cc938605/.circleci%2Fconfig.yml",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/.circleci%2Fconfig.yml?ref=0fc4e66f6ede1ae897a38d560897c826cc938605",
            "patch": "@@ -437,7 +437,7 @@ jobs:\n               assert(actual === expected, 'Expected RxJS v' + expected + ', but found v' + actual + '.');\n             \"\n         # Exclude some examples that are not yet compatible with v7.\n-      - run: yarn --cwd aio example-e2e --cliSpecsConcurrency=5 --shard=${CIRCLE_NODE_INDEX}/${CIRCLE_NODE_TOTAL} --exclude=practical-observable-usage --exclude=upgrade-module --exclude=upgrade-phonecat\n+      - run: yarn --cwd aio example-e2e --cliSpecsConcurrency=5 --shard=${CIRCLE_NODE_INDEX}/${CIRCLE_NODE_TOTAL} --exclude=upgrade-module --exclude=upgrade-phonecat\n \n   # This job should only be run on PR builds, where `CI_PULL_REQUEST` is not `false`.\n   aio_preview:"
        },
        {
            "sha": "88ef2b8d32b4c45da13b6f227a6c4056e324162d",
            "filename": "aio/content/examples/practical-observable-usage/src/typeahead.spec.ts",
            "status": "modified",
            "additions": 97,
            "deletions": 15,
            "changes": 112,
            "blob_url": "https://github.com/angular/angular/blob/0fc4e66f6ede1ae897a38d560897c826cc938605/aio%2Fcontent%2Fexamples%2Fpractical-observable-usage%2Fsrc%2Ftypeahead.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/0fc4e66f6ede1ae897a38d560897c826cc938605/aio%2Fcontent%2Fexamples%2Fpractical-observable-usage%2Fsrc%2Ftypeahead.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fexamples%2Fpractical-observable-usage%2Fsrc%2Ftypeahead.spec.ts?ref=0fc4e66f6ede1ae897a38d560897c826cc938605",
            "patch": "@@ -1,13 +1,15 @@\n-import { Observable, of } from 'rxjs';\n+/// <reference types=\"node\" />\n+\n+import { of } from 'rxjs';\n import { docRegionTypeahead } from './typeahead';\n \n describe('typeahead', () => {\n   let document: Document;\n   let ajax: jasmine.Spy;\n+  let tick: MockClock['tick'];\n   let triggertInputChange: (e: { target: { value: string } }) => void;\n \n   beforeEach(() => {\n-    jasmine.clock().install();\n     const input = {\n       addEventListener: jasmine\n         .createSpy('addEvent')\n@@ -21,52 +23,132 @@ describe('typeahead', () => {\n \n     document = { getElementById: (id: string) => input } as unknown as Document;\n     ajax = jasmine.createSpy('ajax').and.callFake((url: string) => of('foo bar'));\n-  });\n-\n-  afterEach(() => {\n-    jasmine.clock().uninstall();\n+    tick = MockClock.install();\n   });\n \n   it('should make an ajax call to the corrent endpoint', () => {\n     docRegionTypeahead(document, ajax);\n     triggertInputChange({ target: { value: 'foo' } });\n-    jasmine.clock().tick(11);\n+    tick(11);\n     expect(ajax).toHaveBeenCalledWith('/api/endpoint?search=foo');\n   });\n \n   it('should not make an ajax call, when the input length < 3', () => {\n     docRegionTypeahead(document, ajax);\n     triggertInputChange({ target: { value: '' } });\n-    jasmine.clock().tick(11);\n+    tick(11);\n     expect(ajax).not.toHaveBeenCalled();\n     triggertInputChange({ target: { value: 'fo' } });\n-    jasmine.clock().tick(11);\n+    tick(11);\n     expect(ajax).not.toHaveBeenCalled();\n   });\n \n   it('should not make an ajax call for intermediate values when debouncing', () => {\n     docRegionTypeahead(document, ajax);\n     triggertInputChange({ target: { value: 'foo' } });\n-    jasmine.clock().tick(9);\n+    tick(9);\n     triggertInputChange({ target: { value: 'bar' } });\n-    jasmine.clock().tick(9);\n+    tick(9);\n     triggertInputChange({ target: { value: 'baz' } });\n-    jasmine.clock().tick(9);\n+    tick(9);\n     triggertInputChange({ target: { value: 'qux' } });\n     expect(ajax).not.toHaveBeenCalled();\n-    jasmine.clock().tick(10);\n+    tick(10);\n     expect(ajax).toHaveBeenCalledTimes(1);\n     expect(ajax).toHaveBeenCalledWith('/api/endpoint?search=qux');\n   });\n \n   it('should not make an ajax call, when the input value has not changed', () => {\n     docRegionTypeahead(document, ajax);\n     triggertInputChange({ target: { value: 'foo' } });\n-    jasmine.clock().tick(11);\n+    tick(11);\n     expect(ajax).toHaveBeenCalled();\n     ajax.calls.reset();\n     triggertInputChange({ target: { value: 'foo' } });\n-    jasmine.clock().tick(11);\n+    tick(11);\n     expect(ajax).not.toHaveBeenCalled();\n   });\n+\n+  // Helpers\n+  interface MockTask {\n+    id: NodeJS.Timeout;\n+    fn: () => unknown;\n+    delay: number;\n+    recurring: boolean;\n+    nextTriggerTime: number;\n+  }\n+\n+  class MockClock {\n+    private tasks: MockTask[] = [];\n+\n+    private constructor(private now: number) {}\n+\n+    static install(mockTime = 0): MockClock['tick'] {\n+      const mocked = new this(mockTime);\n+\n+      spyOn(global, 'clearInterval').and.callFake(id => mocked.clearTask(id));\n+      spyOn(global, 'clearTimeout').and.callFake(id => mocked.clearTask(id));\n+      spyOn(global, 'setInterval').and.callFake(\n+          (fn, delay, ...args) => mocked.createTask(fn, delay, true, ...args));\n+      spyOn(global, 'setTimeout').and.callFake(\n+          (fn, delay, ...args) => mocked.createTask(fn, delay, false, ...args));\n+\n+      spyOn(Date, 'now').and.callFake(() => mocked.now);\n+\n+      return mocked.tick.bind(mocked);\n+    }\n+\n+    private clearTask(id: MockTask['id']): void {\n+      this.tasks = this.tasks.filter(task => task.id !== id);\n+    }\n+\n+    private createTask(\n+        fn: MockTask['fn'], delay: MockTask['delay'], recurring: MockTask['recurring'],\n+        ...args: any[]): MockTask['id'] {\n+      // Avoid infinite loops.\n+      if (recurring && (delay <= 0)) {\n+        delay = 1;\n+      }\n+\n+      const task: MockTask = {\n+        id: {} as MockTask['id'],\n+        fn: fn.bind<null, unknown, unknown>(null, ...args),\n+        delay,\n+        recurring,\n+        nextTriggerTime: this.now + delay,\n+      };\n+      this.queueTask(task);\n+\n+      return task.id;\n+    }\n+\n+    private queueTask(task: MockTask): void {\n+      const firstLaterTaskIdx = this.tasks.findIndex(\n+          otherTask => otherTask.nextTriggerTime > task.nextTriggerTime);\n+      const newTaskIdx = (firstLaterTaskIdx === -1) ? this.tasks.length : firstLaterTaskIdx;\n+\n+      this.tasks.splice(newTaskIdx, 0, task);\n+    }\n+\n+    private tick(millis: number): void {\n+      const finalNow = this.now + millis;\n+\n+      while (this.tasks[0]?.nextTriggerTime <= finalNow) {\n+        const task = this.tasks.shift()!;\n+        this.now = task.nextTriggerTime;\n+\n+        if (task.recurring) {\n+          this.queueTask({...task, nextTriggerTime: this.now + task.delay});\n+        }\n+\n+        try {\n+          task.fn();\n+        } catch (err) {\n+          console.error(err);\n+        }\n+      }\n+\n+      this.now = finalNow;\n+    }\n+  }\n });"
        }
    ],
    "stats": {
        "total": 114,
        "additions": 98,
        "deletions": 16
    }
}