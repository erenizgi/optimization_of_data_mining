{
    "author": "mgechev",
    "message": "refactor(devtools): move different profiler implementations to separate files",
    "sha": "42a6a775f7a4a6e198b077db2f7fedc00c7a1869",
    "files": [
        {
            "sha": "b95402ad677aa3bdaa20d27b4f1db338a8723a36",
            "filename": "projects/ng-devtools-backend/src/lib/hooks/profiler.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 460,
            "changes": 460,
            "blob_url": "https://github.com/angular/angular/blob/b9a1f8790c153dc313e11a69f0aec4cd4dd6e4c8/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fprofiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/b9a1f8790c153dc313e11a69f0aec4cd4dd6e4c8/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fprofiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fprofiler.ts?ref=b9a1f8790c153dc313e11a69f0aec4cd4dd6e4c8",
            "patch": "@@ -1,460 +0,0 @@\n-import { ɵProfilerEvent } from '@angular/core';\n-import { ElementPosition, LifecycleProfile } from 'protocol';\n-import { Subject } from 'rxjs';\n-import {\n-  getDirectiveHostElement,\n-  getLViewFromDirectiveOrElementInstance,\n-  METADATA_PROPERTY_NAME,\n-} from '../directive-forest';\n-import { runOutsideAngular } from '../utils';\n-import { IdentityTracker, NodeArray } from './identity-tracker';\n-\n-type CreationHook = (\n-  componentOrDirective: any,\n-  node: Node,\n-  id: number,\n-  isComponent: boolean,\n-  position: ElementPosition\n-) => void;\n-\n-type LifecycleStartHook = (\n-  componentOrDirective: any,\n-  hook: keyof LifecycleProfile | 'unknown',\n-  node: Node,\n-  id: number,\n-  isComponent: boolean\n-) => void;\n-\n-type LifecycleEndHook = (\n-  componentOrDirective: any,\n-  hook: keyof LifecycleProfile | 'unknown',\n-  node: Node,\n-  id: number,\n-  isComponent: boolean\n-) => void;\n-\n-type ChangeDetectionStartHook = (component: any, node: Node, id: number, position: ElementPosition) => void;\n-\n-type ChangeDetectionEndHook = (component: any, node: Node, id: number, position: ElementPosition) => void;\n-\n-type DestroyHook = (\n-  componentOrDirective: any,\n-  node: Node,\n-  id: number,\n-  isComponent: boolean,\n-  position: ElementPosition\n-) => void;\n-\n-export interface Hooks {\n-  onCreate: CreationHook;\n-  onDestroy: DestroyHook;\n-  onChangeDetectionStart: ChangeDetectionStartHook;\n-  onChangeDetectionEnd: ChangeDetectionEndHook;\n-  onLifecycleHookStart: LifecycleStartHook;\n-  onLifecycleHookEnd: LifecycleEndHook;\n-}\n-\n-const ngProfilerCallbacks: ((event: ɵProfilerEvent, instanceOrLView: {}, hookOrListener: any) => void)[] = [];\n-export const setProfilerCallback = (cb: (event: ɵProfilerEvent, instanceOrLView: {}, hookOrListener: any) => void) => {\n-  ngProfilerCallbacks.push(cb);\n-};\n-\n-/**\n- * Factory method for creating profiler object.\n- * Gives priority to NgProfiler, falls back on PatchingProfiler if framework APIs are not present.\n- */\n-export const selectProfilerStrategy = (): Profiler => {\n-  const ng = (window as any).ng;\n-  if (typeof ng?.ɵsetProfiler === 'function') {\n-    ng.ɵsetProfiler((event: ɵProfilerEvent, instanceOrLView: {}, hookOrListener: any) =>\n-      ngProfilerCallbacks.forEach((cb) => cb(event, instanceOrLView, hookOrListener))\n-    );\n-    return new NgProfiler();\n-  }\n-\n-  return new PatchingProfiler();\n-};\n-\n-/**\n- *  Class for profiling angular applications. Handles hook subscriptions and emitting change detection events.\n- */\n-export abstract class Profiler {\n-  protected _inChangeDetection = false;\n-  changeDetection$ = new Subject<void>();\n-\n-  private _hooks: Partial<Hooks>[] = [];\n-\n-  constructor(config: Partial<Hooks> = {}) {\n-    this._hooks.push(config);\n-  }\n-\n-  abstract destroy(): void;\n-\n-  abstract onIndexForest(newNodes: NodeArray, removedNodes: NodeArray): void;\n-\n-  subscribe(config: Partial<Hooks>): void {\n-    this._hooks.push(config);\n-  }\n-\n-  unsubscribe(config: Partial<Hooks>): void {\n-    this._hooks.splice(this._hooks.indexOf(config), 1);\n-  }\n-\n-  protected _onCreate(\n-    _: any,\n-    __: Node,\n-    id: number | undefined,\n-    ___: boolean,\n-    position: ElementPosition | undefined\n-  ): void {\n-    if (id === undefined || position === undefined) {\n-      return;\n-    }\n-    this._invokeCallback('onCreate', arguments);\n-  }\n-\n-  protected _onDestroy(\n-    _: any,\n-    __: Node,\n-    id: number | undefined,\n-    ___: boolean,\n-    position: ElementPosition | undefined\n-  ): void {\n-    if (id === undefined || position === undefined) {\n-      return;\n-    }\n-    this._invokeCallback('onDestroy', arguments);\n-  }\n-\n-  protected _onChangeDetectionStart(\n-    _: any,\n-    __: Node,\n-    id: number | undefined,\n-    position: ElementPosition | undefined\n-  ): void {\n-    if (id === undefined || position === undefined) {\n-      return;\n-    }\n-    this._invokeCallback('onChangeDetectionStart', arguments);\n-  }\n-\n-  protected _onChangeDetectionEnd(\n-    _: any,\n-    __: Node,\n-    id: number | undefined,\n-    position: ElementPosition | undefined\n-  ): void {\n-    if (id === undefined || position === undefined) {\n-      return;\n-    }\n-    this._invokeCallback('onChangeDetectionEnd', arguments);\n-  }\n-\n-  protected _onLifecycleHookStart(\n-    _: any,\n-    __: keyof LifecycleProfile | 'unknown',\n-    ___: Node,\n-    id: number | undefined,\n-    ____: boolean\n-  ): void {\n-    if (id === undefined) {\n-      return;\n-    }\n-    this._invokeCallback('onLifecycleHookStart', arguments);\n-  }\n-\n-  protected _onLifecycleHookEnd(\n-    _: any,\n-    __: keyof LifecycleProfile | 'unknown',\n-    ___: Node,\n-    id: number | undefined,\n-    ____: boolean\n-  ): void {\n-    if (id === undefined) {\n-      return;\n-    }\n-    this._invokeCallback('onLifecycleHookEnd', arguments);\n-  }\n-\n-  private _invokeCallback(name: keyof Hooks, args: IArguments): void {\n-    this._hooks.forEach((config) => {\n-      const cb = config[name];\n-      if (cb) {\n-        cb.apply(null, args);\n-      }\n-    });\n-  }\n-}\n-\n-const hookNames = [\n-  'OnInit',\n-  'OnDestroy',\n-  'OnChanges',\n-  'DoCheck',\n-  'AfterContentInit',\n-  'AfterContentChecked',\n-  'AfterViewInit',\n-  'AfterViewChecked',\n-];\n-\n-const hookMethodNames = new Set(hookNames.map((hook) => `ng${hook}`));\n-\n-const hookTViewProperties = [\n-  'preOrderHooks',\n-  'preOrderCheckHooks',\n-  'contentHooks',\n-  'contentCheckHooks',\n-  'viewHooks',\n-  'viewCheckHooks',\n-  'destroyHooks',\n-];\n-\n-// Only used in older Angular versions prior to the introduction of `getDirectiveMetadata`\n-const componentMetadata = (instance: any) => instance?.constructor?.ɵcmp;\n-\n-const getLifeCycleName = (obj: {}, fn: any): keyof LifecycleProfile | 'unknown' => {\n-  const proto = Object.getPrototypeOf(obj);\n-  const keys = Object.getOwnPropertyNames(proto);\n-  for (const propName of keys) {\n-    // We don't want to touch random get accessors.\n-    if (!hookMethodNames.has(propName)) {\n-      continue;\n-    }\n-    if (proto[propName] === fn) {\n-      return propName as keyof LifecycleProfile;\n-    }\n-  }\n-  const fnName = fn.name;\n-  if (typeof fnName !== 'string') {\n-    return 'unknown';\n-  }\n-  for (const hookName of hookNames) {\n-    if (fnName.indexOf(hookName) >= 0) {\n-      return `ng${hookName}` as keyof LifecycleProfile;\n-    }\n-  }\n-  return 'unknown';\n-};\n-\n-/** Implemenation of Profiler that uses monkey patching of directive templates and lifecycle methods to fire profiler hooks. */\n-class PatchingProfiler extends Profiler {\n-  private _patched = new Map<any, () => void>();\n-  private _undoLifecyclePatch: (() => void)[] = [];\n-  private _tracker = IdentityTracker.getInstance();\n-\n-  destroy(): void {\n-    this._tracker.destroy();\n-\n-    for (const [cmp, template] of this._patched) {\n-      const meta = componentMetadata(cmp);\n-      meta.template = template;\n-      meta.tView.template = template;\n-    }\n-\n-    this._patched = new Map<any, () => void>();\n-    this._undoLifecyclePatch.forEach((p) => p());\n-    this._undoLifecyclePatch = [];\n-  }\n-\n-  onIndexForest(newNodes: NodeArray, removedNodes: NodeArray): void {\n-    newNodes.forEach((node) => {\n-      this._observeLifecycle(node.directive, node.isComponent);\n-      this._observeComponent(node.directive);\n-      this._fireCreationCallback(node.directive, node.isComponent);\n-    });\n-    removedNodes.forEach((node) => {\n-      this._patched.delete(node.directive);\n-      this._fireDestroyCallback(node.directive, node.isComponent);\n-    });\n-  }\n-\n-  private _fireCreationCallback(component: any, isComponent: boolean): void {\n-    const position = this._tracker.getDirectivePosition(component);\n-    const id = this._tracker.getDirectiveId(component);\n-    this._onCreate(component, getDirectiveHostElement(component), id, isComponent, position);\n-  }\n-\n-  private _fireDestroyCallback(component: any, isComponent: boolean): void {\n-    const position = this._tracker.getDirectivePosition(component);\n-    const id = this._tracker.getDirectiveId(component);\n-    this._onDestroy(component, getDirectiveHostElement(component), id, isComponent, position);\n-  }\n-\n-  private _observeComponent(cmp: any): void {\n-    const declarations = componentMetadata(cmp);\n-    if (!declarations) {\n-      return;\n-    }\n-    const original = declarations.template;\n-    const self = this;\n-    if (original.patched) {\n-      return;\n-    }\n-    declarations.tView.template = function (_: any, component: any): void {\n-      if (!self._inChangeDetection) {\n-        self._inChangeDetection = true;\n-        runOutsideAngular(() => {\n-          Promise.resolve().then(() => {\n-            self.changeDetection$.next();\n-            self._inChangeDetection = false;\n-          });\n-        });\n-      }\n-      const position = self._tracker.getDirectivePosition(component);\n-      const id = self._tracker.getDirectiveId(component);\n-\n-      self._onChangeDetectionStart(component, getDirectiveHostElement(component), id, position);\n-      original.apply(this, arguments);\n-      if (self._tracker.hasDirective(component) && id !== undefined && position !== undefined) {\n-        self._onChangeDetectionEnd(component, getDirectiveHostElement(component), id, position);\n-      }\n-    };\n-    declarations.tView.template.patched = true;\n-    this._patched.set(cmp, original);\n-  }\n-\n-  private _observeLifecycle(directive: any, isComponent: boolean): void {\n-    const ctx = getLViewFromDirectiveOrElementInstance(directive);\n-    if (!ctx) {\n-      return;\n-    }\n-    const tview = ctx[1];\n-    hookTViewProperties.forEach((hook) => {\n-      const current = tview[hook];\n-      if (!Array.isArray(current)) {\n-        return;\n-      }\n-      current.forEach((el: any, idx: number) => {\n-        if (el.patched) {\n-          return;\n-        }\n-        if (typeof el === 'function') {\n-          const self = this;\n-          current[idx] = function (): any {\n-            // We currently don't want to notify the consumer\n-            // for execution of lifecycle hooks of services and pipes.\n-            // These two abstractions don't have `__ngContext__`, and\n-            // currently we won't be able to extract the required\n-            // metadata by the UI.\n-            if (!this[METADATA_PROPERTY_NAME]) {\n-              return;\n-            }\n-            const id = self._tracker.getDirectiveId(this);\n-            const lifecycleHookName = getLifeCycleName(this, el);\n-            const element = getDirectiveHostElement(this);\n-            self._onLifecycleHookStart(this, lifecycleHookName, element, id, isComponent);\n-            const result = el.apply(this, arguments);\n-            self._onLifecycleHookEnd(this, lifecycleHookName, element, id, isComponent);\n-            return result;\n-          };\n-          current[idx].patched = true;\n-          this._undoLifecyclePatch.push(() => {\n-            current[idx] = el;\n-          });\n-        }\n-      });\n-    });\n-  }\n-}\n-\n-/** Implemenation of Profiler that utilizes framework APIs fire profiler hooks. */\n-class NgProfiler extends Profiler {\n-  private _tracker = IdentityTracker.getInstance();\n-\n-  constructor(config: Partial<Hooks> = {}) {\n-    super(config);\n-    setProfilerCallback((event: ɵProfilerEvent, instanceOrLView: {}, hookOrListener: any) => {\n-      if (this[event] === undefined) {\n-        return;\n-      }\n-\n-      this[event](instanceOrLView, hookOrListener);\n-    });\n-  }\n-\n-  destroy(): void {\n-    this._tracker.destroy();\n-  }\n-\n-  onIndexForest(newNodes: NodeArray, removedNodes: NodeArray): void {\n-    newNodes.forEach((node) => {\n-      const { directive, isComponent } = node;\n-\n-      const position = this._tracker.getDirectivePosition(directive);\n-      const id = this._tracker.getDirectiveId(directive);\n-      this._onCreate(directive, getDirectiveHostElement(directive), id, isComponent, position);\n-    });\n-\n-    removedNodes.forEach((node) => {\n-      const { directive, isComponent } = node;\n-\n-      const position = this._tracker.getDirectivePosition(directive);\n-      const id = this._tracker.getDirectiveId(directive);\n-      this._onDestroy(directive, getDirectiveHostElement(directive), id, isComponent, position);\n-    });\n-  }\n-\n-  [ɵProfilerEvent.TemplateCreateStart](_directive: any, _hookOrListener: any): void {\n-    // todo: implement\n-    return;\n-  }\n-\n-  [ɵProfilerEvent.TemplateCreateEnd](_directive: any, _hookOrListener: any): void {\n-    // todo: implement\n-    return;\n-  }\n-\n-  [ɵProfilerEvent.TemplateUpdateStart](directive: any, _hookOrListener: any): void {\n-    if (!this._inChangeDetection) {\n-      this._inChangeDetection = true;\n-      runOutsideAngular(() => {\n-        Promise.resolve().then(() => {\n-          this.changeDetection$.next();\n-          this._inChangeDetection = false;\n-        });\n-      });\n-    }\n-\n-    const position = this._tracker.getDirectivePosition(directive);\n-    const id = this._tracker.getDirectiveId(directive);\n-\n-    this._onChangeDetectionStart(directive, getDirectiveHostElement(directive), id, position);\n-  }\n-\n-  [ɵProfilerEvent.TemplateUpdateEnd](directive: any, _hookOrListener: any): void {\n-    const position = this._tracker.getDirectivePosition(directive);\n-    const id = this._tracker.getDirectiveId(directive);\n-\n-    if (this._tracker.hasDirective(directive) && id !== undefined && position !== undefined) {\n-      this._onChangeDetectionEnd(directive, getDirectiveHostElement(directive), id, position);\n-    }\n-  }\n-\n-  [ɵProfilerEvent.LifecycleHookStart](directive: any, hookOrListener: any): void {\n-    const id = this._tracker.getDirectiveId(directive);\n-    const element = getDirectiveHostElement(directive);\n-    const lifecycleHookName = getLifeCycleName(directive, hookOrListener);\n-    const isComponent = !!this._tracker.isComponent.get(directive);\n-\n-    this._onLifecycleHookStart(directive, lifecycleHookName, element, id, isComponent);\n-  }\n-\n-  [ɵProfilerEvent.LifecycleHookEnd](directive: any, hookOrListener: any): void {\n-    const id = this._tracker.getDirectiveId(directive);\n-    const element = getDirectiveHostElement(directive);\n-    const lifecycleHookName = getLifeCycleName(directive, hookOrListener);\n-    const isComponent = !!this._tracker.isComponent.get(directive);\n-\n-    this._onLifecycleHookEnd(directive, lifecycleHookName, element, id, isComponent);\n-  }\n-\n-  [ɵProfilerEvent.OutputStart](_directive: any, _hookOrListener: any): void {\n-    // todo: implement\n-    return;\n-  }\n-\n-  [ɵProfilerEvent.OutputEnd](_directive: any, _hookOrListener: any): void {\n-    // todo: implement\n-    return;\n-  }\n-}"
        },
        {
            "sha": "1f5f1246d8394f30d73cb9f625afc3c58d26a213",
            "filename": "projects/ng-devtools-backend/src/lib/hooks/profiler/index.ts",
            "status": "added",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/angular/angular/blob/42a6a775f7a4a6e198b077db2f7fedc00c7a1869/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fprofiler%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/42a6a775f7a4a6e198b077db2f7fedc00c7a1869/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fprofiler%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fprofiler%2Findex.ts?ref=42a6a775f7a4a6e198b077db2f7fedc00c7a1869",
            "patch": "@@ -0,0 +1,22 @@\n+import { ɵProfilerEvent } from '@angular/core';\n+import { NgProfiler } from './native';\n+import { PatchingProfiler } from './polyfill';\n+import { Profiler, ngProfilerCallbacks } from './shared';\n+\n+export { Profiler, Hooks } from './shared';\n+\n+/**\n+ * Factory method for creating profiler object.\n+ * Gives priority to NgProfiler, falls back on PatchingProfiler if framework APIs are not present.\n+ */\n+export const selectProfilerStrategy = (): Profiler => {\n+  const ng = (window as any).ng;\n+  if (typeof ng?.ɵsetProfiler === 'function') {\n+    ng.ɵsetProfiler((event: ɵProfilerEvent, instanceOrLView: {}, hookOrListener: any) =>\n+      ngProfilerCallbacks.forEach((cb) => cb(event, instanceOrLView, hookOrListener))\n+    );\n+    return new NgProfiler();\n+  }\n+\n+  return new PatchingProfiler();\n+};"
        },
        {
            "sha": "db2c6ab4459f14172849769c75f6deafb944a3e8",
            "filename": "projects/ng-devtools-backend/src/lib/hooks/profiler/native.ts",
            "status": "added",
            "additions": 111,
            "deletions": 0,
            "changes": 111,
            "blob_url": "https://github.com/angular/angular/blob/42a6a775f7a4a6e198b077db2f7fedc00c7a1869/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fprofiler%2Fnative.ts",
            "raw_url": "https://github.com/angular/angular/raw/42a6a775f7a4a6e198b077db2f7fedc00c7a1869/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fprofiler%2Fnative.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fprofiler%2Fnative.ts?ref=42a6a775f7a4a6e198b077db2f7fedc00c7a1869",
            "patch": "@@ -0,0 +1,111 @@\n+import { ɵProfilerEvent } from '@angular/core';\n+import { getDirectiveHostElement } from '../../directive-forest';\n+import { runOutsideAngular } from '../../utils';\n+import { IdentityTracker, NodeArray } from '../identity-tracker';\n+import { getLifeCycleName, Hooks, ngProfilerCallbacks, Profiler } from './shared';\n+\n+const setProfilerCallback = (cb: (event: ɵProfilerEvent, instanceOrLView: {}, hookOrListener: any) => void) => {\n+  ngProfilerCallbacks.push(cb);\n+};\n+\n+/** Implementation of Profiler that utilizes framework APIs fire profiler hooks. */\n+export class NgProfiler extends Profiler {\n+  private _tracker = IdentityTracker.getInstance();\n+\n+  constructor(config: Partial<Hooks> = {}) {\n+    super(config);\n+    setProfilerCallback((event: ɵProfilerEvent, instanceOrLView: {}, hookOrListener: any) => {\n+      if (this[event] === undefined) {\n+        return;\n+      }\n+\n+      this[event](instanceOrLView, hookOrListener);\n+    });\n+  }\n+\n+  destroy(): void {\n+    this._tracker.destroy();\n+  }\n+\n+  onIndexForest(newNodes: NodeArray, removedNodes: NodeArray): void {\n+    newNodes.forEach((node) => {\n+      const { directive, isComponent } = node;\n+\n+      const position = this._tracker.getDirectivePosition(directive);\n+      const id = this._tracker.getDirectiveId(directive);\n+      this._onCreate(directive, getDirectiveHostElement(directive), id, isComponent, position);\n+    });\n+\n+    removedNodes.forEach((node) => {\n+      const { directive, isComponent } = node;\n+\n+      const position = this._tracker.getDirectivePosition(directive);\n+      const id = this._tracker.getDirectiveId(directive);\n+      this._onDestroy(directive, getDirectiveHostElement(directive), id, isComponent, position);\n+    });\n+  }\n+\n+  [ɵProfilerEvent.TemplateCreateStart](_directive: any, _hookOrListener: any): void {\n+    // todo: implement\n+    return;\n+  }\n+\n+  [ɵProfilerEvent.TemplateCreateEnd](_directive: any, _hookOrListener: any): void {\n+    // todo: implement\n+    return;\n+  }\n+\n+  [ɵProfilerEvent.TemplateUpdateStart](directive: any, _hookOrListener: any): void {\n+    if (!this._inChangeDetection) {\n+      this._inChangeDetection = true;\n+      runOutsideAngular(() => {\n+        Promise.resolve().then(() => {\n+          this.changeDetection$.next();\n+          this._inChangeDetection = false;\n+        });\n+      });\n+    }\n+\n+    const position = this._tracker.getDirectivePosition(directive);\n+    const id = this._tracker.getDirectiveId(directive);\n+\n+    this._onChangeDetectionStart(directive, getDirectiveHostElement(directive), id, position);\n+  }\n+\n+  [ɵProfilerEvent.TemplateUpdateEnd](directive: any, _hookOrListener: any): void {\n+    const position = this._tracker.getDirectivePosition(directive);\n+    const id = this._tracker.getDirectiveId(directive);\n+\n+    if (this._tracker.hasDirective(directive) && id !== undefined && position !== undefined) {\n+      this._onChangeDetectionEnd(directive, getDirectiveHostElement(directive), id, position);\n+    }\n+  }\n+\n+  [ɵProfilerEvent.LifecycleHookStart](directive: any, hookOrListener: any): void {\n+    const id = this._tracker.getDirectiveId(directive);\n+    const element = getDirectiveHostElement(directive);\n+    const lifecycleHookName = getLifeCycleName(directive, hookOrListener);\n+    const isComponent = !!this._tracker.isComponent.get(directive);\n+\n+    this._onLifecycleHookStart(directive, lifecycleHookName, element, id, isComponent);\n+  }\n+\n+  [ɵProfilerEvent.LifecycleHookEnd](directive: any, hookOrListener: any): void {\n+    const id = this._tracker.getDirectiveId(directive);\n+    const element = getDirectiveHostElement(directive);\n+    const lifecycleHookName = getLifeCycleName(directive, hookOrListener);\n+    const isComponent = !!this._tracker.isComponent.get(directive);\n+\n+    this._onLifecycleHookEnd(directive, lifecycleHookName, element, id, isComponent);\n+  }\n+\n+  [ɵProfilerEvent.OutputStart](_directive: any, _hookOrListener: any): void {\n+    // todo: implement\n+    return;\n+  }\n+\n+  [ɵProfilerEvent.OutputEnd](_directive: any, _hookOrListener: any): void {\n+    // todo: implement\n+    return;\n+  }\n+}"
        },
        {
            "sha": "2edd013f861258f43430c8b54355b9e6a1fea0e0",
            "filename": "projects/ng-devtools-backend/src/lib/hooks/profiler/polyfill.ts",
            "status": "added",
            "additions": 142,
            "deletions": 0,
            "changes": 142,
            "blob_url": "https://github.com/angular/angular/blob/42a6a775f7a4a6e198b077db2f7fedc00c7a1869/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fprofiler%2Fpolyfill.ts",
            "raw_url": "https://github.com/angular/angular/raw/42a6a775f7a4a6e198b077db2f7fedc00c7a1869/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fprofiler%2Fpolyfill.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fprofiler%2Fpolyfill.ts?ref=42a6a775f7a4a6e198b077db2f7fedc00c7a1869",
            "patch": "@@ -0,0 +1,142 @@\n+import {\n+  getDirectiveHostElement,\n+  getLViewFromDirectiveOrElementInstance,\n+  METADATA_PROPERTY_NAME,\n+} from '../../directive-forest';\n+import { runOutsideAngular } from '../../utils';\n+import { IdentityTracker, NodeArray } from '../identity-tracker';\n+import { getLifeCycleName, Profiler } from './shared';\n+\n+const hookTViewProperties = [\n+  'preOrderHooks',\n+  'preOrderCheckHooks',\n+  'contentHooks',\n+  'contentCheckHooks',\n+  'viewHooks',\n+  'viewCheckHooks',\n+  'destroyHooks',\n+];\n+\n+// Only used in older Angular versions prior to the introduction of `getDirectiveMetadata`\n+const componentMetadata = (instance: any) => instance?.constructor?.ɵcmp;\n+\n+/** Implementation of Profiler that uses monkey patching of directive templates and lifecycle methods to fire profiler hooks. */\n+export class PatchingProfiler extends Profiler {\n+  private _patched = new Map<any, () => void>();\n+  private _undoLifecyclePatch: (() => void)[] = [];\n+  private _tracker = IdentityTracker.getInstance();\n+\n+  destroy(): void {\n+    this._tracker.destroy();\n+\n+    for (const [cmp, template] of this._patched) {\n+      const meta = componentMetadata(cmp);\n+      meta.template = template;\n+      meta.tView.template = template;\n+    }\n+\n+    this._patched = new Map<any, () => void>();\n+    this._undoLifecyclePatch.forEach((p) => p());\n+    this._undoLifecyclePatch = [];\n+  }\n+\n+  onIndexForest(newNodes: NodeArray, removedNodes: NodeArray): void {\n+    newNodes.forEach((node) => {\n+      this._observeLifecycle(node.directive, node.isComponent);\n+      this._observeComponent(node.directive);\n+      this._fireCreationCallback(node.directive, node.isComponent);\n+    });\n+    removedNodes.forEach((node) => {\n+      this._patched.delete(node.directive);\n+      this._fireDestroyCallback(node.directive, node.isComponent);\n+    });\n+  }\n+\n+  private _fireCreationCallback(component: any, isComponent: boolean): void {\n+    const position = this._tracker.getDirectivePosition(component);\n+    const id = this._tracker.getDirectiveId(component);\n+    this._onCreate(component, getDirectiveHostElement(component), id, isComponent, position);\n+  }\n+\n+  private _fireDestroyCallback(component: any, isComponent: boolean): void {\n+    const position = this._tracker.getDirectivePosition(component);\n+    const id = this._tracker.getDirectiveId(component);\n+    this._onDestroy(component, getDirectiveHostElement(component), id, isComponent, position);\n+  }\n+\n+  private _observeComponent(cmp: any): void {\n+    const declarations = componentMetadata(cmp);\n+    if (!declarations) {\n+      return;\n+    }\n+    const original = declarations.template;\n+    const self = this;\n+    if (original.patched) {\n+      return;\n+    }\n+    declarations.tView.template = function (_: any, component: any): void {\n+      if (!self._inChangeDetection) {\n+        self._inChangeDetection = true;\n+        runOutsideAngular(() => {\n+          Promise.resolve().then(() => {\n+            self.changeDetection$.next();\n+            self._inChangeDetection = false;\n+          });\n+        });\n+      }\n+      const position = self._tracker.getDirectivePosition(component);\n+      const id = self._tracker.getDirectiveId(component);\n+\n+      self._onChangeDetectionStart(component, getDirectiveHostElement(component), id, position);\n+      original.apply(this, arguments);\n+      if (self._tracker.hasDirective(component) && id !== undefined && position !== undefined) {\n+        self._onChangeDetectionEnd(component, getDirectiveHostElement(component), id, position);\n+      }\n+    };\n+    declarations.tView.template.patched = true;\n+    this._patched.set(cmp, original);\n+  }\n+\n+  private _observeLifecycle(directive: any, isComponent: boolean): void {\n+    const ctx = getLViewFromDirectiveOrElementInstance(directive);\n+    if (!ctx) {\n+      return;\n+    }\n+    const tview = ctx[1];\n+    hookTViewProperties.forEach((hook) => {\n+      const current = tview[hook];\n+      if (!Array.isArray(current)) {\n+        return;\n+      }\n+      current.forEach((el: any, idx: number) => {\n+        if (el.patched) {\n+          return;\n+        }\n+        if (typeof el === 'function') {\n+          const self = this;\n+          current[idx] = function (): any {\n+            // We currently don't want to notify the consumer\n+            // for execution of lifecycle hooks of services and pipes.\n+            // These two abstractions don't have `__ngContext__`, and\n+            // currently we won't be able to extract the required\n+            // metadata by the UI.\n+            if (!this[METADATA_PROPERTY_NAME]) {\n+              return;\n+            }\n+            const id = self._tracker.getDirectiveId(this);\n+            const lifecycleHookName = getLifeCycleName(this, el);\n+            const element = getDirectiveHostElement(this);\n+            self._onLifecycleHookStart(this, lifecycleHookName, element, id, isComponent);\n+            const result = el.apply(this, arguments);\n+            self._onLifecycleHookEnd(this, lifecycleHookName, element, id, isComponent);\n+            return result;\n+          };\n+          current[idx].patched = true;\n+          this._undoLifecyclePatch.push(() => {\n+            current[idx] = el;\n+          });\n+        }\n+      });\n+    });\n+  }\n+}"
        },
        {
            "sha": "1bf64c42d298fa31c2ec0c07a90da800eab5af31",
            "filename": "projects/ng-devtools-backend/src/lib/hooks/profiler/shared.ts",
            "status": "added",
            "additions": 199,
            "deletions": 0,
            "changes": 199,
            "blob_url": "https://github.com/angular/angular/blob/42a6a775f7a4a6e198b077db2f7fedc00c7a1869/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fprofiler%2Fshared.ts",
            "raw_url": "https://github.com/angular/angular/raw/42a6a775f7a4a6e198b077db2f7fedc00c7a1869/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fprofiler%2Fshared.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fprofiler%2Fshared.ts?ref=42a6a775f7a4a6e198b077db2f7fedc00c7a1869",
            "patch": "@@ -0,0 +1,199 @@\n+import { ɵProfilerEvent } from '@angular/core';\n+import { ElementPosition, LifecycleProfile } from 'protocol';\n+import { Subject } from 'rxjs';\n+import { IdentityTracker, NodeArray } from '../identity-tracker';\n+\n+type CreationHook = (\n+  componentOrDirective: any,\n+  node: Node,\n+  id: number,\n+  isComponent: boolean,\n+  position: ElementPosition\n+) => void;\n+\n+type LifecycleStartHook = (\n+  componentOrDirective: any,\n+  hook: keyof LifecycleProfile | 'unknown',\n+  node: Node,\n+  id: number,\n+  isComponent: boolean\n+) => void;\n+\n+type LifecycleEndHook = (\n+  componentOrDirective: any,\n+  hook: keyof LifecycleProfile | 'unknown',\n+  node: Node,\n+  id: number,\n+  isComponent: boolean\n+) => void;\n+\n+type ChangeDetectionStartHook = (component: any, node: Node, id: number, position: ElementPosition) => void;\n+\n+type ChangeDetectionEndHook = (component: any, node: Node, id: number, position: ElementPosition) => void;\n+\n+type DestroyHook = (\n+  componentOrDirective: any,\n+  node: Node,\n+  id: number,\n+  isComponent: boolean,\n+  position: ElementPosition\n+) => void;\n+\n+export interface Hooks {\n+  onCreate: CreationHook;\n+  onDestroy: DestroyHook;\n+  onChangeDetectionStart: ChangeDetectionStartHook;\n+  onChangeDetectionEnd: ChangeDetectionEndHook;\n+  onLifecycleHookStart: LifecycleStartHook;\n+  onLifecycleHookEnd: LifecycleEndHook;\n+}\n+\n+export const ngProfilerCallbacks: ((event: ɵProfilerEvent, instanceOrLView: {}, hookOrListener: any) => void)[] = [];\n+\n+/**\n+ *  Class for profiling angular applications. Handles hook subscriptions and emitting change detection events.\n+ */\n+export abstract class Profiler {\n+  protected _inChangeDetection = false;\n+  changeDetection$ = new Subject<void>();\n+\n+  private _hooks: Partial<Hooks>[] = [];\n+\n+  constructor(config: Partial<Hooks> = {}) {\n+    this._hooks.push(config);\n+  }\n+\n+  abstract destroy(): void;\n+\n+  abstract onIndexForest(newNodes: NodeArray, removedNodes: NodeArray): void;\n+\n+  subscribe(config: Partial<Hooks>): void {\n+    this._hooks.push(config);\n+  }\n+\n+  unsubscribe(config: Partial<Hooks>): void {\n+    this._hooks.splice(this._hooks.indexOf(config), 1);\n+  }\n+\n+  protected _onCreate(\n+    _: any,\n+    __: Node,\n+    id: number | undefined,\n+    ___: boolean,\n+    position: ElementPosition | undefined\n+  ): void {\n+    if (id === undefined || position === undefined) {\n+      return;\n+    }\n+    this._invokeCallback('onCreate', arguments);\n+  }\n+\n+  protected _onDestroy(\n+    _: any,\n+    __: Node,\n+    id: number | undefined,\n+    ___: boolean,\n+    position: ElementPosition | undefined\n+  ): void {\n+    if (id === undefined || position === undefined) {\n+      return;\n+    }\n+    this._invokeCallback('onDestroy', arguments);\n+  }\n+\n+  protected _onChangeDetectionStart(\n+    _: any,\n+    __: Node,\n+    id: number | undefined,\n+    position: ElementPosition | undefined\n+  ): void {\n+    if (id === undefined || position === undefined) {\n+      return;\n+    }\n+    this._invokeCallback('onChangeDetectionStart', arguments);\n+  }\n+\n+  protected _onChangeDetectionEnd(\n+    _: any,\n+    __: Node,\n+    id: number | undefined,\n+    position: ElementPosition | undefined\n+  ): void {\n+    if (id === undefined || position === undefined) {\n+      return;\n+    }\n+    this._invokeCallback('onChangeDetectionEnd', arguments);\n+  }\n+\n+  protected _onLifecycleHookStart(\n+    _: any,\n+    __: keyof LifecycleProfile | 'unknown',\n+    ___: Node,\n+    id: number | undefined,\n+    ____: boolean\n+  ): void {\n+    if (id === undefined) {\n+      return;\n+    }\n+    this._invokeCallback('onLifecycleHookStart', arguments);\n+  }\n+\n+  protected _onLifecycleHookEnd(\n+    _: any,\n+    __: keyof LifecycleProfile | 'unknown',\n+    ___: Node,\n+    id: number | undefined,\n+    ____: boolean\n+  ): void {\n+    if (id === undefined) {\n+      return;\n+    }\n+    this._invokeCallback('onLifecycleHookEnd', arguments);\n+  }\n+\n+  private _invokeCallback(name: keyof Hooks, args: IArguments): void {\n+    this._hooks.forEach((config) => {\n+      const cb = config[name];\n+      if (cb) {\n+        cb.apply(null, args);\n+      }\n+    });\n+  }\n+}\n+\n+const hookNames = [\n+  'OnInit',\n+  'OnDestroy',\n+  'OnChanges',\n+  'DoCheck',\n+  'AfterContentInit',\n+  'AfterContentChecked',\n+  'AfterViewInit',\n+  'AfterViewChecked',\n+];\n+\n+const hookMethodNames = new Set(hookNames.map((hook) => `ng${hook}`));\n+\n+export const getLifeCycleName = (obj: {}, fn: any): keyof LifecycleProfile | 'unknown' => {\n+  const proto = Object.getPrototypeOf(obj);\n+  const keys = Object.getOwnPropertyNames(proto);\n+  for (const propName of keys) {\n+    // We don't want to touch random get accessors.\n+    if (!hookMethodNames.has(propName)) {\n+      continue;\n+    }\n+    if (proto[propName] === fn) {\n+      return propName as keyof LifecycleProfile;\n+    }\n+  }\n+  const fnName = fn.name;\n+  if (typeof fnName !== 'string') {\n+    return 'unknown';\n+  }\n+  for (const hookName of hookNames) {\n+    if (fnName.indexOf(hookName) >= 0) {\n+      return `ng${hookName}` as keyof LifecycleProfile;\n+    }\n+  }\n+  return 'unknown';\n+};"
        }
    ],
    "stats": {
        "total": 934,
        "additions": 474,
        "deletions": 460
    }
}