{
    "author": "atscott",
    "message": "refactor(compiler-cli): Return addEventListener symbol for native output bindings (#39312)\n\nRather than returning `null`, we can provide some useful information to the Language Service\nby returning a symbol for the `addEventListener` function call when the consumer\nof a binding as an element.\n\nPR Close #39312",
    "sha": "2f8a42036af8938296d6c331cd1fe0c814b9cc03",
    "files": [
        {
            "sha": "2cd6d2c746f173c86233f3e7619a305b0f1e5e87",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder.ts",
            "status": "modified",
            "additions": 55,
            "deletions": 29,
            "changes": 84,
            "blob_url": "https://github.com/angular/angular/blob/2f8a42036af8938296d6c331cd1fe0c814b9cc03/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "raw_url": "https://github.com/angular/angular/raw/2f8a42036af8938296d6c331cd1fe0c814b9cc03/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts?ref=2f8a42036af8938296d6c331cd1fe0c814b9cc03",
            "patch": "@@ -176,41 +176,67 @@ export class SymbolBuilder {\n     }\n \n     const consumer = this.templateData.boundTarget.getConsumerOfBinding(eventBinding);\n-    if (consumer === null || consumer instanceof TmplAstTemplate ||\n-        consumer instanceof TmplAstElement) {\n-      // Bindings to element or template events produce `addEventListener` which\n-      // we cannot get the field for.\n-      return null;\n-    }\n-    const outputFieldAccess = TcbDirectiveOutputsOp.decodeOutputCallExpression(node);\n-    if (outputFieldAccess === null) {\n+    if (consumer === null) {\n       return null;\n     }\n \n-    const tsSymbol =\n-        this.getTypeChecker().getSymbolAtLocation(outputFieldAccess.argumentExpression);\n-    if (tsSymbol === undefined) {\n-      return null;\n-    }\n+    if (consumer instanceof TmplAstTemplate || consumer instanceof TmplAstElement) {\n+      if (!ts.isPropertyAccessExpression(node.expression) ||\n+          node.expression.name.text !== 'addEventListener') {\n+        return null;\n+      }\n \n+      const addEventListener = node.expression.name;\n+      const tsSymbol = this.getTypeChecker().getSymbolAtLocation(addEventListener);\n+      const tsType = this.getTypeChecker().getTypeAtLocation(addEventListener);\n+      const positionInShimFile = this.getShimPositionForNode(addEventListener);\n+      const target = this.getSymbol(consumer);\n \n-    const target = this.getDirectiveSymbolForAccessExpression(outputFieldAccess, consumer);\n-    if (target === null) {\n-      return null;\n-    }\n+      if (target === null || tsSymbol === undefined) {\n+        return null;\n+      }\n \n-    const positionInShimFile = this.getShimPositionForNode(outputFieldAccess);\n-    const tsType = this.getTypeChecker().getTypeAtLocation(node);\n-    return {\n-      kind: SymbolKind.Output,\n-      bindings: [{\n-        kind: SymbolKind.Binding,\n-        tsSymbol,\n-        tsType,\n-        target,\n-        shimLocation: {shimPath: this.shimPath, positionInShimFile},\n-      }],\n-    };\n+      return {\n+        kind: SymbolKind.Output,\n+        bindings: [{\n+          kind: SymbolKind.Binding,\n+          tsSymbol,\n+          tsType,\n+          target,\n+          shimLocation: {shimPath: this.shimPath, positionInShimFile},\n+        }],\n+      };\n+    } else {\n+      const outputFieldAccess = TcbDirectiveOutputsOp.decodeOutputCallExpression(node);\n+      if (outputFieldAccess === null) {\n+        return null;\n+      }\n+\n+      const tsSymbol =\n+          this.getTypeChecker().getSymbolAtLocation(outputFieldAccess.argumentExpression);\n+      if (tsSymbol === undefined) {\n+        return null;\n+      }\n+\n+\n+      const target = this.getDirectiveSymbolForAccessExpression(outputFieldAccess, consumer);\n+      if (target === null) {\n+        return null;\n+      }\n+\n+      const positionInShimFile = this.getShimPositionForNode(outputFieldAccess);\n+      const tsType = this.getTypeChecker().getTypeAtLocation(node);\n+      return {\n+        kind: SymbolKind.Output,\n+        bindings: [{\n+          kind: SymbolKind.Binding,\n+          tsSymbol,\n+          tsType,\n+          target,\n+          shimLocation: {shimPath: this.shimPath, positionInShimFile},\n+        }],\n+      };\n+    }\n   }\n \n   private getSymbolOfInputBinding(binding: TmplAstBoundAttribute|"
        },
        {
            "sha": "d39489714ab04599827de499acc5b3af01bcc24b",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker__get_symbol_of_template_node_spec.ts",
            "status": "modified",
            "additions": 23,
            "deletions": 32,
            "changes": 55,
            "blob_url": "https://github.com/angular/angular/blob/2f8a42036af8938296d6c331cd1fe0c814b9cc03/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2f8a42036af8938296d6c331cd1fe0c814b9cc03/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts?ref=2f8a42036af8938296d6c331cd1fe0c814b9cc03",
            "patch": "@@ -1247,38 +1247,29 @@ runInEachFileSystem(() => {\n             .toEqual('TestDir');\n       });\n \n-      it('returns empty list when binding does not match any directive output', () => {\n-        const fileName = absoluteFrom('/main.ts');\n-        const dirFile = absoluteFrom('/dir.ts');\n-        const {program, templateTypeChecker} = setup([\n-          {\n-            fileName,\n-            templates: {'Cmp': `<div dir (doesNotExist)=\"handle($event)\"></div>`},\n-            declarations: [\n-              {\n-                name: 'TestDir',\n-                selector: '[dir]',\n-                file: dirFile,\n-                type: 'directive',\n-                outputs: {outputA: 'outputA'},\n-              },\n-            ]\n-          },\n-          {\n-            fileName: dirFile,\n-            source: `export class TestDir {outputA!: EventEmitter<string>;}`,\n-            templates: {},\n-          }\n-        ]);\n-        const sf = getSourceFileOrError(program, fileName);\n-        const cmp = getClass(sf, 'Cmp');\n-\n-        const nodes = templateTypeChecker.getTemplate(cmp)!;\n-\n-        const outputABinding = (nodes[0] as TmplAstElement).outputs[0];\n-        const symbol = templateTypeChecker.getSymbolOfNode(outputABinding, cmp);\n-        expect(symbol).toBeNull();\n-      });\n+      it('returns addEventListener binding to native element when no match to any directive output',\n+         () => {\n+           const fileName = absoluteFrom('/main.ts');\n+           const {program, templateTypeChecker} = setup([\n+             {\n+               fileName,\n+               templates: {'Cmp': `<div (click)=\"handle($event)\"></div>`},\n+             },\n+           ]);\n+           const sf = getSourceFileOrError(program, fileName);\n+           const cmp = getClass(sf, 'Cmp');\n+\n+           const nodes = templateTypeChecker.getTemplate(cmp)!;\n+\n+           const outputABinding = (nodes[0] as TmplAstElement).outputs[0];\n+           const symbol = templateTypeChecker.getSymbolOfNode(outputABinding, cmp)!;\n+           assertOutputBindingSymbol(symbol);\n+           expect(program.getTypeChecker().symbolToString(symbol.bindings[0].tsSymbol!))\n+               .toEqual('addEventListener');\n+\n+           const eventSymbol = templateTypeChecker.getSymbolOfNode(outputABinding.handler, cmp)!;\n+           assertExpressionSymbol(eventSymbol);\n+         });\n \n       it('returns empty list when checkTypeOfOutputEvents is false', () => {\n         const fileName = absoluteFrom('/main.ts');"
        },
        {
            "sha": "67a495341911e72fe95657087cd9380a949afd8b",
            "filename": "packages/language-service/ivy/test/legacy/definitions_spec.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/2f8a42036af8938296d6c331cd1fe0c814b9cc03/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fdefinitions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2f8a42036af8938296d6c331cd1fe0c814b9cc03/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fdefinitions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Fdefinitions_spec.ts?ref=2f8a42036af8938296d6c331cd1fe0c814b9cc03",
            "patch": "@@ -228,6 +228,18 @@ describe('definitions', () => {\n         expect(directiveDef.textSpan).toEqual('EventSelectorDirective');\n         expect(directiveDef.contextSpan).toContain('export class EventSelectorDirective');\n       });\n+\n+      it('should work for $event from native element', () => {\n+        const definitions = getDefinitionsAndAssertBoundSpan({\n+          templateOverride: `<div (cl¦ick)=\"myClick($event)\"></div>`,\n+          expectedSpanText: 'click',\n+        });\n+        expect(definitions!.length).toEqual(1);\n+        expect(definitions[0].textSpan).toEqual('addEventListener');\n+        expect(definitions[0].contextSpan)\n+            .toContain('addEventListener<K extends keyof HTMLElementEventMap>');\n+        expect(definitions[0].fileName).toContain('lib.dom.d.ts');\n+      });\n     });\n   });\n "
        },
        {
            "sha": "7b1c234469c043070bb8213eaabbce0ceb4d48ad",
            "filename": "packages/language-service/ivy/test/legacy/type_definitions_spec.ts",
            "status": "modified",
            "additions": 39,
            "deletions": 27,
            "changes": 66,
            "blob_url": "https://github.com/angular/angular/blob/2f8a42036af8938296d6c331cd1fe0c814b9cc03/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftype_definitions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2f8a42036af8938296d6c331cd1fe0c814b9cc03/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftype_definitions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftype_definitions_spec.ts?ref=2f8a42036af8938296d6c331cd1fe0c814b9cc03",
            "patch": "@@ -32,7 +32,7 @@ describe('type definitions', () => {\n \n   describe('elements', () => {\n     it('should work for native elements', () => {\n-      const defs = getTypeDefinitionsAndAssertBoundSpan({\n+      const defs = getTypeDefinitions({\n         templateOverride: `<butt¦on></button>`,\n       });\n       expect(defs.length).toEqual(2);\n@@ -42,7 +42,7 @@ describe('type definitions', () => {\n     });\n \n     it('should return directives which match the element tag', () => {\n-      const defs = getTypeDefinitionsAndAssertBoundSpan({\n+      const defs = getTypeDefinitions({\n         templateOverride: `<butt¦on compound custom-button></button>`,\n       });\n       expect(defs.length).toEqual(3);\n@@ -63,7 +63,7 @@ describe('type definitions', () => {\n \n   describe('directives', () => {\n     it('should work for directives', () => {\n-      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+      const definitions = getTypeDefinitions({\n         templateOverride: `<div string-model¦></div>`,\n       });\n       expect(definitions.length).toEqual(1);\n@@ -73,7 +73,7 @@ describe('type definitions', () => {\n     });\n \n     it('should work for components', () => {\n-      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+      const definitions = getTypeDefinitions({\n         templateOverride: `<t¦est-comp></test-comp>`,\n       });\n       expect(definitions.length).toEqual(1);\n@@ -82,7 +82,7 @@ describe('type definitions', () => {\n     });\n \n     it('should work for structural directives', () => {\n-      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+      const definitions = getTypeDefinitions({\n         templateOverride: `<div *¦ngFor=\"let item of heroes\"></div>`,\n       });\n       expect(definitions.length).toEqual(1);\n@@ -94,12 +94,12 @@ describe('type definitions', () => {\n     });\n \n     it('should work for directives with compound selectors', () => {\n-      let defs = getTypeDefinitionsAndAssertBoundSpan({\n+      let defs = getTypeDefinitions({\n         templateOverride: `<button com¦pound custom-button></button>`,\n       });\n       expect(defs.length).toEqual(1);\n       expect(defs[0].contextSpan).toContain('export class CompoundCustomButtonDirective');\n-      defs = getTypeDefinitionsAndAssertBoundSpan({\n+      defs = getTypeDefinitions({\n         templateOverride: `<button compound cu¦stom-button></button>`,\n       });\n       expect(defs.length).toEqual(1);\n@@ -110,15 +110,15 @@ describe('type definitions', () => {\n   describe('bindings', () => {\n     describe('inputs', () => {\n       it('should return something for input providers with non-primitive types', () => {\n-        const defs = getTypeDefinitionsAndAssertBoundSpan({\n+        const defs = getTypeDefinitions({\n           templateOverride: `<button compound custom-button [config¦]=\"{}\"></button>`,\n         });\n         expect(defs.length).toEqual(1);\n         expect(defs[0].textSpan).toEqual('{color?: string}');\n       });\n \n       it('should work for structural directive inputs ngForTrackBy', () => {\n-        const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+        const definitions = getTypeDefinitions({\n           templateOverride: `<div *ngFor=\"let item of heroes; tr¦ackBy: test;\"></div>`,\n         });\n         expect(definitions!.length).toEqual(1);\n@@ -129,7 +129,7 @@ describe('type definitions', () => {\n       });\n \n       it('should work for structural directive inputs ngForOf', () => {\n-        const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+        const definitions = getTypeDefinitions({\n           templateOverride: `<div *ngFor=\"let item o¦f heroes\"></div>`,\n         });\n         // In addition to all the array defs, this will also return the NgForOf def because the\n@@ -140,7 +140,7 @@ describe('type definitions', () => {\n       });\n \n       it('should return nothing for two-way binding providers', () => {\n-        const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+        const definitions = getTypeDefinitions({\n           templateOverride: `<test-comp string-model [(mo¦del)]=\"title\"></test-comp>`,\n         });\n         // TODO(atscott): This should actually return EventEmitter type but we only match the input\n@@ -151,7 +151,7 @@ describe('type definitions', () => {\n \n     describe('outputs', () => {\n       it('should work for event providers', () => {\n-        const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+        const definitions = getTypeDefinitions({\n           templateOverride: `<test-comp (te¦st)=\"myClick($event)\"></test-comp>`,\n         });\n         expect(definitions!.length).toEqual(2);\n@@ -167,7 +167,7 @@ describe('type definitions', () => {\n       });\n \n       it('should return the directive when the event is part of the selector', () => {\n-        const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+        const definitions = getTypeDefinitions({\n           templateOverride: `<div (eventSelect¦or)=\"title = ''\"></div>`,\n         });\n         expect(definitions!.length).toEqual(3);\n@@ -176,12 +176,24 @@ describe('type definitions', () => {\n         const directiveDef = definitions[2];\n         expect(directiveDef.contextSpan).toContain('export class EventSelectorDirective');\n       });\n+\n+      it('should work for native event outputs', () => {\n+        const definitions = getTypeDefinitions({\n+          templateOverride: `<div (cl¦ick)=\"myClick($event)\"></div>`,\n+        });\n+        expect(definitions!.length).toEqual(1);\n+        expect(definitions[0].textSpan).toEqual('addEventListener');\n+        expect(definitions[0].contextSpan)\n+            .toEqual(\n+                'addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;');\n+        expect(definitions[0].fileName).toContain('lib.dom.d.ts');\n+      });\n     });\n   });\n \n   describe('references', () => {\n     it('should work for element references', () => {\n-      const defs = getTypeDefinitionsAndAssertBoundSpan({\n+      const defs = getTypeDefinitions({\n         templateOverride: `<div #chart></div>{{char¦t}}`,\n       });\n       expect(defs.length).toEqual(2);\n@@ -190,7 +202,7 @@ describe('type definitions', () => {\n     });\n \n     it('should work for directive references', () => {\n-      const defs = getTypeDefinitionsAndAssertBoundSpan({\n+      const defs = getTypeDefinitions({\n         templateOverride: `<div #mod¦el=\"stringModel\" string-model></div>`,\n       });\n       expect(defs.length).toEqual(1);\n@@ -201,7 +213,7 @@ describe('type definitions', () => {\n \n   describe('variables', () => {\n     it('should work for array members', () => {\n-      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+      const definitions = getTypeDefinitions({\n         templateOverride: `<div *ngFor=\"let hero of heroes\">{{her¦o}}</div>`,\n       });\n       expect(definitions!.length).toEqual(1);\n@@ -214,7 +226,7 @@ describe('type definitions', () => {\n   describe('pipes', () => {\n     it('should work for pipes', () => {\n       const templateOverride = `<p>The hero's birthday is {{birthday | da¦te: \"MM/dd/yy\"}}</p>`;\n-      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+      const definitions = getTypeDefinitions({\n         templateOverride,\n       });\n       expect(definitions!.length).toEqual(1);\n@@ -227,7 +239,7 @@ describe('type definitions', () => {\n \n   describe('expressions', () => {\n     it('should return nothing for primitives', () => {\n-      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+      const definitions = getTypeDefinitions({\n         templateOverride: `<div>{{ tit¦le }}</div>`,\n       });\n       expect(definitions!.length).toEqual(0);\n@@ -236,7 +248,7 @@ describe('type definitions', () => {\n     // TODO(atscott): Investigate why this returns nothing in the test environment. This actually\n     // works in the extension.\n     xit('should work for functions on primitives', () => {\n-      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+      const definitions = getTypeDefinitions({\n         templateOverride: `<div>{{ title.toLower¦case() }}</div>`,\n       });\n       expect(definitions!.length).toEqual(1);\n@@ -245,7 +257,7 @@ describe('type definitions', () => {\n     });\n \n     it('should work for accessed property reads', () => {\n-      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+      const definitions = getTypeDefinitions({\n         templateOverride: `<div>{{heroes[0].addre¦ss}}</div>`,\n       });\n       expect(definitions!.length).toEqual(1);\n@@ -256,7 +268,7 @@ describe('type definitions', () => {\n     });\n \n     it('should work for $event', () => {\n-      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+      const definitions = getTypeDefinitions({\n         templateOverride: `<button (click)=\"title=$ev¦ent\"></button>`,\n       });\n       expect(definitions!.length).toEqual(2);\n@@ -269,7 +281,7 @@ describe('type definitions', () => {\n     });\n \n     it('should work for method calls', () => {\n-      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+      const definitions = getTypeDefinitions({\n         templateOverride: `<div (click)=\"setT¦itle('title')\"></div>`,\n       });\n       expect(definitions!.length).toEqual(1);\n@@ -280,7 +292,7 @@ describe('type definitions', () => {\n     });\n \n     it('should work for accessed properties in writes', () => {\n-      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+      const definitions = getTypeDefinitions({\n         templateOverride: `<div (click)=\"hero.add¦ress = undefined\"></div>`,\n       });\n       expect(definitions!.length).toEqual(1);\n@@ -291,21 +303,21 @@ describe('type definitions', () => {\n     });\n \n     it('should work for variables in structural directives', () => {\n-      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+      const definitions = getTypeDefinitions({\n         templateOverride: `<div *ngFor=\"let item of heroes as her¦oes2; trackBy: test;\"></div>`,\n       });\n       expectAllDefinitions(definitions, new Set(['Array']), possibleArrayDefFiles);\n     });\n \n     it('should work for uses of members in structural directives', () => {\n-      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+      const definitions = getTypeDefinitions({\n         templateOverride: `<div *ngFor=\"let item of heroes as heroes2\">{{her¦oes2}}</div>`,\n       });\n       expectAllDefinitions(definitions, new Set(['Array']), possibleArrayDefFiles);\n     });\n \n     it('should work for members in structural directives', () => {\n-      const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+      const definitions = getTypeDefinitions({\n         templateOverride: `<div *ngFor=\"let item of her¦oes; trackBy: test;\"></div>`,\n       });\n       expectAllDefinitions(definitions, new Set(['Array']), possibleArrayDefFiles);\n@@ -319,7 +331,7 @@ describe('type definitions', () => {\n     });\n   });\n \n-  function getTypeDefinitionsAndAssertBoundSpan({templateOverride}: {templateOverride: string}):\n+  function getTypeDefinitions({templateOverride}: {templateOverride: string}):\n       HumanizedDefinitionInfo[] {\n     const {position} = service.overwriteInlineTemplate(APP_COMPONENT, templateOverride);\n     const defs = ngLS.getTypeDefinitionAtPosition(APP_COMPONENT, position);"
        },
        {
            "sha": "0a863ecd09b8a8a6c939e7a436d9eca885b02349",
            "filename": "packages/language-service/ivy/test/quick_info_spec.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/2f8a42036af8938296d6c331cd1fe0c814b9cc03/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2f8a42036af8938296d6c331cd1fe0c814b9cc03/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts?ref=2f8a42036af8938296d6c331cd1fe0c814b9cc03",
            "patch": "@@ -309,6 +309,25 @@ describe('quick info', () => {\n           expectedDisplayString: '(reference) chart: HTMLDivElement'\n         });\n       });\n+\n+      it('should work for $event from native element', () => {\n+        expectQuickInfo({\n+          templateOverride: `<div (click)=\"myClick($e¦vent)\"></div>`,\n+          expectedSpanText: '$event',\n+          expectedDisplayString: '(parameter) $event: MouseEvent'\n+        });\n+      });\n+\n+      it('should work for click output from native element', () => {\n+        expectQuickInfo({\n+          templateOverride: `<div (cl¦ick)=\"myClick($event)\"></div>`,\n+          expectedSpanText: 'click',\n+          expectedDisplayString:\n+              '(event) HTMLDivElement.addEventListener<\"click\">(type: \"click\", ' +\n+              'listener: (this: HTMLDivElement, ev: MouseEvent) => any, ' +\n+              'options?: boolean | AddEventListenerOptions | undefined): void (+1 overload)'\n+        });\n+      });\n     });\n \n     describe('variables', () => {"
        }
    ],
    "stats": {
        "total": 236,
        "additions": 148,
        "deletions": 88
    }
}