{
    "author": "JoostK",
    "message": "perf(compiler-cli): detect semantic changes and their effect on an incremental rebuild (#40947)\n\nIn Angular programs, changing a file may require other files to be\nemitted as well due to implicit NgModule dependencies. For example, if\nthe selector of a directive is changed then all components that have\nthat directive in their compilation scope need to be recompiled, as the\nchange of selector may affect the directive matching results.\n\nUntil now, the compiler solved this problem using a single dependency\ngraph. The implicit NgModule dependencies were represented in this\ngraph, such that a changed file would correctly also cause other files\nto be re-emitted. This approach is limited in a few ways:\n\n1. The file dependency graph is used to determine whether it is safe to\n   reuse the analysis data of an Angular decorated class. This analysis\n   data is invariant to unrelated changes to the NgModule scope, but\n   because the single dependency graph also tracked the implicit\n   NgModule dependencies the compiler had to consider analysis data as\n   stale far more often than necessary.\n2. It is typical for a change to e.g. a directive to not affect its\n   public API—its selector, inputs, outputs, or exportAs clause—in which\n   case there is no need to re-emit all declarations in scope, as their\n   compilation output wouldn't have changed.\n\nThis commit implements a mechanism by which the compiler is able to\ndetermine the impact of a change by comparing it to the prior\ncompilation. To achieve this, a new graph is maintained that tracks all\npublic API information of all Angular decorated symbols. During an\nincremental compilation this information is compared to the information\nthat was captured in the most recently succeeded compilation. This\ndetermines the exact impact of the changes to the public API, which\nis then used to determine which files need to be re-emitted.\n\nNote that the file dependency graph remains, as it is still used to\ntrack the dependencies of analysis data. This graph does no longer track\nthe implicit NgModule dependencies, which allows for better reuse of\nanalysis data.\n\nThese changes also fix a bug where template type-checking would fail to\nincorporate changes made to a transitive base class of a\ndirective/component. This used to be a problem because transitive base\nclasses were not recorded as a transitive dependency in the file\ndependency graph, such that prior type-check blocks would erroneously\nbe reused.\n\nThis commit also fixes an incorrectness where a change to a declaration\nin NgModule `A` would not cause the declarations in NgModules that\nimport from NgModule `A` to be re-emitted. This was intentionally\nincorrect as otherwise the performance of incremental rebuilds would\nhave been far worse. This is no longer a concern, as the compiler is now\nable to only re-emit when actually necessary.\n\nFixes #34867\nFixes #40635\nCloses #40728\n\nPR Close #40947",
    "sha": "fed6a7ce7dca054408540f80dbc7bc3200c8f371",
    "files": [
        {
            "sha": "6502721b914e1aa37d11bd9223ccb786969ab66e",
            "filename": "packages/compiler-cli/ngcc/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fngcc%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fngcc%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2FBUILD.bazel?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -19,6 +19,7 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/file_system\",\n         \"//packages/compiler-cli/src/ngtsc/imports\",\n         \"//packages/compiler-cli/src/ngtsc/incremental:api\",\n+        \"//packages/compiler-cli/src/ngtsc/incremental/semantic_graph\",\n         \"//packages/compiler-cli/src/ngtsc/logging\",\n         \"//packages/compiler-cli/src/ngtsc/metadata\",\n         \"//packages/compiler-cli/src/ngtsc/partial_evaluator\","
        },
        {
            "sha": "dd35ddc332bf667bd3fc53faf4493137dd92cf43",
            "filename": "packages/compiler-cli/ngcc/src/analysis/decoration_analyzer.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 3,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fdecoration_analyzer.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fdecoration_analyzer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fdecoration_analyzer.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -14,6 +14,7 @@ import {CycleAnalyzer, CycleHandlingStrategy, ImportGraph} from '../../../src/ng\n import {isFatalDiagnosticError} from '../../../src/ngtsc/diagnostics';\n import {absoluteFromSourceFile, LogicalFileSystem, ReadonlyFileSystem} from '../../../src/ngtsc/file_system';\n import {AbsoluteModuleStrategy, LocalIdentifierStrategy, LogicalProjectStrategy, ModuleResolver, NOOP_DEFAULT_IMPORT_RECORDER, PrivateExportAliasingHost, Reexport, ReferenceEmitter} from '../../../src/ngtsc/imports';\n+import {SemanticSymbol} from '../../../src/ngtsc/incremental/semantic_graph';\n import {CompoundMetadataReader, CompoundMetadataRegistry, DtsMetadataReader, InjectableClassRegistry, LocalMetadataRegistry, ResourceRegistry} from '../../../src/ngtsc/metadata';\n import {PartialEvaluator} from '../../../src/ngtsc/partial_evaluator';\n import {LocalModuleScopeRegistry, MetadataDtsModuleScopeResolver, TypeCheckScopeRegistry} from '../../../src/ngtsc/scope';\n@@ -92,7 +93,7 @@ export class DecorationAnalyzer {\n   cycleAnalyzer = new CycleAnalyzer(this.importGraph);\n   injectableRegistry = new InjectableClassRegistry(this.reflectionHost);\n   typeCheckScopeRegistry = new TypeCheckScopeRegistry(this.scopeRegistry, this.fullMetaReader);\n-  handlers: DecoratorHandler<unknown, unknown, unknown>[] = [\n+  handlers: DecoratorHandler<unknown, unknown, SemanticSymbol|null, unknown>[] = [\n     new ComponentDecoratorHandler(\n         this.reflectionHost, this.evaluator, this.fullRegistry, this.fullMetaReader,\n         this.scopeRegistry, this.scopeRegistry, this.typeCheckScopeRegistry, new ResourceRegistry(),\n@@ -103,19 +104,21 @@ export class DecorationAnalyzer {\n         /* i18nNormalizeLineEndingsInICUs */ false, this.moduleResolver, this.cycleAnalyzer,\n         CycleHandlingStrategy.UseRemoteScoping, this.refEmitter, NOOP_DEFAULT_IMPORT_RECORDER,\n         NOOP_DEPENDENCY_TRACKER, this.injectableRegistry,\n-        !!this.compilerOptions.annotateForClosureCompiler),\n+        /* semanticDepGraphUpdater */ null, !!this.compilerOptions.annotateForClosureCompiler),\n+\n     // See the note in ngtsc about why this cast is needed.\n     // clang-format off\n     new DirectiveDecoratorHandler(\n         this.reflectionHost, this.evaluator, this.fullRegistry, this.scopeRegistry,\n         this.fullMetaReader, NOOP_DEFAULT_IMPORT_RECORDER, this.injectableRegistry, this.isCore,\n+        /* semanticDepGraphUpdater */ null,\n         !!this.compilerOptions.annotateForClosureCompiler,\n         // In ngcc we want to compile undecorated classes with Angular features. As of\n         // version 10, undecorated classes that use Angular features are no longer handled\n         // in ngtsc, but we want to ensure compatibility in ngcc for outdated libraries that\n         // have not migrated to explicit decorators. See: https://hackmd.io/@alx/ryfYYuvzH.\n         /* compileUndecoratedClassesWithAngularFeatures */ true\n-    ) as DecoratorHandler<unknown, unknown, unknown>,\n+    ) as DecoratorHandler<unknown, unknown, SemanticSymbol|null,unknown>,\n     // clang-format on\n     // Pipe handler must be before injectable handler in list so pipe factories are printed\n     // before injectable factories (so injectable factories can delegate to them)"
        },
        {
            "sha": "e5dde6cbf5c4e68adcc59539a68be27a2ff1e527",
            "filename": "packages/compiler-cli/ngcc/src/analysis/ngcc_trait_compiler.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fngcc_trait_compiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fngcc_trait_compiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fngcc_trait_compiler.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -8,6 +8,7 @@\n import * as ts from 'typescript';\n \n import {IncrementalBuild} from '../../../src/ngtsc/incremental/api';\n+import {SemanticSymbol} from '../../../src/ngtsc/incremental/semantic_graph';\n import {NOOP_PERF_RECORDER} from '../../../src/ngtsc/perf';\n import {ClassDeclaration, Decorator} from '../../../src/ngtsc/reflection';\n import {CompilationMode, DecoratorHandler, DtsTransformRegistry, HandlerFlags, Trait, TraitCompiler} from '../../../src/ngtsc/transform';\n@@ -22,11 +23,12 @@ import {isDefined} from '../utils';\n  */\n export class NgccTraitCompiler extends TraitCompiler {\n   constructor(\n-      handlers: DecoratorHandler<unknown, unknown, unknown>[],\n+      handlers: DecoratorHandler<unknown, unknown, SemanticSymbol|null, unknown>[],\n       private ngccReflector: NgccReflectionHost) {\n     super(\n         handlers, ngccReflector, NOOP_PERF_RECORDER, new NoIncrementalBuild(),\n-        /* compileNonExportedClasses */ true, CompilationMode.FULL, new DtsTransformRegistry());\n+        /* compileNonExportedClasses */ true, CompilationMode.FULL, new DtsTransformRegistry(),\n+        /* semanticDepGraphUpdater */ null);\n   }\n \n   get analyzedFiles(): ts.SourceFile[] {\n@@ -54,7 +56,7 @@ export class NgccTraitCompiler extends TraitCompiler {\n    * @param flags optional bitwise flag to influence the compilation of the decorator.\n    */\n   injectSyntheticDecorator(clazz: ClassDeclaration, decorator: Decorator, flags?: HandlerFlags):\n-      Trait<unknown, unknown, unknown>[] {\n+      Trait<unknown, unknown, SemanticSymbol|null, unknown>[] {\n     const migratedTraits = this.detectTraits(clazz, [decorator]);\n     if (migratedTraits === null) {\n       return [];"
        },
        {
            "sha": "f5f5ee6e152a7a37600d78dcc5bbee646b1d13b9",
            "filename": "packages/compiler-cli/ngcc/src/analysis/util.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Futil.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -16,8 +16,6 @@ export function isWithinPackage(packagePath: AbsoluteFsPath, filePath: AbsoluteF\n class NoopDependencyTracker implements DependencyTracker {\n   addDependency(): void {}\n   addResourceDependency(): void {}\n-  addTransitiveDependency(): void {}\n-  addTransitiveResources(): void {}\n   recordDependencyAnalysisFailure(): void {}\n }\n "
        },
        {
            "sha": "0aa28599ace708ce9ec01bda1fb1003cd55ee60d",
            "filename": "packages/compiler-cli/ngcc/test/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fngcc%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fngcc%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2FBUILD.bazel?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -19,6 +19,7 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/file_system\",\n         \"//packages/compiler-cli/src/ngtsc/file_system/testing\",\n         \"//packages/compiler-cli/src/ngtsc/imports\",\n+        \"//packages/compiler-cli/src/ngtsc/incremental/semantic_graph\",\n         \"//packages/compiler-cli/src/ngtsc/logging/testing\",\n         \"//packages/compiler-cli/src/ngtsc/partial_evaluator\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\","
        },
        {
            "sha": "f390fa19abeb8a7dd617737914703996107e469f",
            "filename": "packages/compiler-cli/ngcc/test/analysis/decoration_analyzer_spec.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 3,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fanalysis%2Fdecoration_analyzer_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fanalysis%2Fdecoration_analyzer_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fanalysis%2Fdecoration_analyzer_spec.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -10,6 +10,7 @@ import * as ts from 'typescript';\n import {FatalDiagnosticError, makeDiagnostic} from '../../../src/ngtsc/diagnostics';\n import {absoluteFrom, getFileSystem, getSourceFileOrError} from '../../../src/ngtsc/file_system';\n import {runInEachFileSystem, TestFile} from '../../../src/ngtsc/file_system/testing';\n+import {SemanticSymbol} from '../../../src/ngtsc/incremental/semantic_graph';\n import {MockLogger} from '../../../src/ngtsc/logging/testing';\n import {ClassDeclaration, DeclarationNode, Decorator} from '../../../src/ngtsc/reflection';\n import {loadFakeCore, loadTestFiles} from '../../../src/ngtsc/testing';\n@@ -21,8 +22,9 @@ import {Esm2015ReflectionHost} from '../../src/host/esm2015_host';\n import {Migration, MigrationHost} from '../../src/migrations/migration';\n import {getRootFiles, makeTestEntryPointBundle} from '../helpers/utils';\n \n-type DecoratorHandlerWithResolve = DecoratorHandler<unknown, unknown, unknown>&{\n-  resolve: NonNullable<DecoratorHandler<unknown, unknown, unknown>['resolve']>;\n+type DecoratorHandlerWithResolve =\n+    DecoratorHandler<unknown, unknown, SemanticSymbol|null, unknown>&{\n+  resolve: NonNullable<DecoratorHandler<unknown, unknown, SemanticSymbol|null, unknown>['resolve']>;\n };\n \n runInEachFileSystem(() => {\n@@ -46,6 +48,7 @@ runInEachFileSystem(() => {\n         const handler = jasmine.createSpyObj<DecoratorHandlerWithResolve>('TestDecoratorHandler', [\n           'detect',\n           'analyze',\n+          'symbol',\n           'register',\n           'resolve',\n           'compileFull',\n@@ -442,7 +445,7 @@ runInEachFileSystem(() => {\n \n       describe('declaration files', () => {\n         it('should not run decorator handlers against declaration files', () => {\n-          class FakeDecoratorHandler implements DecoratorHandler<{}|null, unknown, unknown> {\n+          class FakeDecoratorHandler implements DecoratorHandler<{}|null, unknown, null, unknown> {\n             name = 'FakeDecoratorHandler';\n             precedence = HandlerPrecedence.PRIMARY;\n \n@@ -452,6 +455,9 @@ runInEachFileSystem(() => {\n             analyze(): AnalysisOutput<unknown> {\n               throw new Error('analyze should not have been called');\n             }\n+            symbol(): null {\n+              throw new Error('symbol should not have been called');\n+            }\n             compileFull(): CompileResult {\n               throw new Error('compile should not have been called');\n             }"
        },
        {
            "sha": "2e9cd992c251fe9efaed6fe466c58229be721d72",
            "filename": "packages/compiler-cli/ngcc/test/analysis/migration_host_spec.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 3,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fanalysis%2Fmigration_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fanalysis%2Fmigration_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fanalysis%2Fmigration_host_spec.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -11,6 +11,7 @@ import * as ts from 'typescript';\n import {makeDiagnostic} from '../../../src/ngtsc/diagnostics';\n import {absoluteFrom} from '../../../src/ngtsc/file_system';\n import {runInEachFileSystem} from '../../../src/ngtsc/file_system/testing';\n+import {SemanticSymbol} from '../../../src/ngtsc/incremental/semantic_graph';\n import {MockLogger} from '../../../src/ngtsc/logging/testing';\n import {ClassDeclaration, Decorator, isNamedClassDeclaration} from '../../../src/ngtsc/reflection';\n import {getDeclaration, loadTestFiles} from '../../../src/ngtsc/testing';\n@@ -44,7 +45,8 @@ runInEachFileSystem(() => {\n     });\n \n     function createMigrationHost({entryPoint, handlers}: {\n-      entryPoint: EntryPointBundle; handlers: DecoratorHandler<unknown, unknown, unknown>[]\n+      entryPoint: EntryPointBundle;\n+      handlers: DecoratorHandler<unknown, unknown, SemanticSymbol|null, unknown>[]\n     }) {\n       const reflectionHost = new Esm2015ReflectionHost(new MockLogger(), false, entryPoint.src);\n       const compiler = new NgccTraitCompiler(handlers, reflectionHost);\n@@ -190,7 +192,7 @@ runInEachFileSystem(() => {\n   });\n });\n \n-class DetectDecoratorHandler implements DecoratorHandler<unknown, unknown, unknown> {\n+class DetectDecoratorHandler implements DecoratorHandler<unknown, unknown, null, unknown> {\n   readonly name = DetectDecoratorHandler.name;\n \n   constructor(private decorator: string, readonly precedence: HandlerPrecedence) {}\n@@ -210,12 +212,16 @@ class DetectDecoratorHandler implements DecoratorHandler<unknown, unknown, unkno\n     return {};\n   }\n \n+  symbol(node: ClassDeclaration, analysis: Readonly<unknown>): null {\n+    return null;\n+  }\n+\n   compileFull(node: ClassDeclaration): CompileResult|CompileResult[] {\n     return [];\n   }\n }\n \n-class DiagnosticProducingHandler implements DecoratorHandler<unknown, unknown, unknown> {\n+class DiagnosticProducingHandler implements DecoratorHandler<unknown, unknown, null, unknown> {\n   readonly name = DiagnosticProducingHandler.name;\n   readonly precedence = HandlerPrecedence.PRIMARY;\n \n@@ -228,6 +234,10 @@ class DiagnosticProducingHandler implements DecoratorHandler<unknown, unknown, u\n     return {diagnostics: [makeDiagnostic(9999, node, 'test diagnostic')]};\n   }\n \n+  symbol(node: ClassDeclaration, analysis: Readonly<unknown>): null {\n+    return null;\n+  }\n+\n   compileFull(node: ClassDeclaration): CompileResult|CompileResult[] {\n     return [];\n   }"
        },
        {
            "sha": "2cd0ddd0c6ad07c63636cd77e01665d48f7b827a",
            "filename": "packages/compiler-cli/ngcc/test/analysis/ngcc_trait_compiler_spec.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 2,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fanalysis%2Fngcc_trait_compiler_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fanalysis%2Fngcc_trait_compiler_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fanalysis%2Fngcc_trait_compiler_spec.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -9,6 +9,7 @@\n import {ErrorCode, makeDiagnostic, ngErrorCode} from '../../../src/ngtsc/diagnostics';\n import {absoluteFrom} from '../../../src/ngtsc/file_system';\n import {runInEachFileSystem} from '../../../src/ngtsc/file_system/testing';\n+import {SemanticSymbol} from '../../../src/ngtsc/incremental/semantic_graph';\n import {MockLogger} from '../../../src/ngtsc/logging/testing';\n import {ClassDeclaration, Decorator, isNamedClassDeclaration} from '../../../src/ngtsc/reflection';\n import {getDeclaration, loadTestFiles} from '../../../src/ngtsc/testing';\n@@ -39,7 +40,8 @@ runInEachFileSystem(() => {\n     });\n \n     function createCompiler({entryPoint, handlers}: {\n-      entryPoint: EntryPointBundle; handlers: DecoratorHandler<unknown, unknown, unknown>[]\n+      entryPoint: EntryPointBundle;\n+      handlers: DecoratorHandler<unknown, unknown, SemanticSymbol|null, unknown>[]\n     }) {\n       const reflectionHost = new Esm2015ReflectionHost(new MockLogger(), false, entryPoint.src);\n       return new NgccTraitCompiler(handlers, reflectionHost);\n@@ -295,7 +297,7 @@ runInEachFileSystem(() => {\n   });\n });\n \n-class TestHandler implements DecoratorHandler<unknown, unknown, unknown> {\n+class TestHandler implements DecoratorHandler<unknown, unknown, null, unknown> {\n   constructor(readonly name: string, protected log: string[]) {}\n \n   precedence = HandlerPrecedence.PRIMARY;\n@@ -310,6 +312,10 @@ class TestHandler implements DecoratorHandler<unknown, unknown, unknown> {\n     return {};\n   }\n \n+  symbol(node: ClassDeclaration, analysis: Readonly<unknown>): null {\n+    return null;\n+  }\n+\n   compileFull(node: ClassDeclaration): CompileResult|CompileResult[] {\n     this.log.push(this.name + ':compile:' + node.name.text);\n     return [];"
        },
        {
            "sha": "4fc662a552290ec342709670972519dad8e91d4d",
            "filename": "packages/compiler-cli/ngcc/test/host/util.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Futil.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -7,6 +7,8 @@\n  */\n import {Trait, TraitState} from '@angular/compiler-cli/src/ngtsc/transform';\n import * as ts from 'typescript';\n+\n+import {SemanticSymbol} from '../../../src/ngtsc/incremental/semantic_graph';\n import {CtorParameter, TypeValueReferenceKind} from '../../../src/ngtsc/reflection';\n \n /**\n@@ -50,7 +52,8 @@ export function expectTypeValueReferencesForParameters(\n   });\n }\n \n-export function getTraitDiagnostics(trait: Trait<unknown, unknown, unknown>): ts.Diagnostic[]|null {\n+export function getTraitDiagnostics(trait: Trait<unknown, unknown, SemanticSymbol|null, unknown>):\n+    ts.Diagnostic[]|null {\n   if (trait.state === TraitState.Analyzed) {\n     return trait.analysisDiagnostics;\n   } else if (trait.state === TraitState.Resolved) {"
        },
        {
            "sha": "002755aad5f7f65a3aa97aee372a9554d65483a7",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2FBUILD.bazel?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -14,6 +14,7 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/file_system\",\n         \"//packages/compiler-cli/src/ngtsc/imports\",\n         \"//packages/compiler-cli/src/ngtsc/incremental:api\",\n+        \"//packages/compiler-cli/src/ngtsc/incremental/semantic_graph\",\n         \"//packages/compiler-cli/src/ngtsc/indexer\",\n         \"//packages/compiler-cli/src/ngtsc/metadata\",\n         \"//packages/compiler-cli/src/ngtsc/partial_evaluator\","
        },
        {
            "sha": "0f31c76a52ef116d8698cc5c565668cbdad275a8",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/component.ts",
            "status": "modified",
            "additions": 120,
            "deletions": 8,
            "changes": 128,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -14,6 +14,7 @@ import {ErrorCode, FatalDiagnosticError, makeDiagnostic, makeRelatedInformation}\n import {absoluteFrom, relative} from '../../file_system';\n import {DefaultImportRecorder, ModuleResolver, Reference, ReferenceEmitter} from '../../imports';\n import {DependencyTracker} from '../../incremental/api';\n+import {extractSemanticTypeParameters, isArrayEqual, isReferenceEqual, SemanticDepGraphUpdater, SemanticReference, SemanticSymbol} from '../../incremental/semantic_graph';\n import {IndexingContext} from '../../indexer';\n import {ClassPropertyMapping, ComponentResources, DirectiveMeta, DirectiveTypeCheckMeta, extractDirectiveTypeCheckMeta, InjectableClassRegistry, MetadataReader, MetadataRegistry, Resource, ResourceRegistry} from '../../metadata';\n import {EnumValue, PartialEvaluator, ResolvedValue} from '../../partial_evaluator';\n@@ -26,9 +27,10 @@ import {SubsetOfKeys} from '../../util/src/typescript';\n \n import {ResourceLoader} from './api';\n import {createValueHasWrongTypeError, getDirectiveDiagnostics, getProviderDiagnostics} from './diagnostics';\n-import {extractDirectiveMetadata, parseFieldArrayValue} from './directive';\n+import {DirectiveSymbol, extractDirectiveMetadata, parseFieldArrayValue} from './directive';\n import {compileNgFactoryDefField} from './factory';\n import {generateSetClassMetadataCall} from './metadata';\n+import {NgModuleSymbol} from './ng_module';\n import {findAngularDecorator, isAngularCoreReference, isExpressionForwardReference, readBaseClass, resolveProvidersRequiringFactory, unwrapExpression, wrapFunctionExpressionsInParens} from './util';\n \n const EMPTY_MAP = new Map<string, Expression>();\n@@ -111,11 +113,85 @@ export const enum ResourceTypeForDiagnostics {\n   StylesheetFromDecorator,\n }\n \n+/**\n+ * Represents an Angular component.\n+ */\n+export class ComponentSymbol extends DirectiveSymbol {\n+  usedDirectives: SemanticReference[] = [];\n+  usedPipes: SemanticReference[] = [];\n+  isRemotelyScoped = false;\n+\n+  isEmitAffected(previousSymbol: SemanticSymbol, publicApiAffected: Set<SemanticSymbol>): boolean {\n+    if (!(previousSymbol instanceof ComponentSymbol)) {\n+      return true;\n+    }\n+\n+    // Create an equality function that considers symbols equal if they represent the same\n+    // declaration, but only if the symbol in the current compilation does not have its public API\n+    // affected.\n+    const isSymbolUnaffected = (current: SemanticReference, previous: SemanticReference) =>\n+        isReferenceEqual(current, previous) && !publicApiAffected.has(current.symbol);\n+\n+    // The emit of a component is affected if either of the following is true:\n+    //  1. The component used to be remotely scoped but no longer is, or vice versa.\n+    //  2. The list of used directives has changed or any of those directives have had their public\n+    //     API changed. If the used directives have been reordered but not otherwise affected then\n+    //     the component must still be re-emitted, as this may affect directive instantiation order.\n+    //  3. The list of used pipes has changed, or any of those pipes have had their public API\n+    //     changed.\n+    return this.isRemotelyScoped !== previousSymbol.isRemotelyScoped ||\n+        !isArrayEqual(this.usedDirectives, previousSymbol.usedDirectives, isSymbolUnaffected) ||\n+        !isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isSymbolUnaffected);\n+  }\n+\n+  isTypeCheckBlockAffected(\n+      previousSymbol: SemanticSymbol, typeCheckApiAffected: Set<SemanticSymbol>): boolean {\n+    if (!(previousSymbol instanceof ComponentSymbol)) {\n+      return true;\n+    }\n+\n+    // To verify that a used directive is not affected we need to verify that its full inheritance\n+    // chain is not present in `typeCheckApiAffected`.\n+    const isInheritanceChainAffected = (symbol: SemanticSymbol): boolean => {\n+      let currentSymbol: SemanticSymbol|null = symbol;\n+      while (currentSymbol instanceof DirectiveSymbol) {\n+        if (typeCheckApiAffected.has(currentSymbol)) {\n+          return true;\n+        }\n+        currentSymbol = currentSymbol.baseClass;\n+      }\n+\n+      return false;\n+    };\n+\n+    // Create an equality function that considers directives equal if they represent the same\n+    // declaration and if the symbol and all symbols it inherits from in the current compilation\n+    // do not have their type-check API affected.\n+    const isDirectiveUnaffected = (current: SemanticReference, previous: SemanticReference) =>\n+        isReferenceEqual(current, previous) && !isInheritanceChainAffected(current.symbol);\n+\n+    // Create an equality function that considers pipes equal if they represent the same\n+    // declaration and if the symbol in the current compilation does not have its type-check\n+    // API affected.\n+    const isPipeUnaffected = (current: SemanticReference, previous: SemanticReference) =>\n+        isReferenceEqual(current, previous) && !typeCheckApiAffected.has(current.symbol);\n+\n+    // The emit of a type-check block of a component is affected if either of the following is true:\n+    //  1. The list of used directives has changed or any of those directives have had their\n+    //     type-check API changed.\n+    //  2. The list of used pipes has changed, or any of those pipes have had their type-check API\n+    //     changed.\n+    return !isArrayEqual(\n+               this.usedDirectives, previousSymbol.usedDirectives, isDirectiveUnaffected) ||\n+        !isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isPipeUnaffected);\n+  }\n+}\n+\n /**\n  * `DecoratorHandler` which handles the `@Component` annotation.\n  */\n export class ComponentDecoratorHandler implements\n-    DecoratorHandler<Decorator, ComponentAnalysisData, ComponentResolutionData> {\n+    DecoratorHandler<Decorator, ComponentAnalysisData, ComponentSymbol, ComponentResolutionData> {\n   constructor(\n       private reflector: ReflectionHost, private evaluator: PartialEvaluator,\n       private metaRegistry: MetadataRegistry, private metaReader: MetadataReader,\n@@ -131,6 +207,7 @@ export class ComponentDecoratorHandler implements\n       private defaultImportRecorder: DefaultImportRecorder,\n       private depTracker: DependencyTracker|null,\n       private injectableRegistry: InjectableClassRegistry,\n+      private semanticDepGraphUpdater: SemanticDepGraphUpdater|null,\n       private annotateForClosureCompiler: boolean) {}\n \n   private literalCache = new Map<Decorator, ts.ObjectLiteralExpression>();\n@@ -397,6 +474,14 @@ export class ComponentDecoratorHandler implements\n     return output;\n   }\n \n+  symbol(node: ClassDeclaration, analysis: Readonly<ComponentAnalysisData>): ComponentSymbol {\n+    const typeParameters = extractSemanticTypeParameters(node);\n+\n+    return new ComponentSymbol(\n+        node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs,\n+        analysis.typeCheckMeta, typeParameters);\n+  }\n+\n   register(node: ClassDeclaration, analysis: ComponentAnalysisData): void {\n     // Register this component's information with the `MetadataRegistry`. This ensures that\n     // the information about the component is available during the compile() phase.\n@@ -476,8 +561,13 @@ export class ComponentDecoratorHandler implements\n         meta.template.sourceMapping, meta.template.file, meta.template.errors);\n   }\n \n-  resolve(node: ClassDeclaration, analysis: Readonly<ComponentAnalysisData>):\n-      ResolveResult<ComponentResolutionData> {\n+  resolve(\n+      node: ClassDeclaration, analysis: Readonly<ComponentAnalysisData>,\n+      symbol: ComponentSymbol): ResolveResult<ComponentResolutionData> {\n+    if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof Reference) {\n+      symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);\n+    }\n+\n     if (analysis.isPoisoned && !this.usePoisonedData) {\n       return {};\n     }\n@@ -538,7 +628,7 @@ export class ComponentDecoratorHandler implements\n       const bound = binder.bind({template: metadata.template.nodes});\n \n       // The BoundTarget knows which directives and pipes matched the template.\n-      type UsedDirective = R3UsedDirectiveMetadata&{ref: Reference};\n+      type UsedDirective = R3UsedDirectiveMetadata&{ref: Reference<ClassDeclaration>};\n       const usedDirectives: UsedDirective[] = bound.getUsedDirectives().map(directive => {\n         return {\n           ref: directive.ref,\n@@ -550,8 +640,7 @@ export class ComponentDecoratorHandler implements\n           isComponent: directive.isComponent,\n         };\n       });\n-\n-      type UsedPipe = {ref: Reference, pipeName: string, expression: Expression};\n+      type UsedPipe = {ref: Reference<ClassDeclaration>, pipeName: string, expression: Expression};\n       const usedPipes: UsedPipe[] = [];\n       for (const pipeName of bound.getUsedPipes()) {\n         if (!pipes.has(pipeName)) {\n@@ -564,6 +653,13 @@ export class ComponentDecoratorHandler implements\n           expression: this.refEmitter.emit(pipe, context),\n         });\n       }\n+      if (this.semanticDepGraphUpdater !== null) {\n+        symbol.usedDirectives = usedDirectives.map(\n+            dir => this.semanticDepGraphUpdater!.getSemanticReference(dir.ref.node, dir.type));\n+        symbol.usedPipes = usedPipes.map(\n+            pipe =>\n+                this.semanticDepGraphUpdater!.getSemanticReference(pipe.ref.node, pipe.expression));\n+      }\n \n       // Scan through the directives/pipes actually used in the template and check whether any\n       // import which needs to be generated would create a cycle.\n@@ -582,7 +678,8 @@ export class ComponentDecoratorHandler implements\n         }\n       }\n \n-      if (cyclesFromDirectives.size === 0 && cyclesFromPipes.size === 0) {\n+      const cycleDetected = cyclesFromDirectives.size !== 0 || cyclesFromPipes.size !== 0;\n+      if (!cycleDetected) {\n         // No cycle was detected. Record the imports that need to be created in the cycle detector\n         // so that future cyclic import checks consider their production.\n         for (const {type} of usedDirectives) {\n@@ -613,6 +710,21 @@ export class ComponentDecoratorHandler implements\n           // NgModule file will take care of setting the directives for the component.\n           this.scopeRegistry.setComponentRemoteScope(\n               node, usedDirectives.map(dir => dir.ref), usedPipes.map(pipe => pipe.ref));\n+          symbol.isRemotelyScoped = true;\n+\n+          // If a semantic graph is being tracked, record the fact that this component is remotely\n+          // scoped with the declaring NgModule symbol as the NgModule's emit becomes dependent on\n+          // the directive/pipe usages of this component.\n+          if (this.semanticDepGraphUpdater !== null) {\n+            const moduleSymbol = this.semanticDepGraphUpdater.getSymbol(scope.ngModule);\n+            if (!(moduleSymbol instanceof NgModuleSymbol)) {\n+              throw new Error(\n+                  `AssertionError: Expected ${scope.ngModule.name} to be an NgModuleSymbol.`);\n+            }\n+\n+            moduleSymbol.addRemotelyScopedComponent(\n+                symbol, symbol.usedDirectives, symbol.usedPipes);\n+          }\n         } else {\n           // We are not able to handle this cycle so throw an error.\n           const relatedMessages: ts.DiagnosticRelatedInformation[] = [];"
        },
        {
            "sha": "52f5a8b2bb91c3c436ff5e04602d0f76476c494f",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/directive.ts",
            "status": "modified",
            "additions": 143,
            "deletions": 4,
            "changes": 147,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdirective.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdirective.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdirective.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -11,8 +11,10 @@ import {emitDistinctChangesOnlyDefaultValue} from '@angular/compiler/src/core';\n import * as ts from 'typescript';\n \n import {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\n+import {absoluteFromSourceFile} from '../../file_system';\n import {DefaultImportRecorder, Reference} from '../../imports';\n-import {ClassPropertyMapping, DirectiveTypeCheckMeta, InjectableClassRegistry, MetadataReader, MetadataRegistry} from '../../metadata';\n+import {areTypeParametersEqual, extractSemanticTypeParameters, isArrayEqual, isSetEqual, isSymbolEqual, SemanticDepGraphUpdater, SemanticSymbol, SemanticTypeParameter} from '../../incremental/semantic_graph';\n+import {BindingPropertyName, ClassPropertyMapping, ClassPropertyName, DirectiveTypeCheckMeta, InjectableClassRegistry, MetadataReader, MetadataRegistry, TemplateGuardMeta} from '../../metadata';\n import {extractDirectiveTypeCheckMeta} from '../../metadata/src/util';\n import {DynamicValue, EnumValue, PartialEvaluator} from '../../partial_evaluator';\n import {ClassDeclaration, ClassMember, ClassMemberKind, Decorator, filterToMembersWithDecorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\n@@ -46,13 +48,138 @@ export interface DirectiveHandlerData {\n   isStructural: boolean;\n }\n \n+/**\n+ * Represents an Angular directive. Components are represented by `ComponentSymbol`, which inherits\n+ * from this symbol.\n+ */\n+export class DirectiveSymbol extends SemanticSymbol {\n+  baseClass: SemanticSymbol|null = null;\n+\n+  constructor(\n+      decl: ClassDeclaration, public readonly selector: string|null,\n+      public readonly inputs: ClassPropertyMapping, public readonly outputs: ClassPropertyMapping,\n+      public readonly exportAs: string[]|null,\n+      public readonly typeCheckMeta: DirectiveTypeCheckMeta,\n+      public readonly typeParameters: SemanticTypeParameter[]|null) {\n+    super(decl);\n+  }\n+\n+  isPublicApiAffected(previousSymbol: SemanticSymbol): boolean {\n+    // Note: since components and directives have exactly the same items contributing to their\n+    // public API, it is okay for a directive to change into a component and vice versa without\n+    // the API being affected.\n+    if (!(previousSymbol instanceof DirectiveSymbol)) {\n+      return true;\n+    }\n+\n+    // Directives and components have a public API of:\n+    //  1. Their selector.\n+    //  2. The binding names of their inputs and outputs; a change in ordering is also considered\n+    //     to be a change in public API.\n+    //  3. The list of exportAs names and its ordering.\n+    return this.selector !== previousSymbol.selector ||\n+        !isArrayEqual(this.inputs.propertyNames, previousSymbol.inputs.propertyNames) ||\n+        !isArrayEqual(this.outputs.propertyNames, previousSymbol.outputs.propertyNames) ||\n+        !isArrayEqual(this.exportAs, previousSymbol.exportAs);\n+  }\n+\n+  isTypeCheckApiAffected(previousSymbol: SemanticSymbol): boolean {\n+    // If the public API of the directive has changed, then so has its type-check API.\n+    if (this.isPublicApiAffected(previousSymbol)) {\n+      return true;\n+    }\n+\n+    if (!(previousSymbol instanceof DirectiveSymbol)) {\n+      return true;\n+    }\n+\n+    // The type-check block also depends on the class property names, as writes property bindings\n+    // directly into the backing fields.\n+    if (!isArrayEqual(\n+            Array.from(this.inputs), Array.from(previousSymbol.inputs), isInputMappingEqual) ||\n+        !isArrayEqual(\n+            Array.from(this.outputs), Array.from(previousSymbol.outputs), isInputMappingEqual)) {\n+      return true;\n+    }\n+\n+    // The type parameters of a directive are emitted into the type constructors in the type-check\n+    // block of a component, so if the type parameters are not considered equal then consider the\n+    // type-check API of this directive to be affected.\n+    if (!areTypeParametersEqual(this.typeParameters, previousSymbol.typeParameters)) {\n+      return true;\n+    }\n+\n+    // The type-check metadata is used during TCB code generation, so any changes should invalidate\n+    // prior type-check files.\n+    if (!isTypeCheckMetaEqual(this.typeCheckMeta, previousSymbol.typeCheckMeta)) {\n+      return true;\n+    }\n+\n+    // Changing the base class of a directive means that its inputs/outputs etc may have changed,\n+    // so the type-check block of components that use this directive needs to be regenerated.\n+    if (!isBaseClassEqual(this.baseClass, previousSymbol.baseClass)) {\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+}\n+\n+function isInputMappingEqual(\n+    current: [ClassPropertyName, BindingPropertyName],\n+    previous: [ClassPropertyName, BindingPropertyName]): boolean {\n+  return current[0] === previous[0] && current[1] === previous[1];\n+}\n+\n+function isTypeCheckMetaEqual(\n+    current: DirectiveTypeCheckMeta, previous: DirectiveTypeCheckMeta): boolean {\n+  if (current.hasNgTemplateContextGuard !== previous.hasNgTemplateContextGuard) {\n+    return false;\n+  }\n+  if (current.isGeneric !== previous.isGeneric) {\n+    // Note: changes in the number of type parameters is also considered in `areTypeParametersEqual`\n+    // so this check is technically not needed; it is done anyway for completeness in terms of\n+    // whether the `DirectiveTypeCheckMeta` struct itself compares equal or not.\n+    return false;\n+  }\n+  if (!isArrayEqual(current.ngTemplateGuards, previous.ngTemplateGuards, isTemplateGuardEqual)) {\n+    return false;\n+  }\n+  if (!isSetEqual(current.coercedInputFields, previous.coercedInputFields)) {\n+    return false;\n+  }\n+  if (!isSetEqual(current.restrictedInputFields, previous.restrictedInputFields)) {\n+    return false;\n+  }\n+  if (!isSetEqual(current.stringLiteralInputFields, previous.stringLiteralInputFields)) {\n+    return false;\n+  }\n+  if (!isSetEqual(current.undeclaredInputFields, previous.undeclaredInputFields)) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+function isTemplateGuardEqual(current: TemplateGuardMeta, previous: TemplateGuardMeta): boolean {\n+  return current.inputName === previous.inputName && current.type === previous.type;\n+}\n+\n+function isBaseClassEqual(current: SemanticSymbol|null, previous: SemanticSymbol|null): boolean {\n+  if (current === null || previous === null) {\n+    return current === previous;\n+  }\n+\n+  return isSymbolEqual(current, previous);\n+}\n+\n export class DirectiveDecoratorHandler implements\n-    DecoratorHandler<Decorator|null, DirectiveHandlerData, unknown> {\n+    DecoratorHandler<Decorator|null, DirectiveHandlerData, DirectiveSymbol, unknown> {\n   constructor(\n       private reflector: ReflectionHost, private evaluator: PartialEvaluator,\n       private metaRegistry: MetadataRegistry, private scopeRegistry: LocalModuleScopeRegistry,\n       private metaReader: MetadataReader, private defaultImportRecorder: DefaultImportRecorder,\n       private injectableRegistry: InjectableClassRegistry, private isCore: boolean,\n+      private semanticDepGraphUpdater: SemanticDepGraphUpdater|null,\n       private annotateForClosureCompiler: boolean,\n       private compileUndecoratedClassesWithAngularFeatures: boolean) {}\n \n@@ -116,6 +243,14 @@ export class DirectiveDecoratorHandler implements\n     };\n   }\n \n+  symbol(node: ClassDeclaration, analysis: Readonly<DirectiveHandlerData>): DirectiveSymbol {\n+    const typeParameters = extractSemanticTypeParameters(node);\n+\n+    return new DirectiveSymbol(\n+        node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs,\n+        analysis.typeCheckMeta, typeParameters);\n+  }\n+\n   register(node: ClassDeclaration, analysis: Readonly<DirectiveHandlerData>): void {\n     // Register this directive's information with the `MetadataRegistry`. This ensures that\n     // the information about the directive is available during the compile() phase.\n@@ -138,9 +273,13 @@ export class DirectiveDecoratorHandler implements\n     this.injectableRegistry.registerInjectable(node);\n   }\n \n-  resolve(node: ClassDeclaration, analysis: DirectiveHandlerData): ResolveResult<unknown> {\n-    const diagnostics: ts.Diagnostic[] = [];\n+  resolve(node: ClassDeclaration, analysis: DirectiveHandlerData, symbol: DirectiveSymbol):\n+      ResolveResult<unknown> {\n+    if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof Reference) {\n+      symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);\n+    }\n \n+    const diagnostics: ts.Diagnostic[] = [];\n     if (analysis.providersRequiringFactory !== null &&\n         analysis.meta.providers instanceof WrappedNodeExpr) {\n       const providerDiagnostics = getProviderDiagnostics("
        },
        {
            "sha": "4e689a6961176b51d5afffe5319bf2a4259f2734",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Finjectable.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Finjectable.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Finjectable.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -30,7 +30,7 @@ export interface InjectableHandlerData {\n  * Adapts the `compileIvyInjectable` compiler for `@Injectable` decorators to the Ivy compiler.\n  */\n export class InjectableDecoratorHandler implements\n-    DecoratorHandler<Decorator, InjectableHandlerData, unknown> {\n+    DecoratorHandler<Decorator, InjectableHandlerData, null, unknown> {\n   constructor(\n       private reflector: ReflectionHost, private defaultImportRecorder: DefaultImportRecorder,\n       private isCore: boolean, private strictCtorDeps: boolean,\n@@ -83,6 +83,10 @@ export class InjectableDecoratorHandler implements\n     };\n   }\n \n+  symbol(): null {\n+    return null;\n+  }\n+\n   register(node: ClassDeclaration): void {\n     this.injectableRegistry.registerInjectable(node);\n   }"
        },
        {
            "sha": "f27984945f637d96f1a86ae47ff58295f00d4a5e",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/ng_module.ts",
            "status": "modified",
            "additions": 78,
            "deletions": 2,
            "changes": 80,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fng_module.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fng_module.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fng_module.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -11,9 +11,10 @@ import * as ts from 'typescript';\n \n import {ErrorCode, FatalDiagnosticError, makeDiagnostic, makeRelatedInformation} from '../../diagnostics';\n import {DefaultImportRecorder, Reference, ReferenceEmitter} from '../../imports';\n+import {isArrayEqual, isReferenceEqual, isSymbolEqual, SemanticReference, SemanticSymbol} from '../../incremental/semantic_graph';\n import {InjectableClassRegistry, MetadataReader, MetadataRegistry} from '../../metadata';\n import {PartialEvaluator, ResolvedValue} from '../../partial_evaluator';\n-import {ClassDeclaration, DeclarationNode, Decorator, isNamedClassDeclaration, ReflectionHost, reflectObjectLiteral, typeNodeToValueExpr} from '../../reflection';\n+import {ClassDeclaration, Decorator, isNamedClassDeclaration, ReflectionHost, reflectObjectLiteral, typeNodeToValueExpr} from '../../reflection';\n import {NgModuleRouteAnalyzer} from '../../routing';\n import {LocalModuleScopeRegistry, ScopeData} from '../../scope';\n import {FactoryTracker} from '../../shims/api';\n@@ -44,13 +45,84 @@ export interface NgModuleResolution {\n   injectorImports: Expression[];\n }\n \n+/**\n+ * Represents an Angular NgModule.\n+ */\n+export class NgModuleSymbol extends SemanticSymbol {\n+  private remotelyScopedComponents: {\n+    component: SemanticSymbol,\n+    usedDirectives: SemanticReference[],\n+    usedPipes: SemanticReference[]\n+  }[] = [];\n+\n+  isPublicApiAffected(previousSymbol: SemanticSymbol): boolean {\n+    if (!(previousSymbol instanceof NgModuleSymbol)) {\n+      return true;\n+    }\n+\n+    // NgModules don't have a public API that could affect emit of Angular decorated classes.\n+    return false;\n+  }\n+\n+  isEmitAffected(previousSymbol: SemanticSymbol): boolean {\n+    if (!(previousSymbol instanceof NgModuleSymbol)) {\n+      return true;\n+    }\n+\n+    // compare our remotelyScopedComponents to the previous symbol\n+    if (previousSymbol.remotelyScopedComponents.length !== this.remotelyScopedComponents.length) {\n+      return true;\n+    }\n+\n+    for (const currEntry of this.remotelyScopedComponents) {\n+      const prevEntry = previousSymbol.remotelyScopedComponents.find(prevEntry => {\n+        return isSymbolEqual(prevEntry.component, currEntry.component);\n+      });\n+\n+      if (prevEntry === undefined) {\n+        // No previous entry was found, which means that this component became remotely scoped and\n+        // hence this NgModule needs to be re-emitted.\n+        return true;\n+      }\n+\n+      if (!isArrayEqual(currEntry.usedDirectives, prevEntry.usedDirectives, isReferenceEqual)) {\n+        // The list of used directives or their order has changed. Since this NgModule emits\n+        // references to the list of used directives, it should be re-emitted to update this list.\n+        // Note: the NgModule does not have to be re-emitted when any of the directives has had\n+        // their public API changed, as the NgModule only emits a reference to the symbol by its\n+        // name. Therefore, testing for symbol equality is sufficient.\n+        return true;\n+      }\n+\n+      if (!isArrayEqual(currEntry.usedPipes, prevEntry.usedPipes, isReferenceEqual)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  isTypeCheckApiAffected(previousSymbol: SemanticSymbol): boolean {\n+    if (!(previousSymbol instanceof NgModuleSymbol)) {\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  addRemotelyScopedComponent(\n+      component: SemanticSymbol, usedDirectives: SemanticReference[],\n+      usedPipes: SemanticReference[]): void {\n+    this.remotelyScopedComponents.push({component, usedDirectives, usedPipes});\n+  }\n+}\n+\n /**\n  * Compiles @NgModule annotations to ngModuleDef fields.\n  *\n  * TODO(alxhub): handle injector side of things as well.\n  */\n export class NgModuleDecoratorHandler implements\n-    DecoratorHandler<Decorator, NgModuleAnalysis, NgModuleResolution> {\n+    DecoratorHandler<Decorator, NgModuleAnalysis, NgModuleSymbol, NgModuleResolution> {\n   constructor(\n       private reflector: ReflectionHost, private evaluator: PartialEvaluator,\n       private metaReader: MetadataReader, private metaRegistry: MetadataRegistry,\n@@ -293,6 +365,10 @@ export class NgModuleDecoratorHandler implements\n     };\n   }\n \n+  symbol(node: ClassDeclaration): NgModuleSymbol {\n+    return new NgModuleSymbol(node);\n+  }\n+\n   register(node: ClassDeclaration, analysis: NgModuleAnalysis): void {\n     // Register this module's information with the LocalModuleScopeRegistry. This ensures that\n     // during the compile() phase, the module's metadata is available for selector scope"
        },
        {
            "sha": "8732393ef3b2e608c21aba949235f0c07b858c28",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/pipe.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 2,
            "changes": 31,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fpipe.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fpipe.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fpipe.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -11,13 +11,14 @@ import * as ts from 'typescript';\n \n import {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\n import {DefaultImportRecorder, Reference} from '../../imports';\n+import {SemanticSymbol} from '../../incremental/semantic_graph';\n import {InjectableClassRegistry, MetadataRegistry} from '../../metadata';\n import {PartialEvaluator} from '../../partial_evaluator';\n import {ClassDeclaration, Decorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\n import {LocalModuleScopeRegistry} from '../../scope';\n import {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerPrecedence, ResolveResult} from '../../transform';\n-import {createValueHasWrongTypeError} from './diagnostics';\n \n+import {createValueHasWrongTypeError} from './diagnostics';\n import {compileNgFactoryDefField} from './factory';\n import {generateSetClassMetadataCall} from './metadata';\n import {findAngularDecorator, getValidConstructorDependencies, makeDuplicateDeclarationError, unwrapExpression, wrapTypeReference} from './util';\n@@ -27,7 +28,29 @@ export interface PipeHandlerData {\n   metadataStmt: Statement|null;\n }\n \n-export class PipeDecoratorHandler implements DecoratorHandler<Decorator, PipeHandlerData, unknown> {\n+/**\n+ * Represents an Angular pipe.\n+ */\n+export class PipeSymbol extends SemanticSymbol {\n+  constructor(decl: ClassDeclaration, public readonly name: string) {\n+    super(decl);\n+  }\n+\n+  isPublicApiAffected(previousSymbol: SemanticSymbol): boolean {\n+    if (!(previousSymbol instanceof PipeSymbol)) {\n+      return true;\n+    }\n+\n+    return this.name !== previousSymbol.name;\n+  }\n+\n+  isTypeCheckApiAffected(previousSymbol: SemanticSymbol): boolean {\n+    return this.isPublicApiAffected(previousSymbol);\n+  }\n+}\n+\n+export class PipeDecoratorHandler implements\n+    DecoratorHandler<Decorator, PipeHandlerData, PipeSymbol, unknown> {\n   constructor(\n       private reflector: ReflectionHost, private evaluator: PartialEvaluator,\n       private metaRegistry: MetadataRegistry, private scopeRegistry: LocalModuleScopeRegistry,\n@@ -114,6 +137,10 @@ export class PipeDecoratorHandler implements DecoratorHandler<Decorator, PipeHan\n     };\n   }\n \n+  symbol(node: ClassDeclaration, analysis: Readonly<PipeHandlerData>): PipeSymbol {\n+    return new PipeSymbol(node, analysis.meta.name);\n+  }\n+\n   register(node: ClassDeclaration, analysis: Readonly<PipeHandlerData>): void {\n     const ref = new Reference(node);\n     this.metaRegistry.registerPipeMetadata({ref, name: analysis.meta.pipeName});"
        },
        {
            "sha": "ba62f6e73c3db2b20f2bfdd6d0ab030af96da606",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/test/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2FBUILD.bazel?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -17,6 +17,7 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/file_system\",\n         \"//packages/compiler-cli/src/ngtsc/file_system/testing\",\n         \"//packages/compiler-cli/src/ngtsc/imports\",\n+        \"//packages/compiler-cli/src/ngtsc/incremental:api\",\n         \"//packages/compiler-cli/src/ngtsc/metadata\",\n         \"//packages/compiler-cli/src/ngtsc/partial_evaluator\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\","
        },
        {
            "sha": "77cc48cc4a94bef86f509ce267ac31472fd7ac63",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/test/component_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fcomponent_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fcomponent_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fcomponent_spec.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -78,6 +78,7 @@ function setup(program: ts.Program, options: ts.CompilerOptions, host: ts.Compil\n       NOOP_DEFAULT_IMPORT_RECORDER,\n       /* depTracker */ null,\n       injectableRegistry,\n+      /* semanticDepGraphUpdater */ null,\n       /* annotateForClosureCompiler */ false,\n   );\n   return {reflectionHost, handler};\n@@ -247,7 +248,8 @@ runInEachFileSystem(() => {\n         return fail('Failed to recognize @Component');\n       }\n       const {analysis} = handler.analyze(TestCmp, detected.metadata);\n-      const resolution = handler.resolve(TestCmp, analysis!);\n+      const symbol = handler.symbol(TestCmp, analysis!);\n+      const resolution = handler.resolve(TestCmp, analysis!, symbol);\n \n       const compileResult =\n           handler.compileFull(TestCmp, analysis!, resolution.data!, new ConstantPool());"
        },
        {
            "sha": "294174542ff6b4178f3c61d14fb349f2a4d7a7e6",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/test/directive_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fdirective_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fdirective_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fdirective_spec.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -169,6 +169,7 @@ runInEachFileSystem(() => {\n     const handler = new DirectiveDecoratorHandler(\n         reflectionHost, evaluator, scopeRegistry, scopeRegistry, metaReader,\n         NOOP_DEFAULT_IMPORT_RECORDER, injectableRegistry, /*isCore*/ false,\n+        /*semanticDepGraphUpdater*/ null,\n         /*annotateForClosureCompiler*/ false,\n         /*detectUndecoratedClassesWithAngularFeatures*/ false);\n "
        },
        {
            "sha": "a1114618898b299ad7aa9c0280f5f57bf2223190",
            "filename": "packages/compiler-cli/src/ngtsc/core/BUILD.bazel",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2FBUILD.bazel?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -19,6 +19,8 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/file_system\",\n         \"//packages/compiler-cli/src/ngtsc/imports\",\n         \"//packages/compiler-cli/src/ngtsc/incremental\",\n+        \"//packages/compiler-cli/src/ngtsc/incremental:api\",\n+        \"//packages/compiler-cli/src/ngtsc/incremental/semantic_graph\",\n         \"//packages/compiler-cli/src/ngtsc/indexer\",\n         \"//packages/compiler-cli/src/ngtsc/metadata\",\n         \"//packages/compiler-cli/src/ngtsc/modulewithproviders\","
        },
        {
            "sha": "311d768f71ad34fac00cbbb7ced31e6332e0b56b",
            "filename": "packages/compiler-cli/src/ngtsc/core/src/compiler.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 76,
            "changes": 86,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -16,6 +16,7 @@ import {checkForPrivateExports, ReferenceGraph} from '../../entry_point';\n import {LogicalFileSystem, resolve} from '../../file_system';\n import {AbsoluteModuleStrategy, AliasingHost, AliasStrategy, DefaultImportTracker, ImportRewriter, LocalIdentifierStrategy, LogicalProjectStrategy, ModuleResolver, NoopImportRewriter, PrivateExportAliasingHost, R3SymbolsImportRewriter, Reference, ReferenceEmitStrategy, ReferenceEmitter, RelativePathStrategy, UnifiedModulesAliasingHost, UnifiedModulesStrategy} from '../../imports';\n import {IncrementalBuildStrategy, IncrementalDriver} from '../../incremental';\n+import {SemanticSymbol} from '../../incremental/semantic_graph';\n import {generateAnalysis, IndexedComponent, IndexingContext} from '../../indexer';\n import {ComponentResources, CompoundMetadataReader, CompoundMetadataRegistry, DtsMetadataReader, InjectableClassRegistry, LocalMetadataRegistry, MetadataReader, ResourceRegistry} from '../../metadata';\n import {ModuleWithProvidersScanner} from '../../modulewithproviders';\n@@ -636,8 +637,6 @@ export class NgCompiler {\n   private resolveCompilation(traitCompiler: TraitCompiler): void {\n     traitCompiler.resolve();\n \n-    this.recordNgModuleScopeDependencies();\n-\n     // At this point, analysis is complete and the compiler can now calculate which files need to\n     // be emitted, so do that.\n     this.incrementalDriver.recordSuccessfulAnalysis(traitCompiler);\n@@ -810,74 +809,6 @@ export class NgCompiler {\n     return this.nonTemplateDiagnostics;\n   }\n \n-  /**\n-   * Reifies the inter-dependencies of NgModules and the components within their compilation scopes\n-   * into the `IncrementalDriver`'s dependency graph.\n-   */\n-  private recordNgModuleScopeDependencies() {\n-    const recordSpan = this.perfRecorder.start('recordDependencies');\n-    const depGraph = this.incrementalDriver.depGraph;\n-\n-    for (const scope of this.compilation!.scopeRegistry!.getCompilationScopes()) {\n-      const file = scope.declaration.getSourceFile();\n-      const ngModuleFile = scope.ngModule.getSourceFile();\n-\n-      // A change to any dependency of the declaration causes the declaration to be invalidated,\n-      // which requires the NgModule to be invalidated as well.\n-      depGraph.addTransitiveDependency(ngModuleFile, file);\n-\n-      // A change to the NgModule file should cause the declaration itself to be invalidated.\n-      depGraph.addDependency(file, ngModuleFile);\n-\n-      const meta =\n-          this.compilation!.metaReader.getDirectiveMetadata(new Reference(scope.declaration));\n-      if (meta !== null && meta.isComponent) {\n-        // If a component's template changes, it might have affected the import graph, and thus the\n-        // remote scoping feature which is activated in the event of potential import cycles. Thus,\n-        // the module depends not only on the transitive dependencies of the component, but on its\n-        // resources as well.\n-        depGraph.addTransitiveResources(ngModuleFile, file);\n-\n-        // A change to any directive/pipe in the compilation scope should cause the component to be\n-        // invalidated.\n-        for (const directive of scope.directives) {\n-          // When a directive in scope is updated, the component needs to be recompiled as e.g. a\n-          // selector may have changed.\n-          depGraph.addTransitiveDependency(file, directive.ref.node.getSourceFile());\n-        }\n-        for (const pipe of scope.pipes) {\n-          // When a pipe in scope is updated, the component needs to be recompiled as e.g. the\n-          // pipe's name may have changed.\n-          depGraph.addTransitiveDependency(file, pipe.ref.node.getSourceFile());\n-        }\n-\n-        // Components depend on the entire export scope. In addition to transitive dependencies on\n-        // all directives/pipes in the export scope, they also depend on every NgModule in the\n-        // scope, as changes to a module may add new directives/pipes to the scope.\n-        for (const depModule of scope.ngModules) {\n-          // There is a correctness issue here. To be correct, this should be a transitive\n-          // dependency on the depModule file, since the depModule's exports might change via one of\n-          // its dependencies, even if depModule's file itself doesn't change. However, doing this\n-          // would also trigger recompilation if a non-exported component or directive changed,\n-          // which causes performance issues for rebuilds.\n-          //\n-          // Given the rebuild issue is an edge case, currently we err on the side of performance\n-          // instead of correctness. A correct and performant design would distinguish between\n-          // changes to the depModule which affect its export scope and changes which do not, and\n-          // only add a dependency for the former. This concept is currently in development.\n-          //\n-          // TODO(alxhub): fix correctness issue by understanding the semantics of the dependency.\n-          depGraph.addDependency(file, depModule.getSourceFile());\n-        }\n-      } else {\n-        // Directives (not components) and pipes only depend on the NgModule which directly declares\n-        // them.\n-        depGraph.addDependency(file, ngModuleFile);\n-      }\n-    }\n-    this.perfRecorder.stop(recordSpan);\n-  }\n-\n   private scanForMwp(sf: ts.SourceFile): void {\n     this.compilation!.mwpScanner.scan(sf, {\n       addTypeReplacement: (node: ts.Declaration, type: Type): void => {\n@@ -957,6 +888,7 @@ export class NgCompiler {\n     const scopeRegistry =\n         new LocalModuleScopeRegistry(localMetaReader, depScopeReader, refEmitter, aliasingHost);\n     const scopeReader: ComponentScopeReader = scopeRegistry;\n+    const semanticDepGraphUpdater = this.incrementalDriver.getSemanticDepGraphUpdater();\n     const metaRegistry = new CompoundMetadataRegistry([localMetaRegistry, scopeRegistry]);\n     const injectableRegistry = new InjectableClassRegistry(reflector);\n \n@@ -998,7 +930,7 @@ export class NgCompiler {\n         CycleHandlingStrategy.Error;\n \n     // Set up the IvyCompilation, which manages state for the Ivy transformer.\n-    const handlers: DecoratorHandler<unknown, unknown, unknown>[] = [\n+    const handlers: DecoratorHandler<unknown, unknown, SemanticSymbol|null, unknown>[] = [\n       new ComponentDecoratorHandler(\n           reflector, evaluator, metaRegistry, metaReader, scopeReader, scopeRegistry,\n           typeCheckScopeRegistry, resourceRegistry, isCore, this.resourceManager,\n@@ -1007,15 +939,16 @@ export class NgCompiler {\n           this.options.enableI18nLegacyMessageIdFormat !== false, this.usePoisonedData,\n           this.options.i18nNormalizeLineEndingsInICUs, this.moduleResolver, this.cycleAnalyzer,\n           cycleHandlingStrategy, refEmitter, defaultImportTracker, this.incrementalDriver.depGraph,\n-          injectableRegistry, this.closureCompilerEnabled),\n+          injectableRegistry, semanticDepGraphUpdater, this.closureCompilerEnabled),\n+\n       // TODO(alxhub): understand why the cast here is necessary (something to do with `null`\n       // not being assignable to `unknown` when wrapped in `Readonly`).\n       // clang-format off\n         new DirectiveDecoratorHandler(\n             reflector, evaluator, metaRegistry, scopeRegistry, metaReader,\n-            defaultImportTracker, injectableRegistry, isCore, this.closureCompilerEnabled,\n-            compileUndecoratedClassesWithAngularFeatures,\n-        ) as Readonly<DecoratorHandler<unknown, unknown, unknown>>,\n+            defaultImportTracker, injectableRegistry, isCore, semanticDepGraphUpdater,\n+          this.closureCompilerEnabled, compileUndecoratedClassesWithAngularFeatures,\n+        ) as Readonly<DecoratorHandler<unknown, unknown, SemanticSymbol | null,unknown>>,\n       // clang-format on\n       // Pipe handler must be before injectable handler in list so pipe factories are printed\n       // before injectable factories (so injectable factories can delegate to them)\n@@ -1033,7 +966,8 @@ export class NgCompiler {\n \n     const traitCompiler = new TraitCompiler(\n         handlers, reflector, this.perfRecorder, this.incrementalDriver,\n-        this.options.compileNonExportedClasses !== false, compilationMode, dtsTransforms);\n+        this.options.compileNonExportedClasses !== false, compilationMode, dtsTransforms,\n+        semanticDepGraphUpdater);\n \n     const templateTypeChecker = new TemplateTypeCheckerImpl(\n         this.tsProgram, this.typeCheckingProgramStrategy, traitCompiler,"
        },
        {
            "sha": "4b690eb29d045808af073e81a8be5a10f01ae19e",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/BUILD.bazel",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2FBUILD.bazel?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -11,6 +11,7 @@ ts_library(\n         \":api\",\n         \"//packages/compiler-cli/src/ngtsc/file_system\",\n         \"//packages/compiler-cli/src/ngtsc/imports\",\n+        \"//packages/compiler-cli/src/ngtsc/incremental/semantic_graph\",\n         \"//packages/compiler-cli/src/ngtsc/metadata\",\n         \"//packages/compiler-cli/src/ngtsc/partial_evaluator\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\",\n@@ -27,6 +28,7 @@ ts_library(\n     srcs = [\"api.ts\"],\n     deps = [\n         \"//packages/compiler-cli/src/ngtsc/file_system\",\n+        \"//packages/compiler-cli/src/ngtsc/reflection\",\n         \"@npm//typescript\",\n     ],\n )"
        },
        {
            "sha": "a5ed27edd879bce8b1c6f1e08d6e7f9812f89b33",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/README.md",
            "status": "modified",
            "additions": 230,
            "deletions": 93,
            "changes": 323,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2FREADME.md?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -1,154 +1,291 @@\n-# What is the `incremental` package?\n+# Incremental Compilation\n \n-This package contains logic related to incremental compilation in ngtsc.\n+The `incremental` package contains logic related to incremental compilation in ngtsc. Its goal is to\n+ensure that the compiler's incremental performance is largely O(number of files changed in that\n+iteration) instead of O(size of the program as a whole), by allowing the compiler to optimize away\n+as much work as possible without sacrificing the correctness of its output.\n \n-In particular, it tracks dependencies between `ts.SourceFile`s, so the compiler can make intelligent decisions about when it's safe to skip certain operations.\n+An incremental compilation receives information about the prior compilation, including\n+its `ts.Program` and the result of ngtsc's analyses of each class in that program. Depending on the\n+nature of any changes made to files in the program between its prior and current versions, and on\n+the semantic effect of those changes, ngtsc may perform 3 different optimizations as it processes\n+the new build:\n+\n+* It can reuse analysis work performed in the previous program\n \n-# What optimizations are made?\n+ngtsc receives the analyses of all decorated classes performed as part of the previous compilation,\n+and can reuse that work for a class if it can prove that the results are not stale.\n \n-ngtsc currently makes two optimizations: reuse of prior analysis work, and the skipping of file emits.\n+* It can skip emitting a file\n \n-## Reuse of analyses\n+Emitting a file is a very expensive operation in TypeScript, involving the execution of many\n+internal TS transforms (downleveling, module system, etc) as well as the synthesis of a large text\n+buffer for the final JS output. Skipping emit of a file is the most effective optimizations ngtsc\n+can do. It's also one of the most challenging. Even if ngtsc's _analysis_ of a specific file is not\n+stale, that file may still need to be re-emitted if other changes in the program impact its\n+semantics. For example, a change to a component selector affects other components which use that\n+selector in their templates, even though no direct dependency exists between them.\n \n-If a build has succeeded previously, ngtsc has available the analyses of all Angular classes in the prior program, as well as the dependency graph which outlines inter-file dependencies. This is known as the \"last good compilation\".\n+* It can reuse template type-checking code\n \n-When the next build begins, ngtsc follows a simple algorithm which reuses prior work where possible:\n+Template type-checking code is generated using semantic information extracted from the user's\n+program. This generation can be expensive, and ngtsc attempts to reuse previous results as much as\n+possible. This optimization can be thought of as a special case of the above re-emit optimization,\n+since template type-checking code is a particular flavor of \"emit\" for a component.\n \n-1) For each input file, ngtsc makes a determination as to whether the file is \"logically changed\".\n+Due to the way that template type-checking works (creation of a second `ts.Program`\n+with `.ngtypecheck` files containing template type-checking blocks, or TCBs), reuse of template\n+type-checking code is critical for good performance. Not only is generation of these TCBs expensive,\n+but forcing TypeScript to re-parse and re-analyze every `.ngtypecheck` file on each incremental\n+change would be costly as well.\n \n-\"Logically changed\" means that either:\n+The `incremental` package is dedicated to allowing ngtsc to make these important optimizations\n+safely.\n+\n+During an incremental compilation, the compiler begins with a process called \"reconciliation\",\n+focused on understanding the differences between the incoming, new `ts.Program` and the\n+last `ts.Program`. In TypeScript, an unchanged file will have its `ts.SourceFile` AST completely\n+reused. Reconciliation therefore examines the `ts.SourceFile`s of both the old and new programs, and\n+identifies files which have been added, removed, or changed. This information feeds in to the rest\n+of the incremental compilation process.\n+\n+## Reuse of analysis results\n+\n+Angular's process of understanding an individual component, directive, or other decorated class is\n+known as \"analysis\". Analysis is always performed on a class-by-class basis, so the analysis of a\n+component only takes into consideration information present in the `@Component` decorator, and not\n+for example in the `@NgModule` which declares the component.\n+\n+However, analysis _can_ depend on information outside of the decorated class's file. This can happen\n+in two ways:\n+\n+* External resources, such as templates or stylesheets, are covered by analysis.\n+* The partial evaluation of expressions within a class's metadata may descend into symbols imported\n+  from other files.\n+\n+For example, a directive's selector may be determined via an imported constant:\n \n-* The file itself has physically changed on disk, or\n-* One of the file's dependencies has physically changed on disk.\n+```typescript=\n+import {Directive} from '@angular/core';\n+import {DIR_SELECTOR} from './selectors';\n+\n+@Directive({\n+  selector: DIR_SELECTOR,\n+})\n+export class Dir {}\n+```\n+\n+The analysis of this directive _depends on_ the value of `DIR_SELECTOR` from `selectors.ts`.\n+Consequently, if `selectors.ts` changes, `Dir` needs to be re-analyzed, even if `dir.ts` has not\n+changed.\n+\n+The `incremental` system provides a mechanism which tracks such dependencies at the file level. The\n+partial evaluation system records dependencies for any given evaluation operation when an import\n+boundary is crossed, building up a file-to-file dependency graph. This graph is then transmitted to\n+the next incremental compilation, where it can be used to determine, based on the set of files\n+physically changed on disk, which files have _logically_ changed and need to be re-analyzed.\n \n-Either of these conditions invalidates the previous analysis of the file.\n+## Reuse of emit results\n+\n+In plain TypeScript programs, the compiled JavaScript code for any given input file (e.g. `foo.ts`)\n+depends only on the code within that input file. That is, only the contents of `foo.ts` can affect\n+the generated contents written to `foo.js`. The TypeScript compiler can therefore perform a very\n+simple optimization, and avoid generating and emitting code for any input files which do not change.\n+This is important for good incremental build performance, as emitting a file is a very expensive\n+operation.\n \n-2) ngtsc begins constructing a new dependency graph.\n+(in practice, the TypeScript feature of `const enum` declarations breaks this overly simple model)\n \n-For each logically unchanged file, its dependencies are copied wholesale into the new graph.\n+In Angular applications, however, this optimization is not nearly so simple. The emit of a `.js`\n+file in Angular is affected in four main ways:\n \n-3) ngtsc begins analyzing each file in the program.\n+* Just as in plain TS, it depends on the contents of the input `.ts` file.\n+* It can be affected by expressions that were statically evaluated during analysis of any decorated\n+  classes in the input, and these expressions can depend on other files.\n \n-If the file is logically unchanged, ngtsc will reuse the previous analysis and only call the 'register' phase of compilation, to apply any necessary side effects.\n+For example, the directive with its selector specified via the imported `DIR_SELECTOR` constant\n+above has compilation output which depends on the value of `DIR_SELECTOR`. Therefore, the `dir.js`\n+file needs to be emitted whenever the value of the selector constant in `selectors.ts` changes, even\n+if `dir.ts` itself is unchanged. The compiler therefore will re-emit `dir.js` if the `dir.ts` file\n+is determined to have _logically_ changed, using the same dependency graph that powers analysis\n+reuse.\n \n-If the file is logically changed, ngtsc will re-analyze it.\n+* Components can have external templates and CSS stylesheets which influence their compilation.\n \n-## Reuse of template type-checking code\n+These are incorporated into a component's analysis dependencies.\n \n-Generally speaking, the generation of a template type-checking \"shim\" for an input component file is a time-consuming operation. Such generation produces several outputs:\n+* Components (and NgModules) are influenced by the NgModule graph, which controls which directives\n+  and pipes are \"in scope\" for each component's template.\n \n-1) The text of the template type-checking shim file, which can later be fed to TypeScript for the production of raw diagnostics.\n-2) Metadata regarding source mappings within the template type-checking shim, which can be used to convert the raw diagnostics into mapped template diagnostics.\n-3) \"Construction\" diagnostics, which are diagnostics produced as a side effect of generation of the shim itself.\n+This last relationship is the most difficult, as there is no import relationship between a component\n+and the directives and pipes it uses in its template. That means that a component file can be\n+logically unchanged, but still require re-emit if one of its dependencies has been updated in a way\n+that influences the compilation of the component.\n \n-When a component file is logically unchanged, ngtsc attempts to reuse this generation work. As part of creating both the new emit program and template type-checking program, the `ts.SourceFile` of the shim for the component file is included directly and not re-generated.\n+### Example\n \n-At the same time, the metadata and construction diagnostics are passed via the incremental build system. When TS gets diagnostics for the shim file, this metadata is used to convert them into mapped template diagnostics for delivery to the user.\n+For example, the output of a compiled component includes an array called `directiveDefs`, listing\n+all of the directives and components actually used within the component's template. This array is\n+built by combining the template (from analysis) with the \"scope\" of the component - the set of\n+directives and pipes which are available for use in its template. This scope is synthesized from the\n+analysis of not just the component's NgModule, but other NgModules which might be imported, and the\n+components/directives that those NgModules export, and their analysis data as well.\n \n-### Limitations on template type-checking reuse\n+These dependencies of a component on the directives/pipes it consumes, and the NgModule structures\n+that made them visible, are not captured in the file-level dependency graph. This is due to the\n+peculiar nature of NgModule and component relationships: NgModules import components, so there is\n+never a reference from a component to its NgModule, or any of its directive or pipe dependencies.\n \n-In certain cases the template type-checking system is unable to use the existing shim code. If the component is logically changed, the shim is regenerated in case its contents may have changed. If generating the shim itself required the use of any \"inline\" code (type-checking code which needs to be inserted into the component file instead for some reason), it also becomes ineligible for reuse.\n+In code, this looks like:\n \n-## Skipping emit\n+```typescript=\n+// dir.ts\n+@Directive({selector: '[dir]'})\n+export class Dir {}\n \n-ngtsc makes a decision to skip the emit of a file if it can prove that the contents of the file will not have changed since the last good compilation. To prove this, two conditions must be true.\n+// cmp.ts\n+@Component({\n+  selector: 'cmp',\n+  template: '<div dir></div>', // Matches the `[dir]` selector\n+})\n+export class Cmp {}\n \n-* The input file itself must not have changed since the previous compilation.\n+// mod.ts\n+import {Dir} from './dir';\n+import {Cmp} from './cmp';\n \n-* None of the files on which the input file is dependent have changed since the previous compilation.\n+@NgModule({declarations: [Dir, Cmp]})\n+export class Mod {}\n+```\n \n-The second condition is challenging to prove, as Angular allows statically evaluated expressions in lots of contexts that could result in changes from file to file. For example, the `name` of an `@Pipe` could be a reference to a constant in a different file. As part of analyzing the program, the compiler keeps track of such dependencies in order to answer this question.\n+Here, `Cmp` never directly imports or refers to `Dir`, but it _does_ consume the directive in its\n+template. During emit, `Cmp` would receive a `directiveDefs` array:\n \n-The emit of a file is the most expensive part of TypeScript/Angular compilation, so skipping emits when they are not necessary is one of the most valuable things the compiler can do to improve incremental build performance.\n+```typescript=\n+// cmp.js\n+import * as i1 from './dir';\n \n-## The two dependency graphs\n+export class Cmp {\n+  static cmp = defineComponent({\n+    ...\n+    directiveDefs: [i1.Dir],\n+  });\n+}\n+```\n \n-For both of the above optimizations, ngtsc makes use of dependency information extracted from the program. But these usages are subtly different.\n+If `Dir`'s selector were to change to `[other]` in an incremental step, it might no longer\n+match `Cmp`'s template, in which case `cmp.js` would need to be re-emitted.\n \n-To reuse previous analyses, ngtsc uses the _prior_ compilation's dependency graph, plus the information about which files have changed, to determine whether it's safe to reuse the prior compilation's work.\n+### SemanticSymbols\n \n-To skip emit, ngtsc uses the _current_ compilation's dependency graph, coupled with the information about which files have changed since the last successful build, to determine the set of outputs that need to be re-emitted.\n+For each decorated class being processed, the compiler creates a `SemanticSymbol` representing the\n+data regarding that class that's involved in these \"indirect\" relationships. During the\n+compiler's `resolve` phase, these `SemanticSymbol`s are connected together to form a \"semantic\n+dependency graph\". Two classes of data are recorded:\n \n-# How does incremental compilation work?\n+* Information about the public shape API of the class.\n \n-The initial compilation is no different from a standalone compilation; the compiler is unaware that incremental compilation will be utilized.\n+For example, directives have a public API which includes their selector, any inputs or outputs, and\n+their `exportAs` name if any.\n \n-When an `NgtscProgram` is created for a _subsequent_ compilation, it is initialized with the `NgtscProgram` from the previous compilation. It is therefore able to take advantage of any information present in the previous compilation to optimize the next one.\n+* Information about the emit shape of the class, including any dependencies on\n+  other `SemanticSymbol`s.\n \n-This information is leveraged in two major ways:\n+This information allows the compiler to determine which classes have been semantically affected by\n+other changes in the program (and therefore need to be re-emitted) according to a simple algorithm:\n \n-1) The previous `ts.Program` itself is used to create the next `ts.Program`, allowing TypeScript internally to leverage information from the previous compile in much the same way.\n+1. Determine the set of `SemanticSymbol`s which have had their public API changed.\n+2. For each `SemanticSymbol`, determine if its emit shape was affected by any of the public API\n+   changes (that is, if it depends on a symbol with public API changes).\n \n-2) An `IncrementalDriver` instance is constructed from the old and new `ts.Program`s, and the previous program's `IncrementalDriver`.\n+### Determination of public API changes\n \n-The compiler then proceeds normally, using the `IncrementalDriver` to manage the reuse of any pertinent information while processing the new program. As a part of this process, the compiler (again) maps out all of the dependencies between files.\n+The first step of this algorithm is to determine, for each `SemanticSymbol`, if its public API has\n+been affected. Doing this requires knowing which `SemanticSymbol` in the previous program\n+corresponds to the current version of the symbol. There are two ways that symbols can be \"matched\":\n \n-## Determination of files to emit\n+* The old and new symbols share the same `ts.ClassDeclaration`.\n \n-The principle question the incremental build system must answer is \"which TS files need to be emitted for a given compilation?\"\n+This is true whenever the `ts.SourceFile` declaring the class has not changed between the old and\n+new programs. The public API of the symbol may still have changed (such as when a directive's\n+selector is determined by a constant imported from another file, like in one of the examples above).\n+But if the declaration file itself has not changed, then the previous symbol can be directly found\n+this way.\n \n-To determine whether an individual TS file needs to be emitted, the compiler must determine 3 things about the file:\n+* By its unique path and name.\n \n-1. Have its contents changed since the last time it was emitted?\n-2. Has any resource file that the TS file depends on (like an HTML template) changed since the last time it was emitted?\n-3. Have any of the dependencies of the TS file changed since the last time it was emitted?\n+If the file _has_ changed, then symbols can be located by their declaration path plus their name, if\n+they have a name that's guaranteed to be unique. Currently, this means that the classes are declared\n+at the top level of the source file, so their names are in the module's scope. If this is the case,\n+then a symbol can be matched to its ancestor even if the declaration itself has changed in the\n+meantime. Note that there is no guarantee the symbol will be of the same type - an incremental step\n+may change a directive into a component, or even into a pipe or injectable.\n \n-If the answer to any of these questions is yes, then the TS file needs to be re-emitted.\n+Once a previous symbol is located, its public API can be compared against the current version of the\n+symbol. Symbols without a valid ancestor are assumed to have changed in their public API.\n \n-## Tracking of changes\n+The compiler processes all `SemanticSymbol`s and determines the `Set` of them which have experienced\n+public API changes. In the example above, this `Set` would include the `DirectiveSymbol` for `Dir`,\n+since its selector would have changed.\n \n-On every invocation, the compiler receives (or can easily determine) several pieces of information:\n+### Determination of emit requirements\n \n-* The set of `ts.SourceFile`s that have changed since the last invocation.\n-* The set of resources (`.html` files) that have changed since the last invocation.\n+For each potential output file, the compiler then looks at all declared `SemanticSymbol`s and uses\n+their ancestor symbol (if present) as well as the `Set` of public API changes to make a\n+determination if that file needs be emitted.\n \n-With this information, the compiler can perform rebuild optimizations:\n+In the case of a `ComponentSymbol`, for example, the symbol tracks the dependencies of the component\n+which will go into the `directiveDefs` array. If that array is different, the component needs to be\n+re-emitted. Even if the same directives are referenced, if one of those directives has changed in\n+its public API, the emitted output (especially when generating prelink library code) may be\n+affected, and the component needs to be re-emitted.\n \n-1. The compiler uses the last good compilation's dependency graph to determine which parts of its analysis work can be reused, and an initial set of files which need to be re-emitted.\n-2. The compiler analyzes the rest of the program and generates an updated dependency graph, which describes the relationships between files in the program as they are currently.\n-3. Based on this graph, the compiler can make a final determination for each TS file whether it needs to be re-emitted or can safely be skipped. This produces a set called `pendingEmit` of every file which requires a re-emit.\n-4. The compiler cycles through the files and emits those which are necessary, removing them from `pendingEmit`.\n+### `SemanticReference`s\n \n-Theoretically, after this process `pendingEmit` should be empty. As a precaution against errors which might happen in the future, `pendingEmit` is also passed into future compilations, so any files which previously were determined to need an emit (but have not been successfully produced yet) will be retried on subsequent compilations. This is mostly relevant if a client of `ngtsc` attempts to implement emit-on-error functionality.\n+`ComponentSymbol`s track their dependencies via an intermediate type, a `SemanticReference`. Such\n+references track not only the `SemanticSymbol` of the dependency, but also the name by which it was\n+imported previously. Even if a dependency's identity and public API remain the same, changes in how\n+it was exported can affect the import which needs to be emitted within the component consuming it,\n+and thus would require a re-emit.\n \n-However, normally the execution of these steps requires a correct input program. In the presence of TypeScript errors, the compiler cannot perform this process. It might take many invocations for the user to fix all their TypeScript errors and reach a compilation that can be analyzed.\n+## Reuse of template type-checking results\n \n-As a result, the compiler must accumulate the set of these changes (to source files and resource files) from build to build until analysis can succeed.\n+Since type-checking block (TCB) generation for template type-checking is a form of\n+emit, `SemanticSymbol`s also track the type-checking shape of decorated classes. This includes any\n+data which is not public API, but upon which the TCB generation for components might depend. Such\n+data includes:\n \n-This accumulation happens via a type called `BuildState`. This type is a union of two possible states.\n+* Type-checking API shape from any base classes, since TCB generation uses information from the full\n+  inheritance chain of a directive/pipe.\n+* The generic signature shape of the class.\n+* Private field names for `@Input`s and `@Output`s.\n \n-### `PendingBuildState`\n+Using a similar algorithm to the `emit` optimization, the compiler can determine which files need\n+their type-checking code regenerated, and which can continue to use TCB code from the previous\n+program, even if some dependencies have unrelated changes.\n \n-This is the initial state of any build, and the final state of any unsuccessful build. This state tracks both `pendingEmit` files from the previous program as well as any source or resource files which have changed since the last successful analysis.\n+## Unsuccessful compilation attempts\n \n-If a new build starts and inherits from a failed build, it will merge the failed build's `PendingBuildState` into its own, including the sets of changed files.\n+Often, incremental compilations will fail. The user's input program may contain incomplete changes,\n+typos, semantic errors, or other problems which prevent the compiler from fully analyzing or\n+emitting it. Such errors create problems for incremental build correctness, as the compiler relies\n+on information extracted from the previous program to correctly optimize the next compilation. If\n+the previous compilation failed, such information may be unreliable.\n \n-### `AnalyzedBuildState`\n+In theory, the compiler could simply not perform incremental compilation on top of a broken build,\n+and assume that it must redo all analysis and re-emit all files, but this would result in\n+devestatingly poor performance for common developer workflows that rely on automatically running\n+builds and/or tests on every change. The compiler must deal with such scenarios more gracefully.\n \n-After analysis is successfully performed, the compiler uses its dependency graph to evaluate the impact of any accumulated changes from the `PendingBuildState`, and updates `pendingEmit` with all of the pending files. At this point, the compiler transitions from a `PendingBuildState` to an `AnalyzedBuildState`, which only tracks `pendingEmit`. In `AnalyzedBuildState` this set is complete, and the raw changes can be forgotten.\n+ngtsc solves this problem by always performing its incremental steps from a \"last known good\"\n+compilation. Thus, if compilation A succeeds, and a subsequent compilation B fails, compilation C\n+will begin using the state of compilation A as a starting point. This requires tracking of two\n+important pieces of state:\n \n-If a new build is started after a successful build, only `pendingEmit` from the `AnalyzedBuildState` needs to be merged into the new build's `PendingBuildState`.\n+* Reusable information, such as analysis results, from the last known good compilation.\n+* The accumulated set of files which have physically changed since the last known good compilation.\n \n-## Component to NgModule dependencies\n-\n-The dependency of a component on its NgModule is slightly problematic, because its arrow is in the opposite direction of the source dependency (which is from NgModule to the component, via `declarations`). This creates a scenario where, if the NgModule is changed to no longer include the component, the component still needs to be re-emitted because the module has changed.\n-\n-This is one of very few cases where `pendingEmit` must be populated with the logical changes from the previous program (those files determined to be changed in step 1 under \"Tracking of changes\" above), and cannot simply be created from the current dependency graph.\n-\n-# What optimizations are possible in the future?\n-\n-There is plenty of room for improvement here, with diminishing returns for the work involved.\n-\n-## Semantic dependency tracking\n-\n-Currently the compiler tracks dependencies only at the file level, and will re-emit dependent files if they _may_ have been affected by a change. Often times a change though does _not_ require updates to dependent files.\n-\n-For example, today a component's `NgModule` and all of the other components which consume that module's export scope are considered to depend on the component file itself. If the component's template changes, this triggers a re-emit of not only the component's file, but the entire chain of its NgModule and that module's export scope. This happens even though the template of a component _does not have any impact_ on any components which consume it - these other emits are deeply unnecessary.\n-\n-In contrast, if the component's _selector_ changes, then all those dependent files do need to be updated since their `directiveDefs` might have changed.\n-\n-Currently the compiler does not distinguish these two cases, and conservatively always re-emits the entire NgModule chain. It would be possible to break the dependency graph down into finer-grained nodes and distinguish between updates that affect the component, vs updates that affect its dependents. This would be a huge win, but is exceedingly complex.\n-\n-## Skipping template type-checking\n-\n-Under ideal conditions, after an initial template type-checking program is created, it may be possible to reuse it for emit _and_ type-checking in subsequent builds. This would be a pretty advanced optimization but would save creation of a second `ts.Program` on each valid rebuild.\n+Using this information, ngtsc is able to \"forget\" about the intermediate failed attempts and begin\n+each new compilation as if it were a single step from the last successful build. It can then ensure\n+complete correctness of its reuse optimization, since it has reliable data extracted from the \"\n+previous\" successful build."
        },
        {
            "sha": "0f3ca342589495a0071f243bf6b8b851e069b984",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/api.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 16,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fapi.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -49,22 +49,6 @@ export interface DependencyTracker<T extends {fileName: string} = ts.SourceFile>\n    */\n   addResourceDependency(from: T, on: AbsoluteFsPath): void;\n \n-  /**\n-   * Record that the file `from` depends on the file `on` as well as `on`'s direct dependencies.\n-   *\n-   * This operation is reified immediately, so if future dependencies are added to `on` they will\n-   * not automatically be added to `from`.\n-   */\n-  addTransitiveDependency(from: T, on: T): void;\n-\n-  /**\n-   * Record that the file `from` depends on the resource dependencies of `resourcesOf`.\n-   *\n-   * This operation is reified immediately, so if future resource dependencies are added to\n-   * `resourcesOf` they will not automatically be added to `from`.\n-   */\n-  addTransitiveResources(from: T, resourcesOf: T): void;\n-\n   /**\n    * Record that the given file contains unresolvable dependencies.\n    *"
        },
        {
            "sha": "65b262b6b7d5dab802346240b32ab0323961c21a",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/semantic_graph/BUILD.bazel",
            "status": "added",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsemantic_graph%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsemantic_graph%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsemantic_graph%2FBUILD.bazel?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -0,0 +1,16 @@\n+load(\"//tools:defaults.bzl\", \"ts_library\")\n+\n+package(default_visibility = [\"//visibility:public\"])\n+\n+ts_library(\n+    name = \"semantic_graph\",\n+    srcs = [\"index.ts\"] + glob([\n+        \"src/**/*.ts\",\n+    ]),\n+    deps = [\n+        \"//packages/compiler\",\n+        \"//packages/compiler-cli/src/ngtsc/file_system\",\n+        \"//packages/compiler-cli/src/ngtsc/reflection\",\n+        \"@npm//typescript\",\n+    ],\n+)"
        },
        {
            "sha": "5bf44115596a2f1d075479fa74b655879b8907da",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/semantic_graph/index.ts",
            "status": "added",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsemantic_graph%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsemantic_graph%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsemantic_graph%2Findex.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -0,0 +1,12 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+export {SemanticReference, SemanticSymbol} from './src/api';\n+export {SemanticDepGraph, SemanticDepGraphUpdater} from './src/graph';\n+export {areTypeParametersEqual, extractSemanticTypeParameters, SemanticTypeParameter} from './src/type_parameters';\n+export {isArrayEqual, isReferenceEqual, isSetEqual, isSymbolEqual} from './src/util';"
        },
        {
            "sha": "8214f15446bc703cda4e17cc21cc1b634284e4ad",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/api.ts",
            "status": "added",
            "additions": 127,
            "deletions": 0,
            "changes": 127,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsemantic_graph%2Fsrc%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsemantic_graph%2Fsrc%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsemantic_graph%2Fsrc%2Fapi.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -0,0 +1,127 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import * as ts from 'typescript';\n+\n+import {absoluteFromSourceFile, AbsoluteFsPath} from '../../../file_system';\n+import {ClassDeclaration} from '../../../reflection';\n+\n+/**\n+ * Represents a symbol that is recognizable across incremental rebuilds, which enables the captured\n+ * metadata to be compared to the prior compilation. This allows for semantic understanding of\n+ * the changes that have been made in a rebuild, which potentially enables more reuse of work\n+ * from the prior compilation.\n+ */\n+export abstract class SemanticSymbol {\n+  /**\n+   * The path of the file that declares this symbol.\n+   */\n+  public readonly path: AbsoluteFsPath;\n+\n+  /**\n+   * The identifier of this symbol, or null if no identifier could be determined. It should\n+   * uniquely identify the symbol relative to `file`. This is typically just the name of a\n+   * top-level class declaration, as that uniquely identifies the class within the file.\n+   *\n+   * If the identifier is null, then this symbol cannot be recognized across rebuilds. In that\n+   * case, the symbol is always assumed to have semantically changed to guarantee a proper\n+   * rebuild.\n+   */\n+  public readonly identifier: string|null;\n+\n+  constructor(\n+      /**\n+       * The declaration for this symbol.\n+       */\n+      public readonly decl: ClassDeclaration,\n+  ) {\n+    this.path = absoluteFromSourceFile(decl.getSourceFile());\n+    this.identifier = getSymbolIdentifier(decl);\n+  }\n+\n+  /**\n+   * Allows the symbol to be compared to the equivalent symbol in the previous compilation. The\n+   * return value indicates whether the symbol has been changed in a way such that its public API\n+   * is affected.\n+   *\n+   * This method determines whether a change to _this_ symbol require the symbols that\n+   * use to this symbol to be re-emitted.\n+   *\n+   * Note: `previousSymbol` is obtained from the most recently succeeded compilation. Symbols of\n+   * failed compilations are never provided.\n+   *\n+   * @param previousSymbol The symbol from a prior compilation.\n+   */\n+  abstract isPublicApiAffected(previousSymbol: SemanticSymbol): boolean;\n+\n+  /**\n+   * Allows the symbol to determine whether its emit is affected. The equivalent symbol from a prior\n+   * build is given, in addition to the set of symbols of which the public API has changed.\n+   *\n+   * This method determines whether a change to _other_ symbols, i.e. those present in\n+   * `publicApiAffected`, should cause _this_ symbol to be re-emitted.\n+   *\n+   * @param previousSymbol The equivalent symbol from a prior compilation. Note that it may be a\n+   * different type of symbol, if e.g. a Component was changed into a Directive with the same name.\n+   * @param publicApiAffected The set of symbols of which the public API has changed.\n+   */\n+  isEmitAffected?(previousSymbol: SemanticSymbol, publicApiAffected: Set<SemanticSymbol>): boolean;\n+\n+  /**\n+   * Similar to `isPublicApiAffected`, but here equivalent symbol from a prior compilation needs\n+   * to be compared to see if the type-check block of components that use this symbol is affected.\n+   *\n+   * This method determines whether a change to _this_ symbol require the symbols that\n+   * use to this symbol to have their type-check block regenerated.\n+   *\n+   * Note: `previousSymbol` is obtained from the most recently succeeded compilation. Symbols of\n+   * failed compilations are never provided.\n+   *\n+   * @param previousSymbol The symbol from a prior compilation.\n+   */\n+  abstract isTypeCheckApiAffected(previousSymbol: SemanticSymbol): boolean;\n+\n+  /**\n+   * Similar to `isEmitAffected`, but focused on the type-check block of this symbol. This method\n+   * determines whether a change to _other_ symbols, i.e. those present in `typeCheckApiAffected`,\n+   * should cause _this_ symbol's type-check block to be regenerated.\n+   *\n+   * @param previousSymbol The equivalent symbol from a prior compilation. Note that it may be a\n+   * different type of symbol, if e.g. a Component was changed into a Directive with the same name.\n+   * @param typeCheckApiAffected The set of symbols of which the type-check API has changed.\n+   */\n+  isTypeCheckBlockAffected?\n+      (previousSymbol: SemanticSymbol, typeCheckApiAffected: Set<SemanticSymbol>): boolean;\n+}\n+\n+/**\n+ * Represents a reference to a semantic symbol that has been emitted into a source file. The\n+ * reference may refer to the symbol using a different name than the semantic symbol's declared\n+ * name, e.g. in case a re-export under a different name was chosen by a reference emitter.\n+ * Consequently, to know that an emitted reference is still valid not only requires that the\n+ * semantic symbol is still valid, but also that the path by which the symbol is imported has not\n+ * changed.\n+ */\n+export interface SemanticReference {\n+  symbol: SemanticSymbol;\n+\n+  /**\n+   * The path by which the symbol has been referenced.\n+   */\n+  importPath: string|null;\n+}\n+\n+function getSymbolIdentifier(decl: ClassDeclaration): string|null {\n+  if (!ts.isSourceFile(decl.parent)) {\n+    return null;\n+  }\n+\n+  // If this is a top-level class declaration, the class name is used as unique identifier.\n+  // Other scenarios are currently not supported and causes the symbol not to be identified\n+  // across rebuilds, unless the declaration node has not changed.\n+  return decl.name.text;\n+}"
        },
        {
            "sha": "0c62c8b0d55c7ac729f06e56e443d9b789605028",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/graph.ts",
            "status": "added",
            "additions": 281,
            "deletions": 0,
            "changes": 281,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsemantic_graph%2Fsrc%2Fgraph.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsemantic_graph%2Fsrc%2Fgraph.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsemantic_graph%2Fsrc%2Fgraph.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -0,0 +1,281 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {Expression, ExternalExpr} from '@angular/compiler';\n+import {AbsoluteFsPath} from '../../../file_system';\n+import {ClassDeclaration} from '../../../reflection';\n+import {SemanticReference, SemanticSymbol} from './api';\n+\n+export interface SemanticDependencyResult {\n+  /**\n+   * The files that need to be re-emitted.\n+   */\n+  needsEmit: Set<AbsoluteFsPath>;\n+\n+  /**\n+   * The files for which the type-check block should be regenerated.\n+   */\n+  needsTypeCheckEmit: Set<AbsoluteFsPath>;\n+\n+  /**\n+   * The newly built graph that represents the current compilation.\n+   */\n+  newGraph: SemanticDepGraph;\n+}\n+\n+/**\n+ * Represents a declaration for which no semantic symbol has been registered. For example,\n+ * declarations from external dependencies have not been explicitly registered and are represented\n+ * by this symbol. This allows the unresolved symbol to still be compared to a symbol from a prior\n+ * compilation.\n+ */\n+class OpaqueSymbol extends SemanticSymbol {\n+  isPublicApiAffected(): false {\n+    return false;\n+  }\n+\n+  isTypeCheckApiAffected(): false {\n+    return false;\n+  }\n+}\n+\n+/**\n+ * The semantic dependency graph of a single compilation.\n+ */\n+export class SemanticDepGraph {\n+  readonly files = new Map<AbsoluteFsPath, Map<string, SemanticSymbol>>();\n+  readonly symbolByDecl = new Map<ClassDeclaration, SemanticSymbol>();\n+\n+  /**\n+   * Registers a symbol in the graph. The symbol is given a unique identifier if possible, such that\n+   * its equivalent symbol can be obtained from a prior graph even if its declaration node has\n+   * changed across rebuilds. Symbols without an identifier are only able to find themselves in a\n+   * prior graph if their declaration node is identical.\n+   */\n+  registerSymbol(symbol: SemanticSymbol): void {\n+    this.symbolByDecl.set(symbol.decl, symbol);\n+\n+    if (symbol.identifier !== null) {\n+      // If the symbol has a unique identifier, record it in the file that declares it. This enables\n+      // the symbol to be requested by its unique name.\n+      if (!this.files.has(symbol.path)) {\n+        this.files.set(symbol.path, new Map<string, SemanticSymbol>());\n+      }\n+      this.files.get(symbol.path)!.set(symbol.identifier, symbol);\n+    }\n+  }\n+\n+  /**\n+   * Attempts to resolve a symbol in this graph that represents the given symbol from another graph.\n+   * If no matching symbol could be found, null is returned.\n+   *\n+   * @param symbol The symbol from another graph for which its equivalent in this graph should be\n+   * found.\n+   */\n+  getEquivalentSymbol(symbol: SemanticSymbol): SemanticSymbol|null {\n+    // First lookup the symbol by its declaration. It is typical for the declaration to not have\n+    // changed across rebuilds, so this is likely to find the symbol. Using the declaration also\n+    // allows to diff symbols for which no unique identifier could be determined.\n+    let previousSymbol = this.getSymbolByDecl(symbol.decl);\n+    if (previousSymbol === null && symbol.identifier !== null) {\n+      // The declaration could not be resolved to a symbol in a prior compilation, which may\n+      // happen because the file containing the declaration has changed. In that case we want to\n+      // lookup the symbol based on its unique identifier, as that allows us to still compare the\n+      // changed declaration to the prior compilation.\n+      previousSymbol = this.getSymbolByName(symbol.path, symbol.identifier);\n+    }\n+\n+    return previousSymbol;\n+  }\n+\n+  /**\n+   * Attempts to find the symbol by its identifier.\n+   */\n+  private getSymbolByName(path: AbsoluteFsPath, identifier: string): SemanticSymbol|null {\n+    if (!this.files.has(path)) {\n+      return null;\n+    }\n+    const file = this.files.get(path)!;\n+    if (!file.has(identifier)) {\n+      return null;\n+    }\n+    return file.get(identifier)!;\n+  }\n+\n+  /**\n+   * Attempts to resolve the declaration to its semantic symbol.\n+   */\n+  getSymbolByDecl(decl: ClassDeclaration): SemanticSymbol|null {\n+    if (!this.symbolByDecl.has(decl)) {\n+      return null;\n+    }\n+    return this.symbolByDecl.get(decl)!;\n+  }\n+}\n+\n+/**\n+ * Implements the logic to go from a previous dependency graph to a new one, along with information\n+ * on which files have been affected.\n+ */\n+export class SemanticDepGraphUpdater {\n+  private readonly newGraph = new SemanticDepGraph();\n+\n+  /**\n+   * Contains opaque symbols that were created for declarations for which there was no symbol\n+   * registered, which happens for e.g. external declarations.\n+   */\n+  private readonly opaqueSymbols = new Map<ClassDeclaration, OpaqueSymbol>();\n+\n+  constructor(\n+      /**\n+       * The semantic dependency graph of the most recently succeeded compilation, or null if this\n+       * is the initial build.\n+       */\n+      private priorGraph: SemanticDepGraph|null) {}\n+\n+  /**\n+   * Registers the symbol in the new graph that is being created.\n+   */\n+  registerSymbol(symbol: SemanticSymbol): void {\n+    this.newGraph.registerSymbol(symbol);\n+  }\n+\n+  /**\n+   * Takes all facts that have been gathered to create a new semantic dependency graph. In this\n+   * process, the semantic impact of the changes is determined which results in a set of files that\n+   * need to be emitted and/or type-checked.\n+   */\n+  finalize(): SemanticDependencyResult {\n+    if (this.priorGraph === null) {\n+      // If no prior dependency graph is available then this was the initial build, in which case\n+      // we don't need to determine the semantic impact as everything is already considered\n+      // logically changed.\n+      return {\n+        needsEmit: new Set<AbsoluteFsPath>(),\n+        needsTypeCheckEmit: new Set<AbsoluteFsPath>(),\n+        newGraph: this.newGraph,\n+      };\n+    }\n+\n+    const needsEmit = this.determineInvalidatedFiles(this.priorGraph);\n+    const needsTypeCheckEmit = this.determineInvalidatedTypeCheckFiles(this.priorGraph);\n+    return {\n+      needsEmit,\n+      needsTypeCheckEmit,\n+      newGraph: this.newGraph,\n+    };\n+  }\n+\n+  private determineInvalidatedFiles(priorGraph: SemanticDepGraph): Set<AbsoluteFsPath> {\n+    const isPublicApiAffected = new Set<SemanticSymbol>();\n+\n+    // The first phase is to collect all symbols which have their public API affected. Any symbols\n+    // that cannot be matched up with a symbol from the prior graph are considered affected.\n+    for (const symbol of this.newGraph.symbolByDecl.values()) {\n+      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n+      if (previousSymbol === null || symbol.isPublicApiAffected(previousSymbol)) {\n+        isPublicApiAffected.add(symbol);\n+      }\n+    }\n+\n+    // The second phase is to find all symbols for which the emit result is affected, either because\n+    // their used declarations have changed or any of those used declarations has had its public API\n+    // affected as determined in the first phase.\n+    const needsEmit = new Set<AbsoluteFsPath>();\n+    for (const symbol of this.newGraph.symbolByDecl.values()) {\n+      if (symbol.isEmitAffected === undefined) {\n+        continue;\n+      }\n+\n+      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n+      if (previousSymbol === null || symbol.isEmitAffected(previousSymbol, isPublicApiAffected)) {\n+        needsEmit.add(symbol.path);\n+      }\n+    }\n+\n+    return needsEmit;\n+  }\n+\n+  private determineInvalidatedTypeCheckFiles(priorGraph: SemanticDepGraph): Set<AbsoluteFsPath> {\n+    const isTypeCheckApiAffected = new Set<SemanticSymbol>();\n+\n+    // The first phase is to collect all symbols which have their public API affected. Any symbols\n+    // that cannot be matched up with a symbol from the prior graph are considered affected.\n+    for (const symbol of this.newGraph.symbolByDecl.values()) {\n+      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n+      if (previousSymbol === null || symbol.isTypeCheckApiAffected(previousSymbol)) {\n+        isTypeCheckApiAffected.add(symbol);\n+      }\n+    }\n+\n+    // The second phase is to find all symbols for which the emit result is affected, either because\n+    // their used declarations have changed or any of those used declarations has had its public API\n+    // affected as determined in the first phase.\n+    const needsTypeCheckEmit = new Set<AbsoluteFsPath>();\n+    for (const symbol of this.newGraph.symbolByDecl.values()) {\n+      if (symbol.isTypeCheckBlockAffected === undefined) {\n+        continue;\n+      }\n+\n+      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n+      if (previousSymbol === null ||\n+          symbol.isTypeCheckBlockAffected(previousSymbol, isTypeCheckApiAffected)) {\n+        needsTypeCheckEmit.add(symbol.path);\n+      }\n+    }\n+\n+    return needsTypeCheckEmit;\n+  }\n+\n+  /**\n+   * Creates a `SemanticReference` for the reference to `decl` using the expression `expr`. See\n+   * the documentation of `SemanticReference` for details.\n+   */\n+  getSemanticReference(decl: ClassDeclaration, expr: Expression): SemanticReference {\n+    return {\n+      symbol: this.getSymbol(decl),\n+      importPath: getImportPath(expr),\n+    };\n+  }\n+\n+  /**\n+   * Gets the `SemanticSymbol` that was registered for `decl` during the current compilation, or\n+   * returns an opaque symbol that represents `decl`.\n+   */\n+  getSymbol(decl: ClassDeclaration): SemanticSymbol {\n+    const symbol = this.newGraph.getSymbolByDecl(decl);\n+    if (symbol === null) {\n+      // No symbol has been recorded for the provided declaration, which would be the case if the\n+      // declaration is external. Return an opaque symbol in that case, to allow the external\n+      // declaration to be compared to a prior compilation.\n+      return this.getOpaqueSymbol(decl);\n+    }\n+    return symbol;\n+  }\n+\n+  /**\n+   * Gets or creates an `OpaqueSymbol` for the provided class declaration.\n+   */\n+  private getOpaqueSymbol(decl: ClassDeclaration): OpaqueSymbol {\n+    if (this.opaqueSymbols.has(decl)) {\n+      return this.opaqueSymbols.get(decl)!;\n+    }\n+\n+    const symbol = new OpaqueSymbol(decl);\n+    this.opaqueSymbols.set(decl, symbol);\n+    return symbol;\n+  }\n+}\n+\n+function getImportPath(expr: Expression): string|null {\n+  if (expr instanceof ExternalExpr) {\n+    return `${expr.value.moduleName}\\$${expr.value.name}`;\n+  } else {\n+    return null;\n+  }\n+}"
        },
        {
            "sha": "c77e9d2e68395576e8f08ccaaf444ee5b6a6380e",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/type_parameters.ts",
            "status": "added",
            "additions": 70,
            "deletions": 0,
            "changes": 70,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsemantic_graph%2Fsrc%2Ftype_parameters.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsemantic_graph%2Fsrc%2Ftype_parameters.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsemantic_graph%2Fsrc%2Ftype_parameters.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -0,0 +1,70 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import * as ts from 'typescript';\n+\n+import {ClassDeclaration} from '../../../reflection';\n+import {isArrayEqual} from './util';\n+\n+/**\n+ * Describes a generic type parameter of a semantic symbol. A class declaration with type parameters\n+ * needs special consideration in certain contexts. For example, template type-check blocks may\n+ * contain type constructors of used directives which include the type parameters of the directive.\n+ * As a consequence, if a change is made that affects the type parameters of said directive, any\n+ * template type-check blocks that use the directive need to be regenerated.\n+ *\n+ * This type represents a single generic type parameter. It currently only tracks whether the\n+ * type parameter has a constraint, i.e. has an `extends` clause. When a constraint is present, we\n+ * currently assume that the type parameter is affected in each incremental rebuild; proving that\n+ * a type parameter with constraint is not affected is non-trivial as it requires full semantic\n+ * understanding of the type constraint.\n+ */\n+export interface SemanticTypeParameter {\n+  /**\n+   * Whether a type constraint, i.e. an `extends` clause is present on the type parameter.\n+   */\n+  hasGenericTypeBound: boolean;\n+}\n+\n+/**\n+ * Converts the type parameters of the given class into their semantic representation. If the class\n+ * does not have any type parameters, then `null` is returned.\n+ */\n+export function extractSemanticTypeParameters(node: ClassDeclaration): SemanticTypeParameter[]|\n+    null {\n+  if (!ts.isClassDeclaration(node) || node.typeParameters === undefined) {\n+    return null;\n+  }\n+\n+  return node.typeParameters.map(\n+      typeParam => ({hasGenericTypeBound: typeParam.constraint !== undefined}));\n+}\n+\n+/**\n+ * Compares the list of type parameters to determine if they can be considered equal.\n+ */\n+export function areTypeParametersEqual(\n+    current: SemanticTypeParameter[]|null, previous: SemanticTypeParameter[]|null): boolean {\n+  // First compare all type parameters one-to-one; any differences mean that the list of type\n+  // parameters has changed.\n+  if (!isArrayEqual(current, previous, isTypeParameterEqual)) {\n+    return false;\n+  }\n+\n+  // If there is a current list of type parameters and if any of them has a generic type constraint,\n+  // then the meaning of that type parameter may have changed without us being aware; as such we\n+  // have to assume that the type parameters have in fact changed.\n+  if (current !== null && current.some(typeParam => typeParam.hasGenericTypeBound)) {\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+function isTypeParameterEqual(a: SemanticTypeParameter, b: SemanticTypeParameter): boolean {\n+  return a.hasGenericTypeBound === b.hasGenericTypeBound;\n+}"
        },
        {
            "sha": "2f2651005459159a061173d60f5a85b7aa0b8b4d",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/util.ts",
            "status": "added",
            "additions": 93,
            "deletions": 0,
            "changes": 93,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsemantic_graph%2Fsrc%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsemantic_graph%2Fsrc%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsemantic_graph%2Fsrc%2Futil.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -0,0 +1,93 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {SemanticReference, SemanticSymbol} from './api';\n+\n+/**\n+ * Determines whether the provided symbols represent the same declaration.\n+ */\n+export function isSymbolEqual(a: SemanticSymbol, b: SemanticSymbol): boolean {\n+  if (a.decl === b.decl) {\n+    // If the declaration is identical then it must represent the same symbol.\n+    return true;\n+  }\n+\n+  if (a.identifier === null || b.identifier === null) {\n+    // Unidentifiable symbols are assumed to be different.\n+    return false;\n+  }\n+\n+  return a.path === b.path && a.identifier === b.identifier;\n+}\n+\n+/**\n+ * Determines whether the provided references to a semantic symbol are still equal, i.e. represent\n+ * the same symbol and are imported by the same path.\n+ */\n+export function isReferenceEqual(a: SemanticReference, b: SemanticReference): boolean {\n+  if (!isSymbolEqual(a.symbol, b.symbol)) {\n+    // If the reference's target symbols are different, the reference itself is different.\n+    return false;\n+  }\n+\n+  // The reference still corresponds with the same symbol, now check that the path by which it is\n+  // imported has not changed.\n+  return a.importPath === b.importPath;\n+}\n+\n+export function referenceEquality<T>(a: T, b: T): boolean {\n+  return a === b;\n+}\n+\n+/**\n+ * Determines if the provided arrays are equal to each other, using the provided equality tester\n+ * that is called for all entries in the array.\n+ */\n+export function isArrayEqual<T>(\n+    a: readonly T[]|null, b: readonly T[]|null,\n+    equalityTester: (a: T, b: T) => boolean = referenceEquality): boolean {\n+  if (a === null || b === null) {\n+    return a === b;\n+  }\n+\n+  if (a.length !== b.length) {\n+    return false;\n+  }\n+\n+  return !a.some((item, index) => !equalityTester(item, b[index]));\n+}\n+\n+/**\n+ * Determines if the provided sets are equal to each other, using the provided equality tester.\n+ * Sets that only differ in ordering are considered equal.\n+ */\n+export function isSetEqual<T>(\n+    a: ReadonlySet<T>|null, b: ReadonlySet<T>|null,\n+    equalityTester: (a: T, b: T) => boolean = referenceEquality): boolean {\n+  if (a === null || b === null) {\n+    return a === b;\n+  }\n+\n+  if (a.size !== b.size) {\n+    return false;\n+  }\n+\n+  for (const itemA of a) {\n+    let found = false;\n+    for (const itemB of b) {\n+      if (equalityTester(itemA, itemB)) {\n+        found = true;\n+        break;\n+      }\n+    }\n+    if (!found) {\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}"
        },
        {
            "sha": "0dded69344e8db27b2b6c4a98efe8bc150acb6fe",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/src/dependency_tracking.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 24,
            "changes": 24,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fdependency_tracking.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fdependency_tracking.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fdependency_tracking.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -35,24 +35,6 @@ export class FileDependencyGraph<T extends {fileName: string} = ts.SourceFile> i\n     this.nodeFor(from).usesResources.add(resource);\n   }\n \n-  addTransitiveDependency(from: T, on: T): void {\n-    const nodeFrom = this.nodeFor(from);\n-    nodeFrom.dependsOn.add(on.fileName);\n-\n-    const nodeOn = this.nodeFor(on);\n-    for (const dep of nodeOn.dependsOn) {\n-      nodeFrom.dependsOn.add(dep);\n-    }\n-  }\n-\n-  addTransitiveResources(from: T, resourcesOf: T): void {\n-    const nodeFrom = this.nodeFor(from);\n-    const nodeOn = this.nodeFor(resourcesOf);\n-    for (const dep of nodeOn.usesResources) {\n-      nodeFrom.usesResources.add(dep);\n-    }\n-  }\n-\n   recordDependencyAnalysisFailure(file: T): void {\n     this.nodeFor(file).failedAnalysis = true;\n   }\n@@ -63,10 +45,6 @@ export class FileDependencyGraph<T extends {fileName: string} = ts.SourceFile> i\n     return node ? [...node.usesResources] : [];\n   }\n \n-  isStale(sf: T, changedTsPaths: Set<string>, changedResources: Set<AbsoluteFsPath>): boolean {\n-    return isLogicallyChanged(sf, this.nodeFor(sf), changedTsPaths, EMPTY_SET, changedResources);\n-  }\n-\n   /**\n    * Update the current dependency graph from a previous one, incorporating a set of physical\n    * changes.\n@@ -160,5 +138,3 @@ interface FileNode {\n   usesResources: Set<AbsoluteFsPath>;\n   failedAnalysis: boolean;\n }\n-\n-const EMPTY_SET: ReadonlySet<any> = new Set<any>();"
        },
        {
            "sha": "d247aeaa6d7895cc2f01f91419204abbd7c9594e",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/src/state.ts",
            "status": "modified",
            "additions": 62,
            "deletions": 14,
            "changes": 76,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fstate.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fstate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fstate.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -9,9 +9,11 @@\n import * as ts from 'typescript';\n \n import {absoluteFrom, absoluteFromSourceFile, AbsoluteFsPath} from '../../file_system';\n+import {ClassDeclaration} from '../../reflection';\n import {ClassRecord, TraitCompiler} from '../../transform';\n import {FileTypeCheckingData} from '../../typecheck/src/checker';\n import {IncrementalBuild} from '../api';\n+import {SemanticDepGraph, SemanticDepGraphUpdater} from '../semantic_graph';\n \n import {FileDependencyGraph} from './dependency_tracking';\n \n@@ -27,8 +29,8 @@ export class IncrementalDriver implements IncrementalBuild<ClassRecord, FileType\n   private state: BuildState;\n \n   private constructor(\n-      state: PendingBuildState, private allTsFiles: Set<ts.SourceFile>,\n-      readonly depGraph: FileDependencyGraph, private logicalChanges: Set<string>|null) {\n+      state: PendingBuildState, readonly depGraph: FileDependencyGraph,\n+      private logicalChanges: Set<string>|null) {\n     this.state = state;\n   }\n \n@@ -49,14 +51,21 @@ export class IncrementalDriver implements IncrementalBuild<ClassRecord, FileType\n       // this build.\n       state = oldDriver.state;\n     } else {\n+      let priorGraph: SemanticDepGraph|null = null;\n+      if (oldDriver.state.lastGood !== null) {\n+        priorGraph = oldDriver.state.lastGood.semanticDepGraph;\n+      }\n+\n       // The previous build was successfully analyzed. `pendingEmit` is the only state carried\n       // forward into this build.\n       state = {\n         kind: BuildStateKind.Pending,\n         pendingEmit: oldDriver.state.pendingEmit,\n+        pendingTypeCheckEmit: oldDriver.state.pendingTypeCheckEmit,\n         changedResourcePaths: new Set<AbsoluteFsPath>(),\n         changedTsPaths: new Set<string>(),\n         lastGood: oldDriver.state.lastGood,\n+        semanticDepGraphUpdater: new SemanticDepGraphUpdater(priorGraph),\n       };\n     }\n \n@@ -106,6 +115,7 @@ export class IncrementalDriver implements IncrementalBuild<ClassRecord, FileType\n     // The next step is to remove any deleted files from the state.\n     for (const filePath of deletedTsPaths) {\n       state.pendingEmit.delete(filePath);\n+      state.pendingTypeCheckEmit.delete(filePath);\n \n       // Even if the file doesn't exist in the current compilation, it still might have been changed\n       // in a previous one, so delete it from the set of changed TS files, just in case.\n@@ -138,13 +148,13 @@ export class IncrementalDriver implements IncrementalBuild<ClassRecord, FileType\n       // re-emitted.\n       for (const change of logicalChanges) {\n         state.pendingEmit.add(change);\n+        state.pendingTypeCheckEmit.add(change);\n       }\n     }\n \n     // `state` now reflects the initial pending state of the current compilation.\n \n-    return new IncrementalDriver(\n-        state, new Set<ts.SourceFile>(tsOnlyFiles(newProgram)), depGraph, logicalChanges);\n+    return new IncrementalDriver(state, depGraph, logicalChanges);\n   }\n \n   static fresh(program: ts.Program): IncrementalDriver {\n@@ -155,13 +165,21 @@ export class IncrementalDriver implements IncrementalBuild<ClassRecord, FileType\n     const state: PendingBuildState = {\n       kind: BuildStateKind.Pending,\n       pendingEmit: new Set<string>(tsFiles.map(sf => sf.fileName)),\n+      pendingTypeCheckEmit: new Set<string>(tsFiles.map(sf => sf.fileName)),\n       changedResourcePaths: new Set<AbsoluteFsPath>(),\n       changedTsPaths: new Set<string>(),\n       lastGood: null,\n+      semanticDepGraphUpdater: new SemanticDepGraphUpdater(/* priorGraph */ null),\n     };\n \n-    return new IncrementalDriver(\n-        state, new Set(tsFiles), new FileDependencyGraph(), /* logicalChanges */ null);\n+    return new IncrementalDriver(state, new FileDependencyGraph(), /* logicalChanges */ null);\n+  }\n+\n+  getSemanticDepGraphUpdater(): SemanticDepGraphUpdater {\n+    if (this.state.kind !== BuildStateKind.Pending) {\n+      throw new Error('Semantic dependency updater is only available when pending analysis');\n+    }\n+    return this.state.semanticDepGraphUpdater;\n   }\n \n   recordSuccessfulAnalysis(traitCompiler: TraitCompiler): void {\n@@ -170,26 +188,29 @@ export class IncrementalDriver implements IncrementalBuild<ClassRecord, FileType\n       return;\n     }\n \n-    const pendingEmit = this.state.pendingEmit;\n+    const {needsEmit, needsTypeCheckEmit, newGraph} = this.state.semanticDepGraphUpdater.finalize();\n \n-    const state: PendingBuildState = this.state;\n+    const pendingEmit = this.state.pendingEmit;\n+    for (const path of needsEmit) {\n+      pendingEmit.add(path);\n+    }\n \n-    for (const sf of this.allTsFiles) {\n-      if (this.depGraph.isStale(sf, state.changedTsPaths, state.changedResourcePaths)) {\n-        // Something has changed which requires this file be re-emitted.\n-        pendingEmit.add(sf.fileName);\n-      }\n+    const pendingTypeCheckEmit = this.state.pendingTypeCheckEmit;\n+    for (const path of needsTypeCheckEmit) {\n+      pendingTypeCheckEmit.add(path);\n     }\n \n     // Update the state to an `AnalyzedBuildState`.\n     this.state = {\n       kind: BuildStateKind.Analyzed,\n       pendingEmit,\n+      pendingTypeCheckEmit,\n \n       // Since this compilation was successfully analyzed, update the \"last good\" artifacts to the\n       // ones from the current compilation.\n       lastGood: {\n         depGraph: this.depGraph,\n+        semanticDepGraph: newGraph,\n         traitCompiler: traitCompiler,\n         typeCheckingResults: null,\n       },\n@@ -204,6 +225,12 @@ export class IncrementalDriver implements IncrementalBuild<ClassRecord, FileType\n       return;\n     }\n     this.state.lastGood.typeCheckingResults = results;\n+\n+    // Delete the files for which type-check code was generated from the set of pending type-check\n+    // files.\n+    for (const fileName of results.keys()) {\n+      this.state.pendingTypeCheckEmit.delete(fileName);\n+    }\n   }\n \n   recordSuccessfulEmit(sf: ts.SourceFile): void {\n@@ -233,7 +260,7 @@ export class IncrementalDriver implements IncrementalBuild<ClassRecord, FileType\n       return null;\n     }\n \n-    if (this.logicalChanges.has(sf.fileName)) {\n+    if (this.logicalChanges.has(sf.fileName) || this.state.pendingTypeCheckEmit.has(sf.fileName)) {\n       return null;\n     }\n \n@@ -284,6 +311,13 @@ interface BaseBuildState {\n    */\n   pendingEmit: Set<string>;\n \n+  /**\n+   * Similar to `pendingEmit`, but then for representing the set of files for which the type-check\n+   * file should be regenerated. It behaves identically with respect to errored compilations as\n+   * `pendingEmit`.\n+   */\n+  pendingTypeCheckEmit: Set<string>;\n+\n \n   /**\n    * Specific aspects of the last compilation which successfully completed analysis, if any.\n@@ -296,6 +330,14 @@ interface BaseBuildState {\n      */\n     depGraph: FileDependencyGraph;\n \n+    /**\n+     * The semantic dependency graph from the last successfully analyzed build.\n+     *\n+     * This is used to perform in-depth comparison of Angular decorated classes, to determine\n+     * which files have to be re-emitted and/or re-type-checked.\n+     */\n+    semanticDepGraph: SemanticDepGraph;\n+\n     /**\n      * The `TraitCompiler` from the last successfully analyzed build.\n      *\n@@ -333,6 +375,12 @@ interface PendingBuildState extends BaseBuildState {\n    * Set of resource file paths which have changed since the last successfully analyzed build.\n    */\n   changedResourcePaths: Set<AbsoluteFsPath>;\n+\n+  /**\n+   * In a pending state, the semantic dependency graph is available to the compilation to register\n+   * the incremental symbols into.\n+   */\n+  semanticDepGraphUpdater: SemanticDepGraphUpdater;\n }\n \n interface AnalyzedBuildState extends BaseBuildState {"
        },
        {
            "sha": "37d1c56d00cc36108715d0b4b9b548cc320814fc",
            "filename": "packages/compiler-cli/src/ngtsc/partial_evaluator/test/evaluator_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Ftest%2Fevaluator_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Ftest%2Fevaluator_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Ftest%2Fevaluator_spec.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -989,7 +989,5 @@ runInEachFileSystem(() => {\n const fakeDepTracker: DependencyTracker = {\n   addDependency: () => undefined,\n   addResourceDependency: () => undefined,\n-  addTransitiveDependency: () => undefined,\n-  addTransitiveResources: () => undefined,\n   recordDependencyAnalysisFailure: () => undefined,\n };"
        },
        {
            "sha": "5badea3f248a42be4d2953f050adf71f9824fe0c",
            "filename": "packages/compiler-cli/src/ngtsc/scope/src/local.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 24,
            "changes": 24,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fscope%2Fsrc%2Flocal.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fscope%2Fsrc%2Flocal.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fscope%2Fsrc%2Flocal.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -32,16 +32,6 @@ export interface LocalModuleScope extends ExportScope {\n   schemas: SchemaMetadata[];\n }\n \n-/**\n- * Information about the compilation scope of a registered declaration.\n- */\n-export interface CompilationScope extends ScopeData {\n-  /** The declaration whose compilation scope is described here. */\n-  declaration: ClassDeclaration;\n-  /** The declaration of the NgModule that declares this `declaration`. */\n-  ngModule: ClassDeclaration;\n-}\n-\n /**\n  * A registry which collects information about NgModules, Directives, Components, and Pipes which\n  * are local (declared in the ts.Program being compiled), and can produce `LocalModuleScope`s\n@@ -187,20 +177,6 @@ export class LocalModuleScopeRegistry implements MetadataRegistry, ComponentScop\n     }\n   }\n \n-  /**\n-   * Returns a collection of the compilation scope for each registered declaration.\n-   */\n-  getCompilationScopes(): CompilationScope[] {\n-    const scopes: CompilationScope[] = [];\n-    this.declarationToModule.forEach((declData, declaration) => {\n-      const scope = this.getScopeOfModule(declData.ngModule);\n-      if (scope !== null) {\n-        scopes.push({declaration, ngModule: declData.ngModule, ...scope.compilation});\n-      }\n-    });\n-    return scopes;\n-  }\n-\n   private registerDeclarationOfModule(\n       ngModule: ClassDeclaration, decl: Reference<ClassDeclaration>,\n       rawDeclarations: ts.Expression|null): void {"
        },
        {
            "sha": "1ecafaa34f3e60869a88d91b49f8ad071946b3f0",
            "filename": "packages/compiler-cli/src/ngtsc/transform/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2FBUILD.bazel?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -13,6 +13,7 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/diagnostics\",\n         \"//packages/compiler-cli/src/ngtsc/imports\",\n         \"//packages/compiler-cli/src/ngtsc/incremental:api\",\n+        \"//packages/compiler-cli/src/ngtsc/incremental/semantic_graph\",\n         \"//packages/compiler-cli/src/ngtsc/indexer\",\n         \"//packages/compiler-cli/src/ngtsc/modulewithproviders\",\n         \"//packages/compiler-cli/src/ngtsc/perf\","
        },
        {
            "sha": "01054b5f7119d72ced5b5227c77afe645d1ca145",
            "filename": "packages/compiler-cli/src/ngtsc/transform/src/api.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 2,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Fapi.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -10,6 +10,7 @@ import {ConstantPool, Expression, Statement, Type} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {Reexport} from '../../imports';\n+import {SemanticSymbol} from '../../incremental/semantic_graph';\n import {IndexingContext} from '../../indexer';\n import {ClassDeclaration, Decorator} from '../../reflection';\n import {ImportManager} from '../../translator';\n@@ -87,7 +88,7 @@ export enum HandlerFlags {\n  * @param `A` The type of analysis metadata produced by `analyze`.\n  * @param `R` The type of resolution metadata produced by `resolve`.\n  */\n-export interface DecoratorHandler<D, A, R> {\n+export interface DecoratorHandler<D, A, S extends SemanticSymbol|null, R> {\n   readonly name: string;\n \n   /**\n@@ -134,6 +135,20 @@ export interface DecoratorHandler<D, A, R> {\n    */\n   updateResources?(node: ClassDeclaration, analysis: A, resolution: R): void;\n \n+  /**\n+   * Produces a `SemanticSymbol` that represents the class, which is registered into the semantic\n+   * dependency graph. The symbol is used in incremental compilations to let the compiler determine\n+   * how a change to the class affects prior emit results. See the `incremental` target's README for\n+   * details on how this works.\n+   *\n+   * The symbol is passed in to `resolve`, where it can be extended with references into other parts\n+   * of the compilation as needed.\n+   *\n+   * Only primary handlers are allowed to have symbols; handlers with `precedence` other than\n+   * `HandlerPrecedence.PRIMARY` must return a `null` symbol.\n+   */\n+  symbol(node: ClassDeclaration, analysis: Readonly<A>): S;\n+\n   /**\n    * Post-process the analysis of a decorator/class combination and record any necessary information\n    * in the larger compilation.\n@@ -159,7 +174,7 @@ export interface DecoratorHandler<D, A, R> {\n    * `DecoratorHandler` a chance to leverage information from the whole compilation unit to enhance\n    * the `analysis` before the emit phase.\n    */\n-  resolve?(node: ClassDeclaration, analysis: Readonly<A>): ResolveResult<R>;\n+  resolve?(node: ClassDeclaration, analysis: Readonly<A>, symbol: S): ResolveResult<R>;\n \n   typeCheck?\n       (ctx: TypeCheckContext, node: ClassDeclaration, analysis: Readonly<A>,"
        },
        {
            "sha": "d3bae1c54aeaefd8d6c7e98f938c5438c0dd5541",
            "filename": "packages/compiler-cli/src/ngtsc/transform/src/compilation.ts",
            "status": "modified",
            "additions": 39,
            "deletions": 15,
            "changes": 54,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Fcompilation.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Fcompilation.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Fcompilation.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -11,6 +11,7 @@ import * as ts from 'typescript';\n \n import {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\n import {IncrementalBuild} from '../../incremental/api';\n+import {SemanticDepGraphUpdater, SemanticSymbol} from '../../incremental/semantic_graph';\n import {IndexingContext} from '../../indexer';\n import {PerfRecorder} from '../../perf';\n import {ClassDeclaration, DeclarationNode, Decorator, ReflectionHost} from '../../reflection';\n@@ -34,7 +35,7 @@ export interface ClassRecord {\n   /**\n    * All traits which matched on the class.\n    */\n-  traits: Trait<unknown, unknown, unknown>[];\n+  traits: Trait<unknown, unknown, SemanticSymbol|null, unknown>[];\n \n   /**\n    * Meta-diagnostics about the class, which are usually related to whether certain combinations of\n@@ -82,14 +83,16 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n \n   private reexportMap = new Map<string, Map<string, [string, string]>>();\n \n-  private handlersByName = new Map<string, DecoratorHandler<unknown, unknown, unknown>>();\n+  private handlersByName =\n+      new Map<string, DecoratorHandler<unknown, unknown, SemanticSymbol|null, unknown>>();\n \n   constructor(\n-      private handlers: DecoratorHandler<unknown, unknown, unknown>[],\n+      private handlers: DecoratorHandler<unknown, unknown, SemanticSymbol|null, unknown>[],\n       private reflector: ReflectionHost, private perf: PerfRecorder,\n       private incrementalBuild: IncrementalBuild<ClassRecord, unknown>,\n       private compileNonExportedClasses: boolean, private compilationMode: CompilationMode,\n-      private dtsTransforms: DtsTransformRegistry) {\n+      private dtsTransforms: DtsTransformRegistry,\n+      private semanticDepGraphUpdater: SemanticDepGraphUpdater|null) {\n     for (const handler of handlers) {\n       this.handlersByName.set(handler.name, handler);\n     }\n@@ -179,10 +182,12 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n \n     for (const priorTrait of priorRecord.traits) {\n       const handler = this.handlersByName.get(priorTrait.handler.name)!;\n-      let trait: Trait<unknown, unknown, unknown> = Trait.pending(handler, priorTrait.detected);\n+      let trait: Trait<unknown, unknown, SemanticSymbol|null, unknown> =\n+          Trait.pending(handler, priorTrait.detected);\n \n       if (priorTrait.state === TraitState.Analyzed || priorTrait.state === TraitState.Resolved) {\n-        trait = trait.toAnalyzed(priorTrait.analysis, priorTrait.analysisDiagnostics);\n+        const symbol = this.makeSymbolForTrait(handler, record.node, priorTrait.analysis);\n+        trait = trait.toAnalyzed(priorTrait.analysis, priorTrait.analysisDiagnostics, symbol);\n         if (trait.analysis !== null && trait.handler.register !== undefined) {\n           trait.handler.register(record.node, trait.analysis);\n         }\n@@ -202,7 +207,7 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n   }\n \n   private scanClassForTraits(clazz: ClassDeclaration):\n-      PendingTrait<unknown, unknown, unknown>[]|null {\n+      PendingTrait<unknown, unknown, SemanticSymbol|null, unknown>[]|null {\n     if (!this.compileNonExportedClasses && !isExported(clazz)) {\n       return null;\n     }\n@@ -213,9 +218,9 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n   }\n \n   protected detectTraits(clazz: ClassDeclaration, decorators: Decorator[]|null):\n-      PendingTrait<unknown, unknown, unknown>[]|null {\n+      PendingTrait<unknown, unknown, SemanticSymbol|null, unknown>[]|null {\n     let record: ClassRecord|null = this.recordFor(clazz);\n-    let foundTraits: PendingTrait<unknown, unknown, unknown>[] = [];\n+    let foundTraits: PendingTrait<unknown, unknown, SemanticSymbol|null, unknown>[] = [];\n \n     for (const handler of this.handlers) {\n       const result = handler.detect(clazz, decorators);\n@@ -293,6 +298,25 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n     return foundTraits.length > 0 ? foundTraits : null;\n   }\n \n+  private makeSymbolForTrait(\n+      handler: DecoratorHandler<unknown, unknown, SemanticSymbol|null, unknown>,\n+      decl: ClassDeclaration, analysis: Readonly<unknown>|null): SemanticSymbol|null {\n+    if (analysis === null) {\n+      return null;\n+    }\n+    const symbol = handler.symbol(decl, analysis);\n+    if (symbol !== null && this.semanticDepGraphUpdater !== null) {\n+      const isPrimary = handler.precedence === HandlerPrecedence.PRIMARY;\n+      if (!isPrimary) {\n+        throw new Error(\n+            `AssertionError: ${handler.name} returned a symbol but is not a primary handler.`);\n+      }\n+      this.semanticDepGraphUpdater.registerSymbol(symbol);\n+    }\n+\n+    return symbol;\n+  }\n+\n   protected analyzeClass(clazz: ClassDeclaration, preanalyzeQueue: Promise<void>[]|null): void {\n     const traits = this.scanClassForTraits(clazz);\n \n@@ -312,7 +336,7 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n           preanalysis = trait.handler.preanalyze(clazz, trait.detected.metadata) || null;\n         } catch (err) {\n           if (err instanceof FatalDiagnosticError) {\n-            trait.toAnalyzed(null, [err.toDiagnostic()]);\n+            trait.toAnalyzed(null, [err.toDiagnostic()], null);\n             return;\n           } else {\n             throw err;\n@@ -328,7 +352,7 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n   }\n \n   protected analyzeTrait(\n-      clazz: ClassDeclaration, trait: Trait<unknown, unknown, unknown>,\n+      clazz: ClassDeclaration, trait: Trait<unknown, unknown, SemanticSymbol|null, unknown>,\n       flags?: HandlerFlags): void {\n     if (trait.state !== TraitState.Pending) {\n       throw new Error(`Attempt to analyze trait of ${clazz.name.text} in state ${\n@@ -341,18 +365,18 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n       result = trait.handler.analyze(clazz, trait.detected.metadata, flags);\n     } catch (err) {\n       if (err instanceof FatalDiagnosticError) {\n-        trait.toAnalyzed(null, [err.toDiagnostic()]);\n+        trait.toAnalyzed(null, [err.toDiagnostic()], null);\n         return;\n       } else {\n         throw err;\n       }\n     }\n \n+    const symbol = this.makeSymbolForTrait(trait.handler, clazz, result.analysis ?? null);\n     if (result.analysis !== undefined && trait.handler.register !== undefined) {\n       trait.handler.register(clazz, result.analysis);\n     }\n-\n-    trait = trait.toAnalyzed(result.analysis ?? null, result.diagnostics ?? null);\n+    trait = trait.toAnalyzed(result.analysis ?? null, result.diagnostics ?? null, symbol);\n   }\n \n   resolve(): void {\n@@ -384,7 +408,7 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n \n         let result: ResolveResult<unknown>;\n         try {\n-          result = handler.resolve(clazz, trait.analysis as Readonly<unknown>);\n+          result = handler.resolve(clazz, trait.analysis as Readonly<unknown>, trait.symbol);\n         } catch (err) {\n           if (err instanceof FatalDiagnosticError) {\n             trait = trait.toResolved(null, [err.toDiagnostic()]);"
        },
        {
            "sha": "65dc3ce371103a879248fafce886fb59e3de4bb6",
            "filename": "packages/compiler-cli/src/ngtsc/transform/src/trait.ts",
            "status": "modified",
            "additions": 37,
            "deletions": 25,
            "changes": 62,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Ftrait.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Ftrait.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Ftrait.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -7,6 +7,7 @@\n  */\n \n import * as ts from 'typescript';\n+import {SemanticSymbol} from '../../incremental/semantic_graph';\n import {DecoratorHandler, DetectResult} from './api';\n \n export enum TraitState {\n@@ -44,22 +45,23 @@ export enum TraitState {\n  * This not only simplifies the implementation, but ensures traits are monomorphic objects as\n  * they're all just \"views\" in the type system of the same object (which never changes shape).\n  */\n-export type Trait<D, A, R> =\n-    PendingTrait<D, A, R>|SkippedTrait<D, A, R>|AnalyzedTrait<D, A, R>|ResolvedTrait<D, A, R>;\n+export type Trait<D, A, S extends SemanticSymbol|null, R> = PendingTrait<D, A, S, R>|\n+    SkippedTrait<D, A, S, R>|AnalyzedTrait<D, A, S, R>|ResolvedTrait<D, A, S, R>;\n \n /**\n  * The value side of `Trait` exposes a helper to create a `Trait` in a pending state (by delegating\n  * to `TraitImpl`).\n  */\n export const Trait = {\n-  pending: <D, A, R>(handler: DecoratorHandler<D, A, R>, detected: DetectResult<D>):\n-      PendingTrait<D, A, R> => TraitImpl.pending(handler, detected),\n+  pending: <D, A, S extends SemanticSymbol|null, R>(\n+      handler: DecoratorHandler<D, A, S, R>, detected: DetectResult<D>): PendingTrait<D, A, S, R> =>\n+      TraitImpl.pending(handler, detected),\n };\n \n /**\n  * The part of the `Trait` interface that's common to all trait states.\n  */\n-export interface TraitBase<D, A, R> {\n+export interface TraitBase<D, A, S extends SemanticSymbol|null, R> {\n   /**\n    * Current state of the trait.\n    *\n@@ -70,7 +72,7 @@ export interface TraitBase<D, A, R> {\n   /**\n    * The `DecoratorHandler` which matched on the class to create this trait.\n    */\n-  handler: DecoratorHandler<D, A, R>;\n+  handler: DecoratorHandler<D, A, S, R>;\n \n   /**\n    * The detection result (of `handler.detect`) which indicated that this trait applied to the\n@@ -86,20 +88,22 @@ export interface TraitBase<D, A, R> {\n  *\n  * Pending traits have yet to be analyzed in any way.\n  */\n-export interface PendingTrait<D, A, R> extends TraitBase<D, A, R> {\n+export interface PendingTrait<D, A, S extends SemanticSymbol|null, R> extends\n+    TraitBase<D, A, S, R> {\n   state: TraitState.Pending;\n \n   /**\n    * This pending trait has been successfully analyzed, and should transition to the \"analyzed\"\n    * state.\n    */\n-  toAnalyzed(analysis: A|null, diagnostics: ts.Diagnostic[]|null): AnalyzedTrait<D, A, R>;\n+  toAnalyzed(analysis: A|null, diagnostics: ts.Diagnostic[]|null, symbol: S):\n+      AnalyzedTrait<D, A, S, R>;\n \n   /**\n    * During analysis it was determined that this trait is not eligible for compilation after all,\n    * and should be transitioned to the \"skipped\" state.\n    */\n-  toSkipped(): SkippedTrait<D, A, R>;\n+  toSkipped(): SkippedTrait<D, A, S, R>;\n }\n \n /**\n@@ -109,7 +113,8 @@ export interface PendingTrait<D, A, R> extends TraitBase<D, A, R> {\n  *\n  * This is a terminal state.\n  */\n-export interface SkippedTrait<D, A, R> extends TraitBase<D, A, R> {\n+export interface SkippedTrait<D, A, S extends SemanticSymbol|null, R> extends\n+    TraitBase<D, A, S, R> {\n   state: TraitState.Skipped;\n }\n \n@@ -118,8 +123,10 @@ export interface SkippedTrait<D, A, R> extends TraitBase<D, A, R> {\n  *\n  * Analyzed traits have analysis results available, and are eligible for resolution.\n  */\n-export interface AnalyzedTrait<D, A, R> extends TraitBase<D, A, R> {\n+export interface AnalyzedTrait<D, A, S extends SemanticSymbol|null, R> extends\n+    TraitBase<D, A, S, R> {\n   state: TraitState.Analyzed;\n+  symbol: S;\n \n   /**\n    * Analysis results of the given trait (if able to be produced), or `null` if analysis failed\n@@ -136,7 +143,7 @@ export interface AnalyzedTrait<D, A, R> extends TraitBase<D, A, R> {\n    * This analyzed trait has been successfully resolved, and should be transitioned to the\n    * \"resolved\" state.\n    */\n-  toResolved(resolution: R|null, diagnostics: ts.Diagnostic[]|null): ResolvedTrait<D, A, R>;\n+  toResolved(resolution: R|null, diagnostics: ts.Diagnostic[]|null): ResolvedTrait<D, A, S, R>;\n }\n \n /**\n@@ -147,8 +154,10 @@ export interface AnalyzedTrait<D, A, R> extends TraitBase<D, A, R> {\n  *\n  * This is a terminal state.\n  */\n-export interface ResolvedTrait<D, A, R> extends TraitBase<D, A, R> {\n+export interface ResolvedTrait<D, A, S extends SemanticSymbol|null, R> extends\n+    TraitBase<D, A, S, R> {\n   state: TraitState.Resolved;\n+  symbol: S;\n \n   /**\n    * Resolved traits must have produced valid analysis results.\n@@ -176,30 +185,33 @@ export interface ResolvedTrait<D, A, R> extends TraitBase<D, A, R> {\n  * An implementation of the `Trait` type which transitions safely between the various\n  * `TraitState`s.\n  */\n-class TraitImpl<D, A, R> {\n+class TraitImpl<D, A, S extends SemanticSymbol|null, R> {\n   state: TraitState = TraitState.Pending;\n-  handler: DecoratorHandler<D, A, R>;\n+  handler: DecoratorHandler<D, A, S, R>;\n   detected: DetectResult<D>;\n   analysis: Readonly<A>|null = null;\n+  symbol: S|null = null;\n   resolution: Readonly<R>|null = null;\n   analysisDiagnostics: ts.Diagnostic[]|null = null;\n   resolveDiagnostics: ts.Diagnostic[]|null = null;\n \n-  constructor(handler: DecoratorHandler<D, A, R>, detected: DetectResult<D>) {\n+  constructor(handler: DecoratorHandler<D, A, S, R>, detected: DetectResult<D>) {\n     this.handler = handler;\n     this.detected = detected;\n   }\n \n-  toAnalyzed(analysis: A|null, diagnostics: ts.Diagnostic[]|null): AnalyzedTrait<D, A, R> {\n+  toAnalyzed(analysis: A|null, diagnostics: ts.Diagnostic[]|null, symbol: S):\n+      AnalyzedTrait<D, A, S, R> {\n     // Only pending traits can be analyzed.\n     this.assertTransitionLegal(TraitState.Pending, TraitState.Analyzed);\n     this.analysis = analysis;\n     this.analysisDiagnostics = diagnostics;\n+    this.symbol = symbol;\n     this.state = TraitState.Analyzed;\n-    return this as AnalyzedTrait<D, A, R>;\n+    return this as AnalyzedTrait<D, A, S, R>;\n   }\n \n-  toResolved(resolution: R|null, diagnostics: ts.Diagnostic[]|null): ResolvedTrait<D, A, R> {\n+  toResolved(resolution: R|null, diagnostics: ts.Diagnostic[]|null): ResolvedTrait<D, A, S, R> {\n     // Only analyzed traits can be resolved.\n     this.assertTransitionLegal(TraitState.Analyzed, TraitState.Resolved);\n     if (this.analysis === null) {\n@@ -208,14 +220,14 @@ class TraitImpl<D, A, R> {\n     this.resolution = resolution;\n     this.state = TraitState.Resolved;\n     this.resolveDiagnostics = diagnostics;\n-    return this as ResolvedTrait<D, A, R>;\n+    return this as ResolvedTrait<D, A, S, R>;\n   }\n \n-  toSkipped(): SkippedTrait<D, A, R> {\n+  toSkipped(): SkippedTrait<D, A, S, R> {\n     // Only pending traits can be skipped.\n     this.assertTransitionLegal(TraitState.Pending, TraitState.Skipped);\n     this.state = TraitState.Skipped;\n-    return this as SkippedTrait<D, A, R>;\n+    return this as SkippedTrait<D, A, S, R>;\n   }\n \n   /**\n@@ -236,8 +248,8 @@ class TraitImpl<D, A, R> {\n   /**\n    * Construct a new `TraitImpl` in the pending state.\n    */\n-  static pending<D, A, R>(handler: DecoratorHandler<D, A, R>, detected: DetectResult<D>):\n-      PendingTrait<D, A, R> {\n-    return new TraitImpl(handler, detected) as PendingTrait<D, A, R>;\n+  static pending<D, A, S extends SemanticSymbol|null, R>(\n+      handler: DecoratorHandler<D, A, S, R>, detected: DetectResult<D>): PendingTrait<D, A, S, R> {\n+    return new TraitImpl(handler, detected) as PendingTrait<D, A, S, R>;\n   }\n }"
        },
        {
            "sha": "d0431fe2e3af94885245656304203af4eac2cf99",
            "filename": "packages/compiler-cli/src/ngtsc/transform/test/compilation_spec.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 6,
            "changes": 23,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Ftest%2Fcompilation_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Ftest%2Fcompilation_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Ftest%2Fcompilation_spec.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -23,7 +23,7 @@ runInEachFileSystem(() => {\n     beforeEach(() => _ = absoluteFrom);\n \n     it('should not run decoration handlers against declaration files', () => {\n-      class FakeDecoratorHandler implements DecoratorHandler<{}|null, unknown, unknown> {\n+      class FakeDecoratorHandler implements DecoratorHandler<{}|null, unknown, null, unknown> {\n         name = 'FakeDecoratorHandler';\n         precedence = HandlerPrecedence.PRIMARY;\n \n@@ -33,6 +33,9 @@ runInEachFileSystem(() => {\n         analyze(): AnalysisOutput<unknown> {\n           throw new Error('analyze should not have been called');\n         }\n+        symbol(): null {\n+          throw new Error('symbol should not have been called');\n+        }\n         compileFull(): CompileResult {\n           throw new Error('compile should not have been called');\n         }\n@@ -46,7 +49,7 @@ runInEachFileSystem(() => {\n       const reflectionHost = new TypeScriptReflectionHost(checker);\n       const compiler = new TraitCompiler(\n           [new FakeDecoratorHandler()], reflectionHost, NOOP_PERF_RECORDER, NOOP_INCREMENTAL_BUILD,\n-          true, CompilationMode.FULL, new DtsTransformRegistry());\n+          true, CompilationMode.FULL, new DtsTransformRegistry(), null);\n       const sourceFile = program.getSourceFile('lib.d.ts')!;\n       const analysis = compiler.analyzeSync(sourceFile);\n \n@@ -55,7 +58,7 @@ runInEachFileSystem(() => {\n     });\n \n     describe('compilation mode', () => {\n-      class PartialDecoratorHandler implements DecoratorHandler<{}, {}, unknown> {\n+      class PartialDecoratorHandler implements DecoratorHandler<{}, {}, null, unknown> {\n         name = 'PartialDecoratorHandler';\n         precedence = HandlerPrecedence.PRIMARY;\n \n@@ -70,6 +73,10 @@ runInEachFileSystem(() => {\n           return {analysis: {}};\n         }\n \n+        symbol(): null {\n+          return null;\n+        }\n+\n         compileFull(): CompileResult {\n           return {\n             name: 'compileFull',\n@@ -89,7 +96,7 @@ runInEachFileSystem(() => {\n         }\n       }\n \n-      class FullDecoratorHandler implements DecoratorHandler<{}, {}, unknown> {\n+      class FullDecoratorHandler implements DecoratorHandler<{}, {}, null, unknown> {\n         name = 'FullDecoratorHandler';\n         precedence = HandlerPrecedence.PRIMARY;\n \n@@ -104,6 +111,10 @@ runInEachFileSystem(() => {\n           return {analysis: {}};\n         }\n \n+        symbol(): null {\n+          return null;\n+        }\n+\n         compileFull(): CompileResult {\n           return {\n             name: 'compileFull',\n@@ -127,7 +138,7 @@ runInEachFileSystem(() => {\n         const compiler = new TraitCompiler(\n             [new PartialDecoratorHandler(), new FullDecoratorHandler()], reflectionHost,\n             NOOP_PERF_RECORDER, NOOP_INCREMENTAL_BUILD, true, CompilationMode.PARTIAL,\n-            new DtsTransformRegistry());\n+            new DtsTransformRegistry(), null);\n         const sourceFile = program.getSourceFile('test.ts')!;\n         compiler.analyzeSync(sourceFile);\n         compiler.resolve();\n@@ -157,7 +168,7 @@ runInEachFileSystem(() => {\n         const compiler = new TraitCompiler(\n             [new PartialDecoratorHandler(), new FullDecoratorHandler()], reflectionHost,\n             NOOP_PERF_RECORDER, NOOP_INCREMENTAL_BUILD, true, CompilationMode.FULL,\n-            new DtsTransformRegistry());\n+            new DtsTransformRegistry(), null);\n         const sourceFile = program.getSourceFile('test.ts')!;\n         compiler.analyzeSync(sourceFile);\n         compiler.resolve();"
        },
        {
            "sha": "4c68621b65e41dbc62c3a38c2b6bb1dfc557ddac",
            "filename": "packages/compiler-cli/test/ngtsc/env.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fenv.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fenv.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fenv.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -161,7 +161,9 @@ export class NgtscTestEnvironment {\n     const absFilePath = this.fs.resolve(this.basePath, fileName);\n     if (this.multiCompileHostExt !== null) {\n       this.multiCompileHostExt.invalidate(absFilePath);\n-      this.changedResources!.add(absFilePath);\n+      if (!fileName.endsWith('.ts')) {\n+        this.changedResources!.add(absFilePath);\n+      }\n     }\n     this.fs.ensureDir(this.fs.dirname(absFilePath));\n     this.fs.writeFile(absFilePath, content);\n@@ -173,6 +175,9 @@ export class NgtscTestEnvironment {\n       throw new Error(`Not caching files - call enableMultipleCompilations()`);\n     }\n     this.multiCompileHostExt.invalidate(absFilePath);\n+    if (!fileName.endsWith('.ts')) {\n+      this.changedResources!.add(absFilePath);\n+    }\n   }\n \n   tsconfig("
        },
        {
            "sha": "0fb1bf892524eaf0b0363436b3af87fd6a19958d",
            "filename": "packages/compiler-cli/test/ngtsc/incremental_error_spec.ts",
            "status": "modified",
            "additions": 41,
            "deletions": 24,
            "changes": 65,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fincremental_error_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fincremental_error_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fincremental_error_spec.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -239,12 +239,13 @@ runInEachFileSystem(() => {\n         export class TargetCmp {}\n       `);\n       env.write('module.ts', `\n-        import {NgModule} from '@angular/core';\n+        import {NgModule, NO_ERRORS_SCHEMA} from '@angular/core';\n         import {TargetCmp} from './target';\n         import {TestCmp} from './test';\n \n         @NgModule({\n           declarations: [TestCmp, TargetCmp],\n+          schemas: [NO_ERRORS_SCHEMA],\n         })\n         export class Module {}\n       `);\n@@ -268,7 +269,7 @@ runInEachFileSystem(() => {\n       env.write('test.ts', `\n         import {Component} from '@angular/core';\n \n-        @Component({selector: 'test-cmp', template: '...'})\n+        @Component({selector: 'test-cmp-fixed', template: '...'})\n         export class TestCmp {}\n       `);\n \n@@ -283,7 +284,7 @@ runInEachFileSystem(() => {\n         '/module.js',\n \n         // Because TargetCmp also belongs to the same module, it should be re-emitted since\n-        // TestCmp's elector may have changed.\n+        // TestCmp's selector was changed.\n         '/target.js',\n       ]);\n     });\n@@ -329,7 +330,7 @@ runInEachFileSystem(() => {\n       env.write('a.ts', `\n         import {Component} from '@angular/core';\n \n-        @Component({selector: 'test-cmp', template: '...'})\n+        @Component({selector: 'test-cmp', template: '<div dir></div>'})\n         export class CmpA {}\n       `);\n       env.write('b.ts', `\n@@ -357,17 +358,16 @@ runInEachFileSystem(() => {\n         export class Module {}\n       `);\n       env.write('lib.ts', `\n-        import {Component, NgModule} from '@angular/core';\n+        import {Directive, NgModule} from '@angular/core';\n \n-        @Component({\n-          selector: 'lib-cmp',\n-          template: '...',\n+        @Directive({\n+          selector: '[dir]',\n         })\n-        export class LibCmp {}\n+        export class LibDir {}\n \n         @NgModule({\n-          declarations: [LibCmp],\n-          exports: [LibCmp],\n+          declarations: [LibDir],\n+          exports: [LibDir],\n         })\n         export class LibModule {}\n       `);\n@@ -378,17 +378,27 @@ runInEachFileSystem(() => {\n \n       // Introduce the error in LibModule\n       env.write('lib.ts', `\n-      import {Component, NgModule} from '@angular/core';\n+      import {Directive, NgModule} from '@angular/core';\n \n-      @Component({\n-        selector: 'lib-cmp',\n-        template: '...',\n+      @Directive({\n+        selector: '[dir]',\n       })\n-      export class LibCmp {}\n+      export class LibDir {}\n+\n+      @Directive({\n+        selector: '[dir]',\n+      })\n+      export class NewDir {}\n \n       @NgModule({\n-        declarations: [LibCmp],\n-        exports: [LibCmp],\n+        declarations: [NewDir],\n+      })\n+      export class NewModule {}\n+\n+      @NgModule({\n+        declarations: [LibDir],\n+        imports: [NewModule],\n+        exports: [LibDir, NewModule],\n       })\n       export class LibModule // missing braces\n       `);\n@@ -407,19 +417,24 @@ runInEachFileSystem(() => {\n       })\n       export class LibCmp {}\n \n+      @NgModule({})\n+      export class NewModule {}\n+\n       @NgModule({\n         declarations: [LibCmp],\n-        exports: [LibCmp],\n+        imports: [NewModule],\n+        exports: [LibCmp, NewModule],\n       })\n       export class LibModule {}\n       `);\n \n       env.driveMain();\n \n       expectToHaveWritten([\n-        // Both CmpA and CmpB should be re-emitted.\n+        // CmpA should be re-emitted as `NewModule` was added since the successful emit, which added\n+        // `NewDir` as a matching directive to CmpA. Alternatively, CmpB should not be re-emitted\n+        // as it does not use the newly added directive.\n         '/a.js',\n-        '/b.js',\n \n         // So should the module itself.\n         '/module.js',\n@@ -468,8 +483,7 @@ runInEachFileSystem(() => {\n           '/other.js',\n           '/a.js',\n \n-          // Bcause they depend on a.ts\n-          '/b.js',\n+          // Because they depend on a.ts\n           '/module.js',\n         ]);\n       });\n@@ -512,7 +526,10 @@ runInEachFileSystem(() => {\n           '/other.js',\n \n           // Because a.html changed\n-          '/a.js', '/module.js',\n+          '/a.js',\n+\n+          // module.js should not be re-emitted, as it is not affected by the change and its remote\n+          // scope is unaffected.\n \n           // b.js and module.js should not be re-emitted, because specifically when tracking\n           // resource dependencies, the compiler knows that a change to a resource file only affects"
        },
        {
            "sha": "345ed61911f58b298499ce2d17fb8f02749f82a0",
            "filename": "packages/compiler-cli/test/ngtsc/incremental_semantic_changes_spec.ts",
            "status": "added",
            "additions": 2314,
            "deletions": 0,
            "changes": 2314,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fincremental_semantic_changes_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fincremental_semantic_changes_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fincremental_semantic_changes_spec.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -0,0 +1,2314 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {runInEachFileSystem} from '../../src/ngtsc/file_system/testing';\n+import {loadStandardTestFiles} from '../../src/ngtsc/testing';\n+\n+import {NgtscTestEnvironment} from './env';\n+\n+const testFiles = loadStandardTestFiles();\n+\n+runInEachFileSystem(() => {\n+  describe('ngtsc incremental compilation (semantic changes)', () => {\n+    let env!: NgtscTestEnvironment;\n+\n+    beforeEach(() => {\n+      env = NgtscTestEnvironment.setup(testFiles);\n+      env.enableMultipleCompilations();\n+      env.tsconfig();\n+    });\n+\n+    function expectToHaveWritten(files: string[]): void {\n+      const set = env.getFilesWrittenSinceLastFlush();\n+\n+      const expectedSet = new Set<string>();\n+      for (const file of files) {\n+        expectedSet.add(file);\n+        expectedSet.add(file.replace(/\\.js$/, '.d.ts'));\n+      }\n+\n+      expect(set).toEqual(expectedSet);\n+\n+      // Reset for the next compilation.\n+      env.flushWrittenFileTracking();\n+    }\n+\n+    describe('changes to public api', () => {\n+      it('should not recompile dependent components when public api is unchanged', () => {\n+        // Testing setup: ADep is a component with an input and an output, and is consumed by two\n+        // other components - ACmp within its same NgModule, and BCmp which depends on ADep via an\n+        // NgModule import.\n+        //\n+        // ADep is changed during the test without affecting its public API, and the test asserts\n+        // that both ACmp and BCmp which consume ADep are not re-emitted.\n+        env.write('a/dep.ts', `\n+          import {Component, Input, Output, EventEmitter} from '@angular/core';\n+\n+          @Component({\n+            selector: 'a-dep',\n+            template: 'a-dep',\n+          })\n+          export class ADep {\n+            @Input()\n+            input!: string;\n+\n+            @Output()\n+            output = new EventEmitter<string>();\n+          }\n+        `);\n+        env.write('a/cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'a-cmp',\n+            template: '<a-dep></a-dep>',\n+          })\n+          export class ACmp {}\n+        `);\n+        env.write('a/mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {ADep} from './dep';\n+          import {ACmp} from './cmp';\n+\n+          @NgModule({\n+            declarations: [ADep, ACmp],\n+            exports: [ADep],\n+          })\n+          export class AMod {}\n+        `);\n+        env.write('b/cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'b-cmp',\n+            template: '<a-dep></a-dep>',\n+          })\n+          export class BCmp {}\n+        `);\n+        env.write('b/mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {BCmp} from './cmp';\n+          import {AMod} from '../a/mod';\n+\n+          @NgModule({\n+            declarations: [BCmp],\n+            imports: [AMod],\n+          })\n+          export class BMod {}\n+        `);\n+\n+        env.driveMain();\n+        env.flushWrittenFileTracking();\n+\n+        // Change ADep without affecting its public API.\n+        env.write('a/dep.ts', `\n+          import {Component, Input, Output, EventEmitter} from '@angular/core';\n+\n+          @Component({\n+            selector: 'a-dep',\n+            template: 'a-dep',\n+          })\n+          export class ADep {\n+            @Input()\n+            input!: string;\n+\n+            @Output()\n+            output = new EventEmitter<number>(); // changed from string to number\n+          }\n+        `);\n+\n+        env.driveMain();\n+        expectToHaveWritten([\n+          // ADep is written because it was updated.\n+          '/a/dep.js',\n+\n+          // AMod is written because it has a direct dependency on ADep.\n+          '/a/mod.js',\n+\n+          // Nothing else is written because the public API of AppCmpB was not affected\n+        ]);\n+      });\n+\n+      it('should not recompile components that do not use a changed directive', () => {\n+        // Testing setup: ADep is a directive with an input and output, which is visible to two\n+        // components which do not use ADep in their templates - ACmp within the same NgModule, and\n+        // BCmp which has visibility of ADep via an NgModule import.\n+        //\n+        // During the test, ADep's public API is changed, and the test verifies that neither ACmp\n+        // nor BCmp are re-emitted.\n+\n+        env.write('a/dep.ts', `\n+          import {Directive, Input, Output, EventEmitter} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[a-dep]',\n+          })\n+          export class ADep {\n+            @Input()\n+            input!: string;\n+\n+            @Output()\n+            output = new EventEmitter<string>();\n+          }\n+        `);\n+        env.write('a/cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'a-cmp',\n+            template: 'Does not use a-dep.',\n+          })\n+          export class ACmp {}\n+        `);\n+        env.write('a/mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {ADep} from './dep';\n+          import {ACmp} from './cmp';\n+\n+          @NgModule({\n+            declarations: [ADep, ACmp],\n+            exports: [ADep],\n+          })\n+          export class AMod {}\n+        `);\n+        env.write('b/cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'b-cmp',\n+            template: 'Does not use a-dep.',\n+          })\n+          export class BCmp {}\n+        `);\n+        env.write('b/mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {BCmp} from './cmp';\n+          import {AMod} from '../a/mod';\n+\n+          @NgModule({\n+            declarations: [BCmp],\n+            imports: [AMod],\n+          })\n+          export class BMod {}\n+        `);\n+\n+        env.driveMain();\n+        env.flushWrittenFileTracking();\n+\n+        // Update ADep and change its public API.\n+        env.write('a/dep.ts', `\n+          import {Directive, Input, Output, EventEmitter} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[a-dep]',\n+            template: 'a-dep',\n+          })\n+          export class ADep {\n+            @Input()\n+            input!: string;\n+\n+            @Output('output-renamed') // public binding name of the @Output is changed.\n+            output = new EventEmitter<string>();\n+          }\n+        `);\n+\n+        env.driveMain();\n+        expectToHaveWritten([\n+          // ADep is written because it was updated.\n+          '/a/dep.js',\n+\n+          // AMod is written because it has a direct dependency on ADep.\n+          '/a/mod.js',\n+\n+          // Nothing else is written because neither ACmp nor BCmp depend on ADep.\n+        ]);\n+      });\n+\n+      it('should recompile components for which a directive usage is introduced', () => {\n+        // Testing setup: Cmp is a component with a template that would match a directive with the\n+        // selector '[dep]' if one existed. Dep is a directive with a different selector initially.\n+        //\n+        // During the test, Dep's selector is updated to '[dep]', causing it to begin matching the\n+        // template of Cmp. The test verifies that Cmp is re-emitted after this change.\n+        env.write('dep.ts', `\n+          import {Directive} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[does-not-match]',\n+          })\n+          export class Dep {}\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'cmp',\n+            template: '<div dep></div>',\n+          })\n+          export class Cmp {}\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dep} from './dep';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dep],\n+          })\n+          export class Mod {}\n+        `);\n+\n+        env.driveMain();\n+        env.flushWrittenFileTracking();\n+\n+        env.write('dep.ts', `\n+          import {Directive} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dep]', // selector changed to now match inside Cmp's template\n+          })\n+          export class Dep {}\n+        `);\n+        env.driveMain();\n+\n+        expectToHaveWritten([\n+          // Dep is written because it was directly updated.\n+          '/dep.js',\n+\n+          // Mod is written because it has a direct dependency on Dep.\n+          '/mod.js',\n+\n+          // Cmp is written because the directives matched in its template have changed.\n+          '/cmp.js',\n+        ]);\n+      });\n+\n+      it('should recompile components for which a directive usage is removed', () => {\n+        // Testing setup: Cmp is a component with a template that matches a directive Dep with the\n+        // initial selector '[dep]'.\n+        //\n+        // During the test, Dep's selector is changed, causing it to no longer match the template of\n+        // Cmp. The test verifies that Cmp is re-emitted after this change.\n+\n+        env.write('dep.ts', `\n+          import {Directive} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dep]',\n+          })\n+          export class Dep {}\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'cmp',\n+            template: '<div dep></div>',\n+          })\n+          export class Cmp {}\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dep} from './dep';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dep],\n+          })\n+          export class Mod {}\n+        `);\n+\n+        env.driveMain();\n+        env.flushWrittenFileTracking();\n+\n+        env.write('dep.ts', `\n+          import {Directive} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[does-not-match]', // selector changed to no longer match Cmp's template\n+          })\n+          export class Dep {}\n+        `);\n+        env.driveMain();\n+\n+        expectToHaveWritten([\n+          // Dep is written because it was directly updated.\n+          '/dep.js',\n+\n+          // Mod is written because it has a direct dependency on Dep.\n+          '/mod.js',\n+\n+          // Cmp is written because the directives matched in its template have changed.\n+          '/cmp.js',\n+        ]);\n+      });\n+\n+      it('should recompile dependent components when an input is added', () => {\n+        // Testing setup: Cmp is a component with a template that matches a directive Dep with the\n+        // initial selector '[dep]'.\n+        //\n+        // During the test, an input is added to Dep, and the test verifies that Cmp is re-emitted.\n+\n+        env.write('dep.ts', `\n+          import {Directive} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dep]',\n+          })\n+          export class Dep {}\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'cmp',\n+            template: '<div dep></div>',\n+          })\n+          export class Cmp {}\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dep} from './dep';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dep],\n+          })\n+          export class Mod {}\n+        `);\n+\n+        env.driveMain();\n+        env.flushWrittenFileTracking();\n+\n+        env.write('dep.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dep]',\n+          })\n+          export class Dep {\n+            @Input() input!: string; // adding this changes Dep's public API\n+          }\n+        `);\n+        env.driveMain();\n+\n+        expectToHaveWritten([\n+          // Dep is written because it was directly updated.\n+          '/dep.js',\n+\n+          // Mod is written because it has a direct dependency on Dep.\n+          '/mod.js',\n+\n+          // Cmp is written because it depends on Dep, which has changed in its public API.\n+          '/cmp.js',\n+        ]);\n+      });\n+\n+      it('should recompile dependent components when an input is renamed', () => {\n+        // Testing setup: Cmp is a component with a template that matches a directive Dep with the\n+        // initial selector '[dep]'.\n+        //\n+        // During the test, an input of Dep is renamed, and the test verifies that Cmp is\n+        // re-emitted.\n+\n+        env.write('dep.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dep]',\n+          })\n+          export class Dep {\n+            @Input() input!: string;\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'cmp',\n+            template: '<div dep></div>',\n+          })\n+          export class Cmp {}\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dep} from './dep';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dep],\n+          })\n+          export class Mod {}\n+        `);\n+\n+        env.driveMain();\n+        env.flushWrittenFileTracking();\n+\n+        env.write('dep.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dep]',\n+          })\n+          export class Dep {\n+            @Input('renamed') input!: string; // renaming this changes Dep's public API\n+          }\n+        `);\n+        env.driveMain();\n+\n+        expectToHaveWritten([\n+          // Dep is written because it was directly updated.\n+          '/dep.js',\n+\n+          // Mod is written because it has a direct dependency on Dep.\n+          '/mod.js',\n+\n+          // Cmp is written because it depends on Dep, which has changed in its public API.\n+          '/cmp.js',\n+        ]);\n+      });\n+\n+      it('should recompile dependent components when an input is removed', () => {\n+        // Testing setup: Cmp is a component with a template that matches a directive Dep with the\n+        // initial selector '[dep]'.\n+        //\n+        // During the test, an input of Dep is removed, and the test verifies that Cmp is\n+        // re-emitted.\n+\n+        env.write('dep.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dep]',\n+          })\n+          export class Dep {\n+            @Input() input!: string;\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'cmp',\n+            template: '<div dep></div>',\n+          })\n+          export class Cmp {}\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dep} from './dep';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dep],\n+          })\n+          export class Mod {}\n+        `);\n+\n+        env.driveMain();\n+        env.flushWrittenFileTracking();\n+\n+        env.write('dep.ts', `\n+          import {Directive} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dep]',\n+          })\n+          export class Dep {\n+            // Dep's input has been removed, which changes its public API\n+          }\n+        `);\n+        env.driveMain();\n+\n+        expectToHaveWritten([\n+          // Dep is written because it was directly updated.\n+          '/dep.js',\n+\n+          // Mod is written because it has a direct dependency on Dep.\n+          '/mod.js',\n+\n+          // Cmp is written because it depends on Dep, which has changed in its public API.\n+          '/cmp.js',\n+        ]);\n+      });\n+\n+      it('should recompile dependent components when an output is added', () => {\n+        // Testing setup: Cmp is a component with a template that matches a directive Dep with the\n+        // initial selector '[dep]'.\n+        //\n+        // During the test, an output of Dep is added, and the test verifies that Cmp is re-emitted.\n+\n+        env.write('dep.ts', `\n+          import {Directive} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dep]',\n+          })\n+          export class Dep {}\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'cmp',\n+            template: '<div dep></div>',\n+          })\n+          export class Cmp {}\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dep} from './dep';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dep],\n+          })\n+          export class Mod {}\n+        `);\n+\n+        env.driveMain();\n+        env.flushWrittenFileTracking();\n+\n+        env.write('dep.ts', `\n+          import {Directive, Output, EventEmitter} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dep]',\n+          })\n+          export class Dep {\n+            @Output()\n+            output = new EventEmitter<string>(); // added, which changes Dep's public API\n+          }\n+        `);\n+        env.driveMain();\n+\n+        expectToHaveWritten([\n+          // Dep is written because it was directly updated.\n+          '/dep.js',\n+\n+          // Mod is written because it has a direct dependency on Dep.\n+          '/mod.js',\n+\n+          // Cmp is written because it depends on Dep, which has changed in its public API.\n+          '/cmp.js',\n+        ]);\n+      });\n+\n+      it('should recompile dependent components when an output is renamed', () => {\n+        // Testing setup: Cmp is a component with a template that matches a directive Dep with the\n+        // initial selector '[dep]'.\n+        //\n+        // During the test, an output of Dep is renamed, and the test verifies that Cmp is\n+        // re-emitted.\n+\n+        env.write('dep.ts', `\n+          import {Directive, Output, EventEmitter} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dep]',\n+          })\n+          export class Dep {\n+            @Output() output = new EventEmitter<string>();\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'cmp',\n+            template: '<div dep></div>',\n+          })\n+          export class Cmp {}\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dep} from './dep';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dep],\n+          })\n+          export class Mod {}\n+        `);\n+\n+        env.driveMain();\n+        env.flushWrittenFileTracking();\n+\n+        env.write('dep.ts', `\n+          import {Directive, Output, EventEmitter} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dep]',\n+          })\n+          export class Dep {\n+            @Output('renamed') output = new EventEmitter<string>(); // public API changed\n+          }\n+        `);\n+        env.driveMain();\n+\n+        expectToHaveWritten([\n+          // Dep is written because it was directly updated.\n+          '/dep.js',\n+\n+          // Mod is written because it has a direct dependency on Dep.\n+          '/mod.js',\n+\n+          // Cmp is written because it depends on Dep, which has changed in its public API.\n+          '/cmp.js',\n+        ]);\n+      });\n+\n+      it('should recompile dependent components when an output is removed', () => {\n+        // Testing setup: Cmp is a component with a template that matches a directive Dep with the\n+        // initial selector '[dep]'.\n+        //\n+        // During the test, an output of Dep is removed, and the test verifies that Cmp is\n+        // re-emitted.\n+\n+        env.write('dep.ts', `\n+          import {Directive, Output, EventEmitter} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dep]',\n+          })\n+          export class Dep {\n+            @Output() output = new EventEmitter<string>();\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'cmp',\n+            template: '<div dep></div>',\n+          })\n+          export class Cmp {}\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dep} from './dep';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dep],\n+          })\n+          export class Mod {}\n+        `);\n+\n+        env.driveMain();\n+        env.flushWrittenFileTracking();\n+\n+        env.write('dep.ts', `\n+          import {Directive} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dep]',\n+          })\n+          export class Dep {\n+            // Dep's output has been removed, which changes its public API\n+          }\n+        `);\n+        env.driveMain();\n+\n+        expectToHaveWritten([\n+          // Dep is written because it was directly updated.\n+          '/dep.js',\n+\n+          // Mod is written because it has a direct dependency on Dep.\n+          '/mod.js',\n+\n+          // Cmp is written because it depends on Dep, which has changed in its public API.\n+          '/cmp.js',\n+        ]);\n+      });\n+\n+      it('should recompile dependent components when exportAs clause changes', () => {\n+        // Testing setup: Cmp is a component with a template that matches a directive Dep with the\n+        // initial selector '[dep]' and an exportAs clause.\n+        //\n+        // During the test, the exportAs clause of Dep is changed, and the test verifies that Cmp is\n+        // re-emitted.\n+\n+        env.write('dep.ts', `\n+          import {Directive} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dep]',\n+            exportAs: 'depExport1',\n+          })\n+          export class Dep {}\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'cmp',\n+            template: '<div dep></div>',\n+          })\n+          export class Cmp {}\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dep} from './dep';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dep],\n+          })\n+          export class Mod {}\n+        `);\n+\n+        env.driveMain();\n+        env.flushWrittenFileTracking();\n+\n+        env.write('dep.ts', `\n+          import {Directive} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dep]',\n+            exportAs: 'depExport2', // changing this changes Dep's public API\n+          })\n+          export class Dep {}\n+        `);\n+        env.driveMain();\n+\n+        expectToHaveWritten([\n+          // Dep is written because it was directly updated.\n+          '/dep.js',\n+\n+          // Mod is written because it has a direct dependency on Dep.\n+          '/mod.js',\n+\n+          // Cmp is written because it depends on Dep, which has changed in its public API.\n+          '/cmp.js',\n+        ]);\n+      });\n+\n+      it('should recompile components when a pipe is newly matched because it was renamed', () => {\n+        // Testing setup: Cmp uses two pipes (PipeA and PipeB) in its template.\n+        //\n+        // During the test, the selectors of these pipes are swapped. This ensures that Cmp's\n+        // template is still valid, since both pipe names continue to be valid within it. However,\n+        // as the identity of each pipe is now different, the effective public API of those pipe\n+        // usages has changed. The test then verifies that Cmp is re-emitted.\n+\n+        env.write('pipes.ts', `\n+          import {Pipe} from '@angular/core';\n+\n+          @Pipe({\n+            name: 'pipeA',\n+          })\n+          export class PipeA {\n+            transform(value: any): any { return value; }\n+          }\n+\n+          @Pipe({\n+            name: 'pipeB',\n+          })\n+          export class PipeB {\n+            transform(value: any): any { return value; }\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'cmp',\n+            template: '{{ value | pipeA }} {{ value | pipeB }}',\n+          })\n+          export class Cmp {\n+            value!: string;\n+          }\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {PipeA, PipeB} from './pipes';\n+          import {Cmp} from './cmp';\n+\n+          @NgModule({\n+            declarations: [Cmp, PipeA, PipeB],\n+          })\n+          export class Mod {}\n+        `);\n+\n+        env.driveMain();\n+        env.flushWrittenFileTracking();\n+\n+        env.write('pipes.ts', `\n+          import {Pipe} from '@angular/core';\n+\n+          @Pipe({\n+            name: 'pipeB', // swapped with PipeB's selector\n+          })\n+          export class PipeA {\n+            transform(value: any): any { return value; }\n+          }\n+\n+          @Pipe({\n+            name: 'pipeA', // swapped with PipeA's selector\n+          })\n+          export class PipeB {\n+            transform(value: any): any { return value; }\n+          }\n+        `);\n+\n+        env.driveMain();\n+        expectToHaveWritten([\n+          // PipeA and PipeB have directly changed.\n+          '/pipes.js',\n+\n+          // Mod depends directly on PipeA and PipeB.\n+          '/mod.js',\n+\n+          // Cmp depends on the public APIs of PipeA and PipeB, which have changed (as they've\n+          // swapped).\n+          '/cmp.js',\n+        ]);\n+      });\n+    });\n+\n+    describe('external declarations', () => {\n+      it('should not recompile components that use external declarations that are not changed',\n+         () => {\n+           // Testing setup: Two components (MyCmpA and MyCmpB) both depend on an external directive\n+           // which matches their templates, via an NgModule import.\n+           //\n+           // During the test, MyCmpA is invalidated, and the test verifies that only MyCmpA and not\n+           // MyCmpB is re-emitted.\n+           env.write('node_modules/external/index.d.ts', `\n+             import * as ng from '@angular/core';\n+\n+             export declare class ExternalDir {\n+               static ɵdir: ng.ɵɵDirectiveDefWithMeta<ExternalDir, \"[external]\", never, {}, {}, never>;\n+             }\n+\n+             export declare class ExternalMod {\n+               static ɵmod: ng.ɵɵNgModuleDefWithMeta<ExternalMod, [typeof ExternalDir], never, [typeof ExternalDir]>;\n+             }\n+           `);\n+           env.write('cmp-a.ts', `\n+             import {Component} from '@angular/core';\n+\n+             @Component({\n+               template: '<div external></div>',\n+             })\n+             export class MyCmpA {}\n+           `);\n+           env.write('cmp-b.ts', `\n+             import {Component} from '@angular/core';\n+\n+             @Component({\n+               template: '<div external></div>',\n+             })\n+             export class MyCmpB {}\n+           `);\n+           env.write('mod.ts', `\n+             import {NgModule} from '@angular/core';\n+             import {ExternalMod} from 'external';\n+             import {MyCmpA} from './cmp-a';\n+             import {MyCmpB} from './cmp-b';\n+\n+             @NgModule({\n+               declarations: [MyCmpA, MyCmpB],\n+               imports: [ExternalMod],\n+             })\n+             export class MyMod {}\n+           `);\n+           env.driveMain();\n+           env.flushWrittenFileTracking();\n+\n+           // Invalidate MyCmpA, causing it to be re-emitted.\n+           env.invalidateCachedFile('cmp-a.ts');\n+\n+           env.driveMain();\n+           expectToHaveWritten([\n+             // MyMod is written because it has a direct reference to MyCmpA, which was invalidated.\n+             '/mod.js',\n+\n+             // MyCmpA is written because it was invalidated.\n+             '/cmp-a.js',\n+\n+             // MyCmpB should not be written because it is unaffected.\n+           ]);\n+         });\n+\n+      it('should recompile components once an external declaration is changed', () => {\n+        // Testing setup: Two components (MyCmpA and MyCmpB) both depend on an external directive\n+        // which matches their templates, via an NgModule import.\n+        //\n+        // During the test, the external directive is invalidated, and the test verifies that both\n+        // components are re-emitted as a result.\n+        env.write('node_modules/external/index.d.ts', `\n+          import * as ng from '@angular/core';\n+\n+          export declare class ExternalDir {\n+            static ɵdir: ng.ɵɵDirectiveDefWithMeta<ExternalDir, \"[external]\", never, {}, {}, never>;\n+          }\n+\n+          export declare class ExternalMod {\n+            static ɵmod: ng.ɵɵNgModuleDefWithMeta<ExternalMod, [typeof ExternalDir], never, [typeof ExternalDir]>;\n+          }\n+        `);\n+        env.write('cmp-a.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            template: '<div external></div>',\n+          })\n+          export class MyCmpA {}\n+        `);\n+        env.write('cmp-b.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            template: '<div external></div>',\n+          })\n+          export class MyCmpB {}\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {ExternalMod} from 'external';\n+          import {MyCmpA} from './cmp-a';\n+          import {MyCmpB} from './cmp-b';\n+\n+          @NgModule({\n+            declarations: [MyCmpA, MyCmpB],\n+            imports: [ExternalMod],\n+          })\n+          export class MyMod {}\n+        `);\n+        env.driveMain();\n+        env.flushWrittenFileTracking();\n+\n+        // Invalidate the external file. Only the referential identity of external symbols matters\n+        // for emit reuse, so invalidating this should cause all dependent components to be\n+        // re-emitted.\n+        env.invalidateCachedFile('node_modules/external/index.d.ts');\n+        env.driveMain();\n+\n+        expectToHaveWritten([\n+          // MyMod is written because it has a direct reference to ExternalMod, which was\n+          // invalidated.\n+          '/mod.js',\n+\n+          // MyCmpA is written because it uses ExternalDir, which has not changed public API but has\n+          // changed identity.\n+          '/cmp-a.js',\n+\n+          // MyCmpB is written because it uses ExternalDir, which has not changed public API but has\n+          // changed identity.\n+          '/cmp-b.js',\n+        ]);\n+      });\n+    });\n+\n+    describe('symbol identity', () => {\n+      it('should recompile components when their declaration name changes', () => {\n+        // Testing setup: component Cmp depends on component Dep, which is directly exported.\n+        //\n+        // During the test, Dep's name is changed while keeping its public API the same. The test\n+        // verifies that Cmp is re-emitted.\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'cmp',\n+            template: '<dep></dep>',\n+          })\n+          export class Cmp {}\n+        `);\n+        env.write('dep.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'dep',\n+            template: 'Dep',\n+          })\n+          export class Dep {}\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dep} from './dep';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dep]\n+          })\n+          export class Mod {}\n+        `);\n+\n+        env.driveMain();\n+\n+        env.write('dep.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'dep',\n+            template: 'Dep',\n+          })\n+          export class ChangedDep {} // Dep renamed to ChangedDep.\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+\n+          import {Cmp} from './cmp';\n+          import {ChangedDep} from './dep';\n+\n+          @NgModule({\n+            declarations: [Cmp, ChangedDep]\n+          })\n+          export class Mod {}\n+        `);\n+\n+        env.flushWrittenFileTracking();\n+        env.driveMain();\n+\n+        expectToHaveWritten([\n+          // Dep and Mod were directly updated.\n+          '/dep.js',\n+          '/mod.js',\n+\n+          // Cmp required a re-emit because the name of Dep changed.\n+          '/cmp.js',\n+        ]);\n+      });\n+\n+      it('should not recompile components that use a local directive', () => {\n+        // Testing setup: a single source file 'cmp.ts' declares components `Cmp` and `Dir`, where\n+        // `Cmp` uses `Dir` in its template. This test verifies that the local reference of `Cmp`\n+        // that is emitted into `Dir` does not inadvertently cause `cmp.ts` to be emitted even when\n+        // nothing changed.\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'dep',\n+            template: 'Dep',\n+          })\n+          export class Dep {}\n+\n+          @Component({\n+            selector: 'cmp',\n+            template: '<dep></dep>',\n+          })\n+          export class Cmp {}\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp, Dep} from './cmp';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dep]\n+          })\n+          export class Mod {}\n+        `);\n+\n+        env.driveMain();\n+\n+        env.invalidateCachedFile('mod.ts');\n+\n+        env.flushWrittenFileTracking();\n+        env.driveMain();\n+\n+        expectToHaveWritten([\n+          // Only `mod.js` should be written because it was invalidated.\n+          '/mod.js',\n+        ]);\n+      });\n+\n+      it('should recompile components when the name by which they are exported changes', () => {\n+        // Testing setup: component Cmp depends on component Dep, which is directly exported.\n+        //\n+        // During the test, Dep's exported name is changed while keeping its declaration name the\n+        // same. The test verifies that Cmp is re-emitted.\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'cmp',\n+            template: '<dep></dep>',\n+          })\n+          export class Cmp {}\n+        `);\n+        env.write('dep.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'dep',\n+            template: 'Dep',\n+          })\n+          export class Dep {}\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dep} from './dep';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dep]\n+          })\n+          export class Mod {}\n+        `);\n+\n+        env.driveMain();\n+\n+        env.write('dep.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'dep',\n+            template: 'Dep',\n+          })\n+          class Dep {}\n+          export {Dep as ChangedDep}; // the export name of Dep is changed.\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+\n+          import {Cmp} from './cmp';\n+          import {ChangedDep} from './dep';\n+\n+          @NgModule({\n+            declarations: [Cmp, ChangedDep]\n+          })\n+          export class Mod {}\n+        `);\n+\n+        env.flushWrittenFileTracking();\n+        env.driveMain();\n+\n+        expectToHaveWritten([\n+          // Dep and Mod were directly updated.\n+          '/dep.js',\n+          '/mod.js',\n+\n+          // Cmp required a re-emit because the exported name of Dep changed.\n+          '/cmp.js',\n+        ]);\n+      });\n+\n+      it('should recompile components when a re-export is renamed', () => {\n+        // Testing setup: CmpUser uses CmpDep in its template. CmpDep is both directly and\n+        // indirectly exported, and the compiler is guided into using the indirect export.\n+        //\n+        // During the test, the indirect export name is changed, and the test verifies that CmpUser\n+        // is re-emitted.\n+\n+        env.write('cmp-user.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'cmp-user',\n+            template: '<cmp-dep></cmp-dep>',\n+          })\n+          export class CmpUser {}\n+        `);\n+        env.write('cmp-dep.ts', `\n+          import {Component} from '@angular/core';\n+\n+          export {CmpDep as CmpDepExport};\n+\n+          @Component({\n+            selector: 'cmp-dep',\n+            template: 'Dep',\n+          })\n+          export class CmpDep {}\n+        `);\n+        env.write('module.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {CmpUser} from './cmp-user';\n+          import {CmpDepExport} from './cmp-dep';\n+\n+          @NgModule({\n+            declarations: [CmpUser, CmpDepExport]\n+          })\n+          export class Module {}\n+        `);\n+\n+        env.driveMain();\n+\n+        // Verify that the reference emitter used the export of `CmpDep` that appeared first in\n+        // the source, i.e. `CmpDepExport`.\n+        const userCmpJs = env.getContents('cmp-user.js');\n+        expect(userCmpJs).toContain('CmpDepExport');\n+\n+        env.write('cmp-dep.ts', `\n+          import {Component} from '@angular/core';\n+\n+          export {CmpDep as CmpDepExport2};\n+\n+          @Component({\n+            selector: 'cmp-dep',\n+            template: 'Dep',\n+          })\n+          export class CmpDep {}\n+        `);\n+        env.write('module.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {CmpUser} from './cmp-user';\n+          import {CmpDepExport2} from './cmp-dep';\n+\n+          @NgModule({\n+            declarations: [CmpUser, CmpDepExport2]\n+          })\n+          export class Module {}\n+        `);\n+\n+        env.flushWrittenFileTracking();\n+        env.driveMain();\n+\n+        expectToHaveWritten([\n+          // CmpDep and its module were directly updated.\n+          '/cmp-dep.js',\n+          '/module.js',\n+\n+          // CmpUser required a re-emit because it was previous emitted as `CmpDepExport`, but\n+          // that export has since been renamed.\n+          '/cmp-user.js',\n+        ]);\n+\n+        // Verify that `CmpUser` now correctly imports `CmpDep` using its renamed\n+        // re-export `CmpDepExport2`.\n+        const userCmp2Js = env.getContents('cmp-user.js');\n+        expect(userCmp2Js).toContain('CmpDepExport2');\n+      });\n+\n+\n+      it('should not recompile components when a directive is changed into a component', () => {\n+        env.write('cmp-user.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'cmp-user',\n+            template: '<div dep></div>',\n+          })\n+          export class CmpUser {}\n+        `);\n+        env.write('dep.ts', `\n+          import {Directive} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dep]',\n+          })\n+          export class Dep {}\n+        `);\n+        env.write('module.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {CmpUser} from './cmp-user';\n+          import {Dep} from './dep';\n+\n+          @NgModule({\n+            declarations: [CmpUser, Dep]\n+          })\n+          export class Module {}\n+        `);\n+\n+        env.driveMain();\n+        env.write('dep.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: '[dep]',\n+            template: 'Dep',\n+          })\n+          export class Dep {}\n+        `);\n+\n+        env.flushWrittenFileTracking();\n+        env.driveMain();\n+\n+        expectToHaveWritten([\n+          // Dep was directly changed.\n+          '/dep.js',\n+\n+          // Module required a re-emit because its direct dependency (Dep) was changed.\n+          '/module.js',\n+\n+          // CmpUser did not require a re-emit because its semantic dependencies were not affected.\n+          // Dep is still matched and still has the same public API.\n+        ]);\n+      });\n+\n+      it('should recompile components when a directive and pipe are swapped', () => {\n+        // CmpUser uses a directive DepA and a pipe DepB, with the same selector/name 'dep'.\n+        //\n+        // During the test, the decorators of DepA and DepB are swapped, effectively changing the\n+        // SemanticSymbol types for them into different species while ensuring that CmpUser's\n+        // template is still valid. The test then verifies that CmpUser is re-emitted.\n+\n+        env.write('cmp-user.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'cmp-user',\n+            template: '<dep>{{1 | dep}}</dep>',\n+          })\n+          export class CmpUser {}\n+        `);\n+        env.write('dep.ts', `\n+          import {Directive, Pipe} from '@angular/core';\n+\n+          @Directive({\n+            selector: 'dep',\n+          })\n+          export class DepA {}\n+\n+          @Pipe({\n+            name: 'dep',\n+          })\n+          export class DepB {}\n+        `);\n+        env.write('module.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {CmpUser} from './cmp-user';\n+          import {DepA, DepB} from './dep';\n+\n+          @NgModule({\n+            declarations: [CmpUser, DepA, DepB],\n+          })\n+          export class Module {}\n+        `);\n+\n+        env.driveMain();\n+\n+        // The annotations on DepA and DepB are swapped. This ensures that when we're comparing the\n+        // public API of these symbols to the prior program, the prior symbols are of a different\n+        // type (pipe vs directive) than the new symbols, which should lead to a re-emit.\n+        env.write('dep.ts', `\n+          import {Directive, Pipe} from '@angular/core';\n+\n+          @Pipe({\n+            name: 'dep',\n+          })\n+          export class DepA {}\n+\n+          @Directive({\n+            selector: 'dep',\n+          })\n+          export class DepB {}\n+        `);\n+\n+        env.flushWrittenFileTracking();\n+        env.driveMain();\n+\n+        expectToHaveWritten([\n+          // Dep was directly changed.\n+          '/dep.js',\n+\n+          // Module required a re-emit because its direct dependency (Dep) was changed.\n+          '/module.js',\n+\n+          // CmpUser required a re-emit because the shape of its matched symbols changed.\n+          '/cmp-user.js',\n+        ]);\n+      });\n+\n+      it('should not recompile components when a component is changed into a directive', () => {\n+        // Testing setup: CmpUser depends on a component Dep with an attribute selector.\n+        //\n+        // During the test, Dep is changed into a directive, and the test verifies that CmpUser is\n+        // not re-emitted (as the public API of a directive and a component are the same).\n+\n+        env.write('cmp-user.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'cmp-user',\n+            template: '<div dep></div>',\n+          })\n+          export class CmpUser {}\n+        `);\n+        env.write('dep.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: '[dep]',\n+            template: 'Dep',\n+          })\n+          export class Dep {}\n+        `);\n+        env.write('module.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {CmpUser} from './cmp-user';\n+          import {Dep} from './dep';\n+\n+          @NgModule({\n+            declarations: [CmpUser, Dep]\n+          })\n+          export class Module {}\n+        `);\n+\n+        env.driveMain();\n+\n+        env.write('dep.ts', `\n+          import {Directive} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dep]',\n+          })\n+          export class Dep {}\n+        `);\n+\n+        env.flushWrittenFileTracking();\n+        env.driveMain();\n+\n+        expectToHaveWritten([\n+          // Dep was directly changed.\n+          '/dep.js',\n+\n+          // Module required a re-emit because its direct dependency (Dep) was changed.\n+          '/module.js',\n+\n+          // CmpUser did not require a re-emit because its semantic dependencies were not affected.\n+          // Dep is still matched and still has the same public API.\n+        ]);\n+      });\n+    });\n+\n+    describe('remote scoping', () => {\n+      it('should not recompile an NgModule nor component when remote scoping is unaffected', () => {\n+        // Testing setup: MyCmpA and MyCmpB are two components with an indirect import cycle. That\n+        // is, each component consumes the other in its template. This forces the compiler to use\n+        // remote scoping to set the directiveDefs of at least one of the components in their\n+        // NgModule.\n+        //\n+        // During the test, an unrelated change is made to the template of MyCmpB, and the test\n+        // verifies that the NgModule for the components is not re-emitted.\n+\n+        env.write('cmp-a-template.html', `<cmp-b><cmp-b>`);\n+        env.write('cmp-a.ts', `\n+             import {Component} from '@angular/core';\n+\n+             @Component({\n+               selector: 'cmp-a',\n+               templateUrl: './cmp-a-template.html',\n+             })\n+             export class MyCmpA {}\n+           `);\n+        env.write('cmp-b-template.html', `<cmp-a><cmp-a>`);\n+        env.write('cmp-b.ts', `\n+             import {Component} from '@angular/core';\n+\n+             @Component({\n+               selector: 'cmp-b',\n+               templateUrl: './cmp-b-template.html',\n+             })\n+             export class MyCmpB {}\n+           `);\n+        env.write('mod.ts', `\n+             import {NgModule} from '@angular/core';\n+             import {MyCmpA} from './cmp-a';\n+             import {MyCmpB} from './cmp-b';\n+\n+             @NgModule({\n+               declarations: [MyCmpA, MyCmpB],\n+             })\n+             export class MyMod {}\n+           `);\n+        env.driveMain();\n+        env.flushWrittenFileTracking();\n+\n+        env.write('cmp-b-template.html', `<cmp-a>Update</cmp-a>`);\n+        env.driveMain();\n+        expectToHaveWritten([\n+          // MyCmpB is written because its template was updated.\n+          '/cmp-b.js',\n+\n+          // MyCmpA should not be written because MyCmpB's public API didn't change.\n+          // MyMod should not be written because remote scoping didn't change.\n+        ]);\n+      });\n+\n+      it('should recompile an NgModule and component when an import cycle is introduced', () => {\n+        // Testing setup: MyCmpA and MyCmpB are two components where MyCmpB consumes MyCmpA in its\n+        // template.\n+        //\n+        // During the test, MyCmpA's template is updated to consume MyCmpB, creating an effective\n+        // import cycle and forcing the compiler to use remote scoping for at least one of the\n+        // components. The test verifies that the components' NgModule is emitted as a result.\n+\n+        env.write('cmp-a-template.html', ``);\n+        env.write('cmp-a.ts', `\n+             import {Component} from '@angular/core';\n+\n+             @Component({\n+               selector: 'cmp-a',\n+               templateUrl: './cmp-a-template.html',\n+             })\n+             export class MyCmpA {}\n+           `);\n+        env.write('cmp-b-template.html', `<cmp-a><cmp-a>`);\n+        env.write('cmp-b.ts', `\n+             import {Component} from '@angular/core';\n+\n+             @Component({\n+               selector: 'cmp-b',\n+               templateUrl: './cmp-b-template.html',\n+             })\n+             export class MyCmpB {}\n+           `);\n+        env.write('mod.ts', `\n+             import {NgModule} from '@angular/core';\n+             import {MyCmpA} from './cmp-a';\n+             import {MyCmpB} from './cmp-b';\n+\n+             @NgModule({\n+               declarations: [MyCmpA, MyCmpB],\n+             })\n+             export class MyMod {}\n+           `);\n+        env.driveMain();\n+        env.flushWrittenFileTracking();\n+\n+        env.write('cmp-a-template.html', `<cmp-b><cmp-b>`);\n+        env.driveMain();\n+        expectToHaveWritten([\n+          // MyMod is written because its remote scopes have changed.\n+          '/mod.js',\n+\n+          // MyCmpA is written because its template was updated.\n+          '/cmp-a.js',\n+\n+          // MyCmpB is written because it now requires remote scoping, where previously it did not.\n+          '/cmp-b.js',\n+        ]);\n+\n+        // Validate the correctness of the assumptions made above:\n+        // * CmpA should not be using remote scoping.\n+        // * CmpB should be using remote scoping.\n+        const moduleJs = env.getContents('mod.js');\n+        expect(moduleJs).not.toContain('setComponentScope(MyCmpA,');\n+        expect(moduleJs).toContain('setComponentScope(MyCmpB,');\n+      });\n+\n+      it('should recompile an NgModule and component when an import cycle is removed', () => {\n+        // Testing setup: MyCmpA and MyCmpB are two components that each consume the other in their\n+        // template, forcing the compiler to utilize remote scoping for at least one of them.\n+        //\n+        // During the test, MyCmpA's template is updated to no longer consume MyCmpB, breaking the\n+        // effective import cycle and causing remote scoping to no longer be required. The test\n+        // verifies that the components' NgModule is emitted as a result.\n+\n+        env.write('cmp-a-template.html', `<cmp-b><cmp-b>`);\n+        env.write('cmp-a.ts', `\n+             import {Component} from '@angular/core';\n+\n+             @Component({\n+               selector: 'cmp-a',\n+               templateUrl: './cmp-a-template.html',\n+             })\n+             export class MyCmpA {}\n+           `);\n+        env.write('cmp-b-template.html', `<cmp-a><cmp-a>`);\n+        env.write('cmp-b.ts', `\n+             import {Component} from '@angular/core';\n+\n+             @Component({\n+               selector: 'cmp-b',\n+               templateUrl: './cmp-b-template.html',\n+             })\n+             export class MyCmpB {}\n+           `);\n+        env.write('mod.ts', `\n+             import {NgModule} from '@angular/core';\n+             import {MyCmpA} from './cmp-a';\n+             import {MyCmpB} from './cmp-b';\n+\n+             @NgModule({\n+               declarations: [MyCmpA, MyCmpB],\n+             })\n+             export class MyMod {}\n+           `);\n+        env.driveMain();\n+\n+        // Validate the correctness of the assumption that CmpB will be the remotely scoped\n+        // component due to the above cycle:\n+        const moduleJs = env.getContents('mod.js');\n+        expect(moduleJs).not.toContain('setComponentScope(MyCmpA,');\n+        expect(moduleJs).toContain('setComponentScope(MyCmpB,');\n+\n+        env.flushWrittenFileTracking();\n+        env.write('cmp-a-template.html', ``);\n+\n+        env.driveMain();\n+        expectToHaveWritten([\n+          // MyMod is written because its remote scopes have changed.\n+          '/mod.js',\n+\n+          // MyCmpA is written because its template was updated.\n+          '/cmp-a.js',\n+\n+          // MyCmpB is written because it no longer needs remote scoping.\n+          '/cmp-b.js',\n+        ]);\n+      });\n+\n+      it('should recompile an NgModule when a remotely scoped component\\'s scope is changed',\n+         () => {\n+           // Testing setup: MyCmpA and MyCmpB are two components that each consume the other in\n+           // their template, forcing the compiler to utilize remote scoping for MyCmpB (which is\n+           // verified). Dir is a directive which is initially unused by either component.\n+           //\n+           // During the test, MyCmpB is updated to additionally consume Dir in its template. This\n+           // changes the remote scope of MyCmpB, requiring a re-emit of its NgModule which the test\n+           // verifies.\n+\n+           env.write('dir.ts', `\n+               import {Directive} from '@angular/core';\n+\n+               @Directive({\n+                 selector: '[dir]',\n+               })\n+               export class Dir {}\n+           `);\n+           env.write('cmp-a-template.html', `<cmp-b><cmp-b>`);\n+           env.write('cmp-a.ts', `\n+               import {Component} from '@angular/core';\n+\n+               @Component({\n+                 selector: 'cmp-a',\n+                 templateUrl: './cmp-a-template.html',\n+               })\n+               export class MyCmpA {}\n+             `);\n+           env.write('cmp-b-template.html', `<cmp-a><cmp-a>`);\n+           env.write('cmp-b.ts', `\n+               import {Component} from '@angular/core';\n+\n+               @Component({\n+                 selector: 'cmp-b',\n+                 templateUrl: './cmp-b-template.html',\n+               })\n+               export class MyCmpB {}\n+             `);\n+           env.write('mod.ts', `\n+               import {NgModule} from '@angular/core';\n+               import {MyCmpA} from './cmp-a';\n+               import {MyCmpB} from './cmp-b';\n+               import {Dir} from './dir';\n+\n+               @NgModule({\n+                 declarations: [MyCmpA, MyCmpB, Dir],\n+               })\n+               export class MyMod {}\n+             `);\n+           env.driveMain();\n+           env.flushWrittenFileTracking();\n+\n+           // Validate the correctness of the assumption that MyCmpB will be remotely scoped:\n+           const moduleJs = env.getContents('mod.js');\n+           expect(moduleJs).not.toContain('setComponentScope(MyCmpA,');\n+           expect(moduleJs).toContain('setComponentScope(MyCmpB,');\n+\n+           env.write('cmp-b-template.html', `<cmp-a dir>Update</cmp-a>`);\n+\n+           env.driveMain();\n+\n+           expectToHaveWritten([\n+             // MyCmpB is written because its template was updated.\n+             '/cmp-b.js',\n+\n+             // MyMod should be written because one of its remotely scoped components has a changed\n+             // scope.\n+             '/mod.js'\n+\n+             // MyCmpA should not be written because none of its dependencies have changed in their\n+             // public API.\n+           ]);\n+         });\n+\n+\n+      it('should recompile an NgModule when its set of remotely scoped components changes', () => {\n+        // Testing setup: three components (MyCmpA, MyCmpB, and MyCmpC) are declared. MyCmpA\n+        // consumes the other two in its template, and MyCmpB consumes MyCmpA creating an effective\n+        // import cycle that forces the compiler to use remote scoping for MyCmpB (which is\n+        // verified).\n+        //\n+        // During the test, MyCmpC's template is changed to depend on MyCmpA, forcing remote\n+        // scoping for it as well. The test verifies that the NgModule is re-emitted as a new\n+        // component within it now requires remote scoping.\n+\n+        env.write('cmp-a-template.html', `<cmp-b><cmp-b> <cmp-c></cmp-c>`);\n+        env.write('cmp-a.ts', `\n+           import {Component} from '@angular/core';\n+\n+           @Component({\n+             selector: 'cmp-a',\n+             templateUrl: './cmp-a-template.html',\n+           })\n+           export class MyCmpA {}\n+         `);\n+        env.write('cmp-b-template.html', `<cmp-a><cmp-a>`);\n+        env.write('cmp-b.ts', `\n+           import {Component} from '@angular/core';\n+\n+           @Component({\n+             selector: 'cmp-b',\n+             templateUrl: './cmp-b-template.html',\n+           })\n+           export class MyCmpB {}\n+         `);\n+\n+        env.write('cmp-c-template.html', ``);\n+        env.write('cmp-c.ts', `\n+        import {Component} from '@angular/core';\n+\n+        @Component({\n+          selector: 'cmp-c',\n+          templateUrl: './cmp-c-template.html',\n+        })\n+        export class MyCmpC {}\n+      `);\n+        env.write('mod.ts', `\n+           import {NgModule} from '@angular/core';\n+           import {MyCmpA} from './cmp-a';\n+           import {MyCmpB} from './cmp-b';\n+           import {MyCmpC} from './cmp-c';\n+\n+           @NgModule({\n+             declarations: [MyCmpA, MyCmpB, MyCmpC],\n+           })\n+           export class MyMod {}\n+         `);\n+        env.driveMain();\n+        env.flushWrittenFileTracking();\n+\n+        // Validate the correctness of the assumption that MyCmpB will be the only remotely\n+        // scoped component due to the MyCmpA <-> MyCmpB cycle:\n+        const moduleJsBefore = env.getContents('mod.js');\n+        expect(moduleJsBefore).not.toContain('setComponentScope(MyCmpA,');\n+        expect(moduleJsBefore).toContain('setComponentScope(MyCmpB,');\n+        expect(moduleJsBefore).not.toContain('setComponentScope(MyCmpC,');\n+\n+        env.write('cmp-c-template.html', `<cmp-a>Update</cmp-a>`);\n+        env.driveMain();\n+\n+        // Validate the correctness of the assumption that MyCmpB and MyCmpC are now both\n+        // remotely scoped due to the MyCmpA <-> MyCmpB and MyCmpA <-> MyCmpC cycles:\n+        const moduleJsAfter = env.getContents('mod.js');\n+        expect(moduleJsAfter).not.toContain('setComponentScope(MyCmpA,');\n+        expect(moduleJsAfter).toContain('setComponentScope(MyCmpB,');\n+        expect(moduleJsAfter).toContain('setComponentScope(MyCmpC,');\n+\n+        expectToHaveWritten([\n+          // MyCmpC is written because its template was updated.\n+          '/cmp-c.js',\n+\n+          // MyMod should be written because MyCmpC became remotely scoped\n+          '/mod.js'\n+\n+          // MyCmpA and MyCmpB should not be written because none of their dependencies have\n+          // changed in their public API.\n+        ]);\n+      });\n+    });\n+\n+    describe('NgModule declarations', () => {\n+      it('should recompile components when a matching directive is added in the direct scope',\n+         () => {\n+           // Testing setup: A component Cmp has a template which would match a directive Dir,\n+           // except Dir is not included in Cmp's NgModule.\n+           //\n+           // During the test, Dir is added to the NgModule, causing it to begin matching in Cmp's\n+           // template. The test verifies that Cmp is re-emitted to account for this.\n+\n+           env.write('dir.ts', `\n+             import {Directive} from '@angular/core';\n+\n+             @Directive({\n+               selector: '[dir]',\n+             })\n+             export class Dir {}\n+           `);\n+\n+           env.write('cmp.ts', `\n+             import {Component} from '@angular/core';\n+\n+             @Component({\n+               selector: 'test-cmp',\n+               template: '<div dir></div>',\n+             })\n+             export class Cmp {}\n+           `);\n+\n+           env.write('mod.ts', `\n+             import {NgModule} from '@angular/core';\n+             import {Cmp} from './cmp';\n+\n+             @NgModule({\n+               declarations: [Cmp],\n+             })\n+             export class Mod {}\n+           `);\n+\n+           env.driveMain();\n+           env.flushWrittenFileTracking();\n+\n+           env.write('mod.ts', `\n+             import {NgModule} from '@angular/core';\n+             import {Cmp} from './cmp';\n+             import {Dir} from './dir';\n+\n+             @NgModule({\n+               declarations: [Cmp, Dir],\n+             })\n+             export class Mod {}\n+           `);\n+\n+           env.driveMain();\n+           expectToHaveWritten([\n+             // Mod is written as it was directly changed.\n+             '/mod.js',\n+\n+             // Cmp is written as a matching directive was added to Mod's scope.\n+             '/cmp.js',\n+           ]);\n+         });\n+\n+      it('should recompile components when a matching directive is removed from the direct scope',\n+         () => {\n+           // Testing setup: Cmp is a component with a template that matches a directive Dir.\n+           //\n+           // During the test, Dir is removed from Cmp's NgModule, which causes it to stop matching\n+           // in Cmp's template. The test verifies that Cmp is re-emitted as a result.\n+\n+           env.write('dir.ts', `\n+            import {Directive} from '@angular/core';\n+\n+            @Directive({\n+              selector: '[dir]',\n+            })\n+            export class Dir {}\n+          `);\n+\n+           env.write('cmp.ts', `\n+            import {Component} from '@angular/core';\n+\n+            @Component({\n+              selector: 'test-cmp',\n+              template: '<div dir></div>',\n+            })\n+            export class Cmp {}\n+          `);\n+\n+           env.write('mod.ts', `\n+            import {NgModule} from '@angular/core';\n+            import {Cmp} from './cmp';\n+            import {Dir} from './dir';\n+\n+            @NgModule({\n+              declarations: [Cmp, Dir],\n+            })\n+            export class Mod {}\n+          `);\n+\n+           env.driveMain();\n+           env.flushWrittenFileTracking();\n+\n+           env.write('mod.ts', `\n+            import {NgModule} from '@angular/core';\n+            import {Cmp} from './cmp';\n+\n+            @NgModule({\n+              declarations: [Cmp],\n+            })\n+            export class Mod {}\n+          `);\n+\n+           env.driveMain();\n+           expectToHaveWritten([\n+             // Mod is written as it was directly changed.\n+             '/mod.js',\n+\n+             // Cmp is written as a matching directive was removed from Mod's scope.\n+             '/cmp.js',\n+           ]);\n+         });\n+\n+      it('should recompile components when a matching directive is added in the transitive scope',\n+         () => {\n+           // Testing setup: A component Cmp has a template which would match a directive Dir,\n+           // except Dir is not included in Cmp's NgModule.\n+           //\n+           // During the test, Dir is added to the NgModule via an import, causing it to begin\n+           // matching in Cmp's template. The test verifies that Cmp is re-emitted to account for\n+           // this.\n+\n+           env.write('dir.ts', `\n+            import {Directive} from '@angular/core';\n+\n+            @Directive({\n+              selector: '[dir]',\n+            })\n+            export class Dir {}\n+          `);\n+\n+           env.write('cmp.ts', `\n+            import {Component} from '@angular/core';\n+\n+            @Component({\n+              selector: 'test-cmp',\n+              template: '<div dir></div>',\n+            })\n+            export class Cmp {}\n+          `);\n+\n+           env.write('deep.ts', `\n+            import {NgModule} from '@angular/core';\n+\n+            @NgModule({\n+              declarations: [],\n+              exports: [],\n+            })\n+            export class Deep {}\n+          `);\n+\n+           env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Deep} from './deep';\n+\n+          @NgModule({\n+            declarations: [Cmp],\n+            imports: [Deep],\n+          })\n+          export class Mod {}\n+        `);\n+\n+           env.driveMain();\n+           env.flushWrittenFileTracking();\n+\n+\n+           env.write('deep.ts', `\n+            import {NgModule} from '@angular/core';\n+            import {Dir} from './dir';\n+\n+            @NgModule({\n+              declarations: [Dir],\n+              exports: [Dir],\n+            })\n+            export class Deep {}\n+          `);\n+\n+           env.driveMain();\n+           expectToHaveWritten([\n+             // Mod is written as it was directly changed.\n+             '/deep.js',\n+\n+             // Mod is written as its direct dependency (Deep) was changed.\n+             '/mod.js',\n+\n+             // Cmp is written as a matching directive was added to Mod's transitive scope.\n+             '/cmp.js',\n+           ]);\n+         });\n+\n+      it('should recompile components when a matching directive is removed from the transitive scope',\n+         () => {\n+           // Testing setup: Cmp is a component with a template that matches a directive Dir, due to\n+           // Dir's NgModule being imported into Cmp's NgModule.\n+           //\n+           // During the test, this import link is removed, which causes Dir to stop matching in\n+           // Cmp's template. The test verifies that Cmp is re-emitted as a result.\n+\n+           env.write('dir.ts', `\n+            import {Directive} from '@angular/core';\n+\n+            @Directive({\n+              selector: '[dir]',\n+            })\n+            export class Dir {}\n+          `);\n+\n+           env.write('cmp.ts', `\n+            import {Component} from '@angular/core';\n+\n+            @Component({\n+              selector: 'test-cmp',\n+              template: '<div dir></div>',\n+            })\n+            export class Cmp {}\n+          `);\n+\n+           env.write('deep.ts', `\n+            import {NgModule} from '@angular/core';\n+            import {Dir} from './dir';\n+\n+            @NgModule({\n+              declarations: [Dir],\n+              exports: [Dir],\n+            })\n+            export class Deep {}\n+          `);\n+\n+           env.write('mod.ts', `\n+            import {NgModule} from '@angular/core';\n+            import {Cmp} from './cmp';\n+            import {Deep} from './deep';\n+\n+            @NgModule({\n+              declarations: [Cmp],\n+              imports: [Deep],\n+            })\n+            export class Mod {}\n+          `);\n+\n+           env.driveMain();\n+           env.flushWrittenFileTracking();\n+\n+           env.write('deep.ts', `\n+            import {NgModule} from '@angular/core';\n+\n+            @NgModule({\n+              declarations: [],\n+              exports: [],\n+            })\n+            export class Deep {}\n+          `);\n+\n+           env.driveMain();\n+           expectToHaveWritten([\n+             // Mod is written as it was directly changed.\n+             '/deep.js',\n+\n+             // Mod is written as its direct dependency (Deep) was changed.\n+             '/mod.js',\n+\n+             // Cmp is written as a matching directive was removed from Mod's transitive scope.\n+             '/cmp.js',\n+           ]);\n+         });\n+\n+      it('should not recompile components when a non-matching directive is added in scope', () => {\n+        // Testing setup: A component Cmp has a template which does not match a directive Dir,\n+        // and Dir is not included in Cmp's NgModule.\n+        //\n+        // During the test, Dir is added to the NgModule, making it visible in Cmp's template.\n+        // However, Dir still does not match the template. The test verifies that Cmp is not\n+        // re-emitted.\n+\n+        env.write('dir.ts', `\n+          import {Directive} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir {}\n+        `);\n+\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'test-cmp',\n+            template: '<div></div>',\n+          })\n+          export class Cmp {}\n+        `);\n+\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+\n+          @NgModule({\n+            declarations: [Cmp],\n+          })\n+          export class Mod {}\n+        `);\n+\n+        env.driveMain();\n+        env.flushWrittenFileTracking();\n+\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dir} from './dir';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dir],\n+          })\n+          export class Mod {}\n+        `);\n+\n+        env.driveMain();\n+        expectToHaveWritten([\n+          // Mod is written as it was directly changed.\n+          '/mod.js',\n+\n+          // Cmp is not written as its used directives remains the same, since Dir does not match\n+          // within its template.\n+        ]);\n+      });\n+    });\n+\n+    describe('error recovery', () => {\n+      it('should recompile a component when a matching directive is added that first contains an error',\n+         () => {\n+           // Testing setup: Cmp is a component which would match a directive with the selector\n+           // '[dir]'.\n+           //\n+           // During the test, an initial incremental compilation adds an import to a hypothetical\n+           // directive Dir to the NgModule, and adds Dir as a declaration. However, the import\n+           // points to a non-existent file.\n+           //\n+           // During a second incremental compilation, that missing file is added with a declaration\n+           // for Dir as a directive with the selector '[dir]', causing it to begin matching in\n+           // Cmp's template. The test verifies that Cmp is re-emitted once the program is correct.\n+\n+           env.write('cmp.ts', `\n+            import {Component} from '@angular/core';\n+\n+            @Component({\n+              selector: 'test-cmp',\n+              template: '<div dir></div>',\n+            })\n+            export class Cmp {}\n+          `);\n+\n+           env.write('mod.ts', `\n+            import {NgModule} from '@angular/core';\n+            import {Cmp} from './cmp';\n+\n+            @NgModule({\n+              declarations: [Cmp],\n+            })\n+            export class Mod {}\n+          `);\n+\n+           env.driveMain();\n+           env.flushWrittenFileTracking();\n+\n+           env.write('mod.ts', `\n+            import {NgModule} from '@angular/core';\n+            import {Cmp} from './cmp';\n+            import {Dir} from './dir';\n+\n+            @NgModule({\n+              declarations: [Cmp, Dir],\n+            })\n+            export class Mod {}\n+          `);\n+\n+           expect(env.driveDiagnostics().length).not.toBe(0);\n+\n+           env.write('dir.ts', `\n+          import {Directive} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir {}\n+        `);\n+\n+           env.flushWrittenFileTracking();\n+           env.driveMain();\n+\n+           expectToHaveWritten([\n+             // Mod is written as it was changed in the first incremental compilation, but had\n+             // errors and so was not written then.\n+             '/mod.js',\n+\n+             // Dir is written as it was added in the second incremental compilation.\n+             '/dir.js',\n+\n+             // Cmp is written as the cumulative effect of the two changes was to add Dir to its\n+             // scope and thus match in Cmp's template.\n+             '/cmp.js',\n+           ]);\n+         });\n+    });\n+\n+    it('should correctly emit components when public API changes during a broken program', () => {\n+      // Testing setup: a component Cmp exists with a template that matches directive Dir. Cmp also\n+      // references an extra file with a constant declaration.\n+      //\n+      // During the test, a first incremental compilation both adds an input to Dir (changing its\n+      // public API) as well as introducing a compilation error by adding invalid syntax to the\n+      // extra file.\n+      //\n+      // A second incremental compilation then fixes the invalid syntax, and the test verifies that\n+      // Cmp is re-emitted due to the earlier public API change to Dir.\n+\n+      env.write('other.ts', `\n+        export const FOO = true;\n+      `);\n+      env.write('dir.ts', `\n+        import {Directive, Input} from '@angular/core';\n+\n+        @Directive({\n+          selector: '[dir]',\n+        })\n+        export class Dir {\n+          @Input()\n+          dirIn!: string;\n+        }\n+      `);\n+      env.write('cmp.ts', `\n+        import {Component} from '@angular/core';\n+        import './other';\n+\n+        @Component({\n+          selector: 'test-cmp',\n+          template: '<div dir></div>',\n+        })\n+        export class Cmp {}\n+      `);\n+\n+      env.write('mod.ts', `\n+        import {NgModule} from '@angular/core';\n+        import {Cmp} from './cmp';\n+        import {Dir} from './dir';\n+\n+        @NgModule({\n+          declarations: [Cmp, Dir],\n+        })\n+        export class Mod {}\n+      `);\n+\n+      env.driveMain();\n+\n+      env.flushWrittenFileTracking();\n+      env.write('dir.ts', `\n+      import {Directive, Input} from '@angular/core';\n+\n+      @Directive({\n+        selector: '[dir]',\n+      })\n+      export class Dir {\n+        @Input()\n+        dirIn_changed!: string;\n+      }\n+    `);\n+\n+      env.write('other.ts', `\n+        export const FOO = ;\n+      `);\n+      expect(env.driveDiagnostics().length).not.toBe(0);\n+\n+      env.flushWrittenFileTracking();\n+      env.write('other.ts', `\n+        export const FOO = false;\n+      `);\n+\n+      env.driveMain();\n+      expectToHaveWritten([\n+        // Mod is written as its direct dependency (Dir) was changed.\n+        '/mod.js',\n+\n+        // Dir is written as it was directly changed.\n+        '/dir.js',\n+\n+        // other.js is written as it was directly changed.\n+        '/other.js',\n+\n+        // Cmp is written as Dir's public API has changed.\n+        '/cmp.js',\n+      ]);\n+    });\n+  });\n+});"
        },
        {
            "sha": "2dca44d04df4600aba149a32bbe4741a3fb3e451",
            "filename": "packages/compiler-cli/test/ngtsc/incremental_spec.ts",
            "status": "modified",
            "additions": 52,
            "deletions": 21,
            "changes": 73,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fincremental_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fincremental_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fincremental_spec.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -154,14 +154,20 @@ runInEachFileSystem(() => {\n       setupFooBarProgram(env);\n \n       // Pretend a change was made to BarDir.\n-      env.invalidateCachedFile('bar_directive.ts');\n+      env.write('bar_directive.ts', `\n+        import {Directive} from '@angular/core';\n+\n+        @Directive({selector: '[barr]'})\n+        export class BarDir {}\n+      `);\n       env.driveMain();\n \n       let written = env.getFilesWrittenSinceLastFlush();\n       expect(written).toContain('/bar_directive.js');\n       expect(written).toContain('/bar_component.js');\n       expect(written).toContain('/bar_module.js');\n-      expect(written).toContain('/foo_component.js');\n+      expect(written).not.toContain('/foo_component.js');  // BarDir is not exported by BarModule,\n+                                                           // so upstream NgModule is not affected\n       expect(written).not.toContain('/foo_pipe.js');\n       expect(written).not.toContain('/foo_module.js');\n     });\n@@ -178,7 +184,7 @@ runInEachFileSystem(() => {\n       env.write('component2.ts', `\n         import {Component} from '@angular/core';\n \n-        @Component({selector: 'cmp2', template: 'cmp2'})\n+        @Component({selector: 'cmp2', template: '<cmp></cmp>'})\n         export class Cmp2 {}\n       `);\n       env.write('dep.ts', `\n@@ -197,36 +203,43 @@ runInEachFileSystem(() => {\n         export class MyPipe {}\n       `);\n       env.write('module.ts', `\n-        import {NgModule} from '@angular/core';\n+        import {NgModule, NO_ERRORS_SCHEMA} from '@angular/core';\n         import {Cmp1} from './component1';\n         import {Cmp2} from './component2';\n         import {Dir} from './directive';\n         import {MyPipe} from './pipe';\n \n-        @NgModule({declarations: [Cmp1, Cmp2, Dir, MyPipe]})\n+        @NgModule({declarations: [Cmp1, Cmp2, Dir, MyPipe], schemas: [NO_ERRORS_SCHEMA]})\n         export class Mod {}\n       `);\n       env.driveMain();\n \n-      // Pretend a change was made to 'dep'. Since this may affect the NgModule scope, like it does\n-      // here if the selector is updated, all components in the module scope need to be recompiled.\n+      // Pretend a change was made to 'dep'. Since the selector is updated this affects the NgModule\n+      // scope, so all components in the module scope need to be recompiled.\n       env.flushWrittenFileTracking();\n-      env.invalidateCachedFile('dep.ts');\n+      env.write('dep.ts', `\n+        export const SELECTOR = 'cmp_updated';\n+      `);\n       env.driveMain();\n       const written = env.getFilesWrittenSinceLastFlush();\n       expect(written).not.toContain('/directive.js');\n       expect(written).not.toContain('/pipe.js');\n+      expect(written).not.toContain('/module.js');\n       expect(written).toContain('/component1.js');\n       expect(written).toContain('/component2.js');\n       expect(written).toContain('/dep.js');\n-      expect(written).toContain('/module.js');\n     });\n \n     it('should rebuild components where their NgModule declared dependencies have changed', () => {\n       setupFooBarProgram(env);\n \n-      // Pretend a change was made to FooPipe.\n-      env.invalidateCachedFile('foo_pipe.ts');\n+      // Rename the pipe so components that use it need to be recompiled.\n+      env.write('foo_pipe.ts', `\n+        import {Pipe} from '@angular/core';\n+\n+        @Pipe({name: 'foo_changed'})\n+        export class FooPipe {}\n+      `);\n       env.driveMain();\n       const written = env.getFilesWrittenSinceLastFlush();\n       expect(written).not.toContain('/bar_directive.js');\n@@ -240,15 +253,25 @@ runInEachFileSystem(() => {\n     it('should rebuild components where their NgModule has changed', () => {\n       setupFooBarProgram(env);\n \n-      // Pretend a change was made to FooPipe.\n-      env.invalidateCachedFile('foo_module.ts');\n+      // Pretend a change was made to FooModule.\n+      env.write('foo_module.ts', `\n+        import {NgModule} from '@angular/core';\n+        import {FooCmp} from './foo_component';\n+        import {FooPipe} from './foo_pipe';\n+        import {BarModule} from './bar_module';\n+        @NgModule({\n+          declarations: [FooCmp], // removed FooPipe\n+          imports: [BarModule],\n+        })\n+        export class FooModule {}\n+      `);\n       env.driveMain();\n       const written = env.getFilesWrittenSinceLastFlush();\n       expect(written).not.toContain('/bar_directive.js');\n       expect(written).not.toContain('/bar_component.js');\n       expect(written).not.toContain('/bar_module.js');\n+      expect(written).not.toContain('/foo_pipe.js');\n       expect(written).toContain('/foo_component.js');\n-      expect(written).toContain('/foo_pipe.js');\n       expect(written).toContain('/foo_module.js');\n     });\n \n@@ -396,7 +419,7 @@ runInEachFileSystem(() => {\n       expect(env.getContents('cmp.js')).not.toContain('DepDir');\n     });\n \n-    it('should rebuild only a Component (but with the correct CompilationScope) and its module if its template has changed',\n+    it('should rebuild only a Component (but with the correct CompilationScope) if its template has changed',\n        () => {\n          setupFooBarProgram(env);\n \n@@ -407,9 +430,7 @@ runInEachFileSystem(() => {\n          const written = env.getFilesWrittenSinceLastFlush();\n          expect(written).not.toContain('/bar_directive.js');\n          expect(written).toContain('/bar_component.js');\n-         // /bar_module.js should also be re-emitted, because remote scoping of BarComponent might\n-         // have been affected.\n-         expect(written).toContain('/bar_module.js');\n+         expect(written).not.toContain('/bar_module.js');\n          expect(written).not.toContain('/foo_component.js');\n          expect(written).not.toContain('/foo_pipe.js');\n          expect(written).not.toContain('/foo_module.js');\n@@ -764,7 +785,10 @@ runInEachFileSystem(() => {\n     import {Component} from '@angular/core';\n     import {fooSelector} from './foo_selector';\n \n-    @Component({selector: fooSelector, template: 'foo'})\n+    @Component({\n+      selector: fooSelector,\n+      template: '{{ 1 | foo }}'\n+    })\n     export class FooCmp {}\n   `);\n     env.write('foo_pipe.ts', `\n@@ -796,14 +820,21 @@ runInEachFileSystem(() => {\n \n     @Directive({selector: '[bar]'})\n     export class BarDir {}\n+  `);\n+    env.write('bar_pipe.ts', `\n+    import {Pipe} from '@angular/core';\n+\n+    @Pipe({name: 'foo'})\n+    export class BarPipe {}\n   `);\n     env.write('bar_module.ts', `\n     import {NgModule} from '@angular/core';\n     import {BarCmp} from './bar_component';\n     import {BarDir} from './bar_directive';\n+    import {BarPipe} from './bar_pipe';\n     @NgModule({\n-      declarations: [BarCmp, BarDir],\n-      exports: [BarCmp],\n+      declarations: [BarCmp, BarDir, BarPipe],\n+      exports: [BarCmp, BarPipe],\n     })\n     export class BarModule {}\n   `);"
        },
        {
            "sha": "275d5712407bbb5047ce059151d63419bd97de53",
            "filename": "packages/compiler-cli/test/ngtsc/incremental_typecheck_spec.ts",
            "status": "added",
            "additions": 1396,
            "deletions": 0,
            "changes": 1396,
            "blob_url": "https://github.com/angular/angular/blob/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fincremental_typecheck_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fed6a7ce7dca054408540f80dbc7bc3200c8f371/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fincremental_typecheck_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fincremental_typecheck_spec.ts?ref=fed6a7ce7dca054408540f80dbc7bc3200c8f371",
            "patch": "@@ -0,0 +1,1396 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as ts from 'typescript';\n+\n+import {absoluteFrom} from '../../src/ngtsc/file_system';\n+import {runInEachFileSystem} from '../../src/ngtsc/file_system/testing';\n+import {loadStandardTestFiles} from '../../src/ngtsc/testing';\n+\n+import {NgtscTestEnvironment} from './env';\n+\n+const testFiles = loadStandardTestFiles();\n+\n+runInEachFileSystem(() => {\n+  describe('ngtsc incremental compilation (template typecheck)', () => {\n+    let env!: NgtscTestEnvironment;\n+\n+    beforeEach(() => {\n+      env = NgtscTestEnvironment.setup(testFiles);\n+      env.enableMultipleCompilations();\n+      env.tsconfig({strictTemplates: true});\n+    });\n+\n+    describe('type-check api surface', () => {\n+      it('should type-check correctly when a backing input field is renamed', () => {\n+        // This test verifies that renaming the class field of an input is correctly reflected into\n+        // the TCB.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir {\n+            @Input('dir')\n+            dir!: string;\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'test-cmp',\n+            template: '<div [dir]=\"foo\"></div>',\n+          })\n+          export class Cmp {\n+            foo = 'foo';\n+          }\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dir} from './dir';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dir],\n+          })\n+          export class Mod {}\n+        `);\n+        env.driveMain();\n+\n+        // Now rename the backing field of the input; the TCB should be updated such that the `dir`\n+        // input binding is still valid.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir {\n+            @Input('dir')\n+            dirRenamed!: string;\n+          }\n+        `);\n+        env.driveMain();\n+      });\n+\n+      it('should type-check correctly when a backing output field is renamed', () => {\n+        // This test verifies that renaming the class field of an output is correctly reflected into\n+        // the TCB.\n+        env.write('dir.ts', `\n+          import {Directive, EventEmitter, Output} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir {\n+            @Output('dir')\n+            dir = new EventEmitter<string>();\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'test-cmp',\n+            template: '<div (dir)=\"foo($event)\"></div>',\n+          })\n+          export class Cmp {\n+            foo(bar: string) {}\n+          }\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dir} from './dir';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dir],\n+          })\n+          export class Mod {}\n+        `);\n+        env.driveMain();\n+\n+        // Now rename the backing field of the output; the TCB should be updated such that the `dir`\n+        // input binding is still valid.\n+        env.write('dir.ts', `\n+          import {Directive, EventEmitter, Output} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir {\n+            @Output('dir')\n+            dirRenamed = new EventEmitter<string>();\n+          }\n+        `);\n+        env.driveMain();\n+      });\n+\n+      it('should type-check correctly when the backing field of an input is removed', () => {\n+        // For inputs that are only declared in the decorator but for which no backing field is\n+        // declared in the TypeScript class, the TCB should not contain a write to the field as it\n+        // would be an error. This test verifies that the TCB is regenerated when a backing field\n+        // is removed.\n+        env.write('dir.ts', `\n+          import {Directive} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+            inputs: ['dir'],\n+          })\n+          export class Dir {\n+            dir!: string;\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'test-cmp',\n+            template: '<div [dir]=\"foo\"></div>',\n+          })\n+          export class Cmp {\n+            foo = true;\n+          }\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dir} from './dir';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dir],\n+          })\n+          export class Mod {}\n+        `);\n+        const diags = env.driveDiagnostics();\n+        expect(diags.length).toBe(1);\n+        expect(diags[0].messageText)\n+            .toContain(`Type 'boolean' is not assignable to type 'string'.`);\n+\n+        // Now remove the backing field for the `dir` input. The compilation should now succeed\n+        // as there are no type-check errors.\n+        env.write('dir.ts', `\n+          import {Directive} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+            inputs: ['dir'],\n+          })\n+          export class Dir {}\n+        `);\n+        env.driveMain();\n+      });\n+\n+      it('should type-check correctly when the backing field of an input is made readonly', () => {\n+        // When an input is declared as readonly and if `strictInputAccessModifiers` is disabled,\n+        // the TCB contains an indirect write to the property to silence the error that a value\n+        // cannot be assigned to a readonly property. This test verifies that changing a field to\n+        // become readonly does result in the TCB being updated to use such an indirect write, as\n+        // otherwise an error would incorrectly be reported.\n+        env.tsconfig({strictTemplates: true, strictInputAccessModifiers: false});\n+        env.write('dir.ts', `\n+          import {Directive} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+            inputs: ['dir'],\n+          })\n+          export class Dir {\n+            dir!: string;\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'test-cmp',\n+            template: '<div [dir]=\"foo\"></div>',\n+          })\n+          export class Cmp {\n+            foo = 'foo';\n+          }\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dir} from './dir';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dir],\n+          })\n+          export class Mod {}\n+        `);\n+        env.driveMain();\n+\n+        // Now change the `dir` input to be readonly. Because `strictInputAccessModifiers` is\n+        // disabled this should be allowed.\n+        env.write('dir.ts', `\n+          import {Directive} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+            inputs: ['dir'],\n+          })\n+          export class Dir {\n+            readonly dir!: string;\n+          }\n+        `);\n+        env.driveMain();\n+      });\n+\n+      it('should type-check correctly when an ngAcceptInputType field is declared', () => {\n+        // Declaring a static `ngAcceptInputType` member requires that the TCB is regenerated, as\n+        // writes to an input property should then be targeted against this static member instead\n+        // of the input field itself.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir {\n+            @Input()\n+            dir!: string;\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'test-cmp',\n+            template: '<div [dir]=\"foo\"></div>',\n+          })\n+          export class Cmp {\n+            foo = true;\n+          }\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dir} from './dir';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dir],\n+          })\n+          export class Mod {}\n+        `);\n+        const diags = env.driveDiagnostics();\n+        expect(diags.length).toBe(1);\n+        expect(diags[0].messageText)\n+            .toContain(`Type 'boolean' is not assignable to type 'string'.`);\n+\n+        // Now add an `ngAcceptInputType` static member to the directive such that its `dir` input\n+        // also accepts `boolean`, unlike the type of `dir`'s class field. This should therefore\n+        // allow the compilation to succeed.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir {\n+            @Input()\n+            dir!: string;\n+\n+            static ngAcceptInputType_dir: string | boolean;\n+          }\n+        `);\n+        env.driveMain();\n+      });\n+\n+      it('should type-check correctly when an ngTemplateContextGuard field is declared', () => {\n+        // This test adds an `ngTemplateContextGuard` static member to verify that the TCB is\n+        // regenerated for the template context to take effect.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir {\n+            @Input()\n+            dir!: string;\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'test-cmp',\n+            template: '<div *dir=\"let bar\">{{ foo(bar) }}</div>',\n+          })\n+          export class Cmp {\n+            foo(bar: string) {}\n+          }\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dir} from './dir';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dir],\n+          })\n+          export class Mod {}\n+        `);\n+        env.driveMain();\n+\n+        // Now add the template context to declare the `$implicit` variable to be of type `number`.\n+        // Doing so should report an error for `Cmp`, as the type of `bar` which binds to\n+        // `$implicit` is no longer compatible with the method signature which requires a `string`.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          export interface TemplateContext {\n+            $implicit: number;\n+          }\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir {\n+            @Input()\n+            dir!: string;\n+\n+            static ngTemplateContextGuard(dir: Dir, ctx: any): ctx is TemplateContext { return true; }\n+          }\n+        `);\n+        const diags = env.driveDiagnostics();\n+        expect(diags.length).toBe(1);\n+        expect(diags[0].messageText)\n+            .toContain(\n+                `Argument of type 'number' is not assignable to parameter of type 'string'.`);\n+      });\n+\n+      it('should type-check correctly when an ngTemplateGuard field is declared', () => {\n+        // This test verifies that adding an `ngTemplateGuard` static member has the desired effect\n+        // of type-narrowing the bound input expression within the template.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir {\n+            @Input()\n+            dir!: boolean;\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'test-cmp',\n+            template: '<div *dir=\"foo !== null\">{{ test(foo) }}</div>',\n+          })\n+          export class Cmp {\n+            foo!: string | null;\n+            test(foo: string) {}\n+          }\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dir} from './dir';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dir],\n+          })\n+          export class Mod {}\n+        `);\n+        const diags = env.driveDiagnostics();\n+        expect(diags.length).toBe(1);\n+        expect(ts.flattenDiagnosticMessageText(diags[0].messageText, '\\n'))\n+            .toContain(\n+                `Argument of type 'string | null' is not assignable to parameter of type 'string'.`);\n+\n+        // Now resolve the compilation error by adding the `ngTemplateGuard_dir` static member to\n+        // specify that the bound expression for `dir` should be used as template guard. This\n+        // should allow the compilation to succeed.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          export interface TemplateContext {\n+            $implicit: number;\n+          }\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir {\n+            @Input()\n+            dir!: boolean;\n+\n+            static ngTemplateGuard_dir: 'binding';\n+          }\n+        `);\n+        env.driveMain();\n+      });\n+\n+      it('should type-check correctly when the type of an ngTemplateGuard field changes', () => {\n+        // This test verifies that changing the type of an `ngTemplateGuard` static member has the\n+        // desired effect of type-narrowing the bound input expression within the template according\n+        // to the new type of the `ngTemplateGuard` static member. Initially, an \"invocation\" type\n+        // context guard is used, but it's ineffective at narrowing an expression that explicitly\n+        // compares against null. An incremental step changes the type of the guard to be of type\n+        // `binding`.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir<T> {\n+            @Input()\n+            dir!: T;\n+\n+            static ngTemplateGuard_dir<T>(dir: Dir<T>, expr: any): expr is NonNullable<T> { return true; };\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'test-cmp',\n+            template: '<div *dir=\"foo !== null\">{{ test(foo) }}</div>',\n+          })\n+          export class Cmp {\n+            foo!: string | null;\n+            test(foo: string) {}\n+          }\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dir} from './dir';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dir],\n+          })\n+          export class Mod {}\n+        `);\n+        const diags = env.driveDiagnostics();\n+        expect(diags.length).toBe(1);\n+        expect(ts.flattenDiagnosticMessageText(diags[0].messageText, '\\n'))\n+            .toContain(\n+                `Argument of type 'string | null' is not assignable to parameter of type 'string'.`);\n+\n+        // Now change the type of the template guard into \"binding\" to achieve the desired narrowing\n+        // of `foo`, allowing the compilation to succeed.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          export interface TemplateContext {\n+            $implicit: number;\n+          }\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir<T> {\n+            @Input()\n+            dir!: T;\n+\n+            static ngTemplateGuard_dir: 'binding';\n+          }\n+        `);\n+        env.driveMain();\n+      });\n+\n+      it('should type-check correctly when the name of an ngTemplateGuard field changes', () => {\n+        // This test verifies that changing the name of the field to which an `ngTemplateGuard`\n+        // static member applies correctly removes its narrowing effect on the original input\n+        // binding expression.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir<T> {\n+            @Input()\n+            dir!: T;\n+\n+            static ngTemplateGuard_dir: 'binding';\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'test-cmp',\n+            template: '<div *dir=\"foo !== null\">{{ test(foo) }}</div>',\n+          })\n+          export class Cmp {\n+            foo!: string | null;\n+            test(foo: string) {}\n+          }\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dir} from './dir';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dir],\n+          })\n+          export class Mod {}\n+        `);\n+        env.driveMain();\n+\n+        // Now change the `ngTemplateGuard` to target a different field. The `dir` binding should\n+        // no longer be narrowed, causing the template of `Cmp` to become invalid.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          export interface TemplateContext {\n+            $implicit: number;\n+          }\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir<T> {\n+            @Input()\n+            dir!: T;\n+\n+            static ngTemplateGuard_dir_renamed: 'binding';\n+          }\n+        `);\n+        const diags = env.driveDiagnostics();\n+        expect(diags.length).toBe(1);\n+        expect(ts.flattenDiagnosticMessageText(diags[0].messageText, '\\n'))\n+            .toContain(\n+                `Argument of type 'string | null' is not assignable to parameter of type 'string'.`);\n+      });\n+    });\n+\n+    describe('type parameters', () => {\n+      it('should type-check correctly when directive becomes generic', () => {\n+        // This test verifies that changing a non-generic directive `Dir` into a generic directive\n+        // correctly type-checks component `Cmp` that uses `Dir` in its template. The introduction\n+        // of the generic type requires that `Cmp`'s local declaration of `Dir` is also updated,\n+        // otherwise the prior declaration without generic type argument would be invalid.\n+\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir {\n+            @Input()\n+            dir!: string;\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'test-cmp',\n+            template: '<div [dir]=\"foo\"></div>',\n+          })\n+          export class Cmp {\n+            foo = 'foo';\n+          }\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dir} from './dir';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dir],\n+          })\n+          export class Mod {}\n+        `);\n+        env.driveMain();\n+\n+        // Adding a generic type should still allow the compilation to succeed.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir<T> {\n+            @Input()\n+            dir!: string;\n+          }\n+        `);\n+        env.driveMain();\n+      });\n+\n+      it('should type-check correctly when a type parameter is added to a directive', () => {\n+        // This test verifies that adding an additional generic type to directive `Dir` correctly\n+        // type-checks component `Cmp` that uses `Dir` in its template. The addition of a generic\n+        // type requires that `Cmp`'s local declaration of `Dir` is also updated, otherwise the\n+        // prior declaration with fewer generic type argument would be invalid.\n+\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir<T> {\n+            @Input()\n+            dir!: T;\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'test-cmp',\n+            template: '<div [dir]=\"foo\"></div>',\n+          })\n+          export class Cmp {\n+            foo = 'foo';\n+          }\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dir} from './dir';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dir],\n+          })\n+          export class Mod {}\n+        `);\n+        env.driveMain();\n+\n+        // Add generic type parameter `U` should continue to allow the compilation to succeed.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir<T, U> {\n+            @Input()\n+            dir!: T;\n+          }\n+        `);\n+        env.driveMain();\n+      });\n+\n+      it('should type-check correctly when directive removes its generic type parameter', () => {\n+        // This test verifies that removing a type parameter from generic directive `Dir` such that\n+        // it becomes non-generic correctly type-checks component `Cmp` that uses `Dir` in its\n+        // template. The removal of the generic type requires that `Cmp`'s local declaration of\n+        // `Dir` is also updated, as otherwise the prior declaration with a generic type argument\n+        // would be invalid.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir<T> {\n+            @Input()\n+            dir!: string;\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'test-cmp',\n+            template: '<div [dir]=\"foo\"></div>',\n+          })\n+          export class Cmp {\n+            foo = 'foo';\n+          }\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dir} from './dir';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dir],\n+          })\n+          export class Mod {}\n+        `);\n+        env.driveMain();\n+\n+        // Changing `Dir` to become non-generic should allow the compilation to succeed.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir {\n+            @Input()\n+            dir!: string;\n+          }\n+        `);\n+        env.driveMain();\n+      });\n+\n+      it('should type-check correctly when a type parameter is removed from a directive', () => {\n+        // This test verifies that removing a type parameter from generic directive `Dir` correctly\n+        // type-checks component `Cmp` that uses `Dir` in its template. The removal of the generic\n+        // type requires that `Cmp`'s local declaration of `Dir` is also updated, as otherwise the\n+        // prior declaration with the initial number of generic type arguments would be invalid.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir<T, U> {\n+            @Input()\n+            dir!: T;\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'test-cmp',\n+            template: '<div [dir]=\"foo\"></div>',\n+          })\n+          export class Cmp {\n+            foo = 'foo';\n+          }\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dir} from './dir';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dir],\n+          })\n+          export class Mod {}\n+        `);\n+        env.driveMain();\n+\n+        // Removing type parameter `U` should allow the compilation to succeed.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir<T> {\n+            @Input()\n+            dir!: T;\n+          }\n+        `);\n+        env.driveMain();\n+      });\n+\n+      it('should type-check correctly when a generic type bound is added', () => {\n+        // This test verifies that changing an unbound generic type parameter of directive `Dir`\n+        // to have a type constraint properly applies the newly added type constraint during\n+        // type-checking of `Cmp` that uses `Dir` in its template.\n+        env.write('node_modules/foo/index.ts', `\n+          export interface Foo {\n+            a: boolean;\n+          }\n+        `);\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir<T> {\n+            @Input()\n+            dir!: T;\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'test-cmp',\n+            template: '<div [dir]=\"foo\"></div>',\n+          })\n+          export class Cmp {\n+            foo: string;\n+          }\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dir} from './dir';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dir],\n+          })\n+          export class Mod {}\n+        `);\n+        env.driveMain();\n+\n+        // Update `Dir` such that its generic type parameter `T` is constrained to type `Foo`. The\n+        // template of `Cmp` should now fail to type-check, as its bound value for `T` does not\n+        // conform to the `Foo` constraint.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+          import {Foo} from 'foo';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir<T extends Foo> {\n+            @Input()\n+            dir!: T;\n+          }\n+        `);\n+\n+        const diags = env.driveDiagnostics();\n+        expect(diags.length).toBe(1);\n+        expect(diags[0].messageText).toContain(`Type 'string' is not assignable to type 'Foo'.`);\n+\n+        // Now update `Dir` again to remove the constraint of `T`, which should allow the template\n+        // of `Cmp` to succeed type-checking.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir<T> {\n+            @Input()\n+            dir!: T;\n+          }\n+        `);\n+        env.driveMain();\n+      });\n+\n+      it('should type-check correctly when a generic type bound indirectly changes', () => {\n+        // This test verifies the scenario where a generic type constraint is updated indirectly,\n+        // i.e. without the type parameter itself changing. The setup of this test is as follows:\n+        //\n+        // - Have two external modules `foo-a` and `foo-b` that both export a type named `Foo`,\n+        //   each having an incompatible shape.\n+        // - Have a directive `Dir` that has a type parameter constrained to `Foo` from `foo-a`.\n+        // - Have a component `Cmp` that uses `Dir` in its template and binds a `Foo` from `foo-a`\n+        //   to an input of `Dir` of generic type `T`. This should succeed as it conforms to the\n+        //   constraint of `T`.\n+        // - Perform an incremental compilation where the import of `Foo` is changed into `foo-b`.\n+        //   The binding in `Cmp` should now report an error, as its value of `Foo` from `foo-a`\n+        //   no longer conforms to the new type constraint of `Foo` from 'foo-b'.\n+        env.write('node_modules/foo-a/index.ts', `\n+          export interface Foo {\n+            a: boolean;\n+          }\n+        `);\n+        env.write('node_modules/foo-b/index.ts', `\n+          export interface Foo {\n+            b: boolean;\n+          }\n+        `);\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+          import {Foo} from 'foo-a';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir<T extends Foo> {\n+            @Input()\n+            dir!: T;\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+          import {Foo} from 'foo-a';\n+\n+          @Component({\n+            selector: 'test-cmp',\n+            template: '<div [dir]=\"foo\"></div>',\n+          })\n+          export class Cmp {\n+            foo: Foo = {a: true};\n+          }\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dir} from './dir';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dir],\n+          })\n+          export class Mod {}\n+        `);\n+        env.driveMain();\n+\n+        // Now switch the import of `Foo` from `foo-a` to `foo-b`. This should cause a type-check\n+        // failure in `Cmp`, as its binding into `Dir` still provides an incompatible `Foo`\n+        // from `foo-a`.\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+          import {Foo} from 'foo-b';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir<T extends Foo> {\n+            @Input()\n+            dir!: T;\n+          }\n+        `);\n+\n+        const diags = env.driveDiagnostics();\n+        expect(diags.length).toBe(1);\n+        expect(diags[0].messageText)\n+            .toContain(`Type 'import(\"${\n+                absoluteFrom(\n+                    '/node_modules/foo-a/index')}\").Foo' is not assignable to type 'import(\"${\n+                absoluteFrom('/node_modules/foo-b/index')}\").Foo'.`);\n+\n+        // For completeness, update `Cmp` to address the previous template type-check error by\n+        // changing the type of the binding into `Dir` to also be the `Foo` from `foo-b`. This\n+        // should result in a successful compilation.\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+          import {Foo} from 'foo-b';\n+\n+          @Component({\n+            selector: 'test-cmp',\n+            template: '<div [dir]=\"foo\"></div>',\n+          })\n+          export class Cmp {\n+            foo: Foo = {b: true};\n+          }\n+        `);\n+        env.driveMain();\n+      });\n+    });\n+\n+    describe('inheritance', () => {\n+      it('should type-check derived directives when the public API of the parent class is affected',\n+         () => {\n+           // This test verifies that an indirect change to the public API of `Dir` as caused by a\n+           // change to `Dir`'s base class `Parent` causes the type-check result of component `Cmp`\n+           // that uses `Dir` to be updated accordingly.\n+           env.write('parent.ts', `\n+             import {Directive, Input} from '@angular/core';\n+\n+             @Directive()\n+             export class Parent {\n+               @Input()\n+               parent!: string;\n+             }\n+           `);\n+           env.write('dir.ts', `\n+             import {Directive, Input} from '@angular/core';\n+             import {Parent} from './parent';\n+\n+             @Directive({\n+               selector: '[dir]',\n+             })\n+             export class Dir extends Parent {\n+               @Input()\n+               dir!: string;\n+             }\n+           `);\n+           env.write('cmp.ts', `\n+             import {Component} from '@angular/core';\n+\n+             @Component({\n+               selector: 'test-cmp',\n+               template: '<div [dir]=\"foo\" [parent]=\"foo\"></div>',\n+             })\n+             export class Cmp {\n+               foo = 'foo';\n+             }\n+           `);\n+           env.write('mod.ts', `\n+             import {NgModule} from '@angular/core';\n+             import {Cmp} from './cmp';\n+             import {Dir} from './dir';\n+\n+             @NgModule({\n+               declarations: [Cmp, Dir],\n+             })\n+             export class Mod {}\n+           `);\n+           env.driveMain();\n+\n+           // Now remove an input from `Parent`. This invalidates the binding in `Cmp`'s template,\n+           // so an error diagnostic should be reported.\n+           env.write('parent.ts', `\n+             import {Directive, Input} from '@angular/core';\n+\n+             @Directive()\n+             export class Parent {\n+\n+             }\n+           `);\n+           const diags = env.driveDiagnostics();\n+           expect(diags.length).toBe(1);\n+           expect(diags[0].messageText)\n+               .toContain(`Can't bind to 'parent' since it isn't a known property of 'div'.`);\n+         });\n+\n+      it('should type-check derived directives when the public API of the grandparent class is affected',\n+         () => {\n+           // This test verifies that an indirect change to the public API of `Dir` as caused by a\n+           // change to `Dir`'s transitive base class `Grandparent` causes the type-check result of\n+           // component `Cmp` that uses `Dir` to be updated accordingly.\n+           env.write('grandparent.ts', `\n+             import {Directive, Input} from '@angular/core';\n+\n+             @Directive()\n+             export class Grandparent {\n+               @Input()\n+               grandparent!: string;\n+             }\n+           `);\n+           env.write('parent.ts', `\n+             import {Directive, Input} from '@angular/core';\n+             import {Grandparent} from './grandparent';\n+\n+             @Directive()\n+             export class Parent extends Grandparent {\n+               @Input()\n+               parent!: string;\n+             }\n+           `);\n+           env.write('dir.ts', `\n+             import {Directive, Input} from '@angular/core';\n+             import {Parent} from './parent';\n+\n+             @Directive({\n+               selector: '[dir]',\n+             })\n+             export class Dir extends Parent {\n+               @Input()\n+               dir!: string;\n+             }\n+           `);\n+           env.write('cmp.ts', `\n+             import {Component} from '@angular/core';\n+\n+             @Component({\n+               selector: 'test-cmp',\n+               template: '<div [dir]=\"foo\" [parent]=\"foo\" [grandparent]=\"foo\"></div>',\n+             })\n+             export class Cmp {\n+               foo = 'foo';\n+             }\n+           `);\n+           env.write('mod.ts', `\n+             import {NgModule} from '@angular/core';\n+             import {Cmp} from './cmp';\n+             import {Dir} from './dir';\n+\n+             @NgModule({\n+               declarations: [Cmp, Dir],\n+             })\n+             export class Mod {}\n+           `);\n+           env.driveMain();\n+\n+           // Now remove an input from `Grandparent`. This invalidates the binding in `Cmp`'s\n+           // template, so an error diagnostic should be reported.\n+           env.write('grandparent.ts', `\n+             import {Directive, Input} from '@angular/core';\n+\n+             @Directive()\n+             export class Grandparent {\n+\n+             }\n+          `);\n+           const diags = env.driveDiagnostics();\n+           expect(diags.length).toBe(1);\n+           expect(diags[0].messageText)\n+               .toContain(`Can't bind to 'grandparent' since it isn't a known property of 'div'.`);\n+         });\n+\n+      it('should type-check derived directives when a base class is added to a grandparent', () => {\n+        // This test verifies that an indirect change to the public API of `Dir` as caused by\n+        // adding a base class `Grandgrandparent` to `Dir`'s transitive base class `Grandparent`\n+        // causes the type-check result of component `Cmp` that uses `Dir` to be\n+        // updated accordingly.\n+        env.write('grandgrandparent.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive()\n+          export class Grandgrandparent {\n+            @Input()\n+            grandgrandparent!: string;\n+          }\n+        `);\n+        env.write('grandparent.ts', `\n+          import {Directive, Input} from '@angular/core';\n+\n+          @Directive()\n+          export class Grandparent {\n+            @Input()\n+            grandparent!: string;\n+          }\n+        `);\n+        env.write('parent.ts', `\n+          import {Directive, Input} from '@angular/core';\n+          import {Grandparent} from './grandparent';\n+\n+          @Directive()\n+          export class Parent extends Grandparent {\n+            @Input()\n+            parent!: string;\n+          }\n+        `);\n+        env.write('dir.ts', `\n+          import {Directive, Input} from '@angular/core';\n+          import {Parent} from './parent';\n+\n+          @Directive({\n+            selector: '[dir]',\n+          })\n+          export class Dir extends Parent {\n+            @Input()\n+            dir!: string;\n+          }\n+        `);\n+        env.write('cmp.ts', `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            selector: 'test-cmp',\n+            template: '<div [dir]=\"foo\" [parent]=\"foo\" [grandgrandparent]=\"foo\"></div>',\n+          })\n+          export class Cmp {\n+            foo = 'foo';\n+          }\n+        `);\n+        env.write('mod.ts', `\n+          import {NgModule} from '@angular/core';\n+          import {Cmp} from './cmp';\n+          import {Dir} from './dir';\n+\n+          @NgModule({\n+            declarations: [Cmp, Dir],\n+          })\n+          export class Mod {}\n+        `);\n+\n+        // `Cmp` already binds to the `grandgrandparent` input but it's not available, as\n+        // `Granparent` does not yet extend from `Grandgrandparent`.\n+        const diags = env.driveDiagnostics();\n+        expect(diags.length).toBe(1);\n+        expect(diags[0].messageText)\n+            .toContain(\n+                `Can't bind to 'grandgrandparent' since it isn't a known property of 'div'.`);\n+\n+        // Now fix the issue by adding the base class to `Grandparent`; this should allow\n+        // type-checking to succeed.\n+        env.write('grandparent.ts', `\n+          import {Directive, Input} from '@angular/core';\n+          import {Grandgrandparent} from './grandgrandparent';\n+\n+          @Directive()\n+          export class Grandparent extends Grandgrandparent {\n+            @Input()\n+            grandparent!: string;\n+          }\n+        `);\n+        env.driveMain();\n+      });\n+\n+      it('should type-check derived directives when a base class is removed from a grandparent',\n+         () => {\n+           // This test verifies that an indirect change to the public API of `Dir` as caused by\n+           // removing a base class `Grandgrandparent` from `Dir`'s transitive base class\n+           // `Grandparent` causes the type-check result of component `Cmp` that uses `Dir` to be\n+           // updated accordingly.\n+           env.write('grandgrandparent.ts', `\n+             import {Directive, Input} from '@angular/core';\n+\n+             @Directive()\n+             export class Grandgrandparent {\n+               @Input()\n+               grandgrandparent!: string;\n+             }\n+           `);\n+           env.write('grandparent.ts', `\n+             import {Directive, Input} from '@angular/core';\n+             import {Grandgrandparent} from './grandgrandparent';\n+\n+             @Directive()\n+             export class Grandparent extends Grandgrandparent {\n+               @Input()\n+               grandparent!: string;\n+             }\n+           `);\n+           env.write('parent.ts', `\n+             import {Directive, Input} from '@angular/core';\n+             import {Grandparent} from './grandparent';\n+\n+             @Directive()\n+             export class Parent extends Grandparent {\n+               @Input()\n+               parent!: string;\n+             }\n+           `);\n+           env.write('dir.ts', `\n+             import {Directive, Input} from '@angular/core';\n+             import {Parent} from './parent';\n+\n+             @Directive({\n+               selector: '[dir]',\n+             })\n+             export class Dir extends Parent {\n+               @Input()\n+               dir!: string;\n+             }\n+           `);\n+           env.write('cmp.ts', `\n+             import {Component} from '@angular/core';\n+\n+             @Component({\n+               selector: 'test-cmp',\n+               template: '<div [dir]=\"foo\" [parent]=\"foo\" [grandgrandparent]=\"foo\"></div>',\n+             })\n+             export class Cmp {\n+               foo = 'foo';\n+             }\n+           `);\n+           env.write('mod.ts', `\n+             import {NgModule} from '@angular/core';\n+             import {Cmp} from './cmp';\n+             import {Dir} from './dir';\n+\n+             @NgModule({\n+               declarations: [Cmp, Dir],\n+             })\n+             export class Mod {}\n+           `);\n+           env.driveMain();\n+\n+           // Removing the base class from `Grandparent` should start to report a type-check\n+           // error in `Cmp`'s template, as its binding to the `grandgrandparent` input is no\n+           // longer valid.\n+           env.write('grandparent.ts', `\n+             import {Directive, Input} from '@angular/core';\n+\n+             @Directive()\n+             export class Grandparent {\n+               @Input()\n+               grandparent!: string;\n+             }\n+           `);\n+           const diags = env.driveDiagnostics();\n+           expect(diags.length).toBe(1);\n+           expect(diags[0].messageText)\n+               .toContain(\n+                   `Can't bind to 'grandgrandparent' since it isn't a known property of 'div'.`);\n+         });\n+\n+      it('should type-check derived directives when the base class of a grandparent changes',\n+         () => {\n+           // This test verifies that an indirect change to the public API of `Dir` as caused by\n+           // changing the base class of `Dir`'s transitive base class `Grandparent` causes the\n+           // type-check result of component `Cmp` that uses `Dir` to be updated accordingly.\n+           env.write('grandgrandparent-a.ts', `\n+             import {Directive, Input} from '@angular/core';\n+\n+             @Directive()\n+             export class GrandgrandparentA {\n+               @Input()\n+               grandgrandparentA!: string;\n+             }\n+           `);\n+           env.write('grandgrandparent-b.ts', `\n+             import {Directive, Input} from '@angular/core';\n+\n+             @Directive()\n+             export class GrandgrandparentB {\n+               @Input()\n+               grandgrandparentB!: string;\n+             }\n+           `);\n+           env.write('grandparent.ts', `\n+             import {Directive, Input} from '@angular/core';\n+             import {GrandgrandparentA} from './grandgrandparent-a';\n+\n+             @Directive()\n+             export class Grandparent extends GrandgrandparentA {\n+               @Input()\n+               grandparent!: string;\n+             }\n+           `);\n+           env.write('parent.ts', `\n+             import {Directive, Input} from '@angular/core';\n+             import {Grandparent} from './grandparent';\n+\n+             @Directive()\n+             export class Parent extends Grandparent {\n+               @Input()\n+               parent!: string;\n+             }\n+           `);\n+           env.write('dir.ts', `\n+             import {Directive, Input} from '@angular/core';\n+             import {Parent} from './parent';\n+\n+             @Directive({\n+               selector: '[dir]',\n+             })\n+             export class Dir extends Parent {\n+               @Input()\n+               dir!: string;\n+             }\n+           `);\n+           env.write('cmp.ts', `\n+             import {Component} from '@angular/core';\n+\n+             @Component({\n+               selector: 'test-cmp',\n+               template: '<div [dir]=\"foo\" [parent]=\"foo\" [grandgrandparentA]=\"foo\"></div>',\n+             })\n+             export class Cmp {\n+               foo = 'foo';\n+             }\n+           `);\n+           env.write('mod.ts', `\n+             import {NgModule} from '@angular/core';\n+             import {Cmp} from './cmp';\n+             import {Dir} from './dir';\n+\n+             @NgModule({\n+               declarations: [Cmp, Dir],\n+             })\n+             export class Mod {}\n+           `);\n+           env.driveMain();\n+\n+           // Now switch the base class of `Grandparent` from `GrandgrandparentA` to\n+           // `GrandgrandparentB` causes the input binding to `grandgrandparentA` to be reported as\n+           // an error, as it's no longer available.\n+           env.write('grandparent.ts', `\n+             import {Directive, Input} from '@angular/core';\n+             import {GrandgrandparentB} from './grandgrandparent-b';\n+\n+             @Directive()\n+             export class Grandparent extends GrandgrandparentB {\n+               @Input()\n+               grandparent!: string;\n+             }\n+           `);\n+           const diags = env.driveDiagnostics();\n+           expect(diags.length).toBe(1);\n+           expect(diags[0].messageText)\n+               .toContain(\n+                   `Can't bind to 'grandgrandparentA' since it isn't a known property of 'div'.`);\n+         });\n+    });\n+  });\n+});"
        }
    ],
    "stats": {
        "total": 5631,
        "additions": 5253,
        "deletions": 378
    }
}