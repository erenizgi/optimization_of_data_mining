{
    "author": "devversion",
    "message": "fix(migrations): do not incorrectly add todo for @Injectable or @Pipe (#37732)\n\nAs of v10, the `undecorated-classes-with-decorated-fields` migration\ngenerally deals with undecorated classes using Angular features. We\nintended to run this migation as part of v10 again as undecorated\nclasses with Angular features are no longer supported in planned v11.\n\nThe migration currently behaves incorrectly in some cases where an\n`@Injectable` or `@Pipe` decorated classes uses the `ngOnDestroy`\nlifecycle hook. We incorrectly add a TODO for those classes. This\ncommit fixes that.\n\nAdditionally, this change makes the migration more robust to\nnot migrate a class if it inherits from a component, pipe\ninjectable or non-abstract directive. We previously did not\nneed this as the undecorated-classes-with-di migration ran\nbefore, but this is no longer the case.\n\nLast, this commit fixes an issue where multiple TODO's could be\nadded. This happens when multiple Angular CLI build targets have\nan overlap in source files. Multiple programs then capture the\nsame source file, causing the migration to detect an undecorated\nclass multiple times (i.e. adding a TODO twice).\n\nFixes #37726.\n\nPR Close #37732",
    "sha": "d12cdb50195b530d9fee1a06f4b0494084b5cf76",
    "files": [
        {
            "sha": "ade71e3dfaf0ab37fa282a1abda99d35bae9866a",
            "filename": "integration/ng_update_migrations/src/app/migration-tests/undecorated-classes-with-fields.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 1,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/d12cdb50195b530d9fee1a06f4b0494084b5cf76/integration%2Fng_update_migrations%2Fsrc%2Fapp%2Fmigration-tests%2Fundecorated-classes-with-fields.ts",
            "raw_url": "https://github.com/angular/angular/raw/d12cdb50195b530d9fee1a06f4b0494084b5cf76/integration%2Fng_update_migrations%2Fsrc%2Fapp%2Fmigration-tests%2Fundecorated-classes-with-fields.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/integration%2Fng_update_migrations%2Fsrc%2Fapp%2Fmigration-tests%2Fundecorated-classes-with-fields.ts?ref=d12cdb50195b530d9fee1a06f4b0494084b5cf76",
            "patch": "@@ -4,8 +4,10 @@ import {\n   ElementRef,\n   HostBinding,\n   HostListener,\n+  Injectable,\n   Input,\n-  NgModule\n+  NgModule,\n+  Pipe\n } from '@angular/core';\n \n export class NonAngularBaseClass {\n@@ -76,3 +78,17 @@ export class UndecoratedPipeBase {\n export class WithDirectiveLifecycleHook {\n   ngOnInit() {}\n }\n+\n+// This class is already decorated and should not be migrated. i.e. no TODO\n+// or Angular decorator should be added. `@Injectable` is sufficient.\n+@Injectable()\n+export class MyService {\n+  ngOnDestroy() {}\n+}\n+\n+// This class is already decorated and should not be migrated. i.e. no TODO\n+// or Angular decorator should be added. `@Injectable` is sufficient.\n+@Pipe({name: 'my-pipe'})\n+export class MyPipe {\n+  ngOnDestroy() {}\n+}"
        },
        {
            "sha": "cb6b1e39740281dbee27b2132abc3ec00685a32e",
            "filename": "integration/ng_update_migrations/src/app/migration-tests/undecorated-classes-with-fields_expected.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 1,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/d12cdb50195b530d9fee1a06f4b0494084b5cf76/integration%2Fng_update_migrations%2Fsrc%2Fapp%2Fmigration-tests%2Fundecorated-classes-with-fields_expected.ts",
            "raw_url": "https://github.com/angular/angular/raw/d12cdb50195b530d9fee1a06f4b0494084b5cf76/integration%2Fng_update_migrations%2Fsrc%2Fapp%2Fmigration-tests%2Fundecorated-classes-with-fields_expected.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/integration%2Fng_update_migrations%2Fsrc%2Fapp%2Fmigration-tests%2Fundecorated-classes-with-fields_expected.ts?ref=d12cdb50195b530d9fee1a06f4b0494084b5cf76",
            "patch": "@@ -4,8 +4,10 @@ import {\n   ElementRef,\n   HostBinding,\n   HostListener,\n+  Injectable,\n   Input,\n-  NgModule\n+  NgModule,\n+  Pipe\n } from '@angular/core';\n \n export class NonAngularBaseClass {\n@@ -87,3 +89,17 @@ export class UndecoratedPipeBase {\n export class WithDirectiveLifecycleHook {\n   ngOnInit() {}\n }\n+\n+// This class is already decorated and should not be migrated. i.e. no TODO\n+// or Angular decorator should be added. `@Injectable` is sufficient.\n+@Injectable()\n+export class MyService {\n+  ngOnDestroy() {}\n+}\n+\n+// This class is already decorated and should not be migrated. i.e. no TODO\n+// or Angular decorator should be added. `@Injectable` is sufficient.\n+@Pipe({name: 'my-pipe'})\n+export class MyPipe {\n+  ngOnDestroy() {}\n+}"
        },
        {
            "sha": "ddfe450b6b1ace1980c7e222d5b66df20d80000d",
            "filename": "packages/core/schematics/migrations/undecorated-classes-with-decorated-fields/transform.ts",
            "status": "modified",
            "additions": 129,
            "deletions": 60,
            "changes": 189,
            "blob_url": "https://github.com/angular/angular/blob/d12cdb50195b530d9fee1a06f4b0494084b5cf76/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2Ftransform.ts",
            "raw_url": "https://github.com/angular/angular/raw/d12cdb50195b530d9fee1a06f4b0494084b5cf76/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2Ftransform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2Ftransform.ts?ref=d12cdb50195b530d9fee1a06f4b0494084b5cf76",
            "patch": "@@ -43,27 +43,37 @@ const DIRECTIVE_LIFECYCLE_HOOKS = new Set([\n const AMBIGUOUS_LIFECYCLE_HOOKS = new Set(['ngOnDestroy']);\n \n /** Describes how a given class is used in the context of Angular. */\n-enum ClassKind {\n+enum InferredKind {\n   DIRECTIVE,\n   AMBIGUOUS,\n   UNKNOWN,\n }\n \n+/** Describes possible types of Angular declarations. */\n+enum DeclarationType {\n+  DIRECTIVE,\n+  COMPONENT,\n+  ABSTRACT_DIRECTIVE,\n+  PIPE,\n+  INJECTABLE,\n+}\n+\n /** Analyzed class declaration. */\n interface AnalyzedClass {\n-  /** Whether the class is decorated with @Directive or @Component. */\n-  isDirectiveOrComponent: boolean;\n-  /** Whether the class is an abstract directive. */\n-  isAbstractDirective: boolean;\n-  /** Kind of the given class in terms of Angular. */\n-  kind: ClassKind;\n+  /** Type of declaration that is determined through an applied decorator. */\n+  decoratedType: DeclarationType|null;\n+  /** Inferred class kind in terms of Angular. */\n+  inferredKind: InferredKind;\n }\n \n interface AnalysisFailure {\n   node: ts.Node;\n   message: string;\n }\n \n+/** TODO message that is added to ambiguous classes using Angular features. */\n+const AMBIGUOUS_CLASS_TODO = 'Add Angular decorator.';\n+\n export class UndecoratedClassesWithDecoratedFieldsTransform {\n   private printer = ts.createPrinter();\n   private importManager = new ImportManager(this.getUpdateRecorder, this.printer);\n@@ -81,10 +91,10 @@ export class UndecoratedClassesWithDecoratedFieldsTransform {\n    * indicating that a given class uses Angular features. https://hackmd.io/vuQfavzfRG6KUCtU7oK_EA\n    */\n   migrate(sourceFiles: ts.SourceFile[]): AnalysisFailure[] {\n-    const {result, ambiguous} = this._findUndecoratedAbstractDirectives(sourceFiles);\n+    const {detectedAbstractDirectives, ambiguousClasses} =\n+        this._findUndecoratedAbstractDirectives(sourceFiles);\n \n-\n-    result.forEach(node => {\n+    detectedAbstractDirectives.forEach(node => {\n       const sourceFile = node.getSourceFile();\n       const recorder = this.getUpdateRecorder(sourceFile);\n       const directiveExpr =\n@@ -98,12 +108,19 @@ export class UndecoratedClassesWithDecoratedFieldsTransform {\n     // determine whether the class is used as directive, service or pipe. The migration\n     // could potentially determine the type by checking NgModule definitions or inheritance\n     // of other known declarations, but this is out of scope and a TODO/failure is sufficient.\n-    return Array.from(ambiguous).reduce((failures, node) => {\n+    return Array.from(ambiguousClasses).reduce((failures, node) => {\n+      // If the class has been reported as ambiguous before, skip adding a TODO and\n+      // printing an error. A class could be visited multiple times when it's part\n+      // of multiple build targets in the CLI project.\n+      if (this._hasBeenReportedAsAmbiguous(node)) {\n+        return failures;\n+      }\n+\n       const sourceFile = node.getSourceFile();\n       const recorder = this.getUpdateRecorder(sourceFile);\n \n       // Add a TODO to the class that uses Angular features but is not decorated.\n-      recorder.addClassTodo(node, `Add Angular decorator.`);\n+      recorder.addClassTodo(node, AMBIGUOUS_CLASS_TODO);\n \n       // Add an error for the class that will be printed in the `ng update` output.\n       return failures.concat({\n@@ -125,59 +142,83 @@ export class UndecoratedClassesWithDecoratedFieldsTransform {\n    * directives. Those are ambiguous and could be either Directive, Pipe or service.\n    */\n   private _findUndecoratedAbstractDirectives(sourceFiles: ts.SourceFile[]) {\n-    const result = new Set<ts.ClassDeclaration>();\n+    const ambiguousClasses = new Set<ts.ClassDeclaration>();\n+    const declarations = new WeakMap<ts.ClassDeclaration, DeclarationType>();\n+    const detectedAbstractDirectives = new Set<ts.ClassDeclaration>();\n     const undecoratedClasses = new Set<ts.ClassDeclaration>();\n-    const nonAbstractDirectives = new WeakSet<ts.ClassDeclaration>();\n-    const abstractDirectives = new WeakSet<ts.ClassDeclaration>();\n-    const ambiguous = new Set<ts.ClassDeclaration>();\n \n     const visitNode = (node: ts.Node) => {\n       node.forEachChild(visitNode);\n       if (!ts.isClassDeclaration(node)) {\n         return;\n       }\n-      const {isDirectiveOrComponent, isAbstractDirective, kind} =\n-          this._analyzeClassDeclaration(node);\n-      if (isDirectiveOrComponent) {\n-        if (isAbstractDirective) {\n-          abstractDirectives.add(node);\n-        } else {\n-          nonAbstractDirectives.add(node);\n-        }\n-      } else if (kind === ClassKind.DIRECTIVE) {\n-        abstractDirectives.add(node);\n-        result.add(node);\n+      const {inferredKind, decoratedType} = this._analyzeClassDeclaration(node);\n+\n+      if (decoratedType !== null) {\n+        declarations.set(node, decoratedType);\n+        return;\n+      }\n+\n+      if (inferredKind === InferredKind.DIRECTIVE) {\n+        detectedAbstractDirectives.add(node);\n+      } else if (inferredKind === InferredKind.AMBIGUOUS) {\n+        ambiguousClasses.add(node);\n       } else {\n-        if (kind === ClassKind.AMBIGUOUS) {\n-          ambiguous.add(node);\n-        }\n         undecoratedClasses.add(node);\n       }\n     };\n \n     sourceFiles.forEach(sourceFile => sourceFile.forEachChild(visitNode));\n \n-    // We collected all undecorated class declarations which inherit from abstract directives.\n-    // For such abstract directives, the derived classes also need to be migrated.\n-    undecoratedClasses.forEach(node => {\n-      for (const {node: baseClass} of findBaseClassDeclarations(node, this.typeChecker)) {\n-        // If the undecorated class inherits from a non-abstract directive, skip the current\n-        // class. We do this because undecorated classes which inherit metadata from non-abstract\n-        // directives are handled in the `undecorated-classes-with-di` migration that copies\n-        // inherited metadata into an explicit decorator.\n-        if (nonAbstractDirectives.has(baseClass)) {\n-          break;\n-        } else if (abstractDirectives.has(baseClass)) {\n-          result.add(node);\n-          // In case the undecorated class previously could not be detected as directive,\n-          // remove it from the ambiguous set as we now know that it's a guaranteed directive.\n-          ambiguous.delete(node);\n+    /**\n+     * Checks the inheritance of the given set of classes. It removes classes from the\n+     * detected abstract directives set when they inherit from a non-abstract Angular\n+     * declaration. e.g. an abstract directive can never extend from a component.\n+     *\n+     * If a class inherits from an abstract directive though, we will migrate them too\n+     * as derived classes also need to be decorated. This has been done for a simpler mental\n+     * model and reduced complexity in the Angular compiler. See migration plan document.\n+     */\n+    const checkInheritanceOfClasses = (classes: Set<ts.ClassDeclaration>) => {\n+      classes.forEach(node => {\n+        for (const {node: baseClass} of findBaseClassDeclarations(node, this.typeChecker)) {\n+          if (!declarations.has(baseClass)) {\n+            continue;\n+          }\n+          // If the undecorated class inherits from an abstract directive, always migrate it.\n+          // Derived undecorated classes of abstract directives are always also considered\n+          // abstract directives and need to be decorated too. This is necessary as otherwise\n+          // the inheritance chain cannot be resolved by the Angular compiler. e.g. when it\n+          // flattens directive metadata for type checking. In the other case, we never want\n+          // to migrate a class if it extends from a non-abstract Angular declaration. That\n+          // is an unsupported pattern as of v9 and was previously handled with the\n+          // `undecorated-classes-with-di` migration (which copied the inherited decorator).\n+          if (declarations.get(baseClass) === DeclarationType.ABSTRACT_DIRECTIVE) {\n+            detectedAbstractDirectives.add(node);\n+          } else {\n+            detectedAbstractDirectives.delete(node);\n+          }\n+          ambiguousClasses.delete(node);\n           break;\n         }\n-      }\n-    });\n+      });\n+    };\n \n-    return {result, ambiguous};\n+    // Check inheritance of any detected abstract directive. We want to remove\n+    // classes that are not eligible abstract directives due to inheritance. i.e.\n+    // if a class extends from a component, it cannot be a derived abstract directive.\n+    checkInheritanceOfClasses(detectedAbstractDirectives);\n+    // Update the class declarations to reflect the detected abstract directives. This is\n+    // then used later when we check for undecorated classes that inherit from an abstract\n+    // directive and need to be decorated.\n+    detectedAbstractDirectives.forEach(\n+        n => declarations.set(n, DeclarationType.ABSTRACT_DIRECTIVE));\n+    // Check ambiguous and undecorated classes if they inherit from an abstract directive.\n+    // If they do, we want to migrate them too. See function definition for more details.\n+    checkInheritanceOfClasses(ambiguousClasses);\n+    checkInheritanceOfClasses(undecoratedClasses);\n+\n+    return {detectedAbstractDirectives, ambiguousClasses};\n   }\n \n   /**\n@@ -186,19 +227,30 @@ export class UndecoratedClassesWithDecoratedFieldsTransform {\n    */\n   private _analyzeClassDeclaration(node: ts.ClassDeclaration): AnalyzedClass {\n     const ngDecorators = node.decorators && getAngularDecorators(this.typeChecker, node.decorators);\n-    const kind = this._determineClassKind(node);\n+    const inferredKind = this._determineClassKind(node);\n     if (ngDecorators === undefined || ngDecorators.length === 0) {\n-      return {isDirectiveOrComponent: false, isAbstractDirective: false, kind};\n+      return {decoratedType: null, inferredKind};\n     }\n     const directiveDecorator = ngDecorators.find(({name}) => name === 'Directive');\n     const componentDecorator = ngDecorators.find(({name}) => name === 'Component');\n+    const pipeDecorator = ngDecorators.find(({name}) => name === 'Pipe');\n+    const injectableDecorator = ngDecorators.find(({name}) => name === 'Injectable');\n     const isAbstractDirective =\n         directiveDecorator !== undefined && this._isAbstractDirective(directiveDecorator);\n-    return {\n-      isDirectiveOrComponent: !!directiveDecorator || !!componentDecorator,\n-      isAbstractDirective,\n-      kind,\n-    };\n+\n+    let decoratedType: DeclarationType|null = null;\n+    if (isAbstractDirective) {\n+      decoratedType = DeclarationType.ABSTRACT_DIRECTIVE;\n+    } else if (componentDecorator !== undefined) {\n+      decoratedType = DeclarationType.COMPONENT;\n+    } else if (directiveDecorator !== undefined) {\n+      decoratedType = DeclarationType.DIRECTIVE;\n+    } else if (pipeDecorator !== undefined) {\n+      decoratedType = DeclarationType.PIPE;\n+    } else if (injectableDecorator !== undefined) {\n+      decoratedType = DeclarationType.INJECTABLE;\n+    }\n+    return {decoratedType, inferredKind};\n   }\n \n   /**\n@@ -228,35 +280,52 @@ export class UndecoratedClassesWithDecoratedFieldsTransform {\n    * e.g. lifecycle hooks or decorated members like `@Input` or `@Output` are\n    * considered Angular features..\n    */\n-  private _determineClassKind(node: ts.ClassDeclaration): ClassKind {\n-    let usage = ClassKind.UNKNOWN;\n+  private _determineClassKind(node: ts.ClassDeclaration): InferredKind {\n+    let usage = InferredKind.UNKNOWN;\n \n     for (const member of node.members) {\n       const propertyName = member.name !== undefined ? getPropertyNameText(member.name) : null;\n \n       // If the class declares any of the known directive lifecycle hooks, we can\n       // immediately exit the loop as the class is guaranteed to be a directive.\n       if (propertyName !== null && DIRECTIVE_LIFECYCLE_HOOKS.has(propertyName)) {\n-        return ClassKind.DIRECTIVE;\n+        return InferredKind.DIRECTIVE;\n       }\n \n       const ngDecorators = member.decorators !== undefined ?\n           getAngularDecorators(this.typeChecker, member.decorators) :\n           [];\n       for (const {name} of ngDecorators) {\n         if (DIRECTIVE_FIELD_DECORATORS.has(name)) {\n-          return ClassKind.DIRECTIVE;\n+          return InferredKind.DIRECTIVE;\n         }\n       }\n \n       // If the class declares any of the lifecycle hooks that do not guarantee that\n       // the given class is a directive, update the kind and continue looking for other\n       // members that would unveil a more specific kind (i.e. being a directive).\n       if (propertyName !== null && AMBIGUOUS_LIFECYCLE_HOOKS.has(propertyName)) {\n-        usage = ClassKind.AMBIGUOUS;\n+        usage = InferredKind.AMBIGUOUS;\n       }\n     }\n \n     return usage;\n   }\n+\n+  /**\n+   * Checks whether a given class has been reported as ambiguous in previous\n+   * migration run. e.g. when build targets are migrated first, and then test\n+   * targets that have an overlap with build source files, the same class\n+   * could be detected as ambiguous.\n+   */\n+  private _hasBeenReportedAsAmbiguous(node: ts.ClassDeclaration): boolean {\n+    const sourceFile = node.getSourceFile();\n+    const leadingComments = ts.getLeadingCommentRanges(sourceFile.text, node.pos);\n+    if (leadingComments === undefined) {\n+      return false;\n+    }\n+    return leadingComments.some(\n+        ({kind, pos, end}) => kind === ts.SyntaxKind.SingleLineCommentTrivia &&\n+            sourceFile.text.substring(pos, end).includes(`TODO: ${AMBIGUOUS_CLASS_TODO}`));\n+  }\n }"
        },
        {
            "sha": "04afcf0f30731ecef18c9ad09d47a2d53cc0f4a8",
            "filename": "packages/core/schematics/test/google3/undecorated_classes_with_decorated_fields_spec.ts",
            "status": "modified",
            "additions": 20,
            "deletions": 8,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/d12cdb50195b530d9fee1a06f4b0494084b5cf76/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fundecorated_classes_with_decorated_fields_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/d12cdb50195b530d9fee1a06f4b0494084b5cf76/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fundecorated_classes_with_decorated_fields_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fundecorated_classes_with_decorated_fields_spec.ts?ref=d12cdb50195b530d9fee1a06f4b0494084b5cf76",
            "patch": "@@ -136,24 +136,36 @@ describe('Google3 undecorated classes with decorated fields TSLint rule', () =>\n \n   it('should not change decorated classes', () => {\n     writeFile('/index.ts', `\n-      import { Input, Component, Output, EventEmitter } from '@angular/core';\n+      import { Input, Component, Directive, Pipe, Injectable } from '@angular/core';\n \n       @Component({})\n-      export class Base {\n+      export class MyComp {\n+        @Input() isActive: boolean;\n+      }\n+      \n+      @Directive({selector: 'dir'})\n+      export class MyDir {\n         @Input() isActive: boolean;\n       }\n \n-      export class Child extends Base {\n-        @Output() clicked = new EventEmitter<void>();\n+      @Injectable()\n+      export class MyService {\n+        ngOnDestroy() {}\n+      }\n+      \n+      @Pipe({name: 'my-pipe'})\n+      export class MyPipe {\n+        ngOnDestroy() {}\n       }\n     `);\n \n     runTSLint(true);\n     const content = getFile('/index.ts');\n-    expect(content).toContain(\n-        `import { Input, Component, Output, EventEmitter, Directive } from '@angular/core';`);\n-    expect(content).toContain(`@Component({})\\n      export class Base {`);\n-    expect(content).toContain(`@Directive()\\nexport class Child extends Base {`);\n+    expect(content).toMatch(/@Component\\({}\\)\\s+export class MyComp {/);\n+    expect(content).toMatch(/@Directive\\({selector: 'dir'}\\)\\s+export class MyDir {/);\n+    expect(content).toMatch(/@Injectable\\(\\)\\s+export class MyService {/);\n+    expect(content).toMatch(/@Pipe\\({name: 'my-pipe'}\\)\\s+export class MyPipe {/);\n+    expect(content).not.toContain('TODO');\n   });\n \n   it('should add @Directive to undecorated classes that have @Output', () => {"
        },
        {
            "sha": "f2bcfe2d6f381fbbea6be845ffaace43c79e37e7",
            "filename": "packages/core/schematics/test/helpers.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/d12cdb50195b530d9fee1a06f4b0494084b5cf76/packages%2Fcore%2Fschematics%2Ftest%2Fhelpers.ts",
            "raw_url": "https://github.com/angular/angular/raw/d12cdb50195b530d9fee1a06f4b0494084b5cf76/packages%2Fcore%2Fschematics%2Ftest%2Fhelpers.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fhelpers.ts?ref=d12cdb50195b530d9fee1a06f4b0494084b5cf76",
            "patch": "@@ -9,6 +9,7 @@\n /**\n  * Template string function that can be used to dedent the resulting\n  * string literal. The smallest common indentation will be omitted.\n+ * Additionally, whitespace in empty lines is removed.\n  */\n export function dedent(strings: TemplateStringsArray, ...values: any[]) {\n   let joinedString = '';\n@@ -24,5 +25,7 @@ export function dedent(strings: TemplateStringsArray, ...values: any[]) {\n \n   const minLineIndent = Math.min(...matches.map(el => el.length));\n   const omitMinIndentRegex = new RegExp(`^[ \\\\t]{${minLineIndent}}`, 'gm');\n-  return minLineIndent > 0 ? joinedString.replace(omitMinIndentRegex, '') : joinedString;\n+  const omitEmptyLineWhitespaceRegex = /^[ \\t]+$/gm;\n+  const result = minLineIndent > 0 ? joinedString.replace(omitMinIndentRegex, '') : joinedString;\n+  return result.replace(omitEmptyLineWhitespaceRegex, '');\n }"
        },
        {
            "sha": "9887d4bb1a7144cbe4f074cb47d73040cd89b302",
            "filename": "packages/core/schematics/test/undecorated_classes_with_decorated_fields_migration_spec.ts",
            "status": "modified",
            "additions": 242,
            "deletions": 11,
            "changes": 253,
            "blob_url": "https://github.com/angular/angular/blob/d12cdb50195b530d9fee1a06f4b0494084b5cf76/packages%2Fcore%2Fschematics%2Ftest%2Fundecorated_classes_with_decorated_fields_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/d12cdb50195b530d9fee1a06f4b0494084b5cf76/packages%2Fcore%2Fschematics%2Ftest%2Fundecorated_classes_with_decorated_fields_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fundecorated_classes_with_decorated_fields_migration_spec.ts?ref=d12cdb50195b530d9fee1a06f4b0494084b5cf76",
            "patch": "@@ -11,6 +11,7 @@ import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n import {HostTree} from '@angular-devkit/schematics';\n import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n import * as shx from 'shelljs';\n+import {dedent} from './helpers';\n \n describe('Undecorated classes with decorated fields migration', () => {\n   let runner: SchematicTestRunner;\n@@ -117,26 +118,253 @@ describe('Undecorated classes with decorated fields migration', () => {\n     expect(tree.readContent('/index.ts')).toContain(`@Directive()\\nexport class Base {`);\n   });\n \n-  it('should not change decorated classes', async () => {\n-    writeFile('/index.ts', `\n-      import { Input, Component, Output, EventEmitter } from '@angular/core';\n+  it('should not migrate classes decorated with @Component', async () => {\n+    writeFile('/index.ts', dedent`\n+      import {Input, Component} from '@angular/core';\n \n-      @Component({})\n+      @Component({selector: 'hello', template: 'hello'})\n       export class Base {\n         @Input() isActive: boolean;\n       }\n+      \n+      @Component({selector: 'hello', template: 'hello'})\n+      export class Derived extends Base {\n+        ngOnDestroy() {} \n+      }\n+    `);\n \n-      export class Child extends Base {\n-        @Output() clicked = new EventEmitter<void>();\n+    await runMigration();\n+\n+    expect(warnings.length).toBe(0);\n+    expect(tree.readContent('/index.ts')).toBe(dedent`\n+      import {Input, Component} from '@angular/core';\n+\n+      @Component({selector: 'hello', template: 'hello'})\n+      export class Base {\n+        @Input() isActive: boolean;\n+      }\n+\n+      @Component({selector: 'hello', template: 'hello'})\n+      export class Derived extends Base {\n+        ngOnDestroy() {} \n+      }\n+    `);\n+  });\n+\n+  it('should not migrate classes decorated with @Directive', async () => {\n+    writeFile('/index.ts', dedent`\n+      import {Input, Directive} from '@angular/core';\n+\n+      @Directive()\n+      export class Base {\n+        @Input() isActive: boolean;\n+      }\n+      \n+      @Directive({selector: 'other'})\n+      export class Other extends Base {\n+        ngOnDestroy() {} \n       }\n     `);\n \n     await runMigration();\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toContain(\n-        `import { Input, Component, Output, EventEmitter, Directive } from '@angular/core';`);\n-    expect(content).toContain(`@Component({})\\n      export class Base {`);\n-    expect(content).toContain(`@Directive()\\nexport class Child extends Base {`);\n+\n+    expect(warnings.length).toBe(0);\n+    expect(tree.readContent('/index.ts')).toBe(dedent`\n+      import {Input, Directive} from '@angular/core';\n+\n+      @Directive()\n+      export class Base {\n+        @Input() isActive: boolean;\n+      }\n+      \n+      @Directive({selector: 'other'})\n+      export class Other extends Base {\n+        ngOnDestroy() {} \n+      }\n+    `);\n+  });\n+\n+  it('should not migrate when class inherits from component', async () => {\n+    writeFile('/index.ts', dedent`\n+      import {Input, Component} from '@angular/core';\n+\n+      @Component({selector: 'my-comp', template: 'my-comp'})\n+      export class MyComp {}\n+      \n+      export class WithDisabled extends MyComp {\n+        @Input() disabled: boolean;\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    expect(warnings.length).toBe(0);\n+    expect(tree.readContent('/index.ts')).toBe(dedent`\n+      import {Input, Component} from '@angular/core';\n+\n+      @Component({selector: 'my-comp', template: 'my-comp'})\n+      export class MyComp {}\n+      \n+      export class WithDisabled extends MyComp {\n+        @Input() disabled: boolean;\n+      }\n+    `);\n+  });\n+\n+  it('should not migrate when class inherits from pipe', async () => {\n+    writeFile('/index.ts', dedent`\n+      import {Pipe} from '@angular/core';\n+\n+      @Pipe({name: 'my-pipe'})\n+      export class MyPipe {}\n+      \n+      export class PipeDerived extends MyPipe {\n+        ngOnDestroy() {}\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    expect(warnings.length).toBe(0);\n+    expect(tree.readContent('/index.ts')).toBe(dedent`\n+      import {Pipe} from '@angular/core';\n+\n+      @Pipe({name: 'my-pipe'})\n+      export class MyPipe {}\n+      \n+      export class PipeDerived extends MyPipe {\n+        ngOnDestroy() {}\n+      }\n+    `);\n+  });\n+\n+  it('should not migrate when class inherits from injectable', async () => {\n+    writeFile('/index.ts', dedent`\n+      import {Injectable} from '@angular/core';\n+\n+      @Injectable()\n+      export class MyService {}\n+      \n+      export class ServiceDerived extends MyService {\n+        ngOnDestroy() {}\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    expect(warnings.length).toBe(0);\n+    expect(tree.readContent('/index.ts')).toBe(dedent`\n+      import {Injectable} from '@angular/core';\n+\n+      @Injectable()\n+      export class MyService {}\n+      \n+      export class ServiceDerived extends MyService {\n+        ngOnDestroy() {}\n+      }\n+    `);\n+  });\n+\n+  it('should not migrate when class inherits from directive', async () => {\n+    writeFile('/index.ts', dedent`\n+      import {Directive} from '@angular/core';\n+\n+      @Directive({selector: 'hello'})\n+      export class MyDir {}\n+      \n+      export class DirDerived extends MyDir {\n+        ngOnDestroy() {}\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    expect(warnings.length).toBe(0);\n+    expect(tree.readContent('/index.ts')).toBe(dedent`\n+      import {Directive} from '@angular/core';\n+\n+      @Directive({selector: 'hello'})\n+      export class MyDir {}\n+      \n+      export class DirDerived extends MyDir {\n+        ngOnDestroy() {}\n+      }\n+    `);\n+  });\n+\n+  it('should not add multiple TODOs for ambiguous classes', async () => {\n+    writeFile('/angular.json', JSON.stringify({\n+      projects: {\n+        test: {\n+          architect: {\n+            build: {options: {tsConfig: './tsconfig.json'}},\n+            test: {options: {tsConfig: './tsconfig.json'}},\n+          }\n+        }\n+      }\n+    }));\n+    writeFile('/index.ts', dedent`\n+      export class MyService {\n+        ngOnDestroy() {}\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    expect(tree.readContent('/index.ts')).toBe(dedent`\n+      // TODO: Add Angular decorator.\n+      export class MyService {\n+        ngOnDestroy() {}\n+      }\n+    `);\n+  });\n+\n+  it('should not report pipe using `ngOnDestroy` as ambiguous', async () => {\n+    writeFile('/index.ts', dedent`\n+      import {Pipe} from '@angular/core';\n+\n+      @Pipe({name: 'my-pipe'})\n+      export class MyPipe {\n+        ngOnDestroy() {}\n+        transform() {}\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    expect(warnings.length).toBe(0);\n+    expect(tree.readContent('/index.ts')).toBe(dedent`\n+      import {Pipe} from '@angular/core';\n+\n+      @Pipe({name: 'my-pipe'})\n+      export class MyPipe {\n+        ngOnDestroy() {}\n+        transform() {}\n+      }\n+    `);\n+  });\n+\n+  it('should not report injectable using `ngOnDestroy` as ambiguous', async () => {\n+    writeFile('/index.ts', dedent`\n+      import {Injectable} from '@angular/core';\n+\n+      @Injectable({providedIn: 'root'})\n+      export class MyService {\n+        ngOnDestroy() {}\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    expect(warnings.length).toBe(0);\n+    expect(tree.readContent('/index.ts')).toBe(dedent`\n+      import {Injectable} from '@angular/core';\n+\n+      @Injectable({providedIn: 'root'})\n+      export class MyService {\n+        ngOnDestroy() {}\n+      }\n+    `);\n   });\n \n   it('should add @Directive to undecorated classes that have @Output', async () => {\n@@ -298,13 +526,16 @@ describe('Undecorated classes with decorated fields migration', () => {\n \n     await runMigration();\n     const fileContent = tree.readContent('/index.ts');\n+\n+    expect(warnings.length).toBe(0);\n     expect(fileContent).toContain(`import { Input, Directive, NgModule } from '@angular/core';`);\n     expect(fileContent).toMatch(/@Directive\\(\\)\\s+export class Base/);\n     expect(fileContent).toMatch(/@Directive\\(\\)\\s+export class DerivedA/);\n     expect(fileContent).toMatch(/@Directive\\(\\)\\s+export class DerivedB/);\n     expect(fileContent).toMatch(/@Directive\\(\\)\\s+export class DerivedC/);\n     expect(fileContent).toMatch(/}\\s+@Directive\\(\\{selector: 'my-comp'}\\)\\s+export class MyComp/);\n     expect(fileContent).toMatch(/}\\s+export class MyCompWrapped/);\n+    expect(fileContent).not.toContain('TODO: Add Angular decorator');\n   });\n \n   it('should add @Directive to derived undecorated classes of abstract directives', async () => {"
        }
    ],
    "stats": {
        "total": 511,
        "additions": 429,
        "deletions": 82
    }
}