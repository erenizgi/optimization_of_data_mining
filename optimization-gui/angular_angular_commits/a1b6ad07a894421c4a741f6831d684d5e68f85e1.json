{
    "author": "mitchellwills",
    "message": "fix(core): Allow passing AbstractType to the inject function (#37958)\n\nThis is a type only change that replaces `Type<T>|InjectionToken<T>` with\n`Type<T>|AbstractType<T>|InjectionToken<T>` in the injector.\n\nPR Close #37958",
    "sha": "a1b6ad07a894421c4a741f6831d684d5e68f85e1",
    "files": [
        {
            "sha": "ad6dd6a01e79e3df898a07e64f403f8ffafe2e53",
            "filename": "goldens/public-api/core/core.d.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/a1b6ad07a894421c4a741f6831d684d5e68f85e1/goldens%2Fpublic-api%2Fcore%2Fcore.d.ts",
            "raw_url": "https://github.com/angular/angular/raw/a1b6ad07a894421c4a741f6831d684d5e68f85e1/goldens%2Fpublic-api%2Fcore%2Fcore.d.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fpublic-api%2Fcore%2Fcore.d.ts?ref=a1b6ad07a894421c4a741f6831d684d5e68f85e1",
            "patch": "@@ -445,7 +445,7 @@ export declare class InjectionToken<T> {\n }\n \n export declare abstract class Injector {\n-    abstract get<T>(token: Type<T> | InjectionToken<T> | AbstractType<T>, notFoundValue?: T, flags?: InjectFlags): T;\n+    abstract get<T>(token: Type<T> | AbstractType<T> | InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n     /** @deprecated */ abstract get(token: any, notFoundValue?: any): any;\n     static NULL: Injector;\n     static THROW_IF_NOT_FOUND: {};\n@@ -676,8 +676,8 @@ export declare function ɵɵdefineInjectable<T>(opts: {\n }): never;\n \n /** @codeGenApi */\n-export declare function ɵɵinject<T>(token: Type<T> | InjectionToken<T>): T;\n-export declare function ɵɵinject<T>(token: Type<T> | InjectionToken<T>, flags?: InjectFlags): T | null;\n+export declare function ɵɵinject<T>(token: Type<T> | AbstractType<T> | InjectionToken<T>): T;\n+export declare function ɵɵinject<T>(token: Type<T> | AbstractType<T> | InjectionToken<T>, flags?: InjectFlags): T | null;\n \n /** @codeGenApi */\n export declare interface ɵɵInjectableDef<T> {"
        },
        {
            "sha": "9614aa2ec1507173f3148db43d07a44b71981cdc",
            "filename": "packages/core/src/di/inject_switch.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 6,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fcore%2Fsrc%2Fdi%2Finject_switch.ts",
            "raw_url": "https://github.com/angular/angular/raw/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fcore%2Fsrc%2Fdi%2Finject_switch.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Fdi%2Finject_switch.ts?ref=a1b6ad07a894421c4a741f6831d684d5e68f85e1",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {Type} from '../interface/type';\n+import {AbstractType, Type} from '../interface/type';\n import {assertNotEqual} from '../util/assert';\n import {stringify} from '../util/stringify';\n import {InjectionToken} from './injection_token';\n@@ -23,7 +23,8 @@ import {InjectFlags} from './interface/injector';\n  *  1. `Injector` should not depend on ivy logic.\n  *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\n  */\n-let _injectImplementation: (<T>(token: Type<T>|InjectionToken<T>, flags?: InjectFlags) => T | null)|\n+let _injectImplementation:\n+    (<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>, flags?: InjectFlags) => T | null)|\n     undefined;\n export function getInjectImplementation() {\n   return _injectImplementation;\n@@ -34,8 +35,10 @@ export function getInjectImplementation() {\n  * Sets the current inject implementation.\n  */\n export function setInjectImplementation(\n-    impl: (<T>(token: Type<T>|InjectionToken<T>, flags?: InjectFlags) => T | null)|\n-    undefined): (<T>(token: Type<T>|InjectionToken<T>, flags?: InjectFlags) => T | null)|undefined {\n+    impl: (<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>, flags?: InjectFlags) => T | null)|\n+    undefined):\n+    (<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>, flags?: InjectFlags) => T | null)|\n+    undefined {\n   const previous = _injectImplementation;\n   _injectImplementation = impl;\n   return previous;\n@@ -50,7 +53,8 @@ export function setInjectImplementation(\n  * `InjectableDef`.\n  */\n export function injectRootLimpMode<T>(\n-    token: Type<T>|InjectionToken<T>, notFoundValue: T|undefined, flags: InjectFlags): T|null {\n+    token: Type<T>|AbstractType<T>|InjectionToken<T>, notFoundValue: T|undefined,\n+    flags: InjectFlags): T|null {\n   const injectableDef: ɵɵInjectableDef<T>|null = getInjectableDef(token);\n   if (injectableDef && injectableDef.providedIn == 'root') {\n     return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() :\n@@ -70,7 +74,7 @@ export function injectRootLimpMode<T>(\n  * @param fn Function which it should not equal to\n  */\n export function assertInjectImplementationNotEqual(\n-    fn: (<T>(token: Type<T>|InjectionToken<T>, flags?: InjectFlags) => T | null)) {\n+    fn: (<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>, flags?: InjectFlags) => T | null)) {\n   ngDevMode &&\n       assertNotEqual(_injectImplementation, fn, 'Calling ɵɵinject would cause infinite recursion');\n }"
        },
        {
            "sha": "f4c5a370712ff53fab2d1b1c68106c4c6db5025b",
            "filename": "packages/core/src/di/injector.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fcore%2Fsrc%2Fdi%2Finjector.ts",
            "raw_url": "https://github.com/angular/angular/raw/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fcore%2Fsrc%2Fdi%2Finjector.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Fdi%2Finjector.ts?ref=a1b6ad07a894421c4a741f6831d684d5e68f85e1",
            "patch": "@@ -67,9 +67,9 @@ export abstract class Injector {\n    * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n    */\n   abstract get<T>(\n-      token: Type<T>|InjectionToken<T>|AbstractType<T>, notFoundValue?: T, flags?: InjectFlags): T;\n+      token: Type<T>|AbstractType<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n   /**\n-   * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>\n+   * @deprecated from v4.0.0 use Type<T>, AbstractType<T> or InjectionToken<T>\n    * @suppress {duplicate}\n    */\n   abstract get(token: any, notFoundValue?: any): any;\n@@ -156,7 +156,8 @@ export class StaticInjector implements Injector {\n     this.scope = recursivelyProcessProviders(records, providers);\n   }\n \n-  get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n+  get<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags):\n+      T;\n   get(token: any, notFoundValue?: any): any;\n   get(token: any, notFoundValue?: any, flags: InjectFlags = InjectFlags.Default): any {\n     const records = this._records;"
        },
        {
            "sha": "71586aa12798afc77d52fab6a629973f16fca09e",
            "filename": "packages/core/src/di/injector_compatibility.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fcore%2Fsrc%2Fdi%2Finjector_compatibility.ts",
            "raw_url": "https://github.com/angular/angular/raw/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fcore%2Fsrc%2Fdi%2Finjector_compatibility.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Fdi%2Finjector_compatibility.ts?ref=a1b6ad07a894421c4a741f6831d684d5e68f85e1",
            "patch": "@@ -8,7 +8,7 @@\n \n import '../util/ng_dev_mode';\n \n-import {Type} from '../interface/type';\n+import {AbstractType, Type} from '../interface/type';\n import {getClosureSafeProperty} from '../util/property';\n import {stringify} from '../util/stringify';\n import {resolveForwardRef} from './forward_ref';\n@@ -46,12 +46,11 @@ export function setCurrentInjector(injector: Injector|null|undefined): Injector|\n   return former;\n }\n \n-\n-export function injectInjectorOnly<T>(token: Type<T>|InjectionToken<T>): T;\n-export function injectInjectorOnly<T>(token: Type<T>|InjectionToken<T>, flags?: InjectFlags): T|\n-    null;\n+export function injectInjectorOnly<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>): T;\n+export function injectInjectorOnly<T>(\n+    token: Type<T>|AbstractType<T>|InjectionToken<T>, flags?: InjectFlags): T|null;\n export function injectInjectorOnly<T>(\n-    token: Type<T>|InjectionToken<T>, flags = InjectFlags.Default): T|null {\n+    token: Type<T>|AbstractType<T>|InjectionToken<T>, flags = InjectFlags.Default): T|null {\n   if (_currentInjector === undefined) {\n     throw new Error(`inject() must be called from an injection context`);\n   } else if (_currentInjector === null) {\n@@ -74,9 +73,11 @@ export function injectInjectorOnly<T>(\n  * @codeGenApi\n  * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.\n  */\n-export function ɵɵinject<T>(token: Type<T>|InjectionToken<T>): T;\n-export function ɵɵinject<T>(token: Type<T>|InjectionToken<T>, flags?: InjectFlags): T|null;\n-export function ɵɵinject<T>(token: Type<T>|InjectionToken<T>, flags = InjectFlags.Default): T|null {\n+export function ɵɵinject<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>): T;\n+export function ɵɵinject<T>(\n+    token: Type<T>|AbstractType<T>|InjectionToken<T>, flags?: InjectFlags): T|null;\n+export function ɵɵinject<T>(\n+    token: Type<T>|AbstractType<T>|InjectionToken<T>, flags = InjectFlags.Default): T|null {\n   return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);\n }\n \n@@ -130,7 +131,6 @@ Please check that 1) the type for the parameter at index ${\n  */\n export const inject = ɵɵinject;\n \n-\n export function injectArgs(types: (Type<any>|InjectionToken<any>|any[])[]): any[] {\n   const args: any[] = [];\n   for (let i = 0; i < types.length; i++) {"
        },
        {
            "sha": "c993e6a738f751d3e3fd998df855e909cfa7e1ec",
            "filename": "packages/core/src/di/r3_injector.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 6,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fcore%2Fsrc%2Fdi%2Fr3_injector.ts",
            "raw_url": "https://github.com/angular/angular/raw/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fcore%2Fsrc%2Fdi%2Fr3_injector.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Fdi%2Fr3_injector.ts?ref=a1b6ad07a894421c4a741f6831d684d5e68f85e1",
            "patch": "@@ -9,7 +9,7 @@\n import '../util/ng_dev_mode';\n \n import {OnDestroy} from '../interface/lifecycle_hooks';\n-import {Type} from '../interface/type';\n+import {AbstractType, Type} from '../interface/type';\n import {FactoryFn, getFactoryDef} from '../render3/definition_factory';\n import {throwCyclicDependencyError, throwInvalidProviderError, throwMixedMultiProviderError} from '../render3/errors_di';\n import {deepForEach, newArray} from '../util/array_utils';\n@@ -103,7 +103,7 @@ export class R3Injector {\n    * - `null` value implies that we don't have the record. Used by tree-shakable injectors\n    * to prevent further searches.\n    */\n-  private records = new Map<Type<any>|InjectionToken<any>, Record<any>|null>();\n+  private records = new Map<Type<any>|AbstractType<any>|InjectionToken<any>, Record<any>|null>();\n \n   /**\n    * The transitive set of `InjectorType`s which define this injector.\n@@ -181,7 +181,7 @@ export class R3Injector {\n   }\n \n   get<T>(\n-      token: Type<T>|InjectionToken<T>, notFoundValue: any = THROW_IF_NOT_FOUND,\n+      token: Type<T>|AbstractType<T>|InjectionToken<T>, notFoundValue: any = THROW_IF_NOT_FOUND,\n       flags = InjectFlags.Default): T {\n     this.assertNotDestroyed();\n     // Set the injection context.\n@@ -404,7 +404,7 @@ export class R3Injector {\n     this.records.set(token, record);\n   }\n \n-  private hydrate<T>(token: Type<T>|InjectionToken<T>, record: Record<T>): T {\n+  private hydrate<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>, record: Record<T>): T {\n     if (ngDevMode && record.value === CIRCULAR) {\n       throwCyclicDependencyError(stringify(token));\n     } else if (record.value === NOT_YET) {\n@@ -428,7 +428,8 @@ export class R3Injector {\n   }\n }\n \n-function injectableDefOrInjectorDefFactory(token: Type<any>|InjectionToken<any>): FactoryFn<any> {\n+function injectableDefOrInjectorDefFactory(token: Type<any>|AbstractType<any>|\n+                                           InjectionToken<any>): FactoryFn<any> {\n   // Most tokens will have an injectable def directly on them, which specifies a factory directly.\n   const injectableDef = getInjectableDef(token);\n   const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);\n@@ -564,7 +565,8 @@ function hasOnDestroy(value: any): value is OnDestroy {\n       typeof (value as OnDestroy).ngOnDestroy === 'function';\n }\n \n-function couldBeInjectableType(value: any): value is Type<any>|InjectionToken<any> {\n+function couldBeInjectableType(value: any): value is Type<any>|AbstractType<any>|\n+    InjectionToken<any> {\n   return (typeof value === 'function') ||\n       (typeof value === 'object' && value instanceof InjectionToken);\n }"
        },
        {
            "sha": "a5d06798990bf79c453fbd26deb573b93ad5936f",
            "filename": "packages/core/src/render3/component_ref.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fcore%2Fsrc%2Frender3%2Fcomponent_ref.ts",
            "raw_url": "https://github.com/angular/angular/raw/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fcore%2Fsrc%2Frender3%2Fcomponent_ref.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fcomponent_ref.ts?ref=a1b6ad07a894421c4a741f6831d684d5e68f85e1",
            "patch": "@@ -10,7 +10,7 @@ import {ChangeDetectorRef as ViewEngine_ChangeDetectorRef} from '../change_detec\n import {InjectionToken} from '../di/injection_token';\n import {Injector} from '../di/injector';\n import {InjectFlags} from '../di/interface/injector';\n-import {Type} from '../interface/type';\n+import {AbstractType, Type} from '../interface/type';\n import {ComponentFactory as viewEngine_ComponentFactory, ComponentRef as viewEngine_ComponentRef} from '../linker/component_factory';\n import {ComponentFactoryResolver as viewEngine_ComponentFactoryResolver} from '../linker/component_factory_resolver';\n import {createElementRef, ElementRef as viewEngine_ElementRef} from '../linker/element_ref';\n@@ -80,7 +80,9 @@ export const SCHEDULER = new InjectionToken<((fn: () => void) => void)>('SCHEDUL\n \n function createChainedInjector(rootViewInjector: Injector, moduleInjector: Injector): Injector {\n   return {\n-    get: <T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T => {\n+    get: <T>(\n+        token: Type<T>|AbstractType<T>|InjectionToken<T>, notFoundValue?: T,\n+        flags?: InjectFlags): T => {\n       const value = rootViewInjector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR as T, flags);\n \n       if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||"
        },
        {
            "sha": "0decb16f9456c35e225e8272deb5621469399387",
            "filename": "packages/core/src/render3/di.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 9,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fcore%2Fsrc%2Frender3%2Fdi.ts",
            "raw_url": "https://github.com/angular/angular/raw/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fcore%2Fsrc%2Frender3%2Fdi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fdi.ts?ref=a1b6ad07a894421c4a741f6831d684d5e68f85e1",
            "patch": "@@ -13,7 +13,7 @@ import {Injector} from '../di/injector';\n import {InjectorMarkers} from '../di/injector_marker';\n import {getInjectorDef} from '../di/interface/defs';\n import {InjectFlags} from '../di/interface/injector';\n-import {Type} from '../interface/type';\n+import {AbstractType, Type} from '../interface/type';\n import {assertDefined, assertEqual, assertIndexInRange} from '../util/assert';\n import {noSideEffects} from '../util/closure';\n \n@@ -347,7 +347,8 @@ export function injectAttributeImpl(tNode: TNode, attrNameToInject: string): str\n \n \n function notFoundValueOrThrow<T>(\n-    notFoundValue: T|null, token: Type<T>|InjectionToken<T>, flags: InjectFlags): T|null {\n+    notFoundValue: T|null, token: Type<T>|AbstractType<T>|InjectionToken<T>, flags: InjectFlags): T|\n+    null {\n   if (flags & InjectFlags.Optional) {\n     return notFoundValue;\n   } else {\n@@ -365,8 +366,8 @@ function notFoundValueOrThrow<T>(\n  * @returns the value from the injector or throws an exception\n  */\n function lookupTokenUsingModuleInjector<T>(\n-    lView: LView, token: Type<T>|InjectionToken<T>, flags: InjectFlags, notFoundValue?: any): T|\n-    null {\n+    lView: LView, token: Type<T>|AbstractType<T>|InjectionToken<T>, flags: InjectFlags,\n+    notFoundValue?: any): T|null {\n   if (flags & InjectFlags.Optional && notFoundValue === undefined) {\n     // This must be set or the NullInjector will throw for optional deps\n     notFoundValue = null;\n@@ -408,7 +409,7 @@ function lookupTokenUsingModuleInjector<T>(\n  * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n  */\n export function getOrCreateInjectable<T>(\n-    tNode: TDirectiveHostNode|null, lView: LView, token: Type<T>|InjectionToken<T>,\n+    tNode: TDirectiveHostNode|null, lView: LView, token: Type<T>|AbstractType<T>|InjectionToken<T>,\n     flags: InjectFlags = InjectFlags.Default, notFoundValue?: any): T|null {\n   if (tNode !== null) {\n     const bloomHash = bloomHashBitOrFactory(token);\n@@ -508,7 +509,7 @@ export function createNodeInjector(): Injector {\n }\n \n function searchTokensOnInjector<T>(\n-    injectorIndex: number, lView: LView, token: Type<T>|InjectionToken<T>,\n+    injectorIndex: number, lView: LView, token: Type<T>|AbstractType<T>|InjectionToken<T>,\n     previousTView: TView|null, flags: InjectFlags, hostTElementNode: TNode|null) {\n   const currentTView = lView[TVIEW];\n   const tNode = currentTView.data[injectorIndex + NodeInjectorOffset.TNODE] as TNode;\n@@ -555,7 +556,7 @@ function searchTokensOnInjector<T>(\n  * @returns Index of a found directive or provider, or null when none found.\n  */\n export function locateDirectiveOrProvider<T>(\n-    tNode: TNode, tView: TView, token: Type<T>|InjectionToken<T>|string,\n+    tNode: TNode, tView: TView, token: Type<T>|AbstractType<T>|InjectionToken<T>|string,\n     canAccessViewProviders: boolean, isHostSpecialCase: boolean|number): number|null {\n   const nodeProviderIndexes = tNode.providerIndexes;\n   const tInjectables = tView.data;\n@@ -646,8 +647,8 @@ export function getNodeInjectable(\n  * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\n  *   When the returned value is negative then it represents special values such as `Injector`.\n  */\n-export function bloomHashBitOrFactory(token: Type<any>|InjectionToken<any>|string): number|Function|\n-    undefined {\n+export function bloomHashBitOrFactory(token: Type<any>|AbstractType<any>|InjectionToken<any>|\n+                                      string): number|Function|undefined {\n   ngDevMode && assertDefined(token, 'token must be defined');\n   if (typeof token === 'string') {\n     return token.charCodeAt(0) || 0;"
        },
        {
            "sha": "52a4dc83f881087eb369ce11a9f3ff6a6728eed5",
            "filename": "packages/core/src/render3/instructions/di.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fdi.ts",
            "raw_url": "https://github.com/angular/angular/raw/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fdi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fdi.ts?ref=a1b6ad07a894421c4a741f6831d684d5e68f85e1",
            "patch": "@@ -8,7 +8,7 @@\n import {InjectFlags, InjectionToken, resolveForwardRef} from '../../di';\n import {assertInjectImplementationNotEqual} from '../../di/inject_switch';\n import {ɵɵinject} from '../../di/injector_compatibility';\n-import {Type} from '../../interface/type';\n+import {AbstractType, Type} from '../../interface/type';\n import {getOrCreateInjectable} from '../di';\n import {TDirectiveHostNode} from '../interfaces/node';\n import {getCurrentTNode, getLView} from '../state';\n@@ -37,10 +37,11 @@ import {getCurrentTNode, getLView} from '../state';\n  *\n  * @codeGenApi\n  */\n-export function ɵɵdirectiveInject<T>(token: Type<T>|InjectionToken<T>): T;\n-export function ɵɵdirectiveInject<T>(token: Type<T>|InjectionToken<T>, flags: InjectFlags): T;\n+export function ɵɵdirectiveInject<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>): T;\n export function ɵɵdirectiveInject<T>(\n-    token: Type<T>|InjectionToken<T>, flags = InjectFlags.Default): T|null {\n+    token: Type<T>|AbstractType<T>|InjectionToken<T>, flags: InjectFlags): T;\n+export function ɵɵdirectiveInject<T>(\n+    token: Type<T>|AbstractType<T>|InjectionToken<T>, flags = InjectFlags.Default): T|null {\n   const lView = getLView();\n   // Fall back to inject() if view hasn't been created. This situation can happen in tests\n   // if inject utilities are used before bootstrapping."
        },
        {
            "sha": "5a06dc39fb3f82b9960be75e65352a26f4b29a3c",
            "filename": "packages/core/src/render3/interfaces/injector.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Finjector.ts",
            "raw_url": "https://github.com/angular/angular/raw/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Finjector.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Finjector.ts?ref=a1b6ad07a894421c4a741f6831d684d5e68f85e1",
            "patch": "@@ -8,7 +8,7 @@\n \n import {InjectionToken} from '../../di/injection_token';\n import {InjectFlags} from '../../di/interface/injector';\n-import {Type} from '../../interface/type';\n+import {AbstractType, Type} from '../../interface/type';\n import {assertDefined, assertEqual} from '../../util/assert';\n \n import {TDirectiveHostNode} from './node';\n@@ -176,7 +176,8 @@ export class NodeInjectorFactory {\n   /**\n    * The inject implementation to be activated when using the factory.\n    */\n-  injectImpl: null|(<T>(token: Type<T>|InjectionToken<T>, flags?: InjectFlags) => T);\n+  injectImpl: null|\n+      (<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>, flags?: InjectFlags) => T);\n \n   /**\n    * Marker set to true during factory invocation to see if we get into recursive loop.\n@@ -280,7 +281,7 @@ export class NodeInjectorFactory {\n        */\n       isViewProvider: boolean,\n       injectImplementation: null|\n-      (<T>(token: Type<T>|InjectionToken<T>, flags?: InjectFlags) => T)) {\n+      (<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>, flags?: InjectFlags) => T)) {\n     ngDevMode && assertDefined(factory, 'Factory not specified');\n     ngDevMode && assertEqual(typeof factory, 'function', 'Expected factory function.');\n     this.canSeeViewProviders = isViewProvider;"
        },
        {
            "sha": "94b804492e89e32049a8a20d755cd72722360440",
            "filename": "packages/core/test/di/r3_injector_spec.ts",
            "status": "modified",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fcore%2Ftest%2Fdi%2Fr3_injector_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fcore%2Ftest%2Fdi%2Fr3_injector_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fdi%2Fr3_injector_spec.ts?ref=a1b6ad07a894421c4a741f6831d684d5e68f85e1",
            "patch": "@@ -180,6 +180,15 @@ describe('InjectorDef-based createInjector()', () => {\n \n   class ChildService extends ServiceWithDep {}\n \n+  abstract class AbstractService {\n+    static ɵprov = ɵɵdefineInjectable({\n+      token: AbstractService,\n+      providedIn: null,\n+      factory: () => new AbstractServiceImpl(),\n+    });\n+  }\n+  class AbstractServiceImpl extends AbstractService {}\n+\n   class Module {\n     static ɵinj = ɵɵdefineInjector({\n       factory: () => new Module(),\n@@ -200,10 +209,17 @@ describe('InjectorDef-based createInjector()', () => {\n             CircularB,\n             {provide: STATIC_TOKEN, useClass: StaticService, deps: [Service]},\n             InjectorWithDep,\n+            AbstractService,\n           ],\n     });\n   }\n \n+  const ABSTRACT_SERVICE_TOKEN_WITH_FACTORY =\n+      new InjectionToken<AbstractService>('ABSTRACT_SERVICE_TOKEN', {\n+        providedIn: Module,\n+        factory: () => ɵɵinject(AbstractService),\n+      });\n+\n   class OtherModule {\n     static ɵinj = ɵɵdefineInjector({\n       factory: () => new OtherModule(),\n@@ -457,6 +473,18 @@ describe('InjectorDef-based createInjector()', () => {\n     expect(injector.get(ImportsNotAModule)).toBeDefined();\n   });\n \n+  it('injects an abstract class', () => {\n+    const instance = injector.get(AbstractService);\n+    expect(instance instanceof AbstractServiceImpl).toBeTruthy();\n+    expect(injector.get(AbstractService)).toBe(instance);\n+  });\n+\n+  it('injects an abstract class in an InjectionToken factory', () => {\n+    const instance = injector.get(ABSTRACT_SERVICE_TOKEN_WITH_FACTORY);\n+    expect(instance instanceof AbstractServiceImpl).toBeTruthy();\n+    expect(injector.get(ABSTRACT_SERVICE_TOKEN_WITH_FACTORY)).toBe(instance);\n+  });\n+\n   describe('error handling', () => {\n     it('throws an error when a token is not found', () => {\n       expect(() => injector.get(ServiceTwo)).toThrow();"
        },
        {
            "sha": "dcb0037298ebcf72da960d806b51fcd185d3ddfa",
            "filename": "packages/examples/core/di/ts/injector_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fexamples%2Fcore%2Fdi%2Fts%2Finjector_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a1b6ad07a894421c4a741f6831d684d5e68f85e1/packages%2Fexamples%2Fcore%2Fdi%2Fts%2Finjector_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fexamples%2Fcore%2Fdi%2Fts%2Finjector_spec.ts?ref=a1b6ad07a894421c4a741f6831d684d5e68f85e1",
            "patch": "@@ -6,13 +6,13 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {inject, InjectFlags, InjectionToken, Injector, Type, ɵsetCurrentInjector as setCurrentInjector} from '@angular/core';\n+import {AbstractType, inject, InjectFlags, InjectionToken, Injector, Type, ɵsetCurrentInjector as setCurrentInjector} from '@angular/core';\n \n class MockRootScopeInjector implements Injector {\n   constructor(readonly parent: Injector) {}\n \n   get<T>(\n-      token: Type<T>|InjectionToken<T>, defaultValue?: any,\n+      token: Type<T>|AbstractType<T>|InjectionToken<T>, defaultValue?: any,\n       flags: InjectFlags = InjectFlags.Default): T {\n     if ((token as any).ɵprov && (token as any).ɵprov.providedIn === 'root') {\n       const old = setCurrentInjector(this);"
        }
    ],
    "stats": {
        "total": 136,
        "additions": 88,
        "deletions": 48
    }
}