{
    "author": "pmartijena",
    "message": "docs: fix grammatical errors and typos (#38868)\n\nFixed run on sentences, grammatical errors, and made \"ivy\" \"Ivy\" everywhere for consistency.\nPR Close #38868",
    "sha": "421efbf69b9f57cdec8f3b000b05cd1ec73fe100",
    "files": [
        {
            "sha": "308277546929c1ff10060574d66551a12f58489f",
            "filename": "packages/compiler/design/separate_compilation.md",
            "status": "modified",
            "additions": 54,
            "deletions": 54,
            "changes": 108,
            "blob_url": "https://github.com/angular/angular/blob/421efbf69b9f57cdec8f3b000b05cd1ec73fe100/packages%2Fcompiler%2Fdesign%2Fseparate_compilation.md",
            "raw_url": "https://github.com/angular/angular/raw/421efbf69b9f57cdec8f3b000b05cd1ec73fe100/packages%2Fcompiler%2Fdesign%2Fseparate_compilation.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fdesign%2Fseparate_compilation.md?ref=421efbf69b9f57cdec8f3b000b05cd1ec73fe100",
            "patch": "@@ -7,50 +7,50 @@ AUTHOR: chuckj@\n ### Angular 5 (Renderer2)\n \n In 5.0 and prior versions of Angular the compiler performs whole program\n-analysis and generates template and injector definitions that are using\n+analysis and generates template and injector definitions that use\n this global knowledge to flatten injector scope definitions, inline\n directives into the component, pre-calculate queries, pre-calculate\n content projection, etc. This global knowledge requires that module and\n-component factories are generated as a final global step when compiling\n-a module. If any of the transitive information changed then all factories\n+component factories are generated as the final global step when compiling\n+a module. If any of the transitive information changed, then all factories\n need to be regenerated.\n \n Separate component and module compilation is supported only at the module\n-definition level and only from source. That is, npm packages must contain\n-the metadata necessary to generate the factories, they cannot contain,\n-themselves, the generated factories. This is because, if any of there\n-dependencies change, their factories would be invalid preventing them from\n+definition level and only from the source. That is, npm packages must contain\n+the metadata necessary to generate the factories. They cannot contain,\n+themselves, the generated factories. This is because if any of their\n+dependencies change, their factories would be invalid, preventing them from\n using version ranges in their dependencies. To support producing factories\n from compiled source (already translated by TypeScript into JavaScript)\n libraries include metadata that describe the content of the Angular\n decorators.\n \n-This document refers to this style of code generation as Renderer2 after the\n-name of the renderer class it uses at runtime.\n+This document refers to this style of code generation as Renderer2 (after the\n+name of the renderer class it uses at runtime).\n \n ### Angular Ivy\n \n In Ivy, the runtime is crafted in a way that allows for separate compilation\n by performing at runtime much of what was previously pre-calculated by\n-compiler. This allows the definition of components to change without\n-requiring modules and components that depend on them being recompiled.\n+the compiler. This allows the definition of components to change without\n+requiring modules and components that depend on them to be recompiled.\n \n-The mental model of Ivy is that the decorator is the compiler. That is\n+The mental model of Ivy is that the decorator is the compiler. That is,\n the decorator can be thought of as parameters to a class transformer that\n transforms the class by generating definitions based on the decorator\n-parameters. An `@Component` decorator transforms the class by adding\n-a `ɵcmp` static property, `@Directive` adds `ɵdir`,\n-`@Pipe` adds `ɵpipe`, etc. In most cases values supplied to the\n-decorator is sufficient to generate the definition. However, in the case of\n+parameters. A `@Component` decorator transforms the class by adding\n+an `ɵcmp` static property, `@Directive` adds `ɵdir`,\n+`@Pipe` adds `ɵpipe`, etc. In most cases the values supplied to the\n+decorator are sufficient to generate the definition. However, in the case of\n interpreting the template, the compiler needs to know the selector defined for\n-each component, directive and pipe that are in scope of the template. The\n-purpose of this document is to define the information is needed by the\n-compiler and how that information is serialized to be discovered and\n+each component, directive and pipe that are in the scope of the template. The\n+purpose of this document is to define the information that is needed by the\n+compiler, and how that information is serialized to be discovered and\n used by subsequent calls to `ngc`.\n \n-This document refers to this style of code generation as ivy after the code\n-name of the project to create it. It would be more consistent to refer to it\n-as Renderer3 that looks too similar to Renderer2.\n+This document refers to this style of code generation as Ivy (after the code\n+name of the project to create it). It would be more consistent to refer to it\n+as Renderer3, but that looks too similar to Renderer2.\n \n ## Information needed\n \n@@ -125,7 +125,7 @@ reexported from the index.\n ### Angular Ivy\n \n The metadata for a class in ivy is transformed to be what the metadata of the\n-transformed .js file produced by the ivy compiler would be. For example, a\n+transformed .js file produced by the Ivy compiler would be. For example, a\n component's `@Component` is removed by the compiler and replaced by a `ɵcmp`.\n The `.metadata.json` file is similarly transformed but the content of the\n value assigned is elided (e.g. `\"ɵcmp\": {}`). The compiler doesn't\n@@ -183,8 +183,8 @@ export class MyComponent {\n ```\n \n Note that this is exactly what is produced if the transform had been done\n-manually or by some other compiler before `ngc` compiler is invoked. That is\n-this model has the advantage that there is no magic introduced by the compiler\n+manually or by some other compiler before `ngc` compiler is invoked. That is why\n+this model has the advantage that there is no magic introduced by the compiler,\n as it treats classes annotated by `@Component` identically to those produced\n manually.\n \n@@ -420,20 +420,20 @@ the difference between manually and mechanically created module definitions.\n \n With this proposal, the compiler treats manually and mechanically generated\n Angular definitions identically. This allows flexibility not only in the future\n-for how the declarations are mechanically produced it also allows alternative\n-mechanism to generate declarations be easily explored without altering the\n+for how the declarations are mechanically produced, it also allows an alternative\n+mechanism to generate declarations that can be easily explored without altering the\n compiler or dependent tool chain. It also allows third-party code generators\n-with possibly different component syntaxes to generate a component fully\n+with possibly different component syntaxes to generate a component that is fully\n understood by the compiler.\n \n-Unfortunately, however, manually generated modules contain references to\n+Unfortunately, manually generated modules contain references to\n classes that might not be necessary at runtime. Manually or third-party\n components can get the same payload properties of an Angular generated\n component by annotating the `ngSelector` and `ngModuleScope` properties with\n `// @__BUILD_OPTIMIZER_REMOVE_` comment which will cause the build optimizer\n to remove the declaration.\n \n-##### example\n+##### Example\n \n For example the above manually created module would have better payload\n properties by including a `// @__BUILD_OPTIMIZER_REMOVE_` comment:\n@@ -471,21 +471,21 @@ reusable library used in an application.\n \n ### Application output\n \n-The output of the ivy compiler only optionally generates the factories\n-generated by the Renderer2 style output of Angular 5.0. In ivy, the information\n+The output of the Ivy compiler only optionally generates the factories\n+generated by the Renderer2 style output of Angular 5.0. In Ivy, the information\n that was generated in factories is now generated in Angular as a definition\n-that is generated as a static field on the Angular decorated class.\n+that is generated as a static field in the Angular decorated class.\n \n Renderer2 requires that, when building the final application, all factories for\n-all libraries also be generated. In ivy, the definitions are generated when\n+all libraries also be generated. In Ivy, the definitions are generated when\n the library is compiled.\n \n-The ivy compile can adapt Renderer2 target libraries by generating the factories\n+The Ivy compile can adapt Renderer2 target libraries by generating the factories\n for them and back-patching, at runtime, the static property into the class.\n \n #### Back-patching module (`\"renderer2BackPatching\"`)\n \n-When an application contains Renderer2 target libraries the ivy definitions\n+When an application contains Renderer2 target libraries the Ivy definitions\n need to be back-patch onto the component, directive, module, pipe, and\n injectable classes.\n \n@@ -547,7 +547,7 @@ recommended value and do not need to be explicitly set. Options marked\n \n ## Library output\n \n-Building an ivy library with `ngc` differs from Renderer2 in that the\n+Building an Ivy library with `ngc` differs from Renderer2 in that the\n declarations are included in the generated output and should be included in the\n package published to `npm`. The `.metadata.json` files still need to be\n included but they are transformed as described below.\n@@ -558,7 +558,7 @@ As described above, when the compiler adds the declaration to the class it will\n also transform the `.metadata.json` file to reflect the new static fields added\n to the class.\n \n-Once the static fields are added to the metadata, the ivy compiler no longer\n+Once the static fields are added to the metadata, the Ivy compiler no longer\n needs the information in the decorator. When `\"enableIvy\"` is `true` this\n information is removed from the `.metadata.json` file.\n \n@@ -641,7 +641,7 @@ The purpose of the \"package\" target is to produce a library package that will\n be an entry point for an npm package. Each entry point should be separately\n compiled using a \"package\" target.\n \n-##### example - application\n+##### Example - application\n \n To produce a Renderer2 application the options would look like,\n \n@@ -659,7 +659,7 @@ To produce a Renderer2 application the options would look like,\n alternately, since the recommended `\"application\"` options are the default\n values, the `\"angularCompilerOptions\"` can be out.\n \n-##### example - library\n+##### Example - library\n \n To produce a Renderer2 library the options would look like,\n \n@@ -674,7 +674,7 @@ To produce a Renderer2 library the options would look like,\n }\n ```\n \n-##### example - package\n+##### Example - package\n \n To produce a Renderer2 package the options would look like,\n \n@@ -689,9 +689,9 @@ To produce a Renderer2 package the options would look like,\n }\n ```\n \n-##### example - ivy application\n+##### Example - Ivy application\n \n-To produce an ivy application the options would look like,\n+To produce an Ivy application the options would look like,\n \n ```json\n {\n@@ -705,9 +705,9 @@ To produce an ivy application the options would look like,\n }\n ```\n \n-##### example - ivy library\n+##### Example - Ivy library\n \n-To produce an ivy library the options would look like,\n+To produce an Ivy library the options would look like,\n \n ```json\n {\n@@ -721,11 +721,11 @@ To produce an ivy library the options would look like,\n }\n ```\n \n-##### example - ivy package\n+##### Example - Ivy package\n \n Ivy packages are not supported in Angular 6.0 as they are not recommended in\n-npm packages as they would only be usable if in ivy application where an ivy\n-application. Ivy application support Renderer2 libraries so npm packages\n+npm packages as they would only be usable if inside Ivy applications. \n+Ivy applications support Renderer2 libraries so npm packages\n should all be Renderer2 libraries.\n \n ## `ng_module` output (Bazel)\n@@ -755,9 +755,9 @@ The `ng_experimental_ivy_srcs` can be used as use to cause the ivy versions of\n files to be generated. It is intended the sole dependency of a `ts_dev_server`\n rule and the `ts_dev_server` sources move to `ng_experimental_iv_srcs`.\n \n-#### `ng_module` ivy output\n+#### `ng_module` Ivy output\n \n-The `ng_module` is able to provide the ivy version of the `.js` files which\n+The `ng_module` is able to provide the Ivy version of the `.js` files which\n will be generated with as `.ivy.js` for the development sources and `.ivy.mjs`\n for the production sources.\n \n@@ -775,7 +775,7 @@ where `moduleName` is the name of the as it would appear in an import statement\n in a `.ts` file at the same relative location in the source tree. All the\n references in this file are also relative to this location.\n \n-##### example\n+##### Example\n \n The following is a typical Angular application build in bazel:\n \n@@ -793,7 +793,7 @@ ts_dev_server(\n )\n ```\n \n-To use produce an ivy version you would add:\n+To use produce an Ivy version you would add:\n \n ```py\n ng_experimental_ivy_srcs(\n@@ -813,13 +813,13 @@ To serve the Renderer2 version, you would run:\n bazel run :server\n ```\n \n-to serve the ivy version you would run\n+to serve the Ivy version you would run\n \n ```sh\n bazel run :server_ivy\n ```\n \n-The `ng_experimental_ivy_srcs` rule is only needed when ivy is experimental. Once ivy\n+The `ng_experimental_ivy_srcs` rule is only needed when Ivy is experimental. Once Ivy\n is released, the `ng_experimental_ivy_srcs` dependent rules can be removed.\n \n ---"
        }
    ],
    "stats": {
        "total": 108,
        "additions": 54,
        "deletions": 54
    }
}