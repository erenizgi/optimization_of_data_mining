{
    "author": "gkalpak",
    "message": "refactor(service-worker): simplify `Driver#handleFetch()` method (#40234)\n\nThis commit refactors the `Driver#handleFetch()` method to not have to\ncall `event.waitUntil(this.idle.trigger())` in multiple places.\n\nPR Close #40234",
    "sha": "919b93a1f8cccd2b0bcb7fd79c5ce9086a0d8e5f",
    "files": [
        {
            "sha": "9f37d38c541d6053113457d3b1921da33b6483e0",
            "filename": "packages/service-worker/worker/src/driver.ts",
            "status": "modified",
            "additions": 28,
            "deletions": 33,
            "changes": 61,
            "blob_url": "https://github.com/angular/angular/blob/919b93a1f8cccd2b0bcb7fd79c5ce9086a0d8e5f/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdriver.ts",
            "raw_url": "https://github.com/angular/angular/raw/919b93a1f8cccd2b0bcb7fd79c5ce9086a0d8e5f/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdriver.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdriver.ts?ref=919b93a1f8cccd2b0bcb7fd79c5ce9086a0d8e5f",
            "patch": "@@ -423,48 +423,43 @@ export class Driver implements Debuggable, UpdateSource {\n     // Decide which version of the app to use to serve this request. This is asynchronous as in\n     // some cases, a record will need to be written to disk about the assignment that is made.\n     const appVersion = await this.assignVersion(event);\n-\n-    // Bail out\n-    if (appVersion === null) {\n-      event.waitUntil(this.idle.trigger());\n-      return this.safeFetch(event.request);\n-    }\n-\n     let res: Response|null = null;\n+\n     try {\n-      // Handle the request. First try the AppVersion. If that doesn't work, fall back on the\n-      // network.\n-      res = await appVersion.handleFetch(event.request, event);\n-    } catch (err) {\n-      if (err.isUnrecoverableState) {\n-        await this.notifyClientsAboutUnrecoverableState(appVersion, err.message);\n+      if (appVersion !== null) {\n+        try {\n+          // Handle the request. First try the AppVersion. If that doesn't work, fall back on the\n+          // network.\n+          res = await appVersion.handleFetch(event.request, event);\n+        } catch (err) {\n+          if (err.isUnrecoverableState) {\n+            await this.notifyClientsAboutUnrecoverableState(appVersion, err.message);\n+          }\n+          if (err.isCritical) {\n+            // Something went wrong with the activation of this version.\n+            await this.versionFailed(appVersion, err);\n+            return this.safeFetch(event.request);\n+          }\n+          throw err;\n+        }\n       }\n-      if (err.isCritical) {\n-        // Something went wrong with the activation of this version.\n-        await this.versionFailed(appVersion, err);\n \n-        event.waitUntil(this.idle.trigger());\n+      // The response will be `null` only if no `AppVersion` can be assigned to the request or if\n+      // the assigned `AppVersion`'s manifest doesn't specify what to do about the request.\n+      // In that case, just fall back on the network.\n+      if (res === null) {\n         return this.safeFetch(event.request);\n       }\n-      throw err;\n-    }\n-\n \n-    // The AppVersion will only return null if the manifest doesn't specify what to do about this\n-    // request. In that case, just fall back on the network.\n-    if (res === null) {\n+      // The `AppVersion` returned a usable response, so return it.\n+      return res;\n+    } finally {\n+      // Trigger the idle scheduling system. The Promise returned by `trigger()` will resolve after\n+      // a specific amount of time has passed. If `trigger()` hasn't been called again by then (e.g.\n+      // on a subsequent request), the idle task queue will be drained and the `Promise` won't\n+      // be resolved until that operation is complete as well.\n       event.waitUntil(this.idle.trigger());\n-      return this.safeFetch(event.request);\n     }\n-\n-    // Trigger the idle scheduling system. The Promise returned by trigger() will resolve after\n-    // a specific amount of time has passed. If trigger() hasn't been called again by then (e.g.\n-    // on a subsequent request), the idle task queue will be drained and the Promise won't resolve\n-    // until that operation is complete as well.\n-    event.waitUntil(this.idle.trigger());\n-\n-    // The AppVersion returned a usable response, so return it.\n-    return res;\n   }\n \n   /**"
        }
    ],
    "stats": {
        "total": 61,
        "additions": 28,
        "deletions": 33
    }
}