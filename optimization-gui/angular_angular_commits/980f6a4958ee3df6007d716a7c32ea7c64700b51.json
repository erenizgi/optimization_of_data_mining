{
    "author": "bjarkler",
    "message": "fix(core): address Trusted Types bug in Chrome 83 (#40815)\n\nIn Chrome 83 passing a TrustedScript to eval just returns the\nTrustedScript back without evaluating it, causing the\nnewTrustedFunctionFor{Dev,JIT} functions to fail. This is a browser bug\nthat has been fixed in Chrome 84, and only affects Angular applications\nrunning with JIT (which includes unit tests).\n\nAs a temporary workaround for users still on Chrome 83, detect when this\noccurs in the newTrustedFunctionFor* functions and fall back to the\nstraightforward, non-Trusted Types compatible implementation. The only\ncombination that is left affected consists of Angular applications\nrunning with JIT, that have explicitly configured Trusted Types in\nenforcement mode, with users that are still on Chrome 83.\n\nAlso correct docstring for newTrustedFunctionForJIT.\n\nPR Close #40815",
    "sha": "980f6a4958ee3df6007d716a7c32ea7c64700b51",
    "files": [
        {
            "sha": "b7e0fea059e77c173e78a2dfa01a7e2100bd32ec",
            "filename": "packages/compiler/src/output/output_jit_trusted_types.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 4,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/980f6a4958ee3df6007d716a7c32ea7c64700b51/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_jit_trusted_types.ts",
            "raw_url": "https://github.com/angular/angular/raw/980f6a4958ee3df6007d716a7c32ea7c64700b51/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_jit_trusted_types.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_jit_trusted_types.ts?ref=980f6a4958ee3df6007d716a7c32ea7c64700b51",
            "patch": "@@ -93,9 +93,7 @@ function trustedScriptFromString(script: string): TrustedScript|string {\n }\n \n /**\n- * Unsafely call the Function constructor with the given string arguments. It\n- * is only available in development mode, and should be stripped out of\n- * production code.\n+ * Unsafely call the Function constructor with the given string arguments.\n  * @security This is a security-sensitive function; any use of this function\n  * must go through security review. In particular, it must be assured that it\n  * is only called from the JIT compiler, as use in other code can lead to XSS\n@@ -113,7 +111,7 @@ export function newTrustedFunctionForJIT(...args: string[]): Function {\n   // below, where the Chromium bug is also referenced:\n   // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n   const fnArgs = args.slice(0, -1).join(',');\n-  const fnBody = args.pop()!.toString();\n+  const fnBody = args[args.length - 1];\n   const body = `(function anonymous(${fnArgs}\n ) { ${fnBody}\n })`;\n@@ -122,6 +120,13 @@ export function newTrustedFunctionForJIT(...args: string[]): Function {\n   // being stripped out of JS binaries even if not used. The global['eval']\n   // indirection fixes that.\n   const fn = global['eval'](trustedScriptFromString(body) as string) as Function;\n+  if (fn.bind === undefined) {\n+    // Workaround for a browser bug that only exists in Chrome 83, where passing\n+    // a TrustedScript to eval just returns the TrustedScript back without\n+    // evaluating it. In that case, fall back to the most straightforward\n+    // implementation:\n+    return new Function(...args);\n+  }\n \n   // To completely mimic the behavior of calling \"new Function\", two more\n   // things need to happen:"
        },
        {
            "sha": "75f7d7320f92ec379792fffa55ced437b1702381",
            "filename": "packages/core/src/util/security/trusted_types.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 1,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/980f6a4958ee3df6007d716a7c32ea7c64700b51/packages%2Fcore%2Fsrc%2Futil%2Fsecurity%2Ftrusted_types.ts",
            "raw_url": "https://github.com/angular/angular/raw/980f6a4958ee3df6007d716a7c32ea7c64700b51/packages%2Fcore%2Fsrc%2Futil%2Fsecurity%2Ftrusted_types.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Futil%2Fsecurity%2Ftrusted_types.ts?ref=980f6a4958ee3df6007d716a7c32ea7c64700b51",
            "patch": "@@ -111,7 +111,7 @@ export function newTrustedFunctionForDev(...args: string[]): Function {\n   // below, where the Chromium bug is also referenced:\n   // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n   const fnArgs = args.slice(0, -1).join(',');\n-  const fnBody = args.pop()!.toString();\n+  const fnBody = args[args.length - 1];\n   const body = `(function anonymous(${fnArgs}\n ) { ${fnBody}\n })`;\n@@ -120,6 +120,13 @@ export function newTrustedFunctionForDev(...args: string[]): Function {\n   // being stripped out of JS binaries even if not used. The global['eval']\n   // indirection fixes that.\n   const fn = global['eval'](trustedScriptFromString(body) as string) as Function;\n+  if (fn.bind === undefined) {\n+    // Workaround for a browser bug that only exists in Chrome 83, where passing\n+    // a TrustedScript to eval just returns the TrustedScript back without\n+    // evaluating it. In that case, fall back to the most straightforward\n+    // implementation:\n+    return new Function(...args);\n+  }\n \n   // To completely mimic the behavior of calling \"new Function\", two more\n   // things need to happen:"
        }
    ],
    "stats": {
        "total": 22,
        "additions": 17,
        "deletions": 5
    }
}