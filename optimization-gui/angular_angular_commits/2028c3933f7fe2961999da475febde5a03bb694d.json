{
    "author": "crisbeto",
    "message": "refactor(compiler): combine call ASTs (#42882)\n\nCurrently the compiler has three different classes to represent a \"call to something\":\n1. `MethodCall` - `foo.bar()`\n2. `SafeMethodCall` - `foo?.bar()`.\n3. `FunctionCall` - Any calls that don't fit into the first two classes. E.g. `foo.bar()()`.\n\nThere are a few problems with this approach:\n1. It is inconistent with the TypeScript AST which only has one node: `CallExpression`.\n2. It means that we have to maintain more code, because the various parts of the compiler need to know about three node types.\n3. It doesn't allow us to easily implement some new JS features like safe calls (e.g. `foo.bar?.())`).\n\nThese changes rework the compiler so that it produces only one node: `Call`. The new node behaves  similarly to the TypeScript `CallExpression` whose `receiver` can be any expression.\n\nThere was a similar situation in the output AST where we had an `InvokeMethodExpression` and `InvokeFunctionExpression`. I've combined both of them into `InvokeFunctionExpression`.\n\nPR Close #42882",
    "sha": "2028c3933f7fe2961999da475febde5a03bb694d",
    "files": [
        {
            "sha": "c95c1ba52f50a23199ea4339a142239e3fc82a3f",
            "filename": "packages/compiler-cli/linker/test/file_linker/emit_scopes/emit_scope_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Femit_scopes%2Femit_scope_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Femit_scopes%2Femit_scope_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Femit_scopes%2Femit_scope_spec.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -32,7 +32,7 @@ describe('EmitScope', () => {\n       const emitScope = new EmitScope<ts.Statement, ts.Expression>(ngImport, translator);\n \n       const coreImportRef = new o.ExternalReference('@angular/core', 'foo');\n-      const def = emitScope.translateDefinition(o.importExpr(coreImportRef).callMethod('bar', []));\n+      const def = emitScope.translateDefinition(o.importExpr(coreImportRef).prop('bar').callFn([]));\n       expect(generate(def)).toEqual('core.foo.bar()');\n     });\n "
        },
        {
            "sha": "e8b787195fc33e4081871c92fcc9b9d4da93df75",
            "filename": "packages/compiler-cli/linker/test/file_linker/emit_scopes/iief_emit_scope_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Femit_scopes%2Fiief_emit_scope_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Femit_scopes%2Fiief_emit_scope_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Ftest%2Ffile_linker%2Femit_scopes%2Fiief_emit_scope_spec.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -34,7 +34,7 @@ describe('IifeEmitScope', () => {\n           new IifeEmitScope<ts.Statement, ts.Expression>(ngImport, translator, factory);\n \n       const coreImportRef = new o.ExternalReference('@angular/core', 'foo');\n-      const def = emitScope.translateDefinition(o.importExpr(coreImportRef).callMethod('bar', []));\n+      const def = emitScope.translateDefinition(o.importExpr(coreImportRef).prop('bar').callFn([]));\n       expect(generate(def)).toEqual('function () { return core.foo.bar(); }()');\n     });\n "
        },
        {
            "sha": "2ec0ff7fd31ca3fa6891fff3cfe353f4d1e8442f",
            "filename": "packages/compiler-cli/src/ngtsc/indexer/src/api.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Fsrc%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Fsrc%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Fsrc%2Fapi.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -14,7 +14,7 @@ import {ClassDeclaration, DeclarationNode} from '../../reflection';\n  */\n export enum IdentifierKind {\n   Property,\n-  Method,\n+  Method,  // TODO: No longer being used. To be removed together with `MethodIdentifier`.\n   Element,\n   Template,\n   Attribute,\n@@ -46,7 +46,10 @@ export interface PropertyIdentifier extends ExpressionIdentifier {\n   kind: IdentifierKind.Property;\n }\n \n-/** Describes a method accessed in a template. */\n+/**\n+ * Describes a method accessed in a template.\n+ * @deprecated No longer being used. To be removed.\n+ */\n export interface MethodIdentifier extends ExpressionIdentifier {\n   kind: IdentifierKind.Method;\n }\n@@ -109,8 +112,8 @@ export interface VariableIdentifier extends TemplateIdentifier {\n  * Identifiers recorded at the top level of the template, without any context about the HTML nodes\n  * they were discovered in.\n  */\n-export type TopLevelIdentifier = PropertyIdentifier|MethodIdentifier|ElementIdentifier|\n-    TemplateNodeIdentifier|ReferenceIdentifier|VariableIdentifier;\n+export type TopLevelIdentifier = PropertyIdentifier|ElementIdentifier|TemplateNodeIdentifier|\n+    ReferenceIdentifier|VariableIdentifier|MethodIdentifier;\n \n /**\n  * Describes the absolute byte offsets of a text anchor in a source code."
        },
        {
            "sha": "d0f6f4341a5290d4468ece0648fe3a4a76d30e31",
            "filename": "packages/compiler-cli/src/ngtsc/indexer/src/template.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 6,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Fsrc%2Ftemplate.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Fsrc%2Ftemplate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Fsrc%2Ftemplate.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -5,7 +5,7 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {AST, ASTWithSource, BoundTarget, ImplicitReceiver, MethodCall, ParseSourceSpan, PropertyRead, PropertyWrite, RecursiveAstVisitor, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstBoundText, TmplAstElement, TmplAstNode, TmplAstRecursiveVisitor, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\n+import {AST, ASTWithSource, BoundTarget, ImplicitReceiver, ParseSourceSpan, PropertyRead, PropertyWrite, RecursiveAstVisitor, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstBoundText, TmplAstElement, TmplAstNode, TmplAstRecursiveVisitor, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\n import {AbsoluteSourceSpan, AttributeIdentifier, ElementIdentifier, IdentifierKind, MethodIdentifier, PropertyIdentifier, ReferenceIdentifier, TemplateNodeIdentifier, TopLevelIdentifier, VariableIdentifier} from './api';\n import {ComponentMeta} from './context';\n \n@@ -66,11 +66,6 @@ class ExpressionVisitor extends RecursiveAstVisitor {\n     ast.visit(this);\n   }\n \n-  override visitMethodCall(ast: MethodCall, context: {}) {\n-    this.visitIdentifier(ast, IdentifierKind.Method);\n-    super.visitMethodCall(ast, context);\n-  }\n-\n   override visitPropertyRead(ast: PropertyRead, context: {}) {\n     this.visitIdentifier(ast, IdentifierKind.Property);\n     super.visitPropertyRead(ast, context);"
        },
        {
            "sha": "6a2b680c8e527553006cea3defef19f62b580729",
            "filename": "packages/compiler-cli/src/ngtsc/indexer/test/template_spec.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Ftest%2Ftemplate_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Ftest%2Ftemplate_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Ftest%2Ftemplate_spec.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -277,7 +277,7 @@ runInEachFileSystem(() => {\n       });\n     });\n \n-    describe('generates identifiers for MethodCalls', () => {\n+    describe('generates identifiers for method calls', () => {\n       it('should discover component method calls', () => {\n         const template = '{{foo()}}';\n         const refs = getTemplateIdentifiers(bind(template));\n@@ -286,7 +286,7 @@ runInEachFileSystem(() => {\n         const [ref] = Array.from(refs);\n         expect(ref).toEqual({\n           name: 'foo',\n-          kind: IdentifierKind.Method,\n+          kind: IdentifierKind.Property,\n           span: new AbsoluteSourceSpan(2, 5),\n           target: null,\n         });\n@@ -299,7 +299,7 @@ runInEachFileSystem(() => {\n         const refArr = Array.from(refs);\n         expect(refArr).toContain({\n           name: 'foo',\n-          kind: IdentifierKind.Method,\n+          kind: IdentifierKind.Property,\n           span: new AbsoluteSourceSpan(13, 16),\n           target: null,\n         });\n@@ -321,7 +321,7 @@ runInEachFileSystem(() => {\n         const refArr = Array.from(refs);\n         expect(refArr).toContain({\n           name: 'bar',\n-          kind: IdentifierKind.Method,\n+          kind: IdentifierKind.Property,\n           span: new AbsoluteSourceSpan(12, 15),\n           target: null,\n         });\n@@ -334,7 +334,7 @@ runInEachFileSystem(() => {\n         const refArr = Array.from(refs);\n         expect(refArr).toContain({\n           name: 'foos',\n-          kind: IdentifierKind.Method,\n+          kind: IdentifierKind.Property,\n           span: new AbsoluteSourceSpan(24, 28),\n           target: null,\n         });"
        },
        {
            "sha": "bd22bbf6bb4b0a6caf0fb0c1ea351a2911107402",
            "filename": "packages/compiler-cli/src/ngtsc/translator/src/translator.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 10,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftranslator.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftranslator.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftranslator.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -153,16 +153,6 @@ export class ExpressionTranslatorVisitor<TStatement, TExpression> implements o.E\n     return this.factory.createAssignment(target, expr.value.visitExpression(this, context));\n   }\n \n-  visitInvokeMethodExpr(ast: o.InvokeMethodExpr, context: Context): TExpression {\n-    const target = ast.receiver.visitExpression(this, context);\n-    return this.setSourceMapRange(\n-        this.factory.createCallExpression(\n-            ast.name !== null ? this.factory.createPropertyAccess(target, ast.name) : target,\n-            ast.args.map(arg => arg.visitExpression(this, context)),\n-            /* pure */ false),\n-        ast.sourceSpan);\n-  }\n-\n   visitInvokeFunctionExpr(ast: o.InvokeFunctionExpr, context: Context): TExpression {\n     return this.setSourceMapRange(\n         this.factory.createCallExpression("
        },
        {
            "sha": "de30be06cca408da347bf696f66142f43c7e0c89",
            "filename": "packages/compiler-cli/src/ngtsc/translator/src/type_translator.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftype_translator.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftype_translator.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftype_translator.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -90,10 +90,6 @@ export class TypeTranslatorVisitor implements o.ExpressionVisitor, o.TypeVisitor\n     throw new Error('Method not implemented.');\n   }\n \n-  visitInvokeMethodExpr(ast: o.InvokeMethodExpr, context: Context): never {\n-    throw new Error('Method not implemented.');\n-  }\n-\n   visitInvokeFunctionExpr(ast: o.InvokeFunctionExpr, context: Context): never {\n     throw new Error('Method not implemented.');\n   }"
        },
        {
            "sha": "75f886fe7f40eb20c1d04258e8758fa2b7137a96",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/checker.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, LiteralPrimitive, MethodCall, ParseError, ParseSourceSpan, PropertyRead, SafeMethodCall, SafePropertyRead, TmplAstElement, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n+import {AST, Call, LiteralPrimitive, ParseSourceSpan, PropertyRead, SafePropertyRead, TmplAstElement, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n import {AbsoluteFsPath} from '@angular/compiler-cli/src/ngtsc/file_system';\n import {TextAttribute} from '@angular/compiler/src/render3/r3_ast';\n import * as ts from 'typescript';\n@@ -117,8 +117,7 @@ export interface TemplateTypeChecker {\n    * autocompletion at that point in the expression, if such a location exists.\n    */\n   getExpressionCompletionLocation(\n-      expr: PropertyRead|SafePropertyRead|MethodCall|SafeMethodCall,\n-      component: ts.ClassDeclaration): ShimLocation|null;\n+      expr: PropertyRead|SafePropertyRead, component: ts.ClassDeclaration): ShimLocation|null;\n \n   /**\n    * For the given node represents a `LiteralPrimitive`(the `TextAttribute` represents a string"
        },
        {
            "sha": "44ef019ad785d44faa1fbd15b8620c3ccbc2eb73",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, CssSelector, DomElementSchemaRegistry, LiteralPrimitive, MethodCall, ParseError, ParseSourceSpan, parseTemplate, PropertyRead, SafeMethodCall, SafePropertyRead, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\n+import {AST, CssSelector, DomElementSchemaRegistry, LiteralPrimitive, ParseSourceSpan, PropertyRead, SafePropertyRead, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate} from '@angular/compiler';\n import {TextAttribute} from '@angular/compiler/src/render3/r3_ast';\n import * as ts from 'typescript';\n import {ErrorCode, ngErrorCode} from '../../diagnostics';\n@@ -271,8 +271,7 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n   }\n \n   getExpressionCompletionLocation(\n-      ast: PropertyRead|SafePropertyRead|MethodCall|SafeMethodCall,\n-      component: ts.ClassDeclaration): ShimLocation|null {\n+      ast: PropertyRead|SafePropertyRead, component: ts.ClassDeclaration): ShimLocation|null {\n     const engine = this.getOrCreateCompletionEngine(component);\n     if (engine === null) {\n       return null;"
        },
        {
            "sha": "b3c04844b6597d1a67eec64d63207521bc9665e0",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/completion.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 12,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcompletion.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcompletion.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcompletion.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -7,7 +7,7 @@\n  */\n \n import {TmplAstReference, TmplAstTemplate} from '@angular/compiler';\n-import {AST, EmptyExpr, ImplicitReceiver, LiteralPrimitive, MethodCall, PropertyRead, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstNode} from '@angular/compiler/src/compiler';\n+import {AST, EmptyExpr, ImplicitReceiver, LiteralPrimitive, PropertyRead, PropertyWrite, SafePropertyRead, TmplAstNode} from '@angular/compiler/src/compiler';\n import {TextAttribute} from '@angular/compiler/src/render3/r3_ast';\n import * as ts from 'typescript';\n \n@@ -33,9 +33,8 @@ export class CompletionEngine {\n   private templateContextCache =\n       new Map<TmplAstTemplate|null, Map<string, ReferenceCompletion|VariableCompletion>>();\n \n-  private expressionCompletionCache = new Map<\n-      PropertyRead|SafePropertyRead|MethodCall|SafeMethodCall|LiteralPrimitive|TextAttribute,\n-      ShimLocation>();\n+  private expressionCompletionCache =\n+      new Map<PropertyRead|SafePropertyRead|LiteralPrimitive|TextAttribute, ShimLocation>();\n \n \n   constructor(private tcb: ts.Node, private data: TemplateData, private shimPath: AbsoluteFsPath) {\n@@ -111,22 +110,21 @@ export class CompletionEngine {\n     };\n   }\n \n-  getExpressionCompletionLocation(expr: PropertyRead|PropertyWrite|MethodCall|\n-                                  SafeMethodCall): ShimLocation|null {\n+  getExpressionCompletionLocation(expr: PropertyRead|PropertyWrite|SafePropertyRead): ShimLocation\n+      |null {\n     if (this.expressionCompletionCache.has(expr)) {\n       return this.expressionCompletionCache.get(expr)!;\n     }\n \n     // Completion works inside property reads and method calls.\n     let tsExpr: ts.PropertyAccessExpression|null = null;\n-    if (expr instanceof PropertyRead || expr instanceof MethodCall ||\n-        expr instanceof PropertyWrite) {\n+    if (expr instanceof PropertyRead || expr instanceof PropertyWrite) {\n       // Non-safe navigation operations are trivial: `foo.bar` or `foo.bar()`\n       tsExpr = findFirstMatchingNode(this.tcb, {\n         filter: ts.isPropertyAccessExpression,\n         withSpan: expr.nameSpan,\n       });\n-    } else if (expr instanceof SafePropertyRead || expr instanceof SafeMethodCall) {\n+    } else if (expr instanceof SafePropertyRead) {\n       // Safe navigation operations are a little more complex, and involve a ternary. Completion\n       // happens in the \"true\" case of the ternary.\n       const ternaryExpr = findFirstMatchingNode(this.tcb, {\n@@ -138,11 +136,10 @@ export class CompletionEngine {\n       }\n       const whenTrue = ternaryExpr.expression.whenTrue;\n \n-      if (expr instanceof SafePropertyRead && ts.isPropertyAccessExpression(whenTrue)) {\n+      if (ts.isPropertyAccessExpression(whenTrue)) {\n         tsExpr = whenTrue;\n       } else if (\n-          expr instanceof SafeMethodCall && ts.isCallExpression(whenTrue) &&\n-          ts.isPropertyAccessExpression(whenTrue.expression)) {\n+          ts.isCallExpression(whenTrue) && ts.isPropertyAccessExpression(whenTrue.expression)) {\n         tsExpr = whenTrue.expression;\n       }\n     }"
        },
        {
            "sha": "fe4c99bc60ff0287b923d75252860003e1f3be57",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/expression.ts",
            "status": "modified",
            "additions": 31,
            "deletions": 54,
            "changes": 85,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fexpression.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fexpression.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fexpression.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, AstVisitor, ASTWithSource, Binary, BindingPipe, Chain, Conditional, EmptyExpr, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, MethodCall, NonNullAssert, PrefixNot, PropertyRead, PropertyWrite, Quote, SafeKeyedRead, SafeMethodCall, SafePropertyRead, ThisReceiver, Unary} from '@angular/compiler';\n+import {AST, AstVisitor, ASTWithSource, Binary, BindingPipe, Call, Chain, Conditional, EmptyExpr, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, NonNullAssert, PrefixNot, PropertyRead, PropertyWrite, Quote, SafeKeyedRead, SafePropertyRead, ThisReceiver, Unary} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {TypeCheckingConfig} from '../api';\n@@ -129,14 +129,6 @@ class AstTranslator implements AstVisitor {\n     return node;\n   }\n \n-  visitFunctionCall(ast: FunctionCall): ts.Expression {\n-    const receiver = wrapForDiagnostics(this.translate(ast.target!));\n-    const args = ast.args.map(expr => this.translate(expr));\n-    const node = ts.createCall(receiver, undefined, args);\n-    addParseSpanInfo(node, ast.sourceSpan);\n-    return node;\n-  }\n-\n   visitImplicitReceiver(ast: ImplicitReceiver): never {\n     throw new Error('Method not implemented.');\n   }\n@@ -208,16 +200,6 @@ class AstTranslator implements AstVisitor {\n     return node;\n   }\n \n-  visitMethodCall(ast: MethodCall): ts.Expression {\n-    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n-    const method = ts.createPropertyAccess(receiver, ast.name);\n-    addParseSpanInfo(method, ast.nameSpan);\n-    const args = ast.args.map(expr => this.translate(expr));\n-    const node = ts.createCall(method, undefined, args);\n-    addParseSpanInfo(node, ast.sourceSpan);\n-    return node;\n-  }\n-\n   visitNonNullAssert(ast: NonNullAssert): ts.Expression {\n     const expr = wrapForDiagnostics(this.translate(ast.expression));\n     const node = ts.createNonNullExpression(expr);\n@@ -274,32 +256,6 @@ class AstTranslator implements AstVisitor {\n     return NULL_AS_ANY;\n   }\n \n-  visitSafeMethodCall(ast: SafeMethodCall): ts.Expression {\n-    // See the comments in SafePropertyRead above for an explanation of the cases here.\n-    let node: ts.Expression;\n-    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n-    const args = ast.args.map(expr => this.translate(expr));\n-    if (this.config.strictSafeNavigationTypes) {\n-      // \"a?.method(...)\" becomes (null as any ? a!.method(...) : undefined)\n-      const method = ts.createPropertyAccess(ts.createNonNullExpression(receiver), ast.name);\n-      addParseSpanInfo(method, ast.nameSpan);\n-      const call = ts.createCall(method, undefined, args);\n-      node = ts.createParen(ts.createConditional(NULL_AS_ANY, call, UNDEFINED));\n-    } else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {\n-      // \"a?.method(...)\" becomes (a as any).method(...)\n-      const method = ts.createPropertyAccess(tsCastToAny(receiver), ast.name);\n-      addParseSpanInfo(method, ast.nameSpan);\n-      node = ts.createCall(method, undefined, args);\n-    } else {\n-      // \"a?.method(...)\" becomes (a!.method(...) as any)\n-      const method = ts.createPropertyAccess(ts.createNonNullExpression(receiver), ast.name);\n-      addParseSpanInfo(method, ast.nameSpan);\n-      node = tsCastToAny(ts.createCall(method, undefined, args));\n-    }\n-    addParseSpanInfo(node, ast.sourceSpan);\n-    return node;\n-  }\n-\n   visitSafePropertyRead(ast: SafePropertyRead): ts.Expression {\n     let node: ts.Expression;\n     const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n@@ -354,6 +310,33 @@ class AstTranslator implements AstVisitor {\n     addParseSpanInfo(node, ast.sourceSpan);\n     return node;\n   }\n+\n+  visitCall(ast: Call): ts.Expression {\n+    const args = ast.args.map(expr => this.translate(expr));\n+    const expr = wrapForDiagnostics(this.translate(ast.receiver));\n+    let node: ts.Expression;\n+\n+    // Safe property/keyed reads will produce a ternary whose value is nullable.\n+    // We have to generate a similar ternary around the call.\n+    if (ast.receiver instanceof SafePropertyRead || ast.receiver instanceof SafeKeyedRead) {\n+      if (this.config.strictSafeNavigationTypes) {\n+        // \"a?.method(...)\" becomes (null as any ? a!.method(...) : undefined)\n+        const call = ts.createCall(ts.createNonNullExpression(expr), undefined, args);\n+        node = ts.createParen(ts.createConditional(NULL_AS_ANY, call, UNDEFINED));\n+      } else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {\n+        // \"a?.method(...)\" becomes (a as any).method(...)\n+        node = ts.createCall(tsCastToAny(expr), undefined, args);\n+      } else {\n+        // \"a?.method(...)\" becomes (a!.method(...) as any)\n+        node = tsCastToAny(ts.createCall(ts.createNonNullExpression(expr), undefined, args));\n+      }\n+    } else {\n+      node = ts.createCall(expr, undefined, args);\n+    }\n+\n+    addParseSpanInfo(node, ast.sourceSpan);\n+    return node;\n+  }\n }\n \n /**\n@@ -372,9 +355,9 @@ class AstTranslator implements AstVisitor {\n class VeSafeLhsInferenceBugDetector implements AstVisitor {\n   private static SINGLETON = new VeSafeLhsInferenceBugDetector();\n \n-  static veWillInferAnyFor(ast: SafeMethodCall|SafePropertyRead|SafeKeyedRead) {\n+  static veWillInferAnyFor(ast: Call|SafePropertyRead|SafeKeyedRead) {\n     const visitor = VeSafeLhsInferenceBugDetector.SINGLETON;\n-    return ast instanceof SafeKeyedRead ? ast.receiver.visit(visitor) : ast.receiver.visit(visitor);\n+    return ast instanceof Call ? ast.visit(visitor) : ast.receiver.visit(visitor);\n   }\n \n   visitUnary(ast: Unary): boolean {\n@@ -389,7 +372,7 @@ class VeSafeLhsInferenceBugDetector implements AstVisitor {\n   visitConditional(ast: Conditional): boolean {\n     return ast.condition.visit(this) || ast.trueExp.visit(this) || ast.falseExp.visit(this);\n   }\n-  visitFunctionCall(ast: FunctionCall): boolean {\n+  visitCall(ast: Call): boolean {\n     return true;\n   }\n   visitImplicitReceiver(ast: ImplicitReceiver): boolean {\n@@ -416,9 +399,6 @@ class VeSafeLhsInferenceBugDetector implements AstVisitor {\n   visitLiteralPrimitive(ast: LiteralPrimitive): boolean {\n     return false;\n   }\n-  visitMethodCall(ast: MethodCall): boolean {\n-    return true;\n-  }\n   visitPipe(ast: BindingPipe): boolean {\n     return true;\n   }\n@@ -437,9 +417,6 @@ class VeSafeLhsInferenceBugDetector implements AstVisitor {\n   visitQuote(ast: Quote): boolean {\n     return false;\n   }\n-  visitSafeMethodCall(ast: SafeMethodCall): boolean {\n-    return true;\n-  }\n   visitSafePropertyRead(ast: SafePropertyRead): boolean {\n     return false;\n   }"
        },
        {
            "sha": "0bed8ba2dab11f803edc1cbf42b268417c418404",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 8,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, ASTWithSource, BindingPipe, MethodCall, ParseSourceSpan, PropertyRead, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n+import {AST, ASTWithSource, BindingPipe, Call, ParseSourceSpan, PropertyRead, PropertyWrite, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {AbsoluteFsPath} from '../../file_system';\n@@ -493,11 +493,15 @@ export class SymbolBuilder {\n       return this.getSymbol(expressionTarget);\n     }\n \n-    // The `name` part of a `PropertyWrite` and `MethodCall` does not have its own\n+    let withSpan = expression.sourceSpan;\n+\n+    // The `name` part of a `PropertyWrite` and a non-safe `Call` does not have its own\n     // AST so there is no way to retrieve a `Symbol` for just the `name` via a specific node.\n-    const withSpan = (expression instanceof PropertyWrite || expression instanceof MethodCall) ?\n-        expression.nameSpan :\n-        expression.sourceSpan;\n+    if (expression instanceof PropertyWrite) {\n+      withSpan = expression.nameSpan;\n+    } else if (expression instanceof Call && expression.receiver instanceof PropertyRead) {\n+      withSpan = expression.receiver.nameSpan;\n+    }\n \n     let node: ts.Node|null = null;\n \n@@ -526,10 +530,10 @@ export class SymbolBuilder {\n     // - If our expression is a pipe binding (\"a | test:b:c\"), we want the Symbol for the\n     // `transform` on the pipe.\n     // - Otherwise, we retrieve the symbol for the node itself with no special considerations\n-    if ((expression instanceof SafePropertyRead || expression instanceof SafeMethodCall) &&\n+    if ((expression instanceof SafePropertyRead ||\n+         (expression instanceof Call && expression.receiver instanceof SafePropertyRead)) &&\n         ts.isConditionalExpression(node)) {\n-      const whenTrueSymbol =\n-          (expression instanceof SafeMethodCall && ts.isCallExpression(node.whenTrue)) ?\n+      const whenTrueSymbol = (expression instanceof Call && ts.isCallExpression(node.whenTrue)) ?\n           this.getSymbolOfTsNode(node.whenTrue.expression) :\n           this.getSymbolOfTsNode(node.whenTrue);\n       if (whenTrueSymbol === null) {"
        },
        {
            "sha": "077e60aeb10176b33c4deef6ce6c5e42b5be23f1",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 9,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -6,7 +6,8 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, BindingPipe, BindingType, BoundTarget, DYNAMIC_TYPE, ImplicitReceiver, MethodCall, ParsedEventType, ParseSourceSpan, PropertyRead, PropertyWrite, SchemaMetadata, ThisReceiver, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstBoundText, TmplAstElement, TmplAstIcu, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n+import {AST, BindingPipe, BindingType, BoundTarget, Call, DYNAMIC_TYPE, ImplicitReceiver, ParsedEventType, ParseSourceSpan, PropertyRead, PropertyWrite, SchemaMetadata, ThisReceiver, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstBoundText, TmplAstElement, TmplAstIcu, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n+import {SafePropertyRead} from '@angular/compiler/src/compiler';\n import * as ts from 'typescript';\n \n import {Reference} from '../../imports';\n@@ -1704,15 +1705,15 @@ class TcbExpressionTranslator {\n     } else if (ast instanceof ImplicitReceiver) {\n       // AST instances representing variables and references look very similar to property reads\n       // or method calls from the component context: both have the shape\n-      // PropertyRead(ImplicitReceiver, 'propName') or MethodCall(ImplicitReceiver, 'methodName').\n+      // PropertyRead(ImplicitReceiver, 'propName') or Call(ImplicitReceiver, 'methodName').\n       //\n-      // `translate` will first try to `resolve` the outer PropertyRead/MethodCall. If this works,\n+      // `translate` will first try to `resolve` the outer PropertyRead/Call. If this works,\n       // it's because the `BoundTarget` found an expression target for the whole expression, and\n       // therefore `translate` will never attempt to `resolve` the ImplicitReceiver of that\n-      // PropertyRead/MethodCall.\n+      // PropertyRead/Call.\n       //\n       // Therefore if `resolve` is called on an `ImplicitReceiver`, it's because no outer\n-      // PropertyRead/MethodCall resolved to a variable or reference, and therefore this is a\n+      // PropertyRead/Call resolved to a variable or reference, and therefore this is a\n       // property read or method call on the component context itself.\n       return ts.createIdentifier('ctx');\n     } else if (ast instanceof BindingPipe) {\n@@ -1745,11 +1746,12 @@ class TcbExpressionTranslator {\n       addParseSpanInfo(result, ast.sourceSpan);\n       return result;\n     } else if (\n-        ast instanceof MethodCall && ast.receiver instanceof ImplicitReceiver &&\n-        !(ast.receiver instanceof ThisReceiver)) {\n+        ast instanceof Call &&\n+        (ast.receiver instanceof PropertyRead || ast.receiver instanceof SafePropertyRead) &&\n+        !(ast.receiver.receiver instanceof ThisReceiver)) {\n       // Resolve the special `$any(expr)` syntax to insert a cast of the argument to type `any`.\n       // `$any(expr)` -> `expr as any`\n-      if (ast.name === '$any' && ast.args.length === 1) {\n+      if (ast.receiver.name === '$any' && ast.args.length === 1) {\n         const expr = this.translate(ast.args[0]);\n         const exprAsAny =\n             ts.createAsExpression(expr, ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n@@ -1768,7 +1770,7 @@ class TcbExpressionTranslator {\n       }\n \n       const method = wrapForDiagnostics(receiver);\n-      addParseSpanInfo(method, ast.nameSpan);\n+      addParseSpanInfo(method, ast.receiver.nameSpan);\n       const args = ast.args.map(arg => this.translate(arg));\n       const node = ts.createCall(method, undefined, args);\n       addParseSpanInfo(node, ast.sourceSpan);"
        },
        {
            "sha": "a000cf318c7e9701716ab72c63d4615ec27d53a4",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/span_comments_spec.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fspan_comments_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fspan_comments_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fspan_comments_spec.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -39,7 +39,7 @@ describe('type check blocks diagnostics', () => {\n       const TEMPLATE = '{{ m({foo: a, bar: b}) }}';\n       expect(tcbWithSpans(TEMPLATE))\n           .toContain(\n-              '(ctx).m /*3,4*/({ \"foo\": ((ctx).a /*11,12*/) /*11,12*/, \"bar\": ((ctx).b /*19,20*/) /*19,20*/ } /*5,21*/) /*3,22*/');\n+              '((((ctx).m /*3,4*/) /*3,4*/)({ \"foo\": ((ctx).a /*11,12*/) /*11,12*/, \"bar\": ((ctx).b /*19,20*/) /*19,20*/ } /*5,21*/) /*3,22*/)');\n     });\n \n     it('should annotate literal map expressions with shorthand declarations', () => {\n@@ -48,7 +48,7 @@ describe('type check blocks diagnostics', () => {\n       const TEMPLATE = '{{ m({a, b}) }}';\n       expect(tcbWithSpans(TEMPLATE))\n           .toContain(\n-              '((ctx).m /*3,4*/({ \"a\": ((ctx).a /*6,7*/) /*6,7*/, \"b\": ((ctx).b /*9,10*/) /*9,10*/ } /*5,11*/) /*3,12*/)');\n+              '((((ctx).m /*3,4*/) /*3,4*/)({ \"a\": ((ctx).a /*6,7*/) /*6,7*/, \"b\": ((ctx).b /*9,10*/) /*9,10*/ } /*5,11*/) /*3,12*/)');\n     });\n \n     it('should annotate literal array expressions', () => {\n@@ -76,21 +76,21 @@ describe('type check blocks diagnostics', () => {\n       const TEMPLATE = `{{ method(a, b) }}`;\n       expect(tcbWithSpans(TEMPLATE))\n           .toContain(\n-              '(ctx).method /*3,9*/(((ctx).a /*10,11*/) /*10,11*/, ((ctx).b /*13,14*/) /*13,14*/) /*3,15*/');\n+              '((((ctx).method /*3,9*/) /*3,9*/)(((ctx).a /*10,11*/) /*10,11*/, ((ctx).b /*13,14*/) /*13,14*/) /*3,15*/)');\n     });\n \n     it('should annotate method calls of variables', () => {\n       const TEMPLATE = `<ng-template let-method>{{ method(a, b) }}</ng-template>`;\n       expect(tcbWithSpans(TEMPLATE))\n           .toContain(\n-              '(_t2 /*27,39*/) /*27,33*/(((ctx).a /*34,35*/) /*34,35*/, ((ctx).b /*37,38*/) /*37,38*/) /*27,39*/');\n+              '((_t2 /*27,33*/)(((ctx).a /*34,35*/) /*34,35*/, ((ctx).b /*37,38*/) /*37,38*/) /*27,39*/)');\n     });\n \n     it('should annotate function calls', () => {\n       const TEMPLATE = `{{ method(a)(b, c) }}`;\n       expect(tcbWithSpans(TEMPLATE))\n           .toContain(\n-              '((ctx).method /*3,9*/(((ctx).a /*10,11*/) /*10,11*/) /*3,12*/)(((ctx).b /*13,14*/) /*13,14*/, ((ctx).c /*16,17*/) /*16,17*/) /*3,18*/');\n+              '(((((ctx).method /*3,9*/) /*3,9*/)(((ctx).a /*10,11*/) /*10,11*/) /*3,12*/)(((ctx).b /*13,14*/) /*13,14*/, ((ctx).c /*16,17*/) /*16,17*/) /*3,18*/)');\n     });\n \n     it('should annotate property access', () => {\n@@ -135,7 +135,7 @@ describe('type check blocks diagnostics', () => {\n       const TEMPLATE = `{{ a?.method(b) }}`;\n       expect(tcbWithSpans(TEMPLATE))\n           .toContain(\n-              '(null as any ? (((ctx).a /*3,4*/) /*3,4*/)!.method /*6,12*/(((ctx).b /*13,14*/) /*13,14*/) : undefined) /*3,15*/');\n+              '((null as any ? ((null as any ? (((ctx).a /*3,4*/) /*3,4*/)!.method /*6,12*/ : undefined) /*3,12*/)!(((ctx).b /*13,14*/) /*13,14*/) : undefined) /*3,15*/)');\n     });\n \n     it('should annotate safe keyed reads', () => {"
        },
        {
            "sha": "7415dfff0a63b8ada2e43509cfe087fb1a010b47",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_check_block_spec.ts",
            "status": "modified",
            "additions": 30,
            "deletions": 26,
            "changes": 56,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -21,12 +21,12 @@ describe('type check blocks', () => {\n \n   it('should generate literal map expressions', () => {\n     const TEMPLATE = '{{ method({foo: a, bar: b}) }}';\n-    expect(tcb(TEMPLATE)).toContain('(ctx).method({ \"foo\": ((ctx).a), \"bar\": ((ctx).b) })');\n+    expect(tcb(TEMPLATE)).toContain('(((ctx).method))({ \"foo\": ((ctx).a), \"bar\": ((ctx).b) })');\n   });\n \n   it('should generate literal array expressions', () => {\n     const TEMPLATE = '{{ method([a, b]) }}';\n-    expect(tcb(TEMPLATE)).toContain('(ctx).method([((ctx).a), ((ctx).b)])');\n+    expect(tcb(TEMPLATE)).toContain('(((ctx).method))([((ctx).a), ((ctx).b)])');\n   });\n \n   it('should handle non-null assertions', () => {\n@@ -610,7 +610,7 @@ describe('type check blocks', () => {\n   it('should handle $any accessed through `this`', () => {\n     const TEMPLATE = `{{this.$any(a)}}`;\n     const block = tcb(TEMPLATE);\n-    expect(block).toContain('((ctx).$any(((ctx).a)))');\n+    expect(block).toContain('((((ctx).$any))(((ctx).a)))');\n   });\n \n   describe('experimental DOM checking via lib.dom.d.ts', () => {\n@@ -683,27 +683,28 @@ describe('type check blocks', () => {\n       const TEMPLATE = `<div dir (dirOutput)=\"foo($event)\"></div>`;\n       const block = tcb(TEMPLATE, DIRECTIVES);\n       expect(block).toContain(\n-          '_t1[\"outputField\"].subscribe(function ($event): any { (ctx).foo($event); });');\n+          '_t1[\"outputField\"].subscribe(function ($event): any { (((ctx).foo))($event); });');\n     });\n \n     it('should emit a listener function with AnimationEvent for animation events', () => {\n       const TEMPLATE = `<div (@animation.done)=\"foo($event)\"></div>`;\n       const block = tcb(TEMPLATE);\n-      expect(block).toContain('function ($event: i1.AnimationEvent): any { (ctx).foo($event); }');\n+      expect(block).toContain(\n+          'function ($event: i1.AnimationEvent): any { (((ctx).foo))($event); }');\n     });\n \n     it('should emit addEventListener calls for unclaimed outputs', () => {\n       const TEMPLATE = `<div (event)=\"foo($event)\"></div>`;\n       const block = tcb(TEMPLATE);\n       expect(block).toContain(\n-          '_t1.addEventListener(\"event\", function ($event): any { (ctx).foo($event); });');\n+          '_t1.addEventListener(\"event\", function ($event): any { (((ctx).foo))($event); });');\n     });\n \n     it('should allow to cast $event using $any', () => {\n       const TEMPLATE = `<div (event)=\"foo($any($event))\"></div>`;\n       const block = tcb(TEMPLATE);\n       expect(block).toContain(\n-          '_t1.addEventListener(\"event\", function ($event): any { (ctx).foo(($event as any)); });');\n+          '_t1.addEventListener(\"event\", function ($event): any { (((ctx).foo))(($event as any)); });');\n     });\n \n     it('should detect writes to template variables', () => {\n@@ -718,7 +719,7 @@ describe('type check blocks', () => {\n       const block = tcb(TEMPLATE);\n \n       expect(block).toContain(\n-          '_t1.addEventListener(\"event\", function ($event): any { (ctx).foo(((ctx).$event)); });');\n+          '_t1.addEventListener(\"event\", function ($event): any { (((ctx).foo))(((ctx).$event)); });');\n     });\n   });\n \n@@ -846,18 +847,18 @@ describe('type check blocks', () => {\n       it('should check types of directive outputs when enabled', () => {\n         const block = tcb(TEMPLATE, DIRECTIVES);\n         expect(block).toContain(\n-            '_t1[\"outputField\"].subscribe(function ($event): any { (ctx).foo($event); });');\n+            '_t1[\"outputField\"].subscribe(function ($event): any { (((ctx).foo))($event); });');\n         expect(block).toContain(\n-            '_t2.addEventListener(\"nonDirOutput\", function ($event): any { (ctx).foo($event); });');\n+            '_t2.addEventListener(\"nonDirOutput\", function ($event): any { (((ctx).foo))($event); });');\n       });\n       it('should not check types of directive outputs when disabled', () => {\n         const DISABLED_CONFIG:\n             TypeCheckingConfig = {...BASE_CONFIG, checkTypeOfOutputEvents: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n-        expect(block).toContain('function ($event: any): any { (ctx).foo($event); }');\n+        expect(block).toContain('function ($event: any): any { (((ctx).foo))($event); }');\n         // Note that DOM events are still checked, that is controlled by `checkTypeOfDomEvents`\n         expect(block).toContain(\n-            'addEventListener(\"nonDirOutput\", function ($event): any { (ctx).foo($event); });');\n+            'addEventListener(\"nonDirOutput\", function ($event): any { (((ctx).foo))($event); });');\n       });\n     });\n \n@@ -866,13 +867,14 @@ describe('type check blocks', () => {\n \n       it('should check types of animation events when enabled', () => {\n         const block = tcb(TEMPLATE, DIRECTIVES);\n-        expect(block).toContain('function ($event: i1.AnimationEvent): any { (ctx).foo($event); }');\n+        expect(block).toContain(\n+            'function ($event: i1.AnimationEvent): any { (((ctx).foo))($event); }');\n       });\n       it('should not check types of animation events when disabled', () => {\n         const DISABLED_CONFIG:\n             TypeCheckingConfig = {...BASE_CONFIG, checkTypeOfAnimationEvents: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n-        expect(block).toContain('function ($event: any): any { (ctx).foo($event); }');\n+        expect(block).toContain('function ($event: any): any { (((ctx).foo))($event); }');\n       });\n     });\n \n@@ -882,18 +884,18 @@ describe('type check blocks', () => {\n       it('should check types of DOM events when enabled', () => {\n         const block = tcb(TEMPLATE, DIRECTIVES);\n         expect(block).toContain(\n-            '_t1[\"outputField\"].subscribe(function ($event): any { (ctx).foo($event); });');\n+            '_t1[\"outputField\"].subscribe(function ($event): any { (((ctx).foo))($event); });');\n         expect(block).toContain(\n-            '_t2.addEventListener(\"nonDirOutput\", function ($event): any { (ctx).foo($event); });');\n+            '_t2.addEventListener(\"nonDirOutput\", function ($event): any { (((ctx).foo))($event); });');\n       });\n       it('should not check types of DOM events when disabled', () => {\n         const DISABLED_CONFIG: TypeCheckingConfig = {...BASE_CONFIG, checkTypeOfDomEvents: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n         // Note that directive outputs are still checked, that is controlled by\n         // `checkTypeOfOutputEvents`\n         expect(block).toContain(\n-            '_t1[\"outputField\"].subscribe(function ($event): any { (ctx).foo($event); });');\n-        expect(block).toContain('function ($event: any): any { (ctx).foo($event); }');\n+            '_t1[\"outputField\"].subscribe(function ($event): any { (((ctx).foo))($event); });');\n+        expect(block).toContain('function ($event: any): any { (((ctx).foo))($event); }');\n       });\n     });\n \n@@ -1001,15 +1003,16 @@ describe('type check blocks', () => {\n \n       it('should use undefined for safe navigation operations when enabled', () => {\n         const block = tcb(TEMPLATE, DIRECTIVES);\n-        expect(block).toContain('(null as any ? (((ctx).a))!.method() : undefined)');\n+        expect(block).toContain(\n+            '(null as any ? ((null as any ? (((ctx).a))!.method : undefined))!() : undefined)');\n         expect(block).toContain('(null as any ? (((ctx).a))!.b : undefined)');\n         expect(block).toContain('(null as any ? (((ctx).a))![0] : undefined)');\n       });\n       it('should use an \\'any\\' type for safe navigation operations when disabled', () => {\n         const DISABLED_CONFIG:\n             TypeCheckingConfig = {...BASE_CONFIG, strictSafeNavigationTypes: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n-        expect(block).toContain('((((ctx).a))!.method() as any)');\n+        expect(block).toContain('(((((((ctx).a))!.method as any)) as any)())');\n         expect(block).toContain('((((ctx).a))!.b as any)');\n         expect(block).toContain('(((((ctx).a))![0] as any)');\n       });\n@@ -1019,17 +1022,18 @@ describe('type check blocks', () => {\n       const TEMPLATE = `{{a.method()?.b}} {{a()?.method()}} {{a.method()?.[0]}}`;\n       it('should check the presence of a property/method on the receiver when enabled', () => {\n         const block = tcb(TEMPLATE, DIRECTIVES);\n-        expect(block).toContain('(null as any ? ((((ctx).a)).method())!.b : undefined)');\n-        expect(block).toContain('(null as any ? ((ctx).a())!.method() : undefined)');\n-        expect(block).toContain('(null as any ? ((((ctx).a)).method())![0] : undefined)');\n+        expect(block).toContain('(null as any ? ((((((ctx).a)).method))())!.b : undefined)');\n+        expect(block).toContain(\n+            '(null as any ? ((null as any ? ((((ctx).a))())!.method : undefined))!() : undefined)');\n+        expect(block).toContain('(null as any ? ((((((ctx).a)).method))())![0] : undefined)');\n       });\n       it('should not check the presence of a property/method on the receiver when disabled', () => {\n         const DISABLED_CONFIG:\n             TypeCheckingConfig = {...BASE_CONFIG, strictSafeNavigationTypes: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n-        expect(block).toContain('(((((ctx).a)).method()) as any).b');\n-        expect(block).toContain('(((ctx).a()) as any).method()');\n-        expect(block).toContain('(((((ctx).a)).method()) as any)[0]');\n+        expect(block).toContain('((((((((ctx).a)).method))()) as any).b)');\n+        expect(block).toContain('((((((((ctx).a))()) as any).method) as any)())');\n+        expect(block).toContain('((((((((ctx).a)).method))()) as any)[0])');\n       });\n     });\n "
        },
        {
            "sha": "40b9fa408bb334e68bc0409e601a9bc8c9570751",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker__get_symbol_of_template_node_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -855,7 +855,7 @@ runInEachFileSystem(() => {\n         expect(program.getTypeChecker().typeToString(writeSymbol.tsType)).toEqual('any');\n       });\n \n-      it('should get a symbol for MethodCall expressions', () => {\n+      it('should get a symbol for Call expressions', () => {\n         const fileName = absoluteFrom('/main.ts');\n         const {templateTypeChecker, program} = setup([\n           {\n@@ -869,11 +869,11 @@ runInEachFileSystem(() => {\n         const node = getAstElements(templateTypeChecker, cmp)[0];\n         const callSymbol = templateTypeChecker.getSymbolOfNode(node.inputs[0].value, cmp)!;\n         assertExpressionSymbol(callSymbol);\n-        // Note that the symbol returned is for the method name of the MethodCall. The AST\n+        // Note that the symbol returned is for the method name of the Call. The AST\n         // does not support specific designation for the name so we assume that's what\n         // is wanted in this case. We don't support retrieving a symbol for the whole\n         // call expression and if you want to get a symbol for the args, you can\n-        // use the AST of the args in the `MethodCall`.\n+        // use the AST of the args in the `Call`.\n         expect(program.getTypeChecker().symbolToString(callSymbol.tsSymbol!)).toEqual('toString');\n         expect(program.getTypeChecker().typeToString(callSymbol.tsType))\n             .toEqual('(v: any) => string');"
        },
        {
            "sha": "67d907716d5aaae26ee8a11e6e78f99be0566935",
            "filename": "packages/compiler-cli/src/transformers/node_emitter.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 10,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fnode_emitter.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fnode_emitter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fnode_emitter.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AssertNotNull, BinaryOperator, BinaryOperatorExpr, BuiltinMethod, BuiltinVar, CastExpr, ClassStmt, CommaExpr, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, ExpressionStatement, ExpressionVisitor, ExternalExpr, ExternalReference, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, LeadingComment, leadingComment, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, LocalizedString, NotExpr, ParseSourceFile, ParseSourceSpan, PartialModule, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, Statement, StatementVisitor, StmtModifier, TaggedTemplateExpr, ThrowStmt, TryCatchStmt, TypeofExpr, UnaryOperator, UnaryOperatorExpr, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr} from '@angular/compiler';\n+import {AssertNotNull, BinaryOperator, BinaryOperatorExpr, BuiltinMethod, BuiltinVar, CastExpr, ClassStmt, CommaExpr, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, ExpressionStatement, ExpressionVisitor, ExternalExpr, ExternalReference, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, LeadingComment, leadingComment, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, LocalizedString, NotExpr, ParseSourceFile, ParseSourceSpan, PartialModule, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, Statement, StatementVisitor, StmtModifier, TaggedTemplateExpr, ThrowStmt, TryCatchStmt, TypeofExpr, UnaryOperator, UnaryOperatorExpr, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {attachComments} from '../ngtsc/translator';\n@@ -527,15 +527,6 @@ export class NodeEmitterVisitor implements StatementVisitor, ExpressionVisitor {\n             expr.value.visitExpression(this, null)));\n   }\n \n-  visitInvokeMethodExpr(expr: InvokeMethodExpr): RecordedNode<ts.CallExpression> {\n-    const methodName = getMethodName(expr);\n-    return this.postProcess(\n-        expr,\n-        ts.createCall(\n-            ts.createPropertyAccess(expr.receiver.visitExpression(this, null), methodName),\n-            /* typeArguments */ undefined, expr.args.map(arg => arg.visitExpression(this, null))));\n-  }\n-\n   visitInvokeFunctionExpr(expr: InvokeFunctionExpr): RecordedNode<ts.CallExpression> {\n     return this.postProcess(\n         expr,"
        },
        {
            "sha": "a7c80bd1fa0f13fb01f39af00ba1b44f4e0ec12f",
            "filename": "packages/compiler-cli/test/transformers/node_emitter_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 19,
            "changes": 22,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fnode_emitter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fnode_emitter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fnode_emitter_spec.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -151,36 +151,20 @@ describe('TypeScriptNodeEmitter', () => {\n \n   it('should invoke functions and methods and constructors', () => {\n     expect(emitStmt(o.variable('someFn').callFn([o.literal(1)]).toStmt())).toEqual('someFn(1);');\n-    expect(emitStmt(o.variable('someObj').callMethod('someMethod', [o.literal(1)]).toStmt()))\n+    expect(emitStmt(o.variable('someObj').prop('someMethod').callFn([o.literal(1)]).toStmt()))\n         .toEqual('someObj.someMethod(1);');\n     expect(emitStmt(o.variable('SomeClass').instantiate([o.literal(1)]).toStmt()))\n         .toEqual('new SomeClass(1);');\n   });\n \n   it('should invoke functions and methods and constructors', () => {\n     expect(emitStmt(o.variable('someFn').callFn([o.literal(1)]).toStmt())).toEqual('someFn(1);');\n-    expect(emitStmt(o.variable('someObj').callMethod('someMethod', [o.literal(1)]).toStmt()))\n+    expect(emitStmt(o.variable('someObj').prop('someMethod').callFn([o.literal(1)]).toStmt()))\n         .toEqual('someObj.someMethod(1);');\n     expect(emitStmt(o.variable('SomeClass').instantiate([o.literal(1)]).toStmt()))\n         .toEqual('new SomeClass(1);');\n   });\n \n-  it('should support builtin methods', () => {\n-    expect(emitStmt(o.variable('arr1')\n-                        .callMethod(o.BuiltinMethod.ConcatArray, [o.variable('arr2')])\n-                        .toStmt()))\n-        .toEqual('arr1.concat(arr2);');\n-\n-    expect(emitStmt(o.variable('observable')\n-                        .callMethod(o.BuiltinMethod.SubscribeObservable, [o.variable('listener')])\n-                        .toStmt()))\n-        .toEqual('observable.subscribe(listener);');\n-\n-    expect(emitStmt(\n-               o.variable('fn').callMethod(o.BuiltinMethod.Bind, [o.variable('someObj')]).toStmt()))\n-        .toEqual('fn.bind(someObj);');\n-  });\n-\n   it('should support literals', () => {\n     expect(emitStmt(o.literal(0).toStmt())).toEqual('0;');\n     expect(emitStmt(o.literal(true).toStmt())).toEqual('true;');\n@@ -360,7 +344,7 @@ describe('TypeScriptNodeEmitter', () => {\n     let callSomeMethod: o.Statement;\n \n     beforeEach(() => {\n-      callSomeMethod = o.THIS_EXPR.callMethod('someMethod', []).toStmt();\n+      callSomeMethod = o.THIS_EXPR.prop('someMethod').callFn([]).toStmt();\n     });\n \n "
        },
        {
            "sha": "2940ed7f3b1f3c95b524a1a71b41b486dcf4feab",
            "filename": "packages/compiler/src/compiler.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fcompiler.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -78,7 +78,7 @@ export * from './ml_parser/tags';\n export {LexerRange} from './ml_parser/lexer';\n export * from './ml_parser/xml_parser';\n export {NgModuleCompiler} from './ng_module_compiler';\n-export {ArrayType, AssertNotNull, DYNAMIC_TYPE, BinaryOperator, BinaryOperatorExpr, BuiltinMethod, BuiltinType, BuiltinTypeName, BuiltinVar, CastExpr, ClassField, ClassMethod, ClassStmt, CommaExpr, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionType, ExpressionVisitor, ExternalExpr, ExternalReference, literalMap, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, NONE_TYPE, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, StatementVisitor, TaggedTemplateExpr, TemplateLiteral, TemplateLiteralElement, ThrowStmt, TryCatchStmt, Type, TypeVisitor, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr, StmtModifier, Statement, STRING_TYPE, TypeofExpr, collectExternalReferences, jsDocComment, leadingComment, LeadingComment, JSDocComment, UnaryOperator, UnaryOperatorExpr, LocalizedString} from './output/output_ast';\n+export {ArrayType, AssertNotNull, DYNAMIC_TYPE, BinaryOperator, BinaryOperatorExpr, BuiltinMethod, BuiltinType, BuiltinTypeName, BuiltinVar, CastExpr, ClassField, ClassMethod, ClassStmt, CommaExpr, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionType, ExpressionVisitor, ExternalExpr, ExternalReference, literalMap, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, NONE_TYPE, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, StatementVisitor, TaggedTemplateExpr, TemplateLiteral, TemplateLiteralElement, ThrowStmt, TryCatchStmt, Type, TypeVisitor, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr, StmtModifier, Statement, STRING_TYPE, TypeofExpr, collectExternalReferences, jsDocComment, leadingComment, LeadingComment, JSDocComment, UnaryOperator, UnaryOperatorExpr, LocalizedString} from './output/output_ast';\n export {EmitterVisitorContext} from './output/abstract_emitter';\n export {JitEvaluator} from './output/output_jit';\n export * from './output/ts_emitter';"
        },
        {
            "sha": "7923ce4554d8c95979de0520abf1293e33b4a850",
            "filename": "packages/compiler/src/compiler_util/expression_converter.ts",
            "status": "modified",
            "additions": 39,
            "deletions": 83,
            "changes": 122,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Fcompiler_util%2Fexpression_converter.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Fcompiler_util%2Fexpression_converter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fcompiler_util%2Fexpression_converter.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -432,18 +432,6 @@ class _AstToIrVisitor implements cdAst.AstVisitor {\n         `Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);\n   }\n \n-  visitFunctionCall(ast: cdAst.FunctionCall, mode: _Mode): any {\n-    const convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n-    let fnResult: o.Expression;\n-    if (ast instanceof BuiltinFunctionCall) {\n-      fnResult = ast.converter(convertedArgs);\n-    } else {\n-      fnResult = this._visit(ast.target!, _Mode.Expression)\n-                     .callFn(convertedArgs, this.convertSourceSpan(ast.span));\n-    }\n-    return convertToStatementIfNeeded(mode, fnResult);\n-  }\n-\n   visitImplicitReceiver(ast: cdAst.ImplicitReceiver, mode: _Mode): any {\n     ensureExpressionMode(mode, ast);\n     this.usesImplicitReceiver = true;\n@@ -523,42 +511,6 @@ class _AstToIrVisitor implements cdAst.AstVisitor {\n     return this._localResolver.getLocal(name);\n   }\n \n-  visitMethodCall(ast: cdAst.MethodCall, mode: _Mode): any {\n-    if (ast.receiver instanceof cdAst.ImplicitReceiver &&\n-        !(ast.receiver instanceof cdAst.ThisReceiver) && ast.name === '$any') {\n-      const args = this.visitAll(ast.args, _Mode.Expression) as any[];\n-      if (args.length != 1) {\n-        throw new Error(\n-            `Invalid call to $any, expected 1 argument but received ${args.length || 'none'}`);\n-      }\n-      return (args[0] as o.Expression).cast(o.DYNAMIC_TYPE, this.convertSourceSpan(ast.span));\n-    }\n-\n-    const leftMostSafe = this.leftMostSafeNode(ast);\n-    if (leftMostSafe) {\n-      return this.convertSafeAccess(ast, leftMostSafe, mode);\n-    } else {\n-      const args = this.visitAll(ast.args, _Mode.Expression);\n-      const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n-      let result: any = null;\n-      const receiver = this._visit(ast.receiver, _Mode.Expression);\n-      if (receiver === this._implicitReceiver) {\n-        const varExpr = this._getLocal(ast.name, ast.receiver);\n-        if (varExpr) {\n-          // Restore the previous \"usesImplicitReceiver\" state since the implicit\n-          // receiver has been replaced with a resolved local expression.\n-          this.usesImplicitReceiver = prevUsesImplicitReceiver;\n-          result = varExpr.callFn(args);\n-          this.addImplicitReceiverAccess(ast.name);\n-        }\n-      }\n-      if (result == null) {\n-        result = receiver.callMethod(ast.name, args, this.convertSourceSpan(ast.span));\n-      }\n-      return convertToStatementIfNeeded(mode, result);\n-    }\n-  }\n-\n   visitPrefixNot(ast: cdAst.PrefixNot, mode: _Mode): any {\n     return convertToStatementIfNeeded(mode, o.not(this._visit(ast.expression, _Mode.Expression)));\n   }\n@@ -586,7 +538,7 @@ class _AstToIrVisitor implements cdAst.AstVisitor {\n         }\n       }\n       if (result == null) {\n-        result = receiver.prop(ast.name);\n+        result = receiver.prop(ast.name, this.convertSourceSpan(ast.span));\n       }\n       return convertToStatementIfNeeded(mode, result);\n     }\n@@ -621,7 +573,7 @@ class _AstToIrVisitor implements cdAst.AstVisitor {\n     // If no local expression could be produced, use the original receiver's\n     // property as the target.\n     if (varExpr === null) {\n-      varExpr = receiver.prop(ast.name);\n+      varExpr = receiver.prop(ast.name, this.convertSourceSpan(ast.span));\n     }\n     return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));\n   }\n@@ -630,10 +582,6 @@ class _AstToIrVisitor implements cdAst.AstVisitor {\n     return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n   }\n \n-  visitSafeMethodCall(ast: cdAst.SafeMethodCall, mode: _Mode): any {\n-    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n-  }\n-\n   visitSafeKeyedRead(ast: cdAst.SafeKeyedRead, mode: _Mode): any {\n     return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n   }\n@@ -647,15 +595,43 @@ class _AstToIrVisitor implements cdAst.AstVisitor {\n         Statement: ${ast.uninterpretedExpression} located at ${ast.location}`);\n   }\n \n+  visitCall(ast: cdAst.Call, mode: _Mode): any {\n+    const convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n+\n+    if (ast instanceof BuiltinFunctionCall) {\n+      return convertToStatementIfNeeded(mode, ast.converter(convertedArgs));\n+    }\n+\n+    const receiver = ast.receiver;\n+    if (receiver instanceof cdAst.PropertyRead &&\n+        receiver.receiver instanceof cdAst.ImplicitReceiver &&\n+        !(receiver.receiver instanceof cdAst.ThisReceiver) && receiver.name === '$any') {\n+      if (convertedArgs.length !== 1) {\n+        throw new Error(`Invalid call to $any, expected 1 argument but received ${\n+            convertedArgs.length || 'none'}`);\n+      }\n+      return (convertedArgs[0] as o.Expression)\n+          .cast(o.DYNAMIC_TYPE, this.convertSourceSpan(ast.span));\n+    }\n+\n+    const leftMostSafe = this.leftMostSafeNode(ast);\n+    if (leftMostSafe) {\n+      return this.convertSafeAccess(ast, leftMostSafe, mode);\n+    }\n+\n+    const call = this._visit(receiver, _Mode.Expression)\n+                     .callFn(convertedArgs, this.convertSourceSpan(ast.span));\n+    return convertToStatementIfNeeded(mode, call);\n+  }\n+\n   private _visit(ast: cdAst.AST, mode: _Mode): any {\n     const result = this._resultMap.get(ast);\n     if (result) return result;\n     return (this._nodeMap.get(ast) || ast).visit(this, mode);\n   }\n \n   private convertSafeAccess(\n-      ast: cdAst.AST, leftMostSafe: cdAst.SafeMethodCall|cdAst.SafePropertyRead|cdAst.SafeKeyedRead,\n-      mode: _Mode): any {\n+      ast: cdAst.AST, leftMostSafe: cdAst.SafePropertyRead|cdAst.SafeKeyedRead, mode: _Mode): any {\n     // If the expression contains a safe access node on the left it needs to be converted to\n     // an expression that guards the access to the member by checking the receiver for blank. As\n     // execution proceeds from left to right, the left most part of the expression must be guarded\n@@ -712,14 +688,7 @@ class _AstToIrVisitor implements cdAst.AstVisitor {\n \n     // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n     // leftMostNode with its unguarded version in the call to `this.visit()`.\n-    if (leftMostSafe instanceof cdAst.SafeMethodCall) {\n-      this._nodeMap.set(\n-          leftMostSafe,\n-          new cdAst.MethodCall(\n-              leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan,\n-              leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args,\n-              leftMostSafe.argumentSpan));\n-    } else if (leftMostSafe instanceof cdAst.SafeKeyedRead) {\n+    if (leftMostSafe instanceof cdAst.SafeKeyedRead) {\n       this._nodeMap.set(\n           leftMostSafe,\n           new cdAst.KeyedRead(\n@@ -773,8 +742,7 @@ class _AstToIrVisitor implements cdAst.AstVisitor {\n   //   a == null ? null : a.c.b.c?.d.e\n   // then to:\n   //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n-  private leftMostSafeNode(ast: cdAst.AST): cdAst.SafePropertyRead|cdAst.SafeMethodCall\n-      |cdAst.SafeKeyedRead {\n+  private leftMostSafeNode(ast: cdAst.AST): cdAst.SafePropertyRead|cdAst.SafeKeyedRead {\n     const visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): any => {\n       return (this._nodeMap.get(ast) || ast).visit(visitor);\n     };\n@@ -791,8 +759,8 @@ class _AstToIrVisitor implements cdAst.AstVisitor {\n       visitConditional(ast: cdAst.Conditional) {\n         return null;\n       },\n-      visitFunctionCall(ast: cdAst.FunctionCall) {\n-        return null;\n+      visitCall(ast: cdAst.Call) {\n+        return visit(this, ast.receiver);\n       },\n       visitImplicitReceiver(ast: cdAst.ImplicitReceiver) {\n         return null;\n@@ -818,9 +786,6 @@ class _AstToIrVisitor implements cdAst.AstVisitor {\n       visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) {\n         return null;\n       },\n-      visitMethodCall(ast: cdAst.MethodCall) {\n-        return visit(this, ast.receiver);\n-      },\n       visitPipe(ast: cdAst.BindingPipe) {\n         return null;\n       },\n@@ -839,9 +804,6 @@ class _AstToIrVisitor implements cdAst.AstVisitor {\n       visitQuote(ast: cdAst.Quote) {\n         return null;\n       },\n-      visitSafeMethodCall(ast: cdAst.SafeMethodCall) {\n-        return visit(this, ast.receiver) || ast;\n-      },\n       visitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n         return visit(this, ast.receiver) || ast;\n       },\n@@ -874,7 +836,7 @@ class _AstToIrVisitor implements cdAst.AstVisitor {\n       visitConditional(ast: cdAst.Conditional): boolean {\n         return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);\n       },\n-      visitFunctionCall(ast: cdAst.FunctionCall) {\n+      visitCall(ast: cdAst.Call) {\n         return true;\n       },\n       visitImplicitReceiver(ast: cdAst.ImplicitReceiver) {\n@@ -901,9 +863,6 @@ class _AstToIrVisitor implements cdAst.AstVisitor {\n       visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) {\n         return false;\n       },\n-      visitMethodCall(ast: cdAst.MethodCall) {\n-        return true;\n-      },\n       visitPipe(ast: cdAst.BindingPipe) {\n         return true;\n       },\n@@ -922,9 +881,6 @@ class _AstToIrVisitor implements cdAst.AstVisitor {\n       visitQuote(ast: cdAst.Quote) {\n         return false;\n       },\n-      visitSafeMethodCall(ast: cdAst.SafeMethodCall) {\n-        return true;\n-      },\n       visitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n         return false;\n       },\n@@ -1014,10 +970,10 @@ function convertStmtIntoExpression(stmt: o.Statement): o.Expression|null {\n   return null;\n }\n \n-export class BuiltinFunctionCall extends cdAst.FunctionCall {\n+export class BuiltinFunctionCall extends cdAst.Call {\n   constructor(\n       span: cdAst.ParseSpan, sourceSpan: cdAst.AbsoluteSourceSpan, args: cdAst.AST[],\n       public converter: BuiltinConverter) {\n-    super(span, sourceSpan, null, args);\n+    super(span, sourceSpan, new cdAst.EmptyExpr(span, sourceSpan), args, null!);\n   }\n }"
        },
        {
            "sha": "f67c5a828c4b7822b27afbcfa7208d871eb0d5f1",
            "filename": "packages/compiler/src/constant_pool.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Fconstant_pool.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Fconstant_pool.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fconstant_pool.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -324,7 +324,6 @@ class KeyVisitor implements o.ExpressionVisitor {\n   visitWriteVarExpr = invalid;\n   visitWriteKeyExpr = invalid;\n   visitWritePropExpr = invalid;\n-  visitInvokeMethodExpr = invalid;\n   visitInvokeFunctionExpr = invalid;\n   visitTaggedTemplateExpr = invalid;\n   visitInstantiateExpr = invalid;"
        },
        {
            "sha": "65036afcb0a956863ab8ad84619a99ec024fbdbf",
            "filename": "packages/compiler/src/expression_parser/ast.ts",
            "status": "modified",
            "additions": 24,
            "deletions": 90,
            "changes": 114,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fast.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fast.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fast.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -316,38 +316,14 @@ export class NonNullAssert extends AST {\n   }\n }\n \n-export class MethodCall extends ASTWithName {\n+export class Call extends AST {\n   constructor(\n-      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, nameSpan: AbsoluteSourceSpan,\n-      public receiver: AST, public name: string, public args: any[],\n+      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public args: any[],\n       public argumentSpan: AbsoluteSourceSpan) {\n-    super(span, sourceSpan, nameSpan);\n-  }\n-  override visit(visitor: AstVisitor, context: any = null): any {\n-    return visitor.visitMethodCall(this, context);\n-  }\n-}\n-\n-export class SafeMethodCall extends ASTWithName {\n-  constructor(\n-      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, nameSpan: AbsoluteSourceSpan,\n-      public receiver: AST, public name: string, public args: any[],\n-      public argumentSpan: AbsoluteSourceSpan) {\n-    super(span, sourceSpan, nameSpan);\n-  }\n-  override visit(visitor: AstVisitor, context: any = null): any {\n-    return visitor.visitSafeMethodCall(this, context);\n-  }\n-}\n-\n-export class FunctionCall extends AST {\n-  constructor(\n-      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public target: AST|null,\n-      public args: any[]) {\n     super(span, sourceSpan);\n   }\n   override visit(visitor: AstVisitor, context: any = null): any {\n-    return visitor.visitFunctionCall(this, context);\n+    return visitor.visitCall(this, context);\n   }\n }\n \n@@ -442,7 +418,6 @@ export interface AstVisitor {\n   visitBinary(ast: Binary, context: any): any;\n   visitChain(ast: Chain, context: any): any;\n   visitConditional(ast: Conditional, context: any): any;\n-  visitFunctionCall(ast: FunctionCall, context: any): any;\n   /**\n    * The `visitThisReceiver` method is declared as optional for backwards compatibility.\n    * In an upcoming major release, this method will be made required.\n@@ -455,16 +430,15 @@ export interface AstVisitor {\n   visitLiteralArray(ast: LiteralArray, context: any): any;\n   visitLiteralMap(ast: LiteralMap, context: any): any;\n   visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;\n-  visitMethodCall(ast: MethodCall, context: any): any;\n   visitPipe(ast: BindingPipe, context: any): any;\n   visitPrefixNot(ast: PrefixNot, context: any): any;\n   visitNonNullAssert(ast: NonNullAssert, context: any): any;\n   visitPropertyRead(ast: PropertyRead, context: any): any;\n   visitPropertyWrite(ast: PropertyWrite, context: any): any;\n   visitQuote(ast: Quote, context: any): any;\n-  visitSafeMethodCall(ast: SafeMethodCall, context: any): any;\n   visitSafePropertyRead(ast: SafePropertyRead, context: any): any;\n   visitSafeKeyedRead(ast: SafeKeyedRead, context: any): any;\n+  visitCall(ast: Call, context: any): any;\n   visitASTWithSource?(ast: ASTWithSource, context: any): any;\n   /**\n    * This function is optionally defined to allow classes that implement this\n@@ -501,12 +475,6 @@ export class RecursiveAstVisitor implements AstVisitor {\n     this.visit(ast.exp, context);\n     this.visitAll(ast.args, context);\n   }\n-  visitFunctionCall(ast: FunctionCall, context: any): any {\n-    if (ast.target) {\n-      this.visit(ast.target, context);\n-    }\n-    this.visitAll(ast.args, context);\n-  }\n   visitImplicitReceiver(ast: ThisReceiver, context: any): any {}\n   visitThisReceiver(ast: ThisReceiver, context: any): any {}\n   visitInterpolation(ast: Interpolation, context: any): any {\n@@ -528,10 +496,6 @@ export class RecursiveAstVisitor implements AstVisitor {\n     this.visitAll(ast.values, context);\n   }\n   visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any {}\n-  visitMethodCall(ast: MethodCall, context: any): any {\n-    this.visit(ast.receiver, context);\n-    this.visitAll(ast.args, context);\n-  }\n   visitPrefixNot(ast: PrefixNot, context: any): any {\n     this.visit(ast.expression, context);\n   }\n@@ -548,14 +512,14 @@ export class RecursiveAstVisitor implements AstVisitor {\n   visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n     this.visit(ast.receiver, context);\n   }\n-  visitSafeMethodCall(ast: SafeMethodCall, context: any): any {\n-    this.visit(ast.receiver, context);\n-    this.visitAll(ast.args, context);\n-  }\n   visitSafeKeyedRead(ast: SafeKeyedRead, context: any): any {\n     this.visit(ast.receiver, context);\n     this.visit(ast.key, context);\n   }\n+  visitCall(ast: Call, context: any): any {\n+    this.visit(ast.receiver, context);\n+    this.visitAll(ast.args, context);\n+  }\n   visitQuote(ast: Quote, context: any): any {}\n   // This is not part of the AstVisitor interface, just a helper method\n   visitAll(asts: AST[], context: any): any {\n@@ -598,23 +562,6 @@ export class AstTransformer implements AstVisitor {\n         ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n   }\n \n-  visitMethodCall(ast: MethodCall, context: any): AST {\n-    return new MethodCall(\n-        ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name,\n-        this.visitAll(ast.args), ast.argumentSpan);\n-  }\n-\n-  visitSafeMethodCall(ast: SafeMethodCall, context: any): AST {\n-    return new SafeMethodCall(\n-        ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name,\n-        this.visitAll(ast.args), ast.argumentSpan);\n-  }\n-\n-  visitFunctionCall(ast: FunctionCall, context: any): AST {\n-    return new FunctionCall(\n-        ast.span, ast.sourceSpan, ast.target!.visit(this), this.visitAll(ast.args));\n-  }\n-\n   visitLiteralArray(ast: LiteralArray, context: any): AST {\n     return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n   }\n@@ -669,6 +616,12 @@ export class AstTransformer implements AstVisitor {\n         ast.value.visit(this));\n   }\n \n+  visitCall(ast: Call, context: any): AST {\n+    return new Call(\n+        ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args),\n+        ast.argumentSpan);\n+  }\n+\n   visitAll(asts: any[]): any[] {\n     const res = [];\n     for (let i = 0; i < asts.length; ++i) {\n@@ -739,35 +692,6 @@ export class AstMemoryEfficientTransformer implements AstVisitor {\n     return ast;\n   }\n \n-  visitMethodCall(ast: MethodCall, context: any): AST {\n-    const receiver = ast.receiver.visit(this);\n-    const args = this.visitAll(ast.args);\n-    if (receiver !== ast.receiver || args !== ast.args) {\n-      return new MethodCall(\n-          ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args, ast.argumentSpan);\n-    }\n-    return ast;\n-  }\n-\n-  visitSafeMethodCall(ast: SafeMethodCall, context: any): AST {\n-    const receiver = ast.receiver.visit(this);\n-    const args = this.visitAll(ast.args);\n-    if (receiver !== ast.receiver || args !== ast.args) {\n-      return new SafeMethodCall(\n-          ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args, ast.argumentSpan);\n-    }\n-    return ast;\n-  }\n-\n-  visitFunctionCall(ast: FunctionCall, context: any): AST {\n-    const target = ast.target && ast.target.visit(this);\n-    const args = this.visitAll(ast.args);\n-    if (target !== ast.target || args !== ast.args) {\n-      return new FunctionCall(ast.span, ast.sourceSpan, target, args);\n-    }\n-    return ast;\n-  }\n-\n   visitLiteralArray(ast: LiteralArray, context: any): AST {\n     const expressions = this.visitAll(ast.expressions);\n     if (expressions !== ast.expressions) {\n@@ -882,6 +806,16 @@ export class AstMemoryEfficientTransformer implements AstVisitor {\n     return ast;\n   }\n \n+\n+  visitCall(ast: Call, context: any): AST {\n+    const receiver = ast.receiver.visit(this);\n+    const args = this.visitAll(ast.args);\n+    if (receiver !== ast.receiver || args !== ast.args) {\n+      return new Call(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);\n+    }\n+    return ast;\n+  }\n+\n   visitQuote(ast: Quote, context: any): AST {\n     return ast;\n   }"
        },
        {
            "sha": "008cd03be09b31290d6ba05948f8dddbb888de40",
            "filename": "packages/compiler/src/expression_parser/parser.ts",
            "status": "modified",
            "additions": 39,
            "deletions": 41,
            "changes": 80,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -9,7 +9,7 @@\n import * as chars from '../chars';\n import {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../ml_parser/interpolation_config';\n \n-import {AbsoluteSourceSpan, AST, AstVisitor, ASTWithSource, Binary, BindingPipe, Chain, Conditional, EmptyExpr, ExpressionBinding, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralMapKey, LiteralPrimitive, MethodCall, NonNullAssert, ParserError, ParseSpan, PrefixNot, PropertyRead, PropertyWrite, Quote, RecursiveAstVisitor, SafeKeyedRead, SafeMethodCall, SafePropertyRead, TemplateBinding, TemplateBindingIdentifier, ThisReceiver, Unary, VariableBinding} from './ast';\n+import {AbsoluteSourceSpan, AST, AstVisitor, ASTWithSource, Binary, BindingPipe, Call, Chain, Conditional, EmptyExpr, ExpressionBinding, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralMapKey, LiteralPrimitive, NonNullAssert, ParserError, ParseSpan, PrefixNot, PropertyRead, PropertyWrite, Quote, RecursiveAstVisitor, SafeKeyedRead, SafePropertyRead, TemplateBinding, TemplateBindingIdentifier, ThisReceiver, Unary, VariableBinding} from './ast';\n import {EOF, isIdentifier, Lexer, Token, TokenType} from './lexer';\n \n export interface InterpolationPiece {\n@@ -819,21 +819,23 @@ export class _ParseAST {\n     let result = this.parsePrimary();\n     while (true) {\n       if (this.consumeOptionalCharacter(chars.$PERIOD)) {\n-        result = this.parseAccessMemberOrMethodCall(result, start, false);\n+        result = this.parseAccessMemberOrCall(result, start, false);\n \n       } else if (this.consumeOptionalOperator('?.')) {\n         result = this.consumeOptionalCharacter(chars.$LBRACKET) ?\n             this.parseKeyedReadOrWrite(result, start, true) :\n-            this.parseAccessMemberOrMethodCall(result, start, true);\n+            this.parseAccessMemberOrCall(result, start, true);\n       } else if (this.consumeOptionalCharacter(chars.$LBRACKET)) {\n         result = this.parseKeyedReadOrWrite(result, start, false);\n       } else if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n+        const argumentStart = this.inputIndex;\n         this.rparensExpected++;\n         const args = this.parseCallArguments();\n+        const argumentSpan =\n+            this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);\n         this.rparensExpected--;\n         this.expectCharacter(chars.$RPAREN);\n-        result = new FunctionCall(this.span(start), this.sourceSpan(start), result, args);\n-\n+        result = new Call(this.span(start), this.sourceSpan(start), result, args, argumentSpan);\n       } else if (this.consumeOptionalOperator('!')) {\n         result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);\n \n@@ -882,7 +884,7 @@ export class _ParseAST {\n       return this.parseLiteralMap();\n \n     } else if (this.next.isIdentifier()) {\n-      return this.parseAccessMemberOrMethodCall(\n+      return this.parseAccessMemberOrCall(\n           new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);\n \n     } else if (this.next.isNumber()) {\n@@ -953,56 +955,56 @@ export class _ParseAST {\n     return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);\n   }\n \n-  parseAccessMemberOrMethodCall(receiver: AST, start: number, isSafe: boolean): AST {\n+  parseAccessMemberOrCall(readReceiver: AST, start: number, isSafe: boolean): AST {\n     const nameStart = this.inputIndex;\n     const id = this.withContext(ParseContextFlags.Writable, () => {\n       const id = this.expectIdentifierOrKeyword() ?? '';\n       if (id.length === 0) {\n-        this.error(`Expected identifier for property access`, receiver.span.end);\n+        this.error(`Expected identifier for property access`, readReceiver.span.end);\n       }\n       return id;\n     });\n     const nameSpan = this.sourceSpan(nameStart);\n+    let receiver: AST;\n+\n+    if (isSafe) {\n+      if (this.consumeOptionalOperator('=')) {\n+        this.error('The \\'?.\\' operator cannot be used in the assignment');\n+        receiver = new EmptyExpr(this.span(start), this.sourceSpan(start));\n+      } else {\n+        receiver = new SafePropertyRead(\n+            this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n+      }\n+    } else {\n+      if (this.consumeOptionalOperator('=')) {\n+        if (!this.parseAction) {\n+          this.error('Bindings cannot contain assignments');\n+          return new EmptyExpr(this.span(start), this.sourceSpan(start));\n+        }\n+\n+        const value = this.parseConditional();\n+        receiver = new PropertyWrite(\n+            this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id, value);\n+      } else {\n+        receiver =\n+            new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n+      }\n+    }\n \n     if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n       const argumentStart = this.inputIndex;\n       this.rparensExpected++;\n       const args = this.parseCallArguments();\n       const argumentSpan =\n           this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);\n-\n       this.expectCharacter(chars.$RPAREN);\n       this.rparensExpected--;\n       const span = this.span(start);\n       const sourceSpan = this.sourceSpan(start);\n-      return isSafe ?\n-          new SafeMethodCall(span, sourceSpan, nameSpan, receiver, id, args, argumentSpan) :\n-          new MethodCall(span, sourceSpan, nameSpan, receiver, id, args, argumentSpan);\n-\n-    } else {\n-      if (isSafe) {\n-        if (this.consumeOptionalOperator('=')) {\n-          this.error('The \\'?.\\' operator cannot be used in the assignment');\n-          return new EmptyExpr(this.span(start), this.sourceSpan(start));\n-        } else {\n-          return new SafePropertyRead(\n-              this.span(start), this.sourceSpan(start), nameSpan, receiver, id);\n-        }\n-      } else {\n-        if (this.consumeOptionalOperator('=')) {\n-          if (!this.parseAction) {\n-            this.error('Bindings cannot contain assignments');\n-            return new EmptyExpr(this.span(start), this.sourceSpan(start));\n-          }\n-\n-          const value = this.parseConditional();\n-          return new PropertyWrite(\n-              this.span(start), this.sourceSpan(start), nameSpan, receiver, id, value);\n-        } else {\n-          return new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, receiver, id);\n-        }\n-      }\n+      return new Call(span, sourceSpan, receiver, args, argumentSpan);\n     }\n+\n+    return receiver;\n   }\n \n   parseCallArguments(): BindingPipe[] {\n@@ -1318,11 +1320,7 @@ class SimpleExpressionChecker implements AstVisitor {\n \n   visitSafePropertyRead(ast: SafePropertyRead, context: any) {}\n \n-  visitMethodCall(ast: MethodCall, context: any) {}\n-\n-  visitSafeMethodCall(ast: SafeMethodCall, context: any) {}\n-\n-  visitFunctionCall(ast: FunctionCall, context: any) {}\n+  visitCall(ast: Call, context: any) {}\n \n   visitLiteralArray(ast: LiteralArray, context: any) {\n     this.visitAll(ast.expressions, context);"
        },
        {
            "sha": "d7826b59c38b4dcb8d6f1aa3afd2b2b8b76ac911",
            "filename": "packages/compiler/src/injectable_compiler_2.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Finjectable_compiler_2.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Finjectable_compiler_2.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Finjectable_compiler_2.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -204,5 +204,5 @@ function delegateToFactory(\n function createFactoryFunction(type: o.Expression): o.FunctionExpr {\n   return o.fn(\n       [new o.FnParam('t', o.DYNAMIC_TYPE)],\n-      [new o.ReturnStatement(type.callMethod('fac', [o.variable('t')]))]);\n+      [new o.ReturnStatement(type.prop('fac').callFn([o.variable('t')]))]);\n }"
        },
        {
            "sha": "73881ad25f547cbe429cfa484712479a6b058459",
            "filename": "packages/compiler/src/output/abstract_emitter.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 15,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Foutput%2Fabstract_emitter.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Foutput%2Fabstract_emitter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Foutput%2Fabstract_emitter.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -319,21 +319,6 @@ export abstract class AbstractEmitterVisitor implements o.StatementVisitor, o.Ex\n     }\n     return null;\n   }\n-  visitInvokeMethodExpr(expr: o.InvokeMethodExpr, ctx: EmitterVisitorContext): any {\n-    expr.receiver.visitExpression(this, ctx);\n-    let name = expr.name;\n-    if (expr.builtin != null) {\n-      name = this.getBuiltinMethodName(expr.builtin);\n-      if (name == null) {\n-        // some builtins just mean to skip the call.\n-        return null;\n-      }\n-    }\n-    ctx.print(expr, `.${name}(`);\n-    this.visitAllExpressions(expr.args, ctx, `,`);\n-    ctx.print(expr, `)`);\n-    return null;\n-  }\n \n   abstract getBuiltinMethodName(method: o.BuiltinMethod): string;\n "
        },
        {
            "sha": "de3965f3b38aa9818f0369a84cd0ec721ec9fb5f",
            "filename": "packages/compiler/src/output/output_ast.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 51,
            "changes": 51,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_ast.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_ast.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_ast.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -176,11 +176,6 @@ export abstract class Expression {\n     return new ReadKeyExpr(this, index, type, sourceSpan);\n   }\n \n-  callMethod(name: string|BuiltinMethod, params: Expression[], sourceSpan?: ParseSourceSpan|null):\n-      InvokeMethodExpr {\n-    return new InvokeMethodExpr(this, name, params, null, sourceSpan);\n-  }\n-\n   callFn(params: Expression[], sourceSpan?: ParseSourceSpan|null, pure?: boolean):\n       InvokeFunctionExpr {\n     return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);\n@@ -424,37 +419,6 @@ export enum BuiltinMethod {\n   Bind\n }\n \n-export class InvokeMethodExpr extends Expression {\n-  public name: string|null;\n-  public builtin: BuiltinMethod|null;\n-  constructor(\n-      public receiver: Expression, method: string|BuiltinMethod, public args: Expression[],\n-      type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n-    super(type, sourceSpan);\n-    if (typeof method === 'string') {\n-      this.name = method;\n-      this.builtin = null;\n-    } else {\n-      this.name = null;\n-      this.builtin = <BuiltinMethod>method;\n-    }\n-  }\n-\n-  override isEquivalent(e: Expression): boolean {\n-    return e instanceof InvokeMethodExpr && this.receiver.isEquivalent(e.receiver) &&\n-        this.name === e.name && this.builtin === e.builtin && areAllEquivalent(this.args, e.args);\n-  }\n-\n-  override isConstant() {\n-    return false;\n-  }\n-\n-  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n-    return visitor.visitInvokeMethodExpr(this, context);\n-  }\n-}\n-\n-\n export class InvokeFunctionExpr extends Expression {\n   constructor(\n       public fn: Expression, public args: Expression[], type?: Type|null,\n@@ -1001,7 +965,6 @@ export interface ExpressionVisitor {\n   visitWriteVarExpr(expr: WriteVarExpr, context: any): any;\n   visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any;\n   visitWritePropExpr(expr: WritePropExpr, context: any): any;\n-  visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any;\n   visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;\n   visitTaggedTemplateExpr(ast: TaggedTemplateExpr, context: any): any;\n   visitInstantiateExpr(ast: InstantiateExpr, context: any): any;\n@@ -1309,15 +1272,6 @@ export class AstTransformer implements StatementVisitor, ExpressionVisitor {\n         context);\n   }\n \n-  visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any {\n-    const method = ast.builtin || ast.name;\n-    return this.transformExpr(\n-        new InvokeMethodExpr(\n-            ast.receiver.visitExpression(this, context), method!,\n-            this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan),\n-        context);\n-  }\n-\n   visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any {\n     return this.transformExpr(\n         new InvokeFunctionExpr(\n@@ -1576,11 +1530,6 @@ export class RecursiveAstVisitor implements StatementVisitor, ExpressionVisitor\n     ast.value.visitExpression(this, context);\n     return this.visitExpression(ast, context);\n   }\n-  visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any {\n-    ast.receiver.visitExpression(this, context);\n-    this.visitAllExpressions(ast.args, context);\n-    return this.visitExpression(ast, context);\n-  }\n   visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any {\n     ast.fn.visitExpression(this, context);\n     this.visitAllExpressions(ast.args, context);"
        },
        {
            "sha": "d8fc45c5415a5864f1b6b09662b64df9ceecf507",
            "filename": "packages/compiler/src/output/output_interpreter.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 26,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_interpreter.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_interpreter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_interpreter.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -163,38 +163,19 @@ class StatementInterpreter implements o.StatementVisitor, o.ExpressionVisitor {\n     return value;\n   }\n \n-  visitInvokeMethodExpr(expr: o.InvokeMethodExpr, ctx: _ExecutionContext): any {\n-    const receiver = expr.receiver.visitExpression(this, ctx);\n-    const args = this.visitAllExpressions(expr.args, ctx);\n-    let result: any;\n-    if (expr.builtin != null) {\n-      switch (expr.builtin) {\n-        case o.BuiltinMethod.ConcatArray:\n-          result = receiver.concat(...args);\n-          break;\n-        case o.BuiltinMethod.SubscribeObservable:\n-          result = receiver.subscribe({next: args[0]});\n-          break;\n-        case o.BuiltinMethod.Bind:\n-          result = receiver.bind(...args);\n-          break;\n-        default:\n-          throw new Error(`Unknown builtin method ${expr.builtin}`);\n-      }\n-    } else {\n-      result = receiver[expr.name!].apply(receiver, args);\n-    }\n-    return result;\n-  }\n   visitInvokeFunctionExpr(stmt: o.InvokeFunctionExpr, ctx: _ExecutionContext): any {\n     const args = this.visitAllExpressions(stmt.args, ctx);\n-    const fnExpr = stmt.fn;\n+    const fnExpr = stmt.fn as (o.Expression & {receiver: o.Expression | undefined});\n     if (fnExpr instanceof o.ReadVarExpr && fnExpr.builtin === o.BuiltinVar.Super) {\n       ctx.instance!.constructor.prototype.constructor.apply(ctx.instance, args);\n       return null;\n     } else {\n-      const fn = stmt.fn.visitExpression(this, ctx);\n-      return fn.apply(null, args);\n+      const fn = fnExpr.visitExpression(this, ctx);\n+      let context: any = null;\n+      if (fnExpr.receiver) {\n+        context = fnExpr.receiver.visitExpression(this, ctx);\n+      }\n+      return fn.apply(context, args);\n     }\n   }\n   visitTaggedTemplateExpr(expr: o.TaggedTemplateExpr, ctx: _ExecutionContext): any {"
        },
        {
            "sha": "6e38d9c251b484ca38568e8b8cac220cea9ce395",
            "filename": "packages/compiler/src/render3/view/compiler.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fcompiler.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -284,7 +284,7 @@ function compileDeclarationList(\n       return o.fn([], [new o.ReturnStatement(list)]);\n     case DeclarationListEmitMode.ClosureResolved:\n       // directives: function () { return [MyDir].map(ng.resolveForwardRef); }\n-      const resolvedList = list.callMethod('map', [o.importExpr(R3.resolveForwardRef)]);\n+      const resolvedList = list.prop('map').callFn([o.importExpr(R3.resolveForwardRef)]);\n       return o.fn([], [new o.ReturnStatement(resolvedList)]);\n   }\n }"
        },
        {
            "sha": "c6055edbf2175c35bdf641d4698a564363ce5d0d",
            "filename": "packages/compiler/src/render3/view/t2_binder.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 14,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ft2_binder.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ft2_binder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ft2_binder.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, BindingPipe, ImplicitReceiver, MethodCall, PropertyRead, PropertyWrite, RecursiveAstVisitor, SafeMethodCall, SafePropertyRead} from '../../expression_parser/ast';\n+import {AST, BindingPipe, ImplicitReceiver, PropertyRead, PropertyWrite, RecursiveAstVisitor, SafePropertyRead} from '../../expression_parser/ast';\n import {SelectorMatcher} from '../../selector';\n import {BoundAttribute, BoundEvent, BoundText, Content, Element, Icu, Node, Reference, Template, Text, TextAttribute, Variable, Visitor} from '../r3_ast';\n \n@@ -484,19 +484,8 @@ class TemplateBinder extends RecursiveAstVisitor implements Visitor {\n     return super.visitPropertyWrite(ast, context);\n   }\n \n-  override visitMethodCall(ast: MethodCall, context: any): any {\n-    this.maybeMap(context, ast, ast.name);\n-    return super.visitMethodCall(ast, context);\n-  }\n-\n-  override visitSafeMethodCall(ast: SafeMethodCall, context: any): any {\n-    this.maybeMap(context, ast, ast.name);\n-    return super.visitSafeMethodCall(ast, context);\n-  }\n-\n-  private maybeMap(\n-      scope: Scope, ast: PropertyRead|SafePropertyRead|PropertyWrite|MethodCall|SafeMethodCall,\n-      name: string): void {\n+  private maybeMap(scope: Scope, ast: PropertyRead|SafePropertyRead|PropertyWrite, name: string):\n+      void {\n     // If the receiver of the expression isn't the `ImplicitReceiver`, this isn't the root of an\n     // `AST` expression that maps to a `Variable` or `Reference`.\n     if (!(ast.receiver instanceof ImplicitReceiver)) {"
        },
        {
            "sha": "286a0e8aa69e2c6c3172af399a8c725d422286ee",
            "filename": "packages/compiler/src/render3/view/template.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 8,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -10,7 +10,7 @@ import {flatten} from '../../compile_metadata';\n import {BindingForm, BuiltinFunctionCall, convertActionBinding, convertPropertyBinding, convertUpdateArguments, LocalResolver} from '../../compiler_util/expression_converter';\n import {ConstantPool} from '../../constant_pool';\n import * as core from '../../core';\n-import {AST, AstMemoryEfficientTransformer, BindingPipe, BindingType, FunctionCall, ImplicitReceiver, Interpolation, LiteralArray, LiteralMap, LiteralPrimitive, ParsedEventType, PropertyRead, ThisReceiver} from '../../expression_parser/ast';\n+import {AST, AstMemoryEfficientTransformer, BindingPipe, BindingType, Call, ImplicitReceiver, Interpolation, LiteralArray, LiteralMap, LiteralPrimitive, ParsedEventType, PropertyRead} from '../../expression_parser/ast';\n import {Lexer} from '../../expression_parser/lexer';\n import {IvyParser} from '../../expression_parser/parser';\n import * as i18n from '../../i18n/i18n_ast';\n@@ -1484,7 +1484,7 @@ export class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver\n }\n \n export class ValueConverter extends AstMemoryEfficientTransformer {\n-  private _pipeBindExprs: FunctionCall[] = [];\n+  private _pipeBindExprs: Call[] = [];\n \n   constructor(\n       private constantPool: ConstantPool, private allocateSlot: () => number,\n@@ -1511,17 +1511,20 @@ export class ValueConverter extends AstMemoryEfficientTransformer {\n         this.visitAll([new LiteralArray(pipe.span, pipe.sourceSpan, args)]) :\n         this.visitAll(args);\n \n-    const pipeBindExpr = new FunctionCall(pipe.span, pipe.sourceSpan, target, [\n-      new LiteralPrimitive(pipe.span, pipe.sourceSpan, slot),\n-      new LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot),\n-      ...convertedArgs,\n-    ]);\n+    const pipeBindExpr = new Call(\n+        pipe.span, pipe.sourceSpan, target,\n+        [\n+          new LiteralPrimitive(pipe.span, pipe.sourceSpan, slot),\n+          new LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot),\n+          ...convertedArgs,\n+        ],\n+        null!);\n     this._pipeBindExprs.push(pipeBindExpr);\n     return pipeBindExpr;\n   }\n \n   updatePipeSlotOffsets(bindingSlots: number) {\n-    this._pipeBindExprs.forEach((pipe: FunctionCall) => {\n+    this._pipeBindExprs.forEach((pipe: Call) => {\n       // update the slot offset arg (index 1) to account for binding slots\n       const slotOffset = pipe.args[1] as LiteralPrimitive;\n       (slotOffset.value as number) += bindingSlots;"
        },
        {
            "sha": "216458afe2f0e57be10aa8a6fbb91609e6dea09c",
            "filename": "packages/compiler/src/view_compiler/type_check_compiler.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Fview_compiler%2Ftype_check_compiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Fview_compiler%2Ftype_check_compiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fview_compiler%2Ftype_check_compiler.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -354,7 +354,7 @@ class ViewBuilder implements TemplateAstVisitor, LocalResolver {\n               const pipeExpr = this.options.fullTemplateTypeCheck ?\n                   o.variable(this.pipeOutputVar(name)) :\n                   o.variable(this.getOutputVar(o.BuiltinTypeName.Dynamic));\n-              return pipeExpr.callMethod('transform', args);\n+              return pipeExpr.prop('transform').callFn(args);\n             },\n           },\n           expression.value)"
        },
        {
            "sha": "ad774e125f2a3bf20bf3d379e272ccfae9063f66",
            "filename": "packages/compiler/src/view_compiler/view_compiler.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Fview_compiler%2Fview_compiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Fsrc%2Fview_compiler%2Fview_compiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fview_compiler%2Fview_compiler.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -766,7 +766,7 @@ class ViewBuilder implements TemplateAstVisitor, LocalResolver {\n \n       return (args: o.Expression[]) => callUnwrapValue(\n                  expression.nodeIndex, expression.bindingIndex,\n-                 nodeValueExpr.callMethod('transform', args));\n+                 nodeValueExpr.prop('transform').callFn(args));\n     }\n   }\n "
        },
        {
            "sha": "b023844874770d8980a4eb2ad3d8f8acecaada55",
            "filename": "packages/compiler/test/expression_parser/ast_spec.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 8,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fast_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fast_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fast_spec.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -7,7 +7,7 @@\n  */\n \n import {AST, Lexer, Parser, RecursiveAstVisitor} from '@angular/compiler';\n-import {ImplicitReceiver, MethodCall, PropertyRead} from '@angular/compiler/src/compiler';\n+import {Call, ImplicitReceiver, PropertyRead} from '@angular/compiler/src/compiler';\n \n describe('RecursiveAstVisitor', () => {\n   it('should visit every node', () => {\n@@ -18,14 +18,15 @@ describe('RecursiveAstVisitor', () => {\n     visitor.visit(ast.ast, path);\n     // If the visitor method of RecursiveAstVisitor is implemented correctly,\n     // then we should have collected the full path from root to leaf.\n-    expect(path.length).toBe(3);\n-    const [methodCall, propertyRead, implicitReceiver] = path;\n-    expectType(methodCall, MethodCall);\n-    expectType(propertyRead, PropertyRead);\n+    expect(path.length).toBe(4);\n+    const [call, yRead, xRead, implicitReceiver] = path;\n+    expectType(call, Call);\n+    expectType(yRead, PropertyRead);\n+    expectType(xRead, PropertyRead);\n     expectType(implicitReceiver, ImplicitReceiver);\n-    expect(methodCall.name).toBe('y');\n-    expect(methodCall.args).toEqual([]);\n-    expect(propertyRead.name).toBe('x');\n+    expect(xRead.name).toBe('x');\n+    expect(yRead.name).toBe('y');\n+    expect(call.args).toEqual([]);\n   });\n });\n "
        },
        {
            "sha": "4b8419d05950812593354bc9b2144aebfa575e9c",
            "filename": "packages/compiler/test/expression_parser/parser_spec.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 24,
            "changes": 38,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AbsoluteSourceSpan, ASTWithSource, BindingPipe, EmptyExpr, Interpolation, MethodCall, ParserError, TemplateBinding, VariableBinding} from '@angular/compiler/src/expression_parser/ast';\n+import {AbsoluteSourceSpan, ASTWithSource, BindingPipe, Call, EmptyExpr, Interpolation, ParserError, TemplateBinding, VariableBinding} from '@angular/compiler/src/expression_parser/ast';\n import {Lexer} from '@angular/compiler/src/expression_parser/lexer';\n import {IvyParser, Parser, SplitInterpolation} from '@angular/compiler/src/expression_parser/parser';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n@@ -208,28 +208,23 @@ describe('parser', () => {\n       });\n     });\n \n-    describe('method calls', () => {\n-      it('should parse method calls', () => {\n+    describe('calls', () => {\n+      it('should parse calls', () => {\n         checkAction('fn()');\n         checkAction('add(1, 2)');\n         checkAction('a.add(1, 2)');\n         checkAction('fn().add(1, 2)');\n+        checkAction('fn()(1, 2)');\n       });\n \n       it('should parse an EmptyExpr with a correct span for a trailing empty argument', () => {\n-        const ast = parseAction('fn(1, )').ast as MethodCall;\n+        const ast = parseAction('fn(1, )').ast as Call;\n         expect(ast.args[1]).toBeAnInstanceOf(EmptyExpr);\n         const sourceSpan = (ast.args[1] as EmptyExpr).sourceSpan;\n         expect([sourceSpan.start, sourceSpan.end]).toEqual([5, 6]);\n       });\n     });\n \n-    describe('functional calls', () => {\n-      it('should parse function calls', () => {\n-        checkAction('fn()(1, 2)');\n-      });\n-    });\n-\n     describe('keyed read', () => {\n       it('should parse keyed reads', () => {\n         checkBinding('a[\"a\"]');\n@@ -389,27 +384,22 @@ describe('parser', () => {\n       expect(unparseWithSpan(ast)).toContain(['foo?.bar', '[nameSpan] bar']);\n     });\n \n-    it('should record method call span', () => {\n+    it('should record call span', () => {\n       const ast = parseAction('foo()');\n       expect(unparseWithSpan(ast)).toContain(['foo()', 'foo()']);\n-      expect(unparseWithSpan(ast)).toContain(['foo()', '[nameSpan] foo']);\n+      expect(unparseWithSpan(ast)).toContain(['foo()', '[argumentSpan] ']);\n+      expect(unparseWithSpan(ast)).toContain(['foo', '[nameSpan] foo']);\n     });\n \n-    it('should record method call argument span', () => {\n+    it('should record call argument span', () => {\n       const ast = parseAction('foo(1 + 2)');\n       expect(unparseWithSpan(ast)).toContain(['foo(1 + 2)', '[argumentSpan] 1 + 2']);\n     });\n \n-    it('should record accessed method call span', () => {\n+    it('should record accessed call span', () => {\n       const ast = parseAction('foo.bar()');\n       expect(unparseWithSpan(ast)).toContain(['foo.bar()', 'foo.bar()']);\n-      expect(unparseWithSpan(ast)).toContain(['foo.bar()', '[nameSpan] bar']);\n-    });\n-\n-    it('should record safe method call span', () => {\n-      const ast = parseAction('foo?.bar()');\n-      expect(unparseWithSpan(ast)).toContain(['foo?.bar()', 'foo?.bar()']);\n-      expect(unparseWithSpan(ast)).toContain(['foo?.bar()', '[nameSpan] bar']);\n+      expect(unparseWithSpan(ast)).toContain(['foo.bar', '[nameSpan] bar']);\n     });\n \n     it('should record property write span', () => {\n@@ -1087,19 +1077,19 @@ describe('parser', () => {\n             'Host binding expression cannot contain pipes');\n       });\n \n-      it('should throw if a pipe is used inside a function call', () => {\n+      it('should throw if a pipe is used inside a call', () => {\n         expectError(\n             validate(parseSimpleBindingIvy('getId(true, id | myPipe)')),\n             'Host binding expression cannot contain pipes');\n       });\n \n-      it('should throw if a pipe is used inside a method call', () => {\n+      it('should throw if a pipe is used inside a call to a property access', () => {\n         expectError(\n             validate(parseSimpleBindingIvy('idService.getId(true, id | myPipe)')),\n             'Host binding expression cannot contain pipes');\n       });\n \n-      it('should throw if a pipe is used inside a safe method call', () => {\n+      it('should throw if a pipe is used inside a call to a safe property access', () => {\n         expectError(\n             validate(parseSimpleBindingIvy('idService?.getId(true, id | myPipe)')),\n             'Host binding expression cannot contain pipes');"
        },
        {
            "sha": "0732166c0ab2440dc82b70a9b7e524c2f752f71b",
            "filename": "packages/compiler/test/expression_parser/utils/unparser.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 27,
            "changes": 30,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Futils%2Funparser.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Futils%2Funparser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Futils%2Funparser.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, AstVisitor, ASTWithSource, Binary, BindingPipe, Chain, Conditional, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, MethodCall, NonNullAssert, ParseSpan, PrefixNot, PropertyRead, PropertyWrite, Quote, RecursiveAstVisitor, SafeKeyedRead, SafeMethodCall, SafePropertyRead, ThisReceiver, Unary} from '../../../src/expression_parser/ast';\n+import {AST, AstVisitor, ASTWithSource, Binary, BindingPipe, Call, Chain, Conditional, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, NonNullAssert, PrefixNot, PropertyRead, PropertyWrite, Quote, RecursiveAstVisitor, SafeKeyedRead, SafePropertyRead, ThisReceiver, Unary} from '../../../src/expression_parser/ast';\n import {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../../../src/ml_parser/interpolation_config';\n \n class Unparser implements AstVisitor {\n@@ -73,8 +73,8 @@ class Unparser implements AstVisitor {\n     this._expression += ')';\n   }\n \n-  visitFunctionCall(ast: FunctionCall, context: any) {\n-    this._visit(ast.target!);\n+  visitCall(ast: Call, context: any) {\n+    this._visit(ast.receiver);\n     this._expression += '(';\n     let isFirst = true;\n     ast.args.forEach(arg => {\n@@ -150,18 +150,6 @@ class Unparser implements AstVisitor {\n     }\n   }\n \n-  visitMethodCall(ast: MethodCall, context: any) {\n-    this._visit(ast.receiver);\n-    this._expression += ast.receiver instanceof ImplicitReceiver ? `${ast.name}(` : `.${ast.name}(`;\n-    let isFirst = true;\n-    ast.args.forEach(arg => {\n-      if (!isFirst) this._expression += ', ';\n-      isFirst = false;\n-      this._visit(arg);\n-    });\n-    this._expression += ')';\n-  }\n-\n   visitPrefixNot(ast: PrefixNot, context: any) {\n     this._expression += '!';\n     this._visit(ast.expression);\n@@ -177,18 +165,6 @@ class Unparser implements AstVisitor {\n     this._expression += `?.${ast.name}`;\n   }\n \n-  visitSafeMethodCall(ast: SafeMethodCall, context: any) {\n-    this._visit(ast.receiver);\n-    this._expression += `?.${ast.name}(`;\n-    let isFirst = true;\n-    ast.args.forEach(arg => {\n-      if (!isFirst) this._expression += ', ';\n-      isFirst = false;\n-      this._visit(arg);\n-    });\n-    this._expression += ')';\n-  }\n-\n   visitQuote(ast: Quote, context: any) {\n     this._expression += `${ast.prefix}:${ast.uninterpretedExpression}`;\n   }"
        },
        {
            "sha": "50f1d2d3f5391a8edf657f05a8a01d49987f917f",
            "filename": "packages/compiler/test/expression_parser/utils/validator.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 13,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Futils%2Fvalidator.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Futils%2Fvalidator.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Futils%2Fvalidator.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, Binary, BindingPipe, Chain, Conditional, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, MethodCall, ParseSpan, PrefixNot, PropertyRead, PropertyWrite, Quote, RecursiveAstVisitor, SafeKeyedRead, SafeMethodCall, SafePropertyRead, Unary} from '../../../src/expression_parser/ast';\n+import {AST, Binary, BindingPipe, Call, Chain, Conditional, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, ParseSpan, PrefixNot, PropertyRead, PropertyWrite, Quote, RecursiveAstVisitor, SafeKeyedRead, SafePropertyRead, Unary} from '../../../src/expression_parser/ast';\n \n import {unparse} from './unparser';\n \n@@ -50,10 +50,6 @@ class ASTValidator extends RecursiveAstVisitor {\n     this.validate(ast, () => super.visitConditional(ast, context));\n   }\n \n-  override visitFunctionCall(ast: FunctionCall, context: any): any {\n-    this.validate(ast, () => super.visitFunctionCall(ast, context));\n-  }\n-\n   override visitImplicitReceiver(ast: ImplicitReceiver, context: any): any {\n     this.validate(ast, () => super.visitImplicitReceiver(ast, context));\n   }\n@@ -82,10 +78,6 @@ class ASTValidator extends RecursiveAstVisitor {\n     this.validate(ast, () => super.visitLiteralPrimitive(ast, context));\n   }\n \n-  override visitMethodCall(ast: MethodCall, context: any): any {\n-    this.validate(ast, () => super.visitMethodCall(ast, context));\n-  }\n-\n   override visitPipe(ast: BindingPipe, context: any): any {\n     this.validate(ast, () => super.visitPipe(ast, context));\n   }\n@@ -106,17 +98,17 @@ class ASTValidator extends RecursiveAstVisitor {\n     this.validate(ast, () => super.visitQuote(ast, context));\n   }\n \n-  override visitSafeMethodCall(ast: SafeMethodCall, context: any): any {\n-    this.validate(ast, () => super.visitSafeMethodCall(ast, context));\n-  }\n-\n   override visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n     this.validate(ast, () => super.visitSafePropertyRead(ast, context));\n   }\n \n   override visitSafeKeyedRead(ast: SafeKeyedRead, context: any): any {\n     this.validate(ast, () => super.visitSafeKeyedRead(ast, context));\n   }\n+\n+  override visitCall(ast: Call, context: any): any {\n+    this.validate(ast, () => super.visitCall(ast, context));\n+  }\n }\n \n function inSpan(span: ParseSpan, parentSpan: ParseSpan|undefined): parentSpan is ParseSpan {"
        },
        {
            "sha": "93deba58b74f8d6852f8ce1750366e8dc0ad0c77",
            "filename": "packages/compiler/test/output/js_emitter_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 19,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Ftest%2Foutput%2Fjs_emitter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Ftest%2Foutput%2Fjs_emitter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Foutput%2Fjs_emitter_spec.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -71,29 +71,12 @@ const externalModuleIdentifier = new o.ExternalReference(anotherModuleUrl, 'some\n \n     it('should invoke functions and methods and constructors', () => {\n       expect(emitStmt(o.variable('someFn').callFn([o.literal(1)]).toStmt())).toEqual('someFn(1);');\n-      expect(emitStmt(o.variable('someObj').callMethod('someMethod', [o.literal(1)]).toStmt()))\n+      expect(emitStmt(o.variable('someObj').prop('someMethod').callFn([o.literal(1)]).toStmt()))\n           .toEqual('someObj.someMethod(1);');\n       expect(emitStmt(o.variable('SomeClass').instantiate([o.literal(1)]).toStmt()))\n           .toEqual('new SomeClass(1);');\n     });\n \n-    it('should support builtin methods', () => {\n-      expect(emitStmt(o.variable('arr1')\n-                          .callMethod(o.BuiltinMethod.ConcatArray, [o.variable('arr2')])\n-                          .toStmt()))\n-          .toEqual('arr1.concat(arr2);');\n-\n-      expect(emitStmt(o.variable('observable')\n-                          .callMethod(o.BuiltinMethod.SubscribeObservable, [o.variable('listener')])\n-                          .toStmt()))\n-          .toEqual('observable.subscribe(listener);');\n-\n-      expect(\n-          emitStmt(\n-              o.variable('fn').callMethod(o.BuiltinMethod.Bind, [o.variable('someObj')]).toStmt()))\n-          .toEqual('fn.bind(someObj);');\n-    });\n-\n     it('should support literals', () => {\n       expect(emitStmt(o.literal(0).toStmt())).toEqual('0;');\n       expect(emitStmt(o.literal(true).toStmt())).toEqual('true;');\n@@ -275,7 +258,7 @@ const externalModuleIdentifier = new o.ExternalReference(anotherModuleUrl, 'some\n       let callSomeMethod: o.Statement;\n \n       beforeEach(() => {\n-        callSomeMethod = o.THIS_EXPR.callMethod('someMethod', []).toStmt();\n+        callSomeMethod = o.THIS_EXPR.prop('someMethod').callFn([]).toStmt();\n       });\n \n       it('should support declaring classes', () => {"
        },
        {
            "sha": "30c716eb7529e308044d30d6fbe87e85d7f38ba3",
            "filename": "packages/compiler/test/output/ts_emitter_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 19,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Ftest%2Foutput%2Fts_emitter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Ftest%2Foutput%2Fts_emitter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Foutput%2Fts_emitter_spec.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -124,29 +124,12 @@ const externalModuleIdentifier = new o.ExternalReference(anotherModuleUrl, 'some\n \n     it('should invoke functions and methods and constructors', () => {\n       expect(emitStmt(o.variable('someFn').callFn([o.literal(1)]).toStmt())).toEqual('someFn(1);');\n-      expect(emitStmt(o.variable('someObj').callMethod('someMethod', [o.literal(1)]).toStmt()))\n+      expect(emitStmt(o.variable('someObj').prop('someMethod').callFn([o.literal(1)]).toStmt()))\n           .toEqual('someObj.someMethod(1);');\n       expect(emitStmt(o.variable('SomeClass').instantiate([o.literal(1)]).toStmt()))\n           .toEqual('new SomeClass(1);');\n     });\n \n-    it('should support builtin methods', () => {\n-      expect(emitStmt(o.variable('arr1')\n-                          .callMethod(o.BuiltinMethod.ConcatArray, [o.variable('arr2')])\n-                          .toStmt()))\n-          .toEqual('arr1.concat(arr2);');\n-\n-      expect(emitStmt(o.variable('observable')\n-                          .callMethod(o.BuiltinMethod.SubscribeObservable, [o.variable('listener')])\n-                          .toStmt()))\n-          .toEqual('observable.subscribe(listener);');\n-\n-      expect(\n-          emitStmt(\n-              o.variable('fn').callMethod(o.BuiltinMethod.Bind, [o.variable('someObj')]).toStmt()))\n-          .toEqual('fn.bind(someObj);');\n-    });\n-\n     it('should support literals', () => {\n       expect(emitStmt(o.literal(0).toStmt())).toEqual('0;');\n       expect(emitStmt(o.literal(true).toStmt())).toEqual('true;');\n@@ -282,7 +265,7 @@ const externalModuleIdentifier = new o.ExternalReference(anotherModuleUrl, 'some\n       let callSomeMethod: o.Statement;\n \n       beforeEach(() => {\n-        callSomeMethod = o.THIS_EXPR.callMethod('someMethod', []).toStmt();\n+        callSomeMethod = o.THIS_EXPR.prop('someMethod').callFn([]).toStmt();\n       });\n \n "
        },
        {
            "sha": "5183b5d594bfbbd8f2e5925817d7ccd9b3c5341a",
            "filename": "packages/compiler/test/render3/util/expression.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 12,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Ftest%2Frender3%2Futil%2Fexpression.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Ftest%2Frender3%2Futil%2Fexpression.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Frender3%2Futil%2Fexpression.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -46,10 +46,6 @@ class ExpressionSourceHumanizer extends e.RecursiveAstVisitor implements t.Visit\n     this.recordAst(ast);\n     super.visitConditional(ast, null);\n   }\n-  override visitFunctionCall(ast: e.FunctionCall) {\n-    this.recordAst(ast);\n-    super.visitFunctionCall(ast, null);\n-  }\n   override visitImplicitReceiver(ast: e.ImplicitReceiver) {\n     this.recordAst(ast);\n     super.visitImplicitReceiver(ast, null);\n@@ -78,10 +74,6 @@ class ExpressionSourceHumanizer extends e.RecursiveAstVisitor implements t.Visit\n     this.recordAst(ast);\n     super.visitLiteralMap(ast, null);\n   }\n-  override visitMethodCall(ast: e.MethodCall) {\n-    this.recordAst(ast);\n-    super.visitMethodCall(ast, null);\n-  }\n   override visitNonNullAssert(ast: e.NonNullAssert) {\n     this.recordAst(ast);\n     super.visitNonNullAssert(ast, null);\n@@ -102,10 +94,6 @@ class ExpressionSourceHumanizer extends e.RecursiveAstVisitor implements t.Visit\n     this.recordAst(ast);\n     super.visitPropertyWrite(ast, null);\n   }\n-  override visitSafeMethodCall(ast: e.SafeMethodCall) {\n-    this.recordAst(ast);\n-    super.visitSafeMethodCall(ast, null);\n-  }\n   override visitSafePropertyRead(ast: e.SafePropertyRead) {\n     this.recordAst(ast);\n     super.visitSafePropertyRead(ast, null);\n@@ -118,6 +106,10 @@ class ExpressionSourceHumanizer extends e.RecursiveAstVisitor implements t.Visit\n     this.recordAst(ast);\n     super.visitSafeKeyedRead(ast, null);\n   }\n+  override visitCall(ast: e.Call) {\n+    this.recordAst(ast);\n+    super.visitCall(ast, null);\n+  }\n \n   visitTemplate(ast: t.Template) {\n     t.visitAll(this, ast.children);"
        },
        {
            "sha": "c913c609c6f10a33e7fd8a578deb8f51074c8443",
            "filename": "packages/compiler/test/template_parser/util/expression.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 12,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Futil%2Fexpression.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Futil%2Fexpression.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Futil%2Fexpression.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -46,10 +46,6 @@ class ExpressionSourceHumanizer extends e.RecursiveAstVisitor implements t.Templ\n     this.recordAst(ast);\n     super.visitConditional(ast, null);\n   }\n-  override visitFunctionCall(ast: e.FunctionCall) {\n-    this.recordAst(ast);\n-    super.visitFunctionCall(ast, null);\n-  }\n   override visitImplicitReceiver(ast: e.ImplicitReceiver) {\n     this.recordAst(ast);\n     super.visitImplicitReceiver(ast, null);\n@@ -78,10 +74,6 @@ class ExpressionSourceHumanizer extends e.RecursiveAstVisitor implements t.Templ\n     this.recordAst(ast);\n     super.visitLiteralMap(ast, null);\n   }\n-  override visitMethodCall(ast: e.MethodCall) {\n-    this.recordAst(ast);\n-    super.visitMethodCall(ast, null);\n-  }\n   override visitNonNullAssert(ast: e.NonNullAssert) {\n     this.recordAst(ast);\n     super.visitNonNullAssert(ast, null);\n@@ -102,10 +94,6 @@ class ExpressionSourceHumanizer extends e.RecursiveAstVisitor implements t.Templ\n     this.recordAst(ast);\n     super.visitPropertyWrite(ast, null);\n   }\n-  override visitSafeMethodCall(ast: e.SafeMethodCall) {\n-    this.recordAst(ast);\n-    super.visitSafeMethodCall(ast, null);\n-  }\n   override visitSafePropertyRead(ast: e.SafePropertyRead) {\n     this.recordAst(ast);\n     super.visitSafePropertyRead(ast, null);\n@@ -118,6 +106,10 @@ class ExpressionSourceHumanizer extends e.RecursiveAstVisitor implements t.Templ\n     this.recordAst(ast);\n     super.visitSafeKeyedRead(ast, null);\n   }\n+  override visitCall(ast: e.Call) {\n+    this.recordAst(ast);\n+    super.visitCall(ast, null);\n+  }\n \n   visitNgContent(ast: t.NgContentAst) {}\n   visitEmbeddedTemplate(ast: t.EmbeddedTemplateAst) {"
        },
        {
            "sha": "1174d70cf5c563b9e9fae9b44e2ce890001ca533",
            "filename": "packages/core/test/acceptance/integration_spec.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcore%2Ftest%2Facceptance%2Fintegration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Fcore%2Ftest%2Facceptance%2Fintegration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fintegration_spec.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -2074,6 +2074,23 @@ describe('acceptance integration tests', () => {\n     expect(fixture.nativeElement.textContent).toBe('Balance: $5000000');\n   });\n \n+  it('should handle calls to a safe access in templates', () => {\n+    @Component({\n+      template: `\n+      <span>Hello, {{ (person?.getName() || 'unknown') }}!</span>\n+    `\n+    })\n+    class App {\n+      person = null;\n+    }\n+\n+    TestBed.configureTestingModule({declarations: [App]});\n+    const fixture = TestBed.createComponent(App);\n+    fixture.detectChanges();\n+\n+    expect(fixture.nativeElement.textContent).toContain('Hello, unknown!');\n+  });\n+\n   describe('tView.firstUpdatePass', () => {\n     function isFirstUpdatePass() {\n       const lView = getLView();"
        },
        {
            "sha": "7c3c0af04c00249d005c6578a301a03ef5ebcec1",
            "filename": "packages/language-service/ivy/completions.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 8,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fcompletions.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, BindingPipe, EmptyExpr, ImplicitReceiver, LiteralPrimitive, MethodCall, ParseSourceSpan, PropertyRead, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstText, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n+import {AST, BindingPipe, Call, EmptyExpr, ImplicitReceiver, LiteralPrimitive, ParseSourceSpan, PropertyRead, PropertyWrite, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstText, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n import {CompletionKind, DirectiveInScope, SymbolKind, TemplateDeclarationSymbol} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import {BoundEvent, TextAttribute} from '@angular/compiler/src/render3/r3_ast';\n@@ -18,8 +18,7 @@ import {TargetContext, TargetNodeKind, TemplateTarget} from './template_target';\n import {filterAliasImports} from './utils';\n \n type PropertyExpressionCompletionBuilder =\n-    CompletionBuilder<PropertyRead|PropertyWrite|MethodCall|EmptyExpr|SafePropertyRead|\n-                      SafeMethodCall|TmplAstBoundEvent>;\n+    CompletionBuilder<PropertyRead|PropertyWrite|EmptyExpr|SafePropertyRead|TmplAstBoundEvent>;\n \n type ElementAttributeCompletionBuilder =\n     CompletionBuilder<TmplAstElement|TmplAstBoundAttribute|TmplAstTextAttribute|TmplAstBoundEvent>;\n@@ -180,8 +179,7 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n    */\n   private isPropertyExpressionCompletion(this: CompletionBuilder<TmplAstNode|AST>):\n       this is PropertyExpressionCompletionBuilder {\n-    return this.node instanceof PropertyRead || this.node instanceof MethodCall ||\n-        this.node instanceof SafePropertyRead || this.node instanceof SafeMethodCall ||\n+    return this.node instanceof PropertyRead || this.node instanceof SafePropertyRead ||\n         this.node instanceof PropertyWrite || this.node instanceof EmptyExpr ||\n         // BoundEvent nodes only count as property completions if in an EventValue context.\n         (this.node instanceof BoundEvent && this.nodeContext === CompletionNodeContext.EventValue);\n@@ -774,9 +772,8 @@ function makeReplacementSpanFromParseSourceSpan(span: ParseSourceSpan): ts.TextS\n   };\n }\n \n-function makeReplacementSpanFromAst(node: PropertyRead|PropertyWrite|MethodCall|SafePropertyRead|\n-                                    SafeMethodCall|BindingPipe|EmptyExpr|LiteralPrimitive|\n-                                    BoundEvent): ts.TextSpan|undefined {\n+function makeReplacementSpanFromAst(node: PropertyRead|PropertyWrite|SafePropertyRead|BindingPipe|\n+                                    EmptyExpr|LiteralPrimitive|BoundEvent): ts.TextSpan|undefined {\n   if ((node instanceof EmptyExpr || node instanceof LiteralPrimitive ||\n        node instanceof BoundEvent)) {\n     // empty nodes do not replace any existing text"
        },
        {
            "sha": "395d3fd37c252f16e3c78fa6246f48b2dafcb169",
            "filename": "packages/language-service/ivy/language_service.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -163,7 +163,9 @@ export class LanguageService {\n     const node = positionDetails.context.kind === TargetNodeKind.TwoWayBindingContext ?\n         positionDetails.context.nodes[0] :\n         positionDetails.context.node;\n-    return new QuickInfoBuilder(this.tsLS, compiler, templateInfo.component, node).get();\n+    return new QuickInfoBuilder(\n+               this.tsLS, compiler, templateInfo.component, node, positionDetails.parent)\n+        .get();\n   }\n \n   getReferencesAtPosition(fileName: string, position: number): ts.ReferenceEntry[]|undefined {"
        },
        {
            "sha": "a1afd83e1c844f80c18fcefa993457d615cb4b51",
            "filename": "packages/language-service/ivy/quick_info.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 10,
            "changes": 31,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fivy%2Fquick_info.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fivy%2Fquick_info.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fquick_info.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -5,7 +5,7 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {AST, ImplicitReceiver, MethodCall, ThisReceiver, TmplAstBoundAttribute, TmplAstNode, TmplAstTextAttribute} from '@angular/compiler';\n+import {AST, Call, ImplicitReceiver, PropertyRead, ThisReceiver, TmplAstBoundAttribute, TmplAstNode, TmplAstTextAttribute} from '@angular/compiler';\n import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n import {DirectiveSymbol, DomBindingSymbol, ElementSymbol, InputBindingSymbol, OutputBindingSymbol, PipeSymbol, ReferenceSymbol, ShimLocation, Symbol, SymbolKind, VariableSymbol} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import * as ts from 'typescript';\n@@ -18,16 +18,25 @@ export class QuickInfoBuilder {\n \n   constructor(\n       private readonly tsLS: ts.LanguageService, private readonly compiler: NgCompiler,\n-      private readonly component: ts.ClassDeclaration, private node: TmplAstNode|AST) {}\n+      private readonly component: ts.ClassDeclaration, private node: TmplAstNode|AST,\n+      private parent: TmplAstNode|AST|null) {}\n \n   get(): ts.QuickInfo|undefined {\n     const symbol =\n         this.compiler.getTemplateTypeChecker().getSymbolOfNode(this.node, this.component);\n-    if (symbol === null) {\n-      return isDollarAny(this.node) ? createDollarAnyQuickInfo(this.node) : undefined;\n+    if (symbol !== null) {\n+      return this.getQuickInfoForSymbol(symbol);\n     }\n \n-    return this.getQuickInfoForSymbol(symbol);\n+    if (isDollarAny(this.node)) {\n+      return createDollarAnyQuickInfo(this.node);\n+    }\n+\n+    // If the cursor lands on the receiver of a method call, we have to look\n+    // at the entire call in order to figure out if it's a call to `$any`.\n+    if (this.parent !== null && isDollarAny(this.parent) && this.parent.receiver === this.node) {\n+      return createDollarAnyQuickInfo(this.parent);\n+    }\n   }\n \n   private getQuickInfoForSymbol(symbol: Symbol): ts.QuickInfo|undefined {\n@@ -185,16 +194,18 @@ function displayPartsEqual(a: {text: string, kind: string}, b: {text: string, ki\n   return a.text === b.text && a.kind === b.kind;\n }\n \n-function isDollarAny(node: TmplAstNode|AST): node is MethodCall {\n-  return node instanceof MethodCall && node.receiver instanceof ImplicitReceiver &&\n-      !(node.receiver instanceof ThisReceiver) && node.name === '$any' && node.args.length === 1;\n+function isDollarAny(node: TmplAstNode|AST): node is Call {\n+  return node instanceof Call && node.receiver instanceof PropertyRead &&\n+      node.receiver.receiver instanceof ImplicitReceiver &&\n+      !(node.receiver.receiver instanceof ThisReceiver) && node.receiver.name === '$any' &&\n+      node.args.length === 1;\n }\n \n-function createDollarAnyQuickInfo(node: MethodCall): ts.QuickInfo {\n+function createDollarAnyQuickInfo(node: Call): ts.QuickInfo {\n   return createQuickInfo(\n       '$any',\n       DisplayInfoKind.METHOD,\n-      getTextSpanOfNode(node),\n+      getTextSpanOfNode(node.receiver),\n       /** containerName */ undefined,\n       'any',\n       [{"
        },
        {
            "sha": "d28e225044d5217da03f2535416014d99ddef536",
            "filename": "packages/language-service/ivy/references_and_rename_utils.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fivy%2Freferences_and_rename_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fivy%2Freferences_and_rename_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Freferences_and_rename_utils.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -5,7 +5,7 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {AST, BindingPipe, LiteralPrimitive, MethodCall, PropertyRead, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstNode, TmplAstReference, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n+import {AST, BindingPipe, LiteralPrimitive, PropertyRead, PropertyWrite, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstNode, TmplAstReference, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n import {absoluteFrom} from '@angular/compiler-cli/src/ngtsc/file_system';\n import {DirectiveMeta, PipeMeta} from '@angular/compiler-cli/src/ngtsc/metadata';\n@@ -264,9 +264,8 @@ export function getRenameTextAndSpanAtPosition(\n     }\n   }\n \n-  if (node instanceof PropertyRead || node instanceof MethodCall || node instanceof PropertyWrite ||\n-      node instanceof SafePropertyRead || node instanceof SafeMethodCall ||\n-      node instanceof BindingPipe) {\n+  if (node instanceof PropertyRead || node instanceof PropertyWrite ||\n+      node instanceof SafePropertyRead || node instanceof BindingPipe) {\n     return {text: node.name, span: toTextSpan(node.nameSpan)};\n   } else if (node instanceof LiteralPrimitive) {\n     const span = toTextSpan(node.sourceSpan);"
        },
        {
            "sha": "bc2c094ad5846cbdcbd87fcb55cc593d7c66f295",
            "filename": "packages/language-service/ivy/signature_help.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 18,
            "changes": 34,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fivy%2Fsignature_help.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fivy%2Fsignature_help.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fsignature_help.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {MethodCall, SafeMethodCall} from '@angular/compiler';\n+import {Call} from '@angular/compiler';\n import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n import {getSourceFileOrError} from '@angular/compiler-cli/src/ngtsc/file_system';\n import {SymbolKind} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n@@ -33,7 +33,7 @@ export function getSignatureHelp(\n   }\n \n   if (targetInfo.context.kind !== TargetNodeKind.RawExpression &&\n-      targetInfo.context.kind !== TargetNodeKind.MethodCallExpressionInArgContext) {\n+      targetInfo.context.kind !== TargetNodeKind.CallExpressionInArgContext) {\n     // Signature completions are only available in expressions.\n     return undefined;\n   }\n@@ -45,41 +45,40 @@ export function getSignatureHelp(\n   }\n \n   // Determine a shim position to use in the request to the TypeScript Language Service.\n-  // Additionally, extract the `MethodCall` or `SafeMethodCall` node for which signature help is\n-  // being queried, as this is needed to construct the correct span for the results later.\n+  // Additionally, extract the `Call` node for which signature help is being queried, as this\n+  // is needed to construct the correct span for the results later.\n   let shimPosition: number;\n-  let expr: MethodCall|SafeMethodCall;\n+  let expr: Call;\n   switch (targetInfo.context.kind) {\n     case TargetNodeKind.RawExpression:\n       // For normal expressions, just use the primary TCB position of the expression.\n       shimPosition = symbol.shimLocation.positionInShimFile;\n \n-      // Walk up the parents of this expression and try to find a `MethodCall` or `SafeMethodCall`\n-      // for which signature information is being fetched.\n-      let callExpr: MethodCall|SafeMethodCall|null = null;\n+      // Walk up the parents of this expression and try to find a\n+      // `Call` for which signature information is being fetched.\n+      let callExpr: Call|null = null;\n       const parents = targetInfo.context.parents;\n       for (let i = parents.length - 1; i >= 0; i--) {\n         const parent = parents[i];\n-        if (parent instanceof MethodCall || parent instanceof SafeMethodCall) {\n+        if (parent instanceof Call) {\n           callExpr = parent;\n           break;\n         }\n       }\n \n-      // If no MethodCall or SafeMethodCall node could be found, then this query cannot be safely\n+      // If no Call node could be found, then this query cannot be safely\n       // answered as a correct span for the results will not be obtainable.\n       if (callExpr === null) {\n         return undefined;\n       }\n \n       expr = callExpr;\n       break;\n-    case TargetNodeKind.MethodCallExpressionInArgContext:\n-      // The `Symbol` points to a `MethodCall` or `SafeMethodCall` expression in the TCB (where it\n-      // will be represented as a `ts.CallExpression`) *and* the template position was within the\n-      // argument list of the method call. This happens when there was no narrower expression inside\n-      // the argument list that matched the template position, such as when the call has no\n-      // arguments: `foo(|)`.\n+    case TargetNodeKind.CallExpressionInArgContext:\n+      // The `Symbol` points to a `Call` expression in the TCB (where it will be represented as a\n+      // `ts.CallExpression`) *and* the template position was within the argument list of the method\n+      // call. This happens when there was no narrower expression inside the argument list that\n+      // matched the template position, such as when the call has no arguments: `foo(|)`.\n       //\n       // The `Symbol`'s shim position is to the start of the call expression (`|foo()`) and\n       // therefore wouldn't return accurate signature help from the TS language service. For that, a\n@@ -123,8 +122,7 @@ export function getSignatureHelp(\n \n   // The TS language service results are almost returnable as-is. However, they contain an\n   // `applicableSpan` which marks the entire argument list, and that span is in the context of the\n-  // TCB's `ts.CallExpression`. It needs to be replaced with the span for the `MethodCall` (or\n-  // `SafeMethodCall`) argument list.\n+  // TCB's `ts.CallExpression`. It needs to be replaced with the span for the `Call` argument list.\n   return {\n     ...res,\n     applicableSpan: {"
        },
        {
            "sha": "12847cc1d2f0ca3a73d28d9d3e271b10efd487d0",
            "filename": "packages/language-service/ivy/template_target.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 10,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -49,7 +49,7 @@ export interface TemplateTarget {\n export type TargetContext = SingleNodeTarget|MultiNodeTarget;\n \n /** Contexts which logically target only a single node in the template AST. */\n-export type SingleNodeTarget = RawExpression|MethodCallExpressionInArgContext|RawTemplateNode|\n+export type SingleNodeTarget = RawExpression|CallExpressionInArgContext|RawTemplateNode|\n     ElementInBodyContext|ElementInTagContext|AttributeInKeyContext|AttributeInValueContext;\n \n /**\n@@ -65,7 +65,7 @@ export type MultiNodeTarget = TwoWayBindingContext;\n  */\n export enum TargetNodeKind {\n   RawExpression,\n-  MethodCallExpressionInArgContext,\n+  CallExpressionInArgContext,\n   RawTemplateNode,\n   ElementInTagContext,\n   ElementInBodyContext,\n@@ -84,17 +84,16 @@ export interface RawExpression {\n }\n \n /**\n- * An `e.MethodCall` or `e.SafeMethodCall` expression with the cursor in a position where an\n- * argument could appear.\n+ * An `e.Call` expression with the cursor in a position where an argument could appear.\n  *\n  * This is returned when the only matching node is the method call expression, but the cursor is\n  * within the method call parentheses. For example, in the expression `foo(|)` there is no argument\n  * expression that the cursor could be targeting, but the cursor is in a position where one could\n  * appear.\n  */\n-export interface MethodCallExpressionInArgContext {\n-  kind: TargetNodeKind.MethodCallExpressionInArgContext;\n-  node: e.MethodCall|e.SafeMethodCall;\n+export interface CallExpressionInArgContext {\n+  kind: TargetNodeKind.CallExpressionInArgContext;\n+  node: e.Call;\n }\n \n /**\n@@ -185,10 +184,9 @@ export function getTargetAtPosition(template: t.Node[], position: number): Templ\n \n   // Given the candidate node, determine the full targeted context.\n   let nodeInContext: TargetContext;\n-  if ((candidate instanceof e.MethodCall || candidate instanceof e.SafeMethodCall) &&\n-      isWithin(position, candidate.argumentSpan)) {\n+  if (candidate instanceof e.Call && isWithin(position, candidate.argumentSpan)) {\n     nodeInContext = {\n-      kind: TargetNodeKind.MethodCallExpressionInArgContext,\n+      kind: TargetNodeKind.CallExpressionInArgContext,\n       node: candidate,\n     };\n   } else if (candidate instanceof e.AST) {"
        },
        {
            "sha": "d51ecf626ee799ea06c9dc622e16df43c5eac140",
            "filename": "packages/language-service/ivy/test/legacy/template_target_spec.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -147,7 +147,7 @@ describe('getTargetAtPosition for template AST', () => {\n     const {context} = getTargetAtPosition(nodes, position)!;\n     const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n-    expect(node).toBeInstanceOf(e.MethodCall);\n+    expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n \n   it('should locate element children', () => {\n@@ -234,7 +234,7 @@ describe('getTargetAtPosition for template AST', () => {\n     expect(errors).toBe(null);\n     const {context} = getTargetAtPosition(nodes, position)!;\n     const {node} = context as SingleNodeTarget;\n-    expect(node).toBeInstanceOf(e.MethodCall);\n+    expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n \n   it('should locate template attribute key', () => {\n@@ -546,7 +546,7 @@ describe('getTargetAtPosition for expression AST', () => {\n     const {context} = getTargetAtPosition(nodes, position)!;\n     const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n-    expect(node).toBeInstanceOf(e.MethodCall);\n+    expect(node).toBeInstanceOf(e.Call);\n   });\n \n   it('should locate safe method call', () => {\n@@ -555,16 +555,16 @@ describe('getTargetAtPosition for expression AST', () => {\n     const {context} = getTargetAtPosition(nodes, position)!;\n     const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n-    expect(node).toBeInstanceOf(e.SafeMethodCall);\n+    expect(node).toBeInstanceOf(e.Call);\n   });\n \n   it('should identify when in the argument position in a no-arg method call', () => {\n     const {errors, nodes, position} = parse(`{{ title.toString() }}`);\n     expect(errors).toBe(null);\n     const {context} = getTargetAtPosition(nodes, position)!;\n-    expect(context.kind).toEqual(TargetNodeKind.MethodCallExpressionInArgContext);\n+    expect(context.kind).toEqual(TargetNodeKind.CallExpressionInArgContext);\n     const {node} = context as SingleNodeTarget;\n-    expect(node).toBeInstanceOf(e.MethodCall);\n+    expect(node).toBeInstanceOf(e.Call);\n   });\n \n   it('should locate literal primitive in interpolation', () => {"
        },
        {
            "sha": "ee70e00535b1065441a5c9fcaac3fbe7c77314a6",
            "filename": "packages/language-service/ivy/utils.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Futils.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -22,11 +22,10 @@ export function getTextSpanOfNode(node: t.Node|e.AST): ts.TextSpan {\n   if (isTemplateNodeWithKeyAndValue(node)) {\n     return toTextSpan(node.keySpan);\n   } else if (\n-      node instanceof e.PropertyWrite || node instanceof e.MethodCall ||\n-      node instanceof e.BindingPipe || node instanceof e.PropertyRead) {\n-    // The `name` part of a `PropertyWrite`, `MethodCall`, and `BindingPipe` does not\n-    // have its own AST so there is no way to retrieve a `Symbol` for just the `name` via a specific\n-    // node.\n+      node instanceof e.PropertyWrite || node instanceof e.BindingPipe ||\n+      node instanceof e.PropertyRead) {\n+    // The `name` part of a `PropertyWrite` and `BindingPipe` does not have its own AST\n+    // so there is no way to retrieve a `Symbol` for just the `name` via a specific node.\n     return toTextSpan(node.nameSpan);\n   } else {\n     return toTextSpan(node.sourceSpan);"
        },
        {
            "sha": "50421b9c8d93c5215318f29ad7c9f3eaf963a541",
            "filename": "packages/language-service/src/expression_type.ts",
            "status": "modified",
            "additions": 61,
            "deletions": 60,
            "changes": 121,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fsrc%2Fexpression_type.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fsrc%2Fexpression_type.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Fexpression_type.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, AstVisitor, ASTWithName, Binary, BindingPipe, Chain, Conditional, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, MethodCall, NonNullAssert, PrefixNot, PropertyRead, PropertyWrite, Quote, SafeKeyedRead, SafeMethodCall, SafePropertyRead, ThisReceiver, Unary} from '@angular/compiler';\n+import {AST, AstVisitor, ASTWithName, Binary, BindingPipe, Call, Chain, Conditional, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, NonNullAssert, PrefixNot, PropertyRead, PropertyWrite, Quote, SafeKeyedRead, SafePropertyRead, ThisReceiver, Unary} from '@angular/compiler';\n \n import {createDiagnostic, Diagnostic} from './diagnostic_messages';\n import {BuiltinType, Signature, Symbol, SymbolQuery, SymbolTable} from './symbols';\n@@ -197,30 +197,6 @@ export class AstType implements AstVisitor {\n     return this.query.getTypeUnion(this.getType(ast.trueExp), this.getType(ast.falseExp));\n   }\n \n-  visitFunctionCall(ast: FunctionCall) {\n-    // The type of a function call is the return type of the selected signature.\n-    // The signature is selected based on the types of the arguments. Angular doesn't\n-    // support contextual typing of arguments so this is simpler than TypeScript's\n-    // version.\n-    const args = ast.args.map(arg => this.getType(arg));\n-    const target = this.getType(ast.target!);\n-    if (!target || !target.callable) {\n-      this.diagnostics.push(createDiagnostic(\n-          refinedSpan(ast), Diagnostic.call_target_not_callable, this.sourceOf(ast.target!),\n-          target.name));\n-      return this.anyType;\n-    }\n-    const signature = target.selectSignature(args);\n-    if (signature) {\n-      return signature.result;\n-    }\n-    // TODO: Consider a better error message here. See `typescript_symbols#selectSignature` for more\n-    // details.\n-    this.diagnostics.push(\n-        createDiagnostic(refinedSpan(ast), Diagnostic.unable_to_resolve_compatible_call_signature));\n-    return this.anyType;\n-  }\n-\n   visitImplicitReceiver(_ast: ImplicitReceiver): Symbol {\n     const _this = this;\n     // Return a pseudo-symbol for the implicit receiver.\n@@ -322,10 +298,6 @@ export class AstType implements AstVisitor {\n     }\n   }\n \n-  visitMethodCall(ast: MethodCall) {\n-    return this.resolveMethodCall(this.getType(ast.receiver), ast);\n-  }\n-\n   visitPipe(ast: BindingPipe) {\n     // The type of a pipe node is the return type of the pipe's transform method. The table returned\n     // by getPipes() is expected to contain symbols with the corresponding transform method type.\n@@ -371,10 +343,6 @@ export class AstType implements AstVisitor {\n     return this.query.getBuiltinType(BuiltinType.Any);\n   }\n \n-  visitSafeMethodCall(ast: SafeMethodCall) {\n-    return this.resolveMethodCall(this.query.getNonNullableType(this.getType(ast.receiver)), ast);\n-  }\n-\n   visitSafePropertyRead(ast: SafePropertyRead) {\n     return this.resolvePropertyRead(this.query.getNonNullableType(this.getType(ast.receiver)), ast);\n   }\n@@ -387,6 +355,66 @@ export class AstType implements AstVisitor {\n     return result || this.anyType;\n   }\n \n+  visitCall(ast: Call) {\n+    if (ast.receiver instanceof Call) {\n+      // The type of a function call is the return type of the selected signature.\n+      // The signature is selected based on the types of the arguments. Angular doesn't\n+      // support contextual typing of arguments so this is simpler than TypeScript's\n+      // version.\n+      const args = ast.args.map(arg => this.getType(arg));\n+      const target = this.getType(ast.receiver);\n+      if (!target || !target.callable) {\n+        this.diagnostics.push(createDiagnostic(\n+            refinedSpan(ast), Diagnostic.call_target_not_callable, this.sourceOf(ast.receiver),\n+            target.name));\n+        return this.anyType;\n+      }\n+      const signature = target.selectSignature(args);\n+      if (signature) {\n+        return signature.result;\n+      }\n+      // TODO: Consider a better error message here. See `typescript_symbols#selectSignature` for\n+      // more details.\n+      this.diagnostics.push(createDiagnostic(\n+          refinedSpan(ast), Diagnostic.unable_to_resolve_compatible_call_signature));\n+      return this.anyType;\n+    }\n+\n+    if (ast.receiver instanceof PropertyRead || ast.receiver instanceof SafePropertyRead) {\n+      const receiver = ast.receiver;\n+      const receiverType = receiver instanceof SafePropertyRead ?\n+          this.query.getNonNullableType(this.getType(receiver.receiver)) :\n+          this.getType(receiver.receiver);\n+\n+      if (this.isAny(receiverType)) {\n+        return this.anyType;\n+      }\n+      const methodType = this.resolvePropertyRead(receiverType, receiver);\n+      if (!methodType) {\n+        this.diagnostics.push(createDiagnostic(\n+            refinedSpan(receiver), Diagnostic.could_not_resolve_type, receiver.name));\n+        return this.anyType;\n+      }\n+      if (this.isAny(methodType)) {\n+        return this.anyType;\n+      }\n+      if (!methodType.callable) {\n+        this.diagnostics.push(createDiagnostic(\n+            refinedSpan(receiver), Diagnostic.identifier_not_callable, receiver.name));\n+        return this.anyType;\n+      }\n+      const signature = methodType.selectSignature(ast.args.map(arg => this.getType(arg)));\n+      if (!signature) {\n+        this.diagnostics.push(createDiagnostic(\n+            refinedSpan(receiver), Diagnostic.unable_to_resolve_signature, receiver.name));\n+        return this.anyType;\n+      }\n+      return signature.result;\n+    }\n+\n+    return this.anyType;\n+  }\n+\n   /**\n    * Gets the source of an expession AST.\n    * The AST's sourceSpan is relative to the start of the template source code, which is contained\n@@ -414,33 +442,6 @@ export class AstType implements AstVisitor {\n     return result;\n   }\n \n-  private resolveMethodCall(receiverType: Symbol, ast: SafeMethodCall|MethodCall) {\n-    if (this.isAny(receiverType)) {\n-      return this.anyType;\n-    }\n-    const methodType = this.resolvePropertyRead(receiverType, ast);\n-    if (!methodType) {\n-      this.diagnostics.push(\n-          createDiagnostic(refinedSpan(ast), Diagnostic.could_not_resolve_type, ast.name));\n-      return this.anyType;\n-    }\n-    if (this.isAny(methodType)) {\n-      return this.anyType;\n-    }\n-    if (!methodType.callable) {\n-      this.diagnostics.push(\n-          createDiagnostic(refinedSpan(ast), Diagnostic.identifier_not_callable, ast.name));\n-      return this.anyType;\n-    }\n-    const signature = methodType.selectSignature(ast.args.map(arg => this.getType(arg)));\n-    if (!signature) {\n-      this.diagnostics.push(\n-          createDiagnostic(refinedSpan(ast), Diagnostic.unable_to_resolve_signature, ast.name));\n-      return this.anyType;\n-    }\n-    return signature.result;\n-  }\n-\n   private resolvePropertyRead(receiverType: Symbol, ast: SafePropertyRead|PropertyRead) {\n     if (this.isAny(receiverType)) {\n       return this.anyType;"
        },
        {
            "sha": "6cddeeb3c3dcac398663130287655678fb9e35be",
            "filename": "packages/language-service/src/expressions.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 17,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fsrc%2Fexpressions.ts",
            "raw_url": "https://github.com/angular/angular/raw/2028c3933f7fe2961999da475febde5a03bb694d/packages%2Flanguage-service%2Fsrc%2Fexpressions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Fexpressions.ts?ref=2028c3933f7fe2961999da475febde5a03bb694d",
            "patch": "@@ -67,7 +67,7 @@ export function getExpressionCompletions(\n     visitBinary(_ast) {},\n     visitChain(_ast) {},\n     visitConditional(_ast) {},\n-    visitFunctionCall(_ast) {},\n+    visitCall(_ast) {},\n     visitImplicitReceiver(_ast) {},\n     visitThisReceiver(_ast) {},\n     visitInterpolation(_ast) {\n@@ -88,7 +88,6 @@ export function getExpressionCompletions(\n         result = undefined;\n       }\n     },\n-    visitMethodCall(_ast) {},\n     visitPipe(ast) {\n       if (position >= ast.exp.span.end &&\n           (!ast.args || !ast.args.length || position < (<AST>ast.args[0]).span.start)) {\n@@ -110,10 +109,6 @@ export function getExpressionCompletions(\n       // For a quote, return the members of any (if there are any).\n       result = templateInfo.query.getBuiltinType(BuiltinType.Any).members();\n     },\n-    visitSafeMethodCall(ast) {\n-      const receiverType = getType(ast.receiver);\n-      result = receiverType ? receiverType.members() : scope;\n-    },\n     visitSafePropertyRead(ast) {\n       const receiverType = getType(ast.receiver);\n       result = receiverType ? receiverType.members() : scope;\n@@ -164,7 +159,7 @@ export function getExpressionSymbol(\n     visitBinary(_ast) {},\n     visitChain(_ast) {},\n     visitConditional(_ast) {},\n-    visitFunctionCall(_ast) {},\n+    visitCall(_ast) {},\n     visitImplicitReceiver(_ast) {},\n     visitThisReceiver(_ast) {},\n     visitInterpolation(_ast) {},\n@@ -174,11 +169,6 @@ export function getExpressionSymbol(\n     visitLiteralArray(_ast) {},\n     visitLiteralMap(_ast) {},\n     visitLiteralPrimitive(_ast) {},\n-    visitMethodCall(ast) {\n-      const receiverType = getType(ast.receiver);\n-      symbol = receiverType && receiverType.members().get(ast.name);\n-      span = spanFromName(ast);\n-    },\n     visitPipe(ast) {\n       if (inSpan(position, ast.nameSpan, /* exclusive */ true)) {\n         // We are in a position a pipe name is expected.\n@@ -200,11 +190,6 @@ export function getExpressionSymbol(\n       span = spanFromName(ast);\n     },\n     visitQuote(_ast) {},\n-    visitSafeMethodCall(ast) {\n-      const receiverType = getType(ast.receiver);\n-      symbol = receiverType && receiverType.members().get(ast.name);\n-      span = spanFromName(ast);\n-    },\n     visitSafePropertyRead(ast) {\n       const receiverType = getType(ast.receiver);\n       symbol = receiverType && receiverType.members().get(ast.name);"
        }
    ],
    "stats": {
        "total": 1233,
        "additions": 442,
        "deletions": 791
    }
}