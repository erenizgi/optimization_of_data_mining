{
    "author": "JoostK",
    "message": "refactor(compiler-cli): use TypeScript transform to emit type parameters (#42492)\n\nThe template type checker is capable of recreating generic type bounds\nin a different context, rewriting type references along the way (if\npossible). This was previously done using a visitor that only supported\na limited set of types, resulting in the inability to emit all sorts of\ntypes (even if they don't contain type references at all).\n\nThe inability to emit generic type bounds was not critical when the type\nparameter emitting logic was introduced, as the compiler also has a\nfallback strategy of creating inline type constructors. However, this\nfallback is not available to the language service, resulting in\ninaccurate types when components/directives use a complex generic type.\n\nTo mitigate this problem, the specialized visitor has been replaced with\na generalized TypeScript transform, where only type references get\nspecial treatment. This allows for more complex types to be emitted,\nsuch as union and intersection types, object literal types and tuple\ntypes.\n\nPR Close #42492",
    "sha": "16aaa23d4e172d1450a1a46c5ff7517dcaf19800",
    "files": [
        {
            "sha": "6bc966b411940e81e08932b97765c5a834e3ae28",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_emitter.ts",
            "status": "modified",
            "additions": 38,
            "deletions": 53,
            "changes": 91,
            "blob_url": "https://github.com/angular/angular/blob/16aaa23d4e172d1450a1a46c5ff7517dcaf19800/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_emitter.ts",
            "raw_url": "https://github.com/angular/angular/raw/16aaa23d4e172d1450a1a46c5ff7517dcaf19800/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_emitter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_emitter.ts?ref=16aaa23d4e172d1450a1a46c5ff7517dcaf19800",
            "patch": "@@ -20,6 +20,15 @@ export type ResolvedTypeReference = Reference|ts.TypeReferenceNode|null;\n  */\n export type TypeReferenceResolver = (type: ts.TypeReferenceNode) => ResolvedTypeReference;\n \n+/**\n+ * A marker to indicate that a type reference is ineligible for emitting. This needs to be truthy\n+ * as it's returned from `ts.forEachChild`, which only returns truthy values.\n+ */\n+type INELIGIBLE = {\n+  __brand: 'ineligible';\n+};\n+const INELIGIBLE: INELIGIBLE = {} as INELIGIBLE;\n+\n /**\n  * Determines whether the provided type can be emitted, which means that it can be safely emitted\n  * into a different location.\n@@ -32,13 +41,24 @@ export function canEmitType(type: ts.TypeNode, resolver: TypeReferenceResolver):\n   return canEmitTypeWorker(type);\n \n   function canEmitTypeWorker(type: ts.TypeNode): boolean {\n-    return visitTypeNode(type, {\n-      visitTypeReferenceNode: type => canEmitTypeReference(type),\n-      visitArrayTypeNode: type => canEmitTypeWorker(type.elementType),\n-      visitKeywordType: () => true,\n-      visitLiteralType: () => true,\n-      visitOtherType: () => false,\n-    });\n+    return visitNode(type) !== INELIGIBLE;\n+  }\n+\n+  // To determine whether a type can be emitted, we have to recursively look through all type nodes.\n+  // If a type reference node is found at any position within the type and that type reference\n+  // cannot be emitted, then the `INELIGIBLE` constant is returned to stop the recursive walk as\n+  // the type as a whole cannot be emitted in that case. Otherwise, the result of visiting all child\n+  // nodes determines the result. If no ineligible type reference node is found then the walk\n+  // returns `undefined`, indicating that no type node was visited that could not be emitted.\n+  function visitNode(node: ts.Node): INELIGIBLE|undefined {\n+    // Emitting a type reference node in a different context requires that an import for the type\n+    // can be created. If a type reference node cannot be emitted, `INELIGIBLE` is returned to stop\n+    // the walk.\n+    if (ts.isTypeReferenceNode(node) && !canEmitTypeReference(node)) {\n+      return INELIGIBLE;\n+    } else {\n+      return ts.forEachChild(node, visitNode);\n+    }\n   }\n \n   function canEmitTypeReference(type: ts.TypeReferenceNode): boolean {\n@@ -108,15 +128,17 @@ export class TypeEmitter {\n   }\n \n   emitType(type: ts.TypeNode): ts.TypeNode {\n-    return visitTypeNode(type, {\n-      visitTypeReferenceNode: type => this.emitTypeReference(type),\n-      visitArrayTypeNode: type => ts.updateArrayTypeNode(type, this.emitType(type.elementType)),\n-      visitKeywordType: type => type,\n-      visitLiteralType: type => type,\n-      visitOtherType: () => {\n-        throw new Error('Unable to emit a complex type');\n-      },\n-    });\n+    const typeReferenceTransformer: ts.TransformerFactory<ts.TypeNode> = context => {\n+      const visitNode = (node: ts.Node): ts.Node => {\n+        if (ts.isTypeReferenceNode(node)) {\n+          return this.emitTypeReference(node);\n+        } else {\n+          return ts.visitEachChild(node, visitNode, context);\n+        }\n+      };\n+      return node => ts.visitNode(node, visitNode);\n+    };\n+    return ts.transform(type, [typeReferenceTransformer]).transformed[0];\n   }\n \n   private emitTypeReference(type: ts.TypeReferenceNode): ts.TypeNode {\n@@ -151,40 +173,3 @@ export class TypeEmitter {\n     return ts.updateTypeReferenceNode(type, typeName, typeArguments);\n   }\n }\n-\n-/**\n- * Visitor interface that allows for unified recognition of the different types of `ts.TypeNode`s,\n- * so that `visitTypeNode` is a centralized piece of recognition logic to be used in both\n- * `canEmitType` and `TypeEmitter`.\n- */\n-interface TypeEmitterVisitor<R> {\n-  visitTypeReferenceNode(type: ts.TypeReferenceNode): R;\n-  visitArrayTypeNode(type: ts.ArrayTypeNode): R;\n-  visitKeywordType(type: ts.KeywordTypeNode): R;\n-  visitLiteralType(type: ts.LiteralTypeNode): R;\n-  visitOtherType(type: ts.TypeNode): R;\n-}\n-\n-function visitTypeNode<R>(type: ts.TypeNode, visitor: TypeEmitterVisitor<R>): R {\n-  if (ts.isTypeReferenceNode(type)) {\n-    return visitor.visitTypeReferenceNode(type);\n-  } else if (ts.isArrayTypeNode(type)) {\n-    return visitor.visitArrayTypeNode(type);\n-  } else if (ts.isLiteralTypeNode(type)) {\n-    return visitor.visitLiteralType(type);\n-  }\n-\n-  switch (type.kind) {\n-    case ts.SyntaxKind.AnyKeyword:\n-    case ts.SyntaxKind.UnknownKeyword:\n-    case ts.SyntaxKind.NumberKeyword:\n-    case ts.SyntaxKind.ObjectKeyword:\n-    case ts.SyntaxKind.BooleanKeyword:\n-    case ts.SyntaxKind.StringKeyword:\n-    case ts.SyntaxKind.UndefinedKeyword:\n-    case ts.SyntaxKind.NullKeyword:\n-      return visitor.visitKeywordType(type as ts.KeywordTypeNode);\n-    default:\n-      return visitor.visitOtherType(type);\n-  }\n-}"
        },
        {
            "sha": "03d2b15b094fc0614084156166a5a190567abbfe",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_parameter_emitter_spec.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 2,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/16aaa23d4e172d1450a1a46c5ff7517dcaf19800/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_parameter_emitter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/16aaa23d4e172d1450a1a46c5ff7517dcaf19800/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_parameter_emitter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_parameter_emitter_spec.ts?ref=16aaa23d4e172d1450a1a46c5ff7517dcaf19800",
            "patch": "@@ -33,16 +33,21 @@ runInEachFileSystem(() => {\n     }\n \n     function emit(emitter: TypeParameterEmitter) {\n+      const canEmit = emitter.canEmit();\n       const emitted = emitter.emit(ref => {\n         const typeName = ts.createQualifiedName(ts.createIdentifier('test'), ref.debugName!);\n         return ts.createTypeReferenceNode(typeName, /* typeArguments */ undefined);\n       });\n \n       if (emitted === undefined) {\n-        return '';\n+        return canEmit ? '' : null;\n       }\n \n-      const printer = ts.createPrinter();\n+      if (!canEmit) {\n+        fail('canEmit must be true when emitting succeeds');\n+      }\n+\n+      const printer = ts.createPrinter({newLine: ts.NewLineKind.LineFeed});\n       const sf = ts.createSourceFile('test.ts', '', ts.ScriptTarget.Latest);\n       const generics =\n           emitted.map(param => printer.printNode(ts.EmitHint.Unspecified, param, sf)).join(', ');\n@@ -71,6 +76,14 @@ runInEachFileSystem(() => {\n           .toEqual('<T extends undefined>');\n       expect(emit(createEmitter(`export class TestClass<T extends string[]> {}`)))\n           .toEqual('<T extends string[]>');\n+      expect(emit(createEmitter(`export class TestClass<T extends [string, boolean]> {}`)))\n+          .toEqual('<T extends [\\n    string,\\n    boolean\\n]>');\n+      expect(emit(createEmitter(`export class TestClass<T extends string | boolean> {}`)))\n+          .toEqual('<T extends string | boolean>');\n+      expect(emit(createEmitter(`export class TestClass<T extends string & boolean> {}`)))\n+          .toEqual('<T extends string & boolean>');\n+      expect(emit(createEmitter(`export class TestClass<T extends { [key: string]: boolean }> {}`)))\n+          .toEqual('<T extends {\\n    [key: string]: boolean;\\n}>');\n     });\n \n     it('can emit references into external modules', () => {"
        }
    ],
    "stats": {
        "total": 108,
        "additions": 53,
        "deletions": 55
    }
}