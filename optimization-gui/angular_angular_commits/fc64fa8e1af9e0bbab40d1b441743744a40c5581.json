{
    "author": "thePunderWoman",
    "message": "Revert \"fix(compiler): support multiple `:host-context()` selectors (#40494)\" (#40531)\n\nThis reverts commit 07b7af332f164ab150f4b7150e580591c92ca9d5.\n\nReason for revert: Google3 failures\n\nPR Close #40531",
    "sha": "fc64fa8e1af9e0bbab40d1b441743744a40c5581",
    "files": [
        {
            "sha": "5fe6ecb8a871712aeecd96d7f89fb6d87bfef4db",
            "filename": "packages/compiler/src/shadow_css.ts",
            "status": "modified",
            "additions": 35,
            "deletions": 86,
            "changes": 121,
            "blob_url": "https://github.com/angular/angular/blob/fc64fa8e1af9e0bbab40d1b441743744a40c5581/packages%2Fcompiler%2Fsrc%2Fshadow_css.ts",
            "raw_url": "https://github.com/angular/angular/raw/fc64fa8e1af9e0bbab40d1b441743744a40c5581/packages%2Fcompiler%2Fsrc%2Fshadow_css.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fshadow_css.ts?ref=fc64fa8e1af9e0bbab40d1b441743744a40c5581",
            "patch": "@@ -260,29 +260,15 @@ export class ShadowCss {\n    * .foo<scopeName> > .bar\n    */\n   private _convertColonHost(cssText: string): string {\n-    return cssText.replace(_cssColonHostRe, (_, hostSelectors: string, otherSelectors: string) => {\n-      if (hostSelectors) {\n-        const convertedSelectors: string[] = [];\n-        const hostSelectorArray = hostSelectors.split(',').map(p => p.trim());\n-        for (const hostSelector of hostSelectorArray) {\n-          if (!hostSelector) break;\n-          const convertedSelector =\n-              _polyfillHostNoCombinator + hostSelector.replace(_polyfillHost, '') + otherSelectors;\n-          convertedSelectors.push(convertedSelector);\n-        }\n-        return convertedSelectors.join(',');\n-      } else {\n-        return _polyfillHostNoCombinator + otherSelectors;\n-      }\n-    });\n+    return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);\n   }\n \n   /*\n    * convert a rule like :host-context(.foo) > .bar { }\n    *\n    * to\n    *\n-   * .foo<scopeName> > .bar, .foo <scopeName> > .bar { }\n+   * .foo<scopeName> > .bar, .foo scopeName > .bar { }\n    *\n    * and\n    *\n@@ -293,28 +279,40 @@ export class ShadowCss {\n    * .foo<scopeName> .bar { ... }\n    */\n   private _convertColonHostContext(cssText: string): string {\n-    return cssText.replace(_cssColonHostContextReGlobal, selectorText => {\n-      // We have captured a selector that contains a `:host-context` rule.\n-      // There may be more than one so `selectorText` could look like:\n-      // `:host-context(.one):host-context(.two)`.\n-\n-      const contextSelectors: string[] = [];\n-      let match: RegExpMatchArray|null;\n-\n-      // Execute `_cssColonHostContextRe` over and over until we have extracted all the\n-      // `:host-context` selectors from this selector.\n-      while (match = _cssColonHostContextRe.exec(selectorText)) {\n-        // `match` = [':host-context(<selectors>)<rest>', <selectors>, <rest>]\n-        contextSelectors.push(match[1].trim());\n-        selectorText = match[2];\n-      }\n+    return this._convertColonRule(\n+        cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);\n+  }\n \n-      // The context selectors now must be combined with each other to capture all the possible\n-      // selectors that `:host-context` can match.\n-      return combineHostContextSelectors(_polyfillHostNoCombinator, contextSelectors, selectorText);\n+  private _convertColonRule(cssText: string, regExp: RegExp, partReplacer: Function): string {\n+    // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule\n+    return cssText.replace(regExp, function(...m: string[]) {\n+      if (m[2]) {\n+        const parts = m[2].split(',');\n+        const r: string[] = [];\n+        for (let i = 0; i < parts.length; i++) {\n+          const p = parts[i].trim();\n+          if (!p) break;\n+          r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));\n+        }\n+        return r.join(',');\n+      } else {\n+        return _polyfillHostNoCombinator + m[3];\n+      }\n     });\n   }\n \n+  private _colonHostContextPartReplacer(host: string, part: string, suffix: string): string {\n+    if (part.indexOf(_polyfillHost) > -1) {\n+      return this._colonHostPartReplacer(host, part, suffix);\n+    } else {\n+      return host + part + suffix + ', ' + part + ' ' + host + suffix;\n+    }\n+  }\n+\n+  private _colonHostPartReplacer(host: string, part: string, suffix: string): string {\n+    return host + part.replace(_polyfillHost, '') + suffix;\n+  }\n+\n   /*\n    * Convert combinators like ::shadow and pseudo-elements like ::content\n    * by replacing with space.\n@@ -536,12 +534,11 @@ const _cssContentUnscopedRuleRe =\n const _polyfillHost = '-shadowcsshost';\n // note: :host-context pre-processed to -shadowcsshostcontext.\n const _polyfillHostContext = '-shadowcsscontext';\n-const _parenSuffix = '(?:\\\\((' +\n+const _parenSuffix = ')(?:\\\\((' +\n     '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n     ')\\\\))?([^,{]*)';\n-const _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix, 'gim');\n-const _cssColonHostContextReGlobal = new RegExp(_polyfillHostContext + _parenSuffix, 'gim');\n-const _cssColonHostContextRe = new RegExp(_polyfillHostContext + _parenSuffix, 'im');\n+const _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');\n+const _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');\n const _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\n const _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\n const _shadowDOMSelectorsRe = [\n@@ -653,51 +650,3 @@ function escapeBlocks(\n   }\n   return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n }\n-\n-/**\n- * Combine the `contextSelectors` with the `hostMarker` and the `otherSelectors`\n- * to create a selector that matches the same as `:host-context()`.\n- *\n- * Given a single context selector `A` we need to output selectors that match on the host and as an\n- * ancestor of the host:\n- *\n- * ```\n- * A <hostMarker>, A<hostMarker> {}\n- * ```\n- *\n- * When there is more than one context selector we also have to create combinations of those\n- * selectors with each other. For example if there are `A` and `B` selectors the output is:\n- *\n- * ```\n- * AB<hostMarker>, AB <hostMarker>, A B<hostMarker>,\n- * B A<hostMarker>, A B <hostMarker>, B A <hostMarker> {}\n- * ```\n- *\n- * And so on...\n- *\n- * @param hostMarker the string that selects the host element.\n- * @param contextSelectors an array of context selectors that will be combined.\n- * @param otherSelectors the rest of the selectors that are not context selectors.\n- */\n-function combineHostContextSelectors(\n-    hostMarker: string, contextSelectors: string[], otherSelectors: string): string {\n-  const combined: string[] = [contextSelectors.pop() || ''];\n-  while (contextSelectors.length > 0) {\n-    const length = combined.length;\n-    const contextSelector = contextSelectors.pop();\n-    for (let i = 0; i < length; i++) {\n-      const previousSelectors = combined[i];\n-      // Add the new selector as a descendant of the previous selectors\n-      combined[length * 2 + i] = previousSelectors + ' ' + contextSelector;\n-      // Add the new selector as an ancestor of the previous selectors\n-      combined[length + i] = contextSelector + ' ' + previousSelectors;\n-      // Add the new selector to act on the same element as the previous selectors\n-      combined[i] = contextSelector + previousSelectors;\n-    }\n-  }\n-  // Finally connect the selector to the `hostMarker`s: either acting directly on the host\n-  // (A<hostMarker>) or as an ancestor (A <hostMarker>).\n-  return combined\n-      .map(s => `${s}${hostMarker}${otherSelectors}, ${s} ${hostMarker}${otherSelectors}`)\n-      .join(',');\n-}"
        },
        {
            "sha": "5b9ba518813bda03fbffbc066514ab73d325876c",
            "filename": "packages/compiler/test/shadow_css_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 40,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/fc64fa8e1af9e0bbab40d1b441743744a40c5581/packages%2Fcompiler%2Ftest%2Fshadow_css_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fc64fa8e1af9e0bbab40d1b441743744a40c5581/packages%2Fcompiler%2Ftest%2Fshadow_css_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fshadow_css_spec.ts?ref=fc64fa8e1af9e0bbab40d1b441743744a40c5581",
            "patch": "@@ -145,10 +145,6 @@ import {normalizeCSS} from '@angular/platform-browser/testing/src/browser_util';\n             .toEqual('ul[a-host] > .z[contenta], li[a-host] > .z[contenta] {}');\n       });\n \n-      it('should handle compound class selectors', () => {\n-        expect(s(':host(.a.b) {}', 'contenta', 'a-host')).toEqual('.a.b[a-host] {}');\n-      });\n-\n       it('should handle multiple class selectors', () => {\n         expect(s(':host(.x,.y) {}', 'contenta', 'a-host')).toEqual('.x[a-host], .y[a-host] {}');\n         expect(s(':host(.x,.y) > .z {}', 'contenta', 'a-host'))\n@@ -212,42 +208,6 @@ import {normalizeCSS} from '@angular/platform-browser/testing/src/browser_util';\n         expect(s(':host-context([a=b]) {}', 'contenta', 'a-host'))\n             .toEqual('[a=b][a-host], [a=\"b\"] [a-host] {}');\n       });\n-\n-      it('should handle multiple :host-context() selectors', () => {\n-        expect(s(':host-context(.one):host-context(.two) {}', 'contenta', 'a-host'))\n-            .toEqual(\n-                '.one.two[a-host], ' +    // `one` and `two` both on the host\n-                '.one.two [a-host], ' +   // `one` and `two` are both on the same ancestor\n-                '.one .two[a-host], ' +   // `one` is an ancestor and `two` is on the host\n-                '.one .two [a-host], ' +  // `one` and `two` are both ancestors (in that order)\n-                '.two .one[a-host], ' +   // `two` is an ancestor and `one` is on the host\n-                '.two .one [a-host]' +    // `two` and `one` are both ancestors (in that order)\n-                ' {}');\n-\n-        expect(s(':host-context(.X):host-context(.Y):host-context(.Z) {}', 'contenta', 'a-host')\n-                   .replace(/ \\{\\}$/, '')\n-                   .split(/\\,\\s+/))\n-            .toEqual([\n-              '.X.Y.Z[a-host]',\n-              '.X.Y.Z [a-host]',\n-              '.X.Y .Z[a-host]',\n-              '.X.Y .Z [a-host]',\n-              '.X.Z .Y[a-host]',\n-              '.X.Z .Y [a-host]',\n-              '.X .Y.Z[a-host]',\n-              '.X .Y.Z [a-host]',\n-              '.X .Y .Z[a-host]',\n-              '.X .Y .Z [a-host]',\n-              '.X .Z .Y[a-host]',\n-              '.X .Z .Y [a-host]',\n-              '.Y.Z .X[a-host]',\n-              '.Y.Z .X [a-host]',\n-              '.Y .Z .X[a-host]',\n-              '.Y .Z .X [a-host]',\n-              '.Z .Y .X[a-host]',\n-              '.Z .Y .X [a-host]',\n-            ]);\n-      });\n     });\n \n     it('should support polyfill-next-selector', () => {"
        }
    ],
    "stats": {
        "total": 161,
        "additions": 35,
        "deletions": 126
    }
}