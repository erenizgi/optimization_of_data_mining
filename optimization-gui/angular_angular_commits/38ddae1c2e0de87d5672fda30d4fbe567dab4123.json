{
    "author": "dario-piotrowicz",
    "message": "fix(animations): don't consume instructions for animateChild (#44357)\n\nTODO: Fill body commit if PR gets accepted\n\nresolves #41483\nresolves #30693\n\nPR Close #44357",
    "sha": "38ddae1c2e0de87d5672fda30d4fbe567dab4123",
    "files": [
        {
            "sha": "738529e65751a099816f8c1f67a530d48a77e37e",
            "filename": "packages/animations/browser/src/dsl/animation_timeline_builder.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/38ddae1c2e0de87d5672fda30d4fbe567dab4123/packages%2Fanimations%2Fbrowser%2Fsrc%2Fdsl%2Fanimation_timeline_builder.ts",
            "raw_url": "https://github.com/angular/angular/raw/38ddae1c2e0de87d5672fda30d4fbe567dab4123/packages%2Fanimations%2Fbrowser%2Fsrc%2Fdsl%2Fanimation_timeline_builder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fanimations%2Fbrowser%2Fsrc%2Fdsl%2Fanimation_timeline_builder.ts?ref=38ddae1c2e0de87d5672fda30d4fbe567dab4123",
            "patch": "@@ -154,7 +154,7 @@ export class AnimationTimelineBuilderVisitor implements AstVisitor {\n   }\n \n   visitAnimateChild(ast: AnimateChildAst, context: AnimationTimelineContext): any {\n-    const elementInstructions = context.subInstructions.consume(context.element);\n+    const elementInstructions = context.subInstructions.get(context.element);\n     if (elementInstructions) {\n       const innerContext = context.createSubContext(ast.options);\n       const startTime = context.currentTimeline.currentTime;"
        },
        {
            "sha": "25f38bcbea43120996c6e9b7ce37acc9208b38cc",
            "filename": "packages/animations/browser/src/dsl/element_instruction_map.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 8,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/38ddae1c2e0de87d5672fda30d4fbe567dab4123/packages%2Fanimations%2Fbrowser%2Fsrc%2Fdsl%2Felement_instruction_map.ts",
            "raw_url": "https://github.com/angular/angular/raw/38ddae1c2e0de87d5672fda30d4fbe567dab4123/packages%2Fanimations%2Fbrowser%2Fsrc%2Fdsl%2Felement_instruction_map.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fanimations%2Fbrowser%2Fsrc%2Fdsl%2Felement_instruction_map.ts?ref=38ddae1c2e0de87d5672fda30d4fbe567dab4123",
            "patch": "@@ -10,14 +10,8 @@ import {AnimationTimelineInstruction} from './animation_timeline_instruction';\n export class ElementInstructionMap {\n   private _map = new Map<any, AnimationTimelineInstruction[]>();\n \n-  consume(element: any): AnimationTimelineInstruction[] {\n-    let instructions = this._map.get(element);\n-    if (instructions) {\n-      this._map.delete(element);\n-    } else {\n-      instructions = [];\n-    }\n-    return instructions;\n+  get(element: any): AnimationTimelineInstruction[] {\n+    return this._map.get(element) || [];\n   }\n \n   append(element: any, instructions: AnimationTimelineInstruction[]) {"
        },
        {
            "sha": "22ebf519403a7b00750eb8677cf9269c086212dc",
            "filename": "packages/core/test/animation/animation_integration_spec.ts",
            "status": "modified",
            "additions": 43,
            "deletions": 24,
            "changes": 67,
            "blob_url": "https://github.com/angular/angular/blob/38ddae1c2e0de87d5672fda30d4fbe567dab4123/packages%2Fcore%2Ftest%2Fanimation%2Fanimation_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/38ddae1c2e0de87d5672fda30d4fbe567dab4123/packages%2Fcore%2Ftest%2Fanimation%2Fanimation_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fanimation%2Fanimation_integration_spec.ts?ref=38ddae1c2e0de87d5672fda30d4fbe567dab4123",
            "patch": "@@ -979,9 +979,9 @@ describe('animation tests', function() {\n            expect(fixture.nativeElement.children.length).toBe(1);\n \n            engine.flush();\n-           expect(getLog().length).toBe(1);\n+           expect(getLog().length).toBe(2);\n \n-           const player = getLog()[0];\n+           const player = getLog()[1];\n            expect(player.keyframes).toEqual([\n              {opacity: '1', offset: 0},\n              {opacity: '0', offset: 1},\n@@ -3007,18 +3007,25 @@ describe('animation tests', function() {\n          cmp.log = [];\n \n          const players = getLog();\n-         expect(players.length).toEqual(3);\n-         const [p1, p2, p3] = players;\n+         expect(players.length).toEqual(4);\n \n-         p1.finish();\n+         // players:\n+         //  - _scp (skipped child player): player for the child animation\n+         //  - pp1 (parent player 1): player for parent animation (from 0px to 100px)\n+         //  - pcp (parent child player):\n+         //     player for child animation executed by parent via query and animateChild\n+         //  - pp2 (parent player 2): player for parent animation (from 100px to 0px)\n+         const [_scp, pp1, pcp, pp2] = players;\n+\n+         pp1.finish();\n          flushMicrotasks();\n          expect(cmp.log).toEqual([]);\n \n-         p2.finish();\n+         pcp.finish();\n          flushMicrotasks();\n          expect(cmp.log).toEqual([]);\n \n-         p3.finish();\n+         pp2.finish();\n          flushMicrotasks();\n          expect(cmp.log).toEqual(['parent-done', 'child-done']);\n        }));\n@@ -3080,33 +3087,45 @@ describe('animation tests', function() {\n          cmp.log = [];\n \n          const players = getLog();\n-         // 1 + 4 + 4 = 9 players\n-         expect(players.length).toEqual(9);\n-\n-         const [pA, pq1a, pq1b, pq1c, pq1d, pq2a, pq2b, pq2c, pq2d] = getLog();\n-         pA.finish();\n-         pq1a.finish();\n-         pq1b.finish();\n-         pq1c.finish();\n-         pq1d.finish();\n+         expect(players.length).toEqual(13);\n+\n+         // players:\n+         //  - _sc1p, _sc2p, _sc3p, _sc4p (skipped child n (1 to 4) players):\n+         //     players for the children animations\n+         //  - pp1 (parent player 1): player for parent animation (from opacity 0 to opacity 1)\n+         //  - pc1p1, pc2p1, pc3p1, pc4p1 (parent child n (1 to 4) player 1):\n+         //     players for children animations executed by parent via query and animate\n+         //     (from opacity 0 to opacity 1)\n+         //  - pc1p2, pc2p2, pc3p2, pc4p2 (parent child n (1 to 4) player 2):\n+         //     players for children animations executed by parent via query and animateChild\n+         const [_sc1p, _sc2p, _sc3p, _sc4p, pp1, pc1p1, pc2p1, pc3p1, pc4p1, pc1p2, pc2p2, pc3p2, pc4p2] =\n+             getLog();\n+         pp1.finish();\n+         pc1p1.finish();\n+         pc2p1.finish();\n+         pc3p1.finish();\n+         pc4p1.finish();\n          flushMicrotasks();\n \n          expect(cmp.log).toEqual([]);\n-         pq2a.finish();\n-         pq2b.finish();\n-         pq2c.finish();\n-         pq2d.finish();\n+         pc1p2.finish();\n+         pc2p2.finish();\n+         pc3p2.finish();\n+         pc4p2.finish();\n          flushMicrotasks();\n \n          expect(cmp.log).toEqual(['all-done', 'c-0-done', 'c-1-done', 'c-2-done', 'c-3-done']);\n \n-         expect(cmp.events['c-0'].totalTime).toEqual(4100);  // 1000 + 1000 + 1800 + 300\n+         expect(cmp.events['all'].totalTime).toEqual(4100);  // 1000 + 1000 + 1800 + 300\n+         expect(cmp.events['all'].element.innerText.trim().replaceAll('\\n', ' '))\n+             .toEqual('0 1 2 3');\n+         expect(cmp.events['c-0'].totalTime).toEqual(1500);\n          expect(cmp.events['c-0'].element.innerText.trim()).toEqual('0');\n-         expect(cmp.events['c-1'].totalTime).toEqual(4100);\n+         expect(cmp.events['c-1'].totalTime).toEqual(1500);\n          expect(cmp.events['c-1'].element.innerText.trim()).toEqual('1');\n-         expect(cmp.events['c-2'].totalTime).toEqual(4100);\n+         expect(cmp.events['c-2'].totalTime).toEqual(1500);\n          expect(cmp.events['c-2'].element.innerText.trim()).toEqual('2');\n-         expect(cmp.events['c-3'].totalTime).toEqual(4100);\n+         expect(cmp.events['c-3'].totalTime).toEqual(1500);\n          expect(cmp.events['c-3'].element.innerText.trim()).toEqual('3');\n        }));\n   });"
        },
        {
            "sha": "3829f6bac3a35117847ef97bf765c6c333f79e43",
            "filename": "packages/core/test/animation/animation_query_integration_spec.ts",
            "status": "modified",
            "additions": 150,
            "deletions": 80,
            "changes": 230,
            "blob_url": "https://github.com/angular/angular/blob/38ddae1c2e0de87d5672fda30d4fbe567dab4123/packages%2Fcore%2Ftest%2Fanimation%2Fanimation_query_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/38ddae1c2e0de87d5672fda30d4fbe567dab4123/packages%2Fcore%2Ftest%2Fanimation%2Fanimation_query_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fanimation%2Fanimation_query_integration_spec.ts?ref=38ddae1c2e0de87d5672fda30d4fbe567dab4123",
            "patch": "@@ -782,8 +782,8 @@ describe('animation query tests', function() {\n       engine.flush();\n \n       const players = getLog();\n-      expect(players.length).toEqual(1);\n-      const player = players[0];\n+      expect(players.length).toEqual(2);\n+      const player = players[1];\n \n       expect(player.keyframes).toEqual([{height: '0px', offset: 0}, {height: '444px', offset: 1}]);\n       player.finish();\n@@ -1868,16 +1868,23 @@ describe('animation query tests', function() {\n       const elm1 = cmp.elm1;\n       const elm2 = cmp.elm2;\n \n-      const [p1, p2] = getLog();\n-      expect(p1.delay).toEqual(0);\n-      expect(p1.element).toEqual(elm1.nativeElement);\n-      expect(p1.duration).toEqual(1000);\n-      expect(p1.keyframes).toEqual([{width: '0px', offset: 0}, {width: '100px', offset: 1}]);\n+      const players = getLog();\n \n-      expect(p2.delay).toEqual(0);\n-      expect(p2.element).toEqual(elm2.nativeElement);\n-      expect(p2.duration).toEqual(2000);\n-      expect(p2.keyframes).toEqual([\n+      // players:\n+      //  - _scp (skipped child player): player for the child animation\n+      //  - pp (parent player): player for parent animation (from 0px to 100px)\n+      //  - pcp (parent child player):\n+      //      player for child animation executed by parent via query and animateChild\n+      const [_scp, pp, pcp] = players;\n+      expect(pp.delay).toEqual(0);\n+      expect(pp.element).toEqual(elm1.nativeElement);\n+      expect(pp.duration).toEqual(1000);\n+      expect(pp.keyframes).toEqual([{width: '0px', offset: 0}, {width: '100px', offset: 1}]);\n+\n+      expect(pcp.delay).toEqual(0);\n+      expect(pcp.element).toEqual(elm2.nativeElement);\n+      expect(pcp.duration).toEqual(2000);\n+      expect(pcp.keyframes).toEqual([\n         {height: '0px', offset: 0}, {height: '0px', offset: .5}, {height: '100px', offset: 1}\n       ]);\n     });\n@@ -1928,36 +1935,45 @@ describe('animation query tests', function() {\n          const elements = parent.querySelectorAll('.item');\n \n          const players = getLog();\n-         expect(players.length).toEqual(7);\n-         const [pA, pc1, pc2, pc3, pc4, pc5, pZ] = players;\n-\n-         expect(pA.element).toEqual(parent);\n-         expect(pA.delay).toEqual(0);\n-         expect(pA.duration).toEqual(1000);\n-\n-         expect(pc1.element).toEqual(elements[0]);\n-         expect(pc1.delay).toEqual(0);\n-         expect(pc1.duration).toEqual(4000);\n-\n-         expect(pc2.element).toEqual(elements[1]);\n-         expect(pc2.delay).toEqual(0);\n-         expect(pc2.duration).toEqual(4000);\n-\n-         expect(pc3.element).toEqual(elements[2]);\n-         expect(pc3.delay).toEqual(0);\n-         expect(pc3.duration).toEqual(4000);\n-\n-         expect(pc4.element).toEqual(elements[3]);\n-         expect(pc4.delay).toEqual(0);\n-         expect(pc4.duration).toEqual(4000);\n-\n-         expect(pc5.element).toEqual(elements[4]);\n-         expect(pc5.delay).toEqual(0);\n-         expect(pc5.duration).toEqual(4000);\n-\n-         expect(pZ.element).toEqual(parent);\n-         expect(pZ.delay).toEqual(4000);\n-         expect(pZ.duration).toEqual(1000);\n+         expect(players.length).toEqual(12);\n+\n+         // players:\n+         //  - _sc1p, _sc2p, _sc3p, _sc4p (skipped child n (1 to 4) players):\n+         //     players for the children animations\n+         //  - pp1 (parent player 1): player for parent animation (from opacity 0 to opacity 1)\n+         //  - pc1p, pc2p, pc3p, pc4p, pc5p  (parent child n (1 to 4) player):\n+         //     players for children animations executed by parent via query and animateChild\n+         //  - pp2 (parent player 2): player for parent animation (from opacity 1 to opacity 0)\n+         const [_sc1p, _sc2p, _sc3p, _sc4p, _sc5p, pp1, pc1p, pc2p, pc3p, pc4p, pc5p, pp2] =\n+             players;\n+\n+         expect(pp1.element).toEqual(parent);\n+         expect(pp1.delay).toEqual(0);\n+         expect(pp1.duration).toEqual(1000);\n+\n+         expect(pc1p.element).toEqual(elements[0]);\n+         expect(pc1p.delay).toEqual(0);\n+         expect(pc1p.duration).toEqual(4000);\n+\n+         expect(pc2p.element).toEqual(elements[1]);\n+         expect(pc2p.delay).toEqual(0);\n+         expect(pc2p.duration).toEqual(4000);\n+\n+         expect(pc3p.element).toEqual(elements[2]);\n+         expect(pc3p.delay).toEqual(0);\n+         expect(pc3p.duration).toEqual(4000);\n+\n+         expect(pc4p.element).toEqual(elements[3]);\n+         expect(pc4p.delay).toEqual(0);\n+         expect(pc4p.duration).toEqual(4000);\n+\n+         expect(pc5p.element).toEqual(elements[4]);\n+         expect(pc5p.delay).toEqual(0);\n+         expect(pc5p.duration).toEqual(4000);\n+\n+         expect(pp2.element).toEqual(parent);\n+         expect(pp2.delay).toEqual(4000);\n+         expect(pp2.duration).toEqual(1000);\n        });\n \n     it('should silently continue if a sub trigger is animated that doesn\\'t exist', () => {\n@@ -2110,17 +2126,27 @@ describe('animation query tests', function() {\n       engine.flush();\n \n       const players = getLog();\n-      expect(players.length).toEqual(4);\n-      const [pA, pc1, pc2, pZ] = players;\n-\n-      expect(pc1.delay).toEqual(0);\n-      expect(pc1.duration).toEqual(2800);\n-\n-      expect(pc2.delay).toEqual(0);\n-      expect(pc2.duration).toEqual(2500);\n+      expect(players.length).toEqual(6);\n \n-      expect(pZ.delay).toEqual(2800);\n-      expect(pZ.duration).toEqual(1000);\n+      // players:\n+      //  - _scwp (skipped child w player): player for the child animation (trigger w)\n+      //  - _schp (skipped child h player): player for the child animation (trigger h)\n+      //  - _pp1 (parent player 1): player for parent animation (from opacity 0 to opacity 1)\n+      //  - pcwp (parent child w player):\n+      //      player for child w animation executed by parent via query and animateChild\n+      //  - pchp (parent child h player):\n+      //      player for child w animation executed by parent via query and animateChild\n+      //  - pp2 (parent player 2): player for parent animation (from opacity 1 to opacity 0)\n+      const [_scwp, _schp, _pp1, pcwp, pchp, pp2] = players;\n+\n+      expect(pcwp.delay).toEqual(0);\n+      expect(pcwp.duration).toEqual(2800);\n+\n+      expect(pchp.delay).toEqual(0);\n+      expect(pchp.duration).toEqual(2500);\n+\n+      expect(pp2.delay).toEqual(2800);\n+      expect(pp2.duration).toEqual(1000);\n     });\n \n     it('should skip a sub animation when a zero duration value is passed in', () => {\n@@ -2163,14 +2189,21 @@ describe('animation query tests', function() {\n       engine.flush();\n \n       const players = getLog();\n-      expect(players.length).toEqual(2);\n-      const [pA, pZ] = players;\n+      expect(players.length).toEqual(3);\n \n-      expect(pA.delay).toEqual(0);\n-      expect(pA.duration).toEqual(1000);\n+      // players:\n+      //  - _scp (skipped child player): player for the child animation\n+      //  - pp1 (parent player 1): player for parent animation (from opacity 0 to opacity 1)\n+      //  - ( the player for the child animation executed by parent via query\n+      //      and animateChild is skipped entirely )\n+      //  - pp2 (parent player 2): player for parent animation (from opacity 1 to opacity 0)\n+      const [_scp, pp1, pp2] = players;\n \n-      expect(pZ.delay).toEqual(1000);\n-      expect(pZ.duration).toEqual(1000);\n+      expect(pp1.delay).toEqual(0);\n+      expect(pp1.duration).toEqual(1000);\n+\n+      expect(pp2.delay).toEqual(1000);\n+      expect(pp2.duration).toEqual(1000);\n     });\n \n     it('should only allow a sub animation to be used up by a parent trigger once', () => {\n@@ -2215,14 +2248,23 @@ describe('animation query tests', function() {\n       engine.flush();\n \n       const players = getLog();\n-      expect(players.length).toEqual(3);\n-\n-      const [p1, p2, p3] = players;\n+      expect(players.length).toEqual(5);\n \n-      // parent2 is evaluated first because it is inside of parent1\n-      expect(p1.element.classList.contains('parent2')).toBeTruthy();\n-      expect(p2.element.classList.contains('child')).toBeTruthy();\n-      expect(p3.element.classList.contains('parent1')).toBeTruthy();\n+      // players:\n+      //  - _scp (skipped child player): player for the child animation\n+      // (note: parent2 is evaluated first because it is inside of parent1)\n+      //  - p2p (parent 2 player): player for parent animation (from opacity 0 to opacity 1)\n+      //  - p2cp (parent 2 child player):\n+      //      player for child animation executed by parent 2 via query and animateChild\n+      //  - p1p (parent 1 player): player for parent animation (from opacity 0 to opacity 1)\n+      //  - p1cp (parent 1 child player):\n+      //      player for child animation executed by parent 1 via query and animateChild\n+      const [_scp, p2p, p2cp, p1p, p1cp] = players;\n+\n+      expect(p2p.element.classList.contains('parent2')).toBeTruthy();\n+      expect(p2cp.element.classList.contains('child')).toBeTruthy();\n+      expect(p1p.element.classList.contains('parent1')).toBeTruthy();\n+      expect(p1cp.element.classList.contains('child')).toBeTruthy();\n     });\n \n     it('should emulate a leave animation on the nearest sub host elements when a parent is removed',\n@@ -2363,11 +2405,16 @@ describe('animation query tests', function() {\n          fixture.detectChanges();\n \n          let players = getLog();\n-         expect(players.length).toEqual(1);\n-         const [player] = players;\n+         expect(players.length).toEqual(2);\n+\n+         // players:\n+         //  - _scp (skipped child player): player for the child animation\n+         //  - pcp (parent child player):\n+         //     player for child animation executed by parent via query and animateChild\n+         const [_scp, pcp] = players;\n \n-         expect(player.element.classList.contains('inner-div')).toBeTruthy();\n-         expect(player.keyframes).toEqual([\n+         expect(pcp.element.classList.contains('inner-div')).toBeTruthy();\n+         expect(pcp.keyframes).toEqual([\n            {opacity: '0', offset: 0},\n            {opacity: '1', offset: 1},\n          ]);\n@@ -3140,10 +3187,23 @@ describe('animation query tests', function() {\n          fixture.detectChanges();\n          engine.flush();\n          const players = getLog();\n-         expect(players.length).toEqual(5);\n-         const [p1, p2, p3, p4, p5] = players;\n-\n-         expect(p5.keyframes).toEqual([\n+         expect(players.length).toEqual(6);\n+\n+         // players:\n+         //  - _sgcp (skipped grand child player): player for the grand child animation\n+         //  - _psp (parent self player): player for parent self animation (opacity 0)\n+         //  - _pgcp1 (parent grand child player 1):\n+         //     player for child animation executed by parent via query (opacity 0)\n+         //  - _pp1 (parent player 1): player for parent animation (from opacity 0 to opacity 1)\n+         //  - _pgcp2 (parent grand child player 2):\n+         //     player for child animation executed by parent via query and animate\n+         //     (from opacity 0 to opacity 1)\n+         //  - pgcp3 (parent grand child player 3):\n+         //     player for child animation executed by parent via query and animateChild\n+         //     (from 0px to 200px)\n+         const [_sgcp, _psp, _pgcp1, _pp1, _pgcp2, pgcp3] = players;\n+\n+         expect(pgcp3.keyframes).toEqual([\n            {offset: 0, width: '0px'}, {offset: .67, width: '0px'}, {offset: 1, width: '200px'}\n          ]);\n        });\n@@ -3206,11 +3266,16 @@ describe('animation query tests', function() {\n       fixture.detectChanges();\n \n       const players = getLog();\n-      expect(players.length).toEqual(2);\n+      expect(players.length).toEqual(3);\n \n-      const [p1, p2] = players;\n-      expect(p1.element.classList.contains('container')).toBeTruthy();\n-      expect(p2.element.classList.contains('item')).toBeTruthy();\n+      // players:\n+      //  - _scp (skipped child player): player for the child animation\n+      //  - pp (parent player): player for parent animation (from opacity 0 to opacity 1)\n+      //  - pcp (parent child player):\n+      //      player for child animation executed by parent via query and animateChild\n+      const [_scp, pp, pcp] = players;\n+      expect(pp.element.classList.contains('container')).toBeTruthy();\n+      expect(pcp.element.classList.contains('item')).toBeTruthy();\n     });\n \n     it('should scope :leave queries between sub animations', () => {\n@@ -3272,11 +3337,16 @@ describe('animation query tests', function() {\n       fixture.detectChanges();\n \n       const players = getLog();\n-      expect(players.length).toEqual(2);\n+      expect(players.length).toEqual(3);\n \n-      const [p1, p2] = players;\n-      expect(p1.element.classList.contains('container')).toBeTruthy();\n-      expect(p2.element.classList.contains('item')).toBeTruthy();\n+      // players:\n+      //  - _scp (skipped child player): player for the child animation\n+      //  - pp (parent player): player for parent animation (from opacity 0 to opacity 1)\n+      //  - pcp (parent child player):\n+      //      player for child animation executed by parent via query and animateChild\n+      const [_scp, pp, pcp] = players;\n+      expect(pp.element.classList.contains('container')).toBeTruthy();\n+      expect(pcp.element.classList.contains('item')).toBeTruthy();\n     });\n   });\n "
        }
    ],
    "stats": {
        "total": 309,
        "additions": 196,
        "deletions": 113
    }
}