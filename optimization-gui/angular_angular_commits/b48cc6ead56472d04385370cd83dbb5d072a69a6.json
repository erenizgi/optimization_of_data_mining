{
    "author": "unknown",
    "message": "feat(language-service): introduce hybrid visitor to locate AST node (#38540)\n\nThis commit introduces two visitors, one for Template AST and the other\nfor Expression AST to allow us to easily find the node that most closely\ncorresponds to a given cursor position.\n\nThis is crucial because many language service APIs take in a `position`\nparameter, and the information returned depends on how well we can find\na good candidate node.\n\nIn View Engine implementation of language service, the search for the node\nand the processing of information to return the result are strongly coupled.\nThis makes the code hard to understand and hard to debug because the stack\ntrace is often littered with layers of visitor calls.\n\nWith this new feature, we could test the \"searching\" part separately and\ncolocate all the logic (aka hacks) that's required to retrieve an accurate\nspan for a given node.\n\nRight now, only the most \"narrow\" node is returned by the main exported\nfunction `findNodeAtPosition`. If needed, we could expose the entire AST\npath, or expose other methods to provide more context for a node.\n\nNote that due to limitations in the template AST interface, there are\na few known cases where microsyntax spans are not recorded properly.\nThis will be dealt with in a follow-up PR.\n\nPR Close #38540",
    "sha": "b48cc6ead56472d04385370cd83dbb5d072a69a6",
    "files": [
        {
            "sha": "e56ebed70bd47e7d6b3b9f29e9f082c681321cf3",
            "filename": "packages/language-service/ivy/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/b48cc6ead56472d04385370cd83dbb5d072a69a6/packages%2Flanguage-service%2Fivy%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/b48cc6ead56472d04385370cd83dbb5d072a69a6/packages%2Flanguage-service%2Fivy%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2FBUILD.bazel?ref=b48cc6ead56472d04385370cd83dbb5d072a69a6",
            "patch": "@@ -6,6 +6,7 @@ ts_library(\n     name = \"ivy\",\n     srcs = glob([\"*.ts\"]),\n     deps = [\n+        \"//packages/compiler\",\n         \"//packages/compiler-cli\",\n         \"//packages/compiler-cli/src/ngtsc/core\",\n         \"//packages/compiler-cli/src/ngtsc/core:api\","
        },
        {
            "sha": "234649533b5c752bb7f020b6cdcbb1142bc9e55f",
            "filename": "packages/language-service/ivy/hybrid_visitor.ts",
            "status": "added",
            "additions": 180,
            "deletions": 0,
            "changes": 180,
            "blob_url": "https://github.com/angular/angular/blob/b48cc6ead56472d04385370cd83dbb5d072a69a6/packages%2Flanguage-service%2Fivy%2Fhybrid_visitor.ts",
            "raw_url": "https://github.com/angular/angular/raw/b48cc6ead56472d04385370cd83dbb5d072a69a6/packages%2Flanguage-service%2Fivy%2Fhybrid_visitor.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fhybrid_visitor.ts?ref=b48cc6ead56472d04385370cd83dbb5d072a69a6",
            "patch": "@@ -0,0 +1,180 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {ParseSourceSpan} from '@angular/compiler';\n+import * as e from '@angular/compiler/src/expression_parser/ast';  // e for expression AST\n+import * as t from '@angular/compiler/src/render3/r3_ast';         // t for template AST\n+\n+/**\n+ * Return the template AST node or expression AST node that most accurately\n+ * represents the node at the specified cursor `position`.\n+ * @param ast AST tree\n+ * @param position cursor position\n+ */\n+export function findNodeAtPosition(ast: t.Node[], position: number): t.Node|e.AST|undefined {\n+  const visitor = new R3Visitor(position);\n+  visitor.visitAll(ast);\n+  return visitor.path[visitor.path.length - 1];\n+}\n+\n+class R3Visitor implements t.Visitor {\n+  // We need to keep a path instead of the last node because we might need more\n+  // context for the last node, for example what is the parent node?\n+  readonly path: Array<t.Node|e.AST> = [];\n+\n+  // Position must be absolute in the source file.\n+  constructor(private readonly position: number) {}\n+\n+  visit(node: t.Node) {\n+    const {start, end} = getSpanIncludingEndTag(node);\n+    // Note both start and end are inclusive because we want to match conditions\n+    // like ¦start and end¦ where ¦ is the cursor.\n+    if (start <= this.position && this.position <= end) {\n+      const length = end - start;\n+      const last: t.Node|e.AST|undefined = this.path[this.path.length - 1];\n+      if (last) {\n+        const {start, end} = isTemplateNode(last) ? getSpanIncludingEndTag(last) : last.sourceSpan;\n+        const lastLength = end - start;\n+        if (length > lastLength) {\n+          // The current node has a span that is larger than the last node found\n+          // so we do not descend into it. This typically means we have found\n+          // a candidate in one of the root nodes so we do not need to visit\n+          // other root nodes.\n+          return;\n+        }\n+      }\n+      if (node instanceof t.BoundEvent &&\n+          this.path.find((n => n instanceof t.BoundAttribute && node.name === n.name + 'Change'))) {\n+        // For two-way binding aka banana-in-a-box, there are two matches:\n+        // BoundAttribute and BoundEvent. Both have the same spans. We choose to\n+        // return BoundAttribute because it matches the identifier name verbatim.\n+        // TODO: For operations like go to definition, ideally we want to return\n+        // both.\n+        return;\n+      }\n+      this.path.push(node);\n+      node.visit(this);\n+    }\n+  }\n+\n+  visitElement(element: t.Element) {\n+    this.visitAll(element.attributes);\n+    this.visitAll(element.inputs);\n+    this.visitAll(element.outputs);\n+    this.visitAll(element.references);\n+    this.visitAll(element.children);\n+  }\n+\n+  visitTemplate(template: t.Template) {\n+    this.visitAll(template.attributes);\n+    this.visitAll(template.inputs);\n+    this.visitAll(template.outputs);\n+    this.visitAll(template.templateAttrs);\n+    this.visitAll(template.references);\n+    this.visitAll(template.variables);\n+    this.visitAll(template.children);\n+  }\n+\n+  visitContent(content: t.Content) {\n+    t.visitAll(this, content.attributes);\n+  }\n+\n+  visitVariable(variable: t.Variable) {\n+    // Variable has no template nodes or expression nodes.\n+  }\n+\n+  visitReference(reference: t.Reference) {\n+    // Reference has no template nodes or expression nodes.\n+  }\n+\n+  visitTextAttribute(attribute: t.TextAttribute) {\n+    // Text attribute has no template nodes or expression nodes.\n+  }\n+\n+  visitBoundAttribute(attribute: t.BoundAttribute) {\n+    const visitor = new ExpressionVisitor(this.position);\n+    visitor.visit(attribute.value, this.path);\n+  }\n+\n+  visitBoundEvent(attribute: t.BoundEvent) {\n+    const visitor = new ExpressionVisitor(this.position);\n+    visitor.visit(attribute.handler, this.path);\n+  }\n+\n+  visitText(text: t.Text) {\n+    // Text has no template nodes or expression nodes.\n+  }\n+\n+  visitBoundText(text: t.BoundText) {\n+    const visitor = new ExpressionVisitor(this.position);\n+    visitor.visit(text.value, this.path);\n+  }\n+\n+  visitIcu(icu: t.Icu) {\n+    for (const boundText of Object.values(icu.vars)) {\n+      this.visit(boundText);\n+    }\n+    for (const boundTextOrText of Object.values(icu.placeholders)) {\n+      this.visit(boundTextOrText);\n+    }\n+  }\n+\n+  visitAll(nodes: t.Node[]) {\n+    for (const node of nodes) {\n+      this.visit(node);\n+    }\n+  }\n+}\n+\n+class ExpressionVisitor extends e.RecursiveAstVisitor {\n+  // Position must be absolute in the source file.\n+  constructor(private readonly position: number) {\n+    super();\n+  }\n+\n+  visit(node: e.AST, path: Array<t.Node|e.AST>) {\n+    if (node instanceof e.ASTWithSource) {\n+      // In order to reduce noise, do not include `ASTWithSource` in the path.\n+      // For the purpose of source spans, there is no difference between\n+      // `ASTWithSource` and and underlying node that it wraps.\n+      node = node.ast;\n+    }\n+    const {start, end} = node.sourceSpan;\n+    // The third condition is to account for the implicit receiver, which should\n+    // not be visited.\n+    if (start <= this.position && this.position <= end && !(node instanceof e.ImplicitReceiver)) {\n+      path.push(node);\n+      node.visit(this, path);\n+    }\n+  }\n+}\n+\n+export function isTemplateNode(node: t.Node|e.AST): node is t.Node {\n+  // Template node implements the Node interface so we cannot use instanceof.\n+  return node.sourceSpan instanceof ParseSourceSpan;\n+}\n+\n+export function isExpressionNode(node: t.Node|e.AST): node is e.AST {\n+  return node instanceof e.AST;\n+}\n+\n+function getSpanIncludingEndTag(ast: t.Node) {\n+  const result = {\n+    start: ast.sourceSpan.start.offset,\n+    end: ast.sourceSpan.end.offset,\n+  };\n+  // For Element and Template node, sourceSpan.end is the end of the opening\n+  // tag. For the purpose of language service, we need to actually recognize\n+  // the end of the closing tag. Otherwise, for situation like\n+  // <my-component></my-comp¦onent> where the cursor is in the closing tag\n+  // we will not be able to return any information.\n+  if ((ast instanceof t.Element || ast instanceof t.Template) && ast.endSourceSpan) {\n+    result.end = ast.endSourceSpan.end.offset;\n+  }\n+  return result;\n+}"
        },
        {
            "sha": "aaa729f2666c7b6f53c17594e88751c2a4cfaf43",
            "filename": "packages/language-service/ivy/test/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/b48cc6ead56472d04385370cd83dbb5d072a69a6/packages%2Flanguage-service%2Fivy%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/b48cc6ead56472d04385370cd83dbb5d072a69a6/packages%2Flanguage-service%2Fivy%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2FBUILD.bazel?ref=b48cc6ead56472d04385370cd83dbb5d072a69a6",
            "patch": "@@ -5,6 +5,7 @@ ts_library(\n     testonly = True,\n     srcs = glob([\"*.ts\"]),\n     deps = [\n+        \"//packages/compiler\",\n         \"//packages/language-service/ivy\",\n         \"@npm//typescript\",\n     ],"
        },
        {
            "sha": "30eb4daf7338c3f88075c7718c2085509718f7fa",
            "filename": "packages/language-service/ivy/test/hybrid_visitor_spec.ts",
            "status": "added",
            "additions": 568,
            "deletions": 0,
            "changes": 568,
            "blob_url": "https://github.com/angular/angular/blob/b48cc6ead56472d04385370cd83dbb5d072a69a6/packages%2Flanguage-service%2Fivy%2Ftest%2Fhybrid_visitor_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b48cc6ead56472d04385370cd83dbb5d072a69a6/packages%2Flanguage-service%2Fivy%2Ftest%2Fhybrid_visitor_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fhybrid_visitor_spec.ts?ref=b48cc6ead56472d04385370cd83dbb5d072a69a6",
            "patch": "@@ -0,0 +1,568 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {ParseError, parseTemplate} from '@angular/compiler';\n+import * as e from '@angular/compiler/src/expression_parser/ast';  // e for expression AST\n+import * as t from '@angular/compiler/src/render3/r3_ast';         // t for template AST\n+\n+import {findNodeAtPosition, isExpressionNode, isTemplateNode} from '../hybrid_visitor';\n+\n+interface ParseResult {\n+  nodes: t.Node[];\n+  errors?: ParseError[];\n+  position: number;\n+}\n+\n+function parse(template: string): ParseResult {\n+  const position = template.indexOf('¦');\n+  if (position < 0) {\n+    throw new Error(`Template \"${template}\" does not contain the cursor`);\n+  }\n+  template = template.replace('¦', '');\n+  const templateUrl = '/foo';\n+  return {\n+    ...parseTemplate(template, templateUrl),\n+    position,\n+  };\n+}\n+\n+describe('findNodeAtPosition for template AST', () => {\n+  it('should locate element in opening tag', () => {\n+    const {errors, nodes, position} = parse(`<di¦v></div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.Element);\n+  });\n+\n+  it('should locate element in closing tag', () => {\n+    const {errors, nodes, position} = parse(`<div></di¦v>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.Element);\n+  });\n+\n+  it('should locate element when cursor is at the beginning', () => {\n+    const {errors, nodes, position} = parse(`<¦div></div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.Element);\n+  });\n+\n+  it('should locate element when cursor is at the end', () => {\n+    const {errors, nodes, position} = parse(`<div¦></div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.Element);\n+  });\n+\n+  it('should locate attribute key', () => {\n+    const {errors, nodes, position} = parse(`<div cla¦ss=\"foo\"></div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.TextAttribute);\n+  });\n+\n+  it('should locate attribute value', () => {\n+    const {errors, nodes, position} = parse(`<div class=\"fo¦o\"></div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    // TODO: Note that we do not have the ability to detect the RHS (yet)\n+    expect(node).toBeInstanceOf(t.TextAttribute);\n+  });\n+\n+  it('should locate bound attribute key', () => {\n+    const {errors, nodes, position} = parse(`<test-cmp [fo¦o]=\"bar\"></test-cmp>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.BoundAttribute);\n+  });\n+\n+  it('should locate bound attribute value', () => {\n+    const {errors, nodes, position} = parse(`<test-cmp [foo]=\"b¦ar\"></test-cmp>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.PropertyRead);\n+  });\n+\n+  it('should locate bound event key', () => {\n+    const {errors, nodes, position} = parse(`<test-cmp (fo¦o)=\"bar()\"></test-cmp>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.BoundEvent);\n+  });\n+\n+  it('should locate bound event value', () => {\n+    const {errors, nodes, position} = parse(`<test-cmp (foo)=\"b¦ar()\"></test-cmp>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.MethodCall);\n+  });\n+\n+  it('should locate element children', () => {\n+    const {errors, nodes, position} = parse(`<div><sp¦an></span></div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.Element);\n+    expect((node as t.Element).name).toBe('span');\n+  });\n+\n+  it('should locate element reference', () => {\n+    const {errors, nodes, position} = parse(`<div #my¦div></div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.Reference);\n+  });\n+\n+  it('should locate template text attribute', () => {\n+    const {errors, nodes, position} = parse(`<ng-template ng¦If></ng-template>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.TextAttribute);\n+  });\n+\n+  it('should locate template bound attribute key', () => {\n+    const {errors, nodes, position} = parse(`<ng-template [ng¦If]=\"foo\"></ng-template>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.BoundAttribute);\n+  });\n+\n+  it('should locate template bound attribute value', () => {\n+    const {errors, nodes, position} = parse(`<ng-template [ngIf]=\"f¦oo\"></ng-template>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.PropertyRead);\n+  });\n+\n+  it('should locate template bound attribute key in two-way binding', () => {\n+    const {errors, nodes, position} = parse(`<ng-template [(f¦oo)]=\"bar\"></ng-template>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.BoundAttribute);\n+    expect((node as t.BoundAttribute).name).toBe('foo');\n+  });\n+\n+  it('should locate template bound attribute value in two-way binding', () => {\n+    const {errors, nodes, position} = parse(`<ng-template [(foo)]=\"b¦ar\"></ng-template>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.PropertyRead);\n+    expect((node as e.PropertyRead).name).toBe('bar');\n+  });\n+\n+  it('should locate template bound event key', () => {\n+    const {errors, nodes, position} = parse(`<ng-template (cl¦ick)=\"foo()\"></ng-template>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.BoundEvent);\n+  });\n+\n+  it('should locate template bound event value', () => {\n+    const {errors, nodes, position} = parse(`<ng-template (click)=\"f¦oo()\"></ng-template>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(node).toBeInstanceOf(e.MethodCall);\n+  });\n+\n+  it('should locate template attribute key', () => {\n+    const {errors, nodes, position} = parse(`<ng-template i¦d=\"foo\"></ng-template>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.TextAttribute);\n+  });\n+\n+  it('should locate template attribute value', () => {\n+    const {errors, nodes, position} = parse(`<ng-template id=\"f¦oo\"></ng-template>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    // TODO: Note that we do not have the ability to detect the RHS (yet)\n+    expect(node).toBeInstanceOf(t.TextAttribute);\n+  });\n+\n+  it('should locate template reference key via the # notation', () => {\n+    const {errors, nodes, position} = parse(`<ng-template #f¦oo></ng-template>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.Reference);\n+    expect((node as t.Reference).name).toBe('foo');\n+  });\n+\n+  it('should locate template reference key via the ref- notation', () => {\n+    const {errors, nodes, position} = parse(`<ng-template ref-fo¦o></ng-template>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.Reference);\n+    expect((node as t.Reference).name).toBe('foo');\n+  });\n+\n+  it('should locate template reference value via the # notation', () => {\n+    const {errors, nodes, position} = parse(`<ng-template #foo=\"export¦As\"></ng-template>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.Reference);\n+    expect((node as t.Reference).value).toBe('exportAs');\n+    // TODO: Note that we do not have the ability to distinguish LHS and RHS\n+  });\n+\n+  it('should locate template reference value via the ref- notation', () => {\n+    const {errors, nodes, position} = parse(`<ng-template ref-foo=\"export¦As\"></ng-template>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.Reference);\n+    expect((node as t.Reference).value).toBe('exportAs');\n+    // TODO: Note that we do not have the ability to distinguish LHS and RHS\n+  });\n+\n+  it('should locate template variable key', () => {\n+    const {errors, nodes, position} = parse(`<ng-template let-f¦oo=\"bar\"></ng-template>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.Variable);\n+  });\n+\n+  it('should locate template variable value', () => {\n+    const {errors, nodes, position} = parse(`<ng-template let-foo=\"b¦ar\"></ng-template>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.Variable);\n+  });\n+\n+  it('should locate template children', () => {\n+    const {errors, nodes, position} = parse(`<ng-template><d¦iv></div></ng-template>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.Element);\n+  });\n+\n+  it('should locate ng-content', () => {\n+    const {errors, nodes, position} = parse(`<ng-co¦ntent></ng-content>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.Content);\n+  });\n+\n+  it('should locate ng-content attribute key', () => {\n+    const {errors, nodes, position} = parse('<ng-content cla¦ss=\"red\"></ng-content>');\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.TextAttribute);\n+  });\n+\n+  it('should locate ng-content attribute value', () => {\n+    const {errors, nodes, position} = parse('<ng-content class=\"r¦ed\"></ng-content>');\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    // TODO: Note that we do not have the ability to detect the RHS (yet)\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.TextAttribute);\n+  });\n+\n+  it('should not locate implicit receiver', () => {\n+    const {errors, nodes, position} = parse(`<div [foo]=\"¦bar\"></div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.PropertyRead);\n+  });\n+\n+  it('should locate bound attribute key in two-way binding', () => {\n+    const {errors, nodes, position} = parse(`<cmp [(f¦oo)]=\"bar\"></cmp>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.BoundAttribute);\n+    expect((node as t.BoundAttribute).name).toBe('foo');\n+  });\n+\n+  it('should locate bound attribute value in two-way binding', () => {\n+    const {errors, nodes, position} = parse(`<cmp [(foo)]=\"b¦ar\"></cmp>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.PropertyRead);\n+    expect((node as e.PropertyRead).name).toBe('bar');\n+  });\n+});\n+\n+describe('findNodeAtPosition for expression AST', () => {\n+  it('should not locate implicit receiver', () => {\n+    const {errors, nodes, position} = parse(`{{ ¦title }}`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.PropertyRead);\n+    expect((node as e.PropertyRead).name).toBe('title');\n+  });\n+\n+  it('should locate property read', () => {\n+    const {errors, nodes, position} = parse(`{{ ti¦tle }}`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.PropertyRead);\n+    expect((node as e.PropertyRead).name).toBe('title');\n+  });\n+\n+  it('should locate safe property read', () => {\n+    const {errors, nodes, position} = parse(`{{ foo?¦.bar }}`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.SafePropertyRead);\n+    expect((node as e.SafePropertyRead).name).toBe('bar');\n+  });\n+\n+  it('should locate keyed read', () => {\n+    const {errors, nodes, position} = parse(`{{ foo['bar']¦ }}`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.KeyedRead);\n+  });\n+\n+  it('should locate property write', () => {\n+    const {errors, nodes, position} = parse(`<div (foo)=\"b¦ar=$event\"></div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.PropertyWrite);\n+  });\n+\n+  it('should locate keyed write', () => {\n+    const {errors, nodes, position} = parse(`<div (foo)=\"bar['baz']¦=$event\"></div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.KeyedWrite);\n+  });\n+\n+  it('should locate binary', () => {\n+    const {errors, nodes, position} = parse(`{{ 1 +¦ 2 }}`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.Binary);\n+  });\n+\n+  it('should locate binding pipe with an identifier', () => {\n+    const {errors, nodes, position} = parse(`{{ title | p¦ }}`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.BindingPipe);\n+  });\n+\n+  it('should locate binding pipe without identifier',\n+     () => {\n+         // TODO: We are not able to locate pipe if identifier is missing because the\n+         // parser throws an error. This case is important for autocomplete.\n+         // const {errors, nodes, position} = parse(`{{ title | ¦ }}`);\n+         // expect(errors).toBeUndefined();\n+         // const node = findNodeAtPosition(nodes, position);\n+         // expect(isExpressionNode(node!)).toBe(true);\n+         // expect(node).toBeInstanceOf(e.BindingPipe);\n+     });\n+\n+  it('should locate method call', () => {\n+    const {errors, nodes, position} = parse(`{{ title.toString(¦) }}`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.MethodCall);\n+  });\n+\n+  it('should locate safe method call', () => {\n+    const {errors, nodes, position} = parse(`{{ title?.toString(¦) }}`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.SafeMethodCall);\n+  });\n+\n+  it('should locate literal primitive in interpolation', () => {\n+    const {errors, nodes, position} = parse(`{{ title.indexOf('t¦') }}`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.LiteralPrimitive);\n+    expect((node as e.LiteralPrimitive).value).toBe('t');\n+  });\n+\n+  it('should locate literal primitive in binding', () => {\n+    const {errors, nodes, position} = parse(`<div [id]=\"'t¦'\"></div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.LiteralPrimitive);\n+    expect((node as e.LiteralPrimitive).value).toBe('t');\n+  });\n+\n+  it('should locate empty expression', () => {\n+    const {errors, nodes, position} = parse(`<div [id]=\"¦\"></div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.EmptyExpr);\n+  });\n+\n+  it('should locate literal array', () => {\n+    const {errors, nodes, position} = parse(`{{ [1, 2,¦ 3] }}`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.LiteralArray);\n+  });\n+\n+  it('should locate literal map', () => {\n+    const {errors, nodes, position} = parse(`{{ { hello:¦ \"world\" } }}`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.LiteralMap);\n+  });\n+\n+  it('should locate conditional', () => {\n+    const {errors, nodes, position} = parse(`{{ cond ?¦ true : false }}`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.Conditional);\n+  });\n+});\n+\n+describe('findNodeAtPosition for microsyntax expression', () => {\n+  it('should locate template key', () => {\n+    const {errors, nodes, position} = parse(`<div *ng¦If=\"foo\"></div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.BoundAttribute);\n+  });\n+\n+  it('should locate template value', () => {\n+    const {errors, nodes, position} = parse(`<div *ngIf=\"f¦oo\"></div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.PropertyRead);\n+  });\n+\n+  it('should locate text attribute', () => {\n+    const {errors, nodes, position} = parse(`<div *ng¦For=\"let item of items\"></div>`);\n+    // ngFor is a text attribute because the desugared form is\n+    // <ng-template ngFor let-item [ngForOf]=\"items\">\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    // TODO: this is currently wrong because it should point to ngFor text\n+    // attribute instead of ngForOf bound attribute\n+  });\n+\n+  it('should locate not let keyword', () => {\n+    const {errors, nodes, position} = parse(`<div *ngFor=\"l¦et item of items\"></div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    // TODO: this is currently wrong because node is currently pointing to\n+    // \"item\". In this case, it should return undefined.\n+  });\n+\n+  it('should locate let variable', () => {\n+    const {errors, nodes, position} = parse(`<div *ngFor=\"let i¦tem of items\"></div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.Variable);\n+    expect((node as t.Variable).name).toBe('item');\n+  });\n+\n+  it('should locate bound attribute key', () => {\n+    const {errors, nodes, position} = parse(`<div *ngFor=\"let item o¦f items\"></div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.BoundAttribute);\n+    expect((node as t.BoundAttribute).name).toBe('ngForOf');\n+  });\n+\n+  it('should locate bound attribute value', () => {\n+    const {errors, nodes, position} = parse(`<div *ngFor=\"let item of it¦ems\"></div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.PropertyRead);\n+    expect((node as e.PropertyRead).name).toBe('items');\n+  });\n+\n+  it('should locate template children', () => {\n+    const {errors, nodes, position} = parse(`<di¦v *ngIf></div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.Element);\n+    expect((node as t.Element).name).toBe('div');\n+  });\n+\n+  it('should locate property read of variable declared within template', () => {\n+    const {errors, nodes, position} = parse(`\n+      <div *ngFor=\"let item of items; let i=index\">\n+        {{ i¦ }}\n+      </div>`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isExpressionNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(e.PropertyRead);\n+  });\n+\n+  it('should locate LHS of variable declaration', () => {\n+    const {errors, nodes, position} = parse(`<div *ngFor=\"let item of items; let i¦=index\">`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.Variable);\n+    // TODO: Currently there is no way to distinguish LHS from RHS\n+    expect((node as t.Variable).name).toBe('i');\n+  });\n+\n+  it('should locate RHS of variable declaration', () => {\n+    const {errors, nodes, position} = parse(`<div *ngFor=\"let item of items; let i=in¦dex\">`);\n+    expect(errors).toBeUndefined();\n+    const node = findNodeAtPosition(nodes, position);\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.Variable);\n+    // TODO: Currently there is no way to distinguish LHS from RHS\n+    expect((node as t.Variable).value).toBe('index');\n+  });\n+});"
        }
    ],
    "stats": {
        "total": 750,
        "additions": 750,
        "deletions": 0
    }
}