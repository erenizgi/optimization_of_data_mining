{
    "author": "alxhub",
    "message": "refactor(compiler-cli): allow overriding templates in the type checker (#38105)\n\nThis commit adds an `overrideComponentTemplate` operation to the template\ntype-checker. This operation changes the template used during template\ntype-checking operations.\n\nOverriding a template causes any previous work for it to be discarded, and\nthe template type-checking engine will regenerate the TCB for that template\non the next request.\n\nThis operation can be used by a consumer such as the language service to\nget rapid feedback or diagnostics as the user is editing a template file,\nwithout the need for a full incremental build iteration.\n\nCloses #38058\n\nPR Close #38105",
    "sha": "3c0424e7e06ab782c5e42c2a4d256d69c19cd2df",
    "files": [
        {
            "sha": "793dc4e0909f92d40267b38ae399e473ee7d8bd3",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/checker.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 2,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/3c0424e7e06ab782c5e42c2a4d256d69c19cd2df/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/3c0424e7e06ab782c5e42c2a4d256d69c19cd2df/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts?ref=3c0424e7e06ab782c5e42c2a4d256d69c19cd2df",
            "patch": "@@ -6,8 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {TmplAstNode} from '@angular/compiler';\n-\n+import {ParseError, TmplAstNode} from '@angular/compiler';\n import * as ts from 'typescript';\n \n /**\n@@ -24,6 +23,21 @@ import * as ts from 'typescript';\n  * query, depending on the method either `null` will be returned or an error will be thrown.\n  */\n export interface TemplateTypeChecker {\n+  /**\n+   * Clear all overrides and return the template type-checker to the original input program state.\n+   */\n+  resetOverrides(): void;\n+\n+  /**\n+   * Provide a new template string that will be used in place of the user-defined template when\n+   * checking or operating on the given component.\n+   *\n+   * The compiler will parse this template for diagnostics, and will return any parsing errors if it\n+   * is not valid. If the template cannot be parsed correctly, no override will occur.\n+   */\n+  overrideComponentTemplate(component: ts.ClassDeclaration, template: string):\n+      {nodes: TmplAstNode[], errors?: ParseError[]};\n+\n   /**\n    * Get all `ts.Diagnostic`s currently available for the given `ts.SourceFile`.\n    *"
        },
        {
            "sha": "4c5dccfd74b2df4768c4aa49a40eb437fd24eb5e",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts",
            "status": "modified",
            "additions": 83,
            "deletions": 2,
            "changes": 85,
            "blob_url": "https://github.com/angular/angular/blob/3c0424e7e06ab782c5e42c2a4d256d69c19cd2df/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/3c0424e7e06ab782c5e42c2a4d256d69c19cd2df/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts?ref=3c0424e7e06ab782c5e42c2a4d256d69c19cd2df",
            "patch": "@@ -6,6 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n+import {ParseError, parseTemplate, TmplAstNode} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {absoluteFromSourceFile, AbsoluteFsPath, getSourceFileOrError} from '../../file_system';\n@@ -14,7 +15,7 @@ import {IncrementalBuild} from '../../incremental/api';\n import {ReflectionHost} from '../../reflection';\n import {isShim} from '../../shims';\n import {getSourceFileOrNull} from '../../util/src/typescript';\n-import {OptimizeFor, ProgramTypeCheckAdapter, TemplateTypeChecker, TypeCheckingConfig, TypeCheckingProgramStrategy, UpdateMode} from '../api';\n+import {OptimizeFor, ProgramTypeCheckAdapter, TemplateId, TemplateTypeChecker, TypeCheckingConfig, TypeCheckingProgramStrategy, UpdateMode} from '../api';\n \n import {InliningMode, ShimTypeCheckingData, TypeCheckContextImpl, TypeCheckingHost} from './context';\n import {findTypeCheckBlock, shouldReportDiagnostic, TemplateSourceResolver, translateDiagnostic} from './diagnostics';\n@@ -37,6 +38,47 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n       private compilerHost: Pick<ts.CompilerHost, 'getCanonicalFileName'>,\n       private priorBuild: IncrementalBuild<unknown, FileTypeCheckingData>) {}\n \n+  resetOverrides(): void {\n+    for (const fileRecord of this.state.values()) {\n+      if (fileRecord.templateOverrides !== null) {\n+        fileRecord.templateOverrides = null;\n+        fileRecord.shimData.clear();\n+        fileRecord.isComplete = false;\n+      }\n+    }\n+  }\n+\n+  overrideComponentTemplate(component: ts.ClassDeclaration, template: string):\n+      {nodes: TmplAstNode[], errors?: ParseError[]} {\n+    const {nodes, errors} = parseTemplate(template, 'override.html', {\n+      preserveWhitespaces: true,\n+      leadingTriviaChars: [],\n+    });\n+\n+    if (errors !== undefined) {\n+      return {nodes, errors};\n+    }\n+\n+    const filePath = absoluteFromSourceFile(component.getSourceFile());\n+\n+    const fileRecord = this.getFileData(filePath);\n+    const id = fileRecord.sourceManager.getTemplateId(component);\n+\n+    if (fileRecord.templateOverrides === null) {\n+      fileRecord.templateOverrides = new Map();\n+    }\n+\n+    fileRecord.templateOverrides.set(id, nodes);\n+\n+    // Clear data for the shim in question, so it'll be regenerated on the next request.\n+    const shimFile = this.typeCheckingStrategy.shimPathForComponent(component);\n+    fileRecord.shimData.delete(shimFile);\n+    fileRecord.isComplete = false;\n+    this.isComplete = false;\n+\n+    return {nodes};\n+  }\n+\n   /**\n    * Retrieve type-checking diagnostics from the given `ts.SourceFile` using the most recent\n    * type-checking program.\n@@ -106,6 +148,10 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     const sfPath = absoluteFromSourceFile(sf);\n     if (this.state.has(sfPath)) {\n       const existingResults = this.state.get(sfPath)!;\n+      if (existingResults.templateOverrides !== null) {\n+        // Cannot adopt prior results if template overrides have been requested.\n+        return;\n+      }\n \n       if (existingResults.isComplete) {\n         // All data for this file has already been generated, so no need to adopt anything.\n@@ -114,7 +160,8 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     }\n \n     const previousResults = this.priorBuild.priorTypeCheckingResultsFor(sf);\n-    if (previousResults === null || !previousResults.isComplete) {\n+    if (previousResults === null || !previousResults.isComplete ||\n+        previousResults.templateOverrides !== null) {\n       return;\n     }\n \n@@ -214,6 +261,7 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     if (!this.state.has(path)) {\n       this.state.set(path, {\n         hasInlines: false,\n+        templateOverrides: null,\n         sourceManager: new TemplateSourceManager(),\n         isComplete: false,\n         shimData: new Map(),\n@@ -248,6 +296,11 @@ export interface FileTypeCheckingData {\n    */\n   sourceManager: TemplateSourceManager;\n \n+  /**\n+   * Map of template overrides applied to any components in this input file.\n+   */\n+  templateOverrides: Map<TemplateId, TmplAstNode[]>|null;\n+\n   /**\n    * Data for each shim generated from this input file.\n    *\n@@ -280,6 +333,20 @@ class WholeProgramTypeCheckingHost implements TypeCheckingHost {\n     return !fileData.shimData.has(shimPath);\n   }\n \n+  getTemplateOverride(sfPath: AbsoluteFsPath, node: ts.ClassDeclaration): TmplAstNode[]|null {\n+    const fileData = this.impl.getFileData(sfPath);\n+    if (fileData.templateOverrides === null) {\n+      return null;\n+    }\n+\n+    const templateId = fileData.sourceManager.getTemplateId(node);\n+    if (fileData.templateOverrides.has(templateId)) {\n+      return fileData.templateOverrides.get(templateId)!;\n+    }\n+\n+    return null;\n+  }\n+\n   recordShimData(sfPath: AbsoluteFsPath, data: ShimTypeCheckingData): void {\n     const fileData = this.impl.getFileData(sfPath);\n     fileData.shimData.set(data.path, data);\n@@ -324,6 +391,20 @@ class SingleFileTypeCheckingHost implements TypeCheckingHost {\n     return !this.fileData.shimData.has(shimPath);\n   }\n \n+  getTemplateOverride(sfPath: AbsoluteFsPath, node: ts.ClassDeclaration): TmplAstNode[]|null {\n+    this.assertPath(sfPath);\n+    if (this.fileData.templateOverrides === null) {\n+      return null;\n+    }\n+\n+    const templateId = this.fileData.sourceManager.getTemplateId(node);\n+    if (this.fileData.templateOverrides.has(templateId)) {\n+      return this.fileData.templateOverrides.get(templateId)!;\n+    }\n+\n+    return null;\n+  }\n+\n   recordShimData(sfPath: AbsoluteFsPath, data: ShimTypeCheckingData): void {\n     this.assertPath(sfPath);\n "
        },
        {
            "sha": "5c5bb0c2f7f9cd1588b21fe578ec01f166237a27",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/context.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/3c0424e7e06ab782c5e42c2a4d256d69c19cd2df/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts",
            "raw_url": "https://github.com/angular/angular/raw/3c0424e7e06ab782c5e42c2a4d256d69c19cd2df/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts?ref=3c0424e7e06ab782c5e42c2a4d256d69c19cd2df",
            "patch": "@@ -102,6 +102,12 @@ export interface TypeCheckingHost {\n    */\n   shouldCheckComponent(node: ts.ClassDeclaration): boolean;\n \n+  /**\n+   * Check if the given component has had its template overridden, and retrieve the new template\n+   * nodes if so.\n+   */\n+  getTemplateOverride(sfPath: AbsoluteFsPath, node: ts.ClassDeclaration): TmplAstNode[]|null;\n+\n   /**\n    * Report data from a shim generated from the given input file path.\n    */\n@@ -175,6 +181,13 @@ export class TypeCheckContextImpl implements TypeCheckContext {\n       return;\n     }\n \n+    const sfPath = absoluteFromSourceFile(ref.node.getSourceFile());\n+\n+    const overrideTemplate = this.host.getTemplateOverride(sfPath, ref.node);\n+    if (overrideTemplate !== null) {\n+      template = overrideTemplate;\n+    }\n+\n     // Accumulate a list of any directives which could not have type constructors generated due to\n     // unsupported inlining operations.\n     let missingInlines: ClassDeclaration[] = [];"
        },
        {
            "sha": "3e1763319ae5f78f63ac22e23cd4bc0ad73c3926",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker_spec.ts",
            "status": "modified",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/angular/angular/blob/3c0424e7e06ab782c5e42c2a4d256d69c19cd2df/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/3c0424e7e06ab782c5e42c2a4d256d69c19cd2df/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts?ref=3c0424e7e06ab782c5e42c2a4d256d69c19cd2df",
            "patch": "@@ -209,5 +209,114 @@ runInEachFileSystem(() => {\n         expect(absoluteFromSourceFile(diags[0].relatedInformation![0].file!)).toBe(dirFile);\n       });\n     });\n+\n+    describe('template overrides', () => {\n+      it('should override a simple template', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const {program, templateTypeChecker} = setup([{\n+          fileName,\n+          templates: {'Cmp': '<div></div>'},\n+        }]);\n+\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+\n+        const tcbReal = templateTypeChecker.getTypeCheckBlock(cmp)!;\n+        expect(tcbReal.getText()).toContain('div');\n+\n+        templateTypeChecker.overrideComponentTemplate(cmp, '<span></span>');\n+        const tcbOverridden = templateTypeChecker.getTypeCheckBlock(cmp);\n+        expect(tcbOverridden).not.toBeNull();\n+        expect(tcbOverridden!.getText()).not.toContain('div');\n+        expect(tcbOverridden!.getText()).toContain('span');\n+      });\n+\n+      it('should clear overrides on request', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const {program, templateTypeChecker} = setup([{\n+          fileName,\n+          templates: {'Cmp': '<div></div>'},\n+        }]);\n+\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+\n+        templateTypeChecker.overrideComponentTemplate(cmp, '<span></span>');\n+        const tcbOverridden = templateTypeChecker.getTypeCheckBlock(cmp)!;\n+        expect(tcbOverridden.getText()).not.toContain('div');\n+        expect(tcbOverridden.getText()).toContain('span');\n+\n+        templateTypeChecker.resetOverrides();\n+\n+        // The template should be back to the original, which has <div> and not <span>.\n+        const tcbReal = templateTypeChecker.getTypeCheckBlock(cmp)!;\n+        expect(tcbReal.getText()).toContain('div');\n+        expect(tcbReal.getText()).not.toContain('span');\n+      });\n+\n+      it('should override a template and make use of previously unused directives', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const dirFile = absoluteFrom('/dir.ts');\n+        const {program, templateTypeChecker} = setup(\n+            [\n+              {\n+                fileName,\n+                source: `export class Cmp {}`,\n+                templates: {'Cmp': '<div></div>'},\n+                declarations: [{\n+                  name: 'TestDir',\n+                  selector: '[dir]',\n+                  file: dirFile,\n+                  type: 'directive',\n+                }]\n+              },\n+              {\n+                fileName: dirFile,\n+                source: `export class TestDir {}`,\n+                templates: {},\n+              }\n+            ],\n+            {inlining: false});\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+\n+        // TestDir is initially unused. Note that this checks the entire text of the ngtypecheck\n+        // file, to ensure it captures not just the TCB function but also any inline type\n+        // constructors.\n+        const tcbReal = templateTypeChecker.getTypeCheckBlock(cmp)!;\n+        expect(tcbReal.getSourceFile().text).not.toContain('TestDir');\n+\n+        templateTypeChecker.overrideComponentTemplate(cmp, '<div dir></div>');\n+\n+        const tcbOverridden = templateTypeChecker.getTypeCheckBlock(cmp);\n+        expect(tcbOverridden).not.toBeNull();\n+        expect(tcbOverridden!.getSourceFile().text).toContain('TestDir');\n+      });\n+\n+      it('should not invalidate other templates when an override is requested', () => {\n+        const file1 = absoluteFrom('/file1.ts');\n+        const file2 = absoluteFrom('/file2.ts');\n+        const {program, templateTypeChecker, programStrategy} = setup([\n+          {fileName: file1, templates: {'Cmp1': '<div></div>'}},\n+          {fileName: file2, templates: {'Cmp2': '<span></span>'}}\n+        ]);\n+\n+        const cmp1 = getClass(getSourceFileOrError(program, file1), 'Cmp1');\n+        const cmp2 = getClass(getSourceFileOrError(program, file2), 'Cmp2');\n+\n+        // To test this scenario, Cmp1's type check block will be captured, then Cmp2's template\n+        // will be overridden. Cmp1's type check block should not change as a result.\n+        const originalTcb = templateTypeChecker.getTypeCheckBlock(cmp1)!;\n+\n+        templateTypeChecker.overrideComponentTemplate(cmp2, '<p></p>');\n+\n+        // Trigger generation of the TCB for Cmp2.\n+        templateTypeChecker.getTypeCheckBlock(cmp2);\n+\n+        // Verify that Cmp1's TCB has not changed.\n+        const currentTcb = templateTypeChecker.getTypeCheckBlock(cmp1)!;\n+        expect(currentTcb).toBe(originalTcb);\n+      });\n+    });\n   });\n });"
        }
    ],
    "stats": {
        "total": 225,
        "additions": 221,
        "deletions": 4
    }
}