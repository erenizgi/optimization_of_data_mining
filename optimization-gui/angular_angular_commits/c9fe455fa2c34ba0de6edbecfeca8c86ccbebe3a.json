{
    "author": "AndrewKushnir",
    "message": "fix(forms): allow `patchValue()` method of `FormGroup` and `FormArray` classes to skip `null` values (#40534)\n\nPrior to this commit, the `patchValue()` of the `FormGroup` and `FormArray` classes used to throw an exception\nwhen the `value` argument contained a data structure that has `null` or `undefined` as a value for a field\nthat represents an instance of `FormGroup` or `FormArray` (for `FormControl` it's not a problem, since it\ndoesn't have nested controls), since the `patchValue()` method tried to iterate over provided values to\nmatch current data structure.\n\nThis commit updates the `patchValue()` logic in `FormGroup` and `FormArray` classes to just ignore `null` and\n`undefined` values (without any changes to corresponding `FormGroup` and `FormArray` instances). This\nbehavior looks inline with the `patchValue()` method goal of \"doing its best to match the values to the\ncorrect controls\" (quote from docs).\n\nFixes #36672.\nFixes #21021.\n\nPR Close #40534",
    "sha": "c9fe455fa2c34ba0de6edbecfeca8c86ccbebe3a",
    "files": [
        {
            "sha": "c21fe81f088c44d4cd885e5aaed83caa668e64e1",
            "filename": "packages/forms/src/model.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 10,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/c9fe455fa2c34ba0de6edbecfeca8c86ccbebe3a/packages%2Fforms%2Fsrc%2Fmodel.ts",
            "raw_url": "https://github.com/angular/angular/raw/c9fe455fa2c34ba0de6edbecfeca8c86ccbebe3a/packages%2Fforms%2Fsrc%2Fmodel.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Fsrc%2Fmodel.ts?ref=c9fe455fa2c34ba0de6edbecfeca8c86ccbebe3a",
            "patch": "@@ -1569,14 +1569,18 @@ export class FormGroup extends AbstractControl {\n    * * `onlySelf`: When true, each change only affects this control and not its parent. Default is\n    * true.\n    * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n-   * `valueChanges`\n-   * observables emit events with the latest status and value when the control value is updated.\n-   * When false, no events are emitted.\n-   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n-   * updateValueAndValidity} method.\n+   * `valueChanges` observables emit events with the latest status and value when the control value\n+   * is updated. When false, no events are emitted. The configuration options are passed to\n+   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.\n    */\n   patchValue(value: {[key: string]: any}, options: {onlySelf?: boolean, emitEvent?: boolean} = {}):\n       void {\n+    // Even though the `value` argument type doesn't allow `null` and `undefined` values, the\n+    // `patchValue` can be called recursively and inner data structures might have these values, so\n+    // we just ignore such cases when a field containing FormGroup instance receives `null` or\n+    // `undefined` as a value.\n+    if (value == null /* both `null` and `undefined` */) return;\n+\n     Object.keys(value).forEach(name => {\n       if (this.controls[name]) {\n         this.controls[name].patchValue(value[name], {onlySelf: true, emitEvent: options.emitEvent});\n@@ -2002,13 +2006,17 @@ export class FormArray extends AbstractControl {\n    * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n    * is false.\n    * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n-   * `valueChanges`\n-   * observables emit events with the latest status and value when the control value is updated.\n-   * When false, no events are emitted.\n-   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n-   * updateValueAndValidity} method.\n+   * `valueChanges` observables emit events with the latest status and value when the control value\n+   * is updated. When false, no events are emitted. The configuration options are passed to\n+   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.\n    */\n   patchValue(value: any[], options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n+    // Even though the `value` argument type doesn't allow `null` and `undefined` values, the\n+    // `patchValue` can be called recursively and inner data structures might have these values, so\n+    // we just ignore such cases when a field containing FormArray instance receives `null` or\n+    // `undefined` as a value.\n+    if (value == null /* both `null` and `undefined` */) return;\n+\n     value.forEach((newValue: any, index: number) => {\n       if (this.at(index)) {\n         this.at(index).patchValue(newValue, {onlySelf: true, emitEvent: options.emitEvent});"
        },
        {
            "sha": "d1f2737b21ff311a95a06122bbc137a387c7bb72",
            "filename": "packages/forms/test/form_array_spec.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 1,
            "changes": 30,
            "blob_url": "https://github.com/angular/angular/blob/c9fe455fa2c34ba0de6edbecfeca8c86ccbebe3a/packages%2Fforms%2Ftest%2Fform_array_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/c9fe455fa2c34ba0de6edbecfeca8c86ccbebe3a/packages%2Fforms%2Ftest%2Fform_array_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Fform_array_spec.ts?ref=c9fe455fa2c34ba0de6edbecfeca8c86ccbebe3a",
            "patch": "@@ -266,12 +266,13 @@ describe('FormArray', () => {\n   });\n \n   describe('patchValue', () => {\n-    let c: FormControl, c2: FormControl, a: FormArray;\n+    let c: FormControl, c2: FormControl, a: FormArray, a2: FormArray;\n \n     beforeEach(() => {\n       c = new FormControl('');\n       c2 = new FormControl('');\n       a = new FormArray([c, c2]);\n+      a2 = new FormArray([a]);\n     });\n \n     it('should set its own value', () => {\n@@ -329,6 +330,16 @@ describe('FormArray', () => {\n       expect(a.value).toEqual(['', '']);\n     });\n \n+    it('should ignore a array if `null` or `undefined` are used as values', () => {\n+      const INITIAL_STATE = [['', '']];\n+\n+      a2.patchValue([null]);\n+      expect(a2.value).toEqual(INITIAL_STATE);\n+\n+      a2.patchValue([undefined]);\n+      expect(a2.value).toEqual(INITIAL_STATE);\n+    });\n+\n     describe('patchValue() events', () => {\n       let form: FormGroup;\n       let logger: any[];\n@@ -358,6 +369,23 @@ describe('FormArray', () => {\n         expect(logger).toEqual(['control1', 'array', 'form']);\n       });\n \n+      it('should not emit valueChange events for skipped controls (represented as `null` or `undefined`)',\n+         () => {\n+           const logEvent = () => logger.push('valueChanges event');\n+\n+           const [formArrayControl1, formArrayControl2] = (a2.controls as FormArray[])[0].controls;\n+\n+           formArrayControl1.valueChanges.subscribe(logEvent);\n+           formArrayControl2.valueChanges.subscribe(logEvent);\n+\n+           a2.patchValue([null]);\n+           a2.patchValue([undefined]);\n+\n+           // No events are expected in `valueChanges` since\n+           // all controls were skipped in `patchValue`.\n+           expect(logger).toEqual([]);\n+         });\n+\n       it('should not fire an event when explicitly specified', fakeAsync(() => {\n            form.valueChanges.subscribe((value) => {\n              throw 'Should not happen';"
        },
        {
            "sha": "f65e88aa9fa720daaa9c78f4ffadaacd1ab8d7d7",
            "filename": "packages/forms/test/form_group_spec.ts",
            "status": "modified",
            "additions": 42,
            "deletions": 1,
            "changes": 43,
            "blob_url": "https://github.com/angular/angular/blob/c9fe455fa2c34ba0de6edbecfeca8c86ccbebe3a/packages%2Fforms%2Ftest%2Fform_group_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/c9fe455fa2c34ba0de6edbecfeca8c86ccbebe3a/packages%2Fforms%2Ftest%2Fform_group_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Fform_group_spec.ts?ref=c9fe455fa2c34ba0de6edbecfeca8c86ccbebe3a",
            "patch": "@@ -311,12 +311,16 @@ describe('FormGroup', () => {\n   });\n \n   describe('patchValue', () => {\n-    let c: FormControl, c2: FormControl, g: FormGroup;\n+    let c: FormControl, c2: FormControl, g: FormGroup, g2: FormGroup;\n \n     beforeEach(() => {\n       c = new FormControl('');\n       c2 = new FormControl('');\n       g = new FormGroup({'one': c, 'two': c2});\n+      g2 = new FormGroup({\n+        'array': new FormArray([new FormControl(1), new FormControl(2)]),\n+        'group': new FormGroup({'one': new FormControl(3)}),\n+      });\n     });\n \n     it('should set its own value', () => {\n@@ -374,6 +378,22 @@ describe('FormGroup', () => {\n       expect(g.value).toEqual({'one': '', 'two': ''});\n     });\n \n+    it('should ignore a control if `null` or `undefined` are used as values', () => {\n+      const INITIAL_STATE = {'array': [1, 2], 'group': {'one': 3}};\n+\n+      g2.patchValue({'array': null});\n+      expect(g2.value).toEqual(INITIAL_STATE);\n+\n+      g2.patchValue({'array': undefined});\n+      expect(g2.value).toEqual(INITIAL_STATE);\n+\n+      g2.patchValue({'group': null});\n+      expect(g2.value).toEqual(INITIAL_STATE);\n+\n+      g2.patchValue({'group': undefined});\n+      expect(g2.value).toEqual(INITIAL_STATE);\n+    });\n+\n     describe('patchValue() events', () => {\n       let form: FormGroup;\n       let logger: any[];\n@@ -403,6 +423,27 @@ describe('FormGroup', () => {\n         expect(logger).toEqual(['control1', 'group', 'form']);\n       });\n \n+      it('should not emit valueChange events for skipped controls (represented as `null` or `undefined`)',\n+         () => {\n+           const logEvent = () => logger.push('valueChanges event');\n+\n+           const [formArrayControl1, formArrayControl2] = (g2.controls.array as FormArray).controls;\n+           const formGroupControl = (g2.controls.group as FormGroup).controls.one;\n+\n+           formArrayControl1.valueChanges.subscribe(logEvent);\n+           formArrayControl2.valueChanges.subscribe(logEvent);\n+           formGroupControl.valueChanges.subscribe(logEvent);\n+\n+           g2.patchValue({'array': null});\n+           g2.patchValue({'array': undefined});\n+           g2.patchValue({'group': null});\n+           g2.patchValue({'group': undefined});\n+\n+           // No events are expected in `valueChanges` since\n+           // all controls were skipped in `patchValue`.\n+           expect(logger).toEqual([]);\n+         });\n+\n       it('should not fire an event when explicitly specified', fakeAsync(() => {\n            form.valueChanges.subscribe((value) => {\n              throw 'Should not happen';"
        }
    ],
    "stats": {
        "total": 101,
        "additions": 89,
        "deletions": 12
    }
}