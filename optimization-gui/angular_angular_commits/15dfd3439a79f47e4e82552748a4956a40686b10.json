{
    "author": "petebacondarwin",
    "message": "refactor(compiler-cli): split up translator file (#38775)\n\nThis file contains a number of classes making it long and hard to work with.\nThis commit splits the `ImportManager`, `Context` and `TypeTranslatorVisitor`\nclasses, along with associated functions and types into their own files.\n\nPR Close #38775",
    "sha": "15dfd3439a79f47e4e82552748a4956a40686b10",
    "files": [
        {
            "sha": "102b3d406afb2898ce4c008fdd1c2fbcb60f6f0c",
            "filename": "packages/compiler-cli/src/ngtsc/translator/index.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/15dfd3439a79f47e4e82552748a4956a40686b10/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/15dfd3439a79f47e4e82552748a4956a40686b10/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Findex.ts?ref=15dfd3439a79f47e4e82552748a4956a40686b10",
            "patch": "@@ -6,4 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-export {attachComments, Import, ImportManager, NamedImport, translateExpression, translateStatement, translateType} from './src/translator';\n+export {Import, ImportManager, NamedImport} from './src/import_manager';\n+export {attachComments, translateExpression, translateStatement} from './src/translator';\n+export {translateType} from './src/type_translator';\n\\ No newline at end of file"
        },
        {
            "sha": "9e606d0b76f84e115aafab82bcb9b82a08c36a3d",
            "filename": "packages/compiler-cli/src/ngtsc/translator/src/context.ts",
            "status": "added",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/angular/angular/blob/15dfd3439a79f47e4e82552748a4956a40686b10/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Fcontext.ts",
            "raw_url": "https://github.com/angular/angular/raw/15dfd3439a79f47e4e82552748a4956a40686b10/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Fcontext.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Fcontext.ts?ref=15dfd3439a79f47e4e82552748a4956a40686b10",
            "patch": "@@ -0,0 +1,24 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+/**\n+ * The current context of a translator visitor as it traverses the AST tree.\n+ *\n+ * It tracks whether we are in the process of outputting a statement or an expression.\n+ */\n+export class Context {\n+  constructor(readonly isStatement: boolean) {}\n+\n+  get withExpressionMode(): Context {\n+    return this.isStatement ? new Context(false) : this;\n+  }\n+\n+  get withStatementMode(): Context {\n+    return !this.isStatement ? new Context(true) : this;\n+  }\n+}"
        },
        {
            "sha": "2674b2d29750004612add8131d73b7fec2c55d93",
            "filename": "packages/compiler-cli/src/ngtsc/translator/src/import_manager.ts",
            "status": "added",
            "additions": 67,
            "deletions": 0,
            "changes": 67,
            "blob_url": "https://github.com/angular/angular/blob/15dfd3439a79f47e4e82552748a4956a40686b10/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Fimport_manager.ts",
            "raw_url": "https://github.com/angular/angular/raw/15dfd3439a79f47e4e82552748a4956a40686b10/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Fimport_manager.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Fimport_manager.ts?ref=15dfd3439a79f47e4e82552748a4956a40686b10",
            "patch": "@@ -0,0 +1,67 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {ImportRewriter, NoopImportRewriter} from '../../imports/src/core';\n+\n+/**\n+ * Information about an import that has been added to a module.\n+ */\n+export interface Import {\n+  /** The name of the module that has been imported. */\n+  specifier: string;\n+  /** The alias of the imported module. */\n+  qualifier: string;\n+}\n+\n+/**\n+ * The symbol name and import namespace of an imported symbol,\n+ * which has been registered through the ImportManager.\n+ */\n+export interface NamedImport {\n+  /** The import namespace containing this imported symbol. */\n+  moduleImport: string|null;\n+  /** The (possibly rewritten) name of the imported symbol. */\n+  symbol: string;\n+}\n+\n+export class ImportManager {\n+  private specifierToIdentifier = new Map<string, string>();\n+  private nextIndex = 0;\n+\n+  constructor(protected rewriter: ImportRewriter = new NoopImportRewriter(), private prefix = 'i') {\n+  }\n+\n+  generateNamedImport(moduleName: string, originalSymbol: string): NamedImport {\n+    // First, rewrite the symbol name.\n+    const symbol = this.rewriter.rewriteSymbol(originalSymbol, moduleName);\n+\n+    // Ask the rewriter if this symbol should be imported at all. If not, it can be referenced\n+    // directly (moduleImport: null).\n+    if (!this.rewriter.shouldImportSymbol(symbol, moduleName)) {\n+      // The symbol should be referenced directly.\n+      return {moduleImport: null, symbol};\n+    }\n+\n+    // If not, this symbol will be imported. Allocate a prefix for the imported module if needed.\n+\n+    if (!this.specifierToIdentifier.has(moduleName)) {\n+      this.specifierToIdentifier.set(moduleName, `${this.prefix}${this.nextIndex++}`);\n+    }\n+    const moduleImport = this.specifierToIdentifier.get(moduleName)!;\n+\n+    return {moduleImport, symbol};\n+  }\n+\n+  getAllImports(contextPath: string): Import[] {\n+    const imports: {specifier: string, qualifier: string}[] = [];\n+    this.specifierToIdentifier.forEach((qualifier, specifier) => {\n+      specifier = this.rewriter.rewriteSpecifier(specifier, contextPath);\n+      imports.push({specifier, qualifier});\n+    });\n+    return imports;\n+  }\n+}"
        },
        {
            "sha": "c8599239763ce91aaf068282fc96a962e4cc5c5a",
            "filename": "packages/compiler-cli/src/ngtsc/translator/src/translator.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 302,
            "changes": 306,
            "blob_url": "https://github.com/angular/angular/blob/15dfd3439a79f47e4e82552748a4956a40686b10/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftranslator.ts",
            "raw_url": "https://github.com/angular/angular/raw/15dfd3439a79f47e4e82552748a4956a40686b10/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftranslator.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftranslator.ts?ref=15dfd3439a79f47e4e82552748a4956a40686b10",
            "patch": "@@ -6,23 +6,13 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {ArrayType, AssertNotNull, BinaryOperator, BinaryOperatorExpr, BuiltinType, BuiltinTypeName, CastExpr, ClassStmt, CommaExpr, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionType, ExpressionVisitor, ExternalExpr, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, LeadingComment, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, ParseSourceSpan, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, Statement, StatementVisitor, StmtModifier, ThrowStmt, TryCatchStmt, Type, TypeofExpr, TypeVisitor, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr} from '@angular/compiler';\n+import {AssertNotNull, BinaryOperator, BinaryOperatorExpr, CastExpr, ClassStmt, CommaExpr, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionVisitor, ExternalExpr, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, LeadingComment, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, NotExpr, ParseSourceSpan, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, Statement, StatementVisitor, StmtModifier, ThrowStmt, TryCatchStmt, TypeofExpr, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr} from '@angular/compiler';\n import {LocalizedString, UnaryOperator, UnaryOperatorExpr} from '@angular/compiler/src/output/output_ast';\n import * as ts from 'typescript';\n \n-import {DefaultImportRecorder, ImportRewriter, NOOP_DEFAULT_IMPORT_RECORDER, NoopImportRewriter} from '../../imports';\n-\n-export class Context {\n-  constructor(readonly isStatement: boolean) {}\n-\n-  get withExpressionMode(): Context {\n-    return this.isStatement ? new Context(false) : this;\n-  }\n-\n-  get withStatementMode(): Context {\n-    return !this.isStatement ? new Context(true) : this;\n-  }\n-}\n+import {DefaultImportRecorder} from '../../imports';\n+import {Context} from './context';\n+import {ImportManager} from './import_manager';\n \n const UNARY_OPERATORS = new Map<UnaryOperator, ts.PrefixUnaryOperator>([\n   [UnaryOperator.Minus, ts.SyntaxKind.MinusToken],\n@@ -48,65 +38,6 @@ const BINARY_OPERATORS = new Map<BinaryOperator, ts.BinaryOperator>([\n   [BinaryOperator.Plus, ts.SyntaxKind.PlusToken],\n ]);\n \n-/**\n- * Information about an import that has been added to a module.\n- */\n-export interface Import {\n-  /** The name of the module that has been imported. */\n-  specifier: string;\n-  /** The alias of the imported module. */\n-  qualifier: string;\n-}\n-\n-/**\n- * The symbol name and import namespace of an imported symbol,\n- * which has been registered through the ImportManager.\n- */\n-export interface NamedImport {\n-  /** The import namespace containing this imported symbol. */\n-  moduleImport: string|null;\n-  /** The (possibly rewritten) name of the imported symbol. */\n-  symbol: string;\n-}\n-\n-export class ImportManager {\n-  private specifierToIdentifier = new Map<string, string>();\n-  private nextIndex = 0;\n-\n-  constructor(protected rewriter: ImportRewriter = new NoopImportRewriter(), private prefix = 'i') {\n-  }\n-\n-  generateNamedImport(moduleName: string, originalSymbol: string): NamedImport {\n-    // First, rewrite the symbol name.\n-    const symbol = this.rewriter.rewriteSymbol(originalSymbol, moduleName);\n-\n-    // Ask the rewriter if this symbol should be imported at all. If not, it can be referenced\n-    // directly (moduleImport: null).\n-    if (!this.rewriter.shouldImportSymbol(symbol, moduleName)) {\n-      // The symbol should be referenced directly.\n-      return {moduleImport: null, symbol};\n-    }\n-\n-    // If not, this symbol will be imported. Allocate a prefix for the imported module if needed.\n-\n-    if (!this.specifierToIdentifier.has(moduleName)) {\n-      this.specifierToIdentifier.set(moduleName, `${this.prefix}${this.nextIndex++}`);\n-    }\n-    const moduleImport = this.specifierToIdentifier.get(moduleName)!;\n-\n-    return {moduleImport, symbol};\n-  }\n-\n-  getAllImports(contextPath: string): Import[] {\n-    const imports: {specifier: string, qualifier: string}[] = [];\n-    this.specifierToIdentifier.forEach((qualifier, specifier) => {\n-      specifier = this.rewriter.rewriteSpecifier(specifier, contextPath);\n-      imports.push({specifier, qualifier});\n-    });\n-    return imports;\n-  }\n-}\n-\n export function translateExpression(\n     expression: Expression, imports: ImportManager, defaultImportRecorder: DefaultImportRecorder,\n     scriptTarget: Exclude<ts.ScriptTarget, ts.ScriptTarget.JSON>): ts.Expression {\n@@ -123,9 +54,6 @@ export function translateStatement(\n       new Context(true));\n }\n \n-export function translateType(type: Type, imports: ImportManager): ts.TypeNode {\n-  return type.visitType(new TypeTranslatorVisitor(imports), new Context(false));\n-}\n \n class ExpressionTranslatorVisitor implements ExpressionVisitor, StatementVisitor {\n   private externalSourceFiles = new Map<string, ts.SourceMapSource>();\n@@ -544,232 +472,6 @@ class ExpressionTranslatorVisitor implements ExpressionVisitor, StatementVisitor\n   }\n }\n \n-export class TypeTranslatorVisitor implements ExpressionVisitor, TypeVisitor {\n-  constructor(private imports: ImportManager) {}\n-\n-  visitBuiltinType(type: BuiltinType, context: Context): ts.KeywordTypeNode {\n-    switch (type.name) {\n-      case BuiltinTypeName.Bool:\n-        return ts.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\n-      case BuiltinTypeName.Dynamic:\n-        return ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n-      case BuiltinTypeName.Int:\n-      case BuiltinTypeName.Number:\n-        return ts.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\n-      case BuiltinTypeName.String:\n-        return ts.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\n-      case BuiltinTypeName.None:\n-        return ts.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);\n-      default:\n-        throw new Error(`Unsupported builtin type: ${BuiltinTypeName[type.name]}`);\n-    }\n-  }\n-\n-  visitExpressionType(type: ExpressionType, context: Context): ts.TypeNode {\n-    const typeNode = this.translateExpression(type.value, context);\n-    if (type.typeParams === null) {\n-      return typeNode;\n-    }\n-\n-    if (!ts.isTypeReferenceNode(typeNode)) {\n-      throw new Error(\n-          'An ExpressionType with type arguments must translate into a TypeReferenceNode');\n-    } else if (typeNode.typeArguments !== undefined) {\n-      throw new Error(\n-          `An ExpressionType with type arguments cannot have multiple levels of type arguments`);\n-    }\n-\n-    const typeArgs = type.typeParams.map(param => this.translateType(param, context));\n-    return ts.createTypeReferenceNode(typeNode.typeName, typeArgs);\n-  }\n-\n-  visitArrayType(type: ArrayType, context: Context): ts.ArrayTypeNode {\n-    return ts.createArrayTypeNode(this.translateType(type.of, context));\n-  }\n-\n-  visitMapType(type: MapType, context: Context): ts.TypeLiteralNode {\n-    const parameter = ts.createParameter(\n-        undefined, undefined, undefined, 'key', undefined,\n-        ts.createKeywordTypeNode(ts.SyntaxKind.StringKeyword));\n-    const typeArgs = type.valueType !== null ?\n-        this.translateType(type.valueType, context) :\n-        ts.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n-    const indexSignature = ts.createIndexSignature(undefined, undefined, [parameter], typeArgs);\n-    return ts.createTypeLiteralNode([indexSignature]);\n-  }\n-\n-  visitReadVarExpr(ast: ReadVarExpr, context: Context): ts.TypeQueryNode {\n-    if (ast.name === null) {\n-      throw new Error(`ReadVarExpr with no variable name in type`);\n-    }\n-    return ts.createTypeQueryNode(ts.createIdentifier(ast.name));\n-  }\n-\n-  visitWriteVarExpr(expr: WriteVarExpr, context: Context): never {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  visitWriteKeyExpr(expr: WriteKeyExpr, context: Context): never {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  visitWritePropExpr(expr: WritePropExpr, context: Context): never {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  visitInvokeMethodExpr(ast: InvokeMethodExpr, context: Context): never {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: Context): never {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  visitInstantiateExpr(ast: InstantiateExpr, context: Context): never {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  visitLiteralExpr(ast: LiteralExpr, context: Context): ts.TypeNode {\n-    if (ast.value === null) {\n-      // TODO(alan-agius4): Remove when we no longer support TS 3.9\n-      // Use: return ts.createLiteralTypeNode(ts.createNull()) directly.\n-      return ts.versionMajorMinor.charAt(0) === '4' ?\n-          ts.createLiteralTypeNode(ts.createNull() as any) :\n-          ts.createKeywordTypeNode(ts.SyntaxKind.NullKeyword as any);\n-    } else if (ast.value === undefined) {\n-      return ts.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);\n-    } else if (typeof ast.value === 'boolean') {\n-      return ts.createLiteralTypeNode(ts.createLiteral(ast.value));\n-    } else if (typeof ast.value === 'number') {\n-      return ts.createLiteralTypeNode(ts.createLiteral(ast.value));\n-    } else {\n-      return ts.createLiteralTypeNode(ts.createLiteral(ast.value));\n-    }\n-  }\n-\n-  visitLocalizedString(ast: LocalizedString, context: Context): never {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  visitExternalExpr(ast: ExternalExpr, context: Context): ts.EntityName|ts.TypeReferenceNode {\n-    if (ast.value.moduleName === null || ast.value.name === null) {\n-      throw new Error(`Import unknown module or symbol`);\n-    }\n-    const {moduleImport, symbol} =\n-        this.imports.generateNamedImport(ast.value.moduleName, ast.value.name);\n-    const symbolIdentifier = ts.createIdentifier(symbol);\n-\n-    const typeName = moduleImport ?\n-        ts.createQualifiedName(ts.createIdentifier(moduleImport), symbolIdentifier) :\n-        symbolIdentifier;\n-\n-    const typeArguments = ast.typeParams !== null ?\n-        ast.typeParams.map(type => this.translateType(type, context)) :\n-        undefined;\n-    return ts.createTypeReferenceNode(typeName, typeArguments);\n-  }\n-\n-  visitConditionalExpr(ast: ConditionalExpr, context: Context) {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  visitNotExpr(ast: NotExpr, context: Context) {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  visitAssertNotNullExpr(ast: AssertNotNull, context: Context) {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  visitCastExpr(ast: CastExpr, context: Context) {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  visitFunctionExpr(ast: FunctionExpr, context: Context) {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: Context) {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: Context) {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  visitReadPropExpr(ast: ReadPropExpr, context: Context) {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  visitReadKeyExpr(ast: ReadKeyExpr, context: Context) {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: Context): ts.TupleTypeNode {\n-    const values = ast.entries.map(expr => this.translateExpression(expr, context));\n-    return ts.createTupleTypeNode(values);\n-  }\n-\n-  visitLiteralMapExpr(ast: LiteralMapExpr, context: Context): ts.TypeLiteralNode {\n-    const entries = ast.entries.map(entry => {\n-      const {key, quoted} = entry;\n-      const type = this.translateExpression(entry.value, context);\n-      return ts.createPropertySignature(\n-          /* modifiers */ undefined,\n-          /* name */ quoted ? ts.createStringLiteral(key) : key,\n-          /* questionToken */ undefined,\n-          /* type */ type,\n-          /* initializer */ undefined);\n-    });\n-    return ts.createTypeLiteralNode(entries);\n-  }\n-\n-  visitCommaExpr(ast: CommaExpr, context: Context) {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: Context): ts.TypeNode {\n-    const node: ts.Node = ast.node;\n-    if (ts.isEntityName(node)) {\n-      return ts.createTypeReferenceNode(node, /* typeArguments */ undefined);\n-    } else if (ts.isTypeNode(node)) {\n-      return node;\n-    } else if (ts.isLiteralExpression(node)) {\n-      return ts.createLiteralTypeNode(node);\n-    } else {\n-      throw new Error(\n-          `Unsupported WrappedNodeExpr in TypeTranslatorVisitor: ${ts.SyntaxKind[node.kind]}`);\n-    }\n-  }\n-\n-  visitTypeofExpr(ast: TypeofExpr, context: Context): ts.TypeQueryNode {\n-    const typeNode = this.translateExpression(ast.expr, context);\n-    if (!ts.isTypeReferenceNode(typeNode)) {\n-      throw new Error(`The target of a typeof expression must be a type reference, but it was\n-          ${ts.SyntaxKind[typeNode.kind]}`);\n-    }\n-    return ts.createTypeQueryNode(typeNode.typeName);\n-  }\n-\n-  private translateType(type: Type, context: Context): ts.TypeNode {\n-    const typeNode = type.visitType(this, context);\n-    if (!ts.isTypeNode(typeNode)) {\n-      throw new Error(\n-          `A Type must translate to a TypeNode, but was ${ts.SyntaxKind[typeNode.kind]}`);\n-    }\n-    return typeNode;\n-  }\n-\n-  private translateExpression(expr: Expression, context: Context): ts.TypeNode {\n-    const typeNode = expr.visitExpression(this, context);\n-    if (!ts.isTypeNode(typeNode)) {\n-      throw new Error(\n-          `An Expression must translate to a TypeNode, but was ${ts.SyntaxKind[typeNode.kind]}`);\n-    }\n-    return typeNode;\n-  }\n-}\n-\n // HACK: Use this in place of `ts.createTemplateMiddle()`.\n // Revert once https://github.com/microsoft/TypeScript/issues/35374 is fixed\n function createTemplateMiddle(cooked: string, raw: string): ts.TemplateMiddle {"
        },
        {
            "sha": "6f364d4cf118897eeb2aac4a4aed088e245a6563",
            "filename": "packages/compiler-cli/src/ngtsc/translator/src/type_translator.ts",
            "status": "added",
            "additions": 244,
            "deletions": 0,
            "changes": 244,
            "blob_url": "https://github.com/angular/angular/blob/15dfd3439a79f47e4e82552748a4956a40686b10/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftype_translator.ts",
            "raw_url": "https://github.com/angular/angular/raw/15dfd3439a79f47e4e82552748a4956a40686b10/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftype_translator.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftype_translator.ts?ref=15dfd3439a79f47e4e82552748a4956a40686b10",
            "patch": "@@ -0,0 +1,244 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {ArrayType, AssertNotNull, BinaryOperatorExpr, BuiltinType, BuiltinTypeName, CastExpr, CommaExpr, ConditionalExpr, Expression, ExpressionType, ExpressionVisitor, ExternalExpr, FunctionExpr, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, LocalizedString, MapType, NotExpr, ReadKeyExpr, ReadPropExpr, ReadVarExpr, Type, TypeofExpr, TypeVisitor, UnaryOperatorExpr, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr} from '@angular/compiler';\n+import * as ts from 'typescript';\n+\n+import {Context} from './context';\n+import {ImportManager} from './import_manager';\n+\n+\n+export function translateType(type: Type, imports: ImportManager): ts.TypeNode {\n+  return type.visitType(new TypeTranslatorVisitor(imports), new Context(false));\n+}\n+\n+export class TypeTranslatorVisitor implements ExpressionVisitor, TypeVisitor {\n+  constructor(private imports: ImportManager) {}\n+\n+  visitBuiltinType(type: BuiltinType, context: Context): ts.KeywordTypeNode {\n+    switch (type.name) {\n+      case BuiltinTypeName.Bool:\n+        return ts.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\n+      case BuiltinTypeName.Dynamic:\n+        return ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n+      case BuiltinTypeName.Int:\n+      case BuiltinTypeName.Number:\n+        return ts.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\n+      case BuiltinTypeName.String:\n+        return ts.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\n+      case BuiltinTypeName.None:\n+        return ts.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);\n+      default:\n+        throw new Error(`Unsupported builtin type: ${BuiltinTypeName[type.name]}`);\n+    }\n+  }\n+\n+  visitExpressionType(type: ExpressionType, context: Context): ts.TypeNode {\n+    const typeNode = this.translateExpression(type.value, context);\n+    if (type.typeParams === null) {\n+      return typeNode;\n+    }\n+\n+    if (!ts.isTypeReferenceNode(typeNode)) {\n+      throw new Error(\n+          'An ExpressionType with type arguments must translate into a TypeReferenceNode');\n+    } else if (typeNode.typeArguments !== undefined) {\n+      throw new Error(\n+          `An ExpressionType with type arguments cannot have multiple levels of type arguments`);\n+    }\n+\n+    const typeArgs = type.typeParams.map(param => this.translateType(param, context));\n+    return ts.createTypeReferenceNode(typeNode.typeName, typeArgs);\n+  }\n+\n+  visitArrayType(type: ArrayType, context: Context): ts.ArrayTypeNode {\n+    return ts.createArrayTypeNode(this.translateType(type.of, context));\n+  }\n+\n+  visitMapType(type: MapType, context: Context): ts.TypeLiteralNode {\n+    const parameter = ts.createParameter(\n+        undefined, undefined, undefined, 'key', undefined,\n+        ts.createKeywordTypeNode(ts.SyntaxKind.StringKeyword));\n+    const typeArgs = type.valueType !== null ?\n+        this.translateType(type.valueType, context) :\n+        ts.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n+    const indexSignature = ts.createIndexSignature(undefined, undefined, [parameter], typeArgs);\n+    return ts.createTypeLiteralNode([indexSignature]);\n+  }\n+\n+  visitReadVarExpr(ast: ReadVarExpr, context: Context): ts.TypeQueryNode {\n+    if (ast.name === null) {\n+      throw new Error(`ReadVarExpr with no variable name in type`);\n+    }\n+    return ts.createTypeQueryNode(ts.createIdentifier(ast.name));\n+  }\n+\n+  visitWriteVarExpr(expr: WriteVarExpr, context: Context): never {\n+    throw new Error('Method not implemented.');\n+  }\n+\n+  visitWriteKeyExpr(expr: WriteKeyExpr, context: Context): never {\n+    throw new Error('Method not implemented.');\n+  }\n+\n+  visitWritePropExpr(expr: WritePropExpr, context: Context): never {\n+    throw new Error('Method not implemented.');\n+  }\n+\n+  visitInvokeMethodExpr(ast: InvokeMethodExpr, context: Context): never {\n+    throw new Error('Method not implemented.');\n+  }\n+\n+  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: Context): never {\n+    throw new Error('Method not implemented.');\n+  }\n+\n+  visitInstantiateExpr(ast: InstantiateExpr, context: Context): never {\n+    throw new Error('Method not implemented.');\n+  }\n+\n+  visitLiteralExpr(ast: LiteralExpr, context: Context): ts.TypeNode {\n+    if (ast.value === null) {\n+      // TODO(alan-agius4): Remove when we no longer support TS 3.9\n+      // Use: return ts.createLiteralTypeNode(ts.createNull()) directly.\n+      return ts.versionMajorMinor.charAt(0) === '4' ?\n+          ts.createLiteralTypeNode(ts.createNull() as any) :\n+          ts.createKeywordTypeNode(ts.SyntaxKind.NullKeyword as any);\n+    } else if (ast.value === undefined) {\n+      return ts.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);\n+    } else if (typeof ast.value === 'boolean') {\n+      return ts.createLiteralTypeNode(ts.createLiteral(ast.value));\n+    } else if (typeof ast.value === 'number') {\n+      return ts.createLiteralTypeNode(ts.createLiteral(ast.value));\n+    } else {\n+      return ts.createLiteralTypeNode(ts.createLiteral(ast.value));\n+    }\n+  }\n+\n+  visitLocalizedString(ast: LocalizedString, context: Context): never {\n+    throw new Error('Method not implemented.');\n+  }\n+\n+  visitExternalExpr(ast: ExternalExpr, context: Context): ts.EntityName|ts.TypeReferenceNode {\n+    if (ast.value.moduleName === null || ast.value.name === null) {\n+      throw new Error(`Import unknown module or symbol`);\n+    }\n+    const {moduleImport, symbol} =\n+        this.imports.generateNamedImport(ast.value.moduleName, ast.value.name);\n+    const symbolIdentifier = ts.createIdentifier(symbol);\n+\n+    const typeName = moduleImport ?\n+        ts.createQualifiedName(ts.createIdentifier(moduleImport), symbolIdentifier) :\n+        symbolIdentifier;\n+\n+    const typeArguments = ast.typeParams !== null ?\n+        ast.typeParams.map(type => this.translateType(type, context)) :\n+        undefined;\n+    return ts.createTypeReferenceNode(typeName, typeArguments);\n+  }\n+\n+  visitConditionalExpr(ast: ConditionalExpr, context: Context) {\n+    throw new Error('Method not implemented.');\n+  }\n+\n+  visitNotExpr(ast: NotExpr, context: Context) {\n+    throw new Error('Method not implemented.');\n+  }\n+\n+  visitAssertNotNullExpr(ast: AssertNotNull, context: Context) {\n+    throw new Error('Method not implemented.');\n+  }\n+\n+  visitCastExpr(ast: CastExpr, context: Context) {\n+    throw new Error('Method not implemented.');\n+  }\n+\n+  visitFunctionExpr(ast: FunctionExpr, context: Context) {\n+    throw new Error('Method not implemented.');\n+  }\n+\n+  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: Context) {\n+    throw new Error('Method not implemented.');\n+  }\n+\n+  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: Context) {\n+    throw new Error('Method not implemented.');\n+  }\n+\n+  visitReadPropExpr(ast: ReadPropExpr, context: Context) {\n+    throw new Error('Method not implemented.');\n+  }\n+\n+  visitReadKeyExpr(ast: ReadKeyExpr, context: Context) {\n+    throw new Error('Method not implemented.');\n+  }\n+\n+  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: Context): ts.TupleTypeNode {\n+    const values = ast.entries.map(expr => this.translateExpression(expr, context));\n+    return ts.createTupleTypeNode(values);\n+  }\n+\n+  visitLiteralMapExpr(ast: LiteralMapExpr, context: Context): ts.TypeLiteralNode {\n+    const entries = ast.entries.map(entry => {\n+      const {key, quoted} = entry;\n+      const type = this.translateExpression(entry.value, context);\n+      return ts.createPropertySignature(\n+          /* modifiers */ undefined,\n+          /* name */ quoted ? ts.createStringLiteral(key) : key,\n+          /* questionToken */ undefined,\n+          /* type */ type,\n+          /* initializer */ undefined);\n+    });\n+    return ts.createTypeLiteralNode(entries);\n+  }\n+\n+  visitCommaExpr(ast: CommaExpr, context: Context) {\n+    throw new Error('Method not implemented.');\n+  }\n+\n+  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: Context): ts.TypeNode {\n+    const node: ts.Node = ast.node;\n+    if (ts.isEntityName(node)) {\n+      return ts.createTypeReferenceNode(node, /* typeArguments */ undefined);\n+    } else if (ts.isTypeNode(node)) {\n+      return node;\n+    } else if (ts.isLiteralExpression(node)) {\n+      return ts.createLiteralTypeNode(node);\n+    } else {\n+      throw new Error(\n+          `Unsupported WrappedNodeExpr in TypeTranslatorVisitor: ${ts.SyntaxKind[node.kind]}`);\n+    }\n+  }\n+\n+  visitTypeofExpr(ast: TypeofExpr, context: Context): ts.TypeQueryNode {\n+    const typeNode = this.translateExpression(ast.expr, context);\n+    if (!ts.isTypeReferenceNode(typeNode)) {\n+      throw new Error(`The target of a typeof expression must be a type reference, but it was\n+          ${ts.SyntaxKind[typeNode.kind]}`);\n+    }\n+    return ts.createTypeQueryNode(typeNode.typeName);\n+  }\n+\n+  private translateType(type: Type, context: Context): ts.TypeNode {\n+    const typeNode = type.visitType(this, context);\n+    if (!ts.isTypeNode(typeNode)) {\n+      throw new Error(\n+          `A Type must translate to a TypeNode, but was ${ts.SyntaxKind[typeNode.kind]}`);\n+    }\n+    return typeNode;\n+  }\n+\n+  private translateExpression(expr: Expression, context: Context): ts.TypeNode {\n+    const typeNode = expr.visitExpression(this, context);\n+    if (!ts.isTypeNode(typeNode)) {\n+      throw new Error(\n+          `An Expression must translate to a TypeNode, but was ${ts.SyntaxKind[typeNode.kind]}`);\n+    }\n+    return typeNode;\n+  }\n+}"
        }
    ],
    "stats": {
        "total": 645,
        "additions": 342,
        "deletions": 303
    }
}