{
    "author": "danieltre23",
    "message": "refactor(compiler-cli): introduce `getExtendedTemplateDiagnosticsForComponent` function (#42984)\n\nAdd function to get extended template diagnostics generated by all the template checks.\n\nRefs #42966\n\nPR Close #42984",
    "sha": "be8a8e17a8e80d52308690b0e1ee5a1f529c6e78",
    "files": [
        {
            "sha": "ca8d5b1c9ffc18849e20ecf13cd93027fb5b8566",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/extended/BUILD.bazel",
            "status": "added",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/be8a8e17a8e80d52308690b0e1ee5a1f529c6e78/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fextended%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/be8a8e17a8e80d52308690b0e1ee5a1f529c6e78/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fextended%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fextended%2FBUILD.bazel?ref=be8a8e17a8e80d52308690b0e1ee5a1f529c6e78",
            "patch": "@@ -0,0 +1,15 @@\n+load(\"//tools:defaults.bzl\", \"ts_library\")\n+\n+ts_library(\n+    name = \"extended\",\n+    srcs = glob(\n+        [\"**/*.ts\"],\n+    ),\n+    visibility = [\"//packages/compiler-cli/src/ngtsc:__subpackages__\"],\n+    deps = [\n+        \"//packages/compiler-cli/src/ngtsc/diagnostics\",\n+        \"//packages/compiler-cli/src/ngtsc/typecheck/api\",\n+        \"//packages/compiler-cli/src/ngtsc/typecheck/extended/api\",\n+        \"@npm//typescript\",\n+    ],\n+)"
        },
        {
            "sha": "f92e4242164a2cdf6a1f5b8e5b031bdd269aab54",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/extended/src/template_checker.ts",
            "status": "added",
            "additions": 92,
            "deletions": 0,
            "changes": 92,
            "blob_url": "https://github.com/angular/angular/blob/be8a8e17a8e80d52308690b0e1ee5a1f529c6e78/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fextended%2Fsrc%2Ftemplate_checker.ts",
            "raw_url": "https://github.com/angular/angular/raw/be8a8e17a8e80d52308690b0e1ee5a1f529c6e78/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fextended%2Fsrc%2Ftemplate_checker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fextended%2Fsrc%2Ftemplate_checker.ts?ref=be8a8e17a8e80d52308690b0e1ee5a1f529c6e78",
            "patch": "@@ -0,0 +1,92 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as ts from 'typescript';\n+import {ErrorCode} from '../../../diagnostics';\n+import {TemplateTypeChecker} from '../../api';\n+import {TemplateCheck, TemplateContext} from '../api/api';\n+\n+/**\n+ * Run all `TemplateChecks` for a component and return the generated `ts.Diagnostic`s.\n+ * @param component the `@Component()` class from which the template is obtained\n+ * @param templateTypeChecker interface to get information about template nodes\n+ * @param typeChecker program's type checker\n+ * @param templateChecks specific checks to be run\n+ * @returns generated `ts.Diagnostic[]`\n+ */\n+export function getExtendedTemplateDiagnosticsForComponent(\n+    component: ts.ClassDeclaration, templateTypeChecker: TemplateTypeChecker,\n+    typeChecker: ts.TypeChecker, templateChecks: TemplateCheck<ErrorCode>[]): ts.Diagnostic[] {\n+  const template = templateTypeChecker.getTemplate(component);\n+  // Skip checks if component has no template. This can happen if the user writes a\n+  // `@Component()` but doesn't add the template, could happen in the language service\n+  // when users are in the middle of typing code.\n+  if (template === null) {\n+    return [];\n+  }\n+  const diagnostics: ts.Diagnostic[] = [];\n+\n+  const ctx = {templateTypeChecker, typeChecker, component} as TemplateContext;\n+\n+  for (const check of templateChecks) {\n+    diagnostics.push(...deduplicateDiagnostics(check.run(ctx, template)));\n+  }\n+\n+  return diagnostics;\n+}\n+\n+// Filter out duplicated diagnostics, this is possible due to the way the compiler\n+// handles desugaring and produces `AST`s. Ex.\n+//\n+// ```\n+// <div *ngIf=\"true\" (foo)=\"bar\">test</div>\n+// ```\n+//\n+// Would result in the following AST:\n+//\n+// ```\n+// Template {\n+//   outputs: [\n+//    BoundEvent {\n+//      name: 'foo',\n+//      /.../\n+//    }\n+//   ],\n+//   children: [\n+//     Element {\n+//       outputs: [\n+//         BoundEvent {\n+//           name: 'foo',\n+//           /.../\n+//         }\n+//       ]\n+//     }\n+//   ],\n+//   /.../\n+// }\n+// ```\n+//\n+// In this case a duplicated diagnostic could be generated for the output `foo`.\n+// TODO(danieltrevino): handle duplicated diagnostics when they are being generated\n+// to avoid extra work (could be directly in the visitor).\n+// https://github.com/angular/angular/pull/42984#discussion_r684823926\n+function deduplicateDiagnostics(diagnostics: ts.Diagnostic[]): ts.Diagnostic[] {\n+  const result: ts.Diagnostic[] = [];\n+  for (const newDiag of diagnostics) {\n+    const isDuplicateDiag = result.some(existingDiag => areDiagnosticsEqual(newDiag, existingDiag));\n+    if (!isDuplicateDiag) {\n+      result.push(newDiag);\n+    }\n+  }\n+  return result;\n+}\n+\n+function areDiagnosticsEqual(first: ts.Diagnostic, second: ts.Diagnostic): boolean {\n+  return first.file?.fileName === second.file?.fileName && first.start === second.start &&\n+      first.length === second.length && first.code === second.code;\n+}"
        }
    ],
    "stats": {
        "total": 107,
        "additions": 107,
        "deletions": 0
    }
}