{
    "author": "ayazhafiz",
    "message": "refactor(compiler): iteratively parse interpolations (#38977)\n\nThis patch refactors the interpolation parser to do so iteratively\nrather than using a regex. Doing so prepares us for supporting granular\nrecovery on poorly-formed interpolations, for example when an\ninterpolation does not terminate (`{{ 1 + 2`) or is not terminated\nproperly (`{{ 1 + 2 {{ 2 + 3 }}`).\n\nPart of #38596\n\nPR Close #38977",
    "sha": "89c5255b8ca59eed27ede9e1fad69857ab0c6f4f",
    "files": [
        {
            "sha": "4b5b28b8b5ec564a89b3c5ab6d3e7356cbf5975c",
            "filename": "packages/compiler/src/expression_parser/parser.ts",
            "status": "modified",
            "additions": 63,
            "deletions": 28,
            "changes": 91,
            "blob_url": "https://github.com/angular/angular/blob/89c5255b8ca59eed27ede9e1fad69857ab0c6f4f/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "raw_url": "https://github.com/angular/angular/raw/89c5255b8ca59eed27ede9e1fad69857ab0c6f4f/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts?ref=89c5255b8ca59eed27ede9e1fad69857ab0c6f4f",
            "patch": "@@ -185,47 +185,82 @@ export class Parser {\n         location, absoluteOffset, this.errors);\n   }\n \n+  /**\n+   * Splits a string of text into \"raw\" text segments and expressions present in interpolations in\n+   * the string.\n+   * Returns `null` if there are no interpolations, otherwise a\n+   * `SplitInterpolation` with splits that look like\n+   *   <raw text> <expression> <raw text> ... <raw text> <expression> <raw text>\n+   */\n   splitInterpolation(\n       input: string, location: string,\n       interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): SplitInterpolation\n       |null {\n-    const regexp = _getInterpolateRegExp(interpolationConfig);\n-    const parts = input.split(regexp);\n-    if (parts.length <= 1) {\n-      return null;\n-    }\n     const strings: string[] = [];\n     const expressions: string[] = [];\n     const offsets: number[] = [];\n     const stringSpans: {start: number, end: number}[] = [];\n     const expressionSpans: {start: number, end: number}[] = [];\n-    let offset = 0;\n-    for (let i = 0; i < parts.length; i++) {\n-      const part: string = parts[i];\n-      if (i % 2 === 0) {\n-        // fixed string\n+    let i = 0;\n+    let atInterpolation = false;\n+    let extendLastString = false;\n+    let {start: interpStart, end: interpEnd} = interpolationConfig;\n+    while (i < input.length) {\n+      if (!atInterpolation) {\n+        // parse until starting {{\n+        const start = i;\n+        i = input.indexOf(interpStart, i);\n+        if (i === -1) {\n+          i = input.length;\n+        }\n+        const part = input.substring(start, i);\n         strings.push(part);\n-        const start = offset;\n-        offset += part.length;\n-        stringSpans.push({start, end: offset});\n-      } else if (part.trim().length > 0) {\n-        const start = offset;\n-        offset += interpolationConfig.start.length;\n-        expressions.push(part);\n-        offsets.push(offset);\n-        offset += part.length + interpolationConfig.end.length;\n-        expressionSpans.push({start, end: offset});\n+        stringSpans.push({start, end: i});\n+\n+        atInterpolation = true;\n+      } else {\n+        // parse from starting {{ to ending }}\n+        const fullStart = i;\n+        const exprStart = fullStart + interpStart.length;\n+        const exprEnd = input.indexOf(interpEnd, exprStart);\n+        if (exprEnd === -1) {\n+          // Could not find the end of the interpolation; do not parse an expression.\n+          // Instead we should extend the content on the last raw string.\n+          atInterpolation = false;\n+          extendLastString = true;\n+          break;\n+        }\n+        const fullEnd = exprEnd + interpEnd.length;\n+\n+        const part = input.substring(exprStart, exprEnd);\n+        if (part.trim().length > 0) {\n+          expressions.push(part);\n+        } else {\n+          this._reportError(\n+              'Blank expressions are not allowed in interpolated strings', input,\n+              `at column ${i} in`, location);\n+          expressions.push('$implicit');\n+        }\n+        offsets.push(exprStart);\n+        expressionSpans.push({start: fullStart, end: fullEnd});\n+\n+        i = fullEnd;\n+        atInterpolation = false;\n+      }\n+    }\n+    if (!atInterpolation) {\n+      // If we are now at a text section, add the remaining content as a raw string.\n+      if (extendLastString) {\n+        strings[strings.length - 1] += input.substring(i);\n+        stringSpans[stringSpans.length - 1].end = input.length;\n       } else {\n-        this._reportError(\n-            'Blank expressions are not allowed in interpolated strings', input,\n-            `at column ${this._findInterpolationErrorColumn(parts, i, interpolationConfig)} in`,\n-            location);\n-        expressions.push('$implicit');\n-        offsets.push(offset);\n-        expressionSpans.push({start: offset, end: offset});\n+        strings.push(input.substring(i));\n+        stringSpans.push({start: i, end: input.length});\n       }\n     }\n-    return new SplitInterpolation(strings, stringSpans, expressions, expressionSpans, offsets);\n+    return expressions.length === 0 ?\n+        null :\n+        new SplitInterpolation(strings, stringSpans, expressions, expressionSpans, offsets);\n   }\n \n   wrapLiteralPrimitive(input: string|null, location: any, absoluteOffset: number): ASTWithSource {"
        },
        {
            "sha": "0c1f33c8f2a273cbbac5e69a62d0223bb7d0c77e",
            "filename": "packages/compiler/test/expression_parser/parser_spec.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/89c5255b8ca59eed27ede9e1fad69857ab0c6f4f/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/89c5255b8ca59eed27ede9e1fad69857ab0c6f4f/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts?ref=89c5255b8ca59eed27ede9e1fad69857ab0c6f4f",
            "patch": "@@ -728,6 +728,13 @@ describe('parser', () => {\n       expect(parseInterpolation('nothing')).toBe(null);\n     });\n \n+    it('should not parse malformed interpolations as strings', () => {\n+      const ast = parseInterpolation('{{a}} {{example}<!--->}')!.ast as Interpolation;\n+      expect(ast.strings).toEqual(['', ' {{example}<!--->}']);\n+      expect(ast.expressions.length).toEqual(1);\n+      expect(ast.expressions[0].name).toEqual('a');\n+    });\n+\n     it('should parse no prefix/suffix interpolation', () => {\n       const ast = parseInterpolation('{{a}}')!.ast as Interpolation;\n       expect(ast.strings).toEqual(['', '']);"
        }
    ],
    "stats": {
        "total": 98,
        "additions": 70,
        "deletions": 28
    }
}