{
    "author": "alxhub",
    "message": "refactor(compiler-cli): efficient single-file type checking diagnostics (#38105)\n\nPreviously, the `TemplateTypeChecker` abstraction allowed fetching\ndiagnostics for a single file, but under the hood would generate type\nchecking code for the entire program to satisfy the request.\n\nWith this commit, an `OptimizeFor` hint is passed to `getDiagnosticsForFile`\nwhich indicates whether the user intends to request diagnostics for the\nwhole program or is truly interested in just the single file. If the latter,\nthe `TemplateTypeChecker` can perform only the work needed to produce\ndiagnostics for just that file, thus returning answers more efficiently.\n\nPR Close #38105",
    "sha": "de14b2c6709297cadb1923faac6f4586fd78f67b",
    "files": [
        {
            "sha": "6e7cd3ff04c6a29902a33c31882549a621cbecb9",
            "filename": "packages/compiler-cli/src/ngtsc/core/src/compiler.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/de14b2c6709297cadb1923faac6f4586fd78f67b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/de14b2c6709297cadb1923faac6f4586fd78f67b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts?ref=de14b2c6709297cadb1923faac6f4586fd78f67b",
            "patch": "@@ -29,7 +29,7 @@ import {generatedFactoryTransform} from '../../shims';\n import {ivySwitchTransform} from '../../switch';\n import {aliasTransformFactory, declarationTransformFactory, DecoratorHandler, DtsTransformRegistry, ivyTransformFactory, TraitCompiler} from '../../transform';\n import {isTemplateDiagnostic, TemplateTypeCheckerImpl} from '../../typecheck';\n-import {TemplateTypeChecker, TypeCheckingConfig, TypeCheckingProgramStrategy} from '../../typecheck/api';\n+import {OptimizeFor, TemplateTypeChecker, TypeCheckingConfig, TypeCheckingProgramStrategy} from '../../typecheck/api';\n import {getSourceFileOrNull, isDtsPath, resolveModuleName} from '../../util/src/typescript';\n import {LazyRoute, NgCompilerAdapter, NgCompilerOptions} from '../api';\n \n@@ -507,7 +507,8 @@ export class NgCompiler {\n         continue;\n       }\n \n-      diagnostics.push(...compilation.templateTypeChecker.getDiagnosticsForFile(sf));\n+      diagnostics.push(\n+          ...compilation.templateTypeChecker.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram));\n     }\n \n     const program = this.typeCheckingProgramStrategy.getProgram();"
        },
        {
            "sha": "7b4ff3e2b5a9814b84a9e42cae377d307d757338",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/checker.ts",
            "status": "modified",
            "additions": 33,
            "deletions": 1,
            "changes": 34,
            "blob_url": "https://github.com/angular/angular/blob/de14b2c6709297cadb1923faac6f4586fd78f67b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/de14b2c6709297cadb1923faac6f4586fd78f67b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts?ref=de14b2c6709297cadb1923faac6f4586fd78f67b",
            "patch": "@@ -29,8 +29,16 @@ export interface TemplateTypeChecker {\n    *\n    * This method will fail (throw) if there are components within the `ts.SourceFile` that do not\n    * have TCBs available.\n+   *\n+   * Generating a template type-checking program is expensive, and in some workflows (e.g. checking\n+   * an entire program before emit), it should ideally only be done once. The `optimizeFor` flag\n+   * allows the caller to hint to `getDiagnosticsForFile` (which internally will create a template\n+   * type-checking program if needed) whether the caller is interested in just the results of the\n+   * single file, or whether they plan to query about other files in the program. Based on this\n+   * flag, `getDiagnosticsForFile` will determine how much of the user's program to prepare for\n+   * checking as part of the template type-checking program it creates.\n    */\n-  getDiagnosticsForFile(sf: ts.SourceFile): ts.Diagnostic[];\n+  getDiagnosticsForFile(sf: ts.SourceFile, optimizeFor: OptimizeFor): ts.Diagnostic[];\n \n   /**\n    * Retrieve the top-level node representing the TCB for the given component.\n@@ -41,3 +49,27 @@ export interface TemplateTypeChecker {\n    */\n   getTypeCheckBlock(component: ts.ClassDeclaration): ts.Node|null;\n }\n+\n+/**\n+ * Describes the scope of the caller's interest in template type-checking results.\n+ */\n+export enum OptimizeFor {\n+  /**\n+   * Indicates that a consumer of a `TemplateTypeChecker` is only interested in results for a given\n+   * file, and wants them as fast as possible.\n+   *\n+   * Calling `TemplateTypeChecker` methods successively for multiple files while specifying\n+   * `OptimizeFor.SingleFile` can result in significant unnecessary overhead overall.\n+   */\n+  SingleFile,\n+\n+  /**\n+   * Indicates that a consumer of a `TemplateTypeChecker` intends to query for results pertaining to\n+   * the entire user program, and so the type-checker should internally optimize for this case.\n+   *\n+   * Initial calls to retrieve type-checking information may take longer, but repeated calls to\n+   * gather information for the whole user program will be significantly faster with this mode of\n+   * optimization.\n+   */\n+  WholeProgram,\n+}"
        },
        {
            "sha": "d6197ac821c73d88fbe2b36501bb72e1e192437b",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts",
            "status": "modified",
            "additions": 115,
            "deletions": 5,
            "changes": 120,
            "blob_url": "https://github.com/angular/angular/blob/de14b2c6709297cadb1923faac6f4586fd78f67b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/de14b2c6709297cadb1923faac6f4586fd78f67b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts?ref=de14b2c6709297cadb1923faac6f4586fd78f67b",
            "patch": "@@ -14,7 +14,7 @@ import {IncrementalBuild} from '../../incremental/api';\n import {ReflectionHost} from '../../reflection';\n import {isShim} from '../../shims';\n import {getSourceFileOrNull} from '../../util/src/typescript';\n-import {ProgramTypeCheckAdapter, TemplateTypeChecker, TypeCheckingConfig, TypeCheckingProgramStrategy, UpdateMode} from '../api';\n+import {OptimizeFor, ProgramTypeCheckAdapter, TemplateTypeChecker, TypeCheckingConfig, TypeCheckingProgramStrategy, UpdateMode} from '../api';\n \n import {InliningMode, ShimTypeCheckingData, TypeCheckContextImpl, TypeCheckingHost} from './context';\n import {findTypeCheckBlock, shouldReportDiagnostic, TemplateSourceResolver, translateDiagnostic} from './diagnostics';\n@@ -41,8 +41,15 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n    * Retrieve type-checking diagnostics from the given `ts.SourceFile` using the most recent\n    * type-checking program.\n    */\n-  getDiagnosticsForFile(sf: ts.SourceFile): ts.Diagnostic[] {\n-    this.ensureAllShimsForAllFiles();\n+  getDiagnosticsForFile(sf: ts.SourceFile, optimizeFor: OptimizeFor): ts.Diagnostic[] {\n+    switch (optimizeFor) {\n+      case OptimizeFor.WholeProgram:\n+        this.ensureAllShimsForAllFiles();\n+        break;\n+      case OptimizeFor.SingleFile:\n+        this.ensureAllShimsForOneFile(sf);\n+        break;\n+    }\n \n     const sfPath = absoluteFromSourceFile(sf);\n     const fileRecord = this.state.get(sfPath)!;\n@@ -68,7 +75,7 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n   }\n \n   getTypeCheckBlock(component: ts.ClassDeclaration): ts.Node|null {\n-    this.ensureAllShimsForAllFiles();\n+    this.ensureAllShimsForOneFile(component.getSourceFile());\n \n     const program = this.typeCheckingStrategy.getProgram();\n     const filePath = absoluteFromSourceFile(component.getSourceFile());\n@@ -81,7 +88,7 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     const id = fileRecord.sourceManager.getTemplateId(component);\n \n     const shimSf = getSourceFileOrNull(program, shimPath);\n-    if (shimSf === null) {\n+    if (shimSf === null || !fileRecord.shimData.has(shimPath)) {\n       throw new Error(`Error: no shim file in program: ${shimPath}`);\n     }\n \n@@ -144,6 +151,27 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     this.isComplete = true;\n   }\n \n+  private ensureAllShimsForOneFile(sf: ts.SourceFile): void {\n+    this.maybeAdoptPriorResultsForFile(sf);\n+\n+    const sfPath = absoluteFromSourceFile(sf);\n+\n+    const fileData = this.getFileData(sfPath);\n+    if (fileData.isComplete) {\n+      // All data for this file is present and accounted for already.\n+      return;\n+    }\n+\n+    const host = new SingleFileTypeCheckingHost(sfPath, fileData, this.typeCheckingStrategy, this);\n+    const ctx = this.newContext(host);\n+\n+    this.typeCheckAdapter.typeCheck(sf, ctx);\n+\n+    fileData.isComplete = true;\n+\n+    this.updateFromContext(ctx);\n+  }\n+\n   private newContext(host: TypeCheckingHost): TypeCheckContextImpl {\n     const inlining = this.typeCheckingStrategy.supportsInlineOperations ? InliningMode.InlineOps :\n                                                                           InliningMode.Error;\n@@ -152,6 +180,30 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n         host, inlining);\n   }\n \n+  /**\n+   * Remove any shim data that depends on inline operations applied to the type-checking program.\n+   *\n+   * This can be useful if new inlines need to be applied, and it's not possible to guarantee that\n+   * they won't overwrite or corrupt existing inlines that are used by such shims.\n+   */\n+  clearAllShimDataUsingInlines(): void {\n+    for (const fileData of this.state.values()) {\n+      if (!fileData.hasInlines) {\n+        continue;\n+      }\n+\n+      for (const [shimFile, shimData] of fileData.shimData.entries()) {\n+        if (shimData.hasInlines) {\n+          fileData.shimData.delete(shimFile);\n+        }\n+      }\n+\n+      fileData.hasInlines = false;\n+      fileData.isComplete = false;\n+      this.isComplete = false;\n+    }\n+  }\n+\n   private updateFromContext(ctx: TypeCheckContextImpl): void {\n     const updates = ctx.finalize();\n     this.typeCheckingStrategy.updateFiles(updates, UpdateMode.Incremental);\n@@ -240,3 +292,61 @@ class WholeProgramTypeCheckingHost implements TypeCheckingHost {\n     this.impl.getFileData(sfPath).isComplete = true;\n   }\n }\n+\n+/**\n+ * Drives a `TypeCheckContext` to generate type-checking code efficiently for a single input file.\n+ */\n+class SingleFileTypeCheckingHost implements TypeCheckingHost {\n+  private seenInlines = false;\n+\n+  constructor(\n+      private sfPath: AbsoluteFsPath, private fileData: FileTypeCheckingData,\n+      private strategy: TypeCheckingProgramStrategy, private impl: TemplateTypeCheckerImpl) {}\n+\n+  private assertPath(sfPath: AbsoluteFsPath): void {\n+    if (this.sfPath !== sfPath) {\n+      throw new Error(`AssertionError: querying TypeCheckingHost outside of assigned file`);\n+    }\n+  }\n+\n+  getSourceManager(sfPath: AbsoluteFsPath): TemplateSourceManager {\n+    this.assertPath(sfPath);\n+    return this.fileData.sourceManager;\n+  }\n+\n+  shouldCheckComponent(node: ts.ClassDeclaration): boolean {\n+    if (this.sfPath !== absoluteFromSourceFile(node.getSourceFile())) {\n+      return false;\n+    }\n+    const shimPath = this.strategy.shimPathForComponent(node);\n+\n+    // Only need to generate a TCB for the class if no shim exists for it currently.\n+    return !this.fileData.shimData.has(shimPath);\n+  }\n+\n+  recordShimData(sfPath: AbsoluteFsPath, data: ShimTypeCheckingData): void {\n+    this.assertPath(sfPath);\n+\n+    // Previous type-checking state may have required the use of inlines (assuming they were\n+    // supported). If the current operation also requires inlines, this presents a problem:\n+    // generating new inlines may invalidate any old inlines that old state depends on.\n+    //\n+    // Rather than resolve this issue by tracking specific dependencies on inlines, if the new state\n+    // relies on inlines, any old state that relied on them is simply cleared. This happens when the\n+    // first new state that uses inlines is encountered.\n+    if (data.hasInlines && !this.seenInlines) {\n+      this.impl.clearAllShimDataUsingInlines();\n+      this.seenInlines = true;\n+    }\n+\n+    this.fileData.shimData.set(data.path, data);\n+    if (data.hasInlines) {\n+      this.fileData.hasInlines = true;\n+    }\n+  }\n+\n+  recordComplete(sfPath: AbsoluteFsPath): void {\n+    this.assertPath(sfPath);\n+    this.fileData.isComplete = true;\n+  }\n+}"
        },
        {
            "sha": "081296f637634fad956d08e63d95b0fdc8c1109f",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/diagnostics_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/de14b2c6709297cadb1923faac6f4586fd78f67b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fdiagnostics_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/de14b2c6709297cadb1923faac6f4586fd78f67b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fdiagnostics_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fdiagnostics_spec.ts?ref=de14b2c6709297cadb1923faac6f4586fd78f67b",
            "patch": "@@ -10,7 +10,7 @@ import * as ts from 'typescript';\n \n import {absoluteFrom, getSourceFileOrError} from '../../file_system';\n import {runInEachFileSystem, TestFile} from '../../file_system/testing';\n-import {TypeCheckingConfig} from '../api';\n+import {OptimizeFor, TypeCheckingConfig} from '../api';\n \n import {ngForDeclaration, ngForDts, setup, TestDeclaration} from './test_utils';\n \n@@ -472,7 +472,7 @@ function diagnose(\n       ],\n       {config, options});\n   const sf = getSourceFileOrError(program, sfPath);\n-  const diagnostics = templateTypeChecker.getDiagnosticsForFile(sf);\n+  const diagnostics = templateTypeChecker.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram);\n   return diagnostics.map(diag => {\n     const text =\n         typeof diag.messageText === 'string' ? diag.messageText : diag.messageText.messageText;"
        },
        {
            "sha": "601808d55e0692ba0e8a7af5b851b55fabf582a7",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/program_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/de14b2c6709297cadb1923faac6f4586fd78f67b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fprogram_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/de14b2c6709297cadb1923faac6f4586fd78f67b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fprogram_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fprogram_spec.ts?ref=de14b2c6709297cadb1923faac6f4586fd78f67b",
            "patch": "@@ -12,7 +12,7 @@ import {absoluteFrom, AbsoluteFsPath, getSourceFileOrError} from '../../file_sys\n import {runInEachFileSystem} from '../../file_system/testing';\n import {sfExtensionData, ShimReferenceTagger} from '../../shims';\n import {expectCompleteReuse, makeProgram} from '../../testing';\n-import {UpdateMode} from '../api';\n+import {OptimizeFor, UpdateMode} from '../api';\n import {ReusedProgramStrategy} from '../src/augmented_program';\n \n import {setup} from './test_utils';\n@@ -28,7 +28,7 @@ runInEachFileSystem(() => {\n       }]);\n       const sf = getSourceFileOrError(program, fileName);\n \n-      templateTypeChecker.getDiagnosticsForFile(sf);\n+      templateTypeChecker.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram);\n       // expect() here would create a really long error message, so this is checked manually.\n       if (programStrategy.getProgram() !== program) {\n         fail('Template type-checking created a new ts.Program even though it had no changes.');"
        },
        {
            "sha": "b331c058eb9d2a78356ae6a761164d01f3dab9d4",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker_spec.ts",
            "status": "modified",
            "additions": 86,
            "deletions": 6,
            "changes": 92,
            "blob_url": "https://github.com/angular/angular/blob/de14b2c6709297cadb1923faac6f4586fd78f67b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/de14b2c6709297cadb1923faac6f4586fd78f67b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts?ref=de14b2c6709297cadb1923faac6f4586fd78f67b",
            "patch": "@@ -9,8 +9,9 @@\n import {ErrorCode, ngErrorCode} from '../../diagnostics';\n import {absoluteFrom, absoluteFromSourceFile, getSourceFileOrError} from '../../file_system';\n import {runInEachFileSystem} from '../../file_system/testing';\n+import {OptimizeFor} from '../api';\n \n-import {getClass, setup} from './test_utils';\n+import {getClass, setup, TestDeclaration} from './test_utils';\n \n runInEachFileSystem(() => {\n   describe('TemplateTypeChecker', () => {\n@@ -22,14 +23,43 @@ runInEachFileSystem(() => {\n         {fileName: file2, templates: {'Cmp2': '<span></span>'}}\n       ]);\n \n-      templateTypeChecker.getDiagnosticsForFile(getSourceFileOrError(program, file1));\n+      templateTypeChecker.getDiagnosticsForFile(\n+          getSourceFileOrError(program, file1), OptimizeFor.WholeProgram);\n       const ttcProgram1 = programStrategy.getProgram();\n-      templateTypeChecker.getDiagnosticsForFile(getSourceFileOrError(program, file2));\n+      templateTypeChecker.getDiagnosticsForFile(\n+          getSourceFileOrError(program, file2), OptimizeFor.WholeProgram);\n       const ttcProgram2 = programStrategy.getProgram();\n \n       expect(ttcProgram1).toBe(ttcProgram2);\n     });\n \n+    it('should not batch diagnostic operations when requested in SingleFile mode', () => {\n+      const file1 = absoluteFrom('/file1.ts');\n+      const file2 = absoluteFrom('/file2.ts');\n+      const {program, templateTypeChecker, programStrategy} = setup([\n+        {fileName: file1, templates: {'Cmp1': '<div></div>'}},\n+        {fileName: file2, templates: {'Cmp2': '<span></span>'}}\n+      ]);\n+\n+      templateTypeChecker.getDiagnosticsForFile(\n+          getSourceFileOrError(program, file1), OptimizeFor.SingleFile);\n+      const ttcProgram1 = programStrategy.getProgram();\n+\n+      // ttcProgram1 should not contain a type check block for Cmp2.\n+      const ttcSf2Before = getSourceFileOrError(ttcProgram1, absoluteFrom('/file2.ngtypecheck.ts'));\n+      expect(ttcSf2Before.text).not.toContain('Cmp2');\n+\n+      templateTypeChecker.getDiagnosticsForFile(\n+          getSourceFileOrError(program, file2), OptimizeFor.SingleFile);\n+      const ttcProgram2 = programStrategy.getProgram();\n+\n+      // ttcProgram2 should now contain a type check block for Cmp2.\n+      const ttcSf2After = getSourceFileOrError(ttcProgram2, absoluteFrom('/file2.ngtypecheck.ts'));\n+      expect(ttcSf2After.text).toContain('Cmp2');\n+\n+      expect(ttcProgram1).not.toBe(ttcProgram2);\n+    });\n+\n     it('should allow access to the type-check block of a component', () => {\n       const file1 = absoluteFrom('/file1.ts');\n       const file2 = absoluteFrom('/file2.ts');\n@@ -45,6 +75,56 @@ runInEachFileSystem(() => {\n       expect(block!.getText()).toContain(`document.createElement(\"div\")`);\n     });\n \n+    it('should clear old inlines when necessary', () => {\n+      const file1 = absoluteFrom('/file1.ts');\n+      const file2 = absoluteFrom('/file2.ts');\n+      const dirFile = absoluteFrom('/dir.ts');\n+      const dirDeclaration: TestDeclaration = {\n+        name: 'TestDir',\n+        selector: '[dir]',\n+        file: dirFile,\n+        type: 'directive',\n+      };\n+      const {program, templateTypeChecker, programStrategy} = setup([\n+        {\n+          fileName: file1,\n+          templates: {'CmpA': '<div dir></div>'},\n+          declarations: [dirDeclaration],\n+        },\n+        {\n+          fileName: file2,\n+          templates: {'CmpB': '<div dir></div>'},\n+          declarations: [dirDeclaration],\n+        },\n+        {\n+          fileName: dirFile,\n+          source: `\n+                // A non-exported interface used as a type bound for a generic directive causes\n+                // an inline type constructor to be required.\n+                interface NotExported {}\n+                export class TestDir<T extends NotExported> {}`,\n+          templates: {},\n+        },\n+      ]);\n+      const sf1 = getSourceFileOrError(program, file1);\n+      const cmpA = getClass(sf1, 'CmpA');\n+      const sf2 = getSourceFileOrError(program, file2);\n+      const cmpB = getClass(sf2, 'CmpB');\n+      // Prime the TemplateTypeChecker by asking for a TCB from file1.\n+      expect(templateTypeChecker.getTypeCheckBlock(cmpA)).not.toBeNull();\n+\n+      // Next, ask for a TCB from file2. This operation should clear data on TCBs generated for\n+      // file1.\n+      expect(templateTypeChecker.getTypeCheckBlock(cmpB)).not.toBeNull();\n+      console.error(templateTypeChecker.getTypeCheckBlock(cmpB)?.getSourceFile().text);\n+\n+      // This can be detected by asking for a TCB again from file1. Since no data should be\n+      // available for file1, this should cause another type-checking program step.\n+      const prevTtcProgram = programStrategy.getProgram();\n+      expect(templateTypeChecker.getTypeCheckBlock(cmpA)).not.toBeNull();\n+      expect(programStrategy.getProgram()).not.toBe(prevTtcProgram);\n+    });\n+\n     describe('when inlining is unsupported', () => {\n       it('should not produce errors for components that do not require inlining', () => {\n         const fileName = absoluteFrom('/main.ts');\n@@ -70,7 +150,7 @@ runInEachFileSystem(() => {\n             ],\n             {inlining: false});\n         const sf = getSourceFileOrError(program, fileName);\n-        const diags = templateTypeChecker.getDiagnosticsForFile(sf);\n+        const diags = templateTypeChecker.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram);\n         expect(diags.length).toBe(0);\n       });\n \n@@ -84,7 +164,7 @@ runInEachFileSystem(() => {\n             }],\n             {inlining: false});\n         const sf = getSourceFileOrError(program, fileName);\n-        const diags = templateTypeChecker.getDiagnosticsForFile(sf);\n+        const diags = templateTypeChecker.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram);\n         expect(diags.length).toBe(1);\n         expect(diags[0].code).toBe(ngErrorCode(ErrorCode.INLINE_TCB_REQUIRED));\n       });\n@@ -117,7 +197,7 @@ runInEachFileSystem(() => {\n             ],\n             {inlining: false});\n         const sf = getSourceFileOrError(program, fileName);\n-        const diags = templateTypeChecker.getDiagnosticsForFile(sf);\n+        const diags = templateTypeChecker.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram);\n         expect(diags.length).toBe(1);\n         expect(diags[0].code).toBe(ngErrorCode(ErrorCode.INLINE_TYPE_CTOR_REQUIRED));\n "
        }
    ],
    "stats": {
        "total": 259,
        "additions": 241,
        "deletions": 18
    }
}