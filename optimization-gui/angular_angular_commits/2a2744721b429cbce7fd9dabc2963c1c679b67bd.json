{
    "author": "JoostK",
    "message": "fix(compiler-cli): ensure literal types are retained when `strictNullInputTypes` is disabled (#38305)\n\nConsider the `NgModel` directive which has the `ngModelOptions` input:\n\n```ts\nclass NgModel {\n  @Input() ngModelOptions: { updateOn: 'blur'|'change'|'submit' };\n}\n```\n\nIn a template this may be set using an object literal as follows:\n\n```html\n<input ngModel [ngModelOptions]=\"{updateOn: 'blur'}\">\n```\n\nThis assignment should be accepted, as the object's type aligns with the\n`ngModelOptions` input in `NgModel`. However, if the `strictNullInputTypes`\noption is disabled this assignment would inadvertently produce an error:\n\n```\nType '{ updateOn: string; }' is not assignable to type '{ updateOn: \"blur\"|\"change\"|\"submit\"; }'.\n  Types of property 'updateOn' are incompatible.\n    Type 'string' is not assignable to type '\"blur\"|\"change\"|\"submit\"'\n```\n\nThis is due to the `'blur'` value being inferred to be of type `string`\ninstead of retaining its literal type. The non-null assertion operator\nthat is automatically inserted for input binding assignments when\n`strictNullInputTypes` is disabled inhibits TypeScript from inferring\nthe string value as its literal type.\n\nThis commit fixes the issue by omitting the insertion of the non-null\noperator for object literals and array literals.\n\nPR Close #38305",
    "sha": "2a2744721b429cbce7fd9dabc2963c1c679b67bd",
    "files": [
        {
            "sha": "044e3a9f2f653bca2d20997f9f15423f50ba33e3",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.ts",
            "status": "modified",
            "additions": 28,
            "deletions": 30,
            "changes": 58,
            "blob_url": "https://github.com/angular/angular/blob/2a2744721b429cbce7fd9dabc2963c1c679b67bd/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "raw_url": "https://github.com/angular/angular/raw/2a2744721b429cbce7fd9dabc2963c1c679b67bd/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts?ref=2a2744721b429cbce7fd9dabc2963c1c679b67bd",
            "patch": "@@ -701,16 +701,7 @@ class TcbDirectiveInputsOp extends TcbOp {\n     const inputs = getBoundInputs(this.dir, this.node, this.tcb);\n     for (const input of inputs) {\n       // For bound inputs, the property is assigned the binding expression.\n-      let expr = translateInput(input.attribute, this.tcb, this.scope);\n-      if (!this.tcb.env.config.checkTypeOfInputBindings) {\n-        // If checking the type of bindings is disabled, cast the resulting expression to 'any'\n-        // before the assignment.\n-        expr = tsCastToAny(expr);\n-      } else if (!this.tcb.env.config.strictNullInputBindings) {\n-        // If strict null checks are disabled, erase `null` and `undefined` from the type by\n-        // wrapping the expression in a non-null assertion.\n-        expr = ts.createNonNullExpression(expr);\n-      }\n+      const expr = widenBinding(translateInput(input.attribute, this.tcb, this.scope), this.tcb);\n \n       let assignment: ts.Expression = wrapForDiagnostics(expr);\n \n@@ -922,16 +913,7 @@ class TcbUnclaimedInputsOp extends TcbOp {\n         continue;\n       }\n \n-      let expr = tcbExpression(binding.value, this.tcb, this.scope);\n-      if (!this.tcb.env.config.checkTypeOfInputBindings) {\n-        // If checking the type of bindings is disabled, cast the resulting expression to 'any'\n-        // before the assignment.\n-        expr = tsCastToAny(expr);\n-      } else if (!this.tcb.env.config.strictNullInputBindings) {\n-        // If strict null checks are disabled, erase `null` and `undefined` from the type by\n-        // wrapping the expression in a non-null assertion.\n-        expr = ts.createNonNullExpression(expr);\n-      }\n+      const expr = widenBinding(tcbExpression(binding.value, this.tcb, this.scope), this.tcb);\n \n       if (this.tcb.env.config.checkTypeOfDomBindings && binding.type === BindingType.Property) {\n         if (binding.name !== 'style' && binding.name !== 'class') {\n@@ -1811,16 +1793,7 @@ function tcbCallTypeCtor(\n \n     if (input.type === 'binding') {\n       // For bound inputs, the property is assigned the binding expression.\n-      let expr = input.expression;\n-      if (!tcb.env.config.checkTypeOfInputBindings) {\n-        // If checking the type of bindings is disabled, cast the resulting expression to 'any'\n-        // before the assignment.\n-        expr = tsCastToAny(expr);\n-      } else if (!tcb.env.config.strictNullInputBindings) {\n-        // If strict null checks are disabled, erase `null` and `undefined` from the type by\n-        // wrapping the expression in a non-null assertion.\n-        expr = ts.createNonNullExpression(expr);\n-      }\n+      const expr = widenBinding(input.expression, tcb);\n \n       const assignment = ts.createPropertyAssignment(propertyName, wrapForDiagnostics(expr));\n       addParseSpanInfo(assignment, input.sourceSpan);\n@@ -1883,6 +1856,31 @@ function translateInput(\n   }\n }\n \n+/**\n+ * Potentially widens the type of `expr` according to the type-checking configuration.\n+ */\n+function widenBinding(expr: ts.Expression, tcb: Context): ts.Expression {\n+  if (!tcb.env.config.checkTypeOfInputBindings) {\n+    // If checking the type of bindings is disabled, cast the resulting expression to 'any'\n+    // before the assignment.\n+    return tsCastToAny(expr);\n+  } else if (!tcb.env.config.strictNullInputBindings) {\n+    if (ts.isObjectLiteralExpression(expr) || ts.isArrayLiteralExpression(expr)) {\n+      // Object literals and array literals should not be wrapped in non-null assertions as that\n+      // would cause literals to be prematurely widened, resulting in type errors when assigning\n+      // into a literal type.\n+      return expr;\n+    } else {\n+      // If strict null checks are disabled, erase `null` and `undefined` from the type by\n+      // wrapping the expression in a non-null assertion.\n+      return ts.createNonNullExpression(expr);\n+    }\n+  } else {\n+    // No widening is requested, use the expression as is.\n+    return expr;\n+  }\n+}\n+\n /**\n  * An input binding that corresponds with a field of a directive.\n  */"
        },
        {
            "sha": "bc4a55a2ea5a8ccb594a429f00fddb61e7192f3d",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/diagnostics_spec.ts",
            "status": "modified",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/2a2744721b429cbce7fd9dabc2963c1c679b67bd/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fdiagnostics_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2a2744721b429cbce7fd9dabc2963c1c679b67bd/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fdiagnostics_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fdiagnostics_spec.ts?ref=2a2744721b429cbce7fd9dabc2963c1c679b67bd",
            "patch": "@@ -277,6 +277,46 @@ runInEachFileSystem(() => {\n       ]);\n     });\n \n+    it('should retain literal types in object literals together if strictNullInputBindings is disabled',\n+       () => {\n+         const messages = diagnose(\n+             `<div dir [ngModelOptions]=\"{updateOn: 'change'}\"></div>`, `\n+              class Dir {\n+                ngModelOptions: { updateOn: 'change'|'blur' };\n+              }\n+\n+              class TestComponent {}`,\n+             [{\n+               type: 'directive',\n+               name: 'Dir',\n+               selector: '[dir]',\n+               inputs: {'ngModelOptions': 'ngModelOptions'},\n+             }],\n+             [], {strictNullInputBindings: false});\n+\n+         expect(messages).toEqual([]);\n+       });\n+\n+    it('should retain literal types in array literals together if strictNullInputBindings is disabled',\n+       () => {\n+         const messages = diagnose(\n+             `<div dir [options]=\"['literal']\"></div>`, `\n+                class Dir {\n+                  options!: Array<'literal'>;\n+                }\n+\n+                class TestComponent {}`,\n+             [{\n+               type: 'directive',\n+               name: 'Dir',\n+               selector: '[dir]',\n+               inputs: {'options': 'options'},\n+             }],\n+             [], {strictNullInputBindings: false});\n+\n+         expect(messages).toEqual([]);\n+       });\n+\n     it('does not produce diagnostics for user code', () => {\n       const messages = diagnose(`{{ person.name }}`, `\n       class TestComponent {"
        },
        {
            "sha": "3e57890a9338f945b3ed24ed407615b1d8cacc0d",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/testing/index.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/2a2744721b429cbce7fd9dabc2963c1c679b67bd/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftesting%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/2a2744721b429cbce7fd9dabc2963c1c679b67bd/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftesting%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftesting%2Findex.ts?ref=2a2744721b429cbce7fd9dabc2963c1c679b67bd",
            "patch": "@@ -46,6 +46,7 @@ export function typescriptLibDts(): TestFile {\n         [index: number]: T;\n         length: number;\n       }\n+      declare interface Iterable<T> {}\n       declare interface String {\n         length: number;\n       }\n@@ -63,7 +64,7 @@ export function typescriptLibDts(): TestFile {\n       }\n       declare interface HTMLElement {\n         addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any): void;\n-        addEventListener(type: string, listener: (evt: Event): void;): void;\n+        addEventListener(type: string, listener: (evt: Event) => void): void;\n       }\n       declare interface HTMLDivElement extends HTMLElement {}\n       declare interface HTMLImageElement extends HTMLElement {\n@@ -94,8 +95,8 @@ export function angularCoreDts(): TestFile {\n     name: absoluteFrom('/node_modules/@angular/core/index.d.ts'),\n     contents: `\n     export declare class TemplateRef<C> {\n-      abstract readonly elementRef: unknown;\n-      abstract createEmbeddedView(context: C): unknown;\n+      readonly elementRef: unknown;\n+      createEmbeddedView(context: C): unknown;\n     }\n \n     export declare class EventEmitter<T> {"
        }
    ],
    "stats": {
        "total": 105,
        "additions": 72,
        "deletions": 33
    }
}