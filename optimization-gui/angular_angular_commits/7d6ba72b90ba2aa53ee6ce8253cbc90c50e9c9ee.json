{
    "author": "TeriGlover",
    "message": "docs: Edits to remove jargon (#42928)\n\nPR Close #42928",
    "sha": "7d6ba72b90ba2aa53ee6ce8253cbc90c50e9c9ee",
    "files": [
        {
            "sha": "7373f32a90c1f8ea1da764d0602836b55438cc14",
            "filename": "aio/content/guide/dynamic-form.md",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/7d6ba72b90ba2aa53ee6ce8253cbc90c50e9c9ee/aio%2Fcontent%2Fguide%2Fdynamic-form.md",
            "raw_url": "https://github.com/angular/angular/raw/7d6ba72b90ba2aa53ee6ce8253cbc90c50e9c9ee/aio%2Fcontent%2Fguide%2Fdynamic-form.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Fdynamic-form.md?ref=7d6ba72b90ba2aa53ee6ce8253cbc90c50e9c9ee",
            "patch": "@@ -3,15 +3,15 @@\n Many forms, such as questionaires, can be very similar to one another in format and intent.\n To make it faster and easier to generate different versions of such a form,\n you can create a *dynamic form template* based on metadata that describes the business object model.\n-You can then use the template to generate new forms automatically, according to changes in the data model.\n+Then, use the template to generate new forms automatically, according to changes in the data model.\n \n The technique is particularly useful when you have a type of form whose content must\n change frequently to meet rapidly changing business and regulatory requirements.\n A typical use case is a questionaire. You might need to get input from users in different contexts.\n The format and style of the forms a user sees should remain constant, while the actual questions you need to ask vary with the context.\n \n In this tutorial you will build a dynamic form that presents a basic questionaire.\n-You will build an online application for heroes seeking employment.\n+You build an online application for heroes seeking employment.\n The agency is constantly tinkering with the application process, but by using the dynamic form\n you can create the new forms on the fly without changing the application code.\n \n@@ -81,14 +81,14 @@ The following `QuestionBase` is a base class for a set of controls that can repr\n \n From this base, the example derives two new classes, `TextboxQuestion` and `DropdownQuestion`,\n that represent different control types.\n-When you create the form template in the next step, you will instantiate these specific question types in order to render the appropriate controls dynamically.\n+When you create the form template in the next step, you instantiate these specific question types in order to render the appropriate controls dynamically.\n \n-* The `TextboxQuestion` control type presents a question and allows users to enter input.\n+* The `TextboxQuestion` control type presents a question and lets users enter input.\n \n    <code-example path=\"dynamic-form/src/app/question-textbox.ts\" header=\"src/app/question-textbox.ts\"></code-example>\n \n-   The `TextboxQuestion` control type will be represented in a form template using an `<input>` element.\n-   The `type` attribute of the element will be defined based on the `type` field specified in the `options` argument (for example `text`, `email`, `url`).\n+   The `TextboxQuestion` control type is represented in a form template using an `<input>` element.\n+   The `type` attribute of the element is defined based on the `type` field specified in the `options` argument (for example `text`, `email`, `url`).\n \n * The `DropdownQuestion` control presents a list of choices in a select box.\n \n@@ -105,7 +105,7 @@ The following `QuestionControlService` collects a set of `FormGroup` instances t\n \n ## Compose dynamic form contents\n \n-The dynamic form itself will be represented by a container component, which you will add in a later step.\n+The dynamic form itself is represented by a container component, which you add in a later step.\n Each question is represented in the form component's template by an `<app-question>` tag, which matches an instance of `DynamicFormQuestionComponent`.\n \n The `DynamicFormQuestionComponent` is responsible for rendering the details of an individual question based on values in the data-bound question object.\n@@ -134,7 +134,7 @@ The switch uses directives with the [`formControlName`](api/forms/FormControlNam\n ### Supply data\n \n Another service is needed to supply a specific set of questions from which to build an individual form.\n-For this exercise you will create the `QuestionService` to supply this array of questions from the hard-coded sample data.\n+For this exercise you create the `QuestionService` to supply this array of questions from the hard-coded sample data.\n In a real-world app, the service might fetch data from a backend system.\n The key point, however, is that you control the hero job-application questions entirely through the objects returned from `QuestionService`.\n To maintain the questionnaire as requirements change, you only need to add, update, and remove objects from the `questions` array.\n@@ -177,7 +177,7 @@ To display an instance of the dynamic form, the `AppComponent` shell template pa\n \n The example provides a model for a job application for heroes, but there are\n no references to any specific hero question other than the objects returned by `QuestionService`.\n-This separation of model and data allows you to repurpose the components for any type of survey\n+This separation of model and data lets you repurpose the components for any type of survey\n as long as it's compatible with the *question* object model.\n \n ### Ensuring valid data\n@@ -187,7 +187,7 @@ without making any hardcoded assumptions about specific questions.\n It adds both control metadata and validation criteria dynamically.\n \n To ensure valid input, the *Save* button is disabled until the form is in a valid state.\n-When the form is valid, you can click *Save* and the application renders the current form values as JSON.\n+When the form is valid, click *Save* and the application renders the current form values as JSON.\n \n The following figure shows the final form.\n "
        },
        {
            "sha": "ed1306734e50d28ae78229abbb0ca0530612bc0e",
            "filename": "aio/content/guide/form-validation.md",
            "status": "modified",
            "additions": 10,
            "deletions": 11,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/7d6ba72b90ba2aa53ee6ce8253cbc90c50e9c9ee/aio%2Fcontent%2Fguide%2Fform-validation.md",
            "raw_url": "https://github.com/angular/angular/raw/7d6ba72b90ba2aa53ee6ce8253cbc90c50e9c9ee/aio%2Fcontent%2Fguide%2Fform-validation.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Fform-validation.md?ref=7d6ba72b90ba2aa53ee6ce8253cbc90c50e9c9ee",
            "patch": "@@ -78,11 +78,10 @@ Angular then calls these functions whenever the value of the control changes.\n \n Validator functions can be either synchronous or asynchronous.\n \n-* **Sync validators**: Synchronous functions that take a control instance and immediately return either a set of validation errors or `null`. You can pass these in as the second argument when you instantiate a `FormControl`.\n+* **Sync validators**: Synchronous functions that take a control instance and immediately return either a set of validation errors or `null`. Pass these in as the second argument when you instantiate a `FormControl`.\n \n * **Async validators**: Asynchronous functions that take a control instance and return a Promise\n-or Observable that later emits a set of validation errors or `null`. You can\n-pass these in as the third argument when you instantiate a `FormControl`.\n+or Observable that later emits a set of validation errors or `null`. Pass these in as the third argument when you instantiate a `FormControl`.\n \n For performance reasons, Angular only runs async validators if all sync validators pass. Each must complete before errors are set.\n \n@@ -93,14 +92,14 @@ You can choose to [write your own validator functions](#custom-validators), or y\n The same built-in validators that are available as attributes in template-driven forms, such as `required` and `minlength`, are all available to use as functions from the `Validators` class.\n For a full list of built-in validators, see the [Validators](api/forms/Validators) API reference.\n \n-To update the hero form to be a reactive form, you can use some of the same\n+To update the hero form to be a reactive form, use some of the same\n built-in validators&mdash;this time, in function form, as in the following example.\n \n {@a reactive-component-class}\n \n <code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.1.ts\" region=\"form-group\" header=\"reactive/hero-form-reactive.component.ts (validator functions)\"></code-example>\n \n-In this example, the `name` control sets up two built-in validators&mdash;`Validators.required` and `Validators.minLength(4)`&mdash;and one custom validator, `forbiddenNameValidator`. (For more details see [custom validators](#custom-validators) below.)\n+In this example, the `name` control sets up two built-in validators&mdash;`Validators.required` and `Validators.minLength(4)`&mdash;and one custom validator, `forbiddenNameValidator`. (For more details see [custom validators](#custom-validators).)\n \n All of these validators are synchronous, so they are passed as the second argument. Notice that you can support multiple validators by passing the functions in as an array.\n \n@@ -127,7 +126,7 @@ Here's what the definition of that function looks like.\n \n The function is a factory that takes a regular expression to detect a _specific_ forbidden name and returns a validator function.\n \n-In this sample, the forbidden name is \"bob\", so the validator will reject any hero name containing \"bob\".\n+In this sample, the forbidden name is \"bob\", so the validator rejects any hero name containing \"bob\".\n Elsewhere it could reject \"alice\" or any name that the configuring regular expression matches.\n \n The `forbiddenNameValidator` factory returns the configured validator function.\n@@ -185,7 +184,7 @@ If you were to replace `useExisting` with `useClass`, then you’d be registerin\n \n ## Control status CSS classes\n \n-Angular automatically mirrors many control properties onto the form control element as CSS classes. You can use these classes to style form control elements according to the state of the form.\n+Angular automatically mirrors many control properties onto the form control element as CSS classes. Use these classes to style form control elements according to the state of the form.\n The following classes are currently supported.\n \n * `.ng-valid`\n@@ -258,7 +257,7 @@ To provide better user experience, the template shows an appropriate error messa\n \n <code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.html\" region=\"cross-validation-error-message\" header=\"reactive/hero-form-template.component.html\"></code-example>\n \n-This `*ngIf` displays the error if the `FormGroup` has the cross validation error returned by the `identityRevealed` validator, but only if the user has finished [interacting with the form](#dirty-or-touched).\n+This `*ngIf` displays the error if the `FormGroup` has the cross validation error returned by the `identityRevealed` validator, but only if the user finished [interacting with the form](#dirty-or-touched).\n \n ### Adding cross-validation to template-driven forms\n \n@@ -272,7 +271,7 @@ Because the validator must be registered at the highest level in the form, the f\n \n <code-example path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"cross-validation-register-validator\" header=\"template/hero-form-template.component.html\"></code-example>\n \n-To provide better user experience, we show an appropriate error message when the form is invalid.\n+To provide better user experience, an appropriate error message appears when the form is invalid.\n \n <code-example path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"cross-validation-error-message\" header=\"template/hero-form-template.component.html\"></code-example>\n \n@@ -288,9 +287,9 @@ These are very similar to their synchronous counterparts, with the following dif\n To convert an infinite observable into a finite one, pipe the observable through a filtering operator such as `first`, `last`, `take`, or `takeUntil`.\n \n Asynchronous validation happens after the synchronous validation, and is performed only if the synchronous validation is successful.\n-This check allows forms to avoid potentially expensive async validation processes (such as an HTTP request) if the more basic validation methods have already found invalid input.\n+This check lets forms avoid potentially expensive async validation processes (such as an HTTP request) if the more basic validation methods have already found invalid input.\n \n-After asynchronous validation begins, the form control enters a `pending` state. You can inspect the control's `pending` property and use it to give visual feedback about the ongoing validation operation.\n+After asynchronous validation begins, the form control enters a `pending` state. Inspect the control's `pending` property and use it to give visual feedback about the ongoing validation operation.\n \n A common UI pattern is to show a spinner while the async validation is being performed. The following example shows how to achieve this in a template-driven form.\n "
        },
        {
            "sha": "85b16f3d33238553d71f76c791e06c8e7873d212",
            "filename": "aio/content/guide/forms-overview.md",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/7d6ba72b90ba2aa53ee6ce8253cbc90c50e9c9ee/aio%2Fcontent%2Fguide%2Fforms-overview.md",
            "raw_url": "https://github.com/angular/angular/raw/7d6ba72b90ba2aa53ee6ce8253cbc90c50e9c9ee/aio%2Fcontent%2Fguide%2Fforms-overview.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Fforms-overview.md?ref=7d6ba72b90ba2aa53ee6ce8253cbc90c50e9c9ee",
            "patch": "@@ -22,11 +22,11 @@ Reactive forms and template-driven forms process and manage form data differentl\n \n * **Reactive forms** provide direct, explicit access to the underlying forms object model. Compared to template-driven forms, they are more robust: they're more scalable, reusable, and testable. If forms are a key part of your application, or you're already using reactive patterns for building your application, use reactive forms.\n \n-* **Template-driven forms** rely on directives in the template to create and manipulate the underlying object model. They are useful for adding a simple form to an app, such as an email list signup form. They're easy to add to an app, but they don't scale as well as reactive forms. If you have very basic form requirements and logic that can be managed solely in the template, template-driven forms could be a good fit.\n+* **Template-driven forms** rely on directives in the template to create and manipulate the underlying object model. They are useful for adding a simple form to an app, such as an email list signup form. They're straightforward to add to an app, but they don't scale as well as reactive forms. If you have very basic form requirements and logic that can be managed solely in the template, template-driven forms could be a good fit.\n \n ### Key differences\n \n-The table below summarizes the key differences between reactive and template-driven forms.\n+The following table summarizes the key differences between reactive and template-driven forms.\n \n <style>\n   table {width: 100%};\n@@ -69,7 +69,7 @@ Both reactive and template-driven forms are built on the following base classes.\n \n * `FormArray` tracks the same values and status for an array of form controls.\n \n-* `ControlValueAccessor` creates a bridge between Angular `FormControl` instances and native DOM elements.\n+* `ControlValueAccessor` creates a bridge between Angular `FormControl` instances and built-in DOM elements.\n \n {@a setup-the-form-model}\n \n@@ -225,7 +225,7 @@ The following examples demonstrate the process of testing forms with reactive an\n \n ### Testing reactive forms\n \n-Reactive forms provide a relatively easy testing strategy because they provide synchronous access to the form and data models, and they can be tested without rendering the UI.\n+Reactive forms provide a relatively straightforward testing strategy because they provide synchronous access to the form and data models, and they can be tested without rendering the UI.\n In these tests, status and data are queried and manipulated through the control without interacting with the change detection cycle.\n \n The following tests use the favorite-color components from previous examples to verify the view-to-model and model-to-view data flows for a reactive form."
        },
        {
            "sha": "4835d47193e3aeb631a8c63df961e94458924e43",
            "filename": "aio/content/guide/http.md",
            "status": "modified",
            "additions": 25,
            "deletions": 25,
            "changes": 50,
            "blob_url": "https://github.com/angular/angular/blob/7d6ba72b90ba2aa53ee6ce8253cbc90c50e9c9ee/aio%2Fcontent%2Fguide%2Fhttp.md",
            "raw_url": "https://github.com/angular/angular/raw/7d6ba72b90ba2aa53ee6ce8253cbc90c50e9c9ee/aio%2Fcontent%2Fguide%2Fhttp.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Fhttp.md?ref=7d6ba72b90ba2aa53ee6ce8253cbc90c50e9c9ee",
            "patch": "@@ -1,6 +1,6 @@\n # Communicating with backend services using HTTP\n \n-Most front-end applications need to communicate with a server over the HTTP protocol, in order to download or upload data and access other back-end services.\n+Most front-end applications need to communicate with a server over the HTTP protocol, to download or upload data and access other back-end services.\n Angular provides a client HTTP API for Angular applications, the `HttpClient` service class in `@angular/common/http`.\n \n The HTTP client service offers the following major features.\n@@ -66,7 +66,7 @@ Use the [`HttpClient.get()`](api/common/http/HttpClient#get) method to fetch dat\n The asynchronous method sends an HTTP request, and returns an Observable that emits the requested data when the response is received.\n The return type varies based on the `observe` and `responseType` values that you pass to the call.\n \n-The `get()` method takes two arguments; the endpoint URL from which to fetch, and an *options* object that you can use to configure the request.\n+The `get()` method takes two arguments; the endpoint URL from which to fetch, and an *options* object that is used to configure the request.\n \n ```\n options: {\n@@ -86,7 +86,7 @@ Important options include the *observe* and *responseType* properties.\n \n <div class=\"alert is-helpful\">\n \n-You can use the `options` object to configure various other aspects of an outgoing request.\n+Use the `options` object to configure various other aspects of an outgoing request.\n In [Adding headers](#adding-headers), for example, the service set the default headers using the `headers` option property.\n \n Use the `params` property to configure a request with [HTTP URL parameters](#url-params), and the `reportProgress` option to [listen for progress events](#report-progress) when transferring large amounts of data.\n@@ -137,13 +137,13 @@ It copies the data fields into the component's `config` object, which is data-bo\n \n ### Requesting a typed response\n \n-You can structure your `HttpClient` request to declare the type of the response object, to make consuming the output easier and more obvious.\n+Structure your `HttpClient` request to declare the type of the response object, to make consuming the output easier and more obvious.\n Specifying the response type acts as a type assertion at compile time.\n \n <div class=\"alert is-important\">\n \n Specifying the response type is a declaration to TypeScript that it should treat your response as being of the given type.\n-This is a build-time check and doesn't guarantee that the server will actually respond with an object of this type. It is up to the server to ensure that the type specified by the server API is returned.\n+This is a build-time check and doesn't guarantee that the server actually responds with an object of this type. It is up to the server to ensure that the type specified by the server API is returned.\n \n </div>\n \n@@ -165,7 +165,7 @@ Next, specify that interface as the `HttpClient.get()` call's type parameter in\n \n <div class=\"alert is-helpful\">\n \n- When you pass an interface as a type parameter to the `HttpClient.get()` method, you can use the [RxJS `map` operator](guide/rx-library#operators) to transform the response data as needed by the UI. You can then pass the transformed data to the [async pipe](api/common/AsyncPipe).\n+ When you pass an interface as a type parameter to the `HttpClient.get()` method, use the [RxJS `map` operator](guide/rx-library#operators) to transform the response data as needed by the UI. You can then pass the transformed data to the [async pipe](api/common/AsyncPipe).\n \n </div>\n \n@@ -329,7 +329,7 @@ Two types of errors can occur.\n \n * Something could go wrong on the client-side such as a network error that prevents the request from completing successfully or an exception thrown in an RxJS operator. These errors have `status` set to `0` and the `error` property contains a `ProgressEvent` object, whose `type` might provide further information.\n \n-`HttpClient` captures both kinds of errors in its `HttpErrorResponse`. You can inspect that response to identify the error's cause.\n+`HttpClient` captures both kinds of errors in its `HttpErrorResponse`. Inspect that response to identify the error's cause.\n \n The following example defines an error handler in the previously defined [ConfigService](#config-service \"ConfigService defined\").\n \n@@ -358,7 +358,7 @@ can produce a successful result.\n The [RxJS library](guide/rx-library) offers several _retry_ operators.\n For example, the `retry()` operator automatically re-subscribes to a failed `Observable` a specified number of times. _Re-subscribing_ to the result of an `HttpClient` method call has the effect of reissuing the HTTP request.\n \n-The following example shows how you can pipe a failed request to the `retry()` operator before passing it to the error handler.\n+The following example shows how to pipe a failed request to the `retry()` operator before passing it to the error handler.\n \n <code-example\n   path=\"http/src/app/config/config.service.ts\"\n@@ -407,7 +407,7 @@ that hero to the displayed `heroes` list.\n \n ### Making a DELETE request\n \n-This application deletes a hero with the `HttpClient.delete` method by passing the hero's id\n+This application deletes a hero with the `HttpClient.delete` method by passing the hero's ID\n in the request URL.\n \n <code-example\n@@ -451,13 +451,13 @@ The [`AsyncPipe`](api/common/AsyncPipe) subscribes (and unsubscribes) for you au\n </div>\n \n All observables returned from `HttpClient` methods are _cold_ by design.\n-Execution of the HTTP request is _deferred_, allowing you to extend the\n+Execution of the HTTP request is _deferred_, letting you extend the\n observable with additional operations such as  `tap` and `catchError` before anything actually happens.\n \n Calling `subscribe(...)` triggers execution of the observable and causes\n `HttpClient` to compose and send the HTTP request to the server.\n \n-You can think of these observables as _blueprints_ for actual HTTP requests.\n+Think of these observables as _blueprints_ for actual HTTP requests.\n \n <div class=\"alert is-helpful\">\n \n@@ -509,7 +509,7 @@ You can't directly modify the existing headers within the previous options\n object because instances of the `HttpHeaders` class are immutable.\n Use the `set()` method instead, to return a clone of the current instance with the new changes applied.\n \n-The following example shows how, when an old token has expired, you can update the authorization header before making the next request.\n+The following example shows how, when an old token expires, you can update the authorization header before making the next request.\n \n <code-example\n   path=\"http/src/app/heroes/heroes.service.ts\"\n@@ -714,7 +714,7 @@ You can clone and modify the request in a single step, as shown in the following\n   header=\"app/http-interceptors/ensure-https-interceptor.ts (excerpt)\">\n </code-example>\n \n-The `clone()` method's hash argument allows you to mutate specific properties of the request while copying the others.\n+The `clone()` method's hash argument lets you mutate specific properties of the request while copying the others.\n \n #### Modifying a request body\n \n@@ -756,7 +756,7 @@ To do this, set the cloned request body to `null`.\n \n ## Http interceptor use-cases\n \n-Below are a number of common uses for interceptors.\n+Following are a number of common uses for interceptors.\n \n ### Setting default headers\n \n@@ -929,7 +929,7 @@ Sometimes applications transfer large amounts of data and those transfers can ta\n File uploads are a typical example.\n You can give the users a better experience by providing feedback on the progress of such transfers.\n \n-To make a request with progress events enabled, you can create an instance of `HttpRequest`\n+To make a request with progress events enabled, create an instance of `HttpRequest`\n with the `reportProgress` option set true to enable tracking of progress events.\n \n <code-example\n@@ -994,7 +994,7 @@ Here, the `keyup` event binding sends every keystroke to the component's `search\n <div class=\"alert is-helpful\">\n \n The type of `$event.target` is only `EventTarget` in the template.\n-In the `getValue()` method, the target is cast to an `HTMLInputElement` to allow type-safe access to its `value` property.\n+In the `getValue()` method, the target is cast to an `HTMLInputElement` to let type-safe have access to its `value` property.\n \n <code-example path=\"http/src/app/package-search/package-search.component.ts\" region=\"getValue\"></code-example>\n \n@@ -1014,7 +1014,7 @@ that can also emit values for itself by calling `next(value)`,\n as happens in the `search()` method.\n \n Rather than forward every `searchText` value directly to the injected `PackageSearchService`,\n-the code in `ngOnInit()` pipes search values through three operators, so that a search value reaches the service only if it's a new value and the user has stopped typing.\n+the code in `ngOnInit()` pipes search values through three operators, so that a search value reaches the service only if it's a new value and the user stopped typing.\n \n * `debounceTime(500)`⁠—Wait for the user to stop typing (1/2 second in this case).\n \n@@ -1056,7 +1056,7 @@ consider moving it to a utility function or into the `PackageSearchService` itse\n [Cross-Site Request Forgery (XSRF or CSRF)](https://en.wikipedia.org/wiki/Cross-site_request_forgery) is an attack technique by which the attacker can trick an authenticated user into unknowingly executing actions on your website.\n `HttpClient` supports a [common mechanism](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token) used to prevent XSRF attacks.\n When performing HTTP requests, an interceptor reads a token from a cookie, by default `XSRF-TOKEN`, and sets it as an HTTP header, `X-XSRF-TOKEN`.\n-Since only code that runs on your domain could read the cookie, the backend can be certain that the HTTP request came from your client application and not an attacker.\n+Because only code that runs on your domain could read the cookie, the backend can be certain that the HTTP request came from your client application and not an attacker.\n \n By default, an interceptor sends this header on all mutating requests (such as POST)\n to relative URLs, but not on GET/HEAD requests or on requests with an absolute URL.\n@@ -1066,7 +1066,7 @@ On subsequent requests the server can verify that the cookie matches the `X-XSRF\n The token must be unique for each user and must be verifiable by the server; this prevents the client from making up its own tokens.\n Set the token to a digest of your site's authentication cookie with a salt for added security.\n \n-In order to prevent collisions in environments where multiple Angular apps share the same domain or subdomain, give each application a unique cookie name.\n+To prevent collisions in environments where multiple Angular apps share the same domain or subdomain, give each application a unique cookie name.\n \n <div class=\"alert is-important\">\n \n@@ -1098,7 +1098,7 @@ The test then expects that certain requests have or have not been made,\n performs assertions against those requests,\n and finally provides responses by \"flushing\" each expected request.\n \n-At the end, tests can verify that the app has made no unexpected requests.\n+At the end, tests can verify that the app made no unexpected requests.\n \n <div class=\"alert is-helpful\">\n \n@@ -1190,7 +1190,7 @@ Call `request.flush()` with an error message, as seen in the following example.\n   region=\"404\">\n </code-example>\n \n-Alternatively, you can call `request.error()` with an `ErrorEvent`.\n+Alternatively, call `request.error()` with an `ErrorEvent`.\n \n <code-example\n   path=\"http/src/testing/http-client.spec.ts\"\n@@ -1205,7 +1205,7 @@ By default, the interceptor might retry a request three times, but you might wan\n \n `HttpClient` requests contain a _context_ that can carry metadata about the request.\n This context is available for interceptors to read or modify, though it is not transmitted to the backend server when the request is sent.\n-This allows applications or other interceptors to tag requests with configuration parameters, such as how many times to retry a request.\n+This lets applications or other interceptors tag requests with configuration parameters, such as how many times to retry a request.\n \n ### Creating a context token\n \n@@ -1216,11 +1216,11 @@ You can create a context token using the `new` operator, as in the following exa\n \n The lambda function `() => 3` passed during the creation of the `HttpContextToken` serves two purposes:\n \n-1. It allows TypeScript to infer the type of this token: `HttpContextToken<number>`.\n+1. It lets TypeScript infer the type of this token: `HttpContextToken<number>`.\n   The request context is type-safe&mdash;reading a token from a request's context returns a value of the appropriate type.\n \n 1. It sets the default value for the token.\n-  This is the value that the request context returns if no other value has been set for this token.\n+  This is the value that the request context returns if no other value was set for this token.\n   Using a default value avoids the need to check if a particular value is set.\n \n ### Setting context values when making a request\n@@ -1239,7 +1239,7 @@ If you have not explicitly set a value for the token, Angular returns the defaul\n ### Contexts are mutable\n \n Unlike most other aspects of `HttpRequest` instances, the request context is mutable and persists across other immutable transformations of the request.\n-This allows interceptors to coordinate operations through the context.\n+This lets interceptors coordinate operations through the context.\n For instance, the `RetryInterceptor` example could use a second context token to track how many errors occur during the execution of a given request:\n \n <code-example path=\"http/src/app/http-interceptors/retry-interceptor.ts\" region=\"mutable-context\" header=\"coordinating operations through the context\"></code-example>"
        },
        {
            "sha": "760779fce9610833b022cafba7cb52a6cacd7ddb",
            "filename": "aio/content/guide/reactive-forms.md",
            "status": "modified",
            "additions": 13,
            "deletions": 13,
            "changes": 26,
            "blob_url": "https://github.com/angular/angular/blob/7d6ba72b90ba2aa53ee6ce8253cbc90c50e9c9ee/aio%2Fcontent%2Fguide%2Freactive-forms.md",
            "raw_url": "https://github.com/angular/angular/raw/7d6ba72b90ba2aa53ee6ce8253cbc90c50e9c9ee/aio%2Fcontent%2Fguide%2Freactive-forms.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Freactive-forms.md?ref=7d6ba72b90ba2aa53ee6ce8253cbc90c50e9c9ee",
            "patch": "@@ -26,7 +26,7 @@ Reactive forms also provide a straightforward path to testing because you are as\n \n Reactive forms differ from [template-driven forms](guide/forms \"Template-driven forms guide\") in distinct ways. Reactive forms provide synchronous access to the data model, immutability with observable operators, and change tracking through observable streams.\n \n-Template-driven forms allow direct access to modify data in your template, but are less explicit than reactive forms because they rely on directives embedded in the template, along with mutable data to track changes asynchronously. See the [Forms Overview](guide/forms-overview \"Overview of Angular forms.\") for detailed comparisons between the two paradigms.\n+Template-driven forms let direct access modify data in your template, but are less explicit than reactive forms because they rely on directives embedded in the template, along with mutable data to track changes asynchronously. See the [Forms Overview](guide/forms-overview \"Overview of Angular forms.\") for detailed comparisons between the two paradigms.\n \n ## Adding a basic form control\n \n@@ -70,7 +70,7 @@ After you create the control in the component class, you must associate it with\n \n <div class=\"alert is-helpful\">\n \n-* For a summary of the classes and directives provided by `ReactiveFormsModule`, see the [Reactive forms API](#reactive-forms-api \"API summary.\") section below.\n+* For a summary of the classes and directives provided by `ReactiveFormsModule`, see the following [Reactive forms API](#reactive-forms-api \"API summary.\") section.\n \n * For complete syntax details of these classes and directives, see the API reference documentation for the [Forms package](api/forms \"API reference.\").\n \n@@ -140,7 +140,7 @@ The form model is the source of truth for the control, so when you click the but\n Forms typically contain several related controls. Reactive forms provide two ways of grouping multiple related controls into a single input form.\n \n * A form *group* defines a form with a fixed set of controls that you can manage together. Form group basics are discussed in this section. You can also [nest form groups](#nested-groups \"See more about nesting groups.\") to create more complex forms.\n-* A form *array* defines a dynamic form, where you can add and remove controls at run time. You can also nest form arrays to create more complex forms. For more about this option, see [Creating dynamic forms](#dynamic-forms \"See more about form arrays.\") below.\n+* A form *array* defines a dynamic form, where you can add and remove controls at run time. You can also nest form arrays to create more complex forms. For more about this option, see [Creating dynamic forms](#dynamic-forms \"See more about form arrays.\").\n \n Just as a form control instance gives you control over a single input field, a form group instance tracks the form state of a group of form control instances (for example, a form). Each control in a form group instance is tracked by name when creating the form group. The following example shows how to manage multiple form control instances in a single group.\n \n@@ -196,15 +196,15 @@ The `onSubmit()` method in the `ProfileEditor` component captures the current va\n \n </code-example>\n \n-The `submit` event is emitted by the `form` tag using the native DOM event. You trigger the event by clicking a button with `submit` type. This allows the user to press the **Enter** key to submit the completed form.\n+The `submit` event is emitted by the `form` tag using the built-in DOM event. You trigger the event by clicking a button with `submit` type. This lets the user press the **Enter** key to submit the completed form.\n \n Use a `button` element to add a button to the bottom of the form to trigger the form submission.\n \n <code-example path=\"reactive-forms/src/app/profile-editor/profile-editor.component.html\" region=\"submit-button\" header=\"src/app/profile-editor/profile-editor.component.html (submit button)\"></code-example>\n \n <div class=\"alert is-helpful\">\n \n-**Note:** The button in the snippet above also has a `disabled` binding attached to it to disable the button when `profileForm` is invalid. You aren't performing any validation yet, so the button is always enabled. Basic form validation is covered in the [Validating form input](#basic-form-validation \"Basic form validation.\") section.\n+**Note:** The button in the preceding snippet also has a `disabled` binding attached to it to disable the button when `profileForm` is invalid. You aren't performing any validation yet, so the button is always enabled. Basic form validation is covered in the [Validating form input](#basic-form-validation \"Basic form validation.\") section.\n \n </div>\n \n@@ -214,7 +214,7 @@ To display the `ProfileEditor` component that contains the form, add it to a com\n \n <code-example path=\"reactive-forms/src/app/app.component.1.html\" region=\"app-profile-editor\" header=\"src/app/app.component.html (profile editor)\"></code-example>\n \n-`ProfileEditor` allows you to manage the form control instances for the `firstName` and `lastName` controls within the form group instance.\n+`ProfileEditor` lets you manage the form control instances for the `firstName` and `lastName` controls within the form group instance.\n \n <div class=\"lightbox\">\n   <img src=\"generated/images/guide/reactive-forms/profile-editor-1.gif\" alt=\"Profile Editor with labels and inputs for first and last name as well as a submit button\">\n@@ -226,7 +226,7 @@ To display the `ProfileEditor` component that contains the form, add it to a com\n \n Form groups can accept both individual form control instances and other form group instances as children. This makes composing complex form models easier to maintain and logically group together.\n \n-When building complex forms, managing the different areas of information is easier in smaller sections. Using a nested form group instance allows you to break large forms groups into smaller, more manageable ones.\n+When building complex forms, managing the different areas of information is easier in smaller sections. Using a nested form group instance lets you break large forms groups into smaller, more manageable ones.\n \n To make more complex forms, use the following steps.\n \n@@ -265,7 +265,7 @@ The `ProfileEditor` form is displayed as one group, but the model is broken down\n \n ### Updating parts of the data model\n \n-When updating the value for a form group instance that contains multiple controls, you may only want to update parts of the model. This section covers how to update specific parts of a form control data model.\n+When updating the value for a form group instance that contains multiple controls, you might only want to update parts of the model. This section covers how to update specific parts of a form control data model.\n \n There are two ways to update the model value:\n \n@@ -275,7 +275,7 @@ There are two ways to update the model value:\n \n The strict checks of the `setValue()` method help catch nesting errors in complex forms, while `patchValue()` fails silently on those errors.\n \n-In `ProfileEditorComponent`, use the `updateProfile` method with the example below to update the first name and street address for the user.\n+In `ProfileEditorComponent`, use the `updateProfile` method with the following example to update the first name and street address for the user.\n \n <code-example path=\"reactive-forms/src/app/profile-editor/profile-editor.component.1.ts\" region=\"patch-value\" header=\"src/app/profile-editor/profile-editor.component.ts (patch value)\">\n \n@@ -325,7 +325,7 @@ Use the `group` method to create the `profileForm` controls.\n \n </code-example>\n \n-In the example above, you use the `group()` method with the same object to define the properties in the model. The value for each control name is an array containing the initial value as the first item in the array.\n+In the preceding example, you use the `group()` method with the same object to define the properties in the model. The value for each control name is an array containing the initial value as the first item in the array.\n \n <div class=\"alert is-helpful\">\n \n@@ -432,7 +432,7 @@ The aliases control in the form group instance is now populated with a single co\n \n **Access the FormArray control**\n \n-A getter provides easy access to the aliases in the form array instance compared to repeating the `profileForm.get()` method to get each instance. The form array instance represents an undefined number of controls in an array. It's convenient to access a control through a getter, and this approach is easy to repeat for additional controls.\n+A getter provides access to the aliases in the form array instance compared to repeating the `profileForm.get()` method to get each instance. The form array instance represents an undefined number of controls in an array. It's convenient to access a control through a getter, and this approach is straightforward to repeat for additional controls.\n \n Use the getter syntax to create an `aliases` class property to retrieve the alias's form array control from the parent form group.\n \n@@ -459,7 +459,7 @@ In the template, each control is displayed as a separate input field.\n \n To attach the aliases from your form model, you must add it to the template. Similar to the `formGroupName` input provided by `FormGroupNameDirective`, `formArrayName` binds communication from the form array instance to the template with `FormArrayNameDirective`.\n \n-Add the template HTML below after the `<div>` closing the `formGroupName` element.\n+Add the following template HTML after the `<div>` closing the `formGroupName` element.\n \n <code-example path=\"reactive-forms/src/app/profile-editor/profile-editor.component.html\" region=\"formarrayname\" header=\"src/app/profile-editor/profile-editor.component.html (aliases form array template)\"></code-example>\n \n@@ -469,7 +469,7 @@ The `*ngFor` directive iterates over each form control instance provided by the\n   <img src=\"generated/images/guide/reactive-forms/profile-editor-4.png\" alt=\"Profile Editor with aliases section, which includes an alias label, input, and button for adding another alias text input\">\n </div>\n \n-Each time a new alias instance is added, the new form array instance is provided its control based on the index. This allows you to track each individual control when calculating the status and value of the root control.\n+Each time a new alias instance is added, the new form array instance is provided its control based on the index. This lets you track each individual control when calculating the status and value of the root control.\n \n **Add an alias**\n "
        }
    ],
    "stats": {
        "total": 125,
        "additions": 62,
        "deletions": 63
    }
}