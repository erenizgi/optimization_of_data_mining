{
    "author": "devversion",
    "message": "feat(dev-infra): provide organization-wide merge-tool label configuration (#38223)\n\nPreviously, each Angular repository had its own strategy/configuration\nfor merging pull requests and cherry-picking. We worked out a new\nstrategy for labeling/branching/versioning that should be the canonical\nstrategy for all actively maintained projects in the Angular organization.\n\nThis PR provides a `ng-dev` merge configuration that implements the\nlabeling/branching/merging as per the approved proposal.\n\nSee the following document for the proposal this commit is based on\nfor the merge script labeling/branching: https://docs.google.com/document/d/197kVillDwx-RZtSVOBtPb4BBIAw0E9RT3q3v6DZkykU\n\nThe merge tool label configuration can be conveniently accesed\nwithin each `.ng-dev` configuration, and can also be extended\nif there are special labels on individual projects. This is one\nof the reasons why the labels are not directly built into the\nmerge script. The script should remain unopinionated and flexible.\n\nThe configuration is conceptually powerful enough to achieve the\nprocedures as outlined in the versioning/branching/labeling proposal.\n\nPR Close #38223",
    "sha": "f0766a4474403aba752c8a797765ba6999dc613f",
    "files": [
        {
            "sha": "ccfb9cb507e68dbad4c9dff8741c4ebfa7641686",
            "filename": "dev-infra/pr/merge/BUILD.bazel",
            "status": "modified",
            "additions": 34,
            "deletions": 1,
            "changes": 35,
            "blob_url": "https://github.com/angular/angular/blob/f0766a4474403aba752c8a797765ba6999dc613f/dev-infra%2Fpr%2Fmerge%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/f0766a4474403aba752c8a797765ba6999dc613f/dev-infra%2Fpr%2Fmerge%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fpr%2Fmerge%2FBUILD.bazel?ref=f0766a4474403aba752c8a797765ba6999dc613f",
            "patch": "@@ -1,8 +1,12 @@\n load(\"@npm_bazel_typescript//:index.bzl\", \"ts_library\")\n+load(\"//tools:defaults.bzl\", \"jasmine_node_test\")\n \n ts_library(\n     name = \"merge\",\n-    srcs = glob([\"**/*.ts\"]),\n+    srcs = glob(\n+        [\"**/*.ts\"],\n+        exclude = [\"**/*.spec.ts\"],\n+    ),\n     module_name = \"@angular/dev-infra-private/pr/merge\",\n     visibility = [\"//dev-infra:__subpackages__\"],\n     deps = [\n@@ -11,8 +15,37 @@ ts_library(\n         \"@npm//@octokit/rest\",\n         \"@npm//@types/inquirer\",\n         \"@npm//@types/node\",\n+        \"@npm//@types/node-fetch\",\n         \"@npm//@types/semver\",\n         \"@npm//@types/yargs\",\n         \"@npm//chalk\",\n     ],\n )\n+\n+ts_library(\n+    name = \"test_lib\",\n+    testonly = True,\n+    srcs = glob([\"**/*.spec.ts\"]),\n+    deps = [\n+        \":merge\",\n+        \"//dev-infra/utils\",\n+        \"@npm//@types/jasmine\",\n+        \"@npm//@types/node\",\n+        \"@npm//@types/node-fetch\",\n+        \"@npm//nock\",\n+    ],\n+)\n+\n+jasmine_node_test(\n+    name = \"test\",\n+    # Disable the Bazel patched module resolution. It always loads \".mjs\" files first. This\n+    # breaks NodeJS execution for \"node-fetch\" as it uses experimental modules which are not\n+    # enabled in NodeJS. TODO: Remove this with rules_nodejs 3.x where patching is optional.\n+    # https://github.com/bazelbuild/rules_nodejs/commit/7d070ffadf9c3b41711382a4737b995f987c14fa.\n+    args = [\"--nobazel_patch_module_resolver\"],\n+    deps = [\n+        \":test_lib\",\n+        \"@npm//node-fetch\",\n+        \"@npm//semver\",\n+    ],\n+)"
        },
        {
            "sha": "0f40a2d0a2b8ce5dcddaaa4426165e55862946f7",
            "filename": "dev-infra/pr/merge/defaults/branches.ts",
            "status": "added",
            "additions": 212,
            "deletions": 0,
            "changes": 212,
            "blob_url": "https://github.com/angular/angular/blob/f0766a4474403aba752c8a797765ba6999dc613f/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Fbranches.ts",
            "raw_url": "https://github.com/angular/angular/raw/f0766a4474403aba752c8a797765ba6999dc613f/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Fbranches.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Fbranches.ts?ref=f0766a4474403aba752c8a797765ba6999dc613f",
            "patch": "@@ -0,0 +1,212 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as semver from 'semver';\n+import {GithubClient} from '../../../utils/git/github';\n+\n+/** Type describing a Github repository with corresponding API client. */\n+export interface GithubRepo {\n+  /** API client that can access the repository. */\n+  api: GithubClient;\n+  /** Owner login of the repository. */\n+  owner: string;\n+  /** Name of the repository. */\n+  repo: string;\n+  /**\n+   * NPM package representing this repository. Angular repositories usually contain\n+   * multiple packages in a monorepo scheme, but packages commonly are released with\n+   * the same versions. This means that a single package can be used for querying\n+   * NPM about previously published versions (e.g. to determine active LTS versions).\n+   * */\n+  npmPackageName: string;\n+}\n+\n+/** Type describing a version-branch. */\n+export interface VersionBranch {\n+  /** Name of the branch in Git. e.g. `10.0.x`. */\n+  name: string;\n+  /**\n+   * Parsed SemVer version for the version-branch. Version branches technically do\n+   * not follow the SemVer format, but we can have representative SemVer versions\n+   * that can be used for comparisons, sorting and other checks.\n+   */\n+  parsed: semver.SemVer;\n+}\n+\n+/** Branch name for the `next` branch. */\n+export const nextBranchName = 'master';\n+\n+/** Regular expression that matches version-branches for a release-train. */\n+const releaseTrainBranchNameRegex = /(\\d+)\\.(\\d+)\\.x/;\n+\n+/**\n+ * Fetches the active release train and its branches for the specified major version. i.e.\n+ * the latest active release-train branch name is resolved and an optional version-branch for\n+ * a currently active feature-freeze/release-candidate release-train.\n+ */\n+export async function fetchActiveReleaseTrainBranches(\n+    repo: GithubRepo, nextVersion: semver.SemVer): Promise<{\n+  /**\n+   * Name of the currently active release-candidate branch. Null if no\n+   * feature-freeze/release-candidate is currently active.\n+   */\n+  releaseCandidateBranch: string | null,\n+  /** Name of the latest non-prerelease version branch (i.e. the patch branch). */\n+  latestVersionBranch: string\n+}> {\n+  const majorVersionsToConsider: number[] = [];\n+  let expectedReleaseCandidateMajor: number;\n+\n+  // If the `next` branch (i.e. `master` branch) is for an upcoming major version, we know\n+  // that there is no patch branch or feature-freeze/release-candidate branch for this major\n+  // digit. If the current `next` version is the first minor of a major version, we know that\n+  // the feature-freeze/release-candidate branch can only be the actual major branch. The\n+  // patch branch is based on that, either the actual major branch or the last minor from the\n+  // preceding major version. In all other cases, the patch branch and feature-freeze or\n+  // release-candidate branch are part of the same major version. Consider the following:\n+  //\n+  //  CASE 1. next: 11.0.0-next.0: patch and feature-freeze/release-candidate can only be\n+  //          most recent `10.<>.x` branches. The FF/RC branch can only be the last-minor of v10.\n+  //  CASE 2. next: 11.1.0-next.0: patch can be either `11.0.x` or last-minor in v10 based\n+  //          on whether there is a feature-freeze/release-candidate branch (=> `11.0.x`).\n+  //  CASE 3. next: 10.6.0-next.0: patch can be either `10.5.x` or `10.4.x` based on whether\n+  //          there is a feature-freeze/release-candidate branch (=> `10.5.x`)\n+  if (nextVersion.minor === 0) {\n+    expectedReleaseCandidateMajor = nextVersion.major - 1;\n+    majorVersionsToConsider.push(nextVersion.major - 1);\n+  } else if (nextVersion.minor === 1) {\n+    expectedReleaseCandidateMajor = nextVersion.major;\n+    majorVersionsToConsider.push(nextVersion.major, nextVersion.major - 1);\n+  } else {\n+    expectedReleaseCandidateMajor = nextVersion.major;\n+    majorVersionsToConsider.push(nextVersion.major);\n+  }\n+\n+  // Collect all version-branches that should be considered for the latest version-branch,\n+  // or the feature-freeze/release-candidate.\n+  const branches = (await getBranchesForMajorVersions(repo, majorVersionsToConsider));\n+  const {latestVersionBranch, releaseCandidateBranch} =\n+      await findActiveVersionBranches(repo, nextVersion, branches, expectedReleaseCandidateMajor);\n+\n+  if (latestVersionBranch === null) {\n+    throw Error(\n+        `Unable to determine the latest release-train. The following branches ` +\n+        `have been considered: [${branches.join(', ')}]`);\n+  }\n+\n+  return {releaseCandidateBranch, latestVersionBranch};\n+}\n+\n+/** Gets the version of a given branch by reading the `package.json` upstream. */\n+export async function getVersionOfBranch(\n+    repo: GithubRepo, branchName: string): Promise<semver.SemVer> {\n+  const {data} =\n+      await repo.api.repos.getContents({...repo, path: '/package.json', ref: branchName});\n+  const {version} = JSON.parse(Buffer.from(data.content, 'base64').toString());\n+  const parsedVersion = semver.parse(version);\n+  if (parsedVersion === null) {\n+    throw Error(`Invalid version detected in following branch: ${branchName}.`);\n+  }\n+  return parsedVersion;\n+}\n+\n+/** Whether the given branch corresponds to a release-train branch. */\n+export function isReleaseTrainBranch(branchName: string): boolean {\n+  return releaseTrainBranchNameRegex.test(branchName);\n+}\n+\n+/**\n+ * Converts a given version-branch into a SemVer version that can be used with SemVer\n+ * utilities. e.g. to determine semantic order, extract major digit, compare.\n+ *\n+ * For example `10.0.x` will become `10.0.0` in SemVer. The patch digit is not\n+ * relevant but needed for parsing. SemVer does not allow `x` as patch digit.\n+ */\n+export function getVersionForReleaseTrainBranch(branchName: string): semver.SemVer|null {\n+  // Convert a given version-branch into a SemVer version that can be used\n+  // with the SemVer utilities. i.e. to determine semantic order.\n+  return semver.parse(branchName.replace(releaseTrainBranchNameRegex, '$1.$2.0'));\n+}\n+\n+/**\n+ * Gets the version branches for the specified major versions in descending\n+ * order. i.e. latest version branches first.\n+ */\n+export async function getBranchesForMajorVersions(\n+    repo: GithubRepo, majorVersions: number[]): Promise<VersionBranch[]> {\n+  const {data: branchData} = await repo.api.repos.listBranches({...repo, protected: true});\n+  const branches: VersionBranch[] = [];\n+\n+  for (const {name} of branchData) {\n+    if (!isReleaseTrainBranch(name)) {\n+      continue;\n+    }\n+    // Convert the version-branch into a SemVer version that can be used with the\n+    // SemVer utilities. e.g. to determine semantic order, compare versions.\n+    const parsed = getVersionForReleaseTrainBranch(name);\n+    // Collect all version-branches that match the specified major versions.\n+    if (parsed !== null && majorVersions.includes(parsed.major)) {\n+      branches.push({name, parsed});\n+    }\n+  }\n+\n+  // Sort captured version-branches in descending order.\n+  return branches.sort((a, b) => semver.rcompare(a.parsed, b.parsed));\n+}\n+\n+export async function findActiveVersionBranches(\n+    repo: GithubRepo, nextVersion: semver.SemVer, branches: VersionBranch[],\n+    expectedReleaseCandidateMajor: number): Promise<{\n+  latestVersionBranch: string | null,\n+  releaseCandidateBranch: string | null,\n+}> {\n+  let latestVersionBranch: string|null = null;\n+  let releaseCandidateBranch: string|null = null;\n+\n+  // Iterate through the captured branches and find the latest non-prerelease branch and a\n+  // potential release candidate branch. From the collected branches we iterate descending\n+  // order (most recent semantic version-branch first). The first branch is either the latest\n+  // active version branch (i.e. patch) or a feature-freeze/release-candidate branch. A FF/RC\n+  // branch cannot be older than the latest active version-branch, so we stop iterating once\n+  // we found such a branch. Otherwise, if we found a FF/RC branch, we continue looking for the\n+  // next version-branch as that one is supposed to be the latest active version-branch. If it\n+  // is not, then an error will be thrown due to two FF/RC branches existing at the same time.\n+  for (const {name, parsed} of branches) {\n+    // It can happen that version branches that are more recent than the version in the next\n+    // branch (i.e. `master`) have been created. We could ignore such branches silently, but\n+    // it might actually be symptomatic for an outdated version in the `next` branch, or an\n+    // accidentally created branch by the caretaker. In either way we want to raise awareness.\n+    if (semver.gte(parsed, nextVersion)) {\n+      throw Error(\n+          `Discovered unexpected version-branch that is representing a minor ` +\n+          `version more recent than the one in the \"${nextBranchName}\" branch. Consider ` +\n+          `deleting the branch, or check if the version in \"${nextBranchName}\" is outdated.`);\n+    }\n+\n+    const version = await getVersionOfBranch(repo, name);\n+    const isPrerelease = version.prerelease[0] === 'rc' || version.prerelease[0] === 'next';\n+    if (isPrerelease) {\n+      if (releaseCandidateBranch !== null) {\n+        throw Error(\n+            `Unable to determine latest release-train. Found two consecutive ` +\n+            `branches in feature-freeze/release-candidate phase. Did not expect both \"${name}\" ` +\n+            `and \"${releaseCandidateBranch}\" to be in feature-freeze/release-candidate mode.`);\n+      } else if (version.major !== expectedReleaseCandidateMajor) {\n+        throw Error(\n+            `Discovered unexpected old feature-freeze/release-candidate branch. Expected no ` +\n+            `version-branch in feature-freeze/release-candidate mode for v${version.major}.`);\n+      }\n+      releaseCandidateBranch = name;\n+    } else {\n+      latestVersionBranch = name;\n+      break;\n+    }\n+  }\n+\n+  return {releaseCandidateBranch, latestVersionBranch};\n+}"
        },
        {
            "sha": "b633d828256a0513c7f33768991f63bd7b55cfc8",
            "filename": "dev-infra/pr/merge/defaults/index.ts",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/f0766a4474403aba752c8a797765ba6999dc613f/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/f0766a4474403aba752c8a797765ba6999dc613f/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Findex.ts?ref=f0766a4474403aba752c8a797765ba6999dc613f",
            "patch": "@@ -0,0 +1,11 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+export * from './labels';\n+export * from './branches';\n+export * from './lts-branch';"
        },
        {
            "sha": "d085422e9012fdc6b519d5fadaab3b22bbf8b7f5",
            "filename": "dev-infra/pr/merge/defaults/integration.spec.ts",
            "status": "added",
            "additions": 455,
            "deletions": 0,
            "changes": 455,
            "blob_url": "https://github.com/angular/angular/blob/f0766a4474403aba752c8a797765ba6999dc613f/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Fintegration.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f0766a4474403aba752c8a797765ba6999dc613f/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Fintegration.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Fintegration.spec.ts?ref=f0766a4474403aba752c8a797765ba6999dc613f",
            "patch": "@@ -0,0 +1,455 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as nock from 'nock';\n+import * as nodeFetch from 'node-fetch';\n+\n+import {GithubConfig} from '../../../utils/config';\n+import * as console from '../../../utils/console';\n+import {GithubClient} from '../../../utils/git/github';\n+import {TargetLabel} from '../config';\n+import {getBranchesFromTargetLabel, getTargetLabelFromPullRequest} from '../target-label';\n+\n+import {getDefaultTargetLabelConfiguration} from './index';\n+\n+const API_ENDPOINT = `https://api.github.com`;\n+\n+describe('default target labels', () => {\n+  let api: GithubClient;\n+  let config: GithubConfig;\n+  let npmPackageName: string;\n+\n+  beforeEach(() => {\n+    api = new GithubClient();\n+    config = {owner: 'angular', name: 'dev-infra-test'};\n+    npmPackageName = '@angular/dev-infra-test-pkg';\n+\n+    // The label determination will print warn messages. These should not be\n+    // printed to the console, so we turn `console.warn` into a spy.\n+    spyOn(console, 'warn');\n+  });\n+\n+  afterEach(() => nock.cleanAll());\n+\n+  async function computeTargetLabels(): Promise<TargetLabel[]> {\n+    return getDefaultTargetLabelConfiguration(api, config, npmPackageName);\n+  }\n+\n+  function getRepoApiRequestUrl(): string {\n+    return `${API_ENDPOINT}/repos/${config.owner}/${config.name}`;\n+  }\n+\n+  /**\n+   * Mocks a branch `package.json` version API request.\n+   * https://docs.github.com/en/rest/reference/repos#get-repository-content.\n+   */\n+  function interceptBranchVersionRequest(branchName: string, version: string) {\n+    nock(getRepoApiRequestUrl())\n+        .get('/contents//package.json')\n+        .query(params => params.ref === branchName)\n+        .reply(200, {content: Buffer.from(JSON.stringify({version})).toString('base64')});\n+  }\n+\n+  /** Fakes a prompt confirm question with the given value. */\n+  function fakePromptConfirmValue(returnValue: boolean) {\n+    spyOn(console, 'promptConfirm').and.resolveTo(returnValue);\n+  }\n+\n+  /** Fakes a NPM package query API request. */\n+  function fakeNpmPackageQueryRequest(data: unknown) {\n+    // Note: We only need to mock the `json` function for a `Response`. Types\n+    // would expect us to mock more functions, so we need to cast to `any`.\n+    spyOn(nodeFetch, 'default').and.resolveTo({json: async () => data} as any);\n+  }\n+\n+  /**\n+   * Mocks a repository branch list API request.\n+   * https://docs.github.com/en/rest/reference/repos#list-branches.\n+   */\n+  function interceptBranchesListRequest(branches: string[]) {\n+    nock(getRepoApiRequestUrl())\n+        .get('/branches')\n+        .query(true)\n+        .reply(200, branches.map(name => ({name})));\n+  }\n+\n+  async function getBranchesForLabel(\n+      name: string, githubTargetBranch = 'master', labels?: TargetLabel[]): Promise<string[]|null> {\n+    if (labels === undefined) {\n+      labels = await computeTargetLabels();\n+    }\n+    const label = getTargetLabelFromPullRequest({labels}, [name]);\n+    if (label === null) {\n+      return null;\n+    }\n+    return await getBranchesFromTargetLabel(label, githubTargetBranch);\n+  }\n+\n+  it('should detect \"master\" as branch for target: minor', async () => {\n+    interceptBranchVersionRequest('master', '11.0.0-next.0');\n+    interceptBranchVersionRequest('10.2.x', '10.2.4');\n+    interceptBranchesListRequest(['10.2.x']);\n+\n+    expect(await getBranchesForLabel('target: minor')).toEqual(['master']);\n+  });\n+\n+  it('should error if non version-branch is targeted with \"target: lts\"', async () => {\n+    interceptBranchVersionRequest('master', '11.0.0-next.0');\n+    interceptBranchVersionRequest('10.2.x', '10.2.4');\n+    interceptBranchesListRequest(['10.2.x']);\n+\n+    await expectAsync(getBranchesForLabel('target: lts', 'master'))\n+        .toBeRejectedWith(jasmine.objectContaining({\n+          failureMessage:\n+              'PR cannot be merged as it does not target a long-term support branch: \"master\"'\n+        }));\n+  });\n+\n+  it('should error if patch branch is targeted with \"target: lts\"', async () => {\n+    interceptBranchVersionRequest('master', '11.0.0-next.0');\n+    interceptBranchVersionRequest('10.2.x', '10.2.4');\n+    interceptBranchesListRequest(['10.2.x']);\n+\n+    await expectAsync(getBranchesForLabel('target: lts', '10.2.x'))\n+        .toBeRejectedWith(jasmine.objectContaining({\n+          failureMessage:\n+              'PR cannot be merged with \"target: lts\" into patch branch. Consider changing the ' +\n+              'label to \"target: patch\" if this is intentional.'\n+        }));\n+  });\n+\n+  it('should error if feature-freeze branch is targeted with \"target: lts\"', async () => {\n+    interceptBranchVersionRequest('master', '11.0.0-next.0');\n+    interceptBranchVersionRequest('10.2.x', '10.2.0-next.0');\n+    interceptBranchVersionRequest('10.1.x', '10.1.0');\n+    interceptBranchesListRequest(['10.1.x', '10.2.x']);\n+\n+    await expectAsync(getBranchesForLabel('target: lts', '10.2.x'))\n+        .toBeRejectedWith(jasmine.objectContaining({\n+          failureMessage:\n+              'PR cannot be merged with \"target: lts\" into feature-freeze/release-candidate branch. ' +\n+              'Consider changing the label to \"target: rc\" if this is intentional.'\n+        }));\n+  });\n+\n+  it('should error if release-candidate branch is targeted with \"target: lts\"', async () => {\n+    interceptBranchVersionRequest('master', '11.0.0-next.0');\n+    interceptBranchVersionRequest('10.2.x', '10.2.0-rc.0');\n+    interceptBranchVersionRequest('10.1.x', '10.1.0');\n+    interceptBranchesListRequest(['10.1.x', '10.2.x']);\n+\n+    await expectAsync(getBranchesForLabel('target: lts', '10.2.x'))\n+        .toBeRejectedWith(jasmine.objectContaining({\n+          failureMessage:\n+              'PR cannot be merged with \"target: lts\" into feature-freeze/release-candidate branch. ' +\n+              'Consider changing the label to \"target: rc\" if this is intentional.'\n+        }));\n+  });\n+\n+  it('should error if branch targeted with \"target: lts\" is no longer active', async () => {\n+    interceptBranchVersionRequest('master', '11.1.0-next.0');\n+    interceptBranchVersionRequest('11.0.x', '11.0.0');\n+    interceptBranchVersionRequest('10.5.x', '10.5.1');\n+    interceptBranchesListRequest(['10.5.x', '11.0.x']);\n+\n+    // We support forcibly proceeding with merging if a given branch previously was in LTS mode\n+    // but no longer is (after a period of time). In this test, we are not forcibly proceeding.\n+    fakePromptConfirmValue(false);\n+    fakeNpmPackageQueryRequest({\n+      'dist-tags': {\n+        'v10-lts': '10.5.1',\n+      },\n+      'time': {\n+        // v10 has been released at the given specified date. We pick a date that\n+        // guarantees that the version is no longer considered as active LTS version.\n+        '10.0.0': new Date(1912, 5, 23),\n+      }\n+    });\n+\n+    await expectAsync(getBranchesForLabel('target: lts', '10.5.x'))\n+        .toBeRejectedWith(jasmine.objectContaining({\n+          failureMessage:\n+              'Long-term supported ended for v10 on 12/23/1913. Pull request cannot be merged ' +\n+              'into the 10.5.x branch.'\n+        }));\n+  });\n+\n+  it('should error if branch targeted with \"target: lts\" is not latest LTS for given major',\n+     async () => {\n+       interceptBranchVersionRequest('master', '11.1.0-next.0');\n+       interceptBranchVersionRequest('11.0.x', '11.0.0');\n+       interceptBranchVersionRequest('10.5.x', '10.5.1');\n+       interceptBranchVersionRequest('10.4.x', '10.4.4');\n+       interceptBranchesListRequest(['10.4.x', '10.5.x', '11.0.x']);\n+\n+       fakeNpmPackageQueryRequest({\n+         'dist-tags': {\n+           'v10-lts': '10.5.1',\n+         }\n+       });\n+\n+       await expectAsync(getBranchesForLabel('target: lts', '10.4.x'))\n+           .toBeRejectedWith(jasmine.objectContaining({\n+             failureMessage:\n+                 'Not using last-minor branch for v10 LTS version. PR should be updated to ' +\n+                 'target: 10.5.x'\n+           }));\n+     });\n+\n+  it('should error if branch targeted with \"target: lts\" is not a major version with LTS',\n+     async () => {\n+       interceptBranchVersionRequest('master', '11.1.0-next.0');\n+       interceptBranchVersionRequest('11.0.x', '11.0.0');\n+       interceptBranchVersionRequest('10.5.x', '10.5.1');\n+       interceptBranchesListRequest(['10.5.x', '11.0.x']);\n+\n+       fakeNpmPackageQueryRequest({'dist-tags': {}});\n+\n+       await expectAsync(getBranchesForLabel('target: lts', '10.5.x'))\n+           .toBeRejectedWith(\n+               jasmine.objectContaining({failureMessage: 'No LTS version tagged for v10 in NPM.'}));\n+     });\n+\n+  it('should allow forcibly proceeding with merge if branch targeted with \"target: lts\" is no ' +\n+         'longer active',\n+     async () => {\n+       interceptBranchVersionRequest('master', '11.1.0-next.0');\n+       interceptBranchVersionRequest('11.0.x', '11.0.0');\n+       interceptBranchVersionRequest('10.5.x', '10.5.1');\n+       interceptBranchesListRequest(['10.5.x', '11.0.x']);\n+\n+       // We support forcibly proceeding with merging if a given branch previously was in LTS mode\n+       // but no longer is (after a period of time). In this test, we are forcibly proceeding and\n+       // expect the Github target branch to be picked up as branch for the `target: lts` label.\n+       fakePromptConfirmValue(true);\n+       fakeNpmPackageQueryRequest({\n+         'dist-tags': {\n+           'v10-lts': '10.5.1',\n+         },\n+         'time': {\n+           // v10 has been released at the given specified date. We pick a date that\n+           // guarantees that the version is no longer considered as active LTS version.\n+           '10.0.0': new Date(1912, 5, 23),\n+         }\n+       });\n+\n+       expect(await getBranchesForLabel('target: lts', '10.5.x')).toEqual(['10.5.x']);\n+     });\n+\n+  it('should use target branch for \"target: lts\" if it matches an active LTS branch', async () => {\n+    interceptBranchVersionRequest('master', '11.1.0-next.0');\n+    interceptBranchVersionRequest('11.0.x', '11.0.0');\n+    interceptBranchVersionRequest('10.5.x', '10.5.1');\n+    interceptBranchesListRequest(['10.5.x', '11.0.x']);\n+\n+    spyOn(require('node-fetch'), 'default').and.callFake(() => ({\n+                                                           json: () => ({\n+                                                             'dist-tags': {\n+                                                               'v10-lts': '10.5.1',\n+                                                             },\n+                                                             'time': {\n+                                                               '10.0.0': new Date().toISOString(),\n+                                                             }\n+                                                           }),\n+                                                         }));\n+\n+    expect(await getBranchesForLabel('target: lts', '10.5.x')).toEqual(['10.5.x']);\n+  });\n+\n+  it('should error if no active branch for given major version could be found', async () => {\n+    interceptBranchVersionRequest('master', '12.0.0-next.0');\n+    interceptBranchesListRequest(['9.0.x', '9.1.x']);\n+\n+    await expectAsync(getBranchesForLabel('target: lts', '10.2.x'))\n+        .toBeRejectedWithError(\n+            'Unable to determine the latest release-train. The following branches have ' +\n+            'been considered: []');\n+  });\n+\n+  it('should error if invalid version is set for version-branch', async () => {\n+    interceptBranchVersionRequest('master', '11.2.0-next.0');\n+    interceptBranchVersionRequest('11.1.x', '11.1.x');\n+    interceptBranchesListRequest(['11.1.x']);\n+\n+    await expectAsync(getBranchesForLabel('target: lts', '10.2.x'))\n+        .toBeRejectedWithError('Invalid version detected in following branch: 11.1.x.');\n+  });\n+\n+  it('should error if branch more recent than version in \"next\" branch is found', async () => {\n+    interceptBranchVersionRequest('master', '11.2.0-next.0');\n+    interceptBranchVersionRequest('11.2.x', '11.2.0-next.0');\n+    interceptBranchVersionRequest('11.1.x', '11.1.5');\n+    interceptBranchesListRequest(['11.1.x', '11.2.x']);\n+\n+    await expectAsync(getBranchesForLabel('target: lts', '10.2.x'))\n+        .toBeRejectedWithError(\n+            'Discovered unexpected version-branch that is representing a minor version more ' +\n+            'recent than the one in the \"master\" branch. Consider deleting the branch, or check ' +\n+            'if the version in \"master\" is outdated.');\n+  });\n+\n+  it('should allow merging PR only into patch branch with \"target: patch\"', async () => {\n+    interceptBranchVersionRequest('master', '11.2.0-next.0');\n+    interceptBranchVersionRequest('11.1.x', '11.1.0');\n+    interceptBranchesListRequest(['11.1.x']);\n+\n+    expect(await getBranchesForLabel('target: patch', '11.1.x')).toEqual(['11.1.x']);\n+  });\n+\n+  describe('next: major release', () => {\n+    it('should detect \"master\" as branch for target: major', async () => {\n+      interceptBranchVersionRequest('master', '11.0.0-next.0');\n+      interceptBranchVersionRequest('10.2.x', '10.2.4');\n+      interceptBranchesListRequest(['10.2.x']);\n+\n+      expect(await getBranchesForLabel('target: major')).toEqual(['master']);\n+    });\n+\n+    describe('without active release-candidate', () => {\n+      it('should detect last-minor from previous major as branch for target: patch', async () => {\n+        interceptBranchVersionRequest('master', '11.0.0-next.0');\n+        interceptBranchVersionRequest('10.2.x', '10.2.4');\n+        interceptBranchesListRequest(['10.0.x', '10.1.x', '10.2.x']);\n+\n+        expect(await getBranchesForLabel('target: patch')).toEqual(['master', '10.2.x']);\n+      });\n+\n+      it('should error if \"target: rc\" is applied', async () => {\n+        interceptBranchVersionRequest('master', '11.0.0-next.0');\n+        interceptBranchVersionRequest('10.2.x', '10.2.4');\n+        interceptBranchesListRequest(['10.0.x', '10.1.x', '10.2.x']);\n+\n+        await expectAsync(getBranchesForLabel('target: rc'))\n+            .toBeRejectedWith(jasmine.objectContaining({\n+              failureMessage:\n+                  'No active feature-freeze/release-candidate branch. Unable to merge ' +\n+                  'pull request using \"target: rc\" label.'\n+            }));\n+      });\n+    });\n+\n+    describe('with active release-candidate', () => {\n+      it('should detect most recent non-prerelease minor branch from previous major for ' +\n+             'target: patch',\n+         async () => {\n+           interceptBranchVersionRequest('master', '11.0.0-next.0');\n+           interceptBranchVersionRequest('10.2.x', '10.2.0-rc.0');\n+           interceptBranchVersionRequest('10.1.x', '10.2.3');\n+           interceptBranchesListRequest(['10.1.x', '10.2.x']);\n+\n+           // Pull requests should also be merged into the RC and `next` (i.e. `master`) branch.\n+           expect(await getBranchesForLabel('target: patch')).toEqual([\n+             'master', '10.1.x', '10.2.x'\n+           ]);\n+         });\n+\n+      it('should detect release-candidate branch for \"target: rc\"', async () => {\n+        interceptBranchVersionRequest('master', '11.0.0-next.0');\n+        interceptBranchVersionRequest('10.2.x', '10.2.0-rc.0');\n+        interceptBranchVersionRequest('10.1.x', '10.1.0');\n+        interceptBranchesListRequest(['10.0.x', '10.1.x', '10.2.x']);\n+\n+        expect(await getBranchesForLabel('target: rc')).toEqual(['master', '10.2.x']);\n+      });\n+\n+      it('should detect feature-freeze branch with \"target: rc\"', async () => {\n+        interceptBranchVersionRequest('master', '11.0.0-next.0');\n+        interceptBranchVersionRequest('10.2.x', '10.2.0-next.0');\n+        interceptBranchVersionRequest('10.1.x', '10.1.0');\n+        interceptBranchesListRequest(['10.0.x', '10.1.x', '10.2.x']);\n+\n+        expect(await getBranchesForLabel('target: rc')).toEqual(['master', '10.2.x']);\n+      });\n+\n+      it('should error if multiple consecutive release-candidate branches are found', async () => {\n+        interceptBranchVersionRequest('master', '11.0.0-next.0');\n+        interceptBranchVersionRequest('10.4.x', '10.4.0-next.0');\n+        interceptBranchVersionRequest('10.3.x', '10.4.0-rc.5');\n+        interceptBranchesListRequest(['10.3.x', '10.4.x']);\n+\n+        await expectAsync(getBranchesForLabel('target: patch'))\n+            .toBeRejectedWithError(\n+                'Unable to determine latest release-train. Found two consecutive ' +\n+                'branches in feature-freeze/release-candidate phase. Did not expect both ' +\n+                '\"10.3.x\" and \"10.4.x\" to be in feature-freeze/release-candidate mode.');\n+      });\n+    });\n+  });\n+\n+  describe('next: minor release', () => {\n+    it('should error if \"target: major\" is applied', async () => {\n+      interceptBranchVersionRequest('master', '11.2.0-next.0');\n+      interceptBranchVersionRequest('11.1.x', '11.1.4');\n+      interceptBranchesListRequest(['11.1.x']);\n+\n+      await expectAsync(getBranchesForLabel('target: major'))\n+          .toBeRejectedWith(jasmine.objectContaining({\n+            failureMessage:\n+                'Unable to merge pull request. The \"master\" branch will be released as ' +\n+                'a minor version.',\n+          }));\n+    });\n+\n+    describe('without active release-candidate', () => {\n+      it('should detect last-minor from previous major as branch for target: patch', async () => {\n+        interceptBranchVersionRequest('master', '11.2.0-next.0');\n+        interceptBranchVersionRequest('11.1.x', '11.1.0');\n+        interceptBranchesListRequest(['11.1.x']);\n+\n+        expect(await getBranchesForLabel('target: patch')).toEqual(['master', '11.1.x']);\n+      });\n+\n+      it('should error if \"target: rc\" is applied', async () => {\n+        interceptBranchVersionRequest('master', '11.2.0-next.0');\n+        interceptBranchVersionRequest('11.1.x', '11.1.0');\n+        interceptBranchesListRequest(['11.1.x']);\n+\n+        await expectAsync(getBranchesForLabel('target: rc'))\n+            .toBeRejectedWith(jasmine.objectContaining({\n+              failureMessage:\n+                  'No active feature-freeze/release-candidate branch. Unable to merge pull ' +\n+                  'request using \"target: rc\" label.'\n+            }));\n+      });\n+    });\n+\n+    describe('with active release-candidate', () => {\n+      it('should detect most recent non-prerelease minor branch from previous major for ' +\n+             'target: patch',\n+         async () => {\n+           interceptBranchVersionRequest('master', '11.2.0-next.0');\n+           interceptBranchVersionRequest('11.1.x', '11.1.0-rc.0');\n+           interceptBranchVersionRequest('11.0.x', '11.0.0');\n+           interceptBranchesListRequest(['11.0.x', '11.1.x']);\n+\n+           // Pull requests should also be merged into the RC and `next` (i.e. `master`) branch.\n+           expect(await getBranchesForLabel('target: patch')).toEqual([\n+             'master', '11.0.x', '11.1.x'\n+           ]);\n+         });\n+\n+      it('should detect release-candidate branch for \"target: rc\"', async () => {\n+        interceptBranchVersionRequest('master', '11.2.0-next.0');\n+        interceptBranchVersionRequest('11.1.x', '11.1.0-rc.0');\n+        interceptBranchVersionRequest('11.0.x', '10.0.0');\n+        interceptBranchesListRequest(['11.0.x', '11.1.x']);\n+\n+        expect(await getBranchesForLabel('target: rc')).toEqual(['master', '11.1.x']);\n+      });\n+\n+      it('should detect feature-freeze branch with \"target: rc\"', async () => {\n+        interceptBranchVersionRequest('master', '11.2.0-next.0');\n+        interceptBranchVersionRequest('11.1.x', '11.1.0-next.0');\n+        interceptBranchVersionRequest('11.0.x', '10.0.0');\n+        interceptBranchesListRequest(['11.0.x', '11.1.x']);\n+\n+        expect(await getBranchesForLabel('target: rc')).toEqual(['master', '11.1.x']);\n+      });\n+    });\n+  });\n+});"
        },
        {
            "sha": "1ef039bdb9ee7d28ac2b4e50a8b32b556690e264",
            "filename": "dev-infra/pr/merge/defaults/labels.ts",
            "status": "added",
            "additions": 124,
            "deletions": 0,
            "changes": 124,
            "blob_url": "https://github.com/angular/angular/blob/f0766a4474403aba752c8a797765ba6999dc613f/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Flabels.ts",
            "raw_url": "https://github.com/angular/angular/raw/f0766a4474403aba752c8a797765ba6999dc613f/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Flabels.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Flabels.ts?ref=f0766a4474403aba752c8a797765ba6999dc613f",
            "patch": "@@ -0,0 +1,124 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {GithubConfig} from '../../../utils/config';\n+import {GithubClient} from '../../../utils/git/github';\n+import {TargetLabel} from '../config';\n+import {InvalidTargetBranchError, InvalidTargetLabelError} from '../target-label';\n+\n+import {fetchActiveReleaseTrainBranches, getVersionOfBranch, GithubRepo, isReleaseTrainBranch, nextBranchName} from './branches';\n+import {assertActiveLtsBranch} from './lts-branch';\n+\n+/**\n+ * Gets a label configuration for the merge tooling that reflects the default Angular\n+ * organization-wide labeling and branching semantics as outlined in the specification.\n+ *\n+ * https://docs.google.com/document/d/197kVillDwx-RZtSVOBtPb4BBIAw0E9RT3q3v6DZkykU\n+ */\n+export async function getDefaultTargetLabelConfiguration(\n+    api: GithubClient, github: GithubConfig, npmPackageName: string): Promise<TargetLabel[]> {\n+  const repo: GithubRepo = {owner: github.owner, repo: github.name, api, npmPackageName};\n+  const nextVersion = await getVersionOfBranch(repo, nextBranchName);\n+  const hasNextMajorTrain = nextVersion.minor === 0;\n+  const {latestVersionBranch, releaseCandidateBranch} =\n+      await fetchActiveReleaseTrainBranches(repo, nextVersion);\n+\n+  return [\n+    {\n+      pattern: 'target: major',\n+      branches: () => {\n+        // If `next` is currently not designated to be a major version, we do not\n+        // allow merging of PRs with `target: major`.\n+        if (!hasNextMajorTrain) {\n+          throw new InvalidTargetLabelError(\n+              `Unable to merge pull request. The \"${nextBranchName}\" branch will be ` +\n+              `released as a minor version.`);\n+        }\n+        return [nextBranchName];\n+      },\n+    },\n+    {\n+      pattern: 'target: minor',\n+      // Changes labeled with `target: minor` are merged most commonly into the next branch\n+      // (i.e. `master`). In rare cases of an exceptional minor version while being already\n+      // on a major release train, this would need to be overridden manually.\n+      // TODO: Consider handling this automatically by checking if the NPM version matches\n+      // the last-minor. If not, then an exceptional minor might be in progress. See:\n+      // https://docs.google.com/document/d/197kVillDwx-RZtSVOBtPb4BBIAw0E9RT3q3v6DZkykU/edit#heading=h.h7o5pjq6yqd0\n+      branches: [nextBranchName],\n+    },\n+    {\n+      pattern: 'target: patch',\n+      branches: githubTargetBranch => {\n+        // If a PR is targeting the latest active version-branch through the Github UI,\n+        // and is also labeled with `target: patch`, then we merge it directly into the\n+        // branch without doing any cherry-picking. This is useful if a PR could not be\n+        // applied cleanly, and a separate PR for the patch branch has been created.\n+        if (githubTargetBranch === latestVersionBranch) {\n+          return [latestVersionBranch];\n+        }\n+        // Otherwise, patch changes are always merged into the next and patch branch.\n+        const branches = [nextBranchName, latestVersionBranch];\n+        // Additionally, if there is a release-candidate/feature-freeze release-train\n+        // currently active, also merge the PR into that version-branch.\n+        if (releaseCandidateBranch !== null) {\n+          branches.push(releaseCandidateBranch);\n+        }\n+        return branches;\n+      }\n+    },\n+    {\n+      pattern: 'target: rc',\n+      branches: githubTargetBranch => {\n+        // The `target: rc` label cannot be applied if there is no active feature-freeze\n+        // or release-candidate release train.\n+        if (releaseCandidateBranch === null) {\n+          throw new InvalidTargetLabelError(\n+              `No active feature-freeze/release-candidate branch. ` +\n+              `Unable to merge pull request using \"target: rc\" label.`);\n+        }\n+        // If the PR is targeting the active release-candidate/feature-freeze version branch\n+        // directly through the Github UI and has the `target: rc` label applied, merge it\n+        // only into the release candidate branch. This is useful if a PR did not apply cleanly\n+        // into the release-candidate/feature-freeze branch, and a separate PR has been created.\n+        if (githubTargetBranch === releaseCandidateBranch) {\n+          return [releaseCandidateBranch];\n+        }\n+        // Otherwise, merge into the next and active release-candidate/feature-freeze branch.\n+        return [nextBranchName, releaseCandidateBranch];\n+      },\n+    },\n+    {\n+      // LTS changes are rare enough that we won't worry about cherry-picking changes into all\n+      // active LTS branches for PRs created against any other branch. Instead, PR authors need\n+      // to manually create separate PRs for desired LTS branches. Additionally, active LT branches\n+      // commonly diverge quickly. This makes cherry-picking not an option for LTS changes.\n+      pattern: 'target: lts',\n+      branches: async githubTargetBranch => {\n+        if (!isReleaseTrainBranch(githubTargetBranch)) {\n+          throw new InvalidTargetBranchError(\n+              `PR cannot be merged as it does not target a long-term support ` +\n+              `branch: \"${githubTargetBranch}\"`);\n+        }\n+        if (githubTargetBranch === latestVersionBranch) {\n+          throw new InvalidTargetBranchError(\n+              `PR cannot be merged with \"target: lts\" into patch branch. ` +\n+              `Consider changing the label to \"target: patch\" if this is intentional.`);\n+        }\n+        if (githubTargetBranch === releaseCandidateBranch && releaseCandidateBranch !== null) {\n+          throw new InvalidTargetBranchError(\n+              `PR cannot be merged with \"target: lts\" into feature-freeze/release-candidate ` +\n+              `branch. Consider changing the label to \"target: rc\" if this is intentional.`);\n+        }\n+        // Assert that the selected branch is an active LTS branch.\n+        await assertActiveLtsBranch(repo, githubTargetBranch);\n+        return [githubTargetBranch];\n+      },\n+    },\n+  ];\n+}"
        },
        {
            "sha": "5db07f8ad406e0c2747da0243e9dfd0072bb952f",
            "filename": "dev-infra/pr/merge/defaults/lts-branch.ts",
            "status": "added",
            "additions": 80,
            "deletions": 0,
            "changes": 80,
            "blob_url": "https://github.com/angular/angular/blob/f0766a4474403aba752c8a797765ba6999dc613f/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Flts-branch.ts",
            "raw_url": "https://github.com/angular/angular/raw/f0766a4474403aba752c8a797765ba6999dc613f/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Flts-branch.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fpr%2Fmerge%2Fdefaults%2Flts-branch.ts?ref=f0766a4474403aba752c8a797765ba6999dc613f",
            "patch": "@@ -0,0 +1,80 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import fetch from 'node-fetch';\n+import * as semver from 'semver';\n+\n+import {promptConfirm, red, warn, yellow} from '../../../utils/console';\n+import {InvalidTargetBranchError} from '../target-label';\n+\n+import {getVersionOfBranch, GithubRepo} from './branches';\n+\n+/**\n+ * Number of months a major version in Angular is actively supported. See:\n+ * https://angular.io/guide/releases#support-policy-and-schedule.\n+ */\n+const majorActiveSupportDuration = 6;\n+\n+/**\n+ * Number of months a major version has active long-term support. See:\n+ * https://angular.io/guide/releases#support-policy-and-schedule.\n+ */\n+const majorActiveTermSupportDuration = 12;\n+\n+/**\n+ * Asserts that the given branch corresponds to an active LTS version-branch that can receive\n+ * backported fixes. Throws an error if LTS expired or an invalid branch is selected.\n+ */\n+export async function assertActiveLtsBranch(repo: GithubRepo, branchName: string) {\n+  const version = await getVersionOfBranch(repo, branchName);\n+  const {'dist-tags': distTags, time} =\n+      await (await fetch(`https://registry.npmjs.org/${repo.npmPackageName}`)).json();\n+\n+  // LTS versions should be tagged in NPM in the following format: `v{major}-lts`.\n+  const ltsVersion = semver.parse(distTags[`v${version.major}-lts`]);\n+\n+  // Ensure that there is a LTS version tagged for the given version-branch major. e.g.\n+  // if the version branch is `9.2.x` then we want to make sure that there is a LTS\n+  // version tagged in NPM for `v9`, following the `v{major}-lts` tag convention.\n+  if (ltsVersion === null) {\n+    throw new InvalidTargetBranchError(`No LTS version tagged for v${version.major} in NPM.`);\n+  }\n+\n+  // Ensure that the correct branch is used for the LTS version. We do not want to merge\n+  // changes to older minor version branches that do not reflect the current LTS version.\n+  if (branchName !== `${ltsVersion.major}.${ltsVersion.minor}.x`) {\n+    throw new InvalidTargetBranchError(\n+        `Not using last-minor branch for v${version.major} LTS version. PR ` +\n+        `should be updated to target: ${ltsVersion.major}.${ltsVersion.minor}.x`);\n+  }\n+\n+  const today = new Date();\n+  const releaseDate = new Date(time[`${version.major}.0.0`]);\n+  const ltsEndDate = new Date(\n+      releaseDate.getFullYear(),\n+      releaseDate.getMonth() + majorActiveSupportDuration + majorActiveTermSupportDuration,\n+      releaseDate.getDate(), releaseDate.getHours(), releaseDate.getMinutes(),\n+      releaseDate.getSeconds(), releaseDate.getMilliseconds());\n+\n+  // Check if LTS has already expired for the targeted major version. If so, we do not\n+  // allow the merge as per our LTS guarantees. Can be forcibly overridden if desired.\n+  // See: https://angular.io/guide/releases#support-policy-and-schedule.\n+  if (today > ltsEndDate) {\n+    const ltsEndDateText = ltsEndDate.toLocaleDateString();\n+    warn(red(`Long-term support ended for v${version.major} on ${ltsEndDateText}.`));\n+    warn(yellow(\n+        `Merging of pull requests for this major is generally not ` +\n+        `desired, but can be forcibly ignored.`));\n+    if (await promptConfirm('Do you want to forcibly proceed with merging?')) {\n+      return;\n+    }\n+    throw new InvalidTargetBranchError(\n+        `Long-term supported ended for v${version.major} on ${ltsEndDateText}. ` +\n+        `Pull request cannot be merged into the ${branchName} branch.`);\n+  }\n+}"
        },
        {
            "sha": "bf4a479caad63c27cbc2642146eb45eaa07b2a2f",
            "filename": "dev-infra/pr/merge/determine-merge-branches.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 68,
            "changes": 68,
            "blob_url": "https://github.com/angular/angular/blob/6f0f0d3ea2e44f9884a4a0c8acdf4dda52c09b6c/dev-infra%2Fpr%2Fmerge%2Fdetermine-merge-branches.ts",
            "raw_url": "https://github.com/angular/angular/raw/6f0f0d3ea2e44f9884a4a0c8acdf4dda52c09b6c/dev-infra%2Fpr%2Fmerge%2Fdetermine-merge-branches.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fpr%2Fmerge%2Fdetermine-merge-branches.ts?ref=6f0f0d3ea2e44f9884a4a0c8acdf4dda52c09b6c",
            "patch": "@@ -1,68 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as semver from 'semver';\n-import {exec} from '../../utils/shelljs';\n-\n-/**\n- * Helper function that can be used to determine merge branches based on a given\n- * project version. The function determines merge branches primarily through the\n- * specified version, but falls back to consulting the NPM registry when needed.\n- *\n- * Consulting the NPM registry for determining the patch branch may slow down merging,\n- * so whenever possible, the branches are determined statically based on the current\n- * version. In some cases, consulting the NPM registry is inevitable because for major\n- * pre-releases, we cannot determine the latest stable minor version from the current\n- * pre-release version.\n- */\n-export function determineMergeBranches(\n-    currentVersion: string, npmPackageName: string): {minor: string, patch: string} {\n-  const projectVersion = semver.parse(currentVersion);\n-  if (projectVersion === null) {\n-    throw Error('Cannot parse version set in project \"package.json\" file.');\n-  }\n-  const {major, minor, patch, prerelease} = projectVersion;\n-  const isMajor = minor === 0 && patch === 0;\n-  const isMinor = minor !== 0 && patch === 0;\n-\n-  // If there is no prerelease, then we compute patch and minor branches based\n-  // on the current version major and minor.\n-  if (prerelease.length === 0) {\n-    return {minor: `${major}.x`, patch: `${major}.${minor}.x`};\n-  }\n-\n-  // If current version is set to a minor prerelease, we can compute the merge branches\n-  // statically. e.g. if we are set to `9.3.0-next.0`, then our merge branches should\n-  // be set to `9.x` and `9.2.x`.\n-  if (isMinor) {\n-    return {minor: `${major}.x`, patch: `${major}.${minor - 1}.x`};\n-  } else if (!isMajor) {\n-    throw Error('Unexpected version. Cannot have prerelease for patch version.');\n-  }\n-\n-  // If we are set to a major prerelease, we cannot statically determine the stable patch\n-  // branch (as the latest minor segment is unknown). We determine it by looking in the NPM\n-  // registry for the latest stable release that will tell us about the current minor segment.\n-  // e.g. if the current major is `v10.0.0-next.0`, then we need to look for the latest release.\n-  // Let's say this is `v9.2.6`. Our patch branch will then be called `9.2.x`.\n-  const latestVersion = exec(`yarn -s info ${npmPackageName} dist-tags.latest`).trim();\n-  if (!latestVersion) {\n-    throw Error('Could not determine version of latest release.');\n-  }\n-  const expectedMajor = major - 1;\n-  const parsedLatestVersion = semver.parse(latestVersion);\n-  if (parsedLatestVersion === null) {\n-    throw Error(`Could not parse latest version from NPM registry: ${latestVersion}`);\n-  } else if (parsedLatestVersion.major !== expectedMajor) {\n-    throw Error(\n-        `Expected latest release to have major version: v${expectedMajor}, ` +\n-        `but got: v${latestVersion}`);\n-  }\n-\n-  return {patch: `${expectedMajor}.${parsedLatestVersion.minor}.x`, minor: `${expectedMajor}.x`};\n-}"
        },
        {
            "sha": "3a83fc4e890d1a3ce2511951aa8116942bc0deeb",
            "filename": "dev-infra/pr/merge/target-label.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/f0766a4474403aba752c8a797765ba6999dc613f/dev-infra%2Fpr%2Fmerge%2Ftarget-label.ts",
            "raw_url": "https://github.com/angular/angular/raw/f0766a4474403aba752c8a797765ba6999dc613f/dev-infra%2Fpr%2Fmerge%2Ftarget-label.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fpr%2Fmerge%2Ftarget-label.ts?ref=f0766a4474403aba752c8a797765ba6999dc613f",
            "patch": "@@ -26,8 +26,8 @@ export class InvalidTargetLabelError {\n }\n \n /** Gets the target label from the specified pull request labels. */\n-export function getTargetLabelFromPullRequest(config: MergeConfig, labels: string[]): TargetLabel|\n-    null {\n+export function getTargetLabelFromPullRequest(\n+    config: Pick<MergeConfig, 'labels'>, labels: string[]): TargetLabel|null {\n   for (const label of labels) {\n     const match = config.labels.find(({pattern}) => matchesPattern(label, pattern));\n     if (match !== undefined) {"
        },
        {
            "sha": "0b3048a6651adff51d1d6c03649bf748db9a1b43",
            "filename": "dev-infra/tmpl-package.json",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/f0766a4474403aba752c8a797765ba6999dc613f/dev-infra%2Ftmpl-package.json",
            "raw_url": "https://github.com/angular/angular/raw/f0766a4474403aba752c8a797765ba6999dc613f/dev-infra%2Ftmpl-package.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Ftmpl-package.json?ref=f0766a4474403aba752c8a797765ba6999dc613f",
            "patch": "@@ -19,6 +19,7 @@\n     \"inquirer\": \"<from-root>\",\n     \"minimatch\": \"<from-root>\",\n     \"multimatch\": \"<from-root>\",\n+    \"node-fetch\": \"<from-root>\",\n     \"node-uuid\": \"<from-root>\",\n     \"semver\": \"<from-root>\",\n     \"shelljs\": \"<from-root>\","
        },
        {
            "sha": "350be9de2de69a74c5852898f468fa337f1fbcc0",
            "filename": "package.json",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/f0766a4474403aba752c8a797765ba6999dc613f/package.json",
            "raw_url": "https://github.com/angular/angular/raw/f0766a4474403aba752c8a797765ba6999dc613f/package.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/package.json?ref=f0766a4474403aba752c8a797765ba6999dc613f",
            "patch": "@@ -82,6 +82,7 @@\n     \"@types/jasminewd2\": \"^2.0.8\",\n     \"@types/minimist\": \"^1.2.0\",\n     \"@types/node\": \"^12.11.1\",\n+    \"@types/node-fetch\": \"^2.5.7\",\n     \"@types/selenium-webdriver\": \"3.0.7\",\n     \"@types/semver\": \"^6.0.2\",\n     \"@types/shelljs\": \"^0.8.6\",\n@@ -127,6 +128,7 @@\n     \"materialize-css\": \"1.0.0\",\n     \"minimatch\": \"^3.0.4\",\n     \"minimist\": \"1.2.0\",\n+    \"node-fetch\": \"^2.6.0\",\n     \"node-uuid\": \"1.4.8\",\n     \"nodejs-websocket\": \"^1.7.2\",\n     \"protractor\": \"^5.4.2\",\n@@ -185,6 +187,7 @@\n     \"madge\": \"^3.6.0\",\n     \"multimatch\": \"^4.0.0\",\n     \"mutation-observer\": \"^1.0.3\",\n+    \"nock\": \"^13.0.3\",\n     \"rewire\": \"2.5.2\",\n     \"sauce-connect\": \"https://saucelabs.com/downloads/sc-4.5.1-linux.tar.gz\",\n     \"semver\": \"^6.3.0\","
        },
        {
            "sha": "c234a1cc6ecebd87d6aae23f988965703f86b4f1",
            "filename": "yarn.lock",
            "status": "modified",
            "additions": 33,
            "deletions": 1,
            "changes": 34,
            "blob_url": "https://github.com/angular/angular/blob/f0766a4474403aba752c8a797765ba6999dc613f/yarn.lock",
            "raw_url": "https://github.com/angular/angular/raw/f0766a4474403aba752c8a797765ba6999dc613f/yarn.lock",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/yarn.lock?ref=f0766a4474403aba752c8a797765ba6999dc613f",
            "patch": "@@ -2243,6 +2243,14 @@\n   resolved \"https://registry.yarnpkg.com/@types/minimist/-/minimist-1.2.0.tgz#69a23a3ad29caf0097f06eda59b361ee2f0639f6\"\n   integrity sha1-aaI6OtKcrwCX8G7aWbNh7i8GOfY=\n \n+\"@types/node-fetch@^2.5.7\":\n+  version \"2.5.7\"\n+  resolved \"https://registry.yarnpkg.com/@types/node-fetch/-/node-fetch-2.5.7.tgz#20a2afffa882ab04d44ca786449a276f9f6bbf3c\"\n+  integrity sha512-o2WVNf5UhWRkxlf6eq+jMZDu7kjgpgJfl4xVNlvryc95O/6F2ld8ztKX+qu+Rjyet93WAWm5LjeX9H5FGkODvw==\n+  dependencies:\n+    \"@types/node\" \"*\"\n+    form-data \"^3.0.0\"\n+\n \"@types/node@*\", \"@types/node@>= 8\":\n   version \"13.11.0\"\n   resolved \"https://registry.yarnpkg.com/@types/node/-/node-13.11.0.tgz#390ea202539c61c8fa6ba4428b57e05bc36dc47b\"\n@@ -4418,7 +4426,7 @@ colors@~1.2.1:\n   resolved \"https://registry.yarnpkg.com/colors/-/colors-1.2.5.tgz#89c7ad9a374bc030df8013241f68136ed8835afc\"\n   integrity sha512-erNRLao/Y3Fv54qUa0LBB+//Uf3YwMUmdJinN20yMXm9zdKKqH9wt7R9IIVZ+K7ShzfpLV/Zg8+VyrBJYB4lpg==\n \n-combined-stream@^1.0.5, combined-stream@^1.0.6, combined-stream@~1.0.5, combined-stream@~1.0.6:\n+combined-stream@^1.0.5, combined-stream@^1.0.6, combined-stream@^1.0.8, combined-stream@~1.0.5, combined-stream@~1.0.6:\n   version \"1.0.8\"\n   resolved \"https://registry.yarnpkg.com/combined-stream/-/combined-stream-1.0.8.tgz#c3d45a8b34fd730631a110a8a2520682b31d5a7f\"\n   integrity sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==\n@@ -6792,6 +6800,15 @@ forever-agent@~0.6.1:\n   resolved \"https://registry.yarnpkg.com/forever-agent/-/forever-agent-0.6.1.tgz#fbc71f0c41adeb37f96c577ad1ed42d8fdacca91\"\n   integrity sha1-+8cfDEGt6zf5bFd60e1C2P2sypE=\n \n+form-data@^3.0.0:\n+  version \"3.0.0\"\n+  resolved \"https://registry.yarnpkg.com/form-data/-/form-data-3.0.0.tgz#31b7e39c85f1355b7139ee0c647cf0de7f83c682\"\n+  integrity sha512-CKMFDglpbMi6PyN+brwB9Q/GOw0eAnsrEZDgcsH5Krhz5Od/haKHAX0NmQfha2zPPz0JpWzA7GJHGSnvCRLWsg==\n+  dependencies:\n+    asynckit \"^0.4.0\"\n+    combined-stream \"^1.0.8\"\n+    mime-types \"^2.1.12\"\n+\n form-data@~2.0.0:\n   version \"2.0.0\"\n   resolved \"https://registry.yarnpkg.com/form-data/-/form-data-2.0.0.tgz#6f0aebadcc5da16c13e1ecc11137d85f9b883b25\"\n@@ -10742,6 +10759,16 @@ nice-try@^1.0.4:\n   resolved \"https://registry.yarnpkg.com/nice-try/-/nice-try-1.0.5.tgz#a3378a7696ce7d223e88fc9b764bd7ef1089e366\"\n   integrity sha512-1nh45deeb5olNY7eX82BkPO7SSxR5SSYJiPTrTdFUVYwAl8CKMA5N9PjTYkHiRjisVcxcQ1HXdLhx2qxxJzLNQ==\n \n+nock@^13.0.3:\n+  version \"13.0.3\"\n+  resolved \"https://registry.yarnpkg.com/nock/-/nock-13.0.3.tgz#9f81f04499af6a87f9c419a023920b623d715110\"\n+  integrity sha512-hDscKS5chEfyEiF8J1syz8mkkH6Wetp04ECAAPNdL5k6e6WmRgx9FZZNnCrjePNdykgiiPXORBcXbNmMzFOP5w==\n+  dependencies:\n+    debug \"^4.1.0\"\n+    json-stringify-safe \"^5.0.1\"\n+    lodash.set \"^4.3.2\"\n+    propagate \"^2.0.0\"\n+\n node-emoji@^1.4.1:\n   version \"1.10.0\"\n   resolved \"https://registry.yarnpkg.com/node-emoji/-/node-emoji-1.10.0.tgz#8886abd25d9c7bb61802a658523d1f8d2a89b2da\"\n@@ -12306,6 +12333,11 @@ promzard@0.3.0:\n   dependencies:\n     read \"1\"\n \n+propagate@^2.0.0:\n+  version \"2.0.1\"\n+  resolved \"https://registry.yarnpkg.com/propagate/-/propagate-2.0.1.tgz#40cdedab18085c792334e64f0ac17256d38f9a45\"\n+  integrity sha512-vGrhOavPSTz4QVNuBNdcNXePNdNMaO1xj9yBeH1ScQPjk/rhg9sSlCXPhMkFuaNNW/syTvYqsnbIJxMBfRbbag==\n+\n protobufjs@6.8.8:\n   version \"6.8.8\"\n   resolved \"https://registry.yarnpkg.com/protobufjs/-/protobufjs-6.8.8.tgz#c8b4f1282fd7a90e6f5b109ed11c84af82908e7c\""
        }
    ],
    "stats": {
        "total": 1027,
        "additions": 955,
        "deletions": 72
    }
}