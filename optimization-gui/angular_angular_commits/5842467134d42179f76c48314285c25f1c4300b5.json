{
    "author": "atscott",
    "message": "refactor(router): Extract common functions for config matching (#40029)\n\nThe `applyRedirects` and `recognize` algorithms have the same overall goal:\nmatch a `UrlTree` with the application's `Routes` config. There are a\nfew key functions in these algorithms which can be shared rather than\nduplicated between the two. This also makes it easier to see how the two\nare similar and where they diverge.\n\nPR Close #40029",
    "sha": "5842467134d42179f76c48314285c25f1c4300b5",
    "files": [
        {
            "sha": "a6b76085b21aa5ddf9da0cf3b26cb6d6d10f935f",
            "filename": "packages/router/src/apply_redirects.ts",
            "status": "modified",
            "additions": 43,
            "deletions": 112,
            "changes": 155,
            "blob_url": "https://github.com/angular/angular/blob/5842467134d42179f76c48314285c25f1c4300b5/packages%2Frouter%2Fsrc%2Fapply_redirects.ts",
            "raw_url": "https://github.com/angular/angular/raw/5842467134d42179f76c48314285c25f1c4300b5/packages%2Frouter%2Fsrc%2Fapply_redirects.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Fapply_redirects.ts?ref=5842467134d42179f76c48314285c25f1c4300b5",
            "patch": "@@ -14,10 +14,11 @@ import {LoadedRouterConfig, Route, Routes} from './config';\n import {CanLoadFn} from './interfaces';\n import {prioritizedGuardValue} from './operators/prioritized_guard_value';\n import {RouterConfigLoader} from './router_config_loader';\n-import {defaultUrlMatcher, navigationCancelingError, Params, PRIMARY_OUTLET} from './shared';\n+import {navigationCancelingError, Params, PRIMARY_OUTLET} from './shared';\n import {UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\n import {forEach, waitForMap, wrapIntoObservable} from './utils/collection';\n import {getOutlet, groupRoutesByOutlet} from './utils/config';\n+import {match, noLeftoversInUrl, split} from './utils/config_matching';\n import {isCanLoad, isFunction, isUrlTree} from './utils/type_guards';\n \n class NoMatch {\n@@ -79,9 +80,10 @@ class ApplyRedirects {\n   apply(): Observable<UrlTree> {\n     const expanded$ =\n         this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, PRIMARY_OUTLET);\n-    const urlTrees$ = expanded$.pipe(\n-        map((rootSegmentGroup: UrlSegmentGroup) => this.createUrlTree(\n-                rootSegmentGroup, this.urlTree.queryParams, this.urlTree.fragment!)));\n+    const urlTrees$ = expanded$.pipe(map((rootSegmentGroup: UrlSegmentGroup) => {\n+      return this.createUrlTree(\n+          squashSegmentGroup(rootSegmentGroup), this.urlTree.queryParams, this.urlTree.fragment!);\n+    }));\n     return urlTrees$.pipe(catchError((e: any) => {\n       if (e instanceof AbsoluteRedirect) {\n         // after an absolute redirect we do not apply any more redirects!\n@@ -101,9 +103,10 @@ class ApplyRedirects {\n   private match(tree: UrlTree): Observable<UrlTree> {\n     const expanded$ =\n         this.expandSegmentGroup(this.ngModule, this.config, tree.root, PRIMARY_OUTLET);\n-    const mapped$ = expanded$.pipe(\n-        map((rootSegmentGroup: UrlSegmentGroup) =>\n-                this.createUrlTree(rootSegmentGroup, tree.queryParams, tree.fragment!)));\n+    const mapped$ = expanded$.pipe(map((rootSegmentGroup: UrlSegmentGroup) => {\n+      return this.createUrlTree(\n+          squashSegmentGroup(rootSegmentGroup), tree.queryParams, tree.fragment!);\n+    }));\n     return mapped$.pipe(catchError((e: any): Observable<UrlTree> => {\n       if (e instanceof NoMatch) {\n         throw this.noMatchError(e);\n@@ -172,7 +175,7 @@ class ApplyRedirects {\n           first((s: UrlSegmentGroup|null): s is UrlSegmentGroup => s !== null),\n           catchError(e => {\n             if (e instanceof EmptyError || e.name === 'EmptyError') {\n-              if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n+              if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n                 return of(new UrlSegmentGroup([], {}));\n               }\n               throw new NoMatch(segmentGroup);\n@@ -197,11 +200,6 @@ class ApplyRedirects {\n         );\n   }\n \n-  private noLeftoversInUrl(segmentGroup: UrlSegmentGroup, segments: UrlSegment[], outlet: string):\n-      boolean {\n-    return segments.length === 0 && !segmentGroup.children[outlet];\n-  }\n-\n   private expandSegmentAgainstRoute(\n       ngModule: NgModuleRef<any>, segmentGroup: UrlSegmentGroup, routes: Route[], route: Route,\n       paths: UrlSegment[], outlet: string, allowRedirects: boolean): Observable<UrlSegmentGroup> {\n@@ -256,8 +254,8 @@ class ApplyRedirects {\n         match(segmentGroup, route, segments);\n     if (!matched) return noMatch(segmentGroup);\n \n-    const newTree = this.applyRedirectCommands(\n-        consumedSegments, route.redirectTo!, <any>positionalParamSegments);\n+    const newTree =\n+        this.applyRedirectCommands(consumedSegments, route.redirectTo!, positionalParamSegments);\n     if (route.redirectTo!.startsWith('/')) {\n       return absoluteRedirect(newTree);\n     }\n@@ -296,6 +294,14 @@ class ApplyRedirects {\n \n       const {segmentGroup, slicedSegments} =\n           split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig);\n+      // TODO(atscott): clearing the source segment and segment index shift is only necessary to\n+      // prevent failures in tests which assert exact object matches. The `split` is now shared\n+      // between applyRedirects and recognize and only the `recognize` step needs these properties.\n+      // Before the implementations were merged, the applyRedirects would not assign them.\n+      // We should be able to remove this logic as a \"breaking change\" but should do some more\n+      // investigation into the failures first.\n+      segmentGroup._sourceSegment = undefined;\n+      segmentGroup._segmentIndexShift = undefined;\n \n       if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n         const expanded$ = this.expandChildren(childModule, childConfig, segmentGroup);\n@@ -467,64 +473,15 @@ class ApplyRedirects {\n   }\n }\n \n-function match(segmentGroup: UrlSegmentGroup, route: Route, segments: UrlSegment[]): {\n-  matched: boolean,\n-  consumedSegments: UrlSegment[],\n-  lastChild: number,\n-  positionalParamSegments: {[k: string]: UrlSegment}\n-} {\n-  if (route.path === '') {\n-    if ((route.pathMatch === 'full') && (segmentGroup.hasChildren() || segments.length > 0)) {\n-      return {matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {}};\n-    }\n-\n-    return {matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {}};\n-  }\n-\n-  const matcher = route.matcher || defaultUrlMatcher;\n-  const res = matcher(segments, segmentGroup, route);\n-\n-  if (!res) {\n-    return {\n-      matched: false,\n-      consumedSegments: <any[]>[],\n-      lastChild: 0,\n-      positionalParamSegments: {},\n-    };\n-  }\n-\n-  return {\n-    matched: true,\n-    consumedSegments: res.consumed!,\n-    lastChild: res.consumed.length!,\n-    positionalParamSegments: res.posParams!,\n-  };\n-}\n-\n-function split(\n-    segmentGroup: UrlSegmentGroup, consumedSegments: UrlSegment[], slicedSegments: UrlSegment[],\n-    config: Route[]) {\n-  if (slicedSegments.length > 0 &&\n-      containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n-    const s = new UrlSegmentGroup(\n-        consumedSegments,\n-        createChildrenForEmptySegments(\n-            config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n-    return {segmentGroup: mergeTrivialChildren(s), slicedSegments: []};\n-  }\n-\n-  if (slicedSegments.length === 0 &&\n-      containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {\n-    const s = new UrlSegmentGroup(\n-        segmentGroup.segments,\n-        addEmptySegmentsToChildrenIfNeeded(\n-            segmentGroup, slicedSegments, config, segmentGroup.children));\n-    return {segmentGroup: mergeTrivialChildren(s), slicedSegments};\n-  }\n-\n-  return {segmentGroup, slicedSegments};\n-}\n \n+/**\n+ * When possible, merges the primary outlet child into the parent `UrlSegmentGroup`.\n+ *\n+ * When a segment group has only one child which is a primary outlet, merges that child into the\n+ * parent. That is, the child segment group's segments are merged into the `s` and the child's\n+ * children become the children of `s`. Think of this like a 'squash', merging the child segment\n+ * group into the parent.\n+ */\n function mergeTrivialChildren(s: UrlSegmentGroup): UrlSegmentGroup {\n   if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n     const c = s.children[PRIMARY_OUTLET];\n@@ -534,46 +491,20 @@ function mergeTrivialChildren(s: UrlSegmentGroup): UrlSegmentGroup {\n   return s;\n }\n \n-function addEmptySegmentsToChildrenIfNeeded(\n-    segmentGroup: UrlSegmentGroup, slicedSegments: UrlSegment[], routes: Route[],\n-    children: {[name: string]: UrlSegmentGroup}): {[name: string]: UrlSegmentGroup} {\n-  const res: {[name: string]: UrlSegmentGroup} = {};\n-  for (const r of routes) {\n-    if (isEmptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n-      res[getOutlet(r)] = new UrlSegmentGroup([], {});\n-    }\n-  }\n-  return {...children, ...res};\n-}\n-\n-function createChildrenForEmptySegments(\n-    routes: Route[], primarySegmentGroup: UrlSegmentGroup): {[name: string]: UrlSegmentGroup} {\n-  const res: {[name: string]: UrlSegmentGroup} = {};\n-  res[PRIMARY_OUTLET] = primarySegmentGroup;\n-  for (const r of routes) {\n-    if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n-      res[getOutlet(r)] = new UrlSegmentGroup([], {});\n+/**\n+ * Recursively merges primary segment children into their parents and also drops empty children\n+ * (those which have no segments and no children themselves). The latter prevents serializing a\n+ * group into something like `/a(aux:)`, where `aux` is an empty child segment.\n+ */\n+function squashSegmentGroup(segmentGroup: UrlSegmentGroup): UrlSegmentGroup {\n+  const newChildren = {} as any;\n+  for (const [childOutlet, child] of Object.entries(segmentGroup.children)) {\n+    const childCandidate = squashSegmentGroup(child);\n+    // don't add empty children\n+    if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {\n+      newChildren[childOutlet] = childCandidate;\n     }\n   }\n-  return res;\n-}\n-\n-function containsEmptyPathRedirectsWithNamedOutlets(\n-    segmentGroup: UrlSegmentGroup, segments: UrlSegment[], routes: Route[]): boolean {\n-  return routes.some(\n-      r => isEmptyPathRedirect(segmentGroup, segments, r) && getOutlet(r) !== PRIMARY_OUTLET);\n-}\n-\n-function containsEmptyPathRedirects(\n-    segmentGroup: UrlSegmentGroup, segments: UrlSegment[], routes: Route[]): boolean {\n-  return routes.some(r => isEmptyPathRedirect(segmentGroup, segments, r));\n-}\n-\n-function isEmptyPathRedirect(\n-    segmentGroup: UrlSegmentGroup, segments: UrlSegment[], r: Route): boolean {\n-  if ((segmentGroup.hasChildren() || segments.length > 0) && r.pathMatch === 'full') {\n-    return false;\n-  }\n-\n-  return r.path === '' && r.redirectTo !== undefined;\n+  const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);\n+  return mergeTrivialChildren(s);\n }"
        },
        {
            "sha": "d55513beb27bbbbbcd0f7a0ffbf0e3a404941a59",
            "filename": "packages/router/src/recognize.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 168,
            "changes": 181,
            "blob_url": "https://github.com/angular/angular/blob/5842467134d42179f76c48314285c25f1c4300b5/packages%2Frouter%2Fsrc%2Frecognize.ts",
            "raw_url": "https://github.com/angular/angular/raw/5842467134d42179f76c48314285c25f1c4300b5/packages%2Frouter%2Fsrc%2Frecognize.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frecognize.ts?ref=5842467134d42179f76c48314285c25f1c4300b5",
            "patch": "@@ -11,10 +11,11 @@ import {Observable, Observer, of} from 'rxjs';\n \n import {Data, ResolveData, Route, Routes} from './config';\n import {ActivatedRouteSnapshot, inheritedParamsDataResolve, ParamsInheritanceStrategy, RouterStateSnapshot} from './router_state';\n-import {defaultUrlMatcher, PRIMARY_OUTLET} from './shared';\n+import {PRIMARY_OUTLET} from './shared';\n import {UrlSegment, UrlSegmentGroup, UrlTree} from './url_tree';\n-import {forEach, last} from './utils/collection';\n+import {last} from './utils/collection';\n import {getOutlet} from './utils/config';\n+import {isImmediateMatch, match, noLeftoversInUrl, split} from './utils/config_matching';\n import {TreeNode} from './utils/tree';\n \n class NoMatch {}\n@@ -53,7 +54,10 @@ export class Recognizer {\n \n   recognize(): RouterStateSnapshot|null {\n     const rootSegmentGroup =\n-        split(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup;\n+        split(\n+            this.urlTree.root, [], [], this.config.filter(c => c.redirectTo === undefined),\n+            this.relativeLinkResolution)\n+            .segmentGroup;\n \n     const children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);\n     if (children === null) {\n@@ -136,22 +140,17 @@ export class Recognizer {\n         return children;\n       }\n     }\n-    if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n+    if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n       return [];\n     }\n \n     return null;\n   }\n \n-  private noLeftoversInUrl(segmentGroup: UrlSegmentGroup, segments: UrlSegment[], outlet: string):\n-      boolean {\n-    return segments.length === 0 && !segmentGroup.children[outlet];\n-  }\n-\n   processSegmentAgainstRoute(\n       route: Route, rawSegment: UrlSegmentGroup, segments: UrlSegment[],\n       outlet: string): TreeNode<ActivatedRouteSnapshot>[]|null {\n-    if (!isImmediateMatch(route, rawSegment, segments, outlet)) return null;\n+    if (route.redirectTo || !isImmediateMatch(route, rawSegment, segments, outlet)) return null;\n \n     let snapshot: ActivatedRouteSnapshot;\n     let consumedSegments: UrlSegment[] = [];\n@@ -165,8 +164,8 @@ export class Recognizer {\n           getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length,\n           getResolve(route));\n     } else {\n-      const result: MatchResult|null = match(rawSegment, route, segments);\n-      if (result === null) {\n+      const result = match(rawSegment, route, segments);\n+      if (!result.matched) {\n         return null;\n       }\n       consumedSegments = result.consumedSegments;\n@@ -182,7 +181,8 @@ export class Recognizer {\n     const childConfig: Route[] = getChildConfig(route);\n \n     const {segmentGroup, slicedSegments} = split(\n-        rawSegment, consumedSegments, rawSlicedSegments, childConfig, this.relativeLinkResolution);\n+        rawSegment, consumedSegments, rawSlicedSegments,\n+        childConfig.filter(c => c.redirectTo === undefined), this.relativeLinkResolution);\n \n     if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n       const children = this.processChildren(childConfig, segmentGroup);\n@@ -234,37 +234,6 @@ function getChildConfig(route: Route): Route[] {\n   return [];\n }\n \n-interface MatchResult {\n-  consumedSegments: UrlSegment[];\n-  lastChild: number;\n-  parameters: any;\n-}\n-\n-function match(segmentGroup: UrlSegmentGroup, route: Route, segments: UrlSegment[]): MatchResult|\n-    null {\n-  if (route.path === '') {\n-    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n-      return null;\n-    }\n-\n-    return {consumedSegments: [], lastChild: 0, parameters: {}};\n-  }\n-\n-  const matcher = route.matcher || defaultUrlMatcher;\n-  const res = matcher(segments, segmentGroup, route);\n-  if (!res) return null;\n-\n-  const posParams: {[n: string]: string} = {};\n-  forEach(res.posParams!, (v: UrlSegment, k: string) => {\n-    posParams[k] = v.path;\n-  });\n-  const parameters = res.consumed.length > 0 ?\n-      {...posParams, ...res.consumed[res.consumed.length - 1].parameters} :\n-      posParams;\n-\n-  return {consumedSegments: res.consumed, lastChild: res.consumed.length, parameters};\n-}\n-\n /**\n  * Finds `TreeNode`s with matching empty path route configs and merges them into `TreeNode` with the\n  * children from each duplicate. This is necessary because different outlets can match a single\n@@ -327,134 +296,10 @@ function getPathIndexShift(segmentGroup: UrlSegmentGroup): number {\n   return res - 1;\n }\n \n-function split(\n-    segmentGroup: UrlSegmentGroup, consumedSegments: UrlSegment[], slicedSegments: UrlSegment[],\n-    config: Route[], relativeLinkResolution: 'legacy'|'corrected') {\n-  if (slicedSegments.length > 0 &&\n-      containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n-    const s = new UrlSegmentGroup(\n-        consumedSegments,\n-        createChildrenForEmptyPaths(\n-            segmentGroup, consumedSegments, config,\n-            new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n-    s._sourceSegment = segmentGroup;\n-    s._segmentIndexShift = consumedSegments.length;\n-    return {segmentGroup: s, slicedSegments: []};\n-  }\n-\n-  if (slicedSegments.length === 0 &&\n-      containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n-    const s = new UrlSegmentGroup(\n-        segmentGroup.segments,\n-        addEmptyPathsToChildrenIfNeeded(\n-            segmentGroup, consumedSegments, slicedSegments, config, segmentGroup.children,\n-            relativeLinkResolution));\n-    s._sourceSegment = segmentGroup;\n-    s._segmentIndexShift = consumedSegments.length;\n-    return {segmentGroup: s, slicedSegments};\n-  }\n-\n-  const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n-  s._sourceSegment = segmentGroup;\n-  s._segmentIndexShift = consumedSegments.length;\n-  return {segmentGroup: s, slicedSegments};\n-}\n-\n-function addEmptyPathsToChildrenIfNeeded(\n-    segmentGroup: UrlSegmentGroup, consumedSegments: UrlSegment[], slicedSegments: UrlSegment[],\n-    routes: Route[], children: {[name: string]: UrlSegmentGroup},\n-    relativeLinkResolution: 'legacy'|'corrected'): {[name: string]: UrlSegmentGroup} {\n-  const res: {[name: string]: UrlSegmentGroup} = {};\n-  for (const r of routes) {\n-    if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n-      const s = new UrlSegmentGroup([], {});\n-      s._sourceSegment = segmentGroup;\n-      if (relativeLinkResolution === 'legacy') {\n-        s._segmentIndexShift = segmentGroup.segments.length;\n-      } else {\n-        s._segmentIndexShift = consumedSegments.length;\n-      }\n-      res[getOutlet(r)] = s;\n-    }\n-  }\n-  return {...children, ...res};\n-}\n-\n-function createChildrenForEmptyPaths(\n-    segmentGroup: UrlSegmentGroup, consumedSegments: UrlSegment[], routes: Route[],\n-    primarySegment: UrlSegmentGroup): {[name: string]: UrlSegmentGroup} {\n-  const res: {[name: string]: UrlSegmentGroup} = {};\n-  res[PRIMARY_OUTLET] = primarySegment;\n-  primarySegment._sourceSegment = segmentGroup;\n-  primarySegment._segmentIndexShift = consumedSegments.length;\n-\n-  for (const r of routes) {\n-    if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n-      const s = new UrlSegmentGroup([], {});\n-      s._sourceSegment = segmentGroup;\n-      s._segmentIndexShift = consumedSegments.length;\n-      res[getOutlet(r)] = s;\n-    }\n-  }\n-  return res;\n-}\n-\n-function containsEmptyPathMatchesWithNamedOutlets(\n-    segmentGroup: UrlSegmentGroup, slicedSegments: UrlSegment[], routes: Route[]): boolean {\n-  return routes.some(\n-      r => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);\n-}\n-\n-function containsEmptyPathMatches(\n-    segmentGroup: UrlSegmentGroup, slicedSegments: UrlSegment[], routes: Route[]): boolean {\n-  return routes.some(r => emptyPathMatch(segmentGroup, slicedSegments, r));\n-}\n-\n-function emptyPathMatch(\n-    segmentGroup: UrlSegmentGroup, slicedSegments: UrlSegment[], r: Route): boolean {\n-  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n-    return false;\n-  }\n-\n-  return r.path === '' && r.redirectTo === undefined;\n-}\n-\n function getData(route: Route): Data {\n   return route.data || {};\n }\n \n function getResolve(route: Route): ResolveData {\n   return route.resolve || {};\n }\n-\n-/**\n- * Determines if `route` is a path match for the `rawSegment`, `segments`, and `outlet` without\n- * verifying that its children are a full match for the remainder of the `rawSegment` children as\n- * well.\n- */\n-function isImmediateMatch(\n-    route: Route, rawSegment: UrlSegmentGroup, segments: UrlSegment[], outlet: string): boolean {\n-  if (route.redirectTo) {\n-    return false;\n-  }\n-  // We allow matches to empty paths when the outlets differ so we can match a url like `/(b:b)` to\n-  // a config like\n-  // * `{path: '', children: [{path: 'b', outlet: 'b'}]}`\n-  // or even\n-  // * `{path: '', outlet: 'a', children: [{path: 'b', outlet: 'b'}]`\n-  //\n-  // The exception here is when the segment outlet is for the primary outlet. This would\n-  // result in a match inside the named outlet because all children there are written as primary\n-  // outlets. So we need to prevent child named outlet matches in a url like `/b` in a config like\n-  // * `{path: '', outlet: 'x' children: [{path: 'b'}]}`\n-  // This should only match if the url is `/(x:b)`.\n-  if (getOutlet(route) !== outlet &&\n-      (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {\n-    return false;\n-  }\n-  if (route.path === '**') {\n-    return true;\n-  } else {\n-    return match(rawSegment, route, segments) !== null;\n-  }\n-}"
        },
        {
            "sha": "66b90d61baa677a883bbfd40a1809c8e952cef67",
            "filename": "packages/router/src/url_tree.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/5842467134d42179f76c48314285c25f1c4300b5/packages%2Frouter%2Fsrc%2Furl_tree.ts",
            "raw_url": "https://github.com/angular/angular/raw/5842467134d42179f76c48314285c25f1c4300b5/packages%2Frouter%2Fsrc%2Furl_tree.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Furl_tree.ts?ref=5842467134d42179f76c48314285c25f1c4300b5",
            "patch": "@@ -140,11 +140,9 @@ export class UrlTree {\n  */\n export class UrlSegmentGroup {\n   /** @internal */\n-  // TODO(issue/24571): remove '!'.\n-  _sourceSegment!: UrlSegmentGroup;\n+  _sourceSegment?: UrlSegmentGroup;\n   /** @internal */\n-  // TODO(issue/24571): remove '!'.\n-  _segmentIndexShift!: number;\n+  _segmentIndexShift?: number;\n   /** The parent node in the url tree */\n   parent: UrlSegmentGroup|null = null;\n "
        },
        {
            "sha": "b52f2ea344ef7128b2b9fe31904ce87788133dfe",
            "filename": "packages/router/src/utils/config_matching.ts",
            "status": "added",
            "additions": 194,
            "deletions": 0,
            "changes": 194,
            "blob_url": "https://github.com/angular/angular/blob/5842467134d42179f76c48314285c25f1c4300b5/packages%2Frouter%2Fsrc%2Futils%2Fconfig_matching.ts",
            "raw_url": "https://github.com/angular/angular/raw/5842467134d42179f76c48314285c25f1c4300b5/packages%2Frouter%2Fsrc%2Futils%2Fconfig_matching.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Futils%2Fconfig_matching.ts?ref=5842467134d42179f76c48314285c25f1c4300b5",
            "patch": "@@ -0,0 +1,194 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {Route} from '../config';\n+import {defaultUrlMatcher, PRIMARY_OUTLET} from '../shared';\n+import {UrlSegment, UrlSegmentGroup} from '../url_tree';\n+\n+import {forEach} from './collection';\n+import {getOutlet} from './config';\n+\n+export interface MatchResult {\n+  matched: boolean;\n+  consumedSegments: UrlSegment[];\n+  lastChild: number;\n+  parameters: {[k: string]: string};\n+  positionalParamSegments: {[k: string]: UrlSegment};\n+}\n+\n+const noMatch = {\n+  matched: false,\n+  consumedSegments: [],\n+  lastChild: 0,\n+  parameters: {},\n+  positionalParamSegments: {}\n+};\n+\n+export function match(\n+    segmentGroup: UrlSegmentGroup, route: Route, segments: UrlSegment[]): MatchResult {\n+  if (route.path === '') {\n+    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n+      return {...noMatch};\n+    }\n+\n+    return {\n+      matched: true,\n+      consumedSegments: [],\n+      lastChild: 0,\n+      parameters: {},\n+      positionalParamSegments: {}\n+    };\n+  }\n+\n+  const matcher = route.matcher || defaultUrlMatcher;\n+  const res = matcher(segments, segmentGroup, route);\n+  if (!res) return {...noMatch};\n+\n+  const posParams: {[n: string]: string} = {};\n+  forEach(res.posParams!, (v: UrlSegment, k: string) => {\n+    posParams[k] = v.path;\n+  });\n+  const parameters = res.consumed.length > 0 ?\n+      {...posParams, ...res.consumed[res.consumed.length - 1].parameters} :\n+      posParams;\n+\n+  return {\n+    matched: true,\n+    consumedSegments: res.consumed,\n+    lastChild: res.consumed.length,\n+    // TODO(atscott): investigate combining parameters and positionalParamSegments\n+    parameters,\n+    positionalParamSegments: res.posParams ?? {}\n+  };\n+}\n+\n+export function split(\n+    segmentGroup: UrlSegmentGroup, consumedSegments: UrlSegment[], slicedSegments: UrlSegment[],\n+    config: Route[], relativeLinkResolution: 'legacy'|'corrected' = 'corrected') {\n+  if (slicedSegments.length > 0 &&\n+      containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n+    const s = new UrlSegmentGroup(\n+        consumedSegments,\n+        createChildrenForEmptyPaths(\n+            segmentGroup, consumedSegments, config,\n+            new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n+    s._sourceSegment = segmentGroup;\n+    s._segmentIndexShift = consumedSegments.length;\n+    return {segmentGroup: s, slicedSegments: []};\n+  }\n+\n+  if (slicedSegments.length === 0 &&\n+      containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n+    const s = new UrlSegmentGroup(\n+        segmentGroup.segments,\n+        addEmptyPathsToChildrenIfNeeded(\n+            segmentGroup, consumedSegments, slicedSegments, config, segmentGroup.children,\n+            relativeLinkResolution));\n+    s._sourceSegment = segmentGroup;\n+    s._segmentIndexShift = consumedSegments.length;\n+    return {segmentGroup: s, slicedSegments};\n+  }\n+\n+  const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n+  s._sourceSegment = segmentGroup;\n+  s._segmentIndexShift = consumedSegments.length;\n+  return {segmentGroup: s, slicedSegments};\n+}\n+\n+function addEmptyPathsToChildrenIfNeeded(\n+    segmentGroup: UrlSegmentGroup, consumedSegments: UrlSegment[], slicedSegments: UrlSegment[],\n+    routes: Route[], children: {[name: string]: UrlSegmentGroup},\n+    relativeLinkResolution: 'legacy'|'corrected'): {[name: string]: UrlSegmentGroup} {\n+  const res: {[name: string]: UrlSegmentGroup} = {};\n+  for (const r of routes) {\n+    if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n+      const s = new UrlSegmentGroup([], {});\n+      s._sourceSegment = segmentGroup;\n+      if (relativeLinkResolution === 'legacy') {\n+        s._segmentIndexShift = segmentGroup.segments.length;\n+      } else {\n+        s._segmentIndexShift = consumedSegments.length;\n+      }\n+      res[getOutlet(r)] = s;\n+    }\n+  }\n+  return {...children, ...res};\n+}\n+\n+function createChildrenForEmptyPaths(\n+    segmentGroup: UrlSegmentGroup, consumedSegments: UrlSegment[], routes: Route[],\n+    primarySegment: UrlSegmentGroup): {[name: string]: UrlSegmentGroup} {\n+  const res: {[name: string]: UrlSegmentGroup} = {};\n+  res[PRIMARY_OUTLET] = primarySegment;\n+  primarySegment._sourceSegment = segmentGroup;\n+  primarySegment._segmentIndexShift = consumedSegments.length;\n+\n+  for (const r of routes) {\n+    if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n+      const s = new UrlSegmentGroup([], {});\n+      s._sourceSegment = segmentGroup;\n+      s._segmentIndexShift = consumedSegments.length;\n+      res[getOutlet(r)] = s;\n+    }\n+  }\n+  return res;\n+}\n+\n+function containsEmptyPathMatchesWithNamedOutlets(\n+    segmentGroup: UrlSegmentGroup, slicedSegments: UrlSegment[], routes: Route[]): boolean {\n+  return routes.some(\n+      r => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);\n+}\n+\n+function containsEmptyPathMatches(\n+    segmentGroup: UrlSegmentGroup, slicedSegments: UrlSegment[], routes: Route[]): boolean {\n+  return routes.some(r => emptyPathMatch(segmentGroup, slicedSegments, r));\n+}\n+\n+function emptyPathMatch(\n+    segmentGroup: UrlSegmentGroup, slicedSegments: UrlSegment[], r: Route): boolean {\n+  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n+    return false;\n+  }\n+\n+  return r.path === '';\n+}\n+\n+/**\n+ * Determines if `route` is a path match for the `rawSegment`, `segments`, and `outlet` without\n+ * verifying that its children are a full match for the remainder of the `rawSegment` children as\n+ * well.\n+ */\n+export function isImmediateMatch(\n+    route: Route, rawSegment: UrlSegmentGroup, segments: UrlSegment[], outlet: string): boolean {\n+  // We allow matches to empty paths when the outlets differ so we can match a url like `/(b:b)` to\n+  // a config like\n+  // * `{path: '', children: [{path: 'b', outlet: 'b'}]}`\n+  // or even\n+  // * `{path: '', outlet: 'a', children: [{path: 'b', outlet: 'b'}]`\n+  //\n+  // The exception here is when the segment outlet is for the primary outlet. This would\n+  // result in a match inside the named outlet because all children there are written as primary\n+  // outlets. So we need to prevent child named outlet matches in a url like `/b` in a config like\n+  // * `{path: '', outlet: 'x' children: [{path: 'b'}]}`\n+  // This should only match if the url is `/(x:b)`.\n+  if (getOutlet(route) !== outlet &&\n+      (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {\n+    return false;\n+  }\n+  if (route.path === '**') {\n+    return true;\n+  } else {\n+    return match(rawSegment, route, segments).matched;\n+  }\n+}\n+\n+export function noLeftoversInUrl(\n+    segmentGroup: UrlSegmentGroup, segments: UrlSegment[], outlet: string): boolean {\n+  return segments.length === 0 && !segmentGroup.children[outlet];\n+}"
        }
    ],
    "stats": {
        "total": 536,
        "additions": 252,
        "deletions": 284
    }
}