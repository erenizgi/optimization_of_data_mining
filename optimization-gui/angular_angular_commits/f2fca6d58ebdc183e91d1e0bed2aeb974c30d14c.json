{
    "author": "alxhub",
    "message": "refactor(compiler-cli): add a global autocompletion API (#39048)\n\nThis commit introduces a new API for the `TemplateTypeChecker` which allows\nfor autocompletion in a global expression context (for example, in a new\ninterpolation expression such as `{{|}}`). This API returns instances of the\ntype `GlobalCompletion`, which can represent either a completion result from\nthe template's component context or a declaration such as a local reference\nor template variable. The Language Service will use this API to implement\nautocompletion within templates.\n\nPR Close #39048",
    "sha": "f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c",
    "files": [
        {
            "sha": "97f36e6b63b153e6e46d9309260a8bddb25736f0",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/checker.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 1,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts?ref=f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c",
            "patch": "@@ -6,9 +6,10 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, ParseError, TmplAstNode,} from '@angular/compiler';\n+import {AST, ParseError, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n import * as ts from 'typescript';\n \n+import {GlobalCompletion} from './completion';\n import {Symbol} from './symbols';\n \n /**\n@@ -88,6 +89,18 @@ export interface TemplateTypeChecker {\n    * @see Symbol\n    */\n   getSymbolOfNode(node: AST|TmplAstNode, component: ts.ClassDeclaration): Symbol|null;\n+\n+  /**\n+   * Get \"global\" `Completion`s in the given context.\n+   *\n+   * Global completions are completions in the global context, as opposed to completions within an\n+   * existing expression. For example, completing inside a new interpolation expression (`{{|}}`) or\n+   * inside a new property binding `[input]=\"|\" should retrieve global completions, which will\n+   * include completions from the template's context component, as well as any local references or\n+   * template variables which are in scope for that expression.\n+   */\n+  getGlobalCompletions(context: TmplAstTemplate|null, component: ts.ClassDeclaration):\n+      GlobalCompletion[];\n }\n \n /**"
        },
        {
            "sha": "9d5c5e16cac78d994d084b15c7d076f9379929fb",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/completion.ts",
            "status": "added",
            "additions": 62,
            "deletions": 0,
            "changes": 62,
            "blob_url": "https://github.com/angular/angular/blob/f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fcompletion.ts",
            "raw_url": "https://github.com/angular/angular/raw/f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fcompletion.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fcompletion.ts?ref=f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c",
            "patch": "@@ -0,0 +1,62 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {TmplAstReference, TmplAstVariable} from '@angular/compiler';\n+\n+import {ShimLocation} from './symbols';\n+\n+/**\n+ * An autocompletion source of any kind.\n+ */\n+export type Completion = CompletionContextComponent|CompletionReference|CompletionVariable;\n+\n+/**\n+ * An autocompletion source that drives completion in a global context.\n+ */\n+export type GlobalCompletion = CompletionContextComponent|CompletionReference|CompletionVariable;\n+\n+/**\n+ * Discriminant of an autocompletion source (a `Completion`).\n+ */\n+export enum CompletionKind {\n+  ContextComponent,\n+  Reference,\n+  Variable,\n+}\n+\n+/**\n+ * An autocompletion source backed by a shim file position where TS APIs can be used to retrieve\n+ * completions for the context component of a template.\n+ */\n+export interface CompletionContextComponent extends ShimLocation {\n+  kind: CompletionKind.ContextComponent;\n+}\n+\n+/**\n+ * An autocompletion result representing a local reference declared in the template.\n+ */\n+export interface CompletionReference {\n+  kind: CompletionKind.Reference;\n+\n+  /**\n+   * The `TmplAstReference` from the template which should be available as a completion.\n+   */\n+  node: TmplAstReference;\n+}\n+\n+/**\n+ * An autocompletion result representing a variable declared in the template.\n+ */\n+export interface CompletionVariable {\n+  kind: CompletionKind.Variable;\n+\n+  /**\n+   * The `TmplAstVariable` from the template which should be available as a completion.\n+   */\n+  node: TmplAstVariable;\n+}"
        },
        {
            "sha": "675f02d4f042cc4a9ded98b03fa8a0e0d514c91c",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Findex.ts?ref=f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c",
            "patch": "@@ -8,5 +8,6 @@\n \n export * from './api';\n export * from './checker';\n+export * from './completion';\n export * from './context';\n export * from './symbols';"
        },
        {
            "sha": "ceab60d4c92ead475dea40393dbf12bfebadf915",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts",
            "status": "modified",
            "additions": 73,
            "deletions": 35,
            "changes": 108,
            "blob_url": "https://github.com/angular/angular/blob/f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts?ref=f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, ParseError, parseTemplate, TmplAstNode} from '@angular/compiler';\n+import {AST, ParseError, parseTemplate, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {absoluteFromSourceFile, AbsoluteFsPath, getSourceFileOrError} from '../../file_system';\n@@ -16,9 +16,10 @@ import {ReflectionHost} from '../../reflection';\n import {ComponentScopeReader} from '../../scope';\n import {isShim} from '../../shims';\n import {getSourceFileOrNull} from '../../util/src/typescript';\n-import {OptimizeFor, ProgramTypeCheckAdapter, Symbol, TemplateId, TemplateTypeChecker, TypeCheckingConfig, TypeCheckingProgramStrategy, UpdateMode} from '../api';\n+import {CompletionKind, GlobalCompletion, OptimizeFor, ProgramTypeCheckAdapter, Symbol, TemplateId, TemplateTypeChecker, TypeCheckingConfig, TypeCheckingProgramStrategy, UpdateMode} from '../api';\n import {TemplateDiagnostic} from '../diagnostics';\n \n+import {ExpressionIdentifier, findFirstMatchingNode} from './comments';\n import {InliningMode, ShimTypeCheckingData, TemplateData, TypeCheckContextImpl, TypeCheckingHost} from './context';\n import {findTypeCheckBlock, shouldReportDiagnostic, TemplateSourceResolver, translateDiagnostic} from './diagnostics';\n import {TemplateSourceManager} from './source';\n@@ -53,14 +54,15 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n   }\n \n   getTemplate(component: ts.ClassDeclaration): TmplAstNode[]|null {\n-    const templateData = this.getTemplateData(component);\n-    if (templateData === null) {\n+    const {data} = this.getLatestComponentState(component);\n+    if (data === null) {\n       return null;\n     }\n-    return templateData.template;\n+    return data.template;\n   }\n \n-  private getTemplateData(component: ts.ClassDeclaration): TemplateData|null {\n+  private getLatestComponentState(component: ts.ClassDeclaration):\n+      {data: TemplateData|null, tcb: ts.Node|null, shimPath: AbsoluteFsPath} {\n     this.ensureShimForComponent(component);\n \n     const sf = component.getSourceFile();\n@@ -70,17 +72,34 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     const fileRecord = this.getFileData(sfPath);\n \n     if (!fileRecord.shimData.has(shimPath)) {\n-      return null;\n+      return {data: null, tcb: null, shimPath};\n     }\n \n     const templateId = fileRecord.sourceManager.getTemplateId(component);\n     const shimRecord = fileRecord.shimData.get(shimPath)!;\n+    const id = fileRecord.sourceManager.getTemplateId(component);\n \n-    if (!shimRecord.templates.has(templateId)) {\n-      return null;\n+    const program = this.typeCheckingStrategy.getProgram();\n+    const shimSf = getSourceFileOrNull(program, shimPath);\n+\n+    if (shimSf === null || !fileRecord.shimData.has(shimPath)) {\n+      throw new Error(`Error: no shim file in program: ${shimPath}`);\n+    }\n+\n+    let tcb: ts.Node|null = findTypeCheckBlock(shimSf, id);\n+\n+    if (tcb === null) {\n+      // Try for an inline block.\n+      const inlineSf = getSourceFileOrError(program, sfPath);\n+      tcb = findTypeCheckBlock(inlineSf, id);\n+    }\n+\n+    let data: TemplateData|null = null;\n+    if (shimRecord.templates.has(templateId)) {\n+      data = shimRecord.templates.get(templateId)!;\n     }\n \n-    return shimRecord.templates.get(templateId)!;\n+    return {data, tcb, shimPath};\n   }\n \n   overrideComponentTemplate(component: ts.ClassDeclaration, template: string):\n@@ -186,31 +205,55 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n   }\n \n   getTypeCheckBlock(component: ts.ClassDeclaration): ts.Node|null {\n-    this.ensureAllShimsForOneFile(component.getSourceFile());\n-\n-    const program = this.typeCheckingStrategy.getProgram();\n-    const filePath = absoluteFromSourceFile(component.getSourceFile());\n-    const shimPath = this.typeCheckingStrategy.shimPathForComponent(component);\n+    return this.getLatestComponentState(component).tcb;\n+  }\n \n-    if (!this.state.has(filePath)) {\n-      throw new Error(`Error: no data for source file: ${filePath}`);\n+  getGlobalCompletions(context: TmplAstTemplate|null, component: ts.ClassDeclaration):\n+      GlobalCompletion[] {\n+    const {tcb, data, shimPath} = this.getLatestComponentState(component);\n+    if (tcb === null || data === null) {\n+      return [];\n     }\n-    const fileRecord = this.state.get(filePath)!;\n-    const id = fileRecord.sourceManager.getTemplateId(component);\n \n-    const shimSf = getSourceFileOrNull(program, shimPath);\n-    if (shimSf === null || !fileRecord.shimData.has(shimPath)) {\n-      throw new Error(`Error: no shim file in program: ${shimPath}`);\n+    const {boundTarget} = data;\n+\n+    // Global completions are the union of two separate pieces: a `ContextComponentCompletion` which\n+    // is created from an expression within the TCB, and a list of named entities (variables and\n+    // references) which are visible within the given `context` template.\n+    const completions: GlobalCompletion[] = [];\n+\n+    const globalRead = findFirstMatchingNode(tcb, {\n+      filter: ts.isPropertyAccessExpression,\n+      withExpressionIdentifier: ExpressionIdentifier.COMPONENT_COMPLETION\n+    });\n+\n+    if (globalRead === null) {\n+      return [];\n     }\n \n-    let node: ts.Node|null = findTypeCheckBlock(shimSf, id);\n-    if (node === null) {\n-      // Try for an inline block.\n-      const inlineSf = getSourceFileOrError(program, filePath);\n-      node = findTypeCheckBlock(inlineSf, id);\n+    completions.push({\n+      kind: CompletionKind.ContextComponent,\n+      shimPath,\n+      positionInShimFile: globalRead.name.getStart(),\n+    });\n+\n+    // Add completions for each entity in the template scope. Since each entity is uniquely named,\n+    // there is no special ordering applied here.\n+    for (const node of boundTarget.getEntitiesInTemplateScope(context)) {\n+      if (node instanceof TmplAstReference) {\n+        completions.push({\n+          kind: CompletionKind.Reference,\n+          node: node,\n+        });\n+      } else {\n+        completions.push({\n+          kind: CompletionKind.Variable,\n+          node: node,\n+        });\n+      }\n     }\n \n-    return node;\n+    return completions;\n   }\n \n   private maybeAdoptPriorResultsForFile(sf: ts.SourceFile): void {\n@@ -362,17 +405,12 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n   }\n \n   getSymbolOfNode(node: AST|TmplAstNode, component: ts.ClassDeclaration): Symbol|null {\n-    const tcb = this.getTypeCheckBlock(component);\n-    if (tcb === null) {\n+    const {tcb, data, shimPath} = this.getLatestComponentState(component);\n+    if (tcb === null || data === null) {\n       return null;\n     }\n \n     const typeChecker = this.typeCheckingStrategy.getProgram().getTypeChecker();\n-    const shimPath = this.typeCheckingStrategy.shimPathForComponent(component);\n-    const data = this.getTemplateData(component);\n-    if (data === null) {\n-      return null;\n-    }\n \n     return new SymbolBuilder(typeChecker, shimPath, tcb, data, this.componentScopeReader)\n         .getSymbol(node);"
        },
        {
            "sha": "10b6c59dda828dd219f44870ba4bafed082c013e",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/comments.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcomments.ts",
            "raw_url": "https://github.com/angular/angular/raw/f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcomments.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcomments.ts?ref=f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c",
            "patch": "@@ -42,6 +42,7 @@ export enum CommentTriviaType {\n /** Identifies what the TCB expression is for (for example, a directive declaration). */\n export enum ExpressionIdentifier {\n   DIRECTIVE = 'DIR',\n+  COMPONENT_COMPLETION = 'COMPCOMP',\n }\n \n /** Tags the node with the given expression identifier. */\n@@ -85,6 +86,7 @@ function makeRecursiveVisitor<T extends ts.Node>(visitor: (node: ts.Node) => T |\n \n export interface FindOptions<T extends ts.Node> {\n   filter: (node: ts.Node) => node is T;\n+  withExpressionIdentifier?: ExpressionIdentifier;\n   withSpan?: AbsoluteSourceSpan|ParseSourceSpan;\n }\n \n@@ -109,6 +111,7 @@ function getSpanFromOptions(opts: FindOptions<ts.Node>) {\n export function findFirstMatchingNode<T extends ts.Node>(tcb: ts.Node, opts: FindOptions<T>): T|\n     null {\n   const withSpan = getSpanFromOptions(opts);\n+  const withExpressionIdentifier = opts.withExpressionIdentifier;\n   const sf = tcb.getSourceFile();\n   const visitor = makeRecursiveVisitor<T>(node => {\n     if (!opts.filter(node)) {\n@@ -120,6 +123,10 @@ export function findFirstMatchingNode<T extends ts.Node>(tcb: ts.Node, opts: Fin\n         return null;\n       }\n     }\n+    if (withExpressionIdentifier !== undefined &&\n+        !hasExpressionIdentifier(sf, node, withExpressionIdentifier)) {\n+      return null;\n+    }\n     return node;\n   });\n   return tcb.forEachChild(visitor) ?? null;\n@@ -135,6 +142,7 @@ export function findFirstMatchingNode<T extends ts.Node>(tcb: ts.Node, opts: Fin\n  */\n export function findAllMatchingNodes<T extends ts.Node>(tcb: ts.Node, opts: FindOptions<T>): T[] {\n   const withSpan = getSpanFromOptions(opts);\n+  const withExpressionIdentifier = opts.withExpressionIdentifier;\n   const results: T[] = [];\n   const stack: ts.Node[] = [tcb];\n   const sf = tcb.getSourceFile();\n@@ -153,6 +161,10 @@ export function findAllMatchingNodes<T extends ts.Node>(tcb: ts.Node, opts: Find\n         continue;\n       }\n     }\n+    if (withExpressionIdentifier !== undefined &&\n+        !hasExpressionIdentifier(sf, node, withExpressionIdentifier)) {\n+      continue;\n+    }\n \n     results.push(node);\n   }"
        },
        {
            "sha": "a5971b595b8fff8ca7138ef3b435f8913daa1437",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/angular/angular/blob/f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "raw_url": "https://github.com/angular/angular/raw/f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts?ref=f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c",
            "patch": "@@ -962,6 +962,30 @@ class TcbUnclaimedOutputsOp extends TcbOp {\n   }\n }\n \n+/**\n+ * A `TcbOp` which generates a completion point for the component context.\n+ *\n+ * This completion point looks like `ctx. ;` in the TCB output, and does not produce diagnostics.\n+ * TypeScript autocompletion APIs can be used at this completion point (after the '.') to produce\n+ * autocompletion results of properties and methods from the template's component context.\n+ */\n+class TcbComponentContextCompletionOp extends TcbOp {\n+  constructor(private scope: Scope) {\n+    super();\n+  }\n+\n+  readonly optional = false;\n+\n+  execute(): null {\n+    const ctx = ts.createIdentifier('ctx');\n+    const ctxDot = ts.createPropertyAccess(ctx, '');\n+    markIgnoreDiagnostics(ctxDot);\n+    addExpressionIdentifier(ctxDot, ExpressionIdentifier.COMPONENT_COMPLETION);\n+    this.scope.addStatement(ts.createExpressionStatement(ctxDot));\n+    return null;\n+  }\n+}\n+\n /**\n  * Value used to break a circular reference between `TcbOp`s.\n  *\n@@ -1089,6 +1113,11 @@ class Scope {\n       guard: ts.Expression|null): Scope {\n     const scope = new Scope(tcb, parent, guard);\n \n+    if (parent === null && tcb.env.config.enableTemplateTypeChecker) {\n+      // Add an autocompletion point for the component context.\n+      scope.opQueue.push(new TcbComponentContextCompletionOp(scope));\n+    }\n+\n     let children: TmplAstNode[];\n \n     // If given an actual `TmplAstTemplate` instance, then process any additional information it"
        },
        {
            "sha": "f9364d787b994d3f69b68f1d0a73bbd86e1a5023",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker__completion_spec.ts",
            "status": "added",
            "additions": 138,
            "deletions": 0,
            "changes": 138,
            "blob_url": "https://github.com/angular/angular/blob/f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__completion_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__completion_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__completion_spec.ts?ref=f2fca6d58ebdc183e91d1e0bed2aeb974c30d14c",
            "patch": "@@ -0,0 +1,138 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {TmplAstTemplate} from '@angular/compiler';\n+import * as ts from 'typescript';\n+\n+import {absoluteFrom, getSourceFileOrError} from '../../file_system';\n+import {runInEachFileSystem} from '../../file_system/testing';\n+import {getTokenAtPosition} from '../../util/src/typescript';\n+import {CompletionKind, TypeCheckingConfig} from '../api';\n+\n+import {getClass, setup as baseTestSetup, TypeCheckingTarget} from './test_utils';\n+\n+runInEachFileSystem(() => {\n+  describe('TemplateTypeChecker.getGlobalCompletions()', () => {\n+    it('should return a completion point in the TCB for the component context', () => {\n+      const MAIN_TS = absoluteFrom('/main.ts');\n+      const {templateTypeChecker, programStrategy} = setup([\n+        {\n+          fileName: MAIN_TS,\n+          templates: {'SomeCmp': `No special template needed`},\n+          source: `\n+            export class SomeCmp {}\n+          `,\n+        },\n+      ]);\n+      const sf = getSourceFileOrError(programStrategy.getProgram(), MAIN_TS);\n+      const SomeCmp = getClass(sf, 'SomeCmp');\n+\n+      const [global, ...rest] =\n+          templateTypeChecker.getGlobalCompletions(/* root template */ null, SomeCmp);\n+      expect(rest.length).toBe(0);\n+      if (global.kind !== CompletionKind.ContextComponent) {\n+        return fail(`Expected a ContextComponent completion`);\n+      }\n+      const tcbSf =\n+          getSourceFileOrError(programStrategy.getProgram(), absoluteFrom(global.shimPath));\n+      const node = getTokenAtPosition(tcbSf, global.positionInShimFile).parent;\n+      if (!ts.isExpressionStatement(node)) {\n+        return fail(`Expected a ts.ExpressionStatement`);\n+      }\n+      expect(node.expression.getText()).toEqual('ctx.');\n+      // The position should be between the '.' and a following space.\n+      expect(tcbSf.text.substr(global.positionInShimFile - 1, 2)).toEqual('. ');\n+    });\n+\n+    it('should return additional completions for references and variables when available', () => {\n+      const MAIN_TS = absoluteFrom('/main.ts');\n+      const {templateTypeChecker, programStrategy} = setup([\n+        {\n+          fileName: MAIN_TS,\n+          templates: {\n+            'SomeCmp': `\n+              <div *ngFor=\"let user of users\">\n+                <div #innerRef></div>\n+                <div *ngIf=\"user\">\n+                  <div #notInScope></div>\n+                </div>\n+              </div>\n+              <div #topLevelRef></div>\n+          `\n+          },\n+          source: `\n+            export class SomeCmp {\n+              users: string[];\n+            }\n+          `,\n+        },\n+      ]);\n+      const sf = getSourceFileOrError(programStrategy.getProgram(), MAIN_TS);\n+      const SomeCmp = getClass(sf, 'SomeCmp');\n+\n+      const tmpl = templateTypeChecker.getTemplate(SomeCmp)!;\n+      const ngForTemplate = tmpl[0] as TmplAstTemplate;\n+\n+      const [contextCmp, ...rest] =\n+          templateTypeChecker.getGlobalCompletions(ngForTemplate, SomeCmp);\n+      if (contextCmp.kind !== CompletionKind.ContextComponent) {\n+        return fail(`Expected first completion to be a ContextComponent`);\n+      }\n+\n+      const completionKeys: string[] = [];\n+      for (const completion of rest) {\n+        if (completion.kind !== CompletionKind.Reference &&\n+            completion.kind !== CompletionKind.Variable) {\n+          return fail(`Unexpected CompletionKind, expected a Reference or Variable`);\n+        }\n+        completionKeys.push(completion.node.name);\n+      }\n+\n+      expect(new Set(completionKeys)).toEqual(new Set(['innerRef', 'user', 'topLevelRef']));\n+    });\n+\n+    it('should support shadowing between outer and inner templates  ', () => {\n+      const MAIN_TS = absoluteFrom('/main.ts');\n+      const {templateTypeChecker, programStrategy} = setup([\n+        {\n+          fileName: MAIN_TS,\n+          templates: {\n+            'SomeCmp': `\n+              <div *ngFor=\"let user of users\">\n+                Within this template, 'user' should be a variable, not a reference.\n+              </div>\n+              <div #user>Out here, 'user' is the reference.</div>\n+          `\n+          },\n+          source: `\n+            export class SomeCmp {\n+              users: string[];\n+            }\n+          `,\n+        },\n+      ]);\n+      const sf = getSourceFileOrError(programStrategy.getProgram(), MAIN_TS);\n+      const SomeCmp = getClass(sf, 'SomeCmp');\n+\n+      const tmpl = templateTypeChecker.getTemplate(SomeCmp)!;\n+      const ngForTemplate = tmpl[0] as TmplAstTemplate;\n+\n+      const [_a, userAtTopLevel] =\n+          templateTypeChecker.getGlobalCompletions(/* root template */ null, SomeCmp);\n+      const [_b, userInNgFor] = templateTypeChecker.getGlobalCompletions(ngForTemplate, SomeCmp);\n+\n+      expect(userAtTopLevel.kind).toBe(CompletionKind.Reference);\n+      expect(userInNgFor.kind).toBe(CompletionKind.Variable);\n+    });\n+  });\n+});\n+\n+function setup(targets: TypeCheckingTarget[], config?: Partial<TypeCheckingConfig>) {\n+  return baseTestSetup(\n+      targets, {inlining: false, config: {...config, enableTemplateTypeChecker: true}});\n+}"
        }
    ],
    "stats": {
        "total": 365,
        "additions": 329,
        "deletions": 36
    }
}