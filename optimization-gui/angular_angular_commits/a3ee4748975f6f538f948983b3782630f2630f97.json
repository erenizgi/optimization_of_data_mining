{
    "author": "atscott",
    "message": "refactor(router): Remove use of browserUrlTree in scheduleNavigation (#43632)\n\nThere are no added tests here because the change is generally equivalent\nto what was there before. The goal of that piece of code is to prevent\nduplicate navigations due to the location synchronization code between\nAngularJS and Angular. That is, the Angular router listens to the\n`popstate` event and triggers navigations, but so does the AngularJS\nrouter and triggers navigations through `router.navigateByUrl`. The\n`setTimeout` in the Angular Router's `setUpLocationChangeListener` is\nthere to make this bit of code work: the 'popstate'/'hashchange'\nnavigation will necessarily come after the imperative nav triggered by\nAngularJS's location sync.\n\nAnyhow, in the long run, I would like to get rid of this bit of code\naltogether. We should not have special handling for these cases. The\nAngularJS/Angular location sync should either:\n\n1. Not trigger a duplicate navigation in the first place\nor\n2. Be tolerant to processing the duplicate navigation.\n\nIn the short term, this change benefits the router while we investigate\nremoving this logic completely because now browserUrlTree has a single\nresponsiblity: to support `onSameUrlNavigation==='reload'`. This means\nthat we can work towards removing the `browserUrlTree` tracking from the\nRouter code at some point as well and have the `onSameUrlNavigation`\nlogic be part of a pre-navigation hook that can be handled outside the\n`Router`. This may or may not be possible, but the change here opens up\nthat change for investigation.\n\nPR Close #43632",
    "sha": "a3ee4748975f6f538f948983b3782630f2630f97",
    "files": [
        {
            "sha": "9c532512965c3b650e2e7b97e4743ac9f274394c",
            "filename": "packages/router/src/router.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 17,
            "changes": 26,
            "blob_url": "https://github.com/angular/angular/blob/a3ee4748975f6f538f948983b3782630f2630f97/packages%2Frouter%2Fsrc%2Frouter.ts",
            "raw_url": "https://github.com/angular/angular/raw/a3ee4748975f6f538f948983b3782630f2630f97/packages%2Frouter%2Fsrc%2Frouter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frouter.ts?ref=a3ee4748975f6f538f948983b3782630f2630f97",
            "patch": "@@ -1353,26 +1353,18 @@ export class Router {\n       return Promise.resolve(false);\n     }\n \n-    // * Duplicate navigations may also be triggered by attempts to sync AngularJS and Angular\n-    // router states.\n-    // * Imperative navigations can be cancelled by router guards, meaning the URL won't change. If\n-    //   the user follows that with a navigation using the back/forward button or manual URL change,\n-    //   the destination may be the same as the previous imperative attempt. We should not skip\n-    //   these navigations because it's a separate case from the one above -- it's not a duplicate\n-    //   navigation.\n+    // Duplicate navigations may be triggered by attempts to sync AngularJS and\n+    // Angular router states. We have the setTimeout in the location listener to\n+    // ensure the imperative nav is scheduled before the browser nav.\n     const lastNavigation = this.transitions.value;\n-    // We don't want to skip duplicate successful navs if they're imperative because\n-    // onSameUrlNavigation could be 'reload' (so the duplicate is intended).\n     const browserNavPrecededByRouterNav = isBrowserTriggeredNavigation(source) && lastNavigation &&\n         !isBrowserTriggeredNavigation(lastNavigation.source);\n-    const lastNavigationSucceeded = this.lastSuccessfulId === lastNavigation.id;\n-    // If the last navigation succeeded or is in flight, we can use the rawUrl as the comparison.\n-    // However, if it failed, we should compare to the final result (urlAfterRedirects).\n-    const lastNavigationUrl = (lastNavigationSucceeded || this.currentNavigation) ?\n-        lastNavigation.rawUrl :\n-        (lastNavigation.urlAfterRedirects ?? this.browserUrlTree);\n-    const duplicateNav = lastNavigationUrl.toString() === rawUrl.toString();\n-    if (browserNavPrecededByRouterNav && duplicateNav) {\n+    const navToSameUrl = lastNavigation.rawUrl.toString() === rawUrl.toString();\n+    const lastNavigationInProgress = lastNavigation.id === this.currentNavigation?.id;\n+    // We consider duplicates as ones that goes to the same URL while the first\n+    // is still processing.\n+    const isDuplicateNav = navToSameUrl && lastNavigationInProgress;\n+    if (browserNavPrecededByRouterNav && isDuplicateNav) {\n       return Promise.resolve(true);  // return value is not used\n     }\n "
        }
    ],
    "stats": {
        "total": 26,
        "additions": 9,
        "deletions": 17
    }
}