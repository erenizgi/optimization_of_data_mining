{
    "author": "JoostK",
    "message": "fix(animations): ensure consistent transition namespace ordering (#19854)\n\nWhen including a component in a template, the component's host element\nis immediately appended as child of the parent node upon creation.\nHence, `hostElement.parentNode` will be a valid reference. However, if\nthe parent component is being inserted as an embedded view—through\n`ngIf` for example—then the parent's node itself will not have been\ninserted yet. This means that we cannot properly determine the position\nof the transition namespace, as any `containsElement` check will return\nfalse given that the partial DOM tree has not been inserted yet, even\nthough it will be contained within an existing transition namespace once\nthe partial tree is attached.\n\nThis commit fixes the issue by not just looking at the existence of a\nparent node, but rather a more extensive check using the driver's\n`containsElement` method.\n\nPR Close #19854",
    "sha": "e27ac018ed7848f61c09146ccce2184272f4d1ef",
    "files": [
        {
            "sha": "807939a228d4a8602e3c7ef98d7610e6af687474",
            "filename": "packages/animations/browser/src/render/transition_animation_engine.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/e27ac018ed7848f61c09146ccce2184272f4d1ef/packages%2Fanimations%2Fbrowser%2Fsrc%2Frender%2Ftransition_animation_engine.ts",
            "raw_url": "https://github.com/angular/angular/raw/e27ac018ed7848f61c09146ccce2184272f4d1ef/packages%2Fanimations%2Fbrowser%2Fsrc%2Frender%2Ftransition_animation_engine.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fanimations%2Fbrowser%2Fsrc%2Frender%2Ftransition_animation_engine.ts?ref=e27ac018ed7848f61c09146ccce2184272f4d1ef",
            "patch": "@@ -571,7 +571,7 @@ export class TransitionAnimationEngine {\n \n   createNamespace(namespaceId: string, hostElement: any) {\n     const ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);\n-    if (hostElement.parentNode) {\n+    if (this.bodyNode && this.driver.containsElement(this.bodyNode, hostElement)) {\n       this._balanceNamespaceList(ns, hostElement);\n     } else {\n       // defer this later until flush during when the host element has\n@@ -580,7 +580,7 @@ export class TransitionAnimationEngine {\n       this.newHostElements.set(hostElement, ns);\n \n       // given that this host element is apart of the animation code, it\n-      // may or may not be inserted by a parent node that is an of an\n+      // may or may not be inserted by a parent node that is of an\n       // animation renderer type. If this happens then we can still have\n       // access to this item when we query for :enter nodes. If the parent\n       // is a renderer then the set data-structure will normalize the entry"
        },
        {
            "sha": "ee403ec1daa4110aa5ad6e72eeab3d144e8c73e5",
            "filename": "packages/core/test/animation/animation_query_integration_spec.ts",
            "status": "modified",
            "additions": 85,
            "deletions": 0,
            "changes": 85,
            "blob_url": "https://github.com/angular/angular/blob/e27ac018ed7848f61c09146ccce2184272f4d1ef/packages%2Fcore%2Ftest%2Fanimation%2Fanimation_query_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e27ac018ed7848f61c09146ccce2184272f4d1ef/packages%2Fcore%2Ftest%2Fanimation%2Fanimation_query_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fanimation%2Fanimation_query_integration_spec.ts?ref=e27ac018ed7848f61c09146ccce2184272f4d1ef",
            "patch": "@@ -2374,6 +2374,91 @@ describe('animation query tests', function() {\n          ]);\n        });\n \n+    it(`should emulate a leave animation on a nested sub component's inner elements when a parent leave animation occurs with animateChild`,\n+       () => {\n+         @Component({\n+           selector: 'ani-cmp',\n+           template: `\n+            <div @myAnimation *ngIf=\"exp\" class=\"parent\">\n+              <child-cmp></child-cmp>\n+            </div>\n+          `,\n+           animations: [\n+             trigger(\n+                 'myAnimation',\n+                 [\n+                   transition(\n+                       ':leave',\n+                       [\n+                         query('@*', animateChild()),\n+                       ]),\n+                 ]),\n+           ]\n+         })\n+         class ParentCmp {\n+           public exp: boolean = true;\n+         }\n+\n+         @Component({\n+           selector: 'child-cmp',\n+           template: `\n+               <nested-child-cmp></nested-child-cmp>\n+             `\n+         })\n+         class ChildCmp {\n+         }\n+\n+         @Component({\n+           selector: 'nested-child-cmp',\n+           template: `\n+               <section>\n+                 <div class=\"inner-div\" @myChildAnimation></div>\n+               </section>\n+             `,\n+           animations: [\n+             trigger(\n+                 'myChildAnimation',\n+                 [\n+                   transition(\n+                       ':leave',\n+                       [\n+                         style({opacity: 0}),\n+                         animate('1s', style({opacity: 1})),\n+                       ]),\n+                 ]),\n+           ]\n+         })\n+         class NestedChildCmp {\n+         }\n+\n+         TestBed.configureTestingModule({declarations: [ParentCmp, ChildCmp, NestedChildCmp]});\n+\n+         const engine = TestBed.inject(ɵAnimationEngine);\n+         const fixture = TestBed.createComponent(ParentCmp);\n+         const cmp = fixture.componentInstance;\n+\n+         cmp.exp = true;\n+         fixture.detectChanges();\n+\n+         cmp.exp = false;\n+         fixture.detectChanges();\n+\n+         // Inspect the players of the AnimationEngine and not those from getLog. The latter only\n+         // returns the actual animation players, which the parent leave animation is not part\n+         // of given that it does not have animation instructions of its own.\n+         const players = engine.players;\n+         expect(players.length).toEqual(1);\n+         const player = players[0] as TransitionAnimationPlayer;\n+         const realPlayer = player.getRealPlayer() as MockAnimationPlayer;\n+\n+         expect(player.element.classList.contains('parent')).toBeTruthy();\n+         expect(realPlayer.element.classList.contains('inner-div')).toBeTruthy();\n+         expect(realPlayer.keyframes).toEqual([\n+           {opacity: '0', offset: 0},\n+           {opacity: '1', offset: 1},\n+         ]);\n+       });\n+\n     it('should not cause a removal of inner @trigger DOM nodes when a parent animation occurs',\n        fakeAsync(() => {\n          @Component({"
        }
    ],
    "stats": {
        "total": 89,
        "additions": 87,
        "deletions": 2
    }
}