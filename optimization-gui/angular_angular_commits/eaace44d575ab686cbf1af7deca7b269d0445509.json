{
    "author": "alxhub",
    "message": "refactor(language-service): refactor `HybridVisitor` and expand its capabilities (#39505)\n\nThis commit takes the `HybridVisitor` in the language service and gives it\nthe ability to return not just a node but the template context in which it\nappears. In the future, more context regarding where a node appears in the\ntemplate might become necessary (ex: the microsyntax container for binding\nnodes), and this refactoring enables that.\n\nIn the process, `HybridVisitor` is renamed and the concept of a\n`TemplateTarget` interface is introduced to contain the results of this\noperation.\n\nPR Close #39505",
    "sha": "eaace44d575ab686cbf1af7deca7b269d0445509",
    "files": [
        {
            "sha": "e9215eec18f85f30ac53b0d5cb55b5000b2d92ac",
            "filename": "packages/language-service/ivy/definitions.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 15,
            "changes": 29,
            "blob_url": "https://github.com/angular/angular/blob/eaace44d575ab686cbf1af7deca7b269d0445509/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts",
            "raw_url": "https://github.com/angular/angular/raw/eaace44d575ab686cbf1af7deca7b269d0445509/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts?ref=eaace44d575ab686cbf1af7deca7b269d0445509",
            "patch": "@@ -10,8 +10,8 @@ import {AST, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstNo\n import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n import {DirectiveSymbol, DomBindingSymbol, ElementSymbol, ShimLocation, Symbol, SymbolKind, TemplateSymbol} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import * as ts from 'typescript';\n+import {getTargetAtPosition} from './template_target';\n \n-import {getPathToNodeAtPosition} from './hybrid_visitor';\n import {findTightestNode, flatMap, getClassDeclFromDecoratorProp, getDirectiveMatchesForAttribute, getDirectiveMatchesForElementTag, getPropertyAssignmentFromValue, getTemplateInfoAtPosition, getTextSpanOfNode, isDollarEvent, isTypeScriptFile, TemplateInfo, toTextSpan} from './utils';\n \n \n@@ -111,10 +111,9 @@ function getUrlFromProperty(urlNode: ts.StringLiteralLike, resourceResolver: Res\n   };\n }\n \n-\n interface DefinitionMeta {\n   node: AST|TmplAstNode;\n-  path: Array<AST|TmplAstNode>;\n+  parent: AST|TmplAstNode|null;\n   symbol: Symbol;\n }\n \n@@ -156,7 +155,7 @@ export class DefinitionBuilder {\n     return {definitions, textSpan: getTextSpanOfNode(definitionMeta.node)};\n   }\n \n-  private getDefinitionsForSymbol({symbol, node, path, component}: DefinitionMeta&\n+  private getDefinitionsForSymbol({symbol, node, parent, component}: DefinitionMeta&\n                                   TemplateInfo): readonly ts.DefinitionInfo[]|undefined {\n     switch (symbol.kind) {\n       case SymbolKind.Directive:\n@@ -174,7 +173,7 @@ export class DefinitionBuilder {\n         const bindingDefs = this.getDefinitionsForSymbols(...symbol.bindings);\n         // Also attempt to get directive matches for the input name. If there is a directive that\n         // has the input name as part of the selector, we want to return that as well.\n-        const directiveDefs = this.getDirectiveTypeDefsForBindingNode(node, path, component);\n+        const directiveDefs = this.getDirectiveTypeDefsForBindingNode(node, parent, component);\n         return [...bindingDefs, ...directiveDefs];\n       }\n       case SymbolKind.Variable:\n@@ -233,7 +232,7 @@ export class DefinitionBuilder {\n         // Also attempt to get directive matches for the input name. If there is a directive that\n         // has the input name as part of the selector, we want to return that as well.\n         const directiveDefs = this.getDirectiveTypeDefsForBindingNode(\n-            node, definitionMeta.path, templateInfo.component);\n+            node, definitionMeta.parent, templateInfo.component);\n         return [...bindingDefs, ...directiveDefs];\n       }\n       case SymbolKind.Reference:\n@@ -273,13 +272,13 @@ export class DefinitionBuilder {\n   }\n \n   private getDirectiveTypeDefsForBindingNode(\n-      node: TmplAstNode|AST, pathToNode: Array<TmplAstNode|AST>, component: ts.ClassDeclaration) {\n+      node: TmplAstNode|AST, parent: TmplAstNode|AST|null, component: ts.ClassDeclaration) {\n     if (!(node instanceof TmplAstBoundAttribute) && !(node instanceof TmplAstTextAttribute) &&\n         !(node instanceof TmplAstBoundEvent)) {\n       return [];\n     }\n-    const parent = pathToNode[pathToNode.length - 2];\n-    if (!(parent instanceof TmplAstTemplate || parent instanceof TmplAstElement)) {\n+    if (parent === null ||\n+        !(parent instanceof TmplAstTemplate || parent instanceof TmplAstElement)) {\n       return [];\n     }\n     const templateOrElementSymbol =\n@@ -303,16 +302,16 @@ export class DefinitionBuilder {\n \n   private getDefinitionMetaAtPosition({template, component}: TemplateInfo, position: number):\n       DefinitionMeta|undefined {\n-    const path = getPathToNodeAtPosition(template, position);\n-    if (path === undefined) {\n-      return;\n+    const target = getTargetAtPosition(template, position);\n+    if (target === null) {\n+      return undefined;\n     }\n+    const {node, parent} = target;\n \n-    const node = path[path.length - 1];\n     const symbol = this.compiler.getTemplateTypeChecker().getSymbolOfNode(node, component);\n     if (symbol === null) {\n-      return;\n+      return undefined;\n     }\n-    return {node, path, symbol};\n+    return {node, parent, symbol};\n   }\n }"
        },
        {
            "sha": "a7538a8dfea83daa33d6af8edc59668668e9646c",
            "filename": "packages/language-service/ivy/language_service.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 2,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/eaace44d575ab686cbf1af7deca7b269d0445509/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "raw_url": "https://github.com/angular/angular/raw/eaace44d575ab686cbf1af7deca7b269d0445509/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts?ref=eaace44d575ab686cbf1af7deca7b269d0445509",
            "patch": "@@ -16,7 +16,8 @@ import {CompilerFactory} from './compiler_factory';\n import {DefinitionBuilder} from './definitions';\n import {LanguageServiceAdapter} from './language_service_adapter';\n import {QuickInfoBuilder} from './quick_info';\n-import {isTypeScriptFile} from './utils';\n+import {getTargetAtPosition} from './template_target';\n+import {getTemplateInfoAtPosition, isTypeScriptFile} from './utils';\n \n export class LanguageService {\n   private options: CompilerOptions;\n@@ -73,8 +74,19 @@ export class LanguageService {\n   }\n \n   getQuickInfoAtPosition(fileName: string, position: number): ts.QuickInfo|undefined {\n+    const program = this.strategy.getProgram();\n     const compiler = this.compilerFactory.getOrCreateWithChangedFile(fileName, this.options);\n-    const results = new QuickInfoBuilder(this.tsLS, compiler).get(fileName, position);\n+    const templateInfo = getTemplateInfoAtPosition(fileName, position, compiler);\n+    if (templateInfo === undefined) {\n+      return undefined;\n+    }\n+    const positionDetails = getTargetAtPosition(templateInfo.template, position);\n+    if (positionDetails === null) {\n+      return undefined;\n+    }\n+    const results =\n+        new QuickInfoBuilder(this.tsLS, compiler, templateInfo.component, positionDetails.node)\n+            .get();\n     this.compilerFactory.registerLastKnownProgram();\n     return results;\n   }"
        },
        {
            "sha": "0079bc0e2f24f5a9de3e241b724ca6bfed18afc7",
            "filename": "packages/language-service/ivy/quick_info.ts",
            "status": "modified",
            "additions": 36,
            "deletions": 48,
            "changes": 84,
            "blob_url": "https://github.com/angular/angular/blob/eaace44d575ab686cbf1af7deca7b269d0445509/packages%2Flanguage-service%2Fivy%2Fquick_info.ts",
            "raw_url": "https://github.com/angular/angular/raw/eaace44d575ab686cbf1af7deca7b269d0445509/packages%2Flanguage-service%2Fivy%2Fquick_info.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fquick_info.ts?ref=eaace44d575ab686cbf1af7deca7b269d0445509",
            "patch": "@@ -11,59 +11,50 @@ import {DirectiveSymbol, DomBindingSymbol, ElementSymbol, ExpressionSymbol, Inpu\n import * as ts from 'typescript';\n \n import {createDisplayParts, DisplayInfoKind, SYMBOL_PUNC, SYMBOL_SPACE, SYMBOL_TEXT, unsafeCastDisplayInfoKindToScriptElementKind} from './display_parts';\n-import {findNodeAtPosition} from './hybrid_visitor';\n import {filterAliasImports, getDirectiveMatchesForAttribute, getDirectiveMatchesForElementTag, getTemplateInfoAtPosition, getTextSpanOfNode} from './utils';\n \n export class QuickInfoBuilder {\n   private readonly typeChecker = this.compiler.getNextProgram().getTypeChecker();\n-  constructor(private readonly tsLS: ts.LanguageService, private readonly compiler: NgCompiler) {}\n \n-  get(fileName: string, position: number): ts.QuickInfo|undefined {\n-    const templateInfo = getTemplateInfoAtPosition(fileName, position, this.compiler);\n-    if (templateInfo === undefined) {\n-      return undefined;\n-    }\n-    const {template, component} = templateInfo;\n-\n-    const node = findNodeAtPosition(template, position);\n-    if (node === undefined) {\n-      return undefined;\n-    }\n+  constructor(\n+      private readonly tsLS: ts.LanguageService, private readonly compiler: NgCompiler,\n+      private readonly component: ts.ClassDeclaration, private node: TmplAstNode|AST) {}\n \n-    const symbol = this.compiler.getTemplateTypeChecker().getSymbolOfNode(node, component);\n+  get(): ts.QuickInfo|undefined {\n+    const symbol =\n+        this.compiler.getTemplateTypeChecker().getSymbolOfNode(this.node, this.component);\n     if (symbol === null) {\n-      return isDollarAny(node) ? createDollarAnyQuickInfo(node) : undefined;\n+      return isDollarAny(this.node) ? createDollarAnyQuickInfo(this.node) : undefined;\n     }\n \n-    return this.getQuickInfoForSymbol(symbol, node);\n+    return this.getQuickInfoForSymbol(symbol);\n   }\n \n-  private getQuickInfoForSymbol(symbol: Symbol, node: TmplAstNode|AST): ts.QuickInfo|undefined {\n+  private getQuickInfoForSymbol(symbol: Symbol): ts.QuickInfo|undefined {\n     switch (symbol.kind) {\n       case SymbolKind.Input:\n       case SymbolKind.Output:\n-        return this.getQuickInfoForBindingSymbol(symbol, node);\n+        return this.getQuickInfoForBindingSymbol(symbol);\n       case SymbolKind.Template:\n-        return createNgTemplateQuickInfo(node);\n+        return createNgTemplateQuickInfo(this.node);\n       case SymbolKind.Element:\n         return this.getQuickInfoForElementSymbol(symbol);\n       case SymbolKind.Variable:\n-        return this.getQuickInfoForVariableSymbol(symbol, node);\n+        return this.getQuickInfoForVariableSymbol(symbol);\n       case SymbolKind.Reference:\n-        return this.getQuickInfoForReferenceSymbol(symbol, node);\n+        return this.getQuickInfoForReferenceSymbol(symbol);\n       case SymbolKind.DomBinding:\n-        return this.getQuickInfoForDomBinding(node, symbol);\n+        return this.getQuickInfoForDomBinding(symbol);\n       case SymbolKind.Directive:\n-        return this.getQuickInfoAtShimLocation(symbol.shimLocation, node);\n+        return this.getQuickInfoAtShimLocation(symbol.shimLocation);\n       case SymbolKind.Expression:\n-        return node instanceof BindingPipe ?\n-            this.getQuickInfoForPipeSymbol(symbol, node) :\n-            this.getQuickInfoAtShimLocation(symbol.shimLocation, node);\n+        return this.node instanceof BindingPipe ?\n+            this.getQuickInfoForPipeSymbol(symbol) :\n+            this.getQuickInfoAtShimLocation(symbol.shimLocation);\n     }\n   }\n \n-  private getQuickInfoForBindingSymbol(\n-      symbol: InputBindingSymbol|OutputBindingSymbol, node: TmplAstNode|AST): ts.QuickInfo\n+  private getQuickInfoForBindingSymbol(symbol: InputBindingSymbol|OutputBindingSymbol): ts.QuickInfo\n       |undefined {\n     if (symbol.bindings.length === 0) {\n       return undefined;\n@@ -72,7 +63,7 @@ export class QuickInfoBuilder {\n     const kind =\n         symbol.kind === SymbolKind.Input ? DisplayInfoKind.PROPERTY : DisplayInfoKind.EVENT;\n \n-    const quickInfo = this.getQuickInfoAtShimLocation(symbol.bindings[0].shimLocation, node);\n+    const quickInfo = this.getQuickInfoAtShimLocation(symbol.bindings[0].shimLocation);\n     return quickInfo === undefined ? undefined : updateQuickInfoKind(quickInfo, kind);\n   }\n \n@@ -88,43 +79,41 @@ export class QuickInfoBuilder {\n         undefined /* containerName */, this.typeChecker.typeToString(symbol.tsType));\n   }\n \n-  private getQuickInfoForVariableSymbol(symbol: VariableSymbol, node: TmplAstNode|AST):\n-      ts.QuickInfo {\n+  private getQuickInfoForVariableSymbol(symbol: VariableSymbol): ts.QuickInfo {\n     const documentation = this.getDocumentationFromTypeDefAtLocation(symbol.shimLocation);\n     return createQuickInfo(\n-        symbol.declaration.name, DisplayInfoKind.VARIABLE, getTextSpanOfNode(node),\n+        symbol.declaration.name, DisplayInfoKind.VARIABLE, getTextSpanOfNode(this.node),\n         undefined /* containerName */, this.typeChecker.typeToString(symbol.tsType), documentation);\n   }\n \n-  private getQuickInfoForReferenceSymbol(symbol: ReferenceSymbol, node: TmplAstNode|AST):\n-      ts.QuickInfo {\n+  private getQuickInfoForReferenceSymbol(symbol: ReferenceSymbol): ts.QuickInfo {\n     const documentation = this.getDocumentationFromTypeDefAtLocation(symbol.shimLocation);\n     return createQuickInfo(\n-        symbol.declaration.name, DisplayInfoKind.REFERENCE, getTextSpanOfNode(node),\n+        symbol.declaration.name, DisplayInfoKind.REFERENCE, getTextSpanOfNode(this.node),\n         undefined /* containerName */, this.typeChecker.typeToString(symbol.tsType), documentation);\n   }\n \n-  private getQuickInfoForPipeSymbol(symbol: ExpressionSymbol, node: TmplAstNode|AST): ts.QuickInfo\n-      |undefined {\n-    const quickInfo = this.getQuickInfoAtShimLocation(symbol.shimLocation, node);\n+  private getQuickInfoForPipeSymbol(symbol: ExpressionSymbol): ts.QuickInfo|undefined {\n+    const quickInfo = this.getQuickInfoAtShimLocation(symbol.shimLocation);\n     return quickInfo === undefined ? undefined :\n                                      updateQuickInfoKind(quickInfo, DisplayInfoKind.PIPE);\n   }\n \n-  private getQuickInfoForDomBinding(node: TmplAstNode|AST, symbol: DomBindingSymbol) {\n-    if (!(node instanceof TmplAstTextAttribute) && !(node instanceof TmplAstBoundAttribute)) {\n+  private getQuickInfoForDomBinding(symbol: DomBindingSymbol) {\n+    if (!(this.node instanceof TmplAstTextAttribute) &&\n+        !(this.node instanceof TmplAstBoundAttribute)) {\n       return undefined;\n     }\n     const directives = getDirectiveMatchesForAttribute(\n-        node.name, symbol.host.templateNode, symbol.host.directives);\n+        this.node.name, symbol.host.templateNode, symbol.host.directives);\n     if (directives.size === 0) {\n       return undefined;\n     }\n \n-    return this.getQuickInfoForDirectiveSymbol(directives.values().next().value, node);\n+    return this.getQuickInfoForDirectiveSymbol(directives.values().next().value);\n   }\n \n-  private getQuickInfoForDirectiveSymbol(dir: DirectiveSymbol, node: TmplAstNode|AST):\n+  private getQuickInfoForDirectiveSymbol(dir: DirectiveSymbol, node: TmplAstNode|AST = this.node):\n       ts.QuickInfo {\n     const kind = dir.isComponent ? DisplayInfoKind.COMPONENT : DisplayInfoKind.DIRECTIVE;\n     const documentation = this.getDocumentationFromTypeDefAtLocation(dir.shimLocation);\n@@ -134,8 +123,8 @@ export class QuickInfoBuilder {\n     }\n \n     return createQuickInfo(\n-        this.typeChecker.typeToString(dir.tsType), kind, getTextSpanOfNode(node), containerName,\n-        undefined, documentation);\n+        this.typeChecker.typeToString(dir.tsType), kind, getTextSpanOfNode(this.node),\n+        containerName, undefined, documentation);\n   }\n \n   private getDocumentationFromTypeDefAtLocation(shimLocation: ShimLocation):\n@@ -149,8 +138,7 @@ export class QuickInfoBuilder {\n         ?.documentation;\n   }\n \n-  private getQuickInfoAtShimLocation(location: ShimLocation, node: TmplAstNode|AST): ts.QuickInfo\n-      |undefined {\n+  private getQuickInfoAtShimLocation(location: ShimLocation): ts.QuickInfo|undefined {\n     const quickInfo =\n         this.tsLS.getQuickInfoAtPosition(location.shimPath, location.positionInShimFile);\n     if (quickInfo === undefined || quickInfo.displayParts === undefined) {\n@@ -159,7 +147,7 @@ export class QuickInfoBuilder {\n \n     quickInfo.displayParts = filterAliasImports(quickInfo.displayParts);\n \n-    const textSpan = getTextSpanOfNode(node);\n+    const textSpan = getTextSpanOfNode(this.node);\n     return {...quickInfo, textSpan};\n   }\n }"
        },
        {
            "sha": "39d3edaaed2e4e195b0b4e0d0a67c5b854cf2db5",
            "filename": "packages/language-service/ivy/template_target.ts",
            "status": "renamed",
            "additions": 64,
            "deletions": 27,
            "changes": 91,
            "blob_url": "https://github.com/angular/angular/blob/eaace44d575ab686cbf1af7deca7b269d0445509/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "raw_url": "https://github.com/angular/angular/raw/eaace44d575ab686cbf1af7deca7b269d0445509/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts?ref=eaace44d575ab686cbf1af7deca7b269d0445509",
            "patch": "@@ -13,55 +13,92 @@ import * as t from '@angular/compiler/src/render3/r3_ast';         // t for temp\n import {isTemplateNode, isTemplateNodeWithKeyAndValue} from './utils';\n \n /**\n- * Return the path to the template AST node or expression AST node that most accurately\n+ * Contextual information for a target position within the template.\n+ */\n+export interface TemplateTarget {\n+  /**\n+   * Target position within the template.\n+   */\n+  position: number;\n+\n+  /**\n+   * The template node (or AST expression) closest to the search position.\n+   */\n+  node: t.Node|e.AST;\n+\n+  /**\n+   * The `t.Template` which contains the found node or expression (or `null` if in the root\n+   * template).\n+   */\n+  context: t.Template|null;\n+\n+  /**\n+   * The immediate parent node of the targeted node.\n+   */\n+  parent: t.Node|e.AST|null;\n+}\n+\n+/**\n+ * Return the template AST node or expression AST node that most accurately\n  * represents the node at the specified cursor `position`.\n  *\n- * @param ast AST tree\n- * @param position cursor position\n+ * @param template AST tree of the template\n+ * @param position target cursor position\n  */\n-export function getPathToNodeAtPosition(ast: t.Node[], position: number): Array<t.Node|e.AST>|\n-    undefined {\n-  const visitor = new R3Visitor(position);\n-  visitor.visitAll(ast);\n-  const candidate = visitor.path[visitor.path.length - 1];\n-  if (!candidate) {\n-    return;\n+export function getTargetAtPosition(template: t.Node[], position: number): TemplateTarget|null {\n+  const path = TemplateTargetVisitor.visitTemplate(template, position);\n+  if (path.length === 0) {\n+    return null;\n   }\n+\n+  const candidate = path[path.length - 1];\n   if (isTemplateNodeWithKeyAndValue(candidate)) {\n     const {keySpan, valueSpan} = candidate;\n     const isWithinKeyValue =\n         isWithin(position, keySpan) || (valueSpan && isWithin(position, valueSpan));\n     if (!isWithinKeyValue) {\n       // If cursor is within source span but not within key span or value span,\n       // do not return the node.\n-      return;\n+      return null;\n     }\n   }\n-  return visitor.path;\n-}\n \n-/**\n- * Return the template AST node or expression AST node that most accurately\n- * represents the node at the specified cursor `position`.\n- *\n- * @param ast AST tree\n- * @param position cursor position\n- */\n-export function findNodeAtPosition(ast: t.Node[], position: number): t.Node|e.AST|undefined {\n-  const path = getPathToNodeAtPosition(ast, position);\n-  if (!path) {\n-    return;\n+  // Walk up the result nodes to find the nearest `t.Template` which contains the targeted node.\n+  let context: t.Template|null = null;\n+  for (let i = path.length - 2; i >= 0; i--) {\n+    const node = path[i];\n+    if (node instanceof t.Template) {\n+      context = node;\n+      break;\n+    }\n+  }\n+\n+  let parent: t.Node|e.AST|null = null;\n+  if (path.length >= 2) {\n+    parent = path[path.length - 2];\n   }\n-  return path[path.length - 1];\n+\n+  return {position, node: candidate, context, parent};\n }\n \n-class R3Visitor implements t.Visitor {\n+/**\n+ * Visitor which, given a position and a template, identifies the node within the template at that\n+ * position, as well as records the path of increasingly nested nodes that were traversed to reach\n+ * that position.\n+ */\n+class TemplateTargetVisitor implements t.Visitor {\n   // We need to keep a path instead of the last node because we might need more\n   // context for the last node, for example what is the parent node?\n   readonly path: Array<t.Node|e.AST> = [];\n \n+  static visitTemplate(template: t.Node[], position: number): Array<t.Node|e.AST> {\n+    const visitor = new TemplateTargetVisitor(position);\n+    visitor.visitAll(template);\n+    return visitor.path;\n+  }\n+\n   // Position must be absolute in the source file.\n-  constructor(private readonly position: number) {}\n+  private constructor(private readonly position: number) {}\n \n   visit(node: t.Node) {\n     const {start, end} = getSpanIncludingEndTag(node);",
            "previous_filename": "packages/language-service/ivy/hybrid_visitor.ts"
        },
        {
            "sha": "8e904c62f9cb9c6182a5939a8447d6f06ef0ef3f",
            "filename": "packages/language-service/ivy/test/template_target_spec.ts",
            "status": "renamed",
            "additions": 89,
            "deletions": 76,
            "changes": 165,
            "blob_url": "https://github.com/angular/angular/blob/eaace44d575ab686cbf1af7deca7b269d0445509/packages%2Flanguage-service%2Fivy%2Ftest%2Ftemplate_target_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/eaace44d575ab686cbf1af7deca7b269d0445509/packages%2Flanguage-service%2Fivy%2Ftest%2Ftemplate_target_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Ftemplate_target_spec.ts?ref=eaace44d575ab686cbf1af7deca7b269d0445509",
            "patch": "@@ -10,7 +10,7 @@ import {ParseError, parseTemplate} from '@angular/compiler';\n import * as e from '@angular/compiler/src/expression_parser/ast';  // e for expression AST\n import * as t from '@angular/compiler/src/render3/r3_ast';         // t for template AST\n \n-import {findNodeAtPosition} from '../hybrid_visitor';\n+import {getTargetAtPosition} from '../template_target';\n import {isExpressionNode, isTemplateNode} from '../utils';\n \n interface ParseResult {\n@@ -32,51 +32,51 @@ function parse(template: string): ParseResult {\n   };\n }\n \n-describe('findNodeAtPosition for template AST', () => {\n+describe('getTargetAtPosition for template AST', () => {\n   it('should locate element in opening tag', () => {\n     const {errors, nodes, position} = parse(`<di¦v></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate element in closing tag', () => {\n     const {errors, nodes, position} = parse(`<div></di¦v>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate element when cursor is at the beginning', () => {\n     const {errors, nodes, position} = parse(`<¦div></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate element when cursor is at the end', () => {\n     const {errors, nodes, position} = parse(`<div¦></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate attribute key', () => {\n     const {errors, nodes, position} = parse(`<div cla¦ss=\"foo\"></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.TextAttribute);\n   });\n \n   it('should locate attribute value', () => {\n     const {errors, nodes, position} = parse(`<div class=\"fo¦o\"></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     // TODO: Note that we do not have the ability to detect the RHS (yet)\n     expect(node).toBeInstanceOf(t.TextAttribute);\n@@ -85,46 +85,46 @@ describe('findNodeAtPosition for template AST', () => {\n   it('should locate bound attribute key', () => {\n     const {errors, nodes, position} = parse(`<test-cmp [fo¦o]=\"bar\"></test-cmp>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n   });\n \n   it('should locate bound attribute value', () => {\n     const {errors, nodes, position} = parse(`<test-cmp [foo]=\"b¦ar\"></test-cmp>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n \n   it('should not locate bound attribute if cursor is between key and value', () => {\n     const {errors, nodes, position} = parse(`<test-cmp [foo]¦=\"bar\"></test-cmp>`);\n     expect(errors).toBeNull();\n-    const node = findNodeAtPosition(nodes, position);\n-    expect(node).toBeUndefined();\n+    const nodeInfo = getTargetAtPosition(nodes, position)!;\n+    expect(nodeInfo).toBeNull();\n   });\n \n   it('should locate bound event key', () => {\n     const {errors, nodes, position} = parse(`<test-cmp (fo¦o)=\"bar()\"></test-cmp>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundEvent);\n   });\n \n   it('should locate bound event value', () => {\n     const {errors, nodes, position} = parse(`<test-cmp (foo)=\"b¦ar()\"></test-cmp>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.MethodCall);\n   });\n \n   it('should locate element children', () => {\n     const {errors, nodes, position} = parse(`<div><sp¦an></span></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n     expect((node as t.Element).name).toBe('span');\n@@ -133,39 +133,39 @@ describe('findNodeAtPosition for template AST', () => {\n   it('should locate element reference', () => {\n     const {errors, nodes, position} = parse(`<div #my¦div></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n   });\n \n   it('should locate template text attribute', () => {\n     const {errors, nodes, position} = parse(`<ng-template ng¦If></ng-template>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.TextAttribute);\n   });\n \n   it('should locate template bound attribute key', () => {\n     const {errors, nodes, position} = parse(`<ng-template [ng¦If]=\"foo\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n   });\n \n   it('should locate template bound attribute value', () => {\n     const {errors, nodes, position} = parse(`<ng-template [ngIf]=\"f¦oo\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n \n   it('should locate template bound attribute key in two-way binding', () => {\n     const {errors, nodes, position} = parse(`<ng-template [(f¦oo)]=\"bar\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n     expect((node as t.BoundAttribute).name).toBe('foo');\n@@ -174,7 +174,7 @@ describe('findNodeAtPosition for template AST', () => {\n   it('should locate template bound attribute value in two-way binding', () => {\n     const {errors, nodes, position} = parse(`<ng-template [(foo)]=\"b¦ar\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('bar');\n@@ -183,30 +183,30 @@ describe('findNodeAtPosition for template AST', () => {\n   it('should locate template bound event key', () => {\n     const {errors, nodes, position} = parse(`<ng-template (cl¦ick)=\"foo()\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundEvent);\n   });\n \n   it('should locate template bound event value', () => {\n     const {errors, nodes, position} = parse(`<ng-template (click)=\"f¦oo()\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(node).toBeInstanceOf(e.MethodCall);\n   });\n \n   it('should locate template attribute key', () => {\n     const {errors, nodes, position} = parse(`<ng-template i¦d=\"foo\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.TextAttribute);\n   });\n \n   it('should locate template attribute value', () => {\n     const {errors, nodes, position} = parse(`<ng-template id=\"f¦oo\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     // TODO: Note that we do not have the ability to detect the RHS (yet)\n     expect(node).toBeInstanceOf(t.TextAttribute);\n@@ -215,7 +215,7 @@ describe('findNodeAtPosition for template AST', () => {\n   it('should locate template reference key via the # notation', () => {\n     const {errors, nodes, position} = parse(`<ng-template #f¦oo></ng-template>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n     expect((node as t.Reference).name).toBe('foo');\n@@ -224,7 +224,7 @@ describe('findNodeAtPosition for template AST', () => {\n   it('should locate template reference key via the ref- notation', () => {\n     const {errors, nodes, position} = parse(`<ng-template ref-fo¦o></ng-template>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n     expect((node as t.Reference).name).toBe('foo');\n@@ -233,7 +233,7 @@ describe('findNodeAtPosition for template AST', () => {\n   it('should locate template reference value via the # notation', () => {\n     const {errors, nodes, position} = parse(`<ng-template #foo=\"export¦As\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n     expect((node as t.Reference).value).toBe('exportAs');\n@@ -243,7 +243,7 @@ describe('findNodeAtPosition for template AST', () => {\n   it('should locate template reference value via the ref- notation', () => {\n     const {errors, nodes, position} = parse(`<ng-template ref-foo=\"export¦As\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Reference);\n     expect((node as t.Reference).value).toBe('exportAs');\n@@ -253,47 +253,47 @@ describe('findNodeAtPosition for template AST', () => {\n   it('should locate template variable key', () => {\n     const {errors, nodes, position} = parse(`<ng-template let-f¦oo=\"bar\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);\n   });\n \n   it('should locate template variable value', () => {\n     const {errors, nodes, position} = parse(`<ng-template let-foo=\"b¦ar\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);\n   });\n \n   it('should locate template children', () => {\n     const {errors, nodes, position} = parse(`<ng-template><d¦iv></div></ng-template>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n   });\n \n   it('should locate ng-content', () => {\n     const {errors, nodes, position} = parse(`<ng-co¦ntent></ng-content>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Content);\n   });\n \n   it('should locate ng-content attribute key', () => {\n     const {errors, nodes, position} = parse('<ng-content cla¦ss=\"red\"></ng-content>');\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.TextAttribute);\n   });\n \n   it('should locate ng-content attribute value', () => {\n     const {errors, nodes, position} = parse('<ng-content class=\"r¦ed\"></ng-content>');\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     // TODO: Note that we do not have the ability to detect the RHS (yet)\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.TextAttribute);\n@@ -302,15 +302,15 @@ describe('findNodeAtPosition for template AST', () => {\n   it('should not locate implicit receiver', () => {\n     const {errors, nodes, position} = parse(`<div [foo]=\"¦bar\"></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n \n   it('should locate bound attribute key in two-way binding', () => {\n     const {errors, nodes, position} = parse(`<cmp [(f¦oo)]=\"bar\"></cmp>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n     expect((node as t.BoundAttribute).name).toBe('foo');\n@@ -319,7 +319,7 @@ describe('findNodeAtPosition for template AST', () => {\n   it('should locate bound attribute value in two-way binding', () => {\n     const {errors, nodes, position} = parse(`<cmp [(foo)]=\"b¦ar\"></cmp>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('bar');\n@@ -328,7 +328,7 @@ describe('findNodeAtPosition for template AST', () => {\n   it('should locate switch value in ICUs', () => {\n     const {errors, nodes, position} = parse(`<span i18n>{sw¦itch, plural, other {text}}\"></span>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('switch');\n@@ -338,7 +338,7 @@ describe('findNodeAtPosition for template AST', () => {\n     const {errors, nodes, position} = parse(\n         `<span i18n>{expr, plural, other { {ne¦sted, plural, =1 { {{nestedInterpolation}} }} }}\"></span>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('nested');\n@@ -348,7 +348,7 @@ describe('findNodeAtPosition for template AST', () => {\n     const {errors, nodes, position} =\n         parse(`<span i18n>{expr, plural, other { {{ i¦nterpolation }} }}\"></span>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('interpolation');\n@@ -358,18 +358,18 @@ describe('findNodeAtPosition for template AST', () => {\n     const {errors, nodes, position} = parse(\n         `<span i18n>{expr, plural, other { {nested, plural, =1 { {{n¦estedInterpolation}} }} }}\"></span>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('nestedInterpolation');\n   });\n });\n \n-describe('findNodeAtPosition for expression AST', () => {\n+describe('getTargetAtPosition for expression AST', () => {\n   it('should not locate implicit receiver', () => {\n     const {errors, nodes, position} = parse(`{{ ¦title }}`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('title');\n@@ -378,7 +378,7 @@ describe('findNodeAtPosition for expression AST', () => {\n   it('should locate property read', () => {\n     const {errors, nodes, position} = parse(`{{ ti¦tle }}`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('title');\n@@ -387,7 +387,7 @@ describe('findNodeAtPosition for expression AST', () => {\n   it('should locate safe property read', () => {\n     const {errors, nodes, position} = parse(`{{ foo?¦.bar }}`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.SafePropertyRead);\n     expect((node as e.SafePropertyRead).name).toBe('bar');\n@@ -396,39 +396,39 @@ describe('findNodeAtPosition for expression AST', () => {\n   it('should locate keyed read', () => {\n     const {errors, nodes, position} = parse(`{{ foo['bar']¦ }}`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.KeyedRead);\n   });\n \n   it('should locate property write', () => {\n     const {errors, nodes, position} = parse(`<div (foo)=\"b¦ar=$event\"></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyWrite);\n   });\n \n   it('should locate keyed write', () => {\n     const {errors, nodes, position} = parse(`<div (foo)=\"bar['baz']¦=$event\"></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.KeyedWrite);\n   });\n \n   it('should locate binary', () => {\n     const {errors, nodes, position} = parse(`{{ 1 +¦ 2 }}`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.Binary);\n   });\n \n   it('should locate binding pipe with an identifier', () => {\n     const {errors, nodes, position} = parse(`{{ title | p¦ }}`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.BindingPipe);\n   });\n@@ -439,32 +439,44 @@ describe('findNodeAtPosition for expression AST', () => {\n     expect(errors![0].toString())\n         .toContain(\n             'Unexpected end of input, expected identifier or keyword at the end of the expression');\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     // TODO: We want this to be a BindingPipe.\n     expect(node).toBeInstanceOf(e.Interpolation);\n   });\n \n+  it('should locate binding pipe without identifier',\n+     () => {\n+         // TODO: We are not able to locate pipe if identifier is missing because the\n+         // parser throws an error. This case is important for autocomplete.\n+         // const {errors, nodes, position} = parse(`{{ title | ¦ }}`);\n+         // expect(errors).toBe(null);\n+         // const {node} = findNodeAtPosition(nodes, position)!;\n+         // expect(isExpressionNode(node!)).toBe(true);\n+         // expect(node).toBeInstanceOf(e.BindingPipe);\n+     });\n+\n+\n   it('should locate method call', () => {\n     const {errors, nodes, position} = parse(`{{ title.toString(¦) }}`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.MethodCall);\n   });\n \n   it('should locate safe method call', () => {\n     const {errors, nodes, position} = parse(`{{ title?.toString(¦) }}`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.SafeMethodCall);\n   });\n \n   it('should locate literal primitive in interpolation', () => {\n     const {errors, nodes, position} = parse(`{{ title.indexOf('t¦') }}`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.LiteralPrimitive);\n     expect((node as e.LiteralPrimitive).value).toBe('t');\n@@ -473,7 +485,7 @@ describe('findNodeAtPosition for expression AST', () => {\n   it('should locate literal primitive in binding', () => {\n     const {errors, nodes, position} = parse(`<div [id]=\"'t¦'\"></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.LiteralPrimitive);\n     expect((node as e.LiteralPrimitive).value).toBe('t');\n@@ -482,31 +494,31 @@ describe('findNodeAtPosition for expression AST', () => {\n   it('should locate empty expression', () => {\n     const {errors, nodes, position} = parse(`<div [id]=\"¦\"></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.EmptyExpr);\n   });\n \n   it('should locate literal array', () => {\n     const {errors, nodes, position} = parse(`{{ [1, 2,¦ 3] }}`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.LiteralArray);\n   });\n \n   it('should locate literal map', () => {\n     const {errors, nodes, position} = parse(`{{ { hello:¦ \"world\" } }}`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.LiteralMap);\n   });\n \n   it('should locate conditional', () => {\n     const {errors, nodes, position} = parse(`{{ cond ?¦ true : false }}`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.Conditional);\n   });\n@@ -516,15 +528,15 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate template key', () => {\n     const {errors, nodes, position} = parse(`<div *ng¦If=\"foo\"></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n   });\n \n   it('should locate template value', () => {\n     const {errors, nodes, position} = parse(`<div *ngIf=\"f¦oo\"></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n@@ -534,23 +546,23 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n     // ngFor is a text attribute because the desugared form is\n     // <ng-template ngFor let-item [ngForOf]=\"items\">\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBeTrue();\n     expect(node).toBeInstanceOf(t.TextAttribute);\n     expect((node as t.TextAttribute).name).toBe('ngFor');\n   });\n \n-  it('should locate not let keyword', () => {\n+  it('should not locate let keyword', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"l¦et item of items\"></div>`);\n-    expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n-    expect(node).toBeUndefined();\n+    expect(errors).toBeNull();\n+    const target = getTargetAtPosition(nodes, position)!;\n+    expect(target).toBeNull();\n   });\n \n   it('should locate let variable', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let i¦tem of items\"></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);\n     expect((node as t.Variable).name).toBe('item');\n@@ -559,7 +571,7 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate bound attribute key', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let item o¦f items\"></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n     expect((node as t.BoundAttribute).name).toBe('ngForOf');\n@@ -569,7 +581,7 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n     const {errors, nodes, position} =\n         parse(`<div *ngFor=\"let item of items; trac¦kBy: trackByFn\"></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n     expect((node as t.BoundAttribute).name).toBe('ngForTrackBy');\n@@ -582,7 +594,7 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n     const {errors, nodes, position} =\n         parse(`<div *ngFor=\"let item o¦f items; trackBy: trackByFn\"></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.BoundAttribute);\n     expect((node as t.BoundAttribute).name).toBe('ngForOf');\n@@ -591,7 +603,7 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate bound attribute value', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let item of it¦ems\"></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n     expect((node as e.PropertyRead).name).toBe('items');\n@@ -600,10 +612,11 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate template children', () => {\n     const {errors, nodes, position} = parse(`<di¦v *ngIf></div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node, context} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Element);\n     expect((node as t.Element).name).toBe('div');\n+    expect(context).toBeInstanceOf(t.Template);\n   });\n \n   it('should locate property read of variable declared within template', () => {\n@@ -612,15 +625,15 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n         {{ i¦ }}\n       </div>`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isExpressionNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(e.PropertyRead);\n   });\n \n   it('should locate LHS of variable declaration', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let item of items; let i¦=index\">`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);\n     // TODO: Currently there is no way to distinguish LHS from RHS\n@@ -630,7 +643,7 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate RHS of variable declaration', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let item of items; let i=in¦dex\">`);\n     expect(errors).toBe(null);\n-    const node = findNodeAtPosition(nodes, position);\n+    const {node} = getTargetAtPosition(nodes, position)!;\n     expect(isTemplateNode(node!)).toBe(true);\n     expect(node).toBeInstanceOf(t.Variable);\n     // TODO: Currently there is no way to distinguish LHS from RHS",
            "previous_filename": "packages/language-service/ivy/test/hybrid_visitor_spec.ts"
        }
    ],
    "stats": {
        "total": 385,
        "additions": 217,
        "deletions": 168
    }
}