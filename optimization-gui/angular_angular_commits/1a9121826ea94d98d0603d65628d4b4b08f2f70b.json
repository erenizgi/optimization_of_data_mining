{
    "author": "JoostK",
    "message": "fix(compiler-cli): enable narrowing of using type guard methods (#44447)\n\nThe changes in 2028c3933f7fe2961999da475febde5a03bb694d caused method\ncalls to be emitted using additional parenthesis into the TCB, which in\nturn prevented proper type narrowing when the method acts as a type\nguard. This commit special-cases method calls from property reads to\navoid the additional parenthesis.\n\nFixes #44353\n\nPR Close #44447",
    "sha": "1a9121826ea94d98d0603d65628d4b4b08f2f70b",
    "files": [
        {
            "sha": "e7c34cfcbfb28bf25f1bd8c4c2d56915aea1236b",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/expression.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 2,
            "changes": 23,
            "blob_url": "https://github.com/angular/angular/blob/1a9121826ea94d98d0603d65628d4b4b08f2f70b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fexpression.ts",
            "raw_url": "https://github.com/angular/angular/raw/1a9121826ea94d98d0603d65628d4b4b08f2f70b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fexpression.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fexpression.ts?ref=1a9121826ea94d98d0603d65628d4b4b08f2f70b",
            "patch": "@@ -313,12 +313,31 @@ class AstTranslator implements AstVisitor {\n \n   visitCall(ast: Call): ts.Expression {\n     const args = ast.args.map(expr => this.translate(expr));\n-    const expr = wrapForDiagnostics(this.translate(ast.receiver));\n+\n+    let expr: ts.Expression;\n+    const receiver = ast.receiver;\n+\n+    // For calls that have a property read as receiver, we have to special-case their emit to avoid\n+    // inserting superfluous parenthesis as they prevent TypeScript from applying a narrowing effect\n+    // if the method acts as a type guard.\n+    if (receiver instanceof PropertyRead) {\n+      const resolved = this.maybeResolve(receiver);\n+      if (resolved !== null) {\n+        expr = resolved;\n+      } else {\n+        const propertyReceiver = wrapForDiagnostics(this.translate(receiver.receiver));\n+        expr = ts.createPropertyAccess(propertyReceiver, receiver.name);\n+        addParseSpanInfo(expr, receiver.nameSpan);\n+      }\n+    } else {\n+      expr = this.translate(receiver);\n+    }\n+\n     let node: ts.Expression;\n \n     // Safe property/keyed reads will produce a ternary whose value is nullable.\n     // We have to generate a similar ternary around the call.\n-    if (ast.receiver instanceof SafePropertyRead || ast.receiver instanceof SafeKeyedRead) {\n+    if (receiver instanceof SafePropertyRead || receiver instanceof SafeKeyedRead) {\n       if (this.config.strictSafeNavigationTypes) {\n         // \"a?.method(...)\" becomes (null as any ? a!.method(...) : undefined)\n         const call = ts.createCall(ts.createNonNullExpression(expr), undefined, args);"
        },
        {
            "sha": "59b1a524fba9cf39f26b1208fa2338a0be6b5093",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/diagnostics_spec.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 1,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/1a9121826ea94d98d0603d65628d4b4b08f2f70b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fdiagnostics_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/1a9121826ea94d98d0603d65628d4b4b08f2f70b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fdiagnostics_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fdiagnostics_spec.ts?ref=1a9121826ea94d98d0603d65628d4b4b08f2f70b",
            "patch": "@@ -11,7 +11,7 @@ import ts from 'typescript';\n import {absoluteFrom, getSourceFileOrError} from '../../file_system';\n import {runInEachFileSystem, TestFile} from '../../file_system/testing';\n import {OptimizeFor, TypeCheckingConfig} from '../api';\n-import {ngForDeclaration, ngForDts, setup, TestDeclaration} from '../testing';\n+import {ngForDeclaration, ngForDts, ngIfDeclaration, ngIfDts, setup, TestDeclaration} from '../testing';\n \n runInEachFileSystem(() => {\n   describe('template diagnostics', () => {\n@@ -339,6 +339,17 @@ runInEachFileSystem(() => {\n       ]);\n     });\n \n+    it('should support type-narrowing for methods with type guards', () => {\n+      const messages = diagnose(\n+          `<div *ngIf=\"hasSuccess()\">{{ success }}</div>`, `\n+          class TestComponent {\n+            hasSuccess(): this is { success: boolean };\n+          }`,\n+          [ngIfDeclaration()], [ngIfDts()]);\n+\n+      expect(messages).toEqual([]);\n+    });\n+\n     describe('outputs', () => {\n       it('should produce a diagnostic for directive outputs', () => {\n         const messages = diagnose("
        },
        {
            "sha": "808e7092c2a6a33aff9e0a6bc95681fc4f2ce114",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/span_comments_spec.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/1a9121826ea94d98d0603d65628d4b4b08f2f70b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fspan_comments_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/1a9121826ea94d98d0603d65628d4b4b08f2f70b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fspan_comments_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fspan_comments_spec.ts?ref=1a9121826ea94d98d0603d65628d4b4b08f2f70b",
            "patch": "@@ -39,7 +39,7 @@ describe('type check blocks diagnostics', () => {\n       const TEMPLATE = '{{ m({foo: a, bar: b}) }}';\n       expect(tcbWithSpans(TEMPLATE))\n           .toContain(\n-              '((((ctx).m /*3,4*/) /*3,4*/)({ \"foo\": ((ctx).a /*11,12*/) /*11,12*/, \"bar\": ((ctx).b /*19,20*/) /*19,20*/ } /*5,21*/) /*3,22*/)');\n+              '(ctx).m /*3,4*/({ \"foo\": ((ctx).a /*11,12*/) /*11,12*/, \"bar\": ((ctx).b /*19,20*/) /*19,20*/ } /*5,21*/) /*3,22*/');\n     });\n \n     it('should annotate literal map expressions with shorthand declarations', () => {\n@@ -48,7 +48,7 @@ describe('type check blocks diagnostics', () => {\n       const TEMPLATE = '{{ m({a, b}) }}';\n       expect(tcbWithSpans(TEMPLATE))\n           .toContain(\n-              '((((ctx).m /*3,4*/) /*3,4*/)({ \"a\": ((ctx).a /*6,7*/) /*6,7*/, \"b\": ((ctx).b /*9,10*/) /*9,10*/ } /*5,11*/) /*3,12*/)');\n+              '((ctx).m /*3,4*/({ \"a\": ((ctx).a /*6,7*/) /*6,7*/, \"b\": ((ctx).b /*9,10*/) /*9,10*/ } /*5,11*/) /*3,12*/)');\n     });\n \n     it('should annotate literal array expressions', () => {\n@@ -76,21 +76,21 @@ describe('type check blocks diagnostics', () => {\n       const TEMPLATE = `{{ method(a, b) }}`;\n       expect(tcbWithSpans(TEMPLATE))\n           .toContain(\n-              '((((ctx).method /*3,9*/) /*3,9*/)(((ctx).a /*10,11*/) /*10,11*/, ((ctx).b /*13,14*/) /*13,14*/) /*3,15*/)');\n+              '(ctx).method /*3,9*/(((ctx).a /*10,11*/) /*10,11*/, ((ctx).b /*13,14*/) /*13,14*/) /*3,15*/');\n     });\n \n     it('should annotate method calls of variables', () => {\n       const TEMPLATE = `<ng-template let-method>{{ method(a, b) }}</ng-template>`;\n       expect(tcbWithSpans(TEMPLATE))\n           .toContain(\n-              '((_t2 /*27,33*/)(((ctx).a /*34,35*/) /*34,35*/, ((ctx).b /*37,38*/) /*37,38*/) /*27,39*/)');\n+              '_t2 /*27,33*/(((ctx).a /*34,35*/) /*34,35*/, ((ctx).b /*37,38*/) /*37,38*/) /*27,39*/');\n     });\n \n     it('should annotate function calls', () => {\n       const TEMPLATE = `{{ method(a)(b, c) }}`;\n       expect(tcbWithSpans(TEMPLATE))\n           .toContain(\n-              '(((((ctx).method /*3,9*/) /*3,9*/)(((ctx).a /*10,11*/) /*10,11*/) /*3,12*/)(((ctx).b /*13,14*/) /*13,14*/, ((ctx).c /*16,17*/) /*16,17*/) /*3,18*/)');\n+              '(ctx).method /*3,9*/(((ctx).a /*10,11*/) /*10,11*/) /*3,12*/(((ctx).b /*13,14*/) /*13,14*/, ((ctx).c /*16,17*/) /*16,17*/) /*3,18*/');\n     });\n \n     it('should annotate property access', () => {\n@@ -135,7 +135,7 @@ describe('type check blocks diagnostics', () => {\n       const TEMPLATE = `{{ a?.method(b) }}`;\n       expect(tcbWithSpans(TEMPLATE))\n           .toContain(\n-              '((null as any ? ((null as any ? (((ctx).a /*3,4*/) /*3,4*/)!.method /*6,12*/ : undefined) /*3,12*/)!(((ctx).b /*13,14*/) /*13,14*/) : undefined) /*3,15*/)');\n+              '((null as any ? (null as any ? (((ctx).a /*3,4*/) /*3,4*/)!.method /*6,12*/ : undefined) /*3,12*/!(((ctx).b /*13,14*/) /*13,14*/) : undefined) /*3,15*/)');\n     });\n \n     it('should annotate safe keyed reads', () => {"
        },
        {
            "sha": "7c22f3841e77e2c550a771ce431a3b0e385eb7cd",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_check_block_spec.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 31,
            "changes": 60,
            "blob_url": "https://github.com/angular/angular/blob/1a9121826ea94d98d0603d65628d4b4b08f2f70b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/1a9121826ea94d98d0603d65628d4b4b08f2f70b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts?ref=1a9121826ea94d98d0603d65628d4b4b08f2f70b",
            "patch": "@@ -20,12 +20,12 @@ describe('type check blocks', () => {\n \n   it('should generate literal map expressions', () => {\n     const TEMPLATE = '{{ method({foo: a, bar: b}) }}';\n-    expect(tcb(TEMPLATE)).toContain('(((ctx).method))({ \"foo\": ((ctx).a), \"bar\": ((ctx).b) })');\n+    expect(tcb(TEMPLATE)).toContain('(ctx).method({ \"foo\": ((ctx).a), \"bar\": ((ctx).b) })');\n   });\n \n   it('should generate literal array expressions', () => {\n     const TEMPLATE = '{{ method([a, b]) }}';\n-    expect(tcb(TEMPLATE)).toContain('(((ctx).method))([((ctx).a), ((ctx).b)])');\n+    expect(tcb(TEMPLATE)).toContain('(ctx).method([((ctx).a), ((ctx).b)])');\n   });\n \n   it('should handle non-null assertions', () => {\n@@ -115,7 +115,7 @@ describe('type check blocks', () => {\n   it('should handle method calls of template variables', () => {\n     const TEMPLATE = `<ng-template let-a>{{a(1)}}</ng-template>`;\n     expect(tcb(TEMPLATE)).toContain('var _t2 = _t1.$implicit;');\n-    expect(tcb(TEMPLATE)).toContain('(_t2)(1)');\n+    expect(tcb(TEMPLATE)).toContain('_t2(1)');\n   });\n \n   it('should handle implicit vars when using microsyntax', () => {\n@@ -126,7 +126,7 @@ describe('type check blocks', () => {\n   it('should handle direct calls of an implicit template variable', () => {\n     const TEMPLATE = `<div *ngFor=\"let a of letters\">{{a(1)}}</div>`;\n     expect(tcb(TEMPLATE)).toContain('var _t2 = _t1.$implicit;');\n-    expect(tcb(TEMPLATE)).toContain('(_t2)(1)');\n+    expect(tcb(TEMPLATE)).toContain('_t2(1)');\n   });\n \n   describe('type constructors', () => {\n@@ -609,13 +609,13 @@ describe('type check blocks', () => {\n   it('should handle $any accessed through `this`', () => {\n     const TEMPLATE = `{{this.$any(a)}}`;\n     const block = tcb(TEMPLATE);\n-    expect(block).toContain('((((ctx).$any))(((ctx).a)))');\n+    expect(block).toContain('((ctx).$any(((ctx).a)))');\n   });\n \n   it('should handle $any accessed through a property read', () => {\n     const TEMPLATE = `{{foo.$any(a)}}`;\n     const block = tcb(TEMPLATE);\n-    expect(block).toContain('((((((ctx).foo)).$any))(((ctx).a)))');\n+    expect(block).toContain('((((ctx).foo)).$any(((ctx).a)))');\n   });\n \n   describe('experimental DOM checking via lib.dom.d.ts', () => {\n@@ -688,28 +688,27 @@ describe('type check blocks', () => {\n       const TEMPLATE = `<div dir (dirOutput)=\"foo($event)\"></div>`;\n       const block = tcb(TEMPLATE, DIRECTIVES);\n       expect(block).toContain(\n-          '_t1[\"outputField\"].subscribe(function ($event): any { (((ctx).foo))($event); });');\n+          '_t1[\"outputField\"].subscribe(function ($event): any { (ctx).foo($event); });');\n     });\n \n     it('should emit a listener function with AnimationEvent for animation events', () => {\n       const TEMPLATE = `<div (@animation.done)=\"foo($event)\"></div>`;\n       const block = tcb(TEMPLATE);\n-      expect(block).toContain(\n-          'function ($event: i1.AnimationEvent): any { (((ctx).foo))($event); }');\n+      expect(block).toContain('function ($event: i1.AnimationEvent): any { (ctx).foo($event); }');\n     });\n \n     it('should emit addEventListener calls for unclaimed outputs', () => {\n       const TEMPLATE = `<div (event)=\"foo($event)\"></div>`;\n       const block = tcb(TEMPLATE);\n       expect(block).toContain(\n-          '_t1.addEventListener(\"event\", function ($event): any { (((ctx).foo))($event); });');\n+          '_t1.addEventListener(\"event\", function ($event): any { (ctx).foo($event); });');\n     });\n \n     it('should allow to cast $event using $any', () => {\n       const TEMPLATE = `<div (event)=\"foo($any($event))\"></div>`;\n       const block = tcb(TEMPLATE);\n       expect(block).toContain(\n-          '_t1.addEventListener(\"event\", function ($event): any { (((ctx).foo))(($event as any)); });');\n+          '_t1.addEventListener(\"event\", function ($event): any { (ctx).foo(($event as any)); });');\n     });\n \n     it('should detect writes to template variables', () => {\n@@ -724,7 +723,7 @@ describe('type check blocks', () => {\n       const block = tcb(TEMPLATE);\n \n       expect(block).toContain(\n-          '_t1.addEventListener(\"event\", function ($event): any { (((ctx).foo))(((ctx).$event)); });');\n+          '_t1.addEventListener(\"event\", function ($event): any { (ctx).foo(((ctx).$event)); });');\n     });\n   });\n \n@@ -852,18 +851,18 @@ describe('type check blocks', () => {\n       it('should check types of directive outputs when enabled', () => {\n         const block = tcb(TEMPLATE, DIRECTIVES);\n         expect(block).toContain(\n-            '_t1[\"outputField\"].subscribe(function ($event): any { (((ctx).foo))($event); });');\n+            '_t1[\"outputField\"].subscribe(function ($event): any { (ctx).foo($event); });');\n         expect(block).toContain(\n-            '_t2.addEventListener(\"nonDirOutput\", function ($event): any { (((ctx).foo))($event); });');\n+            '_t2.addEventListener(\"nonDirOutput\", function ($event): any { (ctx).foo($event); });');\n       });\n       it('should not check types of directive outputs when disabled', () => {\n         const DISABLED_CONFIG:\n             TypeCheckingConfig = {...BASE_CONFIG, checkTypeOfOutputEvents: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n-        expect(block).toContain('function ($event: any): any { (((ctx).foo))($event); }');\n+        expect(block).toContain('function ($event: any): any { (ctx).foo($event); }');\n         // Note that DOM events are still checked, that is controlled by `checkTypeOfDomEvents`\n         expect(block).toContain(\n-            'addEventListener(\"nonDirOutput\", function ($event): any { (((ctx).foo))($event); });');\n+            'addEventListener(\"nonDirOutput\", function ($event): any { (ctx).foo($event); });');\n       });\n     });\n \n@@ -872,14 +871,13 @@ describe('type check blocks', () => {\n \n       it('should check types of animation events when enabled', () => {\n         const block = tcb(TEMPLATE, DIRECTIVES);\n-        expect(block).toContain(\n-            'function ($event: i1.AnimationEvent): any { (((ctx).foo))($event); }');\n+        expect(block).toContain('function ($event: i1.AnimationEvent): any { (ctx).foo($event); }');\n       });\n       it('should not check types of animation events when disabled', () => {\n         const DISABLED_CONFIG:\n             TypeCheckingConfig = {...BASE_CONFIG, checkTypeOfAnimationEvents: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n-        expect(block).toContain('function ($event: any): any { (((ctx).foo))($event); }');\n+        expect(block).toContain('function ($event: any): any { (ctx).foo($event); }');\n       });\n     });\n \n@@ -889,18 +887,18 @@ describe('type check blocks', () => {\n       it('should check types of DOM events when enabled', () => {\n         const block = tcb(TEMPLATE, DIRECTIVES);\n         expect(block).toContain(\n-            '_t1[\"outputField\"].subscribe(function ($event): any { (((ctx).foo))($event); });');\n+            '_t1[\"outputField\"].subscribe(function ($event): any { (ctx).foo($event); });');\n         expect(block).toContain(\n-            '_t2.addEventListener(\"nonDirOutput\", function ($event): any { (((ctx).foo))($event); });');\n+            '_t2.addEventListener(\"nonDirOutput\", function ($event): any { (ctx).foo($event); });');\n       });\n       it('should not check types of DOM events when disabled', () => {\n         const DISABLED_CONFIG: TypeCheckingConfig = {...BASE_CONFIG, checkTypeOfDomEvents: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n         // Note that directive outputs are still checked, that is controlled by\n         // `checkTypeOfOutputEvents`\n         expect(block).toContain(\n-            '_t1[\"outputField\"].subscribe(function ($event): any { (((ctx).foo))($event); });');\n-        expect(block).toContain('function ($event: any): any { (((ctx).foo))($event); }');\n+            '_t1[\"outputField\"].subscribe(function ($event): any { (ctx).foo($event); });');\n+        expect(block).toContain('function ($event: any): any { (ctx).foo($event); }');\n       });\n     });\n \n@@ -1009,15 +1007,15 @@ describe('type check blocks', () => {\n       it('should use undefined for safe navigation operations when enabled', () => {\n         const block = tcb(TEMPLATE, DIRECTIVES);\n         expect(block).toContain(\n-            '(null as any ? ((null as any ? (((ctx).a))!.method : undefined))!() : undefined)');\n+            '(null as any ? (null as any ? (((ctx).a))!.method : undefined)!() : undefined)');\n         expect(block).toContain('(null as any ? (((ctx).a))!.b : undefined)');\n         expect(block).toContain('(null as any ? (((ctx).a))![0] : undefined)');\n       });\n       it('should use an \\'any\\' type for safe navigation operations when disabled', () => {\n         const DISABLED_CONFIG:\n             TypeCheckingConfig = {...BASE_CONFIG, strictSafeNavigationTypes: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n-        expect(block).toContain('(((((((ctx).a))!.method as any)) as any)())');\n+        expect(block).toContain('((((((ctx).a))!.method as any) as any)())');\n         expect(block).toContain('((((ctx).a))!.b as any)');\n         expect(block).toContain('(((((ctx).a))![0] as any)');\n       });\n@@ -1027,18 +1025,18 @@ describe('type check blocks', () => {\n       const TEMPLATE = `{{a.method()?.b}} {{a()?.method()}} {{a.method()?.[0]}}`;\n       it('should check the presence of a property/method on the receiver when enabled', () => {\n         const block = tcb(TEMPLATE, DIRECTIVES);\n-        expect(block).toContain('(null as any ? ((((((ctx).a)).method))())!.b : undefined)');\n+        expect(block).toContain('(null as any ? ((((ctx).a)).method())!.b : undefined)');\n         expect(block).toContain(\n-            '(null as any ? ((null as any ? ((((ctx).a))())!.method : undefined))!() : undefined)');\n-        expect(block).toContain('(null as any ? ((((((ctx).a)).method))())![0] : undefined)');\n+            '(null as any ? (null as any ? ((ctx).a())!.method : undefined)!() : undefined)');\n+        expect(block).toContain('(null as any ? ((((ctx).a)).method())![0] : undefined)');\n       });\n       it('should not check the presence of a property/method on the receiver when disabled', () => {\n         const DISABLED_CONFIG:\n             TypeCheckingConfig = {...BASE_CONFIG, strictSafeNavigationTypes: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n-        expect(block).toContain('((((((((ctx).a)).method))()) as any).b)');\n-        expect(block).toContain('((((((((ctx).a))()) as any).method) as any)())');\n-        expect(block).toContain('((((((((ctx).a)).method))()) as any)[0])');\n+        expect(block).toContain('(((((ctx).a)).method()) as any).b');\n+        expect(block).toContain('(((((ctx).a()) as any).method as any)())');\n+        expect(block).toContain('(((((ctx).a)).method()) as any)[0]');\n       });\n     });\n "
        },
        {
            "sha": "9f973d8857217a526502d542aafa50ef9a550f89",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/testing/index.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/angular/angular/blob/1a9121826ea94d98d0603d65628d4b4b08f2f70b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftesting%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/1a9121826ea94d98d0603d65628d4b4b08f2f70b/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftesting%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftesting%2Findex.ts?ref=1a9121826ea94d98d0603d65628d4b4b08f2f70b",
            "patch": "@@ -120,6 +120,35 @@ export function angularAnimationsDts(): TestFile {\n   };\n }\n \n+export function ngIfDeclaration(): TestDeclaration {\n+  return {\n+    type: 'directive',\n+    file: absoluteFrom('/ngif.d.ts'),\n+    selector: '[ngIf]',\n+    name: 'NgIf',\n+    inputs: {ngIf: 'ngIf'},\n+    ngTemplateGuards: [{type: 'binding', inputName: 'ngIf'}],\n+    hasNgTemplateContextGuard: true,\n+    isGeneric: true,\n+  };\n+}\n+\n+export function ngIfDts(): TestFile {\n+  return {\n+    name: absoluteFrom('/ngif.d.ts'),\n+    contents: `\n+    export declare class NgIf<T> {\n+      ngIf: T;\n+      static ngTemplateContextGuard<T>(dir: NgIf<T>, ctx: any): ctx is NgIfContext<Exclude<T, false|0|''|null|undefined>>\n+    }\n+\n+    export declare class NgIfContext<T> {\n+      $implicit: T;\n+      ngIf: T;\n+    }`,\n+  };\n+}\n+\n export function ngForDeclaration(): TestDeclaration {\n   return {\n     type: 'directive',"
        }
    ],
    "stats": {
        "total": 137,
        "additions": 97,
        "deletions": 40
    }
}