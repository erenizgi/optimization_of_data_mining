{
    "author": "petebacondarwin",
    "message": "refactor(compiler): capture interpolation source-spans in expression parser (#38645)\n\nThe expression parser will split the expression up at the interpolation markers\ninto expressions and static strings. This commit also captures the positions of\nthese strings in the expression to be used in source-mapping later.\n\nPR Close #38645",
    "sha": "bf31ef29f65f2654218b55608c0f9be26d5d5481",
    "files": [
        {
            "sha": "090e2361351843609a011adce9f3e22d17ad3f4f",
            "filename": "packages/compiler/src/expression_parser/parser.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 2,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/bf31ef29f65f2654218b55608c0f9be26d5d5481/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf31ef29f65f2654218b55608c0f9be26d5d5481/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts?ref=bf31ef29f65f2654218b55608c0f9be26d5d5481",
            "patch": "@@ -14,7 +14,10 @@ import {AbsoluteSourceSpan, AST, AstVisitor, ASTWithSource, Binary, BindingPipe,\n import {EOF, isIdentifier, isQuote, Lexer, Token, TokenType} from './lexer';\n \n export class SplitInterpolation {\n-  constructor(public strings: string[], public expressions: string[], public offsets: number[]) {}\n+  constructor(\n+      public strings: string[], public stringSpans: {start: number, end: number}[],\n+      public expressions: string[], public expressionsSpans: {start: number, end: number}[],\n+      public offsets: number[]) {}\n }\n \n export class TemplateBindingParseResult {\n@@ -194,28 +197,35 @@ export class Parser {\n     const strings: string[] = [];\n     const expressions: string[] = [];\n     const offsets: number[] = [];\n+    const stringSpans: {start: number, end: number}[] = [];\n+    const expressionSpans: {start: number, end: number}[] = [];\n     let offset = 0;\n     for (let i = 0; i < parts.length; i++) {\n       const part: string = parts[i];\n       if (i % 2 === 0) {\n         // fixed string\n         strings.push(part);\n+        const start = offset;\n         offset += part.length;\n+        stringSpans.push({start, end: offset});\n       } else if (part.trim().length > 0) {\n+        const start = offset;\n         offset += interpolationConfig.start.length;\n         expressions.push(part);\n         offsets.push(offset);\n         offset += part.length + interpolationConfig.end.length;\n+        expressionSpans.push({start, end: offset});\n       } else {\n         this._reportError(\n             'Blank expressions are not allowed in interpolated strings', input,\n             `at column ${this._findInterpolationErrorColumn(parts, i, interpolationConfig)} in`,\n             location);\n         expressions.push('$implicit');\n         offsets.push(offset);\n+        expressionSpans.push({start: offset, end: offset});\n       }\n     }\n-    return new SplitInterpolation(strings, expressions, offsets);\n+    return new SplitInterpolation(strings, stringSpans, expressions, expressionSpans, offsets);\n   }\n \n   wrapLiteralPrimitive(input: string|null, location: any, absoluteOffset: number): ASTWithSource {"
        }
    ],
    "stats": {
        "total": 14,
        "additions": 12,
        "deletions": 2
    }
}