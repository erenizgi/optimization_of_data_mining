{
    "author": "JoostK",
    "message": "fix(compiler-cli): enable @types discovery in incremental rebuilds (#39011)\n\nPrior to this fix, incremental rebuilds could fail to type check due to\nmissing ambient types from auto-discovered declaration files in @types\ndirectories, or type roots in general. This was caused by the\nintermediary `ts.Program` that is created for template type checking,\nfor which a `ts.CompilerHost` was used which did not implement the\noptional `directoryExists` methods. As a result, auto-discovery of types\nwould not be working correctly, and this would retain into the\n`ts.Program` that would be created for an incremental rebuild.\n\nThis commit fixes the issue by forcing the custom `ts.CompilerHost` used\nfor type checking to properly delegate into the original\n`ts.CompilerHost`, even for optional methods. This is accomplished using\na base class `DelegatingCompilerHost` which is typed in such a way that\nnewly introduced `ts.CompilerHost` methods must be accounted for.\n\nFixes #38979\n\nPR Close #39011",
    "sha": "e9a8f9f705fdd79697602bd4e132369d5bf3bdde",
    "files": [
        {
            "sha": "d7283890c1de91a13b6c0252daf89bd1df3e1e5f",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/host.ts",
            "status": "modified",
            "additions": 52,
            "deletions": 44,
            "changes": 96,
            "blob_url": "https://github.com/angular/angular/blob/e9a8f9f705fdd79697602bd4e132369d5bf3bdde/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fhost.ts",
            "raw_url": "https://github.com/angular/angular/raw/e9a8f9f705fdd79697602bd4e132369d5bf3bdde/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fhost.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fhost.ts?ref=e9a8f9f705fdd79697602bd4e132369d5bf3bdde",
            "patch": "@@ -10,11 +10,59 @@ import * as ts from 'typescript';\n \n import {copyFileShimData, ShimReferenceTagger} from '../../shims';\n \n+/**\n+ * Represents the `ts.CompilerHost` interface, with a transformation applied that turns all\n+ * methods (even optional ones) into required fields (which may be `undefined`, if the method was\n+ * optional).\n+ */\n+export type RequiredCompilerHostDelegations = {\n+  [M in keyof Required<ts.CompilerHost>]: ts.CompilerHost[M];\n+};\n+\n+/**\n+ * Delegates all methods of `ts.CompilerHost` to a delegate, with the exception of\n+ * `getSourceFile`, `fileExists` and `writeFile` which are implemented in `TypeCheckProgramHost`.\n+ *\n+ * If a new method is added to `ts.CompilerHost` which is not delegated, a type error will be\n+ * generated for this class.\n+ */\n+export class DelegatingCompilerHost implements\n+    Omit<RequiredCompilerHostDelegations, 'getSourceFile'|'fileExists'|'writeFile'> {\n+  constructor(protected delegate: ts.CompilerHost) {}\n+\n+  private delegateMethod<M extends keyof ts.CompilerHost>(name: M): ts.CompilerHost[M] {\n+    return this.delegate[name] !== undefined ? (this.delegate[name] as any).bind(this.delegate) :\n+                                               undefined;\n+  }\n+\n+  // Excluded are 'getSourceFile', 'fileExists' and 'writeFile', which are actually implemented by\n+  // `TypeCheckProgramHost` below.\n+  createHash = this.delegateMethod('createHash');\n+  directoryExists = this.delegateMethod('directoryExists');\n+  getCancellationToken = this.delegateMethod('getCancellationToken');\n+  getCanonicalFileName = this.delegateMethod('getCanonicalFileName');\n+  getCurrentDirectory = this.delegateMethod('getCurrentDirectory');\n+  getDefaultLibFileName = this.delegateMethod('getDefaultLibFileName');\n+  getDefaultLibLocation = this.delegateMethod('getDefaultLibLocation');\n+  getDirectories = this.delegateMethod('getDirectories');\n+  getEnvironmentVariable = this.delegateMethod('getEnvironmentVariable');\n+  getNewLine = this.delegateMethod('getNewLine');\n+  getParsedCommandLine = this.delegateMethod('getParsedCommandLine');\n+  getSourceFileByPath = this.delegateMethod('getSourceFileByPath');\n+  readDirectory = this.delegateMethod('readDirectory');\n+  readFile = this.delegateMethod('readFile');\n+  realpath = this.delegateMethod('realpath');\n+  resolveModuleNames = this.delegateMethod('resolveModuleNames');\n+  resolveTypeReferenceDirectives = this.delegateMethod('resolveTypeReferenceDirectives');\n+  trace = this.delegateMethod('trace');\n+  useCaseSensitiveFileNames = this.delegateMethod('useCaseSensitiveFileNames');\n+}\n+\n /**\n  * A `ts.CompilerHost` which augments source files with type checking code from a\n  * `TypeCheckContext`.\n  */\n-export class TypeCheckProgramHost implements ts.CompilerHost {\n+export class TypeCheckProgramHost extends DelegatingCompilerHost {\n   /**\n    * Map of source file names to `ts.SourceFile` instances.\n    */\n@@ -32,20 +80,11 @@ export class TypeCheckProgramHost implements ts.CompilerHost {\n    */\n   private shimTagger = new ShimReferenceTagger(this.shimExtensionPrefixes);\n \n-  readonly resolveModuleNames?: ts.CompilerHost['resolveModuleNames'];\n-\n   constructor(\n       sfMap: Map<string, ts.SourceFile>, private originalProgram: ts.Program,\n-      private delegate: ts.CompilerHost, private shimExtensionPrefixes: string[]) {\n+      delegate: ts.CompilerHost, private shimExtensionPrefixes: string[]) {\n+    super(delegate);\n     this.sfMap = sfMap;\n-\n-    if (delegate.getDirectories !== undefined) {\n-      this.getDirectories = (path: string) => delegate.getDirectories!(path);\n-    }\n-\n-    if (delegate.resolveModuleNames !== undefined) {\n-      this.resolveModuleNames = delegate.resolveModuleNames;\n-    }\n   }\n \n   getSourceFile(\n@@ -88,42 +127,11 @@ export class TypeCheckProgramHost implements ts.CompilerHost {\n     this.shimTagger.finalize();\n   }\n \n-  // The rest of the methods simply delegate to the underlying `ts.CompilerHost`.\n-\n-  getDefaultLibFileName(options: ts.CompilerOptions): string {\n-    return this.delegate.getDefaultLibFileName(options);\n-  }\n-\n-  writeFile(\n-      fileName: string, data: string, writeByteOrderMark: boolean,\n-      onError: ((message: string) => void)|undefined,\n-      sourceFiles: ReadonlyArray<ts.SourceFile>|undefined): void {\n+  writeFile(): never {\n     throw new Error(`TypeCheckProgramHost should never write files`);\n   }\n \n-  getCurrentDirectory(): string {\n-    return this.delegate.getCurrentDirectory();\n-  }\n-\n-  getDirectories?: (path: string) => string[];\n-\n-  getCanonicalFileName(fileName: string): string {\n-    return this.delegate.getCanonicalFileName(fileName);\n-  }\n-\n-  useCaseSensitiveFileNames(): boolean {\n-    return this.delegate.useCaseSensitiveFileNames();\n-  }\n-\n-  getNewLine(): string {\n-    return this.delegate.getNewLine();\n-  }\n-\n   fileExists(fileName: string): boolean {\n     return this.sfMap.has(fileName) || this.delegate.fileExists(fileName);\n   }\n-\n-  readFile(fileName: string): string|undefined {\n-    return this.delegate.readFile(fileName);\n-  }\n }"
        },
        {
            "sha": "a7fd2024f92bb913796227129736dc2d061d9008",
            "filename": "packages/compiler-cli/test/ngtsc/incremental_spec.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/e9a8f9f705fdd79697602bd4e132369d5bf3bdde/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fincremental_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e9a8f9f705fdd79697602bd4e132369d5bf3bdde/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fincremental_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fincremental_spec.ts?ref=e9a8f9f705fdd79697602bd4e132369d5bf3bdde",
            "patch": "@@ -442,6 +442,27 @@ runInEachFileSystem(() => {\n       // https://github.com/angular/angular/issues/30079), this would have crashed.\n     });\n \n+    // https://github.com/angular/angular/issues/38979\n+    it('should retain ambient types provided by auto-discovered @types', () => {\n+      // This test verifies that ambient types declared in node_modules/@types are still available\n+      // in incremental compilations. In the below code, the usage of `require` should be valid\n+      // in the original program and the incremental program.\n+      env.tsconfig({fullTemplateTypeCheck: true});\n+      env.write('node_modules/@types/node/index.d.ts', 'declare var require: any;');\n+      env.write('main.ts', `\n+        import {Component} from '@angular/core';\n+\n+        require('path');\n+\n+        @Component({template: ''})\n+        export class MyComponent {}\n+      `);\n+      env.driveMain();\n+      env.invalidateCachedFile('main.ts');\n+      const diags = env.driveDiagnostics();\n+      expect(diags.length).toBe(0);\n+    });\n+\n     // https://github.com/angular/angular/pull/26036\n     it('should handle redirected source files', () => {\n       env.tsconfig({fullTemplateTypeCheck: true});"
        }
    ],
    "stats": {
        "total": 117,
        "additions": 73,
        "deletions": 44
    }
}