{
    "author": "gkalpak",
    "message": "refactor(upgrade): remove unused variables (#40045)\n\nThis commit removes a couple of unused variables.\n\nPR Close #40045",
    "sha": "61376d5a6ea6f4329d0d520e8f5de411b6362e06",
    "files": [
        {
            "sha": "0008620b12ff1ad0a2e27739c6149d2f198c2fcd",
            "filename": "packages/upgrade/src/dynamic/src/upgrade_adapter.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/61376d5a6ea6f4329d0d520e8f5de411b6362e06/packages%2Fupgrade%2Fsrc%2Fdynamic%2Fsrc%2Fupgrade_adapter.ts",
            "raw_url": "https://github.com/angular/angular/raw/61376d5a6ea6f4329d0d520e8f5de411b6362e06/packages%2Fupgrade%2Fsrc%2Fdynamic%2Fsrc%2Fupgrade_adapter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fupgrade%2Fsrc%2Fdynamic%2Fsrc%2Fupgrade_adapter.ts?ref=61376d5a6ea6f4329d0d520e8f5de411b6362e06",
            "patch": "@@ -505,7 +505,6 @@ export class UpgradeAdapter {\n     const delayApplyExps: Function[] = [];\n     let original$applyFn: Function;\n     let rootScopePrototype: any;\n-    let rootScope: IRootScopeService;\n     const upgradeAdapter = this;\n     const ng1Module = this.ng1Module = angularModule(this.idPrefix, modules);\n     const platformRef = platformBrowserDynamic();\n@@ -533,7 +532,7 @@ export class UpgradeAdapter {\n                 } else {\n                   throw new Error('Failed to find \\'$apply\\' on \\'$rootScope\\'!');\n                 }\n-                return rootScope = rootScopeDelegate;\n+                return rootScopeDelegate;\n               }\n             ]);\n             if (ng1Injector.has($$TESTABILITY)) {"
        },
        {
            "sha": "b3e32bc9861c3079efcc8db2f980af0b069e59f4",
            "filename": "packages/upgrade/static/src/upgrade_module.ts",
            "status": "modified",
            "additions": 86,
            "deletions": 89,
            "changes": 175,
            "blob_url": "https://github.com/angular/angular/blob/61376d5a6ea6f4329d0d520e8f5de411b6362e06/packages%2Fupgrade%2Fstatic%2Fsrc%2Fupgrade_module.ts",
            "raw_url": "https://github.com/angular/angular/raw/61376d5a6ea6f4329d0d520e8f5de411b6362e06/packages%2Fupgrade%2Fstatic%2Fsrc%2Fupgrade_module.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fupgrade%2Fstatic%2Fsrc%2Fupgrade_module.ts?ref=61376d5a6ea6f4329d0d520e8f5de411b6362e06",
            "patch": "@@ -170,111 +170,108 @@ export class UpgradeModule {\n     const INIT_MODULE_NAME = UPGRADE_MODULE_NAME + '.init';\n \n     // Create an ng1 module to bootstrap\n-    const initModule =\n-        angularModule(INIT_MODULE_NAME, [])\n+    angularModule(INIT_MODULE_NAME, [])\n \n-            .constant(UPGRADE_APP_TYPE_KEY, UpgradeAppType.Static)\n+        .constant(UPGRADE_APP_TYPE_KEY, UpgradeAppType.Static)\n \n-            .value(INJECTOR_KEY, this.injector)\n+        .value(INJECTOR_KEY, this.injector)\n \n-            .factory(\n-                LAZY_MODULE_REF,\n-                [INJECTOR_KEY, (injector: Injector) => ({injector} as LazyModuleRef)])\n+        .factory(\n+            LAZY_MODULE_REF, [INJECTOR_KEY, (injector: Injector) => ({injector} as LazyModuleRef)])\n \n-            .config([\n-              $PROVIDE, $INJECTOR,\n-              ($provide: IProvideService, $injector: IInjectorService) => {\n-                if ($injector.has($$TESTABILITY)) {\n-                  $provide.decorator($$TESTABILITY, [\n-                    $DELEGATE,\n-                    (testabilityDelegate: ITestabilityService) => {\n-                      const originalWhenStable: Function = testabilityDelegate.whenStable;\n-                      const injector = this.injector;\n-                      // Cannot use arrow function below because we need the context\n-                      const newWhenStable = function(callback: Function) {\n-                        originalWhenStable.call(testabilityDelegate, function() {\n-                          const ng2Testability: Testability = injector.get(Testability);\n-                          if (ng2Testability.isStable()) {\n-                            callback();\n-                          } else {\n-                            ng2Testability.whenStable(\n-                                newWhenStable.bind(testabilityDelegate, callback));\n-                          }\n-                        });\n-                      };\n+        .config([\n+          $PROVIDE, $INJECTOR,\n+          ($provide: IProvideService, $injector: IInjectorService) => {\n+            if ($injector.has($$TESTABILITY)) {\n+              $provide.decorator($$TESTABILITY, [\n+                $DELEGATE,\n+                (testabilityDelegate: ITestabilityService) => {\n+                  const originalWhenStable: Function = testabilityDelegate.whenStable;\n+                  const injector = this.injector;\n+                  // Cannot use arrow function below because we need the context\n+                  const newWhenStable = function(callback: Function) {\n+                    originalWhenStable.call(testabilityDelegate, function() {\n+                      const ng2Testability: Testability = injector.get(Testability);\n+                      if (ng2Testability.isStable()) {\n+                        callback();\n+                      } else {\n+                        ng2Testability.whenStable(\n+                            newWhenStable.bind(testabilityDelegate, callback));\n+                      }\n+                    });\n+                  };\n \n-                      testabilityDelegate.whenStable = newWhenStable;\n-                      return testabilityDelegate;\n-                    }\n-                  ]);\n+                  testabilityDelegate.whenStable = newWhenStable;\n+                  return testabilityDelegate;\n                 }\n+              ]);\n+            }\n \n-                if ($injector.has($INTERVAL)) {\n-                  $provide.decorator($INTERVAL, [\n-                    $DELEGATE,\n-                    (intervalDelegate: IIntervalService) => {\n-                      // Wrap the $interval service so that setInterval is called outside NgZone,\n-                      // but the callback is still invoked within it. This is so that $interval\n-                      // won't block stability, which preserves the behavior from AngularJS.\n-                      let wrappedInterval =\n-                          (fn: Function, delay: number, count?: number, invokeApply?: boolean,\n-                           ...pass: any[]) => {\n-                            return this.ngZone.runOutsideAngular(() => {\n-                              return intervalDelegate((...args: any[]) => {\n-                                // Run callback in the next VM turn - $interval calls\n-                                // $rootScope.$apply, and running the callback in NgZone will\n-                                // cause a '$digest already in progress' error if it's in the\n-                                // same vm turn.\n-                                setTimeout(() => {\n-                                  this.ngZone.run(() => fn(...args));\n-                                });\n-                              }, delay, count, invokeApply, ...pass);\n+            if ($injector.has($INTERVAL)) {\n+              $provide.decorator($INTERVAL, [\n+                $DELEGATE,\n+                (intervalDelegate: IIntervalService) => {\n+                  // Wrap the $interval service so that setInterval is called outside NgZone,\n+                  // but the callback is still invoked within it. This is so that $interval\n+                  // won't block stability, which preserves the behavior from AngularJS.\n+                  let wrappedInterval =\n+                      (fn: Function, delay: number, count?: number, invokeApply?: boolean,\n+                       ...pass: any[]) => {\n+                        return this.ngZone.runOutsideAngular(() => {\n+                          return intervalDelegate((...args: any[]) => {\n+                            // Run callback in the next VM turn - $interval calls\n+                            // $rootScope.$apply, and running the callback in NgZone will\n+                            // cause a '$digest already in progress' error if it's in the\n+                            // same vm turn.\n+                            setTimeout(() => {\n+                              this.ngZone.run(() => fn(...args));\n                             });\n-                          };\n+                          }, delay, count, invokeApply, ...pass);\n+                        });\n+                      };\n \n-                      (wrappedInterval as any)['cancel'] = intervalDelegate.cancel;\n-                      return wrappedInterval;\n-                    }\n-                  ]);\n+                  (wrappedInterval as any)['cancel'] = intervalDelegate.cancel;\n+                  return wrappedInterval;\n                 }\n-              }\n-            ])\n+              ]);\n+            }\n+          }\n+        ])\n \n-            .run([\n-              $INJECTOR,\n-              ($injector: IInjectorService) => {\n-                this.$injector = $injector;\n+        .run([\n+          $INJECTOR,\n+          ($injector: IInjectorService) => {\n+            this.$injector = $injector;\n \n-                // Initialize the ng1 $injector provider\n-                setTempInjectorRef($injector);\n-                this.injector.get($INJECTOR);\n+            // Initialize the ng1 $injector provider\n+            setTempInjectorRef($injector);\n+            this.injector.get($INJECTOR);\n \n-                // Put the injector on the DOM, so that it can be \"required\"\n-                angularElement(element).data!(controllerKey(INJECTOR_KEY), this.injector);\n+            // Put the injector on the DOM, so that it can be \"required\"\n+            angularElement(element).data!(controllerKey(INJECTOR_KEY), this.injector);\n \n-                // Wire up the ng1 rootScope to run a digest cycle whenever the zone settles\n-                // We need to do this in the next tick so that we don't prevent the bootup\n-                // stabilizing\n-                setTimeout(() => {\n-                  const $rootScope = $injector.get('$rootScope');\n-                  const subscription = this.ngZone.onMicrotaskEmpty.subscribe(() => {\n-                    if ($rootScope.$$phase) {\n-                      if (isDevMode()) {\n-                        console.warn(\n-                            'A digest was triggered while one was already in progress. This may mean that something is triggering digests outside the Angular zone.');\n-                      }\n+            // Wire up the ng1 rootScope to run a digest cycle whenever the zone settles\n+            // We need to do this in the next tick so that we don't prevent the bootup stabilizing\n+            setTimeout(() => {\n+              const $rootScope = $injector.get('$rootScope');\n+              const subscription = this.ngZone.onMicrotaskEmpty.subscribe(() => {\n+                if ($rootScope.$$phase) {\n+                  if (isDevMode()) {\n+                    console.warn(\n+                        'A digest was triggered while one was already in progress. This may mean that something is triggering digests outside the Angular zone.');\n+                  }\n \n-                      return $rootScope.$evalAsync();\n-                    }\n+                  return $rootScope.$evalAsync();\n+                }\n \n-                    return $rootScope.$digest();\n-                  });\n-                  $rootScope.$on('$destroy', () => {\n-                    subscription.unsubscribe();\n-                  });\n-                }, 0);\n-              }\n-            ]);\n+                return $rootScope.$digest();\n+              });\n+              $rootScope.$on('$destroy', () => {\n+                subscription.unsubscribe();\n+              });\n+            }, 0);\n+          }\n+        ]);\n \n     const upgradeModule = angularModule(UPGRADE_MODULE_NAME, [INIT_MODULE_NAME].concat(modules));\n "
        }
    ],
    "stats": {
        "total": 178,
        "additions": 87,
        "deletions": 91
    }
}