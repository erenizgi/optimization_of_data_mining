{
    "author": "JiaLiPassion",
    "message": "feat(core): add shouldCoalesceRunChangeDetection option to coalesce change detections in the same event loop. (#39422)\n\nClose #39348\n\nNow `NgZone` has an option `shouldCoalesceEventChangeDetection` to coalesce\nmultiple event handler's change detections to one async change detection.\n\nAnd there are some cases other than `event handler` have the same issues.\nIn #39348, the case like this.\n\n```\n// This code results in one change detection occurring per\n// ngZone.run() call. This is entirely feasible, and can be a serious\n// performance issue.\nfor (let i = 0; i < 100; i++) {\n  this.ngZone.run(() => {\n    // do something\n  });\n}\n```\n\nSo such kind of case will trigger multiple change detections.\nAnd now with Ivy, we have a new `markDirty()` API will schedule\na requestAnimationFrame to trigger change detection and also coalesce\nthe change detections in the same event loop, `markDirty()` API doesn't\nonly take care `event handler` but also all other cases `sync/macroTask/..`\n\nSo this PR add a new option to coalesce change detections for all cases.\n\ntest(core): add test case for shouldCoalesceEventChangeDetection option\n\nAdd new test cases for current `shouldCoalesceEventChangeDetection` in `ng_zone.spec`, since\ncurrently we only have integration test for this one.\n\nPR Close #39422",
    "sha": "5e92d649f2e335d39cdd6d5bd580dbaa294a4f00",
    "files": [
        {
            "sha": "e2a87e69cf738debe148af000842d2c7c5125976",
            "filename": "goldens/public-api/core/core.d.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/5e92d649f2e335d39cdd6d5bd580dbaa294a4f00/goldens%2Fpublic-api%2Fcore%2Fcore.d.ts",
            "raw_url": "https://github.com/angular/angular/raw/5e92d649f2e335d39cdd6d5bd580dbaa294a4f00/goldens%2Fpublic-api%2Fcore%2Fcore.d.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fpublic-api%2Fcore%2Fcore.d.ts?ref=5e92d649f2e335d39cdd6d5bd580dbaa294a4f00",
            "patch": "@@ -619,9 +619,10 @@ export declare class NgZone {\n     readonly onMicrotaskEmpty: EventEmitter<any>;\n     readonly onStable: EventEmitter<any>;\n     readonly onUnstable: EventEmitter<any>;\n-    constructor({ enableLongStackTrace, shouldCoalesceEventChangeDetection }: {\n+    constructor({ enableLongStackTrace, shouldCoalesceEventChangeDetection, shouldCoalesceRunChangeDetection }: {\n         enableLongStackTrace?: boolean | undefined;\n         shouldCoalesceEventChangeDetection?: boolean | undefined;\n+        shouldCoalesceRunChangeDetection?: boolean | undefined;\n     });\n     run<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T;\n     runGuarded<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T;"
        },
        {
            "sha": "292c6782b52075a0e70e088c0cf5f804ccd446f4",
            "filename": "goldens/size-tracking/integration-payloads.json",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/5e92d649f2e335d39cdd6d5bd580dbaa294a4f00/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "raw_url": "https://github.com/angular/angular/raw/5e92d649f2e335d39cdd6d5bd580dbaa294a4f00/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fsize-tracking%2Fintegration-payloads.json?ref=5e92d649f2e335d39cdd6d5bd580dbaa294a4f00",
            "patch": "@@ -3,7 +3,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 1485,\n-        \"main-es2015\": 140899,\n+        \"main-es2015\": 141516,\n         \"polyfills-es2015\": 36964\n       }\n     }\n@@ -39,7 +39,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 2285,\n-        \"main-es2015\": 241875,\n+        \"main-es2015\": 242417,\n         \"polyfills-es2015\": 36709,\n         \"5-es2015\": 745\n       }\n@@ -48,10 +48,10 @@\n   \"cli-hello-world-lazy-rollup\": {\n     \"master\": {\n       \"uncompressed\": {\n-        \"runtime-es2015\": 2285,\n-        \"main-es2015\": 218340,\n-        \"polyfills-es2015\": 36709,\n-        \"5-es2015\": 777\n+        \"runtime-es2015\": 2289,\n+        \"main-es2015\": 218507,\n+        \"polyfills-es2015\": 36723,\n+        \"5-es2015\": 781\n       }\n     }\n   },\n@@ -66,4 +66,4 @@\n       }\n     }\n   }\n-}\n\\ No newline at end of file\n+}"
        },
        {
            "sha": "cdff12ceef6b80bd7eccdd9640c8c36df4a0235d",
            "filename": "packages/core/src/application_ref.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 5,
            "changes": 34,
            "blob_url": "https://github.com/angular/angular/blob/5e92d649f2e335d39cdd6d5bd580dbaa294a4f00/packages%2Fcore%2Fsrc%2Fapplication_ref.ts",
            "raw_url": "https://github.com/angular/angular/raw/5e92d649f2e335d39cdd6d5bd580dbaa294a4f00/packages%2Fcore%2Fsrc%2Fapplication_ref.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Fapplication_ref.ts?ref=5e92d649f2e335d39cdd6d5bd580dbaa294a4f00",
            "patch": "@@ -266,6 +266,25 @@ export interface BootstrapOptions {\n    * the change detection will only be triggered once.\n    */\n   ngZoneEventCoalescing?: boolean;\n+\n+  /**\n+   * Optionally specify if `NgZone#run()` method invocations should be coalesced\n+   * into a single change detection.\n+   *\n+   * Consider the following case.\n+   *\n+   * for (let i = 0; i < 10; i ++) {\n+   *   ngZone.run(() => {\n+   *     // do something\n+   *   });\n+   * }\n+   *\n+   * This case triggers the change detection multiple times.\n+   * With ngZoneRunCoalescing options, all change detections in an event loop trigger only once.\n+   * In addition, the change detection executes in requestAnimation.\n+   *\n+   */\n+  ngZoneRunCoalescing?: boolean;\n }\n \n /**\n@@ -316,10 +335,13 @@ export class PlatformRef {\n     // pass that as parent to the NgModuleFactory.\n     const ngZoneOption = options ? options.ngZone : undefined;\n     const ngZoneEventCoalescing = (options && options.ngZoneEventCoalescing) || false;\n-    const ngZone = getNgZone(ngZoneOption, ngZoneEventCoalescing);\n+    const ngZoneRunCoalescing = (options && options.ngZoneRunCoalescing) || false;\n+    const ngZone = getNgZone(ngZoneOption, {ngZoneEventCoalescing, ngZoneRunCoalescing});\n     const providers: StaticProvider[] = [{provide: NgZone, useValue: ngZone}];\n-    // Attention: Don't use ApplicationRef.run here,\n-    // as we want to be sure that all possible constructor calls are inside `ngZone.run`!\n+    // Note: Create ngZoneInjector within ngZone.run so that all of the instantiated services are\n+    // created within the Angular zone\n+    // Do not try to replace ngZone.run with ApplicationRef#run because ApplicationRef would then be\n+    // created outside of the Angular zone.\n     return ngZone.run(() => {\n       const ngZoneInjector = Injector.create(\n           {providers: providers, parent: this.injector, name: moduleFactory.moduleType.name});\n@@ -426,15 +448,17 @@ export class PlatformRef {\n }\n \n function getNgZone(\n-    ngZoneOption: NgZone|'zone.js'|'noop'|undefined, ngZoneEventCoalescing: boolean): NgZone {\n+    ngZoneOption: NgZone|'zone.js'|'noop'|undefined,\n+    extra?: {ngZoneEventCoalescing: boolean, ngZoneRunCoalescing: boolean}): NgZone {\n   let ngZone: NgZone;\n \n   if (ngZoneOption === 'noop') {\n     ngZone = new NoopNgZone();\n   } else {\n     ngZone = (ngZoneOption === 'zone.js' ? undefined : ngZoneOption) || new NgZone({\n                enableLongStackTrace: isDevMode(),\n-               shouldCoalesceEventChangeDetection: ngZoneEventCoalescing\n+               shouldCoalesceEventChangeDetection: !!extra?.ngZoneEventCoalescing,\n+               shouldCoalesceRunChangeDetection: !!extra?.ngZoneRunCoalescing\n              });\n   }\n   return ngZone;"
        },
        {
            "sha": "7d80492292e232d9e707f2683a106d41877c486d",
            "filename": "packages/core/src/zone/ng_zone.ts",
            "status": "modified",
            "additions": 59,
            "deletions": 13,
            "changes": 72,
            "blob_url": "https://github.com/angular/angular/blob/5e92d649f2e335d39cdd6d5bd580dbaa294a4f00/packages%2Fcore%2Fsrc%2Fzone%2Fng_zone.ts",
            "raw_url": "https://github.com/angular/angular/raw/5e92d649f2e335d39cdd6d5bd580dbaa294a4f00/packages%2Fcore%2Fsrc%2Fzone%2Fng_zone.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Fzone%2Fng_zone.ts?ref=5e92d649f2e335d39cdd6d5bd580dbaa294a4f00",
            "patch": "@@ -119,7 +119,11 @@ export class NgZone {\n   readonly onError: EventEmitter<any> = new EventEmitter(false);\n \n \n-  constructor({enableLongStackTrace = false, shouldCoalesceEventChangeDetection = false}) {\n+  constructor({\n+    enableLongStackTrace = false,\n+    shouldCoalesceEventChangeDetection = false,\n+    shouldCoalesceRunChangeDetection = false\n+  }) {\n     if (typeof Zone == 'undefined') {\n       throw new Error(`In this configuration Angular requires Zone.js`);\n     }\n@@ -137,8 +141,11 @@ export class NgZone {\n     if (enableLongStackTrace && (Zone as any)['longStackTraceZoneSpec']) {\n       self._inner = self._inner.fork((Zone as any)['longStackTraceZoneSpec']);\n     }\n-\n-    self.shouldCoalesceEventChangeDetection = shouldCoalesceEventChangeDetection;\n+    // if shouldCoalesceRunChangeDetection is true, all tasks including event tasks will be\n+    // coalesced, so shouldCoalesceEventChangeDetection option is not necessary and can be skipped.\n+    self.shouldCoalesceEventChangeDetection =\n+        !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;\n+    self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;\n     self.lastRequestAnimationFrameId = -1;\n     self.nativeRequestAnimationFrame = getNativeRequestAnimationFrame().nativeRequestAnimationFrame;\n     forkInnerZoneWithAngularBehavior(self);\n@@ -237,11 +244,49 @@ interface NgZonePrivate extends NgZone {\n   hasPendingMicrotasks: boolean;\n   lastRequestAnimationFrameId: number;\n   isStable: boolean;\n+  /**\n+   * Optionally specify coalescing event change detections or not.\n+   * Consider the following case.\n+   *\n+   * <div (click)=\"doSomething()\">\n+   *   <button (click)=\"doSomethingElse()\"></button>\n+   * </div>\n+   *\n+   * When button is clicked, because of the event bubbling, both\n+   * event handlers will be called and 2 change detections will be\n+   * triggered. We can coalesce such kind of events to trigger\n+   * change detection only once.\n+   *\n+   * By default, this option will be false. So the events will not be\n+   * coalesced and the change detection will be triggered multiple times.\n+   * And if this option be set to true, the change detection will be\n+   * triggered async by scheduling it in an animation frame. So in the case above,\n+   * the change detection will only be trigged once.\n+   */\n   shouldCoalesceEventChangeDetection: boolean;\n+  /**\n+   * Optionally specify if `NgZone#run()` method invocations should be coalesced\n+   * into a single change detection.\n+   *\n+   * Consider the following case.\n+   *\n+   * for (let i = 0; i < 10; i ++) {\n+   *   ngZone.run(() => {\n+   *     // do something\n+   *   });\n+   * }\n+   *\n+   * This case triggers the change detection multiple times.\n+   * With ngZoneRunCoalescing options, all change detections in an event loops trigger only once.\n+   * In addition, the change detection executes in requestAnimation.\n+   *\n+   */\n+  shouldCoalesceRunChangeDetection: boolean;\n+\n   nativeRequestAnimationFrame: (callback: FrameRequestCallback) => number;\n \n-  // Cache of  \"fake\" top eventTask. This is done so that we don't need to schedule a new task every\n-  // time we want to run a `checkStable`.\n+  // Cache a  \"fake\" top eventTask so you don't need to schedule a new task every\n+  // time you run a `checkStable`.\n   fakeTopEventTask: Task;\n }\n \n@@ -293,34 +338,34 @@ function forkInnerZoneWithAngularBehavior(zone: NgZonePrivate) {\n   const delayChangeDetectionForEventsDelegate = () => {\n     delayChangeDetectionForEvents(zone);\n   };\n-  const maybeDelayChangeDetection = !!zone.shouldCoalesceEventChangeDetection &&\n-      zone.nativeRequestAnimationFrame && delayChangeDetectionForEventsDelegate;\n   zone._inner = zone._inner.fork({\n     name: 'angular',\n-    properties:\n-        <any>{'isAngularZone': true, 'maybeDelayChangeDetection': maybeDelayChangeDetection},\n+    properties: <any>{'isAngularZone': true},\n     onInvokeTask:\n         (delegate: ZoneDelegate, current: Zone, target: Zone, task: Task, applyThis: any,\n          applyArgs: any): any => {\n           try {\n             onEnter(zone);\n             return delegate.invokeTask(target, task, applyThis, applyArgs);\n           } finally {\n-            if (maybeDelayChangeDetection && task.type === 'eventTask') {\n-              maybeDelayChangeDetection();\n+            if ((zone.shouldCoalesceEventChangeDetection && task.type === 'eventTask') ||\n+                zone.shouldCoalesceRunChangeDetection) {\n+              delayChangeDetectionForEventsDelegate();\n             }\n             onLeave(zone);\n           }\n         },\n \n-\n     onInvoke:\n         (delegate: ZoneDelegate, current: Zone, target: Zone, callback: Function, applyThis: any,\n          applyArgs?: any[], source?: string): any => {\n           try {\n             onEnter(zone);\n             return delegate.invoke(target, callback, applyThis, applyArgs, source);\n           } finally {\n+            if (zone.shouldCoalesceRunChangeDetection) {\n+              delayChangeDetectionForEventsDelegate();\n+            }\n             onLeave(zone);\n           }\n         },\n@@ -351,7 +396,8 @@ function forkInnerZoneWithAngularBehavior(zone: NgZonePrivate) {\n \n function updateMicroTaskStatus(zone: NgZonePrivate) {\n   if (zone._hasPendingMicrotasks ||\n-      (zone.shouldCoalesceEventChangeDetection && zone.lastRequestAnimationFrameId !== -1)) {\n+      ((zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) &&\n+       zone.lastRequestAnimationFrameId !== -1)) {\n     zone.hasPendingMicrotasks = true;\n   } else {\n     zone.hasPendingMicrotasks = false;"
        },
        {
            "sha": "3f11518a0e30485288fbe4b0be8c01405dffdb83",
            "filename": "packages/core/test/zone/ng_zone_spec.ts",
            "status": "modified",
            "additions": 237,
            "deletions": 0,
            "changes": 237,
            "blob_url": "https://github.com/angular/angular/blob/5e92d649f2e335d39cdd6d5bd580dbaa294a4f00/packages%2Fcore%2Ftest%2Fzone%2Fng_zone_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/5e92d649f2e335d39cdd6d5bd580dbaa294a4f00/packages%2Fcore%2Ftest%2Fzone%2Fng_zone_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fzone%2Fng_zone_spec.ts?ref=5e92d649f2e335d39cdd6d5bd580dbaa294a4f00",
            "patch": "@@ -12,6 +12,7 @@ import {AsyncTestCompleter, beforeEach, describe, expect, inject, it, Log, xit}\n import {browserDetection} from '@angular/platform-browser/testing/src/browser_util';\n \n import {scheduleMicroTask} from '../../src/util/microtask';\n+import {getNativeRequestAnimationFrame} from '../../src/util/raf';\n import {NoopNgZone} from '../../src/zone/ng_zone';\n \n const needsLongerTimers = browserDetection.isSlow || browserDetection.isEdge;\n@@ -929,4 +930,240 @@ function commonTests() {\n       });\n     });\n   });\n+\n+  describe('coalescing', () => {\n+    describe(\n+        'shouldCoalesceRunChangeDetection = false, shouldCoalesceEventChangeDetection = false',\n+        () => {\n+          let notCoalesceZone: NgZone;\n+          let logs: string[] = [];\n+\n+          beforeEach(() => {\n+            notCoalesceZone = new NgZone({});\n+            logs = [];\n+            notCoalesceZone.onMicrotaskEmpty.subscribe(() => {\n+              logs.push('microTask empty');\n+            });\n+          });\n+\n+          it('should run sync', () => {\n+            notCoalesceZone.run(() => {});\n+            expect(logs).toEqual(['microTask empty']);\n+          });\n+\n+          it('should emit onMicroTaskEmpty multiple times within the same event loop for multiple ngZone.run',\n+             () => {\n+               notCoalesceZone.run(() => {});\n+               notCoalesceZone.run(() => {});\n+               expect(logs).toEqual(['microTask empty', 'microTask empty']);\n+             });\n+\n+          it('should emit onMicroTaskEmpty multiple times within the same event loop for multiple tasks',\n+             () => {\n+               const tasks: Task[] = [];\n+               notCoalesceZone.run(() => {\n+                 tasks.push(Zone.current.scheduleEventTask('myEvent', () => {\n+                   logs.push('eventTask1');\n+                 }, undefined, () => {}));\n+                 tasks.push(Zone.current.scheduleEventTask('myEvent', () => {\n+                   logs.push('eventTask2');\n+                 }, undefined, () => {}));\n+                 tasks.push(Zone.current.scheduleMacroTask('myMacro', () => {\n+                   logs.push('macroTask');\n+                 }, undefined, () => {}));\n+               });\n+               tasks.forEach(t => t.invoke());\n+               expect(logs).toEqual([\n+                 'microTask empty', 'eventTask1', 'microTask empty', 'eventTask2',\n+                 'microTask empty', 'macroTask', 'microTask empty'\n+               ]);\n+             });\n+        });\n+\n+    describe('shouldCoalesceEventChangeDetection = true, shouldCoalesceRunChangeDetection = false', () => {\n+      let nativeRequestAnimationFrame: (fn: FrameRequestCallback) => void;\n+      if (!(global as any).requestAnimationFrame) {\n+        nativeRequestAnimationFrame = function(fn: Function) {\n+          (global as any)[Zone.__symbol__('setTimeout')](fn, 16);\n+        };\n+      } else {\n+        nativeRequestAnimationFrame = getNativeRequestAnimationFrame().nativeRequestAnimationFrame;\n+      }\n+      let patchedImmediate: any;\n+      let coalesceZone: NgZone;\n+      let logs: string[] = [];\n+\n+      beforeEach(() => {\n+        patchedImmediate = setImmediate;\n+        (global as any).setImmediate = (global as any)[Zone.__symbol__('setImmediate')];\n+        coalesceZone = new NgZone({shouldCoalesceEventChangeDetection: true});\n+        logs = [];\n+        coalesceZone.onMicrotaskEmpty.subscribe(() => {\n+          logs.push('microTask empty');\n+        });\n+      });\n+\n+      afterEach(() => {\n+        (global as any).setImmediate = patchedImmediate;\n+      });\n+\n+      it('should run in requestAnimationFrame async', (done: DoneFn) => {\n+        let task: Task|undefined = undefined;\n+        coalesceZone.run(() => {\n+          task = Zone.current.scheduleEventTask('myEvent', () => {\n+            logs.push('myEvent');\n+          }, undefined, () => {});\n+        });\n+        task!.invoke();\n+        expect(logs).toEqual(['microTask empty', 'myEvent']);\n+        nativeRequestAnimationFrame(() => {\n+          expect(logs).toEqual(['microTask empty', 'myEvent', 'microTask empty']);\n+          done();\n+        });\n+      });\n+\n+      it('should only emit onMicroTaskEmpty once within the same event loop for multiple event tasks',\n+         (done: DoneFn) => {\n+           const tasks: Task[] = [];\n+           coalesceZone.run(() => {\n+             tasks.push(Zone.current.scheduleEventTask('myEvent', () => {\n+               logs.push('eventTask1');\n+             }, undefined, () => {}));\n+             tasks.push(Zone.current.scheduleEventTask('myEvent', () => {\n+               logs.push('eventTask2');\n+             }, undefined, () => {}));\n+           });\n+           tasks.forEach(t => t.invoke());\n+           expect(logs).toEqual(['microTask empty', 'eventTask1', 'eventTask2']);\n+           nativeRequestAnimationFrame(() => {\n+             expect(logs).toEqual(\n+                 ['microTask empty', 'eventTask1', 'eventTask2', 'microTask empty']);\n+             done();\n+           });\n+         });\n+\n+      it('should emit onMicroTaskEmpty once within the same event loop for not only event tasks, but event tasks are before other tasks',\n+         (done: DoneFn) => {\n+           const tasks: Task[] = [];\n+           coalesceZone.run(() => {\n+             tasks.push(Zone.current.scheduleEventTask('myEvent', () => {\n+               logs.push('eventTask1');\n+             }, undefined, () => {}));\n+             tasks.push(Zone.current.scheduleEventTask('myEvent', () => {\n+               logs.push('eventTask2');\n+             }, undefined, () => {}));\n+             tasks.push(Zone.current.scheduleMacroTask('myMacro', () => {\n+               logs.push('macroTask');\n+             }, undefined, () => {}));\n+           });\n+           tasks.forEach(t => t.invoke());\n+           expect(logs).toEqual(['microTask empty', 'eventTask1', 'eventTask2', 'macroTask']);\n+           nativeRequestAnimationFrame(() => {\n+             expect(logs).toEqual(\n+                 ['microTask empty', 'eventTask1', 'eventTask2', 'macroTask', 'microTask empty']);\n+             done();\n+           });\n+         });\n+\n+      it('should emit multiple onMicroTaskEmpty within the same event loop for not only event tasks, but event tasks are after other tasks',\n+         (done: DoneFn) => {\n+           const tasks: Task[] = [];\n+           coalesceZone.run(() => {\n+             tasks.push(Zone.current.scheduleMacroTask('myMacro', () => {\n+               logs.push('macroTask');\n+             }, undefined, () => {}));\n+             tasks.push(Zone.current.scheduleEventTask('myEvent', () => {\n+               logs.push('eventTask1');\n+             }, undefined, () => {}));\n+             tasks.push(Zone.current.scheduleEventTask('myEvent', () => {\n+               logs.push('eventTask2');\n+             }, undefined, () => {}));\n+           });\n+           tasks.forEach(t => t.invoke());\n+           expect(logs).toEqual(\n+               ['microTask empty', 'macroTask', 'microTask empty', 'eventTask1', 'eventTask2']);\n+           nativeRequestAnimationFrame(() => {\n+             expect(logs).toEqual([\n+               'microTask empty', 'macroTask', 'microTask empty', 'eventTask1', 'eventTask2',\n+               'microTask empty'\n+             ]);\n+             done();\n+           });\n+         });\n+    });\n+\n+    describe('shouldCoalesceRunChangeDetection = true', () => {\n+      let nativeRequestAnimationFrame: (fn: FrameRequestCallback) => void;\n+      if (!(global as any).requestAnimationFrame) {\n+        nativeRequestAnimationFrame = function(fn: Function) {\n+          (global as any)[Zone.__symbol__('setTimeout')](fn, 16);\n+        };\n+      } else {\n+        nativeRequestAnimationFrame = getNativeRequestAnimationFrame().nativeRequestAnimationFrame;\n+      }\n+      let patchedImmediate: any;\n+      let coalesceZone: NgZone;\n+      let logs: string[] = [];\n+\n+      beforeEach(() => {\n+        patchedImmediate = setImmediate;\n+        (global as any).setImmediate = (global as any)[Zone.__symbol__('setImmediate')];\n+        coalesceZone = new NgZone({shouldCoalesceRunChangeDetection: true});\n+        logs = [];\n+        coalesceZone.onMicrotaskEmpty.subscribe(() => {\n+          logs.push('microTask empty');\n+        });\n+      });\n+\n+      afterEach(() => {\n+        (global as any).setImmediate = patchedImmediate;\n+      });\n+\n+      it('should run in requestAnimationFrame async', (done: DoneFn) => {\n+        coalesceZone.run(() => {});\n+        expect(logs).toEqual([]);\n+        nativeRequestAnimationFrame(() => {\n+          expect(logs).toEqual(['microTask empty']);\n+          done();\n+        });\n+      });\n+\n+      it('should only emit onMicroTaskEmpty once within the same event loop for multiple ngZone.run',\n+         (done: DoneFn) => {\n+           coalesceZone.run(() => {});\n+           coalesceZone.run(() => {});\n+           expect(logs).toEqual([]);\n+           nativeRequestAnimationFrame(() => {\n+             expect(logs).toEqual(['microTask empty']);\n+             done();\n+           });\n+         });\n+\n+      it('should only emit onMicroTaskEmpty once within the same event loop for multiple tasks',\n+         (done: DoneFn) => {\n+           const tasks: Task[] = [];\n+           coalesceZone.run(() => {\n+             tasks.push(Zone.current.scheduleMacroTask('myMacro', () => {\n+               logs.push('macroTask');\n+             }, undefined, () => {}));\n+             tasks.push(Zone.current.scheduleEventTask('myEvent', () => {\n+               logs.push('eventTask1');\n+             }, undefined, () => {}));\n+             tasks.push(Zone.current.scheduleEventTask('myEvent', () => {\n+               logs.push('eventTask2');\n+             }, undefined, () => {}));\n+             tasks.push(Zone.current.scheduleMacroTask('myMacro', () => {\n+               logs.push('macroTask');\n+             }, undefined, () => {}));\n+           });\n+           tasks.forEach(t => t.invoke());\n+           expect(logs).toEqual(['macroTask', 'eventTask1', 'eventTask2', 'macroTask']);\n+           nativeRequestAnimationFrame(() => {\n+             expect(logs).toEqual(\n+                 ['macroTask', 'eventTask1', 'eventTask2', 'macroTask', 'microTask empty']);\n+             done();\n+           });\n+         });\n+    });\n+  });\n }"
        },
        {
            "sha": "245ca5bf9f06778ddf768a23ccbfbc84e1bf42e1",
            "filename": "packages/platform-browser/test/dom/events/event_manager_spec.ts",
            "status": "modified",
            "additions": 117,
            "deletions": 33,
            "changes": 150,
            "blob_url": "https://github.com/angular/angular/blob/5e92d649f2e335d39cdd6d5bd580dbaa294a4f00/packages%2Fplatform-browser%2Ftest%2Fdom%2Fevents%2Fevent_manager_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/5e92d649f2e335d39cdd6d5bd580dbaa294a4f00/packages%2Fplatform-browser%2Ftest%2Fdom%2Fevents%2Fevent_manager_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser%2Ftest%2Fdom%2Fevents%2Fevent_manager_spec.ts?ref=5e92d649f2e335d39cdd6d5bd580dbaa294a4f00",
            "patch": "@@ -335,41 +335,79 @@ describe('EventManager', () => {\n     expect(receivedEvent).toBe(null);\n   });\n \n-  it('should only trigger one Change detection when bubbling', (done: DoneFn) => {\n-    doc = getDOM().supportsDOMEvents() ? document : getDOM().createHtmlDocument();\n-    zone = new NgZone({shouldCoalesceEventChangeDetection: true});\n-    domEventPlugin = new DomEventsPlugin(doc);\n-    const element = el('<div></div>');\n-    const child = el('<div></div>');\n-    element.appendChild(child);\n-    doc.body.appendChild(element);\n-    const dispatchedEvent = createMouseEvent('click');\n-    let receivedEvents: any = [];\n-    let stables: any = [];\n-    const handler = (e: any) => {\n-      receivedEvents.push(e);\n-    };\n-    const manager = new EventManager([domEventPlugin], zone);\n-    let removerChild: any;\n-    let removerParent: any;\n+  it('should only trigger one Change detection when bubbling with shouldCoalesceEventChangeDetection = true',\n+     (done: DoneFn) => {\n+       doc = getDOM().supportsDOMEvents() ? document : getDOM().createHtmlDocument();\n+       zone = new NgZone({shouldCoalesceEventChangeDetection: true});\n+       domEventPlugin = new DomEventsPlugin(doc);\n+       const element = el('<div></div>');\n+       const child = el('<div></div>');\n+       element.appendChild(child);\n+       doc.body.appendChild(element);\n+       const dispatchedEvent = createMouseEvent('click');\n+       let receivedEvents: any = [];\n+       let stables: any = [];\n+       const handler = (e: any) => {\n+         receivedEvents.push(e);\n+       };\n+       const manager = new EventManager([domEventPlugin], zone);\n+       let removerChild: any;\n+       let removerParent: any;\n \n-    zone.run(() => {\n-      removerChild = manager.addEventListener(child, 'click', handler);\n-      removerParent = manager.addEventListener(element, 'click', handler);\n-    });\n-    zone.onStable.subscribe((isStable: any) => {\n-      stables.push(isStable);\n-    });\n-    getDOM().dispatchEvent(child, dispatchedEvent);\n-    requestAnimationFrame(() => {\n-      expect(receivedEvents.length).toBe(2);\n-      expect(stables.length).toBe(1);\n+       zone.run(() => {\n+         removerChild = manager.addEventListener(child, 'click', handler);\n+         removerParent = manager.addEventListener(element, 'click', handler);\n+       });\n+       zone.onStable.subscribe((isStable: any) => {\n+         stables.push(isStable);\n+       });\n+       getDOM().dispatchEvent(child, dispatchedEvent);\n+       requestAnimationFrame(() => {\n+         expect(receivedEvents.length).toBe(2);\n+         expect(stables.length).toBe(1);\n \n-      removerChild && removerChild();\n-      removerParent && removerParent();\n-      done();\n-    });\n-  });\n+         removerChild && removerChild();\n+         removerParent && removerParent();\n+         done();\n+       });\n+     });\n+\n+  it('should only trigger one Change detection when bubbling with shouldCoalesceRunChangeDetection = true',\n+     (done: DoneFn) => {\n+       doc = getDOM().supportsDOMEvents() ? document : getDOM().createHtmlDocument();\n+       zone = new NgZone({shouldCoalesceRunChangeDetection: true});\n+       domEventPlugin = new DomEventsPlugin(doc);\n+       const element = el('<div></div>');\n+       const child = el('<div></div>');\n+       element.appendChild(child);\n+       doc.body.appendChild(element);\n+       const dispatchedEvent = createMouseEvent('click');\n+       let receivedEvents: any = [];\n+       let stables: any = [];\n+       const handler = (e: any) => {\n+         receivedEvents.push(e);\n+       };\n+       const manager = new EventManager([domEventPlugin], zone);\n+       let removerChild: any;\n+       let removerParent: any;\n+\n+       zone.run(() => {\n+         removerChild = manager.addEventListener(child, 'click', handler);\n+         removerParent = manager.addEventListener(element, 'click', handler);\n+       });\n+       zone.onStable.subscribe((isStable: any) => {\n+         stables.push(isStable);\n+       });\n+       getDOM().dispatchEvent(child, dispatchedEvent);\n+       requestAnimationFrame(() => {\n+         expect(receivedEvents.length).toBe(2);\n+         expect(stables.length).toBe(1);\n+\n+         removerChild && removerChild();\n+         removerParent && removerParent();\n+         done();\n+       });\n+     });\n \n   it('should not drain micro tasks queue too early with shouldCoalesceEventChangeDetection=true',\n      (done: DoneFn) => {\n@@ -393,6 +431,52 @@ describe('EventManager', () => {\n        let removerParent: any;\n        let removerChildFocus: any;\n \n+       zone.run(() => {\n+         removerParent = manager.addEventListener(element, 'click', handler);\n+         removerChildFocus = manager.addEventListener(child, 'blur', blurHandler);\n+       });\n+       const sub = zone.onStable.subscribe(() => {\n+         logs.push('begin');\n+         Promise.resolve().then(() => {\n+           logs.push('promise resolved');\n+         });\n+         element.appendChild(child);\n+         getDOM().dispatchEvent(child, dispatchedBlurEvent);\n+         sub.unsubscribe();\n+         logs.push('end');\n+       });\n+       getDOM().dispatchEvent(element, dispatchedClickEvent);\n+       requestAnimationFrame(() => {\n+         expect(logs).toEqual(['begin', 'blur', 'end', 'promise resolved']);\n+\n+         removerParent && removerParent();\n+         removerChildFocus && removerChildFocus();\n+         done();\n+       });\n+     });\n+\n+  it('should not drain micro tasks queue too early with shouldCoalesceRunChangeDetection=true',\n+     (done: DoneFn) => {\n+       doc = getDOM().supportsDOMEvents() ? document : getDOM().createHtmlDocument();\n+       zone = new NgZone({shouldCoalesceRunChangeDetection: true});\n+       domEventPlugin = new DomEventsPlugin(doc);\n+       const element = el('<div></div>');\n+       const child = el('<div></div>');\n+       doc.body.appendChild(element);\n+       const dispatchedClickEvent = createMouseEvent('click');\n+       const dispatchedBlurEvent: FocusEvent =\n+           getDOM().getDefaultDocument().createEvent('FocusEvent');\n+       dispatchedBlurEvent.initEvent('blur', true, true);\n+       let logs: any = [];\n+       const handler = () => {};\n+\n+       const blurHandler = (e: any) => {\n+         logs.push('blur');\n+       };\n+       const manager = new EventManager([domEventPlugin], zone);\n+       let removerParent: any;\n+       let removerChildFocus: any;\n+\n        zone.run(() => {\n          removerParent = manager.addEventListener(element, 'click', handler);\n          removerChildFocus = manager.addEventListener(child, 'blur', blurHandler);"
        }
    ],
    "stats": {
        "total": 510,
        "additions": 451,
        "deletions": 59
    }
}