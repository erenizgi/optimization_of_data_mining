{
    "author": "atscott",
    "message": "refactor(compiler-cli): Adjust output of TCB to support `TemplateTypeChecker` Symbol retrieval (#38618)\n\nThe statements generated in the TCB are optimized for performance and producing diagnostics.\nThese optimizations can result in generating a TCB that does not have all the information\nneeded by the `TemplateTypeChecker` for retrieving `Symbol`s. For example, as an optimization,\nthe TCB will not generate variable declaration statements for directives that have no\nreferences, inputs, or outputs. However, the `TemplateTypeChecker` always needs these\nstatements to be present in order to provide `ts.Symbol`s and `ts.Type`s for the directives.\n\nThis commit adds logic to the TCB generation to ensure the required\ninformation is available in a form that the `TemplateTypeChecker` can\nconsume. It also adds an option to the `NgCompiler` that makes this\ngeneration configurable.\n\nPR Close #38618",
    "sha": "a46e0e48a3e470934319a0c3144d35aaae316288",
    "files": [
        {
            "sha": "c4a6637d917ef03c53010ffed352e210b27c080c",
            "filename": "packages/compiler-cli/src/ngtsc/core/src/compiler.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 3,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts?ref=a46e0e48a3e470934319a0c3144d35aaae316288",
            "patch": "@@ -99,11 +99,15 @@ export class NgCompiler {\n   readonly ignoreForEmit: Set<ts.SourceFile>;\n \n   constructor(\n-      private adapter: NgCompilerAdapter, private options: NgCompilerOptions,\n+      private adapter: NgCompilerAdapter,\n+      private options: NgCompilerOptions,\n       private tsProgram: ts.Program,\n       private typeCheckingProgramStrategy: TypeCheckingProgramStrategy,\n-      private incrementalStrategy: IncrementalBuildStrategy, oldProgram: ts.Program|null = null,\n-      private perfRecorder: PerfRecorder = NOOP_PERF_RECORDER) {\n+      private incrementalStrategy: IncrementalBuildStrategy,\n+      private enableTemplateTypeChecker: boolean,\n+      oldProgram: ts.Program|null = null,\n+      private perfRecorder: PerfRecorder = NOOP_PERF_RECORDER,\n+  ) {\n     this.constructionDiagnostics.push(...this.adapter.constructionDiagnostics);\n     const incompatibleTypeCheckOptionsDiagnostic = verifyCompatibleTypeCheckOptions(this.options);\n     if (incompatibleTypeCheckOptionsDiagnostic !== null) {\n@@ -212,6 +216,10 @@ export class NgCompiler {\n   }\n \n   getTemplateTypeChecker(): TemplateTypeChecker {\n+    if (!this.enableTemplateTypeChecker) {\n+      throw new Error(\n+          'The `TemplateTypeChecker` does not work without `enableTemplateTypeChecker`.');\n+    }\n     return this.ensureAnalyzed().templateTypeChecker;\n   }\n \n@@ -436,6 +444,7 @@ export class NgCompiler {\n         strictSafeNavigationTypes: strictTemplates,\n         useContextGenericType: strictTemplates,\n         strictLiteralTypes: true,\n+        enableTemplateTypeChecker: this.enableTemplateTypeChecker,\n       };\n     } else {\n       typeCheckingConfig = {\n@@ -456,6 +465,7 @@ export class NgCompiler {\n         strictSafeNavigationTypes: false,\n         useContextGenericType: false,\n         strictLiteralTypes: false,\n+        enableTemplateTypeChecker: this.enableTemplateTypeChecker,\n       };\n     }\n "
        },
        {
            "sha": "16e9fea106b6800cc049ac1832f34ff3fb63461b",
            "filename": "packages/compiler-cli/src/ngtsc/core/test/compiler_test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Ftest%2Fcompiler_test.ts",
            "raw_url": "https://github.com/angular/angular/raw/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Ftest%2Fcompiler_test.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Ftest%2Fcompiler_test.ts?ref=a46e0e48a3e470934319a0c3144d35aaae316288",
            "patch": "@@ -49,7 +49,7 @@ runInEachFileSystem(() => {\n       const program = ts.createProgram({host, options, rootNames: host.inputFiles});\n       const compiler = new NgCompiler(\n           host, options, program, new ReusedProgramStrategy(program, host, options, []),\n-          new NoopIncrementalBuildStrategy());\n+          new NoopIncrementalBuildStrategy(), /** enableTemplateTypeChecker */ false);\n \n       const diags = compiler.getDiagnostics(getSourceFileOrError(program, COMPONENT));\n       expect(diags.length).toBe(1);"
        },
        {
            "sha": "cc277e0d9700ddfefa7f94b2a8441cb8bfe3be7d",
            "filename": "packages/compiler-cli/src/ngtsc/program.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fprogram.ts",
            "raw_url": "https://github.com/angular/angular/raw/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fprogram.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fprogram.ts?ref=a46e0e48a3e470934319a0c3144d35aaae316288",
            "patch": "@@ -99,7 +99,7 @@ export class NgtscProgram implements api.Program {\n     // Create the NgCompiler which will drive the rest of the compilation.\n     this.compiler = new NgCompiler(\n         this.host, options, this.tsProgram, reusedProgramStrategy, this.incrementalStrategy,\n-        reuseProgram, this.perfRecorder);\n+        /** enableTemplateTypeChecker */ false, reuseProgram, this.perfRecorder);\n   }\n \n   getTsProgram(): ts.Program {"
        },
        {
            "sha": "dcd62d5093e3509ac690085fdd42e77105848080",
            "filename": "packages/compiler-cli/src/ngtsc/tsc_plugin.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftsc_plugin.ts",
            "raw_url": "https://github.com/angular/angular/raw/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftsc_plugin.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftsc_plugin.ts?ref=a46e0e48a3e470934319a0c3144d35aaae316288",
            "patch": "@@ -102,7 +102,8 @@ export class NgTscPlugin implements TscPlugin {\n         program, this.host, this.options, this.host.shimExtensionPrefixes);\n     this._compiler = new NgCompiler(\n         this.host, this.options, program, typeCheckStrategy,\n-        new PatchedProgramIncrementalBuildStrategy(), oldProgram, NOOP_PERF_RECORDER);\n+        new PatchedProgramIncrementalBuildStrategy(), /** enableTemplateTypeChecker */ false,\n+        oldProgram, NOOP_PERF_RECORDER);\n     return {\n       ignoreForDiagnostics: this._compiler.ignoreForDiagnostics,\n       ignoreForEmit: this._compiler.ignoreForEmit,"
        },
        {
            "sha": "e9b3a609d111fb846fe3df4f2466db88c7012143",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/api.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fapi.ts?ref=a46e0e48a3e470934319a0c3144d35aaae316288",
            "patch": "@@ -185,6 +185,22 @@ export interface TypeCheckingConfig {\n    */\n   checkTypeOfNonDomReferences: boolean;\n \n+  /**\n+   * Whether to adjust the output of the TCB to ensure compatibility with the `TemplateTypeChecker`.\n+   *\n+   * The statements generated in the TCB are optimized for performance and producing diagnostics.\n+   * These optimizations can result in generating a TCB that does not have all the information\n+   * needed by the `TemplateTypeChecker` for retrieving `Symbol`s. For example, as an optimization,\n+   * the TCB will not generate variable declaration statements for directives that have no\n+   * references, inputs, or outputs. However, the `TemplateTypeChecker` always needs these\n+   * statements to be present in order to provide `ts.Symbol`s and `ts.Type`s for the directives.\n+   *\n+   * When set to `false`, enables TCB optimizations for template diagnostics.\n+   * When set to `true`, ensures all information required by `TemplateTypeChecker` to\n+   * retrieve symbols for template nodes is available in the TCB.\n+   */\n+  enableTemplateTypeChecker: boolean;\n+\n   /**\n    * Whether to include type information from pipes in the type-checking operation.\n    *"
        },
        {
            "sha": "65bc50a7a04ed6925bc0800c47e5b06549539db4",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/comments.ts",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/angular/angular/blob/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcomments.ts",
            "raw_url": "https://github.com/angular/angular/raw/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcomments.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcomments.ts?ref=a46e0e48a3e470934319a0c3144d35aaae316288",
            "patch": "@@ -0,0 +1,74 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {AbsoluteSourceSpan} from '@angular/compiler';\n+import * as ts from 'typescript';\n+\n+const parseSpanComment = /^(\\d+),(\\d+)$/;\n+\n+/**\n+ * Reads the trailing comments and finds the first match which is a span comment (i.e. 4,10) on a\n+ * node and returns it as an `AbsoluteSourceSpan`.\n+ *\n+ * Will return `null` if no trailing comments on the node match the expected form of a source span.\n+ */\n+export function readSpanComment(sourceFile: ts.SourceFile, node: ts.Node): AbsoluteSourceSpan|null {\n+  return ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {\n+    if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n+      return null;\n+    }\n+    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n+    const match = commentText.match(parseSpanComment);\n+    if (match === null) {\n+      return null;\n+    }\n+\n+    return new AbsoluteSourceSpan(+match[1], +match[2]);\n+  }) || null;\n+}\n+\n+/** Used to identify what type the comment is. */\n+export enum CommentTriviaType {\n+  DIAGNOSTIC = 'D',\n+  EXPRESSION_TYPE_IDENTIFIER = 'T',\n+}\n+\n+/** Identifies what the TCB expression is for (for example, a directive declaration). */\n+export enum ExpressionIdentifier {\n+  DIRECTIVE = 'DIR',\n+}\n+\n+/** Tags the node with the given expression identifier. */\n+export function addExpressionIdentifier(node: ts.Node, identifier: ExpressionIdentifier) {\n+  ts.addSyntheticTrailingComment(\n+      node, ts.SyntaxKind.MultiLineCommentTrivia,\n+      `${CommentTriviaType.EXPRESSION_TYPE_IDENTIFIER}:${identifier}`,\n+      /* hasTrailingNewLine */ false);\n+}\n+\n+export const IGNORE_MARKER = `${CommentTriviaType.DIAGNOSTIC}:ignore`;\n+\n+/**\n+ * Tag the `ts.Node` with an indication that any errors arising from the evaluation of the node\n+ * should be ignored.\n+ */\n+export function markIgnoreDiagnostics(node: ts.Node): void {\n+  ts.addSyntheticTrailingComment(\n+      node, ts.SyntaxKind.MultiLineCommentTrivia, IGNORE_MARKER, /* hasTrailingNewLine */ false);\n+}\n+\n+/** Returns true if the node has a marker that indicates diagnostics errors should be ignored.  */\n+export function hasIgnoreMarker(node: ts.Node, sourceFile: ts.SourceFile): boolean {\n+  return ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {\n+    if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n+      return null;\n+    }\n+    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n+    return commentText === IGNORE_MARKER;\n+  }) === true;\n+}"
        },
        {
            "sha": "f80155bf21008fef2c3b6806073907cecdc7365a",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/diagnostics.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 34,
            "changes": 44,
            "blob_url": "https://github.com/angular/angular/blob/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fdiagnostics.ts",
            "raw_url": "https://github.com/angular/angular/raw/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fdiagnostics.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fdiagnostics.ts?ref=a46e0e48a3e470934319a0c3144d35aaae316288",
            "patch": "@@ -9,9 +9,12 @@ import {AbsoluteSourceSpan, ParseSourceSpan} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {getTokenAtPosition} from '../../util/src/typescript';\n-import {ExternalTemplateSourceMapping, TemplateId, TemplateSourceMapping} from '../api';\n+import {TemplateId, TemplateSourceMapping} from '../api';\n import {makeTemplateDiagnostic, TemplateDiagnostic} from '../diagnostics';\n \n+import {hasIgnoreMarker, readSpanComment} from './comments';\n+\n+\n /**\n  * Adapter interface which allows the template type-checking diagnostics code to interpret offsets\n  * in a TCB and map them back to original locations in the template.\n@@ -47,14 +50,14 @@ export function wrapForDiagnostics(expr: ts.Expression): ts.Expression {\n   return ts.createParen(expr);\n }\n \n-const IGNORE_MARKER = 'ignore';\n-\n /**\n- * Adds a marker to the node that signifies that any errors within the node should not be reported.\n+ * Wraps the node in parenthesis such that inserted span comments become attached to the proper\n+ * node. This is an alias for `ts.createParen` with the benefit that it signifies that the\n+ * inserted parenthesis are for use by the type checker, not for correctness of the rendered TCB\n+ * code.\n  */\n-export function ignoreDiagnostics(node: ts.Node): void {\n-  ts.addSyntheticTrailingComment(\n-      node, ts.SyntaxKind.MultiLineCommentTrivia, IGNORE_MARKER, /* hasTrailingNewLine */ false);\n+export function wrapForTypeChecker(expr: ts.Expression): ts.Expression {\n+  return ts.createParen(expr);\n }\n \n /**\n@@ -200,30 +203,3 @@ function getTemplateId(node: ts.Node, sourceFile: ts.SourceFile): TemplateId|nul\n     return commentText;\n   }) as TemplateId || null;\n }\n-\n-const parseSpanComment = /^(\\d+),(\\d+)$/;\n-\n-function readSpanComment(sourceFile: ts.SourceFile, node: ts.Node): AbsoluteSourceSpan|null {\n-  return ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {\n-    if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n-      return null;\n-    }\n-    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n-    const match = commentText.match(parseSpanComment);\n-    if (match === null) {\n-      return null;\n-    }\n-\n-    return new AbsoluteSourceSpan(+match[1], +match[2]);\n-  }) || null;\n-}\n-\n-function hasIgnoreMarker(node: ts.Node, sourceFile: ts.SourceFile): boolean {\n-  return ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {\n-    if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n-      return null;\n-    }\n-    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n-    return commentText === IGNORE_MARKER;\n-  }) === true;\n-}"
        },
        {
            "sha": "6001896b5efdba045e0bd2d7146dccb74934dfdf",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/expression.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 3,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fexpression.ts",
            "raw_url": "https://github.com/angular/angular/raw/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fexpression.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fexpression.ts?ref=a46e0e48a3e470934319a0c3144d35aaae316288",
            "patch": "@@ -10,7 +10,7 @@ import {AST, AstVisitor, ASTWithSource, Binary, BindingPipe, Chain, Conditional,\n import * as ts from 'typescript';\n import {TypeCheckingConfig} from '../api';\n \n-import {addParseSpanInfo, wrapForDiagnostics} from './diagnostics';\n+import {addParseSpanInfo, wrapForDiagnostics, wrapForTypeChecker} from './diagnostics';\n import {tsCastToAny} from './ts_util';\n \n export const NULL_AS_ANY =\n@@ -112,7 +112,14 @@ class AstTranslator implements AstVisitor {\n   visitConditional(ast: Conditional): ts.Expression {\n     const condExpr = this.translate(ast.condition);\n     const trueExpr = this.translate(ast.trueExp);\n-    const falseExpr = this.translate(ast.falseExp);\n+    // Wrap `falseExpr` in parens so that the trailing parse span info is not attributed to the\n+    // whole conditional.\n+    // In the following example, the last source span comment (5,6) could be seen as the\n+    // trailing comment for _either_ the whole conditional expression _or_ just the `falseExpr` that\n+    // is immediately before it:\n+    // `conditional /*1,2*/ ? trueExpr /*3,4*/ : falseExpr /*5,6*/`\n+    // This should be instead be `conditional /*1,2*/ ? trueExpr /*3,4*/ : (falseExpr /*5,6*/)`\n+    const falseExpr = wrapForTypeChecker(this.translate(ast.falseExp));\n     const node = ts.createParen(ts.createConditional(condExpr, trueExpr, falseExpr));\n     addParseSpanInfo(node, ast.sourceSpan);\n     return node;\n@@ -135,7 +142,8 @@ class AstTranslator implements AstVisitor {\n     // interpolation's expressions. The chain is started using an actual string literal to ensure\n     // the type is inferred as 'string'.\n     return ast.expressions.reduce(\n-        (lhs, ast) => ts.createBinary(lhs, ts.SyntaxKind.PlusToken, this.translate(ast)),\n+        (lhs, ast) =>\n+            ts.createBinary(lhs, ts.SyntaxKind.PlusToken, wrapForTypeChecker(this.translate(ast))),\n         ts.createLiteral(''));\n   }\n "
        },
        {
            "sha": "4229892fa72e1b737b813668fde924d82dcb1d84",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.ts",
            "status": "modified",
            "additions": 142,
            "deletions": 72,
            "changes": 214,
            "blob_url": "https://github.com/angular/angular/blob/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "raw_url": "https://github.com/angular/angular/raw/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts?ref=a46e0e48a3e470934319a0c3144d35aaae316288",
            "patch": "@@ -14,16 +14,15 @@ import {ClassPropertyName} from '../../metadata';\n import {ClassDeclaration} from '../../reflection';\n import {TemplateId, TypeCheckableDirectiveMeta, TypeCheckBlockMetadata} from '../api';\n \n-import {addParseSpanInfo, addTemplateId, ignoreDiagnostics, wrapForDiagnostics} from './diagnostics';\n+import {addExpressionIdentifier, ExpressionIdentifier, markIgnoreDiagnostics} from './comments';\n+import {addParseSpanInfo, addTemplateId, wrapForDiagnostics} from './diagnostics';\n import {DomSchemaChecker} from './dom';\n import {Environment} from './environment';\n import {astToTypescript, NULL_AS_ANY} from './expression';\n import {OutOfBandDiagnosticRecorder} from './oob';\n import {ExpressionSemanticVisitor} from './template_semantics';\n import {checkIfClassIsExported, checkIfGenericTypesAreUnbound, tsCallMethod, tsCastToAny, tsCreateElement, tsCreateTypeQueryForCoercedInput, tsCreateVariable, tsDeclareVariable} from './ts_util';\n \n-\n-\n /**\n  * Given a `ts.ClassDeclaration` for a component, and metadata regarding that component, compose a\n  * \"type check block\" function.\n@@ -259,7 +258,7 @@ class TcbTemplateBodyOp extends TcbOp {\n \n             // The expression has already been checked in the type constructor invocation, so\n             // it should be ignored when used within a template guard.\n-            ignoreDiagnostics(expr);\n+            markIgnoreDiagnostics(expr);\n \n             if (guard.type === 'binding') {\n               // Use the binding expression itself as guard.\n@@ -377,11 +376,80 @@ class TcbDirectiveTypeOp extends TcbOp {\n     const id = this.tcb.allocateId();\n \n     const type = this.tcb.env.referenceType(this.dir.ref);\n+    addParseSpanInfo(type, this.node.startSourceSpan || this.node.sourceSpan);\n+    addExpressionIdentifier(type, ExpressionIdentifier.DIRECTIVE);\n     this.scope.addStatement(tsDeclareVariable(id, type));\n     return id;\n   }\n }\n \n+/**\n+ * A `TcbOp` which creates a variable for a local ref in a template.\n+ * The initializer for the variable is the variable expression for the directive, template, or\n+ * element the ref refers to. When the reference is used in the template, those TCB statements will\n+ * access this variable as well. For example:\n+ * ```\n+ * var _t1 = document.createElement('div');\n+ * var _t2 = _t1;\n+ * _t2.value\n+ * ```\n+ * This operation supports more fluent lookups for the `TemplateTypeChecker` when getting a symbol\n+ * for a reference. In most cases, this isn't essential; that is, the information for the symbol\n+ * could be gathered without this operation using the `BoundTarget`. However, for the case of\n+ * ng-template references, we will need this reference variable to not only provide a location in\n+ * the shim file, but also to narrow the variable to the correct `TemplateRef<T>` type rather than\n+ * `TemplateRef<any>` (this work is still TODO).\n+ *\n+ * Executing this operation returns a reference to the directive instance variable with its inferred\n+ * type.\n+ */\n+class TcbReferenceOp extends TcbOp {\n+  constructor(\n+      private readonly tcb: Context, private readonly scope: Scope,\n+      private readonly node: TmplAstReference,\n+      private readonly host: TmplAstElement|TmplAstTemplate,\n+      private readonly target: TypeCheckableDirectiveMeta|TmplAstTemplate|TmplAstElement) {\n+    super();\n+  }\n+\n+  // The statement generated by this operation is only used to for the Type Checker\n+  // so it can map a reference variable in the template directly to a node in the TCB.\n+  readonly optional = true;\n+\n+  execute(): ts.Identifier {\n+    const id = this.tcb.allocateId();\n+    let initializer = ts.getMutableClone(\n+        this.target instanceof TmplAstTemplate || this.target instanceof TmplAstElement ?\n+            this.scope.resolve(this.target) :\n+            this.scope.resolve(this.host, this.target));\n+\n+    // The reference is either to an element, an <ng-template> node, or to a directive on an\n+    // element or template.\n+    if ((this.target instanceof TmplAstElement && !this.tcb.env.config.checkTypeOfDomReferences) ||\n+        !this.tcb.env.config.checkTypeOfNonDomReferences) {\n+      // References to DOM nodes are pinned to 'any' when `checkTypeOfDomReferences` is `false`.\n+      // References to `TemplateRef`s and directives are pinned to 'any' when\n+      // `checkTypeOfNonDomReferences` is `false`.\n+      initializer =\n+          ts.createAsExpression(initializer, ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n+    } else if (this.target instanceof TmplAstTemplate) {\n+      // Direct references to an <ng-template> node simply require a value of type\n+      // `TemplateRef<any>`. To get this, an expression of the form\n+      // `(_t1 as any as TemplateRef<any>)` is constructed.\n+      initializer =\n+          ts.createAsExpression(initializer, ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n+      initializer = ts.createAsExpression(\n+          initializer,\n+          this.tcb.env.referenceExternalType('@angular/core', 'TemplateRef', [DYNAMIC_TYPE]));\n+      initializer = ts.createParen(initializer);\n+    }\n+    addParseSpanInfo(initializer, this.node.sourceSpan);\n+\n+    this.scope.addStatement(tsCreateVariable(id, initializer));\n+    return id;\n+  }\n+}\n+\n /**\n  * A `TcbOp` which constructs an instance of a directive with types inferred from its inputs. The\n  * inputs themselves are not checked here; checking of inputs is achieved in `TcbDirectiveInputsOp`.\n@@ -441,7 +509,7 @@ class TcbDirectiveCtorOp extends TcbOp {\n     // Call the type constructor of the directive to infer a type, and assign the directive\n     // instance.\n     const typeCtor = tcbCallTypeCtor(this.dir, this.tcb, Array.from(genericInputs.values()));\n-    ignoreDiagnostics(typeCtor);\n+    markIgnoreDiagnostics(typeCtor);\n     this.scope.addStatement(tsCreateVariable(id, typeCtor));\n     return id;\n   }\n@@ -731,7 +799,7 @@ class TcbUnclaimedInputsOp extends TcbOp {\n  *\n  * Executing this operation returns nothing.\n  */\n-class TcbDirectiveOutputsOp extends TcbOp {\n+export class TcbDirectiveOutputsOp extends TcbOp {\n   constructor(\n       private tcb: Context, private scope: Scope, private node: TmplAstTemplate|TmplAstElement,\n       private dir: TypeCheckableDirectiveMeta) {\n@@ -789,6 +857,39 @@ class TcbDirectiveOutputsOp extends TcbOp {\n \n     return null;\n   }\n+\n+  /**\n+   * Outputs are a `ts.CallExpression` that look like one of the two:\n+   *  - `_outputHelper(_t1[\"outputField\"]).subscribe(handler);`\n+   *  - `_t1.addEventListener(handler);`\n+   * This method reverses the operations to create a call expression for a directive output.\n+   * It unpacks the given call expression and returns the original element access (i.e.\n+   * `_t1[\"outputField\"]` in the example above). Returns `null` if the given call expression is not\n+   * the expected structure of an output binding\n+   */\n+  static decodeOutputCallExpression(node: ts.CallExpression): ts.ElementAccessExpression|null {\n+    // `node.expression` === `_outputHelper(_t1[\"outputField\"]).subscribe` or `_t1.addEventListener`\n+    if (!ts.isPropertyAccessExpression(node.expression) ||\n+        node.expression.name.text === 'addEventListener') {\n+      // `addEventListener` outputs do not have an `ElementAccessExpression` for the output field.\n+      return null;\n+    }\n+\n+    if (!ts.isCallExpression(node.expression.expression)) {\n+      return null;\n+    }\n+\n+    // `node.expression.expression` === `_outputHelper(_t1[\"outputField\"])`\n+    if (node.expression.expression.arguments.length === 0) {\n+      return null;\n+    }\n+\n+    const [outputFieldAccess] = node.expression.expression.arguments;\n+    if (!ts.isElementAccessExpression(outputFieldAccess)) {\n+      return null;\n+    }\n+    return outputFieldAccess;\n+  }\n }\n \n /**\n@@ -943,6 +1044,11 @@ class Scope {\n   private directiveOpMap =\n       new Map<TmplAstElement|TmplAstTemplate, Map<TypeCheckableDirectiveMeta, number>>();\n \n+  /**\n+   * A map of `TmplAstReference`s to the index of their `TcbReferenceOp` in the `opQueue`\n+   */\n+  private referenceOpMap = new Map<TmplAstReference, number>();\n+\n   /**\n    * Map of immediately nested <ng-template>s (within this `Scope`) represented by `TmplAstTemplate`\n    * nodes to the index of their `TcbTemplateContextOp`s in the `opQueue`.\n@@ -1023,12 +1129,13 @@ class Scope {\n    * * `TmplAstElement` - retrieve the expression for the element DOM node\n    * * `TmplAstTemplate` - retrieve the template context variable\n    * * `TmplAstVariable` - retrieve a template let- variable\n+   * * `TmplAstReference` - retrieve variable created for the local ref\n    *\n    * @param directive if present, a directive type on a `TmplAstElement` or `TmplAstTemplate` to\n    * look up instead of the default for an element or template node.\n    */\n   resolve(\n-      node: TmplAstElement|TmplAstTemplate|TmplAstVariable,\n+      node: TmplAstElement|TmplAstTemplate|TmplAstVariable|TmplAstReference,\n       directive?: TypeCheckableDirectiveMeta): ts.Expression {\n     // Attempt to resolve the operation locally.\n     const res = this.resolveLocal(node, directive);\n@@ -1054,7 +1161,10 @@ class Scope {\n    */\n   render(): ts.Statement[] {\n     for (let i = 0; i < this.opQueue.length; i++) {\n-      this.executeOp(i, /* skipOptional */ true);\n+      // Optional statements cannot be skipped when we are generating the TCB for use\n+      // by the TemplateTypeChecker.\n+      const skipOptional = !this.tcb.env.config.enableTemplateTypeChecker;\n+      this.executeOp(i, skipOptional);\n     }\n     return this.statements;\n   }\n@@ -1086,9 +1196,11 @@ class Scope {\n   }\n \n   private resolveLocal(\n-      ref: TmplAstElement|TmplAstTemplate|TmplAstVariable,\n+      ref: TmplAstElement|TmplAstTemplate|TmplAstVariable|TmplAstReference,\n       directive?: TypeCheckableDirectiveMeta): ts.Expression|null {\n-    if (ref instanceof TmplAstVariable && this.varMap.has(ref)) {\n+    if (ref instanceof TmplAstReference && this.referenceOpMap.has(ref)) {\n+      return this.resolveOp(this.referenceOpMap.get(ref)!);\n+    } else if (ref instanceof TmplAstVariable && this.varMap.has(ref)) {\n       // Resolving a context variable for this template.\n       // Execute the `TcbVariableOp` associated with the `TmplAstVariable`.\n       return this.resolveOp(this.varMap.get(ref)!);\n@@ -1163,27 +1275,38 @@ class Scope {\n       for (const child of node.children) {\n         this.appendNode(child);\n       }\n-      this.checkReferencesOfNode(node);\n+      this.checkAndAppendReferencesOfNode(node);\n     } else if (node instanceof TmplAstTemplate) {\n       // Template children are rendered in a child scope.\n       this.appendDirectivesAndInputsOfNode(node);\n       this.appendOutputsOfNode(node);\n+      const ctxIndex = this.opQueue.push(new TcbTemplateContextOp(this.tcb, this)) - 1;\n+      this.templateCtxOpMap.set(node, ctxIndex);\n       if (this.tcb.env.config.checkTemplateBodies) {\n-        const ctxIndex = this.opQueue.push(new TcbTemplateContextOp(this.tcb, this)) - 1;\n-        this.templateCtxOpMap.set(node, ctxIndex);\n         this.opQueue.push(new TcbTemplateBodyOp(this.tcb, this, node));\n       }\n-      this.checkReferencesOfNode(node);\n+      this.checkAndAppendReferencesOfNode(node);\n     } else if (node instanceof TmplAstBoundText) {\n       this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, node));\n     }\n   }\n \n-  private checkReferencesOfNode(node: TmplAstElement|TmplAstTemplate): void {\n+  private checkAndAppendReferencesOfNode(node: TmplAstElement|TmplAstTemplate): void {\n     for (const ref of node.references) {\n-      if (this.tcb.boundTarget.getReferenceTarget(ref) === null) {\n+      const target = this.tcb.boundTarget.getReferenceTarget(ref);\n+      if (target === null) {\n         this.tcb.oobRecorder.missingReferenceTarget(this.tcb.id, ref);\n+        continue;\n+      }\n+\n+      let ctxIndex: number;\n+      if (target instanceof TmplAstTemplate || target instanceof TmplAstElement) {\n+        ctxIndex = this.opQueue.push(new TcbReferenceOp(this.tcb, this, ref, node, target)) - 1;\n+      } else {\n+        ctxIndex =\n+            this.opQueue.push(new TcbReferenceOp(this.tcb, this, ref, node, target.directive)) - 1;\n       }\n+      this.referenceOpMap.set(ref, ctxIndex);\n     }\n   }\n \n@@ -1422,62 +1545,9 @@ class TcbExpressionTranslator {\n       return null;\n     }\n \n-    // This expression has a binding to some variable or reference in the template. Resolve it.\n-    if (binding instanceof TmplAstVariable) {\n-      const expr = ts.getMutableClone(this.scope.resolve(binding));\n-      addParseSpanInfo(expr, ast.sourceSpan);\n-      return expr;\n-    } else if (binding instanceof TmplAstReference) {\n-      const target = this.tcb.boundTarget.getReferenceTarget(binding);\n-      if (target === null) {\n-        // This reference is unbound. Traversal of the `TmplAstReference` itself should have\n-        // recorded the error in the `OutOfBandDiagnosticRecorder`.\n-        // Still check the rest of the expression if possible by using an `any` value.\n-        return NULL_AS_ANY;\n-      }\n-\n-      // The reference is either to an element, an <ng-template> node, or to a directive on an\n-      // element or template.\n-\n-      if (target instanceof TmplAstElement) {\n-        if (!this.tcb.env.config.checkTypeOfDomReferences) {\n-          // References to DOM nodes are pinned to 'any'.\n-          return NULL_AS_ANY;\n-        }\n-\n-        const expr = ts.getMutableClone(this.scope.resolve(target));\n-        addParseSpanInfo(expr, ast.sourceSpan);\n-        return expr;\n-      } else if (target instanceof TmplAstTemplate) {\n-        if (!this.tcb.env.config.checkTypeOfNonDomReferences) {\n-          // References to `TemplateRef`s pinned to 'any'.\n-          return NULL_AS_ANY;\n-        }\n-\n-        // Direct references to an <ng-template> node simply require a value of type\n-        // `TemplateRef<any>`. To get this, an expression of the form\n-        // `(null as any as TemplateRef<any>)` is constructed.\n-        let value: ts.Expression = ts.createNull();\n-        value = ts.createAsExpression(value, ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n-        value = ts.createAsExpression(\n-            value,\n-            this.tcb.env.referenceExternalType('@angular/core', 'TemplateRef', [DYNAMIC_TYPE]));\n-        value = ts.createParen(value);\n-        addParseSpanInfo(value, ast.sourceSpan);\n-        return value;\n-      } else {\n-        if (!this.tcb.env.config.checkTypeOfNonDomReferences) {\n-          // References to directives are pinned to 'any'.\n-          return NULL_AS_ANY;\n-        }\n-\n-        const expr = ts.getMutableClone(this.scope.resolve(target.node, target.directive));\n-        addParseSpanInfo(expr, ast.sourceSpan);\n-        return expr;\n-      }\n-    } else {\n-      throw new Error(`Unreachable: ${binding}`);\n-    }\n+    const expr = ts.getMutableClone(this.scope.resolve(binding));\n+    addParseSpanInfo(expr, ast.sourceSpan);\n+    return expr;\n   }\n }\n "
        },
        {
            "sha": "ad868292b25c8934db40a2d59db52015e321d73c",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/span_comments_spec.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fspan_comments_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fspan_comments_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fspan_comments_spec.ts?ref=a46e0e48a3e470934319a0c3144d35aaae316288",
            "patch": "@@ -22,12 +22,12 @@ describe('type check blocks diagnostics', () => {\n     it('should annotate conditions', () => {\n       expect(tcbWithSpans('{{ a ? b : c }}'))\n           .toContain(\n-              '(((ctx).a /*3,4*/) /*3,4*/ ? ((ctx).b /*7,8*/) /*7,8*/ : ((ctx).c /*11,12*/) /*11,12*/) /*3,12*/');\n+              '(((ctx).a /*3,4*/) /*3,4*/ ? ((ctx).b /*7,8*/) /*7,8*/ : (((ctx).c /*11,12*/) /*11,12*/)) /*3,12*/');\n     });\n \n     it('should annotate interpolations', () => {\n       expect(tcbWithSpans('{{ hello }} {{ world }}'))\n-          .toContain('\"\" + ((ctx).hello /*3,8*/) /*3,8*/ + ((ctx).world /*15,20*/) /*15,20*/');\n+          .toContain('\"\" + (((ctx).hello /*3,8*/) /*3,8*/) + (((ctx).world /*15,20*/) /*15,20*/)');\n     });\n \n     it('should annotate literal map expressions', () => {\n@@ -47,7 +47,7 @@ describe('type check blocks diagnostics', () => {\n \n     it('should annotate literals', () => {\n       const TEMPLATE = '{{ 123 }}';\n-      expect(tcbWithSpans(TEMPLATE)).toContain('123 /*3,6*/;');\n+      expect(tcbWithSpans(TEMPLATE)).toContain('123 /*3,6*/');\n     });\n \n     it('should annotate non-null assertions', () => {\n@@ -57,7 +57,7 @@ describe('type check blocks diagnostics', () => {\n \n     it('should annotate prefix not', () => {\n       const TEMPLATE = `{{ !a }}`;\n-      expect(tcbWithSpans(TEMPLATE)).toContain('!(((ctx).a /*4,5*/) /*4,5*/) /*3,5*/;');\n+      expect(tcbWithSpans(TEMPLATE)).toContain('!(((ctx).a /*4,5*/) /*4,5*/) /*3,5*/');\n     });\n \n     it('should annotate method calls', () => {\n@@ -141,7 +141,7 @@ describe('type check blocks diagnostics', () => {\n       }];\n       const block = tcbWithSpans(TEMPLATE, PIPES);\n       expect(block).toContain(\n-          '(null as TestPipe).transform(((ctx).a /*3,4*/) /*3,4*/, ((ctx).b /*12,13*/) /*12,13*/) /*3,13*/;');\n+          '((null as TestPipe).transform(((ctx).a /*3,4*/) /*3,4*/, ((ctx).b /*12,13*/) /*12,13*/) /*3,13*/);');\n     });\n \n     describe('attaching multiple comments for multiple references', () => {"
        },
        {
            "sha": "88bb3be9003494980a604de6184eb9747d90aed0",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/test_utils.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts?ref=a46e0e48a3e470934319a0c3144d35aaae316288",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {CssSelector, ParseSourceFile, ParseSourceSpan, parseTemplate, R3TargetBinder, SchemaMetadata, SelectorMatcher, TmplAstElement, TmplAstReference, Type} from '@angular/compiler';\n+import {CssSelector, ParseSourceFile, ParseSourceSpan, parseTemplate, R3TargetBinder, SchemaMetadata, SelectorMatcher, TmplAstElement, Type} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {absoluteFrom, AbsoluteFsPath, getSourceFileOrError, LogicalFileSystem} from '../../file_system';\n@@ -173,6 +173,7 @@ export const ALL_ENABLED_CONFIG: TypeCheckingConfig = {\n   strictSafeNavigationTypes: true,\n   useContextGenericType: true,\n   strictLiteralTypes: true,\n+  enableTemplateTypeChecker: false,\n };\n \n // Remove 'ref' from TypeCheckableDirectiveMeta and add a 'selector' instead.\n@@ -230,6 +231,7 @@ export function tcb(\n     strictSafeNavigationTypes: true,\n     useContextGenericType: true,\n     strictLiteralTypes: true,\n+    enableTemplateTypeChecker: false,\n   };\n   options = options || {\n     emitSpans: false,"
        },
        {
            "sha": "023503fb7417b1a6c382207c1114b453537519e9",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_check_block_spec.ts",
            "status": "modified",
            "additions": 66,
            "deletions": 33,
            "changes": 99,
            "blob_url": "https://github.com/angular/angular/blob/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts?ref=a46e0e48a3e470934319a0c3144d35aaae316288",
            "patch": "@@ -13,38 +13,38 @@ import {ALL_ENABLED_CONFIG, tcb, TestDeclaration, TestDirective} from './test_ut\n \n describe('type check blocks', () => {\n   it('should generate a basic block for a binding', () => {\n-    expect(tcb('{{hello}} {{world}}')).toContain('\"\" + ((ctx).hello) + ((ctx).world);');\n+    expect(tcb('{{hello}} {{world}}')).toContain('\"\" + (((ctx).hello)) + (((ctx).world));');\n   });\n \n   it('should generate literal map expressions', () => {\n     const TEMPLATE = '{{ method({foo: a, bar: b}) }}';\n-    expect(tcb(TEMPLATE)).toContain('(ctx).method({ \"foo\": ((ctx).a), \"bar\": ((ctx).b) });');\n+    expect(tcb(TEMPLATE)).toContain('(ctx).method({ \"foo\": ((ctx).a), \"bar\": ((ctx).b) })');\n   });\n \n   it('should generate literal array expressions', () => {\n     const TEMPLATE = '{{ method([a, b]) }}';\n-    expect(tcb(TEMPLATE)).toContain('(ctx).method([((ctx).a), ((ctx).b)]);');\n+    expect(tcb(TEMPLATE)).toContain('(ctx).method([((ctx).a), ((ctx).b)])');\n   });\n \n   it('should handle non-null assertions', () => {\n     const TEMPLATE = `{{a!}}`;\n-    expect(tcb(TEMPLATE)).toContain('((((ctx).a))!);');\n+    expect(tcb(TEMPLATE)).toContain('((((ctx).a))!)');\n   });\n \n   it('should handle unary - operator', () => {\n     const TEMPLATE = `{{-1}}`;\n-    expect(tcb(TEMPLATE)).toContain('(-1);');\n+    expect(tcb(TEMPLATE)).toContain('(-1)');\n   });\n \n   it('should handle keyed property access', () => {\n     const TEMPLATE = `{{a[b]}}`;\n-    expect(tcb(TEMPLATE)).toContain('(((ctx).a))[((ctx).b)];');\n+    expect(tcb(TEMPLATE)).toContain('(((ctx).a))[((ctx).b)]');\n   });\n \n   it('should handle nested ternary expressions', () => {\n     const TEMPLATE = `{{a ? b : c ? d : e}}`;\n     expect(tcb(TEMPLATE))\n-        .toContain('(((ctx).a) ? ((ctx).b) : (((ctx).c) ? ((ctx).d) : ((ctx).e)))');\n+        .toContain('(((ctx).a) ? ((ctx).b) : ((((ctx).c) ? ((ctx).d) : (((ctx).e)))))');\n   });\n \n   it('should handle quote expressions as any type', () => {\n@@ -106,7 +106,7 @@ describe('type check blocks', () => {\n   it('should handle method calls of template variables', () => {\n     const TEMPLATE = `<ng-template let-a>{{a(1)}}</ng-template>`;\n     expect(tcb(TEMPLATE)).toContain('var _t2 = _t1.$implicit;');\n-    expect(tcb(TEMPLATE)).toContain('(_t2).a(1);');\n+    expect(tcb(TEMPLATE)).toContain('(_t2).a(1)');\n   });\n \n   it('should handle implicit vars when using microsyntax', () => {\n@@ -179,8 +179,9 @@ describe('type check blocks', () => {\n       }];\n       expect(tcb(TEMPLATE, DIRECTIVES))\n           .toContain(\n-              'var _t2 = Dir.ngTypeCtor((null!)); ' +\n-              'var _t1 = Dir.ngTypeCtor({ \"input\": (_t2) });');\n+              'var _t2 = Dir.ngTypeCtor({ \"input\": (null!) }); ' +\n+              'var _t1 = _t2; ' +\n+              '_t2.input = (_t1);');\n     });\n \n     it('should generate circular references between two directives correctly', () => {\n@@ -208,9 +209,12 @@ describe('type check blocks', () => {\n       ];\n       expect(tcb(TEMPLATE, DIRECTIVES))\n           .toContain(\n-              'var _t3 = DirB.ngTypeCtor((null!)); ' +\n-              'var _t2 = DirA.ngTypeCtor({ \"inputA\": (_t3) }); ' +\n-              'var _t1 = DirB.ngTypeCtor({ \"inputB\": (_t2) });');\n+              'var _t4 = DirA.ngTypeCtor({ \"inputA\": (null!) }); ' +\n+              'var _t3 = _t4; ' +\n+              'var _t2 = DirB.ngTypeCtor({ \"inputB\": (_t3) }); ' +\n+              'var _t1 = _t2; ' +\n+              '_t4.inputA = (_t1); ' +\n+              '_t2.inputB = (_t3);');\n     });\n \n     it('should handle empty bindings', () => {\n@@ -263,8 +267,10 @@ describe('type check blocks', () => {\n     `;\n     const block = tcb(TEMPLATE);\n     expect(block).not.toContain('\"div\"');\n-    expect(block).toContain('var _t1 = document.createElement(\"button\");');\n-    expect(block).toContain('(ctx).handle(_t1);');\n+    expect(block).toContain(\n+        'var _t2 = document.createElement(\"button\"); ' +\n+        'var _t1 = _t2; ' +\n+        '_t2.addEventListener');\n   });\n \n   it('should only generate directive declarations that have bindings or are referenced', () => {\n@@ -313,7 +319,8 @@ describe('type check blocks', () => {\n     expect(block).toContain('_t1.input = (((ctx).value));');\n     expect(block).toContain('var _t2: HasOutput = (null!)');\n     expect(block).toContain('_t2[\"output\"]');\n-    expect(block).toContain('var _t3: HasReference = (null!)');\n+    expect(block).toContain('var _t4: HasReference = (null!)');\n+    expect(block).toContain('var _t3 = _t4;');\n     expect(block).toContain('(_t3).a');\n     expect(block).not.toContain('NoBindings');\n     expect(block).not.toContain('NoReference');\n@@ -325,7 +332,8 @@ describe('type check blocks', () => {\n       <input #i>\n     `;\n     expect(tcb(TEMPLATE))\n-        .toContain('var _t1 = document.createElement(\"input\"); \"\" + ((_t1).value);');\n+        .toContain(\n+            'var _t2 = document.createElement(\"input\"); var _t1 = _t2; \"\" + (((_t1).value));');\n   });\n \n   it('should generate a forward directive reference correctly', () => {\n@@ -339,7 +347,11 @@ describe('type check blocks', () => {\n       selector: '[dir]',\n       exportAs: ['dir'],\n     }];\n-    expect(tcb(TEMPLATE, DIRECTIVES)).toContain('var _t1: Dir = (null!); \"\" + ((_t1).value);');\n+    expect(tcb(TEMPLATE, DIRECTIVES))\n+        .toContain(\n+            'var _t2: Dir = (null!); ' +\n+            'var _t1 = _t2; ' +\n+            '\"\" + (((_t1).value));');\n   });\n \n   it('should handle style and class bindings specially', () => {\n@@ -385,8 +397,9 @@ describe('type check blocks', () => {\n     }];\n     expect(tcb(TEMPLATE, DIRECTIVES))\n         .toContain(\n-            'var _t1: Dir = (null!); ' +\n-            '_t1.input = (_t1);');\n+            'var _t2: Dir = (null!); ' +\n+            'var _t1 = _t2; ' +\n+            '_t2.input = (_t1);');\n   });\n \n   it('should generate circular references between two directives correctly', () => {\n@@ -412,10 +425,12 @@ describe('type check blocks', () => {\n     ];\n     expect(tcb(TEMPLATE, DIRECTIVES))\n         .toContain(\n-            'var _t1: DirB = (null!); ' +\n-            'var _t2: DirA = (null!); ' +\n-            '_t2.inputA = (_t1); ' +\n-            '_t1.inputA = (_t2);');\n+            'var _t2: DirB = (null!); ' +\n+            'var _t1 = _t2; ' +\n+            'var _t3: DirA = (null!); ' +\n+            '_t3.inputA = (_t1); ' +\n+            'var _t4 = _t3; ' +\n+            '_t2.inputA = (_t4);');\n   });\n \n   it('should handle undeclared properties', () => {\n@@ -566,7 +581,7 @@ describe('type check blocks', () => {\n   it('should handle $any casts', () => {\n     const TEMPLATE = `{{$any(a)}}`;\n     const block = tcb(TEMPLATE);\n-    expect(block).toContain('(((ctx).a) as any);');\n+    expect(block).toContain('(((ctx).a) as any)');\n   });\n \n   describe('experimental DOM checking via lib.dom.d.ts', () => {\n@@ -699,6 +714,7 @@ describe('type check blocks', () => {\n       strictSafeNavigationTypes: true,\n       useContextGenericType: true,\n       strictLiteralTypes: true,\n+      enableTemplateTypeChecker: false,\n     };\n \n     describe('config.applyTemplateContextGuards', () => {\n@@ -718,16 +734,27 @@ describe('type check blocks', () => {\n     });\n \n     describe('config.checkTemplateBodies', () => {\n-      const TEMPLATE = `<ng-template>{{a}}</ng-template>`;\n+      const TEMPLATE = `<ng-template #ref>{{a}}</ng-template>{{ref}}`;\n \n       it('should descend into template bodies when enabled', () => {\n         const block = tcb(TEMPLATE, DIRECTIVES);\n-        expect(block).toContain('((ctx).a);');\n+        expect(block).toContain('((ctx).a)');\n       });\n       it('should not descend into template bodies when disabled', () => {\n         const DISABLED_CONFIG: TypeCheckingConfig = {...BASE_CONFIG, checkTemplateBodies: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n-        expect(block).not.toContain('((ctx).a);');\n+        expect(block).not.toContain('((ctx).a)');\n+      });\n+\n+      it('generates a references var when enabled', () => {\n+        const block = tcb(TEMPLATE, DIRECTIVES);\n+        expect(block).toContain('var _t2 = (_t1 as any as core.TemplateRef<any>);');\n+      });\n+\n+      it('generates a reference var when disabled', () => {\n+        const DISABLED_CONFIG: TypeCheckingConfig = {...BASE_CONFIG, checkTemplateBodies: false};\n+        const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n+        expect(block).toContain('var _t2 = (_t1 as any as core.TemplateRef<any>);');\n       });\n     });\n \n@@ -844,7 +871,9 @@ describe('type check blocks', () => {\n         const DISABLED_CONFIG:\n             TypeCheckingConfig = {...BASE_CONFIG, checkTypeOfDomReferences: false};\n         const block = tcb(TEMPLATE, [], DISABLED_CONFIG);\n-        expect(block).toContain('(null as any).value');\n+        expect(block).toContain(\n+            'var _t1 = (_t2 as any); ' +\n+            '\"\" + (((_t1).value));');\n       });\n     });\n \n@@ -868,14 +897,18 @@ describe('type check blocks', () => {\n \n       it('should trace references to an <ng-template> when enabled', () => {\n         const block = tcb(TEMPLATE, DIRECTIVES);\n-        expect(block).toContain('((null as any as core.TemplateRef<any>)).value2');\n+        expect(block).toContain(\n+            'var _t4 = (_t3 as any as core.TemplateRef<any>); ' +\n+            '\"\" + (((_t4).value2));');\n       });\n \n       it('should use any for reference types when disabled', () => {\n         const DISABLED_CONFIG:\n             TypeCheckingConfig = {...BASE_CONFIG, checkTypeOfNonDomReferences: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n-        expect(block).toContain('(null as any).value');\n+        expect(block).toContain(\n+            'var _t1 = (_t2 as any); ' +\n+            '\"\" + (((_t1).value));');\n       });\n     });\n \n@@ -914,12 +947,12 @@ describe('type check blocks', () => {\n \n       it('should check types of pipes when enabled', () => {\n         const block = tcb(TEMPLATE, PIPES);\n-        expect(block).toContain('(null as TestPipe).transform(((ctx).a), ((ctx).b), ((ctx).c));');\n+        expect(block).toContain('(null as TestPipe).transform(((ctx).a), ((ctx).b), ((ctx).c))');\n       });\n       it('should not check types of pipes when disabled', () => {\n         const DISABLED_CONFIG: TypeCheckingConfig = {...BASE_CONFIG, checkTypeOfPipes: false};\n         const block = tcb(TEMPLATE, PIPES, DISABLED_CONFIG);\n-        expect(block).toContain('(null as any).transform(((ctx).a), ((ctx).b), ((ctx).c));');\n+        expect(block).toContain('(null as any).transform(((ctx).a), ((ctx).b), ((ctx).c))');\n       });\n     });\n "
        },
        {
            "sha": "88b7edfd0359775568835f32d53df29510be3059",
            "filename": "packages/language-service/ivy/language_service.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "raw_url": "https://github.com/angular/angular/raw/a46e0e48a3e470934319a0c3144d35aaae316288/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts?ref=a46e0e48a3e470934319a0c3144d35aaae316288",
            "patch": "@@ -52,7 +52,9 @@ export class LanguageService {\n         program,\n         this.strategy,\n         new PatchedProgramIncrementalBuildStrategy(),\n+        /** enableTemplateTypeChecker */ true,\n         this.lastKnownProgram,\n+        /** perfRecorder (use default) */ undefined,\n     );\n   }\n "
        }
    ],
    "stats": {
        "total": 500,
        "additions": 346,
        "deletions": 154
    }
}