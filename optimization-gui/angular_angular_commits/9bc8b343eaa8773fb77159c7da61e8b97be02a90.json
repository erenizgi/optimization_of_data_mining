{
    "author": "atscott",
    "message": "refactor(language-service): extract utility functions for reference and rename (#40523)\n\nThis commit extracts utility functions and separates them from the core logic of the\nreferences and rename builder.\n\nPR Close #40523",
    "sha": "9bc8b343eaa8773fb77159c7da61e8b97be02a90",
    "files": [
        {
            "sha": "5847c366f3cdfd644c56dc060a30a1cbb371a0c6",
            "filename": "packages/language-service/ivy/references_and_rename.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 244,
            "changes": 259,
            "blob_url": "https://github.com/angular/angular/blob/9bc8b343eaa8773fb77159c7da61e8b97be02a90/packages%2Flanguage-service%2Fivy%2Freferences_and_rename.ts",
            "raw_url": "https://github.com/angular/angular/raw/9bc8b343eaa8773fb77159c7da61e8b97be02a90/packages%2Flanguage-service%2Fivy%2Freferences_and_rename.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Freferences_and_rename.ts?ref=9bc8b343eaa8773fb77159c7da61e8b97be02a90",
            "patch": "@@ -5,27 +5,17 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {AbsoluteSourceSpan, AST, BindingPipe, LiteralPrimitive, MethodCall, ParseSourceSpan, PropertyRead, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstNode, TmplAstReference, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n+import {AST, TmplAstNode} from '@angular/compiler';\n import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n-import {absoluteFrom, absoluteFromSourceFile, AbsoluteFsPath} from '@angular/compiler-cli/src/ngtsc/file_system';\n+import {absoluteFrom} from '@angular/compiler-cli/src/ngtsc/file_system';\n import {PerfPhase} from '@angular/compiler-cli/src/ngtsc/perf';\n import {ProgramDriver} from '@angular/compiler-cli/src/ngtsc/program_driver';\n-import {DirectiveSymbol, ShimLocation, SymbolKind, TemplateTypeChecker} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n-import {ExpressionIdentifier, hasExpressionIdentifier} from '@angular/compiler-cli/src/ngtsc/typecheck/src/comments';\n import * as ts from 'typescript';\n \n-import {getTargetAtPosition, TargetNodeKind} from './template_target';\n+import {convertToTemplateDocumentSpan, createLocationKey, getRenameTextAndSpanAtPosition, getTargetDetailsAtTemplatePosition} from './references_and_rename_utils';\n import {findTightestNode} from './ts_utils';\n-import {getDirectiveMatchesForAttribute, getDirectiveMatchesForElementTag, getTemplateInfoAtPosition, getTemplateLocationFromShimLocation, isWithin, TemplateInfo, toTextSpan} from './utils';\n+import {getTemplateInfoAtPosition, TemplateInfo} from './utils';\n \n-interface FilePosition {\n-  fileName: string;\n-  position: number;\n-}\n-\n-function toFilePosition(shimLocation: ShimLocation): FilePosition {\n-  return {fileName: shimLocation.shimPath, position: shimLocation.positionInShimFile};\n-}\n \n enum RequestKind {\n   Template,\n@@ -45,20 +35,6 @@ interface TypeScriptRequest {\n \n type RequestOrigin = TemplateRequest|TypeScriptRequest;\n \n-interface TemplateLocationDetails {\n-  /**\n-   * A target node in a template.\n-   */\n-  templateTarget: TmplAstNode|AST;\n-\n-  /**\n-   * TypeScript locations which the template node maps to. A given template node might map to\n-   * several TS nodes. For example, a template node for an attribute might resolve to several\n-   * directives or a directive and one of its inputs.\n-   */\n-  typescriptLocations: FilePosition[];\n-}\n-\n export class ReferencesAndRenameBuilder {\n   private readonly ttc = this.compiler.getTemplateTypeChecker();\n \n@@ -76,15 +52,18 @@ export class ReferencesAndRenameBuilder {\n         return this.tsLS.getRenameInfo(filePath, position);\n       }\n \n-      const allTargetDetails = this.getTargetDetailsAtTemplatePosition(templateInfo, position);\n+      const allTargetDetails = getTargetDetailsAtTemplatePosition(templateInfo, position, this.ttc);\n       if (allTargetDetails === null) {\n         return {\n           canRename: false,\n-          localizedErrorMessage: 'Could not find template node at position.',\n+          localizedErrorMessage: 'Could not find template node at position.'\n         };\n       }\n       const {templateTarget} = allTargetDetails[0];\n-      const templateTextAndSpan = getRenameTextAndSpanAtPosition(templateTarget, position);\n+      const templateTextAndSpan = getRenameTextAndSpanAtPosition(\n+          templateTarget,\n+          position,\n+      );\n       if (templateTextAndSpan === null) {\n         return {canRename: false, localizedErrorMessage: 'Could not determine template node text.'};\n       }\n@@ -119,7 +98,7 @@ export class ReferencesAndRenameBuilder {\n \n   private findRenameLocationsAtTemplatePosition(templateInfo: TemplateInfo, position: number):\n       readonly ts.RenameLocation[]|undefined {\n-    const allTargetDetails = this.getTargetDetailsAtTemplatePosition(templateInfo, position);\n+    const allTargetDetails = getTargetDetailsAtTemplatePosition(templateInfo, position, this.ttc);\n     if (allTargetDetails === null) {\n       return undefined;\n     }\n@@ -181,7 +160,8 @@ export class ReferencesAndRenameBuilder {\n         // TODO(atscott): Determine if a file is a shim file in a more robust way and make the API\n         // available in an appropriate location.\n         if (this.ttc.isTrackedTypeCheckFile(absoluteFrom(location.fileName))) {\n-          const entry = this.convertToTemplateDocumentSpan(location, this.ttc, originalNodeText);\n+          const entry = convertToTemplateDocumentSpan(\n+              location, this.ttc, this.driver.getProgram(), originalNodeText);\n           // There is no template node whose text matches the original rename request. Bail on\n           // renaming completely rather than providing incomplete results.\n           if (entry === null) {\n@@ -215,7 +195,7 @@ export class ReferencesAndRenameBuilder {\n \n   private getReferencesAtTemplatePosition(templateInfo: TemplateInfo, position: number):\n       ts.ReferenceEntry[]|undefined {\n-    const allTargetDetails = this.getTargetDetailsAtTemplatePosition(templateInfo, position);\n+    const allTargetDetails = getTargetDetailsAtTemplatePosition(templateInfo, position, this.ttc);\n     if (allTargetDetails === null) {\n       return undefined;\n     }\n@@ -231,126 +211,6 @@ export class ReferencesAndRenameBuilder {\n     return allReferences.length > 0 ? allReferences : undefined;\n   }\n \n-  private getTargetDetailsAtTemplatePosition({template, component}: TemplateInfo, position: number):\n-      TemplateLocationDetails[]|null {\n-    // Find the AST node in the template at the position.\n-    const positionDetails = getTargetAtPosition(template, position);\n-    if (positionDetails === null) {\n-      return null;\n-    }\n-\n-    const nodes = positionDetails.context.kind === TargetNodeKind.TwoWayBindingContext ?\n-        positionDetails.context.nodes :\n-        [positionDetails.context.node];\n-\n-    const details: TemplateLocationDetails[] = [];\n-\n-    for (const node of nodes) {\n-      // Get the information about the TCB at the template position.\n-      const symbol = this.ttc.getSymbolOfNode(node, component);\n-      if (symbol === null) {\n-        continue;\n-      }\n-\n-      const templateTarget = node;\n-      switch (symbol.kind) {\n-        case SymbolKind.Directive:\n-        case SymbolKind.Template:\n-          // References to elements, templates, and directives will be through template references\n-          // (#ref). They shouldn't be used directly for a Language Service reference request.\n-          break;\n-        case SymbolKind.Element: {\n-          const matches = getDirectiveMatchesForElementTag(symbol.templateNode, symbol.directives);\n-          details.push(\n-              {typescriptLocations: this.getPositionsForDirectives(matches), templateTarget});\n-          break;\n-        }\n-        case SymbolKind.DomBinding: {\n-          // Dom bindings aren't currently type-checked (see `checkTypeOfDomBindings`) so they don't\n-          // have a shim location. This means we can't match dom bindings to their lib.dom\n-          // reference, but we can still see if they match to a directive.\n-          if (!(node instanceof TmplAstTextAttribute) && !(node instanceof TmplAstBoundAttribute)) {\n-            return null;\n-          }\n-          const directives = getDirectiveMatchesForAttribute(\n-              node.name, symbol.host.templateNode, symbol.host.directives);\n-          details.push({\n-            typescriptLocations: this.getPositionsForDirectives(directives),\n-            templateTarget,\n-          });\n-          break;\n-        }\n-        case SymbolKind.Reference: {\n-          details.push({\n-            typescriptLocations: [toFilePosition(symbol.referenceVarLocation)],\n-            templateTarget,\n-          });\n-          break;\n-        }\n-        case SymbolKind.Variable: {\n-          if ((templateTarget instanceof TmplAstVariable)) {\n-            if (templateTarget.valueSpan !== undefined &&\n-                isWithin(position, templateTarget.valueSpan)) {\n-              // In the valueSpan of the variable, we want to get the reference of the initializer.\n-              details.push({\n-                typescriptLocations: [toFilePosition(symbol.initializerLocation)],\n-                templateTarget,\n-              });\n-            } else if (isWithin(position, templateTarget.keySpan)) {\n-              // In the keySpan of the variable, we want to get the reference of the local variable.\n-              details.push({\n-                typescriptLocations: [toFilePosition(symbol.localVarLocation)],\n-                templateTarget,\n-              });\n-            }\n-          } else {\n-            // If the templateNode is not the `TmplAstVariable`, it must be a usage of the\n-            // variable somewhere in the template.\n-            details.push({\n-              typescriptLocations: [toFilePosition(symbol.localVarLocation)],\n-              templateTarget,\n-            });\n-          }\n-          break;\n-        }\n-        case SymbolKind.Input:\n-        case SymbolKind.Output: {\n-          details.push({\n-            typescriptLocations:\n-                symbol.bindings.map(binding => toFilePosition(binding.shimLocation)),\n-            templateTarget,\n-          });\n-          break;\n-        }\n-        case SymbolKind.Pipe:\n-        case SymbolKind.Expression: {\n-          details.push(\n-              {typescriptLocations: [toFilePosition(symbol.shimLocation)], templateTarget});\n-          break;\n-        }\n-      }\n-    }\n-\n-    return details.length > 0 ? details : null;\n-  }\n-\n-  private getPositionsForDirectives(directives: Set<DirectiveSymbol>): FilePosition[] {\n-    const allDirectives: FilePosition[] = [];\n-    for (const dir of directives.values()) {\n-      const dirClass = dir.tsSymbol.valueDeclaration;\n-      if (dirClass === undefined || !ts.isClassDeclaration(dirClass) ||\n-          dirClass.name === undefined) {\n-        continue;\n-      }\n-\n-      const {fileName} = dirClass.getSourceFile();\n-      const position = dirClass.name.getStart();\n-      allDirectives.push({fileName, position});\n-    }\n-\n-    return allDirectives;\n-  }\n-\n   private getReferencesAtTypescriptPosition(fileName: string, position: number):\n       ts.ReferenceEntry[]|undefined {\n     const refs = this.tsLS.getReferencesAtPosition(fileName, position);\n@@ -361,7 +221,7 @@ export class ReferencesAndRenameBuilder {\n     const entries: Map<string, ts.ReferenceEntry> = new Map();\n     for (const ref of refs) {\n       if (this.ttc.isTrackedTypeCheckFile(absoluteFrom(ref.fileName))) {\n-        const entry = this.convertToTemplateDocumentSpan(ref, this.ttc);\n+        const entry = convertToTemplateDocumentSpan(ref, this.ttc, this.driver.getProgram());\n         if (entry !== null) {\n           entries.set(createLocationKey(entry), entry);\n         }\n@@ -371,93 +231,4 @@ export class ReferencesAndRenameBuilder {\n     }\n     return Array.from(entries.values());\n   }\n-\n-  private convertToTemplateDocumentSpan<T extends ts.DocumentSpan>(\n-      shimDocumentSpan: T, templateTypeChecker: TemplateTypeChecker, requiredNodeText?: string): T\n-      |null {\n-    const sf = this.driver.getProgram().getSourceFile(shimDocumentSpan.fileName);\n-    if (sf === undefined) {\n-      return null;\n-    }\n-    const tcbNode = findTightestNode(sf, shimDocumentSpan.textSpan.start);\n-    if (tcbNode === undefined ||\n-        hasExpressionIdentifier(sf, tcbNode, ExpressionIdentifier.EVENT_PARAMETER)) {\n-      // If the reference result is the $event parameter in the subscribe/addEventListener\n-      // function in the TCB, we want to filter this result out of the references. We really only\n-      // want to return references to the parameter in the template itself.\n-      return null;\n-    }\n-    // TODO(atscott): Determine how to consistently resolve paths. i.e. with the project\n-    // serverHost or LSParseConfigHost in the adapter. We should have a better defined way to\n-    // normalize paths.\n-    const mapping = getTemplateLocationFromShimLocation(\n-        templateTypeChecker, absoluteFrom(shimDocumentSpan.fileName),\n-        shimDocumentSpan.textSpan.start);\n-    if (mapping === null) {\n-      return null;\n-    }\n-\n-    const {span, templateUrl} = mapping;\n-    if (requiredNodeText !== undefined && span.toString() !== requiredNodeText) {\n-      return null;\n-    }\n-\n-    return {\n-      ...shimDocumentSpan,\n-      fileName: templateUrl,\n-      textSpan: toTextSpan(span),\n-      // Specifically clear other text span values because we do not have enough knowledge to\n-      // convert these to spans in the template.\n-      contextSpan: undefined,\n-      originalContextSpan: undefined,\n-      originalTextSpan: undefined,\n-    };\n-  }\n-}\n-\n-function getRenameTextAndSpanAtPosition(\n-    node: TmplAstNode|AST, position: number): {text: string, span: ts.TextSpan}|null {\n-  if (node instanceof TmplAstBoundAttribute || node instanceof TmplAstTextAttribute ||\n-      node instanceof TmplAstBoundEvent) {\n-    if (node.keySpan === undefined) {\n-      return null;\n-    }\n-    return {text: node.name, span: toTextSpan(node.keySpan)};\n-  } else if (node instanceof TmplAstVariable || node instanceof TmplAstReference) {\n-    if (isWithin(position, node.keySpan)) {\n-      return {text: node.keySpan.toString(), span: toTextSpan(node.keySpan)};\n-    } else if (node.valueSpan && isWithin(position, node.valueSpan)) {\n-      return {text: node.valueSpan.toString(), span: toTextSpan(node.valueSpan)};\n-    }\n-  }\n-\n-  if (node instanceof BindingPipe) {\n-    // TODO(atscott): Add support for renaming pipes\n-    return null;\n-  }\n-  if (node instanceof PropertyRead || node instanceof MethodCall || node instanceof PropertyWrite ||\n-      node instanceof SafePropertyRead || node instanceof SafeMethodCall) {\n-    return {text: node.name, span: toTextSpan(node.nameSpan)};\n-  } else if (node instanceof LiteralPrimitive) {\n-    const span = toTextSpan(node.sourceSpan);\n-    const text = node.value;\n-    if (typeof text === 'string') {\n-      // The span of a string literal includes the quotes but they should be removed for renaming.\n-      span.start += 1;\n-      span.length -= 2;\n-    }\n-    return {text, span};\n-  }\n-\n-  return null;\n-}\n-\n-\n-/**\n- * Creates a \"key\" for a rename/reference location by concatenating file name, span start, and span\n- * length. This allows us to de-duplicate template results when an item may appear several times\n- * in the TCB but map back to the same template location.\n- */\n-function createLocationKey(ds: ts.DocumentSpan) {\n-  return ds.fileName + ds.textSpan.start + ds.textSpan.length;\n }\n\\ No newline at end of file"
        },
        {
            "sha": "0753ecef7e128466897d4e9178c089dea288aa7e",
            "filename": "packages/language-service/ivy/references_and_rename_utils.ts",
            "status": "added",
            "additions": 244,
            "deletions": 0,
            "changes": 244,
            "blob_url": "https://github.com/angular/angular/blob/9bc8b343eaa8773fb77159c7da61e8b97be02a90/packages%2Flanguage-service%2Fivy%2Freferences_and_rename_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/9bc8b343eaa8773fb77159c7da61e8b97be02a90/packages%2Flanguage-service%2Fivy%2Freferences_and_rename_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Freferences_and_rename_utils.ts?ref=9bc8b343eaa8773fb77159c7da61e8b97be02a90",
            "patch": "@@ -0,0 +1,244 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {AST, BindingPipe, LiteralPrimitive, MethodCall, PropertyRead, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstNode, TmplAstReference, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n+import {absoluteFrom} from '@angular/compiler-cli/src/ngtsc/file_system';\n+import {DirectiveSymbol, ShimLocation, SymbolKind, TemplateTypeChecker} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n+import {ExpressionIdentifier, hasExpressionIdentifier} from '@angular/compiler-cli/src/ngtsc/typecheck/src/comments';\n+import * as ts from 'typescript';\n+\n+import {getTargetAtPosition, TargetNodeKind} from './template_target';\n+import {findTightestNode} from './ts_utils';\n+import {getDirectiveMatchesForAttribute, getDirectiveMatchesForElementTag, getTemplateLocationFromShimLocation, isWithin, TemplateInfo, toTextSpan} from './utils';\n+\n+interface FilePosition {\n+  fileName: string;\n+  position: number;\n+}\n+\n+function toFilePosition(shimLocation: ShimLocation): FilePosition {\n+  return {fileName: shimLocation.shimPath, position: shimLocation.positionInShimFile};\n+}\n+export interface TemplateLocationDetails {\n+  /**\n+   * A target node in a template.\n+   */\n+  templateTarget: TmplAstNode|AST;\n+\n+  /**\n+   * TypeScript locations which the template node maps to. A given template node might map to\n+   * several TS nodes. For example, a template node for an attribute might resolve to several\n+   * directives or a directive and one of its inputs.\n+   */\n+  typescriptLocations: FilePosition[];\n+}\n+\n+\n+export function getTargetDetailsAtTemplatePosition(\n+    {template, component}: TemplateInfo, position: number,\n+    templateTypeChecker: TemplateTypeChecker): TemplateLocationDetails[]|null {\n+  // Find the AST node in the template at the position.\n+  const positionDetails = getTargetAtPosition(template, position);\n+  if (positionDetails === null) {\n+    return null;\n+  }\n+\n+  const nodes = positionDetails.context.kind === TargetNodeKind.TwoWayBindingContext ?\n+      positionDetails.context.nodes :\n+      [positionDetails.context.node];\n+\n+  const details: TemplateLocationDetails[] = [];\n+\n+  for (const node of nodes) {\n+    // Get the information about the TCB at the template position.\n+    const symbol = templateTypeChecker.getSymbolOfNode(node, component);\n+    if (symbol === null) {\n+      continue;\n+    }\n+\n+    const templateTarget = node;\n+    switch (symbol.kind) {\n+      case SymbolKind.Directive:\n+      case SymbolKind.Template:\n+        // References to elements, templates, and directives will be through template references\n+        // (#ref). They shouldn't be used directly for a Language Service reference request.\n+        break;\n+      case SymbolKind.Element: {\n+        const matches = getDirectiveMatchesForElementTag(symbol.templateNode, symbol.directives);\n+        details.push({typescriptLocations: getPositionsForDirectives(matches), templateTarget});\n+        break;\n+      }\n+      case SymbolKind.DomBinding: {\n+        // Dom bindings aren't currently type-checked (see `checkTypeOfDomBindings`) so they don't\n+        // have a shim location. This means we can't match dom bindings to their lib.dom\n+        // reference, but we can still see if they match to a directive.\n+        if (!(node instanceof TmplAstTextAttribute) && !(node instanceof TmplAstBoundAttribute)) {\n+          return null;\n+        }\n+        const directives = getDirectiveMatchesForAttribute(\n+            node.name, symbol.host.templateNode, symbol.host.directives);\n+        details.push({\n+          typescriptLocations: getPositionsForDirectives(directives),\n+          templateTarget,\n+        });\n+        break;\n+      }\n+      case SymbolKind.Reference: {\n+        details.push({\n+          typescriptLocations: [toFilePosition(symbol.referenceVarLocation)],\n+          templateTarget,\n+        });\n+        break;\n+      }\n+      case SymbolKind.Variable: {\n+        if ((templateTarget instanceof TmplAstVariable)) {\n+          if (templateTarget.valueSpan !== undefined &&\n+              isWithin(position, templateTarget.valueSpan)) {\n+            // In the valueSpan of the variable, we want to get the reference of the initializer.\n+            details.push({\n+              typescriptLocations: [toFilePosition(symbol.initializerLocation)],\n+              templateTarget,\n+            });\n+          } else if (isWithin(position, templateTarget.keySpan)) {\n+            // In the keySpan of the variable, we want to get the reference of the local variable.\n+            details.push({\n+              typescriptLocations: [toFilePosition(symbol.localVarLocation)],\n+              templateTarget,\n+            });\n+          }\n+        } else {\n+          // If the templateNode is not the `TmplAstVariable`, it must be a usage of the\n+          // variable somewhere in the template.\n+          details.push({\n+            typescriptLocations: [toFilePosition(symbol.localVarLocation)],\n+            templateTarget,\n+          });\n+        }\n+        break;\n+      }\n+      case SymbolKind.Input:\n+      case SymbolKind.Output: {\n+        details.push({\n+          typescriptLocations: symbol.bindings.map(binding => toFilePosition(binding.shimLocation)),\n+          templateTarget,\n+        });\n+        break;\n+      }\n+      case SymbolKind.Pipe:\n+      case SymbolKind.Expression: {\n+        details.push({typescriptLocations: [toFilePosition(symbol.shimLocation)], templateTarget});\n+        break;\n+      }\n+    }\n+  }\n+\n+  return details.length > 0 ? details : null;\n+}\n+\n+function getPositionsForDirectives(directives: Set<DirectiveSymbol>): FilePosition[] {\n+  const allDirectives: FilePosition[] = [];\n+  for (const dir of directives.values()) {\n+    const dirClass = dir.tsSymbol.valueDeclaration;\n+    if (dirClass === undefined || !ts.isClassDeclaration(dirClass) || dirClass.name === undefined) {\n+      continue;\n+    }\n+\n+    const {fileName} = dirClass.getSourceFile();\n+    const position = dirClass.name.getStart();\n+    allDirectives.push({fileName, position});\n+  }\n+\n+  return allDirectives;\n+}\n+\n+/**\n+ * Creates a \"key\" for a rename/reference location by concatenating file name, span start, and span\n+ * length. This allows us to de-duplicate template results when an item may appear several times\n+ * in the TCB but map back to the same template location.\n+ */\n+export function createLocationKey(ds: ts.DocumentSpan) {\n+  return ds.fileName + ds.textSpan.start + ds.textSpan.length;\n+}\n+\n+export function convertToTemplateDocumentSpan<T extends ts.DocumentSpan>(\n+    shimDocumentSpan: T, templateTypeChecker: TemplateTypeChecker, program: ts.Program,\n+    requiredNodeText?: string): T|null {\n+  const sf = program.getSourceFile(shimDocumentSpan.fileName);\n+  if (sf === undefined) {\n+    return null;\n+  }\n+  const tcbNode = findTightestNode(sf, shimDocumentSpan.textSpan.start);\n+  if (tcbNode === undefined ||\n+      hasExpressionIdentifier(sf, tcbNode, ExpressionIdentifier.EVENT_PARAMETER)) {\n+    // If the reference result is the $event parameter in the subscribe/addEventListener\n+    // function in the TCB, we want to filter this result out of the references. We really only\n+    // want to return references to the parameter in the template itself.\n+    return null;\n+  }\n+  // TODO(atscott): Determine how to consistently resolve paths. i.e. with the project\n+  // serverHost or LSParseConfigHost in the adapter. We should have a better defined way to\n+  // normalize paths.\n+  const mapping = getTemplateLocationFromShimLocation(\n+      templateTypeChecker, absoluteFrom(shimDocumentSpan.fileName),\n+      shimDocumentSpan.textSpan.start);\n+  if (mapping === null) {\n+    return null;\n+  }\n+\n+  const {span, templateUrl} = mapping;\n+  if (requiredNodeText !== undefined && span.toString() !== requiredNodeText) {\n+    return null;\n+  }\n+\n+  return {\n+    ...shimDocumentSpan,\n+    fileName: templateUrl,\n+    textSpan: toTextSpan(span),\n+    // Specifically clear other text span values because we do not have enough knowledge to\n+    // convert these to spans in the template.\n+    contextSpan: undefined,\n+    originalContextSpan: undefined,\n+    originalTextSpan: undefined,\n+  };\n+}\n+\n+export function getRenameTextAndSpanAtPosition(\n+    node: TmplAstNode|AST, position: number): {text: string, span: ts.TextSpan}|null {\n+  if (node instanceof TmplAstBoundAttribute || node instanceof TmplAstTextAttribute ||\n+      node instanceof TmplAstBoundEvent) {\n+    if (node.keySpan === undefined) {\n+      return null;\n+    }\n+    return {text: node.name, span: toTextSpan(node.keySpan)};\n+  } else if (node instanceof TmplAstVariable || node instanceof TmplAstReference) {\n+    if (isWithin(position, node.keySpan)) {\n+      return {text: node.keySpan.toString(), span: toTextSpan(node.keySpan)};\n+    } else if (node.valueSpan && isWithin(position, node.valueSpan)) {\n+      return {text: node.valueSpan.toString(), span: toTextSpan(node.valueSpan)};\n+    }\n+  }\n+\n+  if (node instanceof BindingPipe) {\n+    // TODO(atscott): Add support for renaming pipes\n+    return null;\n+  }\n+  if (node instanceof PropertyRead || node instanceof MethodCall || node instanceof PropertyWrite ||\n+      node instanceof SafePropertyRead || node instanceof SafeMethodCall) {\n+    return {text: node.name, span: toTextSpan(node.nameSpan)};\n+  } else if (node instanceof LiteralPrimitive) {\n+    const span = toTextSpan(node.sourceSpan);\n+    const text = node.value;\n+    if (typeof text === 'string') {\n+      // The span of a string literal includes the quotes but they should be removed for renaming.\n+      span.start += 1;\n+      span.length -= 2;\n+    }\n+    return {text, span};\n+  }\n+\n+  return null;\n+}\n\\ No newline at end of file"
        }
    ],
    "stats": {
        "total": 503,
        "additions": 259,
        "deletions": 244
    }
}