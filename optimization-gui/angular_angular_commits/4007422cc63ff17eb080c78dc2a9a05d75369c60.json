{
    "author": "alxhub",
    "message": "fix(compiler): correct confusion between field and property names (#38685)\n\nThe `R3TargetBinder` accepts an interface for directive metadata which\ndeclares types for `input` and `output` objects. These types convey the\nmapping between the property names for an input or output and the\ncorresponding property name on the component class. Due to\n`R3TargetBinder`'s requirements, this mapping was specified with property\nnames as keys and field names as values.\n\nHowever, because of duck typing, this interface was accidentally satisifed\nby the opposite mapping, of field names to property names, that was produced\nin other parts of the compiler. This form more naturally represents the data\nmodel for inputs.\n\nRather than accept the field -> property mapping and invert it, this commit\nintroduces a new abstraction for such mappings which is bidirectional,\neliminating the ambiguous plain object type. This mapping uses new,\nunambiguous terminology (\"class property name\" and \"binding property name\")\nand can be used to satisfy both the needs of the binder as well as those of\nthe template type-checker (field -> property).\n\nA new test ensures that the input/output metadata produced by the compiler\nduring analysis is directly compatible with the binder via this unambiguous\nnew interface.\n\nPR Close #38685",
    "sha": "4007422cc63ff17eb080c78dc2a9a05d75369c60",
    "files": [
        {
            "sha": "3a616ea5fe1a207f82aa4d59af9eccd18d326182",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/component.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 5,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -15,7 +15,7 @@ import {absoluteFrom, relative} from '../../file_system';\n import {DefaultImportRecorder, ModuleResolver, Reference, ReferenceEmitter} from '../../imports';\n import {DependencyTracker} from '../../incremental/api';\n import {IndexingContext} from '../../indexer';\n-import {DirectiveMeta, DirectiveTypeCheckMeta, extractDirectiveTypeCheckMeta, InjectableClassRegistry, MetadataReader, MetadataRegistry} from '../../metadata';\n+import {ClassPropertyMapping, DirectiveMeta, DirectiveTypeCheckMeta, extractDirectiveTypeCheckMeta, InjectableClassRegistry, MetadataReader, MetadataRegistry} from '../../metadata';\n import {flattenInheritedDirectiveMetadata} from '../../metadata/src/inheritance';\n import {EnumValue, PartialEvaluator} from '../../partial_evaluator';\n import {ClassDeclaration, Decorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\n@@ -56,6 +56,9 @@ export interface ComponentAnalysisData {\n   template: ParsedTemplateWithSource;\n   metadataStmt: Statement|null;\n \n+  inputs: ClassPropertyMapping;\n+  outputs: ClassPropertyMapping;\n+\n   /**\n    * Providers extracted from the `providers` field of the component annotation which will require\n    * an Angular factory definition at runtime.\n@@ -191,7 +194,7 @@ export class ComponentDecoratorHandler implements\n     }\n \n     // Next, read the `@Component`-specific fields.\n-    const {decorator: component, metadata} = directiveResult;\n+    const {decorator: component, metadata, inputs, outputs} = directiveResult;\n \n     // Go through the root directories for this project, and select the one with the smallest\n     // relative path representation.\n@@ -328,6 +331,8 @@ export class ComponentDecoratorHandler implements\n     const output: AnalysisOutput<ComponentAnalysisData> = {\n       analysis: {\n         baseClass: readBaseClass(node, this.reflector, this.evaluator),\n+        inputs,\n+        outputs,\n         meta: {\n           ...metadata,\n           template: {\n@@ -345,7 +350,7 @@ export class ComponentDecoratorHandler implements\n           i18nUseExternalIds: this.i18nUseExternalIds,\n           relativeContextFilePath,\n         },\n-        typeCheckMeta: extractDirectiveTypeCheckMeta(node, metadata.inputs, this.reflector),\n+        typeCheckMeta: extractDirectiveTypeCheckMeta(node, inputs, this.reflector),\n         metadataStmt: generateSetClassMetadataCall(\n             node, this.reflector, this.defaultImportRecorder, this.isCore,\n             this.annotateForClosureCompiler),\n@@ -370,8 +375,8 @@ export class ComponentDecoratorHandler implements\n       name: node.name.text,\n       selector: analysis.meta.selector,\n       exportAs: analysis.meta.exportAs,\n-      inputs: analysis.meta.inputs,\n-      outputs: analysis.meta.outputs,\n+      inputs: analysis.inputs,\n+      outputs: analysis.outputs,\n       queries: analysis.meta.queries.map(query => query.propertyName),\n       isComponent: true,\n       baseClass: analysis.baseClass,"
        },
        {
            "sha": "e85af13159fef843d77f243609c495192bf31bba",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/directive.ts",
            "status": "modified",
            "additions": 28,
            "deletions": 12,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdirective.ts",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdirective.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdirective.ts?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -11,7 +11,7 @@ import * as ts from 'typescript';\n \n import {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\n import {DefaultImportRecorder, Reference} from '../../imports';\n-import {DirectiveTypeCheckMeta, InjectableClassRegistry, MetadataReader, MetadataRegistry} from '../../metadata';\n+import {ClassPropertyMapping, DirectiveTypeCheckMeta, InjectableClassRegistry, MetadataReader, MetadataRegistry} from '../../metadata';\n import {extractDirectiveTypeCheckMeta} from '../../metadata/src/util';\n import {DynamicValue, EnumValue, PartialEvaluator} from '../../partial_evaluator';\n import {ClassDeclaration, ClassMember, ClassMemberKind, Decorator, filterToMembersWithDecorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\n@@ -39,6 +39,8 @@ export interface DirectiveHandlerData {\n   meta: R3DirectiveMetadata;\n   metadataStmt: Statement|null;\n   providersRequiringFactory: Set<Reference<ClassDeclaration>>|null;\n+  inputs: ClassPropertyMapping;\n+  outputs: ClassPropertyMapping;\n }\n \n export class DirectiveDecoratorHandler implements\n@@ -83,11 +85,10 @@ export class DirectiveDecoratorHandler implements\n     const directiveResult = extractDirectiveMetadata(\n         node, decorator, this.reflector, this.evaluator, this.defaultImportRecorder, this.isCore,\n         flags, this.annotateForClosureCompiler);\n-    const analysis = directiveResult && directiveResult.metadata;\n-\n-    if (analysis === undefined) {\n+    if (directiveResult === undefined) {\n       return {};\n     }\n+    const analysis = directiveResult.metadata;\n \n     let providersRequiringFactory: Set<Reference<ClassDeclaration>>|null = null;\n     if (directiveResult !== undefined && directiveResult.decorator.has('providers')) {\n@@ -97,12 +98,14 @@ export class DirectiveDecoratorHandler implements\n \n     return {\n       analysis: {\n+        inputs: directiveResult.inputs,\n+        outputs: directiveResult.outputs,\n         meta: analysis,\n         metadataStmt: generateSetClassMetadataCall(\n             node, this.reflector, this.defaultImportRecorder, this.isCore,\n             this.annotateForClosureCompiler),\n         baseClass: readBaseClass(node, this.reflector, this.evaluator),\n-        typeCheckMeta: extractDirectiveTypeCheckMeta(node, analysis.inputs, this.reflector),\n+        typeCheckMeta: extractDirectiveTypeCheckMeta(node, directiveResult.inputs, this.reflector),\n         providersRequiringFactory\n       }\n     };\n@@ -117,8 +120,8 @@ export class DirectiveDecoratorHandler implements\n       name: node.name.text,\n       selector: analysis.meta.selector,\n       exportAs: analysis.meta.exportAs,\n-      inputs: analysis.meta.inputs,\n-      outputs: analysis.meta.outputs,\n+      inputs: analysis.inputs,\n+      outputs: analysis.outputs,\n       queries: analysis.meta.queries.map(query => query.propertyName),\n       isComponent: false,\n       baseClass: analysis.baseClass,\n@@ -199,8 +202,13 @@ export class DirectiveDecoratorHandler implements\n export function extractDirectiveMetadata(\n     clazz: ClassDeclaration, decorator: Readonly<Decorator|null>, reflector: ReflectionHost,\n     evaluator: PartialEvaluator, defaultImportRecorder: DefaultImportRecorder, isCore: boolean,\n-    flags: HandlerFlags, annotateForClosureCompiler: boolean, defaultSelector: string|null = null):\n-    {decorator: Map<string, ts.Expression>, metadata: R3DirectiveMetadata}|undefined {\n+    flags: HandlerFlags, annotateForClosureCompiler: boolean,\n+    defaultSelector: string|null = null): {\n+  decorator: Map<string, ts.Expression>,\n+  metadata: R3DirectiveMetadata,\n+  inputs: ClassPropertyMapping,\n+  outputs: ClassPropertyMapping,\n+}|undefined {\n   let directive: Map<string, ts.Expression>;\n   if (decorator === null || decorator.args === null || decorator.args.length === 0) {\n     directive = new Map<string, ts.Expression>();\n@@ -331,15 +339,18 @@ export function extractDirectiveMetadata(\n   const type = wrapTypeReference(reflector, clazz);\n   const internalType = new WrappedNodeExpr(reflector.getInternalNameOfClass(clazz));\n \n+  const inputs = ClassPropertyMapping.fromMappedObject({...inputsFromMeta, ...inputsFromFields});\n+  const outputs = ClassPropertyMapping.fromMappedObject({...outputsFromMeta, ...outputsFromFields});\n+\n   const metadata: R3DirectiveMetadata = {\n     name: clazz.name.text,\n     deps: ctorDeps,\n     host,\n     lifecycle: {\n       usesOnChanges,\n     },\n-    inputs: {...inputsFromMeta, ...inputsFromFields},\n-    outputs: {...outputsFromMeta, ...outputsFromFields},\n+    inputs: inputs.toJointMappedObject(),\n+    outputs: outputs.toDirectMappedObject(),\n     queries,\n     viewQueries,\n     selector,\n@@ -352,7 +363,12 @@ export function extractDirectiveMetadata(\n     exportAs,\n     providers\n   };\n-  return {decorator: directive, metadata};\n+  return {\n+    decorator: directive,\n+    metadata,\n+    inputs,\n+    outputs,\n+  };\n }\n \n export function extractQueryMetadata("
        },
        {
            "sha": "1eed4de0100adf7e90e15e8cfae9e7a53cef5aab",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/test/directive_spec.ts",
            "status": "modified",
            "additions": 44,
            "deletions": 0,
            "changes": 44,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fdirective_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fdirective_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fdirective_spec.ts?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -5,6 +5,7 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n+import {CssSelector, DirectiveMeta as T2DirectiveMeta, parseTemplate, R3TargetBinder, SelectorMatcher, TmplAstElement} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {absoluteFrom} from '../../file_system';\n@@ -73,6 +74,49 @@ runInEachFileSystem(() => {\n       expect(span.start.toString()).toContain('/entry.ts@5:22');\n       expect(span.end.toString()).toContain('/entry.ts@5:29');\n     });\n+\n+    it('should produce metadata compatible with template binding', () => {\n+      const src = `\n+        import {Directive, Input} from '@angular/core';\n+\n+        @Directive({selector: '[dir]'})\n+        export class TestDir {\n+          @Input('propName')\n+          fieldName: string;\n+        }\n+      `;\n+      const {program} = makeProgram([\n+        {\n+          name: _('/node_modules/@angular/core/index.d.ts'),\n+          contents: 'export const Directive: any; export const Input: any;',\n+        },\n+        {\n+          name: _('/entry.ts'),\n+          contents: src,\n+        },\n+      ]);\n+\n+      const analysis = analyzeDirective(program, 'TestDir');\n+      const matcher = new SelectorMatcher<T2DirectiveMeta>();\n+      const dirMeta: T2DirectiveMeta = {\n+        exportAs: null,\n+        inputs: analysis.inputs,\n+        outputs: analysis.outputs,\n+        isComponent: false,\n+        name: 'Dir',\n+      };\n+      matcher.addSelectables(CssSelector.parse('[dir]'), dirMeta);\n+\n+      const {nodes} = parseTemplate('<div dir [propName]=\"expr\"></div>', 'unimportant.html');\n+      const binder = new R3TargetBinder(matcher).bind({template: nodes});\n+      const propBinding = (nodes[0] as TmplAstElement).inputs[0];\n+      const propBindingConsumer = binder.getConsumerOfBinding(propBinding);\n+\n+      // Assert that the consumer of the binding is the directive, which means that the metadata\n+      // fed into the SelectorMatcher was compatible with the binder, and did not confuse property\n+      // and field names.\n+      expect(propBindingConsumer).toBe(dirMeta);\n+    });\n   });\n \n   // Helpers"
        },
        {
            "sha": "5013f4652c27e0a49fa98685a4bb27e1bb23be8f",
            "filename": "packages/compiler-cli/src/ngtsc/indexer/test/util.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Ftest%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Ftest%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Findexer%2Ftest%2Futil.ts?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -11,6 +11,7 @@ import * as ts from 'typescript';\n \n import {absoluteFrom, AbsoluteFsPath} from '../../file_system';\n import {Reference} from '../../imports';\n+import {ClassPropertyMapping} from '../../metadata';\n import {ClassDeclaration} from '../../reflection';\n import {getDeclaration, makeProgram} from '../../testing';\n import {ComponentMeta} from '../src/context';\n@@ -50,8 +51,8 @@ export function getBoundTemplate(\n       selector,\n       name: declaration.name.getText(),\n       isComponent: true,\n-      inputs: {},\n-      outputs: {},\n+      inputs: ClassPropertyMapping.fromMappedObject({}),\n+      outputs: ClassPropertyMapping.fromMappedObject({}),\n       exportAs: null,\n     });\n   });"
        },
        {
            "sha": "2f857eee0bc4027628d698f6a68fce8cdc01d834",
            "filename": "packages/compiler-cli/src/ngtsc/metadata/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Findex.ts?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -10,3 +10,4 @@ export * from './src/api';\n export {DtsMetadataReader} from './src/dts';\n export {CompoundMetadataRegistry, LocalMetadataRegistry, InjectableClassRegistry} from './src/registry';\n export {extractDirectiveTypeCheckMeta, CompoundMetadataReader} from './src/util';\n+export {BindingPropertyName, ClassPropertyMapping, ClassPropertyName, InputOrOutput} from './src/property_mapping';"
        },
        {
            "sha": "3ec001db9578dd8bdaf77b5260c237cf261cbb39",
            "filename": "packages/compiler-cli/src/ngtsc/metadata/src/api.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 4,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fapi.ts?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -12,6 +12,8 @@ import * as ts from 'typescript';\n import {Reference} from '../../imports';\n import {ClassDeclaration} from '../../reflection';\n \n+import {ClassPropertyMapping, ClassPropertyName} from './property_mapping';\n+\n \n /**\n  * Metadata collected for an `NgModule`.\n@@ -52,25 +54,25 @@ export interface DirectiveTypeCheckMeta {\n    * Directive's class. This allows inputs to accept a wider range of types and coerce the input to\n    * a narrower type with a getter/setter. See https://angular.io/guide/template-typecheck.\n    */\n-  coercedInputFields: Set<string>;\n+  coercedInputFields: Set<ClassPropertyName>;\n \n   /**\n    * The set of input fields which map to `readonly`, `private`, or `protected` members in the\n    * Directive's class.\n    */\n-  restrictedInputFields: Set<string>;\n+  restrictedInputFields: Set<ClassPropertyName>;\n \n   /**\n    * The set of input fields which are declared as string literal members in the Directive's class.\n    * We need to track these separately because these fields may not be valid JS identifiers so\n    * we cannot use them with property access expressions when assigning inputs.\n    */\n-  stringLiteralInputFields: Set<string>;\n+  stringLiteralInputFields: Set<ClassPropertyName>;\n \n   /**\n    * The set of input fields which do not have corresponding members in the Directive's class.\n    */\n-  undeclaredInputFields: Set<string>;\n+  undeclaredInputFields: Set<ClassPropertyName>;\n \n   /**\n    * Whether the Directive's class is generic, i.e. `class MyDir<T> {...}`.\n@@ -89,6 +91,16 @@ export interface DirectiveMeta extends T2DirectiveMeta, DirectiveTypeCheckMeta {\n   selector: string|null;\n   queries: string[];\n \n+  /**\n+   * A mapping of input field names to the property names.\n+   */\n+  inputs: ClassPropertyMapping;\n+\n+  /**\n+   * A mapping of output field names to the property names.\n+   */\n+  outputs: ClassPropertyMapping;\n+\n   /**\n    * A `Reference` to the base class for the directive, if one was detected.\n    *"
        },
        {
            "sha": "4bbdc14fd8acf6c45b294b729cd5d4df3b7c2875",
            "filename": "packages/compiler-cli/src/ngtsc/metadata/src/dts.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fdts.ts",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fdts.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fdts.ts?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -12,6 +12,7 @@ import {Reference} from '../../imports';\n import {ClassDeclaration, isNamedClassDeclaration, ReflectionHost} from '../../reflection';\n \n import {DirectiveMeta, MetadataReader, NgModuleMeta, PipeMeta} from './api';\n+import {ClassPropertyMapping} from './property_mapping';\n import {extractDirectiveTypeCheckMeta, extractReferencesFromType, readStringArrayType, readStringMapType, readStringType} from './util';\n \n /**\n@@ -76,15 +77,18 @@ export class DtsMetadataReader implements MetadataReader {\n       return null;\n     }\n \n-    const inputs = readStringMapType(def.type.typeArguments[3]);\n+    const inputs =\n+        ClassPropertyMapping.fromMappedObject(readStringMapType(def.type.typeArguments[3]));\n+    const outputs =\n+        ClassPropertyMapping.fromMappedObject(readStringMapType(def.type.typeArguments[4]));\n     return {\n       ref,\n       name: clazz.name.text,\n       isComponent: def.name === 'Éµcmp',\n       selector: readStringType(def.type.typeArguments[1]),\n       exportAs: readStringArrayType(def.type.typeArguments[2]),\n       inputs,\n-      outputs: readStringMapType(def.type.typeArguments[4]),\n+      outputs,\n       queries: readStringArrayType(def.type.typeArguments[5]),\n       ...extractDirectiveTypeCheckMeta(clazz, inputs, this.reflector),\n       baseClass: readBaseClass(clazz, this.checker, this.reflector),"
        },
        {
            "sha": "f5271f4351d32d6fc3ad85c7da2a0924ab74a90e",
            "filename": "packages/compiler-cli/src/ngtsc/metadata/src/inheritance.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 9,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Finheritance.ts",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Finheritance.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Finheritance.ts?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -7,9 +7,11 @@\n  */\n \n import {Reference} from '../../imports';\n-import {DirectiveMeta, MetadataReader} from '../../metadata';\n import {ClassDeclaration} from '../../reflection';\n \n+import {DirectiveMeta, MetadataReader} from './api';\n+import {ClassPropertyMapping, ClassPropertyName} from './property_mapping';\n+\n /**\n  * Given a reference to a directive, return a flattened version of its `DirectiveMeta` metadata\n  * which includes metadata from its entire inheritance chain.\n@@ -25,13 +27,13 @@ export function flattenInheritedDirectiveMetadata(\n     throw new Error(`Metadata not found for directive: ${dir.debugName}`);\n   }\n \n-  let inputs: {[key: string]: string|[string, string]} = {};\n-  let outputs: {[key: string]: string} = {};\n-  const coercedInputFields = new Set<string>();\n-  const undeclaredInputFields = new Set<string>();\n-  const restrictedInputFields = new Set<string>();\n-  const stringLiteralInputFields = new Set<string>();\n+  const coercedInputFields = new Set<ClassPropertyName>();\n+  const undeclaredInputFields = new Set<ClassPropertyName>();\n+  const restrictedInputFields = new Set<ClassPropertyName>();\n+  const stringLiteralInputFields = new Set<ClassPropertyName>();\n   let isDynamic = false;\n+  let inputs = ClassPropertyMapping.empty();\n+  let outputs = ClassPropertyMapping.empty();\n \n   const addMetadata = (meta: DirectiveMeta): void => {\n     if (meta.baseClass === 'dynamic') {\n@@ -45,8 +47,9 @@ export function flattenInheritedDirectiveMetadata(\n         isDynamic = true;\n       }\n     }\n-    inputs = {...inputs, ...meta.inputs};\n-    outputs = {...outputs, ...meta.outputs};\n+\n+    inputs = ClassPropertyMapping.merge(inputs, meta.inputs);\n+    outputs = ClassPropertyMapping.merge(outputs, meta.outputs);\n \n     for (const coercedInputField of meta.coercedInputFields) {\n       coercedInputFields.add(coercedInputField);"
        },
        {
            "sha": "6a78fe1e68dbb7de87acae2eb5443ab4f151ce2a",
            "filename": "packages/compiler-cli/src/ngtsc/metadata/src/property_mapping.ts",
            "status": "added",
            "additions": 200,
            "deletions": 0,
            "changes": 200,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fproperty_mapping.ts",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fproperty_mapping.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fproperty_mapping.ts?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -0,0 +1,200 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {InputOutputPropertySet} from '@angular/compiler';\n+\n+/**\n+ * The name of a class property that backs an input or output declared by a directive or component.\n+ *\n+ * This type exists for documentation only.\n+ */\n+export type ClassPropertyName = string;\n+\n+/**\n+ * The name by which an input or output of a directive or component is bound in an Angular template.\n+ *\n+ * This type exists for documentation only.\n+ */\n+export type BindingPropertyName = string;\n+\n+/**\n+ * An input or output of a directive that has both a named JavaScript class property on a component\n+ * or directive class, as well as an Angular template property name used for binding.\n+ */\n+export interface InputOrOutput {\n+  /**\n+   * The name of the JavaScript property on the component or directive instance for this input or\n+   * output.\n+   */\n+  readonly classPropertyName: ClassPropertyName;\n+\n+  /**\n+   * The property name used to bind this input or output in an Angular template.\n+   */\n+  readonly bindingPropertyName: BindingPropertyName;\n+}\n+\n+/**\n+ * A mapping of component property and template binding property names, for example containing the\n+ * inputs of a particular directive or component.\n+ *\n+ * A single component property has exactly one input/output annotation (and therefore one binding\n+ * property name) associated with it, but the same binding property name may be shared across many\n+ * component property names.\n+ *\n+ * Allows bidirectional querying of the mapping - looking up all inputs/outputs with a given\n+ * property name, or mapping from a specific class property to its binding property name.\n+ */\n+export class ClassPropertyMapping implements InputOutputPropertySet {\n+  /**\n+   * Mapping from class property names to the single `InputOrOutput` for that class property.\n+   */\n+  private forwardMap: Map<ClassPropertyName, InputOrOutput>;\n+\n+  /**\n+   * Mapping from property names to one or more `InputOrOutput`s which share that name.\n+   */\n+  private reverseMap: Map<BindingPropertyName, InputOrOutput[]>;\n+\n+  private constructor(forwardMap: Map<ClassPropertyName, InputOrOutput>) {\n+    this.forwardMap = forwardMap;\n+    this.reverseMap = reverseMapFromForwardMap(forwardMap);\n+  }\n+\n+  /**\n+   * Construct a `ClassPropertyMapping` with no entries.\n+   */\n+  static empty(): ClassPropertyMapping {\n+    return new ClassPropertyMapping(new Map());\n+  }\n+\n+  /**\n+   * Construct a `ClassPropertyMapping` from a primitive JS object which maps class property names\n+   * to either binding property names or an array that contains both names, which is used in on-disk\n+   * metadata formats (e.g. in .d.ts files).\n+   */\n+  static fromMappedObject(obj: {\n+    [classPropertyName: string]: BindingPropertyName|[ClassPropertyName, BindingPropertyName]\n+  }): ClassPropertyMapping {\n+    const forwardMap = new Map<ClassPropertyName, InputOrOutput>();\n+\n+    for (const classPropertyName of Object.keys(obj)) {\n+      const value = obj[classPropertyName];\n+      const bindingPropertyName = Array.isArray(value) ? value[0] : value;\n+      const inputOrOutput: InputOrOutput = {classPropertyName, bindingPropertyName};\n+      forwardMap.set(classPropertyName, inputOrOutput);\n+    }\n+\n+    return new ClassPropertyMapping(forwardMap);\n+  }\n+\n+  /**\n+   * Merge two mappings into one, with class properties from `b` taking precedence over class\n+   * properties from `a`.\n+   */\n+  static merge(a: ClassPropertyMapping, b: ClassPropertyMapping): ClassPropertyMapping {\n+    const forwardMap = new Map<ClassPropertyName, InputOrOutput>(a.forwardMap.entries());\n+    for (const [classPropertyName, inputOrOutput] of b.forwardMap) {\n+      forwardMap.set(classPropertyName, inputOrOutput);\n+    }\n+\n+    return new ClassPropertyMapping(forwardMap);\n+  }\n+\n+  /**\n+   * All class property names mapped in this mapping.\n+   */\n+  get classPropertyNames(): ClassPropertyName[] {\n+    return Array.from(this.forwardMap.keys());\n+  }\n+\n+  /**\n+   * All binding property names mapped in this mapping.\n+   */\n+  get propertyNames(): BindingPropertyName[] {\n+    return Array.from(this.reverseMap.keys());\n+  }\n+\n+  /**\n+   * Check whether a mapping for the given property name exists.\n+   */\n+  hasBindingPropertyName(propertyName: BindingPropertyName): boolean {\n+    return this.reverseMap.has(propertyName);\n+  }\n+\n+  /**\n+   * Lookup all `InputOrOutput`s that use this `propertyName`.\n+   */\n+  getByBindingPropertyName(propertyName: string): ReadonlyArray<InputOrOutput>|null {\n+    return this.reverseMap.has(propertyName) ? this.reverseMap.get(propertyName)! : null;\n+  }\n+\n+  /**\n+   * Lookup the `InputOrOutput` associated with a `classPropertyName`.\n+   */\n+  getByClassPropertyName(classPropertyName: string): InputOrOutput|null {\n+    return this.forwardMap.has(classPropertyName) ? this.forwardMap.get(classPropertyName)! : null;\n+  }\n+\n+  /**\n+   * Convert this mapping to a primitive JS object which maps each class property directly to the\n+   * binding property name associated with it.\n+   */\n+  toDirectMappedObject(): {[classPropertyName: string]: BindingPropertyName} {\n+    const obj: {[classPropertyName: string]: BindingPropertyName} = {};\n+    for (const [classPropertyName, inputOrOutput] of this.forwardMap) {\n+      obj[classPropertyName] = inputOrOutput.bindingPropertyName;\n+    }\n+    return obj;\n+  }\n+\n+  /**\n+   * Convert this mapping to a primitive JS object which maps each class property either to itself\n+   * (for cases where the binding property name is the same) or to an array which contains both\n+   * names if they differ.\n+   *\n+   * This object format is used when mappings are serialized (for example into .d.ts files).\n+   */\n+  toJointMappedObject():\n+      {[classPropertyName: string]: BindingPropertyName|[BindingPropertyName, ClassPropertyName]} {\n+    const obj: {\n+      [classPropertyName: string]: BindingPropertyName|[BindingPropertyName, ClassPropertyName]\n+    } = {};\n+    for (const [classPropertyName, inputOrOutput] of this.forwardMap) {\n+      if (inputOrOutput.bindingPropertyName as string === classPropertyName as string) {\n+        obj[classPropertyName] = inputOrOutput.bindingPropertyName;\n+      } else {\n+        obj[classPropertyName] = [inputOrOutput.bindingPropertyName, classPropertyName];\n+      }\n+    }\n+    return obj;\n+  }\n+\n+  /**\n+   * Implement the iterator protocol and return entry objects which contain the class and binding\n+   * property names (and are useful for destructuring).\n+   */\n+  * [Symbol.iterator](): IterableIterator<[ClassPropertyName, BindingPropertyName]> {\n+    for (const [classPropertyName, inputOrOutput] of this.forwardMap.entries()) {\n+      yield [classPropertyName, inputOrOutput.bindingPropertyName];\n+    }\n+  }\n+}\n+\n+function reverseMapFromForwardMap(forwardMap: Map<ClassPropertyName, InputOrOutput>):\n+    Map<BindingPropertyName, InputOrOutput[]> {\n+  const reverseMap = new Map<BindingPropertyName, InputOrOutput[]>();\n+  for (const [_, inputOrOutput] of forwardMap) {\n+    if (!reverseMap.has(inputOrOutput.bindingPropertyName)) {\n+      reverseMap.set(inputOrOutput.bindingPropertyName, []);\n+    }\n+\n+    reverseMap.get(inputOrOutput.bindingPropertyName)!.push(inputOrOutput);\n+  }\n+  return reverseMap;\n+}"
        },
        {
            "sha": "5d7f6c9841174240f860453f02cce84c8fb3c204",
            "filename": "packages/compiler-cli/src/ngtsc/metadata/src/util.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 10,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Futil.ts?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -13,6 +13,7 @@ import {ClassDeclaration, ClassMember, ClassMemberKind, isNamedClassDeclaration,\n import {nodeDebugInfo} from '../../util/src/typescript';\n \n import {DirectiveMeta, DirectiveTypeCheckMeta, MetadataReader, NgModuleMeta, PipeMeta, TemplateGuardMeta} from './api';\n+import {ClassPropertyMapping, ClassPropertyName} from './property_mapping';\n \n export function extractReferencesFromType(\n     checker: ts.TypeChecker, def: ts.TypeNode, ngModuleImportedFrom: string|null,\n@@ -91,7 +92,7 @@ export function readStringArrayType(type: ts.TypeNode): string[] {\n  * making this metadata invariant to changes of inherited classes.\n  */\n export function extractDirectiveTypeCheckMeta(\n-    node: ClassDeclaration, inputs: {[fieldName: string]: string|[string, string]},\n+    node: ClassDeclaration, inputs: ClassPropertyMapping,\n     reflector: ReflectionHost): DirectiveTypeCheckMeta {\n   const members = reflector.getMembersOfClass(node);\n   const staticMembers = members.filter(member => member.isStatic);\n@@ -102,23 +103,23 @@ export function extractDirectiveTypeCheckMeta(\n \n   const coercedInputFields =\n       new Set(staticMembers.map(extractCoercedInput)\n-                  .filter((inputName): inputName is string => inputName !== null));\n+                  .filter((inputName): inputName is ClassPropertyName => inputName !== null));\n \n-  const restrictedInputFields = new Set<string>();\n-  const stringLiteralInputFields = new Set<string>();\n-  const undeclaredInputFields = new Set<string>();\n+  const restrictedInputFields = new Set<ClassPropertyName>();\n+  const stringLiteralInputFields = new Set<ClassPropertyName>();\n+  const undeclaredInputFields = new Set<ClassPropertyName>();\n \n-  for (const fieldName of Object.keys(inputs)) {\n-    const field = members.find(member => member.name === fieldName);\n+  for (const classPropertyName of inputs.classPropertyNames) {\n+    const field = members.find(member => member.name === classPropertyName);\n     if (field === undefined || field.node === null) {\n-      undeclaredInputFields.add(fieldName);\n+      undeclaredInputFields.add(classPropertyName);\n       continue;\n     }\n     if (isRestricted(field.node)) {\n-      restrictedInputFields.add(fieldName);\n+      restrictedInputFields.add(classPropertyName);\n     }\n     if (field.nameNode !== null && ts.isStringLiteral(field.nameNode)) {\n-      stringLiteralInputFields.add(fieldName);\n+      stringLiteralInputFields.add(classPropertyName);\n     }\n   }\n "
        },
        {
            "sha": "0216fd8864c803812863cfa3b157faa0706e1174",
            "filename": "packages/compiler-cli/src/ngtsc/scope/test/local_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fscope%2Ftest%2Flocal_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fscope%2Ftest%2Flocal_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fscope%2Ftest%2Flocal_spec.ts?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -9,7 +9,7 @@\n import * as ts from 'typescript';\n \n import {Reference, ReferenceEmitter} from '../../imports';\n-import {CompoundMetadataRegistry, DirectiveMeta, LocalMetadataRegistry, MetadataRegistry, PipeMeta} from '../../metadata';\n+import {ClassPropertyMapping, CompoundMetadataRegistry, DirectiveMeta, LocalMetadataRegistry, MetadataRegistry, PipeMeta} from '../../metadata';\n import {ClassDeclaration} from '../../reflection';\n import {ScopeData} from '../src/api';\n import {DtsModuleScopeResolver} from '../src/dependency';\n@@ -236,8 +236,8 @@ function fakeDirective(ref: Reference<ClassDeclaration>): DirectiveMeta {\n     name,\n     selector: `[${ref.debugName}]`,\n     isComponent: name.startsWith('Cmp'),\n-    inputs: {},\n-    outputs: {},\n+    inputs: ClassPropertyMapping.fromMappedObject({}),\n+    outputs: ClassPropertyMapping.fromMappedObject({}),\n     exportAs: null,\n     queries: [],\n     hasNgTemplateContextGuard: false,"
        },
        {
            "sha": "594475009adfb46cef1eb50b8da14a1a9691feff",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/api.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fapi.ts?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -11,7 +11,7 @@ import * as ts from 'typescript';\n \n import {AbsoluteFsPath} from '../../file_system';\n import {Reference} from '../../imports';\n-import {DirectiveTypeCheckMeta} from '../../metadata';\n+import {ClassPropertyMapping, DirectiveTypeCheckMeta} from '../../metadata';\n import {ClassDeclaration} from '../../reflection';\n \n \n@@ -22,6 +22,8 @@ import {ClassDeclaration} from '../../reflection';\n export interface TypeCheckableDirectiveMeta extends DirectiveMeta, DirectiveTypeCheckMeta {\n   ref: Reference<ClassDeclaration>;\n   queries: string[];\n+  inputs: ClassPropertyMapping;\n+  outputs: ClassPropertyMapping;\n }\n \n export type TemplateId = string&{__brand: 'TemplateId'};"
        },
        {
            "sha": "30c15189bc1ac4df6dfb317dcd98c83255ff627d",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/context.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -241,8 +241,8 @@ export class TypeCheckContextImpl implements TypeCheckContext {\n           // it comes from a .d.ts file. .d.ts declarations don't have bodies.\n           body: !dirNode.getSourceFile().isDeclarationFile,\n           fields: {\n-            inputs: Object.keys(dir.inputs),\n-            outputs: Object.keys(dir.outputs),\n+            inputs: dir.inputs.classPropertyNames,\n+            outputs: dir.outputs.classPropertyNames,\n             // TODO(alxhub): support queries\n             queries: dir.queries,\n           },"
        },
        {
            "sha": "bfa79ad8c41f73024839e70f1af0d11b37946327",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/environment.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -79,8 +79,8 @@ export class Environment {\n         fnName,\n         body: true,\n         fields: {\n-          inputs: Object.keys(dir.inputs),\n-          outputs: Object.keys(dir.outputs),\n+          inputs: dir.inputs.classPropertyNames,\n+          outputs: dir.outputs.classPropertyNames,\n           // TODO: support queries\n           queries: dir.queries,\n         },"
        },
        {
            "sha": "e295889c7cc0b0258cf3526d1ed64fcfc24e5a17",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 41,
            "changes": 54,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -10,6 +10,7 @@ import {AST, BindingPipe, BindingType, BoundTarget, DYNAMIC_TYPE, ImplicitReceiv\n import * as ts from 'typescript';\n \n import {Reference} from '../../imports';\n+import {ClassPropertyName} from '../../metadata';\n import {ClassDeclaration} from '../../reflection';\n import {TemplateId, TypeCheckableDirectiveMeta, TypeCheckBlockMetadata} from '../api';\n \n@@ -431,7 +432,7 @@ class TcbDirectiveCtorOp extends TcbOp {\n     }\n \n     // Add unset directive inputs for each of the remaining unset fields.\n-    for (const fieldName of Object.keys(this.dir.inputs)) {\n+    for (const [fieldName] of this.dir.inputs) {\n       if (!genericInputs.has(fieldName)) {\n         genericInputs.set(fieldName, {type: 'unset', field: fieldName});\n       }\n@@ -743,22 +744,14 @@ class TcbDirectiveOutputsOp extends TcbOp {\n \n   execute(): null {\n     let dirId: ts.Expression|null = null;\n-\n-\n-    // `dir.outputs` is an object map of field names on the directive class to event names.\n-    // This is backwards from what's needed to match event handlers - a map of event names to field\n-    // names is desired. Invert `dir.outputs` into `fieldByEventName` to create this map.\n-    const fieldByEventName = new Map<string, string>();\n     const outputs = this.dir.outputs;\n-    for (const key of Object.keys(outputs)) {\n-      fieldByEventName.set(outputs[key], key);\n-    }\n \n     for (const output of this.node.outputs) {\n-      if (output.type !== ParsedEventType.Regular || !fieldByEventName.has(output.name)) {\n+      if (output.type !== ParsedEventType.Regular || !outputs.hasBindingPropertyName(output.name)) {\n         continue;\n       }\n-      const field = fieldByEventName.get(output.name)!;\n+      // TODO(alxhub): consider supporting multiple fields with the same property name for outputs.\n+      const field = outputs.getByBindingPropertyName(output.name)![0].classPropertyName;\n \n       if (this.tcb.env.config.checkTypeOfOutputEvents) {\n         // For strict checking of directive events, generate a call to the `subscribe` method\n@@ -1225,9 +1218,8 @@ class Scope {\n     if (node instanceof TmplAstElement) {\n       // Go through the directives and remove any inputs that it claims from `elementInputs`.\n       for (const dir of directives) {\n-        for (const fieldName of Object.keys(dir.inputs)) {\n-          const value = dir.inputs[fieldName];\n-          claimedInputs.add(Array.isArray(value) ? value[0] : value);\n+        for (const propertyName of dir.inputs.propertyNames) {\n+          claimedInputs.add(propertyName);\n         }\n       }\n \n@@ -1264,8 +1256,8 @@ class Scope {\n     if (node instanceof TmplAstElement) {\n       // Go through the directives and register any outputs that it claims in `claimedOutputs`.\n       for (const dir of directives) {\n-        for (const outputField of Object.keys(dir.outputs)) {\n-          claimedOutputs.add(dir.outputs[outputField]);\n+        for (const outputProperty of dir.outputs.propertyNames) {\n+          claimedOutputs.add(outputProperty);\n         }\n       }\n \n@@ -1276,7 +1268,7 @@ class Scope {\n \n interface TcbBoundInput {\n   attribute: TmplAstBoundAttribute|TmplAstTextAttribute;\n-  fieldNames: string[];\n+  fieldNames: ClassPropertyName[];\n }\n \n /**\n@@ -1537,7 +1529,6 @@ function getBoundInputs(\n     tcb: Context): TcbBoundInput[] {\n   const boundInputs: TcbBoundInput[] = [];\n \n-  const propertyToFieldNames = invertInputs(directive.inputs);\n   const processAttribute = (attr: TmplAstBoundAttribute|TmplAstTextAttribute) => {\n     // Skip non-property bindings.\n     if (attr instanceof TmplAstBoundAttribute && attr.type !== BindingType.Property) {\n@@ -1550,10 +1541,11 @@ function getBoundInputs(\n     }\n \n     // Skip the attribute if the directive does not have an input for it.\n-    if (!propertyToFieldNames.has(attr.name)) {\n+    const inputs = directive.inputs.getByBindingPropertyName(attr.name);\n+    if (inputs === null) {\n       return;\n     }\n-    const fieldNames = propertyToFieldNames.get(attr.name)!;\n+    const fieldNames = inputs.map(input => input.classPropertyName);\n     boundInputs.push({attribute: attr, fieldNames});\n   };\n \n@@ -1580,26 +1572,6 @@ function translateInput(\n   }\n }\n \n-/**\n- * Inverts the input-mapping from field-to-property name into property-to-field name, to be able\n- * to match a property in a template with the corresponding field on a directive.\n- */\n-function invertInputs(inputs: {[fieldName: string]: string|[string, string]}):\n-    Map<string, string[]> {\n-  const propertyToFieldNames = new Map<string, string[]>();\n-  for (const fieldName of Object.keys(inputs)) {\n-    const propertyNames = inputs[fieldName];\n-    const propertyName = Array.isArray(propertyNames) ? propertyNames[0] : propertyNames;\n-\n-    if (propertyToFieldNames.has(propertyName)) {\n-      propertyToFieldNames.get(propertyName)!.push(fieldName);\n-    } else {\n-      propertyToFieldNames.set(propertyName, [fieldName]);\n-    }\n-  }\n-  return propertyToFieldNames;\n-}\n-\n /**\n  * An input binding that corresponds with a field of a directive.\n  */"
        },
        {
            "sha": "523f14ae0daffde2e0b397ea4e267d3fa164d77c",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2FBUILD.bazel?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -16,6 +16,7 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/file_system/testing\",\n         \"//packages/compiler-cli/src/ngtsc/imports\",\n         \"//packages/compiler-cli/src/ngtsc/incremental\",\n+        \"//packages/compiler-cli/src/ngtsc/metadata\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\",\n         \"//packages/compiler-cli/src/ngtsc/shims\",\n         \"//packages/compiler-cli/src/ngtsc/testing\","
        },
        {
            "sha": "248f5ea352b857dd2f4ebd4ee2cb861cdcec0338",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/test_utils.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -13,6 +13,7 @@ import {absoluteFrom, AbsoluteFsPath, getSourceFileOrError, LogicalFileSystem} f\n import {TestFile} from '../../file_system/testing';\n import {AbsoluteModuleStrategy, LocalIdentifierStrategy, LogicalProjectStrategy, ModuleResolver, Reference, ReferenceEmitter} from '../../imports';\n import {NOOP_INCREMENTAL_BUILD} from '../../incremental';\n+import {ClassPropertyMapping} from '../../metadata';\n import {ClassDeclaration, isNamedClassDeclaration, TypeScriptReflectionHost} from '../../reflection';\n import {makeProgram} from '../../testing';\n import {getRootDirs} from '../../util/src/typescript';\n@@ -180,8 +181,9 @@ export type TestDirective = Partial<Pick<\n     Exclude<\n         keyof TypeCheckableDirectiveMeta,\n         'ref'|'coercedInputFields'|'restrictedInputFields'|'stringLiteralInputFields'|\n-        'undeclaredInputFields'>>>&{\n+        'undeclaredInputFields'|'inputs'|'outputs'>>>&{\n   selector: string, name: string, file?: AbsoluteFsPath, type: 'directive',\n+      inputs?: {[fieldName: string]: string}, outputs?: {[fieldName: string]: string},\n       coercedInputFields?: string[], restrictedInputFields?: string[],\n       stringLiteralInputFields?: string[], undeclaredInputFields?: string[], isGeneric?: boolean;\n };\n@@ -418,15 +420,15 @@ function prepareDeclarations(\n       ref: new Reference(resolveDeclaration(decl)),\n       exportAs: decl.exportAs || null,\n       hasNgTemplateContextGuard: decl.hasNgTemplateContextGuard || false,\n-      inputs: decl.inputs || {},\n+      inputs: ClassPropertyMapping.fromMappedObject(decl.inputs || {}),\n       isComponent: decl.isComponent || false,\n       ngTemplateGuards: decl.ngTemplateGuards || [],\n       coercedInputFields: new Set<string>(decl.coercedInputFields || []),\n       restrictedInputFields: new Set<string>(decl.restrictedInputFields || []),\n       stringLiteralInputFields: new Set<string>(decl.stringLiteralInputFields || []),\n       undeclaredInputFields: new Set<string>(decl.undeclaredInputFields || []),\n       isGeneric: decl.isGeneric ?? false,\n-      outputs: decl.outputs || {},\n+      outputs: ClassPropertyMapping.fromMappedObject(decl.outputs || {}),\n       queries: decl.queries || [],\n     };\n     matcher.addSelectables(selector, meta);"
        },
        {
            "sha": "35513968804e0f2cfc638e90110aec2e22e05cc7",
            "filename": "packages/compiler/src/render3/view/t2_api.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 2,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ft2_api.ts",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ft2_api.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ft2_api.ts?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -26,6 +26,16 @@ export interface Target {\n   template?: Node[];\n }\n \n+/**\n+ * A data structure which can indicate whether a given property name is present or not.\n+ *\n+ * This is used to represent the set of inputs or outputs present on a directive, and allows the\n+ * binder to query for the presence of a mapping for property names.\n+ */\n+export interface InputOutputPropertySet {\n+  hasBindingPropertyName(propertyName: string): boolean;\n+}\n+\n /**\n  * Metadata regarding a directive that's needed to match it against template elements. This is\n  * provided by a consumer of the t2 APIs.\n@@ -46,14 +56,14 @@ export interface DirectiveMeta {\n    *\n    * Goes from property names to field names.\n    */\n-  inputs: {[property: string]: string|[string, string]};\n+  inputs: InputOutputPropertySet;\n \n   /**\n    * Set of outputs which this directive claims.\n    *\n    * Goes from property names to field names.\n    */\n-  outputs: {[property: string]: string};\n+  outputs: InputOutputPropertySet;\n \n   /**\n    * Name under which the directive is exported, if any (exportAs in Angular)."
        },
        {
            "sha": "53b363afcc17230d53e2f3d76be3bee827e37fdd",
            "filename": "packages/compiler/src/render3/view/t2_binder.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ft2_binder.ts",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ft2_binder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ft2_binder.ts?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -278,7 +278,7 @@ class DirectiveBinder<DirectiveT extends DirectiveMeta> implements Visitor {\n     type BoundNode = BoundAttribute|BoundEvent|TextAttribute;\n     const setAttributeBinding =\n         (attribute: BoundNode, ioType: keyof Pick<DirectiveMeta, 'inputs'|'outputs'>) => {\n-          const dir = directives.find(dir => dir[ioType].hasOwnProperty(attribute.name));\n+          const dir = directives.find(dir => dir[ioType].hasBindingPropertyName(attribute.name));\n           const binding = dir !== undefined ? dir : node;\n           this.bindings.set(attribute, binding);\n         };"
        },
        {
            "sha": "a1c51254544d25c66eedb1942630e65b1ecb1f7c",
            "filename": "packages/compiler/test/render3/view/binding_spec.ts",
            "status": "modified",
            "additions": 26,
            "deletions": 11,
            "changes": 37,
            "blob_url": "https://github.com/angular/angular/blob/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler%2Ftest%2Frender3%2Fview%2Fbinding_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/4007422cc63ff17eb080c78dc2a9a05d75369c60/packages%2Fcompiler%2Ftest%2Frender3%2Fview%2Fbinding_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Frender3%2Fview%2Fbinding_spec.ts?ref=4007422cc63ff17eb080c78dc2a9a05d75369c60",
            "patch": "@@ -8,41 +8,56 @@\n \n import * as e from '../../../src/expression_parser/ast';\n import * as a from '../../../src/render3/r3_ast';\n-import {DirectiveMeta} from '../../../src/render3/view/t2_api';\n+import {DirectiveMeta, InputOutputPropertySet} from '../../../src/render3/view/t2_api';\n import {R3TargetBinder} from '../../../src/render3/view/t2_binder';\n import {parseTemplate} from '../../../src/render3/view/template';\n import {CssSelector, SelectorMatcher} from '../../../src/selector';\n \n import {findExpression} from './util';\n \n+/**\n+ * A `InputOutputPropertySet` which only uses an identity mapping for fields and properties.\n+ */\n+class IdentityInputMapping implements InputOutputPropertySet {\n+  private names: Set<string>;\n+\n+  constructor(names: string[]) {\n+    this.names = new Set(names);\n+  }\n+\n+  hasBindingPropertyName(propertyName: string): boolean {\n+    return this.names.has(propertyName);\n+  }\n+}\n+\n function makeSelectorMatcher(): SelectorMatcher<DirectiveMeta> {\n   const matcher = new SelectorMatcher<DirectiveMeta>();\n   matcher.addSelectables(CssSelector.parse('[ngFor][ngForOf]'), {\n     name: 'NgFor',\n     exportAs: null,\n-    inputs: {'ngForOf': 'ngForOf'},\n-    outputs: {},\n+    inputs: new IdentityInputMapping(['ngForOf']),\n+    outputs: new IdentityInputMapping([]),\n     isComponent: false,\n   });\n   matcher.addSelectables(CssSelector.parse('[dir]'), {\n     name: 'Dir',\n     exportAs: null,\n-    inputs: {},\n-    outputs: {},\n+    inputs: new IdentityInputMapping([]),\n+    outputs: new IdentityInputMapping([]),\n     isComponent: false,\n   });\n   matcher.addSelectables(CssSelector.parse('[hasOutput]'), {\n     name: 'HasOutput',\n     exportAs: null,\n-    inputs: {},\n-    outputs: {'outputBinding': 'outputBinding'},\n+    inputs: new IdentityInputMapping([]),\n+    outputs: new IdentityInputMapping(['outputBinding']),\n     isComponent: false,\n   });\n   matcher.addSelectables(CssSelector.parse('[hasInput]'), {\n     name: 'HasInput',\n     exportAs: null,\n-    inputs: {'inputBinding': 'inputBinding'},\n-    outputs: {},\n+    inputs: new IdentityInputMapping(['inputBinding']),\n+    outputs: new IdentityInputMapping([]),\n     isComponent: false,\n   });\n   return matcher;\n@@ -85,8 +100,8 @@ describe('t2 binding', () => {\n     matcher.addSelectables(CssSelector.parse('text[dir]'), {\n       name: 'Dir',\n       exportAs: null,\n-      inputs: {},\n-      outputs: {},\n+      inputs: new IdentityInputMapping([]),\n+      outputs: new IdentityInputMapping([]),\n       isComponent: false,\n     });\n     const binder = new R3TargetBinder(matcher);"
        }
    ],
    "stats": {
        "total": 509,
        "additions": 399,
        "deletions": 110
    }
}