{
    "author": "AndrewKushnir",
    "message": "refactor(compiler): separate compilation and transform phases (#38213)\n\nThis commit splits the transformation into 2 separate steps: Ivy compilation and actual transformation\nof corresponding TS nodes. This is needed to have all `o.Expression`s generated before any TS transforms\nhappen. This allows `ConstantPool` to properly identify expressions that can be shared across multiple\ncomponents declared in the same file.\n\nResolves #38203.\n\nPR Close #38213",
    "sha": "2fdc18b42c72c8784a98344e4a5e1b0bc289cf28",
    "files": [
        {
            "sha": "c587ebcc15254e41f89be52cb495a57b26108b79",
            "filename": "packages/compiler-cli/src/ngtsc/transform/src/transform.ts",
            "status": "modified",
            "additions": 99,
            "deletions": 58,
            "changes": 157,
            "blob_url": "https://github.com/angular/angular/blob/2fdc18b42c72c8784a98344e4a5e1b0bc289cf28/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Ftransform.ts",
            "raw_url": "https://github.com/angular/angular/raw/2fdc18b42c72c8784a98344e4a5e1b0bc289cf28/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Ftransform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Ftransform.ts?ref=2fdc18b42c72c8784a98344e4a5e1b0bc289cf28",
            "patch": "@@ -14,6 +14,7 @@ import {Decorator, ReflectionHost} from '../../reflection';\n import {ImportManager, translateExpression, translateStatement} from '../../translator';\n import {visit, VisitListEntryResult, Visitor} from '../../util/src/visitor';\n \n+import {CompileResult} from './api';\n import {TraitCompiler} from './compilation';\n import {addImports} from './utils';\n \n@@ -43,69 +44,94 @@ export function ivyTransformFactory(\n   };\n }\n \n-class IvyVisitor extends Visitor {\n-  constructor(\n-      private compilation: TraitCompiler, private reflector: ReflectionHost,\n-      private importManager: ImportManager, private defaultImportRecorder: DefaultImportRecorder,\n-      private isClosureCompilerEnabled: boolean, private isCore: boolean,\n-      private constantPool: ConstantPool) {\n+/**\n+ * Visits all classes, performs Ivy compilation where Angular decorators are present and collects\n+ * result in a Map that associates a ts.ClassDeclaration with Ivy compilation results. This visitor\n+ * does NOT perform any TS transformations.\n+ */\n+class IvyCompilationVisitor extends Visitor {\n+  public classCompilationMap = new Map<ts.ClassDeclaration, CompileResult[]>();\n+\n+  constructor(private compilation: TraitCompiler, private constantPool: ConstantPool) {\n     super();\n   }\n \n   visitClassDeclaration(node: ts.ClassDeclaration):\n       VisitListEntryResult<ts.Statement, ts.ClassDeclaration> {\n     // Determine if this class has an Ivy field that needs to be added, and compile the field\n     // to an expression if so.\n-    const res = this.compilation.compile(node, this.constantPool);\n-\n-    if (res !== null) {\n-      // There is at least one field to add.\n-      const statements: ts.Statement[] = [];\n-      const members = [...node.members];\n-\n-      res.forEach(field => {\n-        // Translate the initializer for the field into TS nodes.\n-        const exprNode = translateExpression(\n-            field.initializer, this.importManager, this.defaultImportRecorder,\n-            ts.ScriptTarget.ES2015);\n-\n-        // Create a static property declaration for the new field.\n-        const property = ts.createProperty(\n-            undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], field.name, undefined,\n-            undefined, exprNode);\n-\n-        if (this.isClosureCompilerEnabled) {\n-          // Closure compiler transforms the form `Service.ɵprov = X` into `Service$ɵprov = X`. To\n-          // prevent this transformation, such assignments need to be annotated with @nocollapse.\n-          // Note that tsickle is typically responsible for adding such annotations, however it\n-          // doesn't yet handle synthetic fields added during other transformations.\n-          ts.addSyntheticLeadingComment(\n-              property, ts.SyntaxKind.MultiLineCommentTrivia, '* @nocollapse ',\n-              /* hasTrailingNewLine */ false);\n-        }\n-\n-        field.statements\n-            .map(\n-                stmt => translateStatement(\n-                    stmt, this.importManager, this.defaultImportRecorder, ts.ScriptTarget.ES2015))\n-            .forEach(stmt => statements.push(stmt));\n-\n-        members.push(property);\n-      });\n-\n-      // Replace the class declaration with an updated version.\n-      node = ts.updateClassDeclaration(\n-          node,\n-          // Remove the decorator which triggered this compilation, leaving the others alone.\n-          maybeFilterDecorator(node.decorators, this.compilation.decoratorsFor(node)),\n-          node.modifiers, node.name, node.typeParameters, node.heritageClauses || [],\n-          // Map over the class members and remove any Angular decorators from them.\n-          members.map(member => this._stripAngularDecorators(member)));\n-      return {node, after: statements};\n+    const result = this.compilation.compile(node, this.constantPool);\n+    if (result !== null) {\n+      this.classCompilationMap.set(node, result);\n     }\n-\n     return {node};\n   }\n+}\n+\n+/**\n+ * Visits all classes and performs transformation of corresponding TS nodes based on the Ivy\n+ * compilation results (provided as an argument).\n+ */\n+class IvyTransformationVisitor extends Visitor {\n+  constructor(\n+      private compilation: TraitCompiler,\n+      private classCompilationMap: Map<ts.ClassDeclaration, CompileResult[]>,\n+      private reflector: ReflectionHost, private importManager: ImportManager,\n+      private defaultImportRecorder: DefaultImportRecorder,\n+      private isClosureCompilerEnabled: boolean, private isCore: boolean) {\n+    super();\n+  }\n+\n+  visitClassDeclaration(node: ts.ClassDeclaration):\n+      VisitListEntryResult<ts.Statement, ts.ClassDeclaration> {\n+    // If this class is not registered in the map, it means that it doesn't have Angular decorators,\n+    // thus no further processing is required.\n+    if (!this.classCompilationMap.has(node)) return {node};\n+\n+    // There is at least one field to add.\n+    const statements: ts.Statement[] = [];\n+    const members = [...node.members];\n+\n+    this.classCompilationMap.get(node)!.forEach(field => {\n+      // Translate the initializer for the field into TS nodes.\n+      const exprNode = translateExpression(\n+          field.initializer, this.importManager, this.defaultImportRecorder,\n+          ts.ScriptTarget.ES2015);\n+\n+      // Create a static property declaration for the new field.\n+      const property = ts.createProperty(\n+          undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], field.name, undefined,\n+          undefined, exprNode);\n+\n+      if (this.isClosureCompilerEnabled) {\n+        // Closure compiler transforms the form `Service.ɵprov = X` into `Service$ɵprov = X`. To\n+        // prevent this transformation, such assignments need to be annotated with @nocollapse.\n+        // Note that tsickle is typically responsible for adding such annotations, however it\n+        // doesn't yet handle synthetic fields added during other transformations.\n+        ts.addSyntheticLeadingComment(\n+            property, ts.SyntaxKind.MultiLineCommentTrivia, '* @nocollapse ',\n+            /* hasTrailingNewLine */ false);\n+      }\n+\n+      field.statements\n+          .map(\n+              stmt => translateStatement(\n+                  stmt, this.importManager, this.defaultImportRecorder, ts.ScriptTarget.ES2015))\n+          .forEach(stmt => statements.push(stmt));\n+\n+      members.push(property);\n+    });\n+\n+    // Replace the class declaration with an updated version.\n+    node = ts.updateClassDeclaration(\n+        node,\n+        // Remove the decorator which triggered this compilation, leaving the others alone.\n+        maybeFilterDecorator(node.decorators, this.compilation.decoratorsFor(node)), node.modifiers,\n+        node.name, node.typeParameters, node.heritageClauses || [],\n+        // Map over the class members and remove any Angular decorators from them.\n+        members.map(member => this._stripAngularDecorators(member)));\n+    return {node, after: statements};\n+  }\n \n   /**\n    * Return all decorators on a `Declaration` which are from @angular/core, or an empty set if none\n@@ -224,11 +250,26 @@ function transformIvySourceFile(\n   const constantPool = new ConstantPool();\n   const importManager = new ImportManager(importRewriter);\n \n-  // Recursively scan through the AST and perform any updates requested by the IvyCompilation.\n-  const visitor = new IvyVisitor(\n-      compilation, reflector, importManager, defaultImportRecorder, isClosureCompilerEnabled,\n-      isCore, constantPool);\n-  let sf = visit(file, visitor, context);\n+  // The transformation process consists of 2 steps:\n+  //\n+  //  1. Visit all classes, perform compilation and collect the results.\n+  //  2. Perform actual transformation of required TS nodes using compilation results from the first\n+  //     step.\n+  //\n+  // This is needed to have all `o.Expression`s generated before any TS transforms happen. This\n+  // allows `ConstantPool` to properly identify expressions that can be shared across multiple\n+  // components declared in the same file.\n+\n+  // Step 1. Go though all classes in AST, perform compilation and collect the results.\n+  const compilationVisitor = new IvyCompilationVisitor(compilation, constantPool);\n+  visit(file, compilationVisitor, context);\n+\n+  // Step 2. Scan through the AST again and perform transformations based on Ivy compilation\n+  // results obtained at Step 1.\n+  const transformationVisitor = new IvyTransformationVisitor(\n+      compilation, compilationVisitor.classCompilationMap, reflector, importManager,\n+      defaultImportRecorder, isClosureCompilerEnabled, isCore);\n+  let sf = visit(file, transformationVisitor, context);\n \n   // Generate the constant statements first, as they may involve adding additional imports\n   // to the ImportManager."
        }
    ],
    "stats": {
        "total": 157,
        "additions": 99,
        "deletions": 58
    }
}