{
    "author": "atscott",
    "message": "refactor(router): Ensure computed state restoration works for thrown errors (#42933)\n\nWhen `canceledNavigationResolution='computed'`, the `Router` needs to\nhandle the cases where errors are thrown. Previously, the logic was not\nupdated and would simply do a `replaceState` rather than determining\nwhere in the history we should move to restore the page/url from before\nthe failed navigation.\n\nPR Close #42933",
    "sha": "9119e1f7bdfab3161accc80f303d00c4d04ac2c3",
    "files": [
        {
            "sha": "af30d2e32b84a76643a7fc7aeefecb2393ab31c7",
            "filename": "packages/router/src/router.ts",
            "status": "modified",
            "additions": 52,
            "deletions": 30,
            "changes": 82,
            "blob_url": "https://github.com/angular/angular/blob/9119e1f7bdfab3161accc80f303d00c4d04ac2c3/packages%2Frouter%2Fsrc%2Frouter.ts",
            "raw_url": "https://github.com/angular/angular/raw/9119e1f7bdfab3161accc80f303d00c4d04ac2c3/packages%2Frouter%2Fsrc%2Frouter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frouter.ts?ref=9119e1f7bdfab3161accc80f303d00c4d04ac2c3",
            "patch": "@@ -771,7 +771,8 @@ export class Router {\n \n                      filter(t => {\n                        if (!t.guardsResult) {\n-                         this.cancelNavigationTransitionRestoreHistory(t, '');\n+                         this.restoreHistory(t);\n+                         this.cancelNavigationTransition(t, '');\n                          return false;\n                        }\n                        return true;\n@@ -796,7 +797,8 @@ export class Router {\n                                      next: () => dataResolved = true,\n                                      complete: () => {\n                                        if (!dataResolved) {\n-                                         this.cancelNavigationTransitionRestoreHistory(\n+                                         this.restoreHistory(t);\n+                                         this.cancelNavigationTransition(\n                                              t,\n                                              `At least one route resolver didn't emit any value.`);\n                                        }\n@@ -889,7 +891,8 @@ export class Router {\n                            // AngularJS sync code which looks for a value here in order to determine\n                            // whether or not to handle a given popstate event or to leave it to the\n                            // Angular router.\n-                           this.cancelNavigationTransitionRestoreHistory(t, cancelationReason);\n+                           this.restoreHistory(t);\n+                           this.cancelNavigationTransition(t, cancelationReason);\n                          } else {\n                            // We cannot trigger a `location.historyGo` if the\n                            // cancellation was due to a new navigation before the previous could\n@@ -908,6 +911,10 @@ export class Router {\n                        this.currentNavigation = null;\n                      }),\n                      catchError((e) => {\n+                       // TODO(atscott): The NavigationTransition `t` used here does not accurately\n+                       // reflect the current state of the whole transition because some operations\n+                       // return a new object rather than modifying the one in the outermost\n+                       // `switchMap`.\n                        errored = true;\n                        /* This error type is issued during Redirect, and is handled as a\n                         * cancellation rather than an error. */\n@@ -920,7 +927,7 @@ export class Router {\n                            // This is only applicable with initial navigation, so setting\n                            // `navigated` only when not redirecting resolves this scenario.\n                            this.navigated = true;\n-                           this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl);\n+                           this.restoreHistory(t, true);\n                          }\n                          const navCancel = new NavigationCancel(\n                              t.id, this.serializeUrl(t.extractedUrl), e.message);\n@@ -952,7 +959,7 @@ export class Router {\n                          /* All other errors should reset to the router's internal URL reference to\n                           * the pre-error state. */\n                        } else {\n-                         this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl);\n+                         this.restoreHistory(t, true);\n                          const navError =\n                              new NavigationError(t.id, this.serializeUrl(t.extractedUrl), e);\n                          eventsSubject.next(navError);\n@@ -1458,44 +1465,59 @@ export class Router {\n     }\n   }\n \n-  private resetStateAndUrl(storedState: RouterState, storedUrl: UrlTree, rawUrl: UrlTree): void {\n-    (this as {routerState: RouterState}).routerState = storedState;\n-    this.currentUrlTree = storedUrl;\n-    this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, rawUrl);\n-    this.resetUrlToCurrentUrlTree();\n-  }\n-\n-  private resetUrlToCurrentUrlTree(): void {\n-    this.location.replaceState(\n-        this.urlSerializer.serialize(this.rawUrlTree), '',\n-        this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));\n-  }\n-\n   /**\n-   * Responsible for handling the cancellation of a navigation:\n-   * - performs the necessary rollback action to restore the browser URL to the\n-   * state before the transition\n-   * - triggers the `NavigationCancel` event\n-   * - resolves the transition promise with `false`\n+   * Performs the necessary rollback action to restore the browser URL to the\n+   * state before the transition.\n    */\n-  private cancelNavigationTransitionRestoreHistory(t: NavigationTransition, reason: string) {\n+  private restoreHistory(t: NavigationTransition, restoringFromCaughtError = false) {\n     if (this.canceledNavigationResolution === 'computed') {\n+      const targetPagePosition = this.currentPageId - t.targetPageId;\n       // The navigator change the location before triggered the browser event,\n       // so we need to go back to the current url if the navigation is canceled.\n       // Also, when navigation gets cancelled while using url update strategy eager, then we need to\n       // go back. Because, when `urlUpdateSrategy` is `eager`; `setBrowserUrl` method is called\n       // before any verification.\n-      if (t.source === 'popstate' || this.urlUpdateStrategy === 'eager') {\n-        const targetPagePosition = this.currentPageId - t.targetPageId;\n+      const browserUrlUpdateOccurred =\n+          (t.source === 'popstate' || this.urlUpdateStrategy === 'eager' ||\n+           this.currentUrlTree === this.currentNavigation?.finalUrl);\n+      if (browserUrlUpdateOccurred && targetPagePosition !== 0) {\n         this.location.historyGo(targetPagePosition);\n+      } else if (\n+          this.currentUrlTree === this.currentNavigation?.finalUrl && targetPagePosition === 0) {\n+        // We got to the activation stage (where currentUrlTree is set to the navigation's\n+        // finalUrl), but we weren't moving anywhere in history (skipLocationChange or replaceUrl).\n+        // We still need to reset the router state back to what it was when the navigation started.\n+        this.resetState(t);\n+        // TODO(atscott): resetting the `browserUrlTree` should really be done in `resetState`.\n+        // Investigate if this can be done by running TGP.\n+        this.browserUrlTree = t.currentUrlTree;\n+        this.resetUrlToCurrentUrlTree();\n       } else {\n-        // If update is not 'eager' and the transition navigation source isn't 'popstate', then the\n-        // navigation was cancelled before any browser url change so nothing needs to be restored.\n+        // The browser URL and router state was not updated before the navigation cancelled so\n+        // there's no restoration needed.\n+      }\n+    } else if (this.canceledNavigationResolution === 'replace') {\n+      // TODO(atscott): It seems like we should _always_ reset the state here. It would be a no-op\n+      // for `deferred` navigations that haven't change the internal state yet because guards\n+      // reject. For 'eager' navigations, it seems like we also really should reset the state\n+      // because the navigation was cancelled. Investigate if this can be done by running TGP.\n+      if (restoringFromCaughtError) {\n+        this.resetState(t);\n       }\n-    } else {\n       this.resetUrlToCurrentUrlTree();\n     }\n-    this.cancelNavigationTransition(t, reason);\n+  }\n+\n+  private resetState(t: NavigationTransition): void {\n+    (this as {routerState: RouterState}).routerState = t.currentRouterState;\n+    this.currentUrlTree = t.currentUrlTree;\n+    this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl);\n+  }\n+\n+  private resetUrlToCurrentUrlTree(): void {\n+    this.location.replaceState(\n+        this.urlSerializer.serialize(this.rawUrlTree), '',\n+        this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));\n   }\n \n   private cancelNavigationTransition(t: NavigationTransition, reason: string) {"
        },
        {
            "sha": "3d95fa71a1c34fada70603d4106bfe5c68bf831e",
            "filename": "packages/router/test/integration.spec.ts",
            "status": "modified",
            "additions": 97,
            "deletions": 4,
            "changes": 101,
            "blob_url": "https://github.com/angular/angular/blob/9119e1f7bdfab3161accc80f303d00c4d04ac2c3/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/9119e1f7bdfab3161accc80f303d00c4d04ac2c3/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fintegration.spec.ts?ref=9119e1f7bdfab3161accc80f303d00c4d04ac2c3",
            "patch": "@@ -2822,6 +2822,20 @@ describe('Integration', () => {\n       }\n     }\n \n+    @Injectable({providedIn: 'root'})\n+    class ThrowingCanActivateGuard implements CanActivate {\n+      throw = false;\n+\n+      constructor(private router: Router) {}\n+\n+      canActivate(): boolean {\n+        if (this.throw) {\n+          throw new Error('error in guard');\n+        }\n+        return true;\n+      }\n+    }\n+\n     @Injectable({providedIn: 'root'})\n     class MyCanActivateGuard implements CanActivate {\n       allow: boolean = true;\n@@ -2865,33 +2879,37 @@ describe('Integration', () => {\n       const router = TestBed.inject(Router);\n       (router as any).canceledNavigationResolution = 'computed';\n       const location = TestBed.inject(Location);\n-      fixture = createRoot(router, SimpleCmp);\n+      fixture = createRoot(router, RootCmp);\n       router.resetConfig([\n         {\n           path: 'first',\n           component: SimpleCmp,\n           canDeactivate: [MyCanDeactivateGuard],\n-          canActivate: [MyCanActivateGuard],\n+          canActivate: [MyCanActivateGuard, ThrowingCanActivateGuard],\n           resolve: [MyResolve]\n         },\n         {\n           path: 'second',\n           component: SimpleCmp,\n           canDeactivate: [MyCanDeactivateGuard],\n-          canActivate: [MyCanActivateGuard],\n+          canActivate: [MyCanActivateGuard, ThrowingCanActivateGuard],\n           resolve: [MyResolve]\n         },\n         {\n           path: 'third',\n           component: SimpleCmp,\n           canDeactivate: [MyCanDeactivateGuard],\n-          canActivate: [MyCanActivateGuard],\n+          canActivate: [MyCanActivateGuard, ThrowingCanActivateGuard],\n           resolve: [MyResolve]\n         },\n         {\n           path: 'unguarded',\n           component: SimpleCmp,\n         },\n+        {\n+          path: 'throwing',\n+          component: ThrowingCmp,\n+        },\n         {path: 'loaded', loadChildren: () => of(LoadedModule), canLoad: ['alwaysFalse']}\n       ]);\n       router.navigateByUrl('/first');\n@@ -3156,6 +3174,81 @@ describe('Integration', () => {\n          expect(location.path()).toEqual('/second');\n          expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n        }));\n+\n+    for (const urlUpdateSrategy of ['deferred', 'eager'] as const) {\n+      it(`restores history correctly when an error is thrown in guard with urlUpdateStrategy ${\n+             urlUpdateSrategy}`,\n+         fakeAsync(() => {\n+           const location = TestBed.inject(Location);\n+           const router = TestBed.inject(Router);\n+           router.urlUpdateStrategy = urlUpdateSrategy;\n+\n+           TestBed.inject(ThrowingCanActivateGuard).throw = true;\n+\n+           expect(() => {\n+             location.back();\n+             advance(fixture);\n+           }).toThrow();\n+           expect(location.path()).toEqual('/second');\n+           expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+           TestBed.inject(ThrowingCanActivateGuard).throw = false;\n+           location.back();\n+           advance(fixture);\n+           expect(location.path()).toEqual('/first');\n+           expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n+         }));\n+\n+      it(`restores history correctly when component throws error in constructor with urlUpdateStrategy ${\n+             urlUpdateSrategy}`,\n+         fakeAsync(() => {\n+           const location = TestBed.inject(Location);\n+           const router = TestBed.inject(Router);\n+           router.urlUpdateStrategy = urlUpdateSrategy;\n+\n+           router.navigateByUrl('/throwing').catch(() => null);\n+           advance(fixture);\n+           expect(location.path()).toEqual('/second');\n+           expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+           location.back();\n+           advance(fixture);\n+           expect(location.path()).toEqual('/first');\n+           expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n+         }));\n+    }\n+\n+    it('restores history correctly when component throws error in constructor and replaceUrl=true',\n+       fakeAsync(() => {\n+         const location = TestBed.inject(Location);\n+         const router = TestBed.inject(Router);\n+\n+         router.navigateByUrl('/throwing', {replaceUrl: true}).catch(() => null);\n+         advance(fixture);\n+         expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+         location.back();\n+         advance(fixture);\n+         expect(location.path()).toEqual('/first');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n+       }));\n+\n+    it('restores history correctly when component throws error in constructor and skipLocationChange=true',\n+       fakeAsync(() => {\n+         const location = TestBed.inject(Location);\n+         const router = TestBed.inject(Router);\n+\n+         router.navigateByUrl('/throwing', {skipLocationChange: true}).catch(() => null);\n+         advance(fixture);\n+         expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+         location.back();\n+         advance(fixture);\n+         expect(location.path()).toEqual('/first');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n+       }));\n   });\n   describe('guards', () => {\n     describe('CanActivate', () => {"
        }
    ],
    "stats": {
        "total": 183,
        "additions": 149,
        "deletions": 34
    }
}