{
    "author": "alxhub",
    "message": "feat(language-service): complete attributes on elements (#40032)\n\nThis commit adds attribute completion to the Language Service. It completes\nfrom 3 sources:\n\n1. inputs/outputs of directives currently present on the element\n2. inputs/outputs/attributes of directives in scope for the element, that\n   would become present if the input/output/attribute was added\n3. DOM properties and attributes\n\nWe distinguish between completion of a property binding (`[foo|]`) and a\ncompletion in an attribute context (`foo|`). For the latter, bindings to\nthe attribute are offered, as well as a property binding which adds the\nsquare bracket notation.\n\nTo determine hypothetical matches (directives which would become present if\na binding is added), directives in scope are scanned and matched against a\nhypothetical version of the element which has the attribute.\n\nPR Close #40032",
    "sha": "66378ed0efc4fe344c343232a69d2142fdf622d5",
    "files": [
        {
            "sha": "044974cee2fda59f4f4741fcfe9244d4ea6c406d",
            "filename": "packages/language-service/ivy/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/66378ed0efc4fe344c343232a69d2142fdf622d5/packages%2Flanguage-service%2Fivy%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/66378ed0efc4fe344c343232a69d2142fdf622d5/packages%2Flanguage-service%2Fivy%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2FBUILD.bazel?ref=66378ed0efc4fe344c343232a69d2142fdf622d5",
            "patch": "@@ -11,6 +11,7 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/core\",\n         \"//packages/compiler-cli/src/ngtsc/core:api\",\n         \"//packages/compiler-cli/src/ngtsc/file_system\",\n+        \"//packages/compiler-cli/src/ngtsc/imports\",\n         \"//packages/compiler-cli/src/ngtsc/incremental\",\n         \"//packages/compiler-cli/src/ngtsc/metadata\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\","
        },
        {
            "sha": "3cb46fe7892045b0f5b83cf63065f4aaca60d148",
            "filename": "packages/language-service/ivy/attribute_completions.ts",
            "status": "added",
            "additions": 471,
            "deletions": 0,
            "changes": 471,
            "blob_url": "https://github.com/angular/angular/blob/66378ed0efc4fe344c343232a69d2142fdf622d5/packages%2Flanguage-service%2Fivy%2Fattribute_completions.ts",
            "raw_url": "https://github.com/angular/angular/raw/66378ed0efc4fe344c343232a69d2142fdf622d5/packages%2Flanguage-service%2Fivy%2Fattribute_completions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fattribute_completions.ts?ref=66378ed0efc4fe344c343232a69d2142fdf622d5",
            "patch": "@@ -0,0 +1,471 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {CssSelector, SelectorMatcher, TmplAstElement} from '@angular/compiler';\n+import {DirectiveInScope, TemplateTypeChecker} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n+import * as ts from 'typescript';\n+\n+import {DisplayInfoKind, unsafeCastDisplayInfoKindToScriptElementKind} from './display_parts';\n+import {makeElementSelector} from './utils';\n+\n+/**\n+ * Differentiates different kinds of `AttributeCompletion`s.\n+ */\n+export enum AttributeCompletionKind {\n+  /**\n+   * Completion of an attribute from the HTML schema.\n+   *\n+   * Attributes often have a corresponding DOM property of the same name.\n+   */\n+  DomAttribute,\n+\n+  /**\n+   * Completion of a property from the DOM schema.\n+   *\n+   * `DomProperty` completions are generated only for properties which don't share their name with\n+   * an HTML attribute.\n+   */\n+  DomProperty,\n+\n+  /**\n+   * Completion of an attribute that results in a new directive being matched on an element.\n+   */\n+  DirectiveAttribute,\n+\n+  /**\n+   * Completion of an input from a directive which is either present on the element, or becomes\n+   * present after the addition of this attribute.\n+   */\n+  DirectiveInput,\n+\n+  /**\n+   * Completion of an output from a directive which is either present on the element, or becomes\n+   * present after the addition of this attribute.\n+   */\n+  DirectiveOutput,\n+}\n+\n+/**\n+ * Completion of an attribute from the DOM schema.\n+ */\n+export interface DomAttributeCompletion {\n+  kind: AttributeCompletionKind.DomAttribute;\n+\n+  /**\n+   * Name of the HTML attribute (not to be confused with the corresponding DOM property name).\n+   */\n+  attribute: string;\n+\n+  /**\n+   * Whether this attribute is also a DOM property.\n+   */\n+  isAlsoProperty: boolean;\n+}\n+\n+/**\n+ * Completion of a DOM property of an element that's distinct from an HTML attribute.\n+ */\n+export interface DomPropertyCompletion {\n+  kind: AttributeCompletionKind.DomProperty;\n+\n+  /**\n+   * Name of the DOM property\n+   */\n+  property: string;\n+}\n+\n+/**\n+ * Completion of an attribute which results in a new directive being matched on an element.\n+ */\n+export interface DirectiveAttributeCompletion {\n+  kind: AttributeCompletionKind.DirectiveAttribute;\n+\n+  /**\n+   * Name of the attribute whose addition causes this directive to match the element.\n+   */\n+  attribute: string;\n+\n+  /**\n+   * The directive whose selector gave rise to this completion.\n+   */\n+  directive: DirectiveInScope;\n+}\n+\n+/**\n+ * Completion of an input of a directive which may either be present on the element, or become\n+ * present when a binding to this input is added.\n+ */\n+export interface DirectiveInputCompletion {\n+  kind: AttributeCompletionKind.DirectiveInput;\n+\n+  /**\n+   * The public property name of the input (the name which would be used in any binding to that\n+   * input).\n+   */\n+  propertyName: string;\n+\n+  /**\n+   * The directive which has this input.\n+   */\n+  directive: DirectiveInScope;\n+\n+  /**\n+   * The field name on the directive class which corresponds to this input.\n+   *\n+   * Currently, in the case where a single property name corresponds to multiple input fields, only\n+   * the first such field is represented here. In the future multiple results may be warranted.\n+   */\n+  classPropertyName: string;\n+\n+  /**\n+   * Whether this input can be used with two-way binding (that is, whether a corresponding change\n+   * output exists on the directive).\n+   */\n+  twoWayBindingSupported: boolean;\n+}\n+\n+export interface DirectiveOutputCompletion {\n+  kind: AttributeCompletionKind.DirectiveOutput;\n+\n+  /**\n+   * The public event name of the output (the name which would be used in any binding to that\n+   * output).\n+   */\n+  eventName: string;\n+\n+  /**\n+   *The directive which has this output.\n+   */\n+  directive: DirectiveInScope;\n+\n+  /**\n+   * The field name on the directive class which corresponds to this output.\n+   */\n+  classPropertyName: string;\n+}\n+\n+/**\n+ * Any named attribute which is available for completion on a given element.\n+ *\n+ * Disambiguated by the `kind` property into various types of completions.\n+ */\n+export type AttributeCompletion = DomAttributeCompletion|DomPropertyCompletion|\n+    DirectiveAttributeCompletion|DirectiveInputCompletion|DirectiveOutputCompletion;\n+\n+/**\n+ * Given an element and its context, produce a `Map` of all possible attribute completions.\n+ *\n+ * 3 kinds of attributes are considered for completion, from highest to lowest priority:\n+ *\n+ * 1. Inputs/outputs of directives present on the element already.\n+ * 2. Inputs/outputs of directives that are not present on the element, but which would become\n+ *    present if such a binding is added.\n+ * 3. Attributes from the DOM schema for the element.\n+ *\n+ * The priority of these options determines which completions are added to the `Map`. If a directive\n+ * input shares the same name as a DOM attribute, the `Map` will reflect the directive input\n+ * completion, not the DOM completion for that name.\n+ */\n+export function buildAttributeCompletionTable(\n+    component: ts.ClassDeclaration, element: TmplAstElement,\n+    checker: TemplateTypeChecker): Map<string, AttributeCompletion> {\n+  const table = new Map<string, AttributeCompletion>();\n+\n+  // Use the `ElementSymbol` to iterate over directives present on the element, and their\n+  // inputs/outputs. These have the highest priority of completion results.\n+  const symbol = checker.getSymbolOfNode(element, component);\n+  const presentDirectives = new Set<ts.ClassDeclaration>();\n+  if (symbol !== null) {\n+    // An `ElementSymbol` was available. This means inputs and outputs for directives on the\n+    // element can be added to the completion table.\n+    for (const dirSymbol of symbol.directives) {\n+      const directive = dirSymbol.tsSymbol.valueDeclaration;\n+      if (!ts.isClassDeclaration(directive)) {\n+        continue;\n+      }\n+      presentDirectives.add(directive);\n+\n+      const meta = checker.getDirectiveMetadata(directive);\n+      if (meta === null) {\n+        continue;\n+      }\n+\n+      for (const [propertyName, classPropertyName] of meta.inputs) {\n+        if (table.has(propertyName)) {\n+          continue;\n+        }\n+\n+        table.set(propertyName, {\n+          kind: AttributeCompletionKind.DirectiveInput,\n+          propertyName,\n+          directive: dirSymbol,\n+          classPropertyName,\n+          twoWayBindingSupported: meta.outputs.hasBindingPropertyName(propertyName + 'Change'),\n+        });\n+      }\n+\n+      for (const [propertyName, classPropertyName] of meta.outputs) {\n+        if (table.has(propertyName)) {\n+          continue;\n+        }\n+\n+        table.set(propertyName, {\n+          kind: AttributeCompletionKind.DirectiveOutput,\n+          eventName: propertyName,\n+          directive: dirSymbol,\n+          classPropertyName,\n+        });\n+      }\n+    }\n+  }\n+\n+  // Next, explore hypothetical directives and determine if the addition of any single attributes\n+  // can cause the directive to match the element.\n+  const directivesInScope = checker.getDirectivesInScope(component);\n+  if (directivesInScope !== null) {\n+    const elementSelector = makeElementSelector(element);\n+\n+    for (const dirInScope of directivesInScope) {\n+      const directive = dirInScope.tsSymbol.valueDeclaration;\n+      // Skip directives that are present on the element.\n+      if (!ts.isClassDeclaration(directive) || presentDirectives.has(directive)) {\n+        continue;\n+      }\n+\n+      const meta = checker.getDirectiveMetadata(directive);\n+      if (meta === null || meta.selector === null) {\n+        continue;\n+      }\n+\n+      const selectors = CssSelector.parse(meta.selector);\n+      const matcher = new SelectorMatcher();\n+      matcher.addSelectables(selectors);\n+\n+      for (const selector of selectors) {\n+        for (const [attrName, attrValue] of selectorAttributes(selector)) {\n+          if (attrValue !== '') {\n+            // This attribute selector requires a value, which is not supported in completion.\n+            continue;\n+          }\n+\n+          if (table.has(attrName)) {\n+            // Skip this attribute as there's already a binding for it.\n+            continue;\n+          }\n+\n+          // Check whether adding this attribute would cause the directive to start matching.\n+          const newElementSelector = elementSelector + `[${attrName}]`;\n+          if (!matcher.match(CssSelector.parse(newElementSelector)[0], null)) {\n+            // Nope, move on with our lives.\n+            continue;\n+          }\n+\n+          // Adding this attribute causes a new directive to be matched. Decide how to categorize\n+          // it based on the directive's inputs and outputs.\n+          if (meta.inputs.hasBindingPropertyName(attrName)) {\n+            // This attribute corresponds to an input binding.\n+            table.set(attrName, {\n+              kind: AttributeCompletionKind.DirectiveInput,\n+              directive: dirInScope,\n+              propertyName: attrName,\n+              classPropertyName:\n+                  meta.inputs.getByBindingPropertyName(attrName)![0].classPropertyName,\n+              twoWayBindingSupported: meta.outputs.hasBindingPropertyName(attrName + 'Change'),\n+            });\n+          } else if (meta.outputs.hasBindingPropertyName(attrName)) {\n+            // This attribute corresponds to an output binding.\n+            table.set(attrName, {\n+              kind: AttributeCompletionKind.DirectiveOutput,\n+              directive: dirInScope,\n+              eventName: attrName,\n+              classPropertyName:\n+                  meta.outputs.getByBindingPropertyName(attrName)![0].classPropertyName,\n+            });\n+          } else {\n+            // This attribute causes a new directive to be matched, but does not also correspond to\n+            // an input or output binding.\n+            table.set(attrName, {\n+              kind: AttributeCompletionKind.DirectiveAttribute,\n+              attribute: attrName,\n+              directive: dirInScope,\n+            });\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  // Finally, add any DOM attributes not already covered by inputs.\n+  for (const {attribute, property} of checker.getPotentialDomBindings(element.name)) {\n+    const isAlsoProperty = attribute === property;\n+    if (!table.has(attribute)) {\n+      table.set(attribute, {\n+        kind: AttributeCompletionKind.DomAttribute,\n+        attribute,\n+        isAlsoProperty,\n+      });\n+    }\n+    if (!isAlsoProperty && !table.has(property)) {\n+      table.set(property, {\n+        kind: AttributeCompletionKind.DomProperty,\n+        property,\n+      });\n+    }\n+  }\n+\n+  return table;\n+}\n+\n+/**\n+ * Given an `AttributeCompletion`, add any available completions to a `ts.CompletionEntry` array of\n+ * results.\n+ *\n+ * The kind of completions generated depends on whether the current context is an attribute context\n+ * or not. For example, completing on `<element attr|>` will generate two results: `attribute` and\n+ * `[attribute]` - either a static attribute can be generated, or a property binding. However,\n+ * `<element [attr|]>` is not an attribute context, and so only the property completion `attribute`\n+ * is generated. Note that this completion does not have the `[]` property binding sugar as its\n+ * implicitly present in a property binding context (we're already completing within an `[attr|]`\n+ * expression).\n+ */\n+export function addAttributeCompletionEntries(\n+    entries: ts.CompletionEntry[], completion: AttributeCompletion, isAttributeContext: boolean,\n+    replacementSpan: ts.TextSpan|undefined): void {\n+  switch (completion.kind) {\n+    case AttributeCompletionKind.DirectiveAttribute: {\n+      entries.push({\n+        kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+        name: completion.attribute,\n+        sortText: completion.attribute,\n+        replacementSpan,\n+      });\n+      break;\n+    }\n+    case AttributeCompletionKind.DirectiveInput: {\n+      if (isAttributeContext) {\n+        // Offer a completion of a property binding.\n+        entries.push({\n+          kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+          name: `[${completion.propertyName}]`,\n+          sortText: completion.propertyName,\n+          replacementSpan,\n+        });\n+        // If the directive supports banana-in-a-box for this input, offer that as well.\n+        if (completion.twoWayBindingSupported) {\n+          entries.push({\n+            kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+            name: `[(${completion.propertyName})]`,\n+            // This completion should sort after the property binding.\n+            sortText: completion.propertyName + '_1',\n+            replacementSpan,\n+          });\n+        }\n+        // Offer a completion of the input binding as an attribute.\n+        entries.push({\n+          kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+          name: completion.propertyName,\n+          // This completion should sort after both property binding options (one-way and two-way).\n+          sortText: completion.propertyName + '_2',\n+          replacementSpan,\n+        });\n+      } else {\n+        entries.push({\n+          kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+          name: completion.propertyName,\n+          sortText: completion.propertyName,\n+          replacementSpan,\n+        });\n+      }\n+      break;\n+    }\n+    case AttributeCompletionKind.DirectiveOutput: {\n+      if (isAttributeContext) {\n+        entries.push({\n+          kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n+          name: `(${completion.eventName})`,\n+          sortText: completion.eventName,\n+          replacementSpan,\n+        });\n+      } else {\n+        entries.push({\n+          kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n+          name: completion.eventName,\n+          sortText: completion.eventName,\n+          replacementSpan,\n+        });\n+      }\n+      break;\n+    }\n+    case AttributeCompletionKind.DomAttribute: {\n+      if (isAttributeContext) {\n+        // Offer a completion of an attribute binding.\n+        entries.push({\n+          kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+          name: completion.attribute,\n+          sortText: completion.attribute,\n+          replacementSpan,\n+        });\n+        if (completion.isAlsoProperty) {\n+          // Offer a completion of a property binding to the DOM property.\n+          entries.push({\n+            kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+            name: `[${completion.attribute}]`,\n+            // In the case of DOM attributes, the property binding should sort after the attribute\n+            // binding.\n+            sortText: completion.attribute + '_1',\n+            replacementSpan,\n+          });\n+        }\n+      } else if (completion.isAlsoProperty) {\n+        entries.push({\n+          kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+          name: completion.attribute,\n+          sortText: completion.attribute,\n+          replacementSpan,\n+        });\n+      }\n+      break;\n+    }\n+    case AttributeCompletionKind.DomProperty: {\n+      if (!isAttributeContext) {\n+        entries.push({\n+          kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+          name: completion.property,\n+          sortText: completion.property,\n+          replacementSpan,\n+        });\n+      }\n+    }\n+  }\n+}\n+\n+export function getAttributeCompletionSymbol(\n+    completion: AttributeCompletion, checker: ts.TypeChecker): ts.Symbol|null {\n+  switch (completion.kind) {\n+    case AttributeCompletionKind.DomAttribute:\n+    case AttributeCompletionKind.DomProperty:\n+      return null;\n+    case AttributeCompletionKind.DirectiveAttribute:\n+      return completion.directive.tsSymbol;\n+    case AttributeCompletionKind.DirectiveInput:\n+    case AttributeCompletionKind.DirectiveOutput:\n+      return checker.getDeclaredTypeOfSymbol(completion.directive.tsSymbol)\n+                 .getProperty(completion.classPropertyName) ??\n+          null;\n+  }\n+}\n+\n+/**\n+ * Iterates over `CssSelector` attributes, which are internally represented in a zipped array style\n+ * which is not conducive to straightforward iteration.\n+ */\n+function* selectorAttributes(selector: CssSelector): Iterable<[string, string]> {\n+  for (let i = 0; i < selector.attrs.length; i += 2) {\n+    yield [selector.attrs[0], selector.attrs[1]];\n+  }\n+}"
        },
        {
            "sha": "216baa904d4d0e527ba93e52edac47e2b7a947ca",
            "filename": "packages/language-service/ivy/completions.ts",
            "status": "modified",
            "additions": 210,
            "deletions": 30,
            "changes": 240,
            "blob_url": "https://github.com/angular/angular/blob/66378ed0efc4fe344c343232a69d2142fdf622d5/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "raw_url": "https://github.com/angular/angular/raw/66378ed0efc4fe344c343232a69d2142fdf622d5/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fcompletions.ts?ref=66378ed0efc4fe344c343232a69d2142fdf622d5",
            "patch": "@@ -6,24 +6,30 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, EmptyExpr, ImplicitReceiver, LiteralPrimitive, MethodCall, PropertyRead, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\n+import {AST, EmptyExpr, ImplicitReceiver, LiteralPrimitive, MethodCall, ParseSourceSpan, PropertyRead, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n import {CompletionKind, DirectiveInScope, TemplateDeclarationSymbol} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n+import {BoundEvent} from '@angular/compiler/src/render3/r3_ast';\n import * as ts from 'typescript';\n \n-import {DisplayInfoKind, getDirectiveDisplayInfo, getSymbolDisplayInfo, unsafeCastDisplayInfoKindToScriptElementKind} from './display_parts';\n+import {addAttributeCompletionEntries, AttributeCompletionKind, buildAttributeCompletionTable, getAttributeCompletionSymbol} from './attribute_completions';\n+import {DisplayInfo, DisplayInfoKind, getDirectiveDisplayInfo, getSymbolDisplayInfo, getTsSymbolDisplayInfo, unsafeCastDisplayInfoKindToScriptElementKind} from './display_parts';\n import {filterAliasImports} from './utils';\n \n type PropertyExpressionCompletionBuilder =\n     CompletionBuilder<PropertyRead|PropertyWrite|MethodCall|EmptyExpr|SafePropertyRead|\n-                      SafeMethodCall>;\n+                      SafeMethodCall|TmplAstBoundEvent>;\n+\n+type ElementAttributeCompletionBuilder =\n+    CompletionBuilder<TmplAstElement|TmplAstBoundAttribute|TmplAstTextAttribute|TmplAstBoundEvent>;\n \n \n export enum CompletionNodeContext {\n   None,\n   ElementTag,\n   ElementAttributeKey,\n   ElementAttributeValue,\n+  EventValue,\n }\n \n /**\n@@ -57,6 +63,8 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n       return this.getPropertyExpressionCompletion(options);\n     } else if (this.isElementTagCompletion()) {\n       return this.getElementTagCompletion();\n+    } else if (this.isElementAttributeCompletion()) {\n+      return this.getElementAttributeCompletions();\n     } else {\n       return undefined;\n     }\n@@ -72,8 +80,8 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n       return this.getPropertyExpressionCompletionDetails(entryName, formatOptions, preferences);\n     } else if (this.isElementTagCompletion()) {\n       return this.getElementTagCompletionDetails(entryName);\n-    } else {\n-      return undefined;\n+    } else if (this.isElementAttributeCompletion()) {\n+      return this.getElementAttributeCompletionDetails(entryName);\n     }\n   }\n \n@@ -85,6 +93,8 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n       return this.getPropertyExpressionCompletionSymbol(name);\n     } else if (this.isElementTagCompletion()) {\n       return this.getElementTagCompletionSymbol(name);\n+    } else if (this.isElementAttributeCompletion()) {\n+      return this.getElementAttributeCompletionSymbol(name);\n     } else {\n       return undefined;\n     }\n@@ -102,7 +112,8 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n     return this.node instanceof PropertyRead || this.node instanceof MethodCall ||\n         this.node instanceof SafePropertyRead || this.node instanceof SafeMethodCall ||\n         this.node instanceof PropertyWrite || this.node instanceof EmptyExpr ||\n-        isBrokenEmptyBoundEventExpression(this.node, this.nodeParent);\n+        // BoundEvent nodes only count as property completions if in an EventValue context.\n+        (this.node instanceof BoundEvent && this.nodeContext === CompletionNodeContext.EventValue);\n   }\n \n   /**\n@@ -112,8 +123,7 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n       this: PropertyExpressionCompletionBuilder,\n       options: ts.GetCompletionsAtPositionOptions|\n       undefined): ts.WithMetadata<ts.CompletionInfo>|undefined {\n-    if (this.node instanceof EmptyExpr ||\n-        isBrokenEmptyBoundEventExpression(this.node, this.nodeParent) ||\n+    if (this.node instanceof EmptyExpr || this.node instanceof BoundEvent ||\n         this.node.receiver instanceof ImplicitReceiver) {\n       return this.getGlobalPropertyExpressionCompletion(options);\n     } else {\n@@ -128,7 +138,7 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n         return undefined;\n       }\n \n-      const replacementSpan = makeReplacementSpan(this.node);\n+      const replacementSpan = makeReplacementSpanFromAst(this.node);\n \n       let ngResults: ts.CompletionEntry[] = [];\n       for (const result of tsResults.entries) {\n@@ -152,8 +162,7 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n       formatOptions: ts.FormatCodeOptions|ts.FormatCodeSettings|undefined,\n       preferences: ts.UserPreferences|undefined): ts.CompletionEntryDetails|undefined {\n     let details: ts.CompletionEntryDetails|undefined = undefined;\n-    if (this.node instanceof EmptyExpr ||\n-        isBrokenEmptyBoundEventExpression(this.node, this.nodeParent) ||\n+    if (this.node instanceof EmptyExpr || this.node instanceof BoundEvent ||\n         this.node.receiver instanceof ImplicitReceiver) {\n       details =\n           this.getGlobalPropertyExpressionCompletionDetails(entryName, formatOptions, preferences);\n@@ -179,7 +188,7 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n   private getPropertyExpressionCompletionSymbol(\n       this: PropertyExpressionCompletionBuilder, name: string): ts.Symbol|undefined {\n     if (this.node instanceof EmptyExpr || this.node instanceof LiteralPrimitive ||\n-        this.node.receiver instanceof ImplicitReceiver) {\n+        this.node instanceof BoundEvent || this.node.receiver instanceof ImplicitReceiver) {\n       return this.getGlobalPropertyExpressionCompletionSymbol(name);\n     } else {\n       const location = this.compiler.getTemplateTypeChecker().getExpressionCompletionLocation(\n@@ -209,8 +218,9 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n \n     let replacementSpan: ts.TextSpan|undefined = undefined;\n     // Non-empty nodes get replaced with the completion.\n-    if (!(this.node instanceof EmptyExpr || this.node instanceof LiteralPrimitive)) {\n-      replacementSpan = makeReplacementSpan(this.node);\n+    if (!(this.node instanceof EmptyExpr || this.node instanceof LiteralPrimitive ||\n+          this.node instanceof BoundEvent)) {\n+      replacementSpan = makeReplacementSpanFromAst(this.node);\n     }\n \n     // Merge TS completion results with results from the template scope.\n@@ -401,26 +411,183 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n     return directive?.tsSymbol;\n   }\n \n-  // private getElementAttributeCompletions(this: CompletionBuilder<TmplAstElement>):\n-  //     ts.WithMetadata<ts.CompletionInfo> {}\n+  private isElementAttributeCompletion(): this is ElementAttributeCompletionBuilder {\n+    return this.nodeContext === CompletionNodeContext.ElementAttributeKey &&\n+        (this.node instanceof TmplAstElement || this.node instanceof TmplAstBoundAttribute ||\n+         this.node instanceof TmplAstTextAttribute || this.node instanceof TmplAstBoundEvent);\n+  }\n+\n+  private getElementAttributeCompletions(this: ElementAttributeCompletionBuilder):\n+      ts.WithMetadata<ts.CompletionInfo>|undefined {\n+    let element: TmplAstElement;\n+    if (this.node instanceof TmplAstElement) {\n+      element = this.node;\n+    } else if (this.nodeParent instanceof TmplAstElement) {\n+      element = this.nodeParent;\n+    } else {\n+      // Nothing to do without an element to process.\n+      return undefined;\n+    }\n+\n+    let replacementSpan: ts.TextSpan|undefined = undefined;\n+    if ((this.node instanceof TmplAstBoundAttribute || this.node instanceof TmplAstBoundEvent ||\n+         this.node instanceof TmplAstTextAttribute) &&\n+        this.node.keySpan !== undefined) {\n+      replacementSpan = makeReplacementSpanFromParseSourceSpan(this.node.keySpan);\n+    }\n+\n+    const attrTable = buildAttributeCompletionTable(\n+        this.component, element, this.compiler.getTemplateTypeChecker());\n+\n+    let entries: ts.CompletionEntry[] = [];\n+\n+    for (const completion of attrTable.values()) {\n+      // First, filter out completions that don't make sense for the current node. For example, if\n+      // the user is completing on a property binding `[foo|]`, don't offer output event\n+      // completions.\n+      switch (completion.kind) {\n+        case AttributeCompletionKind.DomAttribute:\n+        case AttributeCompletionKind.DomProperty:\n+          if (this.node instanceof TmplAstBoundEvent) {\n+            continue;\n+          }\n+          break;\n+        case AttributeCompletionKind.DirectiveInput:\n+          if (this.node instanceof TmplAstBoundEvent) {\n+            continue;\n+          }\n+          break;\n+        case AttributeCompletionKind.DirectiveOutput:\n+          if (this.node instanceof TmplAstBoundAttribute) {\n+            continue;\n+          }\n+          break;\n+        case AttributeCompletionKind.DirectiveAttribute:\n+          if (this.node instanceof TmplAstBoundAttribute ||\n+              this.node instanceof TmplAstBoundEvent) {\n+            continue;\n+          }\n+          break;\n+      }\n+\n+      // Is the completion in an attribute context (instead of a property context)?\n+      const isAttributeContext =\n+          (this.node instanceof TmplAstElement || this.node instanceof TmplAstTextAttribute);\n+      addAttributeCompletionEntries(entries, completion, isAttributeContext, replacementSpan);\n+    }\n+\n+    return {\n+      entries,\n+      isGlobalCompletion: false,\n+      isMemberCompletion: false,\n+      isNewIdentifierLocation: true,\n+    };\n+  }\n+\n+  private getElementAttributeCompletionDetails(\n+      this: ElementAttributeCompletionBuilder, entryName: string): ts.CompletionEntryDetails\n+      |undefined {\n+    // `entryName` here may be `foo` or `[foo]`, depending on which suggested completion the user\n+    // chose. Strip off any binding syntax to get the real attribute name.\n+    const {name, kind} = stripBindingSugar(entryName);\n+\n+    let element: TmplAstElement;\n+    if (this.node instanceof TmplAstElement) {\n+      element = this.node;\n+    } else if (this.nodeParent instanceof TmplAstElement) {\n+      element = this.nodeParent;\n+    } else {\n+      // Nothing to do without an element to process.\n+      return undefined;\n+    }\n+\n+    const attrTable = buildAttributeCompletionTable(\n+        this.component, element, this.compiler.getTemplateTypeChecker());\n+\n+    if (!attrTable.has(name)) {\n+      return undefined;\n+    }\n+\n+    const completion = attrTable.get(name)!;\n+    let displayParts: ts.SymbolDisplayPart[];\n+    let documentation: ts.SymbolDisplayPart[]|undefined = undefined;\n+    let info: DisplayInfo|null;\n+    switch (completion.kind) {\n+      case AttributeCompletionKind.DomAttribute:\n+      case AttributeCompletionKind.DomProperty:\n+        // TODO(alxhub): ideally we would show the same documentation as quick info here. However,\n+        // since these bindings don't exist in the TCB, there is no straightforward way to retrieve\n+        // a `ts.Symbol` for the field in the TS DOM definition.\n+        displayParts = [];\n+        break;\n+      case AttributeCompletionKind.DirectiveAttribute:\n+        info = getDirectiveDisplayInfo(this.tsLS, completion.directive);\n+        displayParts = info.displayParts;\n+        documentation = info.documentation;\n+        break;\n+      case AttributeCompletionKind.DirectiveInput:\n+      case AttributeCompletionKind.DirectiveOutput:\n+        const propertySymbol = getAttributeCompletionSymbol(completion, this.typeChecker);\n+        if (propertySymbol === null) {\n+          return undefined;\n+        }\n+\n+        info = getTsSymbolDisplayInfo(\n+            this.tsLS, this.typeChecker, propertySymbol,\n+            completion.kind === AttributeCompletionKind.DirectiveInput ? DisplayInfoKind.PROPERTY :\n+                                                                         DisplayInfoKind.EVENT,\n+            completion.directive.tsSymbol.name);\n+        if (info === null) {\n+          return undefined;\n+        }\n+        displayParts = info.displayParts;\n+        documentation = info.documentation;\n+    }\n+\n+    return {\n+      name: entryName,\n+      kind: unsafeCastDisplayInfoKindToScriptElementKind(kind),\n+      kindModifiers: ts.ScriptElementKindModifier.none,\n+      displayParts: [],\n+      documentation,\n+    };\n+  }\n+\n+  private getElementAttributeCompletionSymbol(\n+      this: ElementAttributeCompletionBuilder, attribute: string): ts.Symbol|undefined {\n+    const {name, kind} = stripBindingSugar(attribute);\n+\n+    let element: TmplAstElement;\n+    if (this.node instanceof TmplAstElement) {\n+      element = this.node;\n+    } else if (this.nodeParent instanceof TmplAstElement) {\n+      element = this.nodeParent;\n+    } else {\n+      // Nothing to do without an element to process.\n+      return undefined;\n+    }\n+\n+    const attrTable = buildAttributeCompletionTable(\n+        this.component, element, this.compiler.getTemplateTypeChecker());\n+\n+    if (!attrTable.has(name)) {\n+      return undefined;\n+    }\n+\n+    const completion = attrTable.get(name)!;\n+    return getAttributeCompletionSymbol(completion, this.typeChecker) ?? undefined;\n+  }\n }\n \n-/**\n- * Checks whether the given `node` is (most likely) a synthetic node created by the template parser\n- * for an empty event binding `(event)=\"\"`.\n- *\n- * When parsing such an expression, a synthetic `LiteralPrimitive` node is generated for the\n- * `BoundEvent`'s handler with the literal text value 'ERROR'. Detecting this case is crucial to\n- * supporting completions within empty event bindings.\n- */\n-function isBrokenEmptyBoundEventExpression(\n-    node: TmplAstNode|AST, parent: TmplAstNode|AST|null): node is LiteralPrimitive {\n-  return node instanceof LiteralPrimitive && parent !== null &&\n-      parent instanceof TmplAstBoundEvent && node.value === 'ERROR';\n+function makeReplacementSpanFromParseSourceSpan(span: ParseSourceSpan): ts.TextSpan {\n+  return {\n+    start: span.start.offset,\n+    length: span.end.offset - span.start.offset,\n+  };\n }\n \n-function makeReplacementSpan(node: PropertyRead|PropertyWrite|MethodCall|SafePropertyRead|\n-                             SafeMethodCall): ts.TextSpan {\n+function makeReplacementSpanFromAst(node: PropertyRead|PropertyWrite|MethodCall|SafePropertyRead|\n+                                    SafeMethodCall): ts.TextSpan {\n   return {\n     start: node.nameSpan.start,\n     length: node.nameSpan.end - node.nameSpan.start,\n@@ -438,3 +605,16 @@ function tagCompletionKind(directive: DirectiveInScope|null): ts.ScriptElementKi\n   }\n   return unsafeCastDisplayInfoKindToScriptElementKind(kind);\n }\n+\n+const BINDING_SUGAR = /[\\[\\(\\)\\]]/g;\n+\n+function stripBindingSugar(binding: string): {name: string, kind: DisplayInfoKind} {\n+  const name = binding.replace(BINDING_SUGAR, '');\n+  if (binding.startsWith('[')) {\n+    return {name, kind: DisplayInfoKind.PROPERTY};\n+  } else if (binding.startsWith('(')) {\n+    return {name, kind: DisplayInfoKind.EVENT};\n+  } else {\n+    return {name, kind: DisplayInfoKind.ATTRIBUTE};\n+  }\n+}"
        },
        {
            "sha": "fefda80e9c77a77930c139258d8914950df88598",
            "filename": "packages/language-service/ivy/display_parts.ts",
            "status": "modified",
            "additions": 27,
            "deletions": 1,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/66378ed0efc4fe344c343232a69d2142fdf622d5/packages%2Flanguage-service%2Fivy%2Fdisplay_parts.ts",
            "raw_url": "https://github.com/angular/angular/raw/66378ed0efc4fe344c343232a69d2142fdf622d5/packages%2Flanguage-service%2Fivy%2Fdisplay_parts.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fdisplay_parts.ts?ref=66378ed0efc4fe344c343232a69d2142fdf622d5",
            "patch": "@@ -22,6 +22,7 @@ export const SYMBOL_TEXT = ts.SymbolDisplayPartKind[ts.SymbolDisplayPartKind.tex\n  * Label for various kinds of Angular entities for TS display info.\n  */\n export enum DisplayInfoKind {\n+  ATTRIBUTE = 'attribute',\n   COMPONENT = 'component',\n   DIRECTIVE = 'directive',\n   EVENT = 'event',\n@@ -148,4 +149,29 @@ export function getDirectiveDisplayInfo(\n     displayParts,\n     documentation: res.documentation,\n   };\n-}\n\\ No newline at end of file\n+}\n+\n+export function getTsSymbolDisplayInfo(\n+    tsLS: ts.LanguageService, checker: ts.TypeChecker, symbol: ts.Symbol, kind: DisplayInfoKind,\n+    ownerName: string|null): DisplayInfo|null {\n+  const decl = symbol.valueDeclaration;\n+  if (decl === undefined || (!ts.isPropertyDeclaration(decl) && !ts.isMethodDeclaration(decl)) ||\n+      !ts.isIdentifier(decl.name)) {\n+    return null;\n+  }\n+  const res = tsLS.getQuickInfoAtPosition(decl.getSourceFile().fileName, decl.name.getStart());\n+  if (res === undefined) {\n+    return {kind, displayParts: [], documentation: []};\n+  }\n+\n+  const type = checker.getDeclaredTypeOfSymbol(symbol);\n+  const typeString = checker.typeToString(type);\n+\n+  const displayParts = createDisplayParts(symbol.name, kind, ownerName ?? undefined, typeString);\n+\n+  return {\n+    kind,\n+    displayParts,\n+    documentation: res.documentation,\n+  };\n+}"
        },
        {
            "sha": "2a6903bf659e88cb40fc22445b879fcbe100664a",
            "filename": "packages/language-service/ivy/language_service.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/66378ed0efc4fe344c343232a69d2142fdf622d5/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "raw_url": "https://github.com/angular/angular/raw/66378ed0efc4fe344c343232a69d2142fdf622d5/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts?ref=66378ed0efc4fe344c343232a69d2142fdf622d5",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, TmplAstNode} from '@angular/compiler';\n+import {AST, TmplAstBoundEvent, TmplAstNode} from '@angular/compiler';\n import {CompilerOptions, ConfigurationHost, readConfiguration} from '@angular/compiler-cli';\n import {absoluteFromSourceFile, AbsoluteFsPath} from '@angular/compiler-cli/src/ngtsc/file_system';\n import {TypeCheckShimGenerator} from '@angular/compiler-cli/src/ngtsc/typecheck';\n@@ -265,6 +265,14 @@ function nodeContextFromTarget(target: TargetNode): CompletionNodeContext {\n     case TargetNodeKind.ElementInBodyContext:\n       // Completions in element bodies are for new attributes.\n       return CompletionNodeContext.ElementAttributeKey;\n+    case TargetNodeKind.AttributeInKeyContext:\n+      return CompletionNodeContext.ElementAttributeKey;\n+    case TargetNodeKind.AttributeInValueContext:\n+      if (target.node instanceof TmplAstBoundEvent) {\n+        return CompletionNodeContext.EventValue;\n+      } else {\n+        return CompletionNodeContext.None;\n+      }\n     default:\n       // No special context is available.\n       return CompletionNodeContext.None;"
        },
        {
            "sha": "85860c5b0faf47a9674357b60db7ba489b7bd5dc",
            "filename": "packages/language-service/ivy/template_target.ts",
            "status": "modified",
            "additions": 49,
            "deletions": 2,
            "changes": 51,
            "blob_url": "https://github.com/angular/angular/blob/66378ed0efc4fe344c343232a69d2142fdf622d5/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "raw_url": "https://github.com/angular/angular/raw/66378ed0efc4fe344c343232a69d2142fdf622d5/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts?ref=66378ed0efc4fe344c343232a69d2142fdf622d5",
            "patch": "@@ -6,6 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n+import {TmplAstBoundEvent} from '@angular/compiler';\n import * as e from '@angular/compiler/src/expression_parser/ast';  // e for expression AST\n import * as t from '@angular/compiler/src/render3/r3_ast';         // t for template AST\n \n@@ -45,7 +46,8 @@ export interface TemplateTarget {\n  * as well as a body, and a given position definitively points to one or the other. `TargetNode`\n  * captures the node itself, as well as this additional contextual disambiguation.\n  */\n-export type TargetNode = RawExpression|RawTemplateNode|ElementInBodyContext|ElementInTagContext;\n+export type TargetNode = RawExpression|RawTemplateNode|ElementInBodyContext|ElementInTagContext|\n+    AttributeInKeyContext|AttributeInValueContext;\n \n /**\n  * Differentiates the various kinds of `TargetNode`s.\n@@ -55,6 +57,8 @@ export enum TargetNodeKind {\n   RawTemplateNode,\n   ElementInTagContext,\n   ElementInBodyContext,\n+  AttributeInKeyContext,\n+  AttributeInValueContext,\n }\n \n /**\n@@ -91,6 +95,16 @@ export interface ElementInBodyContext {\n   node: t.Element|t.Template;\n }\n \n+export interface AttributeInKeyContext {\n+  kind: TargetNodeKind.AttributeInKeyContext;\n+  node: t.TextAttribute|t.BoundAttribute|t.BoundEvent;\n+}\n+\n+export interface AttributeInValueContext {\n+  kind: TargetNodeKind.AttributeInValueContext;\n+  node: t.TextAttribute|t.BoundAttribute|t.BoundEvent;\n+}\n+\n /**\n  * Return the template AST node or expression AST node that most accurately\n  * represents the node at the specified cursor `position`.\n@@ -106,7 +120,10 @@ export function getTargetAtPosition(template: t.Node[], position: number): Templ\n \n   const candidate = path[path.length - 1];\n   if (isTemplateNodeWithKeyAndValue(candidate)) {\n-    const {keySpan, valueSpan} = candidate;\n+    let {keySpan, valueSpan} = candidate;\n+    if (valueSpan === undefined && candidate instanceof TmplAstBoundEvent) {\n+      valueSpan = candidate.handlerSpan;\n+    }\n     const isWithinKeyValue =\n         isWithin(position, keySpan) || (valueSpan && isWithin(position, valueSpan));\n     if (!isWithinKeyValue) {\n@@ -157,6 +174,21 @@ export function getTargetAtPosition(template: t.Node[], position: number): Templ\n         node: candidate,\n       };\n     }\n+  } else if (\n+      (candidate instanceof t.BoundAttribute || candidate instanceof t.BoundEvent ||\n+       candidate instanceof t.TextAttribute) &&\n+      candidate.keySpan !== undefined) {\n+    if (isWithin(position, candidate.keySpan)) {\n+      nodeInContext = {\n+        kind: TargetNodeKind.AttributeInKeyContext,\n+        node: candidate,\n+      };\n+    } else {\n+      nodeInContext = {\n+        kind: TargetNodeKind.AttributeInValueContext,\n+        node: candidate,\n+      };\n+    }\n   } else {\n     nodeInContext = {\n       kind: TargetNodeKind.RawTemplateNode,\n@@ -264,6 +296,21 @@ class TemplateTargetVisitor implements t.Visitor {\n       this.path.pop();  // remove bound event from the AST path\n       return;\n     }\n+\n+    // An event binding with no value (e.g. `(event|)`) parses to a `BoundEvent` with a\n+    // `LiteralPrimitive` handler with value `'ERROR'`, as opposed to a property binding with no\n+    // value which has an `EmptyExpr` as its value. This is a synthetic node created by the binding\n+    // parser, and is not suitable to use for Language Service analysis. Skip it.\n+    //\n+    // TODO(alxhub): modify the parser to generate an `EmptyExpr` instead.\n+    let handler: e.AST = event.handler;\n+    if (handler instanceof e.ASTWithSource) {\n+      handler = handler.ast;\n+    }\n+    if (handler instanceof e.LiteralPrimitive && handler.value === 'ERROR') {\n+      return;\n+    }\n+\n     const visitor = new ExpressionVisitor(this.position);\n     visitor.visit(event.handler, this.path);\n   }"
        },
        {
            "sha": "b2ff0754d797c3c082b1afdf11a8016dfcaef904",
            "filename": "packages/language-service/ivy/test/completions_spec.ts",
            "status": "modified",
            "additions": 219,
            "deletions": 1,
            "changes": 220,
            "blob_url": "https://github.com/angular/angular/blob/66378ed0efc4fe344c343232a69d2142fdf622d5/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/66378ed0efc4fe344c343232a69d2142fdf622d5/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts?ref=66378ed0efc4fe344c343232a69d2142fdf622d5",
            "patch": "@@ -15,6 +15,42 @@ import {LanguageService} from '../language_service';\n \n import {LanguageServiceTestEnvironment} from './env';\n \n+const DIR_WITH_INPUT = {\n+  'Dir': `\n+    @Directive({\n+      selector: '[dir]',\n+      inputs: ['myInput']\n+    })\n+    export class Dir {\n+      myInput!: string;\n+    }\n+  `\n+};\n+\n+const DIR_WITH_OUTPUT = {\n+  'Dir': `\n+    @Directive({\n+      selector: '[dir]',\n+      outputs: ['myOutput']\n+    })\n+    export class Dir {\n+      myInput!: any;\n+    }\n+  `\n+};\n+\n+const DIR_WITH_SELECTED_INPUT = {\n+  'Dir': `\n+    @Directive({\n+      selector: '[myInput]',\n+      inputs: ['myInput']\n+    })\n+    export class Dir {\n+      myInput!: string;\n+    }\n+  `\n+};\n+\n describe('completions', () => {\n   beforeEach(() => {\n     initMockFileSystem('Native');\n@@ -252,6 +288,162 @@ describe('completions', () => {\n           .toEqual('(component) AppModule.OtherCmp');\n       expect(ts.displayPartsToString(details.documentation!)).toEqual('This is another component.');\n     });\n+\n+    describe('element attribute scope', () => {\n+      describe('dom completions', () => {\n+        it('should return completions for a new element attribute', () => {\n+          const {ngLS, fileName, cursor} = setup(`<input ¦>`, '');\n+\n+          const completions =\n+              ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+              ['value']);\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+              ['[value]']);\n+        });\n+\n+        it('should return completions for a partial attribute', () => {\n+          const {ngLS, fileName, cursor, text} = setup(`<input val¦>`, '');\n+\n+          const completions =\n+              ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+              ['value']);\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+              ['[value]']);\n+          expectReplacementText(completions, text, 'val');\n+        });\n+\n+        it('should return completions for a partial property binding', () => {\n+          const {ngLS, fileName, cursor, text} = setup(`<input [val¦]>`, '');\n+\n+          const completions =\n+              ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+          expectDoesNotContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+              ['value']);\n+          expectDoesNotContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+              ['[value]']);\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+              ['value']);\n+          expectReplacementText(completions, text, 'val');\n+        });\n+      });\n+\n+      describe('directive present', () => {\n+        it('should return directive input completions for a new attribute', () => {\n+          const {ngLS, fileName, cursor, text} = setup(`<input dir ¦>`, '', DIR_WITH_INPUT);\n+\n+          const completions =\n+              ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+              ['[myInput]']);\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+              ['myInput']);\n+        });\n+\n+        it('should return directive input completions for a partial attribute', () => {\n+          const {ngLS, fileName, cursor, text} = setup(`<input dir my¦>`, '', DIR_WITH_INPUT);\n+\n+          const completions =\n+              ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+              ['[myInput]']);\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+              ['myInput']);\n+        });\n+\n+        it('should return input completions for a partial property binding', () => {\n+          const {ngLS, fileName, cursor, text} = setup(`<input dir [my¦]>`, '', DIR_WITH_INPUT);\n+\n+          const completions =\n+              ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+              ['myInput']);\n+        });\n+      });\n+\n+      describe('directive not present', () => {\n+        it('should return input completions for a new attribute', () => {\n+          const {ngLS, fileName, cursor, text} = setup(`<input ¦>`, '', DIR_WITH_SELECTED_INPUT);\n+\n+          const completions =\n+              ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+          // This context should generate two completions:\n+          //  * `[myInput]` as a property\n+          //  * `myInput` as an attribute\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+              ['[myInput]']);\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+              ['myInput']);\n+        });\n+      });\n+\n+      it('should return input completions for a partial attribute', () => {\n+        const {ngLS, fileName, cursor, text} = setup(`<input my¦>`, '', DIR_WITH_SELECTED_INPUT);\n+\n+        const completions =\n+            ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+        // This context should generate two completions:\n+        //  * `[myInput]` as a property\n+        //  * `myInput` as an attribute\n+        expectContain(\n+            completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+            ['[myInput]']);\n+        expectContain(\n+            completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ATTRIBUTE),\n+            ['myInput']);\n+        expectReplacementText(completions, text, 'my');\n+      });\n+\n+      it('should return input completions for a partial property binding', () => {\n+        const {ngLS, fileName, cursor, text} = setup(`<input [my¦]>`, '', DIR_WITH_SELECTED_INPUT);\n+\n+        const completions =\n+            ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+        // This context should generate two completions:\n+        //  * `[myInput]` as a property\n+        //  * `myInput` as an attribute\n+        expectContain(\n+            completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PROPERTY),\n+            ['myInput']);\n+        expectReplacementText(completions, text, 'my');\n+      });\n+\n+      it('should return output completions for an empty binding', () => {\n+        const {ngLS, fileName, cursor, text} = setup(`<input dir ¦>`, '', DIR_WITH_OUTPUT);\n+\n+        const completions =\n+            ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+        expectContain(\n+            completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n+            ['(myOutput)']);\n+      });\n+\n+      it('should return output completions for a partial event binding', () => {\n+        const {ngLS, fileName, cursor, text} = setup(`<input dir (my¦)>`, '', DIR_WITH_OUTPUT);\n+\n+        const completions =\n+            ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+        expectContain(\n+            completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.EVENT),\n+            ['myOutput']);\n+        expectReplacementText(completions, text, 'my');\n+      });\n+    });\n   });\n });\n \n@@ -274,6 +466,29 @@ function expectAll(\n   expect(completions!.entries.length).toEqual(Object.keys(contains).length);\n }\n \n+function expectDoesNotContain(\n+    completions: ts.CompletionInfo|undefined, kind: ts.ScriptElementKind|DisplayInfoKind,\n+    names: string[]) {\n+  expect(completions).toBeDefined();\n+  for (const name of names) {\n+    expect(completions!.entries).not.toContain(jasmine.objectContaining({name, kind} as any));\n+  }\n+}\n+\n+function expectReplacementText(\n+    completions: ts.CompletionInfo|undefined, text: string, replacementText: string) {\n+  if (completions === undefined) {\n+    return;\n+  }\n+\n+  for (const entry of completions.entries) {\n+    expect(entry.replacementSpan).toBeDefined();\n+    const completionReplaces =\n+        text.substr(entry.replacementSpan!.start, entry.replacementSpan!.length);\n+    expect(completionReplaces).toBe(replacementText);\n+  }\n+}\n+\n function toText(displayParts?: ts.SymbolDisplayPart[]): string {\n   return (displayParts ?? []).map(p => p.text).join('');\n }\n@@ -287,6 +502,7 @@ function setup(\n   ngLS: LanguageService,\n   cursor: number,\n   nodes: TmplAstNode[],\n+  text: string,\n } {\n   const codePath = absoluteFrom('/test.ts');\n   const templatePath = absoluteFrom('/test.html');\n@@ -323,13 +539,15 @@ function setup(\n       contents: 'Placeholder template',\n     }\n   ]);\n-  const {nodes, cursor} = env.overrideTemplateWithCursor(codePath, 'AppCmp', templateWithCursor);\n+  const {nodes, cursor, text} =\n+      env.overrideTemplateWithCursor(codePath, 'AppCmp', templateWithCursor);\n   return {\n     env,\n     fileName: templatePath,\n     AppCmp: env.getClass(codePath, 'AppCmp'),\n     ngLS: env.ngLS,\n     nodes,\n+    text,\n     cursor,\n   };\n }"
        },
        {
            "sha": "28327990a3613d5e55e9f7e51d21056e89128fd4",
            "filename": "packages/language-service/ivy/utils.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/66378ed0efc4fe344c343232a69d2142fdf622d5/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/66378ed0efc4fe344c343232a69d2142fdf622d5/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Futils.ts?ref=66378ed0efc4fe344c343232a69d2142fdf622d5",
            "patch": "@@ -210,6 +210,13 @@ export function getDirectiveMatchesForElementTag(\n   return difference(allDirectiveMatches, matchesWithoutElement);\n }\n \n+\n+export function makeElementSelector(element: t.Element|t.Template): string {\n+  const attributes = getAttributes(element);\n+  const allAttrs = attributes.map(toAttributeString);\n+  return getNodeName(element) + allAttrs.join('');\n+}\n+\n /**\n  * Given an attribute name, determines which directives match because the attribute is present. We\n  * find which directives are applied because of this attribute by elimination: compare the directive"
        }
    ],
    "stats": {
        "total": 1028,
        "additions": 993,
        "deletions": 35
    }
}