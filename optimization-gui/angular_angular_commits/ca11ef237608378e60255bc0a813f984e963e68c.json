{
    "author": "mhevery",
    "message": "fix(core): Store ICU state in `LView` rather than in `TView` (#39233)\n\nBefore this refactoring/fix the ICU would store the current selected\nindex in `TView`. This is incorrect, since if ICU is in `ngFor` it will\ncause issues in some circumstances. This refactoring properly moves the\nstate to `LView`.\n\ncloses #37021\ncloses #38144\ncloses #38073\n\nPR Close #39233",
    "sha": "ca11ef237608378e60255bc0a813f984e963e68c",
    "files": [
        {
            "sha": "efe573fadd0755f257c930ee713149a7ceeb045f",
            "filename": "goldens/circular-deps/packages.json",
            "status": "modified",
            "additions": 18,
            "deletions": 3,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/goldens%2Fcircular-deps%2Fpackages.json",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/goldens%2Fcircular-deps%2Fpackages.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fcircular-deps%2Fpackages.json?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -223,6 +223,7 @@\n     \"packages/core/src/render3/assert.ts\",\n     \"packages/core/src/render3/interfaces/container.ts\",\n     \"packages/core/src/render3/interfaces/node.ts\",\n+    \"packages/core/src/render3/interfaces/i18n.ts\",\n     \"packages/core/src/render3/interfaces/view.ts\",\n     \"packages/core/src/di/injector.ts\",\n     \"packages/core/src/di/r3_injector.ts\",\n@@ -239,6 +240,7 @@\n     \"packages/core/src/render3/assert.ts\",\n     \"packages/core/src/render3/interfaces/container.ts\",\n     \"packages/core/src/render3/interfaces/node.ts\",\n+    \"packages/core/src/render3/interfaces/i18n.ts\",\n     \"packages/core/src/render3/interfaces/view.ts\",\n     \"packages/core/src/metadata.ts\",\n     \"packages/core/src/di.ts\",\n@@ -262,6 +264,7 @@\n     \"packages/core/src/render3/assert.ts\",\n     \"packages/core/src/render3/interfaces/container.ts\",\n     \"packages/core/src/render3/interfaces/node.ts\",\n+    \"packages/core/src/render3/interfaces/i18n.ts\",\n     \"packages/core/src/render3/interfaces/view.ts\",\n     \"packages/core/src/render3/interfaces/definition.ts\",\n     \"packages/core/src/core.ts\",\n@@ -968,25 +971,37 @@\n   [\n     \"packages/core/src/render3/interfaces/container.ts\",\n     \"packages/core/src/render3/interfaces/node.ts\",\n+    \"packages/core/src/render3/interfaces/i18n.ts\",\n     \"packages/core/src/render3/interfaces/view.ts\"\n   ],\n   [\n     \"packages/core/src/render3/interfaces/definition.ts\",\n     \"packages/core/src/render3/interfaces/node.ts\",\n+    \"packages/core/src/render3/interfaces/i18n.ts\",\n     \"packages/core/src/render3/interfaces/view.ts\"\n   ],\n   [\n     \"packages/core/src/render3/interfaces/definition.ts\",\n     \"packages/core/src/render3/interfaces/view.ts\"\n   ],\n   [\n-    \"packages/core/src/render3/interfaces/node.ts\",\n+    \"packages/core/src/render3/interfaces/i18n.ts\",\n+    \"packages/core/src/render3/interfaces/node.ts\"\n+  ],\n+  [\n+    \"packages/core/src/render3/interfaces/i18n.ts\",\n     \"packages/core/src/render3/interfaces/view.ts\"\n   ],\n   [\n-    \"packages/core/src/render3/interfaces/node.ts\",\n+    \"packages/core/src/render3/interfaces/i18n.ts\",\n     \"packages/core/src/render3/interfaces/view.ts\",\n-    \"packages/core/src/render3/interfaces/query.ts\"\n+    \"packages/core/src/render3/interfaces/node.ts\"\n+  ],\n+  [\n+    \"packages/core/src/render3/interfaces/i18n.ts\",\n+    \"packages/core/src/render3/interfaces/view.ts\",\n+    \"packages/core/src/render3/interfaces/query.ts\",\n+    \"packages/core/src/render3/interfaces/node.ts\"\n   ],\n   [\n     \"packages/core/src/render3/interfaces/query.ts\","
        },
        {
            "sha": "0bbed1ad0209ccc149a34f23fc1e90edede4ebbd",
            "filename": "goldens/public-api/core/core.d.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/goldens%2Fpublic-api%2Fcore%2Fcore.d.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/goldens%2Fpublic-api%2Fcore%2Fcore.d.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fpublic-api%2Fcore%2Fcore.d.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -799,7 +799,7 @@ export declare abstract class Renderer2 {\n     abstract createElement(name: string, namespace?: string | null): any;\n     abstract createText(value: string): any;\n     abstract destroy(): void;\n-    abstract insertBefore(parent: any, newChild: any, refChild: any): void;\n+    abstract insertBefore(parent: any, newChild: any, refChild: any, isMove?: boolean): void;\n     abstract listen(target: 'window' | 'document' | 'body' | any, eventName: string, callback: (event: any) => boolean | void): () => void;\n     abstract nextSibling(node: any): any;\n     abstract parentNode(node: any): any;"
        },
        {
            "sha": "48c80297490c46765cd20a02c8bb837a2d2182a8",
            "filename": "goldens/size-tracking/aio-payloads.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/goldens%2Fsize-tracking%2Faio-payloads.json",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/goldens%2Fsize-tracking%2Faio-payloads.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fsize-tracking%2Faio-payloads.json?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -12,7 +12,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 3037,\n-        \"main-es2015\": 447742,\n+        \"main-es2015\": 448676,\n         \"polyfills-es2015\": 52415\n       }\n     }"
        },
        {
            "sha": "75e91afd4da294251b05803d682f21844de92a15",
            "filename": "goldens/size-tracking/integration-payloads.json",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fsize-tracking%2Fintegration-payloads.json?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -3,7 +3,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 1485,\n-        \"main-es2015\": 140199,\n+        \"main-es2015\": 140899,\n         \"polyfills-es2015\": 36571\n       }\n     }\n@@ -12,7 +12,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 1485,\n-        \"main-es2015\": 16650,\n+        \"main-es2015\": 17092,\n         \"polyfills-es2015\": 36657\n       }\n     }\n@@ -21,7 +21,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 1485,\n-        \"main-es2015\": 146417,\n+        \"main-es2015\": 147242,\n         \"polyfills-es2015\": 36571\n       }\n     }\n@@ -30,7 +30,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 1485,\n-        \"main-es2015\": 135003,\n+        \"main-es2015\": 136096,\n         \"polyfills-es2015\": 37248\n       }\n     }\n@@ -39,7 +39,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 2289,\n-        \"main-es2015\": 241850,\n+        \"main-es2015\": 242460,\n         \"polyfills-es2015\": 36938,\n         \"5-es2015\": 751\n       }\n@@ -49,7 +49,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 2289,\n-        \"main-es2015\": 217827,\n+        \"main-es2015\": 218527,\n         \"polyfills-es2015\": 36723,\n         \"5-es2015\": 781\n       }"
        },
        {
            "sha": "1aeb38b2fc3a11ce93d57210df82441b59263d87",
            "filename": "packages/core/src/render/api.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender%2Fapi.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -158,8 +158,13 @@ export abstract class Renderer2 {\n    * @param parent The parent node.\n    * @param newChild The new child nodes.\n    * @param refChild The existing child node before which `newChild` is inserted.\n+   * @param isMove Optional argument which signifies if the current `insertBefore` is a result of a\n+   *     move. Animation uses this information to trigger move animations. In the past the Animation\n+   *     would always assume that any `insertBefore` is a move. This is not strictly true because\n+   *     with runtime i18n it is possible to invoke `insertBefore` as a result of i18n and it should\n+   *     not trigger an animation move.\n    */\n-  abstract insertBefore(parent: any, newChild: any, refChild: any): void;\n+  abstract insertBefore(parent: any, newChild: any, refChild: any, isMove?: boolean): void;\n   /**\n    * Implement this callback to remove a child node from the host element's DOM.\n    * @param parent The parent node."
        },
        {
            "sha": "3e14a28016f4af66082bd8c32f25a75fa630f802",
            "filename": "packages/core/src/render3/assert.ts",
            "status": "modified",
            "additions": 22,
            "deletions": 9,
            "changes": 31,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fassert.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fassert.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fassert.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -10,6 +10,7 @@ import {assertDefined, assertEqual, assertNumber, throwError} from '../util/asse\n import {getComponentDef, getNgModuleDef} from './definition';\n import {LContainer} from './interfaces/container';\n import {DirectiveDef} from './interfaces/definition';\n+import {TIcu} from './interfaces/i18n';\n import {NodeInjectorOffset} from './interfaces/injector';\n import {TNode} from './interfaces/node';\n import {isLContainer, isLView} from './interfaces/type_checks';\n@@ -25,13 +26,28 @@ export function assertTNodeForLView(tNode: TNode, lView: LView) {\n }\n \n export function assertTNodeForTView(tNode: TNode, tView: TView) {\n-  assertDefined(tNode, 'TNode must be defined');\n+  assertTNode(tNode);\n   tNode.hasOwnProperty('tView_') &&\n       assertEqual(\n           (tNode as any as {tView_: TView}).tView_, tView,\n           'This TNode does not belong to this TView.');\n }\n \n+export function assertTNode(tNode: TNode) {\n+  assertDefined(tNode, 'TNode must be defined');\n+  if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {\n+    throwError('Not of type TNode, got: ' + tNode);\n+  }\n+}\n+\n+\n+export function assertTIcu(tIcu: TIcu) {\n+  assertDefined(tIcu, 'Expected TIcu to be defined');\n+  if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {\n+    throwError('Object is not of TIcu type.');\n+  }\n+}\n+\n export function assertComponentType(\n     actual: any,\n     msg: string = 'Type passed in is not ComponentType, it does not have \\'ɵcmp\\' property.') {\n@@ -106,18 +122,15 @@ export function assertIndexInDeclRange(lView: LView, index: number) {\n export function assertIndexInVarsRange(lView: LView, index: number) {\n   const tView = lView[1];\n   assertBetween(\n-      tView.bindingStartIndex, (tView as any as {i18nStartIndex: number}).i18nStartIndex, index);\n-}\n-\n-export function assertIndexInI18nRange(lView: LView, index: number) {\n-  const tView = lView[1];\n-  assertBetween(\n-      (tView as any as {i18nStartIndex: number}).i18nStartIndex, tView.expandoStartIndex, index);\n+      tView.bindingStartIndex,\n+      (tView as any as {originalExpandoStartIndex: number}).originalExpandoStartIndex, index);\n }\n \n export function assertIndexInExpandoRange(lView: LView, index: number) {\n   const tView = lView[1];\n-  assertBetween(tView.expandoStartIndex, lView.length, index);\n+  assertBetween(\n+      (tView as any as {originalExpandoStartIndex: number}).originalExpandoStartIndex, lView.length,\n+      index);\n }\n \n export function assertBetween(lower: number, upper: number, index: number) {"
        },
        {
            "sha": "9027bb9fef4b389f44d7407b10ab13aa9dfadcec",
            "filename": "packages/core/src/render3/component.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fcomponent.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -163,6 +163,7 @@ export function renderComponent<T>(\n  * @param rNode Render host element.\n  * @param def ComponentDef\n  * @param rootView The parent view where the host node is stored\n+ * @param rendererFactory Factory to be used for creating child renderers.\n  * @param hostRenderer The current renderer\n  * @param sanitizer The sanitizer, if provided\n  *\n@@ -174,7 +175,10 @@ export function createRootComponentView(\n   const tView = rootView[TVIEW];\n   ngDevMode && assertIndexInRange(rootView, 0 + HEADER_OFFSET);\n   rootView[0 + HEADER_OFFSET] = rNode;\n-  const tNode: TElementNode = getOrCreateTNode(tView, 0, TNodeType.Element, null, null);\n+  // '#host' is added here as we don't know the real host DOM name (we don't want to read it) and at\n+  // the same time we want to communicate the the debug `TNode` that this is a special `TNode`\n+  // representing a host element.\n+  const tNode = getOrCreateTNode(tView, 0, TNodeType.Element, '#host', null);\n   const mergedAttrs = tNode.mergedAttrs = def.hostAttrs;\n   if (mergedAttrs !== null) {\n     computeStaticStyling(tNode, mergedAttrs, true);"
        },
        {
            "sha": "9aac1aacd01f546e5b7bee500044385185966c9d",
            "filename": "packages/core/src/render3/component_ref.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fcomponent_ref.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fcomponent_ref.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fcomponent_ref.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -23,13 +23,13 @@ import {assertComponentType} from './assert';\n import {createRootComponent, createRootComponentView, createRootContext, LifecycleHooksFeature} from './component';\n import {getComponentDef} from './definition';\n import {NodeInjector} from './di';\n-import {createLView, createTView, elementCreate, locateHostElement, renderView} from './instructions/shared';\n+import {createLView, createTView, locateHostElement, renderView} from './instructions/shared';\n import {ComponentDef} from './interfaces/definition';\n import {TContainerNode, TElementContainerNode, TElementNode, TNode} from './interfaces/node';\n import {domRendererFactory3, RendererFactory3, RNode} from './interfaces/renderer';\n import {LView, LViewFlags, TViewType} from './interfaces/view';\n import {MATH_ML_NAMESPACE, SVG_NAMESPACE} from './namespaces';\n-import {writeDirectClass} from './node_manipulation';\n+import {createElementNode, writeDirectClass} from './node_manipulation';\n import {extractAttrsAndClassesFromSelector, stringifyCSSSelectorList} from './node_selector_matcher';\n import {enterView, leaveView} from './state';\n import {setUpAttributes} from './util/attrs_utils';\n@@ -147,8 +147,8 @@ export class ComponentFactory<T> extends viewEngine_ComponentFactory<T> {\n     const elementName = this.componentDef.selectors[0][0] as string || 'div';\n     const hostRNode = rootSelectorOrNode ?\n         locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation) :\n-        elementCreate(\n-            elementName, rendererFactory.createRenderer(null, this.componentDef),\n+        createElementNode(\n+            rendererFactory.createRenderer(null, this.componentDef), elementName,\n             getNamespace(elementName));\n \n     const rootFlags = this.componentDef.onPush ? LViewFlags.Dirty | LViewFlags.IsRoot :"
        },
        {
            "sha": "fe28f11f06a7348199dc9e3ac62fd3a2b7d2fd47",
            "filename": "packages/core/src/render3/context_discovery.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 5,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fcontext_discovery.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fcontext_discovery.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fcontext_discovery.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -204,11 +204,7 @@ function findViaNativeElement(lView: LView, target: RElement): number {\n  * Locates the next tNode (child, sibling or parent).\n  */\n function traverseNextElement(tNode: TNode): TNode|null {\n-  if (tNode.child && tNode.child.parent === tNode) {\n-    // FIXME(misko): checking if `tNode.child.parent === tNode` should not be necessary\n-    // We have added it here because i18n creates TNode's which are not valid, so this is a work\n-    // around. The i18n code will be refactored in #39003 and once it lands this extra check can be\n-    // deleted.\n+  if (tNode.child) {\n     return tNode.child;\n   } else if (tNode.next) {\n     return tNode.next;"
        },
        {
            "sha": "05669f0dd5ec9e5882c8c8d407ebfe48561dc945",
            "filename": "packages/core/src/render3/i18n/i18n.md",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n.md",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n.md?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -115,10 +115,6 @@ The i18n markers are:\n   - `index`: the index of the `template` instruction, as defined in the template instructions (e.g. `template(index, ...)`).\n   - `block`: the index of the parent sub-template block, in which this child sub-template block was declared.\n \n-- `�!{index}:{block}�/�/!{index}:{block}�`: *Projection block*: Marks the beginning and end of <ng-content> that was embedded in the original translation block.\n-  - `index`: the index of the projection, as defined in the template instructions (e.g. `projection(index, ...)`).\n-  - `block` (*optional*): the index of the parent sub-template block, in which this child sub-template block was declared.\n-\n No other i18n marker format is supported.\n \n The i18n markers in the example above can be interpreted as follows:"
        },
        {
            "sha": "48c38fb4c99a373e50827fd43480ad8ec3bc4e2c",
            "filename": "packages/core/src/render3/i18n/i18n_apply.ts",
            "status": "modified",
            "additions": 252,
            "deletions": 325,
            "changes": 577,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_apply.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_apply.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_apply.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -7,200 +7,256 @@\n  */\n \n import {getPluralCase} from '../../i18n/localization';\n-import {assertDefined, assertEqual, assertIndexInRange} from '../../util/assert';\n+import {assertDefined, assertDomNode, assertEqual, assertGreaterThan, assertIndexInRange, throwError} from '../../util/assert';\n+import {assertIndexInExpandoRange, assertTIcu} from '../assert';\n import {attachPatchData} from '../context_discovery';\n-import {elementAttributeInternal, elementPropertyInternal, getOrCreateTNode, textBindingInternal} from '../instructions/shared';\n-import {LContainer, NATIVE} from '../interfaces/container';\n-import {COMMENT_MARKER, ELEMENT_MARKER, I18nMutateOpCode, I18nMutateOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, IcuType, TI18n, TIcu} from '../interfaces/i18n';\n-import {TElementNode, TIcuContainerNode, TNode, TNodeFlags, TNodeType, TProjectionNode} from '../interfaces/node';\n-import {RComment, RElement, RText} from '../interfaces/renderer';\n+import {elementPropertyInternal, setElementAttribute, textBindingInternal} from '../instructions/shared';\n+import {COMMENT_MARKER, ELEMENT_MARKER, getCurrentICUCaseIndex, getParentFromI18nMutateOpCode, getRefFromI18nMutateOpCode, I18nCreateOpCode, I18nCreateOpCodes, I18nMutateOpCode, I18nMutateOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, IcuType, TI18n, TIcu} from '../interfaces/i18n';\n+import {TNode} from '../interfaces/node';\n+import {RElement, RNode, RText} from '../interfaces/renderer';\n import {SanitizerFn} from '../interfaces/sanitization';\n-import {isLContainer} from '../interfaces/type_checks';\n-import {HEADER_OFFSET, LView, RENDERER, T_HOST, TView} from '../interfaces/view';\n-import {appendChild, applyProjection, createTextNode, nativeRemoveNode} from '../node_manipulation';\n-import {getBindingIndex, getCurrentTNode, getLView, getTView, setCurrentTNode, setCurrentTNodeAsNotParent} from '../state';\n+import {HEADER_OFFSET, LView, RENDERER, TView} from '../interfaces/view';\n+import {createCommentNode, createElementNode, createTextNode, nativeInsertBefore, nativeParentNode, nativeRemoveNode, updateTextNode} from '../node_manipulation';\n+import {getBindingIndex} from '../state';\n import {renderStringify} from '../util/misc_utils';\n-import {getNativeByIndex, getNativeByTNode, getTNode, load} from '../util/view_utils';\n-\n+import {getNativeByIndex, unwrapRNode} from '../util/view_utils';\n import {getLocaleId} from './i18n_locale_id';\n+import {getTIcu} from './i18n_util';\n \n \n-const i18nIndexStack: number[] = [];\n-let i18nIndexStackPointer = -1;\n-\n-function popI18nIndex() {\n-  return i18nIndexStack[i18nIndexStackPointer--];\n-}\n-\n-export function pushI18nIndex(index: number) {\n-  i18nIndexStack[++i18nIndexStackPointer] = index;\n-}\n \n+/**\n+ * Keep track of which input bindings in `ɵɵi18nExp` have changed.\n+ *\n+ * This is used to efficiently update expressions in i18n only when the corresponding input has\n+ * changed.\n+ *\n+ * 1) Each bit represents which of the `ɵɵi18nExp` has changed.\n+ * 2) There are 32 bits allowed in JS.\n+ * 3) Bit 32 is special as it is shared for all changes past 32. (In other words if you have more\n+ * than 32 `ɵɵi18nExp` then all changes past 32nd `ɵɵi18nExp` will be mapped to same bit. This means\n+ * that we may end up changing more than we need to. But i18n expressions with 32 bindings is rare\n+ * so in practice it should not be an issue.)\n+ */\n let changeMask = 0b0;\n-let shiftsCounter = 0;\n \n-export function setMaskBit(bit: boolean) {\n-  if (bit) {\n-    changeMask = changeMask | (1 << shiftsCounter);\n+/**\n+ * Keeps track of which bit needs to be updated in `changeMask`\n+ *\n+ * This value gets incremented on every call to `ɵɵi18nExp`\n+ */\n+let changeMaskCounter = 0;\n+\n+/**\n+ * Keep track of which input bindings in `ɵɵi18nExp` have changed.\n+ *\n+ * `setMaskBit` gets invoked by each call to `ɵɵi18nExp`.\n+ *\n+ * @param hasChange did `ɵɵi18nExp` detect a change.\n+ */\n+export function setMaskBit(hasChange: boolean) {\n+  if (hasChange) {\n+    changeMask = changeMask | (1 << Math.min(changeMaskCounter, 31));\n   }\n-  shiftsCounter++;\n+  changeMaskCounter++;\n }\n \n export function applyI18n(tView: TView, lView: LView, index: number) {\n-  if (shiftsCounter > 0) {\n+  if (changeMaskCounter > 0) {\n     ngDevMode && assertDefined(tView, `tView should be defined`);\n     const tI18n = tView.data[index + HEADER_OFFSET] as TI18n | I18nUpdateOpCodes;\n-    let updateOpCodes: I18nUpdateOpCodes;\n-    let tIcus: TIcu[]|null = null;\n-    if (Array.isArray(tI18n)) {\n-      updateOpCodes = tI18n as I18nUpdateOpCodes;\n-    } else {\n-      updateOpCodes = (tI18n as TI18n).update;\n-      tIcus = (tI18n as TI18n).icus;\n-    }\n-    const bindingsStartIndex = getBindingIndex() - shiftsCounter - 1;\n-    applyUpdateOpCodes(tView, tIcus, lView, updateOpCodes, bindingsStartIndex, changeMask);\n+    // When `index` points to an `ɵɵi18nAttributes` then we have an array otherwise `TI18n`\n+    const updateOpCodes: I18nUpdateOpCodes =\n+        Array.isArray(tI18n) ? tI18n as I18nUpdateOpCodes : (tI18n as TI18n).update;\n+    const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;\n+    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);\n+  }\n+  // Reset changeMask & maskBit to default for the next update cycle\n+  changeMask = 0b0;\n+  changeMaskCounter = 0;\n+}\n+\n \n-    // Reset changeMask & maskBit to default for the next update cycle\n-    changeMask = 0b0;\n-    shiftsCounter = 0;\n+/**\n+ * Apply `I18nCreateOpCodes` op-codes as stored in `TI18n.create`.\n+ *\n+ * Creates text (and comment) nodes which are internationalized.\n+ *\n+ * @param lView Current lView\n+ * @param createOpCodes Set of op-codes to apply\n+ * @param parentRNode Parent node (so that direct children can be added eagerly) or `null` if it is\n+ *     a root node.\n+ * @param insertInFrontOf DOM node that should be used as an anchor.\n+ */\n+export function applyCreateOpCodes(\n+    lView: LView, createOpCodes: I18nCreateOpCodes, parentRNode: RElement|null,\n+    insertInFrontOf: RElement|null): void {\n+  const renderer = lView[RENDERER];\n+  for (let i = 0; i < createOpCodes.length; i++) {\n+    const opCode = createOpCodes[i++] as any;\n+    const text = createOpCodes[i] as string;\n+    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n+    const appendNow =\n+        (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n+    const index = opCode >>> I18nCreateOpCode.SHIFT;\n+    let rNode = lView[index];\n+    if (rNode === null) {\n+      // We only create new DOM nodes if they don't already exist: If ICU switches case back to a\n+      // case which was already instantiated, no need to create new DOM nodes.\n+      rNode = lView[index] =\n+          isComment ? renderer.createComment(text) : createTextNode(renderer, text);\n+    }\n+    if (appendNow && parentRNode !== null) {\n+      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);\n+    }\n   }\n }\n \n /**\n  * Apply `I18nMutateOpCodes` OpCodes.\n  *\n  * @param tView Current `TView`\n- * @param rootIndex Pointer to the root (parent) tNode for the i18n.\n- * @param createOpCodes OpCodes to process\n+ * @param mutableOpCodes Mutable OpCodes to process\n  * @param lView Current `LView`\n+ * @param anchorRNode place where the i18n node should be inserted.\n  */\n-export function applyCreateOpCodes(\n-    tView: TView, rootindex: number, createOpCodes: I18nMutateOpCodes, lView: LView): number[] {\n+export function applyMutableOpCodes(\n+    tView: TView, mutableOpCodes: I18nMutateOpCodes, lView: LView, anchorRNode: RNode): void {\n+  ngDevMode && assertDomNode(anchorRNode);\n   const renderer = lView[RENDERER];\n-  let currentTNode: TNode|null = null;\n-  let previousTNode: TNode|null = null;\n-  const visitedNodes: number[] = [];\n-  for (let i = 0; i < createOpCodes.length; i++) {\n-    const opCode = createOpCodes[i];\n+  // `rootIdx` represents the node into which all inserts happen.\n+  let rootIdx: number|null = null;\n+  // `rootRNode` represents the real node into which we insert. This can be different from\n+  // `lView[rootIdx]` if we have projection.\n+  //  - null we don't have a parent (as can be the case in when we are inserting into a root of\n+  //    LView which has no parent.)\n+  //  - `RElement` The element representing the root after taking projection into account.\n+  let rootRNode!: RElement|null;\n+  for (let i = 0; i < mutableOpCodes.length; i++) {\n+    const opCode = mutableOpCodes[i];\n     if (typeof opCode == 'string') {\n-      const textRNode = createTextNode(opCode, renderer);\n-      const textNodeIndex = createOpCodes[++i] as number;\n-      ngDevMode && ngDevMode.rendererCreateTextNode++;\n-      previousTNode = currentTNode;\n-      currentTNode =\n-          createDynamicNodeAtIndex(tView, lView, textNodeIndex, TNodeType.Element, textRNode, null);\n-      visitedNodes.push(textNodeIndex);\n-      setCurrentTNodeAsNotParent();\n+      const textNodeIndex = mutableOpCodes[++i] as number;\n+      if (lView[textNodeIndex] === null) {\n+        ngDevMode && ngDevMode.rendererCreateTextNode++;\n+        ngDevMode && assertIndexInRange(lView, textNodeIndex);\n+        lView[textNodeIndex] = createTextNode(renderer, opCode);\n+      }\n     } else if (typeof opCode == 'number') {\n       switch (opCode & I18nMutateOpCode.MASK_INSTRUCTION) {\n         case I18nMutateOpCode.AppendChild:\n-          const destinationNodeIndex = opCode >>> I18nMutateOpCode.SHIFT_PARENT;\n-          let destinationTNode: TNode;\n-          if (destinationNodeIndex === rootindex) {\n-            // If the destination node is `i18nStart`, we don't have a\n-            // top-level node and we should use the host node instead\n-            destinationTNode = lView[T_HOST]!;\n+          const parentIdx = getParentFromI18nMutateOpCode(opCode);\n+          if (rootIdx === null) {\n+            // The first operation should save the `rootIdx` because the first operation\n+            // must insert into the root. (Only subsequent operations can insert into a dynamic\n+            // parent)\n+            rootIdx = parentIdx;\n+            rootRNode = nativeParentNode(renderer, anchorRNode);\n+          }\n+          let insertInFrontOf: RNode|null;\n+          let parentRNode: RElement|null;\n+          if (parentIdx === rootIdx) {\n+            insertInFrontOf = anchorRNode;\n+            parentRNode = rootRNode;\n           } else {\n-            destinationTNode = getTNode(tView, destinationNodeIndex);\n+            insertInFrontOf = null;\n+            parentRNode = unwrapRNode(lView[parentIdx]) as RElement;\n           }\n-          ngDevMode &&\n-              assertDefined(\n-                  currentTNode!,\n-                  `You need to create or select a node before you can insert it into the DOM`);\n-          previousTNode =\n-              appendI18nNode(tView, currentTNode!, destinationTNode, previousTNode, lView);\n-          break;\n-        case I18nMutateOpCode.Select:\n-          // Negative indices indicate that a given TNode is a sibling node, not a parent node\n-          // (see `i18nStartFirstPass` for additional information).\n-          const isParent = opCode >= 0;\n-          // FIXME(misko): This SHIFT_REF looks suspect as it does not have mask.\n-          const nodeIndex = (isParent ? opCode : ~opCode) >>> I18nMutateOpCode.SHIFT_REF;\n-          visitedNodes.push(nodeIndex);\n-          previousTNode = currentTNode;\n-          currentTNode = getTNode(tView, nodeIndex);\n-          if (currentTNode) {\n-            setCurrentTNode(currentTNode, isParent);\n+          // FIXME(misko): Refactor with `processI18nText`\n+          if (parentRNode !== null) {\n+            // This can happen if the `LView` we are adding to is not attached to a parent `LView`.\n+            // In such a case there is no \"root\" we can attach to. This is fine, as we still need to\n+            // create the elements. When the `LView` gets later added to a parent these \"root\" nodes\n+            // get picked up and added.\n+            ngDevMode && assertDomNode(parentRNode);\n+            const refIdx = getRefFromI18nMutateOpCode(opCode);\n+            ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, 'Missing ref');\n+            // `unwrapRNode` is not needed here as all of these point to RNodes as part of the i18n\n+            // which can't have components.\n+            const child = lView[refIdx] as RElement;\n+            ngDevMode && assertDomNode(child);\n+            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);\n+            const tIcu = getTIcu(tView, refIdx);\n+            if (tIcu !== null && typeof tIcu === 'object') {\n+              // If we just added a comment node which has ICU then that ICU may have already been\n+              // rendered and therefore we need to re-add it here.\n+              ngDevMode && assertTIcu(tIcu);\n+              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);\n+              if (caseIndex !== null) {\n+                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);\n+              }\n+            }\n           }\n           break;\n-        case I18nMutateOpCode.ElementEnd:\n-          const elementIndex = opCode >>> I18nMutateOpCode.SHIFT_REF;\n-          previousTNode = currentTNode = getTNode(tView, elementIndex);\n-          setCurrentTNode(currentTNode, false);\n-          break;\n         case I18nMutateOpCode.Attr:\n           const elementNodeIndex = opCode >>> I18nMutateOpCode.SHIFT_REF;\n-          const attrName = createOpCodes[++i] as string;\n-          const attrValue = createOpCodes[++i] as string;\n+          const attrName = mutableOpCodes[++i] as string;\n+          const attrValue = mutableOpCodes[++i] as string;\n           // This code is used for ICU expressions only, since we don't support\n           // directives/components in ICUs, we don't need to worry about inputs here\n-          elementAttributeInternal(\n-              getTNode(tView, elementNodeIndex), lView, attrName, attrValue, null, null);\n+          setElementAttribute(\n+              renderer, getNativeByIndex(elementNodeIndex - HEADER_OFFSET, lView) as RElement, null,\n+              null, attrName, attrValue, null);\n           break;\n         default:\n           throw new Error(`Unable to determine the type of mutate operation for \"${opCode}\"`);\n       }\n     } else {\n       switch (opCode) {\n         case COMMENT_MARKER:\n-          const commentValue = createOpCodes[++i] as string;\n-          const commentNodeIndex = createOpCodes[++i] as number;\n-          ngDevMode &&\n-              assertEqual(\n-                  typeof commentValue, 'string',\n-                  `Expected \"${commentValue}\" to be a comment node value`);\n-          const commentRNode = renderer.createComment(commentValue);\n-          ngDevMode && ngDevMode.rendererCreateComment++;\n-          previousTNode = currentTNode;\n-          currentTNode = createDynamicNodeAtIndex(\n-              tView, lView, commentNodeIndex, TNodeType.IcuContainer, commentRNode, null);\n-          visitedNodes.push(commentNodeIndex);\n-          attachPatchData(commentRNode, lView);\n-          // We will add the case nodes later, during the update phase\n-          setCurrentTNodeAsNotParent();\n+          const commentValue = mutableOpCodes[++i] as string;\n+          const commentNodeIndex = mutableOpCodes[++i] as number;\n+          if (lView[commentNodeIndex] === null) {\n+            ngDevMode &&\n+                assertEqual(\n+                    typeof commentValue, 'string',\n+                    `Expected \"${commentValue}\" to be a comment node value`);\n+            ngDevMode && ngDevMode.rendererCreateComment++;\n+            ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);\n+            const commentRNode = lView[commentNodeIndex] =\n+                createCommentNode(renderer, commentValue);\n+            // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n+            attachPatchData(commentRNode, lView);\n+          }\n           break;\n         case ELEMENT_MARKER:\n-          const tagNameValue = createOpCodes[++i] as string;\n-          const elementNodeIndex = createOpCodes[++i] as number;\n-          ngDevMode &&\n-              assertEqual(\n-                  typeof tagNameValue, 'string',\n-                  `Expected \"${tagNameValue}\" to be an element node tag name`);\n-          const elementRNode = renderer.createElement(tagNameValue);\n-          ngDevMode && ngDevMode.rendererCreateElement++;\n-          previousTNode = currentTNode;\n-          currentTNode = createDynamicNodeAtIndex(\n-              tView, lView, elementNodeIndex, TNodeType.Element, elementRNode, tagNameValue);\n-          visitedNodes.push(elementNodeIndex);\n+          const tagName = mutableOpCodes[++i] as string;\n+          const elementNodeIndex = mutableOpCodes[++i] as number;\n+          if (lView[elementNodeIndex] === null) {\n+            ngDevMode &&\n+                assertEqual(\n+                    typeof tagName, 'string',\n+                    `Expected \"${tagName}\" to be an element node tag name`);\n+\n+            ngDevMode && ngDevMode.rendererCreateElement++;\n+            ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);\n+            const elementRNode = lView[elementNodeIndex] =\n+                createElementNode(renderer, tagName, null);\n+            // FIXME(misko): Attaching patch data is only needed for the root (Also add tests)\n+            attachPatchData(elementRNode, lView);\n+          }\n           break;\n         default:\n-          throw new Error(`Unable to determine the type of mutate operation for \"${opCode}\"`);\n+          ngDevMode &&\n+              throwError(`Unable to determine the type of mutate operation for \"${opCode}\"`);\n       }\n     }\n   }\n-\n-  setCurrentTNodeAsNotParent();\n-\n-  return visitedNodes;\n }\n \n \n /**\n  * Apply `I18nUpdateOpCodes` OpCodes\n  *\n  * @param tView Current `TView`\n- * @param tIcus If ICUs present than this contains them.\n  * @param lView Current `LView`\n  * @param updateOpCodes OpCodes to process\n  * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n  * @param changeMask Each bit corresponds to a `ɵɵi18nExp` (Counting backwards from\n  *     `bindingsStartIndex`)\n  */\n export function applyUpdateOpCodes(\n-    tView: TView, tIcus: TIcu[]|null, lView: LView, updateOpCodes: I18nUpdateOpCodes,\n-    bindingsStartIndex: number, changeMask: number) {\n-  let caseCreated = false;\n+    tView: TView, lView: LView, updateOpCodes: I18nUpdateOpCodes, bindingsStartIndex: number,\n+    changeMask: number) {\n   for (let i = 0; i < updateOpCodes.length; i++) {\n     // bit code to check if we should apply the next update\n     const checkBit = updateOpCodes[i] as number;\n@@ -218,31 +274,54 @@ export function applyUpdateOpCodes(\n             // Negative opCode represent `i18nExp` values offset.\n             value += renderStringify(lView[bindingsStartIndex - opCode]);\n           } else {\n-            const nodeIndex = opCode >>> I18nUpdateOpCode.SHIFT_REF;\n+            const nodeIndex = (opCode >>> I18nUpdateOpCode.SHIFT_REF);\n             switch (opCode & I18nUpdateOpCode.MASK_OPCODE) {\n               case I18nUpdateOpCode.Attr:\n                 const propName = updateOpCodes[++j] as string;\n                 const sanitizeFn = updateOpCodes[++j] as SanitizerFn | null;\n-                elementPropertyInternal(\n-                    tView, getTNode(tView, nodeIndex), lView, propName, value, lView[RENDERER],\n-                    sanitizeFn, false);\n+                const tNodeOrTagName = tView.data[nodeIndex] as TNode | string;\n+                ngDevMode && assertDefined(tNodeOrTagName, 'Expecting TNode or string');\n+                if (typeof tNodeOrTagName === 'string') {\n+                  // IF we don't have a `TNode`, then we are an element in ICU (as ICU content does\n+                  // not have TNode), in which case we know that there are no directives, and hence\n+                  // we use attribute setting.\n+                  setElementAttribute(\n+                      lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value,\n+                      sanitizeFn);\n+                } else {\n+                  elementPropertyInternal(\n+                      tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn,\n+                      false);\n+                }\n                 break;\n               case I18nUpdateOpCode.Text:\n-                textBindingInternal(lView, nodeIndex, value);\n+                const rText = lView[nodeIndex] as RText | null;\n+                rText !== null && updateTextNode(lView[RENDERER], rText, value);\n                 break;\n               case I18nUpdateOpCode.IcuSwitch:\n-                caseCreated =\n-                    applyIcuSwitchCase(tView, tIcus!, updateOpCodes[++j] as number, lView, value);\n+                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex)!, lView, value);\n                 break;\n               case I18nUpdateOpCode.IcuUpdate:\n-                applyIcuUpdateCase(\n-                    tView, tIcus!, updateOpCodes[++j] as number, bindingsStartIndex, lView,\n-                    caseCreated);\n+                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex)!, bindingsStartIndex, lView);\n                 break;\n             }\n           }\n         }\n       }\n+    } else {\n+      const opCode = updateOpCodes[i + 1] as number;\n+      if (opCode > 0 && (opCode & I18nUpdateOpCode.MASK_OPCODE) === I18nUpdateOpCode.IcuUpdate) {\n+        // Special case for the `icuUpdateCase`. It could be that the mask did not match, but\n+        // we still need to execute `icuUpdateCase` because the case has changed recently due to\n+        // previous `icuSwitchCase` instruction. (`icuSwitchCase` and `icuUpdateCase` always come in\n+        // pairs.)\n+        const nodeIndex = (opCode >>> I18nUpdateOpCode.SHIFT_REF);\n+        const tIcu = getTIcu(tView, nodeIndex)!;\n+        const currentIndex = lView[tIcu.currentCaseLViewIndex];\n+        if (currentIndex < 0) {\n+          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);\n+        }\n+      }\n     }\n     i += skipCodes;\n   }\n@@ -252,25 +331,23 @@ export function applyUpdateOpCodes(\n  * Apply OpCodes associated with updating an existing ICU.\n  *\n  * @param tView Current `TView`\n- * @param tIcus ICUs active at this location.\n- * @param tIcuIndex Index into `tIcus` to process.\n+ * @param tIcu Current `TIcu`\n  * @param bindingsStartIndex Location of the first `ɵɵi18nApply`\n  * @param lView Current `LView`\n- * @param changeMask Each bit corresponds to a `ɵɵi18nExp` (Counting backwards from\n- *     `bindingsStartIndex`)\n  */\n-function applyIcuUpdateCase(\n-    tView: TView, tIcus: TIcu[], tIcuIndex: number, bindingsStartIndex: number, lView: LView,\n-    caseCreated: boolean) {\n-  ngDevMode && assertIndexInRange(tIcus, tIcuIndex);\n-  const tIcu = tIcus[tIcuIndex];\n+function applyIcuUpdateCase(tView: TView, tIcu: TIcu, bindingsStartIndex: number, lView: LView) {\n   ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);\n-  const activeCaseIndex = lView[tIcu.currentCaseLViewIndex];\n+  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];\n   if (activeCaseIndex !== null) {\n-    const mask = caseCreated ?\n-        -1 :  // -1 is same as all bits on, which simulates creation since it marks all bits dirty\n-        changeMask;\n-    applyUpdateOpCodes(tView, tIcus, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);\n+    let mask = changeMask;\n+    if (activeCaseIndex < 0) {\n+      // Clear the flag.\n+      // Negative number means that the ICU was freshly created and we need to force the update.\n+      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;\n+      // -1 is same as all bits on, which simulates creation since it marks all bits dirty\n+      mask = -1;\n+    }\n+    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);\n   }\n }\n \n@@ -280,215 +357,65 @@ function applyIcuUpdateCase(\n  * This involves tearing down existing case and than building up a new case.\n  *\n  * @param tView Current `TView`\n- * @param tIcus ICUs active at this location.\n- * @param tICuIndex Index into `tIcus` to process.\n+ * @param tIcu Current `TIcu`\n  * @param lView Current `LView`\n  * @param value Value of the case to update to.\n- * @returns true if a new case was created (needed so that the update executes regardless of the\n- *     bitmask)\n  */\n-function applyIcuSwitchCase(\n-    tView: TView, tIcus: TIcu[], tICuIndex: number, lView: LView, value: string): boolean {\n-  applyIcuSwitchCaseRemove(tView, tIcus, tICuIndex, lView);\n-\n+function applyIcuSwitchCase(tView: TView, tIcu: TIcu, lView: LView, value: string) {\n   // Rebuild a new case for this ICU\n-  let caseCreated = false;\n-  const tIcu = tIcus[tICuIndex];\n   const caseIndex = getCaseIndex(tIcu, value);\n-  lView[tIcu.currentCaseLViewIndex] = caseIndex !== -1 ? caseIndex : null;\n-  if (caseIndex > -1) {\n-    // Add the nodes for the new case\n-    applyCreateOpCodes(\n-        tView, -1,  // -1 means we don't have parent node\n-        tIcu.create[caseIndex], lView);\n-    caseCreated = true;\n+  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n+  if (activeCaseIndex !== caseIndex) {\n+    applyIcuSwitchCaseRemove(tView, tIcu, lView);\n+    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;\n+    if (caseIndex !== null) {\n+      // Add the nodes for the new case\n+      const anchorRNode = lView[tIcu.anchorIdx];\n+      if (anchorRNode) {\n+        ngDevMode && assertDomNode(anchorRNode);\n+        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);\n+      }\n+    }\n   }\n-  return caseCreated;\n }\n \n /**\n- * Apply OpCodes associated with tearing down of DOM.\n+ * Apply OpCodes associated with tearing ICU case.\n  *\n  * This involves tearing down existing case and than building up a new case.\n  *\n  * @param tView Current `TView`\n- * @param tIcus ICUs active at this location.\n- * @param tIcuIndex Index into `tIcus` to process.\n+ * @param tIcu Current `TIcu`\n  * @param lView Current `LView`\n- * @returns true if a new case was created (needed so that the update executes regardless of the\n- *     bitmask)\n  */\n-function applyIcuSwitchCaseRemove(tView: TView, tIcus: TIcu[], tIcuIndex: number, lView: LView) {\n-  ngDevMode && assertIndexInRange(tIcus, tIcuIndex);\n-  const tIcu = tIcus[tIcuIndex];\n-  const activeCaseIndex = lView[tIcu.currentCaseLViewIndex];\n+function applyIcuSwitchCaseRemove(tView: TView, tIcu: TIcu, lView: LView) {\n+  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n   if (activeCaseIndex !== null) {\n     const removeCodes = tIcu.remove[activeCaseIndex];\n     for (let k = 0; k < removeCodes.length; k++) {\n       const removeOpCode = removeCodes[k] as number;\n       const nodeOrIcuIndex = removeOpCode >>> I18nMutateOpCode.SHIFT_REF;\n       switch (removeOpCode & I18nMutateOpCode.MASK_INSTRUCTION) {\n         case I18nMutateOpCode.Remove:\n-          // FIXME(misko): this comment is wrong!\n-          // Remove DOM element, but do *not* mark TNode as detached, since we are\n-          // just switching ICU cases (while keeping the same TNode), so a DOM element\n-          // representing a new ICU case will be re-created.\n-          removeNode(tView, lView, nodeOrIcuIndex, /* markAsDetached */ false);\n+          nativeRemoveNode(\n+              lView[RENDERER], getNativeByIndex(nodeOrIcuIndex - HEADER_OFFSET, lView));\n           break;\n         case I18nMutateOpCode.RemoveNestedIcu:\n-          applyIcuSwitchCaseRemove(tView, tIcus, nodeOrIcuIndex, lView);\n+          applyIcuSwitchCaseRemove(tView, getTIcu(tView, nodeOrIcuIndex)!, lView);\n           break;\n       }\n     }\n   }\n }\n \n-function appendI18nNode(\n-    tView: TView, tNode: TNode, parentTNode: TNode, previousTNode: TNode|null,\n-    lView: LView): TNode {\n-  ngDevMode && ngDevMode.rendererMoveNode++;\n-  const nextNode = tNode.next;\n-  if (!previousTNode) {\n-    previousTNode = parentTNode;\n-  }\n-\n-  // Re-organize node tree to put this node in the correct position.\n-  if (previousTNode === parentTNode && tNode !== parentTNode.child) {\n-    tNode.next = parentTNode.child;\n-    // FIXME(misko): Checking `tNode.parent` is a temporary workaround until we properly\n-    // refactor the i18n code in #38707 and this code will be deleted.\n-    if (tNode.parent === null) {\n-      tView.firstChild = tNode;\n-    } else {\n-      parentTNode.child = tNode;\n-    }\n-  } else if (previousTNode !== parentTNode && tNode !== previousTNode.next) {\n-    tNode.next = previousTNode.next;\n-    previousTNode.next = tNode;\n-  } else {\n-    tNode.next = null;\n-  }\n-\n-  if (parentTNode !== lView[T_HOST]) {\n-    tNode.parent = parentTNode as TElementNode;\n-  }\n-\n-  // If tNode was moved around, we might need to fix a broken link.\n-  let cursor: TNode|null = tNode.next;\n-  while (cursor) {\n-    if (cursor.next === tNode) {\n-      cursor.next = nextNode;\n-    }\n-    cursor = cursor.next;\n-  }\n-\n-  // If the placeholder to append is a projection, we need to move the projected nodes instead\n-  if (tNode.type === TNodeType.Projection) {\n-    applyProjection(tView, lView, tNode as TProjectionNode);\n-    return tNode;\n-  }\n-\n-  appendChild(tView, lView, getNativeByTNode(tNode, lView), tNode);\n-\n-  const slotValue = lView[tNode.index];\n-  if (tNode.type !== TNodeType.Container && isLContainer(slotValue)) {\n-    // Nodes that inject ViewContainerRef also have a comment node that should be moved\n-    appendChild(tView, lView, slotValue[NATIVE], tNode);\n-  }\n-  return tNode;\n-}\n-\n-/**\n- * See `i18nEnd` above.\n- */\n-export function i18nEndFirstPass(tView: TView, lView: LView) {\n-  ngDevMode &&\n-      assertEqual(\n-          getBindingIndex(), tView.bindingStartIndex,\n-          'i18nEnd should be called before any binding');\n-\n-  const rootIndex = popI18nIndex();\n-  const tI18n = tView.data[rootIndex + HEADER_OFFSET] as TI18n;\n-  ngDevMode && assertDefined(tI18n, `You should call i18nStart before i18nEnd`);\n-\n-  // Find the last node that was added before `i18nEnd`\n-  const lastCreatedNode = getCurrentTNode();\n-\n-  // Read the instructions to insert/move/remove DOM elements\n-  const visitedNodes = applyCreateOpCodes(tView, rootIndex, tI18n.create, lView);\n-\n-  // Remove deleted nodes\n-  let index = rootIndex + 1;\n-  while (lastCreatedNode !== null && index <= lastCreatedNode.index - HEADER_OFFSET) {\n-    if (visitedNodes.indexOf(index) === -1) {\n-      removeNode(tView, lView, index, /* markAsDetached */ true);\n-    }\n-    // Check if an element has any local refs and skip them\n-    const tNode = getTNode(tView, index);\n-    if (tNode &&\n-        (tNode.type === TNodeType.Container || tNode.type === TNodeType.Element ||\n-         tNode.type === TNodeType.ElementContainer) &&\n-        tNode.localNames !== null) {\n-      // Divide by 2 to get the number of local refs,\n-      // since they are stored as an array that also includes directive indexes,\n-      // i.e. [\"localRef\", directiveIndex, ...]\n-      index += tNode.localNames.length >> 1;\n-    }\n-    index++;\n-  }\n-}\n-\n-function removeNode(tView: TView, lView: LView, index: number, markAsDetached: boolean) {\n-  const removedPhTNode = getTNode(tView, index);\n-  const removedPhRNode = getNativeByIndex(index, lView);\n-  if (removedPhRNode) {\n-    nativeRemoveNode(lView[RENDERER], removedPhRNode);\n-  }\n-\n-  const slotValue = load(lView, index) as RElement | RComment | LContainer;\n-  if (isLContainer(slotValue)) {\n-    const lContainer = slotValue as LContainer;\n-    if (removedPhTNode.type !== TNodeType.Container) {\n-      nativeRemoveNode(lView[RENDERER], lContainer[NATIVE]);\n-    }\n-  }\n-\n-  if (markAsDetached && removedPhTNode) {\n-    // Define this node as detached to avoid projecting it later\n-    removedPhTNode.flags |= TNodeFlags.isDetached;\n-  }\n-  ngDevMode && ngDevMode.rendererRemoveNode++;\n-}\n-\n-/**\n- * Creates and stores the dynamic TNode, and unhooks it from the tree for now.\n- */\n-function createDynamicNodeAtIndex(\n-    tView: TView, lView: LView, index: number, type: TNodeType, native: RElement|RText|null,\n-    name: string|null): TElementNode|TIcuContainerNode {\n-  const currentTNode = getCurrentTNode();\n-  ngDevMode && assertIndexInRange(lView, index + HEADER_OFFSET);\n-  lView[index + HEADER_OFFSET] = native;\n-  // FIXME(misko): Why does this create A TNode??? I would not expect this to be here.\n-  const tNode = getOrCreateTNode(tView, index, type as any, name, null);\n-\n-  // We are creating a dynamic node, the previous tNode might not be pointing at this node.\n-  // We will link ourselves into the tree later with `appendI18nNode`.\n-  if (currentTNode && currentTNode.next === tNode) {\n-    currentTNode.next = null;\n-  }\n-\n-  return tNode;\n-}\n-\n \n /**\n  * Returns the index of the current case of an ICU expression depending on the main binding value\n  *\n  * @param icuExpression\n  * @param bindingValue The value of the main binding used by this ICU expression\n  */\n-function getCaseIndex(icuExpression: TIcu, bindingValue: string): number {\n+function getCaseIndex(icuExpression: TIcu, bindingValue: string): number|null {\n   let index = icuExpression.cases.indexOf(bindingValue);\n   if (index === -1) {\n     switch (icuExpression.type) {\n@@ -506,5 +433,5 @@ function getCaseIndex(icuExpression: TIcu, bindingValue: string): number {\n       }\n     }\n   }\n-  return index;\n+  return index === -1 ? null : index;\n }"
        },
        {
            "sha": "1c0b6c6fc55806f129e37867e507947186c82cd1",
            "filename": "packages/core/src/render3/i18n/i18n_debug.ts",
            "status": "modified",
            "additions": 36,
            "deletions": 9,
            "changes": 45,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_debug.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_debug.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_debug.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -7,8 +7,38 @@\n  */\n \n import {assertNumber, assertString} from '../../util/assert';\n+import {COMMENT_MARKER, ELEMENT_MARKER, getInstructionFromI18nMutateOpCode, getParentFromI18nMutateOpCode, getRefFromI18nMutateOpCode, I18nCreateOpCode, I18nMutateOpCode, I18nMutateOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes} from '../interfaces/i18n';\n \n-import {COMMENT_MARKER, ELEMENT_MARKER, getInstructionFromI18nMutateOpCode, getParentFromI18nMutateOpCode, getRefFromI18nMutateOpCode, I18nMutateOpCode, I18nMutateOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes} from '../interfaces/i18n';\n+\n+/**\n+ * Converts `I18nCreateOpCodes` array into a human readable format.\n+ *\n+ * This function is attached to the `I18nCreateOpCodes.debug` property if `ngDevMode` is enabled.\n+ * This function provides a human readable view of the opcodes. This is useful when debugging the\n+ * application as well as writing more readable tests.\n+ *\n+ * @param this `I18nCreateOpCodes` if attached as a method.\n+ * @param opcodes `I18nCreateOpCodes` if invoked as a function.\n+ */\n+export function i18nCreateOpCodesToString(\n+    this: I18nUpdateOpCodes|void, opcodes?: I18nUpdateOpCodes): string[] {\n+  const createOpCodes: I18nUpdateOpCodes = opcodes || (Array.isArray(this) ? this : []);\n+  let lines: string[] = [];\n+  for (let i = 0; i < createOpCodes.length; i++) {\n+    const opCode = createOpCodes[i++] as any;\n+    const text = createOpCodes[i] as string;\n+    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n+    const appendNow =\n+        (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n+    const index = opCode >>> I18nCreateOpCode.SHIFT;\n+    lines.push(`lView[${index}] = document.${isComment ? 'createComment' : 'createText'}(${\n+        JSON.stringify(text)});`);\n+    if (appendNow) {\n+      lines.push(`parent.appendChild(lView[${index}]);`);\n+    }\n+  }\n+  return lines;\n+}\n \n /**\n  * Converts `I18nUpdateOpCodes` array into a human readable format.\n@@ -37,9 +67,9 @@ export function i18nUpdateOpCodesToString(\n         const value = sanitizationFn ? `(${sanitizationFn})($$$)` : '$$$';\n         return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value})`;\n       case I18nUpdateOpCode.IcuSwitch:\n-        return `icuSwitchCase(lView[${ref}] as Comment, ${parser.consumeNumber()}, $$$)`;\n+        return `icuSwitchCase(${ref}, $$$)`;\n       case I18nUpdateOpCode.IcuUpdate:\n-        return `icuUpdateCase(lView[${ref}] as Comment, ${parser.consumeNumber()})`;\n+        return `icuUpdateCase(${ref})`;\n     }\n     throw new Error('unexpected OpCode');\n   }\n@@ -57,7 +87,9 @@ export function i18nUpdateOpCodesToString(\n         statement += value;\n       } else if (value < 0) {\n         // Negative numbers are ref indexes\n-        statement += '${lView[' + (0 - value) + ']}';\n+        // Here `i` refers to current binding index. It is to signify that the value is relative,\n+        // rather than absolute.\n+        statement += '${lView[i' + value + ']}';\n       } else {\n         // Positive numbers are operations.\n         const opCodeText = consumeOpCode(value);\n@@ -89,18 +121,13 @@ export function i18nMutateOpCodesToString(\n     const parent = getParentFromI18nMutateOpCode(opCode);\n     const ref = getRefFromI18nMutateOpCode(opCode);\n     switch (getInstructionFromI18nMutateOpCode(opCode)) {\n-      case I18nMutateOpCode.Select:\n-        lastRef = ref;\n-        return '';\n       case I18nMutateOpCode.AppendChild:\n         return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;\n       case I18nMutateOpCode.Remove:\n         return `(lView[${parent}] as Element).remove(lView[${ref}])`;\n       case I18nMutateOpCode.Attr:\n         return `(lView[${ref}] as Element).setAttribute(\"${parser.consumeString()}\", \"${\n             parser.consumeString()}\")`;\n-      case I18nMutateOpCode.ElementEnd:\n-        return `setCurrentTNode(tView.data[${ref}] as TNode)`;\n       case I18nMutateOpCode.RemoveNestedIcu:\n         return `removeNestedICU(${ref})`;\n     }"
        },
        {
            "sha": "fc88f18041b2ee3fc1bf70829a94169a12eb5126",
            "filename": "packages/core/src/render3/i18n/i18n_insert_before_index.ts",
            "status": "added",
            "additions": 86,
            "deletions": 0,
            "changes": 86,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_insert_before_index.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_insert_before_index.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_insert_before_index.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -0,0 +1,86 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {assertEqual} from '../../util/assert';\n+import {TNode, TNodeType} from '../interfaces/node';\n+\n+/**\n+ * Add `tNode` to `previousTNodes` list and update relevant `TNode`s in `previousTNodes` list\n+ * `tNode.insertBeforeIndex`.\n+ *\n+ * Things to keep in mind:\n+ * 1. All i18n text nodes are encoded as `TNodeType.Element` and are created eagerly by the\n+ *    `ɵɵi18nStart` instruction.\n+ * 2. All `TNodeType.Placeholder` `TNodes` are elements which will be created later by\n+ *    `ɵɵelementStart` instruction.\n+ * 3. `ɵɵelementStart` instruction will create `TNode`s in the ascending `TNode.index` order. (So a\n+ *    smaller index `TNode` is guaranteed to be created before a larger one)\n+ *\n+ * We use the above three invariants to determine `TNode.insertBeforeIndex`.\n+ *\n+ * In an ideal world `TNode.insertBeforeIndex` would always be `TNode.next.index`. However,\n+ * this will not work because `TNode.next.index` may be larger than `TNode.index` which means that\n+ * the next node is not yet created and therefore we can't insert in front of it.\n+ *\n+ * Rule1: `TNode.insertBeforeIndex = null` if `TNode.next === null` (Initial condition, as we don't\n+ *        know if there will be further `TNode`s inserted after.)\n+ * Rule2: If `previousTNode` is created after the `tNode` being inserted, then\n+ *        `previousTNode.insertBeforeNode = tNode.index` (So when a new `tNode` is added we check\n+ *        previous to see if we can update its `insertBeforeTNode`)\n+ *\n+ * See `TNode.insertBeforeIndex` for more context.\n+ *\n+ * @param previousTNodes A list of previous TNodes so that we can easily traverse `TNode`s in\n+ *     reverse order. (If `TNode` would have `previous` this would not be necessary.)\n+ * @param newTNode A TNode to add to the `previousTNodes` list.\n+ */\n+export function addTNodeAndUpdateInsertBeforeIndex(previousTNodes: TNode[], newTNode: TNode) {\n+  // Start with Rule1\n+  ngDevMode &&\n+      assertEqual(newTNode.insertBeforeIndex, null, 'We expect that insertBeforeIndex is not set');\n+\n+  previousTNodes.push(newTNode);\n+  if (previousTNodes.length > 1) {\n+    for (let i = previousTNodes.length - 2; i >= 0; i--) {\n+      const existingTNode = previousTNodes[i];\n+      // Text nodes are created eagerly and so they don't need their `indexBeforeIndex` updated.\n+      // It is safe to ignore them.\n+      if (!isI18nText(existingTNode)) {\n+        if (isNewTNodeCreatedBefore(existingTNode, newTNode) &&\n+            getInsertBeforeIndex(existingTNode) === null) {\n+          // If it was created before us in time, (and it does not yet have `insertBeforeIndex`)\n+          // then add the `insertBeforeIndex`.\n+          setInsertBeforeIndex(existingTNode, newTNode.index);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+function isI18nText(tNode: TNode): boolean {\n+  return tNode.type !== TNodeType.Placeholder;\n+}\n+\n+function isNewTNodeCreatedBefore(existingTNode: TNode, newTNode: TNode): boolean {\n+  return isI18nText(newTNode) || existingTNode.index > newTNode.index;\n+}\n+\n+function getInsertBeforeIndex(tNode: TNode): number|null {\n+  const index = tNode.insertBeforeIndex;\n+  return Array.isArray(index) ? index[0] : index;\n+}\n+\n+function setInsertBeforeIndex(tNode: TNode, value: number): void {\n+  const index = tNode.insertBeforeIndex;\n+  if (Array.isArray(index)) {\n+    // Array is stored if we have to insert child nodes. See `TNode.insertBeforeIndex`\n+    index[0] = value;\n+  } else {\n+    tNode.insertBeforeIndex = value;\n+  }\n+}"
        },
        {
            "sha": "79667119a5588642fbc508bf49bd1951140268f2",
            "filename": "packages/core/src/render3/i18n/i18n_parse.ts",
            "status": "modified",
            "additions": 349,
            "deletions": 359,
            "changes": 708,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_parse.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_parse.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_parse.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -11,20 +11,23 @@ import '../../util/ng_i18n_closure_mode';\n import {getTemplateContent, SRCSET_ATTRS, URI_ATTRS, VALID_ATTRS, VALID_ELEMENTS} from '../../sanitization/html_sanitizer';\n import {getInertBodyHelper} from '../../sanitization/inert_body';\n import {_sanitizeUrl, sanitizeSrcset} from '../../sanitization/url_sanitizer';\n-import {addAllToArray} from '../../util/array_utils';\n-import {assertEqual} from '../../util/assert';\n-import {allocExpando, elementAttributeInternal, setInputsForProperty, setNgReflectProperties} from '../instructions/shared';\n+import {assertDefined, assertEqual, assertGreaterThanOrEqual, assertOneOf, assertString} from '../../util/assert';\n+import {CharCode} from '../../util/char_code';\n+import {loadIcuContainerVisitor} from '../instructions/i18n_icu_container_visitor';\n+import {allocExpando, createTNodeAtIndex, elementAttributeInternal, setInputsForProperty, setNgReflectProperties} from '../instructions/shared';\n import {getDocument} from '../interfaces/document';\n-import {COMMENT_MARKER, ELEMENT_MARKER, I18nMutateOpCode, I18nMutateOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, IcuCase, IcuExpression, IcuType, TI18n, TIcu} from '../interfaces/i18n';\n-import {TNodeType} from '../interfaces/node';\n+import {COMMENT_MARKER, ELEMENT_MARKER, ensureIcuContainerVisitorLoaded, I18nCreateOpCode, I18nCreateOpCodes, I18nMutateOpCode, i18nMutateOpCode, I18nMutateOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, IcuExpression, IcuType, TI18n, TIcu} from '../interfaces/i18n';\n+import {TNode, TNodeType} from '../interfaces/node';\n import {RComment, RElement} from '../interfaces/renderer';\n import {SanitizerFn} from '../interfaces/sanitization';\n-import {HEADER_OFFSET, LView, T_HOST, TView} from '../interfaces/view';\n-import {getCurrentTNode, isCurrentTNodeParent} from '../state';\n+import {HEADER_OFFSET, LView, TView} from '../interfaces/view';\n+import {getCurrentParentTNode, getCurrentTNode, setCurrentTNode} from '../state';\n import {attachDebugGetter} from '../util/debug_utils';\n import {getNativeByIndex, getTNode} from '../util/view_utils';\n \n-import {i18nMutateOpCodesToString, i18nUpdateOpCodesToString} from './i18n_debug';\n+import {i18nCreateOpCodesToString, i18nMutateOpCodesToString, i18nUpdateOpCodesToString} from './i18n_debug';\n+import {addTNodeAndUpdateInsertBeforeIndex} from './i18n_insert_before_index';\n+import {createTNodePlaceholder, setTIcu, setTNodeInsertBeforeIndex} from './i18n_util';\n \n \n \n@@ -33,22 +36,9 @@ const ICU_REGEXP = /({\\s*�\\d+:?\\d*�\\s*,\\s*\\S{6}\\s*,[\\s\\S]*})/gi;\n const NESTED_ICU = /�(\\d+)�/;\n const ICU_BLOCK_REGEXP = /^\\s*(�\\d+:?\\d*�)\\s*,\\s*(select|plural)\\s*,/;\n \n-\n-// Count for the number of vars that will be allocated for each i18n block.\n-// It is global because this is used in multiple functions that include loops and recursive calls.\n-// This is reset to 0 when `i18nStartFirstPass` is called.\n-let i18nVarsCount: number;\n-\n-const parentIndexStack: number[] = [];\n-\n const MARKER = `�`;\n const SUBTEMPLATE_REGEXP = /�\\/?\\*(\\d+:\\d+)�/gi;\n const PH_REGEXP = /�(\\/?[#*!]\\d+):?\\d*�/gi;\n-const enum TagType {\n-  ELEMENT = '#',\n-  TEMPLATE = '*',\n-  PROJECTION = '!',\n-}\n \n /**\n  * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\n@@ -62,148 +52,170 @@ function replaceNgsp(value: string): string {\n   return value.replace(NGSP_UNICODE_REGEXP, ' ');\n }\n \n-\n /**\n- * See `i18nStart` above.\n+ * Create dynamic nodes from i18n translation block.\n+ *\n+ * - Text nodes are created synchronously\n+ * - TNodes are linked into tree lazily\n+ *\n+ * @param tView Current `TView`\n+ * @parentTNodeIndex index to the parent TNode of this i18n block\n+ * @param lView Current `LView`\n+ * @param index Index of `ɵɵi18nStart` instruction.\n+ * @param message Message to translate.\n+ * @param subTemplateIndex Index into the sub template of message translation. (ie in case of\n+ *     `ngIf`) (-1 otherwise)\n  */\n-export function i18nStartFirstPass(\n-    lView: LView, tView: TView, index: number, message: string, subTemplateIndex?: number) {\n-  const startIndex = tView.blueprint.length - HEADER_OFFSET;\n-  i18nVarsCount = 0;\n-  const currentTNode = getCurrentTNode()!;\n-  const parentTNode = isCurrentTNodeParent() ? currentTNode : currentTNode && currentTNode.parent;\n-  let parentIndex =\n-      parentTNode && parentTNode !== lView[T_HOST] ? parentTNode.index - HEADER_OFFSET : index;\n-  let parentIndexPointer = 0;\n-  parentIndexStack[parentIndexPointer] = parentIndex;\n-  const createOpCodes: I18nMutateOpCodes = [];\n-  if (ngDevMode) {\n-    attachDebugGetter(createOpCodes, i18nMutateOpCodesToString);\n-  }\n-  // If the previous node wasn't the direct parent then we have a translation without top level\n-  // element and we need to keep a reference of the previous element if there is one. We should also\n-  // keep track whether an element was a parent node or not, so that the logic that consumes\n-  // the generated `I18nMutateOpCode`s can leverage this information to properly set TNode state\n-  // (whether it's a parent or sibling).\n-  if (index > 0 && currentTNode !== parentTNode) {\n-    let previousTNodeIndex = currentTNode.index - HEADER_OFFSET;\n-    // If current TNode is a sibling node, encode it using a negative index. This information is\n-    // required when the `Select` action is processed (see the `readCreateOpCodes` function).\n-    if (!isCurrentTNodeParent()) {\n-      previousTNodeIndex = ~previousTNodeIndex;\n-    }\n-    // Create an OpCode to select the previous TNode\n-    createOpCodes.push(previousTNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Select);\n-  }\n+export function i18nStartFirstCreatePass(\n+    tView: TView, parentTNodeIndex: number, lView: LView, index: number, message: string,\n+    subTemplateIndex: number) {\n+  const rootTNode = getCurrentParentTNode();\n+  const createOpCodes: I18nCreateOpCodes = [];\n   const updateOpCodes: I18nUpdateOpCodes = [];\n+  const existingTNodeStack: TNode[][] = [[]];\n   if (ngDevMode) {\n+    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);\n     attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n   }\n-  const icuExpressions: TIcu[] = [];\n-\n-  if (message === '' && isRootTemplateMessage(subTemplateIndex)) {\n-    // If top level translation is an empty string, do not invoke additional processing\n-    // and just create op codes for empty text node instead.\n-    createOpCodes.push(\n-        message, allocNodeIndex(startIndex),\n-        parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n-  } else {\n-    const templateTranslation = getTranslationForTemplate(message, subTemplateIndex);\n-    const msgParts = replaceNgsp(templateTranslation).split(PH_REGEXP);\n-    for (let i = 0; i < msgParts.length; i++) {\n-      let value = msgParts[i];\n-      if (i & 1) {\n-        // Odd indexes are placeholders (elements and sub-templates)\n-        if (value.charAt(0) === '/') {\n-          // It is a closing tag\n-          if (value.charAt(1) === TagType.ELEMENT) {\n-            const phIndex = parseInt(value.substr(2), 10);\n-            parentIndex = parentIndexStack[--parentIndexPointer];\n-            createOpCodes.push(phIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.ElementEnd);\n+\n+  message = getTranslationForTemplate(message, subTemplateIndex);\n+  const msgParts = replaceNgsp(message).split(PH_REGEXP);\n+  for (let i = 0; i < msgParts.length; i++) {\n+    let value = msgParts[i];\n+    if ((i & 1) === 0) {\n+      // Even indexes are text (including bindings & ICU expressions)\n+      const parts = i18nParseTextIntoPartsAndICU(value);\n+      for (let j = 0; j < parts.length; j++) {\n+        let part = parts[j];\n+        if ((j & 1) === 0) {\n+          // `j` is odd therefore `part` is string\n+          const text = part as string;\n+          ngDevMode && assertString(text, 'Parsed ICU part should be string');\n+          if (text !== '') {\n+            i18nStartFirstCreatePassProcessTextNode(\n+                tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);\n           }\n         } else {\n-          const phIndex = parseInt(value.substr(1), 10);\n-          const isElement = value.charAt(0) === TagType.ELEMENT;\n-          // The value represents a placeholder that we move to the designated index.\n-          // Note: positive indicies indicate that a TNode with a given index should also be marked\n-          // as parent while executing `Select` instruction.\n-          createOpCodes.push(\n-              (isElement ? phIndex : ~phIndex) << I18nMutateOpCode.SHIFT_REF |\n-                  I18nMutateOpCode.Select,\n-              parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n-\n-          if (isElement) {\n-            parentIndexStack[++parentIndexPointer] = parentIndex = phIndex;\n+          // `j` is Even therefor `part` is an `ICUExpression`\n+          const icuExpression: IcuExpression = part as IcuExpression;\n+          // Verify that ICU expression has the right shape. Translations might contain invalid\n+          // constructions (while original messages were correct), so ICU parsing at runtime may\n+          // not succeed (thus `icuExpression` remains a string).\n+          if (ngDevMode && typeof icuExpression !== 'object') {\n+            throw new Error(`Unable to parse ICU expression in \"${message}\" message.`);\n           }\n+          const icuContainerTNode = createTNodeAndAddOpCode(\n+              tView, rootTNode, existingTNodeStack[0], lView, createOpCodes,\n+              ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : '', true);\n+          const icuNodeIndex = icuContainerTNode.index;\n+          ngDevMode &&\n+              assertGreaterThanOrEqual(\n+                  icuNodeIndex, HEADER_OFFSET, 'Index must be in absolute LView offset');\n+          icuStart(tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);\n         }\n+      }\n+    } else {\n+      // Odd indexes are placeholders (elements and sub-templates)\n+      // At this point value is something like: '/#1:2' (orginally coming from '�/#1:2�')\n+      const isClosing = value.charCodeAt(0) === CharCode.SLASH;\n+      const type = value.charCodeAt(isClosing ? 1 : 0);\n+      ngDevMode && assertOneOf(type, CharCode.STAR, CharCode.HASH, CharCode.EXCLAMATION);\n+      const index = HEADER_OFFSET + Number.parseInt(value.substring((isClosing ? 2 : 1)));\n+      if (isClosing) {\n+        existingTNodeStack.shift();\n+        setCurrentTNode(getCurrentParentTNode()!, false);\n       } else {\n-        // Even indexes are text (including bindings & ICU expressions)\n-        const parts = extractParts(value);\n-        for (let j = 0; j < parts.length; j++) {\n-          if (j & 1) {\n-            // Odd indexes are ICU expressions\n-            const icuExpression = parts[j] as IcuExpression;\n-\n-            // Verify that ICU expression has the right shape. Translations might contain invalid\n-            // constructions (while original messages were correct), so ICU parsing at runtime may\n-            // not succeed (thus `icuExpression` remains a string).\n-            if (typeof icuExpression !== 'object') {\n-              throw new Error(\n-                  `Unable to parse ICU expression in \"${templateTranslation}\" message.`);\n-            }\n-\n-            // Create the comment node that will anchor the ICU expression\n-            const icuNodeIndex = allocNodeIndex(startIndex);\n-            createOpCodes.push(\n-                COMMENT_MARKER, ngDevMode ? `ICU ${icuNodeIndex}` : '', icuNodeIndex,\n-                parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n-\n-            // Update codes for the ICU expression\n-            const mask = getBindingMask(icuExpression);\n-            icuStart(icuExpressions, icuExpression, icuNodeIndex, icuNodeIndex);\n-            // Since this is recursive, the last TIcu that was pushed is the one we want\n-            const tIcuIndex = icuExpressions.length - 1;\n-            updateOpCodes.push(\n-                toMaskBit(icuExpression.mainBinding),  // mask of the main binding\n-                3,                                     // skip 3 opCodes if not changed\n-                -1 - icuExpression.mainBinding,\n-                icuNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuSwitch, tIcuIndex,\n-                mask,  // mask of all the bindings of this ICU expression\n-                2,     // skip 2 opCodes if not changed\n-                icuNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuUpdate, tIcuIndex);\n-          } else if (parts[j] !== '') {\n-            const text = parts[j] as string;\n-            // Even indexes are text (including bindings)\n-            const hasBinding = text.match(BINDING_REGEXP);\n-            // Create text nodes\n-            const textNodeIndex = allocNodeIndex(startIndex);\n-            createOpCodes.push(\n-                // If there is a binding, the value will be set during update\n-                hasBinding ? '' : text, textNodeIndex,\n-                parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n-\n-            if (hasBinding) {\n-              addAllToArray(generateBindingUpdateOpCodes(text, textNodeIndex), updateOpCodes);\n-            }\n-          }\n-        }\n+        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index);\n+        existingTNodeStack.unshift([]);\n+        setCurrentTNode(tNode, true);\n       }\n     }\n   }\n \n-  if (i18nVarsCount > 0) {\n-    allocExpando(tView, lView, i18nVarsCount);\n-  }\n-\n-  // NOTE: local var needed to properly assert the type of `TI18n`.\n-  const tI18n: TI18n = {\n-    vars: i18nVarsCount,\n+  tView.data[index + HEADER_OFFSET] = <TI18n>{\n     create: createOpCodes,\n     update: updateOpCodes,\n-    icus: icuExpressions.length ? icuExpressions : null,\n   };\n+}\n+\n+/**\n+ * Allocate space in i18n Range add create OpCode instruction to crete a text or comment node.\n+ *\n+ * @param tView Current `TView` needed to allocate space in i18n range.\n+ * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will be\n+ *     added as part of the `i18nStart` instruction or as part of the `TNode.insertBeforeIndex`.\n+ * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n+ * @param lView Current `LView` needed to allocate space in i18n range.\n+ * @param createOpCodes Array storing `I18nCreateOpCodes` where new opCodes will be added.\n+ * @param text Text to be added when the `Text` or `Comment` node will be created.\n+ * @param isICU true if a `Comment` node for ICU (instead of `Text`) node should be created.\n+ */\n+function createTNodeAndAddOpCode(\n+    tView: TView, rootTNode: TNode|null, existingTNodes: TNode[], lView: LView,\n+    createOpCodes: I18nCreateOpCodes, text: string, isICU: boolean): TNode {\n+  const i18nNodeIdx = allocExpando(tView, lView, 1);\n+  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;\n+  let parentTNode = getCurrentParentTNode();\n+\n+  if (rootTNode === parentTNode) {\n+    // FIXME(misko): A null `parentTNode` should represent when we fall of the `LView` boundry.\n+    // (there is no parent), but in some circumstances (because we are inconsistent about how we set\n+    // `previousOrParentTNode`) it could point to `rootTNode` So this is a work around.\n+    parentTNode = null;\n+  }\n+  if (parentTNode === null) {\n+    // If we don't have a parent that means that we can eagerly add nodes.\n+    // If we have a parent than these nodes can't be added now (as the parent has not been created\n+    // yet) and instead the `parentTNode` is responsible for adding it. See\n+    // `TNode.insertBeforeIndex`\n+    opCode |= I18nCreateOpCode.APPEND_EAGERLY;\n+  }\n+  if (isICU) {\n+    opCode |= I18nCreateOpCode.COMMENT;\n+    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);\n+  }\n+  createOpCodes.push(opCode, text);\n+  const tNode = createTNodeAtIndex(\n+      tView, i18nNodeIdx, isICU ? TNodeType.IcuContainer : TNodeType.Element, null, null);\n+  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);\n+  const tNodeIdx = tNode.index;\n+  setCurrentTNode(tNode, false /* Text nodes are self closing */);\n+  if (parentTNode !== null && rootTNode !== parentTNode) {\n+    // We are a child of deeper node (rather than a direct child of `i18nStart` instruction.)\n+    // We have to make sure to add ourselves to the parent.\n+    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);\n+  }\n+  return tNode;\n+}\n \n-  tView.data[index + HEADER_OFFSET] = tI18n;\n+/**\n+ * Processes text node in i18n block.\n+ *\n+ * Text nodes can have:\n+ * - Create instruction in `createOpCodes` for creating the text node.\n+ * - Allocate spec for text node in i18n range of `LView`\n+ * - If contains binding:\n+ *    - bindings => allocate space in i18n range of `LView` to store the binding value.\n+ *    - populate `updateOpCodes` with update instructions.\n+ *\n+ * @param tView Current `TView`\n+ * @param rootTNode Root `TNode` of the i18n block. This node determines if the new TNode will\n+ *     be added as part of the `i18nStart` instruction or as part of the\n+ *     `TNode.insertBeforeIndex`.\n+ * @param existingTNodes internal state for `addTNodeAndUpdateInsertBeforeIndex`.\n+ * @param createOpCodes Location where the creation OpCodes will be stored.\n+ * @param lView Current `LView`\n+ * @param text The translated text (which may contain binding)\n+ */\n+function i18nStartFirstCreatePassProcessTextNode(\n+    tView: TView, rootTNode: TNode|null, existingTNodes: TNode[], createOpCodes: I18nCreateOpCodes,\n+    updateOpCodes: I18nUpdateOpCodes, lView: LView, text: string): void {\n+  const hasBinding = text.match(BINDING_REGEXP);\n+  const tNode = createTNodeAndAddOpCode(\n+      tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? '' : text, false);\n+  if (hasBinding) {\n+    generateBindingUpdateOpCodes(updateOpCodes, text, tNode.index);\n+  }\n }\n \n /**\n@@ -212,7 +224,7 @@ export function i18nStartFirstPass(\n export function i18nAttributesFirstPass(\n     lView: LView, tView: TView, index: number, values: string[]) {\n   const previousElement = getCurrentTNode()!;\n-  const previousElementIndex = previousElement.index - HEADER_OFFSET;\n+  const previousElementIndex = previousElement.index;\n   const updateOpCodes: I18nUpdateOpCodes = [];\n   if (ngDevMode) {\n     attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n@@ -233,11 +245,10 @@ export function i18nAttributesFirstPass(\n         const hasBinding = !!value.match(BINDING_REGEXP);\n         if (hasBinding) {\n           if (tView.firstCreatePass && tView.data[index + HEADER_OFFSET] === null) {\n-            addAllToArray(\n-                generateBindingUpdateOpCodes(value, previousElementIndex, attrName), updateOpCodes);\n+            generateBindingUpdateOpCodes(updateOpCodes, value, previousElementIndex, attrName);\n           }\n         } else {\n-          const tNode = getTNode(tView, previousElementIndex);\n+          const tNode = getTNode(tView, previousElementIndex - HEADER_OFFSET);\n           // Set attributes for Elements only, for other types (like ElementContainer),\n           // only set inputs below\n           if (tNode.type === TNodeType.Element) {\n@@ -248,7 +259,9 @@ export function i18nAttributesFirstPass(\n           if (dataValue) {\n             setInputsForProperty(tView, lView, dataValue, attrName, value);\n             if (ngDevMode) {\n-              const element = getNativeByIndex(previousElementIndex, lView) as RElement | RComment;\n+              const element =\n+                  getNativeByIndex(previousElementIndex - HEADER_OFFSET, lView) as RElement |\n+                  RComment;\n               setNgReflectProperties(lView, element, tNode.type, dataValue, value);\n             }\n           }\n@@ -266,15 +279,22 @@ export function i18nAttributesFirstPass(\n /**\n  * Generate the OpCodes to update the bindings of a string.\n  *\n+ * @param updateOpCodes Place where the update opcodes will be stored.\n  * @param str The string containing the bindings.\n  * @param destinationNode Index of the destination node which will receive the binding.\n  * @param attrName Name of the attribute, if the string belongs to an attribute.\n  * @param sanitizeFn Sanitization function used to sanitize the string after update, if necessary.\n  */\n export function generateBindingUpdateOpCodes(\n-    str: string, destinationNode: number, attrName?: string,\n-    sanitizeFn: SanitizerFn|null = null): I18nUpdateOpCodes {\n-  const updateOpCodes: I18nUpdateOpCodes = [null, null];  // Alloc space for mask and size\n+    updateOpCodes: I18nUpdateOpCodes, str: string, destinationNode: number, attrName?: string,\n+    sanitizeFn: SanitizerFn|null = null): number {\n+  ngDevMode &&\n+      assertGreaterThanOrEqual(\n+          destinationNode, HEADER_OFFSET, 'Index must be in absolute LView offset');\n+  const maskIndex = updateOpCodes.length;  // Location of mask\n+  const sizeIndex = maskIndex + 1;         // location of size for skipping\n+  updateOpCodes.push(null, null);          // Alloc space for mask and size\n+  const startIndex = maskIndex + 2;        // location of first allocation.\n   if (ngDevMode) {\n     attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n   }\n@@ -301,9 +321,9 @@ export function generateBindingUpdateOpCodes(\n   if (attrName) {\n     updateOpCodes.push(attrName, sanitizeFn);\n   }\n-  updateOpCodes[0] = mask;\n-  updateOpCodes[1] = updateOpCodes.length - 2;\n-  return updateOpCodes;\n+  updateOpCodes[maskIndex] = mask;\n+  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;\n+  return mask;\n }\n \n function getBindingMask(icuExpression: IcuExpression, mask = 0): number {\n@@ -325,26 +345,21 @@ function getBindingMask(icuExpression: IcuExpression, mask = 0): number {\n   return mask;\n }\n \n-function allocNodeIndex(startIndex: number): number {\n-  return startIndex + i18nVarsCount++;\n-}\n-\n \n /**\n  * Convert binding index to mask bit.\n  *\n  * Each index represents a single bit on the bit-mask. Because bit-mask only has 32 bits, we make\n- * the 32nd bit share all masks for all bindings higher than 32. Since it is extremely rare to have\n- * more than 32 bindings this will be hit very rarely. The downside of hitting this corner case is\n- * that we will execute binding code more often than necessary. (penalty of performance)\n+ * the 32nd bit share all masks for all bindings higher than 32. Since it is extremely rare to\n+ * have more than 32 bindings this will be hit very rarely. The downside of hitting this corner\n+ * case is that we will execute binding code more often than necessary. (penalty of performance)\n  */\n function toMaskBit(bindingIndex: number): number {\n   return 1 << Math.min(bindingIndex, 31);\n }\n \n-export function isRootTemplateMessage(subTemplateIndex: number|\n-                                      undefined): subTemplateIndex is undefined {\n-  return subTemplateIndex === undefined;\n+export function isRootTemplateMessage(subTemplateIndex: number): subTemplateIndex is - 1 {\n+  return subTemplateIndex === -1;\n }\n \n \n@@ -385,8 +400,8 @@ function removeInnerTemplateTranslation(message: string): string {\n /**\n  * Extracts a part of a message and removes the rest.\n  *\n- * This method is used for extracting a part of the message associated with a template. A translated\n- * message can span multiple templates.\n+ * This method is used for extracting a part of the message associated with a template. A\n+ * translated message can span multiple templates.\n  *\n  * Example:\n  * ```\n@@ -397,7 +412,7 @@ function removeInnerTemplateTranslation(message: string): string {\n  * @param subTemplateIndex Index of the sub-template to extract. If undefined it returns the\n  * external template and removes all sub-templates.\n  */\n-export function getTranslationForTemplate(message: string, subTemplateIndex?: number) {\n+export function getTranslationForTemplate(message: string, subTemplateIndex: number) {\n   if (isRootTemplateMessage(subTemplateIndex)) {\n     // We want the root template message, ignore all sub-templates\n     return removeInnerTemplateTranslation(message);\n@@ -413,19 +428,27 @@ export function getTranslationForTemplate(message: string, subTemplateIndex?: nu\n /**\n  * Generate the OpCodes for ICU expressions.\n  *\n- * @param tIcus\n  * @param icuExpression\n- * @param startIndex\n- * @param expandoStartIndex\n+ * @param index Index where the anchor is stored and an optional `TIcuContainerNode`\n+ *   - `lView[anchorIdx]` points to a `Comment` node representing the anchor for the ICU.\n+ *   - `tView.data[anchorIdx]` points to the `TIcuContainerNode` if ICU is root (`null` otherwise)\n  */\n export function icuStart(\n-    tIcus: TIcu[], icuExpression: IcuExpression, startIndex: number,\n-    expandoStartIndex: number): void {\n-  const createCodes: I18nMutateOpCodes[] = [];\n-  const removeCodes: I18nMutateOpCodes[] = [];\n-  const updateCodes: I18nUpdateOpCodes[] = [];\n-  const vars = [];\n-  const childIcus: number[][] = [];\n+    tView: TView, lView: LView, updateOpCodes: I18nUpdateOpCodes, parentIdx: number,\n+    icuExpression: IcuExpression, anchorIdx: number) {\n+  ngDevMode && assertDefined(icuExpression, 'ICU expression must be defined');\n+  let bindingMask = 0;\n+  const tIcu: TIcu = {\n+    type: icuExpression.type,\n+    currentCaseLViewIndex: allocExpando(tView, lView, 1),\n+    anchorIdx,\n+    cases: [],\n+    create: [],\n+    remove: [],\n+    update: []\n+  };\n+  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);\n+  setTIcu(tView, anchorIdx, tIcu);\n   const values = icuExpression.values;\n   for (let i = 0; i < values.length; i++) {\n     // Each value is an array of strings & other ICU expressions\n@@ -440,29 +463,14 @@ export function icuStart(\n         valueArr[j] = `<!--�${icuIndex}�-->`;\n       }\n     }\n-    const icuCase: IcuCase =\n-        parseIcuCase(valueArr.join(''), startIndex, nestedIcus, tIcus, expandoStartIndex);\n-    createCodes.push(icuCase.create);\n-    removeCodes.push(icuCase.remove);\n-    updateCodes.push(icuCase.update);\n-    vars.push(icuCase.vars);\n-    childIcus.push(icuCase.childIcus);\n+    bindingMask = parseIcuCase(\n+                      tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i],\n+                      valueArr.join(''), nestedIcus) |\n+        bindingMask;\n+  }\n+  if (bindingMask) {\n+    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);\n   }\n-  const tIcu: TIcu = {\n-    type: icuExpression.type,\n-    vars,\n-    currentCaseLViewIndex: HEADER_OFFSET +\n-        expandoStartIndex  // expandoStartIndex does not include the header so add it.\n-        + 1,               // The first item stored is the `<!--ICU #-->` anchor so skip it.\n-    childIcus,\n-    cases: icuExpression.cases,\n-    create: createCodes,\n-    remove: removeCodes,\n-    update: updateCodes\n-  };\n-  tIcus.push(tIcu);\n-  // Adding the maximum possible of vars needed (based on the cases with the most vars)\n-  i18nVarsCount += Math.max(...vars);\n }\n \n /**\n@@ -487,7 +495,7 @@ export function parseICUBlock(pattern: string): IcuExpression {\n     return '';\n   });\n \n-  const parts = extractParts(pattern) as string[];\n+  const parts = i18nParseTextIntoPartsAndICU(pattern) as string[];\n   // Looking for (key block)+ sequence. One of the keys has to be \"other\".\n   for (let pos = 0; pos < parts.length;) {\n     let key = parts[pos++].trim();\n@@ -499,7 +507,7 @@ export function parseICUBlock(pattern: string): IcuExpression {\n       cases.push(key);\n     }\n \n-    const blocks = extractParts(parts[pos++]) as string[];\n+    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]) as string[];\n     if (cases.length > values.length) {\n       values.push(blocks);\n     }\n@@ -510,51 +518,17 @@ export function parseICUBlock(pattern: string): IcuExpression {\n }\n \n \n-/**\n- * Transforms a string template into an HTML template and a list of instructions used to update\n- * attributes or nodes that contain bindings.\n- *\n- * @param unsafeHtml The string to parse\n- * @param parentIndex\n- * @param nestedIcus\n- * @param tIcus\n- * @param expandoStartIndex\n- */\n-function parseIcuCase(\n-    unsafeHtml: string, parentIndex: number, nestedIcus: IcuExpression[], tIcus: TIcu[],\n-    expandoStartIndex: number): IcuCase {\n-  const inertBodyHelper = getInertBodyHelper(getDocument());\n-  const inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n-  if (!inertBodyElement) {\n-    throw new Error('Unable to generate inert body element');\n-  }\n-  const wrapper = getTemplateContent(inertBodyElement!) as Element || inertBodyElement;\n-  const opCodes: IcuCase = {\n-    vars: 1,  // allocate space for `TIcu.currentCaseLViewIndex`\n-    childIcus: [],\n-    create: [],\n-    remove: [],\n-    update: []\n-  };\n-  if (ngDevMode) {\n-    attachDebugGetter(opCodes.create, i18nMutateOpCodesToString);\n-    attachDebugGetter(opCodes.remove, i18nMutateOpCodesToString);\n-    attachDebugGetter(opCodes.update, i18nUpdateOpCodesToString);\n-  }\n-  parseNodes(wrapper.firstChild, opCodes, parentIndex, nestedIcus, tIcus, expandoStartIndex);\n-  return opCodes;\n-}\n-\n /**\n  * Breaks pattern into strings and top level {...} blocks.\n- * Can be used to break a message into text and ICU expressions, or to break an ICU expression into\n- * keys and cases.\n- * Original code from closure library, modified for Angular.\n+ * Can be used to break a message into text and ICU expressions, or to break an ICU expression\n+ * into keys and cases. Original code from closure library, modified for Angular.\n  *\n  * @param pattern (sub)Pattern to be broken.\n- *\n+ * @returns An `Array<string|IcuExpression>` where:\n+ *   - odd positions: `string` => text between ICU expressions\n+ *   - even positions: `ICUExpression` => ICU expression parsed into `ICUExpression` record.\n  */\n-function extractParts(pattern: string): (string|IcuExpression)[] {\n+export function i18nParseTextIntoPartsAndICU(pattern: string): (string|IcuExpression)[] {\n   if (!pattern) {\n     return [];\n   }\n@@ -602,131 +576,147 @@ function extractParts(pattern: string): (string|IcuExpression)[] {\n /**\n  * Parses a node, its children and its siblings, and generates the mutate & update OpCodes.\n  *\n- * @param currentNode The first node to parse\n- * @param icuCase The data for the ICU expression case that contains those nodes\n- * @param parentIndex Index of the current node's parent\n- * @param nestedIcus Data for the nested ICU expressions that this case contains\n- * @param tIcus Data for all ICU expressions of the current message\n- * @param expandoStartIndex Expando start index for the current ICU expression\n  */\n-export function parseNodes(\n-    currentNode: Node|null, icuCase: IcuCase, parentIndex: number, nestedIcus: IcuExpression[],\n-    tIcus: TIcu[], expandoStartIndex: number) {\n-  if (currentNode) {\n-    const nestedIcusToCreate: [IcuExpression, number][] = [];\n-    while (currentNode) {\n-      const nextNode: Node|null = currentNode.nextSibling;\n-      const newIndex = expandoStartIndex + ++icuCase.vars;\n-      switch (currentNode.nodeType) {\n-        case Node.ELEMENT_NODE:\n-          const element = currentNode as Element;\n-          const tagName = element.tagName.toLowerCase();\n-          if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\n-            // This isn't a valid element, we won't create an element for it\n-            icuCase.vars--;\n-          } else {\n-            icuCase.create.push(\n-                ELEMENT_MARKER, tagName, newIndex,\n-                parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n-            const elAttrs = element.attributes;\n-            for (let i = 0; i < elAttrs.length; i++) {\n-              const attr = elAttrs.item(i)!;\n-              const lowerAttrName = attr.name.toLowerCase();\n-              const hasBinding = !!attr.value.match(BINDING_REGEXP);\n-              // we assume the input string is safe, unless it's using a binding\n-              if (hasBinding) {\n-                if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {\n-                  if (URI_ATTRS[lowerAttrName]) {\n-                    addAllToArray(\n-                        generateBindingUpdateOpCodes(attr.value, newIndex, attr.name, _sanitizeUrl),\n-                        icuCase.update);\n-                  } else if (SRCSET_ATTRS[lowerAttrName]) {\n-                    addAllToArray(\n-                        generateBindingUpdateOpCodes(\n-                            attr.value, newIndex, attr.name, sanitizeSrcset),\n-                        icuCase.update);\n-                  } else {\n-                    addAllToArray(\n-                        generateBindingUpdateOpCodes(attr.value, newIndex, attr.name),\n-                        icuCase.update);\n-                  }\n+export function parseIcuCase(\n+    tView: TView, tIcu: TIcu, lView: LView, updateOpCodes: I18nUpdateOpCodes, parentIdx: number,\n+    caseName: string, unsafeCaseHtml: string, nestedIcus: IcuExpression[]): number {\n+  const create: I18nMutateOpCodes = [];\n+  const remove: I18nMutateOpCodes = [];\n+  const update: I18nUpdateOpCodes = [];\n+  if (ngDevMode) {\n+    attachDebugGetter(create, i18nMutateOpCodesToString);\n+    attachDebugGetter(remove, i18nMutateOpCodesToString);\n+    attachDebugGetter(update, i18nUpdateOpCodesToString);\n+  }\n+  tIcu.cases.push(caseName);\n+  tIcu.create.push(create);\n+  tIcu.remove.push(remove);\n+  tIcu.update.push(update);\n+\n+  const inertBodyHelper = getInertBodyHelper(getDocument());\n+  const inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeCaseHtml);\n+  ngDevMode && assertDefined(inertBodyElement, 'Unable to generate inert body element');\n+  const inertRootNode = getTemplateContent(inertBodyElement!) as Element || inertBodyElement;\n+  if (inertRootNode) {\n+    return walkIcuTree(\n+        tView, tIcu, lView, updateOpCodes, create, remove, update, inertRootNode, parentIdx,\n+        nestedIcus, 0);\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+function walkIcuTree(\n+    tView: TView, tIcu: TIcu, lView: LView, sharedUpdateOpCodes: I18nUpdateOpCodes,\n+    create: I18nMutateOpCodes, remove: I18nMutateOpCodes, update: I18nUpdateOpCodes,\n+    parentNode: Element, parentIdx: number, nestedIcus: IcuExpression[], depth: number): number {\n+  let bindingMask = 0;\n+  let currentNode = parentNode.firstChild;\n+  while (currentNode) {\n+    const newIndex = allocExpando(tView, lView, 1);\n+    switch (currentNode.nodeType) {\n+      case Node.ELEMENT_NODE:\n+        const element = currentNode as Element;\n+        const tagName = element.tagName.toLowerCase();\n+        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {\n+          addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);\n+          tView.data[newIndex] = tagName;\n+          const elAttrs = element.attributes;\n+          for (let i = 0; i < elAttrs.length; i++) {\n+            const attr = elAttrs.item(i)!;\n+            const lowerAttrName = attr.name.toLowerCase();\n+            const hasBinding = !!attr.value.match(BINDING_REGEXP);\n+            // we assume the input string is safe, unless it's using a binding\n+            if (hasBinding) {\n+              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {\n+                if (URI_ATTRS[lowerAttrName]) {\n+                  generateBindingUpdateOpCodes(\n+                      update, attr.value, newIndex, attr.name, _sanitizeUrl);\n+                } else if (SRCSET_ATTRS[lowerAttrName]) {\n+                  generateBindingUpdateOpCodes(\n+                      update, attr.value, newIndex, attr.name, sanitizeSrcset);\n                 } else {\n-                  ngDevMode &&\n-                      console.warn(`WARNING: ignoring unsafe attribute value ${\n-                          lowerAttrName} on element ${tagName} (see http://g.co/ng/security#xss)`);\n+                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name);\n                 }\n               } else {\n-                icuCase.create.push(\n-                    newIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Attr, attr.name,\n-                    attr.value);\n+                ngDevMode && console.warn(` WARNING:\n+      ignoring unsafe attribute value ${lowerAttrName} on element $ {\n+    tagName\n+  } (see http://g.co/ng/security#xss)`);\n               }\n+            } else {\n+              create.push(\n+                  newIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Attr, attr.name,\n+                  attr.value);\n             }\n-            // Parse the children of this node (if any)\n-            parseNodes(\n-                currentNode.firstChild, icuCase, newIndex, nestedIcus, tIcus, expandoStartIndex);\n-            // Remove the parent node after the children\n-            icuCase.remove.push(newIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove);\n-          }\n-          break;\n-        case Node.TEXT_NODE:\n-          const value = currentNode.textContent || '';\n-          const hasBinding = value.match(BINDING_REGEXP);\n-          icuCase.create.push(\n-              hasBinding ? '' : value, newIndex,\n-              parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n-          icuCase.remove.push(newIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove);\n-          if (hasBinding) {\n-            addAllToArray(generateBindingUpdateOpCodes(value, newIndex), icuCase.update);\n           }\n-          break;\n-        case Node.COMMENT_NODE:\n-          // Check if the comment node is a placeholder for a nested ICU\n-          const match = NESTED_ICU.exec(currentNode.textContent || '');\n-          if (match) {\n-            const nestedIcuIndex = parseInt(match[1], 10);\n-            const newLocal = ngDevMode ? `nested ICU ${nestedIcuIndex}` : '';\n-            // Create the comment node that will anchor the ICU expression\n-            icuCase.create.push(\n-                COMMENT_MARKER, newLocal, newIndex,\n-                parentIndex << I18nMutateOpCode.SHIFT_PARENT | I18nMutateOpCode.AppendChild);\n-            const nestedIcu = nestedIcus[nestedIcuIndex];\n-            nestedIcusToCreate.push([nestedIcu, newIndex]);\n-          } else {\n-            // We do not handle any other type of comment\n-            icuCase.vars--;\n-          }\n-          break;\n-        default:\n-          // We do not handle any other type of element\n-          icuCase.vars--;\n-      }\n-      currentNode = nextNode!;\n+          // Parse the children of this node (if any)\n+          bindingMask = walkIcuTree(\n+                            tView, tIcu, lView, sharedUpdateOpCodes, create, remove, update,\n+                            currentNode as Element, newIndex, nestedIcus, depth + 1) |\n+              bindingMask;\n+          addRemoveNode(remove, newIndex, depth);\n+        }\n+        break;\n+      case Node.TEXT_NODE:\n+        const value = currentNode.textContent || '';\n+        const hasBinding = value.match(BINDING_REGEXP);\n+        addCreateNodeAndAppend(create, null, hasBinding ? '' : value, parentIdx, newIndex);\n+        addRemoveNode(remove, newIndex, depth);\n+        if (hasBinding) {\n+          bindingMask = generateBindingUpdateOpCodes(update, value, newIndex) | bindingMask;\n+        }\n+        break;\n+      case Node.COMMENT_NODE:\n+        // Check if the comment node is a placeholder for a nested ICU\n+        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || '');\n+        if (isNestedIcu) {\n+          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);\n+          const icuExpression: IcuExpression = nestedIcus[nestedIcuIndex];\n+          // Create the comment node that will anchor the ICU expression\n+          addCreateNodeAndAppend(\n+              create, COMMENT_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : '', parentIdx,\n+              newIndex);\n+          icuStart(tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);\n+          addRemoveNestedIcu(remove, newIndex, depth);\n+        }\n+        break;\n     }\n+    currentNode = currentNode.nextSibling;\n+  }\n+  return bindingMask;\n+}\n+function addRemoveNode(remove: I18nMutateOpCodes, index: number, depth: number) {\n+  if (depth === 0) {\n+    remove.push(index << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove);\n+  }\n+}\n \n-    for (let i = 0; i < nestedIcusToCreate.length; i++) {\n-      const nestedIcu = nestedIcusToCreate[i][0];\n-      const nestedIcuNodeIndex = nestedIcusToCreate[i][1];\n-      icuStart(tIcus, nestedIcu, nestedIcuNodeIndex, expandoStartIndex + icuCase.vars);\n-      // Since this is recursive, the last TIcu that was pushed is the one we want\n-      const nestTIcuIndex = tIcus.length - 1;\n-      icuCase.vars += Math.max(...tIcus[nestTIcuIndex].vars);\n-      icuCase.childIcus.push(nestTIcuIndex);\n-      const mask = getBindingMask(nestedIcu);\n-      icuCase.update.push(\n-          toMaskBit(nestedIcu.mainBinding),  // mask of the main binding\n-          3,                                 // skip 3 opCodes if not changed\n-          -1 - nestedIcu.mainBinding,\n-          nestedIcuNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuSwitch,\n-          // FIXME(misko): Index should be part of the opcode\n-          nestTIcuIndex,\n-          mask,  // mask of all the bindings of this ICU expression\n-          2,     // skip 2 opCodes if not changed\n-          nestedIcuNodeIndex << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuUpdate,\n-          nestTIcuIndex);\n-      icuCase.remove.push(\n-          nestTIcuIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.RemoveNestedIcu,\n-          // FIXME(misko): Index should be part of the opcode\n-          nestedIcuNodeIndex << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove);\n-    }\n+function addRemoveNestedIcu(remove: I18nMutateOpCodes, index: number, depth: number) {\n+  if (depth === 0) {\n+    remove.push(index << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.RemoveNestedIcu);\n+    remove.push(index << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Remove);\n+  }\n+}\n+\n+function addUpdateIcuSwitch(\n+    update: I18nUpdateOpCodes, icuExpression: IcuExpression, index: number) {\n+  update.push(\n+      toMaskBit(icuExpression.mainBinding), 2, -1 - icuExpression.mainBinding,\n+      index << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuSwitch);\n+}\n+\n+function addUpdateIcuUpdate(update: I18nUpdateOpCodes, bindingMask: number, index: number) {\n+  update.push(bindingMask, 1, index << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuUpdate);\n+}\n+\n+function addCreateNodeAndAppend(\n+    create: I18nMutateOpCodes, marker: null|COMMENT_MARKER|ELEMENT_MARKER, text: string,\n+    appendToParentIdx: number, createAtIdx: number) {\n+  if (marker !== null) {\n+    create.push(marker);\n   }\n+  create.push(\n+      text, createAtIdx,\n+      i18nMutateOpCode(I18nMutateOpCode.AppendChild, appendToParentIdx, createAtIdx));\n }"
        },
        {
            "sha": "e0e7d46ddd4929a4d9d486a483becc16155622a9",
            "filename": "packages/core/src/render3/i18n/i18n_util.ts",
            "status": "added",
            "additions": 107,
            "deletions": 0,
            "changes": 107,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_util.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_util.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fi18n%2Fi18n_util.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -0,0 +1,107 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {assertEqual, throwError} from '../../util/assert';\n+import {assertTIcu, assertTNode} from '../assert';\n+import {createTNodeAtIndex} from '../instructions/shared';\n+import {TIcu} from '../interfaces/i18n';\n+import {TIcuContainerNode, TNode, TNodeType} from '../interfaces/node';\n+import {TView} from '../interfaces/view';\n+import {assertNodeType} from '../node_assert';\n+import {addTNodeAndUpdateInsertBeforeIndex} from './i18n_insert_before_index';\n+\n+\n+/**\n+ * Retrieve `TIcu` at a given `index`.\n+ *\n+ * The `TIcu` can be stored either directly (if it is nested ICU) OR\n+ * it is stored inside tho `TIcuContainer` if it is top level ICU.\n+ *\n+ * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n+ * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n+ * expressed (parent ICU may have selected a case which does not contain it.)\n+ *\n+ * @param tView Current `TView`.\n+ * @param index Index where the value should be read from.\n+ */\n+export function getTIcu(tView: TView, index: number): TIcu|null {\n+  const value = tView.data[index] as null | TIcu | TIcuContainerNode | string;\n+  if (value === null || typeof value === 'string') return null;\n+  if (ngDevMode &&\n+      !(value.hasOwnProperty('tViews') || value.hasOwnProperty('currentCaseLViewIndex'))) {\n+    throwError('We expect to get \\'null\\'|\\'TIcu\\'|\\'TIcuContainer\\', but got: ' + value);\n+  }\n+  // Here the `value.hasOwnProperty('currentCaseLViewIndex')` is a polymorphic read as it can be\n+  // either TIcu or TIcuContainerNode. This is not ideal, but we still think it is OK because it\n+  // will be just two cases which fits into the browser inline cache (inline cache can take up to\n+  // 4)\n+  const tIcu = value.hasOwnProperty('currentCaseLViewIndex') ?\n+      value :\n+      (value as TIcuContainerNode).tagName as any;\n+  ngDevMode && assertTIcu(tIcu);\n+  return tIcu;\n+}\n+\n+/**\n+ * Store `TIcu` at a give `index`.\n+ *\n+ * The `TIcu` can be stored either directly (if it is nested ICU) OR\n+ * it is stored inside tho `TIcuContainer` if it is top level ICU.\n+ *\n+ * The reason for this is that the top level ICU need a `TNode` so that they are part of the render\n+ * tree, but nested ICU's have no TNode, because we don't know ahead of time if the nested ICU is\n+ * expressed (parent ICU may have selected a case which does not contain it.)\n+ *\n+ * @param tView Current `TView`.\n+ * @param index Index where the value should be stored at in `Tview.data`\n+ * @param tIcu The TIcu to store.\n+ */\n+export function setTIcu(tView: TView, index: number, tIcu: TIcu): void {\n+  const tNode = tView.data[index] as null | TIcuContainerNode;\n+  ngDevMode &&\n+      assertEqual(\n+          tNode === null || tNode.hasOwnProperty('tViews'), true,\n+          'We expect to get \\'null\\'|\\'TIcuContainer\\'');\n+  if (tNode === null) {\n+    tView.data[index] = tIcu;\n+  } else {\n+    ngDevMode && assertNodeType(tNode, TNodeType.IcuContainer);\n+    // FIXME(misko): This is a hack which allows us to associate `TI18n` with `TNode`.\n+    // This should be refactored so that one can attach arbitrary data with `TNode`\n+    tNode.tagName = tIcu as any;\n+  }\n+}\n+\n+/**\n+ * Set `TNode.insertBeforeIndex` taking the `Array` into account.\n+ *\n+ * See `TNode.insertBeforeIndex`\n+ */\n+export function setTNodeInsertBeforeIndex(tNode: TNode, index: number) {\n+  ngDevMode && assertTNode(tNode);\n+  let insertBeforeIndex = tNode.insertBeforeIndex;\n+  if (insertBeforeIndex === null) {\n+    insertBeforeIndex = tNode.insertBeforeIndex =\n+        [null!/* may be updated to number later */, index];\n+  } else {\n+    assertEqual(Array.isArray(insertBeforeIndex), true, 'Expecting array here');\n+    (insertBeforeIndex as number[]).push(index);\n+  }\n+}\n+\n+/**\n+ * Create `TNode.type=TNodeType.Placeholder` node.\n+ *\n+ * See `TNodeType.Placeholder` for more information.\n+ */\n+export function createTNodePlaceholder(\n+    tView: TView, previousTNodes: TNode[], index: number): TNode {\n+  const tNode = createTNodeAtIndex(tView, index, TNodeType.Placeholder, null, null);\n+  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);\n+  return tNode;\n+}"
        },
        {
            "sha": "6fc23174f20697c3438f41c7dbb2f9d4bc931cc0",
            "filename": "packages/core/src/render3/instructions/element.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 9,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Felement.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Felement.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Felement.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -10,19 +10,18 @@ import {assertDefined, assertEqual, assertIndexInRange} from '../../util/assert'\n import {assertFirstCreatePass, assertHasParent} from '../assert';\n import {attachPatchData} from '../context_discovery';\n import {registerPostOrderHooks} from '../hooks';\n-import {hasClassInput, hasStyleInput, TAttributes, TElementNode, TNode, TNodeType} from '../interfaces/node';\n+import {hasClassInput, hasStyleInput, TAttributes, TElementNode, TNode, TNodeFlags, TNodeType} from '../interfaces/node';\n import {RElement} from '../interfaces/renderer';\n import {isContentQueryHost, isDirectiveHost} from '../interfaces/type_checks';\n-import {HEADER_OFFSET, LView, RENDERER, T_HOST, TVIEW, TView} from '../interfaces/view';\n+import {HEADER_OFFSET, LView, RENDERER, TView} from '../interfaces/view';\n import {assertNodeType} from '../node_assert';\n-import {appendChild, writeDirectClass, writeDirectStyle} from '../node_manipulation';\n+import {appendChild, createElementNode, writeDirectClass, writeDirectStyle} from '../node_manipulation';\n import {decreaseElementDepthCount, getBindingIndex, getCurrentTNode, getElementDepthCount, getLView, getNamespace, getTView, increaseElementDepthCount, isCurrentTNodeParent, setCurrentTNode, setCurrentTNodeAsNotParent} from '../state';\n import {computeStaticStyling} from '../styling/static_styling';\n import {setUpAttributes} from '../util/attrs_utils';\n import {getConstant} from '../util/view_utils';\n-\n import {setDirectiveInputsWhichShadowsStyling} from './property';\n-import {createDirectivesInstances, elementCreate, executeContentQueries, getOrCreateTNode, matchingSchemas, resolveDirectives, saveResolvedLocalsInData} from './shared';\n+import {createDirectivesInstances, executeContentQueries, getOrCreateTNode, matchingSchemas, resolveDirectives, saveResolvedLocalsInData} from './shared';\n \n \n function elementStartFirstCreatePass(\n@@ -78,12 +77,10 @@ export function ɵɵelementStart(\n       assertEqual(\n           getBindingIndex(), tView.bindingStartIndex,\n           'elements should be created before any bindings');\n-  ngDevMode && ngDevMode.rendererCreateElement++;\n   ngDevMode && assertIndexInRange(lView, adjustedIndex);\n \n   const renderer = lView[RENDERER];\n-  const native = lView[adjustedIndex] = elementCreate(name, renderer, getNamespace());\n-\n+  const native = lView[adjustedIndex] = createElementNode(renderer, name, getNamespace());\n   const tNode = tView.firstCreatePass ?\n       elementStartFirstCreatePass(index, tView, lView, native, name, attrsIndex, localRefsIndex) :\n       tView.data[adjustedIndex] as TElementNode;\n@@ -102,7 +99,11 @@ export function ɵɵelementStart(\n     writeDirectStyle(renderer, native, styles);\n   }\n \n-  appendChild(tView, lView, native, tNode);\n+  if ((tNode.flags & TNodeFlags.isDetached) !== TNodeFlags.isDetached) {\n+    // In the i18n case, the translation may have removed this element, so only add it if it is not\n+    // detached. See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.\n+    appendChild(tView, lView, native, tNode);\n+  }\n \n   // any immediate children of a component or template container must be pre-emptively\n   // monkey-patched with the component view data so that the element can be inspected"
        },
        {
            "sha": "ddc9c1bc61ed072fa8ee8236f33bcf8ced2fabf3",
            "filename": "packages/core/src/render3/instructions/i18n.ts",
            "status": "modified",
            "additions": 26,
            "deletions": 22,
            "changes": 48,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fi18n.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fi18n.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fi18n.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -10,15 +10,16 @@ import '../../util/ng_i18n_closure_mode';\n \n import {assertDefined} from '../../util/assert';\n import {bindingUpdated} from '../bindings';\n-import {applyI18n, i18nEndFirstPass, pushI18nIndex, setMaskBit} from '../i18n/i18n_apply';\n-import {i18nAttributesFirstPass, i18nStartFirstPass} from '../i18n/i18n_parse';\n+import {applyCreateOpCodes, applyI18n, setMaskBit} from '../i18n/i18n_apply';\n+import {i18nAttributesFirstPass, i18nStartFirstCreatePass} from '../i18n/i18n_parse';\n import {i18nPostprocess} from '../i18n/i18n_postprocess';\n-import {HEADER_OFFSET} from '../interfaces/view';\n-import {getLView, getTView, nextBindingIndex} from '../state';\n+import {TI18n} from '../interfaces/i18n';\n+import {TElementNode, TNodeType} from '../interfaces/node';\n+import {HEADER_OFFSET, T_HOST} from '../interfaces/view';\n+import {getClosestRElement} from '../node_manipulation';\n+import {getCurrentParentTNode, getLView, getTView, nextBindingIndex, setInI18nBlock} from '../state';\n import {getConstant} from '../util/view_utils';\n \n-import {setDelayProjection} from './projection';\n-\n /**\n  * Marks a block of text as translatable.\n  *\n@@ -34,10 +35,6 @@ import {setDelayProjection} from './projection';\n  *   and end of DOM element that were embedded in the original translation block. The placeholder\n  *   `index` points to the element index in the template instructions set. An optional `block` that\n  *   matches the sub-template in which it was declared.\n- * - `�!{index}(:{block})�`/`�/!{index}(:{block})�`: *Projection Placeholder*:  Marks the\n- *   beginning and end of <ng-content> that was embedded in the original translation block.\n- *   The placeholder `index` points to the element index in the template instructions set.\n- *   An optional `block` that matches the sub-template in which it was declared.\n  * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be\n  *   split up and translated separately in each angular template function. The `index` points to the\n  *   `template` instruction index. A `block` that matches the sub-template in which it was declared.\n@@ -48,16 +45,28 @@ import {setDelayProjection} from './projection';\n  *\n  * @codeGenApi\n  */\n-export function ɵɵi18nStart(index: number, messageIndex: number, subTemplateIndex?: number): void {\n+export function ɵɵi18nStart(\n+    index: number, messageIndex: number, subTemplateIndex: number = -1): void {\n   const tView = getTView();\n+  const lView = getLView();\n   ngDevMode && assertDefined(tView, `tView should be defined`);\n   const message = getConstant<string>(tView.consts, messageIndex)!;\n-  pushI18nIndex(index);\n-  // We need to delay projections until `i18nEnd`\n-  setDelayProjection(true);\n-  if (tView.firstCreatePass && tView.data[index + HEADER_OFFSET] === null) {\n-    i18nStartFirstPass(getLView(), tView, index, message, subTemplateIndex);\n+  const parentTNode = getCurrentParentTNode() as TElementNode | null;\n+  if (tView.firstCreatePass) {\n+    i18nStartFirstCreatePass(\n+        tView, parentTNode === null ? 0 : parentTNode.index, lView, index, message,\n+        subTemplateIndex);\n   }\n+  const tI18n = tView.data[HEADER_OFFSET + index] as TI18n;\n+  const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;\n+  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);\n+  // If `parentTNode` is an `ElementContainer` than it has `<!--ng-container--->`.\n+  // When we do inserts we have to make sure to insert in front of `<!--ng-container--->`.\n+  const insertInFrontOf = parentTNode && parentTNode.type === TNodeType.ElementContainer ?\n+      lView[parentTNode.index] :\n+      null;\n+  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);\n+  setInI18nBlock(true);\n }\n \n \n@@ -69,12 +78,7 @@ export function ɵɵi18nStart(index: number, messageIndex: number, subTemplateIn\n  * @codeGenApi\n  */\n export function ɵɵi18nEnd(): void {\n-  const lView = getLView();\n-  const tView = getTView();\n-  ngDevMode && assertDefined(tView, `tView should be defined`);\n-  i18nEndFirstPass(tView, lView);\n-  // Stop delaying projections\n-  setDelayProjection(false);\n+  setInI18nBlock(false);\n }\n \n /**"
        },
        {
            "sha": "89b4217929fd32c4f1fc0d764b3aa8bfc713e2d8",
            "filename": "packages/core/src/render3/instructions/i18n_icu_container_visitor.ts",
            "status": "added",
            "additions": 93,
            "deletions": 0,
            "changes": 93,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fi18n_icu_container_visitor.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fi18n_icu_container_visitor.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fi18n_icu_container_visitor.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -0,0 +1,93 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {assertDomNode, assertEqual, assertNumber, assertNumberInRange} from '../../util/assert';\n+import {assertTIcu, assertTNodeForLView} from '../assert';\n+import {EMPTY_ARRAY} from '../empty';\n+import {getCurrentICUCaseIndex, I18nMutateOpCode, I18nMutateOpCodes, TIcu} from '../interfaces/i18n';\n+import {TIcuContainerNode} from '../interfaces/node';\n+import {RNode} from '../interfaces/renderer';\n+import {LView, TVIEW} from '../interfaces/view';\n+\n+export function loadIcuContainerVisitor() {\n+  const _stack: any[] = [];\n+  let _index: number = -1;\n+  let _lView: LView;\n+  let _removes: I18nMutateOpCodes;\n+\n+  /**\n+   * Retrieves a set of root nodes from `TIcu.remove`. Used by `TNodeType.ICUContainer`\n+   * to determine which root belong to the ICU.\n+   *\n+   * Example of usage.\n+   * ```\n+   * const nextRNode = icuContainerIteratorStart(tIcuContainerNode, lView);\n+   * let rNode: RNode|null;\n+   * while(rNode = nextRNode()) {\n+   *   console.log(rNode);\n+   * }\n+   * ```\n+   *\n+   * @param tIcuContainerNode Current `TIcuContainerNode`\n+   * @param lView `LView` where the `RNode`s should be looked up.\n+   */\n+  function icuContainerIteratorStart(tIcuContainerNode: TIcuContainerNode, lView: LView): () =>\n+      RNode | null {\n+    _lView = lView;\n+    while (_stack.length) _stack.pop();\n+    // FIXME(misko): This is a hack which allows us to associate `TI18n` with `TNode`.\n+    // This should be refactored so that one can attach arbitrary data with `TNode`\n+    ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);\n+    const tIcu: TIcu = tIcuContainerNode.tagName as any;\n+    enterIcu(tIcu, lView);\n+    return icuContainerIteratorNext;\n+  }\n+\n+  function enterIcu(tIcu: TIcu, lView: LView) {\n+    _index = 0;\n+    const currentCase = getCurrentICUCaseIndex(tIcu, lView);\n+    if (currentCase !== null) {\n+      ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);\n+      _removes = tIcu.remove[currentCase];\n+    } else {\n+      _removes = EMPTY_ARRAY;\n+    }\n+  }\n+\n+\n+  function icuContainerIteratorNext(): RNode|null {\n+    if (_index < _removes.length) {\n+      const removeOpCode = _removes[_index++] as number;\n+      ngDevMode && assertNumber(removeOpCode, 'Expecting OpCode number');\n+      const opCode = removeOpCode & I18nMutateOpCode.MASK_INSTRUCTION;\n+      if (opCode === I18nMutateOpCode.Remove) {\n+        const rNode = _lView[removeOpCode >>> I18nMutateOpCode.SHIFT_REF];\n+        ngDevMode && assertDomNode(rNode);\n+        return rNode;\n+      } else {\n+        ngDevMode &&\n+            assertEqual(opCode, I18nMutateOpCode.RemoveNestedIcu, 'Expecting RemoveNestedIcu');\n+        _stack.push(_index, _removes);\n+        const tIcu = _lView[TVIEW].data[removeOpCode >>> I18nMutateOpCode.SHIFT_REF] as TIcu;\n+        ngDevMode && assertTIcu(tIcu);\n+        enterIcu(tIcu, _lView);\n+        return icuContainerIteratorNext();\n+      }\n+    } else {\n+      if (_stack.length === 0) {\n+        return null;\n+      } else {\n+        _removes = _stack.pop();\n+        _index = _stack.pop();\n+        return icuContainerIteratorNext();\n+      }\n+    }\n+  }\n+\n+  return icuContainerIteratorStart;\n+}"
        },
        {
            "sha": "de52469d60c576395d857890e47b64bee1b6aaad",
            "filename": "packages/core/src/render3/instructions/lview_debug.ts",
            "status": "modified",
            "additions": 34,
            "deletions": 15,
            "changes": 49,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Flview_debug.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Flview_debug.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Flview_debug.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -17,7 +17,7 @@ import {getInjectorIndex} from '../di';\n import {CONTAINER_HEADER_OFFSET, HAS_TRANSPLANTED_VIEWS, LContainer, MOVED_VIEWS, NATIVE} from '../interfaces/container';\n import {ComponentTemplate, DirectiveDef, DirectiveDefList, PipeDefList, ViewQueriesFunction} from '../interfaces/definition';\n import {NO_PARENT_INJECTOR, NodeInjectorOffset} from '../interfaces/injector';\n-import {AttributeMarker, PropertyAliases, TConstants, TContainerNode, TElementNode, TNode as ITNode, TNodeFlags, TNodeProviderIndexes, TNodeType, TNodeTypeAsString} from '../interfaces/node';\n+import {AttributeMarker, InsertBeforeIndex, PropertyAliases, TConstants, TContainerNode, TElementNode, TNode as ITNode, TNodeFlags, TNodeProviderIndexes, TNodeType, TNodeTypeAsString} from '../interfaces/node';\n import {SelectorFlags} from '../interfaces/projection';\n import {LQueries, TQueries} from '../interfaces/query';\n import {RComment, RElement, Renderer3, RendererFactory3, RNode} from '../interfaces/renderer';\n@@ -160,7 +160,13 @@ export const TViewConstructor = class TView implements ITView {\n     return TViewTypeAsString[this.type] || `TViewType.?${this.type}?`;\n   }\n \n-  get i18nStartIndex(): number {\n+  /**\n+   * Returns initial value of `expandoStartIndex`.\n+   */\n+  // FIXME(misko): `originalExpandoStartIndex` should not be needed because it should be the same as\n+  // `expandoStartIndex`. However `expandoStartIndex` is misnamed as it changes as more items get\n+  // allocated in expando.\n+  get originalExpandoStartIndex(): number {\n     return HEADER_OFFSET + this._decls + this._vars;\n   }\n };\n@@ -170,6 +176,7 @@ class TNode implements ITNode {\n       public tView_: TView,                                                          //\n       public type: TNodeType,                                                        //\n       public index: number,                                                          //\n+      public insertBeforeIndex: InsertBeforeIndex,                                   //\n       public injectorIndex: number,                                                  //\n       public directiveStart: number,                                                 //\n       public directiveEnd: number,                                                   //\n@@ -249,8 +256,13 @@ class TNode implements ITNode {\n   }\n \n   get template_(): string {\n+    if (this.tagName === null && this.type === TNodeType.Element) return '#text';\n     const buf: string[] = [];\n-    buf.push('<', this.tagName || this.type_);\n+    const tagName = typeof this.tagName === 'string' && this.tagName || this.type_;\n+    buf.push('<', tagName);\n+    if (this.flags) {\n+      buf.push(' ', this.flags_);\n+    }\n     if (this.attrs) {\n       for (let i = 0; i < this.attrs.length;) {\n         const attrName = this.attrs[i++];\n@@ -263,7 +275,7 @@ class TNode implements ITNode {\n     }\n     buf.push('>');\n     processTNodeChildren(this.child, buf);\n-    buf.push('</', this.tagName || this.type_, '>');\n+    buf.push('</', tagName, '>');\n     return buf.join('');\n   }\n \n@@ -444,7 +456,7 @@ export class LViewDebug implements ILViewDebug {\n     return toHtml(this._raw_lView[HOST], true);\n   }\n   get html(): string {\n-    return (this.nodes || []).map(node => toHtml(node.native, true)).join('');\n+    return (this.nodes || []).map(mapToHTML).join('');\n   }\n   get context(): {}|null {\n     return this._raw_lView[CONTEXT];\n@@ -458,7 +470,9 @@ export class LViewDebug implements ILViewDebug {\n     const tNode = lView[TVIEW].firstChild;\n     return toDebugNodes(tNode, lView);\n   }\n-\n+  get template(): string {\n+    return (this.tView as any as {template_: string}).template_;\n+  }\n   get tView(): ITView {\n     return this._raw_lView[TVIEW];\n   }\n@@ -504,20 +518,15 @@ export class LViewDebug implements ILViewDebug {\n     const tView = this.tView;\n     return toLViewRange(\n         tView, this._raw_lView, tView.bindingStartIndex,\n-        (tView as any as {i18nStartIndex: number}).i18nStartIndex);\n-  }\n-\n-  get i18n(): LViewDebugRange {\n-    const tView = this.tView;\n-    return toLViewRange(\n-        tView, this._raw_lView, (tView as any as {i18nStartIndex: number}).i18nStartIndex,\n-        tView.expandoStartIndex);\n+        (tView as any as {originalExpandoStartIndex: number}).originalExpandoStartIndex);\n   }\n \n   get expando(): LViewDebugRange {\n     const tView = this.tView as any as {_decls: number, _vars: number};\n     return toLViewRange(\n-        this.tView, this._raw_lView, this.tView.expandoStartIndex, this._raw_lView.length);\n+        this.tView, this._raw_lView,\n+        (tView as any as {originalExpandoStartIndex: number}).originalExpandoStartIndex,\n+        this._raw_lView.length);\n   }\n \n   /**\n@@ -534,6 +543,16 @@ export class LViewDebug implements ILViewDebug {\n   }\n }\n \n+function mapToHTML(node: DebugNode): string {\n+  if (node.type === 'ElementContainer') {\n+    return (node.children || []).map(mapToHTML).join('');\n+  } else if (node.type === 'IcuContainer') {\n+    throw new Error('Not implemented');\n+  } else {\n+    return toHtml(node.native, true) || '';\n+  }\n+}\n+\n function toLViewRange(tView: TView, lView: LView, start: number, end: number): LViewDebugRange {\n   let content: LViewDebugRangeContent[] = [];\n   for (let index = start; index < end; index++) {"
        },
        {
            "sha": "4b4f56d38c8d6effc59d780219c946ba4b38a479",
            "filename": "packages/core/src/render3/instructions/projection.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 8,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fprojection.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fprojection.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fprojection.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n import {newArray} from '../../util/array_utils';\n-import {TAttributes, TElementNode, TNode, TNodeType} from '../interfaces/node';\n+import {TAttributes, TElementNode, TNode, TNodeFlags, TNodeType} from '../interfaces/node';\n import {ProjectionSlots} from '../interfaces/projection';\n import {DECLARATION_COMPONENT_VIEW, T_HOST} from '../interfaces/view';\n import {applyProjection} from '../node_manipulation';\n@@ -103,11 +103,6 @@ export function ɵɵprojectionDef(projectionSlots?: ProjectionSlots): void {\n   }\n }\n \n-let delayProjection = false;\n-export function setDelayProjection(value: boolean) {\n-  delayProjection = value;\n-}\n-\n \n /**\n  * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\n@@ -133,8 +128,7 @@ export function ɵɵprojection(\n   // `<ng-content>` has no content\n   setCurrentTNodeAsNotParent();\n \n-  // We might need to delay the projection of nodes if they are in the middle of an i18n block\n-  if (!delayProjection) {\n+  if ((tProjectionNode.flags & TNodeFlags.isDetached) !== TNodeFlags.isDetached) {\n     // re-distribution of projectable nodes is stored on a component's view level\n     applyProjection(tView, lView, tProjectionNode);\n   }"
        },
        {
            "sha": "54c2ceb813e90b8f5b58f0f7b3fc27bce87e183c",
            "filename": "packages/core/src/render3/instructions/shared.ts",
            "status": "modified",
            "additions": 109,
            "deletions": 89,
            "changes": 198,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fshared.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fshared.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Fshared.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -5,43 +5,43 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {Injector} from '../../di';\n-import {ErrorHandler} from '../../error_handler';\n-import {DoCheck, OnChanges, OnInit} from '../../interface/lifecycle_hooks';\n-import {CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, SchemaMetadata} from '../../metadata/schema';\n-import {ViewEncapsulation} from '../../metadata/view';\n-import {validateAgainstEventAttributes, validateAgainstEventProperties} from '../../sanitization/sanitization';\n-import {Sanitizer} from '../../sanitization/sanitizer';\n-import {assertDefined, assertDomNode, assertEqual, assertGreaterThan, assertIndexInRange, assertLessThan, assertNotEqual, assertNotSame, assertSame} from '../../util/assert';\n-import {createNamedArrayType} from '../../util/named_array_type';\n-import {initNgDevMode} from '../../util/ng_dev_mode';\n-import {normalizeDebugBindingName, normalizeDebugBindingValue} from '../../util/ng_reflect';\n-import {stringify} from '../../util/stringify';\n-import {assertFirstCreatePass, assertLContainer, assertLView, assertTNodeForLView} from '../assert';\n-import {attachPatchData} from '../context_discovery';\n-import {getFactoryDef} from '../definition';\n-import {diPublicInInjector, getNodeInjectable, getOrCreateNodeInjectorForNode} from '../di';\n-import {throwMultipleComponentError} from '../errors';\n-import {executeCheckHooks, executeInitAndCheckHooks, incrementInitPhaseFlags} from '../hooks';\n-import {CONTAINER_HEADER_OFFSET, HAS_TRANSPLANTED_VIEWS, LContainer, MOVED_VIEWS} from '../interfaces/container';\n-import {ComponentDef, ComponentTemplate, DirectiveDef, DirectiveDefListOrFactory, PipeDefListOrFactory, RenderFlags, ViewQueriesFunction} from '../interfaces/definition';\n-import {NodeInjectorFactory, NodeInjectorOffset} from '../interfaces/injector';\n-import {AttributeMarker, InitialInputData, InitialInputs, LocalRefExtractor, PropertyAliases, PropertyAliasValue, TAttributes, TConstantsOrFactory, TContainerNode, TDirectiveHostNode, TElementContainerNode, TElementNode, TIcuContainerNode, TNode, TNodeFlags, TNodeProviderIndexes, TNodeType, TProjectionNode} from '../interfaces/node';\n-import {isProceduralRenderer, RComment, RElement, Renderer3, RendererFactory3, RNode, RText} from '../interfaces/renderer';\n-import {SanitizerFn} from '../interfaces/sanitization';\n-import {isComponentDef, isComponentHost, isContentQueryHost, isRootView} from '../interfaces/type_checks';\n-import {CHILD_HEAD, CHILD_TAIL, CLEANUP, CONTEXT, DECLARATION_COMPONENT_VIEW, DECLARATION_VIEW, FLAGS, HEADER_OFFSET, HOST, InitPhaseState, INJECTOR, LView, LViewFlags, NEXT, PARENT, RENDERER, RENDERER_FACTORY, RootContext, RootContextFlags, SANITIZER, T_HOST, TData, TRANSPLANTED_VIEWS_TO_REFRESH, TVIEW, TView, TViewType} from '../interfaces/view';\n-import {assertNodeNotOfTypes, assertNodeOfPossibleTypes} from '../node_assert';\n-import {isInlineTemplate, isNodeMatchingSelectorList} from '../node_selector_matcher';\n-import {enterView, getBindingsEnabled, getCurrentDirectiveIndex, getCurrentTNode, getSelectedIndex, isCurrentTNodeParent, isInCheckNoChangesMode, leaveView, setBindingIndex, setBindingRootForHostBindings, setCurrentDirectiveIndex, setCurrentQueryIndex, setCurrentTNode, setIsInCheckNoChangesMode, setSelectedIndex} from '../state';\n-import {NO_CHANGE} from '../tokens';\n-import {isAnimationProp, mergeHostAttrs} from '../util/attrs_utils';\n-import {INTERPOLATION_DELIMITER, renderStringify, stringifyForError} from '../util/misc_utils';\n-import {getFirstLContainer, getLViewParent, getNextLContainer} from '../util/view_traversal_utils';\n-import {getComponentLViewByIndex, getNativeByIndex, getNativeByTNode, isCreationMode, readPatchedLView, resetPreOrderHookFlags, unwrapLView, updateTransplantedViewCount, viewAttachedToChangeDetector} from '../util/view_utils';\n-\n-import {selectIndexInternal} from './advance';\n-import {attachLContainerDebug, attachLViewDebug, cloneToLViewFromTViewBlueprint, cloneToTViewData, LCleanup, LViewBlueprint, MatchesArray, TCleanup, TNodeDebug, TNodeInitialInputs, TNodeLocalNames, TViewComponents, TViewConstructor} from './lview_debug';\n+import { Injector } from '../../di';\n+import { ErrorHandler } from '../../error_handler';\n+import { DoCheck, OnChanges, OnInit } from '../../interface/lifecycle_hooks';\n+import { CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, SchemaMetadata } from '../../metadata/schema';\n+import { ViewEncapsulation } from '../../metadata/view';\n+import { validateAgainstEventAttributes, validateAgainstEventProperties } from '../../sanitization/sanitization';\n+import { Sanitizer } from '../../sanitization/sanitizer';\n+import { assertDefined, assertDomNode, assertEqual, assertGreaterThan, assertIndexInRange, assertLessThan, assertNotEqual, assertNotSame, assertSame, assertString } from '../../util/assert';\n+import { createNamedArrayType } from '../../util/named_array_type';\n+import { initNgDevMode } from '../../util/ng_dev_mode';\n+import { normalizeDebugBindingName, normalizeDebugBindingValue } from '../../util/ng_reflect';\n+import { stringify } from '../../util/stringify';\n+import { assertFirstCreatePass, assertFirstUpdatePass, assertLContainer, assertLView, assertTNodeForLView, assertTNodeForTView } from '../assert';\n+import { attachPatchData } from '../context_discovery';\n+import { getFactoryDef } from '../definition';\n+import { diPublicInInjector, getNodeInjectable, getOrCreateNodeInjectorForNode } from '../di';\n+import { throwMultipleComponentError } from '../errors';\n+import { executeCheckHooks, executeInitAndCheckHooks, incrementInitPhaseFlags } from '../hooks';\n+import { CONTAINER_HEADER_OFFSET, HAS_TRANSPLANTED_VIEWS, LContainer, MOVED_VIEWS } from '../interfaces/container';\n+import { ComponentDef, ComponentTemplate, DirectiveDef, DirectiveDefListOrFactory, PipeDefListOrFactory, RenderFlags, ViewQueriesFunction } from '../interfaces/definition';\n+import { NodeInjectorFactory, NodeInjectorOffset } from '../interfaces/injector';\n+import { AttributeMarker, InitialInputData, InitialInputs, LocalRefExtractor, PropertyAliases, PropertyAliasValue, TAttributes, TConstantsOrFactory, TContainerNode, TDirectiveHostNode, TElementContainerNode, TElementNode, TIcuContainerNode, TNode, TNodeFlags, TNodeProviderIndexes, TNodeType, TProjectionNode } from '../interfaces/node';\n+import { isProceduralRenderer, RComment, RElement, Renderer3, RendererFactory3, RNode, RText } from '../interfaces/renderer';\n+import { SanitizerFn } from '../interfaces/sanitization';\n+import { isComponentDef, isComponentHost, isContentQueryHost, isRootView } from '../interfaces/type_checks';\n+import { CHILD_HEAD, CHILD_TAIL, CLEANUP, CONTEXT, DECLARATION_COMPONENT_VIEW, DECLARATION_VIEW, FLAGS, HEADER_OFFSET, HOST, InitPhaseState, INJECTOR, LView, LViewFlags, NEXT, PARENT, RENDERER, RENDERER_FACTORY, RootContext, RootContextFlags, SANITIZER, TData, TRANSPLANTED_VIEWS_TO_REFRESH, TVIEW, TView, TViewType, T_HOST } from '../interfaces/view';\n+import { assertNodeNotOfTypes, assertNodeOfPossibleTypes } from '../node_assert';\n+import { updateTextNode } from '../node_manipulation';\n+import { isInlineTemplate, isNodeMatchingSelectorList } from '../node_selector_matcher';\n+import { enterView, getBindingsEnabled, getCurrentDirectiveIndex, getCurrentParentTNode, getCurrentTNode, getCurrentTNodePlaceholderOk, getSelectedIndex, isCurrentTNodeParent, isInCheckNoChangesMode, isInI18nBlock, leaveView, setBindingIndex, setBindingRootForHostBindings, setCurrentDirectiveIndex, setCurrentQueryIndex, setCurrentTNode, setIsInCheckNoChangesMode, setSelectedIndex } from '../state';\n+import { NO_CHANGE } from '../tokens';\n+import { isAnimationProp, mergeHostAttrs } from '../util/attrs_utils';\n+import { INTERPOLATION_DELIMITER, renderStringify, stringifyForError } from '../util/misc_utils';\n+import { getFirstLContainer, getLViewParent, getNextLContainer } from '../util/view_traversal_utils';\n+import { getComponentLViewByIndex, getNativeByIndex, getNativeByTNode, isCreationMode, readPatchedLView, resetPreOrderHookFlags, unwrapLView, updateTransplantedViewCount, viewAttachedToChangeDetector } from '../util/view_utils';\n+import { selectIndexInternal } from './advance';\n+import { attachLContainerDebug, attachLViewDebug, cloneToLViewFromTViewBlueprint, cloneToTViewData, LCleanup, LViewBlueprint, MatchesArray, TCleanup, TNodeDebug, TNodeInitialInputs, TNodeLocalNames, TViewComponents, TViewConstructor } from './lview_debug';\n \n \n \n@@ -155,21 +155,6 @@ function renderChildComponents(hostLView: LView, components: number[]): void {\n   }\n }\n \n-/**\n- * Creates a native element from a tag name, using a renderer.\n- * @param name the tag name\n- * @param renderer A renderer to use\n- * @returns the element created\n- */\n-export function elementCreate(name: string, renderer: Renderer3, namespace: string|null): RElement {\n-  if (isProceduralRenderer(renderer)) {\n-    return renderer.createElement(name, namespace);\n-  } else {\n-    return namespace === null ? renderer.createElement(name) :\n-                                renderer.createElementNS(namespace, name);\n-  }\n-}\n-\n export function createLView<T>(\n     parentLView: LView|null, tView: TView, context: T|null, flags: LViewFlags, host: RElement|null,\n     tHostNode: TNode|null, rendererFactory: RendererFactory3|null, renderer: Renderer3|null,\n@@ -230,17 +215,34 @@ export function getOrCreateTNode(\n     TElementNode&TContainerNode&TElementContainerNode&TProjectionNode&TIcuContainerNode {\n   // Keep this function short, so that the VM will inline it.\n   const adjustedIndex = index + HEADER_OFFSET;\n-  const tNode = tView.data[adjustedIndex] as TNode ||\n-      createTNodeAtIndex(tView, adjustedIndex, type, name, attrs);\n+  let tNode = tView.data[adjustedIndex] as TNode;\n+  if (tNode === null) {\n+    tNode = createTNodeAtIndex(tView, adjustedIndex, type, name, attrs);\n+    if (isInI18nBlock()) {\n+      // If we are in i18n block then all elements should be pre declared through `Placeholder`\n+      // See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.\n+      // If the `TNode` was not pre-declared than it means it was not mentioned which means it was\n+      // removed, so we mark it as detached.\n+      tNode.flags |= TNodeFlags.isDetached;\n+    }\n+  } else if (tNode.type == TNodeType.Placeholder) {\n+    tNode.type = type;\n+    tNode.tagName = name;\n+    tNode.attrs = attrs;\n+    const parent = getCurrentParentTNode();\n+    tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;\n+    ngDevMode && assertTNodeForTView(tNode, tView);\n+    ngDevMode && assertEqual(index + HEADER_OFFSET, tNode.index, 'Expecting same index');\n+  }\n   setCurrentTNode(tNode, true);\n   return tNode as TElementNode & TContainerNode & TElementContainerNode & TProjectionNode &\n       TIcuContainerNode;\n }\n \n-function createTNodeAtIndex(\n+export function createTNodeAtIndex(\n     tView: TView, adjustedIndex: number, type: TNodeType, name: string|null,\n     attrs: TAttributes|null) {\n-  const currentTNode = getCurrentTNode();\n+  const currentTNode = getCurrentTNodePlaceholderOk();\n   const isParent = isCurrentTNodeParent();\n   const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;\n   // Parents cannot cross component boundaries because components will be used in multiple places.\n@@ -253,11 +255,18 @@ function createTNodeAtIndex(\n     tView.firstChild = tNode;\n   }\n   if (currentTNode !== null) {\n-    if (isParent && currentTNode.child == null && tNode.parent !== null) {\n-      // We are in the same view, which means we are adding content node to the parent view.\n-      currentTNode.child = tNode;\n-    } else if (!isParent) {\n-      currentTNode.next = tNode;\n+    if (isParent) {\n+      // FIXME(misko): This logic looks unnecessarily complicated. Could we simplify?\n+      if (currentTNode.child == null && tNode.parent !== null) {\n+        // We are in the same view, which means we are adding content node to the parent view.\n+        currentTNode.child = tNode;\n+      }\n+    } else {\n+      if (currentTNode.next === null) {\n+        // In the case of i18n the `currentTNode` may already be linked, in which case we don't want\n+        // to break the links which i18n created.\n+        currentTNode.next = tNode;\n+      }\n     }\n   }\n   return tNode;\n@@ -266,36 +275,40 @@ function createTNodeAtIndex(\n \n /**\n  * When elements are created dynamically after a view blueprint is created (e.g. through\n- * i18nApply() or ComponentFactory.create), we need to adjust the blueprint for future\n+ * i18nApply()), we need to adjust the blueprint for future\n  * template passes.\n  *\n  * @param tView `TView` associated with `LView`\n- * @param view The `LView` containing the blueprint to adjust\n+ * @param lView The `LView` containing the blueprint to adjust\n  * @param numSlotsToAlloc The number of slots to alloc in the LView, should be >0\n  */\n-export function allocExpando(tView: TView, lView: LView, numSlotsToAlloc: number) {\n-  ngDevMode &&\n-      assertGreaterThan(\n-          numSlotsToAlloc, 0, 'The number of slots to alloc should be greater than 0');\n-  if (numSlotsToAlloc > 0) {\n-    if (tView.firstCreatePass) {\n-      for (let i = 0; i < numSlotsToAlloc; i++) {\n-        tView.blueprint.push(null);\n-        tView.data.push(null);\n-        lView.push(null);\n-      }\n+export function allocExpando(tView: TView, lView: LView, numSlotsToAlloc: number): number {\n+  if (ngDevMode) {\n+    assertGreaterThan(numSlotsToAlloc, 0, 'The number of slots to alloc should be greater than 0');\n+    assertEqual(tView.data.length, lView.length, 'Expecting LView to be same size as TView');\n+    assertEqual(\n+        tView.data.length, tView.blueprint.length, 'Expecting Blueprint to be same size as TView');\n+    assertFirstUpdatePass(tView);\n+  }\n+  const allocIdx = lView.length;\n+  for (let i = 0; i < numSlotsToAlloc; i++) {\n+    tView.blueprint.push(null);\n+    tView.data.push(null);\n+    lView.push(null);\n+  }\n \n-      // We should only increment the expando start index if there aren't already directives\n-      // and injectors saved in the \"expando\" section\n-      if (!tView.expandoInstructions) {\n-        tView.expandoStartIndex += numSlotsToAlloc;\n-      } else {\n-        // Since we're adding the dynamic nodes into the expando section, we need to let the host\n-        // bindings know that they should skip x slots\n-        tView.expandoInstructions.push(numSlotsToAlloc);\n-      }\n-    }\n+  // We should only increment the expando start index if there aren't already directives\n+  // and injectors saved in the \"expando\" section\n+  if (!tView.expandoInstructions) {\n+    tView.expandoStartIndex += numSlotsToAlloc;\n+  } else {\n+    // Since we're adding the dynamic nodes into the expando section, we need to let the host\n+    // bindings know that they should skip x slots\n+    // FIXME(misko): Refactor `expandoInstructions` so that it does not rely on relative binding\n+    // offsets, but absolute values which Means we would not have to store it here.\n+    tView.expandoInstructions.push(numSlotsToAlloc);\n   }\n+  return allocIdx;\n }\n \n \n@@ -824,12 +837,14 @@ export function createTNode(\n     tagName: string|null, attrs: TAttributes|null): TNode {\n   ngDevMode && assertNotSame(attrs, undefined, '\\'undefined\\' is not valid value for \\'attrs\\'');\n   ngDevMode && ngDevMode.tNode++;\n+  ngDevMode && tParent && assertTNodeForTView(tParent, tView);\n   let injectorIndex = tParent ? tParent.injectorIndex : -1;\n   const tNode = ngDevMode ?\n       new TNodeDebug(\n           tView,          // tView_: TView\n           type,           // type: TNodeType\n           adjustedIndex,  // index: number\n+          null,           // insertBeforeIndex: null|-1|number|number[]\n           injectorIndex,  // injectorIndex: number\n           -1,             // directiveStart: number\n           -1,             // directiveEnd: number\n@@ -862,6 +877,7 @@ export function createTNode(\n       {\n         type: type,\n         index: adjustedIndex,\n+        insertBeforeIndex: null,\n         injectorIndex: injectorIndex,\n         directiveStart: -1,\n         directiveEnd: -1,\n@@ -1509,15 +1525,20 @@ export function elementAttributeInternal(\n             `Host bindings are not valid on ng-container or ng-template.`);\n   }\n   const element = getNativeByTNode(tNode, lView) as RElement;\n-  const renderer = lView[RENDERER];\n+  setElementAttribute(lView[RENDERER], element, namespace, tNode.tagName, name, value, sanitizer);\n+}\n+\n+export function setElementAttribute(\n+    renderer: Renderer3, element: RElement, namespace: string|null|undefined, tagName: string|null,\n+    name: string, value: any, sanitizer: SanitizerFn|null|undefined) {\n   if (value == null) {\n     ngDevMode && ngDevMode.rendererRemoveAttribute++;\n     isProceduralRenderer(renderer) ? renderer.removeAttribute(element, name, namespace) :\n                                      element.removeAttribute(name);\n   } else {\n     ngDevMode && ngDevMode.rendererSetAttribute++;\n     const strValue =\n-        sanitizer == null ? renderStringify(value) : sanitizer(value, tNode.tagName || '', name);\n+        sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || '', name);\n \n \n     if (isProceduralRenderer(renderer)) {\n@@ -2065,11 +2086,10 @@ export function setInputsForProperty(\n  * Updates a text binding at a given index in a given LView.\n  */\n export function textBindingInternal(lView: LView, index: number, value: string): void {\n+  ngDevMode && assertString(value, 'Value should be a string');\n   ngDevMode && assertNotSame(value, NO_CHANGE as any, 'value should not be NO_CHANGE');\n   ngDevMode && assertIndexInRange(lView, index + HEADER_OFFSET);\n   const element = getNativeByIndex(index, lView) as any as RText;\n   ngDevMode && assertDefined(element, 'native element should exist');\n-  ngDevMode && ngDevMode.rendererSetText++;\n-  const renderer = lView[RENDERER];\n-  isProceduralRenderer(renderer) ? renderer.setValue(element, value) : element.textContent = value;\n+  updateTextNode(lView[RENDERER], element, value);\n }"
        },
        {
            "sha": "5dc5fdacbfc7dd80d7d34c7546ca2ed02b3da0a1",
            "filename": "packages/core/src/render3/instructions/text.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Ftext.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Ftext.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Ftext.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -38,7 +38,7 @@ export function ɵɵtext(index: number, value: string = ''): void {\n       getOrCreateTNode(tView, index, TNodeType.Element, null, null) :\n       tView.data[adjustedIndex] as TElementNode;\n \n-  const textNative = lView[adjustedIndex] = createTextNode(value, lView[RENDERER]);\n+  const textNative = lView[adjustedIndex] = createTextNode(lView[RENDERER], value);\n   appendChild(tView, lView, textNative, tNode);\n \n   // Text nodes are self closing."
        },
        {
            "sha": "3b93b1b0556389c89ef132f8e1fcbe9b4ef8ae2a",
            "filename": "packages/core/src/render3/interfaces/i18n.ts",
            "status": "modified",
            "additions": 121,
            "deletions": 94,
            "changes": 215,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fi18n.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fi18n.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fi18n.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -6,7 +6,11 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n+import {assertGreaterThan, assertGreaterThanOrEqual} from '../../util/assert';\n+import {TIcuContainerNode} from './node';\n+import {RNode} from './renderer';\n import {SanitizerFn} from './sanitization';\n+import {LView} from './view';\n \n /**\n  * `I18nMutateOpCode` defines OpCodes for `I18nMutateOpCodes` array.\n@@ -43,6 +47,7 @@ export const enum I18nMutateOpCode {\n   /**\n    * Mask for OpCode\n    */\n+  // FIXME(misko): Shrink mask to 2 bits as 4 choices can fit into two bits.\n   MASK_INSTRUCTION = 0b111,\n \n   /**\n@@ -53,11 +58,6 @@ export const enum I18nMutateOpCode {\n   //           11111110000000000\n   //           65432109876543210\n \n-  /**\n-   * Instruction to select a node. (next OpCode will contain the operation.)\n-   */\n-  Select = 0b000,\n-\n   /**\n    * Instruction to append the current node to `PARENT`.\n    */\n@@ -73,29 +73,37 @@ export const enum I18nMutateOpCode {\n    */\n   Attr = 0b100,\n \n-  /**\n-   * Instruction to simulate elementEnd()\n-   */\n-  ElementEnd = 0b101,\n-\n   /**\n    * Instruction to removed the nested ICU.\n    */\n   RemoveNestedIcu = 0b110,\n }\n \n+// FIXME(misko): These function are technically not interfaces, and so we may consider moving them\n+// elsewhere.\n+\n+// FIXME(misko): rename to `getParentFromI18nCreateOpCode`\n export function getParentFromI18nMutateOpCode(mergedCode: number): number {\n   return mergedCode >>> I18nMutateOpCode.SHIFT_PARENT;\n }\n \n+// FIXME(misko): rename to `getRefFromI18nCreateOpCode`\n export function getRefFromI18nMutateOpCode(mergedCode: number): number {\n   return (mergedCode & I18nMutateOpCode.MASK_REF) >>> I18nMutateOpCode.SHIFT_REF;\n }\n \n+// FIXME(misko): rename to `getInstructionFromI18nCreateOpCode`\n export function getInstructionFromI18nMutateOpCode(mergedCode: number): number {\n   return mergedCode & I18nMutateOpCode.MASK_INSTRUCTION;\n }\n \n+// FIXME(misko): rename to `i18nCreateOpCode`\n+export function i18nMutateOpCode(opCode: I18nMutateOpCode, parentIdx: number, refIdx: number) {\n+  ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, 'Missing parent index');\n+  ngDevMode && assertGreaterThan(refIdx, 0, 'Missing ref index');\n+  return opCode | parentIdx << I18nMutateOpCode.SHIFT_PARENT | refIdx << I18nMutateOpCode.SHIFT_REF;\n+}\n+\n /**\n  * Marks that the next string is an element name.\n  *\n@@ -113,6 +121,7 @@ export interface ELEMENT_MARKER {\n  *\n  * See `I18nMutateOpCodes` documentation.\n  */\n+// FIXME(misko): Rename to ICU marker\n export const COMMENT_MARKER: COMMENT_MARKER = {\n   marker: 'comment'\n };\n@@ -132,6 +141,62 @@ export interface I18nDebug {\n   debug?: string[];\n }\n \n+/**\n+ * Array storing OpCode for dynamically creating `i18n` translation DOM elements.\n+ *\n+ * This array creates a sequence of `Text` and `Comment` (as ICU anchor) DOM elements. It consists\n+ * of a pair of `number` and `string` pairs which encode the operations for the creation of the\n+ * translated block.\n+ *\n+ * The number is shifted and encoded according to `I18nCreateOpCode`\n+ *\n+ * Pseudocode:\n+ * ```\n+ * const i18nCreateOpCodes = [\n+ *   10 << I18nCreateOpCode.SHIFT, \"Text Node add to DOM\",\n+ *   11 << I18nCreateOpCode.SHIFT | I18nCreateOpCode.COMMENT, \"Comment Node add to DOM\",\n+ *   12 << I18nCreateOpCode.SHIFT | I18nCreateOpCode.APPEND_LATER, \"Text Node added later\"\n+ * ];\n+ *\n+ * for(var i=0; i<i18nCreateOpCodes.length; i++) {\n+ *   const opcode = i18NCreateOpCodes[i++];\n+ *   const index = opcode >> I18nCreateOpCode.SHIFT;\n+ *   const text = i18NCreateOpCodes[i];\n+ *   let node: Text|Comment;\n+ *   if (opcode & I18nCreateOpCode.COMMENT === I18nCreateOpCode.COMMENT) {\n+ *     node = lView[~index] = document.createComment(text);\n+ *   } else {\n+ *     node = lView[index] = document.createText(text);\n+ *   }\n+ *   if (opcode & I18nCreateOpCode.APPEND_EAGERLY !== I18nCreateOpCode.APPEND_EAGERLY) {\n+ *     parentNode.appendChild(node);\n+ *   }\n+ * }\n+ * ```\n+ */\n+export interface I18nCreateOpCodes extends Array<number|string>, I18nDebug {}\n+\n+/**\n+ * See `I18nCreateOpCodes`\n+ */\n+export enum I18nCreateOpCode {\n+  /**\n+   * Number of bits to shift index so that it can be combined with the `APPEND_EAGERLY` and\n+   * `COMMENT`.\n+   */\n+  SHIFT = 2,\n+\n+  /**\n+   * Should the node be appended to parent imedditatly after creation.\n+   */\n+  APPEND_EAGERLY = 0b01,\n+\n+  /**\n+   * If set the node should be comment (rather than a text) node.\n+   */\n+  COMMENT = 0b10,\n+}\n+\n \n /**\n  * Array storing OpCode for dynamically creating `i18n` blocks.\n@@ -289,38 +354,18 @@ export interface I18nUpdateOpCodes extends Array<string|number|SanitizerFn|null>\n  * Store information for the i18n translation block.\n  */\n export interface TI18n {\n-  /**\n-   * Number of slots to allocate in expando.\n-   *\n-   * This is the max number of DOM elements which will be created by this i18n + ICU blocks. When\n-   * the DOM elements are being created they are stored in the EXPANDO, so that update OpCodes can\n-   * write into them.\n-   */\n-  vars: number;\n-\n   /**\n    * A set of OpCodes which will create the Text Nodes and ICU anchors for the translation blocks.\n    *\n    * NOTE: The ICU anchors are filled in with ICU Update OpCode.\n    */\n-  create: I18nMutateOpCodes;\n+  create: I18nCreateOpCodes;\n \n   /**\n    * A set of OpCodes which will be executed on each change detection to determine if any changes to\n    * DOM are required.\n    */\n   update: I18nUpdateOpCodes;\n-\n-  /**\n-   * A list of ICUs in a translation block (or `null` if block has no ICUs).\n-   *\n-   * Example:\n-   * Given: `<div i18n>You have {count, plural, ...} and {state, switch, ...}</div>`\n-   * There would be 2 ICUs in this array.\n-   *   1. `{count, plural, ...}`\n-   *   2. `{state, switch, ...}`\n-   */\n-  icus: TIcu[]|null;\n }\n \n /**\n@@ -338,52 +383,23 @@ export interface TIcu {\n   type: IcuType;\n \n   /**\n-   * Number of slots to allocate in expando for each case.\n-   *\n-   * This is the max number of DOM elements which will be created by this i18n + ICU blocks. When\n-   * the DOM elements are being created they are stored in the EXPANDO, so that update OpCodes can\n-   * write into them.\n+   * Index in `LView` where the anchor node is stored. `<!-- ICU 0:0 -->`\n    */\n-  vars: number[];\n+  anchorIdx: number;\n \n   /**\n    * Currently selected ICU case pointer.\n    *\n    * `lView[currentCaseLViewIndex]` stores the currently selected case. This is needed to know how\n    * to clean up the current case when transitioning no the new case.\n-   */\n-  currentCaseLViewIndex: number;\n-\n-  /**\n-   * An optional array of child/sub ICUs.\n-   *\n-   * In case of nested ICUs such as:\n-   * ```\n-   * {�0�, plural,\n-   *   =0 {zero}\n-   *   other {�0� {�1�, select,\n-   *                     cat {cats}\n-   *                     dog {dogs}\n-   *                     other {animals}\n-   *                   }!\n-   *   }\n-   * }\n-   * ```\n-   * When the parent ICU is changing it must clean up child ICUs as well. For this reason it needs\n-   * to know which child ICUs to run clean up for as well.\n-   *\n-   * In the above example this would be:\n-   * ```ts\n-   * [\n-   *   [],   // `=0` has no sub ICUs\n-   *   [1],  // `other` has one subICU at `1`st index.\n-   * ]\n-   * ```\n    *\n-   * The reason why it is Array of Arrays is because first array represents the case, and second\n-   * represents the child ICUs to clean up. There may be more than one child ICUs per case.\n+   * If the value stored is:\n+   * `null`: No current case selected.\n+   *   `<0`: A flag which means that the ICU just switched and that `icuUpdate` must be executed\n+   *         regardless of the `mask`. (After the execution the flag is cleared)\n+   *   `>=0` A currently selected case index.\n    */\n-  childIcus: number[][];\n+  currentCaseLViewIndex: number;\n \n   /**\n    * A list of case values which the current ICU will try to match.\n@@ -395,11 +411,13 @@ export interface TIcu {\n   /**\n    * A set of OpCodes to apply in order to build up the DOM render tree for the ICU\n    */\n+  // FIXME(misko): Rename `I18nMutateOpCodes` to `I18nCreateOpCodes`.\n   create: I18nMutateOpCodes[];\n \n   /**\n    * A set of OpCodes to apply in order to destroy the DOM render tree for the ICU.\n    */\n+  // FIXME(misko): Rename `I18nMutateOpCodes` to `I18nRemoveOpCodes`.\n   remove: I18nMutateOpCodes[];\n \n   /**\n@@ -412,40 +430,49 @@ export interface TIcu {\n // failure based on types.\n export const unusedValueExportToPlacateAjd = 1;\n \n+/**\n+ * Parsed ICU expression\n+ */\n export interface IcuExpression {\n   type: IcuType;\n   mainBinding: number;\n   cases: string[];\n   values: (string|IcuExpression)[][];\n }\n \n-export interface IcuCase {\n-  /**\n-   * Number of slots to allocate in expando for this case.\n-   *\n-   * This is the max number of DOM elements which will be created by this i18n + ICU blocks. When\n-   * the DOM elements are being created they are stored in the EXPANDO, so that update OpCodes can\n-   * write into them.\n-   */\n-  vars: number;\n+let _icuContainerIterate: (tIcuContainerNode: TIcuContainerNode, lView: LView) =>\n+    (() => RNode | null);\n \n-  /**\n-   * An optional array of child/sub ICUs.\n-   */\n-  childIcus: number[];\n+/**\n+ * Iterator which provides ability to visit all of the `TIcuContainerNode` root `RNode`s.\n+ */\n+export function icuContainerIterate(tIcuContainerNode: TIcuContainerNode, lView: LView): () =>\n+    RNode | null {\n+  return _icuContainerIterate(tIcuContainerNode, lView);\n+}\n \n-  /**\n-   * A set of OpCodes to apply in order to build up the DOM render tree for the ICU\n-   */\n-  create: I18nMutateOpCodes;\n+/**\n+ * Ensures that `IcuContainerVisitor`'s implementation is present.\n+ *\n+ * This function is invoked when i18n instruction comes across an ICU. The purpose is to allow the\n+ * bundler to tree shake ICU logic and only load it if ICU instruction is executed.\n+ */\n+export function ensureIcuContainerVisitorLoaded(\n+    loader: () => ((tIcuContainerNode: TIcuContainerNode, lView: LView) => (() => RNode | null))) {\n+  if (_icuContainerIterate === undefined) {\n+    // Do not inline this function. We want to keep `ensureIcuContainerVisitorLoaded` light, so it\n+    // can be inlined into call-site.\n+    _icuContainerIterate = loader();\n+  }\n+}\n \n-  /**\n-   * A set of OpCodes to apply in order to destroy the DOM render tree for the ICU.\n-   */\n-  remove: I18nMutateOpCodes;\n \n-  /**\n-   * A set of OpCodes to apply in order to update the DOM render tree for the ICU bindings.\n-   */\n-  update: I18nUpdateOpCodes;\n-}\n+/**\n+ * Returns current ICU case.\n+ *\n+ * We store negative numbers for cases which have just been switched. This function removes that.\n+ */\n+export function getCurrentICUCaseIndex(tIcu: TIcu, lView: LView) {\n+  const currentCase: number|null = lView[tIcu.currentCaseLViewIndex];\n+  return currentCase === null ? currentCase : (currentCase < 0 ? ~currentCase : currentCase);\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "a8b71f46d747df1f916753a4adef5a6decccb029",
            "filename": "packages/core/src/render3/interfaces/node.ts",
            "status": "modified",
            "additions": 82,
            "deletions": 2,
            "changes": 84,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fnode.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fnode.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fnode.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -7,6 +7,7 @@\n  */\n import {KeyValueArray} from '../../util/array_utils';\n import {TStylingRange} from '../interfaces/styling';\n+import {TIcu} from './i18n';\n import {CssSelector} from './projection';\n import {RNode} from './renderer';\n import {LView, TView} from './view';\n@@ -16,9 +17,11 @@ import {LView, TView} from './view';\n  * TNodeType corresponds to the {@link TNode} `type` property.\n  */\n export const enum TNodeType {\n+  // FIXME(misko): Add `Text` type so that it would be much easier to reason/debug about `TNode`s.\n   /**\n    * The TNode contains information about an {@link LContainer} for embedded views.\n    */\n+  // FIXME(misko): Verify that we still need a `Container`, at the very least update the text.\n   Container = 0,\n   /**\n    * The TNode contains information about an `<ng-content>` projection\n@@ -36,6 +39,20 @@ export const enum TNodeType {\n    * The TNode contains information about an ICU comment used in `i18n`.\n    */\n   IcuContainer = 4,\n+  /**\n+   * Special node type representing a placeholder for future `TNode` at this location.\n+   *\n+   * I18n translation blocks are created before the element nodes which they contain. (I18n blocks\n+   * can span over many elements.) Because i18n `TNode`s (representing text) are created first they\n+   * often may need to point to element `TNode`s which are not yet created. In such a case we create\n+   * a `Placeholder` `TNode`. This allows the i18n to structurally link the `TNode`s together\n+   * without knowing any information about the future nodes which will be at that location.\n+   *\n+   * On `firstCreatePass` When element instruction executes it will try to create a `TNode` at that\n+   * location. Seeing a `Placeholder` `TNode` already there tells the system that it should reuse\n+   * existing `TNode` (rather than create a new one) and just update the missing information.\n+   */\n+  Placeholder = 5,\n }\n \n /**\n@@ -47,7 +64,8 @@ export const TNodeTypeAsString = [\n   'Projection',        // 1\n   'Element',           // 2\n   'ElementContainer',  // 3\n-  'IcuContainer'       // 4\n+  'IcuContainer',      // 4\n+  'Placeholder',       // 5\n ] as const;\n \n \n@@ -293,6 +311,59 @@ export interface TNode {\n    */\n   index: number;\n \n+  /**\n+   * Insert before existing DOM node index.\n+   *\n+   * When DOM nodes are being inserted, normally they are being appended as they are created.\n+   * Under i18n case, the translated text nodes are created ahead of time as part of the\n+   * `ɵɵi18nStart` instruction which means that this `TNode` can't just be appended and instead\n+   * needs to be inserted using `insertBeforeIndex` semantics.\n+   *\n+   * Additionally sometimes it is necessary to insert new text nodes as a child of this `TNode`. In\n+   * such a case the value stores an array of text nodes to insert.\n+   *\n+   * Example:\n+   * ```\n+   * <div i18n>\n+   *   Hello <span>World</span>!\n+   * </div>\n+   * ```\n+   * In the above example the `ɵɵi18nStart` instruction can create `Hello `, `World` and `!` text\n+   * nodes. It can also insert `Hello ` and `!` text node as a child of `<div>`, but it can't\n+   * insert `World` because the `<span>` node has not yet been created. In such a case the\n+   * `<span>` `TNode` will have an array which will direct the `<span>` to not only insert\n+   * itself in front of `!` but also to insert the `World` (created by `ɵɵi18nStart`) into `<span>`\n+   * itself.\n+   *\n+   * Pseudo code:\n+   * ```\n+   *   if (insertBeforeIndex === null) {\n+   *     // append as normal\n+   *   } else if (Array.isArray(insertBeforeIndex)) {\n+   *     // First insert current `TNode` at correct location\n+   *     const currentNode = lView[this.index];\n+   *     parentNode.insertBefore(currentNode, lView[this.insertBeforeIndex[0]]);\n+   *     // Now append all of the children\n+   *     for(let i=1; i<this.insertBeforeIndex; i++) {\n+   *       currentNode.appendChild(lView[this.insertBeforeIndex[i]]);\n+   *     }\n+   *   } else {\n+   *     parentNode.insertBefore(lView[this.index], lView[this.insertBeforeIndex])\n+   *   }\n+   * ```\n+   * - null: Append as normal using `parentNode.appendChild`\n+   * - `number`: Append using\n+   *      `parentNode.insertBefore(lView[this.index], lView[this.insertBeforeIndex])`\n+   *\n+   * *Initialization*\n+   *\n+   * Because `ɵɵi18nStart` executes before nodes are created, on `TView.firstCreatePass` it is not\n+   * possible for `ɵɵi18nStart` to set the `insertBeforeIndex` value as the corresponding `TNode`\n+   * has not yet been created. For this reason the `ɵɵi18nStart` creates a `TNodeType.Placeholder`\n+   * `TNode` at that location. See `TNodeType.Placeholder` for more information.\n+   */\n+  insertBeforeIndex: InsertBeforeIndex;\n+\n   /**\n    * The index of the closest injector in this node's LView.\n    *\n@@ -357,6 +428,8 @@ export interface TNode {\n   providerIndexes: TNodeProviderIndexes;\n \n   /** The tag name associated with this node. */\n+  // FIXME(misko): rename to `value` and change the type to `any` so that\n+  // subclasses of `TNode` can use it to link additional payload\n   tagName: string|null;\n \n   /**\n@@ -643,6 +716,11 @@ export interface TNode {\n   styleBindings: TStylingRange;\n }\n \n+/**\n+ * See `TNode.insertBeforeIndex`\n+ */\n+export type InsertBeforeIndex = null|number|number[];\n+\n /** Static data for an element  */\n export interface TElementNode extends TNode {\n   /** Index in the data[] array */\n@@ -715,10 +793,12 @@ export interface TElementContainerNode extends TNode {\n export interface TIcuContainerNode extends TNode {\n   /** Index in the LView[] array. */\n   index: number;\n-  child: TElementNode|TTextNode|null;\n+  child: null;\n   parent: TElementNode|TElementContainerNode|null;\n   tViews: null;\n   projection: null;\n+  // FIXME(misko): Refactor to enable the next line\n+  // tagName: TIcu;\n }\n \n /** Static data for an LProjectionNode  */"
        },
        {
            "sha": "83ce29fbaf2e8cdfd663b2897d7e657db4c707f9",
            "filename": "packages/core/src/render3/interfaces/renderer.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Frenderer.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Frenderer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Frenderer.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -74,7 +74,7 @@ export interface ProceduralRenderer3 {\n    */\n   destroyNode?: ((node: RNode) => void)|null;\n   appendChild(parent: RElement, newChild: RNode): void;\n-  insertBefore(parent: RNode, newChild: RNode, refChild: RNode|null): void;\n+  insertBefore(parent: RNode, newChild: RNode, refChild: RNode|null, isMove?: boolean): void;\n   removeChild(parent: RElement, oldChild: RNode, isHostElement?: boolean): void;\n   selectRootElement(selectorOrNode: string|any, preserveContent?: boolean): RElement;\n "
        },
        {
            "sha": "ca2c4156949f2ddff475c946612adc34eef3628f",
            "filename": "packages/core/src/render3/interfaces/view.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 7,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fview.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fview.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fview.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -14,7 +14,7 @@ import {Sanitizer} from '../../sanitization/sanitizer';\n \n import {LContainer} from './container';\n import {ComponentDef, ComponentTemplate, DirectiveDef, DirectiveDefList, HostBindingsFunction, PipeDef, PipeDefList, ViewQueriesFunction} from './definition';\n-import {I18nUpdateOpCodes, TI18n} from './i18n';\n+import {I18nUpdateOpCodes, TI18n, TIcu} from './i18n';\n import {TConstants, TNode, TNodeTypeAsString} from './node';\n import {PlayerHandler} from './player';\n import {LQueries, TQueries} from './query';\n@@ -839,7 +839,7 @@ export type DestroyHookData = (HookEntry|HookData)[];\n  */\n export type TData =\n     (TNode|PipeDef<any>|DirectiveDef<any>|ComponentDef<any>|number|TStylingRange|TStylingKey|\n-     Type<any>|InjectionToken<any>|TI18n|I18nUpdateOpCodes|null|string)[];\n+     Type<any>|InjectionToken<any>|TI18n|I18nUpdateOpCodes|TIcu|null|string)[];\n \n // Note: This hack is necessary so we don't erroneously get a circular dependency\n // failure based on types.\n@@ -872,6 +872,11 @@ export interface LViewDebug {\n     indexWithinInitPhase: number,\n   };\n \n+  /**\n+   * Associated TView\n+   */\n+  readonly tView: TView;\n+\n   /**\n    * Parent view (or container)\n    */\n@@ -894,6 +899,12 @@ export interface LViewDebug {\n    */\n   readonly nodes: DebugNode[];\n \n+  /**\n+   * Template structure (no instance data).\n+   * (Shows how TNodes are connected)\n+   */\n+  readonly template: string;\n+\n   /**\n    * HTML representation of the `LView`.\n    *\n@@ -921,11 +932,6 @@ export interface LViewDebug {\n    */\n   readonly vars: LViewDebugRange;\n \n-  /**\n-   * Sub range of `LView` containing i18n (translated DOM elements).\n-   */\n-  readonly i18n: LViewDebugRange;\n-\n   /**\n    * Sub range of `LView` containing expando (used by DI).\n    */"
        },
        {
            "sha": "fff333bff8ab7b0695b49d75416ea60f83e06fac",
            "filename": "packages/core/src/render3/node_manipulation.ts",
            "status": "modified",
            "additions": 193,
            "deletions": 76,
            "changes": 269,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fnode_manipulation.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fnode_manipulation.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fnode_manipulation.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -9,16 +9,17 @@\n import {ViewEncapsulation} from '../metadata/view';\n import {Renderer2} from '../render/api';\n import {addToArray, removeFromArray} from '../util/array_utils';\n-import {assertDefined, assertDomNode, assertEqual, assertString} from '../util/assert';\n+import {assertDefined, assertDomNode, assertEqual, assertIndexInRange, assertString} from '../util/assert';\n \n import {assertLContainer, assertLView, assertTNodeForLView} from './assert';\n import {attachPatchData} from './context_discovery';\n import {CONTAINER_HEADER_OFFSET, HAS_TRANSPLANTED_VIEWS, LContainer, MOVED_VIEWS, NATIVE, unusedValueExportToPlacateAjd as unused1} from './interfaces/container';\n import {ComponentDef} from './interfaces/definition';\n+import {icuContainerIterate} from './interfaces/i18n';\n import {NodeInjectorFactory} from './interfaces/injector';\n-import {TElementNode, TNode, TNodeFlags, TNodeType, TProjectionNode, unusedValueExportToPlacateAjd as unused2} from './interfaces/node';\n+import {TElementNode, TIcuContainerNode, TNode, TNodeFlags, TNodeType, TProjectionNode, unusedValueExportToPlacateAjd as unused2} from './interfaces/node';\n import {unusedValueExportToPlacateAjd as unused3} from './interfaces/projection';\n-import {isProceduralRenderer, ProceduralRenderer3, RElement, Renderer3, RNode, RText, unusedValueExportToPlacateAjd as unused4} from './interfaces/renderer';\n+import {isProceduralRenderer, ProceduralRenderer3, RComment, RElement, Renderer3, RNode, RText, unusedValueExportToPlacateAjd as unused4} from './interfaces/renderer';\n import {isLContainer, isLView} from './interfaces/type_checks';\n import {CHILD_HEAD, CLEANUP, DECLARATION_COMPONENT_VIEW, DECLARATION_LCONTAINER, DestroyHookData, FLAGS, HookData, HookFn, HOST, LView, LViewFlags, NEXT, PARENT, QUERIES, RENDERER, T_HOST, TVIEW, TView, TViewType, unusedValueExportToPlacateAjd as unused5} from './interfaces/view';\n import {assertNodeOfPossibleTypes, assertNodeType} from './node_assert';\n@@ -77,10 +78,10 @@ function applyToElementOrContainer(\n       if (beforeNode == null) {\n         nativeAppendChild(renderer, parent, rNode);\n       } else {\n-        nativeInsertBefore(renderer, parent, rNode, beforeNode || null);\n+        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n       }\n     } else if (action === WalkTNodeTreeAction.Insert && parent !== null) {\n-      nativeInsertBefore(renderer, parent, rNode, beforeNode || null);\n+      nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n     } else if (action === WalkTNodeTreeAction.Detach) {\n       nativeRemoveNode(renderer, rNode, isComponent);\n     } else if (action === WalkTNodeTreeAction.Destroy) {\n@@ -93,13 +94,44 @@ function applyToElementOrContainer(\n   }\n }\n \n-export function createTextNode(value: string, renderer: Renderer3): RText {\n+export function createTextNode(renderer: Renderer3, value: string): RText {\n   ngDevMode && ngDevMode.rendererCreateTextNode++;\n   ngDevMode && ngDevMode.rendererSetText++;\n   return isProceduralRenderer(renderer) ? renderer.createText(value) :\n                                           renderer.createTextNode(value);\n }\n \n+export function updateTextNode(renderer: Renderer3, rNode: RText, value: string): void {\n+  ngDevMode && ngDevMode.rendererSetText++;\n+  isProceduralRenderer(renderer) ? renderer.setValue(rNode, value) : rNode.textContent = value;\n+}\n+\n+export function createCommentNode(renderer: Renderer3, value: string): RComment {\n+  ngDevMode && ngDevMode.rendererCreateComment++;\n+  // isProceduralRenderer check is not needed because both `Renderer2` and `Renderer3` have the same\n+  // method name.\n+  return renderer.createComment(value);\n+}\n+\n+/**\n+ * Creates a native element from a tag name, using a renderer.\n+ * @param renderer A renderer to use\n+ * @param name the tag name\n+ * @param namespace Optional namespace for element.\n+ * @returns the element created\n+ */\n+export function createElementNode(\n+    renderer: Renderer3, name: string, namespace: string|null): RElement {\n+  ngDevMode && ngDevMode.rendererCreateElement++;\n+  if (isProceduralRenderer(renderer)) {\n+    return renderer.createElement(name, namespace);\n+  } else {\n+    return namespace === null ? renderer.createElement(name) :\n+                                renderer.createElementNS(namespace, name);\n+  }\n+}\n+\n+\n /**\n  * Removes all DOM elements associated with a view.\n  *\n@@ -479,11 +511,34 @@ function executeOnDestroys(tView: TView, lView: LView): void {\n  *   parent container, which itself is disconnected. For example the parent container is part\n  *   of a View which has not be inserted or is made for projection but has not been inserted\n  *   into destination.\n+ *\n+ * @param tView: Current `TView`.\n+ * @param tNode: `TNode` for which we wish to retrieve render parent.\n+ * @param lView: Current `LView`.\n  */\n-function getRenderParent(tView: TView, tNode: TNode, currentView: LView): RElement|null {\n+export function getParentRElement(tView: TView, tNode: TNode, lView: LView): RElement|null {\n+  return getClosestRElement(tView, tNode.parent, lView);\n+}\n+\n+/**\n+ * Get closest `RElement` or `null` if it can't be found.\n+ *\n+ * If `TNode` is `TNodeType.Element` => return `RElement` at `LView[tNode.index]` location.\n+ * If `TNode` is `TNodeType.ElementContainer|IcuContain` => return the parent (recursively).\n+ * If `TNode` is `null` then return host `RElement`:\n+ *   - return `null` if projection\n+ *   - return `null` if parent container is disconnected (we have no parent.)\n+ *\n+ * @param tView: Current `TView`.\n+ * @param tNode: `TNode` for which we wish to retrieve `RElement` (or `null` if host element is\n+ *     needed).\n+ * @param lView: Current `LView`.\n+ * @returns `null` if the `RElement` can't be determined at this time (no parent / projection)\n+ */\n+export function getClosestRElement(tView: TView, tNode: TNode|null, lView: LView): RElement|null {\n+  let parentTNode: TNode|null = tNode;\n   // Skip over element and ICU containers as those are represented by a comment node and\n   // can't be used as a render parent.\n-  let parentTNode = tNode.parent;\n   while (parentTNode != null &&\n          (parentTNode.type === TNodeType.ElementContainer ||\n           parentTNode.type === TNodeType.IcuContainer)) {\n@@ -496,21 +551,14 @@ function getRenderParent(tView: TView, tNode: TNode, currentView: LView): REleme\n   if (parentTNode === null) {\n     // We are inserting a root element of the component view into the component host element and\n     // it should always be eager.\n-    return currentView[HOST];\n+    return lView[HOST];\n   } else {\n-    const isIcuCase = tNode && tNode.type === TNodeType.IcuContainer;\n-    // If the parent of this node is an ICU container, then it is represented by comment node and we\n-    // need to use it as an anchor. If it is projected then it's direct parent node is the renderer.\n-    if (isIcuCase && tNode.flags & TNodeFlags.isProjected) {\n-      return getNativeByTNode(tNode, currentView).parentNode as RElement;\n-    }\n-\n-    ngDevMode && assertNodeType(parentTNode, TNodeType.Element);\n+    // ngDevMode && assertTNodeType(parentTNode, TNodeType.AnyRNode | TNodeType.Container);\n     if (parentTNode.flags & TNodeFlags.isComponentHost) {\n+      ngDevMode && assertTNodeForLView(parentTNode, lView);\n       const tData = tView.data;\n       const tNode = tData[parentTNode.index] as TNode;\n       const encapsulation = (tData[tNode.directiveStart] as ComponentDef<any>).encapsulation;\n-\n       // We've got a parent which is an element in the current view. We just need to verify if the\n       // parent element is not a component. Component's content nodes are not inserted immediately\n       // because they will be projected, and so doing insert at this point would be wasteful.\n@@ -523,7 +571,7 @@ function getRenderParent(tView: TView, tNode: TNode, currentView: LView): REleme\n       }\n     }\n \n-    return getNativeByTNode(parentTNode, currentView) as RElement;\n+    return getNativeByTNode(parentTNode, lView) as RElement;\n   }\n }\n \n@@ -533,12 +581,13 @@ function getRenderParent(tView: TView, tNode: TNode, currentView: LView): REleme\n  * actual renderer being used.\n  */\n export function nativeInsertBefore(\n-    renderer: Renderer3, parent: RElement, child: RNode, beforeNode: RNode|null): void {\n+    renderer: Renderer3, parent: RElement, child: RNode, beforeNode: RNode|null,\n+    isMove: boolean): void {\n   ngDevMode && ngDevMode.rendererInsertBefore++;\n   if (isProceduralRenderer(renderer)) {\n-    renderer.insertBefore(parent, child, beforeNode);\n+    renderer.insertBefore(parent, child, beforeNode, isMove);\n   } else {\n-    parent.insertBefore(child, beforeNode, true);\n+    parent.insertBefore(child, beforeNode, isMove);\n   }\n }\n \n@@ -553,9 +602,9 @@ function nativeAppendChild(renderer: Renderer3, parent: RElement, child: RNode):\n }\n \n function nativeAppendOrInsertBefore(\n-    renderer: Renderer3, parent: RElement, child: RNode, beforeNode: RNode|null) {\n+    renderer: Renderer3, parent: RElement, child: RNode, beforeNode: RNode|null, isMove: boolean) {\n   if (beforeNode !== null) {\n-    nativeInsertBefore(renderer, parent, child, beforeNode);\n+    nativeInsertBefore(renderer, parent, child, beforeNode, isMove);\n   } else {\n     nativeAppendChild(renderer, parent, child);\n   }\n@@ -586,43 +635,98 @@ export function nativeNextSibling(renderer: Renderer3, node: RNode): RNode|null\n }\n \n /**\n- * Finds a native \"anchor\" node for cases where we can't append a native child directly\n- * (`appendChild`) and need to use a reference (anchor) node for the `insertBefore` operation.\n- * @param parentTNode\n- * @param lView\n+ * Find a node in front of which `currentTNode` should be inserted.\n+ *\n+ * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n+ * takes `TNode.insertBeforeIndex` into account.\n+ *\n+ * @param parentTNode parent `TNode`\n+ * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n+ * @param lView current `LView`\n  */\n-function getNativeAnchorNode(parentTNode: TNode, lView: LView): RNode|null {\n-  if (parentTNode.type === TNodeType.ElementContainer ||\n-      parentTNode.type === TNodeType.IcuContainer) {\n-    return getNativeByTNode(parentTNode, lView);\n+function getInsertInFrontOfRNode(parentTNode: TNode, currentTNode: TNode, lView: LView): RNode|\n+    null {\n+  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;\n+  const insertBeforeIndex =\n+      Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;\n+  if (insertBeforeIndex === null) {\n+    if (parentTNode.type === TNodeType.ElementContainer ||\n+        parentTNode.type === TNodeType.IcuContainer) {\n+      return getNativeByTNode(parentTNode, lView);\n+    }\n+  } else {\n+    ngDevMode && assertIndexInRange(lView, insertBeforeIndex);\n+    return unwrapRNode(lView[insertBeforeIndex]);\n   }\n   return null;\n }\n \n /**\n  * Appends the `child` native node (or a collection of nodes) to the `parent`.\n  *\n- * The element insertion might be delayed {@link canInsertNativeNode}.\n- *\n  * @param tView The `TView' to be appended\n  * @param lView The current LView\n- * @param childEl The native child (or children) that should be appended\n+ * @param childRNode The native child (or children) that should be appended\n  * @param childTNode The TNode of the child element\n- * @returns Whether or not the child was appended\n  */\n export function appendChild(\n-    tView: TView, lView: LView, childEl: RNode|RNode[], childTNode: TNode): void {\n-  const renderParent = getRenderParent(tView, childTNode, lView);\n-  if (renderParent != null) {\n-    const renderer = lView[RENDERER];\n-    const parentTNode: TNode = childTNode.parent || lView[T_HOST]!;\n-    const anchorNode = getNativeAnchorNode(parentTNode, lView);\n-    if (Array.isArray(childEl)) {\n-      for (let i = 0; i < childEl.length; i++) {\n-        nativeAppendOrInsertBefore(renderer, renderParent, childEl[i], anchorNode);\n+    tView: TView, lView: LView, childRNode: RNode|RNode[], childTNode: TNode): void {\n+  const parentRNode = getParentRElement(tView, childTNode, lView);\n+  const renderer = lView[RENDERER];\n+  const parentTNode: TNode = childTNode.parent || lView[T_HOST]!;\n+  const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);\n+  if (parentRNode != null) {\n+    if (Array.isArray(childRNode)) {\n+      for (let i = 0; i < childRNode.length; i++) {\n+        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);\n       }\n     } else {\n-      nativeAppendOrInsertBefore(renderer, renderParent, childEl, anchorNode);\n+      nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);\n+    }\n+  }\n+\n+  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;\n+  if (Array.isArray(tNodeInsertBeforeIndex) &&\n+      (childTNode.flags & TNodeFlags.isComponentHost) === 0) {\n+    // An array indicates that there are i18n nodes that need to be added as children of this\n+    // `rChildNode`. These i18n nodes were created before this `rChildNode` was available and so\n+    // only now can be added. The first element of the array is the normal index where we should\n+    // insert the `rChildNode`. Additional elements are the extra nodes to be added as children of\n+    // `rChildNode`.\n+    processI18nText(renderer, childTNode, lView, childRNode, parentRNode, tNodeInsertBeforeIndex);\n+  }\n+}\n+\n+/**\n+ * Process `TNode.insertBeforeIndex` by adding i18n text nodes.\n+ *\n+ * See `TNode.insertBeforeIndex`\n+ *\n+ * @param renderer\n+ * @param childTNode\n+ * @param lView\n+ * @param childRNode\n+ * @param parentRElement\n+ * @param i18nChildren\n+ */\n+function processI18nText(\n+    renderer: Renderer3, childTNode: TNode, lView: LView, childRNode: RNode|RNode[],\n+    parentRElement: RElement|null, i18nChildren: number[]): void {\n+  ngDevMode && assertDomNode(childRNode);\n+  const isProcedural = isProceduralRenderer(renderer);\n+  let i18nParent: RElement|null = childRNode as RElement;\n+  let anchorRNode: RNode|null = null;\n+  if (childTNode.type !== TNodeType.Element) {\n+    anchorRNode = i18nParent;\n+    i18nParent = parentRElement;\n+  }\n+  const isViewRoot = childTNode.parent === null;\n+  if (i18nParent !== null) {\n+    for (let i = 1; i < i18nChildren.length; i++) {\n+      // No need to `unwrapRNode` because all of the indexes point to i18n text nodes.\n+      // see `assertDomNode` below.\n+      const i18nChild = lView[i18nChildren[i]];\n+      nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);\n     }\n   }\n }\n@@ -644,7 +748,7 @@ function getFirstNativeNode(lView: LView, tNode: TNode|null): RNode|null {\n       return getNativeByTNode(tNode, lView);\n     } else if (tNodeType === TNodeType.Container) {\n       return getBeforeNodeForView(-1, lView[tNode.index]);\n-    } else if (tNodeType === TNodeType.ElementContainer || tNodeType === TNodeType.IcuContainer) {\n+    } else if (tNodeType === TNodeType.ElementContainer) {\n       const elIcuContainerChild = tNode.child;\n       if (elIcuContainerChild !== null) {\n         return getFirstNativeNode(lView, elIcuContainerChild);\n@@ -656,6 +760,11 @@ function getFirstNativeNode(lView: LView, tNode: TNode|null): RNode|null {\n           return unwrapRNode(rNodeOrLContainer);\n         }\n       }\n+    } else if (tNodeType === TNodeType.IcuContainer) {\n+      let nextRNode = icuContainerIterate(tNode as TIcuContainerNode, lView);\n+      let rNode: RNode|null = nextRNode();\n+      // If the ICU container has no nodes, than we use the ICU anchor as the node.\n+      return rNode || unwrapRNode(lView[tNode.index]);\n     } else {\n       const componentView = lView[DECLARATION_COMPONENT_VIEW];\n       const componentHost = componentView[T_HOST] as TElementNode;\n@@ -698,6 +807,7 @@ export function getBeforeNodeForView(viewIndexInContainer: number, lContainer: L\n  * @param isHostElement A flag indicating if a node to be removed is a host of a component.\n  */\n export function nativeRemoveNode(renderer: Renderer3, rNode: RNode, isHostElement?: boolean): void {\n+  ngDevMode && ngDevMode.rendererRemoveNode++;\n   const nativeParent = nativeParentNode(renderer, rNode);\n   if (nativeParent) {\n     nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);\n@@ -711,7 +821,7 @@ export function nativeRemoveNode(renderer: Renderer3, rNode: RNode, isHostElemen\n  */\n function applyNodes(\n     renderer: Renderer3, action: WalkTNodeTreeAction, tNode: TNode|null, lView: LView,\n-    renderParent: RElement|null, beforeNode: RNode|null, isProjection: boolean) {\n+    parentRElement: RElement|null, beforeNode: RNode|null, isProjection: boolean) {\n   while (tNode != null) {\n     ngDevMode && assertTNodeForLView(tNode, lView);\n     ngDevMode && assertNodeOfPossibleTypes(tNode, [\n@@ -727,15 +837,22 @@ function applyNodes(\n       }\n     }\n     if ((tNode.flags & TNodeFlags.isDetached) !== TNodeFlags.isDetached) {\n-      if (tNodeType === TNodeType.ElementContainer || tNodeType === TNodeType.IcuContainer) {\n-        applyNodes(renderer, action, tNode.child, lView, renderParent, beforeNode, false);\n-        applyToElementOrContainer(action, renderer, renderParent, rawSlotValue, beforeNode);\n+      if (tNodeType === TNodeType.ElementContainer) {\n+        applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);\n+        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n+      } else if (tNodeType === TNodeType.IcuContainer) {\n+        const nextRNode = icuContainerIterate(tNode as TIcuContainerNode, lView);\n+        let rNode: RNode|null;\n+        while (rNode = nextRNode()) {\n+          applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n+        }\n+        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n       } else if (tNodeType === TNodeType.Projection) {\n         applyProjectionRecursive(\n-            renderer, action, lView, tNode as TProjectionNode, renderParent, beforeNode);\n+            renderer, action, lView, tNode as TProjectionNode, parentRElement, beforeNode);\n       } else {\n         ngDevMode && assertNodeOfPossibleTypes(tNode, [TNodeType.Element, TNodeType.Container]);\n-        applyToElementOrContainer(action, renderer, renderParent, rawSlotValue, beforeNode);\n+        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n       }\n     }\n     tNode = isProjection ? tNode.projectionNext : tNode.next;\n@@ -763,19 +880,19 @@ function applyNodes(\n  * @param lView The LView which needs to be inserted, detached, destroyed.\n  * @param renderer Renderer to use\n  * @param action action to perform (insert, detach, destroy)\n- * @param renderParent parent DOM element for insertion (Removal does not need it).\n+ * @param parentRElement parent DOM element for insertion (Removal does not need it).\n  * @param beforeNode Before which node the insertions should happen.\n  */\n function applyView(\n     tView: TView, lView: LView, renderer: Renderer3, action: WalkTNodeTreeAction.Destroy,\n-    renderParent: null, beforeNode: null): void;\n+    parentRElement: null, beforeNode: null): void;\n function applyView(\n     tView: TView, lView: LView, renderer: Renderer3, action: WalkTNodeTreeAction,\n-    renderParent: RElement|null, beforeNode: RNode|null): void;\n+    parentRElement: RElement|null, beforeNode: RNode|null): void;\n function applyView(\n     tView: TView, lView: LView, renderer: Renderer3, action: WalkTNodeTreeAction,\n-    renderParent: RElement|null, beforeNode: RNode|null): void {\n-  applyNodes(renderer, action, tView.firstChild, lView, renderParent, beforeNode, false);\n+    parentRElement: RElement|null, beforeNode: RNode|null): void {\n+  applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);\n }\n \n /**\n@@ -790,11 +907,11 @@ function applyView(\n  */\n export function applyProjection(tView: TView, lView: LView, tProjectionNode: TProjectionNode) {\n   const renderer = lView[RENDERER];\n-  const renderParent = getRenderParent(tView, tProjectionNode, lView);\n+  const parentRNode = getParentRElement(tView, tProjectionNode, lView);\n   const parentTNode = tProjectionNode.parent || lView[T_HOST]!;\n-  let beforeNode = getNativeAnchorNode(parentTNode, lView);\n+  let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);\n   applyProjectionRecursive(\n-      renderer, WalkTNodeTreeAction.Create, lView, tProjectionNode, renderParent, beforeNode);\n+      renderer, WalkTNodeTreeAction.Create, lView, tProjectionNode, parentRNode, beforeNode);\n }\n \n /**\n@@ -808,12 +925,12 @@ export function applyProjection(tView: TView, lView: LView, tProjectionNode: TPr\n  * @param action action to perform (insert, detach, destroy)\n  * @param lView The LView which needs to be inserted, detached, destroyed.\n  * @param tProjectionNode node to project\n- * @param renderParent parent DOM element for insertion/removal.\n+ * @param parentRElement parent DOM element for insertion/removal.\n  * @param beforeNode Before which node the insertions should happen.\n  */\n function applyProjectionRecursive(\n     renderer: Renderer3, action: WalkTNodeTreeAction, lView: LView,\n-    tProjectionNode: TProjectionNode, renderParent: RElement|null, beforeNode: RNode|null) {\n+    tProjectionNode: TProjectionNode, parentRElement: RElement|null, beforeNode: RNode|null) {\n   const componentLView = lView[DECLARATION_COMPONENT_VIEW];\n   const componentNode = componentLView[T_HOST] as TElementNode;\n   ngDevMode &&\n@@ -827,13 +944,13 @@ function applyProjectionRecursive(\n     // This should be refactored and cleaned up.\n     for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {\n       const rNode = nodeToProjectOrRNodes[i];\n-      applyToElementOrContainer(action, renderer, renderParent, rNode, beforeNode);\n+      applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n     }\n   } else {\n     let nodeToProject: TNode|null = nodeToProjectOrRNodes;\n     const projectedComponentLView = componentLView[PARENT] as LView;\n     applyNodes(\n-        renderer, action, nodeToProject, projectedComponentLView, renderParent, beforeNode, true);\n+        renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);\n   }\n }\n \n@@ -848,31 +965,31 @@ function applyProjectionRecursive(\n  * @param renderer Renderer to use\n  * @param action action to perform (insert, detach, destroy)\n  * @param lContainer The LContainer which needs to be inserted, detached, destroyed.\n- * @param renderParent parent DOM element for insertion/removal.\n+ * @param parentRElement parent DOM element for insertion/removal.\n  * @param beforeNode Before which node the insertions should happen.\n  */\n function applyContainer(\n     renderer: Renderer3, action: WalkTNodeTreeAction, lContainer: LContainer,\n-    renderParent: RElement|null, beforeNode: RNode|null|undefined) {\n+    parentRElement: RElement|null, beforeNode: RNode|null|undefined) {\n   ngDevMode && assertLContainer(lContainer);\n   const anchor = lContainer[NATIVE];  // LContainer has its own before node.\n   const native = unwrapRNode(lContainer);\n   // An LContainer can be created dynamically on any node by injecting ViewContainerRef.\n-  // Asking for a ViewContainerRef on an element will result in a creation of a separate anchor node\n-  // (comment in the DOM) that will be different from the LContainer's host node. In this particular\n-  // case we need to execute action on 2 nodes:\n+  // Asking for a ViewContainerRef on an element will result in a creation of a separate anchor\n+  // node (comment in the DOM) that will be different from the LContainer's host node. In this\n+  // particular case we need to execute action on 2 nodes:\n   // - container's host node (this is done in the executeActionOnElementOrContainer)\n   // - container's host node (this is done here)\n   if (anchor !== native) {\n-    // This is very strange to me (Misko). I would expect that the native is same as anchor. I don't\n-    // see a reason why they should be different, but they are.\n+    // This is very strange to me (Misko). I would expect that the native is same as anchor. I\n+    // don't see a reason why they should be different, but they are.\n     //\n     // If they are we need to process the second anchor as well.\n-    applyToElementOrContainer(action, renderer, renderParent, anchor, beforeNode);\n+    applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);\n   }\n   for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n     const lView = lContainer[i] as LView;\n-    applyView(lView[TVIEW], lView, renderer, action, renderParent, anchor);\n+    applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);\n   }\n }\n \n@@ -908,8 +1025,8 @@ export function applyStyling(\n       }\n     }\n   } else {\n-    // TODO(misko): Can't import RendererStyleFlags2.DashCase as it causes imports to be resolved in\n-    // different order which causes failures. Using direct constant as workaround for now.\n+    // TODO(misko): Can't import RendererStyleFlags2.DashCase as it causes imports to be resolved\n+    // in different order which causes failures. Using direct constant as workaround for now.\n     const flags = prop.indexOf('-') == -1 ? undefined : 2 /* RendererStyleFlags2.DashCase */;\n     if (value == null /** || value === undefined */) {\n       ngDevMode && ngDevMode.rendererRemoveStyle++;"
        },
        {
            "sha": "6b0f15a13eb3897f1208014ced90d27f45c05fb3",
            "filename": "packages/core/src/render3/state.ts",
            "status": "modified",
            "additions": 72,
            "deletions": 21,
            "changes": 93,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fstate.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fstate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fstate.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -6,10 +6,10 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {assertDefined, assertEqual} from '../util/assert';\n+import {assertDefined, assertEqual, assertNotEqual} from '../util/assert';\n import {assertLViewOrUndefined, assertTNodeForTView} from './assert';\n import {DirectiveDef} from './interfaces/definition';\n-import {TNode} from './interfaces/node';\n+import {TNode, TNodeType} from './interfaces/node';\n import {CONTEXT, DECLARATION_VIEW, LView, OpaqueViewState, TData, TVIEW, TView} from './interfaces/view';\n import {MATH_ML_NAMESPACE, SVG_NAMESPACE} from './namespaces';\n import {getTNode} from './util/view_utils';\n@@ -116,6 +116,22 @@ interface LFrame {\n    * `LView[currentDirectiveIndex]` is directive instance.\n    */\n   currentDirectiveIndex: number;\n+\n+  /**\n+   * Are we currently in i18n block as denoted by `ɵɵelementStart` and `ɵɵelementEnd`.\n+   *\n+   * This information is needed because while we are in i18n block all elements must be pre-declared\n+   * in the translation. (i.e. `Hello �#2�World�/#2�!` pre-declares element at `�#2�` location.)\n+   * This allocates `TNodeType.Placeholder` element at location `2`. If translator removes `�#2�`\n+   * from translation than the runtime must also ensure tha element at `2` does not get inserted\n+   * into the DOM. The translation does not carry information about deleted elements. Therefor the\n+   * only way to know that an element is deleted is that it was not pre-declared in the translation.\n+   *\n+   * This flag works by ensuring that elements which are created without pre-declaration\n+   * (`TNodeType.Placeholder`) are not inserted into the DOM render tree. (It does mean that the\n+   * element still gets instantiated along with all of its behavior [directives])\n+   */\n+  inI18n: boolean;\n }\n \n /**\n@@ -166,12 +182,21 @@ interface InstructionState {\n   isInCheckNoChangesMode: boolean;\n }\n \n-export const instructionState: InstructionState = {\n+const instructionState: InstructionState = {\n   lFrame: createLFrame(null),\n   bindingsEnabled: true,\n   isInCheckNoChangesMode: false,\n };\n \n+/**\n+ * Returns true if the instruction state stack is empty.\n+ *\n+ * Intended to be called from tests only (tree shaken otherwise).\n+ */\n+export function specOnlyIsInstructionStateEmpty(): boolean {\n+  return instructionState.lFrame.parent === null;\n+}\n+\n \n export function getElementDepthCount() {\n   return instructionState.lFrame.elementDepthCount;\n@@ -265,14 +290,30 @@ export function ɵɵrestoreView(viewToRestore: OpaqueViewState) {\n   instructionState.lFrame.contextLView = viewToRestore as any as LView;\n }\n \n+\n export function getCurrentTNode(): TNode|null {\n+  let currentTNode = getCurrentTNodePlaceholderOk();\n+  while (currentTNode !== null && currentTNode.type === TNodeType.Placeholder) {\n+    currentTNode = currentTNode.parent;\n+  }\n+  return currentTNode;\n+}\n+\n+export function getCurrentTNodePlaceholderOk(): TNode|null {\n   return instructionState.lFrame.currentTNode;\n }\n \n-export function setCurrentTNode(tNode: TNode, isParent: boolean) {\n-  ngDevMode && assertTNodeForTView(tNode, instructionState.lFrame.tView);\n-  instructionState.lFrame.currentTNode = tNode;\n-  instructionState.lFrame.isParent = isParent;\n+export function getCurrentParentTNode(): TNode|null {\n+  const lFrame = instructionState.lFrame;\n+  const currentTNode = lFrame.currentTNode;\n+  return lFrame.isParent ? currentTNode : currentTNode!.parent;\n+}\n+\n+export function setCurrentTNode(tNode: TNode|null, isParent: boolean) {\n+  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);\n+  const lFrame = instructionState.lFrame;\n+  lFrame.currentTNode = tNode;\n+  lFrame.isParent = isParent;\n }\n \n export function isCurrentTNodeParent(): boolean {\n@@ -328,6 +369,14 @@ export function incrementBindingIndex(count: number): number {\n   return index;\n }\n \n+export function isInI18nBlock() {\n+  return instructionState.lFrame.inI18n;\n+}\n+\n+export function setInI18nBlock(isInI18nBlock: boolean): void {\n+  instructionState.lFrame.inI18n = isInI18nBlock;\n+}\n+\n /**\n  * Set a new binding root index so that host template functions can execute.\n  *\n@@ -429,6 +478,7 @@ export function enterView(newView: LView): void {\n   newLFrame.tView = tView;\n   newLFrame.contextLView = newView!;\n   newLFrame.bindingIndex = tView.bindingStartIndex;\n+  newLFrame.inI18n = false;\n }\n \n /**\n@@ -443,20 +493,21 @@ function allocLFrame() {\n \n function createLFrame(parent: LFrame|null): LFrame {\n   const lFrame: LFrame = {\n-    currentTNode: null,         //\n-    isParent: true,             //\n-    lView: null!,               //\n-    tView: null!,               //\n-    selectedIndex: 0,           //\n-    contextLView: null!,        //\n-    elementDepthCount: 0,       //\n-    currentNamespace: null,     //\n-    currentDirectiveIndex: -1,  //\n-    bindingRootIndex: -1,       //\n-    bindingIndex: -1,           //\n-    currentQueryIndex: 0,       //\n-    parent: parent!,            //\n-    child: null,                //\n+    currentTNode: null,\n+    isParent: true,\n+    lView: null!,\n+    tView: null!,\n+    selectedIndex: 0,\n+    contextLView: null!,\n+    elementDepthCount: 0,\n+    currentNamespace: null,\n+    currentDirectiveIndex: -1,\n+    bindingRootIndex: -1,\n+    bindingIndex: -1,\n+    currentQueryIndex: 0,\n+    parent: parent!,\n+    child: null,\n+    inI18n: false,\n   };\n   parent !== null && (parent.child = lFrame);  // link the new LFrame for reuse.\n   return lFrame;"
        },
        {
            "sha": "bd95000995c03c0f16a8e02a42650557b38aa8e1",
            "filename": "packages/core/src/render3/util/view_utils.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Futil%2Fview_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Futil%2Fview_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Futil%2Fview_utils.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -7,10 +7,10 @@\n  */\n \n import {assertDefined, assertDomNode, assertGreaterThan, assertIndexInRange, assertLessThan} from '../../util/assert';\n-import {assertTNodeForLView} from '../assert';\n+import {assertTNode, assertTNodeForLView} from '../assert';\n import {LContainer, TYPE} from '../interfaces/container';\n import {LContext, MONKEY_PATCH_KEY_NAME} from '../interfaces/context';\n-import {TConstants, TNode, TNodeType} from '../interfaces/node';\n+import {TConstants, TNode} from '../interfaces/node';\n import {isProceduralRenderer, RNode} from '../interfaces/renderer';\n import {isLContainer, isLView} from '../interfaces/type_checks';\n import {FLAGS, HEADER_OFFSET, HOST, LView, LViewFlags, PARENT, PREORDER_HOOK_FLAGS, RENDERER, TData, TRANSPLANTED_VIEWS_TO_REFRESH, TView} from '../interfaces/view';\n@@ -117,10 +117,13 @@ export function getNativeByTNodeOrNull(tNode: TNode|null, lView: LView): RNode|n\n }\n \n \n+// fixme(misko): The return Type should be `TNode|null`\n export function getTNode(tView: TView, index: number): TNode {\n   ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\n-  ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');\n-  return tView.data[index + HEADER_OFFSET] as TNode;\n+  ngDevMode && assertLessThan(index, tView.data.length - HEADER_OFFSET, 'wrong index for TNode');\n+  const tNode = tView.data[index + HEADER_OFFSET] as TNode;\n+  ngDevMode && tNode !== null && assertTNode(tNode);\n+  return tNode;\n }\n \n /** Retrieves a value from any `LView` or `TData`. */"
        },
        {
            "sha": "415b13998ecb636ce531fe4d38b8e99bb37e69c0",
            "filename": "packages/core/src/render3/view_engine_compatibility.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 6,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fview_engine_compatibility.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fview_engine_compatibility.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fview_engine_compatibility.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -20,7 +20,7 @@ import {assertDefined, assertEqual, assertGreaterThan, assertLessThan} from '../\n \n import {assertLContainer, assertNodeInjector} from './assert';\n import {getParentInjectorLocation, NodeInjector} from './di';\n-import {addToViewTree, createLContainer, createLView, renderView} from './instructions/shared';\n+import {addToViewTree, createLContainer, createLView, createTNode, renderView} from './instructions/shared';\n import {CONTAINER_HEADER_OFFSET, LContainer, NATIVE, VIEW_REFS} from './interfaces/container';\n import {NodeInjectorOffset} from './interfaces/injector';\n import {TContainerNode, TDirectiveHostNode, TElementContainerNode, TElementNode, TNode, TNodeType} from './interfaces/node';\n@@ -287,9 +287,9 @@ export function createContainerRef(\n         // Physical operation of adding the DOM nodes.\n         const beforeNode = getBeforeNodeForView(adjustedIdx, lContainer);\n         const renderer = lView[RENDERER];\n-        const renderParent = nativeParentNode(renderer, lContainer[NATIVE] as RElement | RComment);\n-        if (renderParent !== null) {\n-          addViewToContainer(tView, lContainer[T_HOST], renderer, lView, renderParent, beforeNode);\n+        const parentRNode = nativeParentNode(renderer, lContainer[NATIVE] as RElement | RComment);\n+        if (parentRNode !== null) {\n+          addViewToContainer(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);\n         }\n \n         (viewRef as ViewRef<any>).attachToViewContainerRef(this);\n@@ -388,9 +388,14 @@ export function createContainerRef(\n         const hostNative = getNativeByTNode(hostTNode, hostView)!;\n         const parentOfHostNative = nativeParentNode(renderer, hostNative);\n         nativeInsertBefore(\n-            renderer, parentOfHostNative!, commentNode, nativeNextSibling(renderer, hostNative));\n+            renderer, parentOfHostNative!, commentNode, nativeNextSibling(renderer, hostNative),\n+            false);\n       } else {\n-        appendChild(hostView[TVIEW], hostView, commentNode, hostTNode);\n+        // The TNode created here is bogus, in that it is not added to the TView. It is only created\n+        // to allow us to create a dynamic Comment node.\n+        const commentTNode = createTNode(\n+            hostView[TVIEW], hostTNode.parent, TNodeType.Container, hostTNode.type, null, null);\n+        appendChild(hostView[TVIEW], hostView, commentNode, commentTNode);\n       }\n     }\n "
        },
        {
            "sha": "5db245b0f185e19d8c5312b4ceeb6ac58ab81ec7",
            "filename": "packages/core/src/render3/view_ref.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 3,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fview_ref.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Frender3%2Fview_ref.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fview_ref.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -11,11 +11,14 @@ import {ChangeDetectorRef as viewEngine_ChangeDetectorRef} from '../change_detec\n import {ViewContainerRef as viewEngine_ViewContainerRef} from '../linker/view_container_ref';\n import {EmbeddedViewRef as viewEngine_EmbeddedViewRef, InternalViewRef as viewEngine_InternalViewRef} from '../linker/view_ref';\n import {assertDefined} from '../util/assert';\n+\n import {checkNoChangesInRootView, checkNoChangesInternal, detectChangesInRootView, detectChangesInternal, markViewDirty, storeCleanupWithContext} from './instructions/shared';\n import {CONTAINER_HEADER_OFFSET} from './interfaces/container';\n-import {TElementNode, TNode, TNodeType} from './interfaces/node';\n+import {icuContainerIterate} from './interfaces/i18n';\n+import {TElementNode, TIcuContainerNode, TNode, TNodeType} from './interfaces/node';\n+import {RNode} from './interfaces/renderer';\n import {isLContainer} from './interfaces/type_checks';\n-import {CONTEXT, DECLARATION_COMPONENT_VIEW, FLAGS, HOST, LView, LViewFlags, T_HOST, TVIEW, TView} from './interfaces/view';\n+import {CONTEXT, DECLARATION_COMPONENT_VIEW, FLAGS, LView, LViewFlags, T_HOST, TVIEW, TView} from './interfaces/view';\n import {assertNodeOfPossibleTypes} from './node_assert';\n import {destroyLView, renderDetachView} from './node_manipulation';\n import {getLViewParent} from './util/view_traversal_utils';\n@@ -346,8 +349,14 @@ function collectNativeNodes(\n     }\n \n     const tNodeType = tNode.type;\n-    if (tNodeType === TNodeType.ElementContainer || tNodeType === TNodeType.IcuContainer) {\n+    if (tNodeType === TNodeType.ElementContainer) {\n       collectNativeNodes(tView, lView, tNode.child, result);\n+    } else if (tNodeType === TNodeType.IcuContainer) {\n+      const nextRNode = icuContainerIterate(tNode as TIcuContainerNode, lView);\n+      let rNode: RNode|null;\n+      while (rNode = nextRNode()) {\n+        result.push(rNode);\n+      }\n     } else if (tNodeType === TNodeType.Projection) {\n       const componentView = lView[DECLARATION_COMPONENT_VIEW];\n       const componentHost = componentView[T_HOST] as TElementNode;"
        },
        {
            "sha": "5fdd5bf0b55e4c141750a203c5986d908eea2535",
            "filename": "packages/core/src/util/assert.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 6,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Futil%2Fassert.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Futil%2Fassert.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Futil%2Fassert.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -102,18 +102,25 @@ export function throwError(msg: string, actual?: any, expected?: any, comparison\n \n export function assertDomNode(node: any): asserts node is Node {\n   // If we're in a worker, `Node` will not be defined.\n-  assertEqual(\n-      (typeof Node !== 'undefined' && node instanceof Node) ||\n-          (typeof node === 'object' && node != null &&\n-           node.constructor.name === 'WebWorkerRenderNode'),\n-      true, `The provided value must be an instance of a DOM Node but got ${stringify(node)}`);\n+  if (!(typeof Node !== 'undefined' && node instanceof Node) &&\n+      !(typeof node === 'object' && node != null &&\n+        node.constructor.name === 'WebWorkerRenderNode')) {\n+    throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);\n+  }\n }\n \n \n export function assertIndexInRange(arr: any[], index: number) {\n   assertDefined(arr, 'Array must be defined.');\n   const maxLen = arr.length;\n-  if (index < 0 || index > maxLen) {\n+  if (index < 0 || index >= maxLen) {\n     throwError(`Index expected to be less than ${maxLen} but got ${index}`);\n   }\n }\n+\n+\n+export function assertOneOf(value: any, ...validValues: any[]) {\n+  if (validValues.indexOf(value) !== -1) return true;\n+  throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${\n+      JSON.stringify(value)}.`);\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "0a6fe41461d0b63e7799b8a8185d37817a9b6599",
            "filename": "packages/core/src/util/char_code.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Futil%2Fchar_code.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Futil%2Fchar_code.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Futil%2Fchar_code.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -12,10 +12,24 @@\n export const enum CharCode {\n   UPPER_CASE = ~32,   // & with this will make the char uppercase\n   SPACE = 32,         // \" \"\n+  EXCLAMATION = 33,   // \"!\"\n   DOUBLE_QUOTE = 34,  // \"\\\"\"\n+  HASH = 35,          // \"#\"\n   SINGLE_QUOTE = 39,  // \"'\"\n   OPEN_PAREN = 40,    // \"(\"\n   CLOSE_PAREN = 41,   // \")\"\n+  STAR = 42,          // \"*\"\n+  SLASH = 47,         // \"/\"\n+  _0 = 48,            // \"0\"\n+  _1 = 49,            // \"1\"\n+  _2 = 50,            // \"2\"\n+  _3 = 51,            // \"3\"\n+  _4 = 52,            // \"4\"\n+  _5 = 53,            // \"5\"\n+  _6 = 54,            // \"6\"\n+  _7 = 55,            // \"7\"\n+  _8 = 56,            // \"8\"\n+  _9 = 57,            // \"9\"\n   COLON = 58,         // \":\"\n   DASH = 45,          // \"-\"\n   UNDERSCORE = 95,    // \"_\""
        },
        {
            "sha": "83808ce281531f9e698bc15518916ccaf1ca8102",
            "filename": "packages/core/src/view/services.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Fview%2Fservices.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Fsrc%2Fview%2Fservices.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Fview%2Fservices.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -752,15 +752,15 @@ export class DebugRenderer2 implements Renderer2 {\n     this.delegate.appendChild(parent, newChild);\n   }\n \n-  insertBefore(parent: any, newChild: any, refChild: any): void {\n+  insertBefore(parent: any, newChild: any, refChild: any, isMove?: boolean): void {\n     const debugEl = getDebugNode(parent);\n     const debugChildEl = getDebugNode(newChild);\n     const debugRefEl = getDebugNode(refChild)!;\n     if (debugEl && debugChildEl && debugEl instanceof DebugElement__PRE_R3__) {\n       debugEl.insertBefore(debugRefEl, debugChildEl);\n     }\n \n-    this.delegate.insertBefore(parent, newChild, refChild);\n+    this.delegate.insertBefore(parent, newChild, refChild, isMove);\n   }\n \n   removeChild(parent: any, oldChild: any): void {"
        },
        {
            "sha": "5047501d7175086ed22194150f58b2f5959910e3",
            "filename": "packages/core/test/acceptance/debug_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Facceptance%2Fdebug_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Facceptance%2Fdebug_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fdebug_spec.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -64,7 +64,7 @@ onlyInIvy('Ivy specific').describe('Debug Representation', () => {\n           length: 1,\n           content: [{index: HEADER_OFFSET + 2, t: null, l: 'World'}]\n         });\n-        expect(myComponentView.i18n).toEqual({\n+        expect(myComponentView.expando).toEqual({\n           start: HEADER_OFFSET + 3,\n           end: HEADER_OFFSET + 4,\n           length: 1,\n@@ -74,8 +74,6 @@ onlyInIvy('Ivy specific').describe('Debug Representation', () => {\n             l: matchDomText('Hello World')\n           }]\n         });\n-        expect(myComponentView.expando)\n-            .toEqual({start: HEADER_OFFSET + 4, end: HEADER_OFFSET + 4, length: 0, content: []});\n       });\n     });\n   });"
        },
        {
            "sha": "ddabec0d61e12c465dd4fb70277c291f31666914",
            "filename": "packages/core/test/acceptance/i18n_spec.ts",
            "status": "modified",
            "additions": 378,
            "deletions": 205,
            "changes": 583,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Facceptance%2Fi18n_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Facceptance%2Fi18n_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fi18n_spec.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -14,11 +14,8 @@ import localeEs from '@angular/common/locales/es';\n import localeRo from '@angular/common/locales/ro';\n import {computeMsgId} from '@angular/compiler';\n import {Component, ContentChild, ContentChildren, Directive, ElementRef, HostBinding, Input, LOCALE_ID, NO_ERRORS_SCHEMA, Pipe, PipeTransform, QueryList, RendererFactory2, TemplateRef, Type, ViewChild, ViewContainerRef, ɵsetDocument} from '@angular/core';\n-import {getComponentDef} from '@angular/core/src/render3/definition';\n-import {setDelayProjection} from '@angular/core/src/render3/instructions/projection';\n-import {TI18n, TIcu} from '@angular/core/src/render3/interfaces/i18n';\n import {DebugNode, HEADER_OFFSET, TVIEW} from '@angular/core/src/render3/interfaces/view';\n-import {getComponentLView, loadLContext} from '@angular/core/src/render3/util/discovery_utils';\n+import {getComponentLView} from '@angular/core/src/render3/util/discovery_utils';\n import {TestBed} from '@angular/core/testing';\n import {clearTranslations, loadTranslations} from '@angular/localize';\n import {By, ɵDomRendererFactory2 as DomRendererFactory2} from '@angular/platform-browser';\n@@ -27,19 +24,19 @@ import {onlyInIvy} from '@angular/private/testing';\n import {BehaviorSubject} from 'rxjs';\n \n \n+\n onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n   beforeEach(() => {\n     TestBed.configureTestingModule({\n       declarations: [AppComp, DirectiveWithTplRef, UppercasePipe],\n-      // In some of the tests we use made-up tag names for better readability, however they'll\n-      // cause validation errors. Add the `NO_ERRORS_SCHEMA` so that we don't have to declare\n-      // dummy components for each one of them.\n+      // In some of the tests we use made-up tag names for better readability, however\n+      // they'll cause validation errors. Add the `NO_ERRORS_SCHEMA` so that we don't have\n+      // to declare dummy components for each one of them.\n       schemas: [NO_ERRORS_SCHEMA],\n     });\n   });\n \n   afterEach(() => {\n-    setDelayProjection(false);\n     clearTranslations();\n   });\n \n@@ -105,7 +102,8 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n         {{ obj?.getA()?.b }}\n       </div>\n     `);\n-    // the `obj` field is not yet defined, so 2nd and 3rd interpolations return empty strings\n+    // the `obj` field is not yet defined, so 2nd and 3rd interpolations return empty\n+    // strings\n     expect(fixture.nativeElement.innerHTML).toEqual(`<div> ANGULAR -  -  (fr) </div>`);\n \n     fixture.componentRef.instance.obj = {\n@@ -545,9 +543,9 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n       TestBed.configureTestingModule({\n         providers: [\n           {provide: DOCUMENT, useFactory: _document, deps: []},\n-          // TODO(FW-811): switch back to default server renderer (i.e. remove the line below)\n-          // once it starts to support Ivy namespace format (URIs) correctly. For now, use\n-          // `DomRenderer` that supports Ivy namespace format.\n+          // TODO(FW-811): switch back to default server renderer (i.e. remove the line\n+          // below) once it starts to support Ivy namespace format (URIs) correctly. For\n+          // now, use `DomRenderer` that supports Ivy namespace format.\n           {provide: RendererFactory2, useClass: DomRendererFactory2}\n         ],\n       });\n@@ -633,183 +631,58 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n           jasmine.objectContaining({index: HEADER_OFFSET + 3, l: exclamation}),\n         ]\n       });\n-      expect(lViewDebug.i18n)\n+      expect(lViewDebug.expando)\n           .toEqual(\n               {start: lViewDebug.vars.end, end: lViewDebug.expando.start, length: 0, content: []});\n     });\n \n-    it('should create dynamic TNode for text nodes', () => {\n-      const fixture =\n-          initWithTemplate(AppComp, `<ng-container i18n>Hello <b>World</b>!</ng-container>`);\n-      const lView = getComponentLView(fixture.componentInstance);\n-      const hello_ = (fixture.nativeElement as Element).firstChild!;\n-      const b = hello_.nextSibling!;\n-      const world = b.firstChild!;\n-      const exclamation = b.nextSibling!;\n-      const container = exclamation.nextSibling!;\n-      const lViewDebug = lView.debug!;\n-      expect(lViewDebug.nodes.map(toTypeContent)).toEqual([\n-        'ElementContainer(<!--ng-container-->)'\n-      ]);\n-      // This assertion shows that the translated nodes are correctly linked into the TNode tree.\n-      expect(lViewDebug.nodes[0].children.map(toTypeContent)).toEqual([\n-        'Element(Hello )', 'Element(<b>)', 'Element(!)'\n-      ]);\n-      // This assertion shows that the translated text is not part of decls\n-      expect(lViewDebug.decls).toEqual({\n-        start: HEADER_OFFSET,\n-        end: HEADER_OFFSET + 3,\n-        length: 3,\n-        content: [\n-          jasmine.objectContaining({index: HEADER_OFFSET + 0, l: container}),\n-          jasmine.objectContaining({index: HEADER_OFFSET + 1}),\n-          jasmine.objectContaining({index: HEADER_OFFSET + 2, l: b}),\n-        ]\n-      });\n-      // This assertion shows that the translated DOM elements (and corresponding TNode's are stored\n-      // in i18n section of LView)\n-      expect(lViewDebug.i18n).toEqual({\n-        start: lViewDebug.vars.end,\n-        end: lViewDebug.expando.start,\n-        length: 3,\n-        content: [\n-          jasmine.objectContaining({index: HEADER_OFFSET + 3, l: hello_}),\n-          jasmine.objectContaining({index: HEADER_OFFSET + 4, l: world}),\n-          jasmine.objectContaining({index: HEADER_OFFSET + 5, l: exclamation}),\n-        ]\n-      });\n-      // This assertion shows the DOM operations which the i18n subsystem performed to update the\n-      // DOM with translated text. The offsets in the debug text should match the offsets in the\n-      // above assertions.\n-      expect((lView[TVIEW]!.data[HEADER_OFFSET + 1]! as TI18n).create.debug).toEqual([\n-        'lView[3] = document.createTextNode(\"Hello \")',\n-        '(lView[0] as Element).appendChild(lView[3])',\n-        '(lView[0] as Element).appendChild(lView[2])',\n-        'lView[4] = document.createTextNode(\"World\")',\n-        '(lView[2] as Element).appendChild(lView[4])',\n-        'setCurrentTNode(tView.data[2] as TNode)',\n-        'lView[5] = document.createTextNode(\"!\")',\n-        '(lView[0] as Element).appendChild(lView[5])',\n-      ]);\n-    });\n-\n     describe('ICU', () => {\n-      // In the case of ICUs we can't create TNodes for each ICU part, as different ICU instances\n-      // may have different selections active and hence have different shape. In such a case\n-      // a single `TIcuContainerNode` should be generated only.\n+      // In the case of ICUs we can't create TNodes for each ICU part, as different ICU\n+      // instances may have different selections active and hence have different shape. In\n+      // such a case a single `TIcuContainerNode` should be generated only.\n       it('should create a single dynamic TNode for ICU', () => {\n         const fixture = initWithTemplate(AppComp, `\n           {count, plural, \n             =0 {just now} \n             =1 {one minute ago} \n             other {{{count}} minutes ago}\n           }\n-        `);\n+        `.trim());\n         const lView = getComponentLView(fixture.componentInstance);\n         const lViewDebug = lView.debug!;\n+        fixture.detectChanges();\n         expect((fixture.nativeElement as Element).textContent).toEqual('just now');\n-        const text_just_now = (fixture.nativeElement as Element).firstChild!;\n-        const icuComment = text_just_now.nextSibling!;\n-        expect(lViewDebug.nodes.map(toTypeContent)).toEqual(['IcuContainer(<!--ICU 3-->)']);\n+        expect(lViewDebug.nodes.map(toTypeContent)).toEqual(['IcuContainer(<!--ICU 0:0-->)']);\n         // We want to ensure that the ICU container does not have any content!\n         // This is because the content is instance dependent and therefore can't be shared\n         // across `TNode`s.\n-        expect(lViewDebug.nodes[0].children.map(toTypeContent)).toEqual([\n-          'Element(just now)',  // FIXME(misko): This should not be here. The content of the ICU is\n-                                // instance specific and as such can't be encoded in the tNodes.\n-        ]);\n-        expect(lViewDebug.decls).toEqual({\n-          start: HEADER_OFFSET,\n-          end: HEADER_OFFSET + 1,\n-          length: 1,\n-          content: [\n-            jasmine.objectContaining({\n-              t: jasmine.objectContaining({\n-                vars: 3,  // one slot for: the `<!--ICU 3-->`\n-                          // one slot for: the last selected ICU case.\n-                          // one slot for: the actual text node to attach.\n-                create: jasmine.any(Object),\n-                update: jasmine.any(Object),\n-                icus: [jasmine.any(Object)],\n-              }),\n-              l: null\n-            }),\n-          ]\n-        });\n-        expect(((lViewDebug.decls.content[0].t as TI18n).create.debug)).toEqual([\n-          'lView[3] = document.createComment(\"ICU 3\")',\n-          '(lView[0] as Element).appendChild(lView[3])',\n-        ]);\n-        expect(((lViewDebug.decls.content[0].t as TI18n).update.debug)).toEqual([\n-          'if (mask & 0b1) { icuSwitchCase(lView[3] as Comment, 0, `${lView[1]}`); }',\n-          'if (mask & 0b11) { icuUpdateCase(lView[3] as Comment, 0); }',\n-        ]);\n-        const tIcu = (lViewDebug.decls.content[0].t as TI18n).icus![0];\n-        expect(tIcu.cases).toEqual(['0', '1', 'other']);\n-        // Case: '0'\n-        expect(tIcu.create[0].debug).toEqual([\n-          'lView[5] = document.createTextNode(\"just now\")',\n-          '(lView[3] as Element).appendChild(lView[5])',\n-        ]);\n-        expect(tIcu.remove[0].debug).toEqual(['(lView[0] as Element).remove(lView[5])']);\n-        expect(tIcu.update[0].debug).toEqual([]);\n-\n-        // Case: '1'\n-        expect(tIcu.create[1].debug).toEqual([\n-          'lView[5] = document.createTextNode(\"one minute ago\")',\n-          '(lView[3] as Element).appendChild(lView[5])',\n-        ]);\n-        expect(tIcu.remove[1].debug).toEqual(['(lView[0] as Element).remove(lView[5])']);\n-        expect(tIcu.update[1].debug).toEqual([]);\n-\n-        // Case: 'other'\n-        expect(tIcu.create[2].debug).toEqual([\n-          'lView[5] = document.createTextNode(\"\")',\n-          '(lView[3] as Element).appendChild(lView[5])',\n-        ]);\n-        expect(tIcu.remove[2].debug).toEqual(['(lView[0] as Element).remove(lView[5])']);\n-        expect(tIcu.update[2].debug).toEqual([\n-          'if (mask & 0b10) { (lView[5] as Text).textContent = `${lView[2]} minutes ago`; }'\n-        ]);\n+        expect(lViewDebug.nodes[0].children.map(toTypeContent)).toEqual([]);\n+        expect(fixture.nativeElement.innerHTML).toEqual('just now<!--ICU 0:0-->');\n+      });\n \n-        expect(lViewDebug.i18n).toEqual({\n-          start: lViewDebug.vars.end,\n-          end: lViewDebug.expando.start,\n-          length: 3,\n-          content: [\n-            // ICU anchor `<!--ICU 3-->`.\n-            jasmine.objectContaining({index: HEADER_OFFSET + 3, l: icuComment}),\n-            // ICU `TIcu.currentCaseLViewIndex` storage location\n-            jasmine.objectContaining({\n-              index: HEADER_OFFSET + 4,\n-              t: null,\n-              l: 0,  // The current ICU case\n-            }),\n-            jasmine.objectContaining({index: HEADER_OFFSET + 5, l: text_just_now}),\n-          ]\n-        });\n-      });\n-\n-      // FIXME(misko): re-enable and fix this use case.\n-      xit('should support multiple ICUs', () => {\n+      it('should support multiple ICUs', () => {\n         const fixture = initWithTemplate(AppComp, `\n           {count, plural, \n             =0 {just now} \n             =1 {one minute ago} \n             other {{{count}} minutes ago}\n           }\n-          {count, plural, \n-            =0 {just now} \n-            =1 {one minute ago} \n-            other {{{count}} minutes ago}\n+          {name, select, \n+            Angular {Mr. Angular} \n+            other {Sir}\n           }\n         `);\n         const lView = getComponentLView(fixture.componentInstance);\n-        expect(lView.debug!.nodes.map(toTypeContent)).toEqual(['IcuContainer(<!--ICU 3-->)']);\n+        expect(lView.debug!.nodes.map(toTypeContent)).toEqual([\n+          'IcuContainer(<!--ICU 0:0-->)',\n+          'IcuContainer(<!--ICU 1:0-->)',\n+        ]);\n         // We want to ensure that the ICU container does not have any content!\n         // This is because the content is instance dependent and therefore can't be shared\n         // across `TNode`s.\n         expect(lView.debug!.nodes[0].children.map(toTypeContent)).toEqual([]);\n+        expect(fixture.nativeElement.innerHTML)\n+            .toEqual('just now<!--ICU 0:0-->Mr. Angular<!--ICU 1:0-->');\n       });\n     });\n   });\n@@ -905,19 +778,19 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n         other {({{name}})}\n       }</div>`);\n       expect(fixture.nativeElement.innerHTML)\n-          .toEqual(`<div>aucun <b>email</b>!<!--ICU 7--> - (Angular)<!--ICU 14--></div>`);\n+          .toEqual(`<div>aucun <b>email</b>!<!--ICU 1:0--> - (Angular)<!--ICU 1:3--></div>`);\n \n       fixture.componentRef.instance.count = 4;\n       fixture.detectChanges();\n       expect(fixture.nativeElement.innerHTML)\n           .toEqual(\n-              `<div>4 <span title=\"Angular\">emails</span><!--ICU 7--> - (Angular)<!--ICU 14--></div>`);\n+              `<div>4 <span title=\"Angular\">emails</span><!--ICU 1:0--> - (Angular)<!--ICU 1:3--></div>`);\n \n       fixture.componentRef.instance.count = 0;\n       fixture.componentRef.instance.name = 'John';\n       fixture.detectChanges();\n       expect(fixture.nativeElement.innerHTML)\n-          .toEqual(`<div>aucun <b>email</b>!<!--ICU 7--> - (John)<!--ICU 14--></div>`);\n+          .toEqual(`<div>aucun <b>email</b>!<!--ICU 1:0--> - (John)<!--ICU 1:3--></div>`);\n     });\n \n     it('with custom interpolation config', () => {\n@@ -955,20 +828,32 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n       }</span></div>`);\n       expect(fixture.nativeElement.innerHTML)\n           .toEqual(\n-              `<div><span>aucun <b>email</b>!<!--ICU 9--></span> - <span>(Angular)<!--ICU 16--></span></div>`);\n+              `<div>` +\n+              `<span>aucun <b>email</b>!<!--ICU 1:0--></span>` +\n+              ` - ` +\n+              `<span>(Angular)<!--ICU 1:3--></span>` +\n+              `</div>`);\n \n       fixture.componentRef.instance.count = 4;\n       fixture.detectChanges();\n       expect(fixture.nativeElement.innerHTML)\n           .toEqual(\n-              `<div><span>4 <span title=\"Angular\">emails</span><!--ICU 9--></span> - <span>(Angular)<!--ICU 16--></span></div>`);\n+              `<div>` +\n+              `<span>4 <span title=\"Angular\">emails</span><!--ICU 1:0--></span>` +\n+              ` - ` +\n+              `<span>(Angular)<!--ICU 1:3--></span>` +\n+              `</div>`);\n \n       fixture.componentRef.instance.count = 0;\n       fixture.componentRef.instance.name = 'John';\n       fixture.detectChanges();\n       expect(fixture.nativeElement.innerHTML)\n           .toEqual(\n-              `<div><span>aucun <b>email</b>!<!--ICU 9--></span> - <span>(John)<!--ICU 16--></span></div>`);\n+              `<div>` +\n+              `<span>aucun <b>email</b>!<!--ICU 1:0--></span>` +\n+              ` - ` +\n+              `<span>(John)<!--ICU 1:3--></span>` +\n+              `</div>`);\n     });\n \n     it('inside template directives', () => {\n@@ -982,7 +867,7 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n         other {({{name}})}\n       }</span></div>`);\n       expect(fixture.nativeElement.innerHTML)\n-          .toEqual(`<div><span>(Angular)<!--ICU 4--></span><!--bindings={\n+          .toEqual(`<div><span>(Angular)<!--ICU 0:0--></span><!--bindings={\n   \"ng-reflect-ng-if\": \"true\"\n }--></div>`);\n \n@@ -1001,7 +886,7 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n       const fixture = initWithTemplate(AppComp, `<ng-container i18n>{name, select,\n         other {({{name}})}\n       }</ng-container>`);\n-      expect(fixture.nativeElement.innerHTML).toEqual(`(Angular)<!--ICU 4--><!--ng-container-->`);\n+      expect(fixture.nativeElement.innerHTML).toEqual(`(Angular)<!--ICU 1:0--><!--ng-container-->`);\n     });\n \n     it('inside <ng-template>', () => {\n@@ -1036,12 +921,12 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n                        other {animals}\n                      }!}\n       }</div>`);\n-      expect(fixture.nativeElement.innerHTML).toEqual(`<div>zero<!--ICU 5--></div>`);\n+      expect(fixture.nativeElement.innerHTML).toEqual(`<div>zero<!--ICU 1:1--></div>`);\n \n       fixture.componentRef.instance.count = 4;\n       fixture.detectChanges();\n       expect(fixture.nativeElement.innerHTML)\n-          .toEqual(`<div>4 animaux<!--nested ICU 0-->!<!--ICU 5--></div>`);\n+          .toEqual(`<div>4 animaux<!--nested ICU 0-->!<!--ICU 1:1--></div>`);\n     });\n \n     it('nested with interpolations in \"other\" blocks', () => {\n@@ -1061,16 +946,16 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n                      }!}\n         other {other - {{count}}}\n       }</div>`);\n-      expect(fixture.nativeElement.innerHTML).toEqual(`<div>zero<!--ICU 5--></div>`);\n+      expect(fixture.nativeElement.innerHTML).toEqual(`<div>zero<!--ICU 1:1--></div>`);\n \n       fixture.componentRef.instance.count = 2;\n       fixture.detectChanges();\n       expect(fixture.nativeElement.innerHTML)\n-          .toEqual(`<div>2 animaux<!--nested ICU 0-->!<!--ICU 5--></div>`);\n+          .toEqual(`<div>2 animaux<!--nested ICU 0-->!<!--ICU 1:1--></div>`);\n \n       fixture.componentRef.instance.count = 4;\n       fixture.detectChanges();\n-      expect(fixture.nativeElement.innerHTML).toEqual(`<div>autre - 4<!--ICU 5--></div>`);\n+      expect(fixture.nativeElement.innerHTML).toEqual(`<div>autre - 4<!--ICU 1:1--></div>`);\n     });\n \n     it('should return the correct plural form for ICU expressions when using \"ro\" locale', () => {\n@@ -1103,31 +988,31 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n             =other {lots of emails}\n           }`);\n \n-      expect(fixture.nativeElement.innerHTML).toEqual('no email<!--ICU 2-->');\n+      expect(fixture.nativeElement.innerHTML).toEqual('no email<!--ICU 0:0-->');\n \n       // Change detection cycle, no model changes\n       fixture.detectChanges();\n-      expect(fixture.nativeElement.innerHTML).toEqual('no email<!--ICU 2-->');\n+      expect(fixture.nativeElement.innerHTML).toEqual('no email<!--ICU 0:0-->');\n \n       fixture.componentInstance.count = 3;\n       fixture.detectChanges();\n-      expect(fixture.nativeElement.innerHTML).toEqual('a few emails<!--ICU 2-->');\n+      expect(fixture.nativeElement.innerHTML).toEqual('a few emails<!--ICU 0:0-->');\n \n       fixture.componentInstance.count = 1;\n       fixture.detectChanges();\n-      expect(fixture.nativeElement.innerHTML).toEqual('one email<!--ICU 2-->');\n+      expect(fixture.nativeElement.innerHTML).toEqual('one email<!--ICU 0:0-->');\n \n       fixture.componentInstance.count = 10;\n       fixture.detectChanges();\n-      expect(fixture.nativeElement.innerHTML).toEqual('a few emails<!--ICU 2-->');\n+      expect(fixture.nativeElement.innerHTML).toEqual('a few emails<!--ICU 0:0-->');\n \n       fixture.componentInstance.count = 20;\n       fixture.detectChanges();\n-      expect(fixture.nativeElement.innerHTML).toEqual('lots of emails<!--ICU 2-->');\n+      expect(fixture.nativeElement.innerHTML).toEqual('lots of emails<!--ICU 0:0-->');\n \n       fixture.componentInstance.count = 0;\n       fixture.detectChanges();\n-      expect(fixture.nativeElement.innerHTML).toEqual('no email<!--ICU 2-->');\n+      expect(fixture.nativeElement.innerHTML).toEqual('no email<!--ICU 0:0-->');\n     });\n \n     it(`should return the correct plural form for ICU expressions when using \"es\" locale`, () => {\n@@ -1154,31 +1039,31 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n             =other {lots of emails}\n           }`);\n \n-      expect(fixture.nativeElement.innerHTML).toEqual('no email<!--ICU 2-->');\n+      expect(fixture.nativeElement.innerHTML).toEqual('no email<!--ICU 0:0-->');\n \n       // Change detection cycle, no model changes\n       fixture.detectChanges();\n-      expect(fixture.nativeElement.innerHTML).toEqual('no email<!--ICU 2-->');\n+      expect(fixture.nativeElement.innerHTML).toEqual('no email<!--ICU 0:0-->');\n \n       fixture.componentInstance.count = 3;\n       fixture.detectChanges();\n-      expect(fixture.nativeElement.innerHTML).toEqual('lots of emails<!--ICU 2-->');\n+      expect(fixture.nativeElement.innerHTML).toEqual('lots of emails<!--ICU 0:0-->');\n \n       fixture.componentInstance.count = 1;\n       fixture.detectChanges();\n-      expect(fixture.nativeElement.innerHTML).toEqual('one email<!--ICU 2-->');\n+      expect(fixture.nativeElement.innerHTML).toEqual('one email<!--ICU 0:0-->');\n \n       fixture.componentInstance.count = 10;\n       fixture.detectChanges();\n-      expect(fixture.nativeElement.innerHTML).toEqual('lots of emails<!--ICU 2-->');\n+      expect(fixture.nativeElement.innerHTML).toEqual('lots of emails<!--ICU 0:0-->');\n \n       fixture.componentInstance.count = 20;\n       fixture.detectChanges();\n-      expect(fixture.nativeElement.innerHTML).toEqual('lots of emails<!--ICU 2-->');\n+      expect(fixture.nativeElement.innerHTML).toEqual('lots of emails<!--ICU 0:0-->');\n \n       fixture.componentInstance.count = 0;\n       fixture.detectChanges();\n-      expect(fixture.nativeElement.innerHTML).toEqual('no email<!--ICU 2-->');\n+      expect(fixture.nativeElement.innerHTML).toEqual('no email<!--ICU 0:0-->');\n     });\n \n     it('projection', () => {\n@@ -1273,12 +1158,12 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n       const fixture = TestBed.createComponent(App);\n       fixture.detectChanges();\n       expect(fixture.debugElement.nativeElement.innerHTML)\n-          .toContain('<my-cmp><div>ONE<!--ICU 13--></div><!--container--></my-cmp>');\n+          .toContain('<my-cmp><div>ONE<!--ICU 1:0--></div><!--container--></my-cmp>');\n \n       fixture.componentRef.instance.count = 2;\n       fixture.detectChanges();\n       expect(fixture.debugElement.nativeElement.innerHTML)\n-          .toContain('<my-cmp><div>OTHER<!--ICU 13--></div><!--container--></my-cmp>');\n+          .toContain('<my-cmp><div>OTHER<!--ICU 1:0--></div><!--container--></my-cmp>');\n \n       // destroy component\n       fixture.componentInstance.condition = false;\n@@ -1290,7 +1175,7 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n       fixture.componentInstance.count = 1;\n       fixture.detectChanges();\n       expect(fixture.debugElement.nativeElement.innerHTML)\n-          .toContain('<my-cmp><div>ONE<!--ICU 13--></div><!--container--></my-cmp>');\n+          .toContain('<my-cmp><div>ONE<!--ICU 1:0--></div><!--container--></my-cmp>');\n     });\n \n     it('with nested ICU expression and inside a container when creating a view via vcr.createEmbeddedView',\n@@ -1362,12 +1247,12 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n          fixture.detectChanges();\n          expect(fixture.debugElement.nativeElement.innerHTML)\n              .toBe(\n-                 '<my-cmp><div>2 animals<!--nested ICU 0-->!<!--ICU 15--></div><!--container--></my-cmp>');\n+                 '<my-cmp><div>2 animals<!--nested ICU 0-->!<!--ICU 1:1--></div><!--container--></my-cmp>');\n \n          fixture.componentRef.instance.count = 1;\n          fixture.detectChanges();\n          expect(fixture.debugElement.nativeElement.innerHTML)\n-             .toBe('<my-cmp><div>ONE<!--ICU 15--></div><!--container--></my-cmp>');\n+             .toBe('<my-cmp><div>ONE<!--ICU 1:1--></div><!--container--></my-cmp>');\n        });\n \n     it('with nested containers', () => {\n@@ -1602,7 +1487,8 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n \n       fixture.componentInstance.count = 2;\n       fixture.detectChanges();\n-      // check switching to an existing case after processing nested ICU without matching case\n+      // check switching to an existing case after processing nested ICU without matching\n+      // case\n       expect(fixture.nativeElement.textContent.trim()).toBe('deux (select) - deux (plural)');\n \n       fixture.componentInstance.count = 1;\n@@ -1651,26 +1537,17 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n       expect(fixture.nativeElement.textContent.trim()).toBe('deux articles');\n     });\n \n-    // FIXME(misko): re-enable and fix this use case. Root cause is that\n-    // `addRemoveViewFromContainer` needs to understand ICU\n-    xit('should handle select expressions without an `other` parameter inside a template', () => {\n+    it('should handle select expressions without an `other` parameter inside a template', () => {\n       const fixture = initWithTemplate(AppComp, `\n         <ng-container *ngFor=\"let item of items\">{item.value, select, 0 {A} 1 {B} 2 {C}}</ng-container>\n       `);\n       fixture.componentInstance.items = [{value: 0}, {value: 1}, {value: 1337}];\n       fixture.detectChanges();\n-      const p = fixture.nativeElement.querySelector('p');\n-      const lContext = loadLContext(p);\n-      const lView = lContext.lView;\n-      const nodeIndex = lContext.nodeIndex;\n-      const tView = lView[TVIEW];\n-      const i18n = tView.data[nodeIndex + 1] as unknown as TI18n;\n       expect(fixture.nativeElement.textContent.trim()).toBe('AB');\n \n       fixture.componentInstance.items[0].value = 2;\n       fixture.detectChanges();\n       expect(fixture.nativeElement.textContent.trim()).toBe('CB');\n-      fail('testing');\n     });\n \n     it('should render an element whose case did not match initially', () => {\n@@ -1953,7 +1830,8 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n       const fixture = initWithTemplate(AppComp, `\n         <div i18n-title title=\"{{ name | uppercase }} - {{ obj?.a?.b }} - {{ obj?.getA()?.b }}\"></div>\n       `);\n-      // the `obj` field is not yet defined, so 2nd and 3rd interpolations return empty strings\n+      // the `obj` field is not yet defined, so 2nd and 3rd interpolations return empty\n+      // strings\n       expect(fixture.nativeElement.firstChild.title).toEqual(`ANGULAR -  -  (fr)`);\n \n       fixture.componentRef.instance.obj = {\n@@ -2106,8 +1984,8 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n     const innerDiv: HTMLElement = fixture.nativeElement.querySelector('div[inner]');\n \n     // Note that ideally we'd just compare the innerHTML here, but different browsers return\n-    // the order of attributes differently. E.g. most browsers preserve the declaration order,\n-    // but IE does not.\n+    // the order of attributes differently. E.g. most browsers preserve the declaration\n+    // order, but IE does not.\n     expect(outerDiv.getAttribute('title')).toBe('début 2 milieu 1 fin');\n     expect(outerDiv.getAttribute('class')).toBe('foo');\n     expect(outerDiv.textContent!.trim()).toBe('traduction: un email');\n@@ -2491,13 +2369,13 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n       fixture.detectChanges();\n       expect(fixture.nativeElement.innerHTML)\n           .toEqual(\n-              `<child><div>Contenu enfant et projection depuis Parent<!--ICU 15--></div></child>`);\n+              `<child><div>Contenu enfant et projection depuis Parent<!--ICU 1:0--></div></child>`);\n \n       fixture.componentRef.instance.name = 'angular';\n       fixture.detectChanges();\n       expect(fixture.nativeElement.innerHTML)\n           .toEqual(\n-              `<child><div>Contenu enfant et projection depuis Angular<!--ICU 15--></div></child>`);\n+              `<child><div>Contenu enfant et projection depuis Angular<!--ICU 1:0--></div></child>`);\n     });\n \n     it(`shouldn't project deleted projections in i18n blocks`, () => {\n@@ -2850,6 +2728,301 @@ onlyInIvy('Ivy i18n logic').describe('runtime i18n', () => {\n       expect(fixture.nativeElement.textContent).toContain('a b');\n     });\n   });\n+\n+  describe('viewContainerRef with i18n', () => {\n+    it('should create ViewContainerRef with i18n', () => {\n+      // This test demonstrates an issue with creating a `ViewContainerRef` and having i18n at the\n+      // parent element. The reason this broke is that in this case the `ViewContainerRef` creates\n+      // an dynamic anchor comment but uses `HostTNode` for it which is incorrect. `appendChild`\n+      // then tries to add internationalization to the comment node and fails.\n+      @Component({\n+        template: `\n+            <div i18n>before|<div myDir>inside</div>|after</div>\n+          `\n+      })\n+      class MyApp {\n+      }\n+\n+      @Directive({selector: '[myDir]'})\n+      class MyDir {\n+        constructor(vcRef: ViewContainerRef) {\n+          myDir = this;\n+        }\n+      }\n+      let myDir!: MyDir;\n+\n+\n+      TestBed.configureTestingModule({declarations: [MyApp, MyDir]});\n+      const fixture = TestBed.createComponent(MyApp);\n+      fixture.detectChanges();\n+      expect(myDir).toBeDefined();\n+      expect(fixture.nativeElement.textContent).toEqual(`before|inside|after`);\n+    });\n+  });\n+\n+  it('should create ICU with attributes', () => {\n+    // This test demonstrates an issue with setting attributes on ICU elements.\n+    // NOTE: This test is extracted from g3.\n+    @Component({\n+      template: `\n+            <h1 class=\"num-cart-items\" i18n *ngIf=\"true\">{\n+              registerItemCount, plural,\n+              =0 {Your cart}\n+              =1 {Your cart <span class=\"item-count\">(1 item)</span>}\n+              other {\n+                Your cart <span class=\"item-count\">({{\n+                  registerItemCount\n+                }} items)</span>\n+              }\n+          }</h1>`\n+    })\n+    class MyApp {\n+      registerItemCount = 1;\n+    }\n+\n+    TestBed.configureTestingModule({declarations: [MyApp]});\n+    const fixture = TestBed.createComponent(MyApp);\n+    fixture.detectChanges();\n+    expect(fixture.nativeElement.textContent).toEqual(`Your cart (1 item)`);\n+  });\n+\n+  it('should not insertBeforeIndex non-projected content text', () => {\n+    // This test demonstrates an issue with setting attributes on ICU elements.\n+    // NOTE: This test is extracted from g3.\n+    @Component({template: `<div i18n>before|<child>TextNotProjected</child>|after</div>`})\n+    class MyApp {\n+    }\n+\n+    @Component({\n+      selector: 'child',\n+      template: 'CHILD',\n+    })\n+    class Child {\n+    }\n+\n+    TestBed.configureTestingModule({declarations: [MyApp, Child]});\n+    const fixture = TestBed.createComponent(MyApp);\n+    fixture.detectChanges();\n+    expect(fixture.nativeElement.textContent).toEqual(`before|CHILD|after`);\n+  });\n+\n+  it('should create a pipe inside i18n block', () => {\n+    // This test demonstrates an issue with i18n messing up `getCurrentTNode` which subsequently\n+    // breaks the DI. The issue is that the `i18nStartFirstCreatePass` would create placeholder\n+    // NODES, and than leave `getCurrentTNode` in undetermined state which would then break DI.\n+    // NOTE: This test is extracted from g3.\n+    @Component({\n+      template: `\n+      <div i18n [title]=\"null | async\"><div>A</div></div>\n+      <div i18n>{{(null | async)||'B'}}<div></div></div>`\n+    })\n+    class MyApp {\n+    }\n+\n+    TestBed.configureTestingModule({declarations: [MyApp]});\n+    const fixture = TestBed.createComponent(MyApp);\n+    fixture.detectChanges();\n+    expect(fixture.nativeElement.textContent).toEqual(`AB`);\n+  });\n+\n+\n+  it('should copy injector information unto placeholder', () => {\n+    // This test demonstrates an issue with i18n Placeholders loosing `injectorIndex` information.\n+    // NOTE: This test is extracted from g3.\n+    @Component({\n+      template: `\n+        <parent i18n>\n+          <middle>\n+            <child>Text</child>\n+          </middle>\n+        </parent>`\n+    })\n+    class MyApp {\n+    }\n+\n+    @Component({selector: 'parent'})\n+    class Parent {\n+    }\n+\n+    @Component({selector: 'middle'})\n+    class Middle {\n+    }\n+    @Component({selector: 'child'})\n+    class Child {\n+      constructor(public middle: Middle) {\n+        child = this;\n+      }\n+    }\n+    let child!: Child;\n+\n+\n+    TestBed.configureTestingModule({declarations: [MyApp, Parent, Middle, Child]});\n+    const fixture = TestBed.createComponent(MyApp);\n+    fixture.detectChanges();\n+    expect(child.middle).toBeInstanceOf(Middle);\n+  });\n+\n+  it('should allow container in gotClosestRElement', () => {\n+    // A second iteration of the loop will have `Container` `TNode`s pass through the system.\n+    // NOTE: This test is extracted from g3.\n+    @Component({\n+      template: `\n+      <div *ngFor=\"let i of [1,2]\">\n+        <ng-template #tmpl i18n><span *ngIf=\"true\">X</span></ng-template>\n+        <span [ngTemplateOutlet]=\"tmpl\"></span>\n+      </div>`\n+    })\n+    class MyApp {\n+    }\n+\n+    TestBed.configureTestingModule({declarations: [MyApp]});\n+    const fixture = TestBed.createComponent(MyApp);\n+    fixture.detectChanges();\n+    expect(fixture.nativeElement.textContent).toEqual(`XX`);\n+  });\n+\n+\n+  it('should link text after ICU', () => {\n+    // i18n block must restore the current `currentTNode` so that trailing text node can link to it.\n+    // NOTE: This test is extracted from g3.\n+    @Component({\n+      template: `\n+        <ng-container *ngFor=\"let index of [1, 2]\">\n+          {{'['}}\n+          {index, plural, =1 {1} other {*}}\n+          {index, plural, =1 {one} other {many}}\n+          {{'-'}}\n+          <span>+</span>\n+          {{'-'}}\n+          {index, plural, =1 {first} other {rest}}\n+          {{']'}}\n+        </ng-container>\n+        /\n+        <ng-container *ngFor=\"let index of [1, 2]\" i18n>\n+          {{'['}}\n+          {index, plural, =1 {1} other {*}}\n+          {index, plural, =1 {one} other {many}}\n+          {{'-'}}\n+          <span>+</span>\n+          {{'-'}}\n+          {index, plural, =1 {first} other {rest}}\n+          {{']'}}\n+        </ng-container>\n+      `\n+    })\n+    class MyApp {\n+    }\n+\n+    TestBed.configureTestingModule({declarations: [MyApp]});\n+    const fixture = TestBed.createComponent(MyApp);\n+    fixture.detectChanges();\n+    const textContent = fixture.nativeElement.textContent as string;\n+    expect(textContent.split('/').map(s => s.trim())).toEqual([\n+      '[ 1 one - + - first ]  [ * many - + - rest ]',\n+      '[ 1 one - + - first ]  [ * many - + - rest ]',\n+    ]);\n+  });\n+\n+  it('should ignore non-instantiated ICUs on update', () => {\n+    // Demonstrates an issue of same selector expression used in nested ICUs, causes non\n+    // instantiated nested ICUs to be updated.\n+    // NOTE: This test is extracted from g3.\n+    @Component({\n+      template: `\n+        before|\n+        { retention.unit, select,\n+          SECONDS {\n+              {retention.durationInUnits, plural,\n+                  =1 {1 second}\n+                  other {{{retention.durationInUnits}} seconds}\n+                  }\n+              }\n+          DAYS {\n+              {retention.durationInUnits, plural,\n+                  =1 {1 day}\n+                  other {{{retention.durationInUnits}} days}\n+                  }\n+              }\n+          MONTHS {\n+              {retention.durationInUnits, plural,\n+                  =1 {1 month}\n+                  other {{{retention.durationInUnits}} months}\n+                  }\n+              }\n+          YEARS {\n+              {retention.durationInUnits, plural,\n+                  =1 {1 year}\n+                  other {{{retention.durationInUnits}} years}\n+                  }\n+              }\n+          other {}\n+          }\n+        |after.\n+      `\n+    })\n+    class MyApp {\n+      retention = {\n+        durationInUnits: 10,\n+        unit: 'SECONDS',\n+      };\n+    }\n+\n+    TestBed.configureTestingModule({declarations: [MyApp]});\n+    const fixture = TestBed.createComponent(MyApp);\n+    fixture.detectChanges();\n+    const textContent = fixture.nativeElement.textContent as string;\n+    expect(textContent.replace(/\\s+/g, ' ').trim()).toEqual(`before| 10 seconds |after.`);\n+  });\n+\n+  it('should render attributes defined in ICUs', () => {\n+    // NOTE: This test is extracted from g3.\n+    @Component({\n+      template: `\n+        <div i18n>{\n+          parameters.length,\n+          plural,\n+          =1 {Affects parameter <span class=\"parameter-name\" attr=\"should_be_present\">{{parameters[0].name}}</span>}\n+          other {Affects {{parameters.length}} parameters, including <span\n+              class=\"parameter-name\">{{parameters[0].name}}</span>}\n+          }</div>\n+        `\n+    })\n+    class MyApp {\n+      parameters = [{name: 'void_abt_param'}];\n+    }\n+\n+    TestBed.configureTestingModule({declarations: [MyApp]});\n+    const fixture = TestBed.createComponent(MyApp);\n+    fixture.detectChanges();\n+    const span = (fixture.nativeElement as HTMLElement).querySelector('span')!;\n+    expect(span.getAttribute('attr')).toEqual('should_be_present');\n+    expect(span.getAttribute('class')).toEqual('parameter-name');\n+  });\n+\n+  it('should support different ICUs cases for each *ngFor iteration', () => {\n+    @Component({\n+      template: `\n+      <ul i18n>\n+        <li *ngFor=\"let item of items\">{\n+          item, plural,\n+          =1 {<b>one</b>}\n+          =2 {<i>two</i>}\n+      },</li>\n+      </ul>`\n+    })\n+    class MyApp {\n+      items = [1, 2];\n+    }\n+\n+    TestBed.configureTestingModule({declarations: [MyApp]});\n+    const fixture = TestBed.createComponent(MyApp);\n+    fixture.detectChanges();\n+    expect(fixture.nativeElement.textContent).toEqual(`one,two,`);\n+\n+    fixture.componentInstance.items = [2, 1];\n+    fixture.detectChanges();\n+    expect(fixture.nativeElement.textContent).toEqual(`two,one,`);\n+  });\n });\n \n function initWithTemplate(compType: Type<any>, template: string) {"
        },
        {
            "sha": "02f5704682701e4046424d7cf84d168d8a3d455e",
            "filename": "packages/core/test/animation/animation_integration_spec.ts",
            "status": "modified",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Fanimation%2Fanimation_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Fanimation%2Fanimation_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fanimation%2Fanimation_integration_spec.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -2510,6 +2510,33 @@ describe('animation tests', function() {\n     });\n   });\n \n+  it('should not animate i18n insertBefore', () => {\n+    // I18n uses `insertBefore` API to insert nodes in correct order. Animation assumes that\n+    // any `insertBefore` is a move and tries to animate it.\n+    // NOTE: This test was extracted from `g3`\n+    @Component({\n+      template: `<div i18n>Hello <span>World</span>!</div>`,\n+      animations: [\n+        trigger(\n+            'myAnimation',\n+            [\n+              transition('* => *', [animate(1000)]),\n+            ]),\n+      ]\n+    })\n+    class Cmp {\n+    }\n+\n+    TestBed.configureTestingModule({declarations: [Cmp]});\n+    const fixture = TestBed.createComponent(Cmp);\n+    fixture.detectChanges();\n+    const players = getLog();\n+    const span = fixture.debugElement.nativeElement.querySelector('span');\n+    expect(span.innerText).toEqual('World');\n+    // We should not insert `ng-star-inserted` into the span class.\n+    expect(span.className).not.toContain('ng-star-inserted');\n+  });\n+\n   describe('animation listeners', () => {\n     it('should trigger a `start` state change listener for when the animation changes state from void => state',\n        fakeAsync(() => {"
        },
        {
            "sha": "96d90bb28b104dabb2b3c4b6dd48453c9b90684c",
            "filename": "packages/core/test/bundling/cyclic_import/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 12,
            "deletions": 3,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Fbundling%2Fcyclic_import%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Fbundling%2Fcyclic_import%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Fcyclic_import%2Fbundle.golden_symbols.json?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -155,9 +155,6 @@\n   {\n     \"name\": \"generatePropertyAliases\"\n   },\n-  {\n-    \"name\": \"isInCheckNoChangesMode\"\n-  },\n   {\n     \"name\": \"getClosureSafeProperty\"\n   },\n@@ -173,6 +170,9 @@\n   {\n     \"name\": \"getCurrentTNode\"\n   },\n+  {\n+    \"name\": \"getCurrentTNodePlaceholderOk\"\n+  },\n   {\n     \"name\": \"getFirstLContainer\"\n   },\n@@ -245,6 +245,9 @@\n   {\n     \"name\": \"isCurrentTNodeParent\"\n   },\n+  {\n+    \"name\": \"isInCheckNoChangesMode\"\n+  },\n   {\n     \"name\": \"isInlineTemplate\"\n   },\n@@ -281,6 +284,9 @@\n   {\n     \"name\": \"nativeAppendOrInsertBefore\"\n   },\n+  {\n+    \"name\": \"nativeInsertBefore\"\n+  },\n   {\n     \"name\": \"nextNgElementId\"\n   },\n@@ -344,6 +350,9 @@\n   {\n     \"name\": \"setUpAttributes\"\n   },\n+  {\n+    \"name\": \"unwrapRNode\"\n+  },\n   {\n     \"name\": \"updateTransplantedViewCount\"\n   },"
        },
        {
            "sha": "30129f0e8b5d76ea0958e24816552543853b848d",
            "filename": "packages/core/test/bundling/forms/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 18,
            "deletions": 9,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Fbundling%2Fforms%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Fbundling%2Fforms%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Fforms%2Fbundle.golden_symbols.json?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -797,6 +797,9 @@\n   {\n     \"name\": \"createDirectivesInstances\"\n   },\n+  {\n+    \"name\": \"createElementNode\"\n+  },\n   {\n     \"name\": \"createElementRef\"\n   },\n@@ -815,6 +818,9 @@\n   {\n     \"name\": \"createPlatformFactory\"\n   },\n+  {\n+    \"name\": \"createTNode\"\n+  },\n   {\n     \"name\": \"createTView\"\n   },\n@@ -857,9 +863,6 @@\n   {\n     \"name\": \"domRendererFactory3\"\n   },\n-  {\n-    \"name\": \"elementCreate\"\n-  },\n   {\n     \"name\": \"empty\"\n   },\n@@ -947,9 +950,6 @@\n   {\n     \"name\": \"generatePropertyAliases\"\n   },\n-  {\n-    \"name\": \"isInCheckNoChangesMode\"\n-  },\n   {\n     \"name\": \"getClosureSafeProperty\"\n   },\n@@ -965,6 +965,9 @@\n   {\n     \"name\": \"getCurrentTNode\"\n   },\n+  {\n+    \"name\": \"getCurrentTNodePlaceholderOk\"\n+  },\n   {\n     \"name\": \"getDOM\"\n   },\n@@ -1097,6 +1100,9 @@\n   {\n     \"name\": \"hostReportError\"\n   },\n+  {\n+    \"name\": \"icuContainerIterate\"\n+  },\n   {\n     \"name\": \"identity\"\n   },\n@@ -1181,6 +1187,9 @@\n   {\n     \"name\": \"isFunction\"\n   },\n+  {\n+    \"name\": \"isInCheckNoChangesMode\"\n+  },\n   {\n     \"name\": \"isInlineTemplate\"\n   },\n@@ -1484,9 +1493,6 @@\n   {\n     \"name\": \"setBindingRootForHostBindings\"\n   },\n-  {\n-    \"name\": \"setIsInCheckNoChangesMode\"\n-  },\n   {\n     \"name\": \"setCurrentDirectiveIndex\"\n   },\n@@ -1514,6 +1520,9 @@\n   {\n     \"name\": \"setInputsFromAttrs\"\n   },\n+  {\n+    \"name\": \"setIsInCheckNoChangesMode\"\n+  },\n   {\n     \"name\": \"setLocaleId\"\n   },"
        },
        {
            "sha": "d39dda1a439fb2671153057472fa61c1e803eb14",
            "filename": "packages/core/test/bundling/hello_world/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 15,
            "deletions": 3,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Fbundling%2Fhello_world%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Fbundling%2Fhello_world%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Fhello_world%2Fbundle.golden_symbols.json?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -107,9 +107,6 @@\n   {\n     \"name\": \"extractPipeDef\"\n   },\n-  {\n-    \"name\": \"isInCheckNoChangesMode\"\n-  },\n   {\n     \"name\": \"getClosureSafeProperty\"\n   },\n@@ -122,6 +119,9 @@\n   {\n     \"name\": \"getCurrentTNode\"\n   },\n+  {\n+    \"name\": \"getCurrentTNodePlaceholderOk\"\n+  },\n   {\n     \"name\": \"getFirstLContainer\"\n   },\n@@ -158,6 +158,9 @@\n   {\n     \"name\": \"invertObject\"\n   },\n+  {\n+    \"name\": \"isInCheckNoChangesMode\"\n+  },\n   {\n     \"name\": \"isProceduralRenderer\"\n   },\n@@ -173,6 +176,9 @@\n   {\n     \"name\": \"nativeAppendOrInsertBefore\"\n   },\n+  {\n+    \"name\": \"nativeInsertBefore\"\n+  },\n   {\n     \"name\": \"nextNgElementId\"\n   },\n@@ -218,10 +224,16 @@\n   {\n     \"name\": \"setSelectedIndex\"\n   },\n+  {\n+    \"name\": \"unwrapRNode\"\n+  },\n   {\n     \"name\": \"updateTransplantedViewCount\"\n   },\n   {\n     \"name\": \"viewAttachedToChangeDetector\"\n+  },\n+  {\n+    \"name\": \"ɵɵtext\"\n   }\n ]\n\\ No newline at end of file"
        },
        {
            "sha": "01b94b278ad6e0312ba4caa1c925e25abed4cff9",
            "filename": "packages/core/test/bundling/router/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 18,
            "deletions": 9,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -1031,6 +1031,9 @@\n   {\n     \"name\": \"createContainerRef\"\n   },\n+  {\n+    \"name\": \"createElementNode\"\n+  },\n   {\n     \"name\": \"createElementRef\"\n   },\n@@ -1064,6 +1067,9 @@\n   {\n     \"name\": \"createRouterScroller\"\n   },\n+  {\n+    \"name\": \"createTNode\"\n+  },\n   {\n     \"name\": \"createTView\"\n   },\n@@ -1139,9 +1145,6 @@\n   {\n     \"name\": \"domRendererFactory3\"\n   },\n-  {\n-    \"name\": \"elementCreate\"\n-  },\n   {\n     \"name\": \"empty\"\n   },\n@@ -1259,9 +1262,6 @@\n   {\n     \"name\": \"getBootstrapListener\"\n   },\n-  {\n-    \"name\": \"isInCheckNoChangesMode\"\n-  },\n   {\n     \"name\": \"getClosureSafeProperty\"\n   },\n@@ -1280,6 +1280,9 @@\n   {\n     \"name\": \"getCurrentTNode\"\n   },\n+  {\n+    \"name\": \"getCurrentTNodePlaceholderOk\"\n+  },\n   {\n     \"name\": \"getDOM\"\n   },\n@@ -1439,6 +1442,9 @@\n   {\n     \"name\": \"hostReportError\"\n   },\n+  {\n+    \"name\": \"icuContainerIterate\"\n+  },\n   {\n     \"name\": \"identity\"\n   },\n@@ -1517,6 +1523,9 @@\n   {\n     \"name\": \"isFunction\"\n   },\n+  {\n+    \"name\": \"isInCheckNoChangesMode\"\n+  },\n   {\n     \"name\": \"isInlineTemplate\"\n   },\n@@ -1817,9 +1826,6 @@\n   {\n     \"name\": \"setBindingRootForHostBindings\"\n   },\n-  {\n-    \"name\": \"setIsInCheckNoChangesMode\"\n-  },\n   {\n     \"name\": \"setCurrentDirectiveIndex\"\n   },\n@@ -1847,6 +1853,9 @@\n   {\n     \"name\": \"setInputsFromAttrs\"\n   },\n+  {\n+    \"name\": \"setIsInCheckNoChangesMode\"\n+  },\n   {\n     \"name\": \"setLocaleId\"\n   },"
        },
        {
            "sha": "a650b90fa80205de7aa26ccde4042bd293d617b4",
            "filename": "packages/core/test/bundling/todo/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 15,
            "deletions": 6,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Fbundling%2Ftodo%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Fbundling%2Ftodo%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Ftodo%2Fbundle.golden_symbols.json?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -257,6 +257,9 @@\n   {\n     \"name\": \"createLView\"\n   },\n+  {\n+    \"name\": \"createTNode\"\n+  },\n   {\n     \"name\": \"createTView\"\n   },\n@@ -329,9 +332,6 @@\n   {\n     \"name\": \"generatePropertyAliases\"\n   },\n-  {\n-    \"name\": \"isInCheckNoChangesMode\"\n-  },\n   {\n     \"name\": \"getClosureSafeProperty\"\n   },\n@@ -347,6 +347,9 @@\n   {\n     \"name\": \"getCurrentTNode\"\n   },\n+  {\n+    \"name\": \"getCurrentTNodePlaceholderOk\"\n+  },\n   {\n     \"name\": \"getDebugContext\"\n   },\n@@ -440,6 +443,9 @@\n   {\n     \"name\": \"hasTagAndTypeMatch\"\n   },\n+  {\n+    \"name\": \"icuContainerIterate\"\n+  },\n   {\n     \"name\": \"includeViewProviders\"\n   },\n@@ -485,6 +491,9 @@\n   {\n     \"name\": \"isDirectiveHost\"\n   },\n+  {\n+    \"name\": \"isInCheckNoChangesMode\"\n+  },\n   {\n     \"name\": \"isInlineTemplate\"\n   },\n@@ -641,9 +650,6 @@\n   {\n     \"name\": \"setBindingRootForHostBindings\"\n   },\n-  {\n-    \"name\": \"setIsInCheckNoChangesMode\"\n-  },\n   {\n     \"name\": \"setCurrentDirectiveIndex\"\n   },\n@@ -668,6 +674,9 @@\n   {\n     \"name\": \"setInputsFromAttrs\"\n   },\n+  {\n+    \"name\": \"setIsInCheckNoChangesMode\"\n+  },\n   {\n     \"name\": \"setSelectedIndex\"\n   },"
        },
        {
            "sha": "396c09199e9670d41806e789c4089f3d0c808d6f",
            "filename": "packages/core/test/render3/i18n/i18n_insert_before_index_spec.ts",
            "status": "added",
            "additions": 183,
            "deletions": 0,
            "changes": 183,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Fi18n%2Fi18n_insert_before_index_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Fi18n%2Fi18n_insert_before_index_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Fi18n%2Fi18n_insert_before_index_spec.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -0,0 +1,183 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {addTNodeAndUpdateInsertBeforeIndex} from '@angular/core/src/render3/i18n/i18n_insert_before_index';\n+import {createTNode} from '@angular/core/src/render3/instructions/shared';\n+import {TNode, TNodeType} from '@angular/core/src/render3/interfaces/node';\n+import {matchTNode} from '../matchers';\n+\n+\n+describe('addTNodeAndUpdateInsertBeforeIndex', () => {\n+  function tNode(index: number, type: TNodeType, insertBeforeIndex: number|null = null): TNode {\n+    const tNode = createTNode(null!, null, type, index, null, null);\n+    tNode.insertBeforeIndex = insertBeforeIndex;\n+    return tNode;\n+  }\n+\n+  function tPlaceholderElementNode(index: number, insertBeforeIndex: number|null = null) {\n+    return tNode(index, TNodeType.Placeholder, insertBeforeIndex);\n+  }\n+\n+  function tI18NTextNode(index: number, insertBeforeIndex: number|null = null) {\n+    return tNode(index, TNodeType.Element, insertBeforeIndex);\n+  }\n+\n+  it('should add first node', () => {\n+    const previousTNodes: TNode[] = [];\n+    addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tPlaceholderElementNode(20));\n+    expect(previousTNodes).toEqual([\n+      matchTNode({index: 20, insertBeforeIndex: null}),\n+    ]);\n+  });\n+\n+  describe('when adding a placeholder', () => {\n+    describe('whose index is greater than those already there', () => {\n+      it('should not update the `insertBeforeIndex` values', () => {\n+        const previousTNodes: TNode[] = [\n+          tPlaceholderElementNode(20),\n+          tPlaceholderElementNode(21),\n+        ];\n+        addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tPlaceholderElementNode(22));\n+        expect(previousTNodes).toEqual([\n+          matchTNode({index: 20, insertBeforeIndex: null}),\n+          matchTNode({index: 21, insertBeforeIndex: null}),\n+          matchTNode({index: 22, insertBeforeIndex: null}),\n+        ]);\n+      });\n+    });\n+\n+    describe('whose index is smaller than current nodes', () => {\n+      it('should update the previous insertBeforeIndex', () => {\n+        const previousTNodes: TNode[] = [\n+          tPlaceholderElementNode(20),\n+          tPlaceholderElementNode(21),\n+        ];\n+        addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tPlaceholderElementNode(19));\n+        expect(previousTNodes).toEqual([\n+          matchTNode({index: 20, insertBeforeIndex: 19}),\n+          matchTNode({index: 21, insertBeforeIndex: 19}),\n+          matchTNode({index: 19, insertBeforeIndex: null}),\n+        ]);\n+      });\n+\n+      it('should not update the previous insertBeforeIndex if it is already set', () => {\n+        const previousTNodes: TNode[] = [\n+          tPlaceholderElementNode(20, 19),\n+          tPlaceholderElementNode(21, 19),\n+          tPlaceholderElementNode(19),\n+        ];\n+        addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tPlaceholderElementNode(18));\n+        expect(previousTNodes).toEqual([\n+          matchTNode({index: 20, insertBeforeIndex: 19}),\n+          matchTNode({index: 21, insertBeforeIndex: 19}),\n+          matchTNode({index: 19, insertBeforeIndex: 18}),\n+          matchTNode({index: 18, insertBeforeIndex: null}),\n+        ]);\n+      });\n+\n+      it('should not update the previous insertBeforeIndex if it is created after', () => {\n+        const previousTNodes: TNode[] = [\n+          tPlaceholderElementNode(20, 15),\n+          tPlaceholderElementNode(21, 15),\n+          tPlaceholderElementNode(15),\n+        ];\n+        addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tPlaceholderElementNode(18));\n+        expect(previousTNodes).toEqual([\n+          matchTNode({index: 20, insertBeforeIndex: 15}),\n+          matchTNode({index: 21, insertBeforeIndex: 15}),\n+          matchTNode({index: 15, insertBeforeIndex: null}),\n+          matchTNode({index: 18, insertBeforeIndex: null}),\n+        ]);\n+      });\n+    });\n+  });\n+\n+  describe('when adding a i18nText', () => {\n+    describe('whose index is greater than those already there', () => {\n+      it('should not update the `insertBeforeIndex` values', () => {\n+        const previousTNodes: TNode[] = [\n+          tPlaceholderElementNode(20),\n+          tPlaceholderElementNode(21),\n+        ];\n+        addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tI18NTextNode(22));\n+        expect(previousTNodes).toEqual([\n+          matchTNode({index: 20, insertBeforeIndex: 22}),\n+          matchTNode({index: 21, insertBeforeIndex: 22}),\n+          matchTNode({index: 22, insertBeforeIndex: null}),\n+        ]);\n+      });\n+    });\n+\n+    describe('whose index is smaller than current nodes', () => {\n+      it('should update the previous insertBeforeIndex', () => {\n+        const previousTNodes: TNode[] = [\n+          tPlaceholderElementNode(20),\n+          tPlaceholderElementNode(21),\n+        ];\n+        addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tI18NTextNode(19));\n+        expect(previousTNodes).toEqual([\n+          matchTNode({index: 20, insertBeforeIndex: 19}),\n+          matchTNode({index: 21, insertBeforeIndex: 19}),\n+          matchTNode({index: 19, insertBeforeIndex: null}),\n+        ]);\n+      });\n+\n+      it('should not update the previous insertBeforeIndex if it is already set', () => {\n+        const previousTNodes: TNode[] = [\n+          tPlaceholderElementNode(20, 19),\n+          tPlaceholderElementNode(21, 19),\n+          tPlaceholderElementNode(19),\n+        ];\n+        addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tI18NTextNode(18));\n+        expect(previousTNodes).toEqual([\n+          matchTNode({index: 20, insertBeforeIndex: 19}),\n+          matchTNode({index: 21, insertBeforeIndex: 19}),\n+          matchTNode({index: 19, insertBeforeIndex: 18}),\n+          matchTNode({index: 18, insertBeforeIndex: null}),\n+        ]);\n+      });\n+\n+      it('should not update the previous insertBeforeIndex if it is created after', () => {\n+        const previousTNodes: TNode[] = [\n+          tPlaceholderElementNode(20, 15),\n+          tPlaceholderElementNode(21, 15),\n+          tPlaceholderElementNode(15),\n+        ];\n+        addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tI18NTextNode(18));\n+        expect(previousTNodes).toEqual([\n+          matchTNode({index: 20, insertBeforeIndex: 15}),\n+          matchTNode({index: 21, insertBeforeIndex: 15}),\n+          matchTNode({index: 15, insertBeforeIndex: 18}),\n+          matchTNode({index: 18, insertBeforeIndex: null}),\n+        ]);\n+      });\n+    });\n+  });\n+\n+  describe('scenario', () => {\n+    it('should rearrange the nodes', () => {\n+      const previousTNodes: TNode[] = [];\n+      addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tPlaceholderElementNode(22));\n+      addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tPlaceholderElementNode(28));\n+      addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tPlaceholderElementNode(24));\n+      addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tPlaceholderElementNode(25));\n+      addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tI18NTextNode(29));\n+      addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tPlaceholderElementNode(23));\n+      addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tPlaceholderElementNode(27));\n+      expect(previousTNodes).toEqual([\n+        matchTNode({index: 22, insertBeforeIndex: 29}),\n+        matchTNode({index: 28, insertBeforeIndex: 24}),\n+        matchTNode({index: 24, insertBeforeIndex: 29}),\n+        matchTNode({index: 25, insertBeforeIndex: 29}),\n+        matchTNode({index: 29, insertBeforeIndex: null}),\n+        matchTNode({index: 23, insertBeforeIndex: null}),\n+        matchTNode({index: 27, insertBeforeIndex: null}),\n+      ]);\n+    });\n+  });\n+});\n\\ No newline at end of file"
        },
        {
            "sha": "054dd23c7b23ca2d437aec1f9480c5ec258501ad",
            "filename": "packages/core/test/render3/i18n/i18n_parse_spec.ts",
            "status": "added",
            "additions": 289,
            "deletions": 0,
            "changes": 289,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Fi18n%2Fi18n_parse_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Fi18n%2Fi18n_parse_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Fi18n%2Fi18n_parse_spec.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -0,0 +1,289 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {ɵɵi18nApply, ɵɵi18nExp} from '@angular/core';\n+import {applyCreateOpCodes} from '@angular/core/src/render3/i18n/i18n_apply';\n+import {i18nStartFirstCreatePass} from '@angular/core/src/render3/i18n/i18n_parse';\n+import {getTIcu} from '@angular/core/src/render3/i18n/i18n_util';\n+import {IcuType, TI18n} from '@angular/core/src/render3/interfaces/i18n';\n+import {HEADER_OFFSET} from '@angular/core/src/render3/interfaces/view';\n+import {expect} from '@angular/core/testing/src/testing_internal';\n+import {matchTI18n, matchTIcu} from '../matchers';\n+import {debugMatch} from '../utils';\n+import {ViewFixture} from '../view_fixture';\n+\n+describe('i18n_parse', () => {\n+  let fixture: ViewFixture;\n+  beforeEach(() => fixture = new ViewFixture({decls: 1, vars: 1}));\n+\n+  describe('icu', () => {\n+    it('should parse simple text', () => {\n+      const tI18n = toT18n('some text');\n+      expect(tI18n).toEqual(matchTI18n({\n+        create: debugMatch([\n+          'lView[22] = document.createText(\"some text\");',\n+          'parent.appendChild(lView[22]);',\n+        ]),\n+        update: [],\n+      }));\n+\n+      fixture.apply(() => applyCreateOpCodes(fixture.lView, tI18n.create, fixture.host, null));\n+      expect(fixture.host.innerHTML).toEqual('some text');\n+    });\n+\n+    it('should parse simple ICU', () => {\n+      //     TData                  | LView\n+      // ---------------------------+-------------------------------\n+      //                     ----- DECL -----\n+      // 20: TI18n                  |\n+      //                     ----- VARS -----\n+      // 21: Binding for ICU        |\n+      //                   ----- EXPANDO -----\n+      // 22: null                   | #text(before|)\n+      // 23: TIcu                   | <!-- ICU 0:0 -->\n+      // 24: null                   | currently selected ICU case\n+      // 25: null                   | #text(caseA)\n+      // 26: null                   | #text(otherCase)\n+      // 27: null                   | #text(|after)\n+      const tI18n = toT18n(`before|{\n+          �0�, select,\n+            A {caseA}\n+            other {otherCase}\n+        }|after`);\n+      expect(tI18n).toEqual(matchTI18n({\n+        create: debugMatch([\n+          'lView[22] = document.createText(\"before|\");',\n+          'parent.appendChild(lView[22]);',\n+          'lView[23] = document.createComment(\"ICU 0:0\");',\n+          'parent.appendChild(lView[23]);',\n+          'lView[27] = document.createText(\"|after\");',\n+          'parent.appendChild(lView[27]);',\n+        ]),\n+        update: debugMatch([\n+          'if (mask & 0b1) { icuSwitchCase(23, `${lView[i-1]}`); }',\n+        ])\n+      }));\n+      expect(getTIcu(fixture.tView, 23)).toEqual(matchTIcu({\n+        type: IcuType.select,\n+        anchorIdx: 23,\n+        currentCaseLViewIndex: 24,\n+        cases: ['A', 'other'],\n+        create: [\n+          debugMatch([\n+            'lView[25] = document.createTextNode(\"caseA\")',\n+            '(lView[0] as Element).appendChild(lView[25])'\n+          ]),\n+          debugMatch([\n+            'lView[26] = document.createTextNode(\"otherCase\")',\n+            '(lView[0] as Element).appendChild(lView[26])',\n+          ])\n+        ],\n+        update: [\n+          debugMatch([]),\n+          debugMatch([]),\n+        ],\n+        remove: [\n+          debugMatch(['(lView[0] as Element).remove(lView[25])']),\n+          debugMatch(['(lView[0] as Element).remove(lView[26])'])\n+        ],\n+      }));\n+\n+      fixture.apply(() => {\n+        applyCreateOpCodes(fixture.lView, tI18n.create, fixture.host, null);\n+        expect(fixture.host.innerHTML).toEqual('before|<!--ICU 0:0-->|after');\n+      });\n+      fixture.apply(() => {\n+        ɵɵi18nExp('A');\n+        ɵɵi18nApply(0);  // index 0 + HEADER_OFFSET = 20;\n+        expect(fixture.host.innerHTML).toEqual('before|caseA<!--ICU 0:0-->|after');\n+      });\n+      fixture.apply(() => {\n+        ɵɵi18nExp('x');\n+        ɵɵi18nApply(0);  // index 0 + HEADER_OFFSET = 20;\n+        expect(fixture.host.innerHTML).toEqual('before|otherCase<!--ICU 0:0-->|after');\n+      });\n+      fixture.apply(() => {\n+        ɵɵi18nExp('A');\n+        ɵɵi18nApply(0);  // index 0 + HEADER_OFFSET = 20;\n+        expect(fixture.host.innerHTML).toEqual('before|caseA<!--ICU 0:0-->|after');\n+      });\n+    });\n+\n+    it('should parse HTML in ICU', () => {\n+      const tI18n = toT18n(`{\n+        �0�, select,\n+          A {Hello <b>world<i>!</i></b>}\n+          other {<div>{�0�, select, 0 {nested0} other {nestedOther}}</div>}\n+      }`);\n+      fixture.apply(() => {\n+        applyCreateOpCodes(fixture.lView, tI18n.create, fixture.host, null);\n+        expect(fixture.host.innerHTML).toEqual('<!--ICU 0:0-->');\n+      });\n+      fixture.apply(() => {\n+        ɵɵi18nExp('A');\n+        ɵɵi18nApply(0);  // index 0 + HEADER_OFFSET = 20;\n+        expect(fixture.host.innerHTML).toEqual('Hello <b>world<i>!</i></b><!--ICU 0:0-->');\n+      });\n+      fixture.apply(() => {\n+        ɵɵi18nExp('x');\n+        ɵɵi18nApply(0);  // index 0 + HEADER_OFFSET = 20;\n+        expect(fixture.host.innerHTML)\n+            .toEqual('<div>nestedOther<!--nested ICU 0--></div><!--ICU 0:0-->');\n+      });\n+      fixture.apply(() => {\n+        ɵɵi18nExp('A');\n+        ɵɵi18nApply(0);  // index 0 + HEADER_OFFSET = 20;\n+        expect(fixture.host.innerHTML).toEqual('Hello <b>world<i>!</i></b><!--ICU 0:0-->');\n+      });\n+    });\n+\n+\n+    it('should parse nested ICU', () => {\n+      fixture = new ViewFixture({decls: 1, vars: 3});\n+      //     TData                  | LView\n+      // ---------------------------+-------------------------------\n+      //                     ----- DECL -----\n+      // 20: TI18n                  |\n+      //                     ----- VARS -----\n+      // 21: Binding for parent ICU |\n+      // 22: Binding for child ICU  |\n+      // 23: Binding for child ICU  |\n+      //                   ----- EXPANDO -----\n+      // 24: TIcu (parent)          | <!-- ICU 0:0 -->\n+      // 25: null                   | currently selected ICU case\n+      // 26: null                   | #text( parentA )\n+      // 27: TIcu (child)           | <!-- nested ICU 0 -->\n+      // 28:     null               |     currently selected ICU case\n+      // 29:     null               |     #text(nested0)\n+      // 30:     null               |     #text({{�2�}})\n+      // 31: null                   | #text( )\n+      // 32: null                   | #text( parentOther )\n+      const tI18n = toT18n(`{\n+          �0�, select,\n+            A {parentA {�1�, select, 0 {nested0} other {�2�}}!}\n+            other {parentOther}\n+        }`);\n+      expect(tI18n).toEqual(matchTI18n({\n+        create: debugMatch([\n+          'lView[24] = document.createComment(\"ICU 0:0\");',\n+          'parent.appendChild(lView[24]);',\n+        ]),\n+        update: debugMatch([\n+          'if (mask & 0b1) { icuSwitchCase(24, `${lView[i-1]}`); }',\n+          'if (mask & 0b10) { icuSwitchCase(27, `${lView[i-2]}`); }',\n+          'if (mask & 0b100) { icuUpdateCase(27); }',\n+        ]),\n+      }));\n+      expect(getTIcu(fixture.tView, 24)).toEqual(matchTIcu({\n+        type: IcuType.select,\n+        anchorIdx: 24,\n+        currentCaseLViewIndex: 25,\n+        cases: ['A', 'other'],\n+        create: [\n+          debugMatch([\n+            'lView[26] = document.createTextNode(\"parentA \")',\n+            '(lView[0] as Element).appendChild(lView[26])',\n+            'lView[27] = document.createComment(\"nested ICU 0\")',\n+            '(lView[0] as Element).appendChild(lView[27])',\n+            'lView[31] = document.createTextNode(\"!\")',\n+            '(lView[0] as Element).appendChild(lView[31])',\n+          ]),\n+          debugMatch([\n+            'lView[32] = document.createTextNode(\"parentOther\")',\n+            '(lView[0] as Element).appendChild(lView[32])',\n+          ])\n+        ],\n+        update: [\n+          debugMatch([]),\n+          debugMatch([]),\n+        ],\n+        remove: [\n+          debugMatch([\n+            '(lView[0] as Element).remove(lView[26])',\n+            'removeNestedICU(27)',\n+            '(lView[0] as Element).remove(lView[27])',\n+            '(lView[0] as Element).remove(lView[31])',\n+          ]),\n+          debugMatch([\n+            '(lView[0] as Element).remove(lView[32])',\n+          ])\n+        ],\n+      }));\n+\n+      expect(getTIcu(fixture.tView, 27)).toEqual(matchTIcu({\n+        type: IcuType.select,\n+        anchorIdx: 27,\n+        currentCaseLViewIndex: 28,\n+        cases: ['0', 'other'],\n+        create: [\n+          debugMatch([\n+            'lView[29] = document.createTextNode(\"nested0\")',\n+            '(lView[0] as Element).appendChild(lView[29])'\n+          ]),\n+          debugMatch([\n+            'lView[30] = document.createTextNode(\"\")',\n+            '(lView[0] as Element).appendChild(lView[30])',\n+          ])\n+        ],\n+        update: [\n+          debugMatch([]),\n+          debugMatch([\n+            'if (mask & 0b100) { (lView[30] as Text).textContent = `${lView[i-3]}`; }',\n+          ]),\n+        ],\n+        remove: [\n+          debugMatch(['(lView[0] as Element).remove(lView[29])']),\n+          debugMatch(['(lView[0] as Element).remove(lView[30])'])\n+        ],\n+      }));\n+\n+      fixture.apply(() => {\n+        applyCreateOpCodes(fixture.lView, tI18n.create, fixture.host, null);\n+        expect(fixture.host.innerHTML).toEqual('<!--ICU 0:0-->');\n+      });\n+      fixture.apply(() => {\n+        ɵɵi18nExp('A');\n+        ɵɵi18nExp('0');\n+        ɵɵi18nExp('value1');\n+        ɵɵi18nApply(0);  // index 0 + HEADER_OFFSET = 20;\n+        expect(fixture.host.innerHTML).toEqual('parentA nested0<!--nested ICU 0-->!<!--ICU 0:0-->');\n+      });\n+      fixture.apply(() => {\n+        ɵɵi18nExp('A');\n+        ɵɵi18nExp('x');\n+        ɵɵi18nExp('value1');\n+        ɵɵi18nApply(0);  // index 0 + HEADER_OFFSET = 20;\n+        expect(fixture.host.innerHTML).toEqual('parentA value1<!--nested ICU 0-->!<!--ICU 0:0-->');\n+      });\n+      fixture.apply(() => {\n+        ɵɵi18nExp('x');\n+        ɵɵi18nExp('x');\n+        ɵɵi18nExp('value2');\n+        ɵɵi18nApply(0);  // index 0 + HEADER_OFFSET = 20;\n+        expect(fixture.host.innerHTML).toEqual('parentOther<!--ICU 0:0-->');\n+      });\n+      fixture.apply(() => {\n+        ɵɵi18nExp('A');\n+        ɵɵi18nExp('A');\n+        ɵɵi18nExp('value2');\n+        ɵɵi18nApply(0);  // index 0 + HEADER_OFFSET = 20;\n+        expect(fixture.host.innerHTML).toEqual('parentA value2<!--nested ICU 0-->!<!--ICU 0:0-->');\n+      });\n+    });\n+  });\n+\n+  function toT18n(text: string) {\n+    const tNodeIndex = 0;\n+    fixture.enterView();\n+    i18nStartFirstCreatePass(fixture.tView, 0, fixture.lView, tNodeIndex, text, -1);\n+    fixture.leaveView();\n+    const tI18n = fixture.tView.data[tNodeIndex + HEADER_OFFSET] as TI18n;\n+    expect(tI18n).toEqual(matchTI18n({}));\n+    return tI18n;\n+  }\n+});"
        },
        {
            "sha": "c1447114abd9cfc3958a639738248defb8dd553d",
            "filename": "packages/core/test/render3/i18n/i18n_spec.ts",
            "status": "modified",
            "additions": 350,
            "deletions": 239,
            "changes": 589,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Fi18n%2Fi18n_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Fi18n%2Fi18n_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Fi18n%2Fi18n_spec.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -7,41 +7,44 @@\n  */\n \n import {ɵɵi18nAttributes, ɵɵi18nPostprocess, ɵɵi18nStart} from '@angular/core';\n-import {getTranslationForTemplate} from '@angular/core/src/render3/i18n/i18n_parse';\n-import {setDelayProjection, ɵɵelementEnd, ɵɵelementStart} from '../../../src/render3/instructions/all';\n-import {I18nUpdateOpCodes, TI18n, TIcu} from '../../../src/render3/interfaces/i18n';\n-import {TConstants} from '../../../src/render3/interfaces/node';\n-import {HEADER_OFFSET, LView, TVIEW} from '../../../src/render3/interfaces/view';\n+import {ɵɵi18n} from '@angular/core/src/core';\n+import {getTranslationForTemplate, i18nStartFirstCreatePass} from '@angular/core/src/render3/i18n/i18n_parse';\n+import {getTIcu} from '@angular/core/src/render3/i18n/i18n_util';\n+import {TElementNode, TNodeType} from '@angular/core/src/render3/interfaces/node';\n+import {getCurrentTNode} from '@angular/core/src/render3/state';\n+import {ɵɵelementEnd, ɵɵelementStart} from '../../../src/render3/instructions/all';\n+import {I18nCreateOpCode, I18nUpdateOpCodes, TI18n, TIcu} from '../../../src/render3/interfaces/i18n';\n+import {HEADER_OFFSET, LView, TVIEW, TView} from '../../../src/render3/interfaces/view';\n import {getNativeByIndex} from '../../../src/render3/util/view_utils';\n+import {matchTNode} from '../matchers';\n import {TemplateFixture} from '../render_util';\n import {debugMatch} from '../utils';\n+import {ViewFixture} from '../view_fixture';\n+\n \n \n describe('Runtime i18n', () => {\n-  afterEach(() => {\n-    setDelayProjection(false);\n-  });\n   describe('getTranslationForTemplate', () => {\n     it('should crop messages for the selected template', () => {\n       let message = `simple text`;\n-      expect(getTranslationForTemplate(message)).toEqual(message);\n+      expect(getTranslationForTemplate(message, -1)).toEqual(message);\n \n       message = `Hello �0�!`;\n-      expect(getTranslationForTemplate(message)).toEqual(message);\n+      expect(getTranslationForTemplate(message, -1)).toEqual(message);\n \n       message = `Hello �#2��0��/#2�!`;\n-      expect(getTranslationForTemplate(message)).toEqual(message);\n+      expect(getTranslationForTemplate(message, -1)).toEqual(message);\n \n       // Embedded sub-templates\n       message = `�0� is rendered as: �*2:1�before�*1:2�middle�/*1:2�after�/*2:1�!`;\n-      expect(getTranslationForTemplate(message)).toEqual('�0� is rendered as: �*2:1��/*2:1�!');\n+      expect(getTranslationForTemplate(message, -1)).toEqual('�0� is rendered as: �*2:1��/*2:1�!');\n       expect(getTranslationForTemplate(message, 1)).toEqual('before�*1:2��/*1:2�after');\n       expect(getTranslationForTemplate(message, 2)).toEqual('middle');\n \n       // Embedded & sibling sub-templates\n       message =\n           `�0� is rendered as: �*2:1�before�*1:2�middle�/*1:2�after�/*2:1� and also �*4:3�before�*1:4�middle�/*1:4�after�/*4:3�!`;\n-      expect(getTranslationForTemplate(message))\n+      expect(getTranslationForTemplate(message, -1))\n           .toEqual('�0� is rendered as: �*2:1��/*2:1� and also �*4:3��/*4:3�!');\n       expect(getTranslationForTemplate(message, 1)).toEqual('before�*1:2��/*1:2�after');\n       expect(getTranslationForTemplate(message, 2)).toEqual('middle');\n@@ -51,40 +54,39 @@ describe('Runtime i18n', () => {\n \n     it('should throw if the template is malformed', () => {\n       const message = `�*2:1�message!`;\n-      expect(() => getTranslationForTemplate(message)).toThrowError(/Tag mismatch/);\n+      expect(() => getTranslationForTemplate(message, -1)).toThrowError(/Tag mismatch/);\n     });\n   });\n \n+  let tView: TView;\n+\n   function getOpCodes(\n-      messageOrAtrs: string|string[], createTemplate: () => void, updateTemplate: (() => void)|null,\n-      nbDecls: number, index: number): TI18n|I18nUpdateOpCodes {\n-    const fixture = new TemplateFixture({\n-      create: createTemplate,\n-      update: updateTemplate || undefined,\n-      decls: nbDecls,\n-      consts: [messageOrAtrs]\n-    });\n-    const tView = fixture.hostView[TVIEW];\n+      messageOrAtrs: string|string[], createTemplate: () => void,\n+      updateTemplate: (() => void)|undefined, nbDecls: number, index: number): TI18n|\n+      I18nUpdateOpCodes {\n+    const fixture = new TemplateFixture(\n+        {create: createTemplate, update: updateTemplate, decls: nbDecls, consts: [messageOrAtrs]});\n+    tView = fixture.hostView[TVIEW];\n     return tView.data[index + HEADER_OFFSET] as TI18n;\n   }\n \n   describe('i18nStart', () => {\n     it('for text', () => {\n       const message = 'simple text';\n       const nbConsts = 1;\n-      const index = 0;\n+      const index = 1;\n       const opCodes = getOpCodes(message, () => {\n+                        ɵɵelementStart(0, 'div');\n                         ɵɵi18nStart(index, 0);\n-                      }, null, nbConsts, index) as TI18n;\n+                        ɵɵelementEnd();\n+                      }, undefined, nbConsts, index) as TI18n;\n \n       expect(opCodes).toEqual({\n-        vars: 1,\n         create: debugMatch([\n-          'lView[1] = document.createTextNode(\"simple text\")',\n-          '(lView[0] as Element).appendChild(lView[1])'\n+          `lView[${HEADER_OFFSET + 1}] = document.createText(\"simple text\");`,\n+          `parent.appendChild(lView[${HEADER_OFFSET + 1}]);`,\n         ]),\n         update: [],\n-        icus: null\n       });\n     });\n \n@@ -95,29 +97,23 @@ describe('Runtime i18n', () => {\n       const nbConsts = 4;\n       const index = 1;\n       const opCodes = getOpCodes(message, () => {\n+        ɵɵelementStart(0, 'div');\n         ɵɵi18nStart(index, 0);\n-      }, null, nbConsts, index);\n+        ɵɵelementEnd();\n+      }, undefined, nbConsts, index);\n \n       expect(opCodes).toEqual({\n-        vars: 5,\n         create: debugMatch([\n-          'lView[4] = document.createTextNode(\"Hello \")',\n-          '(lView[1] as Element).appendChild(lView[4])',\n-          '(lView[1] as Element).appendChild(lView[2])',\n-          'lView[5] = document.createTextNode(\"world\")',\n-          '(lView[2] as Element).appendChild(lView[5])',\n-          'setCurrentTNode(tView.data[2] as TNode)',\n-          'lView[6] = document.createTextNode(\" and \")',\n-          '(lView[1] as Element).appendChild(lView[6])',\n-          '(lView[1] as Element).appendChild(lView[3])',\n-          'lView[7] = document.createTextNode(\"universe\")',\n-          '(lView[3] as Element).appendChild(lView[7])',\n-          'setCurrentTNode(tView.data[3] as TNode)',\n-          'lView[8] = document.createTextNode(\"!\")',\n-          '(lView[1] as Element).appendChild(lView[8])',\n+          `lView[${HEADER_OFFSET + 4}] = document.createText(\"Hello \");`,\n+          `parent.appendChild(lView[${HEADER_OFFSET + 4}]);`,\n+          `lView[${HEADER_OFFSET + 5}] = document.createText(\"world\");`,\n+          `lView[${HEADER_OFFSET + 6}] = document.createText(\" and \");`,\n+          `parent.appendChild(lView[${HEADER_OFFSET + 6}]);`,\n+          `lView[${HEADER_OFFSET + 7}] = document.createText(\"universe\");`,\n+          `lView[${HEADER_OFFSET + 8}] = document.createText(\"!\");`,\n+          `parent.appendChild(lView[${HEADER_OFFSET + 8}]);`,\n         ]),\n         update: [],\n-        icus: null\n       });\n     });\n \n@@ -126,22 +122,23 @@ describe('Runtime i18n', () => {\n       const nbConsts = 2;\n       const index = 1;\n       const opCodes = getOpCodes(message, () => {\n+        ɵɵelementStart(0, 'div');\n         ɵɵi18nStart(index, 0);\n-      }, null, nbConsts, index);\n+        ɵɵelementEnd();\n+      }, undefined, nbConsts, index);\n \n       expect((opCodes as any).update.debug).toEqual([\n-        'if (mask & 0b1) { (lView[2] as Text).textContent = `Hello ${lView[1]}!`; }'\n+        'if (mask & 0b1) { (lView[22] as Text).textContent = `Hello ${lView[i-1]}!`; }'\n       ]);\n \n       expect(opCodes).toEqual({\n-        vars: 1,\n         create: debugMatch([\n-          'lView[2] = document.createTextNode(\"\")',\n-          '(lView[1] as Element).appendChild(lView[2])',\n+          `lView[${HEADER_OFFSET + 2}] = document.createText(\"\");`,\n+          `parent.appendChild(lView[${HEADER_OFFSET + 2}]);`,\n+        ]),\n+        update: debugMatch([\n+          'if (mask & 0b1) { (lView[22] as Text).textContent = `Hello ${lView[i-1]}!`; }',\n         ]),\n-        update: debugMatch(\n-            ['if (mask & 0b1) { (lView[2] as Text).textContent = `Hello ${lView[1]}!`; }']),\n-        icus: null\n       });\n     });\n \n@@ -150,18 +147,19 @@ describe('Runtime i18n', () => {\n       const nbConsts = 2;\n       const index = 1;\n       const opCodes = getOpCodes(message, () => {\n+        ɵɵelementStart(0, 'div');\n         ɵɵi18nStart(index, 0);\n-      }, null, nbConsts, index);\n+        ɵɵelementEnd();\n+      }, undefined, nbConsts, index);\n \n       expect(opCodes).toEqual({\n-        vars: 1,\n         create: debugMatch([\n-          'lView[2] = document.createTextNode(\"\")', '(lView[1] as Element).appendChild(lView[2])'\n+          `lView[${HEADER_OFFSET + 2}] = document.createText(\"\");`,\n+          `parent.appendChild(lView[${HEADER_OFFSET + 2}]);`,\n         ]),\n         update: debugMatch([\n-          'if (mask & 0b11) { (lView[2] as Text).textContent = `Hello ${lView[1]} and ${lView[2]}, again ${lView[1]}!`; }'\n+          'if (mask & 0b11) { (lView[22] as Text).textContent = `Hello ${lView[i-1]} and ${lView[i-2]}, again ${lView[i-1]}!`; }',\n         ]),\n-        icus: null\n       });\n     });\n \n@@ -182,63 +180,56 @@ describe('Runtime i18n', () => {\n       let nbConsts = 3;\n       let index = 1;\n       let opCodes = getOpCodes(message, () => {\n+        ɵɵelementStart(0, 'div');\n         ɵɵi18nStart(index, 0);\n-      }, null, nbConsts, index);\n+        ɵɵelementEnd();\n+      }, undefined, nbConsts, index);\n \n       expect(opCodes).toEqual({\n-        vars: 2,\n         create: debugMatch([\n-          'lView[3] = document.createTextNode(\"\")', '(lView[1] as Element).appendChild(lView[3])',\n-          '(lView[1] as Element).appendChild(lView[16381])',\n-          'lView[4] = document.createTextNode(\"!\")', '(lView[1] as Element).appendChild(lView[4])'\n+          `lView[${HEADER_OFFSET + 3}] = document.createText(\"\");`,\n+          `parent.appendChild(lView[${HEADER_OFFSET + 3}]);`,\n+          `lView[${HEADER_OFFSET + 4}] = document.createText(\"!\");`,\n+          `parent.appendChild(lView[${HEADER_OFFSET + 4}]);`,\n         ]),\n         update: debugMatch([\n-          'if (mask & 0b1) { (lView[3] as Text).textContent = `${lView[1]} is rendered as: `; }'\n+          'if (mask & 0b1) { (lView[23] as Text).textContent = `${lView[i-1]} is rendered as: `; }',\n         ]),\n-        icus: null\n       });\n \n \n       /**** First sub-template ****/\n       // �#1:1�before�*2:2�middle�/*2:2�after�/#1:1�\n       nbConsts = 3;\n-      index = 0;\n+      index = 1;\n       opCodes = getOpCodes(message, () => {\n+        ɵɵelementStart(0, 'div');\n         ɵɵi18nStart(index, 0, 1);\n-      }, null, nbConsts, index);\n+      }, undefined, nbConsts, index);\n \n       expect(opCodes).toEqual({\n-        vars: 2,\n         create: debugMatch([\n-          '(lView[0] as Element).appendChild(lView[1])',\n-          'lView[3] = document.createTextNode(\"before\")',\n-          '(lView[1] as Element).appendChild(lView[3])',\n-          '(lView[1] as Element).appendChild(lView[16381])',\n-          'lView[4] = document.createTextNode(\"after\")',\n-          '(lView[1] as Element).appendChild(lView[4])', 'setCurrentTNode(tView.data[1] as TNode)'\n+          `lView[${HEADER_OFFSET + 3}] = document.createText(\"before\");`,\n+          `lView[${HEADER_OFFSET + 4}] = document.createText(\"after\");`,\n         ]),\n         update: [],\n-        icus: null\n       });\n \n \n       /**** Second sub-template ****/\n       // middle\n       nbConsts = 2;\n-      index = 0;\n+      index = 1;\n       opCodes = getOpCodes(message, () => {\n+        ɵɵelementStart(0, 'div');\n         ɵɵi18nStart(index, 0, 2);\n-      }, null, nbConsts, index);\n+      }, undefined, nbConsts, index);\n \n       expect(opCodes).toEqual({\n-        vars: 1,\n         create: debugMatch([\n-          '(lView[0] as Element).appendChild(lView[1])',\n-          'lView[2] = document.createTextNode(\"middle\")',\n-          '(lView[1] as Element).appendChild(lView[2])', 'setCurrentTNode(tView.data[1] as TNode)'\n+          `lView[${HEADER_OFFSET + 2}] = document.createText(\"middle\");`,\n         ]),\n         update: [],\n-        icus: null\n       });\n     });\n \n@@ -248,82 +239,81 @@ describe('Runtime i18n', () => {\n         =1 {one <i>email</i>}\n         other {�0� <span title=\"�1�\">emails</span>}\n       }`;\n-      const nbConsts = 1;\n-      const index = 0;\n+      const nbConsts = 2;\n+      const index = 1;\n       const opCodes = getOpCodes(message, () => {\n+                        ɵɵelementStart(0, 'div');\n                         ɵɵi18nStart(index, 0);\n-                      }, null, nbConsts, index) as TI18n;\n+                        ɵɵelementEnd();\n+                      }, undefined, nbConsts, index) as TI18n;\n \n       expect(opCodes).toEqual({\n-        vars: 6,\n-        update: debugMatch([\n-          'if (mask & 0b1) { icuSwitchCase(lView[1] as Comment, 0, `${lView[1]}`); }',\n-          'if (mask & 0b11) { icuUpdateCase(lView[1] as Comment, 0); }',\n-        ]),\n         create: debugMatch([\n-          'lView[1] = document.createComment(\"ICU 1\")',\n-          '(lView[0] as Element).appendChild(lView[1])',\n+          `lView[${HEADER_OFFSET + 2}] = document.createComment(\"ICU 1:0\");`,\n+          `parent.appendChild(lView[${HEADER_OFFSET + 2}]);`,\n+        ]),\n+        update: debugMatch([\n+          'if (mask & 0b1) { icuSwitchCase(22, `${lView[i-1]}`); }',\n+          'if (mask & 0b1) { icuUpdateCase(22); }',\n         ]),\n-        icus: [<TIcu>{\n-          type: 1,\n-          currentCaseLViewIndex: 22,\n-          vars: [5, 4, 4],\n-          childIcus: [[], [], []],\n-          cases: ['0', '1', 'other'],\n-          create: [\n-            debugMatch([\n-              'lView[3] = document.createTextNode(\"no \")',\n-              '(lView[1] as Element).appendChild(lView[3])',\n-              'lView[4] = document.createElement(\"b\")',\n-              '(lView[1] as Element).appendChild(lView[4])',\n-              '(lView[4] as Element).setAttribute(\"title\", \"none\")',\n-              'lView[5] = document.createTextNode(\"emails\")',\n-              '(lView[4] as Element).appendChild(lView[5])',\n-              'lView[6] = document.createTextNode(\"!\")',\n-              '(lView[1] as Element).appendChild(lView[6])',\n-            ]),\n-            debugMatch([\n-              'lView[3] = document.createTextNode(\"one \")',\n-              '(lView[1] as Element).appendChild(lView[3])',\n-              'lView[4] = document.createElement(\"i\")',\n-              '(lView[1] as Element).appendChild(lView[4])',\n-              'lView[5] = document.createTextNode(\"email\")',\n-              '(lView[4] as Element).appendChild(lView[5])',\n-            ]),\n-            debugMatch([\n-              'lView[3] = document.createTextNode(\"\")',\n-              '(lView[1] as Element).appendChild(lView[3])',\n-              'lView[4] = document.createElement(\"span\")',\n-              '(lView[1] as Element).appendChild(lView[4])',\n-              'lView[5] = document.createTextNode(\"emails\")',\n-              '(lView[4] as Element).appendChild(lView[5])',\n-            ])\n-          ],\n-          remove: [\n-            debugMatch([\n-              '(lView[0] as Element).remove(lView[3])',\n-              '(lView[0] as Element).remove(lView[5])',\n-              '(lView[0] as Element).remove(lView[4])',\n-              '(lView[0] as Element).remove(lView[6])',\n-            ]),\n-            debugMatch([\n-              '(lView[0] as Element).remove(lView[3])',\n-              '(lView[0] as Element).remove(lView[5])',\n-              '(lView[0] as Element).remove(lView[4])',\n-            ]),\n-            debugMatch([\n-              '(lView[0] as Element).remove(lView[3])',\n-              '(lView[0] as Element).remove(lView[5])',\n-              '(lView[0] as Element).remove(lView[4])',\n-            ])\n-          ],\n-          update: [\n-            debugMatch([]), debugMatch([]), debugMatch([\n-              'if (mask & 0b1) { (lView[3] as Text).textContent = `${lView[1]} `; }',\n-              'if (mask & 0b10) { (lView[4] as Element).setAttribute(\\'title\\', `${lView[2]}`); }'\n-            ])\n-          ]\n-        }]\n+      });\n+      expect(getTIcu(tView, 22)).toEqual(<TIcu>{\n+        type: 1,\n+        currentCaseLViewIndex: 23,\n+        anchorIdx: 22,\n+        cases: ['0', '1', 'other'],\n+        create: [\n+          debugMatch([\n+            `lView[${HEADER_OFFSET + 4}] = document.createTextNode(\"no \")`,\n+            `(lView[${HEADER_OFFSET + 0}] as Element).appendChild(lView[${HEADER_OFFSET + 4}])`,\n+            'lView[25] = document.createElement(\"b\")',\n+            `(lView[${HEADER_OFFSET + 0}] as Element).appendChild(lView[${HEADER_OFFSET + 5}])`,\n+            '(lView[25] as Element).setAttribute(\"title\", \"none\")',\n+            `lView[${HEADER_OFFSET + 6}] = document.createTextNode(\"emails\")`,\n+            `(lView[${HEADER_OFFSET + 5}] as Element).appendChild(lView[${HEADER_OFFSET + 6}])`,\n+            `lView[${HEADER_OFFSET + 7}] = document.createTextNode(\"!\")`,\n+            `(lView[${HEADER_OFFSET + 0}] as Element).appendChild(lView[${HEADER_OFFSET + 7}])`,\n+          ]),\n+          debugMatch([\n+            `lView[${HEADER_OFFSET + 8}] = document.createTextNode(\"one \")`,\n+            `(lView[${HEADER_OFFSET + 0}] as Element).appendChild(lView[${HEADER_OFFSET + 8}])`,\n+            'lView[29] = document.createElement(\"i\")',\n+            `(lView[${HEADER_OFFSET + 0}] as Element).appendChild(lView[${HEADER_OFFSET + 9}])`,\n+            'lView[30] = document.createTextNode(\"email\")',\n+            '(lView[29] as Element).appendChild(lView[30])',\n+          ]),\n+          debugMatch([\n+            'lView[31] = document.createTextNode(\"\")',\n+            '(lView[20] as Element).appendChild(lView[31])',\n+            'lView[32] = document.createElement(\"span\")',\n+            '(lView[20] as Element).appendChild(lView[32])',\n+            'lView[33] = document.createTextNode(\"emails\")',\n+            '(lView[32] as Element).appendChild(lView[33])',\n+          ]),\n+        ],\n+        remove: [\n+          debugMatch([\n+            '(lView[0] as Element).remove(lView[24])',\n+            '(lView[0] as Element).remove(lView[25])',\n+            '(lView[0] as Element).remove(lView[27])',\n+          ]),\n+          debugMatch([\n+            '(lView[0] as Element).remove(lView[28])',\n+            '(lView[0] as Element).remove(lView[29])',\n+          ]),\n+          debugMatch([\n+            '(lView[0] as Element).remove(lView[31])',\n+            '(lView[0] as Element).remove(lView[32])',\n+          ]),\n+        ],\n+        update: [\n+          debugMatch([]),\n+          debugMatch([]),\n+          debugMatch([\n+            'if (mask & 0b1) { (lView[31] as Text).textContent = `${lView[i-1]} `; }',\n+            'if (mask & 0b10) { (lView[32] as Element).setAttribute(\\'title\\', `${lView[i-2]}`); }',\n+          ]),\n+        ]\n       });\n     });\n \n@@ -336,91 +326,91 @@ describe('Runtime i18n', () => {\n                        other {animals}\n                      }!}\n       }`;\n-      const nbConsts = 1;\n-      const index = 0;\n+      const nbConsts = 2;\n+      const index = 1;\n       const opCodes = getOpCodes(message, () => {\n-        ɵɵi18nStart(index, 0);\n-      }, null, nbConsts, index);\n+        ɵɵelementStart(0, 'div');\n+        ɵɵi18n(index, 0);\n+        ɵɵelementEnd();\n+      }, undefined, nbConsts, index);\n \n       expect(opCodes).toEqual({\n-        vars: 9,\n         create: debugMatch([\n-          'lView[1] = document.createComment(\"ICU 1\")',\n-          '(lView[0] as Element).appendChild(lView[1])'\n+          `lView[${HEADER_OFFSET + 2}] = document.createComment(\"ICU 1:0\");`,\n+          `parent.appendChild(lView[${HEADER_OFFSET + 2}]);`,\n         ]),\n         update: debugMatch([\n-          'if (mask & 0b1) { icuSwitchCase(lView[1] as Comment, 1, `${lView[1]}`); }',\n-          'if (mask & 0b11) { icuUpdateCase(lView[1] as Comment, 1); }'\n+          'if (mask & 0b1) { icuSwitchCase(22, `${lView[i-1]}`); }',\n+          'if (mask & 0b10) { icuSwitchCase(26, `${lView[i-2]}`); }',\n+          'if (mask & 0b1) { icuUpdateCase(22); }',\n         ]),\n-        icus: [\n-          {\n-            type: 0,\n-            vars: [2, 2, 2],\n-            currentCaseLViewIndex: 26,\n-            childIcus: [[], [], []],\n-            cases: ['cat', 'dog', 'other'],\n-            create: [\n-              debugMatch([\n-                'lView[7] = document.createTextNode(\"cats\")',\n-                '(lView[4] as Element).appendChild(lView[7])'\n-              ]),\n-              debugMatch([\n-                'lView[7] = document.createTextNode(\"dogs\")',\n-                '(lView[4] as Element).appendChild(lView[7])'\n-              ]),\n-              debugMatch([\n-                'lView[7] = document.createTextNode(\"animals\")',\n-                '(lView[4] as Element).appendChild(lView[7])'\n-              ]),\n-            ],\n-            remove: [\n-              debugMatch(['(lView[0] as Element).remove(lView[7])']),\n-              debugMatch(['(lView[0] as Element).remove(lView[7])']),\n-              debugMatch(['(lView[0] as Element).remove(lView[7])'])\n-            ],\n-            update: [\n-              debugMatch([]),\n-              debugMatch([]),\n-              debugMatch([]),\n-            ]\n-          },\n-          {\n-            type: 1,\n-            vars: [2, 6],\n-            childIcus: [[], [0]],\n-            currentCaseLViewIndex: 22,\n-            cases: ['0', 'other'],\n-            create: [\n-              debugMatch([\n-                'lView[3] = document.createTextNode(\"zero\")',\n-                '(lView[1] as Element).appendChild(lView[3])'\n-              ]),\n-              debugMatch([\n-                'lView[3] = document.createTextNode(\"\")',\n-                '(lView[1] as Element).appendChild(lView[3])',\n-                'lView[4] = document.createComment(\"nested ICU 0\")',\n-                '(lView[1] as Element).appendChild(lView[4])',\n-                'lView[5] = document.createTextNode(\"!\")',\n-                '(lView[1] as Element).appendChild(lView[5])'\n-              ]),\n-            ],\n-            remove: [\n-              debugMatch(['(lView[0] as Element).remove(lView[3])']),\n-              debugMatch([\n-                '(lView[0] as Element).remove(lView[3])', '(lView[0] as Element).remove(lView[5])',\n-                'removeNestedICU(0)', '(lView[0] as Element).remove(lView[4])'\n-              ]),\n-            ],\n-            update: [\n-              debugMatch([]),\n-              debugMatch([\n-                'if (mask & 0b1) { (lView[3] as Text).textContent = `${lView[1]} `; }',\n-                'if (mask & 0b10) { icuSwitchCase(lView[4] as Comment, 0, `${lView[2]}`); }',\n-                'if (mask & 0b10) { icuUpdateCase(lView[4] as Comment, 0); }'\n-              ]),\n-            ]\n-          }\n-        ]\n+      });\n+      expect(getTIcu(tView, 22)).toEqual({\n+        type: 1,\n+        anchorIdx: 22,\n+        currentCaseLViewIndex: 23,\n+        cases: ['0', 'other'],\n+        create: [\n+          debugMatch([\n+            `lView[${HEADER_OFFSET + 4}] = document.createTextNode(\"zero\")`,\n+            `(lView[${HEADER_OFFSET + 0}] as Element).appendChild(lView[${HEADER_OFFSET + 4}])`,\n+          ]),\n+          debugMatch([\n+            `lView[${HEADER_OFFSET + 5}] = document.createTextNode(\"\")`,\n+            `(lView[${HEADER_OFFSET + 0}] as Element).appendChild(lView[${HEADER_OFFSET + 5}])`,\n+            'lView[26] = document.createComment(\"nested ICU 0\")',\n+            `(lView[${HEADER_OFFSET + 0}] as Element).appendChild(lView[${HEADER_OFFSET + 6}])`,\n+            'lView[31] = document.createTextNode(\"!\")',\n+            '(lView[20] as Element).appendChild(lView[31])',\n+          ]),\n+        ],\n+        update: [\n+          debugMatch([]),\n+          debugMatch([\n+            'if (mask & 0b1) { (lView[25] as Text).textContent = `${lView[i-1]} `; }',\n+          ]),\n+        ],\n+        remove: [\n+          debugMatch([\n+            '(lView[0] as Element).remove(lView[24])',\n+          ]),\n+          debugMatch([\n+            '(lView[0] as Element).remove(lView[25])',\n+            'removeNestedICU(26)',\n+            '(lView[0] as Element).remove(lView[26])',\n+            '(lView[0] as Element).remove(lView[31])',\n+          ]),\n+        ],\n+      });\n+      expect(tView.data[26]).toEqual({\n+        type: 0,\n+        anchorIdx: 26,\n+        currentCaseLViewIndex: 27,\n+        cases: ['cat', 'dog', 'other'],\n+        create: [\n+          debugMatch([\n+            `lView[${HEADER_OFFSET + 8}] = document.createTextNode(\"cats\")`,\n+            `(lView[${HEADER_OFFSET + 0}] as Element).appendChild(lView[${HEADER_OFFSET + 8}])`,\n+          ]),\n+          debugMatch([\n+            `lView[${HEADER_OFFSET + 9}] = document.createTextNode(\"dogs\")`,\n+            `(lView[${HEADER_OFFSET + 0}] as Element).appendChild(lView[${HEADER_OFFSET + 9}])`,\n+          ]),\n+          debugMatch([\n+            'lView[30] = document.createTextNode(\"animals\")',\n+            '(lView[20] as Element).appendChild(lView[30])',\n+          ]),\n+        ],\n+        update: [\n+          debugMatch([]),\n+          debugMatch([]),\n+          debugMatch([]),\n+        ],\n+        remove: [\n+          debugMatch(['(lView[0] as Element).remove(lView[28])']),\n+          debugMatch(['(lView[0] as Element).remove(lView[29])']),\n+          debugMatch(['(lView[0] as Element).remove(lView[30])'])\n+        ],\n       });\n     });\n   });\n@@ -459,10 +449,10 @@ describe('Runtime i18n', () => {\n         ɵɵelementStart(0, 'div');\n         ɵɵi18nAttributes(index, 0);\n         ɵɵelementEnd();\n-      }, null, nbConsts, index);\n+      }, undefined, nbConsts, index);\n \n       expect(opCodes).toEqual(debugMatch([\n-        'if (mask & 0b1) { (lView[0] as Element).setAttribute(\\'title\\', `Hello ${lView[1]}!`); }'\n+        'if (mask & 0b1) { (lView[20] as Element).setAttribute(\\'title\\', `Hello ${lView[i-1]}!`); }',\n       ]));\n     });\n \n@@ -475,10 +465,10 @@ describe('Runtime i18n', () => {\n         ɵɵelementStart(0, 'div');\n         ɵɵi18nAttributes(index, 0);\n         ɵɵelementEnd();\n-      }, null, nbConsts, index);\n+      }, undefined, nbConsts, index);\n \n       expect(opCodes).toEqual(debugMatch([\n-        'if (mask & 0b11) { (lView[0] as Element).setAttribute(\\'title\\', `Hello ${lView[1]} and ${lView[2]}, again ${lView[1]}!`); }'\n+        'if (mask & 0b11) { (lView[20] as Element).setAttribute(\\'title\\', `Hello ${lView[i-1]} and ${lView[i-2]}, again ${lView[i-1]}!`); }',\n       ]));\n     });\n \n@@ -491,11 +481,11 @@ describe('Runtime i18n', () => {\n         ɵɵelementStart(0, 'div');\n         ɵɵi18nAttributes(index, 0);\n         ɵɵelementEnd();\n-      }, null, nbConsts, index);\n+      }, undefined, nbConsts, index);\n \n       expect(opCodes).toEqual(debugMatch([\n-        'if (mask & 0b1) { (lView[0] as Element).setAttribute(\\'title\\', `Hello ${lView[1]}!`); }',\n-        'if (mask & 0b1) { (lView[0] as Element).setAttribute(\\'aria-label\\', `Hello ${lView[1]}!`); }'\n+        'if (mask & 0b1) { (lView[20] as Element).setAttribute(\\'title\\', `Hello ${lView[i-1]}!`); }',\n+        'if (mask & 0b1) { (lView[20] as Element).setAttribute(\\'aria-label\\', `Hello ${lView[i-1]}!`); }',\n       ]));\n     });\n   });\n@@ -638,4 +628,125 @@ describe('Runtime i18n', () => {\n           .toThrowError();\n     });\n   });\n-});\n\\ No newline at end of file\n+\n+  describe('i18nStartFirstCreatePass', () => {\n+    let fixture: ViewFixture;\n+    let divTNode: TElementNode;\n+    const DECLS = 20;\n+    const VARS = 10;\n+    beforeEach(() => {\n+      fixture = new ViewFixture({decls: DECLS, vars: VARS});\n+      fixture.enterView();\n+      ɵɵelementStart(0, 'div');\n+      divTNode = getCurrentTNode() as TElementNode;\n+    });\n+\n+    afterEach(ViewFixture.cleanUp);\n+\n+    function i18nRangeOffset(offset: number): number {\n+      return HEADER_OFFSET + DECLS + VARS + offset;\n+    }\n+\n+    function i18nRangeOffsetOpcode(\n+        offset: number,\n+        {appendLater, comment}: {appendLater?: boolean, comment?: boolean} = {}): number {\n+      let index = i18nRangeOffset(offset) << I18nCreateOpCode.SHIFT;\n+      if (!appendLater) {\n+        index |= I18nCreateOpCode.APPEND_EAGERLY;\n+      }\n+      if (comment) {\n+        index |= I18nCreateOpCode.COMMENT;\n+      }\n+      return index;\n+    }\n+\n+    it('should process text node with no siblings and no children', () => {\n+      i18nStartFirstCreatePass(fixture.tView, 0, fixture.lView, 1, 'Hello World!', -1);\n+      const ti18n = fixture.tView.data[HEADER_OFFSET + 1] as TI18n;\n+      // Expect that we only create the `Hello World!` text node and nothing else.\n+      expect(ti18n.create).toEqual([\n+        i18nRangeOffsetOpcode(0), 'Hello World!',  //\n+      ]);\n+      const lViewDebug = fixture.lView.debug!;\n+      expect(lViewDebug.template).toEqual('<div>#text</div>');\n+    });\n+\n+    it('should process text with a child node', () => {\n+      i18nStartFirstCreatePass(fixture.tView, 0, fixture.lView, 1, 'Hello �#2��/#2�!', -1);\n+      const ti18n = fixture.tView.data[HEADER_OFFSET + 1] as TI18n;\n+      expect(ti18n.create).toEqual([\n+        i18nRangeOffsetOpcode(0), 'Hello ',  //\n+        i18nRangeOffsetOpcode(1), '!',       //\n+      ]);\n+      // Leave behind `Placeholder` to be picked up by `TNode` creation.\n+      expect(fixture.tView.data[HEADER_OFFSET + 2]).toEqual(matchTNode({\n+        type: TNodeType.Placeholder,\n+        // It should insert itself in front of \"!\"\n+        insertBeforeIndex: i18nRangeOffset(1),\n+      }));\n+      const lViewDebug = fixture.lView.debug!;\n+      expect(lViewDebug.template).toEqual('<div>#text<Placeholder></Placeholder>#text</div>');\n+    });\n+\n+    it('should process text with a child node that has text', () => {\n+      i18nStartFirstCreatePass(fixture.tView, 0, fixture.lView, 1, 'Hello �#2�World�/#2�!', -1);\n+      const ti18n = fixture.tView.data[HEADER_OFFSET + 1] as TI18n;\n+      expect(ti18n.create).toEqual([\n+        i18nRangeOffsetOpcode(0), 'Hello ',                      //\n+        i18nRangeOffsetOpcode(1, {appendLater: true}), 'World',  //\n+        i18nRangeOffsetOpcode(2), '!',                           //\n+      ]);\n+      // Leave behind `Placeholder` to be picked up by `TNode` creation.\n+      expect(fixture.tView.data[HEADER_OFFSET + 2]).toEqual(matchTNode({\n+        type: TNodeType.Placeholder,\n+        insertBeforeIndex: [\n+          i18nRangeOffset(2),  // It should insert itself in front of \"!\"\n+          i18nRangeOffset(1),  // It should append \"World\"\n+        ]\n+      }));\n+    });\n+\n+    it('should process text with a child node that has text and with bindings', () => {\n+      i18nStartFirstCreatePass(\n+          fixture.tView, 0, fixture.lView, 1,\n+          '�0� �#2��1��/#2�!' /* {{salutation}} <b>{{name}}</b>! */, -1);\n+      const ti18n = fixture.tView.data[HEADER_OFFSET + 1] as TI18n;\n+      expect(ti18n.create).toEqual([\n+        i18nRangeOffsetOpcode(0), '',                       // 1 is saved for binding\n+        i18nRangeOffsetOpcode(1, {appendLater: true}), '',  // 3 is saved for binding\n+        i18nRangeOffsetOpcode(2), '!',                      //\n+      ]);\n+      // Leave behind `insertBeforeIndex` to be picked up by `TNode` creation.\n+      expect(fixture.tView.data[HEADER_OFFSET + 2]).toEqual(matchTNode({\n+        type: TNodeType.Placeholder,\n+        insertBeforeIndex: [\n+          i18nRangeOffset(2),  // It should insert itself in front of \"!\"\n+          i18nRangeOffset(1),  // It should append child text node \"{{name}}\"\n+        ],\n+      }));\n+      expect(ti18n.update).toEqual(debugMatch([\n+        'if (mask & 0b1) { (lView[50] as Text).textContent = `${lView[i-1]} `; }',\n+        'if (mask & 0b10) { (lView[51] as Text).textContent = `${lView[i-2]}`; }'\n+      ]));\n+      const lViewDebug = fixture.lView.debug!;\n+      expect(lViewDebug.template).toEqual('<div>#text<Placeholder>#text</Placeholder>#text</div>');\n+    });\n+\n+    it('should process text with a child template', () => {\n+      i18nStartFirstCreatePass(fixture.tView, 0, fixture.lView, 1, 'Hello �*2:1�World�/*2:1�!', -1);\n+      const ti18n = fixture.tView.data[HEADER_OFFSET + 1] as TI18n;\n+      expect(ti18n.create.debug).toEqual([\n+        'lView[50] = document.createText(\"Hello \");',\n+        'parent.appendChild(lView[50]);',\n+        'lView[51] = document.createText(\"!\");',\n+        'parent.appendChild(lView[51]);',\n+      ]);\n+      // Leave behind `Placeholder` to be picked up by `TNode` creation.\n+      // It should insert itself in front of \"!\"\n+      expect(fixture.tView.data[HEADER_OFFSET + 2]).toEqual(matchTNode({\n+        type: TNodeType.Placeholder,\n+        insertBeforeIndex: 51,\n+      }));\n+    });\n+  });\n+});"
        },
        {
            "sha": "68a8cb9306e5e049e2f33ddaf0d453796daa6dbd",
            "filename": "packages/core/test/render3/i18n_debug_spec.ts",
            "status": "modified",
            "additions": 33,
            "deletions": 25,
            "changes": 58,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Fi18n_debug_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Fi18n_debug_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Fi18n_debug_spec.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -6,8 +6,8 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {i18nMutateOpCodesToString, i18nUpdateOpCodesToString} from '@angular/core/src/render3/i18n/i18n_debug';\n-import {COMMENT_MARKER, ELEMENT_MARKER, I18nMutateOpCode, I18nUpdateOpCode} from '@angular/core/src/render3/interfaces/i18n';\n+import {i18nCreateOpCodesToString, i18nMutateOpCodesToString, i18nUpdateOpCodesToString} from '@angular/core/src/render3/i18n/i18n_debug';\n+import {COMMENT_MARKER, ELEMENT_MARKER, I18nCreateOpCode, I18nMutateOpCode, I18nUpdateOpCode} from '@angular/core/src/render3/interfaces/i18n';\n \n describe('i18n debug', () => {\n   describe('i18nUpdateOpCodesToString', () => {\n@@ -25,7 +25,7 @@ describe('i18n debug', () => {\n         1 << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.Text,\n       ]))\n           .toEqual(\n-              ['if (mask & 0b11) { (lView[1] as Text).textContent = `pre ${lView[4]} post`; }']);\n+              ['if (mask & 0b11) { (lView[1] as Text).textContent = `pre ${lView[i-4]} post`; }']);\n     });\n \n     it('should print Attribute opCode', () => {\n@@ -42,23 +42,21 @@ describe('i18n debug', () => {\n         'title', (v) => v,\n       ]))\n           .toEqual([\n-            'if (mask & 0b1) { (lView[1] as Element).setAttribute(\\'title\\', `pre ${lView[4]} in ${lView[3]} post`); }',\n-            'if (mask & 0b10) { (lView[1] as Element).setAttribute(\\'title\\', (function (v) { return v; })(`pre ${lView[4]} in ${lView[3]} post`)); }'\n+            'if (mask & 0b1) { (lView[1] as Element).setAttribute(\\'title\\', `pre ${lView[i-4]} in ${lView[i-3]} post`); }',\n+            'if (mask & 0b10) { (lView[1] as Element).setAttribute(\\'title\\', (function (v) { return v; })(`pre ${lView[i-4]} in ${lView[i-3]} post`)); }'\n           ]);\n     });\n \n     it('should print icuSwitch opCode', () => {\n       expect(i18nUpdateOpCodesToString([\n-        0b100, 2, -5, 12 << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuSwitch,\n-        2  // FIXME(misko): Should be part of IcuSwitch\n-      ])).toEqual(['if (mask & 0b100) { icuSwitchCase(lView[12] as Comment, 2, `${lView[5]}`); }']);\n+        0b100, 2, -5, 12 << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuSwitch\n+      ])).toEqual(['if (mask & 0b100) { icuSwitchCase(12, `${lView[i-5]}`); }']);\n     });\n \n     it('should print icuUpdate opCode', () => {\n       expect(i18nUpdateOpCodesToString([\n-        0b1000, 2, 13 << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuUpdate,\n-        3  // FIXME(misko): should be part of IcuUpdate\n-      ])).toEqual(['if (mask & 0b1000) { icuUpdateCase(lView[13] as Comment, 3); }']);\n+        0b1000, 1, 13 << I18nUpdateOpCode.SHIFT_REF | I18nUpdateOpCode.IcuUpdate\n+      ])).toEqual(['if (mask & 0b1000) { icuUpdateCase(13); }']);\n     });\n   });\n \n@@ -67,14 +65,6 @@ describe('i18n debug', () => {\n       expect(i18nMutateOpCodesToString([])).toEqual([]);\n     });\n \n-    it('should print Move', () => {\n-      expect(i18nMutateOpCodesToString([\n-        1 << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.Select,\n-        2 << I18nMutateOpCode.SHIFT_PARENT | 0 << I18nMutateOpCode.SHIFT_REF |\n-            I18nMutateOpCode.AppendChild,\n-      ])).toEqual(['(lView[2] as Element).appendChild(lView[1])']);\n-    });\n-\n     it('should print text AppendChild', () => {\n       expect(i18nMutateOpCodesToString([\n         'xyz', 0,\n@@ -125,16 +115,34 @@ describe('i18n debug', () => {\n       ])).toEqual(['(lView[1] as Element).setAttribute(\"attr\", \"value\")']);\n     });\n \n-    it('should print ElementEnd', () => {\n-      expect(i18nMutateOpCodesToString([\n-        1 << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.ElementEnd,\n-      ])).toEqual(['setCurrentTNode(tView.data[1] as TNode)']);\n-    });\n-\n     it('should print RemoveNestedIcu', () => {\n       expect(i18nMutateOpCodesToString([\n         1 << I18nMutateOpCode.SHIFT_REF | I18nMutateOpCode.RemoveNestedIcu,\n       ])).toEqual(['removeNestedICU(1)']);\n     });\n   });\n+\n+  describe('i18nCreateOpCodesToString', () => {\n+    it('should print nothing', () => {\n+      expect(i18nCreateOpCodesToString([])).toEqual([]);\n+    });\n+\n+    it('should print text/comment creation', () => {\n+      expect(i18nCreateOpCodesToString([\n+        10 << I18nCreateOpCode.SHIFT, 'text at 10',                                            //\n+        11 << I18nCreateOpCode.SHIFT | I18nCreateOpCode.APPEND_EAGERLY, 'text at 11, append',  //\n+        12 << I18nCreateOpCode.SHIFT | I18nCreateOpCode.COMMENT, 'comment at 12',              //\n+        13 << I18nCreateOpCode.SHIFT | I18nCreateOpCode.COMMENT | I18nCreateOpCode.APPEND_EAGERLY,\n+        'comment at 13, append',  //\n+      ]))\n+          .toEqual([\n+            'lView[10] = document.createText(\"text at 10\");',\n+            'lView[11] = document.createText(\"text at 11, append\");',\n+            'parent.appendChild(lView[11]);',\n+            'lView[12] = document.createComment(\"comment at 12\");',\n+            'lView[13] = document.createComment(\"comment at 13, append\");',\n+            'parent.appendChild(lView[13]);',\n+          ]);\n+    });\n+  });\n });"
        },
        {
            "sha": "972c6fa487b6f594f60c1caf8972f86d24864bb9",
            "filename": "packages/core/test/render3/is_shape_of.ts",
            "status": "modified",
            "additions": 20,
            "deletions": 3,
            "changes": 23,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Fis_shape_of.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Fis_shape_of.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Fis_shape_of.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {TI18n} from '@angular/core/src/render3/interfaces/i18n';\n+import {TI18n, TIcu} from '@angular/core/src/render3/interfaces/i18n';\n import {TNode} from '@angular/core/src/render3/interfaces/node';\n import {TView} from '@angular/core/src/render3/interfaces/view';\n \n@@ -75,10 +75,26 @@ export function isTI18n(obj: any): obj is TI18n {\n   return isShapeOf<TI18n>(obj, ShapeOfTI18n);\n }\n const ShapeOfTI18n: ShapeOf<TI18n> = {\n-  vars: true,\n   create: true,\n   update: true,\n-  icus: true,\n+};\n+\n+\n+/**\n+ * Determines if `obj` matches the shape `TIcu`.\n+ * @param obj\n+ */\n+export function isTIcu(obj: any): obj is TIcu {\n+  return isShapeOf<TIcu>(obj, ShapeOfTIcu);\n+}\n+const ShapeOfTIcu: ShapeOf<TIcu> = {\n+  type: true,\n+  anchorIdx: true,\n+  currentCaseLViewIndex: true,\n+  cases: true,\n+  create: true,\n+  remove: true,\n+  update: true\n };\n \n \n@@ -133,6 +149,7 @@ export function isTNode(obj: any): obj is TNode {\n const ShapeOfTNode: ShapeOf<TNode> = {\n   type: true,\n   index: true,\n+  insertBeforeIndex: true,\n   injectorIndex: true,\n   directiveStart: true,\n   directiveEnd: true,"
        },
        {
            "sha": "7e15888d100c465edaef99165dfb2007a854316d",
            "filename": "packages/core/test/render3/matchers.ts",
            "status": "modified",
            "additions": 53,
            "deletions": 16,
            "changes": 69,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Fmatchers.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Fmatchers.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Fmatchers.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -6,11 +6,11 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {TI18n} from '@angular/core/src/render3/interfaces/i18n';\n+import {I18nDebug, I18nMutateOpCodes, TI18n, TIcu} from '@angular/core/src/render3/interfaces/i18n';\n import {TNode} from '@angular/core/src/render3/interfaces/node';\n import {TView} from '@angular/core/src/render3/interfaces/view';\n \n-import {isDOMElement, isDOMText, isTI18n, isTNode, isTView} from './is_shape_of';\n+import {isDOMElement, isDOMText, isTI18n, isTIcu, isTNode, isTView} from './is_shape_of';\n \n \n /**\n@@ -37,22 +37,17 @@ export function matchObjectShape<T>(\n     return true;\n   };\n   matcher.jasmineToString = function() {\n-    return `${toString(_actual, false)} != ${toString(expected, true)})`;\n+    let errors: string[] = [];\n+    if (!_actual || typeof _actual !== 'object') {\n+      return `Expecting ${jasmine.pp(expect)} got ${jasmine.pp(_actual)}`;\n+    }\n+    for (const key in expected) {\n+      if (expected.hasOwnProperty(key) && !jasmine.matchersUtil.equals(_actual[key], expected[key]))\n+        errors.push(`\\n  property obj.${key} to equal ${expected[key]} but got ${_actual[key]}`);\n+    }\n+    return errors.join('\\n');\n   };\n \n-  function toString(obj: any, isExpected: boolean) {\n-    if (isExpected || shapePredicate(obj)) {\n-      const props =\n-          Object.keys(expected).map(key => `${key}: ${JSON.stringify((obj as any)[key])}`);\n-      if (isExpected === false) {\n-        // Push something to let the user know that there may be other ignored properties in actual\n-        props.push('...');\n-      }\n-      return `${name}({${props.length === 0 ? '' : '\\n  ' + props.join(',\\n  ') + '\\n'}})`;\n-    } else {\n-      return JSON.stringify(obj);\n-    }\n-  }\n   return matcher;\n }\n \n@@ -116,6 +111,26 @@ export function matchTI18n(expected?: Partial<TI18n>): jasmine.AsymmetricMatcher\n }\n \n \n+/**\n+ * Asymmetric matcher which matches a `T1cu` of a given shape.\n+ *\n+ * Expected usage:\n+ * ```\n+ * expect(tNode).toEqual(matchTIcu({type: TIcuType.select}));\n+ * expect({\n+ *   type: TIcuType.select\n+ * }).toEqual({\n+ *   node: matchT18n({type: TIcuType.select})\n+ * });\n+ * ```\n+ *\n+ * @param expected optional properties which the `TIcu` must contain.\n+ */\n+export function matchTIcu(expected?: Partial<TIcu>): jasmine.AsymmetricMatcher<TIcu> {\n+  return matchObjectShape('TIcu', isTIcu, expected);\n+}\n+\n+\n \n /**\n  * Asymmetric matcher which matches a DOM Element.\n@@ -214,5 +229,27 @@ export function matchDomText(expectedText: string|undefined = undefined):\n     return `[${actualStr} != ${expectedStr}]`;\n   };\n \n+  return matcher;\n+}\n+\n+export function matchI18nMutableOpCodes(expectedMutableOpCodes: string[]):\n+    jasmine.AsymmetricMatcher<I18nMutateOpCodes> {\n+  const matcher = function() {};\n+  let _actual: any = null;\n+\n+  matcher.asymmetricMatch = function(actual: any) {\n+    _actual = actual;\n+    if (!Array.isArray(actual)) return false;\n+    const debug = (actual as I18nDebug).debug as undefined | string[];\n+    if (expectedMutableOpCodes && (!jasmine.matchersUtil.equals(debug, expectedMutableOpCodes))) {\n+      return false;\n+    }\n+    return true;\n+  };\n+  matcher.jasmineToString = function() {\n+    const debug = (_actual as I18nDebug).debug as undefined | string[];\n+    return `[${JSON.stringify(debug)} != ${expectedMutableOpCodes}]`;\n+  };\n+\n   return matcher;\n }\n\\ No newline at end of file"
        },
        {
            "sha": "62fd5c76c47a083903367eca3d2315b944e18e42",
            "filename": "packages/core/test/render3/matchers_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 7,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Fmatchers_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Fmatchers_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Fmatchers_spec.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -41,13 +41,8 @@ describe('render3 matchers', () => {\n     it('should produce human readable errors', () => {\n       const matcher = matchMyShape({propA: 'different'});\n       expect(matcher.asymmetricMatch(myShape, [])).toEqual(false);\n-      expect(matcher.jasmineToString!()).toEqual(dedent`\n-        MyShape({\n-          propA: \"value\",\n-          ...\n-        }) != MyShape({\n-          propA: \"different\"\n-        }))`);\n+      expect(matcher.jasmineToString!())\n+          .toEqual('\\n  property obj.propA to equal different but got value');\n     });\n   });\n "
        },
        {
            "sha": "4787b18e5eb4a4c1c70598b5344e990f70c14ce8",
            "filename": "packages/core/test/render3/utils.ts",
            "status": "modified",
            "additions": 43,
            "deletions": 2,
            "changes": 45,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Futils.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -7,6 +7,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n+\n /** Template string function that can be used to strip indentation from a given string literal. */\n export function dedent(strings: TemplateStringsArray, ...values: any[]) {\n   let joinedString = '';\n@@ -59,15 +60,55 @@ function numOfWhiteSpaceLeadingChars(text: string): number {\n  *\n  * @param expected Expected value.\n  */\n+// FIXME(misko): rename to `matchDebug` to be consistent with other API.\n export function debugMatch<T>(expected: T): any {\n   const matcher = function() {};\n-  let actual: any = null;\n+  let actual: any = debugMatch;\n \n   matcher.asymmetricMatch = function(objectWithDebug: any) {\n     return jasmine.matchersUtil.equals(actual = objectWithDebug.debug, expected);\n   };\n   matcher.jasmineToString = function() {\n-    return `<${JSON.stringify(actual)} != ${JSON.stringify(expected)}>`;\n+    if (actual === debugMatch) {\n+      // `asymmetricMatch` never got called hence no error to display\n+      return '';\n+    }\n+    return buildFailureMessage(actual, expected);\n   };\n   return matcher;\n }\n+\n+export function buildFailureMessage(actual: any, expected: any): string {\n+  const diffs: string[] = [];\n+  listPropertyDifferences(diffs, '', actual, expected, 5);\n+  return '\\n  ' + diffs.join('\\n  ');\n+}\n+\n+function listPropertyDifferences(\n+    diffs: string[], path: string, actual: any, expected: any, depth: number) {\n+  if (actual === expected) return;\n+  if (typeof actual !== typeof expected) {\n+    diffs.push(`${path}: Expected ${jasmine.pp(actual)} to be ${jasmine.pp(expected)}`);\n+  } else if (depth && Array.isArray(expected)) {\n+    if (!Array.isArray(actual)) {\n+      diffs.push(`${path}: Expected ${jasmine.pp(expected)} but was ${jasmine.pp(actual)}`);\n+    } else {\n+      const maxLength = Math.max(actual.length, expected.length);\n+      listPropertyDifferences(diffs, path + '.length', expected.length, actual.length, depth - 1);\n+      for (let i = 0; i < maxLength; i++) {\n+        const actualItem = actual[i];\n+        const expectedItem = expected[i];\n+        listPropertyDifferences(diffs, path + '[' + i + ']', actualItem, expectedItem, depth - 1);\n+      }\n+    }\n+  } else if (\n+      depth && expected && typeof expected === 'object' && actual && typeof actual === 'object') {\n+    new Set(Object.keys(expected).concat(Object.keys(actual))).forEach((key) => {\n+      const actualItem = actual[key];\n+      const expectedItem = expected[key];\n+      listPropertyDifferences(diffs, path + '.' + key, actualItem, expectedItem, depth - 1);\n+    });\n+  } else {\n+    diffs.push(`${path}: Expected ${jasmine.pp(actual)} to be ${jasmine.pp(expected)}`);\n+  }\n+}"
        },
        {
            "sha": "f330e3f76c828cdb519ba8a6a2ef291b991b5621",
            "filename": "packages/core/test/render3/view_fixture.ts",
            "status": "added",
            "additions": 84,
            "deletions": 0,
            "changes": 84,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Fview_fixture.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Fview_fixture.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Fview_fixture.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -0,0 +1,84 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {ComponentTemplate} from '@angular/core/src/render3';\n+import {createLView, createTNode, createTView} from '@angular/core/src/render3/instructions/shared';\n+import {TConstants, TElementNode, TNodeType} from '@angular/core/src/render3/interfaces/node';\n+import {domRendererFactory3} from '@angular/core/src/render3/interfaces/renderer';\n+import {LView, LViewFlags, T_HOST, TView, TViewType} from '@angular/core/src/render3/interfaces/view';\n+import {enterView, leaveView, specOnlyIsInstructionStateEmpty} from '@angular/core/src/render3/state';\n+import {noop} from '@angular/core/src/util/noop';\n+\n+/**\n+ * Fixture useful for testing operations which need `LView` / `TView`\n+ */\n+export class ViewFixture {\n+  /**\n+   * Clean up the `LFrame` stack between tests.\n+   */\n+  static cleanUp() {\n+    while (!specOnlyIsInstructionStateEmpty()) {\n+      leaveView();\n+    }\n+  }\n+\n+  /**\n+   * DOM element which acts as a host to the `LView`.\n+   */\n+  host: HTMLElement;\n+\n+  tView: TView;\n+\n+  lView: LView;\n+\n+  constructor({template, decls, vars, consts, context}: {\n+    decls?: number,\n+    vars?: number,\n+    template?: ComponentTemplate<any>,\n+    consts?: TConstants,\n+    context?: {}\n+  } = {}) {\n+    const hostRenderer = domRendererFactory3.createRenderer(null, null);\n+    this.host = hostRenderer.createElement('host-element') as HTMLElement;\n+    const hostTView = createTView(TViewType.Root, null, null, 1, 0, null, null, null, null, null);\n+    const hostLView = createLView(\n+        null, hostTView, {}, LViewFlags.CheckAlways | LViewFlags.IsRoot, null, null,\n+        domRendererFactory3, hostRenderer, null, null);\n+\n+\n+    this.tView = createTView(\n+        TViewType.Component, null, template || noop, decls || 0, vars || 0, null, null, null, null,\n+        consts || null);\n+    const hostTNode =\n+        createTNode(hostTView, null, TNodeType.Element, 0, 'host-element', null) as TElementNode;\n+    this.lView = createLView(\n+        hostLView, this.tView, context || {}, LViewFlags.CheckAlways, this.host, hostTNode,\n+        domRendererFactory3, hostRenderer, null, null);\n+  }\n+\n+  /**\n+   * If you use `ViewFixture` and `enter()`, please add `afterEach(ViewFixture.cleanup);` to ensure\n+   * that he global `LFrame` stack gets cleaned up between the tests.\n+   */\n+  enterView() {\n+    enterView(this.lView);\n+  }\n+\n+  leaveView() {\n+    leaveView();\n+  }\n+\n+  apply(fn: () => void) {\n+    this.enterView();\n+    try {\n+      fn();\n+    } finally {\n+      this.leaveView();\n+    }\n+  }\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "f5d38a0adf04cc6593a0dfe0eb9eb202e5132247",
            "filename": "packages/core/test/render3/view_utils_spec.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 9,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Fview_utils_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fcore%2Ftest%2Frender3%2Fview_utils_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Fview_utils_spec.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -6,22 +6,21 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {createLContainer, createLView, createTNode, createTView} from '@angular/core/src/render3/instructions/shared';\n+import {createLContainer, createTNode} from '@angular/core/src/render3/instructions/shared';\n import {isLContainer, isLView} from '@angular/core/src/render3/interfaces/type_checks';\n-import {TViewType} from '@angular/core/src/render3/interfaces/view';\n+import {ViewFixture} from './view_fixture';\n \n describe('view_utils', () => {\n-  it('should verify unwrap methods', () => {\n-    const div = document.createElement('div');\n-    const tView = createTView(TViewType.Root, null, null, 0, 0, null, null, null, null, null);\n-    const lView = createLView(null, tView, {}, 0, div, null, {} as any, {} as any, null, null);\n+  it('should verify unwrap methods (isLView and isLContainer)', () => {\n+    const viewFixture = new ViewFixture();\n     const tNode = createTNode(null!, null, 3, 0, 'div', []);\n-    const lContainer = createLContainer(lView, lView, div, tNode);\n+    const lContainer =\n+        createLContainer(viewFixture.lView, viewFixture.lView, viewFixture.host, tNode);\n \n-    expect(isLView(lView)).toBe(true);\n+    expect(isLView(viewFixture.lView)).toBe(true);\n     expect(isLView(lContainer)).toBe(false);\n \n-    expect(isLContainer(lView)).toBe(false);\n+    expect(isLContainer(viewFixture.lView)).toBe(false);\n     expect(isLContainer(lContainer)).toBe(true);\n   });\n });"
        },
        {
            "sha": "a7f6adffa6bb5e1c95cc0da06880499ca7bc87db",
            "filename": "packages/platform-browser/animations/src/animation_renderer.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fplatform-browser%2Fanimations%2Fsrc%2Fanimation_renderer.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca11ef237608378e60255bc0a813f984e963e68c/packages%2Fplatform-browser%2Fanimations%2Fsrc%2Fanimation_renderer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser%2Fanimations%2Fsrc%2Fanimation_renderer.ts?ref=ca11ef237608378e60255bc0a813f984e963e68c",
            "patch": "@@ -166,9 +166,10 @@ export class BaseAnimationRenderer implements Renderer2 {\n     this.engine.onInsert(this.namespaceId, newChild, parent, false);\n   }\n \n-  insertBefore(parent: any, newChild: any, refChild: any): void {\n+  insertBefore(parent: any, newChild: any, refChild: any, isMove: boolean = true): void {\n     this.delegate.insertBefore(parent, newChild, refChild);\n-    this.engine.onInsert(this.namespaceId, newChild, parent, true);\n+    // If `isMove` true than we should animate this insert.\n+    this.engine.onInsert(this.namespaceId, newChild, parent, isMove);\n   }\n \n   removeChild(parent: any, oldChild: any, isHostElement: boolean): void {"
        }
    ],
    "stats": {
        "total": 4897,
        "additions": 3262,
        "deletions": 1635
    }
}