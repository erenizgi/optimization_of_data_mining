{
    "author": "JoostK",
    "message": "perf(compiler-cli): optimize cycle detection using a persistent cache (#41271)\n\nFor the compilation of a component, the compiler verifies that the\nimports it needs to generate to reference the used directives and pipes\nwould not create an import cycle in the program. This requires visiting\nthe transitive import graphs of all directive/pipe usage in search of\nthe component file. The observation can be made that all directive/pipe\nusages can leverage the exploration work in search of the component\nfile, thereby allowing sub-graphs of the import graph to be only visited\nonce instead of repeatedly per usage. Additionally, the transitive\nimports of a file are no longer collected into a set to reduce memory\npressure.\n\nPR Close #41271",
    "sha": "07d7e6034f2a9adae643b3a8e64e2cc794596c8c",
    "files": [
        {
            "sha": "237ba044151e32231a10ade3a640d327b6f4ca99",
            "filename": "packages/compiler-cli/src/ngtsc/cycles/src/analyzer.ts",
            "status": "modified",
            "additions": 87,
            "deletions": 3,
            "changes": 90,
            "blob_url": "https://github.com/angular/angular/blob/07d7e6034f2a9adae643b3a8e64e2cc794596c8c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Fsrc%2Fanalyzer.ts",
            "raw_url": "https://github.com/angular/angular/raw/07d7e6034f2a9adae643b3a8e64e2cc794596c8c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Fsrc%2Fanalyzer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Fsrc%2Fanalyzer.ts?ref=07d7e6034f2a9adae643b3a8e64e2cc794596c8c",
            "patch": "@@ -14,6 +14,14 @@ import {ImportGraph} from './imports';\n  * Analyzes a `ts.Program` for cycles.\n  */\n export class CycleAnalyzer {\n+  /**\n+   * Cycle detection is requested with the same `from` source file for all used directives and pipes\n+   * within a component, which makes it beneficial to cache the results as long as the `from` source\n+   * file has not changed. This avoids visiting the import graph that is reachable from multiple\n+   * directives/pipes more than once.\n+   */\n+  private cachedResults: CycleResults|null = null;\n+\n   constructor(private importGraph: ImportGraph) {}\n \n   /**\n@@ -24,10 +32,13 @@ export class CycleAnalyzer {\n    *     otherwise.\n    */\n   wouldCreateCycle(from: ts.SourceFile, to: ts.SourceFile): Cycle|null {\n+    // Try to reuse the cached results as long as the `from` source file is the same.\n+    if (this.cachedResults === null || this.cachedResults.from !== from) {\n+      this.cachedResults = new CycleResults(from, this.importGraph);\n+    }\n+\n     // Import of 'from' -> 'to' is illegal if an edge 'to' -> 'from' already exists.\n-    return this.importGraph.transitiveImportsOf(to).has(from) ?\n-        new Cycle(this.importGraph, from, to) :\n-        null;\n+    return this.cachedResults.wouldBeCyclic(to) ? new Cycle(this.importGraph, from, to) : null;\n   }\n \n   /**\n@@ -37,10 +48,83 @@ export class CycleAnalyzer {\n    * import graph for cycle creation.\n    */\n   recordSyntheticImport(from: ts.SourceFile, to: ts.SourceFile): void {\n+    this.cachedResults = null;\n     this.importGraph.addSyntheticImport(from, to);\n   }\n }\n \n+const NgCyclicResult = Symbol('NgCyclicResult');\n+type CyclicResultMarker = {\n+  __brand: 'CyclicResultMarker';\n+};\n+type CyclicSourceFile = ts.SourceFile&{[NgCyclicResult]?: CyclicResultMarker};\n+\n+/**\n+ * Stores the results of cycle detection in a memory efficient manner. A symbol is attached to\n+ * source files that indicate what the cyclic analysis result is, as indicated by two markers that\n+ * are unique to this instance. This alleviates memory pressure in large import graphs, as each\n+ * execution is able to store its results in the same memory location (i.e. in the symbol\n+ * on the source file) as earlier executions.\n+ */\n+class CycleResults {\n+  private readonly cyclic = {} as CyclicResultMarker;\n+  private readonly acyclic = {} as CyclicResultMarker;\n+\n+  constructor(readonly from: ts.SourceFile, private importGraph: ImportGraph) {}\n+\n+  wouldBeCyclic(sf: ts.SourceFile): boolean {\n+    const cached = this.getCachedResult(sf);\n+    if (cached !== null) {\n+      // The result for this source file has already been computed, so return its result.\n+      return cached;\n+    }\n+\n+    if (sf === this.from) {\n+      // We have reached the source file that we want to create an import from, which means that\n+      // doing so would create a cycle.\n+      return true;\n+    }\n+\n+    // Assume for now that the file will be acyclic; this prevents infinite recursion in the case\n+    // that `sf` is visited again as part of an existing cycle in the graph.\n+    this.markAcyclic(sf);\n+\n+    const imports = this.importGraph.importsOf(sf);\n+    for (const imported of imports) {\n+      if (this.wouldBeCyclic(imported)) {\n+        this.markCyclic(sf);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Returns whether the source file is already known to be cyclic, or `null` if the result is not\n+   * yet known.\n+   */\n+  private getCachedResult(sf: CyclicSourceFile): boolean|null {\n+    const result = sf[NgCyclicResult];\n+    if (result === this.cyclic) {\n+      return true;\n+    } else if (result === this.acyclic) {\n+      return false;\n+    } else {\n+      // Either the symbol is missing or its value does not correspond with one of the current\n+      // result markers. As such, the result is unknown.\n+      return null;\n+    }\n+  }\n+\n+  private markCyclic(sf: CyclicSourceFile): void {\n+    sf[NgCyclicResult] = this.cyclic;\n+  }\n+\n+  private markAcyclic(sf: CyclicSourceFile): void {\n+    sf[NgCyclicResult] = this.acyclic;\n+  }\n+}\n+\n /**\n  * Represents an import cycle between `from` and `to` in the program.\n  *"
        },
        {
            "sha": "f55806ef9ac39efc19f4741e2e50ed8038b8a04b",
            "filename": "packages/compiler-cli/src/ngtsc/cycles/src/imports.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 23,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/07d7e6034f2a9adae643b3a8e64e2cc794596c8c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Fsrc%2Fimports.ts",
            "raw_url": "https://github.com/angular/angular/raw/07d7e6034f2a9adae643b3a8e64e2cc794596c8c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Fsrc%2Fimports.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Fsrc%2Fimports.ts?ref=07d7e6034f2a9adae643b3a8e64e2cc794596c8c",
            "patch": "@@ -17,7 +17,7 @@ import {PerfPhase, PerfRecorder} from '../../perf';\n  * dependencies within the same program are tracked; imports into packages on NPM are not.\n  */\n export class ImportGraph {\n-  private map = new Map<ts.SourceFile, Set<ts.SourceFile>>();\n+  private imports = new Map<ts.SourceFile, Set<ts.SourceFile>>();\n \n   constructor(private checker: ts.TypeChecker, private perf: PerfRecorder) {}\n \n@@ -27,29 +27,10 @@ export class ImportGraph {\n    * This operation is cached.\n    */\n   importsOf(sf: ts.SourceFile): Set<ts.SourceFile> {\n-    if (!this.map.has(sf)) {\n-      this.map.set(sf, this.scanImports(sf));\n+    if (!this.imports.has(sf)) {\n+      this.imports.set(sf, this.scanImports(sf));\n     }\n-    return this.map.get(sf)!;\n-  }\n-\n-  /**\n-   * Lists the transitive imports of a given `ts.SourceFile`.\n-   */\n-  transitiveImportsOf(sf: ts.SourceFile): Set<ts.SourceFile> {\n-    const imports = new Set<ts.SourceFile>();\n-    this.transitiveImportsOfHelper(sf, imports);\n-    return imports;\n-  }\n-\n-  private transitiveImportsOfHelper(sf: ts.SourceFile, results: Set<ts.SourceFile>): void {\n-    if (results.has(sf)) {\n-      return;\n-    }\n-    results.add(sf);\n-    this.importsOf(sf).forEach(imported => {\n-      this.transitiveImportsOfHelper(imported, results);\n-    });\n+    return this.imports.get(sf)!;\n   }\n \n   /**"
        },
        {
            "sha": "e333aabc0541d94e8423ae8714394a400e88a3f1",
            "filename": "packages/compiler-cli/src/ngtsc/cycles/test/analyzer_spec.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/07d7e6034f2a9adae643b3a8e64e2cc794596c8c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Ftest%2Fanalyzer_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/07d7e6034f2a9adae643b3a8e64e2cc794596c8c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Ftest%2Fanalyzer_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Ftest%2Fanalyzer_spec.ts?ref=07d7e6034f2a9adae643b3a8e64e2cc794596c8c",
            "patch": "@@ -36,6 +36,22 @@ runInEachFileSystem(() => {\n       expect(importPath(cycle!.getPath())).toEqual('b,a,b');\n     });\n \n+    it('should deal with cycles', () => {\n+      // a -> b -> c -> d\n+      //      ^---------/\n+      const {program, analyzer} = makeAnalyzer('a:b;b:c;c:d;d:b');\n+      const a = getSourceFileOrError(program, (_('/a.ts')));\n+      const b = getSourceFileOrError(program, (_('/b.ts')));\n+      const c = getSourceFileOrError(program, (_('/c.ts')));\n+      const d = getSourceFileOrError(program, (_('/d.ts')));\n+      expect(analyzer.wouldCreateCycle(a, b)).toBe(null);\n+      expect(analyzer.wouldCreateCycle(a, c)).toBe(null);\n+      expect(analyzer.wouldCreateCycle(a, d)).toBe(null);\n+      expect(analyzer.wouldCreateCycle(b, a)).not.toBe(null);\n+      expect(analyzer.wouldCreateCycle(b, c)).not.toBe(null);\n+      expect(analyzer.wouldCreateCycle(b, d)).not.toBe(null);\n+    });\n+\n     it('should detect a cycle with a re-export in the chain', () => {\n       const {program, analyzer} = makeAnalyzer('a:*b;b:c;c');\n       const a = getSourceFileOrError(program, (_('/a.ts')));"
        },
        {
            "sha": "f721aa3a00d2e85e5e43f1f517a9e484b7f52262",
            "filename": "packages/compiler-cli/src/ngtsc/cycles/test/imports_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 28,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/07d7e6034f2a9adae643b3a8e64e2cc794596c8c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Ftest%2Fimports_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/07d7e6034f2a9adae643b3a8e64e2cc794596c8c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Ftest%2Fimports_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Ftest%2Fimports_spec.ts?ref=07d7e6034f2a9adae643b3a8e64e2cc794596c8c",
            "patch": "@@ -28,34 +28,6 @@ runInEachFileSystem(() => {\n       });\n     });\n \n-    describe('transitiveImportsOf()', () => {\n-      it('should calculate transitive imports of a simple program', () => {\n-        const {program, graph} = makeImportGraph('a:b;b:c;c');\n-        const a = getSourceFileOrError(program, (_('/a.ts')));\n-        const b = getSourceFileOrError(program, (_('/b.ts')));\n-        const c = getSourceFileOrError(program, (_('/c.ts')));\n-        expect(importsToString(graph.transitiveImportsOf(a))).toBe('a,b,c');\n-      });\n-\n-      it('should calculate transitive imports in a more complex program (with a cycle)', () => {\n-        const {program, graph} = makeImportGraph('a:*b,*c;b:*e,*f;c:*g,*h;e:f;f;g:e;h:g');\n-        const c = getSourceFileOrError(program, (_('/c.ts')));\n-        expect(importsToString(graph.transitiveImportsOf(c))).toBe('c,e,f,g,h');\n-      });\n-\n-      it('should reflect the addition of a synthetic import', () => {\n-        const {program, graph} = makeImportGraph('a:b,c,d;b;c;d:b');\n-        const b = getSourceFileOrError(program, (_('/b.ts')));\n-        const c = getSourceFileOrError(program, (_('/c.ts')));\n-        const d = getSourceFileOrError(program, (_('/d.ts')));\n-        expect(importsToString(graph.importsOf(b))).toEqual('');\n-        expect(importsToString(graph.transitiveImportsOf(d))).toEqual('b,d');\n-        graph.addSyntheticImport(b, c);\n-        expect(importsToString(graph.importsOf(b))).toEqual('c');\n-        expect(importsToString(graph.transitiveImportsOf(d))).toEqual('b,c,d');\n-      });\n-    });\n-\n     describe('findPath()', () => {\n       it('should be able to compute the path between two source files if there is a cycle', () => {\n         const {program, graph} = makeImportGraph('a:*b,*c;b:*e,*f;c:*g,*h;e:f;f;g:e;h:g');"
        }
    ],
    "stats": {
        "total": 161,
        "additions": 107,
        "deletions": 54
    }
}