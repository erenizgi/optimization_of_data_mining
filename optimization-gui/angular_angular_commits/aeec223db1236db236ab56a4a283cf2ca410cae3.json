{
    "author": "crisbeto",
    "message": "feat(forms): add migration for AbstractControl.parent accesses (#39009)\n\nAs of #32671, the type of `AbstractControl.parent` can be null which can cause\ncompilation errors in existing apps. These changes add a migration that will append\nnon-null assertions to existing unsafe accesses.\n\n````\n// Before\nconsole.log(control.parent.value);\n\n// After\nconsole.log(control.parent!.value);\n```\n\nThe migration also tries its best to avoid cases where the non-null assertions aren't\nnecessary (e.g. if the `parent` was null checked already).\n\nPR Close #39009",
    "sha": "aeec223db1236db236ab56a4a283cf2ca410cae3",
    "files": [
        {
            "sha": "9d665c57631ed956347750af39ab1cfc33addd4f",
            "filename": "packages/core/schematics/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/aeec223db1236db236ab56a4a283cf2ca410cae3/packages%2Fcore%2Fschematics%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/aeec223db1236db236ab56a4a283cf2ca410cae3/packages%2Fcore%2Fschematics%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2FBUILD.bazel?ref=aeec223db1236db236ab56a4a283cf2ca410cae3",
            "patch": "@@ -10,6 +10,7 @@ pkg_npm(\n     srcs = [\"migrations.json\"],\n     visibility = [\"//packages/core:__pkg__\"],\n     deps = [\n+        \"//packages/core/schematics/migrations/abstract-control-parent\",\n         \"//packages/core/schematics/migrations/dynamic-queries\",\n         \"//packages/core/schematics/migrations/missing-injectable\",\n         \"//packages/core/schematics/migrations/module-with-providers\","
        },
        {
            "sha": "4e5191af2af36ae5473c43c9b37d60054df08986",
            "filename": "packages/core/schematics/migrations.json",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/aeec223db1236db236ab56a4a283cf2ca410cae3/packages%2Fcore%2Fschematics%2Fmigrations.json",
            "raw_url": "https://github.com/angular/angular/raw/aeec223db1236db236ab56a4a283cf2ca410cae3/packages%2Fcore%2Fschematics%2Fmigrations.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations.json?ref=aeec223db1236db236ab56a4a283cf2ca410cae3",
            "patch": "@@ -54,6 +54,11 @@\n       \"version\": \"11.0.0-beta\",\n       \"description\": \"The default value for `relativeLinkResolution` is changing from 'legacy' to 'corrected'.\\nThis migration updates `RouterModule` configurations that use the default value to \\nnow specifically use 'legacy' to prevent breakages when updating.\",\n       \"factory\": \"./migrations/relative-link-resolution/index\"\n+    },\n+    \"migration-v11-abstract-control-parent\": {\n+      \"version\": \"11.0.0-beta\",\n+      \"description\": \"In Angular version 11, the type of `AbstractControl.parent` can be `null` to reflect the runtime value more accurately. This migration automatically adds non-null assertions to existing accesses of the `parent` property on types like `FormControl`, `FormArray` and `FormGroup`.\",\n+      \"factory\": \"./migrations/abstract-control-parent/index\"\n     }\n   }\n }"
        },
        {
            "sha": "c78e69f55f13e33bde6639a591cf8f54c742e432",
            "filename": "packages/core/schematics/migrations/abstract-control-parent/BUILD.bazel",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/aeec223db1236db236ab56a4a283cf2ca410cae3/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/aeec223db1236db236ab56a4a283cf2ca410cae3/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2FBUILD.bazel?ref=aeec223db1236db236ab56a4a283cf2ca410cae3",
            "patch": "@@ -0,0 +1,18 @@\n+load(\"//tools:defaults.bzl\", \"ts_library\")\n+\n+ts_library(\n+    name = \"abstract-control-parent\",\n+    srcs = glob([\"**/*.ts\"]),\n+    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n+    visibility = [\n+        \"//packages/core/schematics:__pkg__\",\n+        \"//packages/core/schematics/migrations/google3:__pkg__\",\n+        \"//packages/core/schematics/test:__pkg__\",\n+    ],\n+    deps = [\n+        \"//packages/core/schematics/utils\",\n+        \"@npm//@angular-devkit/schematics\",\n+        \"@npm//@types/node\",\n+        \"@npm//typescript\",\n+    ],\n+)"
        },
        {
            "sha": "b40ca8deda773cd25352a8d9330a2463bcd840be",
            "filename": "packages/core/schematics/migrations/abstract-control-parent/README.md",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/angular/angular/blob/aeec223db1236db236ab56a4a283cf2ca410cae3/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/aeec223db1236db236ab56a4a283cf2ca410cae3/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2FREADME.md?ref=aeec223db1236db236ab56a4a283cf2ca410cae3",
            "patch": "@@ -0,0 +1,34 @@\n+## `AbstractControl.parent` migration\n+\n+As of Angular v11, the type of `AbstractControl.parent` can be null. This migration automatically\n+identifies usages and adds non-null assertions.\n+\n+#### Before\n+```ts\n+import { Component } from '@angular/core';\n+import { FormControl } from '@angular/forms';\n+\n+@Component()\n+export class MyComponent {\n+  private _control = new FormControl();\n+\n+  getParentValue() {\n+    return this._control.parent.value; // <- Compilation error in v11.\n+  }\n+}\n+```\n+\n+#### After\n+```ts\n+import { Component } from '@angular/core';\n+import { FormControl } from '@angular/forms';\n+\n+@Component()\n+export class MyComponent {\n+  private _control = new FormControl();\n+\n+  getParentValue() {\n+    return this._control.parent!.value; // <- Non-null assertion added during the migration.\n+  }\n+}\n+```"
        },
        {
            "sha": "9aea59128b87b7301fbae4bbf34fc5b6bce00c3a",
            "filename": "packages/core/schematics/migrations/abstract-control-parent/index.ts",
            "status": "added",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/angular/angular/blob/aeec223db1236db236ab56a4a283cf2ca410cae3/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/aeec223db1236db236ab56a4a283cf2ca410cae3/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2Findex.ts?ref=aeec223db1236db236ab56a4a283cf2ca410cae3",
            "patch": "@@ -0,0 +1,57 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\n+import {relative} from 'path';\n+\n+import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n+import {createMigrationProgram} from '../../utils/typescript/compiler_host';\n+import {findParentAccesses} from './util';\n+\n+\n+/** Migration that marks accesses of `AbstractControl.parent` as non-null. */\n+export default function(): Rule {\n+  return (tree: Tree) => {\n+    const {buildPaths, testPaths} = getProjectTsConfigPaths(tree);\n+    const basePath = process.cwd();\n+    const allPaths = [...buildPaths, ...testPaths];\n+\n+    if (!allPaths.length) {\n+      throw new SchematicsException(\n+          'Could not find any tsconfig file. Cannot migrate AbstractControl.parent accesses.');\n+    }\n+\n+    for (const tsconfigPath of allPaths) {\n+      runNativeAbstractControlParentMigration(tree, tsconfigPath, basePath);\n+    }\n+  };\n+}\n+\n+function runNativeAbstractControlParentMigration(\n+    tree: Tree, tsconfigPath: string, basePath: string) {\n+  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n+  const typeChecker = program.getTypeChecker();\n+  const sourceFiles = program.getSourceFiles().filter(\n+      f => !f.isDeclarationFile && !program.isSourceFileFromExternalLibrary(f));\n+\n+  sourceFiles.forEach(sourceFile => {\n+    // We sort the nodes based on their position in the file and we offset the positions by one\n+    // for each non-null assertion that we've added. We have to do it this way, rather than\n+    // creating and printing a new AST node like in other migrations, because property access\n+    // expressions can be nested (e.g. `control.parent.parent.value`), but the node positions\n+    // aren't being updated as we're inserting new code. If we were to go through the AST,\n+    // we'd have to update the `SourceFile` and start over after each operation.\n+    findParentAccesses(typeChecker, sourceFile)\n+        .sort((a, b) => a.getStart() - b.getStart())\n+        .forEach((node, index) => {\n+          const update = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n+          update.insertRight(node.getStart() + node.getWidth() + index, '!');\n+          tree.commitUpdate(update);\n+        });\n+  });\n+}"
        },
        {
            "sha": "f5e47c516fc292ea002362aa22a0062518780857",
            "filename": "packages/core/schematics/migrations/abstract-control-parent/util.ts",
            "status": "added",
            "additions": 155,
            "deletions": 0,
            "changes": 155,
            "blob_url": "https://github.com/angular/angular/blob/aeec223db1236db236ab56a4a283cf2ca410cae3/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/aeec223db1236db236ab56a4a283cf2ca410cae3/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2Futil.ts?ref=aeec223db1236db236ab56a4a283cf2ca410cae3",
            "patch": "@@ -0,0 +1,155 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {normalize} from 'path';\n+import * as ts from 'typescript';\n+\n+/** Names of symbols from `@angular/forms` whose `parent` accesses have to be migrated. */\n+const abstractControlSymbols = new Set<string>([\n+  'AbstractControl',\n+  'FormArray',\n+  'FormControl',\n+  'FormGroup',\n+]);\n+\n+/**\n+ * Finds the `PropertyAccessExpression`-s that are accessing the `parent` property in\n+ * such a way that may result in a compilation error after the v11 type changes.\n+ */\n+export function findParentAccesses(\n+    typeChecker: ts.TypeChecker, sourceFile: ts.SourceFile): ts.PropertyAccessExpression[] {\n+  const results: ts.PropertyAccessExpression[] = [];\n+\n+  sourceFile.forEachChild(function walk(node: ts.Node) {\n+    if (ts.isPropertyAccessExpression(node) && node.name.text === 'parent' && !isNullCheck(node) &&\n+        !isSafeAccess(node) && results.indexOf(node) === -1 &&\n+        isAbstractControlReference(typeChecker, node) && isNullableType(typeChecker, node)) {\n+      results.unshift(node);\n+    }\n+\n+    node.forEachChild(walk);\n+  });\n+\n+  return results;\n+}\n+\n+/** Checks whether a node's type is nullable (`null`, `undefined` or `void`). */\n+function isNullableType(typeChecker: ts.TypeChecker, node: ts.Node) {\n+  // Skip expressions in the form of `foo.bar!.baz` since the `TypeChecker` seems\n+  // to identify them as null, even though the user indicated that it won't be.\n+  if (node.parent && ts.isNonNullExpression(node.parent)) {\n+    return false;\n+  }\n+\n+  const type = typeChecker.getTypeAtLocation(node);\n+  const typeNode = typeChecker.typeToTypeNode(type, undefined, ts.NodeBuilderFlags.None);\n+  let hasSeenNullableType = false;\n+\n+  // Trace the type of the node back to a type node, walk\n+  // through all of its sub-nodes and look for nullable tyes.\n+  if (typeNode) {\n+    (function walk(current: ts.Node) {\n+      if (current.kind === ts.SyntaxKind.NullKeyword ||\n+          current.kind === ts.SyntaxKind.UndefinedKeyword ||\n+          current.kind === ts.SyntaxKind.VoidKeyword) {\n+        hasSeenNullableType = true;\n+        // Note that we don't descend into type literals, because it may cause\n+        // us to mis-identify the root type as nullable, because it has a nullable\n+        // property (e.g. `{ foo: string | null }`).\n+      } else if (!hasSeenNullableType && !ts.isTypeLiteralNode(current)) {\n+        current.forEachChild(walk);\n+      }\n+    })(typeNode);\n+  }\n+\n+  return hasSeenNullableType;\n+}\n+\n+/**\n+ * Checks whether a particular node is part of a null check. E.g. given:\n+ * `control.parent ? control.parent.value : null` the null check would be `control.parent`.\n+ */\n+function isNullCheck(node: ts.PropertyAccessExpression): boolean {\n+  if (!node.parent) {\n+    return false;\n+  }\n+\n+  // `control.parent && control.parent.value` where `node` is `control.parent`.\n+  if (ts.isBinaryExpression(node.parent) && node.parent.left === node) {\n+    return true;\n+  }\n+\n+  // `control.parent && control.parent.parent && control.parent.parent.value`\n+  // where `node` is `control.parent`.\n+  if (node.parent.parent && ts.isBinaryExpression(node.parent.parent) &&\n+      node.parent.parent.left === node.parent) {\n+    return true;\n+  }\n+\n+  // `if (control.parent) {...}` where `node` is `control.parent`.\n+  if (ts.isIfStatement(node.parent) && node.parent.expression === node) {\n+    return true;\n+  }\n+\n+  // `control.parent ? control.parent.value : null` where `node` is `control.parent`.\n+  if (ts.isConditionalExpression(node.parent) && node.parent.condition === node) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+/** Checks whether a property access is safe (e.g. `foo.parent?.value`). */\n+function isSafeAccess(node: ts.PropertyAccessExpression): boolean {\n+  return node.parent != null && ts.isPropertyAccessExpression(node.parent) &&\n+      node.parent.expression === node && node.parent.questionDotToken != null;\n+}\n+\n+/** Checks whether a property access is on an `AbstractControl` coming from `@angular/forms`. */\n+function isAbstractControlReference(\n+    typeChecker: ts.TypeChecker, node: ts.PropertyAccessExpression): boolean {\n+  let current: ts.Expression = node;\n+  const formsPattern = /node_modules\\/?.*\\/@angular\\/forms/;\n+  // Walks up the property access chain and tries to find a symbol tied to a `SourceFile`.\n+  // If such a node is found, we check whether the type is one of the `AbstractControl` symbols\n+  // and whether it comes from the `@angular/forms` directory in the `node_modules`.\n+  while (ts.isPropertyAccessExpression(current)) {\n+    const type = typeChecker.getTypeAtLocation(current.expression);\n+    const symbol = type.getSymbol();\n+    if (symbol && type) {\n+      const sourceFile = symbol.valueDeclaration?.getSourceFile();\n+      return sourceFile != null &&\n+          formsPattern.test(normalize(sourceFile.fileName).replace(/\\\\/g, '/')) &&\n+          hasAbstractControlType(typeChecker, type);\n+    }\n+    current = current.expression;\n+  }\n+  return false;\n+}\n+\n+/**\n+ * Walks through the sub-types of a type, looking for a type that\n+ * has the same name as one of the `AbstractControl` types.\n+ */\n+function hasAbstractControlType(typeChecker: ts.TypeChecker, type: ts.Type): boolean {\n+  const typeNode = typeChecker.typeToTypeNode(type, undefined, ts.NodeBuilderFlags.None);\n+  let hasMatch = false;\n+  if (typeNode) {\n+    (function walk(current: ts.Node) {\n+      if (ts.isIdentifier(current) && abstractControlSymbols.has(current.text)) {\n+        hasMatch = true;\n+        // Note that we don't descend into type literals, because it may cause\n+        // us to mis-identify the root type as nullable, because it has a nullable\n+        // property (e.g. `{ foo: FormControl }`).\n+      } else if (!hasMatch && !ts.isTypeLiteralNode(current)) {\n+        current.forEachChild(walk);\n+      }\n+    })(typeNode);\n+  }\n+  return hasMatch;\n+}"
        },
        {
            "sha": "a8b958bdd781e7063fe42341eac17a1ff3772cbd",
            "filename": "packages/core/schematics/test/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/aeec223db1236db236ab56a4a283cf2ca410cae3/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/aeec223db1236db236ab56a4a283cf2ca410cae3/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel?ref=aeec223db1236db236ab56a4a283cf2ca410cae3",
            "patch": "@@ -8,6 +8,7 @@ ts_library(\n         \"//packages/core/schematics:migrations.json\",\n     ],\n     deps = [\n+        \"//packages/core/schematics/migrations/abstract-control-parent\",\n         \"//packages/core/schematics/migrations/dynamic-queries\",\n         \"//packages/core/schematics/migrations/missing-injectable\",\n         \"//packages/core/schematics/migrations/module-with-providers\","
        },
        {
            "sha": "cdf396734d5185966b837019b8ed544b16f503a4",
            "filename": "packages/core/schematics/test/abstract_control_parent_migration_spec.ts",
            "status": "added",
            "additions": 289,
            "deletions": 0,
            "changes": 289,
            "blob_url": "https://github.com/angular/angular/blob/aeec223db1236db236ab56a4a283cf2ca410cae3/packages%2Fcore%2Fschematics%2Ftest%2Fabstract_control_parent_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/aeec223db1236db236ab56a4a283cf2ca410cae3/packages%2Fcore%2Fschematics%2Ftest%2Fabstract_control_parent_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fabstract_control_parent_migration_spec.ts?ref=aeec223db1236db236ab56a4a283cf2ca410cae3",
            "patch": "@@ -0,0 +1,289 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n+import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n+import {HostTree} from '@angular-devkit/schematics';\n+import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n+import * as shx from 'shelljs';\n+\n+describe('AbstractControl.parent migration', () => {\n+  let runner: SchematicTestRunner;\n+  let host: TempScopedNodeJsSyncHost;\n+  let tree: UnitTestTree;\n+  let tmpDirPath: string;\n+  let previousWorkingDir: string;\n+\n+  beforeEach(() => {\n+    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n+    host = new TempScopedNodeJsSyncHost();\n+    tree = new UnitTestTree(new HostTree(host));\n+\n+    writeFile('/tsconfig.json', JSON.stringify({\n+      compilerOptions: {lib: ['es2015'], strictNullChecks: true},\n+    }));\n+    writeFile('/angular.json', JSON.stringify({\n+      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n+    }));\n+    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n+    writeFile('/node_modules/@angular/forms/index.d.ts', `\n+      export declare abstract class AbstractControl {\n+        get dirty(): boolean;\n+        get disabled(): boolean;\n+        get parent(): FormGroup | FormArray | null;\n+      }\n+\n+      export declare class FormArray extends AbstractControl {\n+        getRawValue(): any[];\n+      }\n+\n+      export declare class FormControl extends AbstractControl {\n+        setValue(value: any): void;\n+      }\n+\n+      export declare class FormGroup extends AbstractControl {\n+        getRawValue(): any;\n+      }\n+    `);\n+\n+    // Fake non-Angular package to make sure that we don't migrate packages we don't own.\n+    writeFile('/node_modules/@not-angular/forms/index.d.ts', `\n+      export declare abstract class AbstractControl {\n+        get dirty(): boolean;\n+        get disabled(): boolean;\n+        get parent(): FormGroup | FormArray | null;\n+      }\n+\n+      export declare class FormControl extends AbstractControl {\n+        setValue(value: any): void;\n+      }\n+    `);\n+\n+    previousWorkingDir = shx.pwd();\n+    tmpDirPath = getSystemPath(host.root);\n+\n+    // Switch into the temporary directory path. This allows us to run\n+    // the schematic against our custom unit test tree.\n+    shx.cd(tmpDirPath);\n+  });\n+\n+  afterEach(() => {\n+    shx.cd(previousWorkingDir);\n+    shx.rm('-r', tmpDirPath);\n+  });\n+\n+  it('should add non-null assertions to accesses of AbstractControl.parent', async () => {\n+    writeFile('/index.ts', `\n+      import {AbstractControl} from '@angular/forms';\n+\n+      class App {\n+        private _control: AbstractControl;\n+\n+        getParentValue() {\n+          return this._control.parent.value;\n+        }\n+      }\n+    `);\n+\n+    await runMigration();\n+    expect(tree.readContent('/index.ts')).toContain(`return this._control.parent!.value;`);\n+  });\n+\n+  it('should add non-null assertions to accesses of FormArray.parent', async () => {\n+    writeFile('/index.ts', `\n+      import {FormArray} from '@angular/forms';\n+\n+      class App {\n+        getParentValueOf(control: FormArray) {\n+          return control.parent.value;\n+        }\n+      }\n+    `);\n+\n+    await runMigration();\n+    expect(tree.readContent('/index.ts')).toContain(`return control.parent!.value;`);\n+  });\n+\n+  it('should add non-null assertions to accesses of FormControl.parent', async () => {\n+    writeFile('/index.ts', `\n+      import {FormControl} from '@angular/forms';\n+\n+      class App {\n+        getBlankControlParentValue() {\n+          return this._getControl().parent.value;\n+        }\n+\n+        private _getControl() {\n+          return new FormControl();\n+        }\n+      }\n+    `);\n+\n+    await runMigration();\n+    expect(tree.readContent('/index.ts')).toContain(`return this._getControl().parent!.value;`);\n+  });\n+\n+  it('should add non-null assertions to accesses of FormGroup.parent', async () => {\n+    writeFile('/index.ts', `\n+      import {FormGroup} from '@angular/forms';\n+\n+      class App {\n+        getGlobalGroupParentValue() {\n+          const parent = (window.foo as FormGroup).parent;\n+          return parent.value;\n+        }\n+      }\n+    `);\n+\n+    await runMigration();\n+    expect(tree.readContent('/index.ts'))\n+        .toContain(`const parent = (window.foo as FormGroup).parent!;`);\n+  });\n+\n+  it('should add non-null assertions to nested accesses of `AbstractControl.parent`', async () => {\n+    writeFile('/index.ts', `\n+      import {FormControl} from '@angular/forms';\n+\n+      class App {\n+        private _control = new FormControl();\n+\n+        getGreatGrandParentValue() {\n+          return this._control.parent.parent.parent.value;\n+        }\n+      }\n+    `);\n+\n+    await runMigration();\n+    expect(tree.readContent('/index.ts'))\n+        .toContain(`return this._control.parent!.parent!.parent!.value;`);\n+  });\n+\n+  it('should not add non-null assertions if the `parent` has been null checked in an if statement',\n+     async () => {\n+       writeFile('/index.ts', `\n+        import {FormControl} from '@angular/forms';\n+\n+        function getParentValue(control: FormControl) {\n+          if (control.parent) {\n+            return control.parent.value;\n+          }\n+\n+          return null;\n+        }\n+      `);\n+\n+       await runMigration();\n+\n+       const content = tree.readContent('/index.ts');\n+       expect(content).toContain(`if (control.parent) {`);\n+       expect(content).toContain(`return control.parent.value;`);\n+     });\n+\n+  it('should not add non-null assertions if the `parent` has been null checked in an else if statement',\n+     async () => {\n+       writeFile('/index.ts', `\n+        import {FormControl} from '@angular/forms';\n+\n+        function getParentValue(foo: boolean, control: FormControl) {\n+          if (foo) {\n+            return foo;\n+          } else if (control.parent) {\n+            return control.parent.value;\n+          }\n+\n+          return null;\n+        }\n+      `);\n+\n+       await runMigration();\n+\n+       const content = tree.readContent('/index.ts');\n+       expect(content).toContain(`} else if (control.parent) {`);\n+       expect(content).toContain(`return control.parent.value;`);\n+     });\n+\n+  it('should not add non-null assertions if the `parent` has been null checked in a ternary expression',\n+     async () => {\n+       writeFile('/index.ts', `\n+        import {FormControl} from '@angular/forms';\n+\n+        function getParentValue(control: FormControl) {\n+          return control.parent ? control.parent.value : null;\n+        }\n+      `);\n+\n+       await runMigration();\n+\n+       expect(tree.readContent('/index.ts'))\n+           .toContain(`return control.parent ? control.parent.value : null;`);\n+     });\n+\n+  it('should not add non-null assertions if a nested `parent` has been null checked', async () => {\n+    writeFile('/index.ts', `\n+      import {FormControl} from '@angular/forms';\n+\n+      function getGreatGrandParentValue(control: FormControl) {\n+        return control.parent && control.parent.parent && control.parent.parent.parent && control.parent.parent.parent.value;\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    expect(tree.readContent('/index.ts'))\n+        .toContain(\n+            `return control.parent && control.parent.parent && control.parent.parent.parent && control.parent.parent.parent.value;`);\n+  });\n+\n+  it('should not add non-null assertions if there is one already', async () => {\n+    writeFile('/index.ts', `\n+      import {FormControl} from '@angular/forms';\n+\n+      function getParentValue(control: FormControl) {\n+        return control.parent!.value;\n+      }\n+    `);\n+\n+    await runMigration();\n+    expect(tree.readContent('/index.ts')).toContain(`return control.parent!.value;`);\n+  });\n+\n+  it('should not add non-null assertions if there is a safe access', async () => {\n+    writeFile('/index.ts', `\n+      import {FormControl} from '@angular/forms';\n+\n+      function getParentValue(control: FormControl) {\n+        return control.parent?.value;\n+      }\n+    `);\n+\n+    await runMigration();\n+    expect(tree.readContent('/index.ts')).toContain(`return control.parent?.value;`);\n+  });\n+\n+  it('should not add non-null assertions if the symbol does not come from @angular/forms',\n+     async () => {\n+       writeFile('/index.ts', `\n+        import {FormControl} from '@not-angular/forms';\n+\n+        function getParentValue(control: FormControl) {\n+          return control.parent.value;\n+        }\n+      `);\n+\n+       await runMigration();\n+       expect(tree.readContent('/index.ts')).toContain(`return control.parent.value;`);\n+     });\n+\n+  function writeFile(filePath: string, contents: string) {\n+    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n+  }\n+\n+  function runMigration() {\n+    return runner.runSchematicAsync('migration-v11-abstract-control-parent', {}, tree).toPromise();\n+  }\n+});"
        }
    ],
    "stats": {
        "total": 560,
        "additions": 560,
        "deletions": 0
    }
}