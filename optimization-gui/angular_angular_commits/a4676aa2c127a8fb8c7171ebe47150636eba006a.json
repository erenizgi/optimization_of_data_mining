{
    "author": "bjarkler",
    "message": "fix(docs-infra): make doc-viewer compatible with Trusted Types (#42800)\n\nChange DocumentContents.contents to a TrustedHTML and update users\naccordingly.\n\nPR Close #42800",
    "sha": "a4676aa2c127a8fb8c7171ebe47150636eba006a",
    "files": [
        {
            "sha": "db0a79b12f9c698ee211991e1cd5f6ccc90b363e",
            "filename": "aio/src/app/documents/document-contents.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 1,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/a4676aa2c127a8fb8c7171ebe47150636eba006a/aio%2Fsrc%2Fapp%2Fdocuments%2Fdocument-contents.ts",
            "raw_url": "https://github.com/angular/angular/raw/a4676aa2c127a8fb8c7171ebe47150636eba006a/aio%2Fsrc%2Fapp%2Fdocuments%2Fdocument-contents.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fsrc%2Fapp%2Fdocuments%2Fdocument-contents.ts?ref=a4676aa2c127a8fb8c7171ebe47150636eba006a",
            "patch": "@@ -1,6 +1,13 @@\n-export interface DocumentContents {\n+export interface UnsafeDocumentContents {\n   /** The unique identifier for this document */\n   id: string;\n   /** The HTML to display in the doc viewer */\n   contents: string|null;\n }\n+\n+export interface DocumentContents {\n+  /** The unique identifier for this document */\n+  id: string;\n+  /** The HTML to display in the doc viewer */\n+  contents: TrustedHTML|null;\n+}"
        },
        {
            "sha": "1a7628953ad763b99cc7270849a78f36a0dd5642",
            "filename": "aio/src/app/documents/document.service.spec.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 13,
            "changes": 32,
            "blob_url": "https://github.com/angular/angular/blob/a4676aa2c127a8fb8c7171ebe47150636eba006a/aio%2Fsrc%2Fapp%2Fdocuments%2Fdocument.service.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a4676aa2c127a8fb8c7171ebe47150636eba006a/aio%2Fsrc%2Fapp%2Fdocuments%2Fdocument.service.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fsrc%2Fapp%2Fdocuments%2Fdocument.service.spec.ts?ref=a4676aa2c127a8fb8c7171ebe47150636eba006a",
            "patch": "@@ -4,8 +4,9 @@ import { TestBed } from '@angular/core/testing';\n import { Subscription } from 'rxjs';\n \n import { LocationService } from 'app/shared/location.service';\n-import { MockLocationService } from 'testing/location.service';\n import { Logger } from 'app/shared/logger.service';\n+import { htmlEscape } from 'safevalues';\n+import { MockLocationService } from 'testing/location.service';\n import { MockLogger } from 'testing/logger.service';\n import { DocumentService, DocumentContents,\n          FETCHING_ERROR_ID, FILE_NOT_FOUND_ID } from './document.service';\n@@ -60,11 +61,13 @@ describe('DocumentService', () => {\n       expect(latestDocument).toBeUndefined();\n \n       httpMock.expectOne({}).flush(doc0);\n-      expect(latestDocument).toEqual(doc0);\n+      expect(latestDocument?.id).toBe(doc0.id);\n+      expect(latestDocument?.contents?.toString()).toBe(doc0.contents);\n \n       locationService.go('new/doc');\n       httpMock.expectOne({}).flush(doc1);\n-      expect(latestDocument).toEqual(doc1);\n+      expect(latestDocument?.id).toBe(doc1.id);\n+      expect(latestDocument?.contents?.toString()).toBe(doc1.contents);\n     });\n \n     it('should encode the request path to be case-insensitive', () => {\n@@ -99,7 +102,8 @@ describe('DocumentService', () => {\n       logger.output.error = [];\n       httpMock.expectOne(CONTENT_URL_PREFIX + 'file-not-found.json').flush(notFoundDoc);\n       expect(logger.output.error).toEqual([]); // does not report repeated errors\n-      expect(currentDocument).toEqual(notFoundDoc);\n+      expect(currentDocument?.id).toBe(notFoundDoc.id);\n+      expect(currentDocument?.contents?.toString()).toBe(notFoundDoc.contents);\n     });\n \n     it('should emit a hard-coded not-found document if the not-found document is not found on the server', () => {\n@@ -111,25 +115,27 @@ describe('DocumentService', () => {\n       docService.currentDocument.subscribe(doc => currentDocument = doc);\n \n       httpMock.expectOne({}).flush(null, {status: 404, statusText: 'NOT FOUND'});\n-      expect(currentDocument).toEqual(hardCodedNotFoundDoc);\n+      expect(currentDocument?.id).toBe(hardCodedNotFoundDoc.id);\n+      expect(currentDocument?.contents?.toString()).toBe(hardCodedNotFoundDoc.contents);\n \n       // now check that we haven't killed the currentDocument observable sequence\n       locationService.go('new/doc');\n       httpMock.expectOne({}).flush(nextDoc);\n-      expect(currentDocument).toEqual(nextDoc);\n+      expect(currentDocument?.id).toBe(nextDoc.id);\n+      expect(currentDocument?.contents?.toString()).toBe(nextDoc.contents);\n     });\n \n     it('should use a hard-coded error doc if the request fails (but not cache it)', () => {\n       let latestDocument!: DocumentContents;\n-      const doc1 = { contents: 'doc 1' } as DocumentContents;\n-      const doc2 = { contents: 'doc 2' } as DocumentContents;\n+      const doc1 = { contents: htmlEscape('doc 1') } as DocumentContents;\n+      const doc2 = { contents: htmlEscape('doc 2') } as DocumentContents;\n       const { docService, locationService, logger } = getServices('initial/doc');\n \n       docService.currentDocument.subscribe(doc => latestDocument = doc);\n \n       httpMock.expectOne({}).flush(null, {status: 500, statusText: 'Server Error'});\n-      expect(latestDocument.id).toEqual(FETCHING_ERROR_ID);\n-      expect(latestDocument.contents).toContain('We are unable to retrieve the \"initial/doc\" page at this time.');\n+      expect(latestDocument.id).toBe(FETCHING_ERROR_ID);\n+      expect(latestDocument.contents?.toString()).toContain('We are unable to retrieve the \"initial/doc\" page at this time.');\n       expect(logger.output.error).toEqual([\n         [jasmine.any(Error)]\n       ]);\n@@ -147,7 +153,7 @@ describe('DocumentService', () => {\n \n     it('should not crash the app if the response is invalid JSON', () => {\n       let latestDocument!: DocumentContents;\n-      const doc1 = { contents: 'doc 1' } as DocumentContents;\n+      const doc1 = { contents: htmlEscape('doc 1') } as DocumentContents;\n       const { docService, locationService } = getServices('initial/doc');\n \n       docService.currentDocument.subscribe(doc => latestDocument = doc);\n@@ -164,8 +170,8 @@ describe('DocumentService', () => {\n       let latestDocument!: DocumentContents;\n       let subscription: Subscription;\n \n-      const doc0 = { contents: 'doc 0' } as DocumentContents;\n-      const doc1 = { contents: 'doc 1' } as DocumentContents;\n+      const doc0 = { contents: htmlEscape('doc 0') } as DocumentContents;\n+      const doc1 = { contents: htmlEscape('doc 1') } as DocumentContents;\n       const { docService, locationService } = getServices('url/0');\n \n       subscription = docService.currentDocument.subscribe(doc => latestDocument = doc);"
        },
        {
            "sha": "b88dca12546e7d26352f1e16ebff1748caaa02fe",
            "filename": "aio/src/app/documents/document.service.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 20,
            "changes": 49,
            "blob_url": "https://github.com/angular/angular/blob/a4676aa2c127a8fb8c7171ebe47150636eba006a/aio%2Fsrc%2Fapp%2Fdocuments%2Fdocument.service.ts",
            "raw_url": "https://github.com/angular/angular/raw/a4676aa2c127a8fb8c7171ebe47150636eba006a/aio%2Fsrc%2Fapp%2Fdocuments%2Fdocument.service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fsrc%2Fapp%2Fdocuments%2Fdocument.service.ts?ref=a4676aa2c127a8fb8c7171ebe47150636eba006a",
            "patch": "@@ -2,9 +2,11 @@ import { Injectable } from '@angular/core';\n import { HttpClient, HttpErrorResponse } from '@angular/common/http';\n \n import { AsyncSubject, Observable, of } from 'rxjs';\n-import { catchError, switchMap, tap } from 'rxjs/operators';\n+import { catchError, map, switchMap, tap } from 'rxjs/operators';\n+import { htmlEscape } from 'safevalues';\n+import { htmlFromStringKnownToSatisfyTypeContract } from 'safevalues/unsafe/reviewed';\n \n-import { DocumentContents } from './document-contents';\n+import { DocumentContents, UnsafeDocumentContents } from './document-contents';\n export { DocumentContents } from './document-contents';\n \n import { LocationService } from 'app/shared/location.service';\n@@ -15,19 +17,19 @@ export const FETCHING_ERROR_ID = 'fetching-error';\n \n export const CONTENT_URL_PREFIX = 'generated/';\n export const DOC_CONTENT_URL_PREFIX = CONTENT_URL_PREFIX + 'docs/';\n-const FETCHING_ERROR_CONTENTS = (path: string) => `\n+const FETCHING_ERROR_CONTENTS = (path: string) => htmlFromStringKnownToSatisfyTypeContract(`\n   <div class=\"nf-container l-flex-wrap flex-center\">\n     <div class=\"nf-icon material-icons\">error_outline</div>\n     <div class=\"nf-response l-flex-wrap center\">\n       <h1 class=\"no-toc\">Request for document failed</h1>\n       <p>\n-        We are unable to retrieve the \"${path}\" page at this time.\n+        We are unable to retrieve the \"${htmlEscape(path)}\" page at this time.\n         <br/>\n         Please check your connection and try again later.\n       </p>\n     </div>\n   </div>\n-`;\n+`, 'inline HTML with interpolations escaped');\n \n @Injectable()\n export class DocumentService {\n@@ -58,20 +60,27 @@ export class DocumentService {\n     const subject = new AsyncSubject<DocumentContents>();\n \n     this.logger.log('fetching document from', requestPath);\n-    this.http\n-      .get<DocumentContents>(requestPath, {responseType: 'json'})\n-      .pipe(\n-        tap(data => {\n-          if (!data || typeof data !== 'object') {\n-            this.logger.log('received invalid data:', data);\n-            throw Error('Invalid data');\n-          }\n-        }),\n-        catchError((error: HttpErrorResponse) =>\n-          error.status === 404 ? this.getFileNotFoundDoc(id) : this.getErrorDoc(id, error)\n-        ),\n-      )\n-      .subscribe(subject);\n+    this.http.get<UnsafeDocumentContents>(requestPath, {responseType: 'json'})\n+        .pipe(\n+            tap(data => {\n+              if (!data || typeof data !== 'object') {\n+                this.logger.log('received invalid data:', data);\n+                throw Error('Invalid data');\n+              }\n+            }),\n+            map((data: UnsafeDocumentContents) => ({\n+              id: data.id,\n+              contents: data.contents === null ?\n+                  null :\n+                  // SECURITY: HTML is authored by the documentation team and is fetched directly\n+                  // from the server\n+                  htmlFromStringKnownToSatisfyTypeContract(data.contents, '^')\n+            })),\n+            catchError((error: HttpErrorResponse) =>\n+              error.status === 404 ? this.getFileNotFoundDoc(id) : this.getErrorDoc(id, error)\n+            ),\n+        )\n+        .subscribe(subject);\n \n     return subject.asObservable();\n   }\n@@ -84,7 +93,7 @@ export class DocumentService {\n     } else {\n       return of({\n         id: FILE_NOT_FOUND_ID,\n-        contents: 'Document not found'\n+        contents: htmlEscape('Document not found')\n       });\n     }\n   }"
        },
        {
            "sha": "21b71e3ef1ca0fbab41f46a44ab8c96d768a9028",
            "filename": "aio/src/app/layout/doc-viewer/doc-viewer.component.spec.ts",
            "status": "modified",
            "additions": 41,
            "deletions": 36,
            "changes": 77,
            "blob_url": "https://github.com/angular/angular/blob/a4676aa2c127a8fb8c7171ebe47150636eba006a/aio%2Fsrc%2Fapp%2Flayout%2Fdoc-viewer%2Fdoc-viewer.component.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a4676aa2c127a8fb8c7171ebe47150636eba006a/aio%2Fsrc%2Fapp%2Flayout%2Fdoc-viewer%2Fdoc-viewer.component.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fsrc%2Fapp%2Flayout%2Fdoc-viewer%2Fdoc-viewer.component.spec.ts?ref=a4676aa2c127a8fb8c7171ebe47150636eba006a",
            "patch": "@@ -2,12 +2,15 @@ import { ComponentFixture, TestBed } from '@angular/core/testing';\n import { Meta, Title } from '@angular/platform-browser';\n \n import { Observable, asapScheduler, of } from 'rxjs';\n+import { EMPTY_HTML, htmlEscape } from 'safevalues';\n+import { htmlFromStringKnownToSatisfyTypeContract } from 'safevalues/unsafe/reviewed';\n \n import { FILE_NOT_FOUND_ID, FETCHING_ERROR_ID } from 'app/documents/document.service';\n-import { Logger } from 'app/shared/logger.service';\n import { CustomElementsModule } from 'app/custom-elements/custom-elements.module';\n-import { TocService } from 'app/shared/toc.service';\n import { ElementsLoader } from 'app/custom-elements/elements-loader';\n+import { Logger } from 'app/shared/logger.service';\n+import { fromOuterHTML } from 'app/shared/security';\n+import { TocService } from 'app/shared/toc.service';\n import {\n MockTitle, MockTocService, ObservableWithSubscriptionSpies,\n TestDocViewerComponent, TestModule, TestParentComponent, MockElementsLoader\n@@ -53,9 +56,10 @@ describe('DocViewerComponent', () => {\n     beforeEach(() => renderSpy = spyOn(docViewer, 'render').and.callFake(() => of(undefined)));\n \n     it('should render the new document', () => {\n-      setCurrentDoc({contents: 'foo', id: 'bar'});\n+      const contents = htmlEscape('foo');\n+      setCurrentDoc({contents, id: 'bar'});\n       expect(renderSpy).toHaveBeenCalledTimes(1);\n-      expect(renderSpy.calls.mostRecent().args).toEqual([{id: 'bar', contents: 'foo'}]);\n+      expect(renderSpy.calls.mostRecent().args).toEqual([{id: 'bar', contents}]);\n \n       setCurrentDoc({contents: null, id: 'baz'});\n       expect(renderSpy).toHaveBeenCalledTimes(2);\n@@ -66,11 +70,11 @@ describe('DocViewerComponent', () => {\n       const obs = new ObservableWithSubscriptionSpies();\n       renderSpy.and.returnValue(obs);\n \n-      setCurrentDoc({contents: 'foo', id: 'bar'});\n+      setCurrentDoc({contents: htmlEscape('foo'), id: 'bar'});\n       expect(obs.subscribeSpy).toHaveBeenCalledTimes(1);\n       expect(obs.unsubscribeSpies[0]).not.toHaveBeenCalled();\n \n-      setCurrentDoc({contents: 'baz', id: 'qux'});\n+      setCurrentDoc({contents: htmlEscape('baz'), id: 'qux'});\n       expect(obs.subscribeSpy).toHaveBeenCalledTimes(2);\n       expect(obs.unsubscribeSpies[0]).toHaveBeenCalledTimes(1);\n     });\n@@ -90,17 +94,17 @@ describe('DocViewerComponent', () => {\n \n       expect(renderSpy).not.toHaveBeenCalled();\n \n-      docViewer.doc = {contents: 'Some content', id: 'some-id'};\n+      docViewer.doc = {contents: htmlEscape('Some content'), id: 'some-id'};\n       safeFlushAsapScheduler();\n       expect(renderSpy).toHaveBeenCalledTimes(1);\n \n       docViewer.ngOnDestroy();\n \n-      docViewer.doc = {contents: 'Other content', id: 'other-id'};\n+      docViewer.doc = {contents: htmlEscape('Other content'), id: 'other-id'};\n       safeFlushAsapScheduler();\n       expect(renderSpy).toHaveBeenCalledTimes(1);\n \n-      docViewer.doc = {contents: 'More content', id: 'more-id'};\n+      docViewer.doc = {contents: htmlEscape('More content'), id: 'more-id'};\n       safeFlushAsapScheduler();\n       expect(renderSpy).toHaveBeenCalledTimes(1);\n     });\n@@ -297,7 +301,7 @@ describe('DocViewerComponent', () => {\n     let swapViewsSpy: jasmine.Spy;\n     let loadElementsSpy: jasmine.Spy;\n \n-    const doRender = (contents: string | null, id = 'foo') =>\n+    const doRender = (contents: TrustedHTML | null, id = 'foo') =>\n       docViewer.render({contents, id}).toPromise();\n \n     beforeEach(() => {\n@@ -308,25 +312,25 @@ describe('DocViewerComponent', () => {\n     });\n \n     it('should return an `Observable`', () => {\n-      expect(docViewer.render({contents: '', id: ''})).toEqual(jasmine.any(Observable));\n+      expect(docViewer.render({contents: EMPTY_HTML, id: ''})).toEqual(jasmine.any(Observable));\n     });\n \n     describe('(contents, title, ToC)', () => {\n       beforeEach(() => swapViewsSpy.and.callThrough());\n \n       it('should display the document contents', async () => {\n-        const contents = '<h1>Hello,</h1> <div>world!</div>';\n+        const contents = htmlFromStringKnownToSatisfyTypeContract('<h1>Hello,</h1> <div>world!</div>', 'constant HTML');\n         await doRender(contents);\n \n-        expect(docViewerEl.innerHTML).toContain(contents);\n+        expect(docViewerEl.innerHTML).toContain(contents.toString());\n         expect(docViewerEl.textContent).toBe('Hello, world!');\n       });\n \n       it('should display nothing if the document has no contents', async () => {\n-        await doRender('Test');\n+        await doRender(htmlEscape('Test'));\n         expect(docViewerEl.textContent).toBe('Test');\n \n-        await doRender('');\n+        await doRender(EMPTY_HTML);\n         expect(docViewerEl.textContent).toBe('');\n \n         docViewer.currViewContainer.innerHTML = 'Test';\n@@ -342,7 +346,7 @@ describe('DocViewerComponent', () => {\n           expect(docId).toBe('foo');\n         });\n \n-        await doRender('Some content', 'foo');\n+        await doRender(htmlEscape('Some content'), 'foo');\n \n         expect(prepareTitleAndTocSpy).toHaveBeenCalledTimes(1);\n         expect(prepareTitleAndTocSpy).toHaveBeenCalledBefore(loadElementsSpy);\n@@ -353,47 +357,47 @@ describe('DocViewerComponent', () => {\n         prepareTitleAndTocSpy.and.returnValue(addTitleAndTocSpy);\n \n         addTitleAndTocSpy.and.callFake(() => expect(docViewerEl.textContent).toBe('Foo content'));\n-        await doRender('Foo content');\n+        await doRender(htmlEscape('Foo content'));\n         expect(addTitleAndTocSpy).toHaveBeenCalledTimes(1);\n \n         addTitleAndTocSpy.and.callFake(() => expect(docViewerEl.textContent).toBe('Bar content'));\n-        await doRender('Bar content');\n+        await doRender(htmlEscape('Bar content'));\n         expect(addTitleAndTocSpy).toHaveBeenCalledTimes(2);\n \n         addTitleAndTocSpy.and.callFake(() => expect(docViewerEl.textContent).toBe(''));\n-        await doRender('');\n+        await doRender(EMPTY_HTML);\n         expect(addTitleAndTocSpy).toHaveBeenCalledTimes(3);\n \n         addTitleAndTocSpy.and.callFake(() => expect(docViewerEl.textContent).toBe('Qux content'));\n-        await doRender('Qux content');\n+        await doRender(htmlEscape('Qux content'));\n         expect(addTitleAndTocSpy).toHaveBeenCalledTimes(4);\n       });\n \n       it('should remove the \"noindex\" meta tag if the document is valid', async () => {\n-        await doRender('foo', 'bar');\n+        await doRender(htmlEscape('foo'), 'bar');\n         expect(TestBed.inject(Meta).removeTag).toHaveBeenCalledWith('name=\"robots\"');\n       });\n \n       it('should add the \"noindex\" meta tag if the document is 404', async () => {\n-        await doRender('missing', FILE_NOT_FOUND_ID);\n+        await doRender(htmlEscape('missing'), FILE_NOT_FOUND_ID);\n         expect(TestBed.inject(Meta).addTag).toHaveBeenCalledWith({ name: 'robots', content: 'noindex' });\n       });\n \n       it('should add a \"noindex\" meta tag if the document fetching fails', async () => {\n-        await doRender('error', FETCHING_ERROR_ID);\n+        await doRender(htmlEscape('error'), FETCHING_ERROR_ID);\n         expect(TestBed.inject(Meta).addTag).toHaveBeenCalledWith({ name: 'robots', content: 'noindex' });\n       });\n     });\n \n     describe('(embedding components)', () => {\n       it('should embed components', async () => {\n-        await doRender('Some content');\n+        await doRender(htmlEscape('Some content'));\n         expect(loadElementsSpy).toHaveBeenCalledTimes(1);\n         expect(loadElementsSpy).toHaveBeenCalledWith(docViewer.nextViewContainer);\n       });\n \n       it('should attempt to embed components even if the document is empty', async () => {\n-        await doRender('');\n+        await doRender(EMPTY_HTML);\n         await doRender(null);\n \n         expect(loadElementsSpy).toHaveBeenCalledTimes(2);\n@@ -405,7 +409,7 @@ describe('DocViewerComponent', () => {\n         const obs = new ObservableWithSubscriptionSpies();\n         loadElementsSpy.and.returnValue(obs);\n \n-        const renderObservable = docViewer.render({contents: 'Some content', id: 'foo'});\n+        const renderObservable = docViewer.render({contents: htmlEscape('Some content'), id: 'foo'});\n         const subscription = renderObservable.subscribe();\n \n         expect(obs.subscribeSpy).toHaveBeenCalledTimes(1);\n@@ -420,7 +424,7 @@ describe('DocViewerComponent', () => {\n \n     describe('(swapping views)', () => {\n       it('should still swap the views if the document is empty', async () => {\n-        await doRender('');\n+        await doRender(EMPTY_HTML);\n         expect(swapViewsSpy).toHaveBeenCalledTimes(1);\n \n         await doRender(null);\n@@ -431,7 +435,8 @@ describe('DocViewerComponent', () => {\n         const addTitleAndTocSpy = jasmine.createSpy('addTitleAndToc');\n         prepareTitleAndTocSpy.and.returnValue(addTitleAndTocSpy);\n \n-        await doRender('<div></div>');\n+        const el = document.createElement('div');\n+        await doRender(fromOuterHTML(el));\n \n         expect(swapViewsSpy).toHaveBeenCalledWith(addTitleAndTocSpy);\n       });\n@@ -440,7 +445,7 @@ describe('DocViewerComponent', () => {\n         const obs = new ObservableWithSubscriptionSpies();\n         swapViewsSpy.and.returnValue(obs);\n \n-        const renderObservable = docViewer.render({contents: 'Hello, world!', id: 'foo'});\n+        const renderObservable = docViewer.render({contents: htmlEscape('Hello, world!'), id: 'foo'});\n         const subscription = renderObservable.subscribe();\n \n         expect(obs.subscribeSpy).toHaveBeenCalledTimes(1);\n@@ -467,7 +472,7 @@ describe('DocViewerComponent', () => {\n           throw error;\n         });\n \n-        await doRender('Some content', 'foo');\n+        await doRender(htmlEscape('Some content'), 'foo');\n \n         expect(prepareTitleAndTocSpy).toHaveBeenCalledTimes(1);\n         expect(swapViewsSpy).not.toHaveBeenCalled();\n@@ -486,7 +491,7 @@ describe('DocViewerComponent', () => {\n           throw error;\n         });\n \n-        await doRender('Some content', 'bar');\n+        await doRender(htmlEscape('Some content'), 'bar');\n \n         expect(prepareTitleAndTocSpy).toHaveBeenCalledTimes(1);\n         expect(loadElementsSpy).toHaveBeenCalledTimes(1);\n@@ -505,7 +510,7 @@ describe('DocViewerComponent', () => {\n           throw error;\n         });\n \n-        await doRender('Some content', 'qux');\n+        await doRender(htmlEscape('Some content'), 'qux');\n \n         expect(prepareTitleAndTocSpy).toHaveBeenCalledTimes(1);\n         expect(swapViewsSpy).toHaveBeenCalledTimes(1);\n@@ -524,7 +529,7 @@ describe('DocViewerComponent', () => {\n           throw error;\n         });\n \n-        await doRender('Some content', 'qux');\n+        await doRender(htmlEscape('Some content'), 'qux');\n \n         expect(swapViewsSpy).toHaveBeenCalledTimes(1);\n         expect(docViewer.nextViewContainer.innerHTML).toBe('');\n@@ -541,7 +546,7 @@ describe('DocViewerComponent', () => {\n         const onDocReadySpy = jasmine.createSpy('onDocReady');\n         docViewer.docReady.subscribe(onDocReadySpy);\n \n-        await doRender('Some content');\n+        await doRender(htmlEscape('Some content'));\n \n         expect(onDocReadySpy).toHaveBeenCalledTimes(1);\n         expect(loadElementsSpy).toHaveBeenCalledBefore(onDocReadySpy);\n@@ -551,7 +556,7 @@ describe('DocViewerComponent', () => {\n         const onDocReadySpy = jasmine.createSpy('onDocReady');\n         docViewer.docReady.subscribe(onDocReadySpy);\n \n-        await doRender('Some content');\n+        await doRender(htmlEscape('Some content'));\n \n         expect(onDocReadySpy).toHaveBeenCalledTimes(1);\n         expect(onDocReadySpy).toHaveBeenCalledBefore(swapViewsSpy);\n@@ -561,7 +566,7 @@ describe('DocViewerComponent', () => {\n         const onDocRenderedSpy = jasmine.createSpy('onDocRendered');\n         docViewer.docRendered.subscribe(onDocRenderedSpy);\n \n-        await doRender('Some content');\n+        await doRender(htmlEscape('Some content'));\n \n         expect(onDocRenderedSpy).toHaveBeenCalledTimes(1);\n         expect(swapViewsSpy).toHaveBeenCalledBefore(onDocRenderedSpy);"
        },
        {
            "sha": "69c8ead8a8d23508636ee0e8f5534231d51a9ba9",
            "filename": "aio/src/app/layout/doc-viewer/doc-viewer.component.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 7,
            "changes": 23,
            "blob_url": "https://github.com/angular/angular/blob/a4676aa2c127a8fb8c7171ebe47150636eba006a/aio%2Fsrc%2Fapp%2Flayout%2Fdoc-viewer%2Fdoc-viewer.component.ts",
            "raw_url": "https://github.com/angular/angular/raw/a4676aa2c127a8fb8c7171ebe47150636eba006a/aio%2Fsrc%2Fapp%2Flayout%2Fdoc-viewer%2Fdoc-viewer.component.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fsrc%2Fapp%2Flayout%2Fdoc-viewer%2Fdoc-viewer.component.ts?ref=a4676aa2c127a8fb8c7171ebe47150636eba006a",
            "patch": "@@ -3,19 +3,21 @@ import { Title, Meta } from '@angular/platform-browser';\n \n import { asapScheduler, Observable, of, timer } from 'rxjs';\n import { catchError, observeOn, switchMap, takeUntil, tap } from 'rxjs/operators';\n+import { EMPTY_HTML, unwrapHtmlForSink } from 'safevalues';\n \n import { DocumentContents, FILE_NOT_FOUND_ID, FETCHING_ERROR_ID } from 'app/documents/document.service';\n import { Logger } from 'app/shared/logger.service';\n import { TocService } from 'app/shared/toc.service';\n import { ElementsLoader } from 'app/custom-elements/elements-loader';\n+import { fromInnerHTML } from 'app/shared/security';\n \n \n // Constants\n export const NO_ANIMATIONS = 'no-animations';\n \n // Initialization prevents flicker once pre-rendering is on\n const initialDocViewerElement = document.querySelector('aio-doc-viewer');\n-const initialDocViewerContent = initialDocViewerElement ? initialDocViewerElement.innerHTML : '';\n+const initialDocViewerContent = initialDocViewerElement ? fromInnerHTML(initialDocViewerElement) : EMPTY_HTML;\n \n @Component({\n   selector: 'aio-doc-viewer',\n@@ -69,8 +71,9 @@ export class DocViewerComponent implements OnDestroy {\n     private tocService: TocService,\n     private elementsLoader: ElementsLoader) {\n     this.hostElement = elementRef.nativeElement;\n+\n     // Security: the initialDocViewerContent comes from the prerendered DOM and is considered to be secure\n-    this.hostElement.innerHTML = initialDocViewerContent;\n+    this.hostElement.innerHTML = unwrapHtmlForSink(initialDocViewerContent);\n \n     if (this.hostElement.firstElementChild) {\n       this.currViewContainer = this.hostElement.firstElementChild as HTMLElement;\n@@ -98,11 +101,11 @@ export class DocViewerComponent implements OnDestroy {\n     const needsToc = !!titleEl && !/no-?toc/i.test(titleEl.className);\n     const embeddedToc = targetElem.querySelector('aio-toc.embedded');\n \n-    if (titleEl && needsToc && !embeddedToc) {\n+    if (titleEl && titleEl.parentNode && needsToc && !embeddedToc) {\n       // Add an embedded ToC if it's needed and there isn't one in the content already.\n       const toc = document.createElement('aio-toc');\n       toc.className = 'embedded';\n-      titleEl.parentNode!.insertBefore(toc, titleEl.nextSibling);\n+      titleEl.parentNode.insertBefore(toc, titleEl.nextSibling);\n     } else if (!needsToc && embeddedToc && embeddedToc.parentNode !== null) {\n       // Remove the embedded Toc if it's there and not needed.\n       // We cannot use ChildNode.remove() because of IE11\n@@ -136,9 +139,15 @@ export class DocViewerComponent implements OnDestroy {\n     this.setNoIndex(doc.id === FILE_NOT_FOUND_ID || doc.id === FETCHING_ERROR_ID);\n \n     return this.void$.pipe(\n-        // Security: `doc.contents` is always authored by the documentation team\n-        //           and is considered to be safe.\n-        tap(() => this.nextViewContainer.innerHTML = doc.contents || ''),\n+        tap(() => {\n+          if (doc.contents === null) {\n+            this.nextViewContainer.textContent = '';\n+          } else {\n+            // Security: `doc.contents` is always authored by the documentation team\n+            //           and is considered to be safe.\n+            this.nextViewContainer.innerHTML = unwrapHtmlForSink(doc.contents);\n+          }\n+        }),\n         tap(() => addTitleAndToc = this.prepareTitleAndToc(this.nextViewContainer, doc.id)),\n         switchMap(() => this.elementsLoader.loadContainedCustomElements(this.nextViewContainer)),\n         tap(() => this.docReady.emit()),"
        }
    ],
    "stats": {
        "total": 190,
        "additions": 113,
        "deletions": 77
    }
}