{
    "author": "gkalpak",
    "message": "refactor(service-worker): move asset URL normalization to `Adapter` (#37922)\n\nThis is in preparation of enabling the ServiceWorker to handle\nrelative paths in `ngsw.json` (as discussed in #25055), which will\nrequire normalizing URLs in other parts of the ServiceWorker.\n\nPR Close #37922",
    "sha": "d380e93b82bbe203f9ded436db9f3de4be3ab2c4",
    "files": [
        {
            "sha": "6a600c63f02456b5057c6bdeda5647b960da6335",
            "filename": "packages/service-worker/worker/main.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/d380e93b82bbe203f9ded436db9f3de4be3ab2c4/packages%2Fservice-worker%2Fworker%2Fmain.ts",
            "raw_url": "https://github.com/angular/angular/raw/d380e93b82bbe203f9ded436db9f3de4be3ab2c4/packages%2Fservice-worker%2Fworker%2Fmain.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fmain.ts?ref=d380e93b82bbe203f9ded436db9f3de4be3ab2c4",
            "patch": "@@ -12,5 +12,5 @@ import {Driver} from './src/driver';\n \n const scope = self as any as ServiceWorkerGlobalScope;\n \n-const adapter = new Adapter(scope);\n+const adapter = new Adapter(scope.registration.scope);\n const driver = new Driver(scope, adapter, new CacheDatabase(scope, adapter));"
        },
        {
            "sha": "cebad8aeef849352759d1c9b4965be43ef492058",
            "filename": "packages/service-worker/worker/src/adapter.ts",
            "status": "modified",
            "additions": 36,
            "deletions": 6,
            "changes": 42,
            "blob_url": "https://github.com/angular/angular/blob/d380e93b82bbe203f9ded436db9f3de4be3ab2c4/packages%2Fservice-worker%2Fworker%2Fsrc%2Fadapter.ts",
            "raw_url": "https://github.com/angular/angular/raw/d380e93b82bbe203f9ded436db9f3de4be3ab2c4/packages%2Fservice-worker%2Fworker%2Fsrc%2Fadapter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fsrc%2Fadapter.ts?ref=d380e93b82bbe203f9ded436db9f3de4be3ab2c4",
            "patch": "@@ -14,12 +14,18 @@\n  */\n export class Adapter {\n   readonly cacheNamePrefix: string;\n+  private readonly origin: string;\n \n-  constructor(scope: ServiceWorkerGlobalScope) {\n-    // Suffixing `ngsw` with the baseHref to avoid clash of cache names\n-    // for SWs with different scopes on the same domain.\n-    const baseHref = this.parseUrl(scope.registration.scope).path;\n-    this.cacheNamePrefix = 'ngsw:' + baseHref;\n+  constructor(protected readonly scopeUrl: string) {\n+    const parsedScopeUrl = this.parseUrl(this.scopeUrl);\n+\n+    // Determine the origin from the registration scope. This is used to differentiate between\n+    // relative and absolute URLs.\n+    this.origin = parsedScopeUrl.origin;\n+\n+    // Suffixing `ngsw` with the baseHref to avoid clash of cache names for SWs with different\n+    // scopes on the same domain.\n+    this.cacheNamePrefix = 'ngsw:' + parsedScopeUrl.path;\n   }\n \n   /**\n@@ -58,7 +64,31 @@ export class Adapter {\n   }\n \n   /**\n-   * Extract the pathname of a URL.\n+   * Get a normalized representation of a URL such as those found in the ServiceWorker's `ngsw.json`\n+   * configuration.\n+   *\n+   * More specifically:\n+   * 1. Resolve the URL relative to the ServiceWorker's scope.\n+   * 2. If the URL is relative to the ServiceWorker's own origin, then only return the path part.\n+   *    Otherwise, return the full URL.\n+   *\n+   * @param url The raw request URL.\n+   * @return A normalized representation of the URL.\n+   */\n+  normalizeUrl(url: string): string {\n+    // Check the URL's origin against the ServiceWorker's.\n+    const parsed = this.parseUrl(url, this.scopeUrl);\n+    if (parsed.origin === this.origin) {\n+      // The URL is relative to the SW's origin: Return the path only.\n+      return parsed.path;\n+    } else {\n+      // The URL is not relative to the SW's origin: Return the full URL.\n+      return url;\n+    }\n+  }\n+\n+  /**\n+   * Parse a URL into its different parts, such as `origin`, `path` and `search`.\n    */\n   parseUrl(url: string, relativeTo?: string): {origin: string, path: string, search: string} {\n     // Workaround a Safari bug, see"
        },
        {
            "sha": "ecebcbaf16924bb8e378d7603a2c7e4a060212d1",
            "filename": "packages/service-worker/worker/src/assets.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 23,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/d380e93b82bbe203f9ded436db9f3de4be3ab2c4/packages%2Fservice-worker%2Fworker%2Fsrc%2Fassets.ts",
            "raw_url": "https://github.com/angular/angular/raw/d380e93b82bbe203f9ded436db9f3de4be3ab2c4/packages%2Fservice-worker%2Fworker%2Fsrc%2Fassets.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fsrc%2Fassets.ts?ref=d380e93b82bbe203f9ded436db9f3de4be3ab2c4",
            "patch": "@@ -47,9 +47,6 @@ export abstract class AssetGroup {\n    */\n   protected metadata: Promise<Table>;\n \n-\n-  private origin: string;\n-\n   constructor(\n       protected scope: ServiceWorkerGlobalScope, protected adapter: Adapter,\n       protected idle: IdleScheduler, protected config: AssetGroupConfig,\n@@ -67,10 +64,6 @@ export abstract class AssetGroup {\n     // the timestamp of when it was added to the cache.\n     this.metadata =\n         this.db.open(`${this.prefix}:${this.config.name}:meta`, this.config.cacheQueryOptions);\n-\n-    // Determine the origin from the registration scope. This is used to differentiate between\n-    // relative and absolute URLs.\n-    this.origin = this.adapter.parseUrl(this.scope.registration.scope).origin;\n   }\n \n   async cacheStatus(url: string): Promise<UpdateCacheStatus> {\n@@ -108,7 +101,7 @@ export abstract class AssetGroup {\n    * Process a request for a given resource and return it, or return null if it's not available.\n    */\n   async handleFetch(req: Request, ctx: Context): Promise<Response|null> {\n-    const url = this.getConfigUrl(req.url);\n+    const url = this.adapter.normalizeUrl(req.url);\n     // Either the request matches one of the known resource URLs, one of the patterns for\n     // dynamically matched URLs, or neither. Determine which is the case for this request in\n     // order to decide how to handle it.\n@@ -156,18 +149,6 @@ export abstract class AssetGroup {\n     }\n   }\n \n-  private getConfigUrl(url: string): string {\n-    // If the URL is relative to the SW's own origin, then only consider the path relative to\n-    // the domain root. Determine this by checking the URL's origin against the SW's.\n-    const parsed = this.adapter.parseUrl(url, this.scope.registration.scope);\n-    if (parsed.origin === this.origin) {\n-      // The URL is relative to the SW's origin domain.\n-      return parsed.path;\n-    } else {\n-      return url;\n-    }\n-  }\n-\n   /**\n    * Some resources are cached without a hash, meaning that their expiration is controlled\n    * by HTTP caching headers. Check whether the given request/response pair is still valid\n@@ -373,7 +354,7 @@ export abstract class AssetGroup {\n    * Load a particular asset from the network, accounting for hash validation.\n    */\n   protected async cacheBustedFetchFromNetwork(req: Request): Promise<Response> {\n-    const url = this.getConfigUrl(req.url);\n+    const url = this.adapter.normalizeUrl(req.url);\n \n     // If a hash is available for this resource, then compare the fetched version with the\n     // canonical hash. Otherwise, the network version will have to be trusted.\n@@ -456,7 +437,7 @@ export abstract class AssetGroup {\n    */\n   protected async maybeUpdate(updateFrom: UpdateSource, req: Request, cache: Cache):\n       Promise<boolean> {\n-    const url = this.getConfigUrl(req.url);\n+    const url = this.adapter.normalizeUrl(req.url);\n     const meta = await this.metadata;\n     // Check if this resource is hashed and already exists in the cache of a prior version.\n     if (this.hashes.has(url)) {\n@@ -546,7 +527,7 @@ export class PrefetchAssetGroup extends AssetGroup {\n           // First, narrow down the set of resources to those which are handled by this group.\n           // Either it's a known URL, or it matches a given pattern.\n           .filter(\n-              url => this.config.urls.some(cacheUrl => cacheUrl === url) ||\n+              url => this.config.urls.indexOf(url) !== -1 ||\n                   this.patterns.some(pattern => pattern.test(url)))\n           // Finally, process each resource in turn.\n           .reduce(async (previous, url) => {"
        },
        {
            "sha": "74a8d5604b357514d0820252c379ec690d6db164",
            "filename": "packages/service-worker/worker/testing/scope.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 11,
            "changes": 24,
            "blob_url": "https://github.com/angular/angular/blob/d380e93b82bbe203f9ded436db9f3de4be3ab2c4/packages%2Fservice-worker%2Fworker%2Ftesting%2Fscope.ts",
            "raw_url": "https://github.com/angular/angular/raw/d380e93b82bbe203f9ded436db9f3de4be3ab2c4/packages%2Fservice-worker%2Fworker%2Ftesting%2Fscope.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Ftesting%2Fscope.ts?ref=d380e93b82bbe203f9ded436db9f3de4be3ab2c4",
            "patch": "@@ -81,8 +81,7 @@ export class MockClients implements Clients {\n   async claim(): Promise<any> {}\n }\n \n-export class SwTestHarness implements ServiceWorkerGlobalScope, Adapter, Context {\n-  readonly cacheNamePrefix: string;\n+export class SwTestHarness extends Adapter implements ServiceWorkerGlobalScope, Context {\n   readonly clients = new MockClients();\n   private eventHandlers = new Map<string, Function>();\n   private skippedWaiting = true;\n@@ -98,7 +97,7 @@ export class SwTestHarness implements ServiceWorkerGlobalScope, Adapter, Context\n         this.selfMessageQueue.push(msg);\n       },\n     },\n-    scope: this.origin,\n+    scope: this.scopeUrl,\n     showNotification:\n         (title: string, options: Object) => {\n           this.notifications.push({title, options});\n@@ -125,7 +124,11 @@ export class SwTestHarness implements ServiceWorkerGlobalScope, Adapter, Context\n     return url && (typeof url.parse === 'function') && (typeof url.resolve === 'function');\n   }\n \n-  time: number;\n+  get time() {\n+    return this.mockTime;\n+  }\n+\n+  private mockTime = Date.now();\n \n   private timers: {\n     at: number,\n@@ -135,10 +138,8 @@ export class SwTestHarness implements ServiceWorkerGlobalScope, Adapter, Context\n   }[] = [];\n \n   constructor(\n-      private server: MockServerState, readonly caches: MockCacheStorage, private origin: string) {\n-    const baseHref = this.parseUrl(origin).path;\n-    this.cacheNamePrefix = 'ngsw:' + baseHref;\n-    this.time = Date.now();\n+      private server: MockServerState, readonly caches: MockCacheStorage, scopeUrl: string) {\n+    super(scopeUrl);\n   }\n \n   async resolveSelfMessages(): Promise<void> {\n@@ -170,6 +171,7 @@ export class SwTestHarness implements ServiceWorkerGlobalScope, Adapter, Context\n     }\n     return skippedWaiting;\n   }\n+\n   updateServerState(server?: MockServerState): void {\n     this.server = server || EMPTY_SERVER_STATE;\n   }\n@@ -281,7 +283,7 @@ export class SwTestHarness implements ServiceWorkerGlobalScope, Adapter, Context\n   timeout(ms: number): Promise<void> {\n     const promise = new Promise<void>(resolve => {\n       this.timers.push({\n-        at: this.time + ms,\n+        at: this.mockTime + ms,\n         duration: ms,\n         fn: resolve,\n         fired: false,\n@@ -296,9 +298,9 @@ export class SwTestHarness implements ServiceWorkerGlobalScope, Adapter, Context\n   }\n \n   advance(by: number): void {\n-    this.time += by;\n+    this.mockTime += by;\n     this.timers.filter(timer => !timer.fired)\n-        .filter(timer => timer.at <= this.time)\n+        .filter(timer => timer.at <= this.mockTime)\n         .forEach(timer => {\n           timer.fired = true;\n           timer.fn();"
        }
    ],
    "stats": {
        "total": 95,
        "additions": 54,
        "deletions": 41
    }
}