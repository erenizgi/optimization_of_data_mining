{
    "author": "atscott",
    "message": "feat(compiler-cli): Add ability to get `Symbol` of `Template`s and `Element`s in component template (#38618)\n\nAdds support to the `TemplateTypeChecker` for retrieving a `Symbol` for\n`TmplAstTemplate` and `TmplAstElement` nodes in a component template.\n\nPR Close #38618",
    "sha": "cf2e8b99a82b039844b6b91041ba64a4829ab0e3",
    "files": [
        {
            "sha": "bf74b313e96367ba04e05dcee7c78a5d95079a3f",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/comments.ts",
            "status": "modified",
            "additions": 48,
            "deletions": 8,
            "changes": 56,
            "blob_url": "https://github.com/angular/angular/blob/cf2e8b99a82b039844b6b91041ba64a4829ab0e3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcomments.ts",
            "raw_url": "https://github.com/angular/angular/raw/cf2e8b99a82b039844b6b91041ba64a4829ab0e3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcomments.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcomments.ts?ref=cf2e8b99a82b039844b6b91041ba64a4829ab0e3",
            "patch": "@@ -88,14 +88,7 @@ export interface FindOptions<T extends ts.Node> {\n   withSpan?: AbsoluteSourceSpan|ParseSourceSpan;\n }\n \n-/**\n- * Given a `ts.Node` with finds the first node whose matching the criteria specified\n- * by the `FindOptions`.\n- *\n- * Returns `null` when no `ts.Node` matches the given conditions.\n- */\n-export function findFirstMatchingNode<T extends ts.Node>(tcb: ts.Node, opts: FindOptions<T>): T|\n-    null {\n+function getSpanFromOptions(opts: FindOptions<ts.Node>) {\n   let withSpan: {start: number, end: number}|null = null;\n   if (opts.withSpan !== undefined) {\n     if (opts.withSpan instanceof AbsoluteSourceSpan) {\n@@ -104,6 +97,18 @@ export function findFirstMatchingNode<T extends ts.Node>(tcb: ts.Node, opts: Fin\n       withSpan = {start: opts.withSpan.start.offset, end: opts.withSpan.end.offset};\n     }\n   }\n+  return withSpan;\n+}\n+\n+/**\n+ * Given a `ts.Node` with finds the first node whose matching the criteria specified\n+ * by the `FindOptions`.\n+ *\n+ * Returns `null` when no `ts.Node` matches the given conditions.\n+ */\n+export function findFirstMatchingNode<T extends ts.Node>(tcb: ts.Node, opts: FindOptions<T>): T|\n+    null {\n+  const withSpan = getSpanFromOptions(opts);\n   const sf = tcb.getSourceFile();\n   const visitor = makeRecursiveVisitor<T>(node => {\n     if (!opts.filter(node)) {\n@@ -120,6 +125,41 @@ export function findFirstMatchingNode<T extends ts.Node>(tcb: ts.Node, opts: Fin\n   return tcb.forEachChild(visitor) ?? null;\n }\n \n+/**\n+ * Given a `ts.Node` with source span comments, finds the first node whose source span comment\n+ * matches the given `sourceSpan`. Additionally, the `filter` function allows matching only\n+ * `ts.Nodes` of a given type, which provides the ability to select only matches of a given type\n+ * when there may be more than one.\n+ *\n+ * Returns `null` when no `ts.Node` matches the given conditions.\n+ */\n+export function findAllMatchingNodes<T extends ts.Node>(tcb: ts.Node, opts: FindOptions<T>): T[] {\n+  const withSpan = getSpanFromOptions(opts);\n+  const results: T[] = [];\n+  const stack: ts.Node[] = [tcb];\n+  const sf = tcb.getSourceFile();\n+\n+  while (stack.length > 0) {\n+    const node = stack.pop()!;\n+\n+    if (!opts.filter(node)) {\n+      stack.push(...node.getChildren());\n+      continue;\n+    }\n+    if (withSpan !== null) {\n+      const comment = readSpanComment(node, sf);\n+      if (comment === null || withSpan.start !== comment.start || withSpan.end !== comment.end) {\n+        stack.push(...node.getChildren());\n+        continue;\n+      }\n+    }\n+\n+    results.push(node);\n+  }\n+\n+  return results;\n+}\n+\n export function hasExpressionIdentifier(\n     sourceFile: ts.SourceFile, node: ts.Node, identifier: ExpressionIdentifier): boolean {\n   return ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {"
        },
        {
            "sha": "4312eaa2abe1a572a3c9377f41238921bc43a478",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder.ts",
            "status": "modified",
            "additions": 64,
            "deletions": 7,
            "changes": 71,
            "blob_url": "https://github.com/angular/angular/blob/cf2e8b99a82b039844b6b91041ba64a4829ab0e3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "raw_url": "https://github.com/angular/angular/raw/cf2e8b99a82b039844b6b91041ba64a4829ab0e3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts?ref=cf2e8b99a82b039844b6b91041ba64a4829ab0e3",
            "patch": "@@ -11,12 +11,13 @@ import * as ts from 'typescript';\n \n import {AbsoluteFsPath} from '../../file_system';\n import {isAssignment} from '../../util/src/typescript';\n-import {DirectiveSymbol, ElementSymbol, ExpressionSymbol, InputBindingSymbol, OutputBindingSymbol, ReferenceSymbol, Symbol, SymbolKind, TsNodeSymbolInfo, VariableSymbol} from '../api';\n+import {DirectiveSymbol, ElementSymbol, ExpressionSymbol, InputBindingSymbol, OutputBindingSymbol, Symbol, SymbolKind, TemplateSymbol, TsNodeSymbolInfo} from '../api';\n \n-import {ExpressionIdentifier, findFirstMatchingNode, hasExpressionIdentifier} from './comments';\n+import {ExpressionIdentifier, findAllMatchingNodes, findFirstMatchingNode, hasExpressionIdentifier} from './comments';\n import {TemplateData} from './context';\n import {TcbDirectiveOutputsOp} from './type_check_block';\n \n+\n /**\n  * A class which extracts information from a type check block.\n  * This class is essentially used as just a closure around the constructor parameters.\n@@ -26,17 +27,74 @@ export class SymbolBuilder {\n       private readonly typeChecker: ts.TypeChecker, private readonly shimPath: AbsoluteFsPath,\n       private readonly typeCheckBlock: ts.Node, private readonly templateData: TemplateData) {}\n \n+  getSymbol(node: TmplAstTemplate|TmplAstElement): TemplateSymbol|ElementSymbol|null;\n+  getSymbol(node: AST|TmplAstNode): Symbol|null;\n   getSymbol(node: AST|TmplAstNode): Symbol|null {\n     if (node instanceof TmplAstBoundAttribute) {\n       // TODO(atscott): input and output bindings only return the first directive match but should\n       // return a list of bindings for all of them.\n       return this.getSymbolOfInputBinding(node);\n     } else if (node instanceof TmplAstBoundEvent) {\n       return this.getSymbolOfBoundEvent(node);\n+    } else if (node instanceof TmplAstElement) {\n+      return this.getSymbolOfElement(node);\n+    } else if (node instanceof TmplAstTemplate) {\n+      return this.getSymbolOfAstTemplate(node);\n     }\n     return null;\n   }\n \n+  private getSymbolOfAstTemplate(template: TmplAstTemplate): TemplateSymbol|null {\n+    const directives = this.getDirectivesOfNode(template);\n+    return {kind: SymbolKind.Template, directives};\n+  }\n+\n+  private getSymbolOfElement(element: TmplAstElement): ElementSymbol|null {\n+    const elementSourceSpan = element.startSourceSpan ?? element.sourceSpan;\n+\n+    const node = findFirstMatchingNode(\n+        this.typeCheckBlock, {withSpan: elementSourceSpan, filter: ts.isVariableDeclaration});\n+    if (node === null) {\n+      return null;\n+    }\n+\n+    const symbolFromDeclaration = this.getSymbolOfVariableDeclaration(node);\n+    if (symbolFromDeclaration === null || symbolFromDeclaration.tsSymbol === null) {\n+      return null;\n+    }\n+\n+    const directives = this.getDirectivesOfNode(element);\n+    // All statements in the TCB are `Expression`s that optionally include more information.\n+    // An `ElementSymbol` uses the information returned for the variable declaration expression,\n+    // adds the directives for the element, and updates the `kind` to be `SymbolKind.Element`.\n+    return {\n+      ...symbolFromDeclaration,\n+      kind: SymbolKind.Element,\n+      directives,\n+    };\n+  }\n+\n+  private getDirectivesOfNode(element: TmplAstElement|TmplAstTemplate): DirectiveSymbol[] {\n+    const elementSourceSpan = element.startSourceSpan ?? element.sourceSpan;\n+    const tcbSourceFile = this.typeCheckBlock.getSourceFile();\n+    const isDirectiveDeclaration = (node: ts.Node): node is ts.TypeNode => ts.isTypeNode(node) &&\n+        hasExpressionIdentifier(tcbSourceFile, node, ExpressionIdentifier.DIRECTIVE);\n+\n+    const nodes = findAllMatchingNodes(\n+        this.typeCheckBlock, {withSpan: elementSourceSpan, filter: isDirectiveDeclaration});\n+    return nodes\n+        .map(node => {\n+          const symbol = this.getSymbolOfTsNode(node);\n+          if (symbol === null || symbol.tsSymbol === null) {\n+            return null;\n+          }\n+          const directiveSymbol:\n+              DirectiveSymbol = {...symbol, tsSymbol: symbol.tsSymbol, kind: SymbolKind.Directive};\n+          return directiveSymbol;\n+        })\n+        .filter((d): d is DirectiveSymbol => d !== null);\n+  }\n+\n   private getSymbolOfBoundEvent(eventBinding: TmplAstBoundEvent): OutputBindingSymbol|null {\n     // Outputs are a `ts.CallExpression` that look like one of the two:\n     // * _outputHelper(_t1[\"outputField\"]).subscribe(handler);\n@@ -110,10 +168,9 @@ export class SymbolBuilder {\n     }\n \n     const consumer = this.templateData.boundTarget.getConsumerOfBinding(attributeBinding);\n-    let target: ElementSymbol|DirectiveSymbol|null;\n+    let target: ElementSymbol|TemplateSymbol|DirectiveSymbol|null;\n     if (consumer instanceof TmplAstTemplate || consumer instanceof TmplAstElement) {\n-      // TODO(atscott): handle bindings to elements and templates\n-      target = null;\n+      target = this.getSymbol(consumer);\n     } else {\n       target = this.getDirectiveSymbolForAccessExpression(node.left);\n     }\n@@ -154,15 +211,15 @@ export class SymbolBuilder {\n     }\n \n     const symbol = this.getSymbolOfVariableDeclaration(declaration);\n-    if (symbol === null || symbol.tsSymbol === null || symbol.tsType === null) {\n+    if (symbol === null || symbol.tsSymbol === null) {\n       return null;\n     }\n \n     return {\n-      ...symbol,\n       kind: SymbolKind.Directive,\n       tsSymbol: symbol.tsSymbol,\n       tsType: symbol.tsType,\n+      shimLocation: symbol.shimLocation,\n     };\n   }\n "
        },
        {
            "sha": "5e5efbf0f447da7a7d718b6d68ceb6d708dd8f53",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker__get_symbol_of_template_node_spec.ts",
            "status": "modified",
            "additions": 171,
            "deletions": 3,
            "changes": 174,
            "blob_url": "https://github.com/angular/angular/blob/cf2e8b99a82b039844b6b91041ba64a4829ab0e3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/cf2e8b99a82b039844b6b91041ba64a4829ab0e3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts?ref=cf2e8b99a82b039844b6b91041ba64a4829ab0e3",
            "patch": "@@ -6,17 +6,69 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {TmplAstBoundAttribute, TmplAstElement, TmplAstTemplate} from '@angular/compiler';\n+import {TmplAstBoundAttribute, TmplAstElement, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {absoluteFrom, getSourceFileOrError} from '../../file_system';\n import {runInEachFileSystem} from '../../file_system/testing';\n-import {InputBindingSymbol, OutputBindingSymbol, Symbol, SymbolKind, TypeCheckingConfig} from '../api';\n+import {ClassDeclaration} from '../../reflection';\n+import {DirectiveSymbol, ElementSymbol, InputBindingSymbol, OutputBindingSymbol, Symbol, SymbolKind, TemplateSymbol, TemplateTypeChecker, TypeCheckingConfig} from '../api';\n \n import {getClass, ngForDeclaration, ngForTypeCheckTarget, setup as baseTestSetup, TypeCheckingTarget} from './test_utils';\n \n runInEachFileSystem(() => {\n-  describe('TemplateTypeChecker.getSymbolOfNodeInComponentTemplate', () => {\n+  describe('TemplateTypeChecker.getSymbolOfNode', () => {\n+    describe('templates', () => {\n+      describe('ng-templates', () => {\n+        let templateTypeChecker: TemplateTypeChecker;\n+        let cmp: ClassDeclaration<ts.ClassDeclaration>;\n+        let templateNode: TmplAstTemplate;\n+        let program: ts.Program;\n+\n+        beforeEach(() => {\n+          const fileName = absoluteFrom('/main.ts');\n+          const dirFile = absoluteFrom('/dir.ts');\n+          const templateString = `\n+              <ng-template dir #ref0 #ref1=\"dir\" let-contextFoo=\"bar\">\n+                <div [input0]=\"contextFoo\" [input1]=\"ref0\" [input2]=\"ref1\"></div>\n+              </ng-template>`;\n+          const testValues = setup([\n+            {\n+              fileName,\n+              templates: {'Cmp': templateString},\n+              source: `\n+                    export class Cmp { }`,\n+              declarations: [{\n+                name: 'TestDir',\n+                selector: '[dir]',\n+                file: dirFile,\n+                type: 'directive',\n+                exportAs: ['dir'],\n+              }]\n+            },\n+            {\n+              fileName: dirFile,\n+              source: `export class TestDir {}`,\n+              templates: {},\n+            }\n+          ]);\n+          templateTypeChecker = testValues.templateTypeChecker;\n+          program = testValues.program;\n+          const sf = getSourceFileOrError(testValues.program, fileName);\n+          cmp = getClass(sf, 'Cmp');\n+          templateNode = getAstTemplates(templateTypeChecker, cmp)[0];\n+        });\n+\n+        it('should get symbol for the template itself', () => {\n+          const symbol = templateTypeChecker.getSymbolOfNode(templateNode, cmp)!;\n+          assertTemplateSymbol(symbol);\n+          expect(symbol.directives.length).toBe(1);\n+          assertDirectiveSymbol(symbol.directives[0]);\n+          expect(symbol.directives[0].tsSymbol.getName()).toBe('TestDir');\n+        });\n+      });\n+    });\n+\n     describe('input bindings', () => {\n       it('can retrieve a symbol for an input binding', () => {\n         const fileName = absoluteFrom('/main.ts');\n@@ -473,9 +525,117 @@ runInEachFileSystem(() => {\n         expect(symbol).toBeNull();\n       });\n     });\n+\n+    describe('for elements', () => {\n+      it('for elements that are components with no inputs', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const dirFile = absoluteFrom('/dir.ts');\n+        const {program, templateTypeChecker} = setup(\n+            [\n+              {\n+                fileName,\n+                templates: {'Cmp': `<child-component></child-component>`},\n+                declarations: [\n+                  {\n+                    name: 'ChildComponent',\n+                    selector: 'child-component',\n+                    file: dirFile,\n+                    type: 'directive',\n+                  },\n+                ]\n+              },\n+              {\n+                fileName: dirFile,\n+                source: `\n+              export class ChildComponent {}\n+            `,\n+                templates: {'ChildComponent': ''},\n+              }\n+            ],\n+        );\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+\n+        const nodes = templateTypeChecker.getTemplate(cmp)!;\n+\n+        const symbol = templateTypeChecker.getSymbolOfNode(nodes[0] as TmplAstElement, cmp)!;\n+        assertElementSymbol(symbol);\n+        expect(symbol.directives.length).toBe(1);\n+        assertDirectiveSymbol(symbol.directives[0]);\n+        expect(program.getTypeChecker().typeToString(symbol.directives[0].tsType))\n+            .toEqual('ChildComponent');\n+      });\n+\n+      it('element with directive matches', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const dirFile = absoluteFrom('/dir.ts');\n+        const {program, templateTypeChecker} = setup(\n+            [\n+              {\n+                fileName,\n+                templates: {'Cmp': `<div dir dir2></div>`},\n+                declarations: [\n+                  {\n+                    name: 'TestDir',\n+                    selector: '[dir]',\n+                    file: dirFile,\n+                    type: 'directive',\n+                  },\n+                  {\n+                    name: 'TestDir2',\n+                    selector: '[dir2]',\n+                    file: dirFile,\n+                    type: 'directive',\n+                  },\n+                  {\n+                    name: 'TestDirAllDivs',\n+                    selector: 'div',\n+                    file: dirFile,\n+                    type: 'directive',\n+                  },\n+                ]\n+              },\n+              {\n+                fileName: dirFile,\n+                source: `\n+              export class TestDir {}\n+              export class TestDir2 {}\n+              export class TestDirAllDivs {}\n+            `,\n+                templates: {},\n+              }\n+            ],\n+        );\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+\n+        const nodes = templateTypeChecker.getTemplate(cmp)!;\n+\n+        const symbol = templateTypeChecker.getSymbolOfNode(nodes[0] as TmplAstElement, cmp)!;\n+        assertElementSymbol(symbol);\n+        expect(symbol.directives.length).toBe(3);\n+        const expectedDirectives = ['TestDir', 'TestDir2', 'TestDirAllDivs'].sort();\n+        const actualDirectives =\n+            symbol.directives.map(dir => program.getTypeChecker().typeToString(dir.tsType)).sort();\n+        expect(actualDirectives).toEqual(expectedDirectives);\n+      });\n+    });\n   });\n });\n \n+function onlyAstTemplates(nodes: TmplAstNode[]): TmplAstTemplate[] {\n+  return nodes.filter((n): n is TmplAstTemplate => n instanceof TmplAstTemplate);\n+}\n+\n+function getAstTemplates(\n+    templateTypeChecker: TemplateTypeChecker, cmp: ts.ClassDeclaration&{name: ts.Identifier}) {\n+  return onlyAstTemplates(templateTypeChecker.getTemplate(cmp)!);\n+}\n+\n+function assertDirectiveSymbol(tSymbol: Symbol): asserts tSymbol is DirectiveSymbol {\n+  expect(tSymbol.kind).toEqual(SymbolKind.Directive);\n+}\n+\n function assertInputBindingSymbol(tSymbol: Symbol): asserts tSymbol is InputBindingSymbol {\n   expect(tSymbol.kind).toEqual(SymbolKind.Input);\n }\n@@ -484,6 +644,14 @@ function assertOutputBindingSymbol(tSymbol: Symbol): asserts tSymbol is OutputBi\n   expect(tSymbol.kind).toEqual(SymbolKind.Output);\n }\n \n+function assertTemplateSymbol(tSymbol: Symbol): asserts tSymbol is TemplateSymbol {\n+  expect(tSymbol.kind).toEqual(SymbolKind.Template);\n+}\n+\n+function assertElementSymbol(tSymbol: Symbol): asserts tSymbol is ElementSymbol {\n+  expect(tSymbol.kind).toEqual(SymbolKind.Element);\n+}\n+\n export function setup(targets: TypeCheckingTarget[], config?: Partial<TypeCheckingConfig>) {\n   return baseTestSetup(\n       targets, {inlining: false, config: {...config, enableTemplateTypeChecker: true}});"
        }
    ],
    "stats": {
        "total": 301,
        "additions": 283,
        "deletions": 18
    }
}