{
    "author": "JoostK",
    "message": "fix(compiler-cli): prevent stack overflow in decorator transform for large number of files (#40374)\n\nThe decorator downleveling transform patches `ts.EmitResolver.isReferencedAliasDeclaration`\nto prevent elision of value imports that occur only in a type-position, which would\ninadvertently install the patch repeatedly for each source file in the program.\nThis could potentially result in a stack overflow when a very large number of files is\npresent in the program.\n\nThis commit fixes the issue by ensuring that the patch is only applied once.\nThis is also a slight performance improvement, as `isReferencedAliasDeclaration`\nis no longer repeatedly calling into all prior installed patch functions.\n\nFixes #40276\n\nPR Close #40374",
    "sha": "27d0e54705744c9aed7accbc9dafd9d74c6f4f3b",
    "files": [
        {
            "sha": "a5533f38a109fe0f88908bed318184b39ca4d576",
            "filename": "packages/compiler-cli/src/transformers/downlevel_decorators_transform.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/27d0e54705744c9aed7accbc9dafd9d74c6f4f3b/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fdownlevel_decorators_transform.ts",
            "raw_url": "https://github.com/angular/angular/raw/27d0e54705744c9aed7accbc9dafd9d74c6f4f3b/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fdownlevel_decorators_transform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fdownlevel_decorators_transform.ts?ref=27d0e54705744c9aed7accbc9dafd9d74c6f4f3b",
            "patch": "@@ -8,7 +8,7 @@\n \n import * as ts from 'typescript';\n import {Decorator, ReflectionHost} from '../ngtsc/reflection';\n-import {isAliasImportDeclaration, patchAliasReferenceResolutionOrDie} from './patch_alias_reference_resolution';\n+import {isAliasImportDeclaration, loadIsReferencedAliasDeclarationPatch} from './patch_alias_reference_resolution';\n \n /**\n  * Whether a given decorator should be treated as an Angular decorator.\n@@ -347,7 +347,12 @@ export function getDownlevelDecoratorsTransform(\n     isCore: boolean, isClosureCompilerEnabled: boolean,\n     skipClassDecorators: boolean): ts.TransformerFactory<ts.SourceFile> {\n   return (context: ts.TransformationContext) => {\n-    let referencedParameterTypes = new Set<ts.Declaration>();\n+    // Ensure that referenced type symbols are not elided by TypeScript. Imports for\n+    // such parameter type symbols previously could be type-only, but now might be also\n+    // used in the `ctorParameters` static property as a value. We want to make sure\n+    // that TypeScript does not elide imports for such type references. Read more\n+    // about this in the description for `loadIsReferencedAliasDeclarationPatch`.\n+    const referencedParameterTypes = loadIsReferencedAliasDeclarationPatch(context);\n \n     /**\n      * Converts an EntityName (from a type annotation) to an expression (accessing a value).\n@@ -595,12 +600,6 @@ export function getDownlevelDecoratorsTransform(\n     }\n \n     return (sf: ts.SourceFile) => {\n-      // Ensure that referenced type symbols are not elided by TypeScript. Imports for\n-      // such parameter type symbols previously could be type-only, but now might be also\n-      // used in the `ctorParameters` static property as a value. We want to make sure\n-      // that TypeScript does not elide imports for such type references. Read more\n-      // about this in the description for `patchAliasReferenceResolution`.\n-      patchAliasReferenceResolutionOrDie(context, referencedParameterTypes);\n       // Downlevel decorators and constructor parameter types. We will keep track of all\n       // referenced constructor parameter types so that we can instruct TypeScript to\n       // not elide their imports if they previously were only type-only."
        },
        {
            "sha": "7f632a315d6c9ed499840a10ddea88e19286a2c5",
            "filename": "packages/compiler-cli/src/transformers/patch_alias_reference_resolution.ts",
            "status": "modified",
            "additions": 30,
            "deletions": 13,
            "changes": 43,
            "blob_url": "https://github.com/angular/angular/blob/27d0e54705744c9aed7accbc9dafd9d74c6f4f3b/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fpatch_alias_reference_resolution.ts",
            "raw_url": "https://github.com/angular/angular/raw/27d0e54705744c9aed7accbc9dafd9d74c6f4f3b/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fpatch_alias_reference_resolution.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fpatch_alias_reference_resolution.ts?ref=27d0e54705744c9aed7accbc9dafd9d74c6f4f3b",
            "patch": "@@ -17,9 +17,12 @@ interface TransformationContextWithResolver extends ts.TransformationContext {\n   getEmitResolver: () => EmitResolver;\n }\n \n+const patchedReferencedAliasesSymbol = Symbol('patchedReferencedAliases');\n+\n /** Describes a subset of the TypeScript internal emit resolver. */\n interface EmitResolver {\n-  isReferencedAliasDeclaration?(node: ts.Node, checkChildren?: boolean): void;\n+  isReferencedAliasDeclaration?(node: ts.Node, ...args: unknown[]): void;\n+  [patchedReferencedAliasesSymbol]?: Set<ts.Declaration>;\n }\n \n /**\n@@ -40,10 +43,10 @@ interface EmitResolver {\n  * This is a trick the CLI used in the past  for constructor parameter downleveling in JIT:\n  * https://github.com/angular/angular-cli/blob/b3f84cc5184337666ce61c07b7b9df418030106f/packages/ngtools/webpack/src/transformers/ctor-parameters.ts#L323-L325\n  * The trick is not ideal though as it preserves the full import (as outlined before), and it\n- * results in a slow-down due to the type checker being involved multiple times. The CLI\n- * worked around this import preserving issue by having another complex post-process step that\n- * detects and elides unused imports. Note that these unused imports could cause unused chunks\n- * being generated by Webpack if the application or library is not marked as side-effect free.\n+ * results in a slow-down due to the type checker being involved multiple times. The CLI worked\n+ * around this import preserving issue by having another complex post-process step that detects and\n+ * elides unused imports. Note that these unused imports could cause unused chunks being generated\n+ * by Webpack if the application or library is not marked as side-effect free.\n  *\n  * This is not ideal though, as we basically re-implement the complex import usage resolution\n  * from TypeScript. We can do better by letting TypeScript do the import eliding, but providing\n@@ -60,32 +63,46 @@ interface EmitResolver {\n  * `emitDecoratorMetadata` flag is enabled. TypeScript basically surfaces the same problem and\n  * solves it conceptually the same way, but obviously doesn't need to access an `@internal` API.\n  *\n+ * The set that is returned by this function is meant to be filled with import declaration nodes\n+ * that have been referenced in a value-position by the transform, such the the installed patch can\n+ * ensure that those import declarations are not elided.\n+ *\n  * See below. Note that this uses sourcegraph as the TypeScript checker file doesn't display on\n  * Github.\n  * https://sourcegraph.com/github.com/microsoft/TypeScript@3eaa7c65f6f076a08a5f7f1946fd0df7c7430259/-/blob/src/compiler/checker.ts#L31219-31257\n  */\n-export function patchAliasReferenceResolutionOrDie(\n-    context: ts.TransformationContext, referencedAliases: Set<ts.Declaration>): void {\n+export function loadIsReferencedAliasDeclarationPatch(context: ts.TransformationContext):\n+    Set<ts.Declaration> {\n   // If the `getEmitResolver` method is not available, TS most likely changed the\n   // internal structure of the transformation context. We will abort gracefully.\n   if (!isTransformationContextWithEmitResolver(context)) {\n     throwIncompatibleTransformationContextError();\n-    return;\n   }\n   const emitResolver = context.getEmitResolver();\n-  const originalReferenceResolution = emitResolver.isReferencedAliasDeclaration;\n+\n+  // The emit resolver may have been patched already, in which case we return the set of referenced\n+  // aliases that was created when the patch was first applied.\n+  // See https://github.com/angular/angular/issues/40276.\n+  const existingReferencedAliases = emitResolver[patchedReferencedAliasesSymbol];\n+  if (existingReferencedAliases !== undefined) {\n+    return existingReferencedAliases;\n+  }\n+\n+  const originalIsReferencedAliasDeclaration = emitResolver.isReferencedAliasDeclaration;\n   // If the emit resolver does not have a function called `isReferencedAliasDeclaration`, then\n   // we abort gracefully as most likely TS changed the internal structure of the emit resolver.\n-  if (originalReferenceResolution === undefined) {\n+  if (originalIsReferencedAliasDeclaration === undefined) {\n     throwIncompatibleTransformationContextError();\n-    return;\n   }\n+\n+  const referencedAliases = new Set<ts.Declaration>();\n   emitResolver.isReferencedAliasDeclaration = function(node, ...args) {\n     if (isAliasImportDeclaration(node) && referencedAliases.has(node)) {\n       return true;\n     }\n-    return originalReferenceResolution.call(emitResolver, node, ...args);\n+    return originalIsReferencedAliasDeclaration.call(emitResolver, node, ...args);\n   };\n+  return emitResolver[patchedReferencedAliasesSymbol] = referencedAliases;\n }\n \n /**\n@@ -110,7 +127,7 @@ function isTransformationContextWithEmitResolver(context: ts.TransformationConte\n  * declaration reference resolution could not be monkey-patched. The error will\n  * also propose potential solutions that can be applied by developers.\n  */\n-function throwIncompatibleTransformationContextError() {\n+function throwIncompatibleTransformationContextError(): never {\n   throw Error(\n       'Unable to downlevel Angular decorators due to an incompatible TypeScript ' +\n       'version.\\nIf you recently updated TypeScript and this issue surfaces now, consider ' +"
        },
        {
            "sha": "7aa942901c9802edca849b7960fc0cdbebaddefa",
            "filename": "packages/compiler-cli/test/transformers/downlevel_decorators_transform_spec.ts",
            "status": "modified",
            "additions": 101,
            "deletions": 0,
            "changes": 101,
            "blob_url": "https://github.com/angular/angular/blob/27d0e54705744c9aed7accbc9dafd9d74c6f4f3b/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fdownlevel_decorators_transform_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/27d0e54705744c9aed7accbc9dafd9d74c6f4f3b/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fdownlevel_decorators_transform_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fdownlevel_decorators_transform_spec.ts?ref=27d0e54705744c9aed7accbc9dafd9d74c6f4f3b",
            "patch": "@@ -740,6 +740,107 @@ describe('downlevel decorator transform', () => {\n       `);\n     });\n   });\n+\n+  describe('transforming multiple files', () => {\n+    it('should work correctly for multiple files that import distinct declarations', () => {\n+      context.writeFile('foo_service.d.ts', `\n+        export declare class Foo {};\n+      `);\n+      context.writeFile('foo.ts', `\n+        import {Injectable} from '@angular/core';\n+        import {Foo} from './foo_service';\n+\n+        @Injectable()\n+        export class MyService {\n+          constructor(foo: Foo) {}\n+        }\n+      `);\n+\n+      context.writeFile('bar_service.d.ts', `\n+        export declare class Bar {};\n+      `);\n+      context.writeFile('bar.ts', `\n+        import {Injectable} from '@angular/core';\n+        import {Bar} from './bar_service';\n+\n+        @Injectable()\n+        export class MyService {\n+          constructor(bar: Bar) {}\n+        }\n+      `);\n+\n+      const {program, transformers} = createProgramWithTransform(['/foo.ts', '/bar.ts']);\n+      program.emit(undefined, undefined, undefined, undefined, transformers);\n+\n+      expect(context.readFile('/foo.js')).toContain(`import { Foo } from './foo_service';`);\n+      expect(context.readFile('/bar.js')).toContain(`import { Bar } from './bar_service';`);\n+    });\n+\n+    it('should not result in a stack overflow for a large number of files', () => {\n+      // The decorators transform used to patch `ts.EmitResolver.isReferencedAliasDeclaration`\n+      // repeatedly for each source file in the program, causing a stack overflow once a large\n+      // number of source files was reached. This test verifies that emit succeeds even when there's\n+      // lots of source files. See https://github.com/angular/angular/issues/40276.\n+      context.writeFile('foo.d.ts', `\n+        export declare class Foo {};\n+      `);\n+\n+      // A somewhat minimal number of source files that used to trigger a stack overflow.\n+      const numberOfTestFiles = 6500;\n+      const files: string[] = [];\n+      for (let i = 0; i < numberOfTestFiles; i++) {\n+        const file = `/${i}.ts`;\n+        files.push(file);\n+        context.writeFile(file, `\n+          import {Injectable} from '@angular/core';\n+          import {Foo} from './foo';\n+\n+          @Injectable()\n+          export class MyService {\n+            constructor(foo: Foo) {}\n+          }\n+        `);\n+      }\n+\n+      const {program, transformers} = createProgramWithTransform(files);\n+\n+      let written = 0;\n+      program.emit(undefined, (fileName, outputText) => {\n+        written++;\n+\n+        // The below assertion throws an explicit error instead of using a Jasmine expectation,\n+        // as we want to abort on the first failure, if any. This avoids as many as `numberOfFiles`\n+        // expectation failures, which would bloat the test output.\n+        if (!outputText.includes(`import { Foo } from './foo';`)) {\n+          throw new Error(`Transform failed to preserve the import in ${fileName}:\\n${outputText}`);\n+        }\n+      }, undefined, undefined, transformers);\n+      expect(written).toBe(numberOfTestFiles);\n+    });\n+\n+    function createProgramWithTransform(files: string[]) {\n+      const program = ts.createProgram(\n+          files, {\n+            moduleResolution: ts.ModuleResolutionKind.NodeJs,\n+            importHelpers: true,\n+            lib: [],\n+            module: ts.ModuleKind.ESNext,\n+            target: ts.ScriptTarget.Latest,\n+            declaration: false,\n+            experimentalDecorators: true,\n+            emitDecoratorMetadata: false,\n+          },\n+          host);\n+      const typeChecker = program.getTypeChecker();\n+      const reflectionHost = new TypeScriptReflectionHost(typeChecker);\n+      const transformers: ts.CustomTransformers = {\n+        before: [getDownlevelDecoratorsTransform(\n+            program.getTypeChecker(), reflectionHost, diagnostics,\n+            /* isCore */ false, isClosureEnabled, skipClassDecorators)]\n+      };\n+      return {program, transformers};\n+    }\n+  });\n });\n \n /** Template string function that can be used to dedent a given string literal. */"
        }
    ],
    "stats": {
        "total": 159,
        "additions": 138,
        "deletions": 21
    }
}