{
    "author": "atscott",
    "message": "test(router): update scroller tests to use real objects (#40241)\n\nThe current tests in the router scroller are\n[change-detector tests](https://testing.googleblog.com/2015/01/testing-on-toilet-change-detector-tests.html)\nand do not ensure the correct behavior of the scroller.\nThis commit updates the tests to assert actual scrolling behavior of the\nbrowser.\n\nPR Close #40241",
    "sha": "112dff81b032810097f46d0690a89aa7b195d6ec",
    "files": [
        {
            "sha": "58ffb5bb1d074ea4ce54800d281d0a05615be593",
            "filename": "packages/common/test/viewport_scroller_spec.ts",
            "status": "modified",
            "additions": 41,
            "deletions": 30,
            "changes": 71,
            "blob_url": "https://github.com/angular/angular/blob/112dff81b032810097f46d0690a89aa7b195d6ec/packages%2Fcommon%2Ftest%2Fviewport_scroller_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/112dff81b032810097f46d0690a89aa7b195d6ec/packages%2Fcommon%2Ftest%2Fviewport_scroller_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Ftest%2Fviewport_scroller_spec.ts?ref=112dff81b032810097f46d0690a89aa7b195d6ec",
            "patch": "@@ -10,19 +10,17 @@ import {describe, expect, it} from '@angular/core/testing/src/testing_internal';\n import {BrowserViewportScroller, ViewportScroller} from '../src/viewport_scroller';\n \n describe('BrowserViewportScroller', () => {\n-  let scroller: ViewportScroller;\n-  let documentSpy: any;\n-  let windowSpy: any;\n+  describe('setHistoryScrollRestoration', () => {\n+    let scroller: ViewportScroller;\n+    let windowSpy: any;\n \n-  beforeEach(() => {\n-    windowSpy =\n-        jasmine.createSpyObj('window', ['history', 'scrollTo', 'pageXOffset', 'pageYOffset']);\n-    windowSpy.history.scrollRestoration = 'auto';\n-    documentSpy = jasmine.createSpyObj('document', ['getElementById', 'getElementsByName']);\n-    scroller = new BrowserViewportScroller(documentSpy, windowSpy);\n-  });\n+    beforeEach(() => {\n+      windowSpy =\n+          jasmine.createSpyObj('window', ['history', 'scrollTo', 'pageXOffset', 'pageYOffset']);\n+      windowSpy.history.scrollRestoration = 'auto';\n+      scroller = new BrowserViewportScroller(document, windowSpy);\n+    });\n \n-  describe('setHistoryScrollRestoration', () => {\n     function createNonWritableScrollRestoration() {\n       Object.defineProperty(windowSpy.history, 'scrollRestoration', {\n         value: 'auto',\n@@ -43,34 +41,47 @@ describe('BrowserViewportScroller', () => {\n   });\n \n   describe('scrollToAnchor', () => {\n+    // Testing scroll behavior does not make sense outside a browser\n+    if (isNode) return;\n     const anchor = 'anchor';\n-    const el = document.createElement('a');\n+    let tallItem: HTMLDivElement;\n+    let el: HTMLAnchorElement;\n+    let scroller: BrowserViewportScroller;\n+\n+    beforeEach(() => {\n+      scroller = new BrowserViewportScroller(document, window);\n+      scroller.scrollToPosition([0, 0]);\n+\n+      tallItem = document.createElement('div');\n+      tallItem.style.height = '3000px';\n+      document.body.appendChild(tallItem);\n+\n+      el = document.createElement('a');\n+      el.innerText = 'some link';\n+      el.href = '#';\n+      document.body.appendChild(el);\n+    });\n+\n+    afterEach(() => {\n+      document.body.removeChild(tallItem);\n+      document.body.removeChild(el);\n+    });\n \n-    it('should only call getElementById when an element is found by id', () => {\n-      documentSpy.getElementById.and.returnValue(el);\n-      spyOn<any>(scroller, 'scrollToElement');\n+    it('should scroll when element with matching id is found', () => {\n+      el.id = anchor;\n       scroller.scrollToAnchor(anchor);\n-      expect(documentSpy.getElementById).toHaveBeenCalledWith(anchor);\n-      expect(documentSpy.getElementsByName).not.toHaveBeenCalled();\n-      expect((scroller as any).scrollToElement).toHaveBeenCalledWith(el);\n+      expect(scroller.getScrollPosition()[1]).not.toEqual(0);\n     });\n \n-    it('should call getElementById and getElementsByName when an element is found by name', () => {\n-      documentSpy.getElementsByName.and.returnValue([el]);\n-      spyOn<any>(scroller, 'scrollToElement');\n+    it('should scroll when anchor with matching name is found', () => {\n+      el.name = anchor;\n       scroller.scrollToAnchor(anchor);\n-      expect(documentSpy.getElementById).toHaveBeenCalledWith(anchor);\n-      expect(documentSpy.getElementsByName).toHaveBeenCalledWith(anchor);\n-      expect((scroller as any).scrollToElement).toHaveBeenCalledWith(el);\n+      expect(scroller.getScrollPosition()[1]).not.toEqual(0);\n     });\n \n-    it('should not call scrollToElement when an element is not found by its id or its name', () => {\n-      documentSpy.getElementsByName.and.returnValue([]);\n-      spyOn<any>(scroller, 'scrollToElement');\n+    it('should not scroll when no matching element is found', () => {\n       scroller.scrollToAnchor(anchor);\n-      expect(documentSpy.getElementById).toHaveBeenCalledWith(anchor);\n-      expect(documentSpy.getElementsByName).toHaveBeenCalledWith(anchor);\n-      expect((scroller as any).scrollToElement).not.toHaveBeenCalled();\n+      expect(scroller.getScrollPosition()[1]).toEqual(0);\n     });\n   });\n });"
        }
    ],
    "stats": {
        "total": 71,
        "additions": 41,
        "deletions": 30
    }
}