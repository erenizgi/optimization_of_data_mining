{
    "author": "thePunderWoman",
    "message": "fix(core): Access injected parent values using SelfSkip (#39464)\n\nIn ViewEngine, SelfSkip would navigate up the tree to get tokens from\nthe parent node, skipping the child. This restores that functionality in\nIvy. In ViewEngine, if a special token (e.g. ElementRef) was not found\nin the NodeInjector tree, the ModuleInjector was also used to lookup\nthat token. While special tokens like ElementRef make sense only in a\ncontext of a NodeInjector, we preserved ViewEngine logic for now to\navoid breaking changes.\n\nWe identified 4 scenarios related to @SkipSelf and special tokens where\nViewEngine behavior was incorrect and is likely due to bugs. In Ivy this\nis implemented to provide a more intuitive API. The list of scenarios\ncan be found below.\n\n1. When Injector is used in combination with @Host and @SkipSelf on the\nfirst Component within a module and the injector is defined in the\nmodule, ViewEngine will get the injector from the module. In Ivy, it\ndoes not do this and throws instead.\n\n2. When retrieving a @ViewContainerRef while @SkipSelf and @Host are\npresent, in ViewEngine, it throws an exception. In Ivy it returns the\nhost ViewContainerRef.\n\n3. When retrieving a @ViewContainerRef on an embedded view and @SkipSelf\nis present, in ViewEngine, the ref is null. In Ivy it returns the parent\nViewContainerRef.\n\n4. When utilizing viewProviders and providers, a child component that is\nnested within a parent component that has @SkipSelf on a viewProvider\nvalue, if that provider is provided by the parent component's\nviewProviders and providers, ViewEngine will return that parent's\nviewProviders value, which violates how viewProviders' visibility should\nwork. In Ivy, it retrieves the value from providers, as it should.\n\nThese discrepancies all behave as they should in Ivy and are likely bugs\nin ViewEngine.\n\nPR Close #39464",
    "sha": "290ea57a9309ed3bd9a5c3635d13f7a45945abbf",
    "files": [
        {
            "sha": "7adccac568bf3fe2e768b11a4058243681704475",
            "filename": "goldens/size-tracking/integration-payloads.json",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/290ea57a9309ed3bd9a5c3635d13f7a45945abbf/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "raw_url": "https://github.com/angular/angular/raw/290ea57a9309ed3bd9a5c3635d13f7a45945abbf/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fsize-tracking%2Fintegration-payloads.json?ref=290ea57a9309ed3bd9a5c3635d13f7a45945abbf",
            "patch": "@@ -12,7 +12,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 1485,\n-        \"main-es2015\": 17210,\n+        \"main-es2015\": 17597,\n         \"polyfills-es2015\": 36709\n       }\n     }\n@@ -21,7 +21,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 1485,\n-        \"main-es2015\": 146698,\n+        \"main-es2015\": 147252,\n         \"polyfills-es2015\": 36964\n       }\n     }\n@@ -30,7 +30,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 1485,\n-        \"main-es2015\": 136062,\n+        \"main-es2015\": 136703,\n         \"polyfills-es2015\": 37641\n       }\n     }\n@@ -66,4 +66,4 @@\n       }\n     }\n   }\n-}\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "5e0fc857df36931e3b616383a40b18fa427db7d4",
            "filename": "packages/core/src/render3/di.ts",
            "status": "modified",
            "additions": 80,
            "deletions": 34,
            "changes": 114,
            "blob_url": "https://github.com/angular/angular/blob/290ea57a9309ed3bd9a5c3635d13f7a45945abbf/packages%2Fcore%2Fsrc%2Frender3%2Fdi.ts",
            "raw_url": "https://github.com/angular/angular/raw/290ea57a9309ed3bd9a5c3635d13f7a45945abbf/packages%2Fcore%2Fsrc%2Frender3%2Fdi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fdi.ts?ref=290ea57a9309ed3bd9a5c3635d13f7a45945abbf",
            "patch": "@@ -27,7 +27,7 @@ import {AttributeMarker, TContainerNode, TDirectiveHostNode, TElementContainerNo\n import {isComponentDef, isComponentHost} from './interfaces/type_checks';\n import {DECLARATION_COMPONENT_VIEW, DECLARATION_VIEW, INJECTOR, LView, T_HOST, TData, TVIEW, TView, TViewType} from './interfaces/view';\n import {assertTNodeType} from './node_assert';\n-import {enterDI, leaveDI} from './state';\n+import {enterDI, getCurrentTNode, getLView, leaveDI} from './state';\n import {isNameOnlyAttributeMarker} from './util/attrs_utils';\n import {getParentInjectorIndex, getParentInjectorView, hasParentInjector} from './util/injector_utils';\n import {stringifyForError} from './util/misc_utils';\n@@ -345,15 +345,59 @@ export function injectAttributeImpl(tNode: TNode, attrNameToInject: string): str\n }\n \n \n+function notFoundValueOrThrow<T>(\n+    notFoundValue: T|null, token: Type<T>|InjectionToken<T>, flags: InjectFlags): T|null {\n+  if (flags & InjectFlags.Optional) {\n+    return notFoundValue;\n+  } else {\n+    throwProviderNotFoundError(token, 'NodeInjector');\n+  }\n+}\n+\n+/**\n+ * Returns the value associated to the given token from the ModuleInjector or throws exception\n+ *\n+ * @param lView The `LView` that contains the `tNode`\n+ * @param token The token to look for\n+ * @param flags Injection flags\n+ * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n+ * @returns the value from the injector or throws an exception\n+ */\n+function lookupTokenUsingModuleInjector<T>(\n+    lView: LView, token: Type<T>|InjectionToken<T>, flags: InjectFlags, notFoundValue?: any): T|\n+    null {\n+  if (flags & InjectFlags.Optional && notFoundValue === undefined) {\n+    // This must be set or the NullInjector will throw for optional deps\n+    notFoundValue = null;\n+  }\n+\n+  if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {\n+    const moduleInjector = lView[INJECTOR];\n+    // switch to `injectInjectorOnly` implementation for module injector, since module injector\n+    // should not have access to Component/Directive DI scope (that may happen through\n+    // `directiveInject` implementation)\n+    const previousInjectImplementation = setInjectImplementation(undefined);\n+    try {\n+      if (moduleInjector) {\n+        return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);\n+      } else {\n+        return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);\n+      }\n+    } finally {\n+      setInjectImplementation(previousInjectImplementation);\n+    }\n+  }\n+  return notFoundValueOrThrow<T>(notFoundValue, token, flags);\n+}\n+\n /**\n  * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.\n  *\n  * Look for the injector providing the token by walking up the node injector tree and then\n  * the module injector tree.\n  *\n  * This function patches `token` with `__NG_ELEMENT_ID__` which contains the id for the bloom\n- * filter. Negative values are reserved for special objects.\n- *   - `-1` is reserved for injecting `Injector` (implemented by `NodeInjector`)\n+ * filter. `-1` is reserved for injecting `Injector` (implemented by `NodeInjector`)\n  *\n  * @param tNode The Node where the search for the injector should start\n  * @param lView The `LView` that contains the `tNode`\n@@ -370,7 +414,10 @@ export function getOrCreateInjectable<T>(\n     // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef\n     // so just call the factory function to create it.\n     if (typeof bloomHash === 'function') {\n-      enterDI(lView, tNode);\n+      if (!enterDI(lView, tNode, flags)) {\n+        // Failed to enter DI use module injector instead.\n+        return lookupTokenUsingModuleInjector<T>(lView, token, flags, notFoundValue);\n+      }\n       try {\n         const value = bloomHash();\n         if (value == null && !(flags & InjectFlags.Optional)) {\n@@ -381,10 +428,30 @@ export function getOrCreateInjectable<T>(\n       } finally {\n         leaveDI();\n       }\n-    } else if (typeof bloomHash == 'number') {\n+    } else if (typeof bloomHash === 'number') {\n+      // This is a value used to identify __NG_ELEMENT_ID__\n+      // `-1` is a special value used to identify `Injector` types in NodeInjector\n+      // This is a workaround for the fact that if the `Injector.__NG_ELEMENT_ID__`\n+      // would have a factory function (such as `ElementRef`) it would cause Ivy\n+      // to be pulled into the ViewEngine, because they both share `Injector` type.\n+      // This should be refactored to follow `ElementRef` pattern once ViewEngine is\n+      // removed\n       if (bloomHash === -1) {\n-        // `-1` is a special value used to identify `Injector` types.\n-        return new NodeInjector(tNode, lView) as any;\n+        if (!enterDI(lView, tNode, flags)) {\n+          // Failed to enter DI, try module injector instead. If a token is injected with the @Host\n+          // flag, the module injector is not searched for that token in Ivy.\n+          return (flags & InjectFlags.Host) ?\n+              notFoundValueOrThrow<T>(notFoundValue, token, flags) :\n+              lookupTokenUsingModuleInjector<T>(lView, token, flags, notFoundValue);\n+        }\n+        try {\n+          // Retrieving current `TNode` and `LView` from the state (rather than using `tNode` and\n+          // `lView`), because entering DI (by calling `enterDI`) may cause these values to change\n+          // (in case `@SkipSelf` flag is present).\n+          return new NodeInjector(getCurrentTNode()! as TDirectiveHostNode, getLView()) as any;\n+        } finally {\n+          leaveDI();\n+        }\n       }\n       // If the token has a bloom hash, then it is a token which could be in NodeInjector.\n \n@@ -453,32 +520,7 @@ export function getOrCreateInjectable<T>(\n     }\n   }\n \n-  if (flags & InjectFlags.Optional && notFoundValue === undefined) {\n-    // This must be set or the NullInjector will throw for optional deps\n-    notFoundValue = null;\n-  }\n-\n-  if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {\n-    const moduleInjector = lView[INJECTOR];\n-    // switch to `injectInjectorOnly` implementation for module injector, since module injector\n-    // should not have access to Component/Directive DI scope (that may happen through\n-    // `directiveInject` implementation)\n-    const previousInjectImplementation = setInjectImplementation(undefined);\n-    try {\n-      if (moduleInjector) {\n-        return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);\n-      } else {\n-        return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);\n-      }\n-    } finally {\n-      setInjectImplementation(previousInjectImplementation);\n-    }\n-  }\n-  if (flags & InjectFlags.Optional) {\n-    return notFoundValue;\n-  } else {\n-    throwProviderNotFoundError(token, 'NodeInjector');\n-  }\n+  return lookupTokenUsingModuleInjector<T>(lView, token, flags, notFoundValue);\n }\n \n const NOT_FOUND = {};\n@@ -582,7 +624,11 @@ export function getNodeInjectable(\n     factory.resolving = true;\n     const previousInjectImplementation =\n         factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;\n-    enterDI(lView, tNode);\n+    const success = enterDI(lView, tNode, InjectFlags.Default);\n+    ngDevMode &&\n+        assertEqual(\n+            success, true,\n+            'Because flags do not contain \\`SkipSelf\\' we expect this to always succeed.');\n     try {\n       value = lView[index] = factory.factory(undefined, tData, lView, tNode);\n       // This code path is hit for both directives and providers."
        },
        {
            "sha": "0217e2f60d35eff8bae854cd7b0db47d96c813e7",
            "filename": "packages/core/src/render3/state.ts",
            "status": "modified",
            "additions": 84,
            "deletions": 11,
            "changes": 95,
            "blob_url": "https://github.com/angular/angular/blob/290ea57a9309ed3bd9a5c3635d13f7a45945abbf/packages%2Fcore%2Fsrc%2Frender3%2Fstate.ts",
            "raw_url": "https://github.com/angular/angular/raw/290ea57a9309ed3bd9a5c3635d13f7a45945abbf/packages%2Fcore%2Fsrc%2Frender3%2Fstate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fstate.ts?ref=290ea57a9309ed3bd9a5c3635d13f7a45945abbf",
            "patch": "@@ -6,13 +6,13 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n+import {InjectFlags} from '../di/interface/injector';\n import {assertDefined, assertEqual, assertGreaterThanOrEqual, assertLessThan, assertNotEqual} from '../util/assert';\n-import {assertLViewOrUndefined, assertTNodeForTView} from './assert';\n+import {assertLViewOrUndefined, assertTNodeForLView, assertTNodeForTView} from './assert';\n import {DirectiveDef} from './interfaces/definition';\n import {TNode, TNodeType} from './interfaces/node';\n-import {CONTEXT, DECLARATION_VIEW, HEADER_OFFSET, LView, OpaqueViewState, TData, TVIEW, TView} from './interfaces/view';\n+import {CONTEXT, DECLARATION_VIEW, HEADER_OFFSET, LView, OpaqueViewState, T_HOST, TData, TVIEW, TView, TViewType} from './interfaces/view';\n import {MATH_ML_NAMESPACE, SVG_NAMESPACE} from './namespaces';\n-import {assertTNodeType} from './node_assert';\n import {getTNode} from './util/view_utils';\n \n \n@@ -433,17 +433,90 @@ export function setCurrentQueryIndex(value: number): void {\n   instructionState.lFrame.currentQueryIndex = value;\n }\n \n+/**\n+ * Returns a `TNode` of the location where the current `LView` is declared at.\n+ *\n+ * @param lView an `LView` that we want to find parent `TNode` for.\n+ */\n+function getDeclarationTNode(lView: LView): TNode|null {\n+  const tView = lView[TVIEW];\n+\n+  // Return the declaration parent for embedded views\n+  if (tView.type === TViewType.Embedded) {\n+    ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n+    return tView.declTNode;\n+  }\n+\n+  // Components don't have `TView.declTNode` because each instance of component could be\n+  // inserted in different location, hence `TView.declTNode` is meaningless.\n+  // Falling back to `T_HOST` in case we cross component boundary.\n+  if (tView.type === TViewType.Component) {\n+    return lView[T_HOST];\n+  }\n+\n+  // Remaining TNode type is `TViewType.Root` which doesn't have a parent TNode.\n+  return null;\n+}\n+\n /**\n  * This is a light weight version of the `enterView` which is needed by the DI system.\n- * @param newView\n- * @param tNode\n+ *\n+ * @param lView `LView` location of the DI context.\n+ * @param tNode `TNode` for DI context\n+ * @param flags DI context flags. if `SkipSelf` flag is set than we walk up the declaration\n+ *     tree from `tNode`  until we find parent declared `TElementNode`.\n+ * @returns `true` if we have successfully entered DI associated with `tNode` (or with declared\n+ *     `TNode` if `flags` has  `SkipSelf`). Failing to enter DI implies that no associated\n+ *     `NodeInjector` can be found and we should instead use `ModuleInjector`.\n+ *     - If `true` than this call must be fallowed by `leaveDI`\n+ *     - If `false` than this call failed and we should NOT call `leaveDI`\n  */\n-export function enterDI(newView: LView, tNode: TNode) {\n-  ngDevMode && assertLViewOrUndefined(newView);\n-  const newLFrame = allocLFrame();\n-  instructionState.lFrame = newLFrame;\n-  newLFrame.currentTNode = tNode!;\n-  newLFrame.lView = newView;\n+export function enterDI(lView: LView, tNode: TNode, flags: InjectFlags) {\n+  ngDevMode && assertLViewOrUndefined(lView);\n+\n+  if (flags & InjectFlags.SkipSelf) {\n+    ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);\n+\n+    let parentTNode = tNode as TNode | null;\n+    let parentLView = lView;\n+\n+    while (true) {\n+      ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');\n+      parentTNode = parentTNode!.parent as TNode | null;\n+      if (parentTNode === null && !(flags & InjectFlags.Host)) {\n+        parentTNode = getDeclarationTNode(parentLView);\n+        if (parentTNode === null) break;\n+\n+        // In this case, a parent exists and is definitely an element. So it will definitely\n+        // have an existing lView as the declaration view, which is why we can assume it's defined.\n+        ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');\n+        parentLView = parentLView[DECLARATION_VIEW]!;\n+\n+        // In Ivy there are Comment nodes that correspond to ngIf and NgFor embedded directives\n+        // We want to skip those and look only at Elements and ElementContainers to ensure\n+        // we're looking at true parent nodes, and not content or other types.\n+        if (parentTNode.type & (TNodeType.Element | TNodeType.ElementContainer)) {\n+          break;\n+        }\n+      } else {\n+        break;\n+      }\n+    }\n+    if (parentTNode === null) {\n+      // If we failed to find a parent TNode this means that we should use module injector.\n+      return false;\n+    } else {\n+      tNode = parentTNode;\n+      lView = parentLView;\n+    }\n+  }\n+\n+  ngDevMode && assertTNodeForLView(tNode, lView);\n+  const lFrame = instructionState.lFrame = allocLFrame();\n+  lFrame.currentTNode = tNode;\n+  lFrame.lView = lView;\n+\n+  return true;\n }\n \n /**"
        },
        {
            "sha": "820416d60e69d41173f16a2f23d0a1ff27882074",
            "filename": "packages/core/test/acceptance/di_spec.ts",
            "status": "modified",
            "additions": 997,
            "deletions": 29,
            "changes": 1026,
            "blob_url": "https://github.com/angular/angular/blob/290ea57a9309ed3bd9a5c3635d13f7a45945abbf/packages%2Fcore%2Ftest%2Facceptance%2Fdi_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/290ea57a9309ed3bd9a5c3635d13f7a45945abbf/packages%2Fcore%2Ftest%2Facceptance%2Fdi_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fdi_spec.ts?ref=290ea57a9309ed3bd9a5c3635d13f7a45945abbf",
            "patch": "@@ -7,10 +7,11 @@\n  */\n \n import {CommonModule} from '@angular/common';\n-import {Attribute, ChangeDetectorRef, Component, ComponentFactoryResolver, ComponentRef, Directive, ElementRef, EventEmitter, forwardRef, Host, HostBinding, Inject, Injectable, InjectionToken, INJECTOR, Injector, Input, LOCALE_ID, NgModule, NgZone, Optional, Output, Pipe, PipeTransform, Self, SkipSelf, TemplateRef, ViewChild, ViewContainerRef, ViewRef, ɵDEFAULT_LOCALE_ID as DEFAULT_LOCALE_ID} from '@angular/core';\n+import {Attribute, ChangeDetectorRef, Component, ComponentFactoryResolver, ComponentRef, ContentChild, Directive, ElementRef, EventEmitter, forwardRef, Host, HostBinding, Inject, Injectable, InjectionToken, INJECTOR, Injector, Input, LOCALE_ID, NgModule, NgZone, Optional, Output, Pipe, PipeTransform, Self, SkipSelf, TemplateRef, ViewChild, ViewContainerRef, ViewRef, ɵDEFAULT_LOCALE_ID as DEFAULT_LOCALE_ID} from '@angular/core';\n import {ɵINJECTOR_SCOPE} from '@angular/core/src/core';\n import {ViewRef as ViewRefInternal} from '@angular/core/src/render3/view_ref';\n import {TestBed} from '@angular/core/testing';\n+import {By} from '@angular/platform-browser';\n import {ivyEnabled, onlyInIvy} from '@angular/private/testing';\n import {BehaviorSubject} from 'rxjs';\n \n@@ -700,30 +701,6 @@ describe('di', () => {\n         });\n       });\n \n-      it('should skip the current node with @SkipSelf', () => {\n-        @Directive({selector: '[dirA]'})\n-        class DirectiveA {\n-          constructor(@SkipSelf() public dirB: DirectiveB) {}\n-        }\n-\n-        @Component({selector: 'my-comp', template: '<div dirA dirB=\"self\"></div>'})\n-        class MyComp {\n-          @ViewChild(DirectiveA) dirA!: DirectiveA;\n-        }\n-\n-        @Component({template: '<my-comp dirB=\"parent\"></my-comp>'})\n-        class MyApp {\n-          @ViewChild(MyComp) myComp!: MyComp;\n-        }\n-\n-        TestBed.configureTestingModule({declarations: [DirectiveA, DirectiveB, MyComp, MyApp]});\n-        const fixture = TestBed.createComponent(MyApp);\n-        fixture.detectChanges();\n-\n-        const dirA = fixture.componentInstance.myComp.dirA;\n-        expect(dirA.dirB.value).toEqual('parent');\n-      });\n-\n       onlyInIvy('Ivy has different error message when dependency is not found')\n           .it('should check only the current node with @Self', () => {\n             @Directive({selector: '[dirA]'})\n@@ -739,6 +716,994 @@ describe('di', () => {\n                 .toThrowError(/NG0201: No provider for DirectiveB found in NodeInjector/);\n           });\n \n+      describe('SkipSelf', () => {\n+        describe('Injectors', () => {\n+          it('should support @SkipSelf when injecting Injectors', () => {\n+            @Component({\n+              selector: 'parent',\n+              template: '<child></child>',\n+              providers: [{\n+                provide: 'token',\n+                useValue: 'PARENT',\n+              }]\n+            })\n+            class ParentComponent {\n+            }\n+\n+            @Component({\n+              selector: 'child',\n+              template: '...',\n+              providers: [{\n+                provide: 'token',\n+                useValue: 'CHILD',\n+              }]\n+            })\n+            class ChildComponent {\n+              constructor(public injector: Injector, @SkipSelf() public parentInjector: Injector) {}\n+            }\n+\n+            TestBed.configureTestingModule({\n+              declarations: [ParentComponent, ChildComponent],\n+            });\n+            const fixture = TestBed.createComponent(ParentComponent);\n+            fixture.detectChanges();\n+\n+            const childComponent =\n+                fixture.debugElement.query(By.directive(ChildComponent)).componentInstance;\n+            expect(childComponent.injector.get('token')).toBe('CHILD');\n+            expect(childComponent.parentInjector.get('token')).toBe('PARENT');\n+          });\n+\n+          it('should lookup module injector in case @SkipSelf is used and no suitable Injector found in element injector tree',\n+             () => {\n+               let componentInjector: Injector;\n+               let moduleInjector: Injector;\n+               @Component({\n+                 selector: 'child',\n+                 template: '...',\n+                 providers: [{\n+                   provide: 'token',\n+                   useValue: 'CHILD',\n+                 }]\n+               })\n+               class MyComponent {\n+                 constructor(@SkipSelf() public injector: Injector) {\n+                   componentInjector = injector;\n+                 }\n+               }\n+\n+               @NgModule({\n+                 declarations: [MyComponent],\n+                 providers: [{\n+                   provide: 'token',\n+                   useValue: 'NG_MODULE',\n+                 }]\n+               })\n+               class MyModule {\n+                 constructor(public injector: Injector) {\n+                   moduleInjector = injector;\n+                 }\n+               }\n+\n+               TestBed.configureTestingModule({\n+                 imports: [MyModule],\n+               });\n+               const fixture = TestBed.createComponent(MyComponent);\n+               fixture.detectChanges();\n+\n+               expect(componentInjector!.get('token')).toBe('NG_MODULE');\n+               expect(moduleInjector!.get('token')).toBe('NG_MODULE');\n+             });\n+\n+          it('should respect @Host in case @SkipSelf is used and no suitable Injector found in element injector tree',\n+             () => {\n+               let componentInjector: Injector;\n+               let moduleInjector: Injector;\n+               @Component({\n+                 selector: 'child',\n+                 template: '...',\n+                 providers: [{\n+                   provide: 'token',\n+                   useValue: 'CHILD',\n+                 }]\n+               })\n+               class MyComponent {\n+                 constructor(@Host() @SkipSelf() public injector: Injector) {\n+                   componentInjector = injector;\n+                 }\n+               }\n+\n+               @NgModule({\n+                 declarations: [MyComponent],\n+                 providers: [{\n+                   provide: 'token',\n+                   useValue: 'NG_MODULE',\n+                 }]\n+               })\n+               class MyModule {\n+                 constructor(public injector: Injector) {\n+                   moduleInjector = injector;\n+                 }\n+               }\n+\n+               TestBed.configureTestingModule({\n+                 imports: [MyModule],\n+               });\n+\n+               // If a token is injected with the @Host flag, the module injector is not searched\n+               // for that token in Ivy.\n+               if (ivyEnabled) {\n+                 expect(() => TestBed.createComponent(MyComponent))\n+                     .toThrowError(/NG0201: No provider for Injector found in NodeInjector/);\n+               } else {\n+                 const fixture = TestBed.createComponent(MyComponent);\n+                 fixture.detectChanges();\n+\n+                 expect(componentInjector!.get('token')).toBe('NG_MODULE');\n+                 expect(moduleInjector!.get('token')).toBe('NG_MODULE');\n+               }\n+             });\n+\n+          it('should throw when injecting Injectors using @SkipSelf and @Host and no Injectors are available in a current view',\n+             () => {\n+               @Component({\n+                 selector: 'parent',\n+                 template: '<child></child>',\n+                 providers: [{\n+                   provide: 'token',\n+                   useValue: 'PARENT',\n+                 }]\n+               })\n+               class ParentComponent {\n+               }\n+\n+               @Component({\n+                 selector: 'child',\n+                 template: '...',\n+                 providers: [{\n+                   provide: 'token',\n+                   useValue: 'CHILD',\n+                 }]\n+               })\n+               class ChildComponent {\n+                 constructor(@Host() @SkipSelf() public injector: Injector) {}\n+               }\n+\n+               TestBed.configureTestingModule({\n+                 declarations: [ParentComponent, ChildComponent],\n+               });\n+\n+               // Ivy has different error message when dependency is not found\n+               const expectedErrorMessage = ivyEnabled ?\n+                   /NG0201: No provider for Injector found in NodeInjector/ :\n+                   /No provider for Injector/;\n+               expect(() => TestBed.createComponent(ParentComponent))\n+                   .toThrowError(expectedErrorMessage);\n+             });\n+\n+          it('should not throw when injecting Injectors using @SkipSelf, @Host, and @Optional and no Injectors are available in a current view',\n+             () => {\n+               @Component({\n+                 selector: 'parent',\n+                 template: '<child></child>',\n+                 providers: [{\n+                   provide: 'token',\n+                   useValue: 'PARENT',\n+                 }]\n+               })\n+               class ParentComponent {\n+               }\n+\n+               @Component({\n+                 selector: 'child',\n+                 template: '...',\n+                 providers: [{\n+                   provide: 'token',\n+                   useValue: 'CHILD',\n+                 }]\n+               })\n+               class ChildComponent {\n+                 constructor(@Host() @SkipSelf() @Optional() public injector: Injector) {}\n+               }\n+\n+               TestBed.configureTestingModule({\n+                 declarations: [ParentComponent, ChildComponent],\n+               });\n+\n+               // Ivy has different error message when dependency is not found\n+               const expectedErrorMessage = ivyEnabled ?\n+                   /NG0201: No provider for Injector found in NodeInjector/ :\n+                   /No provider for Injector/;\n+               expect(() => TestBed.createComponent(ParentComponent))\n+                   .not.toThrowError(expectedErrorMessage);\n+             });\n+        });\n+\n+        describe('ElementRef', () => {\n+          // While tokens like `ElementRef` make sense only in a context of a NodeInjector,\n+          // ViewEngine also used `ModuleInjector` tree to lookup such tokens. In Ivy we replicate\n+          // this behavior for now to avoid breaking changes.\n+          it('should lookup module injector in case @SkipSelf is used for `ElementRef` token and Component has no parent',\n+             () => {\n+               let componentElement: ElementRef;\n+               let moduleElement: ElementRef;\n+               @Component({template: '<div>component</div>'})\n+               class MyComponent {\n+                 constructor(@SkipSelf() public el: ElementRef) {\n+                   componentElement = el;\n+                 }\n+               }\n+\n+               @NgModule({\n+                 declarations: [MyComponent],\n+                 providers: [{\n+                   provide: ElementRef,\n+                   useValue: {from: 'NG_MODULE'},\n+                 }]\n+               })\n+               class MyModule {\n+                 constructor(public el: ElementRef) {\n+                   moduleElement = el;\n+                 }\n+               }\n+\n+               TestBed.configureTestingModule({\n+                 imports: [MyModule],\n+               });\n+               const fixture = TestBed.createComponent(MyComponent);\n+               fixture.detectChanges();\n+\n+               expect((moduleElement! as any).from).toBe('NG_MODULE');\n+               expect((componentElement! as any).from).toBe('NG_MODULE');\n+             });\n+\n+          it('should return host node when @SkipSelf is used for `ElementRef` token and Component has no parent node',\n+             () => {\n+               let parentElement: ElementRef;\n+               let componentElement: ElementRef;\n+               @Component({selector: 'child', template: '...'})\n+               class MyComponent {\n+                 constructor(@SkipSelf() public el: ElementRef) {\n+                   componentElement = el;\n+                 }\n+               }\n+\n+               @Component({\n+                 template: '<child></child>',\n+               })\n+               class ParentComponent {\n+                 constructor(public el: ElementRef) {\n+                   parentElement = el;\n+                 }\n+               }\n+\n+               TestBed.configureTestingModule({\n+                 imports: [CommonModule],\n+                 declarations: [ParentComponent, MyComponent],\n+               });\n+               const fixture = TestBed.createComponent(ParentComponent);\n+               fixture.detectChanges();\n+\n+               expect(componentElement!).toEqual(parentElement!);\n+             });\n+\n+          it('should @SkipSelf on child directive node when injecting ElementRef on nested parent directive',\n+             () => {\n+               let parentRef: ElementRef;\n+               let childRef: ElementRef;\n+\n+               @Directive({selector: '[parent]'})\n+               class ParentDirective {\n+                 constructor(elementRef: ElementRef) {\n+                   parentRef = elementRef;\n+                 }\n+               }\n+\n+               @Directive({selector: '[child]'})\n+               class ChildDirective {\n+                 constructor(@SkipSelf() elementRef: ElementRef) {\n+                   childRef = elementRef;\n+                 }\n+               }\n+\n+               @Component({template: '<div parent>parent <span child>child</span></div>'})\n+               class MyComp {\n+               }\n+\n+               TestBed.configureTestingModule(\n+                   {declarations: [ParentDirective, ChildDirective, MyComp]});\n+               const fixture = TestBed.createComponent(MyComp);\n+               fixture.detectChanges();\n+\n+               // Assert against the `nativeElement` since Ivy always returns a new ElementRef.\n+               expect(childRef!.nativeElement).toBe(parentRef!.nativeElement);\n+               expect(childRef!.nativeElement.tagName).toBe('DIV');\n+             });\n+        });\n+\n+        describe('@SkipSelf when parent contains embedded views', () => {\n+          it('should work for `ElementRef` token', () => {\n+            let requestedElementRef: ElementRef;\n+            @Component({\n+              selector: 'child',\n+              template: '...',\n+            })\n+            class ChildComponent {\n+              constructor(@SkipSelf() public elementRef: ElementRef) {\n+                requestedElementRef = elementRef;\n+              }\n+            }\n+            @Component({\n+              selector: 'root',\n+              template: '<div><child *ngIf=\"true\"></child></div>',\n+            })\n+            class ParentComponent {\n+            }\n+\n+            TestBed.configureTestingModule({\n+              imports: [CommonModule],\n+              declarations: [ParentComponent, ChildComponent],\n+            });\n+            const fixture = TestBed.createComponent(ParentComponent);\n+            fixture.detectChanges();\n+\n+            expect(requestedElementRef!.nativeElement).toEqual(fixture.nativeElement.firstChild);\n+            expect(requestedElementRef!.nativeElement.tagName).toEqual('DIV');\n+          });\n+\n+          it('should work for `ElementRef` token with expanded *ngIf', () => {\n+            let requestedElementRef: ElementRef;\n+            @Component({\n+              selector: 'child',\n+              template: '...',\n+            })\n+            class ChildComponent {\n+              constructor(@SkipSelf() public elementRef: ElementRef) {\n+                requestedElementRef = elementRef;\n+              }\n+            }\n+            @Component({\n+              selector: 'root',\n+              template: '<div><ng-template [ngIf]=\"true\"><child></child></ng-template></div>',\n+            })\n+            class ParentComponent {\n+            }\n+\n+            TestBed.configureTestingModule({\n+              imports: [CommonModule],\n+              declarations: [ParentComponent, ChildComponent],\n+            });\n+            const fixture = TestBed.createComponent(ParentComponent);\n+            fixture.detectChanges();\n+\n+            expect(requestedElementRef!.nativeElement).toEqual(fixture.nativeElement.firstChild);\n+            expect(requestedElementRef!.nativeElement.tagName).toEqual('DIV');\n+          });\n+\n+          it('should work for `ViewContainerRef` token', () => {\n+            let requestedRef: ViewContainerRef;\n+            @Component({\n+              selector: 'child',\n+              template: '...',\n+            })\n+            class ChildComponent {\n+              constructor(@SkipSelf() public ref: ViewContainerRef) {\n+                requestedRef = ref;\n+              }\n+            }\n+\n+            @Component({\n+              selector: 'root',\n+              template: '<div><child *ngIf=\"true\"></child></div>',\n+            })\n+            class ParentComponent {\n+            }\n+\n+            TestBed.configureTestingModule({\n+              imports: [CommonModule],\n+              declarations: [ParentComponent, ChildComponent],\n+            });\n+            const fixture = TestBed.createComponent(ParentComponent);\n+            fixture.detectChanges();\n+\n+            if (ivyEnabled) {\n+              expect(requestedRef!.element.nativeElement).toBe(fixture.nativeElement.firstChild);\n+              expect(requestedRef!.element.nativeElement.tagName).toBe('DIV');\n+            } else {\n+              expect(requestedRef!).toBeNull();\n+            }\n+          });\n+\n+          it('should work for `ChangeDetectorRef` token', () => {\n+            let requestedChangeDetectorRef: ChangeDetectorRef;\n+            @Component({\n+              selector: 'child',\n+              template: '...',\n+            })\n+            class ChildComponent {\n+              constructor(@SkipSelf() public changeDetectorRef: ChangeDetectorRef) {\n+                requestedChangeDetectorRef = changeDetectorRef;\n+              }\n+            }\n+\n+            @Component({\n+              selector: 'root',\n+              template: '<child *ngIf=\"true\"></child>',\n+            })\n+            class ParentComponent {\n+            }\n+\n+            TestBed.configureTestingModule({\n+              imports: [CommonModule],\n+              declarations: [ParentComponent, ChildComponent],\n+            });\n+            const fixture = TestBed.createComponent(ParentComponent);\n+            fixture.detectChanges();\n+\n+            const {context} = requestedChangeDetectorRef! as ViewRefInternal<ParentComponent>;\n+            expect(context).toBe(fixture.componentInstance);\n+          });\n+\n+          // this works consistently between VE and Ivy\n+          it('should work for Injectors', () => {\n+            let childComponentInjector: Injector;\n+            let parentComponentInjector: Injector;\n+            @Component({\n+              selector: 'parent',\n+              template: '<child *ngIf=\"true\"></child>',\n+              providers: [{\n+                provide: 'token',\n+                useValue: 'PARENT',\n+              }]\n+            })\n+            class ParentComponent {\n+              constructor(public injector: Injector) {\n+                parentComponentInjector = injector;\n+              }\n+            }\n+\n+            @Component({\n+              selector: 'child',\n+              template: '...',\n+              providers: [{\n+                provide: 'token',\n+                useValue: 'CHILD',\n+              }]\n+            })\n+            class ChildComponent {\n+              constructor(@SkipSelf() public injector: Injector) {\n+                childComponentInjector = injector;\n+              }\n+            }\n+\n+            TestBed.configureTestingModule({\n+              declarations: [ParentComponent, ChildComponent],\n+            });\n+            const fixture = TestBed.createComponent(ParentComponent);\n+            fixture.detectChanges();\n+\n+            expect(childComponentInjector!.get('token'))\n+                .toBe(parentComponentInjector!.get('token'));\n+          });\n+\n+          it('should work for Injectors with expanded *ngIf', () => {\n+            let childComponentInjector: Injector;\n+            let parentComponentInjector: Injector;\n+            @Component({\n+              selector: 'parent',\n+              template: '<ng-template [ngIf]=\"true\"><child></child></ng-template>',\n+              providers: [{\n+                provide: 'token',\n+                useValue: 'PARENT',\n+              }]\n+            })\n+            class ParentComponent {\n+              constructor(public injector: Injector) {\n+                parentComponentInjector = injector;\n+              }\n+            }\n+\n+            @Component({\n+              selector: 'child',\n+              template: '...',\n+              providers: [{\n+                provide: 'token',\n+                useValue: 'CHILD',\n+              }]\n+            })\n+            class ChildComponent {\n+              constructor(@SkipSelf() public injector: Injector) {\n+                childComponentInjector = injector;\n+              }\n+            }\n+\n+            TestBed.configureTestingModule({\n+              declarations: [ParentComponent, ChildComponent],\n+            });\n+            const fixture = TestBed.createComponent(ParentComponent);\n+            fixture.detectChanges();\n+\n+            expect(childComponentInjector!.get('token'))\n+                .toBe(parentComponentInjector!.get('token'));\n+          });\n+        });\n+\n+        describe('TemplateRef', () => {\n+          // SkipSelf doesn't make sense to use with TemplateRef since you\n+          // can't inject TemplateRef on a regular element and you can initialize\n+          // a child component on a nested `<ng-template>` only when a component/directive\n+          // on a parent `<ng-template>` is initialized.\n+          it('should throw when using @SkipSelf for TemplateRef', () => {\n+            @Directive({selector: '[dir]', exportAs: 'dir'})\n+            class MyDir {\n+              constructor(@SkipSelf() public templateRef: TemplateRef<any>) {}\n+            }\n+\n+            @Component({selector: '[child]', template: '<ng-template dir></ng-template>'})\n+            class ChildComp {\n+              constructor(public templateRef: TemplateRef<any>) {}\n+              @ViewChild(MyDir) directive!: MyDir;\n+            }\n+\n+            @Component({\n+              selector: 'root',\n+              template: '<div child></div>',\n+            })\n+            class MyComp {\n+              @ViewChild(ChildComp) child!: ChildComp;\n+            }\n+\n+            TestBed.configureTestingModule({\n+              imports: [CommonModule],\n+              declarations: [MyDir, ChildComp, MyComp],\n+            });\n+            // Ivy has different error message when dependency is not found\n+            const expectedErrorMessage = ivyEnabled ? /NG0201: No provider for TemplateRef found/ :\n+                                                      /No provider for TemplateRef/;\n+            expect(() => {\n+              const fixture = TestBed.createComponent(MyComp);\n+              fixture.detectChanges();\n+            }).toThrowError(expectedErrorMessage);\n+          });\n+\n+          it('should throw when SkipSelf and no parent TemplateRef', () => {\n+            @Directive({selector: '[dirA]', exportAs: 'dirA'})\n+            class DirA {\n+              constructor(@SkipSelf() public templateRef: TemplateRef<any>) {}\n+            }\n+\n+            @Component({\n+              selector: 'root',\n+              template: '<ng-template dirA></ng-template>',\n+            })\n+            class MyComp {\n+            }\n+\n+            TestBed.configureTestingModule({\n+              imports: [CommonModule],\n+              declarations: [DirA, MyComp],\n+            });\n+            // Ivy has different error message when dependency is not found\n+            const expectedErrorMessage = ivyEnabled ? /NG0201: No provider for TemplateRef found/ :\n+                                                      /No provider for TemplateRef/;\n+            expect(() => {\n+              const fixture = TestBed.createComponent(MyComp);\n+              fixture.detectChanges();\n+            }).toThrowError(expectedErrorMessage);\n+          });\n+\n+          it('should not throw when SkipSelf and Optional', () => {\n+            let directiveTemplateRef;\n+            @Directive({selector: '[dirA]', exportAs: 'dirA'})\n+            class DirA {\n+              constructor(@SkipSelf() @Optional() templateRef: TemplateRef<any>) {\n+                directiveTemplateRef = templateRef;\n+              }\n+            }\n+\n+            @Component({\n+              selector: 'root',\n+              template: '<ng-template dirA></ng-template>',\n+            })\n+            class MyComp {\n+            }\n+\n+            TestBed.configureTestingModule({\n+              imports: [CommonModule],\n+              declarations: [DirA, MyComp],\n+            });\n+\n+            const fixture = TestBed.createComponent(MyComp);\n+            fixture.detectChanges();\n+\n+            expect(directiveTemplateRef).toBeNull();\n+          });\n+\n+          it('should not throw when SkipSelf, Optional, and Host', () => {\n+            @Directive({selector: '[dirA]', exportAs: 'dirA'})\n+            class DirA {\n+              constructor(@SkipSelf() @Optional() @Host() public templateRef: TemplateRef<any>) {}\n+            }\n+\n+            @Component({\n+              selector: 'root',\n+              template: '<ng-template dirA></ng-template>',\n+            })\n+            class MyComp {\n+            }\n+\n+            TestBed.configureTestingModule({\n+              imports: [CommonModule],\n+              declarations: [DirA, MyComp],\n+            });\n+\n+            expect(() => TestBed.createComponent(MyComp)).not.toThrowError();\n+          });\n+        });\n+\n+        describe('ViewContainerRef', () => {\n+          it('should support @SkipSelf when injecting ViewContainerRef', () => {\n+            let parentViewContainer: ViewContainerRef;\n+            let childViewContainer: ViewContainerRef;\n+\n+            @Directive({selector: '[parent]'})\n+            class ParentDirective {\n+              constructor(vc: ViewContainerRef) {\n+                parentViewContainer = vc;\n+              }\n+            }\n+\n+            @Directive({selector: '[child]'})\n+            class ChildDirective {\n+              constructor(@SkipSelf() vc: ViewContainerRef) {\n+                childViewContainer = vc;\n+              }\n+            }\n+\n+            @Component({template: '<div parent>parent <span child>child</span></div>'})\n+            class MyComp {\n+            }\n+\n+            TestBed.configureTestingModule(\n+                {declarations: [ParentDirective, ChildDirective, MyComp]});\n+            const fixture = TestBed.createComponent(MyComp);\n+            fixture.detectChanges();\n+\n+            // Assert against the `element` since Ivy always returns a new ViewContainerRef.\n+            expect(childViewContainer!.element.nativeElement)\n+                .toBe(parentViewContainer!.element.nativeElement);\n+            expect(parentViewContainer!.element.nativeElement.tagName).toBe('DIV');\n+          });\n+\n+          it('should get ViewContainerRef using @SkipSelf and @Host', () => {\n+            let parentViewContainer: ViewContainerRef;\n+            let childViewContainer: ViewContainerRef;\n+\n+            @Directive({selector: '[parent]'})\n+            class ParentDirective {\n+              constructor(vc: ViewContainerRef) {\n+                parentViewContainer = vc;\n+              }\n+            }\n+\n+            @Directive({selector: '[child]'})\n+            class ChildDirective {\n+              constructor(@SkipSelf() @Host() vc: ViewContainerRef) {\n+                childViewContainer = vc;\n+              }\n+            }\n+\n+            @Component({template: '<div parent>parent <span child>child</span></div>'})\n+            class MyComp {\n+            }\n+\n+            TestBed.configureTestingModule(\n+                {declarations: [ParentDirective, ChildDirective, MyComp]});\n+\n+            if (ivyEnabled) {\n+              const fixture = TestBed.createComponent(MyComp);\n+              fixture.detectChanges();\n+\n+              // Assert against the `element` since Ivy always returns a new ViewContainerRef.\n+              expect(childViewContainer!.element.nativeElement)\n+                  .toBe(parentViewContainer!.element.nativeElement);\n+              expect(parentViewContainer!.element.nativeElement.tagName).toBe('DIV');\n+            } else {\n+              // Template parse errors happen in VE\n+              // \"<div parent>parent [ERROR ->]<span child>child</span></div>\"\n+              expect(() => TestBed.createComponent(MyComp))\n+                  .toThrowError(/No provider for ViewContainerRef/);\n+            }\n+          });\n+\n+          it('should get ViewContainerRef using @SkipSelf and @Host on parent', () => {\n+            let parentViewContainer: ViewContainerRef;\n+\n+            @Directive({selector: '[parent]'})\n+            class ParentDirective {\n+              constructor(@SkipSelf() vc: ViewContainerRef) {\n+                parentViewContainer = vc;\n+              }\n+            }\n+\n+            @Component({template: '<div parent>parent</div>'})\n+            class MyComp {\n+            }\n+\n+            TestBed.configureTestingModule({declarations: [ParentDirective, MyComp]});\n+\n+            const fixture = TestBed.createComponent(MyComp);\n+            fixture.detectChanges();\n+\n+            if (ivyEnabled) {\n+              // Assert against the `element` since Ivy always returns a new ViewContainerRef.\n+              expect(parentViewContainer!.element.nativeElement.tagName).toBe('DIV');\n+            } else {\n+              // VE Doesn't throw, but the ref is null\n+              expect(parentViewContainer!).toBeNull();\n+            }\n+          });\n+\n+          it('should throw when injecting ViewContainerRef using @SkipSelf and no ViewContainerRef are available in a current view',\n+             () => {\n+               @Component({template: '<span>component</span>'})\n+               class MyComp {\n+                 constructor(@SkipSelf() vc: ViewContainerRef) {}\n+               }\n+\n+               TestBed.configureTestingModule({declarations: [MyComp]});\n+\n+               expect(() => TestBed.createComponent(MyComp))\n+                   .toThrowError(/No provider for ViewContainerRef/);\n+             });\n+        });\n+\n+        describe('ChangeDetectorRef', () => {\n+          it('should support @SkipSelf when injecting ChangeDetectorRef', () => {\n+            let parentRef: ChangeDetectorRef|undefined;\n+            let childRef: ChangeDetectorRef|undefined;\n+\n+            @Directive({selector: '[parent]'})\n+            class ParentDirective {\n+              constructor(cdr: ChangeDetectorRef) {\n+                parentRef = cdr;\n+              }\n+            }\n+\n+            @Directive({selector: '[child]'})\n+            class ChildDirective {\n+              constructor(@SkipSelf() cdr: ChangeDetectorRef) {\n+                childRef = cdr;\n+              }\n+            }\n+\n+            @Component({template: '<div parent>parent <span child>child</span></div>'})\n+            class MyComp {\n+            }\n+\n+            TestBed.configureTestingModule(\n+                {declarations: [ParentDirective, ChildDirective, MyComp]});\n+            const fixture = TestBed.createComponent(MyComp);\n+            fixture.detectChanges();\n+\n+            // Assert against the `rootNodes` since Ivy always returns a new ChangeDetectorRef.\n+            expect((parentRef as ViewRefInternal<any>).rootNodes)\n+                .toEqual((childRef as ViewRefInternal<any>).rootNodes);\n+          });\n+\n+          it('should inject host component ChangeDetectorRef when @SkipSelf', () => {\n+            let childRef: ChangeDetectorRef|undefined;\n+\n+            @Component({selector: 'child', template: '...'})\n+            class ChildComp {\n+              constructor(@SkipSelf() cdr: ChangeDetectorRef) {\n+                childRef = cdr;\n+              }\n+            }\n+\n+            @Component({template: '<div><child></child></div>'})\n+            class MyComp {\n+              constructor(public cdr: ChangeDetectorRef) {}\n+            }\n+\n+            TestBed.configureTestingModule({declarations: [ChildComp, MyComp]});\n+            const fixture = TestBed.createComponent(MyComp);\n+            fixture.detectChanges();\n+\n+            // Assert against the `rootNodes` since Ivy always returns a new ChangeDetectorRef.\n+            expect((childRef as ViewRefInternal<any>).rootNodes)\n+                .toEqual((fixture.componentInstance.cdr as ViewRefInternal<any>).rootNodes);\n+          });\n+\n+          it('should throw when ChangeDetectorRef and @SkipSelf and not found', () => {\n+            @Component({template: '<div></div>'})\n+            class MyComponent {\n+              constructor(@SkipSelf() public injector: ChangeDetectorRef) {}\n+            }\n+\n+            @NgModule({\n+              declarations: [MyComponent],\n+            })\n+            class MyModule {\n+            }\n+\n+            TestBed.configureTestingModule({\n+              imports: [MyModule],\n+            });\n+\n+            expect(() => TestBed.createComponent(MyComponent))\n+                .toThrowError(/No provider for ChangeDetectorRef/);\n+          });\n+\n+          it('should lookup module injector in case @SkipSelf is used for `ChangeDetectorRef` token and Component has no parent',\n+             () => {\n+               let componentCDR: ChangeDetectorRef;\n+               let moduleCDR: ChangeDetectorRef;\n+               @Component({selector: 'child', template: '...'})\n+               class MyComponent {\n+                 constructor(@SkipSelf() public injector: ChangeDetectorRef) {\n+                   componentCDR = injector;\n+                 }\n+               }\n+\n+               @NgModule({\n+                 declarations: [MyComponent],\n+                 providers: [{\n+                   provide: ChangeDetectorRef,\n+                   useValue: {from: 'NG_MODULE'},\n+                 }]\n+               })\n+               class MyModule {\n+                 constructor(public injector: ChangeDetectorRef) {\n+                   moduleCDR = injector;\n+                 }\n+               }\n+\n+               TestBed.configureTestingModule({\n+                 imports: [MyModule],\n+               });\n+               const fixture = TestBed.createComponent(MyComponent);\n+               fixture.detectChanges();\n+\n+               expect((moduleCDR! as any).from).toBe('NG_MODULE');\n+               expect((componentCDR! as any).from).toBe('NG_MODULE');\n+             });\n+        });\n+\n+        describe('viewProviders', () => {\n+          it('should support @SkipSelf when using viewProviders', () => {\n+            @Component({\n+              selector: 'child',\n+              template: '{{ blah | json }}<br />{{ foo | json }}<br />{{ bar | json }}',\n+              providers: [{provide: 'Blah', useValue: 'Blah as Provider'}],\n+              viewProviders: [\n+                {provide: 'Foo', useValue: 'Foo as ViewProvider'},\n+                {provide: 'Bar', useValue: 'Bar as ViewProvider'},\n+              ]\n+            })\n+            class Child {\n+              constructor(\n+                  @Inject('Blah') public blah: String,\n+                  @Inject('Foo') public foo: String,\n+                  @SkipSelf() @Inject('Bar') public bar: String,\n+              ) {}\n+            }\n+\n+            @Component({\n+              selector: 'parent',\n+              template: '<ng-content></ng-content>',\n+              providers: [\n+                {provide: 'Blah', useValue: 'Blah as provider'},\n+                {provide: 'Bar', useValue: 'Bar as Provider'},\n+              ],\n+              viewProviders: [\n+                {provide: 'Foo', useValue: 'Foo as ViewProvider'},\n+                {provide: 'Bar', useValue: 'Bar as ViewProvider'},\n+              ]\n+            })\n+            class Parent {\n+            }\n+\n+            @Component({selector: 'my-app', template: '<parent><child></child></parent>'})\n+            class MyApp {\n+              @ViewChild(Parent) parent!: Parent;\n+              @ViewChild(Child) child!: Child;\n+            }\n+\n+            TestBed.configureTestingModule({declarations: [Child, Parent, MyApp]});\n+            const fixture = TestBed.createComponent(MyApp);\n+            fixture.detectChanges();\n+\n+            const child = fixture.componentInstance.child;\n+            if (ivyEnabled) {\n+              expect(child.bar).toBe('Bar as Provider');\n+            } else {\n+              // this seems like a ViewEngine bug\n+              expect(child.bar).toBe('Bar as ViewProvider');\n+            }\n+          });\n+\n+          it('should throw when @SkipSelf and no accessible viewProvider', () => {\n+            @Component({\n+              selector: 'child',\n+              template: '{{ blah | json }}<br />{{ foo | json }}<br />{{ bar | json }}',\n+              providers: [{provide: 'Blah', useValue: 'Blah as Provider'}],\n+              viewProviders: [\n+                {provide: 'Foo', useValue: 'Foo as ViewProvider'},\n+                {provide: 'Bar', useValue: 'Bar as ViewProvider'},\n+              ]\n+            })\n+            class Child {\n+              constructor(\n+                  @Inject('Blah') public blah: String,\n+                  @Inject('Foo') public foo: String,\n+                  @SkipSelf() @Inject('Bar') public bar: String,\n+              ) {}\n+            }\n+\n+            @Component({\n+              selector: 'parent',\n+              template: '<ng-content></ng-content>',\n+              providers: [{provide: 'Blah', useValue: 'Blah as provider'}],\n+              viewProviders: [\n+                {provide: 'Foo', useValue: 'Foo as ViewProvider'},\n+                {provide: 'Bar', useValue: 'Bar as ViewProvider'},\n+              ]\n+            })\n+            class Parent {\n+            }\n+\n+            @Component({selector: 'my-app', template: '<parent><child></child></parent>'})\n+            class MyApp {\n+            }\n+\n+            TestBed.configureTestingModule({declarations: [Child, Parent, MyApp]});\n+\n+            expect(() => TestBed.createComponent(MyApp)).toThrowError(/No provider for Bar/);\n+          });\n+\n+          it('should not throw when @SkipSelf and @Optional with no accessible viewProvider',\n+             () => {\n+               @Component({\n+                 selector: 'child',\n+                 template: '{{ blah | json }}<br />{{ foo | json }}<br />{{ bar | json }}',\n+                 providers: [{provide: 'Blah', useValue: 'Blah as Provider'}],\n+                 viewProviders: [\n+                   {provide: 'Foo', useValue: 'Foo as ViewProvider'},\n+                   {provide: 'Bar', useValue: 'Bar as ViewProvider'},\n+                 ]\n+               })\n+               class Child {\n+                 constructor(\n+                     @Inject('Blah') public blah: String,\n+                     @Inject('Foo') public foo: String,\n+                     @SkipSelf() @Optional() @Inject('Bar') public bar: String,\n+                 ) {}\n+               }\n+\n+               @Component({\n+                 selector: 'parent',\n+                 template: '<ng-content></ng-content>',\n+                 providers: [{provide: 'Blah', useValue: 'Blah as provider'}],\n+                 viewProviders: [\n+                   {provide: 'Foo', useValue: 'Foo as ViewProvider'},\n+                   {provide: 'Bar', useValue: 'Bar as ViewProvider'},\n+                 ]\n+               })\n+               class Parent {\n+               }\n+\n+               @Component({selector: 'my-app', template: '<parent><child></child></parent>'})\n+               class MyApp {\n+               }\n+\n+               TestBed.configureTestingModule({declarations: [Child, Parent, MyApp]});\n+\n+               expect(() => TestBed.createComponent(MyApp)).not.toThrowError(/No provider for Bar/);\n+             });\n+        });\n+      });\n+\n       describe('@Host', () => {\n         @Directive({selector: '[dirA]'})\n         class DirectiveA {\n@@ -1134,7 +2099,8 @@ describe('di', () => {\n \n       expect(provider!.getMessage()).toBe('bar');\n \n-      // ViewEngine incorrectly uses the original class DI config, instead of the one from useClass.\n+      // ViewEngine incorrectly uses the original class DI config, instead of the one from\n+      // useClass.\n       if (ivyEnabled) {\n         expect(provider!.dep.name).toBe('BarServiceDep');\n       }\n@@ -1180,7 +2146,8 @@ describe('di', () => {\n       expect(directProvider!.getMessage()).toBe('bar');\n       expect(overriddenProvider!.getMessage()).toBe('foo');\n \n-      // ViewEngine incorrectly uses the original class DI config, instead of the one from useClass.\n+      // ViewEngine incorrectly uses the original class DI config, instead of the one from\n+      // useClass.\n       if (ivyEnabled) {\n         expect(directProvider!.dep.name).toBe('BarServiceDep');\n         expect(overriddenProvider!.dep.name).toBe('FooServiceDep');\n@@ -1811,8 +2778,9 @@ describe('di', () => {\n       providers: [{\n         provide: LOCALE_ID,\n         useFactory: () => 'ja-JP',\n-        // Note: `LOCALE_ID` is also provided within APPLICATION_MODULE_PROVIDERS, so we use it here\n-        // as a dep and making sure it doesn't cause cyclic dependency (since @SkipSelf is present)\n+        // Note: `LOCALE_ID` is also provided within APPLICATION_MODULE_PROVIDERS, so we use it\n+        // here as a dep and making sure it doesn't cause cyclic dependency (since @SkipSelf is\n+        // present)\n         deps: [[new Inject(LOCALE_ID), new Optional(), new SkipSelf()]]\n       }]\n     })"
        },
        {
            "sha": "d4f067f254739505c198042d8058caaedfd2b3b3",
            "filename": "packages/core/test/bundling/cyclic_import/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/290ea57a9309ed3bd9a5c3635d13f7a45945abbf/packages%2Fcore%2Ftest%2Fbundling%2Fcyclic_import%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/290ea57a9309ed3bd9a5c3635d13f7a45945abbf/packages%2Fcore%2Ftest%2Fbundling%2Fcyclic_import%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Fcyclic_import%2Fbundle.golden_symbols.json?ref=290ea57a9309ed3bd9a5c3635d13f7a45945abbf",
            "patch": "@@ -14,6 +14,9 @@\n   {\n     \"name\": \"EMPTY_OBJ\"\n   },\n+  {\n+    \"name\": \"InjectFlags\"\n+  },\n   {\n     \"name\": \"Module\"\n   },\n@@ -173,6 +176,9 @@\n   {\n     \"name\": \"getCurrentTNodePlaceholderOk\"\n   },\n+  {\n+    \"name\": \"getDeclarationTNode\"\n+  },\n   {\n     \"name\": \"getFirstLContainer\"\n   },"
        },
        {
            "sha": "4e692ada58cf4c8d4b432f95758baf0e955fc201",
            "filename": "packages/core/test/bundling/forms/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/290ea57a9309ed3bd9a5c3635d13f7a45945abbf/packages%2Fcore%2Ftest%2Fbundling%2Fforms%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/290ea57a9309ed3bd9a5c3635d13f7a45945abbf/packages%2Fcore%2Ftest%2Fbundling%2Fforms%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Fforms%2Fbundle.golden_symbols.json?ref=290ea57a9309ed3bd9a5c3635d13f7a45945abbf",
            "patch": "@@ -983,6 +983,9 @@\n   {\n     \"name\": \"getDebugContext\"\n   },\n+  {\n+    \"name\": \"getDeclarationTNode\"\n+  },\n   {\n     \"name\": \"getFactoryDef\"\n   },\n@@ -1286,6 +1289,9 @@\n   {\n     \"name\": \"localeEn\"\n   },\n+  {\n+    \"name\": \"lookupTokenUsingModuleInjector\"\n+  },\n   {\n     \"name\": \"makeParamDecorator\"\n   },\n@@ -1379,6 +1385,9 @@\n   {\n     \"name\": \"normalizeValidators\"\n   },\n+  {\n+    \"name\": \"notFoundValueOrThrow\"\n+  },\n   {\n     \"name\": \"observable\"\n   },"
        },
        {
            "sha": "6f5521b982835dbcfffb28767a2fb6c901234e68",
            "filename": "packages/core/test/bundling/hello_world/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/290ea57a9309ed3bd9a5c3635d13f7a45945abbf/packages%2Fcore%2Ftest%2Fbundling%2Fhello_world%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/290ea57a9309ed3bd9a5c3635d13f7a45945abbf/packages%2Fcore%2Ftest%2Fbundling%2Fhello_world%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Fhello_world%2Fbundle.golden_symbols.json?ref=290ea57a9309ed3bd9a5c3635d13f7a45945abbf",
            "patch": "@@ -11,6 +11,9 @@\n   {\n     \"name\": \"EMPTY_OBJ\"\n   },\n+  {\n+    \"name\": \"InjectFlags\"\n+  },\n   {\n     \"name\": \"NG_COMP_DEF\"\n   },\n@@ -128,6 +131,9 @@\n   {\n     \"name\": \"getCurrentTNodePlaceholderOk\"\n   },\n+  {\n+    \"name\": \"getDeclarationTNode\"\n+  },\n   {\n     \"name\": \"getFirstLContainer\"\n   },"
        },
        {
            "sha": "5daed97b13b75cf52d7461ded94500880385c33c",
            "filename": "packages/core/test/bundling/router/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/290ea57a9309ed3bd9a5c3635d13f7a45945abbf/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/290ea57a9309ed3bd9a5c3635d13f7a45945abbf/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json?ref=290ea57a9309ed3bd9a5c3635d13f7a45945abbf",
            "patch": "@@ -1292,6 +1292,9 @@\n   {\n     \"name\": \"getDebugContext\"\n   },\n+  {\n+    \"name\": \"getDeclarationTNode\"\n+  },\n   {\n     \"name\": \"getFactoryDef\"\n   },\n@@ -1607,6 +1610,9 @@\n   {\n     \"name\": \"locateDirectiveOrProvider\"\n   },\n+  {\n+    \"name\": \"lookupTokenUsingModuleInjector\"\n+  },\n   {\n     \"name\": \"makeParamDecorator\"\n   },\n@@ -1703,6 +1709,9 @@\n   {\n     \"name\": \"normalizeQueryParams\"\n   },\n+  {\n+    \"name\": \"notFoundValueOrThrow\"\n+  },\n   {\n     \"name\": \"observable\"\n   },"
        },
        {
            "sha": "c053fb45b047dcbcfa7b66e6a46cf87738e83049",
            "filename": "packages/core/test/bundling/todo/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/290ea57a9309ed3bd9a5c3635d13f7a45945abbf/packages%2Fcore%2Ftest%2Fbundling%2Ftodo%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/290ea57a9309ed3bd9a5c3635d13f7a45945abbf/packages%2Fcore%2Ftest%2Fbundling%2Ftodo%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Ftodo%2Fbundle.golden_symbols.json?ref=290ea57a9309ed3bd9a5c3635d13f7a45945abbf",
            "patch": "@@ -353,6 +353,9 @@\n   {\n     \"name\": \"getDebugContext\"\n   },\n+  {\n+    \"name\": \"getDeclarationTNode\"\n+  },\n   {\n     \"name\": \"getFirstLContainer\"\n   },\n@@ -542,6 +545,9 @@\n   {\n     \"name\": \"leaveViewLight\"\n   },\n+  {\n+    \"name\": \"lookupTokenUsingModuleInjector\"\n+  },\n   {\n     \"name\": \"makeParamDecorator\"\n   },\n@@ -587,6 +593,9 @@\n   {\n     \"name\": \"noSideEffects\"\n   },\n+  {\n+    \"name\": \"notFoundValueOrThrow\"\n+  },\n   {\n     \"name\": \"readPatchedData\"\n   },"
        }
    ],
    "stats": {
        "total": 1282,
        "additions": 1204,
        "deletions": 78
    }
}