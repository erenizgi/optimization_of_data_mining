{
    "author": "twerske",
    "message": "docs: improve the component styling guide (#44234)\n\nPR Close #44234",
    "sha": "c82e5411f3e45ef25bec0b687b14ce2f3abf7383",
    "files": [
        {
            "sha": "f5599981d009b886b3077d411a13285538027110",
            "filename": "aio/content/guide/component-styles.md",
            "status": "modified",
            "additions": 18,
            "deletions": 16,
            "changes": 34,
            "blob_url": "https://github.com/angular/angular/blob/c82e5411f3e45ef25bec0b687b14ce2f3abf7383/aio%2Fcontent%2Fguide%2Fcomponent-styles.md",
            "raw_url": "https://github.com/angular/angular/raw/c82e5411f3e45ef25bec0b687b14ce2f3abf7383/aio%2Fcontent%2Fguide%2Fcomponent-styles.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fcontent%2Fguide%2Fcomponent-styles.md?ref=c82e5411f3e45ef25bec0b687b14ce2f3abf7383",
            "patch": "@@ -23,39 +23,41 @@ Usually you give it one string, as in the following example:\n \n <code-example path=\"component-styles/src/app/hero-app.component.ts\" header=\"src/app/hero-app.component.ts\"></code-example>\n \n-## Style scope\n+## Component styling best practices\n \n-<div class=\"alert is-critical\">\n+<div class=\"alert is-helpful\">\n \n-The styles specified in `@Component` metadata _apply only within the template of that component_.\n+   See [View Encapsulation](guide/view-encapsulation) for information on how Angular scopes styles to specific components.\n \n </div>\n \n-They are _not inherited_ by any components nested within the template nor by any content projected into the component.\n+You should consider the styles of a component to be private implementation details for that component. When consuming a common component, you should not override the component's styles any more than you should access the private members of a TypeScript class. While Angular's default style encapsulation prevents component styles from affecting other components, global styles affect all components on the page. This includes `::ng-deep`, which promotes a component style to a global style.\n+\n+### Authoring a component to support customization\n \n-In this example, the `h1` style applies only to the `HeroAppComponent`,\n-not to the nested `HeroMainComponent` nor to `<h1>` tags anywhere else in the application.\n+As component author, you can explicitly design a component to accept customization in one of four different ways.\n \n-This scoping restriction is a ***styling modularity feature***.\n+#### 1. Use CSS Custom Properties (recommended)\n \n-* Use the CSS class names and selectors that make the most sense in the context of each component.\n+You can define a supported customization API for your component by defining its styles with CSS Custom Properties, alternatively known as CSS Variables. Anyone using your component can consume this API by defining values for these properties, customizing the final appearance of the component on the rendered page.\n \n+While this requires defining a custom property for each customization point, it creates a clear API contract that works in all style encapsulation modes.\n \n-* Class names and selectors are local to the component and don't collide with\n-  classes and selectors used elsewhere in the application.\n+#### 2. Declare global CSS with @mixin\n \n+While Angular's emulated style encapsulation prevents styles from escaping a component, it does not prevent global CSS from affecting the entire page. While component consumers should avoid directly overwriting the CSS internals of a component, you can offer a supported customization API via a CSS preprocessor like Sass.\n \n-* Changes to styles elsewhere in the application don't affect the component's styles.\n+For example, a component may offer one or more supported mixins to customize various aspects of the component's appearance. While this approach uses global styles in itâ€™s implementation, it allows the component author to keep the mixins up to date with changes to the component's private DOM structure and CSS classes.\n \n+#### 3. Customize with CSS ::part\n \n-* Co-locate the CSS code of each component with the TypeScript and HTML code of the component,\n-  which leads to a neat and tidy project structure.\n+If your component uses [Shadow DOM](https://developer.mozilla.org/docs/Web/Web_Components/Using_shadow_DOM), you can apply the `part` attribute to specify elements in your component's template. This allows consumers of the component to author arbitrary styles targeting those specific elements with [the `::part` pseudo-element](https://developer.mozilla.org/docs/Web/CSS/::part).\n \n+While this lets you limit the elements within your template that consumers can customize, it does not limit which CSS properties are customizable. \n \n-* Change or remove component CSS code without searching through the\n-  whole application to find where else the code is used.\n+#### 4. Provide a TypeScript API\n \n-{@a special-selectors}\n+You can define a TypeScript API for customizing styles, using template bindings to update CSS classes and styles. This is not recommended because the additional JavaScript cost of this style API incurs far more performance cost than CSS.\n \n ## Special selectors\n "
        }
    ],
    "stats": {
        "total": 34,
        "additions": 18,
        "deletions": 16
    }
}