{
    "author": "ayazhafiz",
    "message": "feat(compiler): Parse and recover on incomplete opening HTML tags (#38681)\n\nLet's say we have a code like\n\n```html\n<div<span>123</span>\n```\n\nCurrently this gets parsed into a tree with the element tag `div<span`.\nThis has at least two downsides:\n\n- An incorrect diagnostic that `</span>` doesn't close an element is\n  emitted.\n- A consumer of the parse tree using it for editor services is unable to\n  provide correct completions for the opening `<span>` tag.\n\nThis patch attempts to fix both issues by instead parsing the code into\nthe same tree that would be parsed for `<div></div><span>123</span>`.\n\nIn particular, we do this by optimistically scanning an open tag as\nusual, but if we do not notice a terminating '>', we mark the tag as\n\"incomplete\". A parser then emits an error for the incomplete tag and\nadds a synthetic (recovered) element node to the tree with the\nincomplete open tag's name.\n\nWhat's the downside of this? For one, a breaking change.\n\n<ol>\n<li>\n\nThe first breaking change is that `<` symbols that are ambiguously text\nor opening tags will be parsed as opening tags instead of text in\nelement bodies. Take the code\n\n```html\n<p>a<b</p>\n```\n\nClearly we cannot have the best of both worlds, and this patch chooses\nto swap the parsing strategy to support the new feature. Of course, `<`\ncan still be inserted as text via the `&lt;` entity.\n\n</li>\n</ol>\n\nPart of #38596\n\nPR Close #38681",
    "sha": "6ae3b68acf91a086c639fa6479ada98cef7bcf1d",
    "files": [
        {
            "sha": "e7bbb08aeb345e190e5765aff13267e5fec1c70a",
            "filename": "packages/compiler/src/ml_parser/lexer.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 11,
            "changes": 23,
            "blob_url": "https://github.com/angular/angular/blob/6ae3b68acf91a086c639fa6479ada98cef7bcf1d/packages%2Fcompiler%2Fsrc%2Fml_parser%2Flexer.ts",
            "raw_url": "https://github.com/angular/angular/raw/6ae3b68acf91a086c639fa6479ada98cef7bcf1d/packages%2Fcompiler%2Fsrc%2Fml_parser%2Flexer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fml_parser%2Flexer.ts?ref=6ae3b68acf91a086c639fa6479ada98cef7bcf1d",
            "patch": "@@ -17,6 +17,7 @@ export enum TokenType {\n   TAG_OPEN_END,\n   TAG_OPEN_END_VOID,\n   TAG_CLOSE,\n+  INCOMPLETE_TAG_OPEN,\n   TEXT,\n   ESCAPABLE_RAW_TEXT,\n   RAW_TEXT,\n@@ -511,8 +512,6 @@ class _Tokenizer {\n     let tagName: string;\n     let prefix: string;\n     let openTagToken: Token|undefined;\n-    let tokensBeforeTagOpen = this.tokens.length;\n-    const innerStart = this._cursor.clone();\n     try {\n       if (!chars.isAsciiLetter(this._cursor.peek())) {\n         throw this._createError(\n@@ -523,7 +522,8 @@ class _Tokenizer {\n       prefix = openTagToken.parts[0];\n       tagName = openTagToken.parts[1];\n       this._attemptCharCodeUntilFn(isNotWhitespace);\n-      while (this._cursor.peek() !== chars.$SLASH && this._cursor.peek() !== chars.$GT) {\n+      while (this._cursor.peek() !== chars.$SLASH && this._cursor.peek() !== chars.$GT &&\n+             this._cursor.peek() !== chars.$LT) {\n         this._consumeAttributeName();\n         this._attemptCharCodeUntilFn(isNotWhitespace);\n         if (this._attemptCharCode(chars.$EQ)) {\n@@ -535,14 +535,15 @@ class _Tokenizer {\n       this._consumeTagOpenEnd();\n     } catch (e) {\n       if (e instanceof _ControlFlowError) {\n-        // When the start tag is invalid (including invalid \"attributes\"), assume we want a \"<\"\n-        this._cursor = innerStart;\n         if (openTagToken) {\n-          this.tokens.length = tokensBeforeTagOpen;\n+          // We errored before we could close the opening tag, so it is incomplete.\n+          openTagToken.type = TokenType.INCOMPLETE_TAG_OPEN;\n+        } else {\n+          // When the start tag is invalid, assume we want a \"<\" as text.\n+          // Back to back text tokens are merged at the end.\n+          this._beginToken(TokenType.TEXT, start);\n+          this._endToken(['<']);\n         }\n-        // Back to back text tokens are merged at the end\n-        this._beginToken(TokenType.TEXT, start);\n-        this._endToken(['<']);\n         return;\n       }\n \n@@ -772,8 +773,8 @@ function isNotWhitespace(code: number): boolean {\n }\n \n function isNameEnd(code: number): boolean {\n-  return chars.isWhitespace(code) || code === chars.$GT || code === chars.$SLASH ||\n-      code === chars.$SQ || code === chars.$DQ || code === chars.$EQ;\n+  return chars.isWhitespace(code) || code === chars.$GT || code === chars.$LT ||\n+      code === chars.$SLASH || code === chars.$SQ || code === chars.$DQ || code === chars.$EQ;\n }\n \n function isPrefixEnd(code: number): boolean {"
        },
        {
            "sha": "1194a8b7ba9786569277611456533d70f09a0e5a",
            "filename": "packages/compiler/src/ml_parser/parser.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 5,
            "changes": 22,
            "blob_url": "https://github.com/angular/angular/blob/6ae3b68acf91a086c639fa6479ada98cef7bcf1d/packages%2Fcompiler%2Fsrc%2Fml_parser%2Fparser.ts",
            "raw_url": "https://github.com/angular/angular/raw/6ae3b68acf91a086c639fa6479ada98cef7bcf1d/packages%2Fcompiler%2Fsrc%2Fml_parser%2Fparser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fml_parser%2Fparser.ts?ref=6ae3b68acf91a086c639fa6479ada98cef7bcf1d",
            "patch": "@@ -56,7 +56,8 @@ class _TreeBuilder {\n \n   build(): void {\n     while (this._peek.type !== lex.TokenType.EOF) {\n-      if (this._peek.type === lex.TokenType.TAG_OPEN_START) {\n+      if (this._peek.type === lex.TokenType.TAG_OPEN_START ||\n+          this._peek.type === lex.TokenType.INCOMPLETE_TAG_OPEN) {\n         this._consumeStartTag(this._advance());\n       } else if (this._peek.type === lex.TokenType.TAG_CLOSE) {\n         this._consumeEndTag(this._advance());\n@@ -233,8 +234,7 @@ class _TreeBuilder {\n   }\n \n   private _consumeStartTag(startTagToken: lex.Token) {\n-    const prefix = startTagToken.parts[0];\n-    const name = startTagToken.parts[1];\n+    const [prefix, name] = startTagToken.parts;\n     const attrs: html.Attribute[] = [];\n     while (this._peek.type === lex.TokenType.ATTR_NAME) {\n       attrs.push(this._consumeAttr(this._advance()));\n@@ -266,6 +266,12 @@ class _TreeBuilder {\n       // Elements that are self-closed have their `endSourceSpan` set to the full span, as the\n       // element start tag also represents the end tag.\n       this._popElement(fullName, span);\n+    } else if (startTagToken.type === lex.TokenType.INCOMPLETE_TAG_OPEN) {\n+      // We already know the opening tag is not complete, so it is unlikely it has a corresponding\n+      // close tag. Let's optimistically parse it as a full element and emit an error.\n+      this._popElement(fullName, null);\n+      this.errors.push(\n+          TreeError.create(fullName, span, `Opening tag \"${fullName}\" not terminated.`));\n     }\n   }\n \n@@ -295,15 +301,21 @@ class _TreeBuilder {\n     }\n   }\n \n-  private _popElement(fullName: string, endSourceSpan: ParseSourceSpan): boolean {\n+  /**\n+   * Closes the nearest element with the tag name `fullName` in the parse tree.\n+   * `endSourceSpan` is the span of the closing tag, or null if the element does\n+   * not have a closing tag (for example, this happens when an incomplete\n+   * opening tag is recovered).\n+   */\n+  private _popElement(fullName: string, endSourceSpan: ParseSourceSpan|null): boolean {\n     for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n       const el = this._elementStack[stackIndex];\n       if (el.name == fullName) {\n         // Record the parse span with the element that is being closed. Any elements that are\n         // removed from the element stack at this point are closed implicitly, so they won't get\n         // an end source span (as there is no explicit closing element).\n         el.endSourceSpan = endSourceSpan;\n-        el.sourceSpan.end = endSourceSpan.end || el.sourceSpan.end;\n+        el.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : el.sourceSpan.end;\n \n         this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n         return true;"
        },
        {
            "sha": "87dee2f8aa65799505701724d980d12f80c1b161",
            "filename": "packages/compiler/test/ml_parser/html_parser_spec.ts",
            "status": "modified",
            "additions": 62,
            "deletions": 10,
            "changes": 72,
            "blob_url": "https://github.com/angular/angular/blob/6ae3b68acf91a086c639fa6479ada98cef7bcf1d/packages%2Fcompiler%2Ftest%2Fml_parser%2Fhtml_parser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/6ae3b68acf91a086c639fa6479ada98cef7bcf1d/packages%2Fcompiler%2Ftest%2Fml_parser%2Fhtml_parser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fml_parser%2Fhtml_parser_spec.ts?ref=6ae3b68acf91a086c639fa6479ada98cef7bcf1d",
            "patch": "@@ -11,7 +11,7 @@ import {HtmlParser, ParseTreeResult, TreeError} from '../../src/ml_parser/html_p\n import {TokenType} from '../../src/ml_parser/lexer';\n import {ParseError} from '../../src/parse_util';\n \n-import {humanizeDom, humanizeDomSourceSpans, humanizeLineColumn} from './ast_spec_utils';\n+import {humanizeDom, humanizeDomSourceSpans, humanizeLineColumn, humanizeNodes} from './ast_spec_utils';\n \n {\n   describe('HtmlParser', () => {\n@@ -622,7 +622,7 @@ import {humanizeDom, humanizeDomSourceSpans, humanizeLineColumn} from './ast_spe\n               `{a, select, b {foo} % { bar {% bar}}`, 'TestComp', {tokenizeExpansionForms: true});\n           expect(humanizeErrors(p.errors)).toEqual([\n             [\n-              6,\n+              TokenType.RAW_TEXT,\n               'Unexpected character \"EOF\" (Do you have an unescaped \"{\" in your template? Use \"{{ \\'{\\' }}\") to escape it.)',\n               '0:36'\n             ],\n@@ -840,14 +840,66 @@ import {humanizeDom, humanizeDomSourceSpans, humanizeLineColumn} from './ast_spe\n           ]]);\n         });\n \n-        it('should report subsequent open tags without proper close tag', () => {\n-          const errors = parser.parse('<div</div>', 'TestComp').errors;\n-          expect(errors.length).toEqual(1);\n-          expect(humanizeErrors(errors)).toEqual([[\n-            'div',\n-            'Unexpected closing tag \"div\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags',\n-            '0:4'\n-          ]]);\n+        describe('incomplete element tag', () => {\n+          it('should parse and report incomplete tags after the tag name', () => {\n+            const {errors, rootNodes} = parser.parse('<div<span><div  </span>', 'TestComp');\n+\n+            expect(humanizeNodes(rootNodes, true)).toEqual([\n+              [html.Element, 'div', 0, '<div', '<div', null],\n+              [html.Element, 'span', 0, '<span><div  </span>', '<span>', '</span>'],\n+              [html.Element, 'div', 1, '<div  ', '<div  ', null],\n+            ]);\n+\n+            expect(humanizeErrors(errors)).toEqual([\n+              ['div', 'Opening tag \"div\" not terminated.', '0:0'],\n+              ['div', 'Opening tag \"div\" not terminated.', '0:10'],\n+            ]);\n+          });\n+\n+          it('should parse and report incomplete tags after attribute', () => {\n+            const {errors, rootNodes} =\n+                parser.parse('<div class=\"hi\" sty<span></span>', 'TestComp');\n+\n+            expect(humanizeNodes(rootNodes, true)).toEqual([\n+              [html.Element, 'div', 0, '<div class=\"hi\" sty', '<div class=\"hi\" sty', null],\n+              [html.Attribute, 'class', 'hi', 'class=\"hi\"'],\n+              [html.Attribute, 'sty', '', 'sty'],\n+              [html.Element, 'span', 0, '<span></span>', '<span>', '</span>'],\n+            ]);\n+\n+            expect(humanizeErrors(errors)).toEqual([\n+              ['div', 'Opening tag \"div\" not terminated.', '0:0'],\n+            ]);\n+          });\n+\n+          it('should parse and report incomplete tags after quote', () => {\n+            const {errors, rootNodes} = parser.parse('<div \"<span></span>', 'TestComp');\n+\n+            expect(humanizeNodes(rootNodes, true)).toEqual([\n+              [html.Element, 'div', 0, '<div ', '<div ', null],\n+              [html.Text, '\"', 0, '\"'],\n+              [html.Element, 'span', 0, '<span></span>', '<span>', '</span>'],\n+            ]);\n+\n+            expect(humanizeErrors(errors)).toEqual([\n+              ['div', 'Opening tag \"div\" not terminated.', '0:0'],\n+            ]);\n+          });\n+\n+          it('should report subsequent open tags without proper close tag', () => {\n+            const errors = parser.parse('<div</div>', 'TestComp').errors;\n+            expect(errors.length).toEqual(2);\n+            expect(humanizeErrors(errors)).toEqual([\n+              ['div', 'Opening tag \"div\" not terminated.', '0:0'],\n+              // TODO(ayazhafiz): the following error is unnecessary and can be pruned if we keep\n+              // track of the incomplete tag names.\n+              [\n+                'div',\n+                'Unexpected closing tag \"div\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags',\n+                '0:4'\n+              ]\n+            ]);\n+          });\n         });\n \n         it('should report closing tag for void elements', () => {"
        },
        {
            "sha": "1b5e3e3bc423a23e1d2c16c7ca3b9a7e6d6f9eda",
            "filename": "packages/compiler/test/ml_parser/lexer_spec.ts",
            "status": "modified",
            "additions": 62,
            "deletions": 6,
            "changes": 68,
            "blob_url": "https://github.com/angular/angular/blob/6ae3b68acf91a086c639fa6479ada98cef7bcf1d/packages%2Fcompiler%2Ftest%2Fml_parser%2Flexer_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/6ae3b68acf91a086c639fa6479ada98cef7bcf1d/packages%2Fcompiler%2Ftest%2Fml_parser%2Flexer_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fml_parser%2Flexer_spec.ts?ref=6ae3b68acf91a086c639fa6479ada98cef7bcf1d",
            "patch": "@@ -232,6 +232,45 @@ import {ParseLocation, ParseSourceFile, ParseSourceSpan} from '../../src/parse_u\n           [lex.TokenType.EOF, ''],\n         ]);\n       });\n+\n+      describe('tags', () => {\n+        it('after tag name', () => {\n+          expect(tokenizeAndHumanizeSourceSpans('<div<span><div</span>')).toEqual([\n+            [lex.TokenType.INCOMPLETE_TAG_OPEN, '<div'],\n+            [lex.TokenType.TAG_OPEN_START, '<span'],\n+            [lex.TokenType.TAG_OPEN_END, '>'],\n+            [lex.TokenType.INCOMPLETE_TAG_OPEN, '<div'],\n+            [lex.TokenType.TAG_CLOSE, '</span>'],\n+            [lex.TokenType.EOF, ''],\n+          ]);\n+        });\n+\n+        it('in attribute', () => {\n+          expect(tokenizeAndHumanizeSourceSpans('<div class=\"hi\" sty<span></span>')).toEqual([\n+            [lex.TokenType.INCOMPLETE_TAG_OPEN, '<div'],\n+            [lex.TokenType.ATTR_NAME, 'class'],\n+            [lex.TokenType.ATTR_QUOTE, '\"'],\n+            [lex.TokenType.ATTR_VALUE, 'hi'],\n+            [lex.TokenType.ATTR_QUOTE, '\"'],\n+            [lex.TokenType.ATTR_NAME, 'sty'],\n+            [lex.TokenType.TAG_OPEN_START, '<span'],\n+            [lex.TokenType.TAG_OPEN_END, '>'],\n+            [lex.TokenType.TAG_CLOSE, '</span>'],\n+            [lex.TokenType.EOF, ''],\n+          ]);\n+        });\n+\n+        it('after quote', () => {\n+          expect(tokenizeAndHumanizeSourceSpans('<div \"<span></span>')).toEqual([\n+            [lex.TokenType.INCOMPLETE_TAG_OPEN, '<div'],\n+            [lex.TokenType.TEXT, '\"'],\n+            [lex.TokenType.TAG_OPEN_START, '<span'],\n+            [lex.TokenType.TAG_OPEN_END, '>'],\n+            [lex.TokenType.TAG_CLOSE, '</span>'],\n+            [lex.TokenType.EOF, ''],\n+          ]);\n+        });\n+      });\n     });\n \n     describe('attributes', () => {\n@@ -554,7 +593,8 @@ import {ParseLocation, ParseSourceFile, ParseSourceSpan} from '../../src/parse_u\n         expect(tokenizeAndHumanizeSourceSpans('<p>a<b</p>')).toEqual([\n           [lex.TokenType.TAG_OPEN_START, '<p'],\n           [lex.TokenType.TAG_OPEN_END, '>'],\n-          [lex.TokenType.TEXT, 'a<b'],\n+          [lex.TokenType.TEXT, 'a'],\n+          [lex.TokenType.INCOMPLETE_TAG_OPEN, '<b'],\n           [lex.TokenType.TAG_CLOSE, '</p>'],\n           [lex.TokenType.EOF, ''],\n         ]);\n@@ -579,25 +619,41 @@ import {ParseLocation, ParseSourceFile, ParseSourceSpan} from '../../src/parse_u\n \n       it('should parse start tags quotes in place of an attribute name as text', () => {\n         expect(tokenizeAndHumanizeParts('<t \">')).toEqual([\n-          [lex.TokenType.TEXT, '<t \">'],\n+          [lex.TokenType.INCOMPLETE_TAG_OPEN, '', 't'],\n+          [lex.TokenType.TEXT, '\">'],\n           [lex.TokenType.EOF],\n         ]);\n \n         expect(tokenizeAndHumanizeParts('<t \\'>')).toEqual([\n-          [lex.TokenType.TEXT, '<t \\'>'],\n+          [lex.TokenType.INCOMPLETE_TAG_OPEN, '', 't'],\n+          [lex.TokenType.TEXT, '\\'>'],\n           [lex.TokenType.EOF],\n         ]);\n       });\n \n-      it('should parse start tags quotes in place of an attribute name (after a valid attribute) as text',\n+      it('should parse start tags quotes in place of an attribute name (after a valid attribute)',\n          () => {\n            expect(tokenizeAndHumanizeParts('<t a=\"b\" \">')).toEqual([\n-             [lex.TokenType.TEXT, '<t a=\"b\" \">'],\n+             [lex.TokenType.INCOMPLETE_TAG_OPEN, '', 't'],\n+             [lex.TokenType.ATTR_NAME, '', 'a'],\n+             [lex.TokenType.ATTR_QUOTE, '\"'],\n+             [lex.TokenType.ATTR_VALUE, 'b'],\n+             [lex.TokenType.ATTR_QUOTE, '\"'],\n+             // TODO(ayazhafiz): the \" symbol should be a synthetic attribute,\n+             // allowing us to complete the opening tag correctly.\n+             [lex.TokenType.TEXT, '\">'],\n              [lex.TokenType.EOF],\n            ]);\n \n            expect(tokenizeAndHumanizeParts('<t a=\\'b\\' \\'>')).toEqual([\n-             [lex.TokenType.TEXT, '<t a=\\'b\\' \\'>'],\n+             [lex.TokenType.INCOMPLETE_TAG_OPEN, '', 't'],\n+             [lex.TokenType.ATTR_NAME, '', 'a'],\n+             [lex.TokenType.ATTR_QUOTE, '\\''],\n+             [lex.TokenType.ATTR_VALUE, 'b'],\n+             [lex.TokenType.ATTR_QUOTE, '\\''],\n+             // TODO(ayazhafiz): the ' symbol should be a synthetic attribute,\n+             // allowing us to complete the opening tag correctly.\n+             [lex.TokenType.TEXT, '\\'>'],\n              [lex.TokenType.EOF],\n            ]);\n          });"
        }
    ],
    "stats": {
        "total": 185,
        "additions": 153,
        "deletions": 32
    }
}