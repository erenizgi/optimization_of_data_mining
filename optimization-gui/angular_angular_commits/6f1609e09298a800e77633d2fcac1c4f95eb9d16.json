{
    "author": "atscott",
    "message": "refactor(router): Update `recognize` to return `null` when there is no match (#40029)\n\nThis commit updates the `recognize` algorithm to return `null` when a\nsegment does not match a given config rather than throwing an error.\nThis makes the code much easier to follow because the \"no match\" result\nhas to be explicitly handled rather than catching the error in very\nspecific places.\n\nPR Close #40029",
    "sha": "6f1609e09298a800e77633d2fcac1c4f95eb9d16",
    "files": [
        {
            "sha": "42ffac58e9f832707743a3d016147f526f22a8c5",
            "filename": "packages/router/src/recognize.ts",
            "status": "modified",
            "additions": 33,
            "deletions": 16,
            "changes": 49,
            "blob_url": "https://github.com/angular/angular/blob/6f1609e09298a800e77633d2fcac1c4f95eb9d16/packages%2Frouter%2Fsrc%2Frecognize.ts",
            "raw_url": "https://github.com/angular/angular/raw/6f1609e09298a800e77633d2fcac1c4f95eb9d16/packages%2Frouter%2Fsrc%2Frecognize.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frecognize.ts?ref=6f1609e09298a800e77633d2fcac1c4f95eb9d16",
            "patch": "@@ -41,6 +41,10 @@ class Recognizer {\n           split(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup;\n \n       const children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);\n+      if (children === null) {\n+        return new Observable<RouterStateSnapshot>(\n+            (obs: Observer<RouterStateSnapshot>) => obs.error(new NoMatch()));\n+      }\n \n       const root = new ActivatedRouteSnapshot(\n           [], Object.freeze({}), Object.freeze({...this.urlTree.queryParams}),\n@@ -69,7 +73,7 @@ class Recognizer {\n   }\n \n   processSegmentGroup(config: Route[], segmentGroup: UrlSegmentGroup, outlet: string):\n-      TreeNode<ActivatedRouteSnapshot>[] {\n+      TreeNode<ActivatedRouteSnapshot>[]|null {\n     if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n       return this.processChildren(config, segmentGroup);\n     }\n@@ -78,11 +82,15 @@ class Recognizer {\n   }\n \n   processChildren(config: Route[], segmentGroup: UrlSegmentGroup):\n-      TreeNode<ActivatedRouteSnapshot>[] {\n+      TreeNode<ActivatedRouteSnapshot>[]|null {\n     const children: Array<TreeNode<ActivatedRouteSnapshot>> = [];\n     for (const childOutlet of Object.keys(segmentGroup.children)) {\n       const child = segmentGroup.children[childOutlet];\n-      children.push(...this.processSegmentGroup(config, child, childOutlet));\n+      const outletChildren = this.processSegmentGroup(config, child, childOutlet);\n+      if (outletChildren === null) {\n+        return null;\n+      }\n+      children.push(...outletChildren);\n     }\n     checkOutletNameUniqueness(children);\n     sortActivatedRouteSnapshots(children);\n@@ -91,19 +99,18 @@ class Recognizer {\n \n   processSegment(\n       config: Route[], segmentGroup: UrlSegmentGroup, segments: UrlSegment[],\n-      outlet: string): TreeNode<ActivatedRouteSnapshot>[] {\n+      outlet: string): TreeNode<ActivatedRouteSnapshot>[]|null {\n     for (const r of config) {\n-      try {\n-        return this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);\n-      } catch (e) {\n-        if (!(e instanceof NoMatch)) throw e;\n+      const children = this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);\n+      if (children !== null) {\n+        return children;\n       }\n     }\n     if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n       return [];\n     }\n \n-    throw new NoMatch();\n+    return null;\n   }\n \n   private noLeftoversInUrl(segmentGroup: UrlSegmentGroup, segments: UrlSegment[], outlet: string):\n@@ -113,10 +120,10 @@ class Recognizer {\n \n   processSegmentAgainstRoute(\n       route: Route, rawSegment: UrlSegmentGroup, segments: UrlSegment[],\n-      outlet: string): TreeNode<ActivatedRouteSnapshot>[] {\n-    if (route.redirectTo) throw new NoMatch();\n+      outlet: string): TreeNode<ActivatedRouteSnapshot>[]|null {\n+    if (route.redirectTo) return null;\n \n-    if ((route.outlet || PRIMARY_OUTLET) !== outlet) throw new NoMatch();\n+    if ((route.outlet || PRIMARY_OUTLET) !== outlet) return null;\n \n     let snapshot: ActivatedRouteSnapshot;\n     let consumedSegments: UrlSegment[] = [];\n@@ -129,7 +136,10 @@ class Recognizer {\n           getData(route), outlet, route.component!, route, getSourceSegmentGroup(rawSegment),\n           getPathIndexShift(rawSegment) + segments.length, getResolve(route));\n     } else {\n-      const result: MatchResult = match(rawSegment, route, segments);\n+      const result: MatchResult|null = match(rawSegment, route, segments);\n+      if (result === null) {\n+        return null;\n+      }\n       consumedSegments = result.consumedSegments;\n       rawSlicedSegments = segments.slice(result.lastChild);\n \n@@ -147,6 +157,9 @@ class Recognizer {\n \n     if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n       const children = this.processChildren(childConfig, segmentGroup);\n+      if (children === null) {\n+        return null;\n+      }\n       return [new TreeNode<ActivatedRouteSnapshot>(snapshot, children)];\n     }\n \n@@ -155,6 +168,9 @@ class Recognizer {\n     }\n \n     const children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);\n+    if (children === null) {\n+      return null;\n+    }\n     return [new TreeNode<ActivatedRouteSnapshot>(snapshot, children)];\n   }\n }\n@@ -185,18 +201,19 @@ interface MatchResult {\n   parameters: any;\n }\n \n-function match(segmentGroup: UrlSegmentGroup, route: Route, segments: UrlSegment[]): MatchResult {\n+function match(segmentGroup: UrlSegmentGroup, route: Route, segments: UrlSegment[]): MatchResult|\n+    null {\n   if (route.path === '') {\n     if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n-      throw new NoMatch();\n+      return null;\n     }\n \n     return {consumedSegments: [], lastChild: 0, parameters: {}};\n   }\n \n   const matcher = route.matcher || defaultUrlMatcher;\n   const res = matcher(segments, segmentGroup, route);\n-  if (!res) throw new NoMatch();\n+  if (!res) return null;\n \n   const posParams: {[n: string]: string} = {};\n   forEach(res.posParams!, (v: UrlSegment, k: string) => {"
        }
    ],
    "stats": {
        "total": 49,
        "additions": 33,
        "deletions": 16
    }
}