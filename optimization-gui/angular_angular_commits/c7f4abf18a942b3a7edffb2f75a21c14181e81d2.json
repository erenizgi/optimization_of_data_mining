{
    "author": "divdavem",
    "message": "feat(common): allow any Subscribable in async pipe (#39627)\n\nAs only methods from the Subscribable interface are currently used in the\nimplementation of the async pipe, it makes sense to make it explicit so\nthat it works successfully with any other implementation instead of\nonly Observable.\n\nPR Close #39627",
    "sha": "c7f4abf18a942b3a7edffb2f75a21c14181e81d2",
    "files": [
        {
            "sha": "de956a4cecc6c9f8bf1bd560adf0d4019823024e",
            "filename": "goldens/public-api/common/common.d.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/c7f4abf18a942b3a7edffb2f75a21c14181e81d2/goldens%2Fpublic-api%2Fcommon%2Fcommon.d.ts",
            "raw_url": "https://github.com/angular/angular/raw/c7f4abf18a942b3a7edffb2f75a21c14181e81d2/goldens%2Fpublic-api%2Fcommon%2Fcommon.d.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fpublic-api%2Fcommon%2Fcommon.d.ts?ref=c7f4abf18a942b3a7edffb2f75a21c14181e81d2",
            "patch": "@@ -3,9 +3,9 @@ export declare const APP_BASE_HREF: InjectionToken<string>;\n export declare class AsyncPipe implements OnDestroy, PipeTransform {\n     constructor(_ref: ChangeDetectorRef);\n     ngOnDestroy(): void;\n-    transform<T>(obj: Observable<T> | Promise<T>): T | null;\n+    transform<T>(obj: Subscribable<T> | Promise<T>): T | null;\n     transform<T>(obj: null | undefined): null;\n-    transform<T>(obj: Observable<T> | Promise<T> | null | undefined): T | null;\n+    transform<T>(obj: Subscribable<T> | Promise<T> | null | undefined): T | null;\n }\n \n export declare class CommonModule {"
        },
        {
            "sha": "6365dbc067540a2e3d2f109dfdfd66e2be046e93",
            "filename": "packages/common/src/pipes/async_pipe.ts",
            "status": "modified",
            "additions": 20,
            "deletions": 19,
            "changes": 39,
            "blob_url": "https://github.com/angular/angular/blob/c7f4abf18a942b3a7edffb2f75a21c14181e81d2/packages%2Fcommon%2Fsrc%2Fpipes%2Fasync_pipe.ts",
            "raw_url": "https://github.com/angular/angular/raw/c7f4abf18a942b3a7edffb2f75a21c14181e81d2/packages%2Fcommon%2Fsrc%2Fpipes%2Fasync_pipe.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Fsrc%2Fpipes%2Fasync_pipe.ts?ref=c7f4abf18a942b3a7edffb2f75a21c14181e81d2",
            "patch": "@@ -6,19 +6,20 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {ChangeDetectorRef, EventEmitter, OnDestroy, Pipe, PipeTransform, ɵisObservable, ɵisPromise} from '@angular/core';\n-import {Observable, SubscriptionLike} from 'rxjs';\n+import {ChangeDetectorRef, EventEmitter, OnDestroy, Pipe, PipeTransform, ɵisPromise, ɵisSubscribable} from '@angular/core';\n+import {Subscribable, Unsubscribable} from 'rxjs';\n+\n import {invalidPipeArgumentError} from './invalid_pipe_argument_error';\n \n interface SubscriptionStrategy {\n-  createSubscription(async: Observable<any>|Promise<any>, updateLatestValue: any): SubscriptionLike\n+  createSubscription(async: Subscribable<any>|Promise<any>, updateLatestValue: any): Unsubscribable\n       |Promise<any>;\n-  dispose(subscription: SubscriptionLike|Promise<any>): void;\n-  onDestroy(subscription: SubscriptionLike|Promise<any>): void;\n+  dispose(subscription: Unsubscribable|Promise<any>): void;\n+  onDestroy(subscription: Unsubscribable|Promise<any>): void;\n }\n \n-class ObservableStrategy implements SubscriptionStrategy {\n-  createSubscription(async: Observable<any>, updateLatestValue: any): SubscriptionLike {\n+class SubscribableStrategy implements SubscriptionStrategy {\n+  createSubscription(async: Subscribable<any>, updateLatestValue: any): Unsubscribable {\n     return async.subscribe({\n       next: updateLatestValue,\n       error: (e: any) => {\n@@ -27,11 +28,11 @@ class ObservableStrategy implements SubscriptionStrategy {\n     });\n   }\n \n-  dispose(subscription: SubscriptionLike): void {\n+  dispose(subscription: Unsubscribable): void {\n     subscription.unsubscribe();\n   }\n \n-  onDestroy(subscription: SubscriptionLike): void {\n+  onDestroy(subscription: Unsubscribable): void {\n     subscription.unsubscribe();\n   }\n }\n@@ -49,7 +50,7 @@ class PromiseStrategy implements SubscriptionStrategy {\n }\n \n const _promiseStrategy = new PromiseStrategy();\n-const _observableStrategy = new ObservableStrategy();\n+const _subscribableStrategy = new SubscribableStrategy();\n \n /**\n  * @ngModule CommonModule\n@@ -82,8 +83,8 @@ const _observableStrategy = new ObservableStrategy();\n export class AsyncPipe implements OnDestroy, PipeTransform {\n   private _latestValue: any = null;\n \n-  private _subscription: SubscriptionLike|Promise<any>|null = null;\n-  private _obj: Observable<any>|Promise<any>|EventEmitter<any>|null = null;\n+  private _subscription: Unsubscribable|Promise<any>|null = null;\n+  private _obj: Subscribable<any>|Promise<any>|EventEmitter<any>|null = null;\n   private _strategy: SubscriptionStrategy = null!;\n \n   constructor(private _ref: ChangeDetectorRef) {}\n@@ -94,10 +95,10 @@ export class AsyncPipe implements OnDestroy, PipeTransform {\n     }\n   }\n \n-  transform<T>(obj: Observable<T>|Promise<T>): T|null;\n+  transform<T>(obj: Subscribable<T>|Promise<T>): T|null;\n   transform<T>(obj: null|undefined): null;\n-  transform<T>(obj: Observable<T>|Promise<T>|null|undefined): T|null;\n-  transform<T>(obj: Observable<T>|Promise<T>|null|undefined): T|null {\n+  transform<T>(obj: Subscribable<T>|Promise<T>|null|undefined): T|null;\n+  transform<T>(obj: Subscribable<T>|Promise<T>|null|undefined): T|null {\n     if (!this._obj) {\n       if (obj) {\n         this._subscribe(obj);\n@@ -113,20 +114,20 @@ export class AsyncPipe implements OnDestroy, PipeTransform {\n     return this._latestValue;\n   }\n \n-  private _subscribe(obj: Observable<any>|Promise<any>|EventEmitter<any>): void {\n+  private _subscribe(obj: Subscribable<any>|Promise<any>|EventEmitter<any>): void {\n     this._obj = obj;\n     this._strategy = this._selectStrategy(obj);\n     this._subscription = this._strategy.createSubscription(\n         obj, (value: Object) => this._updateLatestValue(obj, value));\n   }\n \n-  private _selectStrategy(obj: Observable<any>|Promise<any>|EventEmitter<any>): any {\n+  private _selectStrategy(obj: Subscribable<any>|Promise<any>|EventEmitter<any>): any {\n     if (ɵisPromise(obj)) {\n       return _promiseStrategy;\n     }\n \n-    if (ɵisObservable(obj)) {\n-      return _observableStrategy;\n+    if (ɵisSubscribable(obj)) {\n+      return _subscribableStrategy;\n     }\n \n     throw invalidPipeArgumentError(AsyncPipe, obj);"
        },
        {
            "sha": "e30eb7ccd608b1564acade4bbdd9c1bc96c06c0a",
            "filename": "packages/common/test/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/c7f4abf18a942b3a7edffb2f75a21c14181e81d2/packages%2Fcommon%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/c7f4abf18a942b3a7edffb2f75a21c14181e81d2/packages%2Fcommon%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Ftest%2FBUILD.bazel?ref=c7f4abf18a942b3a7edffb2f75a21c14181e81d2",
            "patch": "@@ -32,6 +32,7 @@ ts_library(\n         \"//packages/platform-browser-dynamic\",\n         \"//packages/platform-browser/testing\",\n         \"//packages/private/testing\",\n+        \"@npm//rxjs\",\n     ],\n )\n "
        },
        {
            "sha": "9d57ab5f3c2423a405a874cf188a4cc3d3083d67",
            "filename": "packages/common/test/pipes/async_pipe_spec.ts",
            "status": "modified",
            "additions": 32,
            "deletions": 16,
            "changes": 48,
            "blob_url": "https://github.com/angular/angular/blob/c7f4abf18a942b3a7edffb2f75a21c14181e81d2/packages%2Fcommon%2Ftest%2Fpipes%2Fasync_pipe_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/c7f4abf18a942b3a7edffb2f75a21c14181e81d2/packages%2Fcommon%2Ftest%2Fpipes%2Fasync_pipe_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Ftest%2Fpipes%2Fasync_pipe_spec.ts?ref=c7f4abf18a942b3a7edffb2f75a21c14181e81d2",
            "patch": "@@ -10,70 +10,87 @@ import {AsyncPipe, ɵgetDOM as getDOM} from '@angular/common';\n import {EventEmitter} from '@angular/core';\n import {AsyncTestCompleter, beforeEach, describe, expect, inject, it} from '@angular/core/testing/src/testing_internal';\n import {browserDetection} from '@angular/platform-browser/testing/src/browser_util';\n+import {Subscribable, Unsubscribable} from 'rxjs';\n \n import {SpyChangeDetectorRef} from '../spies';\n \n {\n   describe('AsyncPipe', () => {\n     describe('Observable', () => {\n+      // only expose methods from the Subscribable interface, to ensure that\n+      // the implementation does not rely on other methods:\n+      const wrapSubscribable = <T>(input: Subscribable<T>): Subscribable<T> => ({\n+        subscribe(...args: any): Unsubscribable {\n+          const subscription = input.subscribe(...args);\n+          return {\n+            unsubscribe() {\n+              subscription.unsubscribe();\n+            }\n+          };\n+        }\n+      });\n+\n       let emitter: EventEmitter<any>;\n+      let subscribable: Subscribable<any>;\n       let pipe: AsyncPipe;\n       let ref: any;\n       const message = {};\n \n       beforeEach(() => {\n         emitter = new EventEmitter();\n+        subscribable = wrapSubscribable(emitter);\n         ref = new SpyChangeDetectorRef();\n         pipe = new AsyncPipe(ref);\n       });\n \n       describe('transform', () => {\n         it('should return null when subscribing to an observable', () => {\n-          expect(pipe.transform(emitter)).toBe(null);\n+          expect(pipe.transform(subscribable)).toBe(null);\n         });\n \n         it('should return the latest available value',\n            inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-             pipe.transform(emitter);\n+             pipe.transform(subscribable);\n              emitter.emit(message);\n \n              setTimeout(() => {\n-               expect(pipe.transform(emitter)).toEqual(message);\n+               expect(pipe.transform(subscribable)).toEqual(message);\n                async.done();\n              }, 0);\n            }));\n \n \n         it('should return same value when nothing has changed since the last call',\n            inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-             pipe.transform(emitter);\n+             pipe.transform(subscribable);\n              emitter.emit(message);\n \n              setTimeout(() => {\n-               pipe.transform(emitter);\n-               expect(pipe.transform(emitter)).toBe(message);\n+               pipe.transform(subscribable);\n+               expect(pipe.transform(subscribable)).toBe(message);\n                async.done();\n              }, 0);\n            }));\n \n         it('should dispose of the existing subscription when subscribing to a new observable',\n            inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-             pipe.transform(emitter);\n+             pipe.transform(subscribable);\n \n              const newEmitter = new EventEmitter();\n-             expect(pipe.transform(newEmitter)).toBe(null);\n+             const newSubscribable = wrapSubscribable(newEmitter);\n+             expect(pipe.transform(newSubscribable)).toBe(null);\n              emitter.emit(message);\n \n              // this should not affect the pipe\n              setTimeout(() => {\n-               expect(pipe.transform(newEmitter)).toBe(null);\n+               expect(pipe.transform(newSubscribable)).toBe(null);\n                async.done();\n              }, 0);\n            }));\n \n         it('should request a change detection check upon receiving a new value',\n            inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-             pipe.transform(emitter);\n+             pipe.transform(subscribable);\n              emitter.emit(message);\n \n              setTimeout(() => {\n@@ -83,12 +100,11 @@ import {SpyChangeDetectorRef} from '../spies';\n            }));\n \n         it('should return value for unchanged NaN', () => {\n-          const emitter = new EventEmitter<any>();\n           emitter.emit(null);\n-          pipe.transform(emitter);\n+          pipe.transform(subscribable);\n           emitter.next(NaN);\n-          const firstResult = pipe.transform(emitter);\n-          const secondResult = pipe.transform(emitter);\n+          const firstResult = pipe.transform(subscribable);\n+          const secondResult = pipe.transform(subscribable);\n           expect(firstResult).toBeNaN();\n           expect(secondResult).toBeNaN();\n         });\n@@ -101,12 +117,12 @@ import {SpyChangeDetectorRef} from '../spies';\n \n         it('should dispose of the existing subscription',\n            inject([AsyncTestCompleter], (async: AsyncTestCompleter) => {\n-             pipe.transform(emitter);\n+             pipe.transform(subscribable);\n              pipe.ngOnDestroy();\n              emitter.emit(message);\n \n              setTimeout(() => {\n-               expect(pipe.transform(emitter)).toBe(null);\n+               expect(pipe.transform(subscribable)).toBe(null);\n                async.done();\n              }, 0);\n            }));"
        },
        {
            "sha": "edf5f40807a1238cfd75a566bb4a93694db46223",
            "filename": "packages/core/src/core_private_export.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/c7f4abf18a942b3a7edffb2f75a21c14181e81d2/packages%2Fcore%2Fsrc%2Fcore_private_export.ts",
            "raw_url": "https://github.com/angular/angular/raw/c7f4abf18a942b3a7edffb2f75a21c14181e81d2/packages%2Fcore%2Fsrc%2Fcore_private_export.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Fcore_private_export.ts?ref=c7f4abf18a942b3a7edffb2f75a21c14181e81d2",
            "patch": "@@ -29,7 +29,7 @@ export {_sanitizeHtml as ɵ_sanitizeHtml} from './sanitization/html_sanitizer';\n export {_sanitizeUrl as ɵ_sanitizeUrl} from './sanitization/url_sanitizer';\n export {makeDecorator as ɵmakeDecorator} from './util/decorators';\n export {global as ɵglobal} from './util/global';\n-export {isObservable as ɵisObservable, isPromise as ɵisPromise} from './util/lang';\n+export {isObservable as ɵisObservable, isPromise as ɵisPromise, isSubscribable as ɵisSubscribable} from './util/lang';\n export {stringify as ɵstringify} from './util/stringify';\n export {clearOverrides as ɵclearOverrides, initServicesIfNeeded as ɵinitServicesIfNeeded, overrideComponentView as ɵoverrideComponentView, overrideProvider as ɵoverrideProvider} from './view/index';\n export {NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR as ɵNOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR} from './view/provider';"
        },
        {
            "sha": "1d029a776bd1cc92f314af092b2555a041b61018",
            "filename": "packages/core/src/util/lang.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 4,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/c7f4abf18a942b3a7edffb2f75a21c14181e81d2/packages%2Fcore%2Fsrc%2Futil%2Flang.ts",
            "raw_url": "https://github.com/angular/angular/raw/c7f4abf18a942b3a7edffb2f75a21c14181e81d2/packages%2Fcore%2Fsrc%2Futil%2Flang.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Futil%2Flang.ts?ref=c7f4abf18a942b3a7edffb2f75a21c14181e81d2",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {Observable} from 'rxjs';\n+import {Observable, Subscribable} from 'rxjs';\n \n /**\n  * Determine if the argument is shaped like a Promise\n@@ -17,6 +17,13 @@ export function isPromise<T = any>(obj: any): obj is Promise<T> {\n   return !!obj && typeof obj.then === 'function';\n }\n \n+/**\n+ * Determine if the argument is a Subscribable\n+ */\n+export function isSubscribable(obj: any|Subscribable<any>): obj is Subscribable<any> {\n+  return !!obj && typeof obj.subscribe === 'function';\n+}\n+\n /**\n  * Determine if the argument is an Observable\n  *\n@@ -26,6 +33,5 @@ export function isPromise<T = any>(obj: any): obj is Promise<T> {\n  * `subscribe()` method, and RxJS has mechanisms to wrap `Subscribable` objects\n  * into `Observable` as needed.\n  */\n-export function isObservable(obj: any|Observable<any>): obj is Observable<any> {\n-  return !!obj && typeof obj.subscribe === 'function';\n-}\n+export const isObservable =\n+    isSubscribable as ((obj: any|Observable<any>) => obj is Observable<any>);"
        }
    ],
    "stats": {
        "total": 108,
        "additions": 66,
        "deletions": 42
    }
}