{
    "author": "alxhub",
    "message": "feat(language-service): completions for structural directives (#40032)\n\nThis comit adds support for autocompletion of attributes that create\nstructural directives. Such completions differ from those of normal\nattributes, as the structural directive syntax creates a synthetic\n<ng-template> node which has different attributes from the main element.\n\nPR Close #40032",
    "sha": "2a7443117bb3ee06ab14e748b4504c45ab75e8c8",
    "files": [
        {
            "sha": "0bf92f89868ba9e32a7d34d54c89b62110496b81",
            "filename": "packages/language-service/ivy/attribute_completions.ts",
            "status": "modified",
            "additions": 186,
            "deletions": 74,
            "changes": 260,
            "blob_url": "https://github.com/angular/angular/blob/2a7443117bb3ee06ab14e748b4504c45ab75e8c8/packages%2Flanguage-service%2Fivy%2Fattribute_completions.ts",
            "raw_url": "https://github.com/angular/angular/raw/2a7443117bb3ee06ab14e748b4504c45ab75e8c8/packages%2Flanguage-service%2Fivy%2Fattribute_completions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fattribute_completions.ts?ref=2a7443117bb3ee06ab14e748b4504c45ab75e8c8",
            "patch": "@@ -6,8 +6,8 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {CssSelector, SelectorMatcher, TmplAstElement} from '@angular/compiler';\n-import {DirectiveInScope, TemplateTypeChecker} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n+import {CssSelector, SelectorMatcher, TmplAstElement, TmplAstTemplate} from '@angular/compiler';\n+import {DirectiveInScope, ElementSymbol, TemplateSymbol, TemplateTypeChecker, TypeCheckableDirectiveMeta} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import * as ts from 'typescript';\n \n import {DisplayInfoKind, unsafeCastDisplayInfoKindToScriptElementKind} from './display_parts';\n@@ -37,6 +37,12 @@ export enum AttributeCompletionKind {\n    */\n   DirectiveAttribute,\n \n+  /**\n+   * Completion of an attribute that results in a new structural directive being matched on an\n+   * element.\n+   */\n+  StructuralDirectiveAttribute,\n+\n   /**\n    * Completion of an input from a directive which is either present on the element, or becomes\n    * present after the addition of this attribute.\n@@ -83,7 +89,8 @@ export interface DomPropertyCompletion {\n  * Completion of an attribute which results in a new directive being matched on an element.\n  */\n export interface DirectiveAttributeCompletion {\n-  kind: AttributeCompletionKind.DirectiveAttribute;\n+  kind: AttributeCompletionKind.DirectiveAttribute|\n+      AttributeCompletionKind.StructuralDirectiveAttribute;\n \n   /**\n    * Name of the attribute whose addition causes this directive to match the element.\n@@ -172,13 +179,14 @@ export type AttributeCompletion = DomAttributeCompletion|DomPropertyCompletion|\n  * completion, not the DOM completion for that name.\n  */\n export function buildAttributeCompletionTable(\n-    component: ts.ClassDeclaration, element: TmplAstElement,\n+    component: ts.ClassDeclaration, element: TmplAstElement|TmplAstTemplate,\n     checker: TemplateTypeChecker): Map<string, AttributeCompletion> {\n   const table = new Map<string, AttributeCompletion>();\n \n-  // Use the `ElementSymbol` to iterate over directives present on the element, and their\n-  // inputs/outputs. These have the highest priority of completion results.\n-  const symbol = checker.getSymbolOfNode(element, component);\n+  // Use the `ElementSymbol` or `TemplateSymbol` to iterate over directives present on the node, and\n+  // their inputs/outputs. These have the highest priority of completion results.\n+  const symbol: ElementSymbol|TemplateSymbol =\n+      checker.getSymbolOfNode(element, component) as ElementSymbol | TemplateSymbol;\n   const presentDirectives = new Set<ts.ClassDeclaration>();\n   if (symbol !== null) {\n     // An `ElementSymbol` was available. This means inputs and outputs for directives on the\n@@ -242,79 +250,104 @@ export function buildAttributeCompletionTable(\n         continue;\n       }\n \n-      const selectors = CssSelector.parse(meta.selector);\n-      const matcher = new SelectorMatcher();\n-      matcher.addSelectables(selectors);\n-\n-      for (const selector of selectors) {\n-        for (const [attrName, attrValue] of selectorAttributes(selector)) {\n-          if (attrValue !== '') {\n-            // This attribute selector requires a value, which is not supported in completion.\n-            continue;\n-          }\n-\n-          if (table.has(attrName)) {\n-            // Skip this attribute as there's already a binding for it.\n-            continue;\n-          }\n-\n-          // Check whether adding this attribute would cause the directive to start matching.\n-          const newElementSelector = elementSelector + `[${attrName}]`;\n-          if (!matcher.match(CssSelector.parse(newElementSelector)[0], null)) {\n-            // Nope, move on with our lives.\n-            continue;\n-          }\n-\n-          // Adding this attribute causes a new directive to be matched. Decide how to categorize\n-          // it based on the directive's inputs and outputs.\n-          if (meta.inputs.hasBindingPropertyName(attrName)) {\n-            // This attribute corresponds to an input binding.\n-            table.set(attrName, {\n-              kind: AttributeCompletionKind.DirectiveInput,\n-              directive: dirInScope,\n-              propertyName: attrName,\n-              classPropertyName:\n-                  meta.inputs.getByBindingPropertyName(attrName)![0].classPropertyName,\n-              twoWayBindingSupported: meta.outputs.hasBindingPropertyName(attrName + 'Change'),\n-            });\n-          } else if (meta.outputs.hasBindingPropertyName(attrName)) {\n-            // This attribute corresponds to an output binding.\n-            table.set(attrName, {\n-              kind: AttributeCompletionKind.DirectiveOutput,\n-              directive: dirInScope,\n-              eventName: attrName,\n-              classPropertyName:\n-                  meta.outputs.getByBindingPropertyName(attrName)![0].classPropertyName,\n-            });\n-          } else {\n-            // This attribute causes a new directive to be matched, but does not also correspond to\n-            // an input or output binding.\n-            table.set(attrName, {\n-              kind: AttributeCompletionKind.DirectiveAttribute,\n-              attribute: attrName,\n-              directive: dirInScope,\n-            });\n+      if (!meta.isStructural) {\n+        // For non-structural directives, the directive's attribute selector(s) are matched against\n+        // a hypothetical version of the element with those attributes. A match indicates that\n+        // adding that attribute/input/output binding would cause the directive to become present,\n+        // meaning that such a binding is a valid completion.\n+        const selectors = CssSelector.parse(meta.selector);\n+        const matcher = new SelectorMatcher();\n+        matcher.addSelectables(selectors);\n+\n+        for (const selector of selectors) {\n+          for (const [attrName, attrValue] of selectorAttributes(selector)) {\n+            if (attrValue !== '') {\n+              // This attribute selector requires a value, which is not supported in completion.\n+              continue;\n+            }\n+\n+            if (table.has(attrName)) {\n+              // Skip this attribute as there's already a binding for it.\n+              continue;\n+            }\n+\n+            // Check whether adding this attribute would cause the directive to start matching.\n+            const newElementSelector = elementSelector + `[${attrName}]`;\n+            if (!matcher.match(CssSelector.parse(newElementSelector)[0], null)) {\n+              // Nope, move on with our lives.\n+              continue;\n+            }\n+\n+            // Adding this attribute causes a new directive to be matched. Decide how to categorize\n+            // it based on the directive's inputs and outputs.\n+            if (meta.inputs.hasBindingPropertyName(attrName)) {\n+              // This attribute corresponds to an input binding.\n+              table.set(attrName, {\n+                kind: AttributeCompletionKind.DirectiveInput,\n+                directive: dirInScope,\n+                propertyName: attrName,\n+                classPropertyName:\n+                    meta.inputs.getByBindingPropertyName(attrName)![0].classPropertyName,\n+                twoWayBindingSupported: meta.outputs.hasBindingPropertyName(attrName + 'Change'),\n+              });\n+            } else if (meta.outputs.hasBindingPropertyName(attrName)) {\n+              // This attribute corresponds to an output binding.\n+              table.set(attrName, {\n+                kind: AttributeCompletionKind.DirectiveOutput,\n+                directive: dirInScope,\n+                eventName: attrName,\n+                classPropertyName:\n+                    meta.outputs.getByBindingPropertyName(attrName)![0].classPropertyName,\n+              });\n+            } else {\n+              // This attribute causes a new directive to be matched, but does not also correspond\n+              // to an input or output binding.\n+              table.set(attrName, {\n+                kind: AttributeCompletionKind.DirectiveAttribute,\n+                attribute: attrName,\n+                directive: dirInScope,\n+              });\n+            }\n           }\n         }\n+      } else {\n+        // Hypothetically matching a structural directive is a litle different than a plain\n+        // directive. Use of the '*' structural directive syntactic sugar means that the actual\n+        // directive is applied to a plain <ng-template> node, not the existing element with any\n+        // other attributes it might already have.\n+        // Additionally, more than one attribute/input might need to be present in order for the\n+        // directive to match (e.g. `ngFor` has a selector of `[ngFor][ngForOf]`). This gets a\n+        // little tricky.\n+\n+        const structuralAttributes = getStructuralAttributes(meta);\n+        for (const attrName of structuralAttributes) {\n+          table.set(attrName, {\n+            kind: AttributeCompletionKind.StructuralDirectiveAttribute,\n+            attribute: attrName,\n+            directive: dirInScope,\n+          });\n+        }\n       }\n     }\n   }\n \n   // Finally, add any DOM attributes not already covered by inputs.\n-  for (const {attribute, property} of checker.getPotentialDomBindings(element.name)) {\n-    const isAlsoProperty = attribute === property;\n-    if (!table.has(attribute)) {\n-      table.set(attribute, {\n-        kind: AttributeCompletionKind.DomAttribute,\n-        attribute,\n-        isAlsoProperty,\n-      });\n-    }\n-    if (!isAlsoProperty && !table.has(property)) {\n-      table.set(property, {\n-        kind: AttributeCompletionKind.DomProperty,\n-        property,\n-      });\n+  if (element instanceof TmplAstElement) {\n+    for (const {attribute, property} of checker.getPotentialDomBindings(element.name)) {\n+      const isAlsoProperty = attribute === property;\n+      if (!table.has(attribute)) {\n+        table.set(attribute, {\n+          kind: AttributeCompletionKind.DomAttribute,\n+          attribute,\n+          isAlsoProperty,\n+        });\n+      }\n+      if (!isAlsoProperty && !table.has(property)) {\n+        table.set(property, {\n+          kind: AttributeCompletionKind.DomProperty,\n+          property,\n+        });\n+      }\n     }\n   }\n \n@@ -335,7 +368,7 @@ export function buildAttributeCompletionTable(\n  */\n export function addAttributeCompletionEntries(\n     entries: ts.CompletionEntry[], completion: AttributeCompletion, isAttributeContext: boolean,\n-    replacementSpan: ts.TextSpan|undefined): void {\n+    isElementContext: boolean, replacementSpan: ts.TextSpan|undefined): void {\n   switch (completion.kind) {\n     case AttributeCompletionKind.DirectiveAttribute: {\n       entries.push({\n@@ -346,6 +379,19 @@ export function addAttributeCompletionEntries(\n       });\n       break;\n     }\n+    case AttributeCompletionKind.StructuralDirectiveAttribute: {\n+      // In an element, the completion is offered with a leading '*' to activate the structural\n+      // directive. Once present, the structural attribute will be parsed as a template and not an\n+      // element, and the prefix is no longer necessary.\n+      const prefix = isElementContext ? '*' : '';\n+      entries.push({\n+        kind: unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+        name: prefix + completion.attribute,\n+        sortText: prefix + completion.attribute,\n+        replacementSpan,\n+      });\n+      break;\n+    }\n     case AttributeCompletionKind.DirectiveInput: {\n       if (isAttributeContext) {\n         // Offer a completion of a property binding.\n@@ -451,6 +497,7 @@ export function getAttributeCompletionSymbol(\n     case AttributeCompletionKind.DomProperty:\n       return null;\n     case AttributeCompletionKind.DirectiveAttribute:\n+    case AttributeCompletionKind.StructuralDirectiveAttribute:\n       return completion.directive.tsSymbol;\n     case AttributeCompletionKind.DirectiveInput:\n     case AttributeCompletionKind.DirectiveOutput:\n@@ -469,3 +516,68 @@ function* selectorAttributes(selector: CssSelector): Iterable<[string, string]>\n     yield [selector.attrs[0], selector.attrs[1]];\n   }\n }\n+\n+function getStructuralAttributes(meta: TypeCheckableDirectiveMeta): string[] {\n+  if (meta.selector === null) {\n+    return [];\n+  }\n+\n+  const structuralAttributes: string[] = [];\n+  const selectors = CssSelector.parse(meta.selector);\n+  for (const selector of selectors) {\n+    if (selector.element !== null && selector.element !== 'ng-template') {\n+      // This particular selector does not apply under structural directive syntax.\n+      continue;\n+    }\n+\n+    // Every attribute of this selector must be name-only - no required values.\n+    const attributeSelectors = Array.from(selectorAttributes(selector));\n+    if (!attributeSelectors.every(([_, attrValue]) => attrValue === '')) {\n+      continue;\n+    }\n+\n+    // Get every named selector.\n+    const attributes = attributeSelectors.map(([attrName, _]) => attrName);\n+\n+    // Find the shortest attribute. This is the structural directive \"base\", and all potential\n+    // input bindings must begin with the base. E.g. in `*ngFor=\"let a of b\"`, `ngFor` is the\n+    // base attribute, and the `of` binding key corresponds to an input of `ngForOf`.\n+    const baseAttr = attributes.reduce(\n+        (prev, curr) => prev === null || curr.length < prev.length ? curr : prev,\n+        null as string | null);\n+    if (baseAttr === null) {\n+      // No attributes in this selector?\n+      continue;\n+    }\n+\n+    // Validate that the attributes are compatible with use as a structural directive.\n+    const isValid = (attr: string): boolean => {\n+      // The base attribute is valid by default.\n+      if (attr === baseAttr) {\n+        return true;\n+      }\n+\n+      // Non-base attributes must all be prefixed with the base attribute.\n+      if (!attr.startsWith(baseAttr)) {\n+        return false;\n+      }\n+\n+      // Non-base attributes must also correspond to directive inputs.\n+      if (!meta.inputs.hasBindingPropertyName(attr)) {\n+        return false;\n+      }\n+\n+      // This attribute is compatible.\n+      return true;\n+    };\n+\n+    if (!attributes.every(isValid)) {\n+      continue;\n+    }\n+\n+    // This attribute is valid as a structural attribute for this directive.\n+    structuralAttributes.push(baseAttr);\n+  }\n+\n+  return structuralAttributes;\n+}"
        },
        {
            "sha": "88b29999ede7bad21e56e0954d742c7f477cc7b8",
            "filename": "packages/language-service/ivy/completions.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 10,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/2a7443117bb3ee06ab14e748b4504c45ab75e8c8/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "raw_url": "https://github.com/angular/angular/raw/2a7443117bb3ee06ab14e748b4504c45ab75e8c8/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fcompletions.ts?ref=2a7443117bb3ee06ab14e748b4504c45ab75e8c8",
            "patch": "@@ -422,10 +422,11 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n \n   private getElementAttributeCompletions(this: ElementAttributeCompletionBuilder):\n       ts.WithMetadata<ts.CompletionInfo>|undefined {\n-    let element: TmplAstElement;\n+    let element: TmplAstElement|TmplAstTemplate;\n     if (this.node instanceof TmplAstElement) {\n       element = this.node;\n-    } else if (this.nodeParent instanceof TmplAstElement) {\n+    } else if (\n+        this.nodeParent instanceof TmplAstElement || this.nodeParent instanceof TmplAstTemplate) {\n       element = this.nodeParent;\n     } else {\n       // Nothing to do without an element to process.\n@@ -476,7 +477,11 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n       // Is the completion in an attribute context (instead of a property context)?\n       const isAttributeContext =\n           (this.node instanceof TmplAstElement || this.node instanceof TmplAstTextAttribute);\n-      addAttributeCompletionEntries(entries, completion, isAttributeContext, replacementSpan);\n+      // Is the completion for an element (not an <ng-template>)?\n+      const isElementContext =\n+          this.node instanceof TmplAstElement || this.nodeParent instanceof TmplAstElement;\n+      addAttributeCompletionEntries(\n+          entries, completion, isAttributeContext, isElementContext, replacementSpan);\n     }\n \n     return {\n@@ -494,10 +499,11 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n     // chose. Strip off any binding syntax to get the real attribute name.\n     const {name, kind} = stripBindingSugar(entryName);\n \n-    let element: TmplAstElement;\n-    if (this.node instanceof TmplAstElement) {\n+    let element: TmplAstElement|TmplAstTemplate;\n+    if (this.node instanceof TmplAstElement || this.node instanceof TmplAstTemplate) {\n       element = this.node;\n-    } else if (this.nodeParent instanceof TmplAstElement) {\n+    } else if (\n+        this.nodeParent instanceof TmplAstElement || this.nodeParent instanceof TmplAstTemplate) {\n       element = this.nodeParent;\n     } else {\n       // Nothing to do without an element to process.\n@@ -558,12 +564,13 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n \n   private getElementAttributeCompletionSymbol(\n       this: ElementAttributeCompletionBuilder, attribute: string): ts.Symbol|undefined {\n-    const {name, kind} = stripBindingSugar(attribute);\n+    const {name} = stripBindingSugar(attribute);\n \n-    let element: TmplAstElement;\n-    if (this.node instanceof TmplAstElement) {\n+    let element: TmplAstElement|TmplAstTemplate;\n+    if (this.node instanceof TmplAstElement || this.node instanceof TmplAstTemplate) {\n       element = this.node;\n-    } else if (this.nodeParent instanceof TmplAstElement) {\n+    } else if (\n+        this.nodeParent instanceof TmplAstElement || this.nodeParent instanceof TmplAstTemplate) {\n       element = this.nodeParent;\n     } else {\n       // Nothing to do without an element to process."
        },
        {
            "sha": "32a09e9b1934356f69d33d6ef2eb59cb844f8b8e",
            "filename": "packages/language-service/ivy/test/completions_spec.ts",
            "status": "modified",
            "additions": 64,
            "deletions": 1,
            "changes": 65,
            "blob_url": "https://github.com/angular/angular/blob/2a7443117bb3ee06ab14e748b4504c45ab75e8c8/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2a7443117bb3ee06ab14e748b4504c45ab75e8c8/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts?ref=2a7443117bb3ee06ab14e748b4504c45ab75e8c8",
            "patch": "@@ -39,6 +39,19 @@ const DIR_WITH_OUTPUT = {\n   `\n };\n \n+const NG_FOR_DIR = {\n+  'NgFor': `\n+    @Directive({\n+      selector: '[ngFor][ngForOf]',\n+    })\n+    export class NgFor {\n+      constructor(ref: TemplateRef<any>) {}\n+\n+      ngForOf!: any;\n+    }\n+  `\n+};\n+\n const DIR_WITH_SELECTED_INPUT = {\n   'Dir': `\n     @Directive({\n@@ -387,6 +400,56 @@ describe('completions', () => {\n         });\n       });\n \n+      describe('structural directive present', () => {\n+        it('should return structural directive completions for an empty attribute', () => {\n+          const {ngLS, fileName, cursor, text} = setup(`<li ¦>`, '', NG_FOR_DIR);\n+\n+          const completions =\n+              ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+              ['*ngFor']);\n+        });\n+\n+        it('should return structural directive completions for an existing non-structural attribute',\n+           () => {\n+             const {ngLS, fileName, cursor, text} = setup(`<li ng¦>`, '', NG_FOR_DIR);\n+\n+             const completions =\n+                 ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+             expectContain(\n+                 completions,\n+                 unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+                 ['*ngFor']);\n+             expectReplacementText(completions, text, 'ng');\n+           });\n+\n+        it('should return structural directive completions for an existing structural attribute',\n+           () => {\n+             const {ngLS, fileName, cursor, text} = setup(`<li *ng¦>`, '', NG_FOR_DIR);\n+\n+             const completions =\n+                 ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+             expectContain(\n+                 completions,\n+                 unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+                 ['ngFor']);\n+             expectReplacementText(completions, text, 'ng');\n+           });\n+\n+        it('should return structural directive completions for just the structural marker', () => {\n+          const {ngLS, fileName, cursor, text} = setup(`<li *¦>`, '', NG_FOR_DIR);\n+\n+          const completions =\n+              ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+          expectContain(\n+              completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+              ['ngFor']);\n+          // The completion should not try to overwrite the '*'.\n+          expectReplacementText(completions, text, '');\n+        });\n+      });\n+\n       describe('directive not present', () => {\n         it('should return input completions for a new attribute', () => {\n           const {ngLS, fileName, cursor, text} = setup(`<input ¦>`, '', DIR_WITH_SELECTED_INPUT);\n@@ -559,7 +622,7 @@ function setup(\n     {\n       name: codePath,\n       contents: `\n-        import {Component, Directive, NgModule, Pipe} from '@angular/core';\n+        import {Component, Directive, NgModule, Pipe, TemplateRef} from '@angular/core';\n \n         @Component({\n           templateUrl: './test.html',"
        }
    ],
    "stats": {
        "total": 352,
        "additions": 267,
        "deletions": 85
    }
}