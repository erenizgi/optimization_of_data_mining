{
    "author": "crisbeto",
    "message": "feat(router): add migration to update calls to navigateByUrl and createUrlTree with invalid parameters (#38825)\n\nIn #38227 the signatures of `navigateByUrl` and `createUrlTree` were updated to exclude unsupported\nproperties from their `extras` parameter. This migration looks for the relevant method calls that\npass in an `extras` parameter and drops the unsupported properties.\n\n**Before:**\n```\nthis._router.navigateByUrl('/', {skipLocationChange: false, fragment: 'foo'});\n```\n\n**After:**\n```\nthis._router.navigateByUrl('/', {\n  /* Removed unsupported properties by Angular migration: fragment. */\n  skipLocationChange: false\n});\n```\n\nThese changes also move the method call detection logic out of the `Renderer2` migration and into\na common place so that it can be reused in other migrations.\n\nPR Close #38825",
    "sha": "7849fdde09be38b09c939a4ac033861daf52ca4e",
    "files": [
        {
            "sha": "4595724e0952d3b789fc0a1bb3b64d37b66ddadb",
            "filename": "packages/core/schematics/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2FBUILD.bazel?ref=7849fdde09be38b09c939a4ac033861daf52ca4e",
            "patch": "@@ -14,6 +14,7 @@ pkg_npm(\n         \"//packages/core/schematics/migrations/missing-injectable\",\n         \"//packages/core/schematics/migrations/module-with-providers\",\n         \"//packages/core/schematics/migrations/move-document\",\n+        \"//packages/core/schematics/migrations/navigation-extras-omissions\",\n         \"//packages/core/schematics/migrations/renderer-to-renderer2\",\n         \"//packages/core/schematics/migrations/static-queries\",\n         \"//packages/core/schematics/migrations/template-var-assignment\","
        },
        {
            "sha": "ce899486eb42fe05d5e865cf578c46615d61addc",
            "filename": "packages/core/schematics/migrations.json",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations.json",
            "raw_url": "https://github.com/angular/angular/raw/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations.json?ref=7849fdde09be38b09c939a4ac033861daf52ca4e",
            "patch": "@@ -44,6 +44,11 @@\n       \"version\": \"10.0.0-beta\",\n       \"description\": \"Undecorated classes with Angular features migration. In version 10, classes that use Angular features and do not have an Angular decorator are no longer supported. Read more about this here: https://v10.angular.io/guide/migration-undecorated-classes\",\n       \"factory\": \"./migrations/undecorated-classes-with-decorated-fields/index\"\n+    },\n+    \"migration-v11-navigation-extras-omissions\": {\n+      \"version\": \"11.0.0-beta\",\n+      \"description\": \"NavigationExtras omissions migration. In version 11, some unsupported properties were omitted from the `extras` parameter of the `Router.navigateByUrl` and `Router.createUrlTree` methods.\",\n+      \"factory\": \"./migrations/navigation-extras-omissions/index\"\n     }\n   }\n }"
        },
        {
            "sha": "6093886f1d34722b2845dcf9388beeaf22815de7",
            "filename": "packages/core/schematics/migrations/google3/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FBUILD.bazel?ref=7849fdde09be38b09c939a4ac033861daf52ca4e",
            "patch": "@@ -9,6 +9,7 @@ ts_library(\n         \"//packages/core/schematics/migrations/dynamic-queries\",\n         \"//packages/core/schematics/migrations/missing-injectable\",\n         \"//packages/core/schematics/migrations/missing-injectable/google3\",\n+        \"//packages/core/schematics/migrations/navigation-extras-omissions\",\n         \"//packages/core/schematics/migrations/renderer-to-renderer2\",\n         \"//packages/core/schematics/migrations/static-queries\",\n         \"//packages/core/schematics/migrations/template-var-assignment\","
        },
        {
            "sha": "7b3492b0e7408301c03f6c9530ea0341a068af8e",
            "filename": "packages/core/schematics/migrations/google3/navigationExtrasOmissionsRule.ts",
            "status": "added",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/angular/angular/blob/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FnavigationExtrasOmissionsRule.ts",
            "raw_url": "https://github.com/angular/angular/raw/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FnavigationExtrasOmissionsRule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FnavigationExtrasOmissionsRule.ts?ref=7849fdde09be38b09c939a4ac033861daf52ca4e",
            "patch": "@@ -0,0 +1,38 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {Replacement, RuleFailure, Rules} from 'tslint';\n+import * as ts from 'typescript';\n+import {findLiteralsToMigrate, migrateLiteral} from '../../migrations/navigation-extras-omissions/util';\n+\n+\n+/** TSLint rule that migrates `navigateByUrl` and `createUrlTree` calls to an updated signature. */\n+export class Rule extends Rules.TypedRule {\n+  applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): RuleFailure[] {\n+    const failures: RuleFailure[] = [];\n+    const typeChecker = program.getTypeChecker();\n+    const printer = ts.createPrinter();\n+    const literalsToMigrate = findLiteralsToMigrate(sourceFile, typeChecker);\n+\n+    literalsToMigrate.forEach((instances, methodName) => instances.forEach(instance => {\n+      const migratedNode = migrateLiteral(methodName, instance);\n+\n+      if (migratedNode !== instance) {\n+        failures.push(new RuleFailure(\n+            sourceFile, instance.getStart(), instance.getEnd(),\n+            'Object used in navigateByUrl or createUrlTree call contains unsupported properties.',\n+            this.ruleName,\n+            new Replacement(\n+                instance.getStart(), instance.getWidth(),\n+                printer.printNode(ts.EmitHint.Unspecified, migratedNode, sourceFile))));\n+      }\n+    }));\n+\n+    return failures;\n+  }\n+}"
        },
        {
            "sha": "4ec020fbf510fb1012672b41e9ded2559ee237e3",
            "filename": "packages/core/schematics/migrations/google3/rendererToRenderer2Rule.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 7,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FrendererToRenderer2Rule.ts",
            "raw_url": "https://github.com/angular/angular/raw/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FrendererToRenderer2Rule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FrendererToRenderer2Rule.ts?ref=7849fdde09be38b09c939a4ac033861daf52ca4e",
            "patch": "@@ -8,10 +8,11 @@\n \n import {Replacement, RuleFailure, Rules} from 'tslint';\n import * as ts from 'typescript';\n+import {getImportSpecifier} from '../../utils/typescript/imports';\n \n import {getHelper, HelperFunction} from '../renderer-to-renderer2/helpers';\n import {migrateExpression, replaceImport} from '../renderer-to-renderer2/migration';\n-import {findCoreImport, findRendererReferences} from '../renderer-to-renderer2/util';\n+import {findRendererReferences, getNamedImports} from '../renderer-to-renderer2/util';\n \n /**\n  * TSLint rule that migrates from `Renderer` to `Renderer2`. More information on how it works:\n@@ -22,18 +23,21 @@ export class Rule extends Rules.TypedRule {\n     const typeChecker = program.getTypeChecker();\n     const printer = ts.createPrinter();\n     const failures: RuleFailure[] = [];\n-    const rendererImport = findCoreImport(sourceFile, 'Renderer');\n+    const rendererImportSpecifier = getImportSpecifier(sourceFile, '@angular/core', 'Renderer');\n+    const rendererImport =\n+        rendererImportSpecifier ? getNamedImports(rendererImportSpecifier) : null;\n \n     // If there are no imports for the `Renderer`, we can exit early.\n-    if (!rendererImport) {\n+    if (!rendererImportSpecifier || !rendererImport) {\n       return failures;\n     }\n \n     const {typedNodes, methodCalls, forwardRefs} =\n-        findRendererReferences(sourceFile, typeChecker, rendererImport);\n+        findRendererReferences(sourceFile, typeChecker, rendererImportSpecifier);\n     const helpersToAdd = new Set<HelperFunction>();\n \n-    failures.push(this._getNamedImportsFailure(rendererImport, sourceFile, printer));\n+    failures.push(\n+        this._getNamedImportsFailure(rendererImport, rendererImportSpecifier, sourceFile, printer));\n     typedNodes.forEach(node => failures.push(this._getTypedNodeFailure(node, sourceFile)));\n     forwardRefs.forEach(node => failures.push(this._getIdentifierNodeFailure(node, sourceFile)));\n \n@@ -61,9 +65,10 @@ export class Rule extends Rules.TypedRule {\n \n   /** Gets a failure for an import of the Renderer. */\n   private _getNamedImportsFailure(\n-      node: ts.NamedImports, sourceFile: ts.SourceFile, printer: ts.Printer): RuleFailure {\n+      node: ts.NamedImports, importSpecifier: ts.ImportSpecifier, sourceFile: ts.SourceFile,\n+      printer: ts.Printer): RuleFailure {\n     const replacementText = printer.printNode(\n-        ts.EmitHint.Unspecified, replaceImport(node, 'Renderer', 'Renderer2'), sourceFile);\n+        ts.EmitHint.Unspecified, replaceImport(node, importSpecifier, 'Renderer2'), sourceFile);\n \n     return new RuleFailure(\n         sourceFile, node.getStart(), node.getEnd(),"
        },
        {
            "sha": "dc793c9702303ccdce9e99a33912fb6c9cb5c71d",
            "filename": "packages/core/schematics/migrations/navigation-extras-omissions/BUILD.bazel",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2FBUILD.bazel?ref=7849fdde09be38b09c939a4ac033861daf52ca4e",
            "patch": "@@ -0,0 +1,18 @@\n+load(\"//tools:defaults.bzl\", \"ts_library\")\n+\n+ts_library(\n+    name = \"navigation-extras-omissions\",\n+    srcs = glob([\"**/*.ts\"]),\n+    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n+    visibility = [\n+        \"//packages/core/schematics:__pkg__\",\n+        \"//packages/core/schematics/migrations/google3:__pkg__\",\n+        \"//packages/core/schematics/test:__pkg__\",\n+    ],\n+    deps = [\n+        \"//packages/core/schematics/utils\",\n+        \"@npm//@angular-devkit/schematics\",\n+        \"@npm//@types/node\",\n+        \"@npm//typescript\",\n+    ],\n+)"
        },
        {
            "sha": "e8236f03adc1a0a3552c4e7a4b0c735f0cb4adb1",
            "filename": "packages/core/schematics/migrations/navigation-extras-omissions/README.md",
            "status": "added",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/angular/angular/blob/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2FREADME.md?ref=7849fdde09be38b09c939a4ac033861daf52ca4e",
            "patch": "@@ -0,0 +1,35 @@\n+## Router.navigateByUrl and Router.createUrlTree extras migration\n+\n+Previously the `extras` parameter of `Router.navigateByUrl` and `Router.createUrlTree` accepted the\n+full `NavigationExtras` object, even though only a subset of properties was supported. This\n+migration removes the unsupported properties from the relevant method call sites.\n+\n+#### Before\n+```ts\n+import { Component } from '@angular/core';\n+import { Router } from '@angular/router';\n+\n+@Component({})\n+export class MyComponent {\n+  constructor(private _router: Router) {}\n+\n+  goHome() {\n+    this._router.navigateByUrl('/', {skipLocationChange: false, fragment: 'foo'});\n+  }\n+}\n+```\n+\n+#### After\n+```ts\n+import { Component } from '@angular/core';\n+import { Router } from '@angular/router';\n+\n+@Component({})\n+export class MyComponent {\n+  constructor(private _router: Router) {}\n+\n+  goHome() {\n+    this._router.navigateByUrl('/', { /* Removed unsupported properties by Angular migration: fragment. */ skipLocationChange: false });\n+  }\n+}\n+```"
        },
        {
            "sha": "c8e7fa8032c6c79cb05bafb94b9daf9275085b21",
            "filename": "packages/core/schematics/migrations/navigation-extras-omissions/index.ts",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/angular/angular/blob/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2Findex.ts?ref=7849fdde09be38b09c939a4ac033861daf52ca4e",
            "patch": "@@ -0,0 +1,61 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\n+import {relative} from 'path';\n+import * as ts from 'typescript';\n+\n+import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n+import {createMigrationProgram} from '../../utils/typescript/compiler_host';\n+import {findLiteralsToMigrate, migrateLiteral} from './util';\n+\n+\n+/** Migration that switches `Router.navigateByUrl` and `Router.createUrlTree` to a new signature. */\n+export default function(): Rule {\n+  return (tree: Tree) => {\n+    const {buildPaths, testPaths} = getProjectTsConfigPaths(tree);\n+    const basePath = process.cwd();\n+    const allPaths = [...buildPaths, ...testPaths];\n+\n+    if (!allPaths.length) {\n+      throw new SchematicsException(\n+          'Could not find any tsconfig file. Cannot migrate ' +\n+          'Router.navigateByUrl and Router.createUrlTree calls.');\n+    }\n+\n+    for (const tsconfigPath of allPaths) {\n+      runNavigationExtrasOmissionsMigration(tree, tsconfigPath, basePath);\n+    }\n+  };\n+}\n+\n+function runNavigationExtrasOmissionsMigration(tree: Tree, tsconfigPath: string, basePath: string) {\n+  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n+  const typeChecker = program.getTypeChecker();\n+  const printer = ts.createPrinter();\n+  const sourceFiles = program.getSourceFiles().filter(\n+      f => !f.isDeclarationFile && !program.isSourceFileFromExternalLibrary(f));\n+\n+  sourceFiles.forEach(sourceFile => {\n+    const literalsToMigrate = findLiteralsToMigrate(sourceFile, typeChecker);\n+    const update = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n+\n+    literalsToMigrate.forEach((instances, methodName) => instances.forEach(instance => {\n+      const migratedNode = migrateLiteral(methodName, instance);\n+\n+      if (migratedNode !== instance) {\n+        update.remove(instance.getStart(), instance.getWidth());\n+        update.insertRight(\n+            instance.getStart(),\n+            printer.printNode(ts.EmitHint.Unspecified, migratedNode, sourceFile));\n+      }\n+    }));\n+\n+    tree.commitUpdate(update);\n+  });\n+}"
        },
        {
            "sha": "cdf8c3c4c9d020ad06f6a6feba08cf88a684497c",
            "filename": "packages/core/schematics/migrations/navigation-extras-omissions/util.ts",
            "status": "added",
            "additions": 125,
            "deletions": 0,
            "changes": 125,
            "blob_url": "https://github.com/angular/angular/blob/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2Futil.ts?ref=7849fdde09be38b09c939a4ac033861daf52ca4e",
            "patch": "@@ -0,0 +1,125 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as ts from 'typescript';\n+\n+import {getImportSpecifier} from '../../utils/typescript/imports';\n+import {isReferenceToImport} from '../../utils/typescript/symbol';\n+\n+/**\n+ * Configures the methods that the migration should be looking for\n+ * and the properties from `NavigationExtras` that should be preserved.\n+ */\n+const methodConfig = new Map<string, Set<string>>([\n+  ['navigateByUrl', new Set<string>(['skipLocationChange', 'replaceUrl', 'state'])],\n+  [\n+    'createUrlTree', new Set<string>([\n+      'relativeTo', 'queryParams', 'fragment', 'preserveQueryParams', 'queryParamsHandling',\n+      'preserveFragment'\n+    ])\n+  ]\n+]);\n+\n+export function migrateLiteral(\n+    methodName: string, node: ts.ObjectLiteralExpression): ts.ObjectLiteralExpression {\n+  const allowedProperties = methodConfig.get(methodName);\n+\n+  if (!allowedProperties) {\n+    throw Error(`Attempting to migrate unconfigured method called ${methodName}.`);\n+  }\n+\n+  const propertiesToKeep: ts.ObjectLiteralElementLike[] = [];\n+  const removedPropertyNames: string[] = [];\n+\n+  node.properties.forEach(property => {\n+    // Only look for regular and shorthand property assignments since resolving things\n+    // like spread operators becomes too complicated for this migration.\n+    if ((ts.isPropertyAssignment(property) || ts.isShorthandPropertyAssignment(property)) &&\n+        (ts.isStringLiteralLike(property.name) || ts.isNumericLiteral(property.name) ||\n+         ts.isIdentifier(property.name))) {\n+      if (allowedProperties.has(property.name.text)) {\n+        propertiesToKeep.push(property);\n+      } else {\n+        removedPropertyNames.push(property.name.text);\n+      }\n+    } else {\n+      propertiesToKeep.push(property);\n+    }\n+  });\n+\n+  // Don't modify the node if there's nothing to remove.\n+  if (removedPropertyNames.length === 0) {\n+    return node;\n+  }\n+\n+  // Note that the trailing/leading spaces are necessary so the comment looks good.\n+  const removalComment =\n+      ` Removed unsupported properties by Angular migration: ${removedPropertyNames.join(', ')}. `;\n+\n+  if (propertiesToKeep.length > 0) {\n+    propertiesToKeep[0] = addUniqueLeadingComment(propertiesToKeep[0], removalComment);\n+    return ts.createObjectLiteral(propertiesToKeep);\n+  } else {\n+    return addUniqueLeadingComment(ts.createObjectLiteral(propertiesToKeep), removalComment);\n+  }\n+}\n+\n+export function findLiteralsToMigrate(sourceFile: ts.SourceFile, typeChecker: ts.TypeChecker) {\n+  const results = new Map<string, Set<ts.ObjectLiteralExpression>>(\n+      Array.from(methodConfig.keys(), key => [key, new Set()]));\n+  const routerImport = getImportSpecifier(sourceFile, '@angular/router', 'Router');\n+  const seenLiterals = new Map<ts.ObjectLiteralExpression, string>();\n+\n+  if (routerImport) {\n+    sourceFile.forEachChild(function visitNode(node: ts.Node) {\n+      // Look for calls that look like `foo.<method to migrate>` with more than one parameter.\n+      if (ts.isCallExpression(node) && node.arguments.length > 1 &&\n+          ts.isPropertyAccessExpression(node.expression) && ts.isIdentifier(node.expression.name) &&\n+          methodConfig.has(node.expression.name.text)) {\n+        // Check whether the type of the object on which the\n+        // function is called refers to the Router import.\n+        if (isReferenceToImport(typeChecker, node.expression.expression, routerImport)) {\n+          const methodName = node.expression.name.text;\n+          const parameterDeclaration =\n+              typeChecker.getTypeAtLocation(node.arguments[1]).getSymbol()?.valueDeclaration;\n+\n+          // Find the source of the object literal.\n+          if (parameterDeclaration && ts.isObjectLiteralExpression(parameterDeclaration)) {\n+            if (!seenLiterals.has(parameterDeclaration)) {\n+              results.get(methodName)!.add(parameterDeclaration);\n+              seenLiterals.set(parameterDeclaration, methodName);\n+              // If the same literal has been passed into multiple different methods, we can't\n+              // migrate it, because the supported properties are different. When we detect such\n+              // a case, we drop it from the results so that it gets ignored. If it's used multiple\n+              // times for the same method, it can still be migrated.\n+            } else if (seenLiterals.get(parameterDeclaration) !== methodName) {\n+              results.forEach(literals => literals.delete(parameterDeclaration));\n+            }\n+          }\n+        }\n+      } else {\n+        node.forEachChild(visitNode);\n+      }\n+    });\n+  }\n+\n+  return results;\n+}\n+\n+/** Adds a leading comment to a node, if the node doesn't have such a comment already. */\n+function addUniqueLeadingComment<T extends ts.Node>(node: T, comment: string): T {\n+  const existingComments = ts.getSyntheticLeadingComments(node);\n+\n+  // This logic is primarily to ensure that we don't add the same comment multiple\n+  // times when tslint runs over the same file again with outdated information.\n+  if (!existingComments || existingComments.every(c => c.text !== comment)) {\n+    return ts.addSyntheticLeadingComment(node, ts.SyntaxKind.MultiLineCommentTrivia, comment);\n+  }\n+\n+  return node;\n+}"
        },
        {
            "sha": "b40d044b04890ed6fa7b083aee9ee7d08671e6c1",
            "filename": "packages/core/schematics/migrations/renderer-to-renderer2/index.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Findex.ts?ref=7849fdde09be38b09c939a4ac033861daf52ca4e",
            "patch": "@@ -12,10 +12,11 @@ import * as ts from 'typescript';\n \n import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n import {createMigrationProgram} from '../../utils/typescript/compiler_host';\n+import {getImportSpecifier} from '../../utils/typescript/imports';\n \n import {getHelper, HelperFunction} from './helpers';\n import {migrateExpression, replaceImport} from './migration';\n-import {findCoreImport, findRendererReferences} from './util';\n+import {findRendererReferences, getNamedImports} from './util';\n \n const MODULE_AUGMENTATION_FILENAME = 'ɵɵRENDERER_MIGRATION_CORE_AUGMENTATION.d.ts';\n \n@@ -61,15 +62,17 @@ function runRendererToRenderer2Migration(tree: Tree, tsconfigPath: string, baseP\n       f => !f.isDeclarationFile && !program.isSourceFileFromExternalLibrary(f));\n \n   sourceFiles.forEach(sourceFile => {\n-    const rendererImport = findCoreImport(sourceFile, 'Renderer');\n+    const rendererImportSpecifier = getImportSpecifier(sourceFile, '@angular/core', 'Renderer');\n+    const rendererImport =\n+        rendererImportSpecifier ? getNamedImports(rendererImportSpecifier) : null;\n \n     // If there are no imports for the `Renderer`, we can exit early.\n-    if (!rendererImport) {\n+    if (!rendererImportSpecifier || !rendererImport) {\n       return;\n     }\n \n     const {typedNodes, methodCalls, forwardRefs} =\n-        findRendererReferences(sourceFile, typeChecker, rendererImport);\n+        findRendererReferences(sourceFile, typeChecker, rendererImportSpecifier);\n     const update = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n     const helpersToAdd = new Set<HelperFunction>();\n \n@@ -78,8 +81,8 @@ function runRendererToRenderer2Migration(tree: Tree, tsconfigPath: string, baseP\n     update.insertRight(\n         rendererImport.getStart(),\n         printer.printNode(\n-            ts.EmitHint.Unspecified, replaceImport(rendererImport, 'Renderer', 'Renderer2'),\n-            sourceFile));\n+            ts.EmitHint.Unspecified,\n+            replaceImport(rendererImport, rendererImportSpecifier, 'Renderer2'), sourceFile));\n \n     // Change the method parameter and property types to `Renderer2`.\n     typedNodes.forEach(node => {"
        },
        {
            "sha": "49587c4b83faf2348588102ce528cc7098e7f498",
            "filename": "packages/core/schematics/migrations/renderer-to-renderer2/migration.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 11,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Fmigration.ts",
            "raw_url": "https://github.com/angular/angular/raw/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Fmigration.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Fmigration.ts?ref=7849fdde09be38b09c939a4ac033861daf52ca4e",
            "patch": "@@ -9,31 +9,28 @@\n import * as ts from 'typescript';\n \n import {HelperFunction} from './helpers';\n-import {findImportSpecifier} from './util';\n \n /** A call expression that is based on a property access. */\n type PropertyAccessCallExpression = ts.CallExpression&{expression: ts.PropertyAccessExpression};\n \n /** Replaces an import inside an import statement with a different one. */\n-export function replaceImport(node: ts.NamedImports, oldImport: string, newImport: string) {\n-  const isAlreadyImported = findImportSpecifier(node.elements, newImport);\n+export function replaceImport(\n+    node: ts.NamedImports, existingImport: ts.ImportSpecifier, newImportName: string) {\n+  const isAlreadyImported = node.elements.find(element => {\n+    const {name, propertyName} = element;\n+    return propertyName ? propertyName.text === newImportName : name.text === newImportName;\n+  });\n \n   if (isAlreadyImported) {\n     return node;\n   }\n \n-  const existingImport = findImportSpecifier(node.elements, oldImport);\n-\n-  if (!existingImport) {\n-    throw new Error(`Could not find an import to replace using ${oldImport}.`);\n-  }\n-\n   return ts.updateNamedImports(node, [\n     ...node.elements.filter(current => current !== existingImport),\n     // Create a new import while trying to preserve the alias of the old one.\n     ts.createImportSpecifier(\n-        existingImport.propertyName ? ts.createIdentifier(newImport) : undefined,\n-        existingImport.propertyName ? existingImport.name : ts.createIdentifier(newImport))\n+        existingImport.propertyName ? ts.createIdentifier(newImportName) : undefined,\n+        existingImport.propertyName ? existingImport.name : ts.createIdentifier(newImportName))\n   ]);\n }\n "
        },
        {
            "sha": "6d22c4fa0135757029c3f62ad7fc8703fcf451e2",
            "filename": "packages/core/schematics/migrations/renderer-to-renderer2/util.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 49,
            "changes": 68,
            "blob_url": "https://github.com/angular/angular/blob/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Futil.ts?ref=7849fdde09be38b09c939a4ac033861daf52ca4e",
            "patch": "@@ -8,38 +8,40 @@\n \n import * as ts from 'typescript';\n \n+import {getImportSpecifier} from '../../utils/typescript/imports';\n+import {isReferenceToImport} from '../../utils/typescript/symbol';\n+\n /**\n  * Finds typed nodes (e.g. function parameters or class properties) that are referencing the old\n  * `Renderer`, as well as calls to the `Renderer` methods.\n  */\n export function findRendererReferences(\n-    sourceFile: ts.SourceFile, typeChecker: ts.TypeChecker, rendererImport: ts.NamedImports) {\n+    sourceFile: ts.SourceFile, typeChecker: ts.TypeChecker,\n+    rendererImportSpecifier: ts.ImportSpecifier) {\n   const typedNodes = new Set<ts.ParameterDeclaration|ts.PropertyDeclaration|ts.AsExpression>();\n   const methodCalls = new Set<ts.CallExpression>();\n   const forwardRefs = new Set<ts.Identifier>();\n-  const importSpecifier = findImportSpecifier(rendererImport.elements, 'Renderer');\n-  const forwardRefImport = findCoreImport(sourceFile, 'forwardRef');\n-  const forwardRefSpecifier =\n-      forwardRefImport ? findImportSpecifier(forwardRefImport.elements, 'forwardRef') : null;\n+  const forwardRefSpecifier = getImportSpecifier(sourceFile, '@angular/core', 'forwardRef');\n \n   ts.forEachChild(sourceFile, function visitNode(node: ts.Node) {\n     if ((ts.isParameter(node) || ts.isPropertyDeclaration(node)) &&\n-        isReferenceToImport(typeChecker, node.name, importSpecifier)) {\n+        isReferenceToImport(typeChecker, node.name, rendererImportSpecifier)) {\n       typedNodes.add(node);\n     } else if (\n-        ts.isAsExpression(node) && isReferenceToImport(typeChecker, node.type, importSpecifier)) {\n+        ts.isAsExpression(node) &&\n+        isReferenceToImport(typeChecker, node.type, rendererImportSpecifier)) {\n       typedNodes.add(node);\n     } else if (ts.isCallExpression(node)) {\n       if (ts.isPropertyAccessExpression(node.expression) &&\n-          isReferenceToImport(typeChecker, node.expression.expression, importSpecifier)) {\n+          isReferenceToImport(typeChecker, node.expression.expression, rendererImportSpecifier)) {\n         methodCalls.add(node);\n       } else if (\n           // If we're dealing with a forwardRef that's returning a Renderer.\n           forwardRefSpecifier && ts.isIdentifier(node.expression) &&\n           isReferenceToImport(typeChecker, node.expression, forwardRefSpecifier) &&\n           node.arguments.length) {\n         const rendererIdentifier =\n-            findRendererIdentifierInForwardRef(typeChecker, node, importSpecifier);\n+            findRendererIdentifierInForwardRef(typeChecker, node, rendererImportSpecifier);\n         if (rendererIdentifier) {\n           forwardRefs.add(rendererIdentifier);\n         }\n@@ -52,59 +54,27 @@ export function findRendererReferences(\n   return {typedNodes, methodCalls, forwardRefs};\n }\n \n-/** Finds the import from @angular/core that has a symbol with a particular name. */\n-export function findCoreImport(sourceFile: ts.SourceFile, symbolName: string): ts.NamedImports|\n-    null {\n-  // Only look through the top-level imports.\n-  for (const node of sourceFile.statements) {\n-    if (!ts.isImportDeclaration(node) || !ts.isStringLiteral(node.moduleSpecifier) ||\n-        node.moduleSpecifier.text !== '@angular/core') {\n-      continue;\n-    }\n-\n-    const namedBindings = node.importClause && node.importClause.namedBindings;\n-\n-    if (!namedBindings || !ts.isNamedImports(namedBindings)) {\n-      continue;\n-    }\n+/** Gets the closest `NamedImports` to an `ImportSpecifier`. */\n+export function getNamedImports(specifier: ts.ImportSpecifier): ts.NamedImports|null {\n+  let current: ts.Node = specifier;\n \n-    if (findImportSpecifier(namedBindings.elements, symbolName)) {\n-      return namedBindings;\n+  while (current && !ts.isSourceFile(current)) {\n+    if (ts.isNamedImports(current)) {\n+      return current;\n     }\n+    current = current.parent;\n   }\n \n   return null;\n }\n \n-/** Finds an import specifier with a particular name, accounting for aliases. */\n-export function findImportSpecifier(\n-    elements: ts.NodeArray<ts.ImportSpecifier>, importName: string) {\n-  return elements.find(element => {\n-    const {name, propertyName} = element;\n-    return propertyName ? propertyName.text === importName : name.text === importName;\n-  }) ||\n-      null;\n-}\n-\n-/** Checks whether a node is referring to an import spcifier. */\n-function isReferenceToImport(\n-    typeChecker: ts.TypeChecker, node: ts.Node, importSpecifier: ts.ImportSpecifier|null): boolean {\n-  if (importSpecifier) {\n-    const nodeSymbol = typeChecker.getTypeAtLocation(node).getSymbol();\n-    const importSymbol = typeChecker.getTypeAtLocation(importSpecifier).getSymbol();\n-    return !!(nodeSymbol && importSymbol) &&\n-        nodeSymbol.valueDeclaration === importSymbol.valueDeclaration;\n-  }\n-  return false;\n-}\n-\n /** Finds the identifier referring to the `Renderer` inside a `forwardRef` call expression. */\n function findRendererIdentifierInForwardRef(\n     typeChecker: ts.TypeChecker, node: ts.CallExpression,\n     rendererImport: ts.ImportSpecifier|null): ts.Identifier|null {\n   const firstArg = node.arguments[0];\n \n-  if (ts.isArrowFunction(firstArg)) {\n+  if (ts.isArrowFunction(firstArg) && rendererImport) {\n     // Check if the function is `forwardRef(() => Renderer)`.\n     if (ts.isIdentifier(firstArg.body) &&\n         isReferenceToImport(typeChecker, firstArg.body, rendererImport)) {"
        },
        {
            "sha": "2030fef2d61ba2ae890695eee269feac53a5940f",
            "filename": "packages/core/schematics/test/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel?ref=7849fdde09be38b09c939a4ac033861daf52ca4e",
            "patch": "@@ -12,6 +12,7 @@ ts_library(\n         \"//packages/core/schematics/migrations/missing-injectable\",\n         \"//packages/core/schematics/migrations/module-with-providers\",\n         \"//packages/core/schematics/migrations/move-document\",\n+        \"//packages/core/schematics/migrations/navigation-extras-omissions\",\n         \"//packages/core/schematics/migrations/renderer-to-renderer2\",\n         \"//packages/core/schematics/migrations/static-queries\",\n         \"//packages/core/schematics/migrations/template-var-assignment\","
        },
        {
            "sha": "42325de7c02ecdcea73346216aaf534f0349af63",
            "filename": "packages/core/schematics/test/google3/navigation_extras_omissions_spec.ts",
            "status": "added",
            "additions": 334,
            "deletions": 0,
            "changes": 334,
            "blob_url": "https://github.com/angular/angular/blob/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fnavigation_extras_omissions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fnavigation_extras_omissions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fnavigation_extras_omissions_spec.ts?ref=7849fdde09be38b09c939a4ac033861daf52ca4e",
            "patch": "@@ -0,0 +1,334 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {readFileSync, writeFileSync} from 'fs';\n+import {dirname, join} from 'path';\n+import * as shx from 'shelljs';\n+import {Configuration, Linter} from 'tslint';\n+\n+describe('Google3 NavigationExtras omissions TSLint rule', () => {\n+  const rulesDirectory =\n+      dirname(require.resolve('../../migrations/google3/navigationExtrasOmissionsRule'));\n+\n+  let tmpDir: string;\n+\n+  beforeEach(() => {\n+    tmpDir = join(process.env['TEST_TMPDIR']!, 'google3-test');\n+    shx.mkdir('-p', tmpDir);\n+\n+    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n+    writeFile('router.d.ts', `\n+      export declare class Router {\n+        navigateByUrl(url: string, extras?: any);\n+        createUrlTree(commands: any[], extras?: any);\n+      }\n+    `);\n+\n+    writeFile('tsconfig.json', JSON.stringify({\n+      compilerOptions: {\n+        module: 'es2015',\n+        baseUrl: './',\n+        paths: {\n+          '@angular/router': ['router.d.ts'],\n+        }\n+      },\n+    }));\n+  });\n+\n+  afterEach(() => shx.rm('-r', tmpDir));\n+\n+  function runTSLint(fix: boolean) {\n+    const program = Linter.createProgram(join(tmpDir, 'tsconfig.json'));\n+    const linter = new Linter({fix, rulesDirectory: [rulesDirectory]}, program);\n+    const config = Configuration.parseConfigFile({rules: {'navigation-extras-omissions': true}});\n+\n+    program.getRootFileNames().forEach(fileName => {\n+      linter.lint(fileName, program.getSourceFile(fileName)!.getFullText(), config);\n+    });\n+\n+    return linter;\n+  }\n+\n+  function writeFile(fileName: string, content: string) {\n+    writeFileSync(join(tmpDir, fileName), content);\n+  }\n+\n+  function getFile(fileName: string) {\n+    return readFileSync(join(tmpDir, fileName), 'utf8');\n+  }\n+\n+  it('should flag objects with invalid properties used inside the relevant method calls', () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      class Navigator {\n+        constructor(private _router: Router) {}\n+\n+        goHome() {\n+          this._router.navigateByUrl('/', {fragment: 'foo'});\n+        }\n+\n+        createTree() {\n+          return this._router.createUrlTree(['/'], {state: {}});\n+        }\n+\n+        goAway() {\n+          this._router.navigateByUrl('/away');\n+        }\n+      }\n+    `);\n+\n+    const linter = runTSLint(false);\n+    const failures = linter.getResult().failures.map(failure => failure.getFailure());\n+\n+    expect(failures.length).toBe(2);\n+    expect(failures[0])\n+        .toMatch(\n+            /Object used in navigateByUrl or createUrlTree call contains unsupported properties/);\n+    expect(failures[1])\n+        .toMatch(\n+            /Object used in navigateByUrl or createUrlTree call contains unsupported properties/);\n+  });\n+\n+  it('should not change calls with a single argument', () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      class Navigator {\n+        constructor(private _router: Router) {}\n+\n+        goHome() {\n+          this._router.navigateByUrl('/');\n+        }\n+      }\n+\n+      function createTree(router: Router) {\n+        return router.createUrlTree(['/']);\n+      }\n+    `);\n+\n+    runTSLint(true);\n+\n+    const content = getFile('/index.ts');\n+    expect(content).toContain(`this._router.navigateByUrl('/');`);\n+    expect(content).toContain(`return router.createUrlTree(['/']);`);\n+  });\n+\n+  it('should not change calls with an empty object literal', () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      class Navigator {\n+        constructor(private _router: Router) {}\n+\n+        goHome() {\n+          this._router.navigateByUrl('/', {});\n+        }\n+      }\n+\n+      function createTree(router: Router) {\n+        return router.createUrlTree(['/'], {});\n+      }\n+    `);\n+\n+    runTSLint(true);\n+\n+    const content = getFile('/index.ts');\n+    expect(content).toContain(`this._router.navigateByUrl('/', {});`);\n+    expect(content).toContain(`return router.createUrlTree(['/'], {});`);\n+  });\n+\n+  it('should not change objects that are used in multiple different methods', () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      const config = {replaceUrl: true, fragment: 'foo', state: {}};\n+\n+      class Navigator {\n+        constructor(private _router: Router) {}\n+\n+        goHome() {\n+          this._router.navigateByUrl('/', config);\n+          return this._router.createUrlTree(['/'], config);\n+        }\n+      }\n+    `);\n+\n+    runTSLint(true);\n+\n+    const content = getFile('/index.ts');\n+    expect(content).toContain(`const config = {replaceUrl: true, fragment: 'foo', state: {}};`);\n+  });\n+\n+  it('should preserve calls if the router does not come from @angular/router', () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@custom/router';\n+\n+      function createTree(router: Router) {\n+        return router.createUrlTree(['/'], {foo: 1, bar: 2});\n+      }\n+    `);\n+\n+    runTSLint(true);\n+\n+    const content = getFile('/index.ts');\n+    expect(content).toContain(`return router.createUrlTree(['/'], {foo: 1, bar: 2});`);\n+  });\n+\n+  it('should change invalid navigateByUrl calls', () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      class Navigator {\n+        constructor(private _router: Router) {}\n+\n+        goHome() {\n+          this._router.navigateByUrl('/', {preserveFragment: false, skipLocationChange: false, fragment: 'foo'});\n+        }\n+      }\n+    `);\n+\n+    runTSLint(true);\n+\n+    const content = getFile('/index.ts');\n+    expect(content).toContain(\n+        `this._router.navigateByUrl('/', { /* Removed unsupported properties by Angular migration: preserveFragment, fragment. */ skipLocationChange: false });`);\n+  });\n+\n+  it('should change invalid navigateByUrl calls', () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      function createTree(router: Router) {\n+        return router.createUrlTree(['/'], {replaceUrl: true, preserveFragment: true, state: {}});\n+      }\n+    `);\n+\n+    runTSLint(true);\n+\n+    const content = getFile('/index.ts');\n+    expect(content).toContain(\n+        `return router.createUrlTree(['/'], { /* Removed unsupported properties by Angular migration: replaceUrl, state. */ preserveFragment: true });`);\n+  });\n+\n+  it('should set the comment outside the object if all properties were removed', () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      function navigate(router: Router) {\n+        router.navigateByUrl('/', {fragment: 'foo'});\n+      }\n+    `);\n+\n+    runTSLint(true);\n+\n+    const content = getFile('/index.ts');\n+    expect(content).toContain(\n+        `router.navigateByUrl('/', /* Removed unsupported properties by Angular migration: fragment. */ {});`);\n+  });\n+\n+  it('should migrate object literals defined as variables', () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      const config = {skipLocationChange: false, fragment: 'foo'};\n+      const proxy = config;\n+\n+      function navigate(router: Router) {\n+        router.navigateByUrl('/', proxy);\n+      }\n+    `);\n+\n+    runTSLint(true);\n+\n+    const content = getFile('/index.ts');\n+    expect(content).toContain(\n+        `const config = { /* Removed unsupported properties by Angular migration: fragment. */ skipLocationChange: false };`);\n+    expect(content).toContain(`const proxy = config;`);\n+    expect(content).toContain(`router.navigateByUrl('/', proxy);`);\n+  });\n+\n+  it('should pick up calls where the router is returned by a function', () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      function navigate(router: Router) {\n+        getRouter().navigateByUrl('/', {fragment: 'foo'});\n+      }\n+\n+      function getRouter() {\n+        return {} as Router;\n+      }\n+    `);\n+\n+    runTSLint(true);\n+\n+    const content = getFile('/index.ts');\n+    expect(content).toContain(\n+        `getRouter().navigateByUrl('/', /* Removed unsupported properties by Angular migration: fragment. */ {});`);\n+  });\n+\n+  it('should pick up calls where the router is aliased', () => {\n+    writeFile('/index.ts', `\n+      import {Router as AliasedRouter} from '@angular/router';\n+\n+      function navigate(router: AliasedRouter) {\n+        router.navigateByUrl('/', {fragment: 'foo'});\n+      }\n+    `);\n+\n+    runTSLint(true);\n+\n+    const content = getFile('/index.ts');\n+    expect(content).toContain(\n+        `router.navigateByUrl('/', /* Removed unsupported properties by Angular migration: fragment. */ {});`);\n+  });\n+\n+  it('should preserve object spread assignments', () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      function navigate(router: Router) {\n+        const overrides = {foo: 1};\n+        router.navigateByUrl('/', {replaceUrl: true, fragment: 'foo', ...overrides});\n+      }\n+    `);\n+\n+    runTSLint(true);\n+\n+    const content = getFile('/index.ts');\n+    expect(content).toContain(\n+        `router.navigateByUrl('/', { /* Removed unsupported properties by Angular migration: fragment. */ replaceUrl: true, ...overrides });`);\n+  });\n+\n+  it('should migrate objects that are used in multiple calls of the same method', () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      const config = {skipLocationChange: false, fragment: 'foo'};\n+\n+      class Navigator {\n+        constructor(private _router: Router) {}\n+\n+        goHome() {\n+          this._router.navigateByUrl('/', config);\n+        }\n+\n+        goFish() {\n+          this._router.navigateByUrl('/fish', config);\n+        }\n+      }\n+    `);\n+\n+    runTSLint(true);\n+\n+    const content = getFile('/index.ts');\n+    expect(content).toContain(\n+        `const config = { /* Removed unsupported properties by Angular migration: fragment. */ skipLocationChange: false };`);\n+  });\n+});"
        },
        {
            "sha": "c71620cf5f415cee2da35a86685e9c547dc596d9",
            "filename": "packages/core/schematics/test/google3/renderer_to_renderer2_spec.ts",
            "status": "modified",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Frenderer_to_renderer2_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Frenderer_to_renderer2_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Frenderer_to_renderer2_spec.ts?ref=7849fdde09be38b09c939a4ac033861daf52ca4e",
            "patch": "@@ -105,6 +105,26 @@ describe('Google3 Renderer to Renderer2 TSLint rule', () => {\n     expect(content).toContain('(renderer: Renderer2)');\n   });\n \n+  it('should not change Renderer imports if Renderer2 is already imported', () => {\n+    writeFile('/index.ts', `\n+        import { Renderer, Component, Renderer2 } from '@angular/core';\n+\n+        @Component({template: ''})\n+        export class MyComp {\n+          public renderer: Renderer;\n+\n+          constructor(renderer: Renderer) {\n+            this.renderer = renderer;\n+          }\n+        }\n+      `);\n+\n+    runTSLint(true);\n+    const content = getFile('index.ts');\n+\n+    expect(content).toContain(`import { Renderer, Component, Renderer2 } from '@angular/core';`);\n+  });\n+\n   it('should change Renderer inside single-line forwardRefs to Renderer2', () => {\n     writeFile('/index.ts', `\n       import { Renderer, Component, forwardRef, Inject } from '@angular/core';"
        },
        {
            "sha": "3133a8cf6812d570c42c0b042794bb8b664d1f96",
            "filename": "packages/core/schematics/test/navigation_extras_omissions_migration_spec.ts",
            "status": "added",
            "additions": 302,
            "deletions": 0,
            "changes": 302,
            "blob_url": "https://github.com/angular/angular/blob/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Ftest%2Fnavigation_extras_omissions_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Ftest%2Fnavigation_extras_omissions_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fnavigation_extras_omissions_migration_spec.ts?ref=7849fdde09be38b09c939a4ac033861daf52ca4e",
            "patch": "@@ -0,0 +1,302 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n+import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n+import {HostTree} from '@angular-devkit/schematics';\n+import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n+import * as shx from 'shelljs';\n+\n+describe('NavigationExtras omissions migration', () => {\n+  let runner: SchematicTestRunner;\n+  let host: TempScopedNodeJsSyncHost;\n+  let tree: UnitTestTree;\n+  let tmpDirPath: string;\n+  let previousWorkingDir: string;\n+\n+  beforeEach(() => {\n+    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n+    host = new TempScopedNodeJsSyncHost();\n+    tree = new UnitTestTree(new HostTree(host));\n+\n+    writeFile('/tsconfig.json', JSON.stringify({\n+      compilerOptions: {\n+        lib: ['es2015'],\n+        strictNullChecks: true,\n+      },\n+    }));\n+    writeFile('/angular.json', JSON.stringify({\n+      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n+    }));\n+    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n+    writeFile('/node_modules/@angular/router/index.d.ts', `\n+      export declare class Router {\n+        navigateByUrl(url: string, extras?: any);\n+        createUrlTree(commands: any[], extras?: any);\n+      }\n+    `);\n+\n+    previousWorkingDir = shx.pwd();\n+    tmpDirPath = getSystemPath(host.root);\n+\n+    // Switch into the temporary directory path. This allows us to run\n+    // the schematic against our custom unit test tree.\n+    shx.cd(tmpDirPath);\n+  });\n+\n+  afterEach(() => {\n+    shx.cd(previousWorkingDir);\n+    shx.rm('-r', tmpDirPath);\n+  });\n+\n+  it('should not change calls with a single argument', async () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      class Navigator {\n+        constructor(private _router: Router) {}\n+\n+        goHome() {\n+          this._router.navigateByUrl('/');\n+        }\n+      }\n+\n+      function createTree(router: Router) {\n+        return router.createUrlTree(['/']);\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/index.ts');\n+    expect(content).toContain(`this._router.navigateByUrl('/');`);\n+    expect(content).toContain(`return router.createUrlTree(['/']);`);\n+  });\n+\n+  it('should not change calls with an empty object literal', async () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      class Navigator {\n+        constructor(private _router: Router) {}\n+\n+        goHome() {\n+          this._router.navigateByUrl('/', {});\n+        }\n+      }\n+\n+      function createTree(router: Router) {\n+        return router.createUrlTree(['/'], {});\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/index.ts');\n+    expect(content).toContain(`this._router.navigateByUrl('/', {});`);\n+    expect(content).toContain(`return router.createUrlTree(['/'], {});`);\n+  });\n+\n+  it('should not change objects that are used in multiple different methods', async () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      const config = {replaceUrl: true, fragment: 'foo', state: {}};\n+\n+      class Navigator {\n+        constructor(private _router: Router) {}\n+\n+        goHome() {\n+          this._router.navigateByUrl('/', config);\n+          return this._router.createUrlTree(['/'], config);\n+        }\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/index.ts');\n+    expect(content).toContain(`const config = {replaceUrl: true, fragment: 'foo', state: {}};`);\n+  });\n+\n+  it('should preserve calls if the router does not come from @angular/router', async () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@custom/router';\n+\n+      function createTree(router: Router) {\n+        return router.createUrlTree(['/'], {foo: 1, bar: 2});\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/index.ts');\n+    expect(content).toContain(`return router.createUrlTree(['/'], {foo: 1, bar: 2});`);\n+  });\n+\n+  it('should change invalid navigateByUrl calls', async () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      class Navigator {\n+        constructor(private _router: Router) {}\n+\n+        goHome() {\n+          this._router.navigateByUrl('/', {preserveFragment: false, skipLocationChange: false, fragment: 'foo'});\n+        }\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/index.ts');\n+    expect(content).toContain(\n+        `this._router.navigateByUrl('/', { /* Removed unsupported properties by Angular migration: preserveFragment, fragment. */ skipLocationChange: false });`);\n+  });\n+\n+  it('should change invalid navigateByUrl calls', async () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      function createTree(router: Router) {\n+        return router.createUrlTree(['/'], {replaceUrl: true, preserveFragment: true, state: {}});\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/index.ts');\n+    expect(content).toContain(\n+        `return router.createUrlTree(['/'], { /* Removed unsupported properties by Angular migration: replaceUrl, state. */ preserveFragment: true });`);\n+  });\n+\n+  it('should set the comment outside the object if all properties were removed', async () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      function navigate(router: Router) {\n+        router.navigateByUrl('/', {fragment: 'foo'});\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/index.ts');\n+    expect(content).toContain(\n+        `router.navigateByUrl('/', /* Removed unsupported properties by Angular migration: fragment. */ {});`);\n+  });\n+\n+  it('should migrate object literals defined as variables', async () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      const config = {skipLocationChange: false, fragment: 'foo'};\n+      const proxy = config;\n+\n+      function navigate(router: Router) {\n+        router.navigateByUrl('/', proxy);\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/index.ts');\n+    expect(content).toContain(\n+        `const config = { /* Removed unsupported properties by Angular migration: fragment. */ skipLocationChange: false };`);\n+    expect(content).toContain(`const proxy = config;`);\n+    expect(content).toContain(`router.navigateByUrl('/', proxy);`);\n+  });\n+\n+  it('should pick up calls where the router is returned by a function', async () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      function navigate(router: Router) {\n+        getRouter().navigateByUrl('/', {fragment: 'foo'});\n+      }\n+\n+      function getRouter() {\n+        return {} as Router;\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/index.ts');\n+    expect(content).toContain(\n+        `getRouter().navigateByUrl('/', /* Removed unsupported properties by Angular migration: fragment. */ {});`);\n+  });\n+\n+  it('should pick up calls where the router is aliased', async () => {\n+    writeFile('/index.ts', `\n+      import {Router as AliasedRouter} from '@angular/router';\n+\n+      function navigate(router: AliasedRouter) {\n+        router.navigateByUrl('/', {fragment: 'foo'});\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/index.ts');\n+    expect(content).toContain(\n+        `router.navigateByUrl('/', /* Removed unsupported properties by Angular migration: fragment. */ {});`);\n+  });\n+\n+  it('should preserve object spread assignments', async () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      function navigate(router: Router) {\n+        const overrides = {foo: 1};\n+        router.navigateByUrl('/', {replaceUrl: true, fragment: 'foo', ...overrides});\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/index.ts');\n+    expect(content).toContain(\n+        `router.navigateByUrl('/', { /* Removed unsupported properties by Angular migration: fragment. */ replaceUrl: true, ...overrides });`);\n+  });\n+\n+  it('should migrate objects that are used in multiple calls of the same method', async () => {\n+    writeFile('/index.ts', `\n+      import {Router} from '@angular/router';\n+\n+      const config = {skipLocationChange: false, fragment: 'foo'};\n+\n+      class Navigator {\n+        constructor(private _router: Router) {}\n+\n+        goHome() {\n+          this._router.navigateByUrl('/', config);\n+        }\n+\n+        goFish() {\n+          this._router.navigateByUrl('/fish', config);\n+        }\n+      }\n+    `);\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/index.ts');\n+    expect(content).toContain(\n+        `const config = { /* Removed unsupported properties by Angular migration: fragment. */ skipLocationChange: false };`);\n+  });\n+\n+  function writeFile(filePath: string, contents: string) {\n+    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n+  }\n+\n+  function runMigration() {\n+    return runner.runSchematicAsync('migration-v11-navigation-extras-omissions', {}, tree)\n+        .toPromise();\n+  }\n+});"
        },
        {
            "sha": "6312105868206c3e3a7d86589917982d3ada05b2",
            "filename": "packages/core/schematics/test/renderer_to_renderer2_migration_spec.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Ftest%2Frenderer_to_renderer2_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Ftest%2Frenderer_to_renderer2_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Frenderer_to_renderer2_migration_spec.ts?ref=7849fdde09be38b09c939a4ac033861daf52ca4e",
            "patch": "@@ -99,6 +99,21 @@ describe('Renderer to Renderer2 migration', () => {\n       expect(content).toContain(`import { Component } from '@angular/core';`);\n       expect(content).toContain(`import { Renderer } from './my-renderer';`);\n     });\n+\n+    it('should not change imports if Renderer2 was already imported', async () => {\n+      writeFile('/index.ts', `\n+          import { Renderer, Component, Renderer2 } from '@angular/core';\n+\n+          @Component({template: ''})\n+          export class MyComp {\n+            constructor(renderer: Renderer) {}\n+          }\n+        `);\n+\n+      await runMigration();\n+      expect(tree.readContent('/index.ts'))\n+          .toContain(`import { Renderer, Component, Renderer2 } from '@angular/core';`);\n+    });\n   });\n \n   describe('type renaming', () => {"
        },
        {
            "sha": "152c21d292aaeadd893b8cc26d743468e94a4f42",
            "filename": "packages/core/schematics/utils/typescript/imports.ts",
            "status": "modified",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Futils%2Ftypescript%2Fimports.ts",
            "raw_url": "https://github.com/angular/angular/raw/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Futils%2Ftypescript%2Fimports.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Futils%2Ftypescript%2Fimports.ts?ref=7849fdde09be38b09c939a4ac033861daf52ca4e",
            "patch": "@@ -42,3 +42,43 @@ export function getImportOfIdentifier(typeChecker: ts.TypeChecker, node: ts.Iden\n     node: importDecl\n   };\n }\n+\n+\n+/**\n+ * Gets a top-level import specifier with a specific name that is imported from a particular module.\n+ * E.g. given a file that looks like:\n+ *\n+ * ```\n+ * import { Component, Directive } from '@angular/core';\n+ * import { Foo } from './foo';\n+ * ```\n+ *\n+ * Calling `getImportSpecifier(sourceFile, '@angular/core', 'Directive')` will yield the node\n+ * referring to `Directive` in the top import.\n+ *\n+ * @param sourceFile File in which to look for imports.\n+ * @param moduleName Name of the import's module.\n+ * @param specifierName Original name of the specifier to look for. Aliases will be resolved to\n+ *    their original name.\n+ */\n+export function getImportSpecifier(\n+    sourceFile: ts.SourceFile, moduleName: string, specifierName: string): ts.ImportSpecifier|null {\n+  for (const node of sourceFile.statements) {\n+    if (ts.isImportDeclaration(node) && ts.isStringLiteral(node.moduleSpecifier) &&\n+        node.moduleSpecifier.text === moduleName) {\n+      const namedBindings = node.importClause && node.importClause.namedBindings;\n+      if (namedBindings && ts.isNamedImports(namedBindings)) {\n+        const match = namedBindings.elements.find(element => {\n+          const {name, propertyName} = element;\n+          return propertyName ? propertyName.text === specifierName : name.text === specifierName;\n+        });\n+\n+        if (match) {\n+          return match;\n+        }\n+      }\n+    }\n+  }\n+\n+  return null;\n+}"
        },
        {
            "sha": "9d4bbffd1fdcceedbc1600c584f9562ee42157bf",
            "filename": "packages/core/schematics/utils/typescript/symbol.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Futils%2Ftypescript%2Fsymbol.ts",
            "raw_url": "https://github.com/angular/angular/raw/7849fdde09be38b09c939a4ac033861daf52ca4e/packages%2Fcore%2Fschematics%2Futils%2Ftypescript%2Fsymbol.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Futils%2Ftypescript%2Fsymbol.ts?ref=7849fdde09be38b09c939a4ac033861daf52ca4e",
            "patch": "@@ -18,3 +18,12 @@ export function getValueSymbolOfDeclaration(node: ts.Node, typeChecker: ts.TypeC\n \n   return symbol;\n }\n+\n+/** Checks whether a node is referring to a specific import specifier. */\n+export function isReferenceToImport(\n+    typeChecker: ts.TypeChecker, node: ts.Node, importSpecifier: ts.ImportSpecifier): boolean {\n+  const nodeSymbol = typeChecker.getTypeAtLocation(node).getSymbol();\n+  const importSymbol = typeChecker.getTypeAtLocation(importSpecifier).getSymbol();\n+  return !!(nodeSymbol && importSymbol) &&\n+      nodeSymbol.valueDeclaration === importSymbol.valueDeclaration;\n+}"
        }
    ],
    "stats": {
        "total": 1126,
        "additions": 1053,
        "deletions": 73
    }
}