{
    "author": "petebacondarwin",
    "message": "refactor(compiler): support encoded entity tokens when lexing markup (#42062)\n\nThe lexer now splits encoded entity tokens out from text and attribute value tokens.\n\nPreviously encoded entities would be decoded and the decoded value would be\nincluded as part of the text token of the surrounding text. Now the entities\nhave their own tokens. There are two scenarios: text and attribute values.\n\nPreviously the contents of `<div>Hello &amp; goodbye</div>` would be a single\nTEXT token. Now it will be three tokens:\n\n```\nTEXT: \"Hello \"\nENCODED_ENTITY: \"&\", \"&amp;\"\nTEXT: \" goodbye\"\n```\n\nPreviously the attribute value in `<div title=\"Hello &amp; goodbye\">` would be\na single text token. Now it will be three tokens:\n\n```\nATTR_VALUE_TEXT: \"Hello \"\nENCODED_ENTITY: \"&\", \"&amp;\"\nATTR_VALUE_TEXT: \" goodbye\"\n```\n\n- ENCODED_ENTITY tokens have two parts: \"decoded\" and \"encoded\".\n- ENCODED_ENTITY tokens are always preceded and followed by either TEXT tokens\n  or ATTR_VALUE_TEXT tokens, depending upon the context, even if they represent\n  an empty string.\n\nThe HTML parser has been modified to recombine these tokens to allow this\nrefactoring to have limited effect in this commit. Further refactorings\nto use these new tokens will follow in subsequent commits.\n\nPR Close #42062",
    "sha": "942b24d5ea5d36ad4e53ed435bda35a6ae6876c9",
    "files": [
        {
            "sha": "13d3a6bfba82f55647c18936101cbd2892cbb513",
            "filename": "packages/compiler/src/ml_parser/lexer.ts",
            "status": "modified",
            "additions": 44,
            "deletions": 28,
            "changes": 72,
            "blob_url": "https://github.com/angular/angular/blob/942b24d5ea5d36ad4e53ed435bda35a6ae6876c9/packages%2Fcompiler%2Fsrc%2Fml_parser%2Flexer.ts",
            "raw_url": "https://github.com/angular/angular/raw/942b24d5ea5d36ad4e53ed435bda35a6ae6876c9/packages%2Fcompiler%2Fsrc%2Fml_parser%2Flexer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fml_parser%2Flexer.ts?ref=942b24d5ea5d36ad4e53ed435bda35a6ae6876c9",
            "patch": "@@ -23,6 +23,7 @@ export enum TokenType {\n   ESCAPABLE_RAW_TEXT,\n   RAW_TEXT,\n   INTERPOLATION,\n+  ENCODED_ENTITY,\n   COMMENT_START,\n   COMMENT_END,\n   CDATA_START,\n@@ -395,19 +396,16 @@ class _Tokenizer {\n     }\n   }\n \n-  private _readChar(decodeEntities: boolean): string {\n-    if (decodeEntities && this._cursor.peek() === chars.$AMPERSAND) {\n-      return this._decodeEntity();\n-    } else {\n-      // Don't rely upon reading directly from `_input` as the actual char value\n-      // may have been generated from an escape sequence.\n-      const char = String.fromCodePoint(this._cursor.peek());\n-      this._cursor.advance();\n-      return char;\n-    }\n+  private _readChar(): string {\n+    // Don't rely upon reading directly from `_input` as the actual char value\n+    // may have been generated from an escape sequence.\n+    const char = String.fromCodePoint(this._cursor.peek());\n+    this._cursor.advance();\n+    return char;\n   }\n \n-  private _decodeEntity(): string {\n+  private _consumeEntity(textTokenType: TokenType): void {\n+    this._beginToken(TokenType.ENCODED_ENTITY);\n     const start = this._cursor.clone();\n     this._cursor.advance();\n     if (this._attemptCharCode(chars.$HASH)) {\n@@ -427,7 +425,7 @@ class _Tokenizer {\n       this._cursor.advance();\n       try {\n         const charCode = parseInt(strNum, isHex ? 16 : 10);\n-        return String.fromCharCode(charCode);\n+        this._endToken([String.fromCharCode(charCode), this._cursor.getChars(start)]);\n       } catch {\n         throw this._createError(\n             _unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());\n@@ -436,21 +434,25 @@ class _Tokenizer {\n       const nameStart = this._cursor.clone();\n       this._attemptCharCodeUntilFn(isNamedEntityEnd);\n       if (this._cursor.peek() != chars.$SEMICOLON) {\n+        // No semicolon was found so abort the encoded entity token that was in progress, and treat\n+        // this as a text token\n+        this._beginToken(textTokenType, start);\n         this._cursor = nameStart;\n-        return '&';\n-      }\n-      const name = this._cursor.getChars(nameStart);\n-      this._cursor.advance();\n-      const char = NAMED_ENTITIES[name];\n-      if (!char) {\n-        throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));\n+        this._endToken(['&']);\n+      } else {\n+        const name = this._cursor.getChars(nameStart);\n+        this._cursor.advance();\n+        const char = NAMED_ENTITIES[name];\n+        if (!char) {\n+          throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));\n+        }\n+        this._endToken([char, `&${name};`]);\n       }\n-      return char;\n     }\n   }\n \n-  private _consumeRawText(decodeEntities: boolean, endMarkerPredicate: () => boolean): Token {\n-    this._beginToken(decodeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT);\n+  private _consumeRawText(consumeEntities: boolean, endMarkerPredicate: () => boolean): void {\n+    this._beginToken(consumeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT);\n     const parts: string[] = [];\n     while (true) {\n       const tagCloseStart = this._cursor.clone();\n@@ -459,9 +461,16 @@ class _Tokenizer {\n       if (foundEndMarker) {\n         break;\n       }\n-      parts.push(this._readChar(decodeEntities));\n+      if (consumeEntities && this._cursor.peek() === chars.$AMPERSAND) {\n+        this._endToken([this._processCarriageReturns(parts.join(''))]);\n+        parts.length = 0;\n+        this._consumeEntity(TokenType.ESCAPABLE_RAW_TEXT);\n+        this._beginToken(TokenType.ESCAPABLE_RAW_TEXT);\n+      } else {\n+        parts.push(this._readChar());\n+      }\n     }\n-    return this._endToken([this._processCarriageReturns(parts.join(''))]);\n+    this._endToken([this._processCarriageReturns(parts.join(''))]);\n   }\n \n   private _consumeComment(start: CharacterCursor) {\n@@ -563,8 +572,8 @@ class _Tokenizer {\n     }\n   }\n \n-  private _consumeRawTextWithTagClose(prefix: string, tagName: string, decodeEntities: boolean) {\n-    this._consumeRawText(decodeEntities, () => {\n+  private _consumeRawTextWithTagClose(prefix: string, tagName: string, consumeEntities: boolean) {\n+    this._consumeRawText(consumeEntities, () => {\n       if (!this._attemptCharCode(chars.$LT)) return false;\n       if (!this._attemptCharCode(chars.$SLASH)) return false;\n       this._attemptCharCodeUntilFn(isNotWhitespace);\n@@ -712,11 +721,16 @@ class _Tokenizer {\n       const current = this._cursor.clone();\n       if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n         this._endToken([this._processCarriageReturns(parts.join(''))], current);\n+        parts.length = 0;\n         this._consumeInterpolation(interpolationTokenType, current);\n+        this._beginToken(textTokenType);\n+      } else if (this._cursor.peek() === chars.$AMPERSAND) {\n+        this._endToken([this._processCarriageReturns(parts.join(''))]);\n         parts.length = 0;\n+        this._consumeEntity(textTokenType);\n         this._beginToken(textTokenType);\n       } else {\n-        parts.push(this._readChar(true));\n+        parts.push(this._readChar());\n       }\n     }\n \n@@ -895,7 +909,9 @@ function mergeTextTokens(srcTokens: Token[]): Token[] {\n   let lastDstToken: Token|undefined = undefined;\n   for (let i = 0; i < srcTokens.length; i++) {\n     const token = srcTokens[i];\n-    if (lastDstToken && lastDstToken.type == TokenType.TEXT && token.type == TokenType.TEXT) {\n+    if ((lastDstToken && lastDstToken.type == TokenType.TEXT && token.type == TokenType.TEXT) ||\n+        (lastDstToken && lastDstToken.type == TokenType.ATTR_VALUE_TEXT &&\n+         token.type == TokenType.ATTR_VALUE_TEXT)) {\n       lastDstToken.parts[0]! += token.parts[0];\n       lastDstToken.sourceSpan.end = token.sourceSpan.end;\n     } else {"
        },
        {
            "sha": "4d5f18d440318e02873bd143a69bc4ae3f9e742f",
            "filename": "packages/compiler/src/ml_parser/parser.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 17,
            "changes": 38,
            "blob_url": "https://github.com/angular/angular/blob/942b24d5ea5d36ad4e53ed435bda35a6ae6876c9/packages%2Fcompiler%2Fsrc%2Fml_parser%2Fparser.ts",
            "raw_url": "https://github.com/angular/angular/raw/942b24d5ea5d36ad4e53ed435bda35a6ae6876c9/packages%2Fcompiler%2Fsrc%2Fml_parser%2Fparser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fml_parser%2Fparser.ts?ref=942b24d5ea5d36ad4e53ed435bda35a6ae6876c9",
            "patch": "@@ -226,20 +226,21 @@ class _TreeBuilder {\n       }\n     }\n \n-    // For now recombine text and interpolation tokens\n-    if (this._peek.type === lex.TokenType.INTERPOLATION) {\n-      while (this._peek.type === lex.TokenType.INTERPOLATION ||\n-             this._peek.type === lex.TokenType.TEXT) {\n-        token = this._advance();\n-        if (token.type === lex.TokenType.INTERPOLATION) {\n-          // For backward compatibility we decode HTML entities that appear in interpolation\n-          // expressions. This is arguably a bug, but it could be a considerable breaking change to\n-          // fix it. It should be addressed in a larger project to refactor the entire parser/lexer\n-          // chain after View Engine has been removed.\n-          text += token.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n-        } else {\n-          text += token.parts.join('');\n-        }\n+    // For now recombine text, interpolation and entity tokens\n+    while (this._peek.type === lex.TokenType.INTERPOLATION ||\n+           this._peek.type === lex.TokenType.TEXT ||\n+           this._peek.type === lex.TokenType.ENCODED_ENTITY) {\n+      token = this._advance();\n+      if (token.type === lex.TokenType.INTERPOLATION) {\n+        // For backward compatibility we decode HTML entities that appear in interpolation\n+        // expressions. This is arguably a bug, but it could be a considerable breaking change to\n+        // fix it. It should be addressed in a larger project to refactor the entire parser/lexer\n+        // chain after View Engine has been removed.\n+        text += token.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n+      } else if (token.type === lex.TokenType.ENCODED_ENTITY) {\n+        text += token.parts[0];\n+      } else {\n+        text += token.parts.join('');\n       }\n     }\n \n@@ -369,23 +370,26 @@ class _TreeBuilder {\n       this._advance();\n     }\n \n-    // Consume the value\n+    // Consume the attribute value\n     let value = '';\n     let valueStartSpan: ParseSourceSpan|undefined = undefined;\n     let valueEnd: ParseLocation|undefined = undefined;\n     if (this._peek.type === lex.TokenType.ATTR_VALUE_TEXT) {\n       valueStartSpan = this._peek.sourceSpan;\n       valueEnd = this._peek.sourceSpan.end;\n-      // For now we are recombining text and interpolation tokens\n+      // For now recombine text, interpolation and entity tokens\n       while (this._peek.type === lex.TokenType.ATTR_VALUE_TEXT ||\n-             this._peek.type === lex.TokenType.ATTR_VALUE_INTERPOLATION) {\n+             this._peek.type === lex.TokenType.ATTR_VALUE_INTERPOLATION ||\n+             this._peek.type === lex.TokenType.ENCODED_ENTITY) {\n         let valueToken = this._advance();\n         if (valueToken.type === lex.TokenType.ATTR_VALUE_INTERPOLATION) {\n           // For backward compatibility we decode HTML entities that appear in interpolation\n           // expressions. This is arguably a bug, but it could be a considerable breaking change to\n           // fix it. It should be addressed in a larger project to refactor the entire parser/lexer\n           // chain after View Engine has been removed.\n           value += valueToken.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n+        } else if (valueToken.type === lex.TokenType.ENCODED_ENTITY) {\n+          value += valueToken.parts[0];\n         } else {\n           value += valueToken.parts.join('');\n         }"
        },
        {
            "sha": "bc8559221b1575cb38a980763b0bb11360b31928",
            "filename": "packages/compiler/test/ml_parser/lexer_spec.ts",
            "status": "modified",
            "additions": 32,
            "deletions": 12,
            "changes": 44,
            "blob_url": "https://github.com/angular/angular/blob/942b24d5ea5d36ad4e53ed435bda35a6ae6876c9/packages%2Fcompiler%2Ftest%2Fml_parser%2Flexer_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/942b24d5ea5d36ad4e53ed435bda35a6ae6876c9/packages%2Fcompiler%2Ftest%2Fml_parser%2Flexer_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fml_parser%2Flexer_spec.ts?ref=942b24d5ea5d36ad4e53ed435bda35a6ae6876c9",
            "patch": "@@ -407,7 +407,11 @@ import {ParseLocation, ParseSourceFile, ParseSourceSpan} from '../../src/parse_u\n           [lex.TokenType.TAG_OPEN_START, '', 't'],\n           [lex.TokenType.ATTR_NAME, '', 'a'],\n           [lex.TokenType.ATTR_QUOTE, '\"'],\n-          [lex.TokenType.ATTR_VALUE_TEXT, 'AA'],\n+          [lex.TokenType.ATTR_VALUE_TEXT, ''],\n+          [lex.TokenType.ENCODED_ENTITY, 'A', '&#65;'],\n+          [lex.TokenType.ATTR_VALUE_TEXT, ''],\n+          [lex.TokenType.ENCODED_ENTITY, 'A', '&#x41;'],\n+          [lex.TokenType.ATTR_VALUE_TEXT, ''],\n           [lex.TokenType.ATTR_QUOTE, '\"'],\n           [lex.TokenType.TAG_OPEN_END],\n           [lex.TokenType.EOF],\n@@ -522,50 +526,60 @@ import {ParseLocation, ParseSourceFile, ParseSourceSpan} from '../../src/parse_u\n     describe('entities', () => {\n       it('should parse named entities', () => {\n         expect(tokenizeAndHumanizeParts('a&amp;b')).toEqual([\n-          [lex.TokenType.TEXT, 'a&b'],\n+          [lex.TokenType.TEXT, 'a'],\n+          [lex.TokenType.ENCODED_ENTITY, '&', '&amp;'],\n+          [lex.TokenType.TEXT, 'b'],\n           [lex.TokenType.EOF],\n         ]);\n       });\n \n       it('should parse hexadecimal entities', () => {\n         expect(tokenizeAndHumanizeParts('&#x41;&#X41;')).toEqual([\n-          [lex.TokenType.TEXT, 'AA'],\n+          [lex.TokenType.TEXT, ''],\n+          [lex.TokenType.ENCODED_ENTITY, 'A', '&#x41;'],\n+          [lex.TokenType.TEXT, ''],\n+          [lex.TokenType.ENCODED_ENTITY, 'A', '&#X41;'],\n+          [lex.TokenType.TEXT, ''],\n           [lex.TokenType.EOF],\n         ]);\n       });\n \n       it('should parse decimal entities', () => {\n         expect(tokenizeAndHumanizeParts('&#65;')).toEqual([\n-          [lex.TokenType.TEXT, 'A'],\n+          [lex.TokenType.TEXT, ''],\n+          [lex.TokenType.ENCODED_ENTITY, 'A', '&#65;'],\n+          [lex.TokenType.TEXT, ''],\n           [lex.TokenType.EOF],\n         ]);\n       });\n \n       it('should store the locations', () => {\n         expect(tokenizeAndHumanizeSourceSpans('a&amp;b')).toEqual([\n-          [lex.TokenType.TEXT, 'a&amp;b'],\n+          [lex.TokenType.TEXT, 'a'],\n+          [lex.TokenType.ENCODED_ENTITY, '&amp;'],\n+          [lex.TokenType.TEXT, 'b'],\n           [lex.TokenType.EOF, ''],\n         ]);\n       });\n \n       it('should report malformed/unknown entities', () => {\n         expect(tokenizeAndHumanizeErrors('&tbo;')).toEqual([[\n-          lex.TokenType.TEXT,\n+          lex.TokenType.ENCODED_ENTITY,\n           'Unknown entity \"tbo\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax', '0:0'\n         ]]);\n         expect(tokenizeAndHumanizeErrors('&#3sdf;')).toEqual([[\n-          lex.TokenType.TEXT,\n+          lex.TokenType.ENCODED_ENTITY,\n           'Unable to parse entity \"&#3s\" - decimal character reference entities must end with \";\"',\n           '0:4'\n         ]]);\n         expect(tokenizeAndHumanizeErrors('&#xasdf;')).toEqual([[\n-          lex.TokenType.TEXT,\n+          lex.TokenType.ENCODED_ENTITY,\n           'Unable to parse entity \"&#xas\" - hexadecimal character reference entities must end with \";\"',\n           '0:5'\n         ]]);\n \n         expect(tokenizeAndHumanizeErrors('&#xABC')).toEqual([\n-          [lex.TokenType.TEXT, 'Unexpected character \"EOF\"', '0:6']\n+          [lex.TokenType.ENCODED_ENTITY, 'Unexpected character \"EOF\"', '0:6']\n         ]);\n       });\n     });\n@@ -643,12 +657,16 @@ import {ParseLocation, ParseSourceFile, ParseSourceSpan} from '../../src/parse_u\n \n       it('should parse entities', () => {\n         expect(tokenizeAndHumanizeParts('a&amp;b')).toEqual([\n-          [lex.TokenType.TEXT, 'a&b'],\n+          [lex.TokenType.TEXT, 'a'],\n+          [lex.TokenType.ENCODED_ENTITY, '&', '&amp;'],\n+          [lex.TokenType.TEXT, 'b'],\n           [lex.TokenType.EOF],\n         ]);\n \n         expect(tokenizeAndHumanizeSourceSpans('a&amp;b')).toEqual([\n-          [lex.TokenType.TEXT, 'a&amp;b'],\n+          [lex.TokenType.TEXT, 'a'],\n+          [lex.TokenType.ENCODED_ENTITY, '&amp;'],\n+          [lex.TokenType.TEXT, 'b'],\n           [lex.TokenType.EOF, ''],\n         ]);\n       });\n@@ -894,7 +912,9 @@ import {ParseLocation, ParseSourceFile, ParseSourceSpan} from '../../src/parse_u\n         expect(tokenizeAndHumanizeParts(`<title>&amp;</title>`)).toEqual([\n           [lex.TokenType.TAG_OPEN_START, '', 'title'],\n           [lex.TokenType.TAG_OPEN_END],\n-          [lex.TokenType.ESCAPABLE_RAW_TEXT, '&'],\n+          [lex.TokenType.ESCAPABLE_RAW_TEXT, ''],\n+          [lex.TokenType.ENCODED_ENTITY, '&', '&amp;'],\n+          [lex.TokenType.ESCAPABLE_RAW_TEXT, ''],\n           [lex.TokenType.TAG_CLOSE, '', 'title'],\n           [lex.TokenType.EOF],\n         ]);"
        }
    ],
    "stats": {
        "total": 154,
        "additions": 97,
        "deletions": 57
    }
}