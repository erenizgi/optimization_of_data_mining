{
    "author": "ayazhafiz",
    "message": "refactor(compiler): parse bindings \"by hand\" rather than via regex (#39375)\n\nTo support recovery of malformed binding property names like `([a)`,\n`[a`, or `()`, the binding parser needs to be more permissive w.r.t. the\nkinds of bindings it can detect. This is difficult to do maintainably\nwith a regex, but is trivial with a \"hand-rolled\" string parser. This\ncommit refactors render3's binding attribute parsing to use this method\nfor multi-delimited bindings (namely via the `()`, `[]`, and `[()]`)\nsyntax, making the way recovery of malformed bindings in a future patch.\n\nNote that we can keep using a regex for prefix-only binding syntax\n(e.g. `bind-`, `ref-`) because validation of the binding is complete\nonce we have matched the prefix, and the only thing left to do is check\nthat the binding identifier is non-empty, which is trivial.\n\nPart of #38596\n\nPR Close #39375",
    "sha": "3241d922fcca36d21c086f48a041820b9094c6dd",
    "files": [
        {
            "sha": "8f058b676cbac42799198fc719a090fb6f0dea01",
            "filename": "packages/compiler/src/render3/r3_template_transform.ts",
            "status": "modified",
            "additions": 45,
            "deletions": 31,
            "changes": 76,
            "blob_url": "https://github.com/angular/angular/blob/3241d922fcca36d21c086f48a041820b9094c6dd/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_template_transform.ts",
            "raw_url": "https://github.com/angular/angular/raw/3241d922fcca36d21c086f48a041820b9094c6dd/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_template_transform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_template_transform.ts?ref=3241d922fcca36d21c086f48a041820b9094c6dd",
            "patch": "@@ -15,13 +15,11 @@ import {ParseError, ParseErrorLevel, ParseSourceSpan} from '../parse_util';\n import {isStyleUrlResolvable} from '../style_url_resolver';\n import {BindingParser} from '../template_parser/binding_parser';\n import {PreparsedElementType, preparseElement} from '../template_parser/template_preparser';\n-import {syntaxError} from '../util';\n \n import * as t from './r3_ast';\n import {I18N_ICU_VAR_PREFIX, isI18nRootNode} from './view/i18n/util';\n \n-const BIND_NAME_REGEXP =\n-    /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/;\n+const BIND_NAME_REGEXP = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/;\n \n // Group 1 = \"bind-\"\n const KW_BIND_IDX = 1;\n@@ -37,12 +35,12 @@ const KW_BINDON_IDX = 5;\n const KW_AT_IDX = 6;\n // Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\n const IDENT_KW_IDX = 7;\n-// Group 8 = identifier inside [()]\n-const IDENT_BANANA_BOX_IDX = 8;\n-// Group 9 = identifier inside []\n-const IDENT_PROPERTY_IDX = 9;\n-// Group 10 = identifier inside ()\n-const IDENT_EVENT_IDX = 10;\n+\n+const BINDING_DELIMS = {\n+  BANANA_BOX: {start: '[(', end: ')]'},\n+  PROPERTY: {start: '[', end: ']'},\n+  EVENT: {start: '(', end: ')'},\n+};\n \n const TEMPLATE_ATTR_PREFIX = '*';\n \n@@ -337,10 +335,8 @@ class HtmlAstToIvyAst implements html.Visitor {\n     }\n \n     const bindParts = name.match(BIND_NAME_REGEXP);\n-    let hasBinding = false;\n \n     if (bindParts) {\n-      hasBinding = true;\n       if (bindParts[KW_BIND_IDX] != null) {\n         const identifier = bindParts[IDENT_KW_IDX];\n         const keySpan = createKeySpan(srcSpan, bindParts[KW_BIND_IDX], identifier);\n@@ -380,36 +376,54 @@ class HtmlAstToIvyAst implements html.Visitor {\n         this.bindingParser.parseLiteralAttr(\n             name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes,\n             parsedProperties, keySpan);\n+      }\n+      return true;\n+    }\n \n-      } else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n-        const keySpan = createKeySpan(srcSpan, '[(', bindParts[IDENT_BANANA_BOX_IDX]);\n+    // We didn't see a kw-prefixed property binding, but we have not yet checked\n+    // for the []/()/[()] syntax.\n+    let delims: {start: string, end: string}|null = null;\n+    if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {\n+      delims = BINDING_DELIMS.BANANA_BOX;\n+    } else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {\n+      delims = BINDING_DELIMS.PROPERTY;\n+    } else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {\n+      delims = BINDING_DELIMS.EVENT;\n+    }\n+    if (delims !== null &&\n+        // NOTE: older versions of the parser would match a start/end delimited\n+        // binding iff the property name was terminated by the ending delimiter\n+        // and the identifier in the binding was non-empty.\n+        // TODO(ayazhafiz): update this to handle malformed bindings.\n+        name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {\n+      const identifier = name.substring(delims.start.length, name.length - delims.end.length);\n+      if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {\n+        const keySpan = createKeySpan(srcSpan, delims.start, identifier);\n         this.bindingParser.parsePropertyBinding(\n-            bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, absoluteOffset,\n-            attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n+            identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan,\n+            matchableAttributes, parsedProperties, keySpan);\n         this.parseAssignmentEvent(\n-            bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, attribute.valueSpan,\n-            matchableAttributes, boundEvents);\n-\n-      } else if (bindParts[IDENT_PROPERTY_IDX]) {\n-        const keySpan = createKeySpan(srcSpan, '[', bindParts[IDENT_PROPERTY_IDX]);\n+            identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents);\n+      } else if (delims.start === BINDING_DELIMS.PROPERTY.start) {\n+        const keySpan = createKeySpan(srcSpan, delims.start, identifier);\n         this.bindingParser.parsePropertyBinding(\n-            bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, absoluteOffset,\n-            attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n-\n-      } else if (bindParts[IDENT_EVENT_IDX]) {\n+            identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan,\n+            matchableAttributes, parsedProperties, keySpan);\n+      } else {\n         const events: ParsedEvent[] = [];\n         this.bindingParser.parseEvent(\n-            bindParts[IDENT_EVENT_IDX], value, srcSpan, attribute.valueSpan || srcSpan,\n-            matchableAttributes, events);\n+            identifier, value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes,\n+            events);\n         addEvents(events, boundEvents);\n       }\n-    } else {\n-      const keySpan = createKeySpan(srcSpan, '' /* prefix */, name);\n-      hasBinding = this.bindingParser.parsePropertyInterpolation(\n-          name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties,\n-          keySpan);\n+\n+      return true;\n     }\n \n+    // No explicit binding found.\n+    const keySpan = createKeySpan(srcSpan, '' /* prefix */, name);\n+    const hasBinding = this.bindingParser.parsePropertyInterpolation(\n+        name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n     return hasBinding;\n   }\n "
        }
    ],
    "stats": {
        "total": 76,
        "additions": 45,
        "deletions": 31
    }
}