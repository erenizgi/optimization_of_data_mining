{
    "author": "JoostK",
    "message": "refactor(compiler): remove directive matching from template compiler (#44731)\n\nThe directive matching pass that happens during template compilation is\nredundant, since directive matching has already happened during the resolution\nphase of ngtsc and only matching declarables are provided to the template\ncompiler. In JIT mode the declarables only become available after the primary\ntemplate compilation has completed, so there is no need to perform directive\nmatching in both JIT and AOT mode.\n\nPR Close #44731",
    "sha": "1f6249dae8414dedb62c0864008c06821c097be7",
    "files": [
        {
            "sha": "791c67a900629cb25d187fe0e80ebaee6a3028b9",
            "filename": "packages/compiler/src/render3/view/compiler.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 20,
            "changes": 26,
            "blob_url": "https://github.com/angular/angular/blob/1f6249dae8414dedb62c0864008c06821c097be7/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/1f6249dae8414dedb62c0864008c06821c097be7/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fcompiler.ts?ref=1f6249dae8414dedb62c0864008c06821c097be7",
            "patch": "@@ -12,7 +12,7 @@ import * as core from '../../core';\n import {AST, ParsedEvent, ParsedEventType, ParsedProperty} from '../../expression_parser/ast';\n import * as o from '../../output/output_ast';\n import {ParseError, ParseSourceSpan, sanitizeIdentifier} from '../../parse_util';\n-import {CssSelector, SelectorMatcher} from '../../selector';\n+import {CssSelector} from '../../selector';\n import {ShadowCss} from '../../shadow_css';\n import {BindingParser} from '../../template_parser/binding_parser';\n import {error} from '../../util';\n@@ -152,30 +152,16 @@ export function compileComponentFromMetadata(\n     }\n   }\n \n-  // Generate the CSS matcher that recognize directive\n-  let directiveMatcher: SelectorMatcher|null = null;\n-\n-  if (meta.directives.length > 0) {\n-    const matcher = new SelectorMatcher();\n-    for (const {selector, type} of meta.directives) {\n-      matcher.addSelectables(CssSelector.parse(selector), type);\n-    }\n-    directiveMatcher = matcher;\n-  }\n-\n   // e.g. `template: function MyComponent_Template(_ctx, _cm) {...}`\n   const templateTypeName = meta.name;\n   const templateName = templateTypeName ? `${templateTypeName}_Template` : null;\n \n-  const directivesUsed = new Set<o.Expression>();\n-  const pipesUsed = new Set<o.Expression>();\n   const changeDetection = meta.changeDetection;\n \n   const template = meta.template;\n   const templateBuilder = new TemplateDefinitionBuilder(\n       constantPool, BindingScope.createRootScope(), 0, templateTypeName, null, null, templateName,\n-      directiveMatcher, directivesUsed, meta.pipes, pipesUsed, R3.namespaceHTML,\n-      meta.relativeContextFilePath, meta.i18nUseExternalIds);\n+      R3.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);\n \n   const templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []);\n \n@@ -210,15 +196,15 @@ export function compileComponentFromMetadata(\n   definitionMap.set('template', templateFunctionExpression);\n \n   // e.g. `directives: [MyDirective]`\n-  if (directivesUsed.size) {\n-    const directivesList = o.literalArr(Array.from(directivesUsed));\n+  if (meta.directives.length > 0) {\n+    const directivesList = o.literalArr(meta.directives.map(dir => dir.type));\n     const directivesExpr = compileDeclarationList(directivesList, meta.declarationListEmitMode);\n     definitionMap.set('directives', directivesExpr);\n   }\n \n   // e.g. `pipes: [MyPipe]`\n-  if (pipesUsed.size) {\n-    const pipesList = o.literalArr(Array.from(pipesUsed));\n+  if (meta.pipes.size > 0) {\n+    const pipesList = o.literalArr(Array.from(meta.pipes.values()));\n     const pipesExpr = compileDeclarationList(pipesList, meta.declarationListEmitMode);\n     definitionMap.set('pipes', pipesExpr);\n   }"
        },
        {
            "sha": "22bb3bd243909fc1bf5a2d272757d65851fd3ef4",
            "filename": "packages/compiler/src/render3/view/template.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 26,
            "changes": 30,
            "blob_url": "https://github.com/angular/angular/blob/1f6249dae8414dedb62c0864008c06821c097be7/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "raw_url": "https://github.com/angular/angular/raw/1f6249dae8414dedb62c0864008c06821c097be7/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts?ref=1f6249dae8414dedb62c0864008c06821c097be7",
            "patch": "@@ -24,7 +24,7 @@ import * as o from '../../output/output_ast';\n import {ParseError, ParseSourceSpan, sanitizeIdentifier} from '../../parse_util';\n import {DomElementSchemaRegistry} from '../../schema/dom_element_schema_registry';\n import {isTrustedTypesSink} from '../../schema/trusted_types_sinks';\n-import {CssSelector, SelectorMatcher} from '../../selector';\n+import {CssSelector} from '../../selector';\n import {BindingParser} from '../../template_parser/binding_parser';\n import {error, partitionArray} from '../../util';\n import * as t from '../r3_ast';\n@@ -38,7 +38,7 @@ import {createLocalizeStatements} from './i18n/localize_utils';\n import {I18nMetaVisitor} from './i18n/meta';\n import {assembleBoundTextPlaceholders, assembleI18nBoundString, declareI18nVariable, getTranslationConstPrefix, hasI18nMeta, I18N_ICU_MAPPING_PREFIX, i18nFormatPlaceholderNames, icuFromI18nMessage, isI18nRootNode, isSingleI18nIcu, placeholdersToParams, TRANSLATION_VAR_PREFIX, wrapI18nPlaceholder} from './i18n/util';\n import {StylingBuilder, StylingInstruction} from './styling_builder';\n-import {asLiteral, chainedInstruction, CONTEXT_NAME, getAttrsForDirectiveMatching, getInterpolationArgsLength, IMPLICIT_REFERENCE, invalid, NON_BINDABLE_ATTR, REFERENCE_PREFIX, RENDER_FLAGS, RESTORED_VIEW_CONTEXT_NAME, trimTrailingNulls} from './util';\n+import {asLiteral, chainedInstruction, CONTEXT_NAME, getInterpolationArgsLength, IMPLICIT_REFERENCE, invalid, NON_BINDABLE_ATTR, REFERENCE_PREFIX, RENDER_FLAGS, RESTORED_VIEW_CONTEXT_NAME, trimTrailingNulls} from './util';\n \n \n \n@@ -200,8 +200,6 @@ export class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver\n       private constantPool: ConstantPool, parentBindingScope: BindingScope, private level = 0,\n       private contextName: string|null, private i18nContext: I18nContext|null,\n       private templateIndex: number|null, private templateName: string|null,\n-      private directiveMatcher: SelectorMatcher|null, private directives: Set<o.Expression>,\n-      private pipeTypeByName: Map<string, o.Expression>, private pipes: Set<o.Expression>,\n       private _namespace: o.ExternalReference, relativeContextFilePath: string,\n       private i18nUseExternalIds: boolean,\n       private _constants: ComponentDefConsts = createComponentDefConsts()) {\n@@ -215,10 +213,6 @@ export class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver\n         constantPool, () => this.allocateDataSlot(),\n         (numSlots: number) => this.allocatePureFunctionSlots(numSlots),\n         (name, localName, slot, value: o.Expression) => {\n-          const pipeType = pipeTypeByName.get(name);\n-          if (pipeType) {\n-            this.pipes.add(pipeType);\n-          }\n           this._bindingScope.set(this.level, localName, value);\n           this.creationInstruction(null, R3.pipe, [o.literal(slot), o.literal(name)]);\n         });\n@@ -638,9 +632,6 @@ export class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver\n       }\n     }\n \n-    // Match directives on non i18n attributes\n-    this.matchDirectives(element.name, element);\n-\n     // Regular element or ng-container creation mode\n     const parameters: o.Expression[] = [o.literal(elementIndex)];\n     if (!isNgContainer) {\n@@ -891,9 +882,6 @@ export class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver\n       o.literal(tagNameWithoutNamespace),\n     ];\n \n-    // find directives matching on a given <ng-template> node\n-    this.matchDirectives(NG_TEMPLATE_TAG_NAME, template);\n-\n     // prepare attributes parameter (including attributes used for directive matching)\n     const attrsExprs: o.Expression[] = this.getAttributeExpressions(\n         NG_TEMPLATE_TAG_NAME, template.attributes, template.inputs, template.outputs,\n@@ -910,9 +898,8 @@ export class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver\n     // Create the template function\n     const templateVisitor = new TemplateDefinitionBuilder(\n         this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n,\n-        templateIndex, templateName, this.directiveMatcher, this.directives, this.pipeTypeByName,\n-        this.pipes, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds,\n-        this._constants);\n+        templateIndex, templateName, this._namespace, this.fileBasedI18nSuffix,\n+        this.i18nUseExternalIds, this._constants);\n \n     // Nested templates must not be visited until after their parent templates have completed\n     // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't\n@@ -1281,15 +1268,6 @@ export class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver\n     return args;\n   }\n \n-  private matchDirectives(elementName: string, elOrTpl: t.Element|t.Template) {\n-    if (this.directiveMatcher) {\n-      const selector = createCssSelector(elementName, getAttrsForDirectiveMatching(elOrTpl));\n-      this.directiveMatcher.match(selector, (cssSelector, staticType) => {\n-        this.directives.add(staticType);\n-      });\n-    }\n-  }\n-\n   /**\n    * Prepares all attribute expression values for the `TAttributes` array.\n    *"
        }
    ],
    "stats": {
        "total": 56,
        "additions": 10,
        "deletions": 46
    }
}