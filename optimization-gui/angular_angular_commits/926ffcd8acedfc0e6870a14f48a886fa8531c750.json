{
    "author": "atscott",
    "message": "fix(router): support lazy loading for empty path named outlets (#38379)\n\nIn general, the router only matches and loads a single Route config tree. However,\nnamed outlets with empty paths are a special case where the router can\nand should actually match two different `Route`s and ensure that the\nmodules are loaded for each match.\n\nThis change updates the \"ApplyRedirects\" stage to ensure that named\noutlets with empty paths finish loading their configs before proceeding\nto the next stage in the routing pipe. This is necessary because if the\nnamed outlet has `loadChildren` but the associated lazy config is not loaded\nbefore following stages attempt to match and activate relevant `Route`s,\nan error will occur.\n\nfixes #12842\n\nPR Close #38379",
    "sha": "926ffcd8acedfc0e6870a14f48a886fa8531c750",
    "files": [
        {
            "sha": "e96c939e377da3792ed2aa93869740bc4bfde99b",
            "filename": "goldens/size-tracking/integration-payloads.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/926ffcd8acedfc0e6870a14f48a886fa8531c750/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "raw_url": "https://github.com/angular/angular/raw/926ffcd8acedfc0e6870a14f48a886fa8531c750/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fsize-tracking%2Fintegration-payloads.json?ref=926ffcd8acedfc0e6870a14f48a886fa8531c750",
            "patch": "@@ -39,7 +39,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 2289,\n-        \"main-es2015\": 245351,\n+        \"main-es2015\": 245885,\n         \"polyfills-es2015\": 36938,\n         \"5-es2015\": 751\n       }\n@@ -49,7 +49,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 2289,\n-        \"main-es2015\": 221939,\n+        \"main-es2015\": 222476,\n         \"polyfills-es2015\": 36723,\n         \"5-es2015\": 781\n       }"
        },
        {
            "sha": "dcf44e727ac8d71f9fa6718b1a47de8bbc843e07",
            "filename": "packages/router/src/apply_redirects.ts",
            "status": "modified",
            "additions": 50,
            "deletions": 27,
            "changes": 77,
            "blob_url": "https://github.com/angular/angular/blob/926ffcd8acedfc0e6870a14f48a886fa8531c750/packages%2Frouter%2Fsrc%2Fapply_redirects.ts",
            "raw_url": "https://github.com/angular/angular/raw/926ffcd8acedfc0e6870a14f48a886fa8531c750/packages%2Frouter%2Fsrc%2Fapply_redirects.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Fapply_redirects.ts?ref=926ffcd8acedfc0e6870a14f48a886fa8531c750",
            "patch": "@@ -7,8 +7,8 @@\n  */\n \n import {Injector, NgModuleRef} from '@angular/core';\n-import {defer, EmptyError, Observable, Observer, of} from 'rxjs';\n-import {catchError, concatAll, first, map, mergeMap, tap} from 'rxjs/operators';\n+import {defer, EmptyError, from, Observable, Observer, of} from 'rxjs';\n+import {catchError, combineAll, concatMap, first, map, mergeMap, tap} from 'rxjs/operators';\n \n import {LoadedRouterConfig, Route, Routes} from './config';\n import {CanLoadFn} from './interfaces';\n@@ -17,6 +17,7 @@ import {RouterConfigLoader} from './router_config_loader';\n import {defaultUrlMatcher, navigationCancelingError, Params, PRIMARY_OUTLET} from './shared';\n import {UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\n import {forEach, waitForMap, wrapIntoObservable} from './utils/collection';\n+import {getOutlet, groupRoutesByOutlet} from './utils/config';\n import {isCanLoad, isFunction, isUrlTree} from './utils/type_guards';\n \n class NoMatch {\n@@ -148,28 +149,52 @@ class ApplyRedirects {\n       ngModule: NgModuleRef<any>, segmentGroup: UrlSegmentGroup, routes: Route[],\n       segments: UrlSegment[], outlet: string,\n       allowRedirects: boolean): Observable<UrlSegmentGroup> {\n-    return of(...routes).pipe(\n-        map((r: any) => {\n-          const expanded$ = this.expandSegmentAgainstRoute(\n-              ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);\n-          return expanded$.pipe(catchError((e: any) => {\n-            if (e instanceof NoMatch) {\n-              // TODO(i): this return type doesn't match the declared Observable<UrlSegmentGroup> -\n-              // talk to Jason\n-              return of(null) as any;\n+    // We need to expand each outlet group independently to ensure that we not only load modules\n+    // for routes matching the given `outlet`, but also those which will be activated because\n+    // their path is empty string. This can result in multiple outlets being activated at once.\n+    const routesByOutlet: Map<string, Route[]> = groupRoutesByOutlet(routes);\n+    if (!routesByOutlet.has(outlet)) {\n+      routesByOutlet.set(outlet, []);\n+    }\n+\n+    const expandRoutes = (routes: Route[]) => {\n+      return from(routes).pipe(\n+          concatMap((r: Route) => {\n+            const expanded$ = this.expandSegmentAgainstRoute(\n+                ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);\n+            return expanded$.pipe(catchError(e => {\n+              if (e instanceof NoMatch) {\n+                return of(null);\n+              }\n+              throw e;\n+            }));\n+          }),\n+          first((s: UrlSegmentGroup|null): s is UrlSegmentGroup => s !== null),\n+          catchError(e => {\n+            if (e instanceof EmptyError || e.name === 'EmptyError') {\n+              if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n+                return of(new UrlSegmentGroup([], {}));\n+              }\n+              throw new NoMatch(segmentGroup);\n             }\n             throw e;\n-          }));\n-        }),\n-        concatAll(), first((s: any) => !!s), catchError((e: any, _: any) => {\n-          if (e instanceof EmptyError || e.name === 'EmptyError') {\n-            if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n-              return of(new UrlSegmentGroup([], {}));\n-            }\n-            throw new NoMatch(segmentGroup);\n-          }\n-          throw e;\n-        }));\n+          }),\n+      );\n+    };\n+\n+    const expansions = Array.from(routesByOutlet.entries()).map(([routeOutlet, routes]) => {\n+      const expanded = expandRoutes(routes);\n+      // Map all results from outlets we aren't activating to `null` so they can be ignored later\n+      return routeOutlet === outlet ? expanded :\n+                                      expanded.pipe(map(() => null), catchError(() => of(null)));\n+    });\n+    return from(expansions)\n+        .pipe(\n+            combineAll(),\n+            first(),\n+            // Return only the expansion for the route outlet we are trying to activate.\n+            map(results => results.find(result => result !== null)!),\n+        );\n   }\n \n   private noLeftoversInUrl(segmentGroup: UrlSegmentGroup, segments: UrlSegment[], outlet: string):\n@@ -180,7 +205,9 @@ class ApplyRedirects {\n   private expandSegmentAgainstRoute(\n       ngModule: NgModuleRef<any>, segmentGroup: UrlSegmentGroup, routes: Route[], route: Route,\n       paths: UrlSegment[], outlet: string, allowRedirects: boolean): Observable<UrlSegmentGroup> {\n-    if (getOutlet(route) !== outlet) {\n+    // Empty string segments are special because multiple outlets can match a single path, i.e.\n+    // `[{path: '', component: B}, {path: '', loadChildren: () => {}, outlet: \"about\"}]`\n+    if (getOutlet(route) !== outlet && route.path !== '') {\n       return noMatch(segmentGroup);\n     }\n \n@@ -551,7 +578,3 @@ function isEmptyPathRedirect(\n \n   return r.path === '' && r.redirectTo !== undefined;\n }\n-\n-function getOutlet(route: Route): string {\n-  return route.outlet || PRIMARY_OUTLET;\n-}"
        },
        {
            "sha": "f38e56cfd4ff32576740b285951e5a908eeacfa0",
            "filename": "packages/router/src/utils/config.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/926ffcd8acedfc0e6870a14f48a886fa8531c750/packages%2Frouter%2Fsrc%2Futils%2Fconfig.ts",
            "raw_url": "https://github.com/angular/angular/raw/926ffcd8acedfc0e6870a14f48a886fa8531c750/packages%2Frouter%2Fsrc%2Futils%2Fconfig.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Futils%2Fconfig.ts?ref=926ffcd8acedfc0e6870a14f48a886fa8531c750",
            "patch": "@@ -113,3 +113,21 @@ export function standardizeConfig(r: Route): Route {\n   }\n   return c;\n }\n+\n+/** Returns of `Map` of outlet names to the `Route`s for that outlet. */\n+export function groupRoutesByOutlet(routes: Route[]): Map<string, Route[]> {\n+  return routes.reduce((map, route) => {\n+    const routeOutlet = getOutlet(route);\n+    if (map.has(routeOutlet)) {\n+      map.get(routeOutlet)!.push(route);\n+    } else {\n+      map.set(routeOutlet, [route]);\n+    }\n+    return map;\n+  }, new Map<string, Route[]>());\n+}\n+\n+/** Returns the `route.outlet` or PRIMARY_OUTLET if none exists. */\n+export function getOutlet(route: Route): string {\n+  return route.outlet || PRIMARY_OUTLET;\n+}"
        },
        {
            "sha": "3b27bf1fa5b65a0a4d12a78f7082a91deffd8c73",
            "filename": "packages/router/test/apply_redirects.spec.ts",
            "status": "modified",
            "additions": 136,
            "deletions": 2,
            "changes": 138,
            "blob_url": "https://github.com/angular/angular/blob/926ffcd8acedfc0e6870a14f48a886fa8531c750/packages%2Frouter%2Ftest%2Fapply_redirects.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/926ffcd8acedfc0e6870a14f48a886fa8531c750/packages%2Frouter%2Ftest%2Fapply_redirects.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fapply_redirects.spec.ts?ref=926ffcd8acedfc0e6870a14f48a886fa8531c750",
            "patch": "@@ -7,9 +7,9 @@\n  */\n \n import {NgModuleRef} from '@angular/core';\n-import {TestBed} from '@angular/core/testing';\n+import {fakeAsync, TestBed, tick} from '@angular/core/testing';\n import {Observable, of} from 'rxjs';\n-import {delay} from 'rxjs/operators';\n+import {delay, tap} from 'rxjs/operators';\n \n import {applyRedirects} from '../src/apply_redirects';\n import {LoadedRouterConfig, Route, Routes} from '../src/config';\n@@ -482,6 +482,88 @@ describe('applyRedirects', () => {\n             expect((config[0] as any)._loadedConfig).toBe(loadedConfig);\n           });\n     });\n+\n+    it('should load all matching configurations of empty path, including an auxiliary outlets',\n+       fakeAsync(() => {\n+         const loadedConfig =\n+             new LoadedRouterConfig([{path: '', component: ComponentA}], testModule);\n+         let loadCalls = 0;\n+         let loaded: string[] = [];\n+         const loader = {\n+           load: (injector: any, p: Route) => {\n+             loadCalls++;\n+             return of(loadedConfig)\n+                 .pipe(\n+                     delay(100 * loadCalls),\n+                     tap(() => loaded.push(p.loadChildren! as string)),\n+                 );\n+           }\n+         };\n+\n+         const config: Routes =\n+             [{path: '', loadChildren: 'root'}, {path: '', loadChildren: 'aux', outlet: 'popup'}];\n+\n+         applyRedirects(testModule.injector, <any>loader, serializer, tree(''), config).subscribe();\n+         expect(loadCalls).toBe(2);\n+         tick(100);\n+         expect(loaded).toEqual(['root']);\n+         tick(100);\n+         expect(loaded).toEqual(['root', 'aux']);\n+       }));\n+\n+    it('loads only the first match when two Routes with the same outlet have the same path', () => {\n+      const loadedConfig = new LoadedRouterConfig([{path: '', component: ComponentA}], testModule);\n+      let loadCalls = 0;\n+      let loaded: string[] = [];\n+      const loader = {\n+        load: (injector: any, p: Route) => {\n+          loadCalls++;\n+          return of(loadedConfig)\n+              .pipe(\n+                  tap(() => loaded.push(p.loadChildren! as string)),\n+              );\n+        }\n+      };\n+\n+      const config: Routes =\n+          [{path: 'a', loadChildren: 'first'}, {path: 'a', loadChildren: 'second'}];\n+\n+      applyRedirects(testModule.injector, <any>loader, serializer, tree('a'), config).subscribe();\n+      expect(loadCalls).toBe(1);\n+      expect(loaded).toEqual(['first']);\n+    });\n+\n+    it('should load the configuration of empty root path if the entry is an aux outlet',\n+       fakeAsync(() => {\n+         const loadedConfig =\n+             new LoadedRouterConfig([{path: '', component: ComponentA}], testModule);\n+         let loaded: string[] = [];\n+         const rootDelay = 100;\n+         const auxDelay = 1;\n+         const loader = {\n+           load: (injector: any, p: Route) => {\n+             const delayMs = p.loadChildren! as string === 'aux' ? auxDelay : rootDelay;\n+             return of(loadedConfig)\n+                 .pipe(\n+                     delay(delayMs),\n+                     tap(() => loaded.push(p.loadChildren! as string)),\n+                 );\n+           }\n+         };\n+\n+         const config: Routes = [\n+           // Define aux route first so it matches before the primary outlet\n+           {path: 'modal', loadChildren: 'aux', outlet: 'popup'},\n+           {path: '', loadChildren: 'root'},\n+         ];\n+\n+         applyRedirects(testModule.injector, <any>loader, serializer, tree('(popup:modal)'), config)\n+             .subscribe();\n+         tick(auxDelay);\n+         expect(loaded).toEqual(['aux']);\n+         tick(rootDelay);\n+         expect(loaded).toEqual(['aux', 'root']);\n+       }));\n   });\n \n   describe('empty paths', () => {\n@@ -754,6 +836,46 @@ describe('applyRedirects', () => {\n     });\n   });\n \n+  describe('multiple matches with empty path named outlets', () => {\n+    it('should work with redirects when other outlet comes before the one being activated', () => {\n+      applyRedirects(\n+          testModule.injector, null!, serializer, tree(''),\n+          [\n+            {\n+              path: '',\n+              children: [\n+                {path: '', component: ComponentA, outlet: 'aux'},\n+                {path: '', redirectTo: 'b', pathMatch: 'full'},\n+                {path: 'b', component: ComponentB},\n+              ],\n+            },\n+          ])\n+          .subscribe(\n+              (tree: UrlTree) => {\n+                expect(tree.toString()).toEqual('/b');\n+              },\n+              () => {\n+                fail('should not be reached');\n+              });\n+    });\n+\n+    it('should work when entry point is named outlet', () => {\n+      applyRedirects(\n+          testModule.injector, null!, serializer, tree('(popup:modal)'),\n+          [\n+            {path: '', component: ComponentA},\n+            {path: 'modal', component: ComponentB, outlet: 'popup'},\n+          ])\n+          .subscribe(\n+              (tree: UrlTree) => {\n+                expect(tree.toString()).toEqual('/(popup:modal)');\n+              },\n+              (e) => {\n+                fail('should not be reached' + e.message);\n+              });\n+    });\n+  });\n+\n   describe('redirecting to named outlets', () => {\n     it('should work when using absolute redirects', () => {\n       checkRedirect(\n@@ -794,6 +916,18 @@ describe('applyRedirects', () => {\n               });\n     });\n   });\n+\n+  // internal failure b/165719418\n+  it('does not fail with large configs', () => {\n+    const config: Routes = [];\n+    for (let i = 0; i < 400; i++) {\n+      config.push({path: 'no_match', component: ComponentB});\n+    }\n+    config.push({path: 'match', component: ComponentA});\n+    applyRedirects(testModule.injector, null!, serializer, tree('match'), config).forEach(r => {\n+      expectTreeToBe(r, 'match');\n+    });\n+  });\n });\n \n function checkRedirect(config: Routes, url: string, callback: any): void {"
        }
    ],
    "stats": {
        "total": 237,
        "additions": 206,
        "deletions": 31
    }
}