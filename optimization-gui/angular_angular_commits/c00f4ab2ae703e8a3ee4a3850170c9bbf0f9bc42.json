{
    "author": "crisbeto",
    "message": "fix(core): don't consider inherited NG_ELEMENT_ID during DI (#37574)\n\nSpecial DI tokens like `ChangeDetectorRef` and `ElementRef` can provide a factory via `NG_ELEMENT_ID`. The problem is that we were reading it off the token as `token[NG_ELEMENT_ID]` which will go up the prototype chain if it couldn't be found on the current token, resulting in the private `ViewRef` API being exposed, because it extends `ChangeDetectorRef`.\n\nThese changes fix the issue by guarding the property access with `hasOwnProperty`.\n\nFixes #36235.\n\nPR Close #37574",
    "sha": "c00f4ab2ae703e8a3ee4a3850170c9bbf0f9bc42",
    "files": [
        {
            "sha": "5aee59cdd6a5ee982630da9218ff0781208921d5",
            "filename": "packages/core/src/render3/di.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 3,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/c00f4ab2ae703e8a3ee4a3850170c9bbf0f9bc42/packages%2Fcore%2Fsrc%2Frender3%2Fdi.ts",
            "raw_url": "https://github.com/angular/angular/raw/c00f4ab2ae703e8a3ee4a3850170c9bbf0f9bc42/packages%2Fcore%2Fsrc%2Frender3%2Fdi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fdi.ts?ref=c00f4ab2ae703e8a3ee4a3850170c9bbf0f9bc42",
            "patch": "@@ -99,8 +99,12 @@ let nextNgElementId = 0;\n export function bloomAdd(\n     injectorIndex: number, tView: TView, type: Type<any>|InjectionToken<any>|string): void {\n   ngDevMode && assertEqual(tView.firstCreatePass, true, 'expected firstCreatePass to be true');\n-  let id: number|undefined =\n-      typeof type !== 'string' ? (type as any)[NG_ELEMENT_ID] : type.charCodeAt(0) || 0;\n+  let id: number|undefined;\n+  if (typeof type === 'string') {\n+    id = type.charCodeAt(0) || 0;\n+  } else if (type.hasOwnProperty(NG_ELEMENT_ID)) {\n+    id = (type as any)[NG_ELEMENT_ID];\n+  }\n \n   // Set a unique ID on the directive type, so if something tries to inject the directive,\n   // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\n@@ -584,7 +588,9 @@ export function bloomHashBitOrFactory(token: Type<any>|InjectionToken<any>|strin\n   if (typeof token === 'string') {\n     return token.charCodeAt(0) || 0;\n   }\n-  const tokenId: number|undefined = (token as any)[NG_ELEMENT_ID];\n+  const tokenId: number|undefined =\n+      // First check with `hasOwnProperty` so we don't get an inherited ID.\n+      token.hasOwnProperty(NG_ELEMENT_ID) ? (token as any)[NG_ELEMENT_ID] : undefined;\n   // Negative token IDs are used for special objects such as `Injector`\n   return (typeof tokenId === 'number' && tokenId > 0) ? tokenId & BLOOM_MASK : tokenId;\n }"
        },
        {
            "sha": "8c0396654fc3565841b6e81e2e006f09e70cca67",
            "filename": "packages/core/test/acceptance/di_spec.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 9,
            "changes": 30,
            "blob_url": "https://github.com/angular/angular/blob/c00f4ab2ae703e8a3ee4a3850170c9bbf0f9bc42/packages%2Fcore%2Ftest%2Facceptance%2Fdi_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/c00f4ab2ae703e8a3ee4a3850170c9bbf0f9bc42/packages%2Fcore%2Ftest%2Facceptance%2Fdi_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fdi_spec.ts?ref=c00f4ab2ae703e8a3ee4a3850170c9bbf0f9bc42",
            "patch": "@@ -7,9 +7,9 @@\n  */\n \n import {CommonModule} from '@angular/common';\n-import {Attribute, ChangeDetectorRef, Component, ComponentFactoryResolver, ComponentRef, Directive, ElementRef, EventEmitter, forwardRef, Host, HostBinding, Inject, Injectable, InjectionToken, INJECTOR, Injector, Input, LOCALE_ID, ModuleWithProviders, NgModule, NgZone, Optional, Output, Pipe, PipeTransform, Self, SkipSelf, TemplateRef, ViewChild, ViewContainerRef, ɵDEFAULT_LOCALE_ID as DEFAULT_LOCALE_ID} from '@angular/core';\n+import {Attribute, ChangeDetectorRef, Component, ComponentFactoryResolver, ComponentRef, Directive, ElementRef, EventEmitter, forwardRef, Host, HostBinding, Inject, Injectable, InjectionToken, INJECTOR, Injector, Input, LOCALE_ID, ModuleWithProviders, NgModule, NgZone, Optional, Output, Pipe, PipeTransform, Self, SkipSelf, TemplateRef, ViewChild, ViewContainerRef, ViewRef, ɵDEFAULT_LOCALE_ID as DEFAULT_LOCALE_ID} from '@angular/core';\n import {ɵINJECTOR_SCOPE} from '@angular/core/src/core';\n-import {ViewRef} from '@angular/core/src/render3/view_ref';\n+import {ViewRef as ViewRefInternal} from '@angular/core/src/render3/view_ref';\n import {TestBed} from '@angular/core/testing';\n import {ivyEnabled, onlyInIvy} from '@angular/private/testing';\n import {BehaviorSubject} from 'rxjs';\n@@ -1627,7 +1627,8 @@ describe('di', () => {\n         TestBed.configureTestingModule({declarations: [MyApp, MyPipe], imports: [CommonModule]});\n         const fixture = TestBed.createComponent(MyApp);\n         fixture.detectChanges();\n-        expect((pipeInstance!.cdr as ViewRef<MyApp>).context).toBe(fixture.componentInstance);\n+        expect((pipeInstance!.cdr as ViewRefInternal<MyApp>).context)\n+            .toBe(fixture.componentInstance);\n       });\n \n       it('should inject current component ChangeDetectorRef into directives on the same node as components',\n@@ -1643,7 +1644,7 @@ describe('di', () => {\n            fixture.detectChanges();\n            const app = fixture.componentInstance;\n            const comp = fixture.componentInstance.component;\n-           expect((comp!.cdr as ViewRef<MyComp>).context).toBe(comp);\n+           expect((comp!.cdr as ViewRefInternal<MyComp>).context).toBe(comp);\n            // ChangeDetectorRef is the token, ViewRef has historically been the constructor\n            expect(app.directive.value).toContain('ViewRef');\n \n@@ -1664,7 +1665,7 @@ describe('di', () => {\n            const fixture = TestBed.createComponent(MyComp);\n            fixture.detectChanges();\n            const comp = fixture.componentInstance;\n-           expect((comp!.cdr as ViewRef<MyComp>).context).toBe(comp);\n+           expect((comp!.cdr as ViewRefInternal<MyComp>).context).toBe(comp);\n            // ChangeDetectorRef is the token, ViewRef has historically been the constructor\n            expect(comp.directive.value).toContain('ViewRef');\n \n@@ -1692,7 +1693,7 @@ describe('di', () => {\n            const fixture = TestBed.createComponent(MyApp);\n            fixture.detectChanges();\n            const app = fixture.componentInstance;\n-           expect((app!.cdr as ViewRef<MyApp>).context).toBe(app);\n+           expect((app!.cdr as ViewRefInternal<MyApp>).context).toBe(app);\n            const comp = fixture.componentInstance.component;\n            // ChangeDetectorRef is the token, ViewRef has historically been the constructor\n            expect(app.directive.value).toContain('ViewRef');\n@@ -1720,7 +1721,7 @@ describe('di', () => {\n         const fixture = TestBed.createComponent(MyComp);\n         fixture.detectChanges();\n         const comp = fixture.componentInstance;\n-        expect((comp!.cdr as ViewRef<MyComp>).context).toBe(comp);\n+        expect((comp!.cdr as ViewRefInternal<MyComp>).context).toBe(comp);\n         // ChangeDetectorRef is the token, ViewRef has historically been the constructor\n         expect(comp.directive.value).toContain('ViewRef');\n \n@@ -1743,7 +1744,7 @@ describe('di', () => {\n         const fixture = TestBed.createComponent(MyComp);\n         fixture.detectChanges();\n         const comp = fixture.componentInstance;\n-        expect((comp!.cdr as ViewRef<MyComp>).context).toBe(comp);\n+        expect((comp!.cdr as ViewRefInternal<MyComp>).context).toBe(comp);\n         // ChangeDetectorRef is the token, ViewRef has historically been the constructor\n         expect(comp.directive.value).toContain('ViewRef');\n \n@@ -1773,7 +1774,8 @@ describe('di', () => {\n         TestBed.configureTestingModule({declarations: [MyApp, MyDirective]});\n         const fixture = TestBed.createComponent(MyApp);\n         fixture.detectChanges();\n-        expect((dirInstance!.cdr as ViewRef<MyApp>).context).toBe(fixture.componentInstance);\n+        expect((dirInstance!.cdr as ViewRefInternal<MyApp>).context)\n+            .toBe(fixture.componentInstance);\n       });\n     });\n   });\n@@ -2300,4 +2302,14 @@ describe('di', () => {\n       expect(fixture.componentInstance.dir.token).toBe('parent');\n     });\n   });\n+\n+  it('should not be able to inject ViewRef', () => {\n+    @Component({template: ''})\n+    class App {\n+      constructor(_viewRef: ViewRef) {}\n+    }\n+\n+    TestBed.configureTestingModule({declarations: [App]});\n+    expect(() => TestBed.createComponent(App)).toThrowError(/NullInjectorError/);\n+  });\n });"
        }
    ],
    "stats": {
        "total": 42,
        "additions": 30,
        "deletions": 12
    }
}