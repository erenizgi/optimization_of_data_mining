{
    "author": "mhevery",
    "message": "refactor(core): Add injector debug information to `LViewDebug` (#38707)\n\nExtended the `LViewDebug` to display node-injector information for each\nnode.\n\nPR Close #38707",
    "sha": "b2579d43cdb91d1bbfd524be6b917ef384896ff2",
    "files": [
        {
            "sha": "bda945c9d5a4f446d2846e60faa128d1e6dd688f",
            "filename": "packages/core/src/render3/assert.ts",
            "status": "modified",
            "additions": 55,
            "deletions": 3,
            "changes": 58,
            "blob_url": "https://github.com/angular/angular/blob/b2579d43cdb91d1bbfd524be6b917ef384896ff2/packages%2Fcore%2Fsrc%2Frender3%2Fassert.ts",
            "raw_url": "https://github.com/angular/angular/raw/b2579d43cdb91d1bbfd524be6b917ef384896ff2/packages%2Fcore%2Fsrc%2Frender3%2Fassert.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fassert.ts?ref=b2579d43cdb91d1bbfd524be6b917ef384896ff2",
            "patch": "@@ -6,14 +6,14 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {assertDefined, assertEqual, throwError} from '../util/assert';\n-\n+import {assertDefined, assertEqual, assertIndexInRange, assertNumber, throwError} from '../util/assert';\n import {getComponentDef, getNgModuleDef} from './definition';\n import {LContainer} from './interfaces/container';\n import {DirectiveDef} from './interfaces/definition';\n+import { PARENT_INJECTOR } from './interfaces/injector';\n import {TNode} from './interfaces/node';\n import {isLContainer, isLView} from './interfaces/type_checks';\n-import {LView, TVIEW, TView} from './interfaces/view';\n+import {HEADER_OFFSET, LView, TVIEW, TView} from './interfaces/view';\n \n // [Assert functions do not constraint type when they are guarded by a truthy\n // expression.](https://github.com/microsoft/TypeScript/issues/37295)\n@@ -96,3 +96,55 @@ export function assertDirectiveDef<T>(obj: any): asserts obj is DirectiveDef<T>\n         `Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);\n   }\n }\n+\n+export function assertIndexInDeclRange(lView: LView, index: number) {\n+  const tView = lView[1];\n+  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);\n+}\n+\n+export function assertIndexInVarsRange(lView: LView, index: number) {\n+  const tView = lView[1];\n+  assertBetween(\n+      tView.bindingStartIndex, (tView as any as {i18nStartIndex: number}).i18nStartIndex, index);\n+}\n+\n+export function assertIndexInI18nRange(lView: LView, index: number) {\n+  const tView = lView[1];\n+  assertBetween(\n+      (tView as any as {i18nStartIndex: number}).i18nStartIndex, tView.expandoStartIndex, index);\n+}\n+\n+export function assertIndexInExpandoRange(lView: LView, index: number) {\n+  const tView = lView[1];\n+  assertBetween(tView.expandoStartIndex, lView.length, index);\n+}\n+\n+export function assertBetween(lower: number, upper: number, index: number) {\n+  if (!(lower <= index && index < upper)) {\n+    throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);\n+  }\n+}\n+\n+\n+/**\n+ * This is a basic sanity check that the `injectorIndex` seems to point to what looks like a\n+ * NodeInjector data structure.\n+ *\n+ * @param lView `LView` which should be checked.\n+ * @param injectorIndex index into the `LView` where the `NodeInjector` is expected.\n+ */\n+export function assertNodeInjector(lView: LView, injectorIndex: number) {\n+  assertIndexInExpandoRange(lView, injectorIndex);\n+  assertIndexInExpandoRange(lView, injectorIndex + PARENT_INJECTOR);\n+  assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');\n+  assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');\n+  assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');\n+  assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');\n+  assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');\n+  assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');\n+  assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');\n+  assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');\n+  assertNumber(\n+      lView[injectorIndex + 8 /*PARENT_INJECTOR*/],\n+      'injectorIndex should point to parent injector');\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "3c75066753898b042e66a172f630c6aa32984cee",
            "filename": "packages/core/src/render3/features/providers_feature.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/b2579d43cdb91d1bbfd524be6b917ef384896ff2/packages%2Fcore%2Fsrc%2Frender3%2Ffeatures%2Fproviders_feature.ts",
            "raw_url": "https://github.com/angular/angular/raw/b2579d43cdb91d1bbfd524be6b917ef384896ff2/packages%2Fcore%2Fsrc%2Frender3%2Ffeatures%2Fproviders_feature.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Ffeatures%2Fproviders_feature.ts?ref=b2579d43cdb91d1bbfd524be6b917ef384896ff2",
            "patch": "@@ -32,7 +32,7 @@ import {DirectiveDef} from '../interfaces/definition';\n  *        ɵɵtextInterpolate(ctx.greeter.greet());\n  *      }\n  *    },\n- *    features: [ProvidersFeature([GreeterDE])]\n+ *    features: [ɵɵProvidersFeature([GreeterDE])]\n  *  });\n  * }\n  * ```"
        },
        {
            "sha": "5521e3a3701a5bd2cbef00f12f9d643903a7638b",
            "filename": "packages/core/src/render3/instructions/lview_debug.ts",
            "status": "modified",
            "additions": 125,
            "deletions": 31,
            "changes": 156,
            "blob_url": "https://github.com/angular/angular/blob/b2579d43cdb91d1bbfd524be6b917ef384896ff2/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Flview_debug.ts",
            "raw_url": "https://github.com/angular/angular/raw/b2579d43cdb91d1bbfd524be6b917ef384896ff2/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Flview_debug.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finstructions%2Flview_debug.ts?ref=b2579d43cdb91d1bbfd524be6b917ef384896ff2",
            "patch": "@@ -6,21 +6,25 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {Injector, SchemaMetadata} from '../../core';\n+import {Injector, SchemaMetadata, Type} from '../../core';\n import {Sanitizer} from '../../sanitization/sanitizer';\n import {KeyValueArray} from '../../util/array_utils';\n import {assertDefined} from '../../util/assert';\n import {createNamedArrayType} from '../../util/named_array_type';\n import {initNgDevMode} from '../../util/ng_dev_mode';\n+import {assertNodeInjector} from '../assert';\n+import {getInjectorIndex} from '../di';\n import {CONTAINER_HEADER_OFFSET, HAS_TRANSPLANTED_VIEWS, LContainer, MOVED_VIEWS, NATIVE} from '../interfaces/container';\n-import {ComponentTemplate, DirectiveDefList, PipeDefList, ViewQueriesFunction} from '../interfaces/definition';\n+import {ComponentTemplate, DirectiveDef, DirectiveDefList, PipeDefList, ViewQueriesFunction} from '../interfaces/definition';\n+import {NO_PARENT_INJECTOR, PARENT_INJECTOR, TNODE} from '../interfaces/injector';\n import {AttributeMarker, PropertyAliases, TConstants, TContainerNode, TElementNode, TNode as ITNode, TNodeFlags, TNodeProviderIndexes, TNodeType, TNodeTypeAsString, TViewNode} from '../interfaces/node';\n import {SelectorFlags} from '../interfaces/projection';\n import {LQueries, TQueries} from '../interfaces/query';\n import {RComment, RElement, Renderer3, RendererFactory3, RNode} from '../interfaces/renderer';\n import {getTStylingRangeNext, getTStylingRangeNextDuplicate, getTStylingRangePrev, getTStylingRangePrevDuplicate, TStylingKey, TStylingRange} from '../interfaces/styling';\n-import {CHILD_HEAD, CHILD_TAIL, CLEANUP, CONTEXT, DebugNode, DECLARATION_VIEW, DestroyHookData, ExpandoInstructions, FLAGS, HEADER_OFFSET, HookData, HOST, INJECTOR, LContainerDebug as ILContainerDebug, LView, LViewDebug as ILViewDebug, LViewDebugRange, LViewDebugRangeContent, LViewFlags, NEXT, PARENT, QUERIES, RENDERER, RENDERER_FACTORY, SANITIZER, T_HOST, TData, TView as ITView, TVIEW, TView, TViewType} from '../interfaces/view';\n+import {CHILD_HEAD, CHILD_TAIL, CLEANUP, CONTEXT, DebugNode, DECLARATION_VIEW, DestroyHookData, ExpandoInstructions, FLAGS, HEADER_OFFSET, HookData, HOST, INJECTOR, LContainerDebug as ILContainerDebug, LView, LViewDebug as ILViewDebug, LViewDebugRange, LViewDebugRangeContent, LViewFlags, NEXT, PARENT, QUERIES, RENDERER, RENDERER_FACTORY, SANITIZER, T_HOST, TData, TView as ITView, TVIEW, TView, TViewType, TViewTypeAsString} from '../interfaces/view';\n import {attachDebugObject} from '../util/debug_utils';\n+import {getParentInjectorIndex, getParentInjectorView} from '../util/injector_utils';\n import {unwrapRNode} from '../util/view_utils';\n \n const NG_DEV_MODE = ((typeof ngDevMode === 'undefined' || !!ngDevMode) && initNgDevMode());\n@@ -152,6 +156,14 @@ export const TViewConstructor = class TView implements ITView {\n     processTNodeChildren(this.firstChild, buf);\n     return buf.join('');\n   }\n+\n+  get type_(): string {\n+    return TViewTypeAsString[this.type] || `TViewType.?${this.type}?`;\n+  }\n+\n+  get i18nStartIndex(): number {\n+    return HEADER_OFFSET + this._decls + this._vars;\n+  }\n };\n \n class TNode implements ITNode {\n@@ -189,23 +201,39 @@ class TNode implements ITNode {\n       public styleBindings: TStylingRange,                                           //\n   ) {}\n \n-  get type_(): string {\n-    switch (this.type) {\n-      case TNodeType.Container:\n-        return 'TNodeType.Container';\n-      case TNodeType.Element:\n-        return 'TNodeType.Element';\n-      case TNodeType.ElementContainer:\n-        return 'TNodeType.ElementContainer';\n-      case TNodeType.IcuContainer:\n-        return 'TNodeType.IcuContainer';\n-      case TNodeType.Projection:\n-        return 'TNodeType.Projection';\n-      case TNodeType.View:\n-        return 'TNodeType.View';\n-      default:\n-        return 'TNodeType.???';\n+  /**\n+   * Return a human debug version of the set of `NodeInjector`s which will be consulted when\n+   * resolving tokens from this `TNode`.\n+   *\n+   * When debugging applications, it is often difficult to determine which `NodeInjector`s will be\n+   * consulted. This method shows a list of `DebugNode`s representing the `TNode`s which will be\n+   * consulted in order when resolving a token starting at this `TNode`.\n+   *\n+   * The original data is stored in `LView` and `TView` with a lot of offset indexes, and so it is\n+   * difficult to reason about.\n+   *\n+   * @param lView The `LView` instance for this `TNode`.\n+   */\n+  debugNodeInjectorPath(lView: LView): DebugNode[] {\n+    const path: DebugNode[] = [];\n+    let injectorIndex = getInjectorIndex(this, lView);\n+    ngDevMode && assertNodeInjector(lView, injectorIndex);\n+    while (injectorIndex !== -1) {\n+      const tNode = lView[TVIEW].data[injectorIndex + TNODE] as TNode;\n+      path.push(buildDebugNode(tNode, lView));\n+      const parentLocation = lView[injectorIndex + PARENT_INJECTOR];\n+      if (parentLocation === NO_PARENT_INJECTOR) {\n+        injectorIndex = -1;\n+      } else {\n+        injectorIndex = getParentInjectorIndex(parentLocation);\n+        lView = getParentInjectorView(parentLocation, lView);\n+      }\n     }\n+    return path;\n+  }\n+\n+  get type_(): string {\n+    return TNodeTypeAsString[this.type] || `TNodeType.?${this.type}?`;\n   }\n \n   get flags_(): string {\n@@ -246,6 +274,14 @@ class TNode implements ITNode {\n   get classBindings_(): DebugStyleBindings {\n     return toDebugStyleBinding(this, true);\n   }\n+\n+  get providerIndexStart_(): number {\n+    return this.providerIndexes & TNodeProviderIndexes.ProvidersStartIndexMask;\n+  }\n+  get providerIndexEnd_(): number {\n+    return this.providerIndexStart_ +\n+        (this.providerIndexes >>> TNodeProviderIndexes.CptViewProvidersCountShift);\n+  }\n }\n export const TNodeDebug = TNode;\n export type TNodeDebug = TNode;\n@@ -462,21 +498,21 @@ export class LViewDebug implements ILViewDebug {\n   }\n \n   get decls(): LViewDebugRange {\n-    const tView = this.tView as any as {_decls: number, _vars: number};\n-    const start = HEADER_OFFSET;\n-    return toLViewRange(this.tView, this._raw_lView, start, start + tView._decls);\n+    return toLViewRange(this.tView, this._raw_lView, HEADER_OFFSET, this.tView.bindingStartIndex);\n   }\n \n   get vars(): LViewDebugRange {\n-    const tView = this.tView as any as {_decls: number, _vars: number};\n-    const start = HEADER_OFFSET + tView._decls;\n-    return toLViewRange(this.tView, this._raw_lView, start, start + tView._vars);\n+    const tView = this.tView;\n+    return toLViewRange(\n+        tView, this._raw_lView, tView.bindingStartIndex,\n+        (tView as any as {i18nStartIndex: number}).i18nStartIndex);\n   }\n \n   get i18n(): LViewDebugRange {\n-    const tView = this.tView as any as {_decls: number, _vars: number};\n-    const start = HEADER_OFFSET + tView._decls + tView._vars;\n-    return toLViewRange(this.tView, this._raw_lView, start, this.tView.expandoStartIndex);\n+    const tView = this.tView;\n+    return toLViewRange(\n+        tView, this._raw_lView, (tView as any as {i18nStartIndex: number}).i18nStartIndex,\n+        tView.expandoStartIndex);\n   }\n \n   get expando(): LViewDebugRange {\n@@ -518,7 +554,7 @@ export function toDebugNodes(tNode: ITNode|null, lView: LView): DebugNode[] {\n     const debugNodes: DebugNode[] = [];\n     let tNodeCursor: ITNode|null = tNode;\n     while (tNodeCursor) {\n-      debugNodes.push(buildDebugNode(tNodeCursor, lView, tNodeCursor.index));\n+      debugNodes.push(buildDebugNode(tNodeCursor, lView));\n       tNodeCursor = tNodeCursor.next;\n     }\n     return debugNodes;\n@@ -527,17 +563,75 @@ export function toDebugNodes(tNode: ITNode|null, lView: LView): DebugNode[] {\n   }\n }\n \n-export function buildDebugNode(tNode: ITNode, lView: LView, nodeIndex: number): DebugNode {\n-  const rawValue = lView[nodeIndex];\n+export function buildDebugNode(tNode: ITNode, lView: LView): DebugNode {\n+  const rawValue = lView[tNode.index];\n   const native = unwrapRNode(rawValue);\n+  const factories: Type<any>[] = [];\n+  const instances: any[] = [];\n+  const tView = lView[TVIEW];\n+  for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {\n+    const def = tView.data[i] as DirectiveDef<any>;\n+    factories.push(def.type);\n+    instances.push(lView[i]);\n+  }\n   return {\n     html: toHtml(native),\n     type: TNodeTypeAsString[tNode.type],\n     native: native as any,\n     children: toDebugNodes(tNode.child, lView),\n+    factories,\n+    instances,\n+    injector: buildNodeInjectorDebug(tNode, tView, lView)\n   };\n }\n \n+function buildNodeInjectorDebug(tNode: ITNode, tView: ITView, lView: LView) {\n+  const viewProviders: Type<any>[] = [];\n+  for (let i = (tNode as TNode).providerIndexStart_; i < (tNode as TNode).providerIndexEnd_; i++) {\n+    viewProviders.push(tView.data[i] as Type<any>);\n+  }\n+  const providers: Type<any>[] = [];\n+  for (let i = (tNode as TNode).providerIndexEnd_; i < (tNode as TNode).directiveEnd; i++) {\n+    providers.push(tView.data[i] as Type<any>);\n+  }\n+  const nodeInjectorDebug = {\n+    bloom: toBloom(lView, tNode.injectorIndex),\n+    cumulativeBloom: toBloom(tView.data, tNode.injectorIndex),\n+    providers,\n+    viewProviders,\n+    parentInjectorIndex: lView[(tNode as TNode).providerIndexStart_ - 1],\n+  };\n+  return nodeInjectorDebug;\n+}\n+\n+/**\n+ * Convert a number at `idx` location in `array` into binary representation.\n+ *\n+ * @param array\n+ * @param idx\n+ */\n+function binary(array: any[], idx: number): string {\n+  const value = array[idx];\n+  // If not a number we print 8 `?` to retain alignment but let user know that it was called on\n+  // wrong type.\n+  if (typeof value !== 'number') return '????????';\n+  // We prefix 0s so that we have constant length number\n+  const text = '00000000' + value.toString(2);\n+  return text.substring(text.length - 8);\n+}\n+\n+/**\n+ * Convert a bloom filter at location `idx` in `array` into binary representation.\n+ *\n+ * @param array\n+ * @param idx\n+ */\n+function toBloom(array: any[], idx: number): string {\n+  return `${binary(array, idx + 7)}_${binary(array, idx + 6)}_${binary(array, idx + 5)}_${\n+      binary(array, idx + 4)}_${binary(array, idx + 3)}_${binary(array, idx + 2)}_${\n+      binary(array, idx + 1)}_${binary(array, idx + 0)}`;\n+}\n+\n export class LContainerDebug implements ILContainerDebug {\n   constructor(private readonly _raw_lContainer: LContainer) {}\n "
        },
        {
            "sha": "1c5da2b9a4faf3f4071b60072ba19138324a0e5c",
            "filename": "packages/core/src/render3/interfaces/injector.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/b2579d43cdb91d1bbfd524be6b917ef384896ff2/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Finjector.ts",
            "raw_url": "https://github.com/angular/angular/raw/b2579d43cdb91d1bbfd524be6b917ef384896ff2/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Finjector.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Finjector.ts?ref=b2579d43cdb91d1bbfd524be6b917ef384896ff2",
            "patch": "@@ -9,6 +9,7 @@\n import {InjectionToken} from '../../di/injection_token';\n import {InjectFlags} from '../../di/interface/injector';\n import {Type} from '../../interface/type';\n+import {assertDefined, assertEqual} from '../../util/assert';\n \n import {TDirectiveHostNode} from './node';\n import {LView, TData} from './view';\n@@ -239,6 +240,8 @@ export class NodeInjectorFactory {\n       isViewProvider: boolean,\n       injectImplementation: null|\n       (<T>(token: Type<T>|InjectionToken<T>, flags?: InjectFlags) => T)) {\n+    ngDevMode && assertDefined(factory, 'Factory not specified');\n+    ngDevMode && assertEqual(typeof factory, 'function', 'Expected factory function.');\n     this.canSeeViewProviders = isViewProvider;\n     this.injectImpl = injectImplementation;\n   }"
        },
        {
            "sha": "2c96f100bbf4ab1552d1797613c38721e60a3530",
            "filename": "packages/core/src/render3/interfaces/view.ts",
            "status": "modified",
            "additions": 44,
            "deletions": 0,
            "changes": 44,
            "blob_url": "https://github.com/angular/angular/blob/b2579d43cdb91d1bbfd524be6b917ef384896ff2/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fview.ts",
            "raw_url": "https://github.com/angular/angular/raw/b2579d43cdb91d1bbfd524be6b917ef384896ff2/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fview.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Finterfaces%2Fview.ts?ref=b2579d43cdb91d1bbfd524be6b917ef384896ff2",
            "patch": "@@ -1021,4 +1021,48 @@ export interface DebugNode {\n    * Child nodes\n    */\n   children: DebugNode[];\n+\n+  /**\n+   * A list of Component/Directive types which need to be instantiated an this location.\n+   */\n+  factories: Type<unknown>[];\n+\n+  /**\n+   * A list of Component/Directive instances which were instantiated an this location.\n+   */\n+  instances: unknown[];\n+\n+  /**\n+   * NodeInjector information.\n+   */\n+  injector: NodeInjectorDebug;\n+}\n+\n+interface NodeInjectorDebug {\n+  /**\n+   * Instance bloom. Does the current injector have a provider with a given bloom mask.\n+   */\n+  bloom: string;\n+\n+\n+  /**\n+   * Cumulative bloom. Do any of the above injectors have a provider with a given bloom mask.\n+   */\n+  cumulativeBloom: string;\n+\n+  /**\n+   * A list of providers associated with this injector.\n+   */\n+  providers: (Type<unknown>|DirectiveDef<unknown>|ComponentDef<unknown>)[];\n+\n+  /**\n+   * A list of providers associated with this injector visible to the view of the component only.\n+   */\n+  viewProviders: Type<unknown>[];\n+\n+\n+  /**\n+   * Location of the parent `TNode`.\n+   */\n+  parentInjectorIndex: number;\n }\n\\ No newline at end of file"
        },
        {
            "sha": "1c66981fc84437b492ee3bbdb0690d713495b2a9",
            "filename": "packages/core/src/render3/util/discovery_utils.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/b2579d43cdb91d1bbfd524be6b917ef384896ff2/packages%2Fcore%2Fsrc%2Frender3%2Futil%2Fdiscovery_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/b2579d43cdb91d1bbfd524be6b917ef384896ff2/packages%2Fcore%2Fsrc%2Frender3%2Futil%2Fdiscovery_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Futil%2Fdiscovery_utils.ts?ref=b2579d43cdb91d1bbfd524be6b917ef384896ff2",
            "patch": "@@ -389,7 +389,7 @@ export function getDebugNode(element: Element): DebugNode|null {\n     // data. In this situation the TNode is not accessed at the same spot.\n     const tNode = isLView(valueInLView) ? (valueInLView[T_HOST] as TNode) :\n                                           getTNode(lView[TVIEW], nodeIndex - HEADER_OFFSET);\n-    debugNode = buildDebugNode(tNode, lView, nodeIndex);\n+    debugNode = buildDebugNode(tNode, lView);\n   }\n \n   return debugNode;"
        },
        {
            "sha": "bd35fa870e4ff3f56875dd6375a777e23f7e1552",
            "filename": "packages/core/test/render3/instructions/lview_debug_spec.ts",
            "status": "modified",
            "additions": 87,
            "deletions": 1,
            "changes": 88,
            "blob_url": "https://github.com/angular/angular/blob/b2579d43cdb91d1bbfd524be6b917ef384896ff2/packages%2Fcore%2Ftest%2Frender3%2Finstructions%2Flview_debug_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/b2579d43cdb91d1bbfd524be6b917ef384896ff2/packages%2Fcore%2Ftest%2Frender3%2Finstructions%2Flview_debug_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Frender3%2Finstructions%2Flview_debug_spec.ts?ref=b2579d43cdb91d1bbfd524be6b917ef384896ff2",
            "patch": "@@ -6,14 +6,16 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n+import {ɵɵdefineComponent, ɵɵdefineDirective, ɵɵdirectiveInject, ɵɵProvidersFeature} from '@angular/core/src/core';\n+import {ɵɵelement, ɵɵelementEnd, ɵɵelementStart} from '@angular/core/src/render3/instructions/element';\n import {TNodeDebug} from '@angular/core/src/render3/instructions/lview_debug';\n import {createTNode, createTView} from '@angular/core/src/render3/instructions/shared';\n import {TNodeType} from '@angular/core/src/render3/interfaces/node';\n import {LView, TView, TViewType} from '@angular/core/src/render3/interfaces/view';\n import {enterView, leaveView} from '@angular/core/src/render3/state';\n import {insertTStylingBinding} from '@angular/core/src/render3/styling/style_binding_list';\n import {KeyValueArray} from '@angular/core/src/util/array_utils';\n-\n+import {TemplateFixture} from '../render_util';\n \n describe('lView_debug', () => {\n   const mockFirstUpdatePassLView: LView = [null, {firstUpdatePass: true}] as any;\n@@ -151,4 +153,88 @@ describe('lView_debug', () => {\n       });\n     });\n   });\n+\n+  describe('di', () => {\n+    it('should show basic information', () => {\n+      class DepA {\n+        static ɵfac = () => new DepA();\n+      }\n+      class DepB {\n+        static ɵfac = () => new DepB();\n+      }\n+\n+      const instances: any[] = [];\n+      class MyComponent {\n+        constructor(public depA: DepA, public depB: DepB) {\n+          instances.push(this);\n+        }\n+        static ɵfac = () => new MyComponent(ɵɵdirectiveInject(DepA), ɵɵdirectiveInject(DepB));\n+        static ɵcmp = ɵɵdefineComponent({\n+          type: MyComponent,\n+          selectors: [['my-comp']],\n+          decls: 1,\n+          vars: 0,\n+          template: function() {},\n+          features: [ɵɵProvidersFeature(\n+              [DepA, {provide: String, useValue: 'String'}],\n+              [DepB, {provide: Number, useValue: 123}])]\n+        });\n+      }\n+\n+      let myChild!: MyChild;\n+      class MyChild {\n+        constructor() {\n+          myChild = this;\n+        }\n+        static ɵfac = () => new MyChild();\n+        static ɵdir = ɵɵdefineDirective({\n+          type: MyChild,\n+          selectors: [['my-child']],\n+        });\n+      }\n+\n+\n+      class MyDirective {\n+        constructor(public myComp: MyComponent) {\n+          instances.push(this);\n+        }\n+        static ɵfac = () => new MyDirective(ɵɵdirectiveInject(MyComponent));\n+        static ɵdir = ɵɵdefineDirective({\n+          type: MyDirective,\n+          selectors: [['', 'my-dir', '']],\n+        });\n+      }\n+\n+      const fixture = new TemplateFixture(\n+          () => {\n+            ɵɵelementStart(0, 'my-comp', 0);\n+            ɵɵelement(1, 'my-child');\n+            ɵɵelementEnd();\n+          },\n+          () => null, 2, 0, [MyComponent, MyDirective, MyChild], null, null, undefined,\n+          [['my-dir', '']]);\n+      const lView = fixture.hostView;\n+      const lViewDebug = lView.debug!;\n+      const myCompNode = lViewDebug.nodes[0];\n+      expect(myCompNode.factories).toEqual([MyComponent, MyDirective]);\n+      expect(myCompNode.instances).toEqual(instances);\n+      expect(myCompNode.injector).toEqual({\n+        bloom: jasmine.anything(),\n+        cumulativeBloom: jasmine.anything(),\n+        providers: [DepA, String, MyComponent.ɵcmp, MyDirective.ɵdir],\n+        viewProviders: [DepB, Number],\n+        parentInjectorIndex: -1,\n+      });\n+      const myChildNode = myCompNode.children[0];\n+      expect(myChildNode.factories).toEqual([MyChild]);\n+      expect(myChildNode.instances).toEqual([myChild]);\n+      expect(myChildNode.injector).toEqual({\n+        bloom: jasmine.anything(),\n+        cumulativeBloom: jasmine.anything(),\n+        providers: [MyChild.ɵdir],\n+        viewProviders: [],\n+        parentInjectorIndex: 22,\n+      });\n+    });\n+  });\n });"
        }
    ],
    "stats": {
        "total": 353,
        "additions": 316,
        "deletions": 37
    }
}