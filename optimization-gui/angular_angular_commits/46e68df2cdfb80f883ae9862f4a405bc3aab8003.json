{
    "author": "danieltre23",
    "message": "refactor(compiler-cli): add abstract `TemplateCheckWithVisitor` class (#43232)\n\nAdd an abstract class that has a default implementation of the run\nfunction and visits all nodes. Authors of template checks can extend\nthis class and override the `visitNode` method to return diagnostics.\n\nRefs #42966\n\nPR Close #43232",
    "sha": "46e68df2cdfb80f883ae9862f4a405bc3aab8003",
    "files": [
        {
            "sha": "ef89a47904fed42bba276ac811e0f0a5dac13522",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/extended/api/api.ts",
            "status": "modified",
            "additions": 102,
            "deletions": 1,
            "changes": 103,
            "blob_url": "https://github.com/angular/angular/blob/46e68df2cdfb80f883ae9862f4a405bc3aab8003/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fextended%2Fapi%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/46e68df2cdfb80f883ae9862f4a405bc3aab8003/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fextended%2Fapi%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fextended%2Fapi%2Fapi.ts?ref=46e68df2cdfb80f883ae9862f4a405bc3aab8003",
            "patch": "@@ -6,7 +6,8 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {TmplAstNode} from '@angular/compiler';\n+import {AST, RecursiveAstVisitor, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstBoundText, TmplAstContent, TmplAstElement, TmplAstIcu, TmplAstNode, TmplAstRecursiveVisitor, TmplAstReference, TmplAstTemplate, TmplAstText, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n+import {ASTWithSource} from '@angular/compiler/src/compiler';\n import * as ts from 'typescript';\n \n import {ErrorCode} from '../../../diagnostics';\n@@ -38,3 +39,103 @@ export interface TemplateContext {\n    */\n   typeChecker: ts.TypeChecker;\n }\n+\n+/**\n+ * This abstract class provides a base implementation for the run method.\n+ */\n+export abstract class TemplateCheckWithVisitor<T extends ErrorCode> implements TemplateCheck<T> {\n+  abstract code: T;\n+\n+  /**\n+   * Base implementation for run function, visits all nodes in template and calls\n+   * `visitNode()` for each one.\n+   */\n+  run(ctx: TemplateContext, component: ts.ClassDeclaration,\n+      template: TmplAstNode[]): NgTemplateDiagnostic<T>[] {\n+    const visitor = new TemplateVisitor<T>(ctx, component, this);\n+    return visitor.getDiagnostics(template);\n+  }\n+\n+  /**\n+   * Visit a TmplAstNode or AST node of the template. Authors should override this\n+   * method to implement the check and return diagnostics.\n+   */\n+  abstract visitNode(ctx: TemplateContext, component: ts.ClassDeclaration, node: TmplAstNode|AST):\n+      NgTemplateDiagnostic<T>[];\n+}\n+\n+/**\n+ * Visits all nodes in a template (TmplAstNode and AST) and calls `visitNode` for each one.\n+ */\n+class TemplateVisitor<T extends ErrorCode> extends RecursiveAstVisitor implements\n+    TmplAstRecursiveVisitor {\n+  diagnostics: NgTemplateDiagnostic<T>[] = [];\n+\n+  constructor(\n+      private readonly ctx: TemplateContext, private readonly component: ts.ClassDeclaration,\n+      private readonly check: TemplateCheckWithVisitor<T>) {\n+    super();\n+  }\n+\n+  override visit(node: AST|TmplAstNode, context?: any) {\n+    this.diagnostics.push(...this.check.visitNode(this.ctx, this.component, node));\n+    node.visit(this);\n+  }\n+\n+  visitAllNodes(nodes: TmplAstNode[]) {\n+    for (const node of nodes) {\n+      this.visit(node);\n+    }\n+  }\n+\n+  visitAst(ast: AST) {\n+    if (ast instanceof ASTWithSource) {\n+      ast = ast.ast;\n+    }\n+    this.visit(ast);\n+  }\n+\n+  visitElement(element: TmplAstElement) {\n+    this.visitAllNodes(element.attributes);\n+    this.visitAllNodes(element.inputs);\n+    this.visitAllNodes(element.outputs);\n+    this.visitAllNodes(element.references);\n+    this.visitAllNodes(element.children);\n+  }\n+\n+  visitTemplate(template: TmplAstTemplate) {\n+    this.visitAllNodes(template.attributes);\n+    if (template.tagName === 'ng-template') {\n+      // Only visit input/outputs/templateAttrs if this isn't an inline template node\n+      // generated for a structural directive (like `<div *ngIf></div>`). These nodes\n+      // would be visited when the underlying element of an inline template node is processed.\n+      this.visitAllNodes(template.inputs);\n+      this.visitAllNodes(template.outputs);\n+      this.visitAllNodes(template.templateAttrs);\n+    }\n+    this.visitAllNodes(template.variables);\n+    this.visitAllNodes(template.references);\n+    this.visitAllNodes(template.children);\n+  }\n+  visitContent(content: TmplAstContent): void {}\n+  visitVariable(variable: TmplAstVariable): void {}\n+  visitReference(reference: TmplAstReference): void {}\n+  visitTextAttribute(attribute: TmplAstTextAttribute): void {}\n+  visitBoundAttribute(attribute: TmplAstBoundAttribute): void {\n+    this.visitAst(attribute.value);\n+  }\n+  visitBoundEvent(attribute: TmplAstBoundEvent): void {\n+    this.visitAst(attribute.handler);\n+  }\n+  visitText(text: TmplAstText): void {}\n+  visitBoundText(text: TmplAstBoundText): void {\n+    this.visitAst(text.value);\n+  }\n+  visitIcu(icu: TmplAstIcu): void {}\n+\n+  getDiagnostics(template: TmplAstNode[]): NgTemplateDiagnostic<T>[] {\n+    this.diagnostics = [];\n+    this.visitAllNodes(template);\n+    return this.diagnostics;\n+  }\n+}"
        }
    ],
    "stats": {
        "total": 103,
        "additions": 102,
        "deletions": 1
    }
}