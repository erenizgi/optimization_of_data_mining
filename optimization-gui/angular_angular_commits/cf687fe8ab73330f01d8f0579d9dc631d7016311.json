{
    "author": "atscott",
    "message": "refactor(language-service): Remove old testing helpers (#40966)\n\nAll specs have been switched to the new testing package. The old test\nhelpers are no longer needed.\n\nPR Close #40966",
    "sha": "cf687fe8ab73330f01d8f0579d9dc631d7016311",
    "files": [
        {
            "sha": "73b88e66385eea8bf01e71aee169c522f162fab1",
            "filename": "packages/language-service/ivy/test/env.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 226,
            "changes": 226,
            "blob_url": "https://github.com/angular/angular/blob/dcee784b4f176a9428fca9e84a0c8ffdd3e06fcf/packages%2Flanguage-service%2Fivy%2Ftest%2Fenv.ts",
            "raw_url": "https://github.com/angular/angular/raw/dcee784b4f176a9428fca9e84a0c8ffdd3e06fcf/packages%2Flanguage-service%2Fivy%2Ftest%2Fenv.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fenv.ts?ref=dcee784b4f176a9428fca9e84a0c8ffdd3e06fcf",
            "patch": "@@ -1,226 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {TmplAstNode} from '@angular/compiler';\n-import {StrictTemplateOptions} from '@angular/compiler-cli/src/ngtsc/core/api';\n-import {absoluteFrom, AbsoluteFsPath, FileSystem, getFileSystem, getSourceFileOrError} from '@angular/compiler-cli/src/ngtsc/file_system';\n-import {MockFileSystem, TestFile} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n-import {loadStandardTestFiles} from '@angular/compiler-cli/src/ngtsc/testing';\n-import {OptimizeFor, TemplateTypeChecker} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n-import * as ts from 'typescript/lib/tsserverlibrary';\n-\n-import {LanguageService} from '../language_service';\n-\n-import {MockServerHost} from './mock_host';\n-\n-// TODO(alxhub): replace this environment with //packages/language-service/ivy/testing\n-\n-function writeTsconfig(\n-    fs: FileSystem, entryFiles: AbsoluteFsPath[], options: TestableOptions): void {\n-  fs.writeFile(\n-      absoluteFrom('/tsconfig.json'),\n-\n-      JSON.stringify(\n-          {\n-            compilerOptions: {\n-              strict: true,\n-              experimentalDecorators: true,\n-              moduleResolution: 'node',\n-              target: 'es2015',\n-              lib: [\n-                'dom',\n-                'es2015',\n-              ],\n-            },\n-            files: entryFiles,\n-            angularCompilerOptions: {\n-              strictTemplates: true,\n-              ...options,\n-            }\n-          },\n-          null, 2));\n-}\n-\n-export type TestableOptions = StrictTemplateOptions;\n-\n-export class LanguageServiceTestEnvironment {\n-  private constructor(\n-      readonly tsLS: ts.LanguageService, readonly ngLS: LanguageService,\n-      readonly projectService: ts.server.ProjectService, readonly host: MockServerHost) {}\n-\n-  static setup(files: TestFile[], options: TestableOptions = {}): LanguageServiceTestEnvironment {\n-    const fs = getFileSystem();\n-    if (!(fs instanceof MockFileSystem)) {\n-      throw new Error(`LanguageServiceTestEnvironment only works with a mock filesystem`);\n-    }\n-    fs.init(loadStandardTestFiles({\n-      fakeCommon: true,\n-    }));\n-\n-    const host = new MockServerHost(fs);\n-    const tsconfigPath = absoluteFrom('/tsconfig.json');\n-\n-    const entryFiles: AbsoluteFsPath[] = [];\n-    for (const {name, contents, isRoot} of files) {\n-      fs.writeFile(name, contents);\n-      if (isRoot === true) {\n-        entryFiles.push(name);\n-      }\n-    }\n-\n-    if (entryFiles.length === 0) {\n-      throw new Error(`Expected at least one root TestFile.`);\n-    }\n-\n-    writeTsconfig(fs, files.filter(file => file.isRoot === true).map(file => file.name), options);\n-\n-    const projectService = new ts.server.ProjectService({\n-      host,\n-      logger,\n-      cancellationToken: ts.server.nullCancellationToken,\n-      useSingleInferredProject: true,\n-      useInferredProjectPerProjectRoot: true,\n-      typingsInstaller: ts.server.nullTypingsInstaller,\n-    });\n-\n-    // Open all root files.\n-    for (const entryFile of entryFiles) {\n-      projectService.openClientFile(entryFile);\n-    }\n-\n-    const project = projectService.findProject(tsconfigPath);\n-    if (project === undefined) {\n-      throw new Error(`Failed to create project for ${tsconfigPath}`);\n-    }\n-    // The following operation forces a ts.Program to be created.\n-    const tsLS = project.getLanguageService();\n-\n-    const ngLS = new LanguageService(project, tsLS);\n-    return new LanguageServiceTestEnvironment(tsLS, ngLS, projectService, host);\n-  }\n-\n-  getClass(fileName: AbsoluteFsPath, className: string): ts.ClassDeclaration {\n-    const program = this.tsLS.getProgram();\n-    if (program === undefined) {\n-      throw new Error(`Expected to get a ts.Program`);\n-    }\n-    const sf = getSourceFileOrError(program, fileName);\n-    return getClassOrError(sf, className);\n-  }\n-\n-  updateFileWithCursor(fileName: AbsoluteFsPath, contents: string): {cursor: number, text: string} {\n-    const {cursor, text} = extractCursorInfo(contents);\n-    this.updateFile(fileName, text);\n-    return {cursor, text};\n-  }\n-\n-  updateFile(fileName: AbsoluteFsPath, contents: string): void {\n-    const normalFileName = ts.server.toNormalizedPath(fileName);\n-    const scriptInfo =\n-        this.projectService.getOrCreateScriptInfoForNormalizedPath(normalFileName, true, '');\n-    if (scriptInfo === undefined) {\n-      throw new Error(`Could not find a file named ${fileName}`);\n-    }\n-\n-    // Get the current contents to find the length\n-    const len = scriptInfo.getSnapshot().getLength();\n-    scriptInfo.editContent(0, len, contents);\n-  }\n-\n-  expectNoSourceDiagnostics(): void {\n-    const program = this.tsLS.getProgram();\n-    if (program === undefined) {\n-      throw new Error(`Expected to get a ts.Program`);\n-    }\n-\n-    const ngCompiler = this.ngLS.compilerFactory.getOrCreate();\n-\n-    for (const sf of program.getSourceFiles()) {\n-      if (sf.isDeclarationFile || sf.fileName.endsWith('.ngtypecheck.ts')) {\n-        continue;\n-      }\n-\n-      const syntactic = program.getSyntacticDiagnostics(sf);\n-      expect(syntactic.map(diag => diag.messageText)).toEqual([]);\n-      if (syntactic.length > 0) {\n-        continue;\n-      }\n-\n-      const semantic = program.getSemanticDiagnostics(sf);\n-      expect(semantic.map(diag => diag.messageText)).toEqual([]);\n-      if (semantic.length > 0) {\n-        continue;\n-      }\n-\n-      // It's more efficient to optimize for WholeProgram since we call this with every file in the\n-      // program.\n-      const ngDiagnostics = ngCompiler.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram);\n-      expect(ngDiagnostics.map(diag => diag.messageText)).toEqual([]);\n-    }\n-\n-    this.ngLS.compilerFactory.registerLastKnownProgram();\n-  }\n-\n-  expectNoTemplateDiagnostics(fileName: AbsoluteFsPath, className: string): void {\n-    const program = this.tsLS.getProgram();\n-    if (program === undefined) {\n-      throw new Error(`Expected to get a ts.Program`);\n-    }\n-    const sf = getSourceFileOrError(program, fileName);\n-    const component = getClassOrError(sf, className);\n-\n-    const diags = this.getTemplateTypeChecker().getDiagnosticsForComponent(component);\n-    this.ngLS.compilerFactory.registerLastKnownProgram();\n-    expect(diags.map(diag => diag.messageText)).toEqual([]);\n-  }\n-\n-  getTemplateTypeChecker(): TemplateTypeChecker {\n-    return this.ngLS.compilerFactory.getOrCreate().getTemplateTypeChecker();\n-  }\n-}\n-\n-const logger: ts.server.Logger = {\n-  close(): void{},\n-  hasLevel(level: ts.server.LogLevel): boolean {\n-    return false;\n-  },\n-  loggingEnabled(): boolean {\n-    return false;\n-  },\n-  perftrc(s: string): void{},\n-  info(s: string): void{},\n-  startGroup(): void{},\n-  endGroup(): void{},\n-  msg(s: string, type?: ts.server.Msg): void{},\n-  getLogFileName(): string |\n-      undefined {\n-        return;\n-      },\n-};\n-\n-\n-function getClassOrError(sf: ts.SourceFile, name: string): ts.ClassDeclaration {\n-  for (const stmt of sf.statements) {\n-    if (ts.isClassDeclaration(stmt) && stmt.name !== undefined && stmt.name.text === name) {\n-      return stmt;\n-    }\n-  }\n-  throw new Error(`Class ${name} not found in file: ${sf.fileName}: ${sf.text}`);\n-}\n-\n-export function extractCursorInfo(textWithCursor: string): {cursor: number, text: string} {\n-  const cursor = textWithCursor.indexOf('¦');\n-  if (cursor === -1 || textWithCursor.indexOf('¦', cursor + 1) !== -1) {\n-    throw new Error(`Expected to find exactly one cursor symbol '¦'`);\n-  }\n-\n-  return {\n-    cursor,\n-    text: textWithCursor.substr(0, cursor) + textWithCursor.substr(cursor + 1),\n-  };\n-}"
        },
        {
            "sha": "6f99cf1aa5bfacc7e55aace2bc6a54c88b7610ed",
            "filename": "packages/language-service/ivy/test/mock_host.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 121,
            "changes": 121,
            "blob_url": "https://github.com/angular/angular/blob/dcee784b4f176a9428fca9e84a0c8ffdd3e06fcf/packages%2Flanguage-service%2Fivy%2Ftest%2Fmock_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/dcee784b4f176a9428fca9e84a0c8ffdd3e06fcf/packages%2Flanguage-service%2Fivy%2Ftest%2Fmock_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fmock_host.ts?ref=dcee784b4f176a9428fca9e84a0c8ffdd3e06fcf",
            "patch": "@@ -1,121 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {absoluteFrom} from '@angular/compiler-cli/src/ngtsc/file_system';\n-import {MockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n-\n-import * as ts from 'typescript/lib/tsserverlibrary';\n-\n-const NOOP_FILE_WATCHER: ts.FileWatcher = {\n-  close() {}\n-};\n-\n-/**\n- * Adapts from the `ts.server.ServerHost` API to an in-memory filesystem.\n- */\n-export class MockServerHost implements ts.server.ServerHost {\n-  constructor(private fs: MockFileSystem) {}\n-\n-  get newLine(): string {\n-    return '\\n';\n-  }\n-\n-  get useCaseSensitiveFileNames(): boolean {\n-    return this.fs.isCaseSensitive();\n-  }\n-\n-  readFile(path: string, encoding?: string): string|undefined {\n-    return this.fs.readFile(absoluteFrom(path));\n-  }\n-\n-  resolvePath(path: string): string {\n-    return this.fs.resolve(path);\n-  }\n-\n-  fileExists(path: string): boolean {\n-    const absPath = absoluteFrom(path);\n-    return this.fs.exists(absPath) && this.fs.lstat(absPath).isFile();\n-  }\n-\n-  directoryExists(path: string): boolean {\n-    const absPath = absoluteFrom(path);\n-    return this.fs.exists(absPath) && this.fs.lstat(absPath).isDirectory();\n-  }\n-\n-  createDirectory(path: string): void {\n-    this.fs.ensureDir(absoluteFrom(path));\n-  }\n-\n-  getExecutingFilePath(): string {\n-    // This is load-bearing, as TypeScript uses the result of this call to locate the directory in\n-    // which it expects to find .d.ts files for the \"standard libraries\" - DOM, ES2015, etc.\n-    return '/node_modules/typescript/lib/tsserver.js';\n-  }\n-\n-  getCurrentDirectory(): string {\n-    return '/';\n-  }\n-\n-  createHash(data: string): string {\n-    return ts.sys.createHash!(data);\n-  }\n-\n-  get args(): string[] {\n-    throw new Error('Property not implemented.');\n-  }\n-\n-  watchFile(\n-      path: string, callback: ts.FileWatcherCallback, pollingInterval?: number,\n-      options?: ts.WatchOptions): ts.FileWatcher {\n-    return NOOP_FILE_WATCHER;\n-  }\n-\n-  watchDirectory(\n-      path: string, callback: ts.DirectoryWatcherCallback, recursive?: boolean,\n-      options?: ts.WatchOptions): ts.FileWatcher {\n-    return NOOP_FILE_WATCHER;\n-  }\n-\n-  setTimeout(callback: (...args: any[]) => void, ms: number, ...args: any[]) {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  clearTimeout(timeoutId: any): void {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  setImmediate(callback: (...args: any[]) => void, ...args: any[]) {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  clearImmediate(timeoutId: any): void {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  write(s: string): void {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  writeFile(path: string, data: string, writeByteOrderMark?: boolean): void {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  getDirectories(path: string): string[] {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  readDirectory(\n-      path: string, extensions?: readonly string[], exclude?: readonly string[],\n-      include?: readonly string[], depth?: number): string[] {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  exit(exitCode?: number): void {\n-    throw new Error('Method not implemented.');\n-  }\n-}"
        },
        {
            "sha": "4ddb57d80a7bec26f84859d3bdc431b6cae93181",
            "filename": "packages/language-service/ivy/test/test_utils.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 88,
            "changes": 88,
            "blob_url": "https://github.com/angular/angular/blob/dcee784b4f176a9428fca9e84a0c8ffdd3e06fcf/packages%2Flanguage-service%2Fivy%2Ftest%2Ftest_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/dcee784b4f176a9428fca9e84a0c8ffdd3e06fcf/packages%2Flanguage-service%2Fivy%2Ftest%2Ftest_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Ftest_utils.ts?ref=dcee784b4f176a9428fca9e84a0c8ffdd3e06fcf",
            "patch": "@@ -1,88 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import {absoluteFrom as _} from '@angular/compiler-cli/src/ngtsc/file_system';\n-import {TestFile} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n-import {LanguageServiceTestEnvironment, TestableOptions} from '@angular/language-service/ivy/test/env';\n-import * as ts from 'typescript/lib/tsserverlibrary';\n-\n-\n-export function getText(contents: string, textSpan: ts.TextSpan) {\n-  return contents.substr(textSpan.start, textSpan.length);\n-}\n-\n-function last<T>(array: T[]): T {\n-  return array[array.length - 1];\n-}\n-\n-function getFirstClassDeclaration(declaration: string) {\n-  const matches = declaration.match(/(?:export class )(\\w+)(?:\\s|\\{)/);\n-  if (matches === null || matches.length !== 2) {\n-    throw new Error(`Did not find exactly one exported class in: ${declaration}`);\n-  }\n-  return matches[1].trim();\n-}\n-\n-export function createModuleWithDeclarations(\n-    filesWithClassDeclarations: TestFile[], externalResourceFiles: TestFile[] = [],\n-    options: TestableOptions = {}): LanguageServiceTestEnvironment {\n-  const externalClasses =\n-      filesWithClassDeclarations.map(file => getFirstClassDeclaration(file.contents));\n-  const externalImports = filesWithClassDeclarations.map(file => {\n-    const className = getFirstClassDeclaration(file.contents);\n-    const fileName = last(file.name.split('/')).replace('.ts', '');\n-    return `import {${className}} from './${fileName}';`;\n-  });\n-  const contents = `\n-        import {NgModule} from '@angular/core';\n-        import {CommonModule} from '@angular/common';\n-        ${externalImports.join('\\n')}\n-\n-        @NgModule({\n-          declarations: [${externalClasses.join(',')}],\n-          imports: [CommonModule],\n-        })\n-        export class AppModule {}\n-      `;\n-  const moduleFile = {name: _('/app-module.ts'), contents, isRoot: true};\n-  return LanguageServiceTestEnvironment.setup(\n-      [moduleFile, ...filesWithClassDeclarations, ...externalResourceFiles], options);\n-}\n-\n-export function humanizeDocumentSpanLike<T extends ts.DocumentSpan>(\n-    item: T, env: LanguageServiceTestEnvironment, overrides: Map<string, string> = new Map()): T&\n-    Stringy<ts.DocumentSpan> {\n-  const fileContents = (overrides.has(item.fileName) ? overrides.get(item.fileName) :\n-                                                       env.host.readFile(item.fileName)) ??\n-      '';\n-  if (!fileContents) {\n-    throw new Error(`Could not read file ${item.fileName}`);\n-  }\n-  return {\n-    ...item,\n-    textSpan: getText(fileContents, item.textSpan),\n-    contextSpan: item.contextSpan ? getText(fileContents, item.contextSpan) : undefined,\n-    originalTextSpan: item.originalTextSpan ? getText(fileContents, item.originalTextSpan) :\n-                                              undefined,\n-    originalContextSpan:\n-        item.originalContextSpan ? getText(fileContents, item.originalContextSpan) : undefined,\n-  };\n-}\n-type Stringy<T> = {\n-  [P in keyof T]: string;\n-};\n-\n-export function assertFileNames(refs: Array<{fileName: string}>, expectedFileNames: string[]) {\n-  const actualPaths = refs.map(r => r.fileName);\n-  const actualFileNames = actualPaths.map(p => last(p.split('/')));\n-  expect(new Set(actualFileNames)).toEqual(new Set(expectedFileNames));\n-}\n-\n-export function assertTextSpans(items: Array<{textSpan: string}>, expectedTextSpans: string[]) {\n-  const actualSpans = items.map(item => item.textSpan);\n-  expect(new Set(actualSpans)).toEqual(new Set(expectedTextSpans));\n-}"
        }
    ],
    "stats": {
        "total": 435,
        "additions": 0,
        "deletions": 435
    }
}