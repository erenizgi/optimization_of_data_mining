{
    "author": "sonukapoor",
    "message": "feat(service-worker): add `UnrecoverableStateError` (#36847)\n\nIn several occasions it has been observed when the browser has evicted\neagerly cached assets from the cache and which can also not be found on the\nserver anymore. This can lead to broken state where only parts of the application\nwill load and others will fail.\n\nThis commit fixes this issue by checking for the missing asset in the cache\nand on the server. If this condition is true, the broken client will be\nnotified about the current state through the `UnrecoverableStateError`.\n\nCloses #36539\n\nPR Close #36847",
    "sha": "036a2faf02e4dafad80a777f32d6b7c2303139c3",
    "files": [
        {
            "sha": "946a370fdd4ed2d399a591dfa09c524a2fe7ab07",
            "filename": "goldens/public-api/service-worker/service-worker.d.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/036a2faf02e4dafad80a777f32d6b7c2303139c3/goldens%2Fpublic-api%2Fservice-worker%2Fservice-worker.d.ts",
            "raw_url": "https://github.com/angular/angular/raw/036a2faf02e4dafad80a777f32d6b7c2303139c3/goldens%2Fpublic-api%2Fservice-worker%2Fservice-worker.d.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fpublic-api%2Fservice-worker%2Fservice-worker.d.ts?ref=036a2faf02e4dafad80a777f32d6b7c2303139c3",
            "patch": "@@ -29,11 +29,17 @@ export declare class SwUpdate {\n     readonly activated: Observable<UpdateActivatedEvent>;\n     readonly available: Observable<UpdateAvailableEvent>;\n     get isEnabled(): boolean;\n+    readonly unrecoverable: Observable<UnrecoverableStateEvent>;\n     constructor(sw: Éµangular_packages_service_worker_service_worker_a);\n     activateUpdate(): Promise<void>;\n     checkForUpdate(): Promise<void>;\n }\n \n+export declare interface UnrecoverableStateEvent {\n+    reason: string;\n+    type: 'UNRECOVERABLE_STATE';\n+}\n+\n export declare interface UpdateActivatedEvent {\n     current: {\n         hash: string;"
        },
        {
            "sha": "38a540dc2bed94c0fdaa61ce7ea77e70956cb394",
            "filename": "packages/service-worker/src/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/036a2faf02e4dafad80a777f32d6b7c2303139c3/packages%2Fservice-worker%2Fsrc%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/036a2faf02e4dafad80a777f32d6b7c2303139c3/packages%2Fservice-worker%2Fsrc%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fsrc%2Findex.ts?ref=036a2faf02e4dafad80a777f32d6b7c2303139c3",
            "patch": "@@ -14,7 +14,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-export {UpdateActivatedEvent, UpdateAvailableEvent} from './low_level';\n+export {UnrecoverableStateEvent, UpdateActivatedEvent, UpdateAvailableEvent} from './low_level';\n export {ServiceWorkerModule, SwRegistrationOptions} from './module';\n export {SwPush} from './push';\n export {SwUpdate} from './update';"
        },
        {
            "sha": "220e631cd6bff654e311fdcd892a73813b549797",
            "filename": "packages/service-worker/src/low_level.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 1,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/036a2faf02e4dafad80a777f32d6b7c2303139c3/packages%2Fservice-worker%2Fsrc%2Flow_level.ts",
            "raw_url": "https://github.com/angular/angular/raw/036a2faf02e4dafad80a777f32d6b7c2303139c3/packages%2Fservice-worker%2Fsrc%2Flow_level.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fsrc%2Flow_level.ts?ref=036a2faf02e4dafad80a777f32d6b7c2303139c3",
            "patch": "@@ -33,6 +33,22 @@ export interface UpdateActivatedEvent {\n   current: {hash: string, appData?: Object};\n }\n \n+/**\n+ * An event emitted when the version of the app used by the service worker to serve this client is\n+ * in a broken state that cannot be recovered from and a full page reload is required.\n+ *\n+ * For example, the service worker may not be able to retrieve a required resource, neither from the\n+ * cache nor from the server. This could happen if a new version is deployed to the server and the\n+ * service worker cache has been partially cleaned by the browser, removing some files of a previous\n+ * app version but not all.\n+ *\n+ * @publicApi\n+ */\n+export interface UnrecoverableStateEvent {\n+  type: 'UNRECOVERABLE_STATE';\n+  reason: string;\n+}\n+\n /**\n  * An event emitted when a `PushEvent` is received by the service worker.\n  */\n@@ -41,7 +57,7 @@ export interface PushEvent {\n   data: any;\n }\n \n-export type IncomingEvent = UpdateAvailableEvent|UpdateActivatedEvent;\n+export type IncomingEvent = UpdateAvailableEvent|UpdateActivatedEvent|UnrecoverableStateEvent;\n \n export interface TypedEvent {\n   type: string;"
        },
        {
            "sha": "f9a8ad802a2087b3e4f814c969e5e3f39882c5c9",
            "filename": "packages/service-worker/src/update.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 1,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/036a2faf02e4dafad80a777f32d6b7c2303139c3/packages%2Fservice-worker%2Fsrc%2Fupdate.ts",
            "raw_url": "https://github.com/angular/angular/raw/036a2faf02e4dafad80a777f32d6b7c2303139c3/packages%2Fservice-worker%2Fsrc%2Fupdate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fsrc%2Fupdate.ts?ref=036a2faf02e4dafad80a777f32d6b7c2303139c3",
            "patch": "@@ -9,7 +9,7 @@\n import {Injectable} from '@angular/core';\n import {NEVER, Observable} from 'rxjs';\n \n-import {ERR_SW_NOT_SUPPORTED, NgswCommChannel, UpdateActivatedEvent, UpdateAvailableEvent} from './low_level';\n+import {ERR_SW_NOT_SUPPORTED, NgswCommChannel, UnrecoverableStateEvent, UpdateActivatedEvent, UpdateAvailableEvent} from './low_level';\n \n \n \n@@ -31,6 +31,13 @@ export class SwUpdate {\n    */\n   readonly activated: Observable<UpdateActivatedEvent>;\n \n+  /**\n+   * Emits an `UnrecoverableStateEvent` event whenever the version of the app used by the service\n+   * worker to serve this client is in a broken state that cannot be recovered from without a full\n+   * page reload.\n+   */\n+  readonly unrecoverable: Observable<UnrecoverableStateEvent>;\n+\n   /**\n    * True if the Service Worker is enabled (supported by the browser and enabled via\n    * `ServiceWorkerModule`).\n@@ -43,10 +50,12 @@ export class SwUpdate {\n     if (!sw.isEnabled) {\n       this.available = NEVER;\n       this.activated = NEVER;\n+      this.unrecoverable = NEVER;\n       return;\n     }\n     this.available = this.sw.eventsOfType<UpdateAvailableEvent>('UPDATE_AVAILABLE');\n     this.activated = this.sw.eventsOfType<UpdateActivatedEvent>('UPDATE_ACTIVATED');\n+    this.unrecoverable = this.sw.eventsOfType<UnrecoverableStateEvent>('UNRECOVERABLE_STATE');\n   }\n \n   checkForUpdate(): Promise<void> {"
        },
        {
            "sha": "efbc3d55e04e40eac61a23303808180b7f84d04a",
            "filename": "packages/service-worker/test/comm_spec.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/036a2faf02e4dafad80a777f32d6b7c2303139c3/packages%2Fservice-worker%2Ftest%2Fcomm_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/036a2faf02e4dafad80a777f32d6b7c2303139c3/packages%2Fservice-worker%2Ftest%2Fcomm_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Ftest%2Fcomm_spec.ts?ref=036a2faf02e4dafad80a777f32d6b7c2303139c3",
            "patch": "@@ -435,6 +435,14 @@ import {MockPushManager, MockPushSubscription, MockServiceWorkerContainer, MockS\n           },\n         });\n       });\n+      it('processes unrecoverable notifications when sent', done => {\n+        update.unrecoverable.subscribe(event => {\n+          expect(event.reason).toEqual('Invalid Resource');\n+          expect(event.type).toEqual('UNRECOVERABLE_STATE');\n+          done();\n+        });\n+        mock.sendMessage({type: 'UNRECOVERABLE_STATE', reason: 'Invalid Resource'});\n+      });\n       it('processes update activation notifications when sent', done => {\n         update.activated.subscribe(event => {\n           expect(event.previous).toEqual({hash: 'A'});\n@@ -500,6 +508,7 @@ import {MockPushManager, MockPushSubscription, MockServiceWorkerContainer, MockS\n           update = new SwUpdate(comm);\n           update.available.toPromise().catch(err => fail(err));\n           update.activated.toPromise().catch(err => fail(err));\n+          update.unrecoverable.toPromise().catch(err => fail(err));\n         });\n         it('gives an error when checking for updates', done => {\n           update = new SwUpdate(comm);"
        },
        {
            "sha": "c2f4222bdd5c58b8bbea2fc751ec1c01bd2e2244",
            "filename": "packages/service-worker/worker/src/assets.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 5,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/036a2faf02e4dafad80a777f32d6b7c2303139c3/packages%2Fservice-worker%2Fworker%2Fsrc%2Fassets.ts",
            "raw_url": "https://github.com/angular/angular/raw/036a2faf02e4dafad80a777f32d6b7c2303139c3/packages%2Fservice-worker%2Fworker%2Fsrc%2Fassets.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fsrc%2Fassets.ts?ref=036a2faf02e4dafad80a777f32d6b7c2303139c3",
            "patch": "@@ -9,7 +9,7 @@\n import {Adapter, Context} from './adapter';\n import {CacheState, NormalizedUrl, UpdateCacheStatus, UpdateSource, UrlMetadata} from './api';\n import {Database, Table} from './database';\n-import {errorToString, SwCriticalError} from './error';\n+import {errorToString, SwCriticalError, SwUnrecoverableStateError} from './error';\n import {IdleScheduler} from './idle';\n import {AssetGroupConfig} from './manifest';\n import {sha1Binary} from './sha1';\n@@ -145,6 +145,7 @@ export abstract class AssetGroup {\n           return cachedResponse;\n         }\n       }\n+\n       // No already-cached response exists, so attempt a fetch/cache operation. The original request\n       // may specify things like credential inclusion, but for assets these are not honored in order\n       // to avoid issues with opaque responses. The SW requests the data itself.\n@@ -414,10 +415,16 @@ export abstract class AssetGroup {\n \n         // If the response was unsuccessful, there's nothing more that can be done.\n         if (!cacheBustedResult.ok) {\n-          throw new SwCriticalError(\n-              `Response not Ok (cacheBustedFetchFromNetwork): cache busted request for ${\n-                  req.url} returned response ${cacheBustedResult.status} ${\n-                  cacheBustedResult.statusText}`);\n+          if (cacheBustedResult.status === 404) {\n+            throw new SwUnrecoverableStateError(\n+                `Failed to retrieve hashed resource from the server. (AssetGroup: ${\n+                    this.config.name} | URL: ${url})`);\n+          } else {\n+            throw new SwCriticalError(\n+                `Response not Ok (cacheBustedFetchFromNetwork): cache busted request for ${\n+                    req.url} returned response ${cacheBustedResult.status} ${\n+                    cacheBustedResult.statusText}`);\n+          }\n         }\n \n         // Hash the contents."
        },
        {
            "sha": "006cb2cce56139c1e265e6a21d84c2d875d21d51",
            "filename": "packages/service-worker/worker/src/driver.ts",
            "status": "modified",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/angular/angular/blob/036a2faf02e4dafad80a777f32d6b7c2303139c3/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdriver.ts",
            "raw_url": "https://github.com/angular/angular/raw/036a2faf02e4dafad80a777f32d6b7c2303139c3/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdriver.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fsrc%2Fdriver.ts?ref=036a2faf02e4dafad80a777f32d6b7c2303139c3",
            "patch": "@@ -436,6 +436,9 @@ export class Driver implements Debuggable, UpdateSource {\n       // network.\n       res = await appVersion.handleFetch(event.request, event);\n     } catch (err) {\n+      if (err.isUnrecoverableState) {\n+        await this.notifyClientsAboutUnrecoverableState(appVersion, err.message);\n+      }\n       if (err.isCritical) {\n         // Something went wrong with the activation of this version.\n         await this.versionFailed(appVersion, err);\n@@ -1009,6 +1012,26 @@ export class Driver implements Debuggable, UpdateSource {\n     };\n   }\n \n+  async notifyClientsAboutUnrecoverableState(appVersion: AppVersion, reason: string):\n+      Promise<void> {\n+    const broken =\n+        Array.from(this.versions.entries()).find(([hash, version]) => version === appVersion);\n+    if (broken === undefined) {\n+      // This version is no longer in use anyway, so nobody cares.\n+      return;\n+    }\n+\n+    const brokenHash = broken[0];\n+    const affectedClients = Array.from(this.clientVersionMap.entries())\n+                                .filter(([clientId, hash]) => hash === brokenHash)\n+                                .map(([clientId]) => clientId);\n+\n+    affectedClients.forEach(async clientId => {\n+      const client = await this.scope.clients.get(clientId);\n+      client.postMessage({type: 'UNRECOVERABLE_STATE', reason});\n+    });\n+  }\n+\n   async notifyClientsAboutUpdate(next: AppVersion): Promise<void> {\n     await this.initialized;\n "
        },
        {
            "sha": "3bb7ac4276a5839768cbb6037f30ac58a87e1e58",
            "filename": "packages/service-worker/worker/src/error.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/036a2faf02e4dafad80a777f32d6b7c2303139c3/packages%2Fservice-worker%2Fworker%2Fsrc%2Ferror.ts",
            "raw_url": "https://github.com/angular/angular/raw/036a2faf02e4dafad80a777f32d6b7c2303139c3/packages%2Fservice-worker%2Fworker%2Fsrc%2Ferror.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fsrc%2Ferror.ts?ref=036a2faf02e4dafad80a777f32d6b7c2303139c3",
            "patch": "@@ -17,3 +17,7 @@ export function errorToString(error: any): string {\n     return `${error}`;\n   }\n }\n+\n+export class SwUnrecoverableStateError extends SwCriticalError {\n+  readonly isUnrecoverableState: boolean = true;\n+}"
        },
        {
            "sha": "e4cdaaa320af046ac9d63271a72d477321c01247",
            "filename": "packages/service-worker/worker/test/happy_spec.ts",
            "status": "modified",
            "additions": 163,
            "deletions": 0,
            "changes": 163,
            "blob_url": "https://github.com/angular/angular/blob/036a2faf02e4dafad80a777f32d6b7c2303139c3/packages%2Fservice-worker%2Fworker%2Ftest%2Fhappy_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/036a2faf02e4dafad80a777f32d6b7c2303139c3/packages%2Fservice-worker%2Fworker%2Ftest%2Fhappy_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Ftest%2Fhappy_spec.ts?ref=036a2faf02e4dafad80a777f32d6b7c2303139c3",
            "patch": "@@ -1738,6 +1738,169 @@ describe('Driver', () => {\n       expect(requestUrls2).toContain(httpsRequestUrl);\n     });\n \n+    describe('unrecoverable state', () => {\n+      const generateMockServerState = (fileSystem: MockFileSystem) => {\n+        const manifest: Manifest = {\n+          configVersion: 1,\n+          timestamp: 1234567890123,\n+          index: '/index.html',\n+          assetGroups: [{\n+            name: 'assets',\n+            installMode: 'prefetch',\n+            updateMode: 'prefetch',\n+            urls: fileSystem.list(),\n+            patterns: [],\n+            cacheQueryOptions: {ignoreVary: true},\n+          }],\n+          dataGroups: [],\n+          navigationUrls: processNavigationUrls(''),\n+          hashTable: tmpHashTableForFs(fileSystem),\n+        };\n+\n+        return {\n+          serverState: new MockServerStateBuilder()\n+                           .withManifest(manifest)\n+                           .withStaticFiles(fileSystem)\n+                           .build(),\n+          manifest,\n+        };\n+      };\n+\n+      it('notifies affected clients', async () => {\n+        const {serverState: serverState1} = generateMockServerState(\n+            new MockFileSystemBuilder()\n+                .addFile('/index.html', '<script src=\"foo.hash.js\"></script>')\n+                .addFile('/foo.hash.js', 'console.log(\"FOO\");')\n+                .build());\n+\n+        const {serverState: serverState2, manifest: manifest2} = generateMockServerState(\n+            new MockFileSystemBuilder()\n+                .addFile('/index.html', '<script src=\"bar.hash.js\"></script>')\n+                .addFile('/bar.hash.js', 'console.log(\"BAR\");')\n+                .build());\n+\n+        const {serverState: serverState3} = generateMockServerState(\n+            new MockFileSystemBuilder()\n+                .addFile('/index.html', '<script src=\"baz.hash.js\"></script>')\n+                .addFile('/baz.hash.js', 'console.log(\"BAZ\");')\n+                .build());\n+\n+        // Create initial server state and initialize the SW.\n+        scope = new SwTestHarnessBuilder().withServerState(serverState1).build();\n+        driver = new Driver(scope, scope, new CacheDatabase(scope, scope));\n+\n+        // Verify that all three clients are able to make the request.\n+        expect(await makeRequest(scope, '/foo.hash.js', 'client1')).toBe('console.log(\"FOO\");');\n+        expect(await makeRequest(scope, '/foo.hash.js', 'client2')).toBe('console.log(\"FOO\");');\n+        expect(await makeRequest(scope, '/foo.hash.js', 'client3')).toBe('console.log(\"FOO\");');\n+\n+        await driver.initialized;\n+        serverState1.clearRequests();\n+\n+        // Verify that the `foo.hash.js` file is cached.\n+        expect(await makeRequest(scope, '/foo.hash.js')).toBe('console.log(\"FOO\");');\n+        serverState1.assertNoRequestFor('/foo.hash.js');\n+\n+        // Update the ServiceWorker to the second version.\n+        scope.updateServerState(serverState2);\n+        expect(await driver.checkForUpdate()).toEqual(true);\n+\n+        // Update the first two clients to the latest version, keep `client3` as is.\n+        const [client1, client2] =\n+            await Promise.all([scope.clients.get('client1'), scope.clients.get('client2')]);\n+\n+        await Promise.all([driver.updateClient(client1), driver.updateClient(client2)]);\n+\n+        // Update the ServiceWorker to the latest version\n+        scope.updateServerState(serverState3);\n+        expect(await driver.checkForUpdate()).toEqual(true);\n+\n+        // Remove `bar.hash.js` from the cache to emulate the browser evicting files from the cache.\n+        await removeAssetFromCache(scope, manifest2, '/bar.hash.js');\n+\n+        // Get all clients and verify their messages\n+        const mockClient1 = scope.clients.getMock('client1')!;\n+        const mockClient2 = scope.clients.getMock('client2')!;\n+        const mockClient3 = scope.clients.getMock('client3')!;\n+\n+        // Try to retrieve `bar.hash.js`, which is neither in the cache nor on the server.\n+        // This should put the SW in an unrecoverable state and notify clients.\n+        expect(await makeRequest(scope, '/bar.hash.js', 'client1')).toBeNull();\n+        serverState2.assertSawRequestFor('/bar.hash.js');\n+        const unrecoverableMessage = {\n+          type: 'UNRECOVERABLE_STATE',\n+          reason:\n+              'Failed to retrieve hashed resource from the server. (AssetGroup: assets | URL: /bar.hash.js)'\n+        };\n+\n+        expect(mockClient1.messages).toContain(unrecoverableMessage);\n+        expect(mockClient2.messages).toContain(unrecoverableMessage);\n+        expect(mockClient3.messages).not.toContain(unrecoverableMessage);\n+\n+        // Because `client1` failed, `client1` and `client2` have been moved to the latest version.\n+        // Verify that by retrieving `baz.hash.js`.\n+        expect(await makeRequest(scope, '/baz.hash.js', 'client1')).toBe('console.log(\"BAZ\");');\n+        serverState2.assertNoRequestFor('/baz.hash.js');\n+        expect(await makeRequest(scope, '/baz.hash.js', 'client2')).toBe('console.log(\"BAZ\");');\n+        serverState2.assertNoRequestFor('/baz.hash.js');\n+\n+        // Ensure that `client3` remains on the first version and can request `foo.hash.js`.\n+        expect(await makeRequest(scope, '/foo.hash.js', 'client3')).toBe('console.log(\"FOO\");');\n+        serverState2.assertNoRequestFor('/foo.hash.js');\n+      });\n+\n+      it('enters degraded mode', async () => {\n+        const originalFiles = new MockFileSystemBuilder()\n+                                  .addFile('/index.html', '<script src=\"foo.hash.js\"></script>')\n+                                  .addFile('/foo.hash.js', 'console.log(\"FOO\");')\n+                                  .build();\n+\n+        const updatedFiles = new MockFileSystemBuilder()\n+                                 .addFile('/index.html', '<script src=\"bar.hash.js\"></script>')\n+                                 .addFile('/bar.hash.js', 'console.log(\"BAR\");')\n+                                 .build();\n+\n+        const {serverState: originalServer, manifest} = generateMockServerState(originalFiles);\n+        const {serverState: updatedServer} = generateMockServerState(updatedFiles);\n+\n+        // Create initial server state and initialize the SW.\n+        scope = new SwTestHarnessBuilder().withServerState(originalServer).build();\n+        driver = new Driver(scope, scope, new CacheDatabase(scope, scope));\n+\n+        expect(await makeRequest(scope, '/foo.hash.js')).toBe('console.log(\"FOO\");');\n+        await driver.initialized;\n+        originalServer.clearRequests();\n+\n+        // Verify that the `foo.hash.js` file is cached.\n+        expect(await makeRequest(scope, '/foo.hash.js')).toBe('console.log(\"FOO\");');\n+        originalServer.assertNoRequestFor('/foo.hash.js');\n+\n+        // Update the server state to emulate deploying a new version (where `foo.hash.js` does not\n+        // exist any more). Keep the cache though.\n+        scope = new SwTestHarnessBuilder()\n+                    .withCacheState(scope.caches.dehydrate())\n+                    .withServerState(updatedServer)\n+                    .build();\n+        driver = new Driver(scope, scope, new CacheDatabase(scope, scope));\n+\n+        // The SW is still able to serve `foo.hash.js` from the cache.\n+        expect(await makeRequest(scope, '/foo.hash.js')).toBe('console.log(\"FOO\");');\n+        updatedServer.assertNoRequestFor('/foo.hash.js');\n+\n+        // Remove `foo.hash.js` from the cache to emulate the browser evicting files from the cache.\n+        await removeAssetFromCache(scope, manifest, '/foo.hash.js');\n+\n+        // Try to retrieve `foo.hash.js`, which is neither in the cache nor on the server.\n+        // This should put the SW in an unrecoverable state and notify clients.\n+        expect(await makeRequest(scope, '/foo.hash.js')).toBeNull();\n+        updatedServer.assertSawRequestFor('/foo.hash.js');\n+\n+        // This should also enter the `SW` into degraded mode, because the broken version was the\n+        // latest one.\n+        expect(driver.state).toEqual(DriverReadyState.EXISTING_CLIENTS_ONLY);\n+      });\n+    });\n+\n     describe('backwards compatibility with v5', () => {\n       beforeEach(() => {\n         const serverV5 = new MockServerStateBuilder()"
        }
    ],
    "stats": {
        "total": 253,
        "additions": 245,
        "deletions": 8
    }
}