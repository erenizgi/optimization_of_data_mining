{
    "author": "atscott",
    "message": "Revert \"refactor(router): restore history in a consistent way on canceled navigations (#43651)\" (#44006)\n\nThis reverts commit a268c4471f2e1dcaffe3304236d506222adab44c.\n\nCauses failures in internal team's code. The failures likely relate to\nattempting to manually update private Router state tracking properties,\nwhich this change would have affected.\n\nPR Close #44006",
    "sha": "d015ac214f4e372607403e6e93c48f8a2b5014f9",
    "files": [
        {
            "sha": "63683d5df3866ae409b086bbdde00d68f3bfc41f",
            "filename": "packages/router/src/router.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 5,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/d015ac214f4e372607403e6e93c48f8a2b5014f9/packages%2Frouter%2Fsrc%2Frouter.ts",
            "raw_url": "https://github.com/angular/angular/raw/d015ac214f4e372607403e6e93c48f8a2b5014f9/packages%2Frouter%2Fsrc%2Frouter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frouter.ts?ref=d015ac214f4e372607403e6e93c48f8a2b5014f9",
            "patch": "@@ -953,7 +953,7 @@ export class Router {\n                            // This is only applicable with initial navigation, so setting\n                            // `navigated` only when not redirecting resolves this scenario.\n                            this.navigated = true;\n-                           this.restoreHistory(t);\n+                           this.restoreHistory(t, true);\n                          }\n                          const navCancel = new NavigationCancel(\n                              t.id, this.serializeUrl(t.extractedUrl), e.message);\n@@ -990,7 +990,7 @@ export class Router {\n                          /* All other errors should reset to the router's internal URL reference to\n                           * the pre-error state. */\n                        } else {\n-                         this.restoreHistory(t);\n+                         this.restoreHistory(t, true);\n                          const navError =\n                              new NavigationError(t.id, this.serializeUrl(t.extractedUrl), e);\n                          eventsSubject.next(navError);\n@@ -1447,7 +1447,7 @@ export class Router {\n    * Performs the necessary rollback action to restore the browser URL to the\n    * state before the transition.\n    */\n-  private restoreHistory(t: NavigationTransition) {\n+  private restoreHistory(t: NavigationTransition, restoringFromCaughtError = false) {\n     if (this.canceledNavigationResolution === 'computed') {\n       const targetPagePosition = this.currentPageId - t.targetPageId;\n       // The navigator change the location before triggered the browser event,\n@@ -1469,12 +1469,20 @@ export class Router {\n         // TODO(atscott): resetting the `browserUrlTree` should really be done in `resetState`.\n         // Investigate if this can be done by running TGP.\n         this.browserUrlTree = t.currentUrlTree;\n+        this.resetUrlToCurrentUrlTree();\n       } else {\n         // The browser URL and router state was not updated before the navigation cancelled so\n         // there's no restoration needed.\n       }\n     } else if (this.canceledNavigationResolution === 'replace') {\n-      this.resetState(t);\n+      // TODO(atscott): It seems like we should _always_ reset the state here. It would be a no-op\n+      // for `deferred` navigations that haven't change the internal state yet because guards\n+      // reject. For 'eager' navigations, it seems like we also really should reset the state\n+      // because the navigation was cancelled. Investigate if this can be done by running TGP.\n+      if (restoringFromCaughtError) {\n+        this.resetState(t);\n+      }\n+      this.resetUrlToCurrentUrlTree();\n     }\n   }\n \n@@ -1487,7 +1495,6 @@ export class Router {\n     // addition, the URLHandlingStrategy may be configured to specifically preserve parts of the URL\n     // when merging, such as the query params so they are not lost on a refresh.\n     this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl);\n-    this.resetUrlToCurrentUrlTree();\n   }\n \n   private resetUrlToCurrentUrlTree(): void {"
        }
    ],
    "stats": {
        "total": 17,
        "additions": 12,
        "deletions": 5
    }
}