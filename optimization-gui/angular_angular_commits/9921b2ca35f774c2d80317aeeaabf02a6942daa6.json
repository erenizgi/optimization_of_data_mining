{
    "author": "dylhunn",
    "message": "feat(core): Add a migration for typed forms. (#44449)\n\nThis migration will insert `<AnyForUntypedForms>` or `<AnyForUntypedForms[]>` at existing uses of `AbstractControl` classes, as well as calls to `FormBuilder` methods.\n\nWe need to submit this ahead of time in order to get started with the migration in google3.\n\nPR Close #44449",
    "sha": "9921b2ca35f774c2d80317aeeaabf02a6942daa6",
    "files": [
        {
            "sha": "93f2516b90abfca4df7f657086a02c68066e18e5",
            "filename": "packages/core/schematics/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2FBUILD.bazel?ref=9921b2ca35f774c2d80317aeeaabf02a6942daa6",
            "patch": "@@ -16,5 +16,6 @@ pkg_npm(\n         \"//packages/core/schematics/migrations/entry-components\",\n         \"//packages/core/schematics/migrations/router-link-empty-expression\",\n         \"//packages/core/schematics/migrations/testbed-teardown\",\n+        \"//packages/core/schematics/migrations/typed-forms\",\n     ],\n )"
        },
        {
            "sha": "e20833f7545435b70b0d1b0d8f8a1580272176d4",
            "filename": "packages/core/schematics/migrations/google3/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FBUILD.bazel?ref=9921b2ca35f774c2d80317aeeaabf02a6942daa6",
            "patch": "@@ -8,6 +8,7 @@ ts_library(\n     deps = [\n         \"//packages/core/schematics/migrations/entry-components\",\n         \"//packages/core/schematics/migrations/testbed-teardown\",\n+        \"//packages/core/schematics/migrations/typed-forms\",\n         \"//packages/core/schematics/utils\",\n         \"//packages/core/schematics/utils/tslint\",\n         \"@npm//tslint\","
        },
        {
            "sha": "2b527784eb8467c4ce3651396b69d4a0cf2776ce",
            "filename": "packages/core/schematics/migrations/google3/typedFormsRule.ts",
            "status": "added",
            "additions": 66,
            "deletions": 0,
            "changes": 66,
            "blob_url": "https://github.com/angular/angular/blob/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FtypedFormsRule.ts",
            "raw_url": "https://github.com/angular/angular/raw/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FtypedFormsRule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FtypedFormsRule.ts?ref=9921b2ca35f774c2d80317aeeaabf02a6942daa6",
            "patch": "@@ -0,0 +1,66 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {Replacement, RuleFailure, Rules} from 'tslint';\n+import ts from 'typescript';\n+\n+import {anySymbolName, findControlClassUsages, findFormBuilderCalls, getAnyImport, getControlClassImports, getFormBuilderImport, MigratableNode} from '../typed-forms/util';\n+\n+/** TSLint rule for Typed Forms migration. */\n+export class Rule extends Rules.TypedRule {\n+  override applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): RuleFailure[] {\n+    const typeChecker = program.getTypeChecker();\n+\n+    const controlClassImports = getControlClassImports(sourceFile);\n+    const formBuilderImport = getFormBuilderImport(sourceFile);\n+\n+    const failures: RuleFailure[] = [];\n+\n+    // If no relevant classes are imported, we can exit early.\n+    if (controlClassImports.length === 0 && formBuilderImport !== null) return failures;\n+\n+    // For each control class, migrate all of its uses.\n+    for (const importSpecifier of controlClassImports) {\n+      const usages = findControlClassUsages(sourceFile, typeChecker, importSpecifier);\n+      for (const node of usages) {\n+        failures.push(this.getNodeFailure(node, sourceFile));\n+      }\n+    }\n+\n+    // For each FormBuilder method, migrate all of its uses.\n+    const nodes = findFormBuilderCalls(sourceFile, typeChecker, formBuilderImport);\n+    for (const n of nodes) {\n+      failures.push(this.getNodeFailure(n, sourceFile));\n+    }\n+\n+    // Add the any symbol used by the migrated calls.\n+    if (getAnyImport(sourceFile) !== null) {\n+      const firstValidFormsImport =\n+          [...controlClassImports, formBuilderImport].sort().filter(i => i)[0]!;\n+      failures.push(this.getImportFailure(firstValidFormsImport, sourceFile));\n+    }\n+\n+    return failures;\n+  }\n+\n+  private getNodeFailure(node: MigratableNode, sourceFile: ts.SourceFile): RuleFailure {\n+    return new RuleFailure(\n+        sourceFile, node.node.getStart(), node.node.getEnd(),\n+        'Typed Forms requires a generic be provided for this identifier.', this.ruleName,\n+        new Replacement(\n+            node.node.getStart(), node.node.getWidth(), node.node.getText() + node.generic));\n+  }\n+\n+  private getImportFailure(importd: ts.ImportSpecifier, sourceFile: ts.SourceFile): RuleFailure {\n+    return new RuleFailure(\n+        sourceFile, importd.getStart(), importd.getEnd(),\n+        `Typed Forms requires ${anySymbolName} to be imported.`, this.ruleName,\n+        new Replacement(\n+            importd.getStart(), importd.getWidth(), `${anySymbolName}, ` + importd.getText()));\n+  }\n+}"
        },
        {
            "sha": "c72a74e130421ba2b830406cd92b4d10735aa3fb",
            "filename": "packages/core/schematics/migrations/typed-forms/BUILD.bazel",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2Fmigrations%2Ftyped-forms%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2Fmigrations%2Ftyped-forms%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Ftyped-forms%2FBUILD.bazel?ref=9921b2ca35f774c2d80317aeeaabf02a6942daa6",
            "patch": "@@ -0,0 +1,18 @@\n+load(\"//tools:defaults.bzl\", \"ts_library\")\n+\n+ts_library(\n+    name = \"typed-forms\",\n+    srcs = glob([\"**/*.ts\"]),\n+    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n+    visibility = [\n+        \"//packages/core/schematics:__pkg__\",\n+        \"//packages/core/schematics/migrations/google3:__pkg__\",\n+        \"//packages/core/schematics/test:__pkg__\",\n+    ],\n+    deps = [\n+        \"//packages/core/schematics/utils\",\n+        \"@npm//@angular-devkit/schematics\",\n+        \"@npm//@types/node\",\n+        \"@npm//typescript\",\n+    ],\n+)"
        },
        {
            "sha": "e141cbd69df0aa47f32043061dd14e18a35742df",
            "filename": "packages/core/schematics/migrations/typed-forms/README.md",
            "status": "added",
            "additions": 47,
            "deletions": 0,
            "changes": 47,
            "blob_url": "https://github.com/angular/angular/blob/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2Fmigrations%2Ftyped-forms%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2Fmigrations%2Ftyped-forms%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Ftyped-forms%2FREADME.md?ref=9921b2ca35f774c2d80317aeeaabf02a6942daa6",
            "patch": "@@ -0,0 +1,47 @@\n+## Typed Forms migration\n+\n+As of Angular v14, `AbstractControl` and `FormBuilder` classes have a generic type parameter. This migration identifies usage of these classes, and adds `<AnyForUntypedForms>` or `<AnyForUntypedForms[]>` in the appropriate places to preserve the old untyped behavior.\n+\n+#### Before\n+```ts\n+import { Component } from '@angular/core';\n+import { AbstractControl, FormArray, FormBuilder, FormControl as FC, FormGroup } from '@angular/forms';\n+\n+@Component({template: ''})\n+export class MyComponent {\n+  private _control = new FC(42);\n+  private _group = new FormGroup({});\n+  private _array = new FormArray([]);\n+\n+  private fb = new FormBuilder();\n+\n+  build() {\n+    const c = this.fb.control(42);\n+    const g = this.fb.group({one: this.fb.control('')});\n+    const a = this.fb.array([42]);\n+    const fc2 = new FC(0);\n+  }\n+}\n+```\n+\n+#### After\n+```ts\n+import { Component } from '@angular/core';\n+import { AbstractControl, AnyForUntypedForms, FormArray, FormBuilder, FormControl as FC, FormGroup } from '@angular/forms';\n+\n+@Component({template: ''})\n+export class MyComponent {\n+  private _control = new FC<AnyForUntypedForms>(42);\n+  private _group = new FormGroup<AnyForUntypedForms>({});\n+  private _array = new FormArray<AnyForUntypedForms[]>([]);\n+\n+  private fb = new FormBuilder();\n+\n+  build() {\n+    const c = this.fb.control<AnyForUntypedForms>(42);\n+    const g = this.fb.group<AnyForUntypedForms>({one: this.fb.control<AnyForUntypedForms>('')});\n+    const a = this.fb.array<AnyForUntypedForms[]>([42]);\n+    const fc2 = new FC<AnyForUntypedForms>(0);\n+  }\n+}\n+```"
        },
        {
            "sha": "ede6f8401cd40ea75d40e442e4270a00709155d2",
            "filename": "packages/core/schematics/migrations/typed-forms/index.ts",
            "status": "added",
            "additions": 83,
            "deletions": 0,
            "changes": 83,
            "blob_url": "https://github.com/angular/angular/blob/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2Fmigrations%2Ftyped-forms%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2Fmigrations%2Ftyped-forms%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Ftyped-forms%2Findex.ts?ref=9921b2ca35f774c2d80317aeeaabf02a6942daa6",
            "patch": "@@ -0,0 +1,83 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {Rule, SchematicsException, Tree, UpdateRecorder} from '@angular-devkit/schematics';\n+import {relative} from 'path';\n+import ts from 'typescript';\n+\n+import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n+import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n+\n+import {anySymbolName, findControlClassUsages, findFormBuilderCalls, getAnyImport, getControlClassImports, getFormBuilderImport, MigratableNode} from './util';\n+\n+export default function(): Rule {\n+  return async (tree: Tree) => {\n+    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n+    const basePath = process.cwd();\n+    const allPaths = [...buildPaths, ...testPaths];\n+\n+    if (!allPaths.length) {\n+      throw new SchematicsException(\n+          'Could not find any tsconfig file. Cannot migrate to Typed Forms.');\n+    }\n+\n+    for (const tsconfigPath of allPaths) {\n+      runTypedFormsMigration(tree, tsconfigPath, basePath);\n+    }\n+  };\n+}\n+\n+function runTypedFormsMigration(tree: Tree, tsconfigPath: string, basePath: string) {\n+  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n+  const typeChecker = program.getTypeChecker();\n+  const sourceFiles =\n+      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n+\n+  for (const sourceFile of sourceFiles) {\n+    const controlClassImports = getControlClassImports(sourceFile);\n+    const formBuilderImport = getFormBuilderImport(sourceFile);\n+\n+    // If no relevant classes are imported, we can exit early.\n+    if (controlClassImports.length === 0 && formBuilderImport !== null) return;\n+\n+    const update = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n+\n+    // For each control class, migrate all of its uses.\n+    for (const importSpecifier of controlClassImports) {\n+      const usages = findControlClassUsages(sourceFile, typeChecker, importSpecifier);\n+      for (const node of usages) {\n+        migrateNode(update, node, importSpecifier);\n+      }\n+    }\n+\n+    // For each FormBuilder method, migrate all of its uses.\n+    const nodes = findFormBuilderCalls(sourceFile, typeChecker, formBuilderImport);\n+    for (const n of nodes) {\n+      migrateNode(update, n, formBuilderImport);\n+    }\n+\n+    // Add the any symbol used by the migrated calls.\n+    if (getAnyImport(sourceFile) !== null) {\n+      const firstValidFormsImport =\n+          [...controlClassImports, formBuilderImport].sort().filter(i => i !== null)[0]!;\n+      insertAnyImport(update, firstValidFormsImport);\n+    }\n+\n+    tree.commitUpdate(update);\n+  }\n+}\n+\n+export function migrateNode(\n+    update: UpdateRecorder, node: MigratableNode, importd: ts.ImportSpecifier|null) {\n+  if (importd === null) return;\n+  update.insertRight(node.node.getEnd(), node.generic);\n+}\n+\n+export function insertAnyImport(update: UpdateRecorder, importd: ts.ImportSpecifier) {\n+  update.insertLeft(importd.getStart(), `${anySymbolName}, `);\n+}"
        },
        {
            "sha": "3d5dd5d5788df6c979be9fabce9beff4b9d2644a",
            "filename": "packages/core/schematics/migrations/typed-forms/util.ts",
            "status": "added",
            "additions": 80,
            "deletions": 0,
            "changes": 80,
            "blob_url": "https://github.com/angular/angular/blob/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2Fmigrations%2Ftyped-forms%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2Fmigrations%2Ftyped-forms%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Ftyped-forms%2Futil.ts?ref=9921b2ca35f774c2d80317aeeaabf02a6942daa6",
            "patch": "@@ -0,0 +1,80 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import ts from 'typescript';\n+\n+import {getImportSpecifier} from '../../utils/typescript/imports';\n+import {isReferenceToImport} from '../../utils/typescript/symbol';\n+\n+export const controlClassNames = ['AbstractControl', 'FormArray', 'FormControl', 'FormGroup'];\n+export const builderMethodNames = ['control', 'group', 'array'];\n+export const anySymbolName = 'AnyForUntypedForms';\n+\n+export interface MigratableNode {\n+  node: ts.Expression;\n+  generic: string;\n+}\n+\n+export function getControlClassImports(sourceFile: ts.SourceFile) {\n+  return controlClassNames.map(cclass => getImportSpecifier(sourceFile, '@angular/forms', cclass))\n+      .filter(v => v != null);\n+}\n+\n+export function getFormBuilderImport(sourceFile: ts.SourceFile) {\n+  return getImportSpecifier(sourceFile, '@angular/forms', 'FormBuilder');\n+}\n+\n+export function getAnyImport(sourceFile: ts.SourceFile) {\n+  return getImportSpecifier(sourceFile, '@angular/forms', anySymbolName);\n+}\n+\n+export function findControlClassUsages(\n+    sourceFile: ts.SourceFile, typeChecker: ts.TypeChecker,\n+    importSpecifier: ts.ImportSpecifier|null): MigratableNode[] {\n+  if (importSpecifier === null) return [];\n+  let generic = `<${anySymbolName}>`;\n+  if (importSpecifier.name.getText() === 'FormArray' ||\n+      importSpecifier.propertyName?.getText() === 'FormArray') {\n+    generic = `<${anySymbolName}[]>`;\n+  }\n+  const usages: MigratableNode[] = [];\n+  const visitNode = (node: ts.Node) => {\n+    // Look for a `new` expression with no type arguments which references an import we care about:\n+    // `new FormControl()`\n+    if (ts.isNewExpression(node) && !node.typeArguments &&\n+        isReferenceToImport(typeChecker, node.expression, importSpecifier)) {\n+      usages.push({node: node.expression, generic});\n+    }\n+    ts.forEachChild(node, visitNode);\n+  };\n+  ts.forEachChild(sourceFile, visitNode);\n+  return usages;\n+}\n+\n+export function findFormBuilderCalls(\n+    sourceFile: ts.SourceFile, typeChecker: ts.TypeChecker,\n+    importSpecifier: ts.ImportSpecifier|null): MigratableNode[] {\n+  if (!importSpecifier) return [];\n+  const usages = new Array<MigratableNode>();\n+  ts.forEachChild(sourceFile, function visitNode(node: ts.Node) {\n+    // Look for calls that look like `foo.<method to migrate>`.\n+    if (ts.isCallExpression(node) && !node.typeArguments &&\n+        ts.isPropertyAccessExpression(node.expression) && ts.isIdentifier(node.expression.name) &&\n+        builderMethodNames.includes(node.expression.name.text)) {\n+      const generic =\n+          node.expression.name.text === 'array' ? `<${anySymbolName}[]>` : `<${anySymbolName}>`;\n+      // Check whether the type of the object on which the function is called refers to the\n+      // provided import.\n+      if (isReferenceToImport(typeChecker, node.expression.expression, importSpecifier)) {\n+        usages.push({node: node.expression, generic});\n+      }\n+    }\n+    ts.forEachChild(node, visitNode);\n+  });\n+  return usages;\n+}"
        },
        {
            "sha": "f96bfe4d539d56d2a4cd71ce57ecc3a52870caf3",
            "filename": "packages/core/schematics/test/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel?ref=9921b2ca35f774c2d80317aeeaabf02a6942daa6",
            "patch": "@@ -11,6 +11,7 @@ ts_library(\n         \"//packages/core/schematics/migrations/entry-components\",\n         \"//packages/core/schematics/migrations/router-link-empty-expression\",\n         \"//packages/core/schematics/migrations/testbed-teardown\",\n+        \"//packages/core/schematics/migrations/typed-forms\",\n         \"//packages/core/schematics/utils\",\n         \"@npm//@angular-devkit/core\",\n         \"@npm//@angular-devkit/schematics\","
        },
        {
            "sha": "567bde1d3639907ec0b8a8b046f5bef0cd2d87fb",
            "filename": "packages/core/schematics/test/google3/typed_forms_spec.ts",
            "status": "added",
            "additions": 126,
            "deletions": 0,
            "changes": 126,
            "blob_url": "https://github.com/angular/angular/blob/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Ftyped_forms_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Ftyped_forms_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Ftyped_forms_spec.ts?ref=9921b2ca35f774c2d80317aeeaabf02a6942daa6",
            "patch": "@@ -0,0 +1,126 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {readFileSync, writeFileSync} from 'fs';\n+import {dirname, join} from 'path';\n+import * as shx from 'shelljs';\n+import {Configuration, Linter} from 'tslint';\n+\n+const anySymbolName = 'AnyForUntypedForms';\n+\n+// Tests disabled, as the migration is currently disabled in package.json.\n+/*\n+\n+describe('Google3 typedForms TSLint rule', () => {\n+  const rulesDirectory = dirname(require.resolve('../../migrations/google3/typedFormsRule'));\n+\n+  let tmpDir: string;\n+\n+  beforeEach(() => {\n+    tmpDir = join(process.env['TEST_TMPDIR']!, 'google3-test');\n+    shx.mkdir('-p', tmpDir);\n+\n+    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n+    writeFile('testing.d.ts', `\n+        export type ${anySymbolName} = any;\n+        export declare class FormControl {}\n+        export declare class FormGroup {}\n+        export declare class FormArray {}\n+        export declare class AbstractControl {}\n+        export declare class FormBuilder {\n+          constructor();\n+          control(\n+            formState: any, validatorOrOpts?: any,\n+            asyncValidator?: any): FormControl;\n+          group(\n+            controlsConfig: {[key: string]: any},\n+            options?: any,\n+            ): FormGroup;\n+          group(\n+            controlsConfig: {[key: string]: any},\n+            options: {[key: string]: any},\n+            ): FormGroup;\n+          group(\n+            controlsConfig: {[key: string]: any},\n+            options: any): FormGroup;\n+          array(\n+            controlsConfig: any[],\n+            validatorOrOpts?: any,\n+            asyncValidator?: any): FormArray;\n+        }\n+     `);\n+\n+    writeFile('tsconfig.json', JSON.stringify({\n+      compilerOptions: {\n+        module: 'es2015',\n+        baseUrl: './',\n+        paths: {\n+          '@angular/forms': ['testing.d.ts'],\n+        }\n+      },\n+    }));\n+  });\n+\n+  afterEach(() => shx.rm('-r', tmpDir));\n+\n+  function runTSLint(fix: boolean) {\n+    const program = Linter.createProgram(join(tmpDir, 'tsconfig.json'));\n+    const linter = new Linter({fix, rulesDirectory: [rulesDirectory]}, program);\n+    const config = Configuration.parseConfigFile({rules: {'typedForms': true}});\n+\n+    program.getRootFileNames().forEach(fileName => {\n+      linter.lint(fileName, program.getSourceFile(fileName)!.getFullText(), config);\n+    });\n+\n+    return linter;\n+  }\n+\n+  function writeFile(fileName: string, content: string) {\n+    writeFileSync(join(tmpDir, fileName), content);\n+  }\n+\n+  function getFile(fileName: string) {\n+    return readFileSync(join(tmpDir, fileName), 'utf8');\n+  }\n+\n+  it('should migrate a complete example', () => {\n+    writeFile('/index.ts', `\n+      import { Component } from '@angular/core';\n+      import { AbstractControl, FormArray, FormBuilder, FormControl as FC, FormGroup } from\n+'@angular/forms';\n+\n+      @Component({template: ''})\n+      export class MyComponent {\n+        private _control = new FC(42);\n+        private _group = new FormGroup({});\n+        private _array = new FormArray([]);\n+\n+        private fb = new FormBuilder();\n+\n+        build() {\n+          const c = this.fb.control(42);\n+          const g = this.fb.group({one: this.fb.control('')});\n+          const a = this.fb.array([42]);\n+          const fc2 = new FC(0);\n+        }\n+      }\n+    `);\n+\n+    const linter = runTSLint(true);\n+\n+    [`import { ${\n+         anySymbolName}, AbstractControl, FormArray, FormBuilder, FormControl as FC, FormGroup }\n+from '@angular/forms';`, `private _control = new FC<${anySymbolName}>(42)`, `private _group = new\n+FormGroup<${anySymbolName}>({})`, `private _array = new FormArray<${anySymbolName}[]>([])`, `const\n+fc2 = new FC<${anySymbolName}>(0)`, `const c = this.fb.control<${anySymbolName}>(42)`, `const g =\n+this.fb.group<${anySymbolName}>({one: this.fb.control<${anySymbolName}>('')})`, `const a =\n+this.fb.array<${anySymbolName}[]>([42])`] .forEach(t => expect(getFile(`/index.ts`)).toContain(t));\n+  });\n+});\n+\n+*/"
        },
        {
            "sha": "a3bdf6c8d105256e0f4ba9e01614685d3dfecdd1",
            "filename": "packages/core/schematics/test/typed_forms_spec.ts",
            "status": "added",
            "additions": 298,
            "deletions": 0,
            "changes": 298,
            "blob_url": "https://github.com/angular/angular/blob/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2Ftest%2Ftyped_forms_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/9921b2ca35f774c2d80317aeeaabf02a6942daa6/packages%2Fcore%2Fschematics%2Ftest%2Ftyped_forms_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Ftyped_forms_spec.ts?ref=9921b2ca35f774c2d80317aeeaabf02a6942daa6",
            "patch": "@@ -0,0 +1,298 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n+import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n+import {HostTree} from '@angular-devkit/schematics';\n+import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n+import * as shx from 'shelljs';\n+\n+const anySymbolName = 'AnyForUntypedForms';\n+\n+// Tests disabled, as the migration is currently disabled in package.json.\n+/*\n+\n+describe('Typed Forms migration', () => {\n+  let runner: SchematicTestRunner;\n+  let host: TempScopedNodeJsSyncHost;\n+  let tree: UnitTestTree;\n+  let tmpDirPath: string;\n+  let previousWorkingDir: string;\n+\n+  beforeEach(() => {\n+    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n+    host = new TempScopedNodeJsSyncHost();\n+    tree = new UnitTestTree(new HostTree(host));\n+\n+    writeFile('/tsconfig.json', JSON.stringify({\n+      compilerOptions: {\n+        lib: ['es2015'],\n+        strictNullChecks: true,\n+      },\n+    }));\n+\n+    writeFile('/angular.json', JSON.stringify({\n+      version: 1,\n+      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n+    }));\n+\n+    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n+    writeFile('/node_modules/@angular/forms/index.d.ts', `\n+       export type ${anySymbolName} = any;\n+       export declare class FormControl {}\n+       export declare class FormGroup {}\n+       export declare class FormArray {}\n+       export declare class AbstractControl {}\n+       export declare class FormBuilder {\n+         constructor();\n+         control(\n+           formState: any, validatorOrOpts?: any,\n+           asyncValidator?: any): FormControl;\n+         group(\n+           controlsConfig: {[key: string]: any},\n+           options?: any,\n+           ): FormGroup;\n+         group(\n+           controlsConfig: {[key: string]: any},\n+           options: {[key: string]: any},\n+           ): FormGroup;\n+         group(\n+           controlsConfig: {[key: string]: any},\n+           options: any): FormGroup;\n+         array(\n+           controlsConfig: any[],\n+           validatorOrOpts?: any,\n+           asyncValidator?: any): FormArray;\n+       }\n+      `);\n+\n+    previousWorkingDir = shx.pwd();\n+    tmpDirPath = getSystemPath(host.root);\n+\n+    // Switch into the temporary directory path. This allows us to run\n+    // the schematic against our custom unit test tree.\n+    shx.cd(tmpDirPath);\n+  });\n+  afterEach(() => {\n+    shx.cd(previousWorkingDir);\n+    shx.rm('-r', tmpDirPath);\n+  });\n+\n+  describe(`should add ${anySymbolName} to constructors`, () => {\n+    it('for FormControl', async () => {\n+      writeFile('/index.ts', `\n+           import { FormControl } from '@angular/forms';\n+           @Component({template: ''})\n+           export class MyComp {\n+             const fc1 = new FormControl();\n+             new FormControl(42);\n+             constructor() {}\n+           }\n+         `);\n+      await runMigration();\n+      expect(tree.readContent('/index.ts'))\n+          .toContain(`const fc1 = new FormControl<${anySymbolName}>();`);\n+      expect(tree.readContent('/index.ts')).toContain(`new FormControl<${anySymbolName}>(42);`);\n+    });\n+\n+    it('for FormGroup', async () => {\n+      writeFile('/index.ts', `\n+           import { FormGroup } from '@angular/forms';\n+           @Component({template: ''})\n+           export class MyComp {\n+             const fg = new FormGroup({foo: 3});\n+             constructor() {}\n+           }\n+         `);\n+      await runMigration();\n+      expect(tree.readContent('/index.ts'))\n+          .toContain(`const fg = new FormGroup<${anySymbolName}>({foo: 3});`);\n+    });\n+\n+    it('for FormArray', async () => {\n+      writeFile('/index.ts', `\n+           import { FormArray } from '@angular/forms';\n+           @Component({template: ''})\n+           export class MyComp {\n+             const fa = new FormArray([null]);\n+             constructor() {}\n+           }\n+         `);\n+      await runMigration();\n+      expect(tree.readContent('/index.ts'))\n+          .toContain(`const fa = new FormArray<${anySymbolName}[]>([null]);`);\n+    });\n+\n+    it('for FormControl with a qualified import', async () => {\n+      writeFile('/index.ts', `\n+           import { FormControl as FC } from '@angular/forms';\n+           @Component({template: ''})\n+           export class MyComp {\n+             const fc = new FC({foo: 3});\n+             constructor() {}\n+           }\n+         `);\n+      await runMigration();\n+      expect(tree.readContent('/index.ts'))\n+          .toContain(`const fc = new FC<${anySymbolName}>({foo: 3});`);\n+    });\n+\n+    it('for FormArray with a qualified import', async () => {\n+      writeFile('/index.ts', `\n+           import { FormArray as FA } from '@angular/forms';\n+           @Component({template: ''})\n+           export class MyComp {\n+             const fa = new FA([null]);\n+             constructor() {}\n+           }\n+         `);\n+      await runMigration();\n+      expect(tree.readContent('/index.ts'))\n+          .toContain(`const fa = new FA<${anySymbolName}[]>([null]);`);\n+    });\n+\n+    it('but not for controls that already have type arguments', async () => {\n+      writeFile('/index.ts', `\n+           import { FormControl } from '@angular/forms';\n+           @Component({template: ''})\n+           export class MyComp {\n+             const fc1 = new FormControl<${anySymbolName}>();\n+             constructor() {}\n+           }\n+         `);\n+      await runMigration();\n+      expect(tree.readContent('/index.ts'))\n+          .toContain(`const fc1 = new FormControl<${anySymbolName}>();`);\n+    });\n+  });\n+\n+  describe(`should add ${anySymbolName} to FormBuilder method`, () => {\n+    it('control', async () => {\n+      writeFile('/index.ts', `\n+           import { FormBuilder } from '@angular/forms';\n+           @Component({template: ''})\n+           export class MyComp {\n+             constructor() {\n+               const fb = new FormBuilder();\n+               const fc = fb.control(43);\n+               const fd = new FormBuilder().control(42);\n+             }\n+           }\n+         `);\n+      await runMigration();\n+      expect(tree.readContent('/index.ts')).toContain(`.control<${anySymbolName}>(43);`);\n+      expect(tree.readContent('/index.ts'))\n+          .toContain(`const fd = new FormBuilder().control<${anySymbolName}>(42)`);\n+    });\n+\n+    it('group', async () => {\n+      writeFile('/index.ts', `\n+           import { FormBuilder } from '@angular/forms';\n+           @Component({template: ''})\n+           export class MyComp {\n+             constructor() {\n+               const fb = new FormBuilder();\n+               const fc = fb.group({});\n+               const fd = new FormBuilder().group({});\n+             }\n+           }\n+         `);\n+      await runMigration();\n+      expect(tree.readContent('/index.ts')).toContain(`fb.group<${anySymbolName}>({});`);\n+      expect(tree.readContent('/index.ts'))\n+          .toContain(`const fd = new FormBuilder().group<${anySymbolName}>({})`);\n+    });\n+\n+    it('array', async () => {\n+      writeFile('/index.ts', `\n+           import { FormBuilder } from '@angular/forms';\n+           @Component({template: ''})\n+           export class MyComp {\n+             constructor() {\n+               const fb = new FormBuilder();\n+               const fc = fb.array([0]);\n+               const fd = new FormBuilder().array([0]);\n+             }\n+           }\n+         `);\n+      await runMigration();\n+      expect(tree.readContent('/index.ts')).toContain(`fb.array<${anySymbolName}[]>([0]);`);\n+      expect(tree.readContent('/index.ts'))\n+          .toContain(`const fd = new FormBuilder().array<${anySymbolName}[]>([0])`);\n+    });\n+  });\n+\n+  describe('should add import', () => {\n+    it('any when not already imported', async () => {\n+      writeFile('/index.ts', `\n+        import { FormBuilder } from '@angular/forms';\n+        @Component({template: ''})\n+        export class MyComp { }\n+      `);\n+      await runMigration();\n+      expect(tree.readContent('/index.ts'))\n+          .toContain(`import { ${anySymbolName}, FormBuilder } from '@angular/forms';`);\n+    });\n+\n+    it('exclusively when not already imported', async () => {\n+      writeFile('/index.ts', `\n+        import { ${anySymbolName}, FormBuilder } from '@angular/forms';\n+        @Component({template: ''})\n+        export class MyComp { }\n+      `);\n+      await runMigration();\n+      expect(tree.readContent('/index.ts'))\n+          .toContain(`import { ${anySymbolName}, FormBuilder } from '@angular/forms';`);\n+    });\n+  });\n+\n+  describe('should handle', () => {\n+    it('an integrated example', async () => {\n+      writeFile('/index.ts', `\n+           import { Component } from '@angular/core';\n+           import { AbstractControl, FormArray, FormBuilder, FormControl as FC, FormGroup } from\n+'@angular/forms';\n+\n+           @Component({template: ''})\n+           export class MyComponent {\n+             private _control = new FC(42);\n+             private _group = new FormGroup({});\n+             private _array = new FormArray([]);\n+\n+             private fb = new FormBuilder();\n+\n+             build() {\n+               const c = this.fb.control(42);\n+               const g = this.fb.group({one: this.fb.control('')});\n+               const a = this.fb.array([42]);\n+               const fc2 = new FC(0);\n+             }\n+           }\n+         `);\n+      await runMigration();\n+      [`import { ${\n+           anySymbolName}, AbstractControl, FormArray, FormBuilder, FormControl as FC, FormGroup }\n+from '@angular/forms';`, `private _control = new FC<${anySymbolName}>(42)`, `private _group = new\n+FormGroup<${anySymbolName}>({})`, `private _array = new FormArray<${anySymbolName}[]>([])`, `const\n+fc2 = new FC<${anySymbolName}>(0)`, `const c = this.fb.control<${anySymbolName}>(42)`, `const g =\n+this.fb.group<${anySymbolName}>({one: this.fb.control<${anySymbolName}>('')})`, `const a =\n+this.fb.array<${anySymbolName}[]>([42])`] .forEach(t =>\n+expect(tree.readContent('/index.ts')).toContain(t));\n+    });\n+  });\n+\n+  function writeFile(filePath: string, contents: string) {\n+    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n+  }\n+\n+  function runMigration() {\n+    return runner.runSchematicAsync('migration-v14-typed-forms', {}, tree).toPromise();\n+  }\n+});\n+\n+*/"
        }
    ],
    "stats": {
        "total": 721,
        "additions": 721,
        "deletions": 0
    }
}