{
    "author": "alxhub",
    "message": "refactor(compiler-cli): cache Symbols in the TemplateTypeCheckerImpl (#39278)\n\nThis commit introduces caching of `Symbol`s produced by the template type-\nchecking infrastructure, in the same way that autocompletion results are\nnow cached.\n\nPR Close #39278",
    "sha": "01cc9497227aad523d317cb2d587f17bdab8bc87",
    "files": [
        {
            "sha": "b3a415691f004a87cbb6d47c21739901728d49ca",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts",
            "status": "modified",
            "additions": 28,
            "deletions": 5,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/01cc9497227aad523d317cb2d587f17bdab8bc87/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/01cc9497227aad523d317cb2d587f17bdab8bc87/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts?ref=01cc9497227aad523d317cb2d587f17bdab8bc87",
            "patch": "@@ -42,6 +42,14 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n    * `ts.Program` changes, the `TemplateTypeCheckerImpl` as a whole is destroyed and replaced.\n    */\n   private completionCache = new Map<ts.ClassDeclaration, CompletionEngine>();\n+  /**\n+   * Stores the `SymbolBuilder` which creates symbols for each component class.\n+   *\n+   * Must be invalidated whenever the component's template or the `ts.Program` changes. Invalidation\n+   * on template changes is performed within this `TemplateTypeCheckerImpl` instance. When the\n+   * `ts.Program` changes, the `TemplateTypeCheckerImpl` as a whole is destroyed and replaced.\n+   */\n+  private symbolBuilderCache = new Map<ts.ClassDeclaration, SymbolBuilder>();\n \n   private isComplete = false;\n \n@@ -67,6 +75,7 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     // but the `TemplateTypeCheckerImpl` does not track the class for components with overrides. As\n     // a quick workaround, clear the entire cache instead.\n     this.completionCache.clear();\n+    this.symbolBuilderCache.clear();\n   }\n \n   getTemplate(component: ts.ClassDeclaration): TmplAstNode[]|null {\n@@ -146,8 +155,9 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     fileRecord.isComplete = false;\n     this.isComplete = false;\n \n-    // Overriding a component's template invalidates its autocompletion results.\n+    // Overriding a component's template invalidates its cached results.\n     this.completionCache.delete(component);\n+    this.symbolBuilderCache.delete(component);\n \n     return {nodes};\n   }\n@@ -400,15 +410,28 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n   }\n \n   getSymbolOfNode(node: AST|TmplAstNode, component: ts.ClassDeclaration): Symbol|null {\n+    const builder = this.getOrCreateSymbolBuilder(component);\n+    if (builder === null) {\n+      return null;\n+    }\n+    return builder.getSymbol(node);\n+  }\n+\n+  private getOrCreateSymbolBuilder(component: ts.ClassDeclaration): SymbolBuilder|null {\n+    if (this.symbolBuilderCache.has(component)) {\n+      return this.symbolBuilderCache.get(component)!;\n+    }\n+\n     const {tcb, data, shimPath} = this.getLatestComponentState(component);\n     if (tcb === null || data === null) {\n       return null;\n     }\n \n-    const typeChecker = this.typeCheckingStrategy.getProgram().getTypeChecker();\n-\n-    return new SymbolBuilder(typeChecker, shimPath, tcb, data, this.componentScopeReader)\n-        .getSymbol(node);\n+    const builder = new SymbolBuilder(\n+        shimPath, tcb, data, this.componentScopeReader,\n+        () => this.typeCheckingStrategy.getProgram().getTypeChecker());\n+    this.symbolBuilderCache.set(component, builder);\n+    return builder;\n   }\n }\n "
        },
        {
            "sha": "999351cd9f7c3efaeda93190a49c9d930b59b1e4",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder.ts",
            "status": "modified",
            "additions": 37,
            "deletions": 22,
            "changes": 59,
            "blob_url": "https://github.com/angular/angular/blob/01cc9497227aad523d317cb2d587f17bdab8bc87/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "raw_url": "https://github.com/angular/angular/raw/01cc9497227aad523d317cb2d587f17bdab8bc87/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts?ref=01cc9497227aad523d317cb2d587f17bdab8bc87",
            "patch": "@@ -21,41 +21,55 @@ import {isAccessExpression} from './ts_util';\n import {TcbDirectiveOutputsOp} from './type_check_block';\n \n /**\n- * A class which extracts information from a type check block.\n- * This class is essentially used as just a closure around the constructor parameters.\n+ * Generates and caches `Symbol`s for various template structures for a given component.\n+ *\n+ * The `SymbolBuilder` internally caches the `Symbol`s it creates, and must be destroyed and\n+ * replaced if the component's template changes.\n  */\n export class SymbolBuilder {\n+  private symbolCache = new Map<AST|TmplAstNode, Symbol|null>();\n+\n   constructor(\n-      private readonly typeChecker: ts.TypeChecker,\n       private readonly shimPath: AbsoluteFsPath,\n       private readonly typeCheckBlock: ts.Node,\n       private readonly templateData: TemplateData,\n       private readonly componentScopeReader: ComponentScopeReader,\n+      // The `ts.TypeChecker` depends on the current type-checking program, and so must be requested\n+      // on-demand instead of cached.\n+      private readonly getTypeChecker: () => ts.TypeChecker,\n   ) {}\n \n   getSymbol(node: TmplAstTemplate|TmplAstElement): TemplateSymbol|ElementSymbol|null;\n   getSymbol(node: TmplAstReference|TmplAstVariable): ReferenceSymbol|VariableSymbol|null;\n   getSymbol(node: AST|TmplAstNode): Symbol|null;\n   getSymbol(node: AST|TmplAstNode): Symbol|null {\n+    if (this.symbolCache.has(node)) {\n+      return this.symbolCache.get(node)!;\n+    }\n+\n+    let symbol: Symbol|null = null;\n     if (node instanceof TmplAstBoundAttribute || node instanceof TmplAstTextAttribute) {\n       // TODO(atscott): input and output bindings only return the first directive match but should\n       // return a list of bindings for all of them.\n-      return this.getSymbolOfInputBinding(node);\n+      symbol = this.getSymbolOfInputBinding(node);\n     } else if (node instanceof TmplAstBoundEvent) {\n-      return this.getSymbolOfBoundEvent(node);\n+      symbol = this.getSymbolOfBoundEvent(node);\n     } else if (node instanceof TmplAstElement) {\n-      return this.getSymbolOfElement(node);\n+      symbol = this.getSymbolOfElement(node);\n     } else if (node instanceof TmplAstTemplate) {\n-      return this.getSymbolOfAstTemplate(node);\n+      symbol = this.getSymbolOfAstTemplate(node);\n     } else if (node instanceof TmplAstVariable) {\n-      return this.getSymbolOfVariable(node);\n+      symbol = this.getSymbolOfVariable(node);\n     } else if (node instanceof TmplAstReference) {\n-      return this.getSymbolOfReference(node);\n+      symbol = this.getSymbolOfReference(node);\n     } else if (node instanceof AST) {\n-      return this.getSymbolOfTemplateExpression(node);\n+      symbol = this.getSymbolOfTemplateExpression(node);\n+    } else {\n+      // TODO(atscott): TmplAstContent, TmplAstIcu\n     }\n-    // TODO(atscott): TmplAstContent, TmplAstIcu\n-    return null;\n+\n+    this.symbolCache.set(node, symbol);\n+    return symbol;\n   }\n \n   private getSymbolOfAstTemplate(template: TmplAstTemplate): TemplateSymbol|null {\n@@ -171,7 +185,8 @@ export class SymbolBuilder {\n       return null;\n     }\n \n-    const tsSymbol = this.typeChecker.getSymbolAtLocation(outputFieldAccess.argumentExpression);\n+    const tsSymbol =\n+        this.getTypeChecker().getSymbolAtLocation(outputFieldAccess.argumentExpression);\n     if (tsSymbol === undefined) {\n       return null;\n     }\n@@ -183,7 +198,7 @@ export class SymbolBuilder {\n     }\n \n     const positionInShimFile = this.getShimPositionForNode(outputFieldAccess);\n-    const tsType = this.typeChecker.getTypeAtLocation(node);\n+    const tsType = this.getTypeChecker().getTypeAtLocation(node);\n     return {\n       kind: SymbolKind.Output,\n       bindings: [{\n@@ -240,7 +255,7 @@ export class SymbolBuilder {\n       {isComponent, selector}: TypeCheckableDirectiveMeta): DirectiveSymbol|null {\n     // In either case, `_t1[\"index\"]` or `_t1.index`, `node.expression` is _t1.\n     // The retrieved symbol for _t1 will be the variable declaration.\n-    const tsSymbol = this.typeChecker.getSymbolAtLocation(node.expression);\n+    const tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.expression);\n     if (tsSymbol === undefined || tsSymbol.declarations.length === 0) {\n       return null;\n     }\n@@ -304,8 +319,8 @@ export class SymbolBuilder {\n     // initializers as invalid for symbol retrieval.\n     const originalDeclaration = ts.isParenthesizedExpression(node.initializer) &&\n             ts.isAsExpression(node.initializer.expression) ?\n-        this.typeChecker.getSymbolAtLocation(node.name) :\n-        this.typeChecker.getSymbolAtLocation(node.initializer);\n+        this.getTypeChecker().getSymbolAtLocation(node.name) :\n+        this.getTypeChecker().getSymbolAtLocation(node.initializer);\n     if (originalDeclaration === undefined || originalDeclaration.valueDeclaration === undefined) {\n       return null;\n     }\n@@ -384,7 +399,7 @@ export class SymbolBuilder {\n         kind: SymbolKind.Expression,\n         // Rather than using the type of only the `whenTrue` part of the expression, we should\n         // still get the type of the whole conditional expression to include `|undefined`.\n-        tsType: this.typeChecker.getTypeAtLocation(node)\n+        tsType: this.getTypeChecker().getTypeAtLocation(node)\n       };\n     } else if (expression instanceof BindingPipe && ts.isCallExpression(node)) {\n       // TODO(atscott): Create a PipeSymbol to include symbol for the Pipe class\n@@ -403,15 +418,15 @@ export class SymbolBuilder {\n \n     let tsSymbol: ts.Symbol|undefined;\n     if (ts.isPropertyAccessExpression(node)) {\n-      tsSymbol = this.typeChecker.getSymbolAtLocation(node.name);\n+      tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.name);\n     } else if (ts.isElementAccessExpression(node)) {\n-      tsSymbol = this.typeChecker.getSymbolAtLocation(node.argumentExpression);\n+      tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.argumentExpression);\n     } else {\n-      tsSymbol = this.typeChecker.getSymbolAtLocation(node);\n+      tsSymbol = this.getTypeChecker().getSymbolAtLocation(node);\n     }\n \n     const positionInShimFile = this.getShimPositionForNode(node);\n-    const type = this.typeChecker.getTypeAtLocation(node);\n+    const type = this.getTypeChecker().getTypeAtLocation(node);\n     return {\n       // If we could not find a symbol, fall back to the symbol on the type for the node.\n       // Some nodes won't have a \"symbol at location\" but will have a symbol for the type."
        },
        {
            "sha": "326c9c613646697fdcf2244ee63dfe3b7e8e95de",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker__get_symbol_of_template_node_spec.ts",
            "status": "modified",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/01cc9497227aad523d317cb2d587f17bdab8bc87/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/01cc9497227aad523d317cb2d587f17bdab8bc87/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts?ref=01cc9497227aad523d317cb2d587f17bdab8bc87",
            "patch": "@@ -39,6 +39,33 @@ runInEachFileSystem(() => {\n       assertElementSymbol(symbol.host);\n     });\n \n+    it('should invalidate symbols when template overrides change', () => {\n+      const fileName = absoluteFrom('/main.ts');\n+      const templateString = `<div id=\"helloWorld\"></div>`;\n+      const {templateTypeChecker, program} = setup(\n+          [\n+            {\n+              fileName,\n+              templates: {'Cmp': templateString},\n+              source: `export class Cmp {}`,\n+            },\n+          ],\n+      );\n+      const sf = getSourceFileOrError(program, fileName);\n+      const cmp = getClass(sf, 'Cmp');\n+      const {attributes: beforeAttributes} = getAstElements(templateTypeChecker, cmp)[0];\n+      const beforeSymbol = templateTypeChecker.getSymbolOfNode(beforeAttributes[0], cmp)!;\n+\n+      // Replace the <div> with a <span>.\n+      templateTypeChecker.overrideComponentTemplate(cmp, '<span id=\"helloWorld\"></span>');\n+\n+      const {attributes: afterAttributes} = getAstElements(templateTypeChecker, cmp)[0];\n+      const afterSymbol = templateTypeChecker.getSymbolOfNode(afterAttributes[0], cmp)!;\n+\n+      // After the override, the symbol cache should have been invalidated.\n+      expect(beforeSymbol).not.toBe(afterSymbol);\n+    });\n+\n     it('should get a symbol for text attributes corresponding with a directive input', () => {\n       const fileName = absoluteFrom('/main.ts');\n       const dirFile = absoluteFrom('/dir.ts');"
        }
    ],
    "stats": {
        "total": 119,
        "additions": 92,
        "deletions": 27
    }
}