{
    "author": "mhevery",
    "message": "Revert \"fix(router): support lazy loading for empty path named outlets (#38379)\"\n\nThis reverts commit 7ad32649c0d0004fcc3604c62cf0c1ae159a825b.",
    "sha": "8f24bc9443b3872fe095d9f7f77b308a361a13b4",
    "files": [
        {
            "sha": "2d5ce83c09fbc2380a72f414bd0ea25bddf33c92",
            "filename": "goldens/size-tracking/integration-payloads.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/8f24bc9443b3872fe095d9f7f77b308a361a13b4/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "raw_url": "https://github.com/angular/angular/raw/8f24bc9443b3872fe095d9f7f77b308a361a13b4/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fsize-tracking%2Fintegration-payloads.json?ref=8f24bc9443b3872fe095d9f7f77b308a361a13b4",
            "patch": "@@ -39,7 +39,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 2289,\n-        \"main-es2015\": 245885,\n+        \"main-es2015\": 245351,\n         \"polyfills-es2015\": 36938,\n         \"5-es2015\": 751\n       }"
        },
        {
            "sha": "5eb40504737c0e32c35eb67b9bc875360274b1c1",
            "filename": "packages/router/src/apply_redirects.ts",
            "status": "modified",
            "additions": 24,
            "deletions": 45,
            "changes": 69,
            "blob_url": "https://github.com/angular/angular/blob/8f24bc9443b3872fe095d9f7f77b308a361a13b4/packages%2Frouter%2Fsrc%2Fapply_redirects.ts",
            "raw_url": "https://github.com/angular/angular/raw/8f24bc9443b3872fe095d9f7f77b308a361a13b4/packages%2Frouter%2Fsrc%2Fapply_redirects.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Fapply_redirects.ts?ref=8f24bc9443b3872fe095d9f7f77b308a361a13b4",
            "patch": "@@ -8,7 +8,7 @@\n \n import {Injector, NgModuleRef} from '@angular/core';\n import {defer, EmptyError, Observable, Observer, of} from 'rxjs';\n-import {catchError, first, map, mergeMap, switchMap, tap} from 'rxjs/operators';\n+import {catchError, concatAll, first, map, mergeMap, tap} from 'rxjs/operators';\n \n import {LoadedRouterConfig, Route, Routes} from './config';\n import {CanLoadFn} from './interfaces';\n@@ -148,47 +148,28 @@ class ApplyRedirects {\n       ngModule: NgModuleRef<any>, segmentGroup: UrlSegmentGroup, routes: Route[],\n       segments: UrlSegment[], outlet: string,\n       allowRedirects: boolean): Observable<UrlSegmentGroup> {\n-    type MatchedSegment = {segment: UrlSegmentGroup, outlet: string};\n-    // This logic takes each route and switches to a new observable that depends on the result of\n-    // the previous route expansion. In this way, we compose a list of results where each one can\n-    // depend on and look at the previous to determine how to proceed with expansion of the\n-    // current route.\n-    return routes\n-        .reduce(\n-            (accumulatedResults: Observable<Array<MatchedSegment>>, r: Route) => {\n-              return accumulatedResults.pipe(switchMap(resultsThusFar => {\n-                // If we already matched a previous `Route` with the same outlet as the current,\n-                // we should not process the current one.\n-                if (resultsThusFar.some(result => result && result.outlet === getOutlet(r))) {\n-                  return of(resultsThusFar);\n-                }\n-                const expanded$ = this.expandSegmentAgainstRoute(\n-                    ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);\n-                return expanded$.pipe(\n-                    map((segment) => resultsThusFar.concat({segment, outlet: getOutlet(r)})),\n-                    catchError((e: any) => {\n-                      if (e instanceof NoMatch) {\n-                        return of(resultsThusFar);\n-                      }\n-                      throw e;\n-                    }));\n-              }));\n-            },\n-            of([] as MatchedSegment[]))\n-        .pipe(\n-            // Find the matched segment whose outlet matches the one we're looking for.\n-            map(results => results.find(s => s.outlet === outlet)?.segment),\n-            first((s): s is UrlSegmentGroup => s !== undefined),\n-            catchError((e: any, _: any) => {\n-              if (e instanceof EmptyError || e.name === 'EmptyError') {\n-                if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n-                  return of(new UrlSegmentGroup([], {}));\n-                }\n-                throw new NoMatch(segmentGroup);\n-              }\n-              throw e;\n-            }),\n-        );\n+    return of(...routes).pipe(\n+        map((r: any) => {\n+          const expanded$ = this.expandSegmentAgainstRoute(\n+              ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);\n+          return expanded$.pipe(catchError((e: any) => {\n+            if (e instanceof NoMatch) {\n+              // TODO(i): this return type doesn't match the declared Observable<UrlSegmentGroup> -\n+              // talk to Jason\n+              return of(null) as any;\n+            }\n+            throw e;\n+          }));\n+        }),\n+        concatAll(), first((s: any) => !!s), catchError((e: any, _: any) => {\n+          if (e instanceof EmptyError || e.name === 'EmptyError') {\n+            if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n+              return of(new UrlSegmentGroup([], {}));\n+            }\n+            throw new NoMatch(segmentGroup);\n+          }\n+          throw e;\n+        }));\n   }\n \n   private noLeftoversInUrl(segmentGroup: UrlSegmentGroup, segments: UrlSegment[], outlet: string):\n@@ -199,9 +180,7 @@ class ApplyRedirects {\n   private expandSegmentAgainstRoute(\n       ngModule: NgModuleRef<any>, segmentGroup: UrlSegmentGroup, routes: Route[], route: Route,\n       paths: UrlSegment[], outlet: string, allowRedirects: boolean): Observable<UrlSegmentGroup> {\n-    // Empty string segments are special because multiple outlets can match a single path, i.e.\n-    // `[{path: '', component: B}, {path: '', loadChildren: () => {}, outlet: \"about\"}]`\n-    if (getOutlet(route) !== outlet && route.path !== '') {\n+    if (getOutlet(route) !== outlet) {\n       return noMatch(segmentGroup);\n     }\n "
        },
        {
            "sha": "d564727a880ebf9c6a18ac0b7019cf3c2d207118",
            "filename": "packages/router/test/apply_redirects.spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 125,
            "changes": 127,
            "blob_url": "https://github.com/angular/angular/blob/8f24bc9443b3872fe095d9f7f77b308a361a13b4/packages%2Frouter%2Ftest%2Fapply_redirects.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/8f24bc9443b3872fe095d9f7f77b308a361a13b4/packages%2Frouter%2Ftest%2Fapply_redirects.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fapply_redirects.spec.ts?ref=8f24bc9443b3872fe095d9f7f77b308a361a13b4",
            "patch": "@@ -7,9 +7,9 @@\n  */\n \n import {NgModuleRef} from '@angular/core';\n-import {fakeAsync, TestBed, tick} from '@angular/core/testing';\n+import {TestBed} from '@angular/core/testing';\n import {Observable, of} from 'rxjs';\n-import {delay, tap} from 'rxjs/operators';\n+import {delay} from 'rxjs/operators';\n \n import {applyRedirects} from '../src/apply_redirects';\n import {LoadedRouterConfig, Route, Routes} from '../src/config';\n@@ -482,89 +482,6 @@ describe('applyRedirects', () => {\n             expect((config[0] as any)._loadedConfig).toBe(loadedConfig);\n           });\n     });\n-\n-    it('should load all matching configurations of empty path, including an auxiliary outlets',\n-       fakeAsync(() => {\n-         const loadedConfig =\n-             new LoadedRouterConfig([{path: '', component: ComponentA}], testModule);\n-         let loadCalls = 0;\n-         let loaded: string[] = [];\n-         const loader = {\n-           load: (injector: any, p: Route) => {\n-             loadCalls++;\n-             return of(loadedConfig)\n-                 .pipe(\n-                     delay(100 * loadCalls),\n-                     tap(() => loaded.push(p.loadChildren! as string)),\n-                 );\n-           }\n-         };\n-\n-         const config: Routes =\n-             [{path: '', loadChildren: 'root'}, {path: '', loadChildren: 'aux', outlet: 'popup'}];\n-\n-         applyRedirects(testModule.injector, <any>loader, serializer, tree(''), config).subscribe();\n-         expect(loadCalls).toBe(1);\n-         tick(100);\n-         expect(loaded).toEqual(['root']);\n-         tick(200);\n-         expect(loadCalls).toBe(2);\n-         expect(loaded).toEqual(['root', 'aux']);\n-       }));\n-\n-    it('loads only the first match when two Routes with the same outlet have the same path', () => {\n-      const loadedConfig = new LoadedRouterConfig([{path: '', component: ComponentA}], testModule);\n-      let loadCalls = 0;\n-      let loaded: string[] = [];\n-      const loader = {\n-        load: (injector: any, p: Route) => {\n-          loadCalls++;\n-          return of(loadedConfig)\n-              .pipe(\n-                  tap(() => loaded.push(p.loadChildren! as string)),\n-              );\n-        }\n-      };\n-\n-      const config: Routes =\n-          [{path: 'a', loadChildren: 'first'}, {path: 'a', loadChildren: 'second'}];\n-\n-      applyRedirects(testModule.injector, <any>loader, serializer, tree('a'), config).subscribe();\n-      expect(loadCalls).toBe(1);\n-      expect(loaded).toEqual(['first']);\n-    });\n-\n-    it('should load the configuration of empty root path if the entry is an aux outlet',\n-       fakeAsync(() => {\n-         const loadedConfig =\n-             new LoadedRouterConfig([{path: '', component: ComponentA}], testModule);\n-         let loaded: string[] = [];\n-         const rootDelay = 100;\n-         const auxDelay = 1;\n-         const loader = {\n-           load: (injector: any, p: Route) => {\n-             const delayMs = p.loadChildren! as string === 'aux' ? auxDelay : rootDelay;\n-             return of(loadedConfig)\n-                 .pipe(\n-                     delay(delayMs),\n-                     tap(() => loaded.push(p.loadChildren! as string)),\n-                 );\n-           }\n-         };\n-\n-         const config: Routes = [\n-           // Define aux route first so it matches before the primary outlet\n-           {path: 'modal', loadChildren: 'aux', outlet: 'popup'},\n-           {path: '', loadChildren: 'root'},\n-         ];\n-\n-         applyRedirects(testModule.injector, <any>loader, serializer, tree('(popup:modal)'), config)\n-             .subscribe();\n-         tick(auxDelay);\n-         expect(loaded).toEqual(['aux']);\n-         tick(rootDelay);\n-         expect(loaded).toEqual(['aux', 'root']);\n-       }));\n   });\n \n   describe('empty paths', () => {\n@@ -837,46 +754,6 @@ describe('applyRedirects', () => {\n     });\n   });\n \n-  describe('multiple matches with empty path named outlets', () => {\n-    it('should work with redirects when other outlet comes before the one being activated', () => {\n-      applyRedirects(\n-          testModule.injector, null!, serializer, tree(''),\n-          [\n-            {\n-              path: '',\n-              children: [\n-                {path: '', component: ComponentA, outlet: 'aux'},\n-                {path: '', redirectTo: 'b', pathMatch: 'full'},\n-                {path: 'b', component: ComponentB},\n-              ],\n-            },\n-          ])\n-          .subscribe(\n-              (tree: UrlTree) => {\n-                expect(tree.toString()).toEqual('/b');\n-              },\n-              () => {\n-                fail('should not be reached');\n-              });\n-    });\n-\n-    it('should work when entry point is named outlet', () => {\n-      applyRedirects(\n-          testModule.injector, null!, serializer, tree('(popup:modal)'),\n-          [\n-            {path: '', component: ComponentA},\n-            {path: 'modal', component: ComponentB, outlet: 'popup'},\n-          ])\n-          .subscribe(\n-              (tree: UrlTree) => {\n-                expect(tree.toString()).toEqual('/(popup:modal)');\n-              },\n-              (e) => {\n-                fail('should not be reached' + e.message);\n-              });\n-    });\n-  });\n-\n   describe('redirecting to named outlets', () => {\n     it('should work when using absolute redirects', () => {\n       checkRedirect("
        }
    ],
    "stats": {
        "total": 198,
        "additions": 27,
        "deletions": 171
    }
}