{
    "author": "petebacondarwin",
    "message": "refactor(compiler-cli): simplify imports from compiler to type translator (#38775)\n\nPreviously each identifier was being imported individually, which made for a\nvery long import statement, but also obscurred, in the code, which identifiers\ncame from the compiler.\n\nPR Close #38775",
    "sha": "a93605f2a452d64f2e9bff7882457c74d0111174",
    "files": [
        {
            "sha": "eb898e05af7ed53fbb1d518cdc5a59eddc7e3207",
            "filename": "packages/compiler-cli/src/ngtsc/translator/src/type_translator.ts",
            "status": "modified",
            "additions": 42,
            "deletions": 43,
            "changes": 85,
            "blob_url": "https://github.com/angular/angular/blob/a93605f2a452d64f2e9bff7882457c74d0111174/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftype_translator.ts",
            "raw_url": "https://github.com/angular/angular/raw/a93605f2a452d64f2e9bff7882457c74d0111174/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftype_translator.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftype_translator.ts?ref=a93605f2a452d64f2e9bff7882457c74d0111174",
            "patch": "@@ -6,39 +6,39 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {ArrayType, AssertNotNull, BinaryOperatorExpr, BuiltinType, BuiltinTypeName, CastExpr, CommaExpr, ConditionalExpr, Expression, ExpressionType, ExpressionVisitor, ExternalExpr, FunctionExpr, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, LocalizedString, MapType, NotExpr, ReadKeyExpr, ReadPropExpr, ReadVarExpr, Type, TypeofExpr, TypeVisitor, UnaryOperatorExpr, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr} from '@angular/compiler';\n+import * as o from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {Context} from './context';\n import {ImportManager} from './import_manager';\n \n \n-export function translateType(type: Type, imports: ImportManager): ts.TypeNode {\n+export function translateType(type: o.Type, imports: ImportManager): ts.TypeNode {\n   return type.visitType(new TypeTranslatorVisitor(imports), new Context(false));\n }\n \n-export class TypeTranslatorVisitor implements ExpressionVisitor, TypeVisitor {\n+export class TypeTranslatorVisitor implements o.ExpressionVisitor, o.TypeVisitor {\n   constructor(private imports: ImportManager) {}\n \n-  visitBuiltinType(type: BuiltinType, context: Context): ts.KeywordTypeNode {\n+  visitBuiltinType(type: o.BuiltinType, context: Context): ts.KeywordTypeNode {\n     switch (type.name) {\n-      case BuiltinTypeName.Bool:\n+      case o.BuiltinTypeName.Bool:\n         return ts.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\n-      case BuiltinTypeName.Dynamic:\n+      case o.BuiltinTypeName.Dynamic:\n         return ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n-      case BuiltinTypeName.Int:\n-      case BuiltinTypeName.Number:\n+      case o.BuiltinTypeName.Int:\n+      case o.BuiltinTypeName.Number:\n         return ts.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\n-      case BuiltinTypeName.String:\n+      case o.BuiltinTypeName.String:\n         return ts.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\n-      case BuiltinTypeName.None:\n+      case o.BuiltinTypeName.None:\n         return ts.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);\n       default:\n-        throw new Error(`Unsupported builtin type: ${BuiltinTypeName[type.name]}`);\n+        throw new Error(`Unsupported builtin type: ${o.BuiltinTypeName[type.name]}`);\n     }\n   }\n \n-  visitExpressionType(type: ExpressionType, context: Context): ts.TypeNode {\n+  visitExpressionType(type: o.ExpressionType, context: Context): ts.TypeNode {\n     const typeNode = this.translateExpression(type.value, context);\n     if (type.typeParams === null) {\n       return typeNode;\n@@ -56,11 +56,11 @@ export class TypeTranslatorVisitor implements ExpressionVisitor, TypeVisitor {\n     return ts.createTypeReferenceNode(typeNode.typeName, typeArgs);\n   }\n \n-  visitArrayType(type: ArrayType, context: Context): ts.ArrayTypeNode {\n+  visitArrayType(type: o.ArrayType, context: Context): ts.ArrayTypeNode {\n     return ts.createArrayTypeNode(this.translateType(type.of, context));\n   }\n \n-  visitMapType(type: MapType, context: Context): ts.TypeLiteralNode {\n+  visitMapType(type: o.MapType, context: Context): ts.TypeLiteralNode {\n     const parameter = ts.createParameter(\n         undefined, undefined, undefined, 'key', undefined,\n         ts.createKeywordTypeNode(ts.SyntaxKind.StringKeyword));\n@@ -71,38 +71,38 @@ export class TypeTranslatorVisitor implements ExpressionVisitor, TypeVisitor {\n     return ts.createTypeLiteralNode([indexSignature]);\n   }\n \n-  visitReadVarExpr(ast: ReadVarExpr, context: Context): ts.TypeQueryNode {\n+  visitReadVarExpr(ast: o.ReadVarExpr, context: Context): ts.TypeQueryNode {\n     if (ast.name === null) {\n       throw new Error(`ReadVarExpr with no variable name in type`);\n     }\n     return ts.createTypeQueryNode(ts.createIdentifier(ast.name));\n   }\n \n-  visitWriteVarExpr(expr: WriteVarExpr, context: Context): never {\n+  visitWriteVarExpr(expr: o.WriteVarExpr, context: Context): never {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitWriteKeyExpr(expr: WriteKeyExpr, context: Context): never {\n+  visitWriteKeyExpr(expr: o.WriteKeyExpr, context: Context): never {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitWritePropExpr(expr: WritePropExpr, context: Context): never {\n+  visitWritePropExpr(expr: o.WritePropExpr, context: Context): never {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitInvokeMethodExpr(ast: InvokeMethodExpr, context: Context): never {\n+  visitInvokeMethodExpr(ast: o.InvokeMethodExpr, context: Context): never {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: Context): never {\n+  visitInvokeFunctionExpr(ast: o.InvokeFunctionExpr, context: Context): never {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitInstantiateExpr(ast: InstantiateExpr, context: Context): never {\n+  visitInstantiateExpr(ast: o.InstantiateExpr, context: Context): never {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitLiteralExpr(ast: LiteralExpr, context: Context): ts.TypeNode {\n+  visitLiteralExpr(ast: o.LiteralExpr, context: Context): ts.TypeNode {\n     if (ast.value === null) {\n       // TODO(alan-agius4): Remove when we no longer support TS 3.9\n       // Use: return ts.createLiteralTypeNode(ts.createNull()) directly.\n@@ -120,70 +120,69 @@ export class TypeTranslatorVisitor implements ExpressionVisitor, TypeVisitor {\n     }\n   }\n \n-  visitLocalizedString(ast: LocalizedString, context: Context): never {\n+  visitLocalizedString(ast: o.LocalizedString, context: Context): never {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitExternalExpr(ast: ExternalExpr, context: Context): ts.EntityName|ts.TypeReferenceNode {\n+  visitExternalExpr(ast: o.ExternalExpr, context: Context): ts.EntityName|ts.TypeReferenceNode {\n     if (ast.value.moduleName === null || ast.value.name === null) {\n       throw new Error(`Import unknown module or symbol`);\n     }\n     const {moduleImport, symbol} =\n         this.imports.generateNamedImport(ast.value.moduleName, ast.value.name);\n     const symbolIdentifier = ts.createIdentifier(symbol);\n \n-    const typeName = moduleImport ?\n-        ts.createQualifiedName(ts.createIdentifier(moduleImport), symbolIdentifier) :\n-        symbolIdentifier;\n+    const typeName =\n+        moduleImport ? ts.createQualifiedName(moduleImport, symbolIdentifier) : symbolIdentifier;\n \n     const typeArguments = ast.typeParams !== null ?\n         ast.typeParams.map(type => this.translateType(type, context)) :\n         undefined;\n     return ts.createTypeReferenceNode(typeName, typeArguments);\n   }\n \n-  visitConditionalExpr(ast: ConditionalExpr, context: Context) {\n+  visitConditionalExpr(ast: o.ConditionalExpr, context: Context) {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitNotExpr(ast: NotExpr, context: Context) {\n+  visitNotExpr(ast: o.NotExpr, context: Context) {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitAssertNotNullExpr(ast: AssertNotNull, context: Context) {\n+  visitAssertNotNullExpr(ast: o.AssertNotNull, context: Context) {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitCastExpr(ast: CastExpr, context: Context) {\n+  visitCastExpr(ast: o.CastExpr, context: Context) {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitFunctionExpr(ast: FunctionExpr, context: Context) {\n+  visitFunctionExpr(ast: o.FunctionExpr, context: Context) {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: Context) {\n+  visitUnaryOperatorExpr(ast: o.UnaryOperatorExpr, context: Context) {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: Context) {\n+  visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, context: Context) {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitReadPropExpr(ast: ReadPropExpr, context: Context) {\n+  visitReadPropExpr(ast: o.ReadPropExpr, context: Context) {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitReadKeyExpr(ast: ReadKeyExpr, context: Context) {\n+  visitReadKeyExpr(ast: o.ReadKeyExpr, context: Context) {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: Context): ts.TupleTypeNode {\n+  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, context: Context): ts.TupleTypeNode {\n     const values = ast.entries.map(expr => this.translateExpression(expr, context));\n     return ts.createTupleTypeNode(values);\n   }\n \n-  visitLiteralMapExpr(ast: LiteralMapExpr, context: Context): ts.TypeLiteralNode {\n+  visitLiteralMapExpr(ast: o.LiteralMapExpr, context: Context): ts.TypeLiteralNode {\n     const entries = ast.entries.map(entry => {\n       const {key, quoted} = entry;\n       const type = this.translateExpression(entry.value, context);\n@@ -197,11 +196,11 @@ export class TypeTranslatorVisitor implements ExpressionVisitor, TypeVisitor {\n     return ts.createTypeLiteralNode(entries);\n   }\n \n-  visitCommaExpr(ast: CommaExpr, context: Context) {\n+  visitCommaExpr(ast: o.CommaExpr, context: Context) {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: Context): ts.TypeNode {\n+  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, context: Context): ts.TypeNode {\n     const node: ts.Node = ast.node;\n     if (ts.isEntityName(node)) {\n       return ts.createTypeReferenceNode(node, /* typeArguments */ undefined);\n@@ -215,7 +214,7 @@ export class TypeTranslatorVisitor implements ExpressionVisitor, TypeVisitor {\n     }\n   }\n \n-  visitTypeofExpr(ast: TypeofExpr, context: Context): ts.TypeQueryNode {\n+  visitTypeofExpr(ast: o.TypeofExpr, context: Context): ts.TypeQueryNode {\n     const typeNode = this.translateExpression(ast.expr, context);\n     if (!ts.isTypeReferenceNode(typeNode)) {\n       throw new Error(`The target of a typeof expression must be a type reference, but it was\n@@ -224,7 +223,7 @@ export class TypeTranslatorVisitor implements ExpressionVisitor, TypeVisitor {\n     return ts.createTypeQueryNode(typeNode.typeName);\n   }\n \n-  private translateType(type: Type, context: Context): ts.TypeNode {\n+  private translateType(type: o.Type, context: Context): ts.TypeNode {\n     const typeNode = type.visitType(this, context);\n     if (!ts.isTypeNode(typeNode)) {\n       throw new Error(\n@@ -233,7 +232,7 @@ export class TypeTranslatorVisitor implements ExpressionVisitor, TypeVisitor {\n     return typeNode;\n   }\n \n-  private translateExpression(expr: Expression, context: Context): ts.TypeNode {\n+  private translateExpression(expr: o.Expression, context: Context): ts.TypeNode {\n     const typeNode = expr.visitExpression(this, context);\n     if (!ts.isTypeNode(typeNode)) {\n       throw new Error("
        }
    ],
    "stats": {
        "total": 85,
        "additions": 42,
        "deletions": 43
    }
}