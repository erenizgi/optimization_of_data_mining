{
    "author": "unknown",
    "message": "fix(language-service): incorrect autocomplete results on unknown symbol (#37518)\n\nThis commit fixes a bug whereby the language service would incorrectly\nreturn HTML elements if autocomplete is requested for an unknown symbol.\nThis is because we walk through every possible scenario, and fallback to\nelement autocomplete if none of the scenarios match.\n\nThe fix here is to return results from interpolation if we know for sure\nwe are in a bound text. This means we will now return an empty results if\nthere is no suggestions.\n\nThis commit also refactors the code a little to make it easier to\nunderstand.\n\nPR Close #37518",
    "sha": "ae5257cda6dd6957c3def575176e922111ea170d",
    "files": [
        {
            "sha": "b4cf641aff06a46fe9e48443d47911b5e8228aa8",
            "filename": "packages/language-service/src/completions.ts",
            "status": "modified",
            "additions": 82,
            "deletions": 76,
            "changes": 158,
            "blob_url": "https://github.com/angular/angular/blob/ae5257cda6dd6957c3def575176e922111ea170d/packages%2Flanguage-service%2Fsrc%2Fcompletions.ts",
            "raw_url": "https://github.com/angular/angular/raw/ae5257cda6dd6957c3def575176e922111ea170d/packages%2Flanguage-service%2Fsrc%2Fcompletions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fsrc%2Fcompletions.ts?ref=ae5257cda6dd6957c3def575176e922111ea170d",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AbsoluteSourceSpan, AST, AstPath, AttrAst, Attribute, BoundDirectivePropertyAst, BoundElementPropertyAst, BoundEventAst, BoundTextAst, Element, ElementAst, EmptyExpr, ExpressionBinding, getHtmlTagDefinition, HtmlAstPath, Node as HtmlAst, NullTemplateVisitor, ParseSpan, ReferenceAst, TagContentType, TemplateBinding, Text, VariableBinding} from '@angular/compiler';\n+import {AbsoluteSourceSpan, AST, AstPath, AttrAst, Attribute, BoundDirectivePropertyAst, BoundElementPropertyAst, BoundEventAst, BoundTextAst, Element, ElementAst, EmptyExpr, ExpressionBinding, getHtmlTagDefinition, HtmlAstPath, Node as HtmlAst, NullTemplateVisitor, ParseSpan, ReferenceAst, TagContentType, TemplateBinding, Text, VariableBinding, Visitor} from '@angular/compiler';\n import {$$, $_, isAsciiLetter, isDigit} from '@angular/compiler/src/chars';\n \n import {ATTR, getBindingDescriptor} from './binding_utils';\n@@ -127,79 +127,97 @@ function getBoundedWordSpan(\n \n export function getTemplateCompletions(\n     templateInfo: ng.AstResult, position: number): ng.CompletionEntry[] {\n-  let result: ng.CompletionEntry[] = [];\n   const {htmlAst, template} = templateInfo;\n-  // The templateNode starts at the delimiter character so we add 1 to skip it.\n+  // Calculate the position relative to the start of the template. This is needed\n+  // because spans in HTML AST are relative. Inline template has non-zero start position.\n   const templatePosition = position - template.span.start;\n-  const path = getPathToNodeAtPosition(htmlAst, templatePosition);\n-  const mostSpecific = path.tail;\n-  if (path.empty || !mostSpecific) {\n-    result = elementCompletions(templateInfo);\n-  } else {\n-    const astPosition = templatePosition - mostSpecific.sourceSpan.start.offset;\n-    mostSpecific.visit(\n-        {\n-          visitElement(ast) {\n-            const startTagSpan = spanOf(ast.sourceSpan);\n-            const tagLen = ast.name.length;\n-            // + 1 for the opening angle bracket\n-            if (templatePosition <= startTagSpan.start + tagLen + 1) {\n-              // If we are in the tag then return the element completions.\n-              result = elementCompletions(templateInfo);\n-            } else if (templatePosition < startTagSpan.end) {\n-              // We are in the attribute section of the element (but not in an attribute).\n-              // Return the attribute completions.\n-              result = attributeCompletionsForElement(templateInfo, ast.name);\n-            }\n-          },\n-          visitAttribute(ast: Attribute) {\n-            // An attribute consists of two parts, LHS=\"RHS\".\n-            // Determine if completions are requested for LHS or RHS\n-            if (ast.valueSpan && inSpan(templatePosition, spanOf(ast.valueSpan))) {\n-              // RHS completion\n-              result = attributeValueCompletions(templateInfo, path);\n-            } else {\n-              // LHS completion\n-              result = attributeCompletions(templateInfo, path);\n-            }\n-          },\n-          visitText(ast) {\n-            result = interpolationCompletions(templateInfo, templatePosition);\n-            if (result.length) return result;\n-            const element = path.first(Element);\n-            if (element) {\n-              const definition = getHtmlTagDefinition(element.name);\n-              if (definition.contentType === TagContentType.PARSABLE_DATA) {\n-                result = voidElementAttributeCompletions(templateInfo, path);\n-                if (!result.length) {\n-                  // If the element can hold content, show element completions.\n-                  result = elementCompletions(templateInfo);\n-                }\n-              }\n-            } else {\n-              // If no element container, implies parsable data so show elements.\n-              result = voidElementAttributeCompletions(templateInfo, path);\n-              if (!result.length) {\n-                result = elementCompletions(templateInfo);\n-              }\n-            }\n-          },\n-          visitComment() {},\n-          visitExpansion() {},\n-          visitExpansionCase() {}\n-        },\n-        null);\n-  }\n-\n+  const htmlPath: HtmlAstPath = getPathToNodeAtPosition(htmlAst, templatePosition);\n+  const mostSpecific = htmlPath.tail;\n+  const visitor = new HtmlVisitor(templateInfo, htmlPath);\n+  const results: ng.CompletionEntry[] = mostSpecific ?\n+      mostSpecific.visit(visitor, null /* context */) :\n+      elementCompletions(templateInfo);\n   const replacementSpan = getBoundedWordSpan(templateInfo, position, mostSpecific);\n-  return result.map(entry => {\n+  return results.map(entry => {\n     return {\n       ...entry,\n       replacementSpan,\n     };\n   });\n }\n \n+class HtmlVisitor implements Visitor {\n+  /**\n+   * Position relative to the start of the template.\n+   */\n+  private readonly relativePosition: number;\n+  constructor(private readonly templateInfo: ng.AstResult, private readonly htmlPath: HtmlAstPath) {\n+    this.relativePosition = htmlPath.position;\n+  }\n+  // Note that every visitor method must explicitly specify return type because\n+  // Visitor returns `any` for all methods.\n+  visitElement(ast: Element): ng.CompletionEntry[] {\n+    const startTagSpan = spanOf(ast.sourceSpan);\n+    const tagLen = ast.name.length;\n+    // + 1 for the opening angle bracket\n+    if (this.relativePosition <= startTagSpan.start + tagLen + 1) {\n+      // If we are in the tag then return the element completions.\n+      return elementCompletions(this.templateInfo);\n+    }\n+    if (this.relativePosition < startTagSpan.end) {\n+      // We are in the attribute section of the element (but not in an attribute).\n+      // Return the attribute completions.\n+      return attributeCompletionsForElement(this.templateInfo, ast.name);\n+    }\n+    return [];\n+  }\n+  visitAttribute(ast: Attribute): ng.CompletionEntry[] {\n+    // An attribute consists of two parts, LHS=\"RHS\".\n+    // Determine if completions are requested for LHS or RHS\n+    if (ast.valueSpan && inSpan(this.relativePosition, spanOf(ast.valueSpan))) {\n+      // RHS completion\n+      return attributeValueCompletions(this.templateInfo, this.htmlPath);\n+    }\n+    // LHS completion\n+    return attributeCompletions(this.templateInfo, this.htmlPath);\n+  }\n+  visitText(): ng.CompletionEntry[] {\n+    const templatePath = findTemplateAstAt(this.templateInfo.templateAst, this.relativePosition);\n+    if (templatePath.tail instanceof BoundTextAst) {\n+      // If we know that this is an interpolation then do not try other scenarios.\n+      const visitor = new ExpressionVisitor(\n+          this.templateInfo, this.relativePosition,\n+          () =>\n+              getExpressionScope(diagnosticInfoFromTemplateInfo(this.templateInfo), templatePath));\n+      templatePath.tail?.visit(visitor, null);\n+      return visitor.results;\n+    }\n+    // TODO(kyliau): Not sure if this check is really needed since we don't have\n+    // any test cases for it.\n+    const element = this.htmlPath.first(Element);\n+    if (element &&\n+        getHtmlTagDefinition(element.name).contentType !== TagContentType.PARSABLE_DATA) {\n+      return [];\n+    }\n+    // This is to account for cases like <h1> <a> text | </h1> where the\n+    // closest element has no closing tag and thus is considered plain text.\n+    const results = voidElementAttributeCompletions(this.templateInfo, this.htmlPath);\n+    if (results.length) {\n+      return results;\n+    }\n+    return elementCompletions(this.templateInfo);\n+  }\n+  visitComment(): ng.CompletionEntry[] {\n+    return [];\n+  }\n+  visitExpansion(): ng.CompletionEntry[] {\n+    return [];\n+  }\n+  visitExpansionCase(): ng.CompletionEntry[] {\n+    return [];\n+  }\n+}\n+\n function attributeCompletions(info: ng.AstResult, path: AstPath<HtmlAst>): ng.CompletionEntry[] {\n   const attr = path.tail;\n   const elem = path.parentOf(attr);\n@@ -356,18 +374,6 @@ function elementCompletions(info: ng.AstResult): ng.CompletionEntry[] {\n   return results;\n }\n \n-function interpolationCompletions(info: ng.AstResult, position: number): ng.CompletionEntry[] {\n-  // Look for an interpolation in at the position.\n-  const templatePath = findTemplateAstAt(info.templateAst, position);\n-  if (!templatePath.tail) {\n-    return [];\n-  }\n-  const visitor = new ExpressionVisitor(\n-      info, position, () => getExpressionScope(diagnosticInfoFromTemplateInfo(info), templatePath));\n-  templatePath.tail.visit(visitor, null);\n-  return visitor.results;\n-}\n-\n // There is a special case of HTML where text that contains a unclosed tag is treated as\n // text. For exaple '<h1> Some <a text </h1>' produces a text nodes inside of the H1\n // element \"Some <a text\". We, however, want to treat this as if the user was requesting"
        },
        {
            "sha": "b5a818b6569c11bd577ae336cb5435caf850dd9b",
            "filename": "packages/language-service/test/completions_spec.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/ae5257cda6dd6957c3def575176e922111ea170d/packages%2Flanguage-service%2Ftest%2Fcompletions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/ae5257cda6dd6957c3def575176e922111ea170d/packages%2Flanguage-service%2Ftest%2Fcompletions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fcompletions_spec.ts?ref=ae5257cda6dd6957c3def575176e922111ea170d",
            "patch": "@@ -841,6 +841,13 @@ describe('completions', () => {\n       'trim',\n     ]);\n   });\n+\n+  it('should not return any results for unknown symbol', () => {\n+    mockHost.override(TEST_TEMPLATE, '{{ doesnotexist.~{cursor} }}');\n+    const marker = mockHost.getLocationMarkerFor(TEST_TEMPLATE, 'cursor');\n+    const completions = ngLS.getCompletionsAtPosition(TEST_TEMPLATE, marker.start);\n+    expect(completions).toBeUndefined();\n+  });\n });\n \n function expectContain("
        }
    ],
    "stats": {
        "total": 165,
        "additions": 89,
        "deletions": 76
    }
}