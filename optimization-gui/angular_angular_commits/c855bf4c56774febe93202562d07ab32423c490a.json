{
    "author": "devversion",
    "message": "refactor(compiler): clean up template information passed for partial compilation (#41583)\n\nWith the introduction of the partial compilation, the Angular compiler's\nexisting `parseTemplate` method has been extended to pass through multiple\nproperties purely in favor of the partial compilation.\n\ne.g. the `parseTemplate` function now accepts an \"option\" called `isInline`.\nThis option is just passed through and returned as part of the `ParsedTemplate`.\n\nThis is not ideal because the `parseTemplate` function doesn't care\nwhether the specified template was inline or not. This commit cleans\nup the `parseTemplate` compiler function so that nothing needed only\nfor the partial compilation is added to it.\n\nWe introduce a new struct for additional template information that\nis specific to the generation of the `declareComponent` function. With\nthat change, we can simplify the component decorator handler and keep\nlogic more local.\n\nPR Close #41583",
    "sha": "c855bf4c56774febe93202562d07ab32423c490a",
    "files": [
        {
            "sha": "b2cd37eea97c6402dbe2cffc3ffe311ae7f741f5",
            "filename": "packages/compiler-cli/linker/src/file_linker/partial_linkers/partial_component_linker_1.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/c855bf4c56774febe93202562d07ab32423c490a/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_component_linker_1.ts",
            "raw_url": "https://github.com/angular/angular/raw/c855bf4c56774febe93202562d07ab32423c490a/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_component_linker_1.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_component_linker_1.ts?ref=c855bf4c56774febe93202562d07ab32423c490a",
            "patch": "@@ -55,7 +55,6 @@ export class PartialComponentLinkerVersion1<TStatement, TExpression> implements\n           metaObj.has('preserveWhitespaces') ? metaObj.getBoolean('preserveWhitespaces') : false,\n       // We normalize line endings if the template is was inline.\n       i18nNormalizeLineEndingsInICUs: isInline,\n-      isInline,\n     });\n     if (template.errors !== null) {\n       const errors = template.errors.map(err => err.toString()).join('\\n');"
        },
        {
            "sha": "67722e6589e6f9f7ef6c4ddd8d10bb85ed9132ad",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/component.ts",
            "status": "modified",
            "additions": 37,
            "deletions": 35,
            "changes": 72,
            "blob_url": "https://github.com/angular/angular/blob/c855bf4c56774febe93202562d07ab32423c490a/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/c855bf4c56774febe93202562d07ab32423c490a/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts?ref=c855bf4c56774febe93202562d07ab32423c490a",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {compileClassMetadata, compileComponentFromMetadata, compileDeclareClassMetadata, compileDeclareComponentFromMetadata, ConstantPool, CssSelector, DeclarationListEmitMode, DEFAULT_INTERPOLATION_CONFIG, DomElementSchemaRegistry, Expression, ExternalExpr, FactoryTarget, InterpolationConfig, LexerRange, makeBindingParser, ParsedTemplate, ParseSourceFile, parseTemplate, R3ClassMetadata, R3ComponentMetadata, R3FactoryMetadata, R3TargetBinder, R3UsedDirectiveMetadata, SelectorMatcher, Statement, TmplAstNode, WrappedNodeExpr} from '@angular/compiler';\n+import {compileClassMetadata, compileComponentFromMetadata, compileDeclareClassMetadata, compileDeclareComponentFromMetadata, ConstantPool, CssSelector, DeclarationListEmitMode, DeclareComponentTemplateInfo, DEFAULT_INTERPOLATION_CONFIG, DomElementSchemaRegistry, Expression, ExternalExpr, FactoryTarget, InterpolationConfig, LexerRange, makeBindingParser, ParsedTemplate, ParseSourceFile, parseTemplate, R3ClassMetadata, R3ComponentMetadata, R3TargetBinder, R3UsedDirectiveMetadata, SelectorMatcher, Statement, TmplAstNode, WrappedNodeExpr} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {Cycle, CycleAnalyzer, CycleHandlingStrategy} from '../../cycles';\n@@ -390,7 +390,7 @@ export class ComponentDecoratorHandler implements\n       template = this.extractTemplate(node, templateDecl);\n     }\n     const templateResource =\n-        template.isInline ? {path: null, expression: component.get('template')!} : {\n+        template.declaration.isInline ? {path: null, expression: component.get('template')!} : {\n           path: absoluteFrom(template.declaration.resolvedTemplateUrl),\n           expression: template.sourceMapping.node\n         };\n@@ -571,7 +571,7 @@ export class ComponentDecoratorHandler implements\n       selector,\n       boundTemplate,\n       templateMeta: {\n-        isInline: analysis.template.isInline,\n+        isInline: analysis.template.declaration.isInline,\n         file: analysis.template.file,\n       },\n     });\n@@ -882,9 +882,17 @@ export class ComponentDecoratorHandler implements\n     if (analysis.template.errors !== null && analysis.template.errors.length > 0) {\n       return [];\n     }\n+    const templateInfo: DeclareComponentTemplateInfo = {\n+      content: analysis.template.content,\n+      sourceUrl: analysis.template.declaration.resolvedTemplateUrl,\n+      isInline: analysis.template.declaration.isInline,\n+      inlineTemplateExpression: analysis.template.declaration.isInline ?\n+          new WrappedNodeExpr(analysis.template.declaration.expression) :\n+          null,\n+    };\n     const meta: R3ComponentMetadata = {...analysis.meta, ...resolution};\n     const fac = compileDeclareFactory(toFactoryMetadata(meta, FactoryTarget.Component));\n-    const def = compileDeclareComponentFromMetadata(meta, analysis.template);\n+    const def = compileDeclareComponentFromMetadata(meta, analysis.template, templateInfo);\n     const classMetadata = analysis.classMetadata !== null ?\n         compileDeclareClassMetadata(analysis.classMetadata).toStmt() :\n         null;\n@@ -1055,21 +1063,19 @@ export class ComponentDecoratorHandler implements\n   private extractTemplate(node: ClassDeclaration, template: TemplateDeclaration):\n       ParsedTemplateWithSource {\n     if (template.isInline) {\n-      let templateStr: string;\n-      let templateLiteral: ts.Node|null = null;\n-      let templateUrl: string = '';\n-      let templateRange: LexerRange|null = null;\n+      let sourceStr: string;\n+      let sourceParseRange: LexerRange|null = null;\n+      let templateContent: string;\n       let sourceMapping: TemplateSourceMapping;\n       let escapedString = false;\n       // We only support SourceMaps for inline templates that are simple string literals.\n       if (ts.isStringLiteral(template.expression) ||\n           ts.isNoSubstitutionTemplateLiteral(template.expression)) {\n         // the start and end of the `templateExpr` node includes the quotation marks, which we must\n         // strip\n-        templateRange = getTemplateRange(template.expression);\n-        templateStr = template.expression.getSourceFile().text;\n-        templateLiteral = template.expression;\n-        templateUrl = template.templateUrl;\n+        sourceParseRange = getTemplateRange(template.expression);\n+        sourceStr = template.expression.getSourceFile().text;\n+        templateContent = template.expression.text;\n         escapedString = true;\n         sourceMapping = {\n           type: 'direct',\n@@ -1081,38 +1087,43 @@ export class ComponentDecoratorHandler implements\n           throw createValueHasWrongTypeError(\n               template.expression, resolvedTemplate, 'template must be a string');\n         }\n-        templateStr = resolvedTemplate;\n+        // We do not parse the template directly from the source file using a lexer range, so\n+        // the template source and content are set to the statically resolved template.\n+        sourceStr = resolvedTemplate;\n+        templateContent = resolvedTemplate;\n         sourceMapping = {\n           type: 'indirect',\n           node: template.expression,\n           componentClass: node,\n-          template: templateStr,\n+          template: templateContent,\n         };\n       }\n \n       return {\n-        ...this._parseTemplate(template, templateStr, templateRange, escapedString),\n+        ...this._parseTemplate(template, sourceStr, sourceParseRange, escapedString),\n+        content: templateContent,\n         sourceMapping,\n         declaration: template,\n       };\n     } else {\n-      const templateStr = this.resourceLoader.load(template.resolvedTemplateUrl);\n+      const templateContent = this.resourceLoader.load(template.resolvedTemplateUrl);\n       if (this.depTracker !== null) {\n         this.depTracker.addResourceDependency(\n             node.getSourceFile(), absoluteFrom(template.resolvedTemplateUrl));\n       }\n \n       return {\n         ...this._parseTemplate(\n-            template, templateStr, /* templateRange */ null,\n+            template, /* sourceStr */ templateContent, /* sourceParseRange */ null,\n             /* escapedString */ false),\n+        content: templateContent,\n         sourceMapping: {\n           type: 'external',\n           componentClass: node,\n           // TODO(alxhub): TS in g3 is unable to make this inference on its own, so cast it here\n           // until g3 is able to figure this out.\n           node: (template as ExternalTemplateDeclaration).templateUrlExpression,\n-          template: templateStr,\n+          template: templateContent,\n           templateUrl: template.resolvedTemplateUrl,\n         },\n         declaration: template,\n@@ -1121,19 +1132,18 @@ export class ComponentDecoratorHandler implements\n   }\n \n   private _parseTemplate(\n-      template: TemplateDeclaration, templateStr: string, templateRange: LexerRange|null,\n+      template: TemplateDeclaration, sourceStr: string, sourceParseRange: LexerRange|null,\n       escapedString: boolean): ParsedComponentTemplate {\n     // We always normalize line endings if the template has been escaped (i.e. is inline).\n     const i18nNormalizeLineEndingsInICUs = escapedString || this.i18nNormalizeLineEndingsInICUs;\n \n-    const parsedTemplate = parseTemplate(templateStr, template.sourceMapUrl, {\n+    const parsedTemplate = parseTemplate(sourceStr, template.sourceMapUrl, {\n       preserveWhitespaces: template.preserveWhitespaces,\n       interpolationConfig: template.interpolationConfig,\n-      range: templateRange ?? undefined,\n+      range: sourceParseRange ?? undefined,\n       escapedString,\n       enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n       i18nNormalizeLineEndingsInICUs,\n-      isInline: template.isInline,\n       alwaysAttemptHtmlToR3AstConversion: this.usePoisonedData,\n     });\n \n@@ -1152,26 +1162,22 @@ export class ComponentDecoratorHandler implements\n     // In order to guarantee the correctness of diagnostics, templates are parsed a second time\n     // with the above options set to preserve source mappings.\n \n-    const {nodes: diagNodes} = parseTemplate(templateStr, template.sourceMapUrl, {\n+    const {nodes: diagNodes} = parseTemplate(sourceStr, template.sourceMapUrl, {\n       preserveWhitespaces: true,\n       preserveLineEndings: true,\n       interpolationConfig: template.interpolationConfig,\n-      range: templateRange ?? undefined,\n+      range: sourceParseRange ?? undefined,\n       escapedString,\n       enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n       i18nNormalizeLineEndingsInICUs,\n       leadingTriviaChars: [],\n-      isInline: template.isInline,\n       alwaysAttemptHtmlToR3AstConversion: this.usePoisonedData,\n     });\n \n     return {\n       ...parsedTemplate,\n       diagNodes,\n-      template: template.isInline ? new WrappedNodeExpr(template.expression) : templateStr,\n-      templateUrl: template.resolvedTemplateUrl,\n-      isInline: template.isInline,\n-      file: new ParseSourceFile(templateStr, template.resolvedTemplateUrl),\n+      file: new ParseSourceFile(sourceStr, template.resolvedTemplateUrl),\n     };\n   }\n \n@@ -1363,12 +1369,6 @@ function getTemplateDeclarationNodeForError(declaration: TemplateDeclaration): t\n  * some of which might be useful for re-parsing the template with different options.\n  */\n export interface ParsedComponentTemplate extends ParsedTemplate {\n-  /**\n-   * True if the original template was stored inline;\n-   * False if the template was in an external file.\n-   */\n-  isInline: boolean;\n-\n   /**\n    * The template AST, parsed in a manner which preserves source map information for diagnostics.\n    *\n@@ -1383,6 +1383,8 @@ export interface ParsedComponentTemplate extends ParsedTemplate {\n }\n \n export interface ParsedTemplateWithSource extends ParsedComponentTemplate {\n+  /** The string contents of the template. */\n+  content: string;\n   sourceMapping: TemplateSourceMapping;\n   declaration: TemplateDeclaration;\n }"
        },
        {
            "sha": "af28935d55b1a36d088e7ca22805569bff177b30",
            "filename": "packages/compiler/src/compiler.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/c855bf4c56774febe93202562d07ab32423c490a/packages%2Fcompiler%2Fsrc%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/c855bf4c56774febe93202562d07ab32423c490a/packages%2Fcompiler%2Fsrc%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fcompiler.ts?ref=c855bf4c56774febe93202562d07ab32423c490a",
            "patch": "@@ -106,7 +106,7 @@ export {makeBindingParser, ParsedTemplate, parseTemplate, ParseTemplateOptions}\n export {R3CompiledExpression, R3Reference, devOnlyGuardedExpression, getSafePropertyAccessString} from './render3/util';\n export {compileComponentFromMetadata, compileDirectiveFromMetadata, parseHostBindings, ParsedHostBindings, verifyHostBindings} from './render3/view/compiler';\n export {compileDeclareClassMetadata} from './render3/partial/class_metadata';\n-export {compileDeclareComponentFromMetadata} from './render3/partial/component';\n+export {compileDeclareComponentFromMetadata, DeclareComponentTemplateInfo} from './render3/partial/component';\n export {compileDeclareDirectiveFromMetadata} from './render3/partial/directive';\n export {compileDeclareFactoryFunction} from './render3/partial/factory';\n export {compileDeclareInjectableFromMetadata} from './render3/partial/injectable';"
        },
        {
            "sha": "5f56a0638464cd4a6f55c39570e3125b6e52c4e4",
            "filename": "packages/compiler/src/render3/partial/component.ts",
            "status": "modified",
            "additions": 46,
            "deletions": 24,
            "changes": 70,
            "blob_url": "https://github.com/angular/angular/blob/c855bf4c56774febe93202562d07ab32423c490a/packages%2Fcompiler%2Fsrc%2Frender3%2Fpartial%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/c855bf4c56774febe93202562d07ab32423c490a/packages%2Fcompiler%2Fsrc%2Frender3%2Fpartial%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fpartial%2Fcomponent.ts?ref=c855bf4c56774febe93202562d07ab32423c490a",
            "patch": "@@ -20,13 +20,39 @@ import {R3DeclareComponentMetadata, R3DeclareUsedDirectiveMetadata} from './api'\n import {createDirectiveDefinitionMap} from './directive';\n import {generateForwardRef, toOptionalLiteralArray} from './util';\n \n+export interface DeclareComponentTemplateInfo {\n+  /**\n+   * The string contents of the template.\n+   *\n+   * This is the \"logical\" template string, after expansion of any escaped characters (for inline\n+   * templates). This may differ from the actual template bytes as they appear in the .ts file.\n+   */\n+  content: string;\n+\n+  /**\n+   * A full path to the file which contains the template.\n+   *\n+   * This can be either the original .ts file if the template is inline, or the .html file if an\n+   * external file was used.\n+   */\n+  sourceUrl: string;\n+\n+  /**\n+   * Whether the template was inline (using `template`) or external (using `templateUrl`).\n+   */\n+  isInline: boolean;\n+\n+  /** Expression that resolves to the inline template. */\n+  inlineTemplateExpression: o.Expression|null;\n+}\n \n /**\n  * Compile a component declaration defined by the `R3ComponentMetadata`.\n  */\n export function compileDeclareComponentFromMetadata(\n-    meta: R3ComponentMetadata, template: ParsedTemplate): R3CompiledExpression {\n-  const definitionMap = createComponentDefinitionMap(meta, template);\n+    meta: R3ComponentMetadata, template: ParsedTemplate,\n+    additionalTemplateInfo: DeclareComponentTemplateInfo): R3CompiledExpression {\n+  const definitionMap = createComponentDefinitionMap(meta, template, additionalTemplateInfo);\n \n   const expression = o.importExpr(R3.declareComponent).callFn([definitionMap.toLiteralMap()]);\n   const type = createComponentType(meta);\n@@ -37,13 +63,14 @@ export function compileDeclareComponentFromMetadata(\n /**\n  * Gathers the declaration fields for a component into a `DefinitionMap`.\n  */\n-export function createComponentDefinitionMap(meta: R3ComponentMetadata, template: ParsedTemplate):\n-    DefinitionMap<R3DeclareComponentMetadata> {\n+export function createComponentDefinitionMap(\n+    meta: R3ComponentMetadata, template: ParsedTemplate,\n+    templateInfo: DeclareComponentTemplateInfo): DefinitionMap<R3DeclareComponentMetadata> {\n   const definitionMap: DefinitionMap<R3DeclareComponentMetadata> =\n       createDirectiveDefinitionMap(meta);\n \n-  definitionMap.set('template', getTemplateExpression(template));\n-  if (template.isInline) {\n+  definitionMap.set('template', getTemplateExpression(template, templateInfo));\n+  if (templateInfo.isInline) {\n     definitionMap.set('isInline', o.literal(true));\n   }\n \n@@ -82,25 +109,20 @@ export function createComponentDefinitionMap(meta: R3ComponentMetadata, template\n   return definitionMap;\n }\n \n-function getTemplateExpression(template: ParsedTemplate): o.Expression {\n-  if (typeof template.template === 'string') {\n-    if (template.isInline) {\n-      // The template is inline but not a simple literal string, so give up with trying to\n-      // source-map it and just return a simple literal here.\n-      return o.literal(template.template);\n-    } else {\n-      // The template is external so we must synthesize an expression node with the appropriate\n-      // source-span.\n-      const contents = template.template;\n-      const file = new ParseSourceFile(contents, template.templateUrl);\n-      const start = new ParseLocation(file, 0, 0, 0);\n-      const end = computeEndLocation(file, contents);\n-      const span = new ParseSourceSpan(start, end);\n-      return o.literal(contents, null, span);\n-    }\n-  } else {\n+function getTemplateExpression(\n+    template: ParsedTemplate, templateInfo: DeclareComponentTemplateInfo): o.Expression {\n+  if (templateInfo.isInline) {\n     // The template is inline so we can just reuse the current expression node.\n-    return template.template;\n+    return templateInfo.inlineTemplateExpression!;\n+  } else {\n+    // The template is external so we must synthesize an expression node with the appropriate\n+    // source-span.\n+    const contents = templateInfo.content;\n+    const file = new ParseSourceFile(contents, templateInfo.sourceUrl);\n+    const start = new ParseLocation(file, 0, 0, 0);\n+    const end = computeEndLocation(file, contents);\n+    const span = new ParseSourceSpan(start, end);\n+    return o.literal(contents, null, span);\n   }\n }\n "
        },
        {
            "sha": "530ce30ccc2d6caf0bc69d1269569638d2adb844",
            "filename": "packages/compiler/src/render3/view/template.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 39,
            "changes": 42,
            "blob_url": "https://github.com/angular/angular/blob/c855bf4c56774febe93202562d07ab32423c490a/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "raw_url": "https://github.com/angular/angular/raw/c855bf4c56774febe93202562d07ab32423c490a/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts?ref=c855bf4c56774febe93202562d07ab32423c490a",
            "patch": "@@ -22,7 +22,7 @@ import {LexerRange} from '../../ml_parser/lexer';\n import {isNgContainer as checkIsNgContainer, splitNsName} from '../../ml_parser/tags';\n import {mapLiteral} from '../../output/map_util';\n import * as o from '../../output/output_ast';\n-import {ParseError, ParseSourceSpan} from '../../parse_util';\n+import {ParseError, ParseSourceFile, ParseSourceSpan} from '../../parse_util';\n import {DomElementSchemaRegistry} from '../../schema/dom_element_schema_registry';\n import {isTrustedTypesSink} from '../../schema/trusted_types_sinks';\n import {CssSelector, SelectorMatcher} from '../../selector';\n@@ -2082,6 +2082,7 @@ export interface ParseTemplateOptions {\n    * `$localize` message id format and you are not using compile time translation merging.\n    */\n   enableI18nLegacyMessageIdFormat?: boolean;\n+\n   /**\n    * If this text is stored in an external template (e.g. via `templateUrl`) then we need to decide\n    * whether or not to normalize the line-endings (from `\\r\\n` to `\\n`) when processing ICU\n@@ -2092,11 +2093,6 @@ export interface ParseTemplateOptions {\n    */\n   i18nNormalizeLineEndingsInICUs?: boolean;\n \n-  /**\n-   * Whether the template was inline.\n-   */\n-  isInline?: boolean;\n-\n   /**\n    * Whether to always attempt to convert the parsed HTML AST to an R3 AST, despite HTML or i18n\n    * Meta parse errors.\n@@ -2134,7 +2130,6 @@ export interface ParseTemplateOptions {\n export function parseTemplate(\n     template: string, templateUrl: string, options: ParseTemplateOptions = {}): ParsedTemplate {\n   const {interpolationConfig, preserveWhitespaces, enableI18nLegacyMessageIdFormat} = options;\n-  const isInline = options.isInline ?? false;\n   const bindingParser = makeBindingParser(interpolationConfig);\n   const htmlParser = new HtmlParser();\n   const parseResult = htmlParser.parse(\n@@ -2146,9 +2141,6 @@ export function parseTemplate(\n     const parsedTemplate: ParsedTemplate = {\n       interpolationConfig,\n       preserveWhitespaces,\n-      template,\n-      templateUrl,\n-      isInline,\n       errors: parseResult.errors,\n       nodes: [],\n       styleUrls: [],\n@@ -2177,9 +2169,6 @@ export function parseTemplate(\n     const parsedTemplate: ParsedTemplate = {\n       interpolationConfig,\n       preserveWhitespaces,\n-      template,\n-      templateUrl,\n-      isInline,\n       errors: i18nMetaResult.errors,\n       nodes: [],\n       styleUrls: [],\n@@ -2215,14 +2204,12 @@ export function parseTemplate(\n     interpolationConfig,\n     preserveWhitespaces,\n     errors: errors.length > 0 ? errors : null,\n-    template,\n-    templateUrl,\n-    isInline,\n     nodes,\n     styleUrls,\n     styles,\n     ngContentSelectors\n   };\n+\n   if (options.collectCommentNodes) {\n     parsedTemplate.commentNodes = commentNodes;\n   }\n@@ -2383,29 +2370,6 @@ export interface ParsedTemplate {\n    * How to parse interpolation markers.\n    */\n   interpolationConfig?: InterpolationConfig;\n-\n-  /**\n-   * The string contents of the template, or an expression that represents the string/template\n-   * literal as it occurs in the source.\n-   *\n-   * This is the \"logical\" template string, after expansion of any escaped characters (for inline\n-   * templates). This may differ from the actual template bytes as they appear in the .ts file.\n-   */\n-  template: string|o.Expression;\n-\n-  /**\n-   * A full path to the file which contains the template.\n-   *\n-   * This can be either the original .ts file if the template is inline, or the .html file if an\n-   * external file was used.\n-   */\n-  templateUrl: string;\n-\n-  /**\n-   * Whether the template was inline (using `template`) or external (using `templateUrl`).\n-   */\n-  isInline: boolean;\n-\n   /**\n    * Any errors from parsing the template the first time.\n    *"
        }
    ],
    "stats": {
        "total": 187,
        "additions": 87,
        "deletions": 100
    }
}