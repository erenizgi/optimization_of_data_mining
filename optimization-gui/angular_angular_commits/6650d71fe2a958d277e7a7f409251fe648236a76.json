{
    "author": "petebacondarwin",
    "message": "test(compiler-cli): make the `getDeclaration()` utility more resilient to code format (#38959)\n\nPreviously `getDeclaration()` would only return the first node that matched\nthe name passed in and then assert the predicate on this single node.\nIt also only considered a subset of possible declaration types that we might\ncare about.\n\nNow the function will parse the whole tree collecting an array of all the\nnodes that match the name. It then filters this array based on the predicate\nand only errors if the filtered array is empty.\n\nThis makes this function much more resilient to more esoteric code formats\nsuch as UMD.\n\nPR Close #38959",
    "sha": "6650d71fe2a958d277e7a7f409251fe648236a76",
    "files": [
        {
            "sha": "d0c209f8715c169f4cc4167c8c8df875f12335ab",
            "filename": "packages/compiler-cli/ngcc/test/host/esm2015_host_spec.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 15,
            "changes": 30,
            "blob_url": "https://github.com/angular/angular/blob/6650d71fe2a958d277e7a7f409251fe648236a76/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fesm2015_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/6650d71fe2a958d277e7a7f409251fe648236a76/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fesm2015_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fesm2015_host_spec.ts?ref=6650d71fe2a958d277e7a7f409251fe648236a76",
            "patch": "@@ -13,7 +13,7 @@ import {runInEachFileSystem, TestFile} from '../../../src/ngtsc/file_system/test\n import {MockLogger} from '../../../src/ngtsc/logging/testing';\n import {ClassMemberKind, ConcreteDeclaration, CtorParameter, DownleveledEnum, isNamedClassDeclaration, isNamedFunctionDeclaration, isNamedVariableDeclaration, TypeScriptReflectionHost} from '../../../src/ngtsc/reflection';\n import {getDeclaration} from '../../../src/ngtsc/testing';\n-import {walkForDeclaration} from '../../../src/ngtsc/testing/src/utils';\n+import {walkForDeclarations} from '../../../src/ngtsc/testing/src/utils';\n import {loadFakeCore, loadTestFiles} from '../../../test/helpers';\n import {DelegatingReflectionHost} from '../../src/host/delegating_host';\n import {Esm2015ReflectionHost} from '../../src/host/esm2015_host';\n@@ -1732,13 +1732,13 @@ runInEachFileSystem(() => {\n            const classDeclaration = getDeclaration(\n                bundle.program, WRAPPED_CLASS_EXPRESSION_FILE.name, 'DecoratedWrappedClass',\n                ts.isVariableDeclaration);\n-           const innerClassDeclaration =\n-               walkForDeclaration('InnerDecoratedWrappedClass', classDeclaration);\n-           if (innerClassDeclaration === null) {\n+           const innerClassDeclarations =\n+               walkForDeclarations('InnerDecoratedWrappedClass', classDeclaration);\n+           if (innerClassDeclarations.length === 0) {\n              throw new Error('Expected InnerDecoratedWrappedClass to exist');\n            }\n            const aliasedClassIdentifier =\n-               (innerClassDeclaration.parent as ts.BinaryExpression).left as ts.Identifier;\n+               (innerClassDeclarations[0].parent as ts.BinaryExpression).left as ts.Identifier;\n            expect(aliasedClassIdentifier.text).toBe('DecoratedWrappedClass_1');\n            const d = host.getDeclarationOfIdentifier(aliasedClassIdentifier);\n            expect(d!.node).toBe(classDeclaration);\n@@ -2065,18 +2065,18 @@ runInEachFileSystem(() => {\n            const outerNode = getDeclaration(\n                bundle.program, WRAPPED_CLASS_EXPRESSION_FILE.name, 'DecoratedWrappedClass',\n                isNamedVariableDeclaration);\n-           const innerNode = walkForDeclaration('InnerDecoratedWrappedClass', outerNode);\n-           if (innerNode === null) {\n+           const innerNodes = walkForDeclarations('InnerDecoratedWrappedClass', outerNode);\n+           if (innerNodes.length === 0) {\n              throw new Error('Expected to find InnerDecoratedWrappedClass');\n            }\n-           const classSymbol = host.getClassSymbol(innerNode);\n+           const classSymbol = host.getClassSymbol(innerNodes[0]);\n \n            if (classSymbol === undefined) {\n              return fail('Expected classSymbol to be defined');\n            }\n            expect(classSymbol.name).toEqual('DecoratedWrappedClass');\n            expect(classSymbol.declaration.valueDeclaration).toBe(outerNode);\n-           expect(classSymbol.implementation.valueDeclaration).toBe(innerNode);\n+           expect(classSymbol.implementation.valueDeclaration).toBe(innerNodes[0]);\n \n            if (classSymbol.adjacent === undefined ||\n                !isNamedVariableDeclaration(classSymbol.adjacent.valueDeclaration)) {\n@@ -2096,8 +2096,8 @@ runInEachFileSystem(() => {\n            const outerNode = getDeclaration(\n                bundle.program, WRAPPED_CLASS_EXPRESSION_FILE.name, 'DecoratedWrappedClass',\n                isNamedVariableDeclaration);\n-           const innerNode = walkForDeclaration('InnerDecoratedWrappedClass', outerNode);\n-           if (innerNode === null) {\n+           const innerNodes = walkForDeclarations('InnerDecoratedWrappedClass', outerNode);\n+           if (innerNodes.length === 0) {\n              throw new Error('Expected to find InnerDecoratedWrappedClass');\n            }\n            const adjacentNode: ts.ClassExpression =\n@@ -2112,7 +2112,7 @@ runInEachFileSystem(() => {\n            }\n            expect(classSymbol.name).toEqual('DecoratedWrappedClass');\n            expect(classSymbol.declaration.valueDeclaration).toBe(outerNode);\n-           expect(classSymbol.implementation.valueDeclaration).toBe(innerNode);\n+           expect(classSymbol.implementation.valueDeclaration).toBe(innerNodes[0]);\n \n            if (classSymbol.adjacent === undefined ||\n                !isNamedVariableDeclaration(classSymbol.adjacent.valueDeclaration)) {\n@@ -2131,12 +2131,12 @@ runInEachFileSystem(() => {\n            const outerNode = getDeclaration(\n                bundle.program, WRAPPED_CLASS_EXPRESSION_FILE.name, 'DecoratedWrappedClass',\n                isNamedVariableDeclaration);\n-           const innerNode = walkForDeclaration('InnerDecoratedWrappedClass', outerNode);\n-           if (innerNode === null) {\n+           const innerNodes = walkForDeclarations('InnerDecoratedWrappedClass', outerNode);\n+           if (innerNodes.length === 0) {\n              throw new Error('Expected to find InnerDecoratedWrappedClass');\n            }\n \n-           const innerSymbol = host.getClassSymbol(innerNode)!;\n+           const innerSymbol = host.getClassSymbol(innerNodes[0])!;\n            const outerSymbol = host.getClassSymbol(outerNode)!;\n            expect(innerSymbol.declaration).toBe(outerSymbol.declaration);\n            expect(innerSymbol.implementation).toBe(outerSymbol.implementation);"
        },
        {
            "sha": "fa339eefceab005c2f386b2d0b30ef6ab8c42104",
            "filename": "packages/compiler-cli/src/ngtsc/testing/src/utils.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 17,
            "changes": 46,
            "blob_url": "https://github.com/angular/angular/blob/6650d71fe2a958d277e7a7f409251fe648236a76/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftesting%2Fsrc%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/6650d71fe2a958d277e7a7f409251fe648236a76/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftesting%2Fsrc%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftesting%2Fsrc%2Futils.ts?ref=6650d71fe2a958d277e7a7f409251fe648236a76",
            "patch": "@@ -50,52 +50,64 @@ export function makeProgram(\n   return {program, host: compilerHost, options: compilerOptions};\n }\n \n+/**\n+ * Search the file specified by `fileName` in the given `program` for a declaration that has the\n+ * name `name` and passes the `predicate` function.\n+ *\n+ * An error will be thrown if there is not at least one AST node with the given `name` and passes\n+ * the `predicate` test.\n+ */\n export function getDeclaration<T extends ts.Declaration>(\n     program: ts.Program, fileName: AbsoluteFsPath, name: string,\n     assert: (value: any) => value is T): T {\n   const sf = getSourceFileOrError(program, fileName);\n-  const chosenDecl = walkForDeclaration(name, sf);\n+  const chosenDecls = walkForDeclarations(name, sf);\n \n-  if (chosenDecl === null) {\n+  if (chosenDecls.length === 0) {\n     throw new Error(`No such symbol: ${name} in ${fileName}`);\n   }\n-  if (!assert(chosenDecl)) {\n-    throw new Error(`Symbol ${name} from ${fileName} is a ${\n-        ts.SyntaxKind[chosenDecl.kind]}. Expected it to pass predicate \"${assert.name}()\".`);\n+  const chosenDecl = chosenDecls.find(assert);\n+  if (chosenDecl === undefined) {\n+    throw new Error(`Symbols with name ${name} in ${fileName} have types: ${\n+        chosenDecls.map(decl => ts.SyntaxKind[decl.kind])}. Expected one to pass predicate \"${\n+        assert.name}()\".`);\n   }\n   return chosenDecl;\n }\n \n-// We walk the AST tree looking for a declaration that matches\n-export function walkForDeclaration(name: string, rootNode: ts.Node): ts.Declaration|null {\n-  let chosenDecl: ts.Declaration|null = null;\n+/**\n+ * Walk the AST tree from the `rootNode` looking for a declaration that has the given `name`.\n+ */\n+export function walkForDeclarations(name: string, rootNode: ts.Node): ts.Declaration[] {\n+  const chosenDecls: ts.Declaration[] = [];\n   rootNode.forEachChild(node => {\n-    if (chosenDecl !== null) {\n-      return;\n-    }\n     if (ts.isVariableStatement(node)) {\n       node.declarationList.declarations.forEach(decl => {\n         if (bindingNameEquals(decl.name, name)) {\n-          chosenDecl = decl;\n+          chosenDecls.push(decl);\n+          if (decl.initializer) {\n+            chosenDecls.push(...walkForDeclarations(name, decl.initializer));\n+          }\n         } else {\n-          chosenDecl = walkForDeclaration(name, node);\n+          chosenDecls.push(...walkForDeclarations(name, node));\n         }\n       });\n     } else if (\n         ts.isClassDeclaration(node) || ts.isFunctionDeclaration(node) ||\n         ts.isInterfaceDeclaration(node) || ts.isClassExpression(node)) {\n       if (node.name !== undefined && node.name.text === name) {\n-        chosenDecl = node;\n+        chosenDecls.push(node);\n       }\n+      chosenDecls.push(...walkForDeclarations(name, node));\n     } else if (\n         ts.isImportDeclaration(node) && node.importClause !== undefined &&\n         node.importClause.name !== undefined && node.importClause.name.text === name) {\n-      chosenDecl = node.importClause;\n+      chosenDecls.push(node.importClause);\n     } else {\n-      chosenDecl = walkForDeclaration(name, node);\n+      chosenDecls.push(...walkForDeclarations(name, node));\n     }\n   });\n-  return chosenDecl;\n+  return chosenDecls;\n }\n \n const COMPLETE_REUSE_FAILURE_MESSAGE ="
        }
    ],
    "stats": {
        "total": 76,
        "additions": 44,
        "deletions": 32
    }
}