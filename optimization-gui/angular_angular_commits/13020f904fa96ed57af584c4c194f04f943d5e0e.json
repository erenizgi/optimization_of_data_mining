{
    "author": "atscott",
    "message": "fix(router): correctly deactivate children with componentless parent (#40196)\n\nDuring route activation, a componentless route will not have a context created\nfor it, but the logic continues to recurse so that children are still\nactivated. This can be seen here:\nhttps://github.com/angular/angular/blob/362f45c4bf1bb49a90b014d2053f4c4474d132c0/packages/router/src/operators/activate_routes.ts#L151-L158\n\nThe current deactivation logic does not currently account for componentless routes.\n\nThis commit adjusts the deactivation logic so that if a context cannot\nbe retrieved for a given route (because it is componentless), we\ncontinue to recurse and deactivate the children using the same\n`parentContexts` in the same way that activation does.\n\nFixes #20694\n\nPR Close #40196",
    "sha": "13020f904fa96ed57af584c4c194f04f943d5e0e",
    "files": [
        {
            "sha": "f62ec645a408b2347ddd18f28c1bda479fda2dd8",
            "filename": "packages/router/src/operators/activate_routes.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 12,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/13020f904fa96ed57af584c4c194f04f943d5e0e/packages%2Frouter%2Fsrc%2Foperators%2Factivate_routes.ts",
            "raw_url": "https://github.com/angular/angular/raw/13020f904fa96ed57af584c4c194f04f943d5e0e/packages%2Frouter%2Fsrc%2Foperators%2Factivate_routes.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Foperators%2Factivate_routes.ts?ref=13020f904fa96ed57af584c4c194f04f943d5e0e",
            "patch": "@@ -109,26 +109,27 @@ export class ActivateRoutes {\n   private deactivateRouteAndOutlet(\n       route: TreeNode<ActivatedRoute>, parentContexts: ChildrenOutletContexts): void {\n     const context = parentContexts.getContext(route.value.outlet);\n+    // The context could be `null` if we are on a componentless route but there may still be\n+    // children that need deactivating.\n+    const contexts = context && route.value.component ? context.children : parentContexts;\n+    const children: {[outletName: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(route);\n \n-    if (context) {\n-      const children: {[outletName: string]: any} = nodeChildrenAsMap(route);\n-      const contexts = route.value.component ? context.children : parentContexts;\n-\n-      forEach(children, (v: any, k: string) => this.deactivateRouteAndItsChildren(v, contexts));\n+    for (const child of Object.values(children)) {\n+      this.deactivateRouteAndItsChildren(child, contexts);\n+    }\n \n-      if (context.outlet) {\n-        // Destroy the component\n-        context.outlet.deactivate();\n-        // Destroy the contexts for all the outlets that were in the component\n-        context.children.onOutletDeactivated();\n-      }\n+    if (context && context.outlet) {\n+      // Destroy the component\n+      context.outlet.deactivate();\n+      // Destroy the contexts for all the outlets that were in the component\n+      context.children.onOutletDeactivated();\n     }\n   }\n \n   private activateChildRoutes(\n       futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>|null,\n       contexts: ChildrenOutletContexts): void {\n-    const children: {[outlet: string]: any} = nodeChildrenAsMap(currNode);\n+    const children: {[outlet: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(currNode);\n     futureNode.children.forEach(c => {\n       this.activateRoutes(c, children[c.value.outlet], contexts);\n       this.forwardEvent(new ActivationEnd(c.value.snapshot));"
        },
        {
            "sha": "23041f1cf005735680daf875cc4f9b4da24d273b",
            "filename": "packages/router/test/integration.spec.ts",
            "status": "modified",
            "additions": 107,
            "deletions": 8,
            "changes": 115,
            "blob_url": "https://github.com/angular/angular/blob/13020f904fa96ed57af584c4c194f04f943d5e0e/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/13020f904fa96ed57af584c4c194f04f943d5e0e/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fintegration.spec.ts?ref=13020f904fa96ed57af584c4c194f04f943d5e0e",
            "patch": "@@ -390,7 +390,7 @@ describe('Integration', () => {\n       });\n     });\n \n-    describe('should advance the parent route after deactivating its children', () => {\n+    describe('route activation', () => {\n       @Component({template: '<router-outlet></router-outlet>'})\n       class Parent {\n         constructor(route: ActivatedRoute) {\n@@ -400,8 +400,24 @@ describe('Integration', () => {\n         }\n       }\n \n+      @Component({\n+        template: `\n+        <router-outlet (deactivate)=\"logDeactivate('primary')\"></router-outlet>\n+        <router-outlet name=\"first\" (deactivate)=\"logDeactivate('first')\"></router-outlet>\n+        <router-outlet name=\"second\" (deactivate)=\"logDeactivate('second')\"></router-outlet>\n+        `\n+      })\n+      class NamedOutletHost {\n+        logDeactivate(route: string) {\n+          log.push(route + ' deactivate');\n+        }\n+      }\n+\n       @Component({template: 'child1'})\n       class Child1 {\n+        constructor() {\n+          log.push('child1 constructor');\n+        }\n         ngOnDestroy() {\n           log.push('child1 destroy');\n         }\n@@ -412,20 +428,33 @@ describe('Integration', () => {\n         constructor() {\n           log.push('child2 constructor');\n         }\n+        ngOnDestroy() {\n+          log.push('child2 destroy');\n+        }\n+      }\n+\n+      @Component({template: 'child3'})\n+      class Child3 {\n+        constructor() {\n+          log.push('child3 constructor');\n+        }\n+        ngOnDestroy() {\n+          log.push('child3 destroy');\n+        }\n       }\n \n       @NgModule({\n-        declarations: [Parent, Child1, Child2],\n-        entryComponents: [Parent, Child1, Child2],\n+        declarations: [Parent, NamedOutletHost, Child1, Child2, Child3],\n+        entryComponents: [Parent, NamedOutletHost, Child1, Child2, Child3],\n         imports: [RouterModule]\n       })\n       class TestModule {\n       }\n \n-      beforeEach(() => TestBed.configureTestingModule({imports: [TestModule]}));\n-\n-      it('should work',\n-         fakeAsync(inject([Router, Location], (router: Router, location: Location) => {\n+      it('should advance the parent route after deactivating its children', fakeAsync(() => {\n+           TestBed.configureTestingModule({imports: [TestModule]});\n+           const router = TestBed.inject(Router);\n+           const location = TestBed.inject(Location);\n            const fixture = createRoot(router, RootCmp);\n \n            router.resetConfig([{\n@@ -446,11 +475,81 @@ describe('Integration', () => {\n            expect(location.path()).toEqual('/parent/2/child2');\n            expect(log).toEqual([\n              {id: '1'},\n+             'child1 constructor',\n              'child1 destroy',\n              {id: '2'},\n              'child2 constructor',\n            ]);\n-         })));\n+         }));\n+\n+      it('should deactivate outlet children with componentless parent', fakeAsync(() => {\n+           TestBed.configureTestingModule({imports: [TestModule]});\n+           const router = TestBed.inject(Router);\n+           const fixture = createRoot(router, RootCmp);\n+\n+           router.resetConfig([\n+             {\n+               path: 'named-outlets',\n+               component: NamedOutletHost,\n+               children: [\n+                 {\n+                   path: 'home',\n+                   children: [\n+                     {path: '', component: Child1, outlet: 'first'},\n+                     {path: '', component: Child2, outlet: 'second'},\n+                     {path: 'primary', component: Child3},\n+                   ]\n+                 },\n+                 {\n+                   path: 'about',\n+                   children: [\n+                     {path: '', component: Child1, outlet: 'first'},\n+                     {path: '', component: Child2, outlet: 'second'},\n+                   ]\n+                 },\n+\n+               ]\n+             },\n+             {\n+               path: 'other',\n+               component: Parent,\n+             },\n+           ]);\n+\n+           router.navigateByUrl('/named-outlets/home/primary');\n+           advance(fixture);\n+           expect(log).toEqual([\n+             'child3 constructor',  // primary outlet always first\n+             'child1 constructor',\n+             'child2 constructor',\n+           ]);\n+           log.length = 0;\n+\n+           router.navigateByUrl('/named-outlets/about');\n+           advance(fixture);\n+           expect(log).toEqual([\n+             'child3 destroy',\n+             'primary deactivate',\n+             'child1 destroy',\n+             'first deactivate',\n+             'child2 destroy',\n+             'second deactivate',\n+             'child1 constructor',\n+             'child2 constructor',\n+           ]);\n+           log.length = 0;\n+\n+           router.navigateByUrl('/other');\n+           advance(fixture);\n+           expect(log).toEqual([\n+             'child1 destroy',\n+             'first deactivate',\n+             'child2 destroy',\n+             'second deactivate',\n+             // route param subscription from 'Parent' component\n+             {},\n+           ]);\n+         }));\n     });\n \n     it('should not wait for prior navigations to start a new navigation',"
        }
    ],
    "stats": {
        "total": 140,
        "additions": 120,
        "deletions": 20
    }
}