{
    "author": "crisbeto",
    "message": "feat(core): add migration to opt out existing apps from new test module teardown behavior (#43353)\n\nSince the `destroyAfterEach` teardown behavior is enabled by default now, existing tests that depended on the old behavior can start to fail. These changes add an automated migration that explicitly adds `destroyAfterEach: false` to existing tests.\n\nThe migration works by looking for `initTestEnvironment` calls across the entire app and adding the flag to them. If no calls were found, the migration will add the flag to all `configureTestingModule` and `withModule` calls instead.\n\nPR Close #43353",
    "sha": "81c7eb813c27f08d2d640f34e165a1b5e487bac2",
    "files": [
        {
            "sha": "d7611840e0feb0d7b92697c0aeb6227155e841fb",
            "filename": "packages/core/schematics/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2FBUILD.bazel?ref=81c7eb813c27f08d2d640f34e165a1b5e487bac2",
            "patch": "@@ -30,6 +30,7 @@ pkg_npm(\n         \"//packages/core/schematics/migrations/router-preserve-query-params\",\n         \"//packages/core/schematics/migrations/static-queries\",\n         \"//packages/core/schematics/migrations/template-var-assignment\",\n+        \"//packages/core/schematics/migrations/testbed-teardown\",\n         \"//packages/core/schematics/migrations/undecorated-classes-with-decorated-fields\",\n         \"//packages/core/schematics/migrations/undecorated-classes-with-di\",\n         \"//packages/core/schematics/migrations/wait-for-async\","
        },
        {
            "sha": "5c85a231027e70e5e7698b17eb03ee306ed838df",
            "filename": "packages/core/schematics/migrations.json",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Fmigrations.json",
            "raw_url": "https://github.com/angular/angular/raw/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Fmigrations.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations.json?ref=81c7eb813c27f08d2d640f34e165a1b5e487bac2",
            "patch": "@@ -104,6 +104,11 @@\n       \"version\": \"13.0.0-beta\",\n       \"description\": \"Migrates `[routerLink]=\\\"\\\"` in templates to `[routerLink]=\\\"[]\\\"` because these links are likely intended to route to the current page with updated fragment/query params.\",\n       \"factory\": \"./migrations/router-link-empty-expression/index\"\n+    },\n+    \"migration-v13-testbed-teardown\": {\n+      \"version\": \"13.0.0-beta\",\n+      \"description\": \"In Angular version 13, the `teardown` flag in `TestBed` will be enabled by default. This migration automatically opts out existing apps from the new teardown behavior.\",\n+      \"factory\": \"./migrations/testbed-teardown/index\"\n     }\n   }\n-}\n\\ No newline at end of file\n+}"
        },
        {
            "sha": "3a71b955b488b541b0c85018b94ba698172f3798",
            "filename": "packages/core/schematics/migrations/google3/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FBUILD.bazel?ref=81c7eb813c27f08d2d640f34e165a1b5e487bac2",
            "patch": "@@ -24,6 +24,7 @@ ts_library(\n         \"//packages/core/schematics/migrations/renderer-to-renderer2\",\n         \"//packages/core/schematics/migrations/static-queries\",\n         \"//packages/core/schematics/migrations/template-var-assignment\",\n+        \"//packages/core/schematics/migrations/testbed-teardown\",\n         \"//packages/core/schematics/migrations/undecorated-classes-with-decorated-fields\",\n         \"//packages/core/schematics/migrations/undecorated-classes-with-decorated-fields/google3\",\n         \"//packages/core/schematics/migrations/wait-for-async\","
        },
        {
            "sha": "b30da384d84a248b1b1401643ba9158569880372",
            "filename": "packages/core/schematics/migrations/google3/testbedTeardownRule.ts",
            "status": "added",
            "additions": 72,
            "deletions": 0,
            "changes": 72,
            "blob_url": "https://github.com/angular/angular/blob/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FtestbedTeardownRule.ts",
            "raw_url": "https://github.com/angular/angular/raw/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FtestbedTeardownRule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FtestbedTeardownRule.ts?ref=81c7eb813c27f08d2d640f34e165a1b5e487bac2",
            "patch": "@@ -0,0 +1,72 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {Replacement, RuleFailure, Rules} from 'tslint';\n+import ts from 'typescript';\n+import {findInitTestEnvironmentCalls, findTestModuleMetadataNodes, InitTestEnvironmentAnalysis, migrateInitTestEnvironment, migrateTestModuleMetadataLiteral} from '../testbed-teardown/util';\n+\n+/** TSLint rule that adds the `teardown` flag to `TestBed` calls. */\n+export class Rule extends Rules.TypedRule {\n+  private _analysis = new Map<ts.Program, InitTestEnvironmentAnalysis>();\n+\n+  override applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): RuleFailure[] {\n+    const typeChecker = program.getTypeChecker();\n+    const printer = ts.createPrinter();\n+    let initTestEnvironmentResult = this._analysis.get(program);\n+\n+    // The analysis for `initTestEnvironment` calls only needs to run once per program.\n+    if (!initTestEnvironmentResult) {\n+      const sourceFiles = program.getSourceFiles().filter(\n+          s => !s.isDeclarationFile && !program.isSourceFileFromExternalLibrary(s));\n+      initTestEnvironmentResult = findInitTestEnvironmentCalls(typeChecker, sourceFiles);\n+      this._analysis.set(program, initTestEnvironmentResult);\n+    }\n+\n+    return this._migrateFile(typeChecker, printer, sourceFile, initTestEnvironmentResult);\n+  }\n+\n+  private _migrateFile(\n+      typeChecker: ts.TypeChecker, printer: ts.Printer, sourceFile: ts.SourceFile,\n+      initTestEnvironmentResult: InitTestEnvironmentAnalysis): RuleFailure[] {\n+    const failures: RuleFailure[] = [];\n+\n+    // If we identified at least one call to `initTestEnvironment` (can be migrated or unmigrated),\n+    // we don't need to migrate `configureTestingModule` or `withModule` calls, because they'll take\n+    // the default teardown behavior from the environment. This is preferrable, because it'll result\n+    // in the least number of changes to users' code.\n+    if (initTestEnvironmentResult.totalCalls > 0) {\n+      // Migrate all of the unmigrated calls `initTestEnvironment` in this file. This could be zero\n+      // if the user has already opted into the new teardown behavior themselves.\n+      initTestEnvironmentResult.callsToMigrate.forEach(call => {\n+        // This analysis is global so we need to check that the call is within this file.\n+        if (call.getSourceFile() === sourceFile) {\n+          failures.push(this._getFailure(call, migrateInitTestEnvironment, printer));\n+        }\n+      });\n+    } else {\n+      // Otherwise migrate the metadata passed into the `configureTestingModule` and `withModule`\n+      // calls. This scenario is less likely, but it could happen if `initTestEnvironment` has been\n+      // abstracted away or is inside a .js file.\n+      findTestModuleMetadataNodes(typeChecker, sourceFile).forEach(literal => {\n+        failures.push(this._getFailure(literal, migrateTestModuleMetadataLiteral, printer));\n+      });\n+    }\n+\n+    return failures;\n+  }\n+\n+  private _getFailure<T extends ts.Node>(node: T, migrator: (node: T) => T, printer: ts.Printer) {\n+    const sourceFile = node.getSourceFile();\n+    const migrated = migrator(node);\n+    const replacementText = printer.printNode(ts.EmitHint.Unspecified, migrated, sourceFile);\n+\n+    return new RuleFailure(\n+        sourceFile, node.getStart(), node.getEnd(), 'Teardown behavior has to be configured.',\n+        this.ruleName, new Replacement(node.getStart(), node.getWidth(), replacementText));\n+  }\n+}"
        },
        {
            "sha": "4b1dde93eca3b519020f116b68354d1c72f049d6",
            "filename": "packages/core/schematics/migrations/testbed-teardown/BUILD.bazel",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Fmigrations%2Ftestbed-teardown%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Fmigrations%2Ftestbed-teardown%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Ftestbed-teardown%2FBUILD.bazel?ref=81c7eb813c27f08d2d640f34e165a1b5e487bac2",
            "patch": "@@ -0,0 +1,18 @@\n+load(\"//tools:defaults.bzl\", \"ts_library\")\n+\n+ts_library(\n+    name = \"testbed-teardown\",\n+    srcs = glob([\"**/*.ts\"]),\n+    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n+    visibility = [\n+        \"//packages/core/schematics:__pkg__\",\n+        \"//packages/core/schematics/migrations/google3:__pkg__\",\n+        \"//packages/core/schematics/test:__pkg__\",\n+    ],\n+    deps = [\n+        \"//packages/core/schematics/utils\",\n+        \"@npm//@angular-devkit/schematics\",\n+        \"@npm//@types/node\",\n+        \"@npm//typescript\",\n+    ],\n+)"
        },
        {
            "sha": "e4742e9acdab1f6cdc7e49cbaf63dceaa716d3c9",
            "filename": "packages/core/schematics/migrations/testbed-teardown/README.md",
            "status": "added",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/angular/angular/blob/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Fmigrations%2Ftestbed-teardown%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Fmigrations%2Ftestbed-teardown%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Ftestbed-teardown%2FREADME.md?ref=81c7eb813c27f08d2d640f34e165a1b5e487bac2",
            "patch": "@@ -0,0 +1,32 @@\n+## TestBed teardown behavior migration\n+\n+In Angular version 13, the `teardown` flag in `TestBed` will be enabled by default. This migration\n+automatically opts out existing apps from the new teardown behavior. It works by looking through\n+the entire project for `initTestEnvironment` calls and adding the `teardown` flag to them.\n+\n+If no `initTestEnvironment` calls were found, the migration will add the `teardown` flag to all\n+`configureTestingModule` and `withModule` calls instead.\n+\n+#### Before\n+```ts\n+import { getTestBed } from '@angular/core/testing';\n+import {\n+  BrowserDynamicTestingModule,\n+  platformBrowserDynamicTesting\n+} from '@angular/platform-browser-dynamic/testing';\n+\n+getTestBed().initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());\n+```\n+\n+#### After\n+```ts\n+import { getTestBed } from '@angular/core/testing';\n+import {\n+  BrowserDynamicTestingModule,\n+  platformBrowserDynamicTesting\n+} from '@angular/platform-browser-dynamic/testing';\n+\n+getTestBed().initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+  teardown: { destroyAfterEach: false }\n+});\n+```"
        },
        {
            "sha": "898ae1613ac5cb31f48517d25a0a32fa16266e85",
            "filename": "packages/core/schematics/migrations/testbed-teardown/index.ts",
            "status": "added",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/angular/angular/blob/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Fmigrations%2Ftestbed-teardown%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Fmigrations%2Ftestbed-teardown%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Ftestbed-teardown%2Findex.ts?ref=81c7eb813c27f08d2d640f34e165a1b5e487bac2",
            "patch": "@@ -0,0 +1,75 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\n+import {relative} from 'path';\n+import ts from 'typescript';\n+\n+import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n+import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n+import {findInitTestEnvironmentCalls, findTestModuleMetadataNodes, migrateInitTestEnvironment, migrateTestModuleMetadataLiteral} from './util';\n+\n+\n+/** Migration that adds the `teardown` flag to `TestBed` calls. */\n+export default function(): Rule {\n+  return async (tree: Tree) => {\n+    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n+    const basePath = process.cwd();\n+    const allPaths = [...buildPaths, ...testPaths];\n+\n+    if (!allPaths.length) {\n+      throw new SchematicsException(\n+          'Could not find any tsconfig file. Cannot add `teardown` flag to `TestBed`.');\n+    }\n+\n+    for (const tsconfigPath of allPaths) {\n+      runTestbedTeardownMigration(tree, tsconfigPath, basePath);\n+    }\n+  };\n+}\n+\n+function runTestbedTeardownMigration(tree: Tree, tsconfigPath: string, basePath: string) {\n+  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n+  const typeChecker = program.getTypeChecker();\n+  const sourceFiles =\n+      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n+  const initTestEnvironmentResult = findInitTestEnvironmentCalls(typeChecker, sourceFiles);\n+  const printer = ts.createPrinter();\n+\n+  // If we identified at least one call to `initTestEnvironment` (can be migrated or unmigrated),\n+  // we don't need to migrate `configureTestingModule` or `withModule` calls, because they'll take\n+  // the default teardown behavior from the environment. This is preferrable, because it'll result\n+  // in the least number of changes to users' code.\n+  if (initTestEnvironmentResult.totalCalls > 0) {\n+    // Migrate all of the unmigrated calls `initTestEnvironment`. This could be zero\n+    // if the user has already opted into the new teardown behavior themselves.\n+    initTestEnvironmentResult.callsToMigrate.forEach(call => {\n+      migrate(call, migrateInitTestEnvironment, tree, basePath, printer);\n+    });\n+  } else {\n+    // Otherwise migrate the metadata passed into the `configureTestingModule` and `withModule`\n+    // calls. This scenario is less likely, but it could happen if `initTestEnvironment` has been\n+    // abstracted away or is inside a .js file.\n+    sourceFiles.forEach(sourceFile => {\n+      findTestModuleMetadataNodes(typeChecker, sourceFile).forEach(literal => {\n+        migrate(literal, migrateTestModuleMetadataLiteral, tree, basePath, printer);\n+      });\n+    });\n+  }\n+}\n+\n+\n+function migrate<T extends ts.Node>(\n+    node: T, migrator: (node: T) => T, tree: Tree, basePath: string, printer: ts.Printer) {\n+  const migrated = migrator(node);\n+  const update = tree.beginUpdate(relative(basePath, node.getSourceFile().fileName));\n+  update.remove(node.getStart(), node.getWidth());\n+  update.insertRight(\n+      node.getStart(), printer.printNode(ts.EmitHint.Unspecified, migrated, node.getSourceFile()));\n+  tree.commitUpdate(update);\n+}"
        },
        {
            "sha": "3a062afcb98ff61eaf50d3decfba489aa778bb55",
            "filename": "packages/core/schematics/migrations/testbed-teardown/util.ts",
            "status": "added",
            "additions": 193,
            "deletions": 0,
            "changes": 193,
            "blob_url": "https://github.com/angular/angular/blob/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Fmigrations%2Ftestbed-teardown%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Fmigrations%2Ftestbed-teardown%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Ftestbed-teardown%2Futil.ts?ref=81c7eb813c27f08d2d640f34e165a1b5e487bac2",
            "patch": "@@ -0,0 +1,193 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import ts from 'typescript';\n+\n+import {getImportSpecifier} from '../../utils/typescript/imports';\n+import {isReferenceToImport} from '../../utils/typescript/symbol';\n+\n+/** Result of a full-program analysis looking for `initTestEnvironment` calls. */\n+export interface InitTestEnvironmentAnalysis {\n+  /** Total number of calls that were found. */\n+  totalCalls: number;\n+  /** Calls that need to be migrated. */\n+  callsToMigrate: ts.CallExpression[];\n+}\n+\n+/** Finds the `initTestEnvironment` calls that need to be migrated. */\n+export function findInitTestEnvironmentCalls(\n+    typeChecker: ts.TypeChecker, allSourceFiles: ts.SourceFile[]): InitTestEnvironmentAnalysis {\n+  const callsToMigrate = new Set<ts.CallExpression>();\n+  let totalCalls = 0;\n+\n+  allSourceFiles.forEach(sourceFile => {\n+    sourceFile.forEachChild(function walk(node: ts.Node) {\n+      if (ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression) &&\n+          ts.isIdentifier(node.expression.name) &&\n+          node.expression.name.text === 'initTestEnvironment' &&\n+          isTestBedAccess(typeChecker, node.expression)) {\n+        totalCalls++;\n+        if (shouldMigrateInitTestEnvironment(node)) {\n+          callsToMigrate.add(node);\n+        }\n+      }\n+\n+      node.forEachChild(walk);\n+    });\n+  });\n+\n+  return {\n+    // Sort the nodes so that they will be migrated in reverse source order (nodes at the end of\n+    // the file are migrated first). This avoids issues where a migrated node will offset the\n+    // bounds of all nodes that come after it. Note that the nodes here are from all of the\n+    // passed in source files, but that doesn't matter since the later nodes will still appear\n+    // after the earlier ones.\n+    callsToMigrate: sortInReverseSourceOrder(Array.from(callsToMigrate)),\n+    totalCalls\n+  };\n+}\n+\n+/** Finds the `configureTestingModule` and `withModule` calls that need to be migrated. */\n+export function findTestModuleMetadataNodes(\n+    typeChecker: ts.TypeChecker, sourceFile: ts.SourceFile) {\n+  const testModuleMetadataLiterals = new Set<ts.ObjectLiteralExpression>();\n+  const withModuleImport = getImportSpecifier(sourceFile, '@angular/core/testing', 'withModule');\n+\n+  sourceFile.forEachChild(function walk(node: ts.Node) {\n+    if (ts.isCallExpression(node)) {\n+      const isConfigureTestingModuleCall = ts.isPropertyAccessExpression(node.expression) &&\n+          ts.isIdentifier(node.expression.name) &&\n+          node.expression.name.text === 'configureTestingModule' &&\n+          isTestBedAccess(typeChecker, node.expression) && shouldMigrateModuleConfigCall(node);\n+      const isWithModuleCall = withModuleImport && ts.isIdentifier(node.expression) &&\n+          isReferenceToImport(typeChecker, node.expression, withModuleImport) &&\n+          shouldMigrateModuleConfigCall(node);\n+\n+      if (isConfigureTestingModuleCall || isWithModuleCall) {\n+        testModuleMetadataLiterals.add(node.arguments[0] as ts.ObjectLiteralExpression);\n+      }\n+    }\n+\n+    node.forEachChild(walk);\n+  });\n+\n+  // Sort the nodes so that they will be migrated in reverse source order (nodes at the end of\n+  // the file are migrated first). This avoids issues where a migrated node will offset the\n+  // bounds of all nodes that come after it.\n+  return sortInReverseSourceOrder(Array.from(testModuleMetadataLiterals));\n+}\n+\n+/** Migrates a call to `TestBed.initTestEnvironment`. */\n+export function migrateInitTestEnvironment(node: ts.CallExpression): ts.CallExpression {\n+  const literalProperties: ts.ObjectLiteralElementLike[] = [];\n+\n+  if (node.arguments.length > 2) {\n+    if (isFunction(node.arguments[2])) {\n+      // If the last argument is a function, add the function as the `aotSummaries` property.\n+      literalProperties.push(ts.createPropertyAssignment('aotSummaries', node.arguments[2]));\n+    } else if (ts.isObjectLiteralExpression(node.arguments[2])) {\n+      // If the property is an object literal, copy over all the properties.\n+      literalProperties.push(...node.arguments[2].properties);\n+    }\n+  }\n+\n+  // Finally push the teardown object so that it appears last.\n+  literalProperties.push(createTeardownAssignment());\n+\n+  return ts.createCall(\n+      node.expression, node.typeArguments,\n+      [...node.arguments.slice(0, 2), ts.createObjectLiteral(literalProperties, true)]);\n+}\n+\n+/** Migrates an object literal that is passed into `configureTestingModule` or `withModule`. */\n+export function migrateTestModuleMetadataLiteral(node: ts.ObjectLiteralExpression):\n+    ts.ObjectLiteralExpression {\n+  return ts.createObjectLiteral(\n+      [...node.properties, createTeardownAssignment()], node.properties.length > 0);\n+}\n+\n+/** Returns whether a property access points to `TestBed`. */\n+function isTestBedAccess(typeChecker: ts.TypeChecker, node: ts.PropertyAccessExpression): boolean {\n+  const symbolName = typeChecker.getTypeAtLocation(node.expression)?.getSymbol()?.getName();\n+  return symbolName === 'TestBed' || symbolName === 'TestBedStatic';\n+}\n+\n+/** Whether a call to `initTestEnvironment` should be migrated. */\n+function shouldMigrateInitTestEnvironment(node: ts.CallExpression): boolean {\n+  // If there is no third argument, we definitely have to migrate it.\n+  if (node.arguments.length === 2) {\n+    return true;\n+  }\n+\n+  // This is technically a type error so we shouldn't mess with it.\n+  if (node.arguments.length < 2) {\n+    return false;\n+  }\n+\n+  // Otherwise we need to figure out if the `teardown` flag is set on the last argument.\n+  const lastArg = node.arguments[2];\n+\n+  // Note: the checks below will identify something like `initTestEnvironment(..., ..., {})`,\n+  // but they'll ignore a variable being passed in as the last argument like `const config = {};\n+  // initTestEnvironment(..., ..., config)`. While we can resolve the variable to its declaration\n+  // using `typeChecker.getTypeAtLocation(lastArg).getSymbol()?.valueDeclaration`, we deliberately\n+  // don't, because it introduces some complexity and we may end up breaking user code. E.g.\n+  // the `config` from the example above may be passed in to other functions or the `teardown`\n+  // flag could be added later on by a function call.\n+\n+  // If the argument is an object literal and there are no\n+  // properties called `teardown`, we have to migrate it.\n+  if (isObjectLiteralWithoutTeardown(lastArg)) {\n+    return true;\n+  }\n+\n+  // If the last argument is an `aotSummaries` function, we also have to migrate.\n+  if (isFunction(lastArg)) {\n+    return true;\n+  }\n+\n+  // Otherwise don't migrate if we couldn't identify the last argument.\n+  return false;\n+}\n+\n+/**\n+ * Whether a call to a module configuration function should be migrated. This covers\n+ * `TestBed.configureTestingModule` and `withModule` since they both accept `TestModuleMetadata`\n+ * as their first argument.\n+ */\n+function shouldMigrateModuleConfigCall(node: ts.CallExpression): node is ts.CallExpression&\n+    {arguments: [ts.ObjectLiteralExpression, ...ts.Expression[]]} {\n+  return node.arguments.length > 0 && isObjectLiteralWithoutTeardown(node.arguments[0]);\n+}\n+\n+/** Returns whether a node is a function literal. */\n+function isFunction(node: ts.Node): node is ts.ArrowFunction|ts.FunctionExpression|\n+    ts.FunctionDeclaration {\n+  return ts.isArrowFunction(node) || ts.isFunctionExpression(node) ||\n+      ts.isFunctionDeclaration(node);\n+}\n+\n+/** Checks whether a node is an object literal that doesn't contain a property called `teardown`. */\n+function isObjectLiteralWithoutTeardown(node: ts.Node): node is ts.ObjectLiteralExpression {\n+  return ts.isObjectLiteralExpression(node) && !node.properties.find(prop => {\n+    return prop.name?.getText() === 'teardown';\n+  });\n+}\n+\n+/** Creates a teardown configuration property assignment. */\n+function createTeardownAssignment(): ts.PropertyAssignment {\n+  // `teardown: {destroyAfterEach: false}`\n+  return ts.createPropertyAssignment(\n+      'teardown',\n+      ts.createObjectLiteral([ts.createPropertyAssignment('destroyAfterEach', ts.createFalse())]));\n+}\n+\n+/** Sorts an array of AST nodes in reverse source order. */\n+function sortInReverseSourceOrder<T extends ts.Node>(nodes: T[]): T[] {\n+  return nodes.sort((a, b) => b.getEnd() - a.getEnd());\n+}"
        },
        {
            "sha": "ae590010ceff732fe19d28d41a3419f987f85b3c",
            "filename": "packages/core/schematics/test/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel?ref=81c7eb813c27f08d2d640f34e165a1b5e487bac2",
            "patch": "@@ -25,6 +25,7 @@ ts_library(\n         \"//packages/core/schematics/migrations/router-preserve-query-params\",\n         \"//packages/core/schematics/migrations/static-queries\",\n         \"//packages/core/schematics/migrations/template-var-assignment\",\n+        \"//packages/core/schematics/migrations/testbed-teardown\",\n         \"//packages/core/schematics/migrations/undecorated-classes-with-decorated-fields\",\n         \"//packages/core/schematics/migrations/undecorated-classes-with-di\",\n         \"//packages/core/schematics/migrations/wait-for-async\","
        },
        {
            "sha": "79d45f84b75ec6c41be1a67df4c24609301a871a",
            "filename": "packages/core/schematics/test/google3/testbed_teardown_spec.ts",
            "status": "added",
            "additions": 707,
            "deletions": 0,
            "changes": 707,
            "blob_url": "https://github.com/angular/angular/blob/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Ftestbed_teardown_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Ftestbed_teardown_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Ftestbed_teardown_spec.ts?ref=81c7eb813c27f08d2d640f34e165a1b5e487bac2",
            "patch": "@@ -0,0 +1,707 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {readFileSync, writeFileSync} from 'fs';\n+import {dirname, join} from 'path';\n+import * as shx from 'shelljs';\n+import {Configuration, Linter} from 'tslint';\n+\n+describe('Google3 TestBed teardown TSLint rule', () => {\n+  const rulesDirectory = dirname(require.resolve('../../migrations/google3/testbedTeardownRule'));\n+  let tmpDir: string;\n+\n+  beforeEach(() => {\n+    tmpDir = join(process.env['TEST_TMPDIR']!, 'google3-test');\n+    shx.mkdir('-p', tmpDir);\n+\n+    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n+    // Note that the declarations here are a little more convoluted than they need to be. It's\n+    // because they've been copied over directly from `node_modules/@angular/core/testing.d.ts`,\n+    // except for removing some methods that are irrelevant to these tests.\n+    writeFile('testing.d.ts', `\n+      export declare const getTestBed: () => TestBed;\n+\n+      export declare interface TestBed {\n+        initTestEnvironment(ngModule: any, platform: any, options?: any): void;\n+        configureTestingModule(moduleDef: any): void;\n+      }\n+\n+      export declare const TestBed: TestBedStatic;\n+\n+      export declare interface TestBedStatic {\n+        new (...args: any[]): TestBed;\n+        initTestEnvironment(ngModule: any, platform: any, options?: any): TestBed;\n+        configureTestingModule(moduleDef: any): TestBedStatic;\n+      }\n+\n+      export declare function withModule(moduleDef: any, fn: Function): () => any;\n+    `);\n+\n+    writeFile('tsconfig.json', JSON.stringify({\n+      compilerOptions: {\n+        module: 'es2015',\n+        baseUrl: './',\n+        paths: {\n+          '@angular/core/testing': ['testing.d.ts'],\n+        }\n+      },\n+    }));\n+  });\n+\n+  afterEach(() => shx.rm('-r', tmpDir));\n+\n+  function runTSLint(fix: boolean) {\n+    const program = Linter.createProgram(join(tmpDir, 'tsconfig.json'));\n+    const linter = new Linter({fix, rulesDirectory: [rulesDirectory]}, program);\n+    const config = Configuration.parseConfigFile({rules: {'testbedTeardown': true}});\n+\n+    program.getRootFileNames().forEach(fileName => {\n+      linter.lint(fileName, program.getSourceFile(fileName)!.getFullText(), config);\n+    });\n+\n+    return linter;\n+  }\n+\n+  function writeFile(fileName: string, content: string) {\n+    writeFileSync(join(tmpDir, fileName), content);\n+  }\n+\n+  function getFile(fileName: string) {\n+    return readFileSync(join(tmpDir, fileName), 'utf8');\n+  }\n+\n+\n+  function stripWhitespace(contents: string) {\n+    return contents.replace(/\\s/g, '');\n+  }\n+\n+  it('should flag initTestEnvironment calls', () => {\n+    writeFile('/index.ts', `\n+      import { TestBed } from '@angular/core/testing';\n+      import {\n+        BrowserDynamicTestingModule,\n+        platformBrowserDynamicTesting\n+      } from '@angular/platform-browser-dynamic/testing';\n+\n+      TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());\n+    `);\n+\n+    const linter = runTSLint(false);\n+    const failures = linter.getResult().failures.map(failure => failure.getFailure());\n+    expect(failures.length).toBe(1);\n+    expect(failures[0]).toMatch(/Teardown behavior has to be configured\\./);\n+  });\n+\n+  it('should flag configureTestingModule and withModule calls', () => {\n+    writeFile('/index.ts', `\n+      import { Component } from '@angular/core';\n+      import { TestBed, withModule } from '@angular/core/testing';\n+\n+      @Component({template: ''})\n+      class Comp {}\n+\n+      it('should work', () => {\n+        TestBed.configureTestingModule({\n+          declarations: [Comp]\n+        });\n+\n+        const fixture = TestBed.createComponent(Comp);\n+        fixture.detectChanges();\n+      });\n+\n+      it('should also work', withModule({\n+        declarations: [Comp],\n+      }, () => {\n+        TestBed.createComponent(Comp);\n+      }));\n+    `);\n+\n+    const linter = runTSLint(false);\n+    const failures = linter.getResult().failures.map(failure => failure.getFailure());\n+    expect(failures.length).toBe(2);\n+    expect(failures[0]).toMatch(/Teardown behavior has to be configured\\./);\n+    expect(failures[1]).toMatch(/Teardown behavior has to be configured\\./);\n+  });\n+\n+  it('should migrate calls to initTestEnvironment', () => {\n+    writeFile('/index.ts', `\n+      import { TestBed } from '@angular/core/testing';\n+      import {\n+        BrowserDynamicTestingModule,\n+        platformBrowserDynamicTesting\n+      } from '@angular/platform-browser-dynamic/testing';\n+\n+      TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());\n+    `);\n+\n+    runTSLint(true);\n+\n+    expect(stripWhitespace(getFile('/index.ts'))).toContain(stripWhitespace(`\n+      TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+        teardown: { destroyAfterEach: false }\n+      });\n+    `));\n+  });\n+\n+  it('should migrate calls to initTestEnvironment going through getTestBed()', () => {\n+    writeFile('/index.ts', `\n+      import { getTestBed } from '@angular/core/testing';\n+      import {\n+        BrowserDynamicTestingModule,\n+        platformBrowserDynamicTesting\n+      } from '@angular/platform-browser-dynamic/testing';\n+\n+      getTestBed().initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());\n+    `);\n+\n+    runTSLint(true);\n+\n+    expect(stripWhitespace(getFile('/index.ts'))).toContain(stripWhitespace(`\n+      getTestBed().initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+        teardown: { destroyAfterEach: false }\n+      });\n+    `));\n+  });\n+\n+  it('should migrate calls to initTestEnvironment going through a variable', () => {\n+    writeFile('/index.ts', `\n+      import { getTestBed } from '@angular/core/testing';\n+      import {\n+        BrowserDynamicTestingModule,\n+        platformBrowserDynamicTesting\n+      } from '@angular/platform-browser-dynamic/testing';\n+\n+      const tb = getTestBed();\n+\n+      tb.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());\n+    `);\n+\n+    runTSLint(true);\n+\n+    expect(stripWhitespace(getFile('/index.ts'))).toContain(stripWhitespace(`\n+      tb.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+        teardown: { destroyAfterEach: false }\n+      });\n+    `));\n+  });\n+\n+  it('should migrate not calls to initTestEnvironment that already specify a teardown behavior',\n+     () => {\n+       writeFile('/index.ts', `\n+        import { TestBed } from '@angular/core/testing';\n+        import {\n+          BrowserDynamicTestingModule,\n+          platformBrowserDynamicTesting\n+        } from '@angular/platform-browser-dynamic/testing';\n+\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+          teardown: {destroyAfterEach: true}\n+        });\n+      `);\n+\n+       runTSLint(true);\n+\n+       expect(stripWhitespace(getFile('/index.ts'))).toContain(stripWhitespace(`\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+          teardown: {destroyAfterEach: true}\n+        });\n+      `));\n+     });\n+\n+  it('should migrate calls to initTestEnvironment that pass in aotSummaries as an arrow function',\n+     () => {\n+       writeFile('/index.ts', `\n+        import { TestBed } from '@angular/core/testing';\n+        import {\n+          BrowserDynamicTestingModule,\n+          platformBrowserDynamicTesting\n+        } from '@angular/platform-browser-dynamic/testing';\n+\n+        class Foo {}\n+\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), () => [Foo]);\n+      `);\n+\n+       runTSLint(true);\n+\n+       expect(stripWhitespace(getFile('/index.ts'))).toContain(stripWhitespace(`\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+          aotSummaries: () => [Foo],\n+          teardown: { destroyAfterEach: false }\n+        });\n+      `));\n+     });\n+\n+  it('should migrate calls to initTestEnvironment that pass in aotSummaries as an anonymous function',\n+     () => {\n+       writeFile('/index.ts', `\n+        import { TestBed } from '@angular/core/testing';\n+        import {\n+          BrowserDynamicTestingModule,\n+          platformBrowserDynamicTesting\n+        } from '@angular/platform-browser-dynamic/testing';\n+\n+        class Foo {}\n+\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), function() {\n+          return [Foo];\n+        });\n+      `);\n+\n+       runTSLint(true);\n+\n+       expect(stripWhitespace(getFile('/index.ts'))).toContain(stripWhitespace(`\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+          aotSummaries: function() {\n+            return [Foo];\n+          },\n+          teardown: { destroyAfterEach: false }\n+        });\n+      `));\n+     });\n+\n+  it('should migrate calls to initTestEnvironment that pass in aotSummaries via an object literal',\n+     () => {\n+       writeFile('/index.ts', `\n+        import { TestBed } from '@angular/core/testing';\n+        import {\n+          BrowserDynamicTestingModule,\n+          platformBrowserDynamicTesting\n+        } from '@angular/platform-browser-dynamic/testing';\n+\n+        class Foo {}\n+\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+          aotSummaries: () => [Foo]\n+        });\n+      `);\n+\n+       runTSLint(true);\n+\n+       expect(stripWhitespace(getFile('/index.ts'))).toContain(stripWhitespace(`\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+          aotSummaries: () => [Foo],\n+          teardown: { destroyAfterEach: false }\n+        });\n+      `));\n+     });\n+\n+\n+  it('should migrate initTestEnvironment calls across multiple files', () => {\n+    writeFile('/test-init.ts', `\n+      import { TestBed } from '@angular/core/testing';\n+      import {\n+        BrowserDynamicTestingModule,\n+        platformBrowserDynamicTesting\n+      } from '@angular/platform-browser-dynamic/testing';\n+\n+      TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());\n+    `);\n+\n+    writeFile('/other-test-init.ts', `\n+      import { getTestBed } from '@angular/core/testing';\n+      import {\n+        BrowserDynamicTestingModule,\n+        platformBrowserDynamicTesting\n+      } from '@angular/platform-browser-dynamic/testing';\n+\n+      getTestBed().initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());\n+    `);\n+\n+    runTSLint(true);\n+\n+    expect(stripWhitespace(getFile('/test-init.ts'))).toContain(stripWhitespace(`\n+      TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+        teardown: { destroyAfterEach: false }\n+      });\n+    `));\n+\n+    expect(stripWhitespace(getFile('/other-test-init.ts'))).toContain(stripWhitespace(`\n+      getTestBed().initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+        teardown: { destroyAfterEach: false }\n+      });\n+    `));\n+  });\n+\n+  it('should not migrate calls to initTestEnvironment that pass in a variable', () => {\n+    writeFile('/index.ts', `\n+      import { TestBed } from '@angular/core/testing';\n+      import {\n+        BrowserDynamicTestingModule,\n+        platformBrowserDynamicTesting\n+      } from '@angular/platform-browser-dynamic/testing';\n+\n+      const config = {aotSummaries: () => []};\n+\n+      TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), config);\n+    `);\n+\n+    runTSLint(true);\n+\n+    const content = stripWhitespace(getFile('/index.ts'));\n+    expect(content).toContain(stripWhitespace(`const config = {aotSummaries: () => []};`));\n+    expect(content).toContain(stripWhitespace(`\n+      TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), config);\n+    `));\n+  });\n+\n+  it('should not migrate invalid initTestEnvironment calls', () => {\n+    writeFile('/index.ts', `\n+      import { TestBed } from '@angular/core/testing';\n+\n+      TestBed.initTestEnvironment();\n+    `);\n+\n+    runTSLint(true);\n+\n+    expect(stripWhitespace(getFile('/index.ts')))\n+        .toContain(stripWhitespace(`TestBed.initTestEnvironment();`));\n+  });\n+\n+  it('should not migrate calls to initTestEnvironment not coming from Angular', () => {\n+    writeFile('/index.ts', `\n+      import { TestBed } from '@not-angular/core/testing';\n+      import {\n+        BrowserDynamicTestingModule,\n+        platformBrowserDynamicTesting\n+      } from '@angular/platform-browser-dynamic/testing';\n+\n+      TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());\n+    `);\n+\n+    runTSLint(true);\n+\n+    expect(stripWhitespace(getFile('/index.ts')))\n+        .toContain(stripWhitespace(\n+            `TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());`));\n+  });\n+\n+  it('should migrate calls to initTestEnvironment when TestBed is aliased', () => {\n+    writeFile('/index.ts', `\n+      import { TestBed as AliasOfTestBed } from '@angular/core/testing';\n+      import {\n+        BrowserDynamicTestingModule,\n+        platformBrowserDynamicTesting\n+      } from '@angular/platform-browser-dynamic/testing';\n+\n+      AliasOfTestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());\n+    `);\n+\n+    runTSLint(true);\n+\n+    expect(stripWhitespace(getFile('/index.ts'))).toContain(stripWhitespace(`\n+      AliasOfTestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+        teardown: { destroyAfterEach: false }\n+      });\n+    `));\n+  });\n+\n+  it('should migrate withModule calls', () => {\n+    writeFile('/index.spec.ts', `\n+      import { Component } from '@angular/core';\n+      import { withModule, TestBed } from '@angular/core/testing';\n+\n+      @Component({template: ''})\n+      class Comp {}\n+\n+      it('should work', withModule({\n+        declarations: [Comp],\n+      }, () => {\n+        TestBed.createComponent(Comp);\n+      }));\n+    `);\n+\n+    runTSLint(true);\n+\n+    expect(stripWhitespace(getFile('/index.spec.ts'))).toContain(stripWhitespace(`\n+      it('should work', withModule({\n+        declarations: [Comp],\n+        teardown: {destroyAfterEach: false}\n+      }, () => {\n+        TestBed.createComponent(Comp);\n+      }));\n+    `));\n+  });\n+\n+  it('should not migrate withModule calls that already pass in the teardown flag', () => {\n+    writeFile('/index.spec.ts', `\n+      import { Component } from '@angular/core';\n+      import { withModule, TestBed } from '@angular/core/testing';\n+\n+      @Component({template: ''})\n+      class Comp {}\n+\n+      it('should work', withModule({\n+        teardown: {destroyAfterEach: true},\n+        declarations: [Comp],\n+      }, () => {\n+        TestBed.createComponent(Comp);\n+      }));\n+    `);\n+\n+    runTSLint(true);\n+\n+    expect(stripWhitespace(getFile('/index.spec.ts'))).toContain(stripWhitespace(`\n+      it('should work', withModule({\n+        teardown: {destroyAfterEach: true},\n+        declarations: [Comp],\n+      }, () => {\n+        TestBed.createComponent(Comp);\n+      }));\n+    `));\n+  });\n+\n+  it('should not migrate withModule calls that do not come from Angular', () => {\n+    writeFile('/index.spec.ts', `\n+      import { Component } from '@angular/core';\n+      import { TestBed } from '@angular/core/testing';\n+\n+      function withModule(...args: any[]) {}\n+\n+      @Component({template: ''})\n+      class Comp {}\n+\n+      it('should work', withModule({\n+        declarations: [Comp],\n+      }, () => {\n+        TestBed.createComponent(Comp);\n+      }));\n+    `);\n+\n+    runTSLint(true);\n+\n+    expect(stripWhitespace(getFile('/index.spec.ts'))).toContain(stripWhitespace(`\n+      it('should work', withModule({\n+        declarations: [Comp],\n+      }, () => {\n+        TestBed.createComponent(Comp);\n+      }));\n+    `));\n+  });\n+\n+  it('should migrate aliased withModule calls', () => {\n+    writeFile('/index.spec.ts', `\n+      import { Component } from '@angular/core';\n+      import { withModule as aliasOfWithModule, TestBed } from '@angular/core/testing';\n+\n+      @Component({template: ''})\n+      class Comp {}\n+\n+      it('should work', aliasOfWithModule({\n+        declarations: [Comp],\n+      }, () => {\n+        TestBed.createComponent(Comp);\n+      }));\n+    `);\n+\n+    runTSLint(true);\n+\n+    expect(stripWhitespace(getFile('/index.spec.ts'))).toContain(stripWhitespace(`\n+      it('should work', aliasOfWithModule({\n+        declarations: [Comp],\n+        teardown: {destroyAfterEach: false}\n+      }, () => {\n+        TestBed.createComponent(Comp);\n+      }));\n+    `));\n+  });\n+\n+  it('should migrate configureTestingModule calls', () => {\n+    writeFile('/index.spec.ts', `\n+      import { Component } from '@angular/core';\n+      import { TestBed } from '@angular/core/testing';\n+\n+      @Component({template: ''})\n+      class Comp {}\n+\n+      it('should work', () => {\n+        TestBed.configureTestingModule({\n+          declarations: [Comp]\n+        });\n+\n+        const fixture = TestBed.createComponent(Comp);\n+        fixture.detectChanges();\n+      });\n+    `);\n+\n+    runTSLint(true);\n+\n+    expect(stripWhitespace(getFile('/index.spec.ts'))).toContain(stripWhitespace(`\n+      TestBed.configureTestingModule({\n+        declarations: [Comp],\n+        teardown: {destroyAfterEach: false}\n+      });\n+    `));\n+  });\n+\n+  it('should migrate multiple configureTestingModule calls within the same file', () => {\n+    writeFile('/index.spec.ts', `\n+      import { Component } from '@angular/core';\n+      import { TestBed } from '@angular/core/testing';\n+\n+      @Component({template: ''})\n+      class Comp {}\n+\n+      @Component({template: ''})\n+      class BetterComp {}\n+\n+      it('should work', () => {\n+        TestBed.configureTestingModule({\n+          declarations: [Comp]\n+        });\n+\n+        const fixture = TestBed.createComponent(Comp);\n+        fixture.detectChanges();\n+      });\n+\n+      it('should work better', () => {\n+        TestBed.configureTestingModule({\n+          declarations: [BetterComp]\n+        });\n+\n+        const fixture = TestBed.createComponent(BetterComp);\n+        fixture.detectChanges();\n+      });\n+    `);\n+\n+    runTSLint(true);\n+\n+    const content = stripWhitespace(getFile('/index.spec.ts'));\n+\n+    expect(content).toContain(stripWhitespace(`\n+      TestBed.configureTestingModule({\n+        declarations: [Comp],\n+        teardown: {destroyAfterEach: false}\n+      });\n+    `));\n+\n+    expect(content).toContain(stripWhitespace(`\n+      TestBed.configureTestingModule({\n+        declarations: [BetterComp],\n+        teardown: {destroyAfterEach: false}\n+      });\n+    `));\n+  });\n+\n+  it('should migrate configureTestingModule calls through getTestBed()', () => {\n+    writeFile('/index.spec.ts', `\n+      import { Component } from '@angular/core';\n+      import { getTestBed } from '@angular/core/testing';\n+\n+      @Component({template: ''})\n+      class Comp {}\n+\n+      it('should work', () => {\n+        getTestBed().configureTestingModule({\n+          declarations: [Comp]\n+        });\n+\n+        const fixture = getTestBed().createComponent(Comp);\n+        fixture.detectChanges();\n+      });\n+    `);\n+\n+    runTSLint(true);\n+\n+    expect(stripWhitespace(getFile('/index.spec.ts'))).toContain(stripWhitespace(`\n+      getTestBed().configureTestingModule({\n+        declarations: [Comp],\n+        teardown: {destroyAfterEach: false}\n+      });\n+    `));\n+  });\n+\n+  it('should not migrate configureTestingModule calls that already pass in the teardown flag',\n+     () => {\n+       writeFile('/index.spec.ts', `\n+        import { Component } from '@angular/core';\n+        import { TestBed } from '@angular/core/testing';\n+\n+        @Component({template: ''})\n+        class Comp {}\n+\n+        it('should work', () => {\n+          TestBed.configureTestingModule({\n+            teardown: {destroyAfterEach: true},\n+            declarations: [Comp]\n+          });\n+\n+          const fixture = TestBed.createComponent(Comp);\n+          fixture.detectChanges();\n+        });\n+      `);\n+\n+       runTSLint(true);\n+\n+       expect(stripWhitespace(getFile('/index.spec.ts'))).toContain(stripWhitespace(`\n+        TestBed.configureTestingModule({\n+          teardown: {destroyAfterEach: true},\n+          declarations: [Comp]\n+        });\n+      `));\n+     });\n+\n+\n+  it('should not migrate configureTestingModule or withModule calls if initTestEnvironment was migrated in another file',\n+     () => {\n+       writeFile('/test-init.ts', `\n+        import { TestBed, withModule } from '@angular/core/testing';\n+        import {\n+          BrowserDynamicTestingModule,\n+          platformBrowserDynamicTesting\n+        } from '@angular/platform-browser-dynamic/testing';\n+\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());\n+      `);\n+\n+       writeFile('/comp.spec.ts', `\n+        import { Component } from '@angular/core';\n+        import { TestBed } from '@angular/core/testing';\n+\n+        @Component({template: ''})\n+        class Comp {}\n+\n+        it('should work', () => {\n+          TestBed.configureTestingModule({\n+            declarations: [Comp]\n+          });\n+\n+          const fixture = TestBed.createComponent(Comp);\n+          fixture.detectChanges();\n+        });\n+\n+        it('should also work', withModule({\n+          declarations: [Comp],\n+        }, () => {\n+          TestBed.createComponent(Comp);\n+        }));\n+      `);\n+\n+       runTSLint(true);\n+\n+       expect(stripWhitespace(getFile('/test-init.ts'))).toContain(stripWhitespace(`\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+          teardown: { destroyAfterEach: false }\n+        });\n+      `));\n+\n+       expect(stripWhitespace(getFile('/comp.spec.ts'))).toContain(stripWhitespace(`\n+        TestBed.configureTestingModule({\n+          declarations: [Comp]\n+        });\n+      `));\n+\n+       expect(stripWhitespace(getFile('/comp.spec.ts'))).toContain(stripWhitespace(`\n+        it('should also work', withModule({\n+          declarations: [Comp],\n+        }, () => {\n+          TestBed.createComponent(Comp);\n+        }));\n+      `));\n+     });\n+});"
        },
        {
            "sha": "4448fcc2581633118b5a07fdc832e2f87ecf02e4",
            "filename": "packages/core/schematics/test/testbed_teardown_spec.ts",
            "status": "added",
            "additions": 664,
            "deletions": 0,
            "changes": 664,
            "blob_url": "https://github.com/angular/angular/blob/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Ftest%2Ftestbed_teardown_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/81c7eb813c27f08d2d640f34e165a1b5e487bac2/packages%2Fcore%2Fschematics%2Ftest%2Ftestbed_teardown_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Ftestbed_teardown_spec.ts?ref=81c7eb813c27f08d2d640f34e165a1b5e487bac2",
            "patch": "@@ -0,0 +1,664 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n+import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n+import {HostTree} from '@angular-devkit/schematics';\n+import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n+import * as shx from 'shelljs';\n+\n+\n+describe('TestBed teardown migration', () => {\n+  let runner: SchematicTestRunner;\n+  let host: TempScopedNodeJsSyncHost;\n+  let tree: UnitTestTree;\n+  let tmpDirPath: string;\n+  let previousWorkingDir: string;\n+\n+  beforeEach(() => {\n+    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n+    host = new TempScopedNodeJsSyncHost();\n+    tree = new UnitTestTree(new HostTree(host));\n+\n+    writeFile('/tsconfig.json', JSON.stringify({\n+      compilerOptions: {\n+        lib: ['es2015'],\n+        strictNullChecks: true,\n+      },\n+    }));\n+    writeFile('/angular.json', JSON.stringify({\n+      version: 1,\n+      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n+    }));\n+\n+    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n+    // Note that the declarations here are a little more convoluted than they need to be. It's\n+    // because they've been copied over directly from `node_modules/@angular/core/testing.d.ts`,\n+    // except for removing some methods that are irrelevant to these tests.\n+    writeFile('/node_modules/@angular/core/testing.d.ts', `\n+      export declare const getTestBed: () => TestBed;\n+\n+      export declare interface TestBed {\n+        initTestEnvironment(ngModule: any, platform: any, options?: any): void;\n+        configureTestingModule(moduleDef: any): void;\n+      }\n+\n+      export declare const TestBed: TestBedStatic;\n+\n+      export declare interface TestBedStatic {\n+        new (...args: any[]): TestBed;\n+        initTestEnvironment(ngModule: any, platform: any, options?: any): TestBed;\n+        configureTestingModule(moduleDef: any): TestBedStatic;\n+      }\n+\n+      export declare function withModule(moduleDef: any, fn: Function): () => any;\n+    `);\n+\n+    previousWorkingDir = shx.pwd();\n+    tmpDirPath = getSystemPath(host.root);\n+\n+    // Switch into the temporary directory path. This allows us to run\n+    // the schematic against our custom unit test tree.\n+    shx.cd(tmpDirPath);\n+  });\n+\n+  afterEach(() => {\n+    shx.cd(previousWorkingDir);\n+    shx.rm('-r', tmpDirPath);\n+  });\n+\n+  it('should migrate calls to initTestEnvironment', async () => {\n+    writeFile('/index.ts', `\n+      import { TestBed } from '@angular/core/testing';\n+      import {\n+        BrowserDynamicTestingModule,\n+        platformBrowserDynamicTesting\n+      } from '@angular/platform-browser-dynamic/testing';\n+\n+      TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());\n+    `);\n+\n+    await runMigration();\n+\n+    expect(stripWhitespace(tree.readContent('/index.ts'))).toContain(stripWhitespace(`\n+      TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+        teardown: { destroyAfterEach: false }\n+      });\n+    `));\n+  });\n+\n+  it('should migrate calls to initTestEnvironment going through getTestBed()', async () => {\n+    writeFile('/index.ts', `\n+      import { getTestBed } from '@angular/core/testing';\n+      import {\n+        BrowserDynamicTestingModule,\n+        platformBrowserDynamicTesting\n+      } from '@angular/platform-browser-dynamic/testing';\n+\n+      getTestBed().initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());\n+    `);\n+\n+    await runMigration();\n+\n+    expect(stripWhitespace(tree.readContent('/index.ts'))).toContain(stripWhitespace(`\n+      getTestBed().initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+        teardown: { destroyAfterEach: false }\n+      });\n+    `));\n+  });\n+\n+  it('should migrate calls to initTestEnvironment going through a variable', async () => {\n+    writeFile('/index.ts', `\n+      import { getTestBed } from '@angular/core/testing';\n+      import {\n+        BrowserDynamicTestingModule,\n+        platformBrowserDynamicTesting\n+      } from '@angular/platform-browser-dynamic/testing';\n+\n+      const tb = getTestBed();\n+\n+      tb.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());\n+    `);\n+\n+    await runMigration();\n+\n+    expect(stripWhitespace(tree.readContent('/index.ts'))).toContain(stripWhitespace(`\n+      tb.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+        teardown: { destroyAfterEach: false }\n+      });\n+    `));\n+  });\n+\n+  it('should migrate not calls to initTestEnvironment that already specify a teardown behavior',\n+     async () => {\n+       writeFile('/index.ts', `\n+        import { TestBed } from '@angular/core/testing';\n+        import {\n+          BrowserDynamicTestingModule,\n+          platformBrowserDynamicTesting\n+        } from '@angular/platform-browser-dynamic/testing';\n+\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+          teardown: {destroyAfterEach: true}\n+        });\n+      `);\n+\n+       await runMigration();\n+\n+       expect(stripWhitespace(tree.readContent('/index.ts'))).toContain(stripWhitespace(`\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+          teardown: {destroyAfterEach: true}\n+        });\n+      `));\n+     });\n+\n+  it('should migrate calls to initTestEnvironment that pass in aotSummaries as an arrow function',\n+     async () => {\n+       writeFile('/index.ts', `\n+        import { TestBed } from '@angular/core/testing';\n+        import {\n+          BrowserDynamicTestingModule,\n+          platformBrowserDynamicTesting\n+        } from '@angular/platform-browser-dynamic/testing';\n+\n+        class Foo {}\n+\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), () => [Foo]);\n+      `);\n+\n+       await runMigration();\n+\n+       expect(stripWhitespace(tree.readContent('/index.ts'))).toContain(stripWhitespace(`\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+          aotSummaries: () => [Foo],\n+          teardown: { destroyAfterEach: false }\n+        });\n+      `));\n+     });\n+\n+  it('should migrate calls to initTestEnvironment that pass in aotSummaries as an anonymous function',\n+     async () => {\n+       writeFile('/index.ts', `\n+        import { TestBed } from '@angular/core/testing';\n+        import {\n+          BrowserDynamicTestingModule,\n+          platformBrowserDynamicTesting\n+        } from '@angular/platform-browser-dynamic/testing';\n+\n+        class Foo {}\n+\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), function() {\n+          return [Foo];\n+        });\n+      `);\n+\n+       await runMigration();\n+\n+       expect(stripWhitespace(tree.readContent('/index.ts'))).toContain(stripWhitespace(`\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+          aotSummaries: function() {\n+            return [Foo];\n+          },\n+          teardown: { destroyAfterEach: false }\n+        });\n+      `));\n+     });\n+\n+  it('should migrate calls to initTestEnvironment that pass in aotSummaries via an object literal',\n+     async () => {\n+       writeFile('/index.ts', `\n+        import { TestBed } from '@angular/core/testing';\n+        import {\n+          BrowserDynamicTestingModule,\n+          platformBrowserDynamicTesting\n+        } from '@angular/platform-browser-dynamic/testing';\n+\n+        class Foo {}\n+\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+          aotSummaries: () => [Foo]\n+        });\n+      `);\n+\n+       await runMigration();\n+\n+       expect(stripWhitespace(tree.readContent('/index.ts'))).toContain(stripWhitespace(`\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+          aotSummaries: () => [Foo],\n+          teardown: { destroyAfterEach: false }\n+        });\n+      `));\n+     });\n+\n+\n+  it('should migrate initTestEnvironment calls across multiple files', async () => {\n+    writeFile('/test-init.ts', `\n+      import { TestBed } from '@angular/core/testing';\n+      import {\n+        BrowserDynamicTestingModule,\n+        platformBrowserDynamicTesting\n+      } from '@angular/platform-browser-dynamic/testing';\n+\n+      TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());\n+    `);\n+\n+    writeFile('/other-test-init.ts', `\n+      import { getTestBed } from '@angular/core/testing';\n+      import {\n+        BrowserDynamicTestingModule,\n+        platformBrowserDynamicTesting\n+      } from '@angular/platform-browser-dynamic/testing';\n+\n+      getTestBed().initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());\n+    `);\n+\n+    await runMigration();\n+\n+    expect(stripWhitespace(tree.readContent('/test-init.ts'))).toContain(stripWhitespace(`\n+      TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+        teardown: { destroyAfterEach: false }\n+      });\n+    `));\n+\n+    expect(stripWhitespace(tree.readContent('/other-test-init.ts'))).toContain(stripWhitespace(`\n+      getTestBed().initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+        teardown: { destroyAfterEach: false }\n+      });\n+    `));\n+  });\n+\n+  it('should not migrate calls to initTestEnvironment that pass in a variable', async () => {\n+    writeFile('/index.ts', `\n+      import { TestBed } from '@angular/core/testing';\n+      import {\n+        BrowserDynamicTestingModule,\n+        platformBrowserDynamicTesting\n+      } from '@angular/platform-browser-dynamic/testing';\n+\n+      const config = {aotSummaries: () => []};\n+\n+      TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), config);\n+    `);\n+\n+    await runMigration();\n+\n+    const content = stripWhitespace(tree.readContent('/index.ts'));\n+    expect(content).toContain(stripWhitespace(`const config = {aotSummaries: () => []};`));\n+    expect(content).toContain(stripWhitespace(`\n+      TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), config);\n+    `));\n+  });\n+\n+  it('should not migrate invalid initTestEnvironment calls', async () => {\n+    writeFile('/index.ts', `\n+      import { TestBed } from '@angular/core/testing';\n+\n+      TestBed.initTestEnvironment();\n+    `);\n+\n+    await runMigration();\n+\n+    expect(stripWhitespace(tree.readContent('/index.ts')))\n+        .toContain(stripWhitespace(`TestBed.initTestEnvironment();`));\n+  });\n+\n+  it('should not migrate calls to initTestEnvironment not coming from Angular', async () => {\n+    writeFile('/index.ts', `\n+      import { TestBed } from '@not-angular/core/testing';\n+      import {\n+        BrowserDynamicTestingModule,\n+        platformBrowserDynamicTesting\n+      } from '@angular/platform-browser-dynamic/testing';\n+\n+      TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());\n+    `);\n+\n+    await runMigration();\n+\n+    expect(stripWhitespace(tree.readContent('/index.ts')))\n+        .toContain(stripWhitespace(\n+            `TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());`));\n+  });\n+\n+  it('should migrate calls to initTestEnvironment when TestBed is aliased', async () => {\n+    writeFile('/index.ts', `\n+      import { TestBed as AliasOfTestBed } from '@angular/core/testing';\n+      import {\n+        BrowserDynamicTestingModule,\n+        platformBrowserDynamicTesting\n+      } from '@angular/platform-browser-dynamic/testing';\n+\n+      AliasOfTestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());\n+    `);\n+\n+    await runMigration();\n+\n+    expect(stripWhitespace(tree.readContent('/index.ts'))).toContain(stripWhitespace(`\n+      AliasOfTestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+        teardown: { destroyAfterEach: false }\n+      });\n+    `));\n+  });\n+\n+  it('should migrate withModule calls', async () => {\n+    writeFile('/index.spec.ts', `\n+      import { Component } from '@angular/core';\n+      import { withModule, TestBed } from '@angular/core/testing';\n+\n+      @Component({template: ''})\n+      class Comp {}\n+\n+      it('should work', withModule({\n+        declarations: [Comp],\n+      }, () => {\n+        TestBed.createComponent(Comp);\n+      }));\n+    `);\n+\n+    await runMigration();\n+\n+    expect(stripWhitespace(tree.readContent('/index.spec.ts'))).toContain(stripWhitespace(`\n+      it('should work', withModule({\n+        declarations: [Comp],\n+        teardown: {destroyAfterEach: false}\n+      }, () => {\n+        TestBed.createComponent(Comp);\n+      }));\n+    `));\n+  });\n+\n+  it('should not migrate withModule calls that already pass in the teardown flag', async () => {\n+    writeFile('/index.spec.ts', `\n+      import { Component } from '@angular/core';\n+      import { withModule, TestBed } from '@angular/core/testing';\n+\n+      @Component({template: ''})\n+      class Comp {}\n+\n+      it('should work', withModule({\n+        teardown: {destroyAfterEach: true},\n+        declarations: [Comp],\n+      }, () => {\n+        TestBed.createComponent(Comp);\n+      }));\n+    `);\n+\n+    await runMigration();\n+\n+    expect(stripWhitespace(tree.readContent('/index.spec.ts'))).toContain(stripWhitespace(`\n+      it('should work', withModule({\n+        teardown: {destroyAfterEach: true},\n+        declarations: [Comp],\n+      }, () => {\n+        TestBed.createComponent(Comp);\n+      }));\n+    `));\n+  });\n+\n+  it('should not migrate withModule calls that do not come from Angular', async () => {\n+    writeFile('/index.spec.ts', `\n+      import { Component } from '@angular/core';\n+      import { TestBed } from '@angular/core/testing';\n+\n+      function withModule(...args: any[]) {}\n+\n+      @Component({template: ''})\n+      class Comp {}\n+\n+      it('should work', withModule({\n+        declarations: [Comp],\n+      }, () => {\n+        TestBed.createComponent(Comp);\n+      }));\n+    `);\n+\n+    await runMigration();\n+\n+    expect(stripWhitespace(tree.readContent('/index.spec.ts'))).toContain(stripWhitespace(`\n+      it('should work', withModule({\n+        declarations: [Comp],\n+      }, () => {\n+        TestBed.createComponent(Comp);\n+      }));\n+    `));\n+  });\n+\n+  it('should migrate aliased withModule calls', async () => {\n+    writeFile('/index.spec.ts', `\n+      import { Component } from '@angular/core';\n+      import { withModule as aliasOfWithModule, TestBed } from '@angular/core/testing';\n+\n+      @Component({template: ''})\n+      class Comp {}\n+\n+      it('should work', aliasOfWithModule({\n+        declarations: [Comp],\n+      }, () => {\n+        TestBed.createComponent(Comp);\n+      }));\n+    `);\n+\n+    await runMigration();\n+\n+    expect(stripWhitespace(tree.readContent('/index.spec.ts'))).toContain(stripWhitespace(`\n+      it('should work', aliasOfWithModule({\n+        declarations: [Comp],\n+        teardown: {destroyAfterEach: false}\n+      }, () => {\n+        TestBed.createComponent(Comp);\n+      }));\n+    `));\n+  });\n+\n+  it('should migrate configureTestingModule calls', async () => {\n+    writeFile('/index.spec.ts', `\n+      import { Component } from '@angular/core';\n+      import { TestBed } from '@angular/core/testing';\n+\n+      @Component({template: ''})\n+      class Comp {}\n+\n+      it('should work', () => {\n+        TestBed.configureTestingModule({\n+          declarations: [Comp]\n+        });\n+\n+        const fixture = TestBed.createComponent(Comp);\n+        fixture.detectChanges();\n+      });\n+    `);\n+\n+    await runMigration();\n+\n+    expect(stripWhitespace(tree.readContent('/index.spec.ts'))).toContain(stripWhitespace(`\n+      TestBed.configureTestingModule({\n+        declarations: [Comp],\n+        teardown: {destroyAfterEach: false}\n+      });\n+    `));\n+  });\n+\n+  it('should migrate multiple configureTestingModule calls within the same file', async () => {\n+    writeFile('/index.spec.ts', `\n+      import { Component } from '@angular/core';\n+      import { TestBed } from '@angular/core/testing';\n+\n+      @Component({template: ''})\n+      class Comp {}\n+\n+      @Component({template: ''})\n+      class BetterComp {}\n+\n+      it('should work', () => {\n+        TestBed.configureTestingModule({\n+          declarations: [Comp]\n+        });\n+\n+        const fixture = TestBed.createComponent(Comp);\n+        fixture.detectChanges();\n+      });\n+\n+      it('should work better', () => {\n+        TestBed.configureTestingModule({\n+          declarations: [BetterComp]\n+        });\n+\n+        const fixture = TestBed.createComponent(BetterComp);\n+        fixture.detectChanges();\n+      });\n+    `);\n+\n+    await runMigration();\n+\n+    const content = stripWhitespace(tree.readContent('/index.spec.ts'));\n+\n+    expect(content).toContain(stripWhitespace(`\n+      TestBed.configureTestingModule({\n+        declarations: [Comp],\n+        teardown: {destroyAfterEach: false}\n+      });\n+    `));\n+\n+    expect(content).toContain(stripWhitespace(`\n+      TestBed.configureTestingModule({\n+        declarations: [BetterComp],\n+        teardown: {destroyAfterEach: false}\n+      });\n+    `));\n+  });\n+\n+  it('should migrate configureTestingModule calls through getTestBed()', async () => {\n+    writeFile('/index.spec.ts', `\n+      import { Component } from '@angular/core';\n+      import { getTestBed } from '@angular/core/testing';\n+\n+      @Component({template: ''})\n+      class Comp {}\n+\n+      it('should work', () => {\n+        getTestBed().configureTestingModule({\n+          declarations: [Comp]\n+        });\n+\n+        const fixture = getTestBed().createComponent(Comp);\n+        fixture.detectChanges();\n+      });\n+    `);\n+\n+    await runMigration();\n+\n+    expect(stripWhitespace(tree.readContent('/index.spec.ts'))).toContain(stripWhitespace(`\n+      getTestBed().configureTestingModule({\n+        declarations: [Comp],\n+        teardown: {destroyAfterEach: false}\n+      });\n+    `));\n+  });\n+\n+  it('should not migrate configureTestingModule calls that already pass in the teardown flag',\n+     async () => {\n+       writeFile('/index.spec.ts', `\n+        import { Component } from '@angular/core';\n+        import { TestBed } from '@angular/core/testing';\n+\n+        @Component({template: ''})\n+        class Comp {}\n+\n+        it('should work', () => {\n+          TestBed.configureTestingModule({\n+            teardown: {destroyAfterEach: true},\n+            declarations: [Comp]\n+          });\n+\n+          const fixture = TestBed.createComponent(Comp);\n+          fixture.detectChanges();\n+        });\n+      `);\n+\n+       await runMigration();\n+\n+       expect(stripWhitespace(tree.readContent('/index.spec.ts'))).toContain(stripWhitespace(`\n+        TestBed.configureTestingModule({\n+          teardown: {destroyAfterEach: true},\n+          declarations: [Comp]\n+        });\n+      `));\n+     });\n+\n+\n+  it('should not migrate configureTestingModule or withModule calls if initTestEnvironment was migrated in another file',\n+     async () => {\n+       writeFile('/test-init.ts', `\n+        import { TestBed } from '@angular/core/testing';\n+        import {\n+          BrowserDynamicTestingModule,\n+          platformBrowserDynamicTesting\n+        } from '@angular/platform-browser-dynamic/testing';\n+\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting());\n+      `);\n+\n+       writeFile('/comp.spec.ts', `\n+        import { Component } from '@angular/core';\n+        import { TestBed, withModule } from '@angular/core/testing';\n+\n+        @Component({template: ''})\n+        class Comp {}\n+\n+        it('should work', () => {\n+          TestBed.configureTestingModule({\n+            declarations: [Comp]\n+          });\n+\n+          const fixture = TestBed.createComponent(Comp);\n+          fixture.detectChanges();\n+        });\n+\n+        it('should also work', withModule({\n+          declarations: [Comp],\n+        }, () => {\n+          TestBed.createComponent(Comp);\n+        }));\n+      `);\n+\n+       await runMigration();\n+\n+       expect(stripWhitespace(tree.readContent('/test-init.ts'))).toContain(stripWhitespace(`\n+        TestBed.initTestEnvironment(BrowserDynamicTestingModule, platformBrowserDynamicTesting(), {\n+          teardown: { destroyAfterEach: false }\n+        });\n+      `));\n+\n+       expect(stripWhitespace(tree.readContent('/comp.spec.ts'))).toContain(stripWhitespace(`\n+        TestBed.configureTestingModule({\n+          declarations: [Comp]\n+        });\n+      `));\n+\n+       expect(stripWhitespace(tree.readContent('/comp.spec.ts'))).toContain(stripWhitespace(`\n+        it('should also work', withModule({\n+          declarations: [Comp],\n+        }, () => {\n+          TestBed.createComponent(Comp);\n+        }));\n+      `));\n+     });\n+\n+\n+  function writeFile(filePath: string, contents: string) {\n+    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n+  }\n+\n+  function runMigration() {\n+    return runner.runSchematicAsync('migration-v13-testbed-teardown', {}, tree).toPromise();\n+  }\n+\n+  function stripWhitespace(contents: string) {\n+    return contents.replace(/\\s/g, '');\n+  }\n+});"
        }
    ],
    "stats": {
        "total": 1771,
        "additions": 1770,
        "deletions": 1
    }
}