{
    "author": "JoostK",
    "message": "refactor(compiler-cli): improve DX for reference emit failures (#44587)\n\nIn certain scenarios, the compiler may have crashed with an\n`Unable to write a reference` error which would be particularly hard\nto diagnose. One of the primary reasons for this failure is when the\n`rootDir` option is configured---typically the case for libraries---\nand a source file is imported using a relative import from an external\nentry-point. This would normally report TS6059 for the invalid relative\nimport, but the crash prevents this error from being surfaced.\n\nThis commit refactors the reference emit logic to result in an explicit\n`Failure` state with a reason as to why the failure occurred. This state\nis then used to report a `FatalDiagnosticException`, preventing a hard\ncrash.\n\nCloses #44414\n\nPR Close #44587",
    "sha": "7052e27677b9213009e99d34c8cfc013fd0552de",
    "files": [
        {
            "sha": "0fba1f0e3735e71c567337d2b6f0c0316df42d5d",
            "filename": "goldens/public-api/compiler-cli/error_code.md",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/7052e27677b9213009e99d34c8cfc013fd0552de/goldens%2Fpublic-api%2Fcompiler-cli%2Ferror_code.md",
            "raw_url": "https://github.com/angular/angular/raw/7052e27677b9213009e99d34c8cfc013fd0552de/goldens%2Fpublic-api%2Fcompiler-cli%2Ferror_code.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fpublic-api%2Fcompiler-cli%2Ferror_code.md?ref=7052e27677b9213009e99d34c8cfc013fd0552de",
            "patch": "@@ -31,6 +31,7 @@ export enum ErrorCode {\n     DUPLICATE_VARIABLE_DECLARATION = 8006,\n     HOST_BINDING_PARSE_ERROR = 5001,\n     IMPORT_CYCLE_DETECTED = 3003,\n+    IMPORT_GENERATION_FAILURE = 3004,\n     INJECTABLE_DUPLICATE_PROV = 9001,\n     INLINE_TCB_REQUIRED = 8900,\n     INLINE_TYPE_CTOR_REQUIRED = 8901,"
        },
        {
            "sha": "036a04da3e290fc885f52ff84a54d23169171a97",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/component.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts?ref=7052e27677b9213009e99d34c8cfc013fd0552de",
            "patch": "@@ -12,7 +12,7 @@ import ts from 'typescript';\n import {Cycle, CycleAnalyzer, CycleHandlingStrategy} from '../../cycles';\n import {ErrorCode, FatalDiagnosticError, makeDiagnostic, makeRelatedInformation} from '../../diagnostics';\n import {absoluteFrom, relative} from '../../file_system';\n-import {ImportedFile, ModuleResolver, Reference, ReferenceEmitter} from '../../imports';\n+import {assertSuccessfulReferenceEmit, ImportedFile, ModuleResolver, Reference, ReferenceEmitter} from '../../imports';\n import {DependencyTracker} from '../../incremental/api';\n import {extractSemanticTypeParameters, isArrayEqual, isReferenceEqual, SemanticDepGraphUpdater, SemanticReference, SemanticSymbol} from '../../incremental/semantic_graph';\n import {IndexingContext} from '../../indexer';\n@@ -690,6 +690,8 @@ export class ComponentDecoratorHandler implements\n           R3UsedDirectiveMetadata&{ref: Reference<ClassDeclaration>, importedFile: ImportedFile};\n       const usedDirectives: UsedDirective[] = bound.getUsedDirectives().map(directive => {\n         const type = this.refEmitter.emit(directive.ref, context);\n+        assertSuccessfulReferenceEmit(\n+            type, node.name, directive.isComponent ? 'component' : 'directive');\n         return {\n           ref: directive.ref,\n           type: type.expression,\n@@ -715,6 +717,7 @@ export class ComponentDecoratorHandler implements\n         }\n         const pipe = pipes.get(pipeName)!;\n         const type = this.refEmitter.emit(pipe, context);\n+        assertSuccessfulReferenceEmit(type, node.name, 'pipe');\n         usedPipes.push({\n           ref: pipe,\n           pipeName,"
        },
        {
            "sha": "216b118b76309e379e6ba561142a552d57bb345e",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/ng_module.ts",
            "status": "modified",
            "additions": 33,
            "deletions": 15,
            "changes": 48,
            "blob_url": "https://github.com/angular/angular/blob/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fng_module.ts",
            "raw_url": "https://github.com/angular/angular/raw/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fng_module.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fng_module.ts?ref=7052e27677b9213009e99d34c8cfc013fd0552de",
            "patch": "@@ -10,7 +10,7 @@ import {compileClassMetadata, compileDeclareClassMetadata, compileDeclareInjecto\n import ts from 'typescript';\n \n import {ErrorCode, FatalDiagnosticError, makeDiagnostic, makeRelatedInformation} from '../../diagnostics';\n-import {Reference, ReferenceEmitter} from '../../imports';\n+import {assertSuccessfulReferenceEmit, Reference, ReferenceEmitter} from '../../imports';\n import {isArrayEqual, isReferenceEqual, isSymbolEqual, SemanticReference, SemanticSymbol} from '../../incremental/semantic_graph';\n import {InjectableClassRegistry, MetadataReader, MetadataRegistry} from '../../metadata';\n import {PartialEvaluator, ResolvedValue} from '../../partial_evaluator';\n@@ -280,12 +280,19 @@ export class NgModuleDecoratorHandler implements\n       typeContext = typeNode.getSourceFile();\n     }\n \n-    const bootstrap =\n-        bootstrapRefs.map(bootstrap => this._toR3Reference(bootstrap, valueContext, typeContext));\n-    const declarations =\n-        declarationRefs.map(decl => this._toR3Reference(decl, valueContext, typeContext));\n-    const imports = importRefs.map(imp => this._toR3Reference(imp, valueContext, typeContext));\n-    const exports = exportRefs.map(exp => this._toR3Reference(exp, valueContext, typeContext));\n+    const bootstrap = bootstrapRefs.map(\n+        bootstrap => this._toR3Reference(\n+            bootstrap.getOriginForDiagnostics(meta, node.name), bootstrap, valueContext,\n+            typeContext));\n+    const declarations = declarationRefs.map(\n+        decl => this._toR3Reference(\n+            decl.getOriginForDiagnostics(meta, node.name), decl, valueContext, typeContext));\n+    const imports = importRefs.map(\n+        imp => this._toR3Reference(\n+            imp.getOriginForDiagnostics(meta, node.name), imp, valueContext, typeContext));\n+    const exports = exportRefs.map(\n+        exp => this._toR3Reference(\n+            exp.getOriginForDiagnostics(meta, node.name), exp, valueContext, typeContext));\n \n     const isForwardReference = (ref: R3Reference) =>\n         isExpressionForwardReference(ref.value, node.name!, valueContext);\n@@ -419,7 +426,9 @@ export class NgModuleDecoratorHandler implements\n       const context = getSourceFile(node);\n       for (const exportRef of analysis.exports) {\n         if (isNgModule(exportRef.node, scope.compilation)) {\n-          data.injectorImports.push(this.refEmitter.emit(exportRef, context).expression);\n+          const type = this.refEmitter.emit(exportRef, context);\n+          assertSuccessfulReferenceEmit(type, node, 'NgModule');\n+          data.injectorImports.push(type.expression);\n         }\n       }\n \n@@ -506,12 +515,21 @@ export class NgModuleDecoratorHandler implements\n     for (const decl of declarations) {\n       const remoteScope = this.scopeRegistry.getRemoteScope(decl.node);\n       if (remoteScope !== null) {\n-        const directives = remoteScope.directives.map(\n-            directive => this.refEmitter.emit(directive, context).expression);\n-        const pipes = remoteScope.pipes.map(pipe => this.refEmitter.emit(pipe, context).expression);\n+        const directives = remoteScope.directives.map(directive => {\n+          const type = this.refEmitter.emit(directive, context);\n+          assertSuccessfulReferenceEmit(type, node, 'directive');\n+          return type.expression;\n+        });\n+        const pipes = remoteScope.pipes.map(pipe => {\n+          const type = this.refEmitter.emit(pipe, context);\n+          assertSuccessfulReferenceEmit(type, node, 'pipe');\n+          return type.expression;\n+        });\n         const directiveArray = new LiteralArrayExpr(directives);\n         const pipesArray = new LiteralArrayExpr(pipes);\n-        const declExpr = this.refEmitter.emit(decl, context).expression;\n+        const componentType = this.refEmitter.emit(decl, context);\n+        assertSuccessfulReferenceEmit(componentType, node, 'component');\n+        const declExpr = componentType.expression;\n         const setComponentScope = new ExternalExpr(R3Identifiers.setComponentScope);\n         const callExpr =\n             new InvokeFunctionExpr(setComponentScope, [declExpr, directiveArray, pipesArray]);\n@@ -543,17 +561,17 @@ export class NgModuleDecoratorHandler implements\n   }\n \n   private _toR3Reference(\n-      valueRef: Reference<ClassDeclaration>, valueContext: ts.SourceFile,\n+      origin: ts.Node, valueRef: Reference<ClassDeclaration>, valueContext: ts.SourceFile,\n       typeContext: ts.SourceFile): R3Reference {\n     if (valueRef.hasOwningModuleGuess) {\n-      return toR3Reference(valueRef, valueRef, valueContext, valueContext, this.refEmitter);\n+      return toR3Reference(origin, valueRef, valueRef, valueContext, valueContext, this.refEmitter);\n     } else {\n       let typeRef = valueRef;\n       let typeNode = this.reflector.getDtsDeclaration(typeRef.node);\n       if (typeNode !== null && isNamedClassDeclaration(typeNode)) {\n         typeRef = new Reference(typeNode);\n       }\n-      return toR3Reference(valueRef, typeRef, valueContext, typeContext, this.refEmitter);\n+      return toR3Reference(origin, valueRef, typeRef, valueContext, typeContext, this.refEmitter);\n     }\n   }\n "
        },
        {
            "sha": "56d38ccace290a29b3f50417c156d963d19cb93c",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/util.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 6,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Futil.ts?ref=7052e27677b9213009e99d34c8cfc013fd0552de",
            "patch": "@@ -10,7 +10,7 @@ import {Expression, ExternalExpr, FactoryTarget, LiteralExpr, ParseLocation, Par\n import ts from 'typescript';\n \n import {ErrorCode, FatalDiagnosticError, makeDiagnostic, makeRelatedInformation} from '../../diagnostics';\n-import {ImportFlags, Reference, ReferenceEmitter} from '../../imports';\n+import {assertSuccessfulReferenceEmit, ImportFlags, Reference, ReferenceEmitter} from '../../imports';\n import {attachDefaultImportDeclaration} from '../../imports/src/default';\n import {ForeignFunctionResolver, PartialEvaluator} from '../../partial_evaluator';\n import {ClassDeclaration, CtorParameter, Decorator, Import, ImportedTypeValueReference, isNamedClassDeclaration, LocalTypeValueReference, ReflectionHost, TypeValueReference, TypeValueReferenceKind, UnavailableValue, ValueUnavailableKind} from '../../reflection';\n@@ -257,13 +257,18 @@ function createUnsuitableInjectionTokenError(\n }\n \n export function toR3Reference(\n-    valueRef: Reference, typeRef: Reference, valueContext: ts.SourceFile,\n+    origin: ts.Node, valueRef: Reference, typeRef: Reference, valueContext: ts.SourceFile,\n     typeContext: ts.SourceFile, refEmitter: ReferenceEmitter): R3Reference {\n+  const emittedValueRef = refEmitter.emit(valueRef, valueContext);\n+  assertSuccessfulReferenceEmit(emittedValueRef, origin, 'class');\n+\n+  const emittedTypeRef = refEmitter.emit(\n+      typeRef, typeContext, ImportFlags.ForceNewImport | ImportFlags.AllowTypeImports);\n+  assertSuccessfulReferenceEmit(emittedTypeRef, origin, 'class');\n+\n   return {\n-    value: refEmitter.emit(valueRef, valueContext).expression,\n-    type: refEmitter\n-              .emit(typeRef, typeContext, ImportFlags.ForceNewImport | ImportFlags.AllowTypeImports)\n-              .expression,\n+    value: emittedValueRef.expression,\n+    type: emittedTypeRef.expression,\n   };\n }\n "
        },
        {
            "sha": "25a283f8781cc4ef27c01ba2e078a942dfd18c6e",
            "filename": "packages/compiler-cli/src/ngtsc/diagnostics/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fdiagnostics%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fdiagnostics%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fdiagnostics%2Findex.ts?ref=7052e27677b9213009e99d34c8cfc013fd0552de",
            "patch": "@@ -7,7 +7,7 @@\n  */\n \n export {COMPILER_ERRORS_WITH_GUIDES} from './src/docs';\n-export {FatalDiagnosticError, isFatalDiagnosticError, makeDiagnostic, makeRelatedInformation} from './src/error';\n+export {FatalDiagnosticError, isFatalDiagnosticError, makeDiagnostic, makeDiagnosticChain, makeRelatedInformation} from './src/error';\n export {ErrorCode} from './src/error_code';\n export {ERROR_DETAILS_PAGE_BASE_URL} from './src/error_details_base_url';\n export {ngErrorCode, replaceTsWithNgInErrors} from './src/util';"
        },
        {
            "sha": "bd16c1495911995377ade8aeeec987ebebeb51a1",
            "filename": "packages/compiler-cli/src/ngtsc/diagnostics/src/error.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fdiagnostics%2Fsrc%2Ferror.ts",
            "raw_url": "https://github.com/angular/angular/raw/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fdiagnostics%2Fsrc%2Ferror.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fdiagnostics%2Fsrc%2Ferror.ts?ref=7052e27677b9213009e99d34c8cfc013fd0552de",
            "patch": "@@ -42,6 +42,16 @@ export function makeDiagnostic(\n   };\n }\n \n+export function makeDiagnosticChain(\n+    messageText: string, next?: ts.DiagnosticMessageChain[]): ts.DiagnosticMessageChain {\n+  return {\n+    category: ts.DiagnosticCategory.Message,\n+    code: 0,\n+    messageText,\n+    next,\n+  };\n+}\n+\n export function makeRelatedInformation(\n     node: ts.Node, messageText: string): ts.DiagnosticRelatedInformation {\n   node = ts.getOriginalNode(node);"
        },
        {
            "sha": "b41686eee3a7506945bee84e60fd742f813f06be",
            "filename": "packages/compiler-cli/src/ngtsc/diagnostics/src/error_code.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fdiagnostics%2Fsrc%2Ferror_code.ts",
            "raw_url": "https://github.com/angular/angular/raw/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fdiagnostics%2Fsrc%2Ferror_code.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fdiagnostics%2Fsrc%2Ferror_code.ts?ref=7052e27677b9213009e99d34c8cfc013fd0552de",
            "patch": "@@ -64,6 +64,11 @@ export enum ErrorCode {\n    */\n   IMPORT_CYCLE_DETECTED = 3003,\n \n+  /**\n+   * Raised when the compiler is unable to generate an import statement for a reference.\n+   */\n+  IMPORT_GENERATION_FAILURE = 3004,\n+\n   CONFIG_FLAT_MODULE_NO_INDEX = 4001,\n   CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK = 4002,\n "
        },
        {
            "sha": "02288da57d2a7d0209876e271f7bdb3d6c5eff3d",
            "filename": "packages/compiler-cli/src/ngtsc/imports/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2FBUILD.bazel?ref=7052e27677b9213009e99d34c8cfc013fd0552de",
            "patch": "@@ -11,6 +11,7 @@ ts_library(\n         \"//packages:types\",\n         \"//packages/compiler\",\n         \"//packages/compiler-cli/src/ngtsc/core:api\",\n+        \"//packages/compiler-cli/src/ngtsc/diagnostics\",\n         \"//packages/compiler-cli/src/ngtsc/file_system\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\",\n         \"//packages/compiler-cli/src/ngtsc/util\","
        },
        {
            "sha": "e042588d6eba9d8e43ce4f510b1ff74491abcf67",
            "filename": "packages/compiler-cli/src/ngtsc/imports/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Findex.ts?ref=7052e27677b9213009e99d34c8cfc013fd0552de",
            "patch": "@@ -9,7 +9,7 @@\n export {AliasingHost, AliasStrategy, PrivateExportAliasingHost, UnifiedModulesAliasingHost} from './src/alias';\n export {ImportRewriter, NoopImportRewriter, R3SymbolsImportRewriter, validateAndRewriteCoreSymbol} from './src/core';\n export {DefaultImportTracker} from './src/default';\n-export {AbsoluteModuleStrategy, EmittedReference, ImportedFile, ImportFlags, LocalIdentifierStrategy, LogicalProjectStrategy, ReferenceEmitStrategy, ReferenceEmitter, RelativePathStrategy, UnifiedModulesStrategy} from './src/emitter';\n+export {AbsoluteModuleStrategy, assertSuccessfulReferenceEmit, EmittedReference, FailedEmitResult, ImportedFile, ImportFlags, LocalIdentifierStrategy, LogicalProjectStrategy, ReferenceEmitKind, ReferenceEmitResult, ReferenceEmitStrategy, ReferenceEmitter, RelativePathStrategy, UnifiedModulesStrategy} from './src/emitter';\n export {Reexport} from './src/reexport';\n export {OwningModule, Reference} from './src/references';\n export {ModuleResolver} from './src/resolver';"
        },
        {
            "sha": "4c41e3cc4a34517114c6a57316b300b5b9686424",
            "filename": "packages/compiler-cli/src/ngtsc/imports/src/alias.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Fsrc%2Falias.ts",
            "raw_url": "https://github.com/angular/angular/raw/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Fsrc%2Falias.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Fsrc%2Falias.ts?ref=7052e27677b9213009e99d34c8cfc013fd0552de",
            "patch": "@@ -12,7 +12,7 @@ import ts from 'typescript';\n import {UnifiedModulesHost} from '../../core/api';\n import {ClassDeclaration, ReflectionHost} from '../../reflection';\n \n-import {EmittedReference, ImportFlags, ReferenceEmitStrategy} from './emitter';\n+import {EmittedReference, ImportFlags, ReferenceEmitKind, ReferenceEmitStrategy} from './emitter';\n import {Reference} from './references';\n \n \n@@ -217,6 +217,10 @@ export class AliasStrategy implements ReferenceEmitStrategy {\n       return null;\n     }\n \n-    return {expression: ref.alias, importedFile: 'unknown'};\n+    return {\n+      kind: ReferenceEmitKind.Success,\n+      expression: ref.alias,\n+      importedFile: 'unknown',\n+    };\n   }\n }"
        },
        {
            "sha": "d272a5113b23f53eb3fb07e2eed723293d5a3e40",
            "filename": "packages/compiler-cli/src/ngtsc/imports/src/emitter.ts",
            "status": "modified",
            "additions": 120,
            "deletions": 23,
            "changes": 143,
            "blob_url": "https://github.com/angular/angular/blob/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Fsrc%2Femitter.ts",
            "raw_url": "https://github.com/angular/angular/raw/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Fsrc%2Femitter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Fsrc%2Femitter.ts?ref=7052e27677b9213009e99d34c8cfc013fd0552de",
            "patch": "@@ -9,6 +9,7 @@ import {Expression, ExternalExpr, ExternalReference, WrappedNodeExpr} from '@ang\n import ts from 'typescript';\n \n import {UnifiedModulesHost} from '../../core/api';\n+import {ErrorCode, FatalDiagnosticError, makeDiagnosticChain, makeRelatedInformation} from '../../diagnostics';\n import {absoluteFromSourceFile, dirname, LogicalFileSystem, LogicalProjectPath, relative, toRelativeImport} from '../../file_system';\n import {stripExtension} from '../../file_system/src/util';\n import {DeclarationNode, ReflectionHost} from '../../reflection';\n@@ -62,11 +63,18 @@ export enum ImportFlags {\n  */\n export type ImportedFile = ts.SourceFile|'unknown'|null;\n \n+export const enum ReferenceEmitKind {\n+  Success,\n+  Failed,\n+}\n+\n /**\n  * Represents the emitted expression of a `Reference` that is valid in the source file it was\n  * emitted from.\n  */\n export interface EmittedReference {\n+  kind: ReferenceEmitKind.Success;\n+\n   /**\n    * The expression that refers to `Reference`.\n    */\n@@ -81,6 +89,52 @@ export interface EmittedReference {\n   importedFile: ImportedFile;\n }\n \n+/**\n+ * Represents a failure to emit a `Reference` into a different source file.\n+ */\n+export interface FailedEmitResult {\n+  kind: ReferenceEmitKind.Failed;\n+\n+  /**\n+   * The reference that could not be emitted.\n+   */\n+  ref: Reference;\n+\n+  /**\n+   * The source file into which the reference was requested to be emitted.\n+   */\n+  context: ts.SourceFile;\n+\n+  /**\n+   * Describes why the reference could not be emitted. This may be shown in a diagnostic.\n+   */\n+  reason: string;\n+}\n+\n+export type ReferenceEmitResult = EmittedReference|FailedEmitResult;\n+\n+/**\n+ * Verifies that a reference was emitted successfully, or raises a `FatalDiagnosticError` otherwise.\n+ * @param result The emit result that should have been successful.\n+ * @param origin The node that is used to report the failure diagnostic.\n+ * @param typeKind The kind of the symbol that the reference represents, e.g. 'component' or\n+ *     'class'.\n+ */\n+export function assertSuccessfulReferenceEmit(\n+    result: ReferenceEmitResult, origin: ts.Node,\n+    typeKind: string): asserts result is EmittedReference {\n+  if (result.kind === ReferenceEmitKind.Success) {\n+    return;\n+  }\n+\n+  const message = makeDiagnosticChain(\n+      `Unable to import ${typeKind} ${nodeNameForError(result.ref.node)}.`,\n+      [makeDiagnosticChain(result.reason)]);\n+  throw new FatalDiagnosticError(\n+      ErrorCode.IMPORT_GENERATION_FAILURE, origin, message,\n+      [makeRelatedInformation(result.ref.node, `The ${typeKind} is declared here.`)]);\n+}\n+\n /**\n  * A particular strategy for generating an expression which refers to a `Reference`.\n  *\n@@ -104,7 +158,7 @@ export interface ReferenceEmitStrategy {\n    * @returns an `EmittedReference` which refers to the `Reference`, or `null` if none can be\n    *   generated\n    */\n-  emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags): EmittedReference|null;\n+  emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags): ReferenceEmitResult|null;\n }\n \n /**\n@@ -117,15 +171,20 @@ export class ReferenceEmitter {\n   constructor(private strategies: ReferenceEmitStrategy[]) {}\n \n   emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags = ImportFlags.None):\n-      EmittedReference {\n+      ReferenceEmitResult {\n     for (const strategy of this.strategies) {\n       const emitted = strategy.emit(ref, context, importFlags);\n       if (emitted !== null) {\n         return emitted;\n       }\n     }\n-    throw new Error(`Unable to write a reference to ${nodeNameForError(ref.node)} in ${\n-        ref.node.getSourceFile().fileName} from ${context.fileName}`);\n+\n+    return {\n+      kind: ReferenceEmitKind.Failed,\n+      ref,\n+      context,\n+      reason: `Unable to write a reference to ${nodeNameForError(ref.node)}.`,\n+    };\n   }\n }\n \n@@ -150,6 +209,7 @@ export class LocalIdentifierStrategy implements ReferenceEmitStrategy {\n     // invalid emission of a free-standing `foo` identifier, rather than `exports.foo`.\n     if (!isDeclaration(ref.node) && refSf === context) {\n       return {\n+        kind: ReferenceEmitKind.Success,\n         expression: new WrappedNodeExpr(ref.node),\n         importedFile: null,\n       };\n@@ -160,6 +220,7 @@ export class LocalIdentifierStrategy implements ReferenceEmitStrategy {\n     const identifier = ref.getIdentityIn(context);\n     if (identifier !== null) {\n       return {\n+        kind: ReferenceEmitKind.Success,\n         expression: new WrappedNodeExpr(identifier),\n         importedFile: null,\n       };\n@@ -176,12 +237,12 @@ interface ModuleExports {\n   /**\n    * The source file of the module.\n    */\n-  module: ts.SourceFile;\n+  module: ts.SourceFile|null;\n \n   /**\n    * The map of declarations to their exported name.\n    */\n-  exportMap: Map<DeclarationNode, string>;\n+  exportMap: Map<DeclarationNode, string>|null;\n }\n \n /**\n@@ -198,13 +259,13 @@ export class AbsoluteModuleStrategy implements ReferenceEmitStrategy {\n    * A cache of the exports of specific modules, because resolving a module to its exports is a\n    * costly operation.\n    */\n-  private moduleExportsCache = new Map<string, ModuleExports|null>();\n+  private moduleExportsCache = new Map<string, ModuleExports>();\n \n   constructor(\n       protected program: ts.Program, protected checker: ts.TypeChecker,\n       protected moduleResolver: ModuleResolver, private reflectionHost: ReflectionHost) {}\n \n-  emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags): EmittedReference|null {\n+  emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags): ReferenceEmitResult|null {\n     if (ref.bestGuessOwningModule === null) {\n       // There is no module name available for this Reference, meaning it was arrived at via a\n       // relative path.\n@@ -221,38 +282,48 @@ export class AbsoluteModuleStrategy implements ReferenceEmitStrategy {\n     // Try to find the exported name of the declaration, if one is available.\n     const {specifier, resolutionContext} = ref.bestGuessOwningModule;\n     const exports = this.getExportsOfModule(specifier, resolutionContext);\n-    if (exports === null || !exports.exportMap.has(ref.node)) {\n-      // TODO(alxhub): make this error a ts.Diagnostic pointing at whatever caused this import to be\n-      // triggered.\n-      throw new Error(`Symbol ${ref.debugName} declared in ${\n-          getSourceFile(ref.node).fileName} is not exported from ${specifier} (import into ${\n-          context.fileName})`);\n+    if (exports.module === null) {\n+      return {\n+        kind: ReferenceEmitKind.Failed,\n+        ref,\n+        context,\n+        reason: `The module '${specifier}' could not be found.`,\n+      };\n+    } else if (exports.exportMap === null || !exports.exportMap.has(ref.node)) {\n+      return {\n+        kind: ReferenceEmitKind.Failed,\n+        ref,\n+        context,\n+        reason:\n+            `The symbol is not exported from ${exports.module.fileName} (module '${specifier}').`,\n+      };\n     }\n     const symbolName = exports.exportMap.get(ref.node)!;\n \n     return {\n+      kind: ReferenceEmitKind.Success,\n       expression: new ExternalExpr(new ExternalReference(specifier, symbolName)),\n       importedFile: exports.module,\n     };\n   }\n \n-  private getExportsOfModule(moduleName: string, fromFile: string): ModuleExports|null {\n+  private getExportsOfModule(moduleName: string, fromFile: string): ModuleExports {\n     if (!this.moduleExportsCache.has(moduleName)) {\n       this.moduleExportsCache.set(moduleName, this.enumerateExportsOfModule(moduleName, fromFile));\n     }\n     return this.moduleExportsCache.get(moduleName)!;\n   }\n \n-  protected enumerateExportsOfModule(specifier: string, fromFile: string): ModuleExports|null {\n+  protected enumerateExportsOfModule(specifier: string, fromFile: string): ModuleExports {\n     // First, resolve the module specifier to its entry point, and get the ts.Symbol for it.\n     const entryPointFile = this.moduleResolver.resolveModule(specifier, fromFile);\n     if (entryPointFile === null) {\n-      return null;\n+      return {module: null, exportMap: null};\n     }\n \n     const exports = this.reflectionHost.getExportsOfModule(entryPointFile);\n     if (exports === null) {\n-      return null;\n+      return {module: entryPointFile, exportMap: null};\n     }\n     const exportMap = new Map<DeclarationNode, string>();\n     for (const [name, declaration] of exports) {\n@@ -284,15 +355,22 @@ export class AbsoluteModuleStrategy implements ReferenceEmitStrategy {\n export class LogicalProjectStrategy implements ReferenceEmitStrategy {\n   constructor(private reflector: ReflectionHost, private logicalFs: LogicalFileSystem) {}\n \n-  emit(ref: Reference, context: ts.SourceFile): EmittedReference|null {\n+  emit(ref: Reference, context: ts.SourceFile): ReferenceEmitResult|null {\n     const destSf = getSourceFile(ref.node);\n \n     // Compute the relative path from the importing file to the file being imported. This is done\n     // as a logical path computation, because the two files might be in different rootDirs.\n     const destPath = this.logicalFs.logicalPathOfSf(destSf);\n     if (destPath === null) {\n       // The imported file is not within the logical project filesystem.\n-      return null;\n+      // Note: this error is analogous to `TS6059: File is not under 'rootDir'` that TypeScript\n+      // reports.\n+      return {\n+        kind: ReferenceEmitKind.Failed,\n+        ref,\n+        context,\n+        reason: `The file ${destSf.fileName} is outside of the configured 'rootDir'.`,\n+      };\n     }\n \n     const originPath = this.logicalFs.logicalPathOfSf(context);\n@@ -309,13 +387,19 @@ export class LogicalProjectStrategy implements ReferenceEmitStrategy {\n     const name = findExportedNameOfNode(ref.node, destSf, this.reflector);\n     if (name === null) {\n       // The target declaration isn't exported from the file it's declared in. This is an issue!\n-      return null;\n+      return {\n+        kind: ReferenceEmitKind.Failed,\n+        ref,\n+        context,\n+        reason: `The symbol is not exported from ${destSf.fileName}.`,\n+      };\n     }\n \n     // With both files expressed as LogicalProjectPaths, getting the module specifier as a relative\n     // path is now straightforward.\n     const moduleName = LogicalProjectPath.relativePathBetween(originPath, destPath);\n     return {\n+      kind: ReferenceEmitKind.Success,\n       expression: new ExternalExpr({moduleName, name}),\n       importedFile: destSf,\n     };\n@@ -331,14 +415,26 @@ export class LogicalProjectStrategy implements ReferenceEmitStrategy {\n export class RelativePathStrategy implements ReferenceEmitStrategy {\n   constructor(private reflector: ReflectionHost) {}\n \n-  emit(ref: Reference, context: ts.SourceFile): EmittedReference|null {\n+  emit(ref: Reference, context: ts.SourceFile): ReferenceEmitResult|null {\n     const destSf = getSourceFile(ref.node);\n     const relativePath =\n         relative(dirname(absoluteFromSourceFile(context)), absoluteFromSourceFile(destSf));\n     const moduleName = toRelativeImport(stripExtension(relativePath));\n \n     const name = findExportedNameOfNode(ref.node, destSf, this.reflector);\n-    return {expression: new ExternalExpr({moduleName, name}), importedFile: destSf};\n+    if (name === null) {\n+      return {\n+        kind: ReferenceEmitKind.Failed,\n+        ref,\n+        context,\n+        reason: `The symbol is not exported from ${destSf.fileName}.`,\n+      };\n+    }\n+    return {\n+      kind: ReferenceEmitKind.Success,\n+      expression: new ExternalExpr({moduleName, name}),\n+      importedFile: destSf,\n+    };\n   }\n }\n \n@@ -360,6 +456,7 @@ export class UnifiedModulesStrategy implements ReferenceEmitStrategy {\n         this.unifiedModulesHost.fileNameToModuleName(destSf.fileName, context.fileName);\n \n     return {\n+      kind: ReferenceEmitKind.Success,\n       expression: new ExternalExpr({moduleName, name}),\n       importedFile: destSf,\n     };"
        },
        {
            "sha": "61214cee43e2d41b35d90f67d3eb1dc6aaa96e16",
            "filename": "packages/compiler-cli/src/ngtsc/imports/src/find_export.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 27,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Fsrc%2Ffind_export.ts",
            "raw_url": "https://github.com/angular/angular/raw/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Fsrc%2Ffind_export.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Fsrc%2Ffind_export.ts?ref=7052e27677b9213009e99d34c8cfc013fd0552de",
            "patch": "@@ -7,6 +7,7 @@\n  */\n \n import ts from 'typescript';\n+\n import {ReflectionHost} from '../../reflection';\n import {isNamedDeclaration} from '../../util/src/typescript';\n \n@@ -36,32 +37,5 @@ export function findExportedNameOfNode(\n \n     foundExportName = exportName;\n   }\n-\n-  if (foundExportName === null) {\n-    throw new Error(\n-        `Failed to find exported name of node (${target.getText()}) in '${file.fileName}'.`);\n-  }\n   return foundExportName;\n }\n-\n-/**\n- * Check whether a given `ts.Symbol` represents a declaration of a given node.\n- *\n- * This is not quite as trivial as just checking the declarations, as some nodes are\n- * `ts.ExportSpecifier`s and need to be unwrapped.\n- */\n-function symbolDeclaresNode(sym: ts.Symbol, node: ts.Node, checker: ts.TypeChecker): boolean {\n-  if (sym.declarations === undefined) {\n-    return false;\n-  }\n-\n-  return sym.declarations.some(decl => {\n-    if (ts.isExportSpecifier(decl)) {\n-      const exportedSymbol = checker.getExportSpecifierLocalTargetSymbol(decl);\n-      if (exportedSymbol !== undefined) {\n-        return symbolDeclaresNode(exportedSymbol, node, checker);\n-      }\n-    }\n-    return decl === node;\n-  });\n-}"
        },
        {
            "sha": "fc58e5a6ace337a4ee60dc027479d7d957b296ca",
            "filename": "packages/compiler-cli/src/ngtsc/imports/test/emitter_spec.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 8,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Ftest%2Femitter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Ftest%2Femitter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Ftest%2Femitter_spec.ts?ref=7052e27677b9213009e99d34c8cfc013fd0552de",
            "patch": "@@ -7,13 +7,13 @@\n  */\n import {ExternalExpr} from '@angular/compiler';\n import ts from 'typescript';\n-import {UnifiedModulesHost} from '../../core/api';\n \n+import {UnifiedModulesHost} from '../../core/api';\n import {absoluteFrom as _, basename, LogicalFileSystem} from '../../file_system';\n import {runInEachFileSystem, TestFile} from '../../file_system/testing';\n import {Declaration, TypeScriptReflectionHost} from '../../reflection';\n import {getDeclaration, makeProgram} from '../../testing';\n-import {AbsoluteModuleStrategy, ImportFlags, LogicalProjectStrategy, RelativePathStrategy, UnifiedModulesStrategy} from '../src/emitter';\n+import {AbsoluteModuleStrategy, ImportFlags, LogicalProjectStrategy, ReferenceEmitKind, RelativePathStrategy, UnifiedModulesStrategy} from '../src/emitter';\n import {Reference} from '../src/references';\n import {ModuleResolver} from '../src/resolver';\n \n@@ -75,7 +75,7 @@ runInEachFileSystem(() => {\n         resolutionContext: context.fileName,\n       });\n       const emitted = strategy.emit(reference, context, ImportFlags.None);\n-      if (emitted === null) {\n+      if (emitted === null || emitted.kind !== ReferenceEmitKind.Success) {\n         return fail('Reference should be emitted');\n       }\n       if (!(emitted.expression instanceof ExternalExpr)) {\n@@ -108,7 +108,7 @@ runInEachFileSystem(() => {\n         resolutionContext: context.fileName,\n       });\n       const emitted = strategy.emit(reference, context, ImportFlags.None);\n-      if (emitted === null) {\n+      if (emitted === null || emitted.kind !== ReferenceEmitKind.Success) {\n         return fail('Reference should be emitted');\n       }\n       if (!(emitted.expression instanceof ExternalExpr)) {\n@@ -160,7 +160,7 @@ runInEachFileSystem(() => {\n       const reference =\n           new Reference(decl, {specifier: 'external', resolutionContext: context.fileName});\n       const emitted = strategy.emit(reference, context, ImportFlags.AllowTypeImports);\n-      if (emitted === null) {\n+      if (emitted === null || emitted.kind !== ReferenceEmitKind.Success) {\n         return fail('Reference should be emitted');\n       }\n       if (!(emitted.expression instanceof ExternalExpr)) {\n@@ -204,7 +204,9 @@ runInEachFileSystem(() => {\n       const decl = getDeclaration(program, _('/index.ts'), 'Foo', ts.isClassDeclaration);\n       const context = program.getSourceFile(_('/context.ts'))!;\n       const ref = strategy.emit(new Reference(decl), context);\n-      expect(ref).not.toBeNull();\n+      if (ref === null || ref.kind !== ReferenceEmitKind.Success) {\n+        return fail('Reference should be emitted');\n+      }\n \n       // Expect the prefixed name from the TestHost.\n       expect((ref!.expression as ExternalExpr).value.name).toEqual('testFoo');\n@@ -232,7 +234,7 @@ runInEachFileSystem(() => {\n       const decl = getDeclaration(program, _('/index.ts'), 'Foo', ts.isClassDeclaration);\n       const context = program.getSourceFile(_('/context.ts'))!;\n       const emitted = strategy.emit(new Reference(decl), context);\n-      if (emitted === null) {\n+      if (emitted === null || emitted.kind !== ReferenceEmitKind.Success) {\n         return fail('Reference should be emitted');\n       }\n       if (!(emitted.expression instanceof ExternalExpr)) {\n@@ -265,7 +267,7 @@ runInEachFileSystem(() => {\n       const decl = getDeclaration(program, _('/index.ts'), 'Foo', ts.isClassDeclaration);\n       const context = program.getSourceFile(_('/context.ts'))!;\n       const emitted = strategy.emit(new Reference(decl), context);\n-      if (emitted === null) {\n+      if (emitted === null || emitted.kind !== ReferenceEmitKind.Success) {\n         return fail('Reference should be emitted');\n       }\n       if (!(emitted.expression instanceof ExternalExpr)) {"
        },
        {
            "sha": "3bc5cdda23283a38dc34ae753de5b0c9dedf36aa",
            "filename": "packages/compiler-cli/src/ngtsc/scope/src/local.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fscope%2Fsrc%2Flocal.ts",
            "raw_url": "https://github.com/angular/angular/raw/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fscope%2Fsrc%2Flocal.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fscope%2Fsrc%2Flocal.ts?ref=7052e27677b9213009e99d34c8cfc013fd0552de",
            "patch": "@@ -10,7 +10,7 @@ import {ExternalExpr, SchemaMetadata} from '@angular/compiler';\n import ts from 'typescript';\n \n import {ErrorCode, makeDiagnostic, makeRelatedInformation} from '../../diagnostics';\n-import {AliasingHost, Reexport, Reference, ReferenceEmitter} from '../../imports';\n+import {AliasingHost, assertSuccessfulReferenceEmit, Reexport, Reference, ReferenceEmitter} from '../../imports';\n import {DirectiveMeta, MetadataReader, MetadataRegistry, NgModuleMeta, PipeMeta} from '../../metadata';\n import {ClassDeclaration, DeclarationNode} from '../../reflection';\n import {identifierOfNode, nodeNameForError} from '../../util/src/typescript';\n@@ -511,8 +511,9 @@ export class LocalModuleScopeRegistry implements MetadataRegistry, ComponentScop\n             asAlias: exportName,\n           });\n         } else {\n-          const expr =\n-              this.refEmitter.emit(exportRef.cloneWithNoIdentifiers(), sourceFile).expression;\n+          const emittedRef = this.refEmitter.emit(exportRef.cloneWithNoIdentifiers(), sourceFile);\n+          assertSuccessfulReferenceEmit(emittedRef, ngModuleRef.node.name, 'class');\n+          const expr = emittedRef.expression;\n           if (!(expr instanceof ExternalExpr) || expr.value.moduleName === null ||\n               expr.value.name === null) {\n             throw new Error('Expected ExternalExpr');"
        },
        {
            "sha": "0995cffe968066c7cdd90a0c525fc157f42965d0",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/environment.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts",
            "raw_url": "https://github.com/angular/angular/raw/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts?ref=7052e27677b9213009e99d34c8cfc013fd0552de",
            "patch": "@@ -9,7 +9,7 @@\n import {ExpressionType, ExternalExpr, Type, WrappedNodeExpr} from '@angular/compiler';\n import ts from 'typescript';\n \n-import {ImportFlags, Reference, ReferenceEmitter} from '../../imports';\n+import {assertSuccessfulReferenceEmit, ImportFlags, Reference, ReferenceEmitter} from '../../imports';\n import {ClassDeclaration, ReflectionHost} from '../../reflection';\n import {ImportManager, translateExpression, translateType} from '../../translator';\n import {TypeCheckableDirectiveMeta, TypeCheckingConfig, TypeCtorMetadata} from '../api';\n@@ -121,6 +121,7 @@ export class Environment {\n     // in these cases as there is no strict dependency checking during the template type-checking\n     // pass.\n     const ngExpr = this.refEmitter.emit(ref, this.contextFile, ImportFlags.NoAliasing);\n+    assertSuccessfulReferenceEmit(ngExpr, this.contextFile, 'class');\n \n     // Use `translateExpression` to convert the `Expression` into a `ts.Expression`.\n     return translateExpression(ngExpr.expression, this.importManager);\n@@ -134,6 +135,7 @@ export class Environment {\n   referenceType(ref: Reference): ts.TypeNode {\n     const ngExpr = this.refEmitter.emit(\n         ref, this.contextFile, ImportFlags.NoAliasing | ImportFlags.AllowTypeImports);\n+    assertSuccessfulReferenceEmit(ngExpr, this.contextFile, 'symbol');\n \n     // Create an `ExpressionType` from the `Expression` and translate it via `translateType`.\n     // TODO(alxhub): support references to types with generic arguments in a clean way."
        },
        {
            "sha": "cc3d7cbc428e4717adc9eccad2d3f7908e39638e",
            "filename": "packages/compiler-cli/test/ngtsc/imports_spec.ts",
            "status": "added",
            "additions": 119,
            "deletions": 0,
            "changes": 119,
            "blob_url": "https://github.com/angular/angular/blob/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fimports_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/7052e27677b9213009e99d34c8cfc013fd0552de/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fimports_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fimports_spec.ts?ref=7052e27677b9213009e99d34c8cfc013fd0552de",
            "patch": "@@ -0,0 +1,119 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import ts from 'typescript';\n+\n+import {absoluteFrom} from '../../src/ngtsc/file_system';\n+import {runInEachFileSystem} from '../../src/ngtsc/file_system/testing';\n+import {loadStandardTestFiles} from '../../src/ngtsc/testing';\n+\n+import {NgtscTestEnvironment} from './env';\n+\n+const testFiles = loadStandardTestFiles();\n+\n+runInEachFileSystem(() => {\n+  describe('import generation', () => {\n+    let env!: NgtscTestEnvironment;\n+\n+    beforeEach(() => {\n+      env = NgtscTestEnvironment.setup(testFiles, absoluteFrom('/app'));\n+      const tsconfig: {[key: string]: any} = {\n+        extends: '../tsconfig-base.json',\n+        compilerOptions: {\n+          baseUrl: '.',\n+          rootDirs: ['/app'],\n+        },\n+        angularCompilerOptions: {},\n+      };\n+      env.write('tsconfig.json', JSON.stringify(tsconfig, null, 2));\n+    });\n+\n+    it('should report an error when using a directive outside of rootDirs', () => {\n+      env.write('/app/module.ts', `\n+        import {NgModule} from '@angular/core';\n+        import {ExternalDir} from '../lib/dir';\n+        import {MyComponent} from './comp';\n+\n+        @NgModule({\n+          declarations: [ExternalDir, MyComponent],\n+        })\n+        export class MyModule {}\n+      `);\n+      env.write('/app/comp.ts', `\n+        import {Component} from '@angular/core';\n+\n+        @Component({\n+          template: '<div external></div>',\n+        })\n+        export class MyComponent {}\n+      `);\n+      env.write('/lib/dir.ts', `\n+        import {Directive} from '@angular/core';\n+\n+        @Directive({selector: '[external]'})\n+        export class ExternalDir {}\n+      `);\n+\n+      const diags = env.driveDiagnostics();\n+      expect(diags.length).toBe(1);\n+      expect(ts.flattenDiagnosticMessageText(diags[0].messageText, '\\n'))\n+          .toEqual(`Unable to import class ExternalDir.\n+  The file ${absoluteFrom('/lib/dir.ts')} is outside of the configured 'rootDir'.`);\n+      expect(diags[0].file!.fileName).toEqual(absoluteFrom('/app/module.ts'));\n+      expect(getDiagnosticSourceCode(diags[0])).toEqual('ExternalDir');\n+    });\n+\n+    it('should report an error when a library entry-point does not export the symbol', () => {\n+      env.write('/app/module.ts', `\n+        import {NgModule} from '@angular/core';\n+        import {ExternalModule} from 'lib';\n+        import {MyComponent} from './comp';\n+\n+        @NgModule({\n+          imports: [ExternalModule],\n+          declarations: [MyComponent],\n+        })\n+        export class MyModule {}\n+      `);\n+      env.write('/app/comp.ts', `\n+        import {Component} from '@angular/core';\n+\n+        @Component({\n+          template: '<div external></div>',\n+        })\n+        export class MyComponent {}\n+      `);\n+      env.write('/node_modules/lib/index.d.ts', `\n+        import {NgModuleDeclaration} from '@angular/core';\n+        import {ExternalDir} from './dir';\n+\n+        export class ExternalModule {\n+          static mod: NgModuleDeclaration<ExternalModule, [typeof ExternalDir], never, [typeof ExternalDir]>;\n+        }\n+      `);\n+      env.write('/node_modules/lib/dir.d.ts', `\n+        import {DirectiveDeclaration} from '@angular/core';\n+\n+        export class ExternalDir {\n+          static dir: DirectiveDeclaration<ExternalDir, '[external]', never, never, never, never>;\n+        }\n+      `);\n+\n+      const diags = env.driveDiagnostics();\n+      expect(diags.length).toBe(1);\n+      expect(ts.flattenDiagnosticMessageText(diags[0].messageText, '\\n'))\n+          .toEqual(`Unable to import directive ExternalDir.\n+  The symbol is not exported from ${absoluteFrom('/node_modules/lib/index.d.ts')} (module 'lib').`);\n+      expect(diags[0].file!.fileName).toEqual(absoluteFrom('/app/comp.ts'));\n+      expect(getDiagnosticSourceCode(diags[0])).toEqual('MyComponent');\n+    });\n+  });\n+});\n+\n+function getDiagnosticSourceCode(diag: ts.Diagnostic): string {\n+  return diag.file!.text.substring(diag.start!, diag.start! + diag.length!);\n+}"
        }
    ],
    "stats": {
        "total": 418,
        "additions": 330,
        "deletions": 88
    }
}