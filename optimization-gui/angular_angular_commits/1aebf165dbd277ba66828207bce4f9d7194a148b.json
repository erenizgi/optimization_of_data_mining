{
    "author": "crisbeto",
    "message": "fix(common): viewport scroller not finding elements inside the shadow DOM (#41644)\n\nThe `ViewportScroller` figures out which element to scroll into view using `document.getElementById`. The problem is that it won't find elements inside the shadow DOM.\n\nThese changes add some extra logic that goes through all the shadow roots to look for the element.\n\nFixes #41470.\n\nPR Close #41644",
    "sha": "1aebf165dbd277ba66828207bce4f9d7194a148b",
    "files": [
        {
            "sha": "69b97318426ee58fe3e405973cbec2a8c3be0f46",
            "filename": "packages/common/src/viewport_scroller.ts",
            "status": "modified",
            "additions": 41,
            "deletions": 9,
            "changes": 50,
            "blob_url": "https://github.com/angular/angular/blob/1aebf165dbd277ba66828207bce4f9d7194a148b/packages%2Fcommon%2Fsrc%2Fviewport_scroller.ts",
            "raw_url": "https://github.com/angular/angular/raw/1aebf165dbd277ba66828207bce4f9d7194a148b/packages%2Fcommon%2Fsrc%2Fviewport_scroller.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Fsrc%2Fviewport_scroller.ts?ref=1aebf165dbd277ba66828207bce4f9d7194a148b",
            "patch": "@@ -123,16 +123,14 @@ export class BrowserViewportScroller implements ViewportScroller {\n     // TODO(atscott): The correct behavior for `getElementsByName` would be to also verify that the\n     // element is an anchor. However, this could be considered a breaking change and should be\n     // done in a major version.\n-    const elSelected: HTMLElement|undefined =\n-        this.document.getElementById(target) ?? this.document.getElementsByName(target)[0];\n-    if (elSelected === undefined) {\n-      return;\n-    }\n+    const elSelected = findAnchorFromDocument(this.document, target);\n \n-    this.scrollToElement(elSelected);\n-    // After scrolling to the element, the spec dictates that we follow the focus steps for the\n-    // target. Rather than following the robust steps, simply attempt focus.\n-    this.attemptFocus(elSelected);\n+    if (elSelected) {\n+      this.scrollToElement(elSelected);\n+      // After scrolling to the element, the spec dictates that we follow the focus steps for the\n+      // target. Rather than following the robust steps, simply attempt focus.\n+      this.attemptFocus(elSelected);\n+    }\n   }\n \n   /**\n@@ -214,6 +212,40 @@ function getScrollRestorationProperty(obj: any): PropertyDescriptor|undefined {\n   return Object.getOwnPropertyDescriptor(obj, 'scrollRestoration');\n }\n \n+function findAnchorFromDocument(document: Document, target: string): HTMLElement|null {\n+  const documentResult = document.getElementById(target) || document.getElementsByName(target)[0];\n+\n+  if (documentResult) {\n+    return documentResult;\n+  }\n+\n+  // `getElementById` and `getElementsByName` won't pierce through the shadow DOM so we\n+  // have to traverse the DOM manually and do the lookup through the shadow roots.\n+  if (typeof document.createTreeWalker === 'function' && document.body &&\n+      ((document.body as any).createShadowRoot || document.body.attachShadow)) {\n+    const treeWalker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT);\n+    let currentNode = treeWalker.currentNode as HTMLElement | null;\n+\n+    while (currentNode) {\n+      const shadowRoot = currentNode.shadowRoot;\n+\n+      if (shadowRoot) {\n+        // Note that `ShadowRoot` doesn't support `getElementsByName`\n+        // so we have to fall back to `querySelector`.\n+        const result =\n+            shadowRoot.getElementById(target) || shadowRoot.querySelector(`[name=\"${target}\"]`);\n+        if (result) {\n+          return result;\n+        }\n+      }\n+\n+      currentNode = treeWalker.nextNode() as HTMLElement | null;\n+    }\n+  }\n+\n+  return null;\n+}\n+\n /**\n  * Provides an empty implementation of the viewport scroller.\n  */"
        },
        {
            "sha": "68c0518e36272a5e2a86005d3e88d7ecf3f59f93",
            "filename": "packages/common/test/viewport_scroller_spec.ts",
            "status": "modified",
            "additions": 78,
            "deletions": 18,
            "changes": 96,
            "blob_url": "https://github.com/angular/angular/blob/1aebf165dbd277ba66828207bce4f9d7194a148b/packages%2Fcommon%2Ftest%2Fviewport_scroller_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/1aebf165dbd277ba66828207bce4f9d7194a148b/packages%2Fcommon%2Ftest%2Fviewport_scroller_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Ftest%2Fviewport_scroller_spec.ts?ref=1aebf165dbd277ba66828207bce4f9d7194a148b",
            "patch": "@@ -7,6 +7,7 @@\n  */\n \n import {describe, expect, it} from '@angular/core/testing/src/testing_internal';\n+import {browserDetection} from '@angular/platform-browser/testing/src/browser_util';\n import {BrowserViewportScroller, ViewportScroller} from '../src/viewport_scroller';\n \n describe('BrowserViewportScroller', () => {\n@@ -44,44 +45,103 @@ describe('BrowserViewportScroller', () => {\n     // Testing scroll behavior does not make sense outside a browser\n     if (isNode) return;\n     const anchor = 'anchor';\n-    let tallItem: HTMLDivElement;\n-    let el: HTMLAnchorElement;\n     let scroller: BrowserViewportScroller;\n \n     beforeEach(() => {\n       scroller = new BrowserViewportScroller(document, window);\n       scroller.scrollToPosition([0, 0]);\n-\n-      tallItem = document.createElement('div');\n-      tallItem.style.height = '3000px';\n-      document.body.appendChild(tallItem);\n-\n-      el = document.createElement('a');\n-      el.innerText = 'some link';\n-      el.href = '#';\n-      document.body.appendChild(el);\n-    });\n-\n-    afterEach(() => {\n-      document.body.removeChild(tallItem);\n-      document.body.removeChild(el);\n     });\n \n     it('should scroll when element with matching id is found', () => {\n-      el.id = anchor;\n+      const {anchorNode, cleanup} = createTallElement();\n+      anchorNode.id = anchor;\n       scroller.scrollToAnchor(anchor);\n       expect(scroller.getScrollPosition()[1]).not.toEqual(0);\n+      cleanup();\n     });\n \n     it('should scroll when anchor with matching name is found', () => {\n-      el.name = anchor;\n+      const {anchorNode, cleanup} = createTallElement();\n+      anchorNode.name = anchor;\n       scroller.scrollToAnchor(anchor);\n       expect(scroller.getScrollPosition()[1]).not.toEqual(0);\n+      cleanup();\n     });\n \n     it('should not scroll when no matching element is found', () => {\n+      const {cleanup} = createTallElement();\n       scroller.scrollToAnchor(anchor);\n       expect(scroller.getScrollPosition()[1]).toEqual(0);\n+      cleanup();\n     });\n+\n+    it('should scroll when element with matching id is found inside the shadow DOM', () => {\n+      // This test is only relevant for browsers that support shadow DOM.\n+      if (!browserDetection.supportsShadowDom) {\n+        return;\n+      }\n+\n+      const {anchorNode, cleanup} = createTallElementWithShadowRoot();\n+      anchorNode.id = anchor;\n+      scroller.scrollToAnchor(anchor);\n+      expect(scroller.getScrollPosition()[1]).not.toEqual(0);\n+      cleanup();\n+    });\n+\n+    it('should scroll when anchor with matching name is found inside the shadow DOM', () => {\n+      // This test is only relevant for browsers that support shadow DOM.\n+      if (!browserDetection.supportsShadowDom) {\n+        return;\n+      }\n+\n+      const {anchorNode, cleanup} = createTallElementWithShadowRoot();\n+      anchorNode.name = anchor;\n+      scroller.scrollToAnchor(anchor);\n+      expect(scroller.getScrollPosition()[1]).not.toEqual(0);\n+      cleanup();\n+    });\n+\n+    function createTallElement() {\n+      const tallItem = document.createElement('div');\n+      tallItem.style.height = '3000px';\n+      document.body.appendChild(tallItem);\n+      const anchorNode = createAnchorNode();\n+      document.body.appendChild(anchorNode);\n+\n+      return {\n+        anchorNode,\n+        cleanup: () => {\n+          document.body.removeChild(tallItem);\n+          document.body.removeChild(anchorNode);\n+        }\n+      };\n+    }\n+\n+    function createTallElementWithShadowRoot() {\n+      const tallItem = document.createElement('div');\n+      tallItem.style.height = '3000px';\n+      document.body.appendChild(tallItem);\n+\n+      const elementWithShadowRoot = document.createElement('div');\n+      const shadowRoot = elementWithShadowRoot.attachShadow({mode: 'open'});\n+      const anchorNode = createAnchorNode();\n+      shadowRoot.appendChild(anchorNode);\n+      document.body.appendChild(elementWithShadowRoot);\n+\n+      return {\n+        anchorNode,\n+        cleanup: () => {\n+          document.body.removeChild(tallItem);\n+          document.body.removeChild(elementWithShadowRoot);\n+        }\n+      };\n+    }\n+\n+    function createAnchorNode() {\n+      const anchorNode = document.createElement('a');\n+      anchorNode.innerText = 'some link';\n+      anchorNode.href = '#';\n+      return anchorNode;\n+    }\n   });\n });"
        }
    ],
    "stats": {
        "total": 146,
        "additions": 119,
        "deletions": 27
    }
}