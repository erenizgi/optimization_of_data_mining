{
    "author": "petebacondarwin",
    "message": "refactor(compiler): tidy up interpolation splitting (#39717)\n\nWhen parsing for i18n messages, interpolated strings are\nsplit into `Text` and `Placeholder` pieces.  The method that\ndoes this `_visitTextWithInterpolation()` was becoming too\ncomplex. This commit refactors that method along with some\nassociated functions that it uses.\n\nPR Close #39717",
    "sha": "969ad329de01c2287e99aac16bb94d21b66d1fb0",
    "files": [
        {
            "sha": "e87c2c3b61eee3622d7f57941234d6456cbe8697",
            "filename": "packages/compiler/src/expression_parser/parser.ts",
            "status": "modified",
            "additions": 40,
            "deletions": 40,
            "changes": 80,
            "blob_url": "https://github.com/angular/angular/blob/969ad329de01c2287e99aac16bb94d21b66d1fb0/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "raw_url": "https://github.com/angular/angular/raw/969ad329de01c2287e99aac16bb94d21b66d1fb0/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts?ref=969ad329de01c2287e99aac16bb94d21b66d1fb0",
            "patch": "@@ -13,10 +13,14 @@ import {escapeRegExp} from '../util';\n import {AbsoluteSourceSpan, AST, AstVisitor, ASTWithSource, Binary, BindingPipe, Chain, Conditional, EmptyExpr, ExpressionBinding, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralMapKey, LiteralPrimitive, MethodCall, NonNullAssert, ParserError, ParseSpan, PrefixNot, PropertyRead, PropertyWrite, Quote, RecursiveAstVisitor, SafeMethodCall, SafePropertyRead, TemplateBinding, TemplateBindingIdentifier, ThisReceiver, Unary, VariableBinding} from './ast';\n import {EOF, isIdentifier, isQuote, Lexer, Token, TokenType} from './lexer';\n \n+export interface InterpolationPiece {\n+  text: string;\n+  start: number;\n+  end: number;\n+}\n export class SplitInterpolation {\n   constructor(\n-      public strings: string[], public stringSpans: {start: number, end: number}[],\n-      public expressions: string[], public expressionsSpans: {start: number, end: number}[],\n+      public strings: InterpolationPiece[], public expressions: InterpolationPiece[],\n       public offsets: number[]) {}\n }\n \n@@ -48,7 +52,7 @@ export class Parser {\n   simpleExpressionChecker = SimpleExpressionChecker;\n \n   parseAction(\n-      input: string, location: any, absoluteOffset: number,\n+      input: string, location: string, absoluteOffset: number,\n       interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n     this._checkNoInterpolation(input, location, interpolationConfig);\n     const sourceToLex = this._stripComments(input);\n@@ -61,7 +65,7 @@ export class Parser {\n   }\n \n   parseBinding(\n-      input: string, location: any, absoluteOffset: number,\n+      input: string, location: string, absoluteOffset: number,\n       interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n     const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n     return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n@@ -85,7 +89,7 @@ export class Parser {\n     return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n   }\n \n-  private _reportError(message: string, input: string, errLocation: string, ctxLocation?: any) {\n+  private _reportError(message: string, input: string, errLocation: string, ctxLocation?: string) {\n     this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n   }\n \n@@ -109,7 +113,7 @@ export class Parser {\n         .parseChain();\n   }\n \n-  private _parseQuote(input: string|null, location: any, absoluteOffset: number): AST|null {\n+  private _parseQuote(input: string|null, location: string, absoluteOffset: number): AST|null {\n     if (input == null) return null;\n     const prefixSeparatorIndex = input.indexOf(':');\n     if (prefixSeparatorIndex == -1) return null;\n@@ -161,33 +165,35 @@ export class Parser {\n   }\n \n   parseInterpolation(\n-      input: string, location: any, absoluteOffset: number,\n+      input: string, location: string, absoluteOffset: number,\n       interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource|null {\n-    const split = this.splitInterpolation(input, location, interpolationConfig);\n-    if (split == null) return null;\n+    const {strings, expressions, offsets} =\n+        this.splitInterpolation(input, location, interpolationConfig);\n+    if (expressions.length === 0) return null;\n \n-    const expressions: AST[] = [];\n+    const expressionNodes: AST[] = [];\n \n-    for (let i = 0; i < split.expressions.length; ++i) {\n-      const expressionText = split.expressions[i];\n+    for (let i = 0; i < expressions.length; ++i) {\n+      const expressionText = expressions[i].text;\n       const sourceToLex = this._stripComments(expressionText);\n       const tokens = this._lexer.tokenize(sourceToLex);\n       const ast = new _ParseAST(\n                       input, location, absoluteOffset, tokens, sourceToLex.length, false,\n-                      this.errors, split.offsets[i] + (expressionText.length - sourceToLex.length))\n+                      this.errors, offsets[i] + (expressionText.length - sourceToLex.length))\n                       .parseChain();\n-      expressions.push(ast);\n+      expressionNodes.push(ast);\n     }\n \n-    return this.createInterpolationAst(split.strings, expressions, input, location, absoluteOffset);\n+    return this.createInterpolationAst(\n+        strings.map(s => s.text), expressionNodes, input, location, absoluteOffset);\n   }\n \n   /**\n    * Similar to `parseInterpolation`, but treats the provided string as a single expression\n    * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n    * This is used for parsing the switch expression in ICUs.\n    */\n-  parseInterpolationExpression(expression: string, location: any, absoluteOffset: number):\n+  parseInterpolationExpression(expression: string, location: string, absoluteOffset: number):\n       ASTWithSource {\n     const sourceToLex = this._stripComments(expression);\n     const tokens = this._lexer.tokenize(sourceToLex);\n@@ -217,13 +223,10 @@ export class Parser {\n    */\n   splitInterpolation(\n       input: string, location: string,\n-      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): SplitInterpolation\n-      |null {\n-    const strings: string[] = [];\n-    const expressions: string[] = [];\n+      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): SplitInterpolation {\n+    const strings: InterpolationPiece[] = [];\n+    const expressions: InterpolationPiece[] = [];\n     const offsets: number[] = [];\n-    const stringSpans: {start: number, end: number}[] = [];\n-    const expressionSpans: {start: number, end: number}[] = [];\n     let i = 0;\n     let atInterpolation = false;\n     let extendLastString = false;\n@@ -236,9 +239,8 @@ export class Parser {\n         if (i === -1) {\n           i = input.length;\n         }\n-        const part = input.substring(start, i);\n-        strings.push(part);\n-        stringSpans.push({start, end: i});\n+        const text = input.substring(start, i);\n+        strings.push({text, start, end: i});\n \n         atInterpolation = true;\n       } else {\n@@ -255,17 +257,16 @@ export class Parser {\n         }\n         const fullEnd = exprEnd + interpEnd.length;\n \n-        const part = input.substring(exprStart, exprEnd);\n-        if (part.trim().length > 0) {\n-          expressions.push(part);\n+        const text = input.substring(exprStart, exprEnd);\n+        if (text.trim().length > 0) {\n+          expressions.push({text, start: fullStart, end: fullEnd});\n         } else {\n           this._reportError(\n               'Blank expressions are not allowed in interpolated strings', input,\n               `at column ${i} in`, location);\n-          expressions.push('$implicit');\n+          expressions.push({text: '$implicit', start: fullStart, end: fullEnd});\n         }\n         offsets.push(exprStart);\n-        expressionSpans.push({start: fullStart, end: fullEnd});\n \n         i = fullEnd;\n         atInterpolation = false;\n@@ -274,19 +275,18 @@ export class Parser {\n     if (!atInterpolation) {\n       // If we are now at a text section, add the remaining content as a raw string.\n       if (extendLastString) {\n-        strings[strings.length - 1] += input.substring(i);\n-        stringSpans[stringSpans.length - 1].end = input.length;\n+        const piece = strings[strings.length - 1];\n+        piece.text += input.substring(i);\n+        piece.end = input.length;\n       } else {\n-        strings.push(input.substring(i));\n-        stringSpans.push({start: i, end: input.length});\n+        strings.push({text: input.substring(i), start: i, end: input.length});\n       }\n     }\n-    return expressions.length === 0 ?\n-        null :\n-        new SplitInterpolation(strings, stringSpans, expressions, expressionSpans, offsets);\n+    return new SplitInterpolation(strings, expressions, offsets);\n   }\n \n-  wrapLiteralPrimitive(input: string|null, location: any, absoluteOffset: number): ASTWithSource {\n+  wrapLiteralPrimitive(input: string|null, location: string, absoluteOffset: number):\n+      ASTWithSource {\n     const span = new ParseSpan(0, input == null ? 0 : input.length);\n     return new ASTWithSource(\n         new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location,\n@@ -316,7 +316,7 @@ export class Parser {\n   }\n \n   private _checkNoInterpolation(\n-      input: string, location: any, interpolationConfig: InterpolationConfig): void {\n+      input: string, location: string, interpolationConfig: InterpolationConfig): void {\n     const regexp = _getInterpolateRegExp(interpolationConfig);\n     const parts = input.split(regexp);\n     if (parts.length > 1) {\n@@ -374,7 +374,7 @@ export class _ParseAST {\n   index: number = 0;\n \n   constructor(\n-      public input: string, public location: any, public absoluteOffset: number,\n+      public input: string, public location: string, public absoluteOffset: number,\n       public tokens: Token[], public inputLength: number, public parseAction: boolean,\n       private errors: ParserError[], private offset: number) {}\n "
        },
        {
            "sha": "67791e7c7b03088c586c61b93b12cc568e7a1ed0",
            "filename": "packages/compiler/src/i18n/i18n_parser.ts",
            "status": "modified",
            "additions": 95,
            "deletions": 51,
            "changes": 146,
            "blob_url": "https://github.com/angular/angular/blob/969ad329de01c2287e99aac16bb94d21b66d1fb0/packages%2Fcompiler%2Fsrc%2Fi18n%2Fi18n_parser.ts",
            "raw_url": "https://github.com/angular/angular/raw/969ad329de01c2287e99aac16bb94d21b66d1fb0/packages%2Fcompiler%2Fsrc%2Fi18n%2Fi18n_parser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fi18n%2Fi18n_parser.ts?ref=969ad329de01c2287e99aac16bb94d21b66d1fb0",
            "patch": "@@ -7,7 +7,7 @@\n  */\n \n import {Lexer as ExpressionLexer} from '../expression_parser/lexer';\n-import {Parser as ExpressionParser} from '../expression_parser/parser';\n+import {InterpolationPiece, Parser as ExpressionParser} from '../expression_parser/parser';\n import * as html from '../ml_parser/ast';\n import {getHtmlTagDefinition} from '../ml_parser/html_tags';\n import {InterpolationConfig} from '../ml_parser/interpolation_config';\n@@ -156,73 +156,110 @@ class _I18nVisitor implements html.Visitor {\n     throw new Error('Unreachable code');\n   }\n \n+  /**\n+   * Split the, potentially interpolated, text up into text and placeholder pieces.\n+   *\n+   * @param text The potentially interpolated string to be split.\n+   * @param sourceSpan The span of the whole of the `text` string.\n+   * @param context The current context of the visitor, used to compute and store placeholders.\n+   * @param previousI18n Any i18n metadata associated with this `text` from a previous pass.\n+   */\n   private _visitTextWithInterpolation(\n       text: string, sourceSpan: ParseSourceSpan, context: I18nMessageVisitorContext,\n       previousI18n: i18n.I18nMeta|undefined): i18n.Node {\n-    const splitInterpolation = this._expressionParser.splitInterpolation(\n+    const {strings, expressions} = this._expressionParser.splitInterpolation(\n         text, sourceSpan.start.toString(), this._interpolationConfig);\n \n-    if (!splitInterpolation) {\n-      // No expression, return a single text\n+    // No expressions, return a single text.\n+    if (expressions.length === 0) {\n       return new i18n.Text(text, sourceSpan);\n     }\n \n-    // Return a group of text + expressions\n+    // Return a sequence of `Text` and `Placeholder` nodes grouped in a `Container`.\n     const nodes: i18n.Node[] = [];\n-    const container = new i18n.Container(nodes, sourceSpan);\n-    const {start: sDelimiter, end: eDelimiter} = this._interpolationConfig;\n-\n-    for (let i = 0; i < splitInterpolation.strings.length - 1; i++) {\n-      const expression = splitInterpolation.expressions[i];\n-      const baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';\n-      const phName = context.placeholderRegistry.getPlaceholderName(baseName, expression);\n-\n-      if (splitInterpolation.strings[i].length) {\n-        // No need to add empty strings\n-        const stringSpan = getOffsetSourceSpan(sourceSpan, splitInterpolation.stringSpans[i]);\n-        nodes.push(new i18n.Text(splitInterpolation.strings[i], stringSpan));\n-      }\n-\n-      const expressionSpan =\n-          getOffsetSourceSpan(sourceSpan, splitInterpolation.expressionsSpans[i]);\n-      nodes.push(new i18n.Placeholder(expression, phName, expressionSpan));\n-      context.placeholderToContent[phName] = {\n-        text: sDelimiter + expression + eDelimiter,\n-        sourceSpan: expressionSpan,\n-      };\n+    for (let i = 0; i < strings.length - 1; i++) {\n+      this._addText(nodes, strings[i], sourceSpan);\n+      this._addPlaceholder(nodes, context, expressions[i], sourceSpan);\n     }\n-\n     // The last index contains no expression\n-    const lastStringIdx = splitInterpolation.strings.length - 1;\n-    if (splitInterpolation.strings[lastStringIdx].length) {\n-      const stringSpan =\n-          getOffsetSourceSpan(sourceSpan, splitInterpolation.stringSpans[lastStringIdx]);\n-      nodes.push(new i18n.Text(splitInterpolation.strings[lastStringIdx], stringSpan));\n-    }\n+    this._addText(nodes, strings[strings.length - 1], sourceSpan);\n \n-    if (previousI18n instanceof i18n.Message) {\n-      // The `previousI18n` is an i18n `Message`, so we are processing an `Attribute` with i18n\n-      // metadata. The `Message` should consist only of a single `Container` that contains the\n-      // parts (`Text` and `Placeholder`) to process.\n-      assertSingleContainerMessage(previousI18n);\n-      previousI18n = previousI18n.nodes[0];\n-    }\n+    // Whitespace removal may have invalidated the interpolation source-spans.\n+    reusePreviousSourceSpans(nodes, previousI18n);\n \n-    if (previousI18n instanceof i18n.Container) {\n-      // The `previousI18n` is a `Container`, which means that this is a second i18n extraction pass\n-      // after whitespace has been removed from the AST ndoes.\n-      assertEquivalentNodes(previousI18n.children, nodes);\n+    return new i18n.Container(nodes, sourceSpan);\n+  }\n \n-      // Reuse the source-spans from the first pass.\n-      for (let i = 0; i < nodes.length; i++) {\n-        nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;\n-      }\n+  /**\n+   * Create a new `Text` node from the `textPiece` and add it to the `nodes` collection.\n+   *\n+   * @param nodes The nodes to which the created `Text` node should be added.\n+   * @param textPiece The text and relative span information for this `Text` node.\n+   * @param interpolationSpan The span of the whole interpolated text.\n+   */\n+  private _addText(\n+      nodes: i18n.Node[], textPiece: InterpolationPiece, interpolationSpan: ParseSourceSpan): void {\n+    if (textPiece.text.length > 0) {\n+      // No need to add empty strings\n+      const stringSpan = getOffsetSourceSpan(interpolationSpan, textPiece);\n+      nodes.push(new i18n.Text(textPiece.text, stringSpan));\n     }\n+  }\n \n-    return container;\n+  /**\n+   * Create a new `Placeholder` node from the `expression` and add it to the `nodes` collection.\n+   *\n+   * @param nodes The nodes to which the created `Text` node should be added.\n+   * @param context The current context of the visitor, used to compute and store placeholders.\n+   * @param expression The expression text and relative span information for this `Placeholder`\n+   *     node.\n+   * @param interpolationSpan The span of the whole interpolated text.\n+   */\n+  private _addPlaceholder(\n+      nodes: i18n.Node[], context: I18nMessageVisitorContext, expression: InterpolationPiece,\n+      interpolationSpan: ParseSourceSpan): void {\n+    const sourceSpan = getOffsetSourceSpan(interpolationSpan, expression);\n+    const baseName = extractPlaceholderName(expression.text) || 'INTERPOLATION';\n+    const phName = context.placeholderRegistry.getPlaceholderName(baseName, expression.text);\n+    const text = this._interpolationConfig.start + expression.text + this._interpolationConfig.end;\n+    context.placeholderToContent[phName] = {text, sourceSpan};\n+    nodes.push(new i18n.Placeholder(expression.text, phName, sourceSpan));\n   }\n }\n \n+/**\n+ * Re-use the source-spans from `previousI18n` metadata for the `nodes`.\n+ *\n+ * Whitespace removal can invalidate the source-spans of interpolation nodes, so we\n+ * reuse the source-span stored from a previous pass before the whitespace was removed.\n+ *\n+ * @param nodes The `Text` and `Placeholder` nodes to be processed.\n+ * @param previousI18n Any i18n metadata for these `nodes` stored from a previous pass.\n+ */\n+function reusePreviousSourceSpans(nodes: i18n.Node[], previousI18n: i18n.I18nMeta|undefined): void {\n+  if (previousI18n instanceof i18n.Message) {\n+    // The `previousI18n` is an i18n `Message`, so we are processing an `Attribute` with i18n\n+    // metadata. The `Message` should consist only of a single `Container` that contains the\n+    // parts (`Text` and `Placeholder`) to process.\n+    assertSingleContainerMessage(previousI18n);\n+    previousI18n = previousI18n.nodes[0];\n+  }\n+\n+  if (previousI18n instanceof i18n.Container) {\n+    // The `previousI18n` is a `Container`, which means that this is a second i18n extraction pass\n+    // after whitespace has been removed from the AST ndoes.\n+    assertEquivalentNodes(previousI18n.children, nodes);\n+\n+    // Reuse the source-spans from the first pass.\n+    for (let i = 0; i < nodes.length; i++) {\n+      nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;\n+    }\n+  }\n+}\n+\n+/**\n+ * Asserts that the `message` contains exactly one `Container` node.\n+ */\n function assertSingleContainerMessage(message: i18n.Message): void {\n   const nodes = message.nodes;\n   if (nodes.length !== 1 || !(nodes[0] instanceof i18n.Container)) {\n@@ -231,6 +268,10 @@ function assertSingleContainerMessage(message: i18n.Message): void {\n   }\n }\n \n+/**\n+ * Asserts that the `previousNodes` and `node` collections have the same number of elements and\n+ * corresponding elements have the same node type.\n+ */\n function assertEquivalentNodes(previousNodes: i18n.Node[], nodes: i18n.Node[]): void {\n   if (previousNodes.length !== nodes.length) {\n     throw new Error('The number of i18n message children changed between first and second pass.');\n@@ -241,14 +282,17 @@ function assertEquivalentNodes(previousNodes: i18n.Node[], nodes: i18n.Node[]):\n   }\n }\n \n+/**\n+ * Create a new `ParseSourceSpan` from the `sourceSpan`, offset by the `start` and `end` values.\n+ */\n function getOffsetSourceSpan(\n-    sourceSpan: ParseSourceSpan, {start, end}: {start: number, end: number}): ParseSourceSpan {\n+    sourceSpan: ParseSourceSpan, {start, end}: InterpolationPiece): ParseSourceSpan {\n   return new ParseSourceSpan(sourceSpan.fullStart.moveBy(start), sourceSpan.fullStart.moveBy(end));\n }\n \n const _CUSTOM_PH_EXP =\n     /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\n \n-function _extractPlaceholderName(input: string): string {\n+function extractPlaceholderName(input: string): string {\n   return input.split(_CUSTOM_PH_EXP)[2];\n }"
        },
        {
            "sha": "c49ff622f4130bc036212e702b588f65b66857d6",
            "filename": "packages/compiler/test/expression_parser/ast_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/969ad329de01c2287e99aac16bb94d21b66d1fb0/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fast_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/969ad329de01c2287e99aac16bb94d21b66d1fb0/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fast_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fast_spec.ts?ref=969ad329de01c2287e99aac16bb94d21b66d1fb0",
            "patch": "@@ -12,7 +12,7 @@ import {ImplicitReceiver, MethodCall, PropertyRead} from '@angular/compiler/src/\n describe('RecursiveAstVisitor', () => {\n   it('should visit every node', () => {\n     const parser = new Parser(new Lexer());\n-    const ast = parser.parseBinding('x.y()', null /* location */, 0 /* absoluteOffset */);\n+    const ast = parser.parseBinding('x.y()', '', 0 /* absoluteOffset */);\n     const visitor = new Visitor();\n     const path: AST[] = [];\n     visitor.visit(ast.ast, path);"
        },
        {
            "sha": "4b96ffa70e42192f8974187b34e563d408cb6700",
            "filename": "packages/compiler/test/expression_parser/parser_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/969ad329de01c2287e99aac16bb94d21b66d1fb0/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/969ad329de01c2287e99aac16bb94d21b66d1fb0/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts?ref=969ad329de01c2287e99aac16bb94d21b66d1fb0",
            "patch": "@@ -855,8 +855,7 @@ describe('parser', () => {\n \n     it('should support custom interpolation', () => {\n       const parser = new Parser(new Lexer());\n-      const ast =\n-          parser.parseInterpolation('{% a %}', null, 0, {start: '{%', end: '%}'})!.ast as any;\n+      const ast = parser.parseInterpolation('{% a %}', '', 0, {start: '{%', end: '%}'})!.ast as any;\n       expect(ast.strings).toEqual(['', '']);\n       expect(ast.expressions.length).toEqual(1);\n       expect(ast.expressions[0].name).toEqual('a');\n@@ -978,8 +977,7 @@ describe('parser', () => {\n \n   describe('wrapLiteralPrimitive', () => {\n     it('should wrap a literal primitive', () => {\n-      expect(unparse(validate(createParser().wrapLiteralPrimitive('foo', null, 0))))\n-          .toEqual('\"foo\"');\n+      expect(unparse(validate(createParser().wrapLiteralPrimitive('foo', '', 0)))).toEqual('\"foo\"');\n     });\n   });\n "
        }
    ],
    "stats": {
        "total": 234,
        "additions": 138,
        "deletions": 96
    }
}