{
    "author": "gkalpak",
    "message": "refactor(ngcc): make it easy to support more UMD wrapper function formats (#44245)\n\nPreviously, ngcc could only handle UMD modules whose wrapper function\nwas implemented as a `ts.ConditionalExpression` (i.e. using a ternary\noperator). This is the format emitted by popular bundlers, such as\nRollup. However, this failed to account for a different format, using\n`if/else` statements, such as the one [emitted by Webpack][1].\n\nThis commit prepares ngcc for supporting different UMD wrapper function\nformats by decoupling the operation of parsing the wrapper function body\nto capture the various factory function calls and that of operating on\nthe factory function calls (for example, to read or update their\narguments). In a subsequent commit, this will be used to add support for\nthe Webpack format.\n\n[1]: https://webpack.js.org/configuration/output/#type-umd\n\nPR Close #44245",
    "sha": "e145b7a3f8e649fa327a62c0f5ccc13483747a0e",
    "files": [
        {
            "sha": "098c5c1c71f60650f5ab7d2c44e811f10632c110",
            "filename": "packages/compiler-cli/ngcc/src/host/umd_host.ts",
            "status": "modified",
            "additions": 213,
            "deletions": 30,
            "changes": 243,
            "blob_url": "https://github.com/angular/angular/blob/e145b7a3f8e649fa327a62c0f5ccc13483747a0e/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fumd_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/e145b7a3f8e649fa327a62c0f5ccc13483747a0e/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fumd_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fumd_host.ts?ref=e145b7a3f8e649fa327a62c0f5ccc13483747a0e",
            "patch": "@@ -292,9 +292,9 @@ export class UmdReflectionHost extends Esm5ReflectionHost {\n       statement: WildcardReexportStatement, containingFile: ts.SourceFile): ExportDeclaration[] {\n     const reexportArg = statement.expression.arguments[0];\n \n-    const requireCall = isRequireCall(reexportArg) ?\n-        reexportArg :\n-        ts.isIdentifier(reexportArg) ? findRequireCallReference(reexportArg, this.checker) : null;\n+    const requireCall = isRequireCall(reexportArg) ? reexportArg :\n+        ts.isIdentifier(reexportArg) ? findRequireCallReference(reexportArg, this.checker) :\n+                                       null;\n \n     let importPath: string|null = null;\n \n@@ -521,7 +521,25 @@ export function parseStatementForUmdModule(statement: ts.Statement): UmdModule|n\n   const factoryFn = stripParentheses(wrapper.call.arguments[factoryFnParamIndex]);\n   if (!factoryFn || !ts.isFunctionExpression(factoryFn)) return null;\n \n-  return {wrapperFn: wrapper.fn, factoryFn};\n+  let factoryCalls: UmdModule['factoryCalls']|null = null;\n+\n+  return {\n+    wrapperFn: wrapper.fn,\n+    factoryFn,\n+    // Compute `factoryCalls` lazily, because in some cases they might not be needed for the task at\n+    // hand.\n+    // For example, if we just want to determine if an entry-point is in CommonJS or UMD format,\n+    // trying to parse the wrapper function could potentially throw a (premature) error. By making\n+    // the computation of `factoryCalls` lazy, such an error would be thrown later (during an\n+    // operation where the format of the wrapper function does actually matter) or potentially not\n+    // at all (if we end up not having to process that entry-point).\n+    get factoryCalls() {\n+      if (factoryCalls === null) {\n+        factoryCalls = parseUmdWrapperFunction(this.wrapperFn);\n+      }\n+      return factoryCalls;\n+    },\n+  };\n }\n \n function getUmdWrapper(statement: ts.Statement):\n@@ -547,51 +565,216 @@ function getUmdWrapper(statement: ts.Statement):\n   return null;\n }\n \n+/**\n+ * Parse the wrapper function of a UMD module and extract info about the factory function calls for\n+ * the various formats (CommonJS, AMD, global).\n+ *\n+ * The supported format for the UMD wrapper function body is a single statement which is a\n+ * `ts.ConditionalExpression` (i.e. using a ternary operator). For example:\n+ *\n+ * ```js\n+ * // Using a conditional expression:\n+ * (function (global, factory) {\n+ *   typeof exports === 'object' && typeof module !== 'undefined' ?\n+ *     // CommonJS2 factory call.\n+ *     factory(exports, require('foo'), require('bar')) :\n+ *   typeof define === 'function' && define.amd ?\n+ *     // AMD factory call.\n+ *     define(['exports', 'foo', 'bar'], factory) :\n+ *     // Global factory call.\n+ *     (factory((global['my-lib'] = {}), global.foo, global.bar));\n+ * }(this, (function (exports, foo, bar) {\n+ *   // ...\n+ * }));\n+ * ```\n+ */\n+function parseUmdWrapperFunction(wrapperFn: ts.FunctionExpression): UmdModule['factoryCalls'] {\n+  const stmt = wrapperFn.body.statements[0];\n+  let conditionalFactoryCalls: UmdConditionalFactoryCall[];\n+\n+  if (ts.isExpressionStatement(stmt) && ts.isConditionalExpression(stmt.expression)) {\n+    conditionalFactoryCalls = extractFactoryCallsFromConditionalExpression(stmt.expression);\n+  } else {\n+    throw new Error(\n+        'UMD wrapper body is not in a supported format (expected a conditional expression):\\n' +\n+        wrapperFn.body.getText());\n+  }\n+\n+  const factoryCalls = {\n+    amdDefine: getAmdDefineCall(conditionalFactoryCalls),\n+    commonJs: getCommonJsFactoryCall(conditionalFactoryCalls),\n+    global: getGlobalFactoryCall(conditionalFactoryCalls),\n+  };\n+\n+  if (factoryCalls.commonJs === null) {\n+    throw new Error(\n+        'Unable to find a CommonJS factory call inside the UMD wrapper function:\\n' +\n+        stmt.getText());\n+  }\n+\n+  return factoryCalls as (typeof factoryCalls&{commonJs: ts.CallExpression});\n+}\n+\n+/**\n+ * Extract `UmdConditionalFactoryCall`s from a `ts.ConditionalExpression` of the form:\n+ *\n+ * ```js\n+ * typeof exports === 'object' && typeof module !== 'undefined' ?\n+ *   // CommonJS2 factory call.\n+ *   factory(exports, require('foo'), require('bar')) :\n+ * typeof define === 'function' && define.amd ?\n+ *   // AMD factory call.\n+ *   define(['exports', 'foo', 'bar'], factory) :\n+ *   // Global factory call.\n+ *   (factory((global['my-lib'] = {}), global.foo, global.bar));\n+ * ```\n+ */\n+function extractFactoryCallsFromConditionalExpression(node: ts.ConditionalExpression):\n+    UmdConditionalFactoryCall[] {\n+  const factoryCalls: UmdConditionalFactoryCall[] = [];\n+  let currentNode: ts.Expression = node;\n+\n+  while (ts.isConditionalExpression(currentNode)) {\n+    if (!ts.isBinaryExpression(currentNode.condition)) {\n+      throw new Error(\n+          'Condition inside UMD wrapper is not a binary expression:\\n' +\n+          currentNode.condition.getText());\n+    }\n+\n+    factoryCalls.push({\n+      condition: currentNode.condition,\n+      factoryCall: getFunctionCallFromExpression(currentNode.whenTrue),\n+    });\n+\n+    currentNode = currentNode.whenFalse;\n+  }\n+\n+  factoryCalls.push({\n+    condition: null,\n+    factoryCall: getFunctionCallFromExpression(currentNode),\n+  });\n+\n+  return factoryCalls;\n+}\n+\n+function getFunctionCallFromExpression(node: ts.Expression): ts.CallExpression {\n+  // Be resilient to `node` being inside parenthesis.\n+  if (ts.isParenthesizedExpression(node)) {\n+    // NOTE:\n+    // Since we are going further down the AST, there is no risk of infinite recursion.\n+    return getFunctionCallFromExpression(node.expression);\n+  }\n+\n+  // Be resilient to `node` being part of a comma expression.\n+  if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.CommaToken) {\n+    // NOTE:\n+    // Since we are going further down the AST, there is no risk of infinite recursion.\n+    return getFunctionCallFromExpression(node.right);\n+  }\n+\n+  if (!ts.isCallExpression(node)) {\n+    throw new Error('Expression inside UMD wrapper is not a call expression:\\n' + node.getText());\n+  }\n+\n+  return node;\n+}\n+\n+/**\n+ * Get the `define` call for setting up the AMD dependencies in the UMD wrapper.\n+ */\n+function getAmdDefineCall(calls: UmdConditionalFactoryCall[]): ts.CallExpression|null {\n+  // The `define` call for AMD dependencies is the one that is guarded with a `&&` expression whose\n+  // one side is a `typeof define` condition.\n+  const amdConditionalCall = calls.find(\n+      call => call.condition?.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken &&\n+          oneOfBinaryConditions(call.condition, exp => isTypeOf(exp, 'define')) &&\n+          ts.isIdentifier(call.factoryCall.expression) &&\n+          call.factoryCall.expression.text === 'define');\n+\n+  return amdConditionalCall?.factoryCall ?? null;\n+}\n+\n+/**\n+ * Get the factory call for setting up the CommonJS dependencies in the UMD wrapper.\n+ */\n+function getCommonJsFactoryCall(calls: UmdConditionalFactoryCall[]): ts.CallExpression|null {\n+  // The factory call for CommonJS dependencies is the one that is guarded with a `&&` expression\n+  // whose one side is a `typeof exports` or `typeof module` condition.\n+  const cjsConditionalCall = calls.find(\n+      call => call.condition?.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken &&\n+          oneOfBinaryConditions(call.condition, exp => isTypeOf(exp, 'exports', 'module')) &&\n+          ts.isIdentifier(call.factoryCall.expression) &&\n+          call.factoryCall.expression.text === 'factory');\n+\n+  return cjsConditionalCall?.factoryCall ?? null;\n+}\n+\n+/**\n+ * Get the factory call for setting up the global dependencies in the UMD wrapper.\n+ */\n+function getGlobalFactoryCall(calls: UmdConditionalFactoryCall[]): ts.CallExpression|null {\n+  // The factory call for global dependencies is the one that is the final else-case (i.e. the one\n+  // that has `condition: null`).\n+  const globalConditionalCall = calls.find(call => call.condition === null);\n+\n+  return globalConditionalCall?.factoryCall ?? null;\n+}\n+\n+function oneOfBinaryConditions(\n+    node: ts.BinaryExpression, test: (expression: ts.Expression) => boolean) {\n+  return test(node.left) || test(node.right);\n+}\n+\n+function isTypeOf(node: ts.Expression, ...types: string[]): boolean {\n+  return ts.isBinaryExpression(node) && ts.isTypeOfExpression(node.left) &&\n+      ts.isIdentifier(node.left.expression) && types.includes(node.left.expression.text);\n+}\n \n export function getImportsOfUmdModule(umdModule: UmdModule):\n     {parameter: ts.ParameterDeclaration, path: string}[] {\n   const imports: {parameter: ts.ParameterDeclaration, path: string}[] = [];\n+  const cjsFactoryCall = umdModule.factoryCalls.commonJs;\n+\n   for (let i = 1; i < umdModule.factoryFn.parameters.length; i++) {\n     imports.push({\n       parameter: umdModule.factoryFn.parameters[i],\n-      path: getRequiredModulePath(umdModule.wrapperFn, i)\n+      path: getRequiredModulePath(cjsFactoryCall, i),\n     });\n   }\n+\n   return imports;\n }\n \n interface UmdModule {\n   wrapperFn: ts.FunctionExpression;\n   factoryFn: ts.FunctionExpression;\n+  factoryCalls: {\n+    commonJs: ts.CallExpression; amdDefine: ts.CallExpression | null;\n+    global: ts.CallExpression | null;\n+  };\n+}\n+\n+/**\n+ * Represents a factory call found inside the UMD wrapper function.\n+ *\n+ * Each factory call corresponds to a format (such as AMD, CommonJS, etc.) and is guarded by a\n+ * condition (except for the last factory call, which is reached when all other conditions fail).\n+ */\n+interface UmdConditionalFactoryCall {\n+  condition: ts.BinaryExpression|null;\n+  factoryCall: ts.CallExpression;\n }\n \n-function getRequiredModulePath(wrapperFn: ts.FunctionExpression, paramIndex: number): string {\n-  const statement = wrapperFn.body.statements[0];\n-  if (!ts.isExpressionStatement(statement)) {\n+function getRequiredModulePath(cjsFactoryCall: ts.CallExpression, paramIndex: number): string {\n+  const requireCall = cjsFactoryCall.arguments[paramIndex];\n+\n+  if (requireCall !== undefined && !isRequireCall(requireCall)) {\n     throw new Error(\n-        'UMD wrapper body is not an expression statement:\\n' + wrapperFn.body.getText());\n-  }\n-  const modulePaths: string[] = [];\n-  findModulePaths(statement.expression);\n-\n-  // Since we were only interested in the `require()` calls, we miss the `exports` argument, so we\n-  // need to subtract 1.\n-  // E.g. `function(exports, dep1, dep2)` maps to `function(exports, require('path/to/dep1'),\n-  // require('path/to/dep2'))`\n-  return modulePaths[paramIndex - 1];\n-\n-  // Search the statement for calls to `require('...')` and extract the string value of the first\n-  // argument\n-  function findModulePaths(node: ts.Node) {\n-    if (isRequireCall(node)) {\n-      const argument = node.arguments[0];\n-      if (ts.isStringLiteral(argument)) {\n-        modulePaths.push(argument.text);\n-      }\n-    } else {\n-      node.forEachChild(findModulePaths);\n-    }\n+        `Argument at index ${paramIndex} of UMD factory call is not a \\`require\\` call with a ` +\n+        'single string argument:\\n' + cjsFactoryCall.getText());\n   }\n+\n+  return requireCall.arguments[0].text;\n }\n \n /**"
        },
        {
            "sha": "60544dc421a986dfeb46a3a14cb8a8a105a69ad6",
            "filename": "packages/compiler-cli/ngcc/src/rendering/umd_rendering_formatter.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 97,
            "changes": 114,
            "blob_url": "https://github.com/angular/angular/blob/e145b7a3f8e649fa327a62c0f5ccc13483747a0e/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fumd_rendering_formatter.ts",
            "raw_url": "https://github.com/angular/angular/raw/e145b7a3f8e649fa327a62c0f5ccc13483747a0e/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fumd_rendering_formatter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fumd_rendering_formatter.ts?ref=e145b7a3f8e649fa327a62c0f5ccc13483747a0e",
            "patch": "@@ -17,9 +17,6 @@ import {UmdReflectionHost} from '../host/umd_host';\n import {Esm5RenderingFormatter} from './esm5_rendering_formatter';\n import {stripExtension} from './utils';\n \n-type CommonJsConditional = ts.ConditionalExpression&{whenTrue: ts.CallExpression};\n-type AmdConditional = ts.ConditionalExpression&{whenTrue: ts.CallExpression};\n-\n /**\n  * A RenderingFormatter that works with UMD files, instead of `import` and `export` statements\n  * the module is an IIFE with a factory function call with dependencies, which are defined in a\n@@ -61,12 +58,12 @@ export class UmdRenderingFormatter extends Esm5RenderingFormatter {\n       return;\n     }\n \n-    const {wrapperFn, factoryFn} = umdModule;\n+    const {factoryFn, factoryCalls} = umdModule;\n \n     // We need to add new `require()` calls for each import in the CommonJS initializer\n-    renderCommonJsDependencies(output, wrapperFn, imports);\n-    renderAmdDependencies(output, wrapperFn, imports);\n-    renderGlobalDependencies(output, wrapperFn, imports);\n+    renderCommonJsDependencies(output, factoryCalls.commonJs, imports);\n+    renderAmdDependencies(output, factoryCalls.amdDefine, imports);\n+    renderGlobalDependencies(output, factoryCalls.global, imports);\n     renderFactoryParameters(output, factoryFn, imports);\n   }\n \n@@ -140,12 +137,11 @@ export class UmdRenderingFormatter extends Esm5RenderingFormatter {\n  * Add dependencies to the CommonJS part of the UMD wrapper function.\n  */\n function renderCommonJsDependencies(\n-    output: MagicString, wrapperFunction: ts.FunctionExpression, imports: Import[]) {\n-  const conditional = find(wrapperFunction.body.statements[0], isCommonJSConditional);\n-  if (!conditional) {\n+    output: MagicString, factoryCall: ts.CallExpression|null, imports: Import[]) {\n+  if (factoryCall === null) {\n     return;\n   }\n-  const factoryCall = conditional.whenTrue;\n+\n   const injectionPoint = factoryCall.arguments.length > 0 ?\n       // Add extra dependencies before the first argument\n       factoryCall.arguments[0].getFullStart() :\n@@ -159,12 +155,11 @@ function renderCommonJsDependencies(\n  * Add dependencies to the AMD part of the UMD wrapper function.\n  */\n function renderAmdDependencies(\n-    output: MagicString, wrapperFunction: ts.FunctionExpression, imports: Import[]) {\n-  const conditional = find(wrapperFunction.body.statements[0], isAmdConditional);\n-  if (!conditional) {\n+    output: MagicString, amdDefineCall: ts.CallExpression|null, imports: Import[]) {\n+  if (amdDefineCall === null) {\n     return;\n   }\n-  const amdDefineCall = conditional.whenTrue;\n+\n   const importString = imports.map(i => `'${i.specifier}'`).join(',');\n   // The dependency array (if it exists) is the second to last argument\n   // `define(id?, dependencies?, factory);`\n@@ -191,19 +186,18 @@ function renderAmdDependencies(\n  * Add dependencies to the global part of the UMD wrapper function.\n  */\n function renderGlobalDependencies(\n-    output: MagicString, wrapperFunction: ts.FunctionExpression, imports: Import[]) {\n-  const globalFactoryCall = find(wrapperFunction.body.statements[0], isGlobalFactoryCall);\n-  if (!globalFactoryCall) {\n+    output: MagicString, factoryCall: ts.CallExpression|null, imports: Import[]) {\n+  if (factoryCall === null) {\n     return;\n   }\n-  const injectionPoint = globalFactoryCall.arguments.length > 0 ?\n+\n+  const injectionPoint = factoryCall.arguments.length > 0 ?\n       // Add extra dependencies before the first argument\n-      globalFactoryCall.arguments[0].getFullStart() :\n+      factoryCall.arguments[0].getFullStart() :\n       // Backup one char to account for the closing parenthesis on the call\n-      globalFactoryCall.getEnd() - 1;\n+      factoryCall.getEnd() - 1;\n   const importString = imports.map(i => `global.${getGlobalIdentifier(i)}`).join(',');\n-  output.appendLeft(\n-      injectionPoint, importString + (globalFactoryCall.arguments.length > 0 ? ',' : ''));\n+  output.appendLeft(injectionPoint, importString + (factoryCall.arguments.length > 0 ? ',' : ''));\n }\n \n /**\n@@ -226,66 +220,6 @@ function renderFactoryParameters(\n   }\n }\n \n-/**\n- * Is this node the CommonJS conditional expression in the UMD wrapper?\n- */\n-function isCommonJSConditional(value: ts.Node): value is CommonJsConditional {\n-  if (!ts.isConditionalExpression(value)) {\n-    return false;\n-  }\n-  if (!ts.isBinaryExpression(value.condition) ||\n-      value.condition.operatorToken.kind !== ts.SyntaxKind.AmpersandAmpersandToken) {\n-    return false;\n-  }\n-  if (!oneOfBinaryConditions(value.condition, (exp) => isTypeOf(exp, 'exports', 'module'))) {\n-    return false;\n-  }\n-  if (!ts.isCallExpression(value.whenTrue) || !ts.isIdentifier(value.whenTrue.expression)) {\n-    return false;\n-  }\n-  return value.whenTrue.expression.text === 'factory';\n-}\n-\n-/**\n- * Is this node the AMD conditional expression in the UMD wrapper?\n- */\n-function isAmdConditional(value: ts.Node): value is AmdConditional {\n-  if (!ts.isConditionalExpression(value)) {\n-    return false;\n-  }\n-  if (!ts.isBinaryExpression(value.condition) ||\n-      value.condition.operatorToken.kind !== ts.SyntaxKind.AmpersandAmpersandToken) {\n-    return false;\n-  }\n-  if (!oneOfBinaryConditions(value.condition, (exp) => isTypeOf(exp, 'define'))) {\n-    return false;\n-  }\n-  if (!ts.isCallExpression(value.whenTrue) || !ts.isIdentifier(value.whenTrue.expression)) {\n-    return false;\n-  }\n-  return value.whenTrue.expression.text === 'define';\n-}\n-\n-/**\n- * Is this node the call to setup the global dependencies in the UMD wrapper?\n- */\n-function isGlobalFactoryCall(value: ts.Node): value is ts.CallExpression {\n-  if (ts.isCallExpression(value) && !!value.parent) {\n-    // Be resilient to the value being part of a comma list\n-    value = isCommaExpression(value.parent) ? value.parent : value;\n-    // Be resilient to the value being inside parentheses\n-    value = ts.isParenthesizedExpression(value.parent) ? value.parent : value;\n-    return !!value.parent && ts.isConditionalExpression(value.parent) &&\n-        value.parent.whenFalse === value;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-function isCommaExpression(value: ts.Node): value is ts.BinaryExpression {\n-  return ts.isBinaryExpression(value) && value.operatorToken.kind === ts.SyntaxKind.CommaToken;\n-}\n-\n /**\n  * Compute a global identifier for the given import (`i`).\n  *\n@@ -315,17 +249,3 @@ function getGlobalIdentifier(i: Import): string {\n       .replace(/[-_]+(.?)/g, (_, c) => c.toUpperCase())\n       .replace(/^./, c => c.toLowerCase());\n }\n-\n-function find<T>(node: ts.Node, test: (node: ts.Node) => node is ts.Node & T): T|undefined {\n-  return test(node) ? node : node.forEachChild(child => find<T>(child, test));\n-}\n-\n-function oneOfBinaryConditions(\n-    node: ts.BinaryExpression, test: (expression: ts.Expression) => boolean) {\n-  return test(node.left) || test(node.right);\n-}\n-\n-function isTypeOf(node: ts.Expression, ...types: string[]): boolean {\n-  return ts.isBinaryExpression(node) && ts.isTypeOfExpression(node.left) &&\n-      ts.isIdentifier(node.left.expression) && types.indexOf(node.left.expression.text) !== -1;\n-}"
        },
        {
            "sha": "46f2d31b7b58425a4ce430ddde3d967d2a8c7fe5",
            "filename": "packages/compiler-cli/ngcc/test/host/umd_host_spec.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/e145b7a3f8e649fa327a62c0f5ccc13483747a0e/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fumd_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e145b7a3f8e649fa327a62c0f5ccc13483747a0e/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fumd_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fumd_host_spec.ts?ref=e145b7a3f8e649fa327a62c0f5ccc13483747a0e",
            "patch": "@@ -735,7 +735,8 @@ runInEachFileSystem(() => {\n             name: _('/wildcard_reexports_with_require.js'),\n             contents: `(function (global, factory) {\\n` +\n                 `  typeof exports === 'object' && typeof module !== 'undefined' ? factory(require, exports) :\\n` +\n-                `  typeof define === 'function' && define.amd ? define('wildcard_reexports_with_require', ['require', 'exports'], factory);\\n` +\n+                `  typeof define === 'function' && define.amd ? define('wildcard_reexports_with_require', ['require', 'exports'], factory) :\\n` +\n+                `  (factory(global.require, global.wildcard_reexports_with_require));\\n` +\n                 `}(this, (function (require, exports) { 'use strict';\\n` +\n                 `  function __export(m) {\\n` +\n                 `    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\\n` +\n@@ -749,7 +750,8 @@ runInEachFileSystem(() => {\n             name: _('/define_property_reexports.js'),\n             contents: `(function (global, factory) {\\n` +\n                 `  typeof exports === 'object' && typeof module !== 'undefined' ? factory(require, exports) :\\n` +\n-                `  typeof define === 'function' && define.amd ? define('define_property_reexports', ['require', 'exports'], factory);\\n` +\n+                `  typeof define === 'function' && define.amd ? define('define_property_reexports', ['require', 'exports'], factory) :\\n` +\n+                `  (factory(global.require, global.define_property_reexports));\\n` +\n                 `}(this, (function (require, exports) { 'use strict';\\n` +\n                 `var moduleA = require(\"./a_module\");\\n` +\n                 `Object.defineProperty(exports, \"newA\", { enumerable: true, get: function () { return moduleA.a; } });\\n` +\n@@ -1769,7 +1771,7 @@ runInEachFileSystem(() => {\n             case 'imported':\n               fileHeaderWithUmd = `\n               (function (global, factory) {\n-                typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'))) :\n+                typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib')) :\n                 typeof define === 'function' && define.amd ? define('test', ['exports', 'tslib'], factory) :\n                     (factory(global.test, global.tslib));\n                 }(this, (function (exports, tslib) { 'use strict';\n@@ -1778,7 +1780,7 @@ runInEachFileSystem(() => {\n             case 'inlined':\n               fileHeaderWithUmd = `\n               (function (global, factory) {\n-                typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports)) :\n+                typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n                 typeof define === 'function' && define.amd ? define('test', ['exports'], factory) :\n                     (factory(global.test));\n                 }(this, (function (exports) { 'use strict';\n@@ -1791,7 +1793,7 @@ runInEachFileSystem(() => {\n             case 'inlined_with_suffix':\n               fileHeaderWithUmd = `\n               (function (global, factory) {\n-                typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports)) :\n+                typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n                 typeof define === 'function' && define.amd ? define('test', ['exports'], factory) :\n                     (factory(global.test));\n                 }(this, (function (exports) { 'use strict';"
        },
        {
            "sha": "1970a8ddcc84fe58c0c6be1e8686c5186211b943",
            "filename": "packages/compiler-cli/ngcc/test/packages/entry_point_spec.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/e145b7a3f8e649fa327a62c0f5ccc13483747a0e/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fpackages%2Fentry_point_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e145b7a3f8e649fa327a62c0f5ccc13483747a0e/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fpackages%2Fentry_point_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fpackages%2Fentry_point_spec.ts?ref=e145b7a3f8e649fa327a62c0f5ccc13483747a0e",
            "patch": "@@ -851,6 +851,27 @@ runInEachFileSystem(() => {\n         entryPoint.packageJson.main = './bundles/valid_entry_point';\n         expect(getEntryPointFormat(fs, entryPoint, browserOrMain)).toBe('umd');\n       });\n+\n+      it('should detect UMD even if the wrapper function is not of a supported format', () => {\n+        // In order to correctly process UMD, we require that at least one CommonJS variant is\n+        // present. However, for the purposes of detecting the module format, it should not matter\n+        // what the body of the wrapper function looks like.\n+        loadTestFiles([{\n+          name: _(\n+              '/project/node_modules/some_package/valid_entry_point/bundles/valid_entry_point/index.js'),\n+          contents: `\n+            (function (global, factory) {\n+              // This is not a supported format for the wrapper function body, but it should still\n+              // be detected as UMD (since it is closer to UMD than any other of the supported\n+              // formats).\n+              typeof define === 'function' && define.amd ? define([], factory) : factory();\n+            })(this, function () { 'use strict'; });\n+          `,\n+        }]);\n+\n+        entryPoint.packageJson.main = './bundles/valid_entry_point';\n+        expect(getEntryPointFormat(fs, entryPoint, browserOrMain)).toBe('umd');\n+      });\n     });\n \n     it('should return `undefined` if the `browser` property is not a string', () => {"
        }
    ],
    "stats": {
        "total": 390,
        "additions": 258,
        "deletions": 132
    }
}