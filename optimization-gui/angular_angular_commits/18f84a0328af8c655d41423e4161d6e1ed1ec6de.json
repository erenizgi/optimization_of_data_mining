{
    "author": "atscott",
    "message": "Revert \"perf(compiler-cli): only emit directive/pipe references that are used (#38539)\" (#38765)\n\nThis reverts commit 4faac78e32657f6b60b98b4330e746ba645c8f2e.\ninternal failure:\nhttps://test.corp.google.com/ui#id=OCL:329948619:BASE:329967516:1599160428139:d63165ae\n\nPR Close #38765",
    "sha": "18f84a0328af8c655d41423e4161d6e1ed1ec6de",
    "files": [
        {
            "sha": "9de9616075915420785a27b641d1d9718ff0629c",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/component.ts",
            "status": "modified",
            "additions": 25,
            "deletions": 33,
            "changes": 58,
            "blob_url": "https://github.com/angular/angular/blob/18f84a0328af8c655d41423e4161d6e1ed1ec6de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/18f84a0328af8c655d41423e4161d6e1ed1ec6de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts?ref=18f84a0328af8c655d41423e4161d6e1ed1ec6de",
            "patch": "@@ -495,58 +495,45 @@ export class ComponentDecoratorHandler implements\n       // Set up the R3TargetBinder, as well as a 'directives' array and a 'pipes' map that are later\n       // fed to the TemplateDefinitionBuilder. First, a SelectorMatcher is constructed to match\n       // directives that are in scope.\n-      type MatchedDirective = DirectiveMeta&{selector: string};\n-      const matcher = new SelectorMatcher<MatchedDirective>();\n+      const matcher = new SelectorMatcher<DirectiveMeta&{expression: Expression}>();\n+      const directives: {selector: string, expression: Expression}[] = [];\n \n       for (const dir of scope.compilation.directives) {\n-        if (dir.selector !== null) {\n-          matcher.addSelectables(CssSelector.parse(dir.selector), dir as MatchedDirective);\n+        const {ref, selector} = dir;\n+        if (selector !== null) {\n+          const expression = this.refEmitter.emit(ref, context);\n+          directives.push({selector, expression});\n+          matcher.addSelectables(CssSelector.parse(selector), {...dir, expression});\n         }\n       }\n-      const pipes = new Map<string, Reference<ClassDeclaration>>();\n+      const pipes = new Map<string, Expression>();\n       for (const pipe of scope.compilation.pipes) {\n-        pipes.set(pipe.name, pipe.ref);\n+        pipes.set(pipe.name, this.refEmitter.emit(pipe.ref, context));\n       }\n \n-      // Next, the component template AST is bound using the R3TargetBinder. This produces a\n+      // Next, the component template AST is bound using the R3TargetBinder. This produces an\n       // BoundTarget, which is similar to a ts.TypeChecker.\n       const binder = new R3TargetBinder(matcher);\n       const bound = binder.bind({template: metadata.template.nodes});\n \n       // The BoundTarget knows which directives and pipes matched the template.\n-      const usedDirectives = bound.getUsedDirectives().map(directive => {\n-        return {\n-          selector: directive.selector,\n-          expression: this.refEmitter.emit(directive.ref, context),\n-        };\n-      });\n-\n-      const usedPipes: {pipeName: string, expression: Expression}[] = [];\n-      for (const pipeName of bound.getUsedPipes()) {\n-        if (!pipes.has(pipeName)) {\n-          continue;\n-        }\n-        const pipe = pipes.get(pipeName)!;\n-        usedPipes.push({\n-          pipeName,\n-          expression: this.refEmitter.emit(pipe, context),\n-        });\n-      }\n+      const usedDirectives = bound.getUsedDirectives();\n+      const usedPipes = bound.getUsedPipes().map(name => pipes.get(name)!);\n \n       // Scan through the directives/pipes actually used in the template and check whether any\n       // import which needs to be generated would create a cycle.\n       const cycleDetected =\n           usedDirectives.some(dir => this._isCyclicImport(dir.expression, context)) ||\n-          usedPipes.some(pipe => this._isCyclicImport(pipe.expression, context));\n+          usedPipes.some(pipe => this._isCyclicImport(pipe, context));\n \n       if (!cycleDetected) {\n         // No cycle was detected. Record the imports that need to be created in the cycle detector\n         // so that future cyclic import checks consider their production.\n         for (const {expression} of usedDirectives) {\n           this._recordSyntheticImport(expression, context);\n         }\n-        for (const {expression} of usedPipes) {\n-          this._recordSyntheticImport(expression, context);\n+        for (const pipe of usedPipes) {\n+          this._recordSyntheticImport(pipe, context);\n         }\n \n         // Check whether the directive/pipe arrays in Éµcmp need to be wrapped in closures.\n@@ -555,11 +542,16 @@ export class ComponentDecoratorHandler implements\n         const wrapDirectivesAndPipesInClosure =\n             usedDirectives.some(\n                 dir => isExpressionForwardReference(dir.expression, node.name, context)) ||\n-            usedPipes.some(\n-                pipe => isExpressionForwardReference(pipe.expression, node.name, context));\n-\n-        data.directives = usedDirectives;\n-        data.pipes = new Map(usedPipes.map(pipe => [pipe.pipeName, pipe.expression]));\n+            usedPipes.some(pipe => isExpressionForwardReference(pipe, node.name, context));\n+\n+        // Actual compilation still uses the full scope, not the narrowed scope determined by\n+        // R3TargetBinder. This is a hedge against potential issues with the R3TargetBinder - right\n+        // now the TemplateDefinitionBuilder is the \"source of truth\" for which directives/pipes are\n+        // actually used (though the two should agree perfectly).\n+        //\n+        // TODO(alxhub): switch TemplateDefinitionBuilder over to using R3TargetBinder directly.\n+        data.directives = directives;\n+        data.pipes = pipes;\n         data.wrapDirectivesAndPipesInClosure = wrapDirectivesAndPipesInClosure;\n       } else {\n         // Declaring the directiveDefs/pipeDefs arrays directly would require imports that would"
        }
    ],
    "stats": {
        "total": 58,
        "additions": 25,
        "deletions": 33
    }
}