{
    "author": "atscott",
    "message": "test(router): move computed state restoration tests to own file (#42933)\n\nTo reduce the enormouse size of the integration.spec.ts file, move tests related to the computed\nstate restoration to their own file.\n\nPR Close #42933",
    "sha": "4b498242362ce6133645b57d452604e940e8c1bb",
    "files": [
        {
            "sha": "db34072a3584e737a2a60ffa2fab892a8cf33870",
            "filename": "packages/router/src/router.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/4b498242362ce6133645b57d452604e940e8c1bb/packages%2Frouter%2Fsrc%2Frouter.ts",
            "raw_url": "https://github.com/angular/angular/raw/4b498242362ce6133645b57d452604e940e8c1bb/packages%2Frouter%2Fsrc%2Frouter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frouter.ts?ref=4b498242362ce6133645b57d452604e940e8c1bb",
            "patch": "@@ -915,6 +915,13 @@ export class Router {\n                        // reflect the current state of the whole transition because some operations\n                        // return a new object rather than modifying the one in the outermost\n                        // `switchMap`.\n+                       //  The fix can likely be to:\n+                       //  1. Rename the outer `t` variable so it's not shadowed all the time and\n+                       //  confusing\n+                       //  2. Keep reassigning to the outer variable after each stage to ensure it\n+                       //  gets updated. Or change the implementations to not return a copy.\n+                       // Not changed yet because it affects existing code and would need to be\n+                       // tested more thoroughly.\n                        errored = true;\n                        /* This error type is issued during Redirect, and is handled as a\n                         * cancellation rather than an error. */"
        },
        {
            "sha": "e4925938e46b421654ae216792c9e3d9fbd5d58c",
            "filename": "packages/router/test/computed_state_restoration.spec.ts",
            "status": "added",
            "additions": 645,
            "deletions": 0,
            "changes": 645,
            "blob_url": "https://github.com/angular/angular/blob/4b498242362ce6133645b57d452604e940e8c1bb/packages%2Frouter%2Ftest%2Fcomputed_state_restoration.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/4b498242362ce6133645b57d452604e940e8c1bb/packages%2Frouter%2Ftest%2Fcomputed_state_restoration.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fcomputed_state_restoration.spec.ts?ref=4b498242362ce6133645b57d452604e940e8c1bb",
            "patch": "@@ -0,0 +1,645 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {CommonModule, Location, LocationStrategy, PlatformLocation} from '@angular/common';\n+import {SpyLocation} from '@angular/common/testing';\n+import {Component, EventEmitter, Injectable, NgModule} from '@angular/core';\n+import {ComponentFixture, fakeAsync, TestBed, tick} from '@angular/core/testing';\n+import {expect} from '@angular/platform-browser/testing/src/matchers';\n+import {CanActivate, CanDeactivate, Resolve, Router, RouterModule, UrlTree} from '@angular/router';\n+import {EMPTY, Observable, of, SubscriptionLike} from 'rxjs';\n+\n+import {isUrlTree} from '../src/utils/type_guards';\n+import {RouterTestingModule} from '../testing';\n+\n+describe('`restoredState#ɵrouterPageId`', () => {\n+  // TODO: Remove RouterSpyLocation after #38884 is submitted.\n+  class RouterSpyLocation implements Location {\n+    urlChanges: string[] = [];\n+    private _history: LocationState[] = [new LocationState('', '', null)];\n+    private _historyIndex: number = 0;\n+    /** @internal */\n+    _subject: EventEmitter<any> = new EventEmitter();\n+    /** @internal */\n+    _baseHref: string = '';\n+    /** @internal */\n+    _platformStrategy: LocationStrategy = null!;\n+    /** @internal */\n+    _platformLocation: PlatformLocation = null!;\n+    /** @internal */\n+    _urlChangeListeners: ((url: string, state: unknown) => void)[] = [];\n+    /** @internal */\n+    _urlChangeSubscription?: SubscriptionLike;\n+\n+    setInitialPath(url: string) {\n+      this._history[this._historyIndex].path = url;\n+    }\n+\n+    setBaseHref(url: string) {\n+      this._baseHref = url;\n+    }\n+\n+    path(): string {\n+      return this._history[this._historyIndex].path;\n+    }\n+\n+    getState(): unknown {\n+      return this._history[this._historyIndex].state;\n+    }\n+\n+    isCurrentPathEqualTo(path: string, query: string = ''): boolean {\n+      const givenPath = path.endsWith('/') ? path.substring(0, path.length - 1) : path;\n+      const currPath = this.path().endsWith('/') ?\n+          this.path().substring(0, this.path().length - 1) :\n+          this.path();\n+\n+      return currPath == givenPath + (query.length > 0 ? ('?' + query) : '');\n+    }\n+\n+    simulateUrlPop(pathname: string) {\n+      this._subject.emit({'url': pathname, 'pop': true, 'type': 'popstate'});\n+    }\n+\n+    simulateHashChange(pathname: string) {\n+      // Because we don't prevent the native event, the browser will independently update the path\n+      this.setInitialPath(pathname);\n+      this.urlChanges.push('hash: ' + pathname);\n+      this._subject.emit({'url': pathname, 'pop': true, 'type': 'hashchange'});\n+    }\n+\n+    prepareExternalUrl(url: string): string {\n+      if (url.length > 0 && !url.startsWith('/')) {\n+        url = '/' + url;\n+      }\n+      return this._baseHref + url;\n+    }\n+\n+    go(path: string, query: string = '', state: any = null) {\n+      path = this.prepareExternalUrl(path);\n+\n+      if (this._historyIndex > 0) {\n+        this._history.splice(this._historyIndex + 1);\n+      }\n+      this._history.push(new LocationState(path, query, state));\n+      this._historyIndex = this._history.length - 1;\n+\n+      const locationState = this._history[this._historyIndex - 1];\n+      if (locationState.path == path && locationState.query == query) {\n+        return;\n+      }\n+\n+      const url = path + (query.length > 0 ? ('?' + query) : '');\n+      this.urlChanges.push(url);\n+    }\n+\n+    replaceState(path: string, query: string = '', state: any = null) {\n+      path = this.prepareExternalUrl(path);\n+\n+      const history = this._history[this._historyIndex];\n+      if (history.path == path && history.query == query) {\n+        return;\n+      }\n+\n+      history.path = path;\n+      history.query = query;\n+      history.state = state;\n+\n+      const url = path + (query.length > 0 ? ('?' + query) : '');\n+      this.urlChanges.push('replace: ' + url);\n+    }\n+\n+    forward() {\n+      if (this._historyIndex < (this._history.length - 1)) {\n+        this._historyIndex++;\n+        this._subject.emit(\n+            {'url': this.path(), 'state': this.getState(), 'pop': true, 'type': 'popstate'});\n+      }\n+    }\n+\n+    back() {\n+      if (this._historyIndex > 0) {\n+        this._historyIndex--;\n+        this._subject.emit(\n+            {'url': this.path(), 'state': this.getState(), 'pop': true, 'type': 'popstate'});\n+      }\n+    }\n+\n+    historyGo(relativePosition: number = 0): void {\n+      const nextPageIndex = this._historyIndex + relativePosition;\n+      if (nextPageIndex >= 0 && nextPageIndex < this._history.length) {\n+        this._historyIndex = nextPageIndex;\n+        this._subject.emit(\n+            {'url': this.path(), 'state': this.getState(), 'pop': true, 'type': 'popstate'});\n+      }\n+    }\n+\n+    onUrlChange(fn: (url: string, state: unknown) => void) {\n+      this._urlChangeListeners.push(fn);\n+\n+      if (!this._urlChangeSubscription) {\n+        this._urlChangeSubscription = this.subscribe(v => {\n+          this._notifyUrlChangeListeners(v.url, v.state);\n+        });\n+      }\n+    }\n+\n+    /** @internal */\n+    _notifyUrlChangeListeners(url: string = '', state: unknown) {\n+      this._urlChangeListeners.forEach(fn => fn(url, state));\n+    }\n+\n+    subscribe(\n+        onNext: (value: any) => void, onThrow?: ((error: any) => void)|null,\n+        onReturn?: (() => void)|null): SubscriptionLike {\n+      return this._subject.subscribe({next: onNext, error: onThrow, complete: onReturn});\n+    }\n+\n+    normalize(url: string): string {\n+      return null!;\n+    }\n+  }\n+\n+  class LocationState {\n+    constructor(public path: string, public query: string, public state: any) {}\n+  }\n+\n+  @Injectable({providedIn: 'root'})\n+  class MyCanDeactivateGuard implements CanDeactivate<any> {\n+    allow: boolean = true;\n+    canDeactivate(): boolean {\n+      return this.allow;\n+    }\n+  }\n+\n+  @Injectable({providedIn: 'root'})\n+  class ThrowingCanActivateGuard implements CanActivate {\n+    throw = false;\n+\n+    constructor(private router: Router) {}\n+\n+    canActivate(): boolean {\n+      if (this.throw) {\n+        throw new Error('error in guard');\n+      }\n+      return true;\n+    }\n+  }\n+\n+  @Injectable({providedIn: 'root'})\n+  class MyCanActivateGuard implements CanActivate {\n+    allow: boolean = true;\n+    redirectTo: string|null|UrlTree = null;\n+\n+    constructor(private router: Router) {}\n+\n+    canActivate(): boolean|UrlTree {\n+      if (typeof this.redirectTo === 'string') {\n+        this.router.navigateByUrl(this.redirectTo);\n+      } else if (isUrlTree(this.redirectTo)) {\n+        return this.redirectTo;\n+      }\n+      return this.allow;\n+    }\n+  }\n+  @Injectable({providedIn: 'root'})\n+  class MyResolve implements Resolve<Observable<any>> {\n+    myresolve: Observable<any> = of(2);\n+    resolve(): Observable<any> {\n+      return this.myresolve;\n+    }\n+  }\n+\n+  @NgModule(\n+      {imports: [RouterModule.forChild([{path: '', component: SimpleCmp}])]},\n+      )\n+  class LoadedModule {\n+  }\n+\n+  let fixture: ComponentFixture<unknown>;\n+\n+  beforeEach(fakeAsync(() => {\n+    TestBed.configureTestingModule({\n+      imports: [TestModule],\n+      providers: [\n+        {provide: 'alwaysFalse', useValue: (a: any) => false},\n+        {provide: Location, useClass: RouterSpyLocation}\n+      ]\n+    });\n+    const router = TestBed.inject(Router);\n+    (router as any).canceledNavigationResolution = 'computed';\n+    const location = TestBed.inject(Location);\n+    fixture = createRoot(router, RootCmp);\n+    router.resetConfig([\n+      {\n+        path: 'first',\n+        component: SimpleCmp,\n+        canDeactivate: [MyCanDeactivateGuard],\n+        canActivate: [MyCanActivateGuard, ThrowingCanActivateGuard],\n+        resolve: [MyResolve]\n+      },\n+      {\n+        path: 'second',\n+        component: SimpleCmp,\n+        canDeactivate: [MyCanDeactivateGuard],\n+        canActivate: [MyCanActivateGuard, ThrowingCanActivateGuard],\n+        resolve: [MyResolve]\n+      },\n+      {\n+        path: 'third',\n+        component: SimpleCmp,\n+        canDeactivate: [MyCanDeactivateGuard],\n+        canActivate: [MyCanActivateGuard, ThrowingCanActivateGuard],\n+        resolve: [MyResolve]\n+      },\n+      {\n+        path: 'unguarded',\n+        component: SimpleCmp,\n+      },\n+      {\n+        path: 'throwing',\n+        component: ThrowingCmp,\n+      },\n+      {path: 'loaded', loadChildren: () => of(LoadedModule), canLoad: ['alwaysFalse']}\n+    ]);\n+    router.navigateByUrl('/first');\n+    advance(fixture);\n+    expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n+\n+    router.navigateByUrl('/second');\n+    advance(fixture);\n+    expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+    router.navigateByUrl('/third');\n+    advance(fixture);\n+    expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+\n+    location.back();\n+    advance(fixture);\n+  }));\n+\n+  it('should work when CanActivate returns false', fakeAsync(() => {\n+       const location = TestBed.inject(Location);\n+       const router = TestBed.inject(Router);\n+       expect(location.path()).toEqual('/second');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+       TestBed.inject(MyCanActivateGuard).allow = false;\n+       location.back();\n+       advance(fixture);\n+       expect(location.path()).toEqual('/second');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+       TestBed.inject(MyCanActivateGuard).allow = true;\n+       location.back();\n+       advance(fixture);\n+       expect(location.path()).toEqual('/first');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n+\n+       TestBed.inject(MyCanActivateGuard).allow = false;\n+       location.forward();\n+       advance(fixture);\n+       expect(location.path()).toEqual('/first');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n+\n+       router.navigateByUrl('/second');\n+       advance(fixture);\n+       expect(location.path()).toEqual('/first');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n+     }));\n+\n+\n+  it('should work when CanDeactivate returns false', fakeAsync(() => {\n+       const location = TestBed.inject(Location);\n+       const router = TestBed.inject(Router);\n+\n+       TestBed.inject(MyCanDeactivateGuard).allow = false;\n+       location.back();\n+       advance(fixture);\n+       expect(location.path()).toEqual('/second');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+       location.forward();\n+       advance(fixture);\n+       expect(location.path()).toEqual('/second');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+       router.navigateByUrl('third');\n+       advance(fixture);\n+       expect(location.path()).toEqual('/second');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+\n+       TestBed.inject(MyCanDeactivateGuard).allow = true;\n+       location.forward();\n+       advance(fixture);\n+       expect(location.path()).toEqual('/third');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+     }));\n+\n+  it('should work when using `NavigationExtras.skipLocationChange`', fakeAsync(() => {\n+       const location = TestBed.inject(Location);\n+       const router = TestBed.inject(Router);\n+\n+       expect(location.path()).toEqual('/second');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+       router.navigateByUrl('/first', {skipLocationChange: true});\n+       advance(fixture);\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+       router.navigateByUrl('/third');\n+       advance(fixture);\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+\n+       location.back();\n+       advance(fixture);\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+     }));\n+\n+  it('should work when using `NavigationExtras.replaceUrl`', fakeAsync(() => {\n+       const location = TestBed.inject(Location);\n+       const router = TestBed.inject(Router);\n+\n+       expect(location.path()).toEqual('/second');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+       router.navigateByUrl('/first', {replaceUrl: true});\n+       advance(fixture);\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+       expect(location.path()).toEqual('/first');\n+     }));\n+\n+  it('should work when CanLoad returns false', fakeAsync(() => {\n+       const location = TestBed.inject(Location);\n+       const router = TestBed.inject(Router);\n+\n+       router.navigateByUrl('/loaded');\n+       advance(fixture);\n+       expect(location.path()).toEqual('/second');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+     }));\n+\n+  it('should work when resolve empty', fakeAsync(() => {\n+       const location = TestBed.inject(Location);\n+       const router = TestBed.inject(Router);\n+\n+       expect(location.path()).toEqual('/second');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+       TestBed.inject(MyResolve).myresolve = EMPTY;\n+\n+       location.back();\n+       advance(fixture);\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+       expect(location.path()).toEqual('/second');\n+\n+       TestBed.inject(MyResolve).myresolve = of(2);\n+\n+       location.back();\n+       advance(fixture);\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n+       expect(location.path()).toEqual('/first');\n+\n+       TestBed.inject(MyResolve).myresolve = EMPTY;\n+\n+       // We should cancel the navigation to `/third` when myresolve is empty\n+       router.navigateByUrl('/third');\n+       advance(fixture);\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n+       expect(location.path()).toEqual('/first');\n+\n+       location.historyGo(2);\n+       advance(fixture);\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n+       expect(location.path()).toEqual('/first');\n+\n+       TestBed.inject(MyResolve).myresolve = of(2);\n+       location.historyGo(2);\n+       advance(fixture);\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+       expect(location.path()).toEqual('/third');\n+\n+       TestBed.inject(MyResolve).myresolve = EMPTY;\n+       location.historyGo(-2);\n+       advance(fixture);\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+       expect(location.path()).toEqual('/third');\n+     }));\n+\n+\n+  it('should work when an error occured during navigation', fakeAsync(() => {\n+       const location = TestBed.inject(Location);\n+       const router = TestBed.inject(Router);\n+\n+       expect(location.path()).toEqual('/second');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+\n+       router.navigateByUrl('/invalid').catch(() => null);\n+       advance(fixture);\n+       expect(location.path()).toEqual('/second');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+       location.back();\n+       advance(fixture);\n+       expect(location.path()).toEqual('/first');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n+     }));\n+\n+  it('should work when urlUpdateStrategy=\"eager\"', fakeAsync(() => {\n+       const location = TestBed.inject(Location) as SpyLocation;\n+       const router = TestBed.inject(Router);\n+       expect(location.path()).toEqual('/second');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+       router.urlUpdateStrategy = 'eager';\n+\n+       TestBed.inject(MyCanActivateGuard).allow = false;\n+       router.navigateByUrl('/first');\n+       advance(fixture);\n+       expect(location.path()).toEqual('/second');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+       location.back();\n+       advance(fixture);\n+       expect(location.path()).toEqual('/second');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+     }));\n+\n+  it('should work when CanActivate redirects', fakeAsync(() => {\n+       const location = TestBed.inject(Location);\n+\n+       TestBed.inject(MyCanActivateGuard).redirectTo = '/unguarded';\n+       location.back();\n+       advance(fixture);\n+       expect(location.path()).toEqual('/unguarded');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+       TestBed.inject(MyCanActivateGuard).redirectTo = null;\n+\n+       location.back();\n+       advance(fixture);\n+       expect(location.path()).toEqual('/first');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n+     }));\n+\n+  it('should work when CanActivate redirects and urlUpdateStrategy=\"eager\"', fakeAsync(() => {\n+       const location = TestBed.inject(Location);\n+       const router = TestBed.inject(Router);\n+       router.urlUpdateStrategy = 'eager';\n+\n+       TestBed.inject(MyCanActivateGuard).redirectTo = '/unguarded';\n+       router.navigateByUrl('/third');\n+       advance(fixture);\n+       expect(location.path()).toEqual('/unguarded');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 4}));\n+\n+       TestBed.inject(MyCanActivateGuard).redirectTo = null;\n+\n+       location.back();\n+       advance(fixture);\n+       expect(location.path()).toEqual('/third');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+     }));\n+\n+  it('should work when CanActivate redirects with UrlTree and urlUpdateStrategy=\"eager\"',\n+     fakeAsync(() => {\n+       // Note that this test is different from the above case because we are able to specifically\n+       // handle the `UrlTree` case as a proper redirect and set `replaceUrl: true` on the\n+       // follow-up navigation.\n+       const location = TestBed.inject(Location);\n+       const router = TestBed.inject(Router);\n+       router.urlUpdateStrategy = 'eager';\n+\n+       TestBed.inject(MyCanActivateGuard).redirectTo = router.createUrlTree(['unguarded']);\n+       router.navigateByUrl('/third');\n+       advance(fixture);\n+       expect(location.path()).toEqual('/unguarded');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n+\n+       TestBed.inject(MyCanActivateGuard).redirectTo = null;\n+\n+       location.back();\n+       advance(fixture);\n+       expect(location.path()).toEqual('/second');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+     }));\n+\n+  for (const urlUpdateSrategy of ['deferred', 'eager'] as const) {\n+    it(`restores history correctly when an error is thrown in guard with urlUpdateStrategy ${\n+           urlUpdateSrategy}`,\n+       fakeAsync(() => {\n+         const location = TestBed.inject(Location);\n+         const router = TestBed.inject(Router);\n+         router.urlUpdateStrategy = urlUpdateSrategy;\n+\n+         TestBed.inject(ThrowingCanActivateGuard).throw = true;\n+\n+         expect(() => {\n+           location.back();\n+           advance(fixture);\n+         }).toThrow();\n+         expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+         TestBed.inject(ThrowingCanActivateGuard).throw = false;\n+         location.back();\n+         advance(fixture);\n+         expect(location.path()).toEqual('/first');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n+       }));\n+\n+    it(`restores history correctly when component throws error in constructor with urlUpdateStrategy ${\n+           urlUpdateSrategy}`,\n+       fakeAsync(() => {\n+         const location = TestBed.inject(Location);\n+         const router = TestBed.inject(Router);\n+         router.urlUpdateStrategy = urlUpdateSrategy;\n+\n+         router.navigateByUrl('/throwing').catch(() => null);\n+         advance(fixture);\n+         expect(location.path()).toEqual('/second');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+         location.back();\n+         advance(fixture);\n+         expect(location.path()).toEqual('/first');\n+         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n+       }));\n+  }\n+\n+  it('restores history correctly when component throws error in constructor and replaceUrl=true',\n+     fakeAsync(() => {\n+       const location = TestBed.inject(Location);\n+       const router = TestBed.inject(Router);\n+\n+       router.navigateByUrl('/throwing', {replaceUrl: true}).catch(() => null);\n+       advance(fixture);\n+       expect(location.path()).toEqual('/second');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+       location.back();\n+       advance(fixture);\n+       expect(location.path()).toEqual('/first');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n+     }));\n+\n+  it('restores history correctly when component throws error in constructor and skipLocationChange=true',\n+     fakeAsync(() => {\n+       const location = TestBed.inject(Location);\n+       const router = TestBed.inject(Router);\n+\n+       router.navigateByUrl('/throwing', {skipLocationChange: true}).catch(() => null);\n+       advance(fixture);\n+       expect(location.path()).toEqual('/second');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n+\n+       location.back();\n+       advance(fixture);\n+       expect(location.path()).toEqual('/first');\n+       expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n+     }));\n+});\n+\n+function createRoot(router: Router, type: any): ComponentFixture<any> {\n+  const f = TestBed.createComponent(type);\n+  advance(f);\n+  router.initialNavigation();\n+  advance(f);\n+  return f;\n+}\n+\n+@Component({selector: 'simple-cmp', template: `simple`})\n+class SimpleCmp {\n+}\n+\n+@Component({selector: 'root-cmp', template: `<router-outlet></router-outlet>`})\n+class RootCmp {\n+}\n+\n+@Component({selector: 'throwing-cmp', template: ''})\n+class ThrowingCmp {\n+  constructor() {\n+    throw new Error('Throwing Cmp');\n+  }\n+}\n+\n+\n+\n+function advance(fixture: ComponentFixture<any>, millis?: number): void {\n+  tick(millis);\n+  fixture.detectChanges();\n+}\n+\n+@NgModule({\n+  imports: [RouterTestingModule, CommonModule],\n+  exports: [SimpleCmp, RootCmp, ThrowingCmp],\n+  entryComponents: [SimpleCmp, RootCmp, ThrowingCmp],\n+  declarations: [SimpleCmp, RootCmp, ThrowingCmp]\n+})\n+class TestModule {\n+}"
        },
        {
            "sha": "3a221459a5861573a0acc760de9ad3004bafdc60",
            "filename": "packages/router/test/integration.spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 587,
            "changes": 587,
            "blob_url": "https://github.com/angular/angular/blob/4b498242362ce6133645b57d452604e940e8c1bb/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/4b498242362ce6133645b57d452604e940e8c1bb/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fintegration.spec.ts?ref=4b498242362ce6133645b57d452604e940e8c1bb",
            "patch": "@@ -2663,593 +2663,6 @@ describe('Integration', () => {\n          expect(location.path()).toEqual('/initial');\n        })));\n   });\n-  describe('`restoredState#ɵrouterPageId`', () => {\n-    // TODO: Remove RouterSpyLocation after #38884 is submitted.\n-    class RouterSpyLocation implements Location {\n-      urlChanges: string[] = [];\n-      private _history: LocationState[] = [new LocationState('', '', null)];\n-      private _historyIndex: number = 0;\n-      /** @internal */\n-      _subject: EventEmitter<any> = new EventEmitter();\n-      /** @internal */\n-      _baseHref: string = '';\n-      /** @internal */\n-      _platformStrategy: LocationStrategy = null!;\n-      /** @internal */\n-      _platformLocation: PlatformLocation = null!;\n-      /** @internal */\n-      _urlChangeListeners: ((url: string, state: unknown) => void)[] = [];\n-      /** @internal */\n-      _urlChangeSubscription?: SubscriptionLike;\n-\n-      setInitialPath(url: string) {\n-        this._history[this._historyIndex].path = url;\n-      }\n-\n-      setBaseHref(url: string) {\n-        this._baseHref = url;\n-      }\n-\n-      path(): string {\n-        return this._history[this._historyIndex].path;\n-      }\n-\n-      getState(): unknown {\n-        return this._history[this._historyIndex].state;\n-      }\n-\n-      isCurrentPathEqualTo(path: string, query: string = ''): boolean {\n-        const givenPath = path.endsWith('/') ? path.substring(0, path.length - 1) : path;\n-        const currPath = this.path().endsWith('/') ?\n-            this.path().substring(0, this.path().length - 1) :\n-            this.path();\n-\n-        return currPath == givenPath + (query.length > 0 ? ('?' + query) : '');\n-      }\n-\n-      simulateUrlPop(pathname: string) {\n-        this._subject.emit({'url': pathname, 'pop': true, 'type': 'popstate'});\n-      }\n-\n-      simulateHashChange(pathname: string) {\n-        // Because we don't prevent the native event, the browser will independently update the path\n-        this.setInitialPath(pathname);\n-        this.urlChanges.push('hash: ' + pathname);\n-        this._subject.emit({'url': pathname, 'pop': true, 'type': 'hashchange'});\n-      }\n-\n-      prepareExternalUrl(url: string): string {\n-        if (url.length > 0 && !url.startsWith('/')) {\n-          url = '/' + url;\n-        }\n-        return this._baseHref + url;\n-      }\n-\n-      go(path: string, query: string = '', state: any = null) {\n-        path = this.prepareExternalUrl(path);\n-\n-        if (this._historyIndex > 0) {\n-          this._history.splice(this._historyIndex + 1);\n-        }\n-        this._history.push(new LocationState(path, query, state));\n-        this._historyIndex = this._history.length - 1;\n-\n-        const locationState = this._history[this._historyIndex - 1];\n-        if (locationState.path == path && locationState.query == query) {\n-          return;\n-        }\n-\n-        const url = path + (query.length > 0 ? ('?' + query) : '');\n-        this.urlChanges.push(url);\n-      }\n-\n-      replaceState(path: string, query: string = '', state: any = null) {\n-        path = this.prepareExternalUrl(path);\n-\n-        const history = this._history[this._historyIndex];\n-        if (history.path == path && history.query == query) {\n-          return;\n-        }\n-\n-        history.path = path;\n-        history.query = query;\n-        history.state = state;\n-\n-        const url = path + (query.length > 0 ? ('?' + query) : '');\n-        this.urlChanges.push('replace: ' + url);\n-      }\n-\n-      forward() {\n-        if (this._historyIndex < (this._history.length - 1)) {\n-          this._historyIndex++;\n-          this._subject.emit(\n-              {'url': this.path(), 'state': this.getState(), 'pop': true, 'type': 'popstate'});\n-        }\n-      }\n-\n-      back() {\n-        if (this._historyIndex > 0) {\n-          this._historyIndex--;\n-          this._subject.emit(\n-              {'url': this.path(), 'state': this.getState(), 'pop': true, 'type': 'popstate'});\n-        }\n-      }\n-\n-      historyGo(relativePosition: number = 0): void {\n-        const nextPageIndex = this._historyIndex + relativePosition;\n-        if (nextPageIndex >= 0 && nextPageIndex < this._history.length) {\n-          this._historyIndex = nextPageIndex;\n-          this._subject.emit(\n-              {'url': this.path(), 'state': this.getState(), 'pop': true, 'type': 'popstate'});\n-        }\n-      }\n-\n-      onUrlChange(fn: (url: string, state: unknown) => void) {\n-        this._urlChangeListeners.push(fn);\n-\n-        if (!this._urlChangeSubscription) {\n-          this._urlChangeSubscription = this.subscribe(v => {\n-            this._notifyUrlChangeListeners(v.url, v.state);\n-          });\n-        }\n-      }\n-\n-      /** @internal */\n-      _notifyUrlChangeListeners(url: string = '', state: unknown) {\n-        this._urlChangeListeners.forEach(fn => fn(url, state));\n-      }\n-\n-      subscribe(\n-          onNext: (value: any) => void, onThrow?: ((error: any) => void)|null,\n-          onReturn?: (() => void)|null): SubscriptionLike {\n-        return this._subject.subscribe({next: onNext, error: onThrow, complete: onReturn});\n-      }\n-\n-      normalize(url: string): string {\n-        return null!;\n-      }\n-    }\n-\n-    class LocationState {\n-      constructor(public path: string, public query: string, public state: any) {}\n-    }\n-\n-    @Injectable({providedIn: 'root'})\n-    class MyCanDeactivateGuard implements CanDeactivate<any> {\n-      allow: boolean = true;\n-      canDeactivate(): boolean {\n-        return this.allow;\n-      }\n-    }\n-\n-    @Injectable({providedIn: 'root'})\n-    class ThrowingCanActivateGuard implements CanActivate {\n-      throw = false;\n-\n-      constructor(private router: Router) {}\n-\n-      canActivate(): boolean {\n-        if (this.throw) {\n-          throw new Error('error in guard');\n-        }\n-        return true;\n-      }\n-    }\n-\n-    @Injectable({providedIn: 'root'})\n-    class MyCanActivateGuard implements CanActivate {\n-      allow: boolean = true;\n-      redirectTo: string|null|UrlTree = null;\n-\n-      constructor(private router: Router) {}\n-\n-      canActivate(): boolean|UrlTree {\n-        if (typeof this.redirectTo === 'string') {\n-          this.router.navigateByUrl(this.redirectTo);\n-        } else if (isUrlTree(this.redirectTo)) {\n-          return this.redirectTo;\n-        }\n-        return this.allow;\n-      }\n-    }\n-    @Injectable({providedIn: 'root'})\n-    class MyResolve implements Resolve<Observable<any>> {\n-      myresolve: Observable<any> = of(2);\n-      resolve(): Observable<any> {\n-        return this.myresolve;\n-      }\n-    }\n-\n-    @NgModule(\n-        {imports: [RouterModule.forChild([{path: '', component: BlankCmp}])]},\n-        )\n-    class LoadedModule {\n-    }\n-\n-    let fixture: ComponentFixture<unknown>;\n-\n-    beforeEach(fakeAsync(() => {\n-      TestBed.configureTestingModule({\n-        imports: [TestModule],\n-        providers: [\n-          {provide: 'alwaysFalse', useValue: (a: any) => false},\n-          {provide: Location, useClass: RouterSpyLocation}\n-        ]\n-      });\n-      const router = TestBed.inject(Router);\n-      (router as any).canceledNavigationResolution = 'computed';\n-      const location = TestBed.inject(Location);\n-      fixture = createRoot(router, RootCmp);\n-      router.resetConfig([\n-        {\n-          path: 'first',\n-          component: SimpleCmp,\n-          canDeactivate: [MyCanDeactivateGuard],\n-          canActivate: [MyCanActivateGuard, ThrowingCanActivateGuard],\n-          resolve: [MyResolve]\n-        },\n-        {\n-          path: 'second',\n-          component: SimpleCmp,\n-          canDeactivate: [MyCanDeactivateGuard],\n-          canActivate: [MyCanActivateGuard, ThrowingCanActivateGuard],\n-          resolve: [MyResolve]\n-        },\n-        {\n-          path: 'third',\n-          component: SimpleCmp,\n-          canDeactivate: [MyCanDeactivateGuard],\n-          canActivate: [MyCanActivateGuard, ThrowingCanActivateGuard],\n-          resolve: [MyResolve]\n-        },\n-        {\n-          path: 'unguarded',\n-          component: SimpleCmp,\n-        },\n-        {\n-          path: 'throwing',\n-          component: ThrowingCmp,\n-        },\n-        {path: 'loaded', loadChildren: () => of(LoadedModule), canLoad: ['alwaysFalse']}\n-      ]);\n-      router.navigateByUrl('/first');\n-      advance(fixture);\n-      expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n-\n-      router.navigateByUrl('/second');\n-      advance(fixture);\n-      expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-\n-      router.navigateByUrl('/third');\n-      advance(fixture);\n-      expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n-\n-      location.back();\n-      advance(fixture);\n-    }));\n-\n-    it('should work when CanActivate returns false', fakeAsync(() => {\n-         const location = TestBed.inject(Location);\n-         const router = TestBed.inject(Router);\n-         expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-\n-         TestBed.inject(MyCanActivateGuard).allow = false;\n-         location.back();\n-         advance(fixture);\n-         expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-\n-         TestBed.inject(MyCanActivateGuard).allow = true;\n-         location.back();\n-         advance(fixture);\n-         expect(location.path()).toEqual('/first');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n-\n-         TestBed.inject(MyCanActivateGuard).allow = false;\n-         location.forward();\n-         advance(fixture);\n-         expect(location.path()).toEqual('/first');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n-\n-         router.navigateByUrl('/second');\n-         advance(fixture);\n-         expect(location.path()).toEqual('/first');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n-       }));\n-\n-\n-    it('should work when CanDeactivate returns false', fakeAsync(() => {\n-         const location = TestBed.inject(Location);\n-         const router = TestBed.inject(Router);\n-\n-         TestBed.inject(MyCanDeactivateGuard).allow = false;\n-         location.back();\n-         advance(fixture);\n-         expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-\n-         location.forward();\n-         advance(fixture);\n-         expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-\n-         router.navigateByUrl('third');\n-         advance(fixture);\n-         expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-\n-\n-         TestBed.inject(MyCanDeactivateGuard).allow = true;\n-         location.forward();\n-         advance(fixture);\n-         expect(location.path()).toEqual('/third');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n-       }));\n-\n-    it('should work when using `NavigationExtras.skipLocationChange`', fakeAsync(() => {\n-         const location = TestBed.inject(Location);\n-         const router = TestBed.inject(Router);\n-\n-         expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-\n-         router.navigateByUrl('/first', {skipLocationChange: true});\n-         advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-\n-         router.navigateByUrl('/third');\n-         advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n-\n-         location.back();\n-         advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-       }));\n-\n-    it('should work when using `NavigationExtras.replaceUrl`', fakeAsync(() => {\n-         const location = TestBed.inject(Location);\n-         const router = TestBed.inject(Router);\n-\n-         expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-\n-         router.navigateByUrl('/first', {replaceUrl: true});\n-         advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-         expect(location.path()).toEqual('/first');\n-       }));\n-\n-    it('should work when CanLoad returns false', fakeAsync(() => {\n-         const location = TestBed.inject(Location);\n-         const router = TestBed.inject(Router);\n-\n-         router.navigateByUrl('/loaded');\n-         advance(fixture);\n-         expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-       }));\n-\n-    it('should work when resolve empty', fakeAsync(() => {\n-         const location = TestBed.inject(Location);\n-         const router = TestBed.inject(Router);\n-\n-         expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-\n-         TestBed.inject(MyResolve).myresolve = EMPTY;\n-\n-         location.back();\n-         advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-         expect(location.path()).toEqual('/second');\n-\n-         TestBed.inject(MyResolve).myresolve = of(2);\n-\n-         location.back();\n-         advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n-         expect(location.path()).toEqual('/first');\n-\n-         TestBed.inject(MyResolve).myresolve = EMPTY;\n-\n-         // We should cancel the navigation to `/third` when myresolve is empty\n-         router.navigateByUrl('/third');\n-         advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n-         expect(location.path()).toEqual('/first');\n-\n-         location.historyGo(2);\n-         advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n-         expect(location.path()).toEqual('/first');\n-\n-         TestBed.inject(MyResolve).myresolve = of(2);\n-         location.historyGo(2);\n-         advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n-         expect(location.path()).toEqual('/third');\n-\n-         TestBed.inject(MyResolve).myresolve = EMPTY;\n-         location.historyGo(-2);\n-         advance(fixture);\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n-         expect(location.path()).toEqual('/third');\n-       }));\n-\n-\n-    it('should work when an error occured during navigation', fakeAsync(() => {\n-         const location = TestBed.inject(Location);\n-         const router = TestBed.inject(Router);\n-\n-         expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-\n-\n-         router.navigateByUrl('/invalid').catch(() => null);\n-         advance(fixture);\n-         expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-\n-         location.back();\n-         advance(fixture);\n-         expect(location.path()).toEqual('/first');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n-       }));\n-\n-    it('should work when urlUpdateStrategy=\"eager\"', fakeAsync(() => {\n-         const location = TestBed.inject(Location) as SpyLocation;\n-         const router = TestBed.inject(Router);\n-         expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-         router.urlUpdateStrategy = 'eager';\n-\n-         TestBed.inject(MyCanActivateGuard).allow = false;\n-         router.navigateByUrl('/first');\n-         advance(fixture);\n-         expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-\n-         location.back();\n-         advance(fixture);\n-         expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-       }));\n-\n-    it('should work when CanActivate redirects', fakeAsync(() => {\n-         const location = TestBed.inject(Location);\n-\n-         TestBed.inject(MyCanActivateGuard).redirectTo = '/unguarded';\n-         location.back();\n-         advance(fixture);\n-         expect(location.path()).toEqual('/unguarded');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-\n-         TestBed.inject(MyCanActivateGuard).redirectTo = null;\n-\n-         location.back();\n-         advance(fixture);\n-         expect(location.path()).toEqual('/first');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n-       }));\n-\n-    it('should work when CanActivate redirects and urlUpdateStrategy=\"eager\"', fakeAsync(() => {\n-         const location = TestBed.inject(Location);\n-         const router = TestBed.inject(Router);\n-         router.urlUpdateStrategy = 'eager';\n-\n-         TestBed.inject(MyCanActivateGuard).redirectTo = '/unguarded';\n-         router.navigateByUrl('/third');\n-         advance(fixture);\n-         expect(location.path()).toEqual('/unguarded');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 4}));\n-\n-         TestBed.inject(MyCanActivateGuard).redirectTo = null;\n-\n-         location.back();\n-         advance(fixture);\n-         expect(location.path()).toEqual('/third');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n-       }));\n-\n-    it('should work when CanActivate redirects with UrlTree and urlUpdateStrategy=\"eager\"',\n-       fakeAsync(() => {\n-         // Note that this test is different from the above case because we are able to specifically\n-         // handle the `UrlTree` case as a proper redirect and set `replaceUrl: true` on the\n-         // follow-up navigation.\n-         const location = TestBed.inject(Location);\n-         const router = TestBed.inject(Router);\n-         router.urlUpdateStrategy = 'eager';\n-\n-         TestBed.inject(MyCanActivateGuard).redirectTo = router.createUrlTree(['unguarded']);\n-         router.navigateByUrl('/third');\n-         advance(fixture);\n-         expect(location.path()).toEqual('/unguarded');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 3}));\n-\n-         TestBed.inject(MyCanActivateGuard).redirectTo = null;\n-\n-         location.back();\n-         advance(fixture);\n-         expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-       }));\n-\n-    for (const urlUpdateSrategy of ['deferred', 'eager'] as const) {\n-      it(`restores history correctly when an error is thrown in guard with urlUpdateStrategy ${\n-             urlUpdateSrategy}`,\n-         fakeAsync(() => {\n-           const location = TestBed.inject(Location);\n-           const router = TestBed.inject(Router);\n-           router.urlUpdateStrategy = urlUpdateSrategy;\n-\n-           TestBed.inject(ThrowingCanActivateGuard).throw = true;\n-\n-           expect(() => {\n-             location.back();\n-             advance(fixture);\n-           }).toThrow();\n-           expect(location.path()).toEqual('/second');\n-           expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-\n-           TestBed.inject(ThrowingCanActivateGuard).throw = false;\n-           location.back();\n-           advance(fixture);\n-           expect(location.path()).toEqual('/first');\n-           expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n-         }));\n-\n-      it(`restores history correctly when component throws error in constructor with urlUpdateStrategy ${\n-             urlUpdateSrategy}`,\n-         fakeAsync(() => {\n-           const location = TestBed.inject(Location);\n-           const router = TestBed.inject(Router);\n-           router.urlUpdateStrategy = urlUpdateSrategy;\n-\n-           router.navigateByUrl('/throwing').catch(() => null);\n-           advance(fixture);\n-           expect(location.path()).toEqual('/second');\n-           expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-\n-           location.back();\n-           advance(fixture);\n-           expect(location.path()).toEqual('/first');\n-           expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n-         }));\n-    }\n-\n-    it('restores history correctly when component throws error in constructor and replaceUrl=true',\n-       fakeAsync(() => {\n-         const location = TestBed.inject(Location);\n-         const router = TestBed.inject(Router);\n-\n-         router.navigateByUrl('/throwing', {replaceUrl: true}).catch(() => null);\n-         advance(fixture);\n-         expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-\n-         location.back();\n-         advance(fixture);\n-         expect(location.path()).toEqual('/first');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n-       }));\n-\n-    it('restores history correctly when component throws error in constructor and skipLocationChange=true',\n-       fakeAsync(() => {\n-         const location = TestBed.inject(Location);\n-         const router = TestBed.inject(Router);\n-\n-         router.navigateByUrl('/throwing', {skipLocationChange: true}).catch(() => null);\n-         advance(fixture);\n-         expect(location.path()).toEqual('/second');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 2}));\n-\n-         location.back();\n-         advance(fixture);\n-         expect(location.path()).toEqual('/first');\n-         expect(location.getState()).toEqual(jasmine.objectContaining({ɵrouterPageId: 1}));\n-       }));\n-  });\n   describe('guards', () => {\n     describe('CanActivate', () => {\n       describe('should not activate a route when CanActivate returns false', () => {"
        }
    ],
    "stats": {
        "total": 1239,
        "additions": 652,
        "deletions": 587
    }
}