{
    "author": "kyliau",
    "message": "refactor(language-service): [Ivy] remove temporary compiler (#38310)\n\nNow that Ivy compiler has a proper `TemplateTypeChecker` interface\n(see https://github.com/angular/angular/pull/38105) we no longer need to\nkeep the temporary compiler implementation.\n\nThe temporary compiler was created to enable testing infrastructure to\nbe developed for the Ivy language service.\n\nThis commit removes the whole `ivy/compiler` directory and moves two\nfunctions `createTypeCheckingProgramStrategy` and\n`getOrCreateTypeCheckScriptInfo` to the `LanguageService` class.\n\nAlso re-enable the Ivy LS test since it's no longer blocking development.\n\nPR Close #38310",
    "sha": "cfe424e875f77bf7708feeea9a2347790d14aaf2",
    "files": [
        {
            "sha": "3519eedd136e066509fb21bc6fe17ad54e115a0c",
            "filename": "packages/language-service/ivy/BUILD.bazel",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/cfe424e875f77bf7708feeea9a2347790d14aaf2/packages%2Flanguage-service%2Fivy%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/cfe424e875f77bf7708feeea9a2347790d14aaf2/packages%2Flanguage-service%2Fivy%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2FBUILD.bazel?ref=cfe424e875f77bf7708feeea9a2347790d14aaf2",
            "patch": "@@ -7,7 +7,13 @@ ts_library(\n     srcs = glob([\"*.ts\"]),\n     deps = [\n         \"//packages/compiler-cli\",\n-        \"//packages/language-service/ivy/compiler\",\n+        \"//packages/compiler-cli/src/ngtsc/core\",\n+        \"//packages/compiler-cli/src/ngtsc/core:api\",\n+        \"//packages/compiler-cli/src/ngtsc/file_system\",\n+        \"//packages/compiler-cli/src/ngtsc/incremental\",\n+        \"//packages/compiler-cli/src/ngtsc/shims\",\n+        \"//packages/compiler-cli/src/ngtsc/typecheck\",\n+        \"//packages/compiler-cli/src/ngtsc/typecheck/api\",\n         \"@npm//typescript\",\n     ],\n )"
        },
        {
            "sha": "22c25e3ba19b92109954f5bb1d35b211629a1b87",
            "filename": "packages/language-service/ivy/compiler/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 17,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/3b9c802deefcc53ab2b759ac8650449bed75aa9a/packages%2Flanguage-service%2Fivy%2Fcompiler%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/3b9c802deefcc53ab2b759ac8650449bed75aa9a/packages%2Flanguage-service%2Fivy%2Fcompiler%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fcompiler%2FBUILD.bazel?ref=3b9c802deefcc53ab2b759ac8650449bed75aa9a",
            "patch": "@@ -1,17 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-package(default_visibility = [\"//packages/language-service/ivy:__pkg__\"])\n-\n-ts_library(\n-    name = \"compiler\",\n-    srcs = glob([\"*.ts\"]),\n-    deps = [\n-        \"//packages/compiler-cli\",\n-        \"//packages/compiler-cli/src/ngtsc/core\",\n-        \"//packages/compiler-cli/src/ngtsc/file_system\",\n-        \"//packages/compiler-cli/src/ngtsc/incremental\",\n-        \"//packages/compiler-cli/src/ngtsc/typecheck\",\n-        \"//packages/compiler-cli/src/ngtsc/typecheck/api\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "2945bc7dac0ef837fed30f383528dafeda5e1bd9",
            "filename": "packages/language-service/ivy/compiler/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/3b9c802deefcc53ab2b759ac8650449bed75aa9a/packages%2Flanguage-service%2Fivy%2Fcompiler%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/3b9c802deefcc53ab2b759ac8650449bed75aa9a/packages%2Flanguage-service%2Fivy%2Fcompiler%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fcompiler%2FREADME.md?ref=3b9c802deefcc53ab2b759ac8650449bed75aa9a",
            "patch": "@@ -1,2 +0,0 @@\n-All files in this directory are temporary. This is created to simulate the final\n-form of the Ivy compiler that supports language service."
        },
        {
            "sha": "9454666ffb20174bd8f56b8bb13c70f0f0fdfbb2",
            "filename": "packages/language-service/ivy/compiler/compiler.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 124,
            "changes": 124,
            "blob_url": "https://github.com/angular/angular/blob/3b9c802deefcc53ab2b759ac8650449bed75aa9a/packages%2Flanguage-service%2Fivy%2Fcompiler%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/3b9c802deefcc53ab2b759ac8650449bed75aa9a/packages%2Flanguage-service%2Fivy%2Fcompiler%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fcompiler%2Fcompiler.ts?ref=3b9c802deefcc53ab2b759ac8650449bed75aa9a",
            "patch": "@@ -1,124 +0,0 @@\n-\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompilerOptions} from '@angular/compiler-cli';\n-import {NgCompiler, NgCompilerHost} from '@angular/compiler-cli/src/ngtsc/core';\n-import {absoluteFromSourceFile, AbsoluteFsPath} from '@angular/compiler-cli/src/ngtsc/file_system';\n-import {PatchedProgramIncrementalBuildStrategy} from '@angular/compiler-cli/src/ngtsc/incremental';\n-import {TypeCheckShimGenerator} from '@angular/compiler-cli/src/ngtsc/typecheck';\n-import {TypeCheckingProgramStrategy, UpdateMode} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n-import * as ts from 'typescript/lib/tsserverlibrary';\n-\n-import {makeCompilerHostFromProject} from './compiler_host';\n-\n-interface AnalysisResult {\n-  compiler: NgCompiler;\n-  program: ts.Program;\n-}\n-\n-export class Compiler {\n-  private tsCompilerHost: ts.CompilerHost;\n-  private lastKnownProgram: ts.Program|null = null;\n-  private readonly strategy: TypeCheckingProgramStrategy;\n-\n-  constructor(private readonly project: ts.server.Project, private options: CompilerOptions) {\n-    this.tsCompilerHost = makeCompilerHostFromProject(project);\n-    this.strategy = createTypeCheckingProgramStrategy(project);\n-    // Do not retrieve the program in constructor because project is still in\n-    // the process of loading, and not all data members have been initialized.\n-  }\n-\n-  setCompilerOptions(options: CompilerOptions) {\n-    this.options = options;\n-  }\n-\n-  analyze(): AnalysisResult|undefined {\n-    const inputFiles = this.project.getRootFiles();\n-    const ngCompilerHost =\n-        NgCompilerHost.wrap(this.tsCompilerHost, inputFiles, this.options, this.lastKnownProgram);\n-    const program = this.strategy.getProgram();\n-    const compiler = new NgCompiler(\n-        ngCompilerHost, this.options, program, this.strategy,\n-        new PatchedProgramIncrementalBuildStrategy(), this.lastKnownProgram);\n-    try {\n-      // This is the only way to force the compiler to update the typecheck file\n-      // in the program. We have to do try-catch because the compiler immediately\n-      // throws if it fails to parse any template in the entire program!\n-      const d = compiler.getDiagnostics();\n-      if (d.length) {\n-        // There could be global compilation errors. It's useful to print them\n-        // out in development.\n-        console.error(d.map(d => ts.flattenDiagnosticMessageText(d.messageText, '\\n')));\n-      }\n-    } catch (e) {\n-      console.error('Failed to analyze program', e.message);\n-      return;\n-    }\n-    this.lastKnownProgram = compiler.getNextProgram();\n-    return {\n-      compiler,\n-      program: this.lastKnownProgram,\n-    };\n-  }\n-}\n-\n-function createTypeCheckingProgramStrategy(project: ts.server.Project):\n-    TypeCheckingProgramStrategy {\n-  return {\n-    supportsInlineOperations: false,\n-    shimPathForComponent(component: ts.ClassDeclaration): AbsoluteFsPath {\n-      return TypeCheckShimGenerator.shimFor(absoluteFromSourceFile(component.getSourceFile()));\n-    },\n-    getProgram(): ts.Program {\n-      const program = project.getLanguageService().getProgram();\n-      if (!program) {\n-        throw new Error('Language service does not have a program!');\n-      }\n-      return program;\n-    },\n-    updateFiles(contents: Map<AbsoluteFsPath, string>, updateMode: UpdateMode) {\n-      if (updateMode !== UpdateMode.Complete) {\n-        throw new Error(`Incremental update mode is currently not supported`);\n-      }\n-      for (const [fileName, newText] of contents) {\n-        const scriptInfo = getOrCreateTypeCheckScriptInfo(project, fileName);\n-        const snapshot = scriptInfo.getSnapshot();\n-        const length = snapshot.getLength();\n-        scriptInfo.editContent(0, length, newText);\n-      }\n-    },\n-  };\n-}\n-\n-function getOrCreateTypeCheckScriptInfo(\n-    project: ts.server.Project, tcf: string): ts.server.ScriptInfo {\n-  // First check if there is already a ScriptInfo for the tcf\n-  const {projectService} = project;\n-  let scriptInfo = projectService.getScriptInfo(tcf);\n-  if (!scriptInfo) {\n-    // ScriptInfo needs to be opened by client to be able to set its user-defined\n-    // content. We must also provide file content, otherwise the service will\n-    // attempt to fetch the content from disk and fail.\n-    scriptInfo = projectService.getOrCreateScriptInfoForNormalizedPath(\n-        ts.server.toNormalizedPath(tcf),\n-        true,              // openedByClient\n-        '',                // fileContent\n-        ts.ScriptKind.TS,  // scriptKind\n-    );\n-    if (!scriptInfo) {\n-      throw new Error(`Failed to create script info for ${tcf}`);\n-    }\n-  }\n-  // Add ScriptInfo to project if it's missing. A ScriptInfo needs to be part of\n-  // the project so that it becomes part of the program.\n-  if (!project.containsScriptInfo(scriptInfo)) {\n-    project.addRoot(scriptInfo);\n-  }\n-  return scriptInfo;\n-}"
        },
        {
            "sha": "f417ed2541436e665a333463ed8d30921f5c91b5",
            "filename": "packages/language-service/ivy/compiler/compiler_host.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 103,
            "changes": 103,
            "blob_url": "https://github.com/angular/angular/blob/3b9c802deefcc53ab2b759ac8650449bed75aa9a/packages%2Flanguage-service%2Fivy%2Fcompiler%2Fcompiler_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/3b9c802deefcc53ab2b759ac8650449bed75aa9a/packages%2Flanguage-service%2Fivy%2Fcompiler%2Fcompiler_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fcompiler%2Fcompiler_host.ts?ref=3b9c802deefcc53ab2b759ac8650449bed75aa9a",
            "patch": "@@ -1,103 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as ts from 'typescript/lib/tsserverlibrary';\n-\n-export function makeCompilerHostFromProject(project: ts.server.Project): ts.CompilerHost {\n-  const compilerHost: ts.CompilerHost = {\n-    fileExists(fileName: string): boolean {\n-      return project.fileExists(fileName);\n-    },\n-    readFile(fileName: string): string |\n-        undefined {\n-          return project.readFile(fileName);\n-        },\n-    directoryExists(directoryName: string): boolean {\n-      return project.directoryExists(directoryName);\n-    },\n-    getCurrentDirectory(): string {\n-      return project.getCurrentDirectory();\n-    },\n-    getDirectories(path: string): string[] {\n-      return project.getDirectories(path);\n-    },\n-    getSourceFile(\n-        fileName: string, languageVersion: ts.ScriptTarget, onError?: (message: string) => void,\n-        shouldCreateNewSourceFile?: boolean): ts.SourceFile |\n-        undefined {\n-          const path = project.projectService.toPath(fileName);\n-          return project.getSourceFile(path);\n-        },\n-    getSourceFileByPath(\n-        fileName: string, path: ts.Path, languageVersion: ts.ScriptTarget,\n-        onError?: (message: string) => void, shouldCreateNewSourceFile?: boolean): ts.SourceFile |\n-        undefined {\n-          return project.getSourceFile(path);\n-        },\n-    getCancellationToken(): ts.CancellationToken {\n-      return {\n-        isCancellationRequested() {\n-          return project.getCancellationToken().isCancellationRequested();\n-        },\n-        throwIfCancellationRequested() {\n-          if (this.isCancellationRequested()) {\n-            throw new ts.OperationCanceledException();\n-          }\n-        },\n-      };\n-    },\n-    getDefaultLibFileName(options: ts.CompilerOptions): string {\n-      return project.getDefaultLibFileName();\n-    },\n-    writeFile(\n-        fileName: string, data: string, writeByteOrderMark: boolean,\n-        onError?: (message: string) => void, sourceFiles?: readonly ts.SourceFile[]) {\n-      return project.writeFile(fileName, data);\n-    },\n-    getCanonicalFileName(fileName: string): string {\n-      return project.projectService.toCanonicalFileName(fileName);\n-    },\n-    useCaseSensitiveFileNames(): boolean {\n-      return project.useCaseSensitiveFileNames();\n-    },\n-    getNewLine(): string {\n-      return project.getNewLine();\n-    },\n-    readDirectory(\n-        rootDir: string, extensions: readonly string[], excludes: readonly string[]|undefined,\n-        includes: readonly string[], depth?: number): string[] {\n-      return project.readDirectory(rootDir, extensions, excludes, includes, depth);\n-    },\n-    resolveModuleNames(\n-        moduleNames: string[], containingFile: string, reusedNames: string[]|undefined,\n-        redirectedReference: ts.ResolvedProjectReference|undefined, options: ts.CompilerOptions):\n-        (ts.ResolvedModule | undefined)[] {\n-          return project.resolveModuleNames(\n-              moduleNames, containingFile, reusedNames, redirectedReference);\n-        },\n-    resolveTypeReferenceDirectives(\n-        typeReferenceDirectiveNames: string[], containingFile: string,\n-        redirectedReference: ts.ResolvedProjectReference|undefined, options: ts.CompilerOptions):\n-        (ts.ResolvedTypeReferenceDirective | undefined)[] {\n-          return project.resolveTypeReferenceDirectives(\n-              typeReferenceDirectiveNames, containingFile, redirectedReference);\n-        },\n-  };\n-\n-  if (project.trace) {\n-    compilerHost.trace = function trace(s: string) {\n-      project.trace!(s);\n-    };\n-  }\n-  if (project.realpath) {\n-    compilerHost.realpath = function realpath(path: string): string {\n-      return project.realpath!(path);\n-    };\n-  }\n-  return compilerHost;\n-}"
        },
        {
            "sha": "128c1ed1a92f3767bd42990c6ce3dacf549293c4",
            "filename": "packages/language-service/ivy/language_service.ts",
            "status": "modified",
            "additions": 112,
            "deletions": 13,
            "changes": 125,
            "blob_url": "https://github.com/angular/angular/blob/cfe424e875f77bf7708feeea9a2347790d14aaf2/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "raw_url": "https://github.com/angular/angular/raw/cfe424e875f77bf7708feeea9a2347790d14aaf2/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts?ref=cfe424e875f77bf7708feeea9a2347790d14aaf2",
            "patch": "@@ -7,30 +7,53 @@\n  */\n \n import {CompilerOptions, createNgCompilerOptions} from '@angular/compiler-cli';\n+import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n+import {NgCompilerAdapter} from '@angular/compiler-cli/src/ngtsc/core/api';\n+import {absoluteFrom, absoluteFromSourceFile, AbsoluteFsPath} from '@angular/compiler-cli/src/ngtsc/file_system';\n+import {PatchedProgramIncrementalBuildStrategy} from '@angular/compiler-cli/src/ngtsc/incremental';\n+import {isShim} from '@angular/compiler-cli/src/ngtsc/shims';\n+import {TypeCheckShimGenerator} from '@angular/compiler-cli/src/ngtsc/typecheck';\n+import {OptimizeFor, TypeCheckingProgramStrategy} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import * as ts from 'typescript/lib/tsserverlibrary';\n-import {Compiler} from './compiler/compiler';\n \n export class LanguageService {\n   private options: CompilerOptions;\n-  private readonly compiler: Compiler;\n+  private lastKnownProgram: ts.Program|null = null;\n+  private readonly strategy: TypeCheckingProgramStrategy;\n+  private readonly adapter: NgCompilerAdapter;\n \n   constructor(project: ts.server.Project, private readonly tsLS: ts.LanguageService) {\n     this.options = parseNgCompilerOptions(project);\n+    this.strategy = createTypeCheckingProgramStrategy(project);\n+    this.adapter = createNgCompilerAdapter(project);\n     this.watchConfigFile(project);\n-    this.compiler = new Compiler(project, this.options);\n   }\n \n   getSemanticDiagnostics(fileName: string): ts.Diagnostic[] {\n-    const result = this.compiler.analyze();\n-    if (!result) {\n-      return [];\n+    const program = this.strategy.getProgram();\n+    const compiler = this.createCompiler(program);\n+    if (fileName.endsWith('.ts')) {\n+      const sourceFile = program.getSourceFile(fileName);\n+      if (!sourceFile) {\n+        return [];\n+      }\n+      const ttc = compiler.getTemplateTypeChecker();\n+      const diagnostics = ttc.getDiagnosticsForFile(sourceFile, OptimizeFor.SingleFile);\n+      this.lastKnownProgram = compiler.getNextProgram();\n+      return diagnostics;\n     }\n-    const {compiler, program} = result;\n-    const sourceFile = program.getSourceFile(fileName);\n-    if (!sourceFile) {\n-      return [];\n-    }\n-    return compiler.getDiagnostics(sourceFile);\n+    throw new Error('Ivy LS currently does not support external template');\n+  }\n+\n+  private createCompiler(program: ts.Program): NgCompiler {\n+    return new NgCompiler(\n+        this.adapter,\n+        this.options,\n+        program,\n+        this.strategy,\n+        new PatchedProgramIncrementalBuildStrategy(),\n+        this.lastKnownProgram,\n+    );\n   }\n \n   private watchConfigFile(project: ts.server.Project) {\n@@ -47,7 +70,6 @@ export class LanguageService {\n           project.log(`Config file changed: ${fileName}`);\n           if (eventKind === ts.FileWatcherEventKind.Changed) {\n             this.options = parseNgCompilerOptions(project);\n-            this.compiler.setCompilerOptions(this.options);\n           }\n         });\n   }\n@@ -66,3 +88,80 @@ export function parseNgCompilerOptions(project: ts.server.Project): CompilerOpti\n   const basePath = project.getCurrentDirectory();\n   return createNgCompilerOptions(basePath, config, project.getCompilationSettings());\n }\n+\n+function createNgCompilerAdapter(project: ts.server.Project): NgCompilerAdapter {\n+  return {\n+    entryPoint: null,  // entry point is only needed if code is emitted\n+    constructionDiagnostics: [],\n+    ignoreForEmit: new Set(),\n+    factoryTracker: null,      // no .ngfactory shims\n+    unifiedModulesHost: null,  // only used in Bazel\n+    rootDirs: project.getCompilationSettings().rootDirs?.map(absoluteFrom) || [],\n+    isShim,\n+    fileExists(fileName: string): boolean {\n+      return project.fileExists(fileName);\n+    },\n+    readFile(fileName: string): string |\n+        undefined {\n+          return project.readFile(fileName);\n+        },\n+    getCurrentDirectory(): string {\n+      return project.getCurrentDirectory();\n+    },\n+    getCanonicalFileName(fileName: string): string {\n+      return project.projectService.toCanonicalFileName(fileName);\n+    },\n+  };\n+}\n+\n+function createTypeCheckingProgramStrategy(project: ts.server.Project):\n+    TypeCheckingProgramStrategy {\n+  return {\n+    supportsInlineOperations: false,\n+    shimPathForComponent(component: ts.ClassDeclaration): AbsoluteFsPath {\n+      return TypeCheckShimGenerator.shimFor(absoluteFromSourceFile(component.getSourceFile()));\n+    },\n+    getProgram(): ts.Program {\n+      const program = project.getLanguageService().getProgram();\n+      if (!program) {\n+        throw new Error('Language service does not have a program!');\n+      }\n+      return program;\n+    },\n+    updateFiles(contents: Map<AbsoluteFsPath, string>) {\n+      for (const [fileName, newText] of contents) {\n+        const scriptInfo = getOrCreateTypeCheckScriptInfo(project, fileName);\n+        const snapshot = scriptInfo.getSnapshot();\n+        const length = snapshot.getLength();\n+        scriptInfo.editContent(0, length, newText);\n+      }\n+    },\n+  };\n+}\n+\n+function getOrCreateTypeCheckScriptInfo(\n+    project: ts.server.Project, tcf: string): ts.server.ScriptInfo {\n+  // First check if there is already a ScriptInfo for the tcf\n+  const {projectService} = project;\n+  let scriptInfo = projectService.getScriptInfo(tcf);\n+  if (!scriptInfo) {\n+    // ScriptInfo needs to be opened by client to be able to set its user-defined\n+    // content. We must also provide file content, otherwise the service will\n+    // attempt to fetch the content from disk and fail.\n+    scriptInfo = projectService.getOrCreateScriptInfoForNormalizedPath(\n+        ts.server.toNormalizedPath(tcf),\n+        true,              // openedByClient\n+        '',                // fileContent\n+        ts.ScriptKind.TS,  // scriptKind\n+    );\n+    if (!scriptInfo) {\n+      throw new Error(`Failed to create script info for ${tcf}`);\n+    }\n+  }\n+  // Add ScriptInfo to project if it's missing. A ScriptInfo needs to be part of\n+  // the project so that it becomes part of the program.\n+  if (!project.containsScriptInfo(scriptInfo)) {\n+    project.addRoot(scriptInfo);\n+  }\n+  return scriptInfo;\n+}"
        },
        {
            "sha": "7d539e9e6b1f5bd4079934fb2443d928b1264a48",
            "filename": "packages/language-service/ivy/test/BUILD.bazel",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/cfe424e875f77bf7708feeea9a2347790d14aaf2/packages%2Flanguage-service%2Fivy%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/cfe424e875f77bf7708feeea9a2347790d14aaf2/packages%2Flanguage-service%2Fivy%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2FBUILD.bazel?ref=cfe424e875f77bf7708feeea9a2347790d14aaf2",
            "patch": "@@ -25,7 +25,6 @@ jasmine_node_test(\n     ],\n     tags = [\n         \"ivy-only\",\n-        \"manual\",  # do not run this on CI since compiler APIs are not yet stable\n     ],\n     deps = [\n         \":test_lib\","
        }
    ],
    "stats": {
        "total": 380,
        "additions": 119,
        "deletions": 261
    }
}