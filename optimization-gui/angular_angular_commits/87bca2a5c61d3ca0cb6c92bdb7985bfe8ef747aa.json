{
    "author": "JoostK",
    "message": "perf(compiler-cli): avoid module resolution in cycle analysis (#40948)\n\nThe compiler performs cycle analysis for the used directives and pipes\nof a component's template to avoid introducing a cyclic import into the\ngenerated output. The used directives and pipes are represented by their\noutput expression which would typically be an `ExternalExpr`; those are\nresponsible for the generation of an `import` statement. Cycle analysis\nneeds to determine the `ts.SourceFile` that would end up being imported\nby these `ExternalExpr`s, as the `ts.SourceFile` is then checked against\nthe program's `ImportGraph` to determine if the import is allowed, i.e.\ndoes not introduce a cycle. To accomplish this, the `ExternalExpr` was\ndissected and ran through module resolution to obtain the imported\n`ts.SourceFile`.\n\nThis module resolution step is relatively expensive, as it typically\nneeds to hit the filesystem. Even in the presence of a module resolution\ncache would these module resolution requests generally see cache misses,\nas the generated import originates from a file for which the cache has\nnot previously seen the imported module specifier.\n\nThis commit removes the need for the module resolution by wrapping the\ngenerated `Expression` in an `EmittedReference` struct. This allows the\nreference emitter mechanism that is responsible for generating the\n`Expression` to also communicate from which `ts.SourceFile` the\ngenerated `Expression` would be imported, precluding the need for module\nresolution down the road.\n\nPR Close #40948",
    "sha": "87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa",
    "files": [
        {
            "sha": "ed83da47960a50e04e2584466c9c2cf3a6aa06c0",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/component.ts",
            "status": "modified",
            "additions": 43,
            "deletions": 19,
            "changes": 62,
            "blob_url": "https://github.com/angular/angular/blob/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts?ref=87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa",
            "patch": "@@ -12,7 +12,7 @@ import * as ts from 'typescript';\n import {Cycle, CycleAnalyzer, CycleHandlingStrategy} from '../../cycles';\n import {ErrorCode, FatalDiagnosticError, makeDiagnostic, makeRelatedInformation} from '../../diagnostics';\n import {absoluteFrom, relative} from '../../file_system';\n-import {DefaultImportRecorder, ModuleResolver, Reference, ReferenceEmitter} from '../../imports';\n+import {DefaultImportRecorder, ImportedFile, ModuleResolver, Reference, ReferenceEmitter} from '../../imports';\n import {DependencyTracker} from '../../incremental/api';\n import {extractSemanticTypeParameters, isArrayEqual, isReferenceEqual, SemanticDepGraphUpdater, SemanticReference, SemanticSymbol} from '../../incremental/semantic_graph';\n import {IndexingContext} from '../../indexer';\n@@ -628,29 +628,40 @@ export class ComponentDecoratorHandler implements\n       const bound = binder.bind({template: metadata.template.nodes});\n \n       // The BoundTarget knows which directives and pipes matched the template.\n-      type UsedDirective = R3UsedDirectiveMetadata&{ref: Reference<ClassDeclaration>};\n+      type UsedDirective =\n+          R3UsedDirectiveMetadata&{ref: Reference<ClassDeclaration>, importedFile: ImportedFile};\n       const usedDirectives: UsedDirective[] = bound.getUsedDirectives().map(directive => {\n+        const type = this.refEmitter.emit(directive.ref, context);\n         return {\n           ref: directive.ref,\n-          type: this.refEmitter.emit(directive.ref, context),\n+          type: type.expression,\n+          importedFile: type.importedFile,\n           selector: directive.selector,\n           inputs: directive.inputs.propertyNames,\n           outputs: directive.outputs.propertyNames,\n           exportAs: directive.exportAs,\n           isComponent: directive.isComponent,\n         };\n       });\n-      type UsedPipe = {ref: Reference<ClassDeclaration>, pipeName: string, expression: Expression};\n+\n+      type UsedPipe = {\n+        ref: Reference<ClassDeclaration>,\n+        pipeName: string,\n+        expression: Expression,\n+        importedFile: ImportedFile,\n+      };\n       const usedPipes: UsedPipe[] = [];\n       for (const pipeName of bound.getUsedPipes()) {\n         if (!pipes.has(pipeName)) {\n           continue;\n         }\n         const pipe = pipes.get(pipeName)!;\n+        const type = this.refEmitter.emit(pipe, context);\n         usedPipes.push({\n           ref: pipe,\n           pipeName,\n-          expression: this.refEmitter.emit(pipe, context),\n+          expression: type.expression,\n+          importedFile: type.importedFile,\n         });\n       }\n       if (this.semanticDepGraphUpdater !== null) {\n@@ -665,14 +676,16 @@ export class ComponentDecoratorHandler implements\n       // import which needs to be generated would create a cycle.\n       const cyclesFromDirectives = new Map<UsedDirective, Cycle>();\n       for (const usedDirective of usedDirectives) {\n-        const cycle = this._checkForCyclicImport(usedDirective.ref, usedDirective.type, context);\n+        const cycle =\n+            this._checkForCyclicImport(usedDirective.importedFile, usedDirective.type, context);\n         if (cycle !== null) {\n           cyclesFromDirectives.set(usedDirective, cycle);\n         }\n       }\n       const cyclesFromPipes = new Map<UsedPipe, Cycle>();\n       for (const usedPipe of usedPipes) {\n-        const cycle = this._checkForCyclicImport(usedPipe.ref, usedPipe.expression, context);\n+        const cycle =\n+            this._checkForCyclicImport(usedPipe.importedFile, usedPipe.expression, context);\n         if (cycle !== null) {\n           cyclesFromPipes.set(usedPipe, cycle);\n         }\n@@ -682,11 +695,11 @@ export class ComponentDecoratorHandler implements\n       if (!cycleDetected) {\n         // No cycle was detected. Record the imports that need to be created in the cycle detector\n         // so that future cyclic import checks consider their production.\n-        for (const {type} of usedDirectives) {\n-          this._recordSyntheticImport(type, context);\n+        for (const {type, importedFile} of usedDirectives) {\n+          this._recordSyntheticImport(importedFile, type, context);\n         }\n-        for (const {expression} of usedPipes) {\n-          this._recordSyntheticImport(expression, context);\n+        for (const {expression, importedFile} of usedPipes) {\n+          this._recordSyntheticImport(importedFile, expression, context);\n         }\n \n         // Check whether the directive/pipe arrays in ɵcmp need to be wrapped in closures.\n@@ -1189,7 +1202,17 @@ export class ComponentDecoratorHandler implements\n     }\n   }\n \n-  private _expressionToImportedFile(expr: Expression, origin: ts.SourceFile): ts.SourceFile|null {\n+  private _resolveImportedFile(importedFile: ImportedFile, expr: Expression, origin: ts.SourceFile):\n+      ts.SourceFile|null {\n+    // If `importedFile` is not 'unknown' then it accurately reflects the source file that is\n+    // being imported.\n+    if (importedFile !== 'unknown') {\n+      return importedFile;\n+    }\n+\n+    // Otherwise `expr` has to be inspected to determine the file that is being imported. If `expr`\n+    // is not an `ExternalExpr` then it does not correspond with an import, so return null in that\n+    // case.\n     if (!(expr instanceof ExternalExpr)) {\n       return null;\n     }\n@@ -1204,18 +1227,19 @@ export class ComponentDecoratorHandler implements\n    *\n    * @returns a `Cycle` object if a cycle would be created, otherwise `null`.\n    */\n-  private _checkForCyclicImport(ref: Reference, expr: Expression, origin: ts.SourceFile): Cycle\n-      |null {\n-    const importedFile = this._expressionToImportedFile(expr, origin);\n-    if (importedFile === null) {\n+  private _checkForCyclicImport(\n+      importedFile: ImportedFile, expr: Expression, origin: ts.SourceFile): Cycle|null {\n+    const imported = this._resolveImportedFile(importedFile, expr, origin);\n+    if (imported === null) {\n       return null;\n     }\n     // Check whether the import is legal.\n-    return this.cycleAnalyzer.wouldCreateCycle(origin, importedFile);\n+    return this.cycleAnalyzer.wouldCreateCycle(origin, imported);\n   }\n \n-  private _recordSyntheticImport(expr: Expression, origin: ts.SourceFile): void {\n-    const imported = this._expressionToImportedFile(expr, origin);\n+  private _recordSyntheticImport(\n+      importedFile: ImportedFile, expr: Expression, origin: ts.SourceFile): void {\n+    const imported = this._resolveImportedFile(importedFile, expr, origin);\n     if (imported === null) {\n       return;\n     }"
        },
        {
            "sha": "76e3cc541183f9523af47ff389e0564e88196d36",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/ng_module.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fng_module.ts",
            "raw_url": "https://github.com/angular/angular/raw/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fng_module.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fng_module.ts?ref=87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa",
            "patch": "@@ -418,7 +418,7 @@ export class NgModuleDecoratorHandler implements\n       const context = getSourceFile(node);\n       for (const exportRef of analysis.exports) {\n         if (isNgModule(exportRef.node, scope.compilation)) {\n-          data.injectorImports.push(this.refEmitter.emit(exportRef, context));\n+          data.injectorImports.push(this.refEmitter.emit(exportRef, context).expression);\n         }\n       }\n \n@@ -466,12 +466,12 @@ export class NgModuleDecoratorHandler implements\n     for (const decl of analysis.declarations) {\n       const remoteScope = this.scopeRegistry.getRemoteScope(decl.node);\n       if (remoteScope !== null) {\n-        const directives =\n-            remoteScope.directives.map(directive => this.refEmitter.emit(directive, context));\n-        const pipes = remoteScope.pipes.map(pipe => this.refEmitter.emit(pipe, context));\n+        const directives = remoteScope.directives.map(\n+            directive => this.refEmitter.emit(directive, context).expression);\n+        const pipes = remoteScope.pipes.map(pipe => this.refEmitter.emit(pipe, context).expression);\n         const directiveArray = new LiteralArrayExpr(directives);\n         const pipesArray = new LiteralArrayExpr(pipes);\n-        const declExpr = this.refEmitter.emit(decl, context)!;\n+        const declExpr = this.refEmitter.emit(decl, context).expression;\n         const setComponentScope = new ExternalExpr(R3Identifiers.setComponentScope);\n         const callExpr =\n             new InvokeFunctionExpr(setComponentScope, [declExpr, directiveArray, pipesArray]);"
        },
        {
            "sha": "47e787a6095978d234da9cfdb0e2b0d285e38f82",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/util.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Futil.ts?ref=87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa",
            "patch": "@@ -267,13 +267,12 @@ function createUnsuitableInjectionTokenError(\n export function toR3Reference(\n     valueRef: Reference, typeRef: Reference, valueContext: ts.SourceFile,\n     typeContext: ts.SourceFile, refEmitter: ReferenceEmitter): R3Reference {\n-  const value = refEmitter.emit(valueRef, valueContext);\n-  const type = refEmitter.emit(\n-      typeRef, typeContext, ImportFlags.ForceNewImport | ImportFlags.AllowTypeImports);\n-  if (value === null || type === null) {\n-    throw new Error(`Could not refer to ${ts.SyntaxKind[valueRef.node.kind]}`);\n-  }\n-  return {value, type};\n+  return {\n+    value: refEmitter.emit(valueRef, valueContext).expression,\n+    type: refEmitter\n+              .emit(typeRef, typeContext, ImportFlags.ForceNewImport | ImportFlags.AllowTypeImports)\n+              .expression,\n+  };\n }\n \n export function isAngularCore(decorator: Decorator): decorator is Decorator&{import: Import} {"
        },
        {
            "sha": "8843ad182498a5ee674f2ced3525d7b65d395f4a",
            "filename": "packages/compiler-cli/src/ngtsc/imports/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Findex.ts?ref=87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa",
            "patch": "@@ -9,7 +9,7 @@\n export {AliasingHost, AliasStrategy, PrivateExportAliasingHost, UnifiedModulesAliasingHost} from './src/alias';\n export {ImportRewriter, NoopImportRewriter, R3SymbolsImportRewriter, validateAndRewriteCoreSymbol} from './src/core';\n export {DefaultImportRecorder, DefaultImportTracker, NOOP_DEFAULT_IMPORT_RECORDER} from './src/default';\n-export {AbsoluteModuleStrategy, ImportFlags, LocalIdentifierStrategy, LogicalProjectStrategy, ReferenceEmitStrategy, ReferenceEmitter, RelativePathStrategy, UnifiedModulesStrategy} from './src/emitter';\n+export {AbsoluteModuleStrategy, EmittedReference, ImportedFile, ImportFlags, LocalIdentifierStrategy, LogicalProjectStrategy, ReferenceEmitStrategy, ReferenceEmitter, RelativePathStrategy, UnifiedModulesStrategy} from './src/emitter';\n export {Reexport} from './src/reexport';\n export {OwningModule, Reference} from './src/references';\n export {ModuleResolver} from './src/resolver';"
        },
        {
            "sha": "7af8ffebf0544e2e7689f3f8def3475078c7846c",
            "filename": "packages/compiler-cli/src/ngtsc/imports/src/alias.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 6,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Fsrc%2Falias.ts",
            "raw_url": "https://github.com/angular/angular/raw/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Fsrc%2Falias.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Fsrc%2Falias.ts?ref=87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa",
            "patch": "@@ -10,13 +10,12 @@ import {Expression, ExternalExpr} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {UnifiedModulesHost} from '../../core/api';\n-import {ClassDeclaration, isNamedClassDeclaration, ReflectionHost} from '../../reflection';\n+import {ClassDeclaration, ReflectionHost} from '../../reflection';\n \n-import {ImportFlags, ReferenceEmitStrategy} from './emitter';\n+import {EmittedReference, ImportFlags, ReferenceEmitStrategy} from './emitter';\n import {Reference} from './references';\n \n \n-\n // Escape anything that isn't alphanumeric, '/' or '_'.\n const CHARS_TO_ESCAPE = /[^a-zA-Z0-9/_]/g;\n \n@@ -213,11 +212,11 @@ export class PrivateExportAliasingHost implements AliasingHost {\n  * directive or pipe, if it exists.\n  */\n export class AliasStrategy implements ReferenceEmitStrategy {\n-  emit(ref: Reference<ts.Node>, context: ts.SourceFile, importMode: ImportFlags): Expression|null {\n-    if (importMode & ImportFlags.NoAliasing) {\n+  emit(ref: Reference, context: ts.SourceFile, importMode: ImportFlags): EmittedReference|null {\n+    if (importMode & ImportFlags.NoAliasing || ref.alias === null) {\n       return null;\n     }\n \n-    return ref.alias;\n+    return {expression: ref.alias, importedFile: 'unknown'};\n   }\n }"
        },
        {
            "sha": "f21dca0ce136c2b39a365fcc0db9b6dc1b26c827",
            "filename": "packages/compiler-cli/src/ngtsc/imports/src/emitter.ts",
            "status": "modified",
            "additions": 84,
            "deletions": 34,
            "changes": 118,
            "blob_url": "https://github.com/angular/angular/blob/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Fsrc%2Femitter.ts",
            "raw_url": "https://github.com/angular/angular/raw/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Fsrc%2Femitter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Fsrc%2Femitter.ts?ref=87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa",
            "patch": "@@ -11,7 +11,7 @@ import * as ts from 'typescript';\n import {UnifiedModulesHost} from '../../core/api';\n import {absoluteFromSourceFile, dirname, LogicalFileSystem, LogicalProjectPath, relative, toRelativeImport} from '../../file_system';\n import {stripExtension} from '../../file_system/src/util';\n-import {DeclarationNode, isConcreteDeclaration, ReflectionHost} from '../../reflection';\n+import {DeclarationNode, ReflectionHost} from '../../reflection';\n import {getSourceFile, isDeclaration, isTypeDeclaration, nodeNameForError} from '../../util/src/typescript';\n \n import {findExportedNameOfNode} from './find_export';\n@@ -51,6 +51,36 @@ export enum ImportFlags {\n   AllowTypeImports = 0x04,\n }\n \n+/**\n+ * An emitter strategy has the ability to indicate which `ts.SourceFile` is being imported by the\n+ * expression that it has generated. This information is useful for consumers of the emitted\n+ * reference that would otherwise have to perform a relatively expensive module resolution step,\n+ * e.g. for cyclic import analysis. In cases the emitter is unable to definitively determine the\n+ * imported source file or a computation would be required to actually determine the imported\n+ * source file, then `'unknown'` should be returned. If the generated expression does not represent\n+ * an import then `null` should be used.\n+ */\n+export type ImportedFile = ts.SourceFile|'unknown'|null;\n+\n+/**\n+ * Represents the emitted expression of a `Reference` that is valid in the source file it was\n+ * emitted from.\n+ */\n+export interface EmittedReference {\n+  /**\n+   * The expression that refers to `Reference`.\n+   */\n+  expression: Expression;\n+\n+  /**\n+   * The `ts.SourceFile` that is imported by `expression`. This is not necessarily the source file\n+   * of the `Reference`'s declaration node, as the reference may have been rewritten through an\n+   * alias export. It could also be `null` if `expression` is a local identifier, or `'unknown'` if\n+   * the exact source file that is being imported is not known to the emitter.\n+   */\n+  importedFile: ImportedFile;\n+}\n+\n /**\n  * A particular strategy for generating an expression which refers to a `Reference`.\n  *\n@@ -71,9 +101,10 @@ export interface ReferenceEmitStrategy {\n    * @param ref the `Reference` for which to generate an expression\n    * @param context the source file in which the `Expression` must be valid\n    * @param importFlags a flag which controls whether imports should be generated or not\n-   * @returns an `Expression` which refers to the `Reference`, or `null` if none can be generated\n+   * @returns an `EmittedReference` which refers to the `Reference`, or `null` if none can be\n+   *   generated\n    */\n-  emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags): Expression|null;\n+  emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags): EmittedReference|null;\n }\n \n /**\n@@ -85,8 +116,8 @@ export interface ReferenceEmitStrategy {\n export class ReferenceEmitter {\n   constructor(private strategies: ReferenceEmitStrategy[]) {}\n \n-  emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags = ImportFlags.None):\n-      Expression {\n+  emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags = ImportFlags.None):\n+      EmittedReference {\n     for (const strategy of this.strategies) {\n       const emitted = strategy.emit(ref, context, importFlags);\n       if (emitted !== null) {\n@@ -103,7 +134,7 @@ export class ReferenceEmitter {\n  * such identifiers are available.\n  */\n export class LocalIdentifierStrategy implements ReferenceEmitStrategy {\n-  emit(ref: Reference<ts.Node>, context: ts.SourceFile, importFlags: ImportFlags): Expression|null {\n+  emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags): EmittedReference|null {\n     const refSf = getSourceFile(ref.node);\n \n     // If the emitter has specified ForceNewImport, then LocalIdentifierStrategy should not use a\n@@ -118,20 +149,41 @@ export class LocalIdentifierStrategy implements ReferenceEmitStrategy {\n     // such a case, the reference's `identities` property would be `[foo]`, which would result in an\n     // invalid emission of a free-standing `foo` identifier, rather than `exports.foo`.\n     if (!isDeclaration(ref.node) && refSf === context) {\n-      return new WrappedNodeExpr(ref.node);\n+      return {\n+        expression: new WrappedNodeExpr(ref.node),\n+        importedFile: null,\n+      };\n     }\n \n     // A Reference can have multiple identities in different files, so it may already have an\n     // Identifier in the requested context file.\n     const identifier = ref.getIdentityIn(context);\n     if (identifier !== null) {\n-      return new WrappedNodeExpr(identifier);\n+      return {\n+        expression: new WrappedNodeExpr(identifier),\n+        importedFile: null,\n+      };\n     } else {\n       return null;\n     }\n   }\n }\n \n+/**\n+ * Represents the exported declarations from a module source file.\n+ */\n+interface ModuleExports {\n+  /**\n+   * The source file of the module.\n+   */\n+  module: ts.SourceFile;\n+\n+  /**\n+   * The map of declarations to their exported name.\n+   */\n+  exportMap: Map<DeclarationNode, string>;\n+}\n+\n /**\n  * A `ReferenceEmitStrategy` which will refer to declarations that come from `node_modules` using\n  * an absolute import.\n@@ -146,13 +198,13 @@ export class AbsoluteModuleStrategy implements ReferenceEmitStrategy {\n    * A cache of the exports of specific modules, because resolving a module to its exports is a\n    * costly operation.\n    */\n-  private moduleExportsCache = new Map<string, Map<DeclarationNode, string>|null>();\n+  private moduleExportsCache = new Map<string, ModuleExports|null>();\n \n   constructor(\n       protected program: ts.Program, protected checker: ts.TypeChecker,\n       protected moduleResolver: ModuleResolver, private reflectionHost: ReflectionHost) {}\n \n-  emit(ref: Reference<ts.Node>, context: ts.SourceFile, importFlags: ImportFlags): Expression|null {\n+  emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags): EmittedReference|null {\n     if (ref.bestGuessOwningModule === null) {\n       // There is no module name available for this Reference, meaning it was arrived at via a\n       // relative path.\n@@ -168,38 +220,30 @@ export class AbsoluteModuleStrategy implements ReferenceEmitStrategy {\n \n     // Try to find the exported name of the declaration, if one is available.\n     const {specifier, resolutionContext} = ref.bestGuessOwningModule;\n-    const symbolName = this.resolveImportName(specifier, ref.node, resolutionContext);\n-    if (symbolName === null) {\n+    const exports = this.getExportsOfModule(specifier, resolutionContext);\n+    if (exports === null || !exports.exportMap.has(ref.node)) {\n       // TODO(alxhub): make this error a ts.Diagnostic pointing at whatever caused this import to be\n       // triggered.\n       throw new Error(`Symbol ${ref.debugName} declared in ${\n           getSourceFile(ref.node).fileName} is not exported from ${specifier} (import into ${\n           context.fileName})`);\n     }\n+    const symbolName = exports.exportMap.get(ref.node)!;\n \n-    return new ExternalExpr(new ExternalReference(specifier, symbolName));\n-  }\n-\n-  private resolveImportName(moduleName: string, target: DeclarationNode, fromFile: string): string\n-      |null {\n-    const exports = this.getExportsOfModule(moduleName, fromFile);\n-    if (exports !== null && exports.has(target)) {\n-      return exports.get(target)!;\n-    } else {\n-      return null;\n-    }\n+    return {\n+      expression: new ExternalExpr(new ExternalReference(specifier, symbolName)),\n+      importedFile: exports.module,\n+    };\n   }\n \n-  private getExportsOfModule(moduleName: string, fromFile: string):\n-      Map<DeclarationNode, string>|null {\n+  private getExportsOfModule(moduleName: string, fromFile: string): ModuleExports|null {\n     if (!this.moduleExportsCache.has(moduleName)) {\n       this.moduleExportsCache.set(moduleName, this.enumerateExportsOfModule(moduleName, fromFile));\n     }\n     return this.moduleExportsCache.get(moduleName)!;\n   }\n \n-  protected enumerateExportsOfModule(specifier: string, fromFile: string):\n-      Map<DeclarationNode, string>|null {\n+  protected enumerateExportsOfModule(specifier: string, fromFile: string): ModuleExports|null {\n     // First, resolve the module specifier to its entry point, and get the ts.Symbol for it.\n     const entryPointFile = this.moduleResolver.resolveModule(specifier, fromFile);\n     if (entryPointFile === null) {\n@@ -214,7 +258,7 @@ export class AbsoluteModuleStrategy implements ReferenceEmitStrategy {\n     exports.forEach((declaration, name) => {\n       exportMap.set(declaration.node, name);\n     });\n-    return exportMap;\n+    return {module: entryPointFile, exportMap};\n   }\n }\n \n@@ -229,7 +273,7 @@ export class AbsoluteModuleStrategy implements ReferenceEmitStrategy {\n export class LogicalProjectStrategy implements ReferenceEmitStrategy {\n   constructor(private reflector: ReflectionHost, private logicalFs: LogicalFileSystem) {}\n \n-  emit(ref: Reference<ts.Node>, context: ts.SourceFile): Expression|null {\n+  emit(ref: Reference, context: ts.SourceFile): EmittedReference|null {\n     const destSf = getSourceFile(ref.node);\n \n     // Compute the relative path from the importing file to the file being imported. This is done\n@@ -260,7 +304,10 @@ export class LogicalProjectStrategy implements ReferenceEmitStrategy {\n     // With both files expressed as LogicalProjectPaths, getting the module specifier as a relative\n     // path is now straightforward.\n     const moduleName = LogicalProjectPath.relativePathBetween(originPath, destPath);\n-    return new ExternalExpr({moduleName, name});\n+    return {\n+      expression: new ExternalExpr({moduleName, name}),\n+      importedFile: destSf,\n+    };\n   }\n }\n \n@@ -273,14 +320,14 @@ export class LogicalProjectStrategy implements ReferenceEmitStrategy {\n export class RelativePathStrategy implements ReferenceEmitStrategy {\n   constructor(private reflector: ReflectionHost) {}\n \n-  emit(ref: Reference<ts.Node>, context: ts.SourceFile): Expression|null {\n+  emit(ref: Reference, context: ts.SourceFile): EmittedReference|null {\n     const destSf = getSourceFile(ref.node);\n     const relativePath =\n         relative(dirname(absoluteFromSourceFile(context)), absoluteFromSourceFile(destSf));\n     const moduleName = toRelativeImport(stripExtension(relativePath));\n \n     const name = findExportedNameOfNode(ref.node, destSf, this.reflector);\n-    return new ExternalExpr({moduleName, name});\n+    return {expression: new ExternalExpr({moduleName, name}), importedFile: destSf};\n   }\n }\n \n@@ -291,7 +338,7 @@ export class RelativePathStrategy implements ReferenceEmitStrategy {\n export class UnifiedModulesStrategy implements ReferenceEmitStrategy {\n   constructor(private reflector: ReflectionHost, private unifiedModulesHost: UnifiedModulesHost) {}\n \n-  emit(ref: Reference<ts.Node>, context: ts.SourceFile): Expression|null {\n+  emit(ref: Reference, context: ts.SourceFile): EmittedReference|null {\n     const destSf = getSourceFile(ref.node);\n     const name = findExportedNameOfNode(ref.node, destSf, this.reflector);\n     if (name === null) {\n@@ -301,6 +348,9 @@ export class UnifiedModulesStrategy implements ReferenceEmitStrategy {\n     const moduleName =\n         this.unifiedModulesHost.fileNameToModuleName(destSf.fileName, context.fileName);\n \n-    return new ExternalExpr({moduleName, name});\n+    return {\n+      expression: new ExternalExpr({moduleName, name}),\n+      importedFile: destSf,\n+    };\n   }\n }"
        },
        {
            "sha": "c556a1cf727486075f6e2cde012ad04a11cdfe60",
            "filename": "packages/compiler-cli/src/ngtsc/imports/test/emitter_spec.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 7,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Ftest%2Femitter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Ftest%2Femitter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Ftest%2Femitter_spec.ts?ref=87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa",
            "patch": "@@ -72,11 +72,14 @@ runInEachFileSystem(() => {\n         resolutionContext: context.fileName,\n       });\n       const emitted = strategy.emit(reference, context, ImportFlags.None);\n-      if (!(emitted instanceof ExternalExpr)) {\n+      if (emitted === null) {\n+        return fail('Reference should be emitted');\n+      }\n+      if (!(emitted.expression instanceof ExternalExpr)) {\n         return fail('Reference should be emitted as ExternalExpr');\n       }\n-      expect(emitted.value.name).toEqual('Bar');\n-      expect(emitted.value.moduleName).toEqual('external');\n+      expect(emitted.expression.value.name).toEqual('Bar');\n+      expect(emitted.expression.value.moduleName).toEqual('external');\n     });\n \n     it('should throw when generating an import to a type-only declaration when not allowed', () => {\n@@ -121,11 +124,14 @@ runInEachFileSystem(() => {\n       const reference =\n           new Reference(decl, {specifier: 'external', resolutionContext: context.fileName});\n       const emitted = strategy.emit(reference, context, ImportFlags.AllowTypeImports);\n-      if (!(emitted instanceof ExternalExpr)) {\n+      if (emitted === null) {\n+        return fail('Reference should be emitted');\n+      }\n+      if (!(emitted.expression instanceof ExternalExpr)) {\n         return fail('Reference should be emitted as ExternalExpr');\n       }\n-      expect(emitted.value.name).toEqual('Foo');\n-      expect(emitted.value.moduleName).toEqual('external');\n+      expect(emitted.expression.value.name).toEqual('Foo');\n+      expect(emitted.expression.value.moduleName).toEqual('external');\n     });\n   });\n \n@@ -165,7 +171,7 @@ runInEachFileSystem(() => {\n       expect(ref).not.toBeNull();\n \n       // Expect the prefixed name from the TestHost.\n-      expect((ref! as ExternalExpr).value.name).toEqual('testFoo');\n+      expect((ref!.expression as ExternalExpr).value.name).toEqual('testFoo');\n     });\n   });\n });"
        },
        {
            "sha": "573dd20a2d4f31565766fa1731342eb896eb22a1",
            "filename": "packages/compiler-cli/src/ngtsc/modulewithproviders/src/scanner.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmodulewithproviders%2Fsrc%2Fscanner.ts",
            "raw_url": "https://github.com/angular/angular/raw/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmodulewithproviders%2Fsrc%2Fscanner.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmodulewithproviders%2Fsrc%2Fscanner.ts?ref=87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa",
            "patch": "@@ -101,7 +101,7 @@ export class ModuleWithProvidersScanner {\n \n     const ngModuleExpr =\n         this.emitter.emit(ngModule, decl.getSourceFile(), ImportFlags.ForceNewImport);\n-    const ngModuleType = new ExpressionType(ngModuleExpr);\n+    const ngModuleType = new ExpressionType(ngModuleExpr.expression);\n     const mwpNgType = new ExpressionType(\n         new ExternalExpr(Identifiers.ModuleWithProviders), [/* modifiers */], [ngModuleType]);\n "
        },
        {
            "sha": "5e509324d12eb30acc1c21f354242457dafc12ae",
            "filename": "packages/compiler-cli/src/ngtsc/scope/src/local.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fscope%2Fsrc%2Flocal.ts",
            "raw_url": "https://github.com/angular/angular/raw/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fscope%2Fsrc%2Flocal.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fscope%2Fsrc%2Flocal.ts?ref=87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa",
            "patch": "@@ -511,7 +511,8 @@ export class LocalModuleScopeRegistry implements MetadataRegistry, ComponentScop\n             asAlias: exportName,\n           });\n         } else {\n-          const expr = this.refEmitter.emit(exportRef.cloneWithNoIdentifiers(), sourceFile);\n+          const expr =\n+              this.refEmitter.emit(exportRef.cloneWithNoIdentifiers(), sourceFile).expression;\n           if (!(expr instanceof ExternalExpr) || expr.value.moduleName === null ||\n               expr.value.name === null) {\n             throw new Error('Expected ExternalExpr');"
        },
        {
            "sha": "4f5dddb68ce548a428256f70142604cfbb2bd4a4",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/environment.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts",
            "raw_url": "https://github.com/angular/angular/raw/87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts?ref=87bca2a5c61d3ca0cb6c92bdb7985bfe8ef747aa",
            "patch": "@@ -123,7 +123,7 @@ export class Environment {\n     const ngExpr = this.refEmitter.emit(ref, this.contextFile, ImportFlags.NoAliasing);\n \n     // Use `translateExpression` to convert the `Expression` into a `ts.Expression`.\n-    return translateExpression(ngExpr, this.importManager);\n+    return translateExpression(ngExpr.expression, this.importManager);\n   }\n \n   /**\n@@ -137,7 +137,7 @@ export class Environment {\n \n     // Create an `ExpressionType` from the `Expression` and translate it via `translateType`.\n     // TODO(alxhub): support references to types with generic arguments in a clean way.\n-    return translateType(new ExpressionType(ngExpr), this.importManager);\n+    return translateType(new ExpressionType(ngExpr.expression), this.importManager);\n   }\n \n   private emitTypeParameters(declaration: ClassDeclaration<ts.ClassDeclaration>):"
        }
    ],
    "stats": {
        "total": 245,
        "additions": 162,
        "deletions": 83
    }
}