{
    "author": "jbogarthyde",
    "message": "docs: update reference doc for router guards and resolvers (#38079)\n\nComplete and clarify descriptions and example of the guard and resolver functions in Router API documentation.\n\nPR Close #38079",
    "sha": "b00121c9a6e4b9601008d303a9ea74815d3d6ac5",
    "files": [
        {
            "sha": "c072fa690f3e2e541f8a755bfba670532aacd296",
            "filename": "packages/router/src/interfaces.ts",
            "status": "modified",
            "additions": 86,
            "deletions": 23,
            "changes": 109,
            "blob_url": "https://github.com/angular/angular/blob/b00121c9a6e4b9601008d303a9ea74815d3d6ac5/packages%2Frouter%2Fsrc%2Finterfaces.ts",
            "raw_url": "https://github.com/angular/angular/raw/b00121c9a6e4b9601008d303a9ea74815d3d6ac5/packages%2Frouter%2Fsrc%2Finterfaces.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Finterfaces.ts?ref=b00121c9a6e4b9601008d303a9ea74815d3d6ac5",
            "patch": "@@ -17,10 +17,12 @@ import {UrlSegment, UrlTree} from './url_tree';\n  * @description\n  *\n  * Interface that a class can implement to be a guard deciding if a route can be activated.\n- * If all guards return `true`, navigation will continue. If any guard returns `false`,\n- * navigation will be cancelled. If any guard returns a `UrlTree`, current navigation will\n- * be cancelled and a new navigation will be kicked off to the `UrlTree` returned from the\n- * guard.\n+ * If all guards return `true`, navigation continues. If any guard returns `false`,\n+ * navigation is cancelled. If any guard returns a `UrlTree`, the current navigation\n+ * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n+ *\n+ * The following example implements a `CanActivate` function that checks whether the\n+ * current user has permission to activate the requested route.\n  *\n  * ```\n  * class UserToken {}\n@@ -41,7 +43,12 @@ import {UrlSegment, UrlTree} from './url_tree';\n  *     return this.permissions.canActivate(this.currentUser, route.params.id);\n  *   }\n  * }\n+ * ```\n  *\n+ * Here, the defined guard function is provided as part of the `Route` object\n+ * in the router configuration:\n+ *\n+ * ```\n  * @NgModule({\n  *   imports: [\n  *     RouterModule.forRoot([\n@@ -57,7 +64,7 @@ import {UrlSegment, UrlTree} from './url_tree';\n  * class AppModule {}\n  * ```\n  *\n- * You can alternatively provide a function with the `canActivate` signature:\n+ * You can alternatively provide an in-line function with the `canActivate` signature:\n  *\n  * ```\n  * @NgModule({\n@@ -94,10 +101,12 @@ export type CanActivateFn = (route: ActivatedRouteSnapshot, state: RouterStateSn\n  * @description\n  *\n  * Interface that a class can implement to be a guard deciding if a child route can be activated.\n- * If all guards return `true`, navigation will continue. If any guard returns `false`,\n- * navigation will be cancelled. If any guard returns a `UrlTree`, current navigation will\n- * be cancelled and a new navigation will be kicked off to the `UrlTree` returned from the\n- * guard.\n+ * If all guards return `true`, navigation continues. If any guard returns `false`,\n+ * navigation is cancelled. If any guard returns a `UrlTree`, current navigation\n+ * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n+ *\n+ * The following example implements a `CanActivateChild` function that checks whether the\n+ * current user has permission to activate the requested child route.\n  *\n  * ```\n  * class UserToken {}\n@@ -118,7 +127,12 @@ export type CanActivateFn = (route: ActivatedRouteSnapshot, state: RouterStateSn\n  *     return this.permissions.canActivate(this.currentUser, route.params.id);\n  *   }\n  * }\n+ * ```\n  *\n+ * Here, the defined guard function is provided as part of the `Route` object\n+ * in the router configuration:\n+ *\n+ * ```\n  * @NgModule({\n  *   imports: [\n  *     RouterModule.forRoot([\n@@ -139,7 +153,7 @@ export type CanActivateFn = (route: ActivatedRouteSnapshot, state: RouterStateSn\n  * class AppModule {}\n  * ```\n  *\n- * You can alternatively provide a function with the `canActivateChild` signature:\n+ * You can alternatively provide an in-line function with the `canActivateChild` signature:\n  *\n  * ```\n  * @NgModule({\n@@ -181,10 +195,12 @@ export type CanActivateChildFn = (childRoute: ActivatedRouteSnapshot, state: Rou\n  * @description\n  *\n  * Interface that a class can implement to be a guard deciding if a route can be deactivated.\n- * If all guards return `true`, navigation will continue. If any guard returns `false`,\n- * navigation will be cancelled. If any guard returns a `UrlTree`, current navigation will\n- * be cancelled and a new navigation will be kicked off to the `UrlTree` returned from the\n- * guard.\n+ * If all guards return `true`, navigation continues. If any guard returns `false`,\n+ * navigation is cancelled. If any guard returns a `UrlTree`, current navigation\n+ * is cancelled and a new navigation begins to the `UrlTree` returned from the guard.\n+ *\n+ * The following example implements a `CanDeactivate` function that checks whether the\n+ * current user has permission to deactivate the requested route.\n  *\n  * ```\n  * class UserToken {}\n@@ -193,6 +209,12 @@ export type CanActivateChildFn = (childRoute: ActivatedRouteSnapshot, state: Rou\n  *     return true;\n  *   }\n  * }\n+ * ```\n+ *\n+ * Here, the defined guard function is provided as part of the `Route` object\n+ * in the router configuration:\n+ *\n+ * ```\n  *\n  * @Injectable()\n  * class CanDeactivateTeam implements CanDeactivate<TeamComponent> {\n@@ -223,7 +245,7 @@ export type CanActivateChildFn = (childRoute: ActivatedRouteSnapshot, state: Rou\n  * class AppModule {}\n  * ```\n  *\n- * You can alternatively provide a function with the `canDeactivate` signature:\n+ * You can alternatively provide an in-line function with the `canDeactivate` signature:\n  *\n  * ```\n  * @NgModule({\n@@ -266,8 +288,11 @@ export type CanDeactivateFn<T> =\n  *\n  * Interface that classes can implement to be a data provider.\n  * A data provider class can be used with the router to resolve data during navigation.\n- * The interface defines a `resolve()` method that will be invoked when the navigation starts.\n- * The router will then wait for the data to be resolved before the route is finally activated.\n+ * The interface defines a `resolve()` method that is invoked when the navigation starts.\n+ * The router waits for the data to be resolved before the route is finally activated.\n+ *\n+ * The following example implements a `resolve()` method that retrieves the data\n+ * needed to activate the requested route.\n  *\n  * ```\n  * @Injectable({ providedIn: 'root' })\n@@ -281,7 +306,13 @@ export type CanDeactivateFn<T> =\n  *     return this.service.getHero(route.paramMap.get('id'));\n  *   }\n  * }\n+ * ```\n  *\n+ * Here, the defined `resolve()` function is provided as part of the `Route` object\n+ * in the router configuration:\n+ *\n+ * ```\n+\n  * @NgModule({\n  *   imports: [\n  *     RouterModule.forRoot([\n@@ -299,7 +330,7 @@ export type CanDeactivateFn<T> =\n  * export class AppRoutingModule {}\n  * ```\n  *\n- * You can alternatively provide a function with the `resolve` signature:\n+ * You can alternatively provide an in-line function with the `resolve()` signature:\n  *\n  * ```\n  * export const myHero: Hero = {\n@@ -328,6 +359,29 @@ export type CanDeactivateFn<T> =\n  * export class AppModule {}\n  * ```\n  *\n+ * @usageNotes\n+ *\n+ * When both guard and resolvers are specified, the resolvers are not executed until\n+ * all guards have run and succeeded.\n+ * For example, consider the following route configuration:\n+ *\n+ * ```\n+ * {\n+ *  path: 'base'\n+ *  canActivate: [BaseGuard],\n+ *  resolve: {data: BaseDataResolver}\n+ *  children: [\n+ *   {\n+ *     path: 'child',\n+ *     guards: [ChildGuard],\n+ *     component: ChildComponent,\n+ *     resolve: {childData: ChildDataResolver}\n+ *    }\n+ *  ]\n+ * }\n+ * ```\n+ * The order of execution is: BaseGuard, ChildGuard, BaseDataResolver, ChildDataResolver.\n+ *\n  * @publicApi\n  */\n export interface Resolve<T> {\n@@ -339,10 +393,13 @@ export interface Resolve<T> {\n  * @description\n  *\n  * Interface that a class can implement to be a guard deciding if children can be loaded.\n- * If all guards return `true`, navigation will continue. If any guard returns `false`,\n- * navigation will be cancelled. If any guard returns a `UrlTree`, current navigation will\n- * be cancelled and a new navigation will be kicked off to the `UrlTree` returned from the\n- * guard.\n+ * If all guards return `true`, navigation continues. If any guard returns `false`,\n+ * navigation is cancelled. If any guard returns a `UrlTree`, current navigation\n+ * is cancelled and a new navigation starts to the `UrlTree` returned from the guard.\n+ *\n+ * The following example implements a `CanLoad` function that decides whether the\n+ * current user has permission to load requested child routes.\n+ *\n  *\n  * ```\n  * class UserToken {}\n@@ -360,6 +417,12 @@ export interface Resolve<T> {\n  *     return this.permissions.canLoadChildren(this.currentUser, route, segments);\n  *   }\n  * }\n+ * ```\n+ *\n+ * Here, the defined guard function is provided as part of the `Route` object\n+ * in the router configuration:\n+ *\n+ * ```\n  *\n  * @NgModule({\n  *   imports: [\n@@ -377,7 +440,7 @@ export interface Resolve<T> {\n  * class AppModule {}\n  * ```\n  *\n- * You can alternatively provide a function with the `canLoad` signature:\n+ * You can alternatively provide an in-line function with the `canLoad` signature:\n  *\n  * ```\n  * @NgModule({"
        }
    ],
    "stats": {
        "total": 109,
        "additions": 86,
        "deletions": 23
    }
}