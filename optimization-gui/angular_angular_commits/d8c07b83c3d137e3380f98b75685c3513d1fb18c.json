{
    "author": "alxhub",
    "message": "refactor(compiler-cli): support type-checking a single component (#38105)\n\nThis commit adds a method `getDiagnosticsForComponent` to the\n`TemplateTypeChecker`, which does the minimum amount of work to retrieve\ndiagnostics for a single component.\n\nWith the normal `ReusedProgramStrategy` this offers virtually no improvement\nover the standard `getDiagnosticsForFile` operation, but if the\n`TypeCheckingProgramStrategy` supports separate shims for each component,\nthis operation can yield a faster turnaround for components that are\ndeclared in files with many other components.\n\nPR Close #38105",
    "sha": "d8c07b83c3d137e3380f98b75685c3513d1fb18c",
    "files": [
        {
            "sha": "32a804c4e71b1a4c4540a76e2ffa37d6056f9558",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/checker.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/d8c07b83c3d137e3380f98b75685c3513d1fb18c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/d8c07b83c3d137e3380f98b75685c3513d1fb18c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts?ref=d8c07b83c3d137e3380f98b75685c3513d1fb18c",
            "patch": "@@ -54,6 +54,13 @@ export interface TemplateTypeChecker {\n    */\n   getDiagnosticsForFile(sf: ts.SourceFile, optimizeFor: OptimizeFor): ts.Diagnostic[];\n \n+  /**\n+   * Get all `ts.Diagnostic`s currently available that pertain to the given component.\n+   *\n+   * This method always runs in `OptimizeFor.SingleFile` mode.\n+   */\n+  getDiagnosticsForComponent(component: ts.ClassDeclaration): ts.Diagnostic[];\n+\n   /**\n    * Retrieve the top-level node representing the TCB for the given component.\n    *"
        },
        {
            "sha": "defdc7f7057d36ed986c7aba297874a97173feed",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts",
            "status": "modified",
            "additions": 88,
            "deletions": 5,
            "changes": 93,
            "blob_url": "https://github.com/angular/angular/blob/d8c07b83c3d137e3380f98b75685c3513d1fb18c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/d8c07b83c3d137e3380f98b75685c3513d1fb18c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts?ref=d8c07b83c3d137e3380f98b75685c3513d1fb18c",
            "patch": "@@ -18,7 +18,7 @@ import {getSourceFileOrNull} from '../../util/src/typescript';\n import {OptimizeFor, ProgramTypeCheckAdapter, TemplateId, TemplateTypeChecker, TypeCheckingConfig, TypeCheckingProgramStrategy, UpdateMode} from '../api';\n \n import {InliningMode, ShimTypeCheckingData, TypeCheckContextImpl, TypeCheckingHost} from './context';\n-import {findTypeCheckBlock, shouldReportDiagnostic, TemplateSourceResolver, translateDiagnostic} from './diagnostics';\n+import {findTypeCheckBlock, shouldReportDiagnostic, TemplateDiagnostic, TemplateSourceResolver, translateDiagnostic} from './diagnostics';\n import {TemplateSourceManager} from './source';\n \n /**\n@@ -112,10 +112,44 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n       diagnostics.push(...shimRecord.genesisDiagnostics);\n     }\n \n-\n     return diagnostics.filter((diag: ts.Diagnostic|null): diag is ts.Diagnostic => diag !== null);\n   }\n \n+  getDiagnosticsForComponent(component: ts.ClassDeclaration): ts.Diagnostic[] {\n+    this.ensureShimForComponent(component);\n+\n+    const sf = component.getSourceFile();\n+    const sfPath = absoluteFromSourceFile(sf);\n+    const shimPath = this.typeCheckingStrategy.shimPathForComponent(component);\n+\n+    const fileRecord = this.getFileData(sfPath);\n+\n+    if (!fileRecord.shimData.has(shimPath)) {\n+      return [];\n+    }\n+\n+    const templateId = fileRecord.sourceManager.getTemplateId(component);\n+    const shimRecord = fileRecord.shimData.get(shimPath)!;\n+\n+    const typeCheckProgram = this.typeCheckingStrategy.getProgram();\n+\n+    const diagnostics: (TemplateDiagnostic|null)[] = [];\n+    if (shimRecord.hasInlines) {\n+      const inlineSf = getSourceFileOrError(typeCheckProgram, sfPath);\n+      diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(inlineSf).map(\n+          diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n+    }\n+\n+    const shimSf = getSourceFileOrError(typeCheckProgram, shimPath);\n+    diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(shimSf).map(\n+        diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n+    diagnostics.push(...shimRecord.genesisDiagnostics);\n+\n+    return diagnostics.filter(\n+        (diag: TemplateDiagnostic|null): diag is TemplateDiagnostic =>\n+            diag !== null && diag.templateId === templateId);\n+  }\n+\n   getTypeCheckBlock(component: ts.ClassDeclaration): ts.Node|null {\n     this.ensureAllShimsForOneFile(component.getSourceFile());\n \n@@ -219,6 +253,28 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     this.updateFromContext(ctx);\n   }\n \n+  private ensureShimForComponent(component: ts.ClassDeclaration): void {\n+    const sf = component.getSourceFile();\n+    const sfPath = absoluteFromSourceFile(sf);\n+\n+    this.maybeAdoptPriorResultsForFile(sf);\n+\n+    const fileData = this.getFileData(sfPath);\n+    const shimPath = this.typeCheckingStrategy.shimPathForComponent(component);\n+\n+    if (fileData.shimData.has(shimPath)) {\n+      // All data for this component is available.\n+      return;\n+    }\n+\n+    const host =\n+        new SingleShimTypeCheckingHost(sfPath, fileData, this.typeCheckingStrategy, this, shimPath);\n+    const ctx = this.newContext(host);\n+\n+    this.typeCheckAdapter.typeCheck(sf, ctx);\n+    this.updateFromContext(ctx);\n+  }\n+\n   private newContext(host: TypeCheckingHost): TypeCheckContextImpl {\n     const inlining = this.typeCheckingStrategy.supportsInlineOperations ? InliningMode.InlineOps :\n                                                                           InliningMode.Error;\n@@ -272,7 +328,7 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n }\n \n function convertDiagnostic(\n-    diag: ts.Diagnostic, sourceResolver: TemplateSourceResolver): ts.Diagnostic|null {\n+    diag: ts.Diagnostic, sourceResolver: TemplateSourceResolver): TemplateDiagnostic|null {\n   if (!shouldReportDiagnostic(diag)) {\n     return null;\n   }\n@@ -367,8 +423,8 @@ class SingleFileTypeCheckingHost implements TypeCheckingHost {\n   private seenInlines = false;\n \n   constructor(\n-      private sfPath: AbsoluteFsPath, private fileData: FileTypeCheckingData,\n-      private strategy: TypeCheckingProgramStrategy, private impl: TemplateTypeCheckerImpl) {}\n+      protected sfPath: AbsoluteFsPath, protected fileData: FileTypeCheckingData,\n+      protected strategy: TypeCheckingProgramStrategy, protected impl: TemplateTypeCheckerImpl) {}\n \n   private assertPath(sfPath: AbsoluteFsPath): void {\n     if (this.sfPath !== sfPath) {\n@@ -431,3 +487,30 @@ class SingleFileTypeCheckingHost implements TypeCheckingHost {\n     this.fileData.isComplete = true;\n   }\n }\n+\n+/**\n+ * Drives a `TypeCheckContext` to generate type-checking code efficiently for only those components\n+ * which map to a single shim of a single input file.\n+ */\n+class SingleShimTypeCheckingHost extends SingleFileTypeCheckingHost {\n+  constructor(\n+      sfPath: AbsoluteFsPath, fileData: FileTypeCheckingData, strategy: TypeCheckingProgramStrategy,\n+      impl: TemplateTypeCheckerImpl, private shimPath: AbsoluteFsPath) {\n+    super(sfPath, fileData, strategy, impl);\n+  }\n+\n+  shouldCheckNode(node: ts.ClassDeclaration): boolean {\n+    if (this.sfPath !== absoluteFromSourceFile(node.getSourceFile())) {\n+      return false;\n+    }\n+\n+    // Only generate a TCB for the component if it maps to the requested shim file.\n+    const shimPath = this.strategy.shimPathForComponent(node);\n+    if (shimPath !== this.shimPath) {\n+      return false;\n+    }\n+\n+    // Only need to generate a TCB for the class if no shim exists for it currently.\n+    return !this.fileData.shimData.has(shimPath);\n+  }\n+}"
        },
        {
            "sha": "63f7a8148fb08b6ef3068dcfe38a8faa81c28743",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker_spec.ts",
            "status": "modified",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/d8c07b83c3d137e3380f98b75685c3513d1fb18c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/d8c07b83c3d137e3380f98b75685c3513d1fb18c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts?ref=d8c07b83c3d137e3380f98b75685c3513d1fb18c",
            "patch": "@@ -318,5 +318,30 @@ runInEachFileSystem(() => {\n         expect(currentTcb).toBe(originalTcb);\n       });\n     });\n+\n+    it('should allow get diagnostics for a single component', () => {\n+      const fileName = absoluteFrom('/main.ts');\n+\n+      const {program, templateTypeChecker} = setup([{\n+        fileName,\n+        templates: {\n+          'Cmp1': '<invalid-element-a></invalid-element-a>',\n+          'Cmp2': '<invalid-element-b></invalid-element-b>'\n+        },\n+      }]);\n+      const sf = getSourceFileOrError(program, fileName);\n+      const cmp1 = getClass(sf, 'Cmp1');\n+      const cmp2 = getClass(sf, 'Cmp2');\n+\n+      const diags1 = templateTypeChecker.getDiagnosticsForComponent(cmp1);\n+      expect(diags1.length).toBe(1);\n+      expect(diags1[0].messageText).toContain('invalid-element-a');\n+      expect(diags1[0].messageText).not.toContain('invalid-element-b');\n+\n+      const diags2 = templateTypeChecker.getDiagnosticsForComponent(cmp2);\n+      expect(diags2.length).toBe(1);\n+      expect(diags2[0].messageText).toContain('invalid-element-b');\n+      expect(diags2[0].messageText).not.toContain('invalid-element-a');\n+    });\n   });\n });"
        }
    ],
    "stats": {
        "total": 125,
        "additions": 120,
        "deletions": 5
    }
}