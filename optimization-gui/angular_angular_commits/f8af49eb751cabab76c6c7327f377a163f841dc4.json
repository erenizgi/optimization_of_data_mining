{
    "author": "JoostK",
    "message": "fix(compiler-cli): fix crash during type-checking of library builds (#44587)\n\nWhen building a library, the `rootDir` option is configured to ensure\nthat all source files are present within the entry-point that is being\nbuild. This imposes an extra constraint on the reference emit logic,\nwhich does not allow emitting a reference into a source file outside of\nthis `rootDir`.\n\nDuring the generation of type-check blocks we used to make a best-effort\nestimation of whether a type reference can be emitted into the\ntype-check file. This check was relaxed in #42492 to support emitting\nmore syntax forms and type references, but this change did not consider\nthe `rootDir` constraint that is present in library builds. As such, the\ncompiler might conclude that a type reference is eligible for emit into\nthe type-check file, whereas in practice this would cause a failure.\n\nThis commit changes the best-effort estimation into a \"preflight\"\nreference emit that is fully accurate as to whether emitting a type\nreference is possible.\n\nFixes #43624\n\nPR Close #44587",
    "sha": "f8af49eb751cabab76c6c7327f377a163f841dc4",
    "files": [
        {
            "sha": "ae21f775ea1cd20ebaa61a883921e891ee98c1a3",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/context.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/f8af49eb751cabab76c6c7327f377a163f841dc4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts",
            "raw_url": "https://github.com/angular/angular/raw/f8af49eb751cabab76c6c7327f377a163f841dc4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts?ref=f8af49eb751cabab76c6c7327f377a163f841dc4",
            "patch": "@@ -235,7 +235,7 @@ export class TypeCheckContextImpl implements TypeCheckContext {\n         const dirRef = dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n         const dirNode = dirRef.node;\n \n-        if (!dir.isGeneric || !requiresInlineTypeCtor(dirNode, this.reflector)) {\n+        if (!dir.isGeneric || !requiresInlineTypeCtor(dirNode, this.reflector, shimData.file)) {\n           // inlining not required\n           continue;\n         }\n@@ -263,7 +263,8 @@ export class TypeCheckContextImpl implements TypeCheckContext {\n       templateDiagnostics,\n     });\n \n-    const inliningRequirement = requiresInlineTypeCheckBlock(ref.node, pipes, this.reflector);\n+    const inliningRequirement =\n+        requiresInlineTypeCheckBlock(ref.node, shimData.file, pipes, this.reflector);\n \n     // If inlining is not supported, but is required for either the TCB or one of its directive\n     // dependencies, then exit here with an error."
        },
        {
            "sha": "effbea268bd05e11a269e62e366c4bfbe5e4b9d1",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/environment.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 5,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/f8af49eb751cabab76c6c7327f377a163f841dc4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts",
            "raw_url": "https://github.com/angular/angular/raw/f8af49eb751cabab76c6c7327f377a163f841dc4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts?ref=f8af49eb751cabab76c6c7327f377a163f841dc4",
            "patch": "@@ -9,11 +9,12 @@\n import {ExpressionType, ExternalExpr, Type, WrappedNodeExpr} from '@angular/compiler';\n import ts from 'typescript';\n \n-import {assertSuccessfulReferenceEmit, ImportFlags, Reference, ReferenceEmitter} from '../../imports';\n+import {assertSuccessfulReferenceEmit, ImportFlags, Reference, ReferenceEmitKind, ReferenceEmitter} from '../../imports';\n import {ClassDeclaration, ReflectionHost} from '../../reflection';\n import {ImportManager, translateExpression, translateType} from '../../translator';\n import {TypeCheckableDirectiveMeta, TypeCheckingConfig, TypeCtorMetadata} from '../api';\n \n+import {ReferenceEmitEnvironment} from './tcb_util';\n import {tsDeclareVariable} from './ts_util';\n import {generateTypeCtorDeclarationFn, requiresInlineTypeCtor} from './type_constructor';\n import {TypeParameterEmitter} from './type_parameter_emitter';\n@@ -29,7 +30,7 @@ import {TypeParameterEmitter} from './type_parameter_emitter';\n  * `Environment` can be used in a standalone fashion, or can be extended to support more specialized\n  * usage.\n  */\n-export class Environment {\n+export class Environment implements ReferenceEmitEnvironment {\n   private nextIds = {\n     pipeInst: 1,\n     typeCtor: 1,\n@@ -59,7 +60,7 @@ export class Environment {\n       return this.typeCtors.get(node)!;\n     }\n \n-    if (requiresInlineTypeCtor(node, this.reflector)) {\n+    if (requiresInlineTypeCtor(node, this.reflector, this)) {\n       // The constructor has already been created inline, we just need to construct a reference to\n       // it.\n       const ref = this.reference(dirRef);\n@@ -84,8 +85,7 @@ export class Environment {\n         coercedInputFields: dir.coercedInputFields,\n       };\n       const typeParams = this.emitTypeParameters(node);\n-      const typeCtor = generateTypeCtorDeclarationFn(\n-          node, meta, nodeTypeRef.typeName, typeParams, this.reflector);\n+      const typeCtor = generateTypeCtorDeclarationFn(node, meta, nodeTypeRef.typeName, typeParams);\n       this.typeCtorStatements.push(typeCtor);\n       const fnId = ts.createIdentifier(fnName);\n       this.typeCtors.set(node, fnId);\n@@ -127,6 +127,12 @@ export class Environment {\n     return translateExpression(ngExpr.expression, this.importManager);\n   }\n \n+  canReferenceType(ref: Reference): boolean {\n+    const result = this.refEmitter.emit(\n+        ref, this.contextFile, ImportFlags.NoAliasing | ImportFlags.AllowTypeImports);\n+    return result.kind === ReferenceEmitKind.Success;\n+  }\n+\n   /**\n    * Generate a `ts.TypeNode` that references the given node as a type.\n    *"
        },
        {
            "sha": "c93753f26a8aca02e94db74bf534325b029393ab",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/tcb_util.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 5,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/f8af49eb751cabab76c6c7327f377a163f841dc4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftcb_util.ts",
            "raw_url": "https://github.com/angular/angular/raw/f8af49eb751cabab76c6c7327f377a163f841dc4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftcb_util.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftcb_util.ts?ref=f8af49eb751cabab76c6c7327f377a163f841dc4",
            "patch": "@@ -18,6 +18,15 @@ import {hasIgnoreForDiagnosticsMarker, readSpanComment} from './comments';\n import {checkIfClassIsExported} from './ts_util';\n import {TypeParameterEmitter} from './type_parameter_emitter';\n \n+/**\n+ * Represents the origin environment from where reference will be emitted. This interface exists\n+ * as an indirection for the `Environment` type, which would otherwise introduce a (type-only)\n+ * import cycle.\n+ */\n+export interface ReferenceEmitEnvironment {\n+  canReferenceType(ref: Reference): boolean;\n+}\n+\n /**\n  * Adapter interface which allows the template type-checking diagnostics code to interpret offsets\n  * in a TCB and map them back to original locations in the template.\n@@ -64,7 +73,7 @@ export enum TcbInliningRequirement {\n }\n \n export function requiresInlineTypeCheckBlock(\n-    node: ClassDeclaration<ts.ClassDeclaration>,\n+    node: ClassDeclaration<ts.ClassDeclaration>, env: ReferenceEmitEnvironment,\n     usedPipes: Map<string, Reference<ClassDeclaration<ts.ClassDeclaration>>>,\n     reflector: ReflectionHost): TcbInliningRequirement {\n   // In order to qualify for a declared TCB (not inline) two conditions must be met:\n@@ -73,7 +82,7 @@ export function requiresInlineTypeCheckBlock(\n   if (!checkIfClassIsExported(node)) {\n     // Condition 1 is false, the class is not exported.\n     return TcbInliningRequirement.MustInline;\n-  } else if (!checkIfGenericTypeBoundsAreContextFree(node, reflector)) {\n+  } else if (!checkIfGenericTypeBoundsCanBeEmitted(node, reflector, env)) {\n     // Condition 2 is false, the class has constrained generic types. It should be checked with an\n     // inline TCB if possible, but can potentially use fallbacks to avoid inlining if not.\n     return TcbInliningRequirement.ShouldInlineForGenericBounds;\n@@ -175,8 +184,10 @@ function getTemplateId(\n   }) as TemplateId || null;\n }\n \n-export function checkIfGenericTypeBoundsAreContextFree(\n-    node: ClassDeclaration<ts.ClassDeclaration>, reflector: ReflectionHost): boolean {\n+export function checkIfGenericTypeBoundsCanBeEmitted(\n+    node: ClassDeclaration<ts.ClassDeclaration>, reflector: ReflectionHost,\n+    env: ReferenceEmitEnvironment): boolean {\n   // Generic type parameters are considered context free if they can be emitted into any context.\n-  return new TypeParameterEmitter(node.typeParameters, reflector).canEmit();\n+  const emitter = new TypeParameterEmitter(node.typeParameters, reflector);\n+  return emitter.canEmit(ref => env.canReferenceType(ref));\n }"
        },
        {
            "sha": "e58b1890afd0b09c0f8f7dc3bcf144bf83b8a6e7",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/f8af49eb751cabab76c6c7327f377a163f841dc4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "raw_url": "https://github.com/angular/angular/raw/f8af49eb751cabab76c6c7327f377a163f841dc4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts?ref=f8af49eb751cabab76c6c7327f377a163f841dc4",
            "patch": "@@ -11,7 +11,7 @@ import ts from 'typescript';\n \n import {Reference} from '../../imports';\n import {ClassPropertyName} from '../../metadata';\n-import {ClassDeclaration, ReflectionHost} from '../../reflection';\n+import {ClassDeclaration} from '../../reflection';\n import {TemplateId, TypeCheckableDirectiveMeta, TypeCheckBlockMetadata} from '../api';\n \n import {addExpressionIdentifier, ExpressionIdentifier, markIgnoreDiagnostics} from './comments';\n@@ -1509,7 +1509,7 @@ class Scope {\n         // `TcbNonDirectiveTypeOp`.\n         directiveOp = new TcbNonGenericDirectiveTypeOp(this.tcb, this, node, dir);\n       } else if (\n-          !requiresInlineTypeCtor(dirRef.node, host) ||\n+          !requiresInlineTypeCtor(dirRef.node, host, this.tcb.env) ||\n           this.tcb.env.config.useInlineTypeConstructors) {\n         // For generic directives, we use a type constructor to infer types. If a directive requires\n         // an inline type constructor, then inlining must be available to use the"
        },
        {
            "sha": "d5a9199b162b683eac8ba9d6ab52318cec431aae",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_constructor.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 9,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/f8af49eb751cabab76c6c7327f377a163f841dc4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_constructor.ts",
            "raw_url": "https://github.com/angular/angular/raw/f8af49eb751cabab76c6c7327f377a163f841dc4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_constructor.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_constructor.ts?ref=f8af49eb751cabab76c6c7327f377a163f841dc4",
            "patch": "@@ -10,17 +10,13 @@ import ts from 'typescript';\n \n import {ClassDeclaration, ReflectionHost} from '../../reflection';\n import {TypeCtorMetadata} from '../api';\n-import {checkIfGenericTypeBoundsAreContextFree} from './tcb_util';\n \n+import {checkIfGenericTypeBoundsCanBeEmitted, ReferenceEmitEnvironment} from './tcb_util';\n import {tsCreateTypeQueryForCoercedInput} from './ts_util';\n \n export function generateTypeCtorDeclarationFn(\n     node: ClassDeclaration<ts.ClassDeclaration>, meta: TypeCtorMetadata, nodeTypeRef: ts.EntityName,\n-    typeParams: ts.TypeParameterDeclaration[]|undefined, reflector: ReflectionHost): ts.Statement {\n-  if (requiresInlineTypeCtor(node, reflector)) {\n-    throw new Error(`${node.name.text} requires an inline type constructor`);\n-  }\n-\n+    typeParams: ts.TypeParameterDeclaration[]|undefined): ts.Statement {\n   const rawTypeArgs = typeParams !== undefined ? generateGenericArgs(typeParams) : undefined;\n   const rawType = ts.createTypeReferenceNode(nodeTypeRef, rawTypeArgs);\n \n@@ -190,10 +186,11 @@ function generateGenericArgs(params: ReadonlyArray<ts.TypeParameterDeclaration>)\n }\n \n export function requiresInlineTypeCtor(\n-    node: ClassDeclaration<ts.ClassDeclaration>, host: ReflectionHost): boolean {\n+    node: ClassDeclaration<ts.ClassDeclaration>, host: ReflectionHost,\n+    env: ReferenceEmitEnvironment): boolean {\n   // The class requires an inline type constructor if it has generic type bounds that can not be\n-  // emitted into a different context.\n-  return !checkIfGenericTypeBoundsAreContextFree(node, host);\n+  // emitted into the provided type-check environment.\n+  return !checkIfGenericTypeBoundsCanBeEmitted(node, host, env);\n }\n \n /**"
        },
        {
            "sha": "fca37467d5e915a3610029d34eec496b78bd33db",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_emitter.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 51,
            "changes": 62,
            "blob_url": "https://github.com/angular/angular/blob/f8af49eb751cabab76c6c7327f377a163f841dc4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_emitter.ts",
            "raw_url": "https://github.com/angular/angular/raw/f8af49eb751cabab76c6c7327f377a163f841dc4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_emitter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_emitter.ts?ref=f8af49eb751cabab76c6c7327f377a163f841dc4",
            "patch": "@@ -6,20 +6,13 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n import ts from 'typescript';\n-import {Reference} from '../../imports';\n \n /**\n- * A resolved type reference can either be a `Reference`, the original `ts.TypeReferenceNode` itself\n- * or null. A value of null indicates that no reference could be resolved or that the reference can\n- * not be emitted.\n+ * A type reference resolver function is responsible for translating a type reference from the\n+ * origin source file into a type reference that is valid in the desired source file. If the type\n+ * cannot be translated to the desired source file, then null can be returned.\n  */\n-export type ResolvedTypeReference = Reference|ts.TypeReferenceNode|null;\n-\n-/**\n- * A type reference resolver function is responsible for finding the declaration of the type\n- * reference and verifying whether it can be emitted.\n- */\n-export type TypeReferenceResolver = (type: ts.TypeReferenceNode) => ResolvedTypeReference;\n+export type TypeReferenceTranslator = (type: ts.TypeReferenceNode) => ts.TypeReferenceNode|null;\n \n /**\n  * A marker to indicate that a type reference is ineligible for emitting. This needs to be truthy\n@@ -38,7 +31,8 @@ const INELIGIBLE: INELIGIBLE = {} as INELIGIBLE;\n  * function returns false, then using the `TypeEmitter` should not be attempted as it is known to\n  * fail.\n  */\n-export function canEmitType(type: ts.TypeNode, resolver: TypeReferenceResolver): boolean {\n+export function canEmitType(\n+    type: ts.TypeNode, canEmit: (type: ts.TypeReferenceNode) => boolean): boolean {\n   return canEmitTypeWorker(type);\n \n   function canEmitTypeWorker(type: ts.TypeNode): boolean {\n@@ -69,18 +63,10 @@ export function canEmitType(type: ts.TypeNode, resolver: TypeReferenceResolver):\n   }\n \n   function canEmitTypeReference(type: ts.TypeReferenceNode): boolean {\n-    const reference = resolver(type);\n-\n-    // If the type could not be resolved, it can not be emitted.\n-    if (reference === null) {\n+    if (!canEmit(type)) {\n       return false;\n     }\n \n-    // If the type is a reference, consider the type to be eligible for emitting.\n-    if (reference instanceof Reference) {\n-      return true;\n-    }\n-\n     // The type can be emitted if either it does not have any type arguments, or all of them can be\n     // emitted.\n     return type.typeArguments === undefined || type.typeArguments.every(canEmitTypeWorker);\n@@ -117,21 +103,7 @@ export function canEmitType(type: ts.TypeNode, resolver: TypeReferenceResolver):\n  * referring to the namespace import that was created.\n  */\n export class TypeEmitter {\n-  /**\n-   * Resolver function that computes a `Reference` corresponding with a `ts.TypeReferenceNode`.\n-   */\n-  private resolver: TypeReferenceResolver;\n-\n-  /**\n-   * Given a `Reference`, this function is responsible for the actual emitting work. It should\n-   * produce a `ts.TypeNode` that is valid within the desired context.\n-   */\n-  private emitReference: (ref: Reference) => ts.TypeNode;\n-\n-  constructor(resolver: TypeReferenceResolver, emitReference: (ref: Reference) => ts.TypeNode) {\n-    this.resolver = resolver;\n-    this.emitReference = emitReference;\n-  }\n+  constructor(private translator: TypeReferenceTranslator) {}\n \n   emitType(type: ts.TypeNode): ts.TypeNode {\n     const typeReferenceTransformer: ts.TransformerFactory<ts.TypeNode> = context => {\n@@ -163,8 +135,8 @@ export class TypeEmitter {\n \n   private emitTypeReference(type: ts.TypeReferenceNode): ts.TypeNode {\n     // Determine the reference that the type corresponds with.\n-    const reference = this.resolver(type);\n-    if (reference === null) {\n+    const translatedType = this.translator(type);\n+    if (translatedType === null) {\n       throw new Error('Unable to emit an unresolved reference');\n     }\n \n@@ -174,18 +146,6 @@ export class TypeEmitter {\n       typeArguments = ts.createNodeArray(type.typeArguments.map(typeArg => this.emitType(typeArg)));\n     }\n \n-    // Emit the type name.\n-    let typeName = type.typeName;\n-    if (reference instanceof Reference) {\n-      const emittedType = this.emitReference(reference);\n-      if (!ts.isTypeReferenceNode(emittedType)) {\n-        throw new Error(`Expected TypeReferenceNode for emitted reference, got ${\n-            ts.SyntaxKind[emittedType.kind]}`);\n-      }\n-\n-      typeName = emittedType.typeName;\n-    }\n-\n-    return ts.updateTypeReferenceNode(type, typeName, typeArguments);\n+    return ts.updateTypeReferenceNode(type, translatedType.typeName, typeArguments);\n   }\n }"
        },
        {
            "sha": "c673169f32f9455d00d09606395df85eeec852fa",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_parameter_emitter.ts",
            "status": "modified",
            "additions": 36,
            "deletions": 19,
            "changes": 55,
            "blob_url": "https://github.com/angular/angular/blob/f8af49eb751cabab76c6c7327f377a163f841dc4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_parameter_emitter.ts",
            "raw_url": "https://github.com/angular/angular/raw/f8af49eb751cabab76c6c7327f377a163f841dc4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_parameter_emitter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_parameter_emitter.ts?ref=f8af49eb751cabab76c6c7327f377a163f841dc4",
            "patch": "@@ -10,7 +10,7 @@ import ts from 'typescript';\n import {OwningModule, Reference} from '../../imports';\n import {DeclarationNode, ReflectionHost} from '../../reflection';\n \n-import {canEmitType, ResolvedTypeReference, TypeEmitter} from './type_emitter';\n+import {canEmitType, TypeEmitter} from './type_emitter';\n \n \n /**\n@@ -26,22 +26,35 @@ export class TypeParameterEmitter {\n    * `emit` is known to succeed. Vice versa, if false is returned then `emit` should not be\n    * called, as it would fail.\n    */\n-  canEmit(): boolean {\n+  canEmit(canEmitReference: (ref: Reference) => boolean): boolean {\n     if (this.typeParameters === undefined) {\n       return true;\n     }\n \n     return this.typeParameters.every(typeParam => {\n-      return this.canEmitType(typeParam.constraint) && this.canEmitType(typeParam.default);\n+      return this.canEmitType(typeParam.constraint, canEmitReference) &&\n+          this.canEmitType(typeParam.default, canEmitReference);\n     });\n   }\n \n-  private canEmitType(type: ts.TypeNode|undefined): boolean {\n+  private canEmitType(type: ts.TypeNode|undefined, canEmitReference: (ref: Reference) => boolean):\n+      boolean {\n     if (type === undefined) {\n       return true;\n     }\n \n-    return canEmitType(type, typeReference => this.resolveTypeReference(typeReference));\n+    return canEmitType(type, typeReference => {\n+      const reference = this.resolveTypeReference(typeReference);\n+      if (reference === null) {\n+        return false;\n+      }\n+\n+      if (reference instanceof Reference) {\n+        return canEmitReference(reference);\n+      }\n+\n+      return true;\n+    });\n   }\n \n   /**\n@@ -52,7 +65,7 @@ export class TypeParameterEmitter {\n       return undefined;\n     }\n \n-    const emitter = new TypeEmitter(type => this.resolveTypeReference(type), emitReference);\n+    const emitter = new TypeEmitter(type => this.translateTypeReference(type, emitReference));\n \n     return this.typeParameters.map(typeParam => {\n       const constraint =\n@@ -68,7 +81,7 @@ export class TypeParameterEmitter {\n     });\n   }\n \n-  private resolveTypeReference(type: ts.TypeReferenceNode): ResolvedTypeReference {\n+  private resolveTypeReference(type: ts.TypeReferenceNode): Reference|ts.TypeReferenceNode|null {\n     const target = ts.isIdentifier(type.typeName) ? type.typeName : type.typeName.right;\n     const declaration = this.reflector.getDeclarationOfIdentifier(target);\n \n@@ -92,23 +105,27 @@ export class TypeParameterEmitter {\n       };\n     }\n \n-    // The declaration needs to be exported as a top-level export to be able to emit an import\n-    // statement for it. If the declaration is not exported, null is returned to prevent emit.\n-    if (!this.isTopLevelExport(declaration.node)) {\n-      return null;\n-    }\n-\n     return new Reference(declaration.node, owningModule);\n   }\n \n-  private isTopLevelExport(decl: DeclarationNode): boolean {\n-    if (decl.parent === undefined || !ts.isSourceFile(decl.parent)) {\n-      // The declaration has to exist at the top-level, as the reference emitters are not capable of\n-      // generating imports to classes declared in a namespace.\n-      return false;\n+  private translateTypeReference(\n+      type: ts.TypeReferenceNode,\n+      emitReference: (ref: Reference) => ts.TypeNode | null): ts.TypeReferenceNode|null {\n+    const reference = this.resolveTypeReference(type);\n+    if (!(reference instanceof Reference)) {\n+      return reference;\n     }\n \n-    return this.reflector.isStaticallyExported(decl);\n+    const typeNode = emitReference(reference);\n+    if (typeNode === null) {\n+      return null;\n+    }\n+\n+    if (!ts.isTypeReferenceNode(typeNode)) {\n+      throw new Error(\n+          `Expected TypeReferenceNode for emitted reference, got ${ts.SyntaxKind[typeNode.kind]}.`);\n+    }\n+    return typeNode;\n   }\n \n   private isLocalTypeParameter(decl: DeclarationNode): boolean {"
        },
        {
            "sha": "a6872eefaadbe17dfdf0c90549249aca315e753c",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_parameter_emitter_spec.ts",
            "status": "modified",
            "additions": 80,
            "deletions": 57,
            "changes": 137,
            "blob_url": "https://github.com/angular/angular/blob/f8af49eb751cabab76c6c7327f377a163f841dc4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_parameter_emitter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f8af49eb751cabab76c6c7327f377a163f841dc4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_parameter_emitter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_parameter_emitter_spec.ts?ref=f8af49eb751cabab76c6c7327f377a163f841dc4",
            "patch": "@@ -7,44 +7,61 @@\n  */\n import ts from 'typescript';\n \n-import {absoluteFrom} from '../../file_system';\n+import {absoluteFrom, LogicalFileSystem} from '../../file_system';\n import {runInEachFileSystem, TestFile} from '../../file_system/testing';\n+import {AbsoluteModuleStrategy, LocalIdentifierStrategy, LogicalProjectStrategy, ModuleResolver, ReferenceEmitter} from '../../imports';\n import {isNamedClassDeclaration, TypeScriptReflectionHost} from '../../reflection';\n import {getDeclaration, makeProgram} from '../../testing';\n+import {Environment} from '../src/environment';\n+import {TypeCheckFile} from '../src/type_check_file';\n import {TypeParameterEmitter} from '../src/type_parameter_emitter';\n-\n-import {angularCoreDts} from '../testing';\n+import {ALL_ENABLED_CONFIG, angularCoreDts} from '../testing';\n \n \n runInEachFileSystem(() => {\n   describe('type parameter emitter', () => {\n     function createEmitter(source: string, additionalFiles: TestFile[] = []) {\n       const files: TestFile[] = [\n-        angularCoreDts(), {name: absoluteFrom('/main.ts'), contents: source}, ...additionalFiles\n+        angularCoreDts(),\n+        {name: absoluteFrom('/app/main.ts'), contents: source},\n+        ...additionalFiles,\n       ];\n-      const {program} = makeProgram(files, undefined, undefined, false);\n+      const {program, host} = makeProgram(files, undefined, undefined, false);\n       const checker = program.getTypeChecker();\n       const reflector = new TypeScriptReflectionHost(checker);\n \n-      const TestClass =\n-          getDeclaration(program, absoluteFrom('/main.ts'), 'TestClass', isNamedClassDeclaration);\n-\n-      return new TypeParameterEmitter(TestClass.typeParameters, reflector);\n+      const TestClass = getDeclaration(\n+          program, absoluteFrom('/app/main.ts'), 'TestClass', isNamedClassDeclaration);\n+\n+      const moduleResolver = new ModuleResolver(\n+          program, program.getCompilerOptions(), host, /* moduleResolutionCache */ null);\n+      const refEmitter = new ReferenceEmitter([\n+        new LocalIdentifierStrategy(),\n+        new AbsoluteModuleStrategy(program, checker, moduleResolver, reflector),\n+        new LogicalProjectStrategy(reflector, new LogicalFileSystem([absoluteFrom('/app')], host)),\n+      ]);\n+\n+      const env = new TypeCheckFile(\n+          absoluteFrom('/app/main.ngtypecheck.ts'), ALL_ENABLED_CONFIG, refEmitter, reflector,\n+          host);\n+      const emitter = new TypeParameterEmitter(TestClass.typeParameters, reflector);\n+      return {emitter, env};\n     }\n \n-    function emit(emitter: TypeParameterEmitter) {\n-      const canEmit = emitter.canEmit();\n-      const emitted = emitter.emit(ref => {\n-        const typeName = ts.createQualifiedName(ts.createIdentifier('test'), ref.debugName!);\n-        return ts.createTypeReferenceNode(typeName, /* typeArguments */ undefined);\n-      });\n+    function emit({emitter, env}: {emitter: TypeParameterEmitter; env: Environment}) {\n+      const canEmit = emitter.canEmit(ref => env.canReferenceType(ref));\n \n-      if (emitted === undefined) {\n-        return canEmit ? '' : null;\n+      let emitted: ts.TypeParameterDeclaration[]|undefined;\n+      try {\n+        emitted = emitter.emit(ref => env.referenceType(ref));\n+        expect(canEmit).toBe(true);\n+      } catch (e) {\n+        expect(canEmit).toBe(false);\n+        throw e;\n       }\n \n-      if (!canEmit) {\n-        fail('canEmit must be true when emitting succeeds');\n+      if (emitted === undefined) {\n+        return '';\n       }\n \n       const printer = ts.createPrinter({newLine: ts.NewLineKind.LineFeed});\n@@ -104,7 +121,6 @@ runInEachFileSystem(() => {\n     it('cannot emit import types', () => {\n       const emitter = createEmitter(`export class TestClass<T extends import('module')> {}`);\n \n-      expect(emitter.canEmit()).toBe(false);\n       expect(() => emit(emitter)).toThrowError('Unable to emit import type');\n     });\n \n@@ -114,8 +130,7 @@ runInEachFileSystem(() => {\n \n           export class TestClass<T extends NgIterable<any>> {}`);\n \n-      expect(emitter.canEmit()).toBe(true);\n-      expect(emit(emitter)).toEqual('<T extends test.NgIterable<any>>');\n+      expect(emit(emitter)).toEqual('<T extends i0.NgIterable<any>>');\n     });\n \n     it('can emit references into external modules using qualified name', () => {\n@@ -124,8 +139,7 @@ runInEachFileSystem(() => {\n \n           export class TestClass<T extends ng.NgIterable<any>> {}`);\n \n-      expect(emitter.canEmit()).toBe(true);\n-      expect(emit(emitter)).toEqual('<T extends test.NgIterable<any>>');\n+      expect(emit(emitter)).toEqual('<T extends i0.NgIterable<any>>');\n     });\n \n     it('can emit references to other type parameters', () => {\n@@ -134,8 +148,7 @@ runInEachFileSystem(() => {\n \n           export class TestClass<T, U extends NgIterable<T>> {}`);\n \n-      expect(emitter.canEmit()).toBe(true);\n-      expect(emit(emitter)).toEqual('<T, U extends test.NgIterable<T>>');\n+      expect(emit(emitter)).toEqual('<T, U extends i0.NgIterable<T>>');\n     });\n \n     it('can emit references to local, exported declarations', () => {\n@@ -144,17 +157,15 @@ runInEachFileSystem(() => {\n           export {Local};\n           export class TestClass<T extends Local> {}`);\n \n-      expect(emitter.canEmit()).toBe(true);\n-      expect(emit(emitter)).toEqual('<T extends test.Local>');\n+      expect(emit(emitter)).toEqual('<T extends i0.Local>');\n     });\n \n     it('cannot emit references to non-exported local declarations', () => {\n       const emitter = createEmitter(`\n           class Local {};\n           export class TestClass<T extends Local> {}`);\n \n-      expect(emitter.canEmit()).toBe(false);\n-      expect(() => emit(emitter)).toThrowError('Unable to emit an unresolved reference');\n+      expect(() => emit(emitter)).toThrow();\n     });\n \n     it('cannot emit references to local declarations as nested type arguments', () => {\n@@ -164,8 +175,7 @@ runInEachFileSystem(() => {\n           class Local {};\n           export class TestClass<T extends NgIterable<Local>> {}`);\n \n-      expect(emitter.canEmit()).toBe(false);\n-      expect(() => emit(emitter)).toThrowError('Unable to emit an unresolved reference');\n+      expect(() => emit(emitter)).toThrow();\n     });\n \n     it('can emit references into external modules within array types', () => {\n@@ -174,22 +184,20 @@ runInEachFileSystem(() => {\n \n           export class TestClass<T extends NgIterable[]> {}`);\n \n-      expect(emitter.canEmit()).toBe(true);\n-      expect(emit(emitter)).toEqual('<T extends test.NgIterable[]>');\n+      expect(emit(emitter)).toEqual('<T extends i0.NgIterable[]>');\n     });\n \n     it('cannot emit references to local declarations within array types', () => {\n       const emitter = createEmitter(`\n           class Local {};\n           export class TestClass<T extends Local[]> {}`);\n \n-      expect(emitter.canEmit()).toBe(false);\n-      expect(() => emit(emitter)).toThrowError('Unable to emit an unresolved reference');\n+      expect(() => emit(emitter)).toThrow();\n     });\n \n     it('can emit references into relative files', () => {\n       const additionalFiles: TestFile[] = [{\n-        name: absoluteFrom('/internal.ts'),\n+        name: absoluteFrom('/app/internal.ts'),\n         contents: `export class Internal {}`,\n       }];\n       const emitter = createEmitter(\n@@ -199,29 +207,51 @@ runInEachFileSystem(() => {\n           export class TestClass<T extends Internal> {}`,\n           additionalFiles);\n \n-      expect(emitter.canEmit()).toBe(true);\n-      expect(emit(emitter)).toEqual('<T extends test.Internal>');\n+      expect(emit(emitter)).toEqual('<T extends i0.Internal>');\n     });\n \n-    it('can emit references to exported classes imported using a namespace import', () => {\n+    it('cannot emit references into relative files that are outside of rootDirs', () => {\n       const additionalFiles: TestFile[] = [{\n         name: absoluteFrom('/internal.ts'),\n         contents: `export class Internal {}`,\n       }];\n+      const emitter = createEmitter(\n+          `\n+          import {Internal} from '../internal';\n+\n+          export class TestClass<T extends Internal> {}`,\n+          additionalFiles);\n+\n+      expect(() => emit(emitter)).toThrow();\n+    });\n+\n+    it('cannot emit unresolved references', () => {\n+      const emitter = createEmitter(`\n+          import {Internal} from 'unresolved';\n+\n+          export class TestClass<T extends Internal> {}`);\n+\n+      expect(() => emit(emitter)).toThrow();\n+    });\n+\n+    it('can emit references to exported classes imported using a namespace import', () => {\n+      const additionalFiles: TestFile[] = [{\n+        name: absoluteFrom('/app/internal.ts'),\n+        contents: `export class Internal {}`,\n+      }];\n       const emitter = createEmitter(\n           `\n         import * as ns from './internal';\n \n         export class TestClass<T extends ns.Internal> {}`,\n           additionalFiles);\n \n-      expect(emitter.canEmit()).toBe(true);\n-      expect(emit(emitter)).toEqual('<T extends test.Internal>');\n+      expect(emit(emitter)).toEqual('<T extends i0.Internal>');\n     });\n \n     it('cannot emit references to local classes exported within a namespace', () => {\n       const additionalFiles: TestFile[] = [{\n-        name: absoluteFrom('/ns.ts'),\n+        name: absoluteFrom('/app/ns.ts'),\n         contents: `\n           export namespace ns {\n             export class Nested {}\n@@ -235,8 +265,7 @@ runInEachFileSystem(() => {\n           export class TestClass<T extends ns.Nested> {}`,\n           additionalFiles);\n \n-      expect(emitter.canEmit()).toBe(false);\n-      expect(() => emit(emitter)).toThrowError('Unable to emit an unresolved reference');\n+      expect(() => emit(emitter)).toThrow();\n     });\n \n     it('cannot emit references to external classes exported within a namespace', () => {\n@@ -255,8 +284,7 @@ runInEachFileSystem(() => {\n           export class TestClass<T extends ns.Nested> {}`,\n           additionalFiles);\n \n-      expect(emitter.canEmit()).toBe(false);\n-      expect(() => emit(emitter)).toThrowError('Unable to emit an unresolved reference');\n+      expect(() => emit(emitter)).toThrow();\n     });\n \n     it('can emit references to interfaces', () => {\n@@ -271,8 +299,7 @@ runInEachFileSystem(() => {\n           export class TestClass<T extends MyInterface> {}`,\n           additionalFiles);\n \n-      expect(emitter.canEmit()).toBe(true);\n-      expect(emit(emitter)).toEqual('<T extends test.MyInterface>');\n+      expect(emit(emitter)).toEqual('<T extends i0.MyInterface>');\n     });\n \n     it('can emit references to enums', () => {\n@@ -287,8 +314,7 @@ runInEachFileSystem(() => {\n           export class TestClass<T extends MyEnum> {}`,\n           additionalFiles);\n \n-      expect(emitter.canEmit()).toBe(true);\n-      expect(emit(emitter)).toEqual('<T extends test.MyEnum>');\n+      expect(emit(emitter)).toEqual('<T extends i0.MyEnum>');\n     });\n \n     it('can emit references to type aliases', () => {\n@@ -303,8 +329,7 @@ runInEachFileSystem(() => {\n           export class TestClass<T extends MyType> {}`,\n           additionalFiles);\n \n-      expect(emitter.canEmit()).toBe(true);\n-      expect(emit(emitter)).toEqual('<T extends test.MyType>');\n+      expect(emit(emitter)).toEqual('<T extends i0.MyType>');\n     });\n \n     it('transforms generic type parameter defaults', () => {\n@@ -319,8 +344,7 @@ runInEachFileSystem(() => {\n           export class TestClass<T extends MyType = MyType> {}`,\n           additionalFiles);\n \n-      expect(emitter.canEmit()).toBe(true);\n-      expect(emit(emitter)).toEqual('<T extends test.MyType = test.MyType>');\n+      expect(emit(emitter)).toEqual('<T extends i0.MyType = i0.MyType>');\n     });\n \n     it('cannot emit when a type parameter default cannot be emitted', () => {\n@@ -329,8 +353,7 @@ runInEachFileSystem(() => {\n \n           export class TestClass<T extends object = Local> {}`);\n \n-      expect(emitter.canEmit()).toBe(false);\n-      expect(() => emit(emitter)).toThrowError('Unable to emit an unresolved reference');\n+      expect(() => emit(emitter)).toThrow();\n     });\n   });\n });"
        }
    ],
    "stats": {
        "total": 315,
        "additions": 165,
        "deletions": 150
    }
}