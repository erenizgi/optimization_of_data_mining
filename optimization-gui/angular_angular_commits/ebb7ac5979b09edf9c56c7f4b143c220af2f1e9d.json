{
    "author": "atscott",
    "message": "fix(language-service): Support 'find references' for two-way bindings (#40185)\n\nRather than expecting that a position in a template only targets a\nsingle node, this commit simply adjusts the approach to account for two way\nbindings. Specifically, we attempt to get references for each targeted\nnode and then return the combination of all results, or `undefined` if\nnone of the target nodes had references.\n\nPR Close #40185",
    "sha": "ebb7ac5979b09edf9c56c7f4b143c220af2f1e9d",
    "files": [
        {
            "sha": "265a8c27eb5007a7b5e4df5889fcc01f05e6f6db",
            "filename": "packages/language-service/ivy/references.ts",
            "status": "modified",
            "additions": 79,
            "deletions": 59,
            "changes": 138,
            "blob_url": "https://github.com/angular/angular/blob/ebb7ac5979b09edf9c56c7f4b143c220af2f1e9d/packages%2Flanguage-service%2Fivy%2Freferences.ts",
            "raw_url": "https://github.com/angular/angular/raw/ebb7ac5979b09edf9c56c7f4b143c220af2f1e9d/packages%2Flanguage-service%2Fivy%2Freferences.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Freferences.ts?ref=ebb7ac5979b09edf9c56c7f4b143c220af2f1e9d",
            "patch": "@@ -39,72 +39,92 @@ export class ReferenceBuilder {\n       return undefined;\n     }\n \n-    const node = positionDetails.context.kind === TargetNodeKind.TwoWayBindingContext ?\n-        positionDetails.context.nodes[0] :\n-        positionDetails.context.node;\n-\n-    // Get the information about the TCB at the template position.\n-    const symbol = this.ttc.getSymbolOfNode(node, component);\n-    if (symbol === null) {\n-      return undefined;\n-    }\n-    switch (symbol.kind) {\n-      case SymbolKind.Directive:\n-      case SymbolKind.Template:\n-        // References to elements, templates, and directives will be through template references\n-        // (#ref). They shouldn't be used directly for a Language Service reference request.\n-        return undefined;\n-      case SymbolKind.Element: {\n-        const matches = getDirectiveMatchesForElementTag(symbol.templateNode, symbol.directives);\n-        return this.getReferencesForDirectives(matches);\n+    const nodes = positionDetails.context.kind === TargetNodeKind.TwoWayBindingContext ?\n+        positionDetails.context.nodes :\n+        [positionDetails.context.node];\n+\n+    const references: ts.ReferenceEntry[] = [];\n+    for (const node of nodes) {\n+      // Get the information about the TCB at the template position.\n+      const symbol = this.ttc.getSymbolOfNode(node, component);\n+      if (symbol === null) {\n+        continue;\n       }\n-      case SymbolKind.DomBinding: {\n-        // Dom bindings aren't currently type-checked (see `checkTypeOfDomBindings`) so they don't\n-        // have a shim location. This means we can't match dom bindings to their lib.dom reference,\n-        // but we can still see if they match to a directive.\n-        if (!(node instanceof TmplAstTextAttribute) && !(node instanceof TmplAstBoundAttribute)) {\n-          return undefined;\n+\n+      switch (symbol.kind) {\n+        case SymbolKind.Directive:\n+        case SymbolKind.Template:\n+          // References to elements, templates, and directives will be through template references\n+          // (#ref). They shouldn't be used directly for a Language Service reference request.\n+          break;\n+        case SymbolKind.Element: {\n+          const matches = getDirectiveMatchesForElementTag(symbol.templateNode, symbol.directives);\n+          references.push(...this.getReferencesForDirectives(matches) ?? []);\n+          break;\n         }\n-        const directives = getDirectiveMatchesForAttribute(\n-            node.name, symbol.host.templateNode, symbol.host.directives);\n-        return this.getReferencesForDirectives(directives);\n-      }\n-      case SymbolKind.Reference: {\n-        const {shimPath, positionInShimFile} = symbol.referenceVarLocation;\n-        return this.getReferencesAtTypescriptPosition(shimPath, positionInShimFile);\n-      }\n-      case SymbolKind.Variable: {\n-        const {positionInShimFile: initializerPosition, shimPath} = symbol.initializerLocation;\n-        const localVarPosition = symbol.localVarLocation.positionInShimFile;\n-\n-        if ((node instanceof TmplAstVariable)) {\n-          if (node.valueSpan !== undefined && isWithin(position, node.valueSpan)) {\n-            // In the valueSpan of the variable, we want to get the reference of the initializer.\n-            return this.getReferencesAtTypescriptPosition(shimPath, initializerPosition);\n-          } else if (isWithin(position, node.keySpan)) {\n-            // In the keySpan of the variable, we want to get the reference of the local variable.\n-            return this.getReferencesAtTypescriptPosition(shimPath, localVarPosition);\n-          } else {\n-            return undefined;\n+        case SymbolKind.DomBinding: {\n+          // Dom bindings aren't currently type-checked (see `checkTypeOfDomBindings`) so they don't\n+          // have a shim location. This means we can't match dom bindings to their lib.dom\n+          // reference, but we can still see if they match to a directive.\n+          if (!(node instanceof TmplAstTextAttribute) && !(node instanceof TmplAstBoundAttribute)) {\n+            break;\n           }\n+          const directives = getDirectiveMatchesForAttribute(\n+              node.name, symbol.host.templateNode, symbol.host.directives);\n+          references.push(...this.getReferencesForDirectives(directives) ?? []);\n+          break;\n         }\n+        case SymbolKind.Reference: {\n+          const {shimPath, positionInShimFile} = symbol.referenceVarLocation;\n+          references.push(\n+              ...this.getReferencesAtTypescriptPosition(shimPath, positionInShimFile) ?? []);\n+          break;\n+        }\n+        case SymbolKind.Variable: {\n+          const {positionInShimFile: initializerPosition, shimPath} = symbol.initializerLocation;\n+          const localVarPosition = symbol.localVarLocation.positionInShimFile;\n+\n+          if ((node instanceof TmplAstVariable)) {\n+            if (node.valueSpan !== undefined && isWithin(position, node.valueSpan)) {\n+              // In the valueSpan of the variable, we want to get the reference of the initializer.\n+              references.push(\n+                  ...this.getReferencesAtTypescriptPosition(shimPath, initializerPosition) ?? []);\n+            } else if (isWithin(position, node.keySpan)) {\n+              // In the keySpan of the variable, we want to get the reference of the local variable.\n+              references.push(\n+                  ...this.getReferencesAtTypescriptPosition(shimPath, localVarPosition) ?? []);\n+            }\n+          } else {\n+            // If the templateNode is not the `TmplAstVariable`, it must be a usage of the variable\n+            // somewhere in the template.\n+            references.push(\n+                ...this.getReferencesAtTypescriptPosition(shimPath, localVarPosition) ?? []);\n+          }\n \n-        // If the templateNode is not the `TmplAstVariable`, it must be a usage of the variable\n-        // somewhere in the template.\n-        return this.getReferencesAtTypescriptPosition(shimPath, localVarPosition);\n-      }\n-      case SymbolKind.Input:\n-      case SymbolKind.Output: {\n-        // TODO(atscott): Determine how to handle when the binding maps to several inputs/outputs\n-        const {shimPath, positionInShimFile} = symbol.bindings[0].shimLocation;\n-        return this.getReferencesAtTypescriptPosition(shimPath, positionInShimFile);\n-      }\n-      case SymbolKind.Pipe:\n-      case SymbolKind.Expression: {\n-        const {shimPath, positionInShimFile} = symbol.shimLocation;\n-        return this.getReferencesAtTypescriptPosition(shimPath, positionInShimFile);\n+          break;\n+        }\n+        case SymbolKind.Input:\n+        case SymbolKind.Output: {\n+          // TODO(atscott): Determine how to handle when the binding maps to several inputs/outputs\n+          const {shimPath, positionInShimFile} = symbol.bindings[0].shimLocation;\n+          references.push(\n+              ...this.getReferencesAtTypescriptPosition(shimPath, positionInShimFile) ?? []);\n+          break;\n+        }\n+        case SymbolKind.Pipe:\n+        case SymbolKind.Expression: {\n+          const {shimPath, positionInShimFile} = symbol.shimLocation;\n+          references.push(\n+              ...this.getReferencesAtTypescriptPosition(shimPath, positionInShimFile) ?? []);\n+          break;\n+        }\n       }\n     }\n+    if (references.length === 0) {\n+      return undefined;\n+    }\n+\n+    return references;\n   }\n \n   private getReferencesForDirectives(directives: Set<DirectiveSymbol>):"
        },
        {
            "sha": "07d0dd51d77b1808bca437b7c3ed6a4152a35f88",
            "filename": "packages/language-service/ivy/test/references_spec.ts",
            "status": "modified",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/angular/angular/blob/ebb7ac5979b09edf9c56c7f4b143c220af2f1e9d/packages%2Flanguage-service%2Fivy%2Ftest%2Freferences_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/ebb7ac5979b09edf9c56c7f4b143c220af2f1e9d/packages%2Flanguage-service%2Fivy%2Ftest%2Freferences_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Freferences_spec.ts?ref=ebb7ac5979b09edf9c56c7f4b143c220af2f1e9d",
            "patch": "@@ -666,6 +666,37 @@ describe('find references', () => {\n     });\n   });\n \n+  it('should get references to both input and output for two-way binding', () => {\n+    const dirFile = {\n+      name: _('/dir.ts'),\n+      contents: `\n+      import {Directive, Input, Output} from '@angular/core';\n+\n+      @Directive({selector: '[string-model]'})\n+      export class StringModel {\n+        @Input() model!: any;\n+        @Output() modelChange!: any;\n+      }`\n+    };\n+    const {text, cursor} = extractCursorInfo(`\n+    import {Component} from '@angular/core';\n+\n+    @Component({template: '<div string-model [(modÂ¦el)]=\"title\"></div>'})\n+    export class AppCmp {\n+      title = 'title';\n+    }`);\n+    const appFile = {name: _('/app.ts'), contents: text};\n+    env = createModuleWithDeclarations([appFile, dirFile]);\n+\n+    const refs = getReferencesAtPosition(_('/app.ts'), cursor)!;\n+    // Note that this includes the 'model` twice from the template. As with other potential\n+    // duplicates (like if another plugin returns the same span), we expect the LS clients to filter\n+    // these out themselves.\n+    expect(refs.length).toEqual(4);\n+    assertFileNames(refs, ['dir.ts', 'app.ts']);\n+    assertTextSpans(refs, ['model', 'modelChange']);\n+  });\n+\n   describe('directives', () => {\n     it('works for directive classes', () => {\n       const {text, cursor} = extractCursorInfo(`"
        }
    ],
    "stats": {
        "total": 169,
        "additions": 110,
        "deletions": 59
    }
}