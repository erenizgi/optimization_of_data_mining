{
    "author": "atscott",
    "message": "feat(compiler-cli): `TemplateTypeChecker` operation to get `Symbol` from a template node (#38618)\n\nSpecifically, this commit adds support for retrieving a `Symbol` from a\n`TmplAstBoundEvent` or `TmplAstBoundAttribute`. Other template nodes\nwill be supported in following commits.\n\nPR Close #38618",
    "sha": "c4556db9f57e8898d0059739ea397d6a67325398",
    "files": [
        {
            "sha": "843466a2e4361a833e9ed72c0dd31b9ea15cbf01",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/checker.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 1,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/c4556db9f57e8898d0059739ea397d6a67325398/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/c4556db9f57e8898d0059739ea397d6a67325398/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts?ref=c4556db9f57e8898d0059739ea397d6a67325398",
            "patch": "@@ -6,9 +6,11 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {ParseError, TmplAstNode} from '@angular/compiler';\n+import {AST, ParseError, TmplAstNode,} from '@angular/compiler';\n import * as ts from 'typescript';\n \n+import {Symbol} from './symbols';\n+\n /**\n  * Interface to the Angular Template Type Checker to extract diagnostics and intelligence from the\n  * compiler's understanding of component templates.\n@@ -77,6 +79,15 @@ export interface TemplateTypeChecker {\n    * This method always runs in `OptimizeFor.SingleFile` mode.\n    */\n   getTypeCheckBlock(component: ts.ClassDeclaration): ts.Node|null;\n+\n+  /**\n+   * Retrieves a `Symbol` for the node in a component's template.\n+   *\n+   * This method can return `null` if a valid `Symbol` cannot be determined for the node.\n+   *\n+   * @see Symbol\n+   */\n+  getSymbolOfNode(node: AST|TmplAstNode, component: ts.ClassDeclaration): Symbol|null;\n }\n \n /**"
        },
        {
            "sha": "5ef92a8a601706ae155ee33988b53247daaddc32",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts",
            "status": "modified",
            "additions": 30,
            "deletions": 5,
            "changes": 35,
            "blob_url": "https://github.com/angular/angular/blob/c4556db9f57e8898d0059739ea397d6a67325398/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/c4556db9f57e8898d0059739ea397d6a67325398/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts?ref=c4556db9f57e8898d0059739ea397d6a67325398",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {ParseError, parseTemplate, TmplAstNode} from '@angular/compiler';\n+import {AST, ParseError, parseTemplate, TmplAstNode} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {absoluteFromSourceFile, AbsoluteFsPath, getSourceFileOrError} from '../../file_system';\n@@ -15,12 +15,13 @@ import {IncrementalBuild} from '../../incremental/api';\n import {ReflectionHost} from '../../reflection';\n import {isShim} from '../../shims';\n import {getSourceFileOrNull} from '../../util/src/typescript';\n-import {OptimizeFor, ProgramTypeCheckAdapter, TemplateId, TemplateTypeChecker, TypeCheckingConfig, TypeCheckingProgramStrategy, UpdateMode} from '../api';\n+import {OptimizeFor, ProgramTypeCheckAdapter, Symbol, TemplateId, TemplateTypeChecker, TypeCheckingConfig, TypeCheckingProgramStrategy, UpdateMode} from '../api';\n import {TemplateDiagnostic} from '../diagnostics';\n \n-import {InliningMode, ShimTypeCheckingData, TypeCheckContextImpl, TypeCheckingHost} from './context';\n+import {InliningMode, ShimTypeCheckingData, TemplateData, TypeCheckContextImpl, TypeCheckingHost} from './context';\n import {findTypeCheckBlock, shouldReportDiagnostic, TemplateSourceResolver, translateDiagnostic} from './diagnostics';\n import {TemplateSourceManager} from './source';\n+import {SymbolBuilder} from './template_symbol_builder';\n \n /**\n  * Primary template type-checking engine, which performs type-checking using a\n@@ -50,6 +51,14 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n   }\n \n   getTemplate(component: ts.ClassDeclaration): TmplAstNode[]|null {\n+    const templateData = this.getTemplateData(component);\n+    if (templateData === null) {\n+      return null;\n+    }\n+    return templateData.template;\n+  }\n+\n+  private getTemplateData(component: ts.ClassDeclaration): TemplateData|null {\n     this.ensureShimForComponent(component);\n \n     const sf = component.getSourceFile();\n@@ -59,7 +68,7 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     const fileRecord = this.getFileData(sfPath);\n \n     if (!fileRecord.shimData.has(shimPath)) {\n-      return [];\n+      return null;\n     }\n \n     const templateId = fileRecord.sourceManager.getTemplateId(component);\n@@ -69,7 +78,7 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n       return null;\n     }\n \n-    return shimRecord.templates.get(templateId)!.template;\n+    return shimRecord.templates.get(templateId)!;\n   }\n \n   overrideComponentTemplate(component: ts.ClassDeclaration, template: string):\n@@ -349,6 +358,22 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     }\n     return this.state.get(path)!;\n   }\n+\n+  getSymbolOfNode(node: AST|TmplAstNode, component: ts.ClassDeclaration): Symbol|null {\n+    const tcb = this.getTypeCheckBlock(component);\n+    if (tcb === null) {\n+      return null;\n+    }\n+\n+    const typeChecker = this.typeCheckingStrategy.getProgram().getTypeChecker();\n+    const shimPath = this.typeCheckingStrategy.shimPathForComponent(component);\n+    const data = this.getTemplateData(component);\n+    if (data === null) {\n+      return null;\n+    }\n+\n+    return new SymbolBuilder(typeChecker, shimPath, tcb, data).getSymbol(node);\n+  }\n }\n \n function convertDiagnostic("
        },
        {
            "sha": "3255b2dae2ef032e9a6a166df3f26172a1730751",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/comments.ts",
            "status": "modified",
            "additions": 61,
            "deletions": 3,
            "changes": 64,
            "blob_url": "https://github.com/angular/angular/blob/c4556db9f57e8898d0059739ea397d6a67325398/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcomments.ts",
            "raw_url": "https://github.com/angular/angular/raw/c4556db9f57e8898d0059739ea397d6a67325398/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcomments.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcomments.ts?ref=c4556db9f57e8898d0059739ea397d6a67325398",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AbsoluteSourceSpan} from '@angular/compiler';\n+import {AbsoluteSourceSpan, ParseSourceSpan} from '@angular/compiler';\n import * as ts from 'typescript';\n \n const parseSpanComment = /^(\\d+),(\\d+)$/;\n@@ -17,7 +17,8 @@ const parseSpanComment = /^(\\d+),(\\d+)$/;\n  *\n  * Will return `null` if no trailing comments on the node match the expected form of a source span.\n  */\n-export function readSpanComment(sourceFile: ts.SourceFile, node: ts.Node): AbsoluteSourceSpan|null {\n+export function readSpanComment(\n+    node: ts.Node, sourceFile: ts.SourceFile = node.getSourceFile()): AbsoluteSourceSpan|null {\n   return ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {\n     if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n       return null;\n@@ -51,7 +52,7 @@ export function addExpressionIdentifier(node: ts.Node, identifier: ExpressionIde\n       /* hasTrailingNewLine */ false);\n }\n \n-export const IGNORE_MARKER = `${CommentTriviaType.DIAGNOSTIC}:ignore`;\n+const IGNORE_MARKER = `${CommentTriviaType.DIAGNOSTIC}:ignore`;\n \n /**\n  * Tag the `ts.Node` with an indication that any errors arising from the evaluation of the node\n@@ -72,3 +73,60 @@ export function hasIgnoreMarker(node: ts.Node, sourceFile: ts.SourceFile): boole\n     return commentText === IGNORE_MARKER;\n   }) === true;\n }\n+\n+function makeRecursiveVisitor<T extends ts.Node>(visitor: (node: ts.Node) => T | null):\n+    (node: ts.Node) => T | undefined {\n+  function recursiveVisitor(node: ts.Node): T|undefined {\n+    const res = visitor(node);\n+    return res !== null ? res : node.forEachChild(recursiveVisitor);\n+  }\n+  return recursiveVisitor;\n+}\n+\n+export interface FindOptions<T extends ts.Node> {\n+  filter: (node: ts.Node) => node is T;\n+  withSpan?: AbsoluteSourceSpan|ParseSourceSpan;\n+}\n+\n+/**\n+ * Given a `ts.Node` with finds the first node whose matching the criteria specified\n+ * by the `FindOptions`.\n+ *\n+ * Returns `null` when no `ts.Node` matches the given conditions.\n+ */\n+export function findFirstMatchingNode<T extends ts.Node>(tcb: ts.Node, opts: FindOptions<T>): T|\n+    null {\n+  let withSpan: {start: number, end: number}|null = null;\n+  if (opts.withSpan !== undefined) {\n+    if (opts.withSpan instanceof AbsoluteSourceSpan) {\n+      withSpan = opts.withSpan;\n+    } else {\n+      withSpan = {start: opts.withSpan.start.offset, end: opts.withSpan.end.offset};\n+    }\n+  }\n+  const sf = tcb.getSourceFile();\n+  const visitor = makeRecursiveVisitor<T>(node => {\n+    if (!opts.filter(node)) {\n+      return null;\n+    }\n+    if (withSpan !== null) {\n+      const comment = readSpanComment(node, sf);\n+      if (comment === null || withSpan.start !== comment.start || withSpan.end !== comment.end) {\n+        return null;\n+      }\n+    }\n+    return node;\n+  });\n+  return tcb.forEachChild(visitor) ?? null;\n+}\n+\n+export function hasExpressionIdentifier(\n+    sourceFile: ts.SourceFile, node: ts.Node, identifier: ExpressionIdentifier): boolean {\n+  return ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {\n+    if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n+      return false;\n+    }\n+    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n+    return commentText === `${CommentTriviaType.EXPRESSION_TYPE_IDENTIFIER}:${identifier}`;\n+  }) || false;\n+}"
        },
        {
            "sha": "ff8be749683ee51d1a39031e539af3d8483e0629",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/diagnostics.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/c4556db9f57e8898d0059739ea397d6a67325398/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fdiagnostics.ts",
            "raw_url": "https://github.com/angular/angular/raw/c4556db9f57e8898d0059739ea397d6a67325398/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fdiagnostics.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fdiagnostics.ts?ref=c4556db9f57e8898d0059739ea397d6a67325398",
            "patch": "@@ -162,7 +162,7 @@ function findSourceLocation(node: ts.Node, sourceFile: ts.SourceFile): SourceLoc\n       return null;\n     }\n \n-    const span = readSpanComment(sourceFile, node);\n+    const span = readSpanComment(node, sourceFile);\n     if (span !== null) {\n       // Once the positional information has been extracted, search further up the TCB to extract\n       // the unique id that is attached with the TCB's function declaration."
        },
        {
            "sha": "37bca8f8bc4c1fc14b98b9178a35f0921ba3d4f2",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder.ts",
            "status": "added",
            "additions": 215,
            "deletions": 0,
            "changes": 215,
            "blob_url": "https://github.com/angular/angular/blob/c4556db9f57e8898d0059739ea397d6a67325398/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "raw_url": "https://github.com/angular/angular/raw/c4556db9f57e8898d0059739ea397d6a67325398/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts?ref=c4556db9f57e8898d0059739ea397d6a67325398",
            "patch": "@@ -0,0 +1,215 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {AST, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n+import * as ts from 'typescript';\n+\n+import {AbsoluteFsPath} from '../../file_system';\n+import {isAssignment} from '../../util/src/typescript';\n+import {DirectiveSymbol, ElementSymbol, ExpressionSymbol, InputBindingSymbol, OutputBindingSymbol, ReferenceSymbol, Symbol, SymbolKind, TsNodeSymbolInfo, VariableSymbol} from '../api';\n+\n+import {ExpressionIdentifier, findFirstMatchingNode, hasExpressionIdentifier} from './comments';\n+import {TemplateData} from './context';\n+import {TcbDirectiveOutputsOp} from './type_check_block';\n+\n+/**\n+ * A class which extracts information from a type check block.\n+ * This class is essentially used as just a closure around the constructor parameters.\n+ */\n+export class SymbolBuilder {\n+  constructor(\n+      private readonly typeChecker: ts.TypeChecker, private readonly shimPath: AbsoluteFsPath,\n+      private readonly typeCheckBlock: ts.Node, private readonly templateData: TemplateData) {}\n+\n+  getSymbol(node: AST|TmplAstNode): Symbol|null {\n+    if (node instanceof TmplAstBoundAttribute) {\n+      // TODO(atscott): input and output bindings only return the first directive match but should\n+      // return a list of bindings for all of them.\n+      return this.getSymbolOfInputBinding(node);\n+    } else if (node instanceof TmplAstBoundEvent) {\n+      return this.getSymbolOfBoundEvent(node);\n+    }\n+    return null;\n+  }\n+\n+  private getSymbolOfBoundEvent(eventBinding: TmplAstBoundEvent): OutputBindingSymbol|null {\n+    // Outputs are a `ts.CallExpression` that look like one of the two:\n+    // * _outputHelper(_t1[\"outputField\"]).subscribe(handler);\n+    // * _t1.addEventListener(handler);\n+    const node = findFirstMatchingNode(\n+        this.typeCheckBlock, {withSpan: eventBinding.sourceSpan, filter: ts.isCallExpression});\n+    if (node === null) {\n+      return null;\n+    }\n+\n+    const consumer = this.templateData.boundTarget.getConsumerOfBinding(eventBinding);\n+    if (consumer instanceof TmplAstTemplate || consumer instanceof TmplAstElement) {\n+      // Bindings to element or template events produce `addEventListener` which\n+      // we cannot get the field for.\n+      return null;\n+    }\n+    const outputFieldAccess = TcbDirectiveOutputsOp.decodeOutputCallExpression(node);\n+    if (outputFieldAccess === null) {\n+      return null;\n+    }\n+\n+    const tsSymbol = this.typeChecker.getSymbolAtLocation(outputFieldAccess.argumentExpression);\n+    if (tsSymbol === undefined) {\n+      return null;\n+    }\n+\n+\n+    const target = this.getDirectiveSymbolForAccessExpression(outputFieldAccess);\n+    if (target === null) {\n+      return null;\n+    }\n+\n+    const positionInShimFile = outputFieldAccess.argumentExpression.getStart();\n+    const tsType = this.typeChecker.getTypeAtLocation(node);\n+    return {\n+      kind: SymbolKind.Output,\n+      bindings: [{\n+        kind: SymbolKind.Binding,\n+        tsSymbol,\n+        tsType,\n+        target,\n+        shimLocation: {shimPath: this.shimPath, positionInShimFile},\n+      }],\n+    };\n+  }\n+\n+  private getSymbolOfInputBinding(attributeBinding: TmplAstBoundAttribute): InputBindingSymbol\n+      |null {\n+    const node = findFirstMatchingNode(\n+        this.typeCheckBlock, {withSpan: attributeBinding.sourceSpan, filter: isAssignment});\n+    if (node === null) {\n+      return null;\n+    }\n+\n+    let tsSymbol: ts.Symbol|undefined;\n+    let positionInShimFile: number|null = null;\n+    let tsType: ts.Type;\n+    if (ts.isElementAccessExpression(node.left)) {\n+      tsSymbol = this.typeChecker.getSymbolAtLocation(node.left.argumentExpression);\n+      positionInShimFile = node.left.argumentExpression.getStart();\n+      tsType = this.typeChecker.getTypeAtLocation(node.left.argumentExpression);\n+    } else if (ts.isPropertyAccessExpression(node.left)) {\n+      tsSymbol = this.typeChecker.getSymbolAtLocation(node.left.name);\n+      positionInShimFile = node.left.name.getStart();\n+      tsType = this.typeChecker.getTypeAtLocation(node.left.name);\n+    } else {\n+      return null;\n+    }\n+    if (tsSymbol === undefined || positionInShimFile === null) {\n+      return null;\n+    }\n+\n+    const consumer = this.templateData.boundTarget.getConsumerOfBinding(attributeBinding);\n+    let target: ElementSymbol|DirectiveSymbol|null;\n+    if (consumer instanceof TmplAstTemplate || consumer instanceof TmplAstElement) {\n+      // TODO(atscott): handle bindings to elements and templates\n+      target = null;\n+    } else {\n+      target = this.getDirectiveSymbolForAccessExpression(node.left);\n+    }\n+\n+    if (target === null) {\n+      return null;\n+    }\n+\n+    return {\n+      kind: SymbolKind.Input,\n+      bindings: [{\n+        kind: SymbolKind.Binding,\n+        tsSymbol,\n+        tsType,\n+        target,\n+        shimLocation: {shimPath: this.shimPath, positionInShimFile},\n+      }],\n+    };\n+  }\n+\n+  private getDirectiveSymbolForAccessExpression(node: ts.ElementAccessExpression|\n+                                                ts.PropertyAccessExpression): DirectiveSymbol|null {\n+    // In either case, `_t1[\"index\"]` or `_t1.index`, `node.expression` is _t1.\n+    // The retrieved symbol for _t1 will be the variable declaration.\n+    const tsSymbol = this.typeChecker.getSymbolAtLocation(node.expression);\n+    if (tsSymbol === undefined || tsSymbol.declarations.length === 0) {\n+      return null;\n+    }\n+\n+    const [declaration] = tsSymbol.declarations;\n+    if (!ts.isVariableDeclaration(declaration) ||\n+        !hasExpressionIdentifier(\n+            // The expression identifier could be on the type (for regular directives) or the name\n+            // (for generic directives and the ctor op).\n+            declaration.getSourceFile(), declaration.type ?? declaration.name,\n+            ExpressionIdentifier.DIRECTIVE)) {\n+      return null;\n+    }\n+\n+    const symbol = this.getSymbolOfVariableDeclaration(declaration);\n+    if (symbol === null || symbol.tsSymbol === null || symbol.tsType === null) {\n+      return null;\n+    }\n+\n+    return {\n+      ...symbol,\n+      kind: SymbolKind.Directive,\n+      tsSymbol: symbol.tsSymbol,\n+      tsType: symbol.tsType,\n+    };\n+  }\n+\n+  private getSymbolOfTsNode(node: ts.Node): TsNodeSymbolInfo|null {\n+    while (ts.isParenthesizedExpression(node)) {\n+      node = node.expression;\n+    }\n+\n+    let tsSymbol: ts.Symbol|undefined;\n+    let positionInShimFile: number;\n+    if (ts.isPropertyAccessExpression(node)) {\n+      tsSymbol = this.typeChecker.getSymbolAtLocation(node.name);\n+      positionInShimFile = node.name.getStart();\n+    } else {\n+      tsSymbol = this.typeChecker.getSymbolAtLocation(node);\n+      positionInShimFile = node.getStart();\n+    }\n+\n+    const type = this.typeChecker.getTypeAtLocation(node);\n+    return {\n+      // If we could not find a symbol, fall back to the symbol on the type for the node.\n+      // Some nodes won't have a \"symbol at location\" but will have a symbol for the type.\n+      // One example of this would be literals.\n+      tsSymbol: tsSymbol ?? type.symbol ?? null,\n+      tsType: type,\n+      shimLocation: {shimPath: this.shimPath, positionInShimFile},\n+    };\n+  }\n+\n+  private getSymbolOfVariableDeclaration(declaration: ts.VariableDeclaration): TsNodeSymbolInfo\n+      |null {\n+    // Instead of returning the Symbol for the temporary variable, we want to get the `ts.Symbol`\n+    // for:\n+    // - The type reference for `var _t2: MyDir = xyz` (prioritize/trust the declared type)\n+    // - The initializer for `var _t2 = _t1.index`.\n+    if (declaration.type && ts.isTypeReferenceNode(declaration.type)) {\n+      return this.getSymbolOfTsNode(declaration.type.typeName);\n+    }\n+    if (declaration.initializer === undefined) {\n+      return null;\n+    }\n+\n+    const symbol = this.getSymbolOfTsNode(declaration.initializer);\n+    if (symbol === null) {\n+      return null;\n+    }\n+\n+    return symbol;\n+  }\n+}"
        },
        {
            "sha": "bb2ba890985e8385b5d6c670c09e73c0f27aeb8b",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/c4556db9f57e8898d0059739ea397d6a67325398/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "raw_url": "https://github.com/angular/angular/raw/c4556db9f57e8898d0059739ea397d6a67325398/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts?ref=c4556db9f57e8898d0059739ea397d6a67325398",
            "patch": "@@ -376,8 +376,8 @@ class TcbDirectiveTypeOp extends TcbOp {\n     const id = this.tcb.allocateId();\n \n     const type = this.tcb.env.referenceType(this.dir.ref);\n-    addParseSpanInfo(type, this.node.startSourceSpan || this.node.sourceSpan);\n     addExpressionIdentifier(type, ExpressionIdentifier.DIRECTIVE);\n+    addParseSpanInfo(type, this.node.startSourceSpan || this.node.sourceSpan);\n     this.scope.addStatement(tsDeclareVariable(id, type));\n     return id;\n   }\n@@ -477,6 +477,8 @@ class TcbDirectiveCtorOp extends TcbOp {\n \n   execute(): ts.Identifier {\n     const id = this.tcb.allocateId();\n+    addExpressionIdentifier(id, ExpressionIdentifier.DIRECTIVE);\n+    addParseSpanInfo(id, this.node.startSourceSpan || this.node.sourceSpan);\n \n     const genericInputs = new Map<string, TcbDirectiveInput>();\n "
        },
        {
            "sha": "253e5b81934a3dd21d732278073615fea067f6bd",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/test_utils.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/c4556db9f57e8898d0059739ea397d6a67325398/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/c4556db9f57e8898d0059739ea397d6a67325398/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts?ref=c4556db9f57e8898d0059739ea397d6a67325398",
            "patch": "@@ -153,6 +153,16 @@ export function ngForDts(): TestFile {\n   };\n }\n \n+export function ngForTypeCheckTarget(): TypeCheckingTarget {\n+  const dts = ngForDts();\n+  return {\n+    ...dts,\n+    fileName: dts.name,\n+    source: dts.contents,\n+    templates: {},\n+  };\n+}\n+\n export const ALL_ENABLED_CONFIG: TypeCheckingConfig = {\n   applyTemplateContextGuards: true,\n   checkQueries: false,"
        },
        {
            "sha": "def71f70ba33340799795286ef699bdeeb879970",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker__get_symbol_of_template_node_spec.ts",
            "status": "added",
            "additions": 490,
            "deletions": 0,
            "changes": 490,
            "blob_url": "https://github.com/angular/angular/blob/c4556db9f57e8898d0059739ea397d6a67325398/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/c4556db9f57e8898d0059739ea397d6a67325398/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts?ref=c4556db9f57e8898d0059739ea397d6a67325398",
            "patch": "@@ -0,0 +1,490 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {TmplAstBoundAttribute, TmplAstElement, TmplAstTemplate} from '@angular/compiler';\n+import * as ts from 'typescript';\n+\n+import {absoluteFrom, getSourceFileOrError} from '../../file_system';\n+import {runInEachFileSystem} from '../../file_system/testing';\n+import {InputBindingSymbol, OutputBindingSymbol, Symbol, SymbolKind, TypeCheckingConfig} from '../api';\n+\n+import {getClass, ngForDeclaration, ngForTypeCheckTarget, setup as baseTestSetup, TypeCheckingTarget} from './test_utils';\n+\n+runInEachFileSystem(() => {\n+  describe('TemplateTypeChecker.getSymbolOfNodeInComponentTemplate', () => {\n+    describe('input bindings', () => {\n+      it('can retrieve a symbol for an input binding', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const dirFile = absoluteFrom('/dir.ts');\n+        const templateString =\n+            `<div dir [inputA]=\"'my input A'\" [inputBRenamed]=\"'my inputB'\"></div>`;\n+        const {program, templateTypeChecker} = setup([\n+          {\n+            fileName,\n+            templates: {'Cmp': templateString},\n+            declarations: [{\n+              name: 'TestDir',\n+              selector: '[dir]',\n+              file: dirFile,\n+              type: 'directive',\n+              inputs: {inputA: 'inputA', inputB: 'inputBRenamed'},\n+            }]\n+          },\n+          {\n+            fileName: dirFile,\n+            source: `export class TestDir {inputA!: string; inputB!: string}`,\n+            templates: {},\n+          }\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+\n+        const nodes = templateTypeChecker.getTemplate(cmp)!;\n+\n+        const inputAbinding = (nodes[0] as TmplAstElement).inputs[0];\n+        const aSymbol = templateTypeChecker.getSymbolOfNode(inputAbinding, cmp)!;\n+        assertInputBindingSymbol(aSymbol);\n+        expect((aSymbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration)\n+                   .name.getText())\n+            .toEqual('inputA');\n+\n+        const inputBbinding = (nodes[0] as TmplAstElement).inputs[1];\n+        const bSymbol = templateTypeChecker.getSymbolOfNode(inputBbinding, cmp)!;\n+        // TODO(atscott): The BoundTarget is not assigning renamed properties correctly\n+        // assertInputBindingSymbol(bSymbol);\n+        // expect((bSymbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration)\n+        //            .name.getText())\n+        //     .toEqual('inputB');\n+      });\n+\n+      it('does not retrieve a symbol for an input when undeclared', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const dirFile = absoluteFrom('/dir.ts');\n+        const templateString = `<div dir [inputA]=\"'my input A'\"></div>`;\n+        const {program, templateTypeChecker} = setup([\n+          {\n+            fileName,\n+            templates: {'Cmp': templateString},\n+            declarations: [{\n+              name: 'TestDir',\n+              selector: '[dir]',\n+              file: dirFile,\n+              type: 'directive',\n+              inputs: {inputA: 'inputA'},\n+            }]\n+          },\n+          {\n+            fileName: dirFile,\n+            source: `export class TestDir {}`,\n+            templates: {},\n+          }\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+\n+        const nodes = templateTypeChecker.getTemplate(cmp)!;\n+\n+        const inputAbinding = (nodes[0] as TmplAstElement).inputs[0];\n+        const aSymbol = templateTypeChecker.getSymbolOfNode(inputAbinding, cmp)!;\n+        expect(aSymbol).toBeNull();\n+      });\n+\n+      it('can retrieve a symbol for an input of structural directive', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const templateString = `<div *ngFor=\"let user of users\"></div>`;\n+        const {program, templateTypeChecker} = setup([\n+          {fileName, templates: {'Cmp': templateString}, declarations: [ngForDeclaration()]},\n+          ngForTypeCheckTarget(),\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+\n+        const nodes = templateTypeChecker.getTemplate(cmp)!;\n+\n+        const ngForOfBinding =\n+            (nodes[0] as TmplAstTemplate).templateAttrs.find(a => a.name === 'ngForOf')! as\n+            TmplAstBoundAttribute;\n+        const symbol = templateTypeChecker.getSymbolOfNode(ngForOfBinding, cmp)!;\n+        assertInputBindingSymbol(symbol);\n+        expect(\n+            (symbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration).name.getText())\n+            .toEqual('ngForOf');\n+      });\n+\n+      it('returns empty list when there is no directive registered for the binding', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const templateString = `<div dir [inputA]=\"'my input'\"></div>`;\n+        const {program, templateTypeChecker} = setup([\n+          {fileName, templates: {'Cmp': templateString}, declarations: []},\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+\n+        const nodes = templateTypeChecker.getTemplate(cmp)!;\n+        const binding = (nodes[0] as TmplAstElement).inputs[0];\n+\n+        const symbol = templateTypeChecker.getSymbolOfNode(binding, cmp);\n+        expect(symbol).toBeNull();\n+      });\n+\n+      it('returns empty list when directive members do not match the input', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const dirFile = absoluteFrom('/dir.ts');\n+        const templateString = `<div dir [inputA]=\"'my input A'\"></div>`;\n+        const {program, templateTypeChecker} = setup([\n+          {\n+            fileName,\n+            templates: {'Cmp': templateString},\n+            declarations: [{\n+              name: 'TestDir',\n+              selector: '[dir]',\n+              file: dirFile,\n+              type: 'directive',\n+              inputs: {},\n+            }]\n+          },\n+          {\n+            fileName: dirFile,\n+            source: `export class TestDir {}`,\n+            templates: {},\n+          }\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+\n+        const nodes = templateTypeChecker.getTemplate(cmp)!;\n+\n+        const inputAbinding = (nodes[0] as TmplAstElement).inputs[0];\n+        const symbol = templateTypeChecker.getSymbolOfNode(inputAbinding, cmp);\n+        expect(symbol).toBeNull();\n+      });\n+\n+      it('can match binding when there are two directives', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const dirFile = absoluteFrom('/dir.ts');\n+        const templateString = `<div dir otherDir [inputA]=\"'my input A'\"></div>`;\n+        const {program, templateTypeChecker} = setup([\n+          {\n+            fileName,\n+            templates: {'Cmp': templateString},\n+            declarations: [\n+              {\n+                name: 'TestDir',\n+                selector: '[dir]',\n+                file: dirFile,\n+                type: 'directive',\n+                inputs: {inputA: 'inputA'},\n+              },\n+              {\n+                name: 'OtherDir',\n+                selector: '[otherDir]',\n+                file: dirFile,\n+                type: 'directive',\n+                inputs: {},\n+              }\n+            ]\n+          },\n+          {\n+            fileName: dirFile,\n+            source: `\n+              export class TestDir {inputA!: string;}\n+              export class OtherDir {}\n+              `,\n+            templates: {},\n+          }\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+\n+        const nodes = templateTypeChecker.getTemplate(cmp)!;\n+\n+        const inputAbinding = (nodes[0] as TmplAstElement).inputs[0];\n+        const symbol = templateTypeChecker.getSymbolOfNode(inputAbinding, cmp)!;\n+        assertInputBindingSymbol(symbol);\n+        expect(\n+            (symbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration).name.getText())\n+            .toEqual('inputA');\n+        expect((symbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration)\n+                   .parent.name?.text)\n+            .toEqual('TestDir');\n+      });\n+\n+      it('returns the first field match when directive maps same input to two fields', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const dirFile = absoluteFrom('/dir.ts');\n+        const {program, templateTypeChecker} = setup([\n+          {\n+            fileName,\n+            templates: {'Cmp': `<div dir [inputA]=\"'my input A'\"></div>`},\n+            declarations: [\n+              {\n+                name: 'TestDir',\n+                selector: '[dir]',\n+                file: dirFile,\n+                type: 'directive',\n+                inputs: {inputA: 'inputA', otherInputA: 'inputA'},\n+              },\n+            ]\n+          },\n+          {\n+            fileName: dirFile,\n+            source: `\n+              export class TestDir {inputA!: string; otherInputA!: string;}\n+              `,\n+            templates: {},\n+          }\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+\n+        const nodes = templateTypeChecker.getTemplate(cmp)!;\n+\n+        const inputAbinding = (nodes[0] as TmplAstElement).inputs[0];\n+        const symbol = templateTypeChecker.getSymbolOfNode(inputAbinding, cmp)!;\n+        assertInputBindingSymbol(symbol);\n+        expect(\n+            (symbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration).name.getText())\n+            .toEqual('otherInputA');\n+        expect((symbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration)\n+                   .parent.name?.text)\n+            .toEqual('TestDir');\n+      });\n+\n+      it('returns the first directive match when two directives have the same input', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const dirFile = absoluteFrom('/dir.ts');\n+        const templateString = `<div dir otherDir [inputA]=\"'my input A'\"></div>`;\n+        const {program, templateTypeChecker} = setup([\n+          {\n+            fileName,\n+            templates: {'Cmp': templateString},\n+            declarations: [\n+              {\n+                name: 'TestDir',\n+                selector: '[dir]',\n+                file: dirFile,\n+                type: 'directive',\n+                inputs: {inputA: 'inputA'},\n+              },\n+              {\n+                name: 'OtherDir',\n+                selector: '[otherDir]',\n+                file: dirFile,\n+                type: 'directive',\n+                inputs: {otherDirInputA: 'inputA'},\n+              }\n+            ]\n+          },\n+          {\n+            fileName: dirFile,\n+            source: `\n+              export class TestDir {inputA!: string;}\n+              export class OtherDir {otherDirInputA!: string;}\n+              `,\n+            templates: {},\n+          }\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+\n+        const nodes = templateTypeChecker.getTemplate(cmp)!;\n+\n+        const inputAbinding = (nodes[0] as TmplAstElement).inputs[0];\n+        const symbol = templateTypeChecker.getSymbolOfNode(inputAbinding, cmp)!;\n+        assertInputBindingSymbol(symbol);\n+        expect(\n+            (symbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration).name.getText())\n+            .toEqual('inputA');\n+        expect((symbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration)\n+                   .parent.name?.text)\n+            .toEqual('TestDir');\n+      });\n+    });\n+\n+    describe('output bindings', () => {\n+      it('should find symbol for output binding', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const dirFile = absoluteFrom('/dir.ts');\n+        const templateString =\n+            `<div dir (outputA)=\"handle($event)\" (renamedOutputB)=\"handle($event)\"></div>`;\n+        const {program, templateTypeChecker} = setup([\n+          {\n+            fileName,\n+            templates: {'Cmp': templateString},\n+            declarations: [\n+              {\n+                name: 'TestDir',\n+                selector: '[dir]',\n+                file: dirFile,\n+                type: 'directive',\n+                outputs: {outputA: 'outputA', outputB: 'renamedOutputB'},\n+              },\n+            ]\n+          },\n+          {\n+            fileName: dirFile,\n+            source: `\n+              export class TestDir {outputA!: EventEmitter<string>; outputB!: EventEmitter<string>}\n+              `,\n+            templates: {},\n+          }\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+\n+        const nodes = templateTypeChecker.getTemplate(cmp)!;\n+\n+        const outputABinding = (nodes[0] as TmplAstElement).outputs[0];\n+        const aSymbol = templateTypeChecker.getSymbolOfNode(outputABinding, cmp)!;\n+        assertOutputBindingSymbol(aSymbol);\n+        expect((aSymbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration)\n+                   .name.getText())\n+            .toEqual('outputA');\n+\n+        const outputBBinding = (nodes[0] as TmplAstElement).outputs[1];\n+        const bSymbol = templateTypeChecker.getSymbolOfNode(outputBBinding, cmp)!;\n+        // TODO(atscott): The BoundTarget is not assigning renamed properties correctly\n+        // assertOutputBindingSymbol(bSymbol);\n+        // expect((bSymbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration)\n+        //            .name.getText())\n+        //     .toEqual('outputB');\n+      });\n+\n+      it('should find symbol for output binding when there are multiple directives', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const dirFile = absoluteFrom('/dir.ts');\n+        const {program, templateTypeChecker} = setup([\n+          {\n+            fileName,\n+            templates: {'Cmp': `<div dir otherdir (outputA)=\"handle($event)\"></div>`},\n+            declarations: [\n+              {\n+                name: 'TestDir',\n+                selector: '[dir]',\n+                file: dirFile,\n+                type: 'directive',\n+                outputs: {outputA: 'outputA'},\n+              },\n+              {\n+                name: 'OtherDir',\n+                selector: '[otherdir]',\n+                file: dirFile,\n+                type: 'directive',\n+                outputs: {unusedOutput: 'unusedOutput'},\n+              },\n+            ]\n+          },\n+          {\n+            fileName: dirFile,\n+            source: `\n+              export class TestDir {outputA!: EventEmitter<string>;}\n+              export class OtherDir {unusedOutput!: EventEmitter<string>;}\n+              `,\n+            templates: {},\n+          }\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+\n+        const nodes = templateTypeChecker.getTemplate(cmp)!;\n+\n+        const outputABinding = (nodes[0] as TmplAstElement).outputs[0];\n+        const symbol = templateTypeChecker.getSymbolOfNode(outputABinding, cmp)!;\n+        assertOutputBindingSymbol(symbol);\n+        expect(\n+            (symbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration).name.getText())\n+            .toEqual('outputA');\n+        expect((symbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration)\n+                   .parent.name?.text)\n+            .toEqual('TestDir');\n+      });\n+\n+      it('returns empty list when binding does not match any directive output', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const dirFile = absoluteFrom('/dir.ts');\n+        const {program, templateTypeChecker} = setup([\n+          {\n+            fileName,\n+            templates: {'Cmp': `<div dir (doesNotExist)=\"handle($event)\"></div>`},\n+            declarations: [\n+              {\n+                name: 'TestDir',\n+                selector: '[dir]',\n+                file: dirFile,\n+                type: 'directive',\n+                outputs: {outputA: 'outputA'},\n+              },\n+            ]\n+          },\n+          {\n+            fileName: dirFile,\n+            source: `export class TestDir {outputA!: EventEmitter<string>;}`,\n+            templates: {},\n+          }\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+\n+        const nodes = templateTypeChecker.getTemplate(cmp)!;\n+\n+        const outputABinding = (nodes[0] as TmplAstElement).outputs[0];\n+        const symbol = templateTypeChecker.getSymbolOfNode(outputABinding, cmp);\n+        expect(symbol).toBeNull();\n+      });\n+\n+      it('returns empty list when checkTypeOfOutputEvents is false', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const dirFile = absoluteFrom('/dir.ts');\n+        const {program, templateTypeChecker} = setup(\n+            [\n+              {\n+                fileName,\n+                templates: {'Cmp': `<div dir (outputA)=\"handle($event)\"></div>`},\n+                declarations: [\n+                  {\n+                    name: 'TestDir',\n+                    selector: '[dir]',\n+                    file: dirFile,\n+                    type: 'directive',\n+                    outputs: {outputA: 'outputA'},\n+                  },\n+                ]\n+              },\n+              {\n+                fileName: dirFile,\n+                source: `export class TestDir {outputA!: EventEmitter<string>;}`,\n+                templates: {},\n+              }\n+            ],\n+            {checkTypeOfOutputEvents: false});\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+\n+        const nodes = templateTypeChecker.getTemplate(cmp)!;\n+\n+        const outputABinding = (nodes[0] as TmplAstElement).outputs[0];\n+        const symbol = templateTypeChecker.getSymbolOfNode(outputABinding, cmp);\n+        // TODO(atscott): should type checker still generate the subscription in this case?\n+        expect(symbol).toBeNull();\n+      });\n+    });\n+  });\n+});\n+\n+function assertInputBindingSymbol(tSymbol: Symbol): asserts tSymbol is InputBindingSymbol {\n+  expect(tSymbol.kind).toEqual(SymbolKind.Input);\n+}\n+\n+function assertOutputBindingSymbol(tSymbol: Symbol): asserts tSymbol is OutputBindingSymbol {\n+  expect(tSymbol.kind).toEqual(SymbolKind.Output);\n+}\n+\n+export function setup(targets: TypeCheckingTarget[], config?: Partial<TypeCheckingConfig>) {\n+  return baseTestSetup(\n+      targets, {inlining: false, config: {...config, enableTemplateTypeChecker: true}});\n+}"
        },
        {
            "sha": "346c47773f5e9959ed3e5daa33aaa514c4ae8721",
            "filename": "packages/compiler-cli/src/ngtsc/util/src/typescript.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/c4556db9f57e8898d0059739ea397d6a67325398/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Futil%2Fsrc%2Ftypescript.ts",
            "raw_url": "https://github.com/angular/angular/raw/c4556db9f57e8898d0059739ea397d6a67325398/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Futil%2Fsrc%2Ftypescript.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Futil%2Fsrc%2Ftypescript.ts?ref=c4556db9f57e8898d0059739ea397d6a67325398",
            "patch": "@@ -139,6 +139,11 @@ export function resolveModuleName(\n   }\n }\n \n+/** Returns true if the node is an assignment expression. */\n+export function isAssignment(node: ts.Node): node is ts.BinaryExpression {\n+  return ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken;\n+}\n+\n /**\n  * Asserts that the keys `K` form a subset of the keys of `T`.\n  */"
        }
    ],
    "stats": {
        "total": 838,
        "additions": 827,
        "deletions": 11
    }
}