{
    "author": "clydin",
    "message": "feat(compiler-cli): support transforming component style resources (#41307)\n\nThis change introduces a new hook on the `ResourceHost` interface named `transformResource`.\nResource transformation allows both external and inline resources to be transformed prior to\ncompilation by the AOT compiler. This provides support for tooling integrations to enable\nfeatures such as preprocessor support for inline styles.\nOnly style resources are currently supported. However, the infrastructure is in place to add\ntemplate support in the future.\n\nPR Close #41307",
    "sha": "1de04b124e1e92ea21a070c9d928664f193d220c",
    "files": [
        {
            "sha": "ce1a5a154bf8fd76364232c45ae0375cc5367fa8",
            "filename": "packages/compiler-cli/ngcc/src/analysis/decoration_analyzer.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/1de04b124e1e92ea21a070c9d928664f193d220c/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fdecoration_analyzer.ts",
            "raw_url": "https://github.com/angular/angular/raw/1de04b124e1e92ea21a070c9d928664f193d220c/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fdecoration_analyzer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fdecoration_analyzer.ts?ref=1de04b124e1e92ea21a070c9d928664f193d220c",
            "patch": "@@ -40,9 +40,13 @@ import {isWithinPackage, NOOP_DEPENDENCY_TRACKER} from './util';\n class NgccResourceLoader implements ResourceLoader {\n   constructor(private fs: ReadonlyFileSystem) {}\n   canPreload = false;\n+  canPreprocess = false;\n   preload(): undefined|Promise<void> {\n     throw new Error('Not implemented.');\n   }\n+  preprocessInline(): Promise<string> {\n+    throw new Error('Not implemented.');\n+  }\n   load(url: string): string {\n     return this.fs.readFile(this.fs.resolve(url));\n   }"
        },
        {
            "sha": "98f12928a1709f0f59ecac7c63da54bd3889e052",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/1de04b124e1e92ea21a070c9d928664f193d220c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/1de04b124e1e92ea21a070c9d928664f193d220c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Findex.ts?ref=1de04b124e1e92ea21a070c9d928664f193d220c",
            "patch": "@@ -8,7 +8,7 @@\n \n /// <reference types=\"node\" />\n \n-export {ResourceLoader} from './src/api';\n+export {ResourceLoader, ResourceLoaderContext} from './src/api';\n export {ComponentDecoratorHandler} from './src/component';\n export {DirectiveDecoratorHandler} from './src/directive';\n export {InjectableDecoratorHandler} from './src/injectable';"
        },
        {
            "sha": "2ff84162eab643afa8e3a87fd8cf5374defd06ee",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/api.ts",
            "status": "modified",
            "additions": 36,
            "deletions": 1,
            "changes": 37,
            "blob_url": "https://github.com/angular/angular/blob/1de04b124e1e92ea21a070c9d928664f193d220c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/1de04b124e1e92ea21a070c9d928664f193d220c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fapi.ts?ref=1de04b124e1e92ea21a070c9d928664f193d220c",
            "patch": "@@ -21,6 +21,11 @@ export interface ResourceLoader {\n    */\n   canPreload: boolean;\n \n+  /**\n+   * If true, the resource loader is able to preprocess inline resources.\n+   */\n+  canPreprocess: boolean;\n+\n   /**\n    * Resolve the url of a resource relative to the file that contains the reference to it.\n    * The return value of this method can be used in the `load()` and `preload()` methods.\n@@ -37,11 +42,22 @@ export interface ResourceLoader {\n    * should be cached so it can be accessed synchronously via the `load()` method.\n    *\n    * @param resolvedUrl The url (resolved by a call to `resolve()`) of the resource to preload.\n+   * @param context Information regarding the resource such as the type and containing file.\n    * @returns A Promise that is resolved once the resource has been loaded or `undefined`\n    * if the file has already been loaded.\n    * @throws An Error if pre-loading is not available.\n    */\n-  preload(resolvedUrl: string): Promise<void>|undefined;\n+  preload(resolvedUrl: string, context: ResourceLoaderContext): Promise<void>|undefined;\n+\n+  /**\n+   * Preprocess the content data of an inline resource, asynchronously.\n+   *\n+   * @param data The existing content data from the inline resource.\n+   * @param context Information regarding the resource such as the type and containing file.\n+   * @returns A Promise that resolves to the processed data. If no processing occurs, the\n+   * same data string that was passed to the function will be resolved.\n+   */\n+  preprocessInline(data: string, context: ResourceLoaderContext): Promise<string>;\n \n   /**\n    * Load the resource at the given url, synchronously.\n@@ -53,3 +69,22 @@ export interface ResourceLoader {\n    */\n   load(resolvedUrl: string): string;\n }\n+\n+/**\n+ * Contextual information used by members of the ResourceLoader interface.\n+ */\n+export interface ResourceLoaderContext {\n+  /**\n+   * The type of the component resource.\n+   * * Resources referenced via a component's `styles` or `styleUrls` properties are of\n+   * type `style`.\n+   * * Resources referenced via a component's `template` or `templateUrl` properties are of type\n+   * `template`.\n+   */\n+  type: 'style'|'template';\n+\n+  /**\n+   * The absolute path to the file that contains the resource or reference to the resource.\n+   */\n+  containingFile: string;\n+}"
        },
        {
            "sha": "dd58ad5b56aeb937e542275e40dec83cd51f762c",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/component.ts",
            "status": "modified",
            "additions": 52,
            "deletions": 22,
            "changes": 74,
            "blob_url": "https://github.com/angular/angular/blob/1de04b124e1e92ea21a070c9d928664f193d220c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/1de04b124e1e92ea21a070c9d928664f193d220c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts?ref=1de04b124e1e92ea21a070c9d928664f193d220c",
            "patch": "@@ -220,6 +220,7 @@ export class ComponentDecoratorHandler implements\n    * thrown away, and the parsed template is reused during the analyze phase.\n    */\n   private preanalyzeTemplateCache = new Map<DeclarationNode, ParsedTemplateWithSource>();\n+  private preanalyzeStylesCache = new Map<DeclarationNode, string[]|null>();\n \n   readonly precedence = HandlerPrecedence.PRIMARY;\n   readonly name = ComponentDecoratorHandler.name;\n@@ -266,7 +267,7 @@ export class ComponentDecoratorHandler implements\n          resourceType: ResourceTypeForDiagnostics): Promise<void>|undefined => {\n           const resourceUrl =\n               this._resolveResourceOrThrow(styleUrl, containingFile, nodeForError, resourceType);\n-          return this.resourceLoader.preload(resourceUrl);\n+          return this.resourceLoader.preload(resourceUrl, {type: 'style', containingFile});\n         };\n \n     // A Promise that waits for the template and all <link>ed styles within it to be preloaded.\n@@ -289,22 +290,33 @@ export class ComponentDecoratorHandler implements\n     // Extract all the styleUrls in the decorator.\n     const componentStyleUrls = this._extractComponentStyleUrls(component);\n \n-    if (componentStyleUrls === null) {\n-      // A fast path exists if there are no styleUrls, to just wait for\n-      // templateAndTemplateStyleResources.\n-      return templateAndTemplateStyleResources;\n-    } else {\n-      // Wait for both the template and all styleUrl resources to resolve.\n-      return Promise\n-          .all([\n-            templateAndTemplateStyleResources,\n-            ...componentStyleUrls.map(\n-                styleUrl => resolveStyleUrl(\n-                    styleUrl.url, styleUrl.nodeForError,\n-                    ResourceTypeForDiagnostics.StylesheetFromDecorator))\n-          ])\n-          .then(() => undefined);\n+    // Extract inline styles, process, and cache for use in synchronous analyze phase\n+    let inlineStyles;\n+    if (component.has('styles')) {\n+      const litStyles = parseFieldArrayValue(component, 'styles', this.evaluator);\n+      if (litStyles === null) {\n+        this.preanalyzeStylesCache.set(node, null);\n+      } else {\n+        inlineStyles = Promise\n+                           .all(litStyles.map(\n+                               style => this.resourceLoader.preprocessInline(\n+                                   style, {type: 'style', containingFile})))\n+                           .then(styles => {\n+                             this.preanalyzeStylesCache.set(node, styles);\n+                           });\n+      }\n     }\n+\n+    // Wait for both the template and all styleUrl resources to resolve.\n+    return Promise\n+        .all([\n+          templateAndTemplateStyleResources, inlineStyles,\n+          ...componentStyleUrls.map(\n+              styleUrl => resolveStyleUrl(\n+                  styleUrl.url, styleUrl.nodeForError,\n+                  ResourceTypeForDiagnostics.StylesheetFromDecorator))\n+        ])\n+        .then(() => undefined);\n   }\n \n   analyze(\n@@ -409,12 +421,29 @@ export class ComponentDecoratorHandler implements\n       }\n     }\n \n+    // If inline styles were preprocessed use those\n     let inlineStyles: string[]|null = null;\n-    if (component.has('styles')) {\n-      const litStyles = parseFieldArrayValue(component, 'styles', this.evaluator);\n-      if (litStyles !== null) {\n-        inlineStyles = [...litStyles];\n-        styles.push(...litStyles);\n+    if (this.preanalyzeStylesCache.has(node)) {\n+      inlineStyles = this.preanalyzeStylesCache.get(node)!;\n+      this.preanalyzeStylesCache.delete(node);\n+      if (inlineStyles !== null) {\n+        styles.push(...inlineStyles);\n+      }\n+    } else {\n+      // Preprocessing is only supported asynchronously\n+      // If no style cache entry is present asynchronous preanalyze was not executed.\n+      // This protects against accidental differences in resource contents when preanalysis\n+      // is not used with a provided transformResource hook on the ResourceHost.\n+      if (this.resourceLoader.canPreprocess) {\n+        throw new Error('Inline resource processing requires asynchronous preanalyze.');\n+      }\n+\n+      if (component.has('styles')) {\n+        const litStyles = parseFieldArrayValue(component, 'styles', this.evaluator);\n+        if (litStyles !== null) {\n+          inlineStyles = [...litStyles];\n+          styles.push(...litStyles);\n+        }\n       }\n     }\n     if (template.styles.length > 0) {\n@@ -979,7 +1008,8 @@ export class ComponentDecoratorHandler implements\n       }\n       const resourceUrl = this._resolveResourceOrThrow(\n           templateUrl, containingFile, templateUrlExpr, ResourceTypeForDiagnostics.Template);\n-      const templatePromise = this.resourceLoader.preload(resourceUrl);\n+      const templatePromise =\n+          this.resourceLoader.preload(resourceUrl, {type: 'template', containingFile});\n \n       // If the preload worked, then actually load and parse the template, and wait for any style\n       // URLs to resolve."
        },
        {
            "sha": "63d33bd2c36bc2fbd76abcb9c9f5ee8a1c8a9aee",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/test/component_spec.ts",
            "status": "modified",
            "additions": 49,
            "deletions": 3,
            "changes": 52,
            "blob_url": "https://github.com/angular/angular/blob/1de04b124e1e92ea21a070c9d928664f193d220c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fcomponent_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/1de04b124e1e92ea21a070c9d928664f193d220c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fcomponent_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fcomponent_spec.ts?ref=1de04b124e1e92ea21a070c9d928664f193d220c",
            "patch": "@@ -20,20 +20,24 @@ import {NOOP_PERF_RECORDER} from '../../perf';\n import {isNamedClassDeclaration, TypeScriptReflectionHost} from '../../reflection';\n import {LocalModuleScopeRegistry, MetadataDtsModuleScopeResolver, TypeCheckScopeRegistry} from '../../scope';\n import {getDeclaration, makeProgram} from '../../testing';\n-import {ResourceLoader} from '../src/api';\n+import {ResourceLoader, ResourceLoaderContext} from '../src/api';\n import {ComponentDecoratorHandler} from '../src/component';\n \n export class StubResourceLoader implements ResourceLoader {\n   resolve(v: string): string {\n     return v;\n   }\n   canPreload = false;\n+  canPreprocess = false;\n   load(v: string): string {\n     return '';\n   }\n   preload(): Promise<void>|undefined {\n     throw new Error('Not implemented');\n   }\n+  preprocessInline(_data: string, _context: ResourceLoaderContext): Promise<string> {\n+    throw new Error('Not implemented');\n+  }\n }\n \n function setup(program: ts.Program, options: ts.CompilerOptions, host: ts.CompilerHost) {\n@@ -54,6 +58,7 @@ function setup(program: ts.Program, options: ts.CompilerOptions, host: ts.Compil\n   const injectableRegistry = new InjectableClassRegistry(reflectionHost);\n   const resourceRegistry = new ResourceRegistry();\n   const typeCheckScopeRegistry = new TypeCheckScopeRegistry(scopeRegistry, metaReader);\n+  const resourceLoader = new StubResourceLoader();\n \n   const handler = new ComponentDecoratorHandler(\n       reflectionHost,\n@@ -65,7 +70,7 @@ function setup(program: ts.Program, options: ts.CompilerOptions, host: ts.Compil\n       typeCheckScopeRegistry,\n       resourceRegistry,\n       /* isCore */ false,\n-      new StubResourceLoader(),\n+      resourceLoader,\n       /* rootDirs */['/'],\n       /* defaultPreserveWhitespaces */ false,\n       /* i18nUseExternalIds */ true,\n@@ -83,7 +88,7 @@ function setup(program: ts.Program, options: ts.CompilerOptions, host: ts.Compil\n       /* annotateForClosureCompiler */ false,\n       NOOP_PERF_RECORDER,\n   );\n-  return {reflectionHost, handler};\n+  return {reflectionHost, handler, resourceLoader};\n }\n \n runInEachFileSystem(() => {\n@@ -257,6 +262,47 @@ runInEachFileSystem(() => {\n           handler.compileFull(TestCmp, analysis!, resolution.data!, new ConstantPool());\n       expect(compileResult).toEqual([]);\n     });\n+\n+    it('should replace inline style content with transformed content', async () => {\n+      const {program, options, host} = makeProgram([\n+        {\n+          name: _('/node_modules/@angular/core/index.d.ts'),\n+          contents: 'export const Component: any;',\n+        },\n+        {\n+          name: _('/entry.ts'),\n+          contents: `\n+          import {Component} from '@angular/core';\n+\n+          @Component({\n+            template: '',\n+            styles: ['.abc {}']\n+          }) class TestCmp {}\n+      `\n+        },\n+      ]);\n+      const {reflectionHost, handler, resourceLoader} = setup(program, options, host);\n+      resourceLoader.canPreload = true;\n+      resourceLoader.canPreprocess = true;\n+      resourceLoader.preprocessInline = async function(data, context) {\n+        expect(data).toBe('.abc {}');\n+        expect(context.containingFile).toBe(_('/entry.ts').toLowerCase());\n+        expect(context.type).toBe('style');\n+\n+        return '.xyz {}';\n+      };\n+\n+      const TestCmp = getDeclaration(program, _('/entry.ts'), 'TestCmp', isNamedClassDeclaration);\n+      const detected = handler.detect(TestCmp, reflectionHost.getDecoratorsOfDeclaration(TestCmp));\n+      if (detected === undefined) {\n+        return fail('Failed to recognize @Component');\n+      }\n+\n+      await handler.preanalyze(TestCmp, detected.metadata);\n+\n+      const {analysis} = handler.analyze(TestCmp, detected.metadata);\n+      expect(analysis?.inlineStyles).toEqual(jasmine.arrayWithExactContents(['.xyz {}']));\n+    });\n   });\n \n   function ivyCode(code: ErrorCode): number {"
        },
        {
            "sha": "b9ba08a2cc0b6e93549a89dfd02f2cb3bdcfeb3e",
            "filename": "packages/compiler-cli/src/ngtsc/core/api/src/adapter.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/1de04b124e1e92ea21a070c9d928664f193d220c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fapi%2Fsrc%2Fadapter.ts",
            "raw_url": "https://github.com/angular/angular/raw/1de04b124e1e92ea21a070c9d928664f193d220c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fapi%2Fsrc%2Fadapter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fapi%2Fsrc%2Fadapter.ts?ref=1de04b124e1e92ea21a070c9d928664f193d220c",
            "patch": "@@ -28,7 +28,7 @@ export type ExtendedCompilerHostMethods =\n     'getCurrentDirectory'|\n     // Additional methods of `ExtendedTsCompilerHost` related to resource files (e.g. HTML\n     // templates). These are optional.\n-    'getModifiedResourceFiles'|'readResource'|'resourceNameToFileName';\n+    'getModifiedResourceFiles'|'readResource'|'resourceNameToFileName'|'transformResource';\n \n /**\n  * Adapter for `NgCompiler` that allows it to be used in various circumstances, such as"
        },
        {
            "sha": "3c3a2f0179eb174fc9a12b1f445be01f85d5213a",
            "filename": "packages/compiler-cli/src/ngtsc/core/api/src/interfaces.ts",
            "status": "modified",
            "additions": 46,
            "deletions": 0,
            "changes": 46,
            "blob_url": "https://github.com/angular/angular/blob/1de04b124e1e92ea21a070c9d928664f193d220c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fapi%2Fsrc%2Finterfaces.ts",
            "raw_url": "https://github.com/angular/angular/raw/1de04b124e1e92ea21a070c9d928664f193d220c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fapi%2Fsrc%2Finterfaces.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fapi%2Fsrc%2Finterfaces.ts?ref=1de04b124e1e92ea21a070c9d928664f193d220c",
            "patch": "@@ -49,6 +49,52 @@ export interface ResourceHost {\n    * or `undefined` if this is not an incremental build.\n    */\n   getModifiedResourceFiles?(): Set<string>|undefined;\n+\n+  /**\n+   * Transform an inline or external resource asynchronously.\n+   * It is assumed the consumer of the corresponding `Program` will call\n+   * `loadNgStructureAsync()`. Using outside `loadNgStructureAsync()` will\n+   * cause a diagnostics error or an exception to be thrown.\n+   * Only style resources are currently supported.\n+   *\n+   * @param data The resource data to transform.\n+   * @param context Information regarding the resource such as the type and containing file.\n+   * @returns A promise of either the transformed resource data or null if no transformation occurs.\n+   */\n+  transformResource?\n+      (data: string, context: ResourceHostContext): Promise<TransformResourceResult|null>;\n+}\n+\n+/**\n+ * Contextual information used by members of the ResourceHost interface.\n+ */\n+export interface ResourceHostContext {\n+  /**\n+   * The type of the component resource. Templates are not yet supported.\n+   * * Resources referenced via a component's `styles` or `styleUrls` properties are of\n+   * type `style`.\n+   */\n+  readonly type: 'style';\n+  /**\n+   * The absolute path to the resource file. If the resource is inline, the value will be null.\n+   */\n+  readonly resourceFile: string|null;\n+  /**\n+   * The absolute path to the file that contains the resource or reference to the resource.\n+   */\n+  readonly containingFile: string;\n+}\n+\n+/**\n+ * The successful transformation result of the `ResourceHost.transformResource` function.\n+ * This interface may be expanded in the future to include diagnostic information and source mapping\n+ * support.\n+ */\n+export interface TransformResourceResult {\n+  /**\n+   * The content generated by the transformation.\n+   */\n+  content: string;\n }\n \n /**"
        },
        {
            "sha": "b6378b9d2da04e569b3edfb759ef28ad0cc6f180",
            "filename": "packages/compiler-cli/src/ngtsc/core/src/host.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/1de04b124e1e92ea21a070c9d928664f193d220c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fhost.ts",
            "raw_url": "https://github.com/angular/angular/raw/1de04b124e1e92ea21a070c9d928664f193d220c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fhost.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fhost.ts?ref=1de04b124e1e92ea21a070c9d928664f193d220c",
            "patch": "@@ -59,6 +59,7 @@ export class DelegatingCompilerHost implements\n   readDirectory = this.delegateMethod('readDirectory');\n   readFile = this.delegateMethod('readFile');\n   readResource = this.delegateMethod('readResource');\n+  transformResource = this.delegateMethod('transformResource');\n   realpath = this.delegateMethod('realpath');\n   resolveModuleNames = this.delegateMethod('resolveModuleNames');\n   resolveTypeReferenceDirectives = this.delegateMethod('resolveTypeReferenceDirectives');"
        },
        {
            "sha": "9db512d65bbafcb650cd95536310ee2ae674fd33",
            "filename": "packages/compiler-cli/src/ngtsc/resource/src/loader.ts",
            "status": "modified",
            "additions": 41,
            "deletions": 4,
            "changes": 45,
            "blob_url": "https://github.com/angular/angular/blob/1de04b124e1e92ea21a070c9d928664f193d220c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fresource%2Fsrc%2Floader.ts",
            "raw_url": "https://github.com/angular/angular/raw/1de04b124e1e92ea21a070c9d928664f193d220c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fresource%2Fsrc%2Floader.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fresource%2Fsrc%2Floader.ts?ref=1de04b124e1e92ea21a070c9d928664f193d220c",
            "patch": "@@ -8,8 +8,8 @@\n \n import * as ts from 'typescript';\n \n-import {ResourceLoader} from '../../annotations';\n-import {NgCompilerAdapter} from '../../core/api';\n+import {ResourceLoader, ResourceLoaderContext} from '../../annotations';\n+import {NgCompilerAdapter, ResourceHostContext} from '../../core/api';\n import {AbsoluteFsPath, join, PathSegment} from '../../file_system';\n import {RequiredDelegations} from '../../util/src/typescript';\n \n@@ -27,6 +27,7 @@ export class AdapterResourceLoader implements ResourceLoader {\n   private lookupResolutionHost = createLookupResolutionHost(this.adapter);\n \n   canPreload = !!this.adapter.readResource;\n+  canPreprocess = !!this.adapter.transformResource;\n \n   constructor(private adapter: NgCompilerAdapter, private options: ts.CompilerOptions) {}\n \n@@ -62,11 +63,12 @@ export class AdapterResourceLoader implements ResourceLoader {\n    * `load()` method.\n    *\n    * @param resolvedUrl The url (resolved by a call to `resolve()`) of the resource to preload.\n+   * @param context Information about the resource such as the type and containing file.\n    * @returns A Promise that is resolved once the resource has been loaded or `undefined` if the\n    * file has already been loaded.\n    * @throws An Error if pre-loading is not available.\n    */\n-  preload(resolvedUrl: string): Promise<void>|undefined {\n+  preload(resolvedUrl: string, context: ResourceLoaderContext): Promise<void>|undefined {\n     if (!this.adapter.readResource) {\n       throw new Error(\n           'HostResourceLoader: the CompilerHost provided does not support pre-loading resources.');\n@@ -77,7 +79,20 @@ export class AdapterResourceLoader implements ResourceLoader {\n       return this.fetching.get(resolvedUrl);\n     }\n \n-    const result = this.adapter.readResource(resolvedUrl);\n+    let result = this.adapter.readResource(resolvedUrl);\n+\n+    if (this.adapter.transformResource && context.type === 'style') {\n+      const resourceContext: ResourceHostContext = {\n+        type: 'style',\n+        containingFile: context.containingFile,\n+        resourceFile: resolvedUrl,\n+      };\n+      result = Promise.resolve(result).then(async (str) => {\n+        const transformResult = await this.adapter.transformResource!(str, resourceContext);\n+        return transformResult === null ? str : transformResult.content;\n+      });\n+    }\n+\n     if (typeof result === 'string') {\n       this.cache.set(resolvedUrl, result);\n       return undefined;\n@@ -91,6 +106,28 @@ export class AdapterResourceLoader implements ResourceLoader {\n     }\n   }\n \n+  /**\n+   * Preprocess the content data of an inline resource, asynchronously.\n+   *\n+   * @param data The existing content data from the inline resource.\n+   * @param context Information regarding the resource such as the type and containing file.\n+   * @returns A Promise that resolves to the processed data. If no processing occurs, the\n+   * same data string that was passed to the function will be resolved.\n+   */\n+  async preprocessInline(data: string, context: ResourceLoaderContext): Promise<string> {\n+    if (!this.adapter.transformResource || context.type !== 'style') {\n+      return data;\n+    }\n+\n+    const transformResult = await this.adapter.transformResource(\n+        data, {type: 'style', containingFile: context.containingFile, resourceFile: null});\n+    if (transformResult === null) {\n+      return data;\n+    }\n+\n+    return transformResult.content;\n+  }\n+\n   /**\n    * Load the resource at the given url, synchronously.\n    *"
        }
    ],
    "stats": {
        "total": 263,
        "additions": 231,
        "deletions": 32
    }
}