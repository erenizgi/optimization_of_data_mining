{
    "author": "devversion",
    "message": "fix(ngcc): detect synthesized delegate constructors for downleveled ES2015 classes (#38463)\n\nSimilarly to the change we landed in the `@angular/core` reflection\ncapabilities, we need to make sure that ngcc can detect pass-through\ndelegate constructors for classes using downleveled ES2015 output.\n\nMore details can be found in the preceding commit, and in the issue\noutlining the problem: #38453.\n\nFixes #38453.\n\nPR Close #38463",
    "sha": "3b9c802deefcc53ab2b759ac8650449bed75aa9a",
    "files": [
        {
            "sha": "5464fbcff4cbec29f4db4c9417ce8099228b9106",
            "filename": "packages/compiler-cli/ngcc/src/host/esm5_host.ts",
            "status": "modified",
            "additions": 217,
            "deletions": 124,
            "changes": 341,
            "blob_url": "https://github.com/angular/angular/blob/3b9c802deefcc53ab2b759ac8650449bed75aa9a/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fesm5_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/3b9c802deefcc53ab2b759ac8650449bed75aa9a/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fesm5_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fesm5_host.ts?ref=3b9c802deefcc53ab2b759ac8650449bed75aa9a",
            "patch": "@@ -8,7 +8,7 @@\n \n import * as ts from 'typescript';\n \n-import {ClassDeclaration, ClassMember, ClassMemberKind, Declaration, Decorator, FunctionDefinition, Parameter, reflectObjectLiteral} from '../../../src/ngtsc/reflection';\n+import {ClassDeclaration, ClassMember, ClassMemberKind, Declaration, Decorator, FunctionDefinition, KnownDeclaration, Parameter, reflectObjectLiteral} from '../../../src/ngtsc/reflection';\n import {getTsHelperFnFromDeclaration, getTsHelperFnFromIdentifier, hasNameIdentifier} from '../utils';\n \n import {Esm2015ReflectionHost, getClassDeclarationFromInnerDeclaration, getPropertyValueFromSymbol, isAssignmentStatement, ParamInfo} from './esm2015_host';\n@@ -219,7 +219,7 @@ export class Esm5ReflectionHost extends Esm2015ReflectionHost {\n       return Array.from(constructor.parameters);\n     }\n \n-    if (isSynthesizedConstructor(constructor)) {\n+    if (this.isSynthesizedConstructor(constructor)) {\n       return null;\n     }\n \n@@ -352,6 +352,219 @@ export class Esm5ReflectionHost extends Esm2015ReflectionHost {\n     const classDeclarationParent = classSymbol.implementation.valueDeclaration.parent;\n     return ts.isBlock(classDeclarationParent) ? Array.from(classDeclarationParent.statements) : [];\n   }\n+\n+  ///////////// Host Private Helpers /////////////\n+\n+  /**\n+   * A constructor function may have been \"synthesized\" by TypeScript during JavaScript emit,\n+   * in the case no user-defined constructor exists and e.g. property initializers are used.\n+   * Those initializers need to be emitted into a constructor in JavaScript, so the TypeScript\n+   * compiler generates a synthetic constructor.\n+   *\n+   * We need to identify such constructors as ngcc needs to be able to tell if a class did\n+   * originally have a constructor in the TypeScript source. For ES5, we can not tell an\n+   * empty constructor apart from a synthesized constructor, but fortunately that does not\n+   * matter for the code generated by ngtsc.\n+   *\n+   * When a class has a superclass however, a synthesized constructor must not be considered\n+   * as a user-defined constructor as that prevents a base factory call from being created by\n+   * ngtsc, resulting in a factory function that does not inject the dependencies of the\n+   * superclass. Hence, we identify a default synthesized super call in the constructor body,\n+   * according to the structure that TypeScript's ES2015 to ES5 transformer generates in\n+   * https://github.com/Microsoft/TypeScript/blob/v3.2.2/src/compiler/transformers/es2015.ts#L1082-L1098\n+   *\n+   * Additionally, we handle synthetic delegate constructors that are emitted when TypeScript\n+   * downlevel's ES2015 synthetically generated to ES5. These vary slightly from the default\n+   * structure mentioned above because the ES2015 output uses a spread operator, for delegating\n+   * to the parent constructor, that is preserved through a TypeScript helper in ES5. e.g.\n+   *\n+   * ```\n+   * return _super.apply(this, tslib.__spread(arguments)) || this;\n+   * ```\n+   *\n+   * Such constructs can be still considered as synthetic delegate constructors as they are\n+   * the product of a common TypeScript to ES5 synthetic constructor, just being downleveled\n+   * to ES5 using `tsc`. See: https://github.com/angular/angular/issues/38453.\n+   *\n+   *\n+   * @param constructor a constructor function to test\n+   * @returns true if the constructor appears to have been synthesized\n+   */\n+  private isSynthesizedConstructor(constructor: ts.FunctionDeclaration): boolean {\n+    if (!constructor.body) return false;\n+\n+    const firstStatement = constructor.body.statements[0];\n+    if (!firstStatement) return false;\n+\n+    return this.isSynthesizedSuperThisAssignment(firstStatement) ||\n+        this.isSynthesizedSuperReturnStatement(firstStatement);\n+  }\n+\n+  /**\n+   * Identifies synthesized super calls which pass-through function arguments directly and are\n+   * being assigned to a common `_this` variable. The following patterns we intend to match:\n+   *\n+   * 1. Delegate call emitted by TypeScript when it emits ES5 directly.\n+   *   ```\n+   *   var _this = _super !== null && _super.apply(this, arguments) || this;\n+   *   ```\n+   *\n+   * 2. Delegate call emitted by TypeScript when it downlevel's ES2015 to ES5.\n+   *   ```\n+   *   var _this = _super.apply(this, tslib.__spread(arguments)) || this;\n+   *   ```\n+   *\n+   *\n+   * @param statement a statement that may be a synthesized super call\n+   * @returns true if the statement looks like a synthesized super call\n+   */\n+  private isSynthesizedSuperThisAssignment(statement: ts.Statement): boolean {\n+    if (!ts.isVariableStatement(statement)) return false;\n+\n+    const variableDeclarations = statement.declarationList.declarations;\n+    if (variableDeclarations.length !== 1) return false;\n+\n+    const variableDeclaration = variableDeclarations[0];\n+    if (!ts.isIdentifier(variableDeclaration.name) ||\n+        !variableDeclaration.name.text.startsWith('_this'))\n+      return false;\n+\n+    const initializer = variableDeclaration.initializer;\n+    if (!initializer) return false;\n+\n+    return this.isSynthesizedDefaultSuperCall(initializer);\n+  }\n+  /**\n+   * Identifies synthesized super calls which pass-through function arguments directly and\n+   * are being returned. The following patterns correspond to synthetic super return calls:\n+   *\n+   * 1. Delegate call emitted by TypeScript when it emits ES5 directly.\n+   *   ```\n+   *   return _super !== null && _super.apply(this, arguments) || this;\n+   *   ```\n+   *\n+   * 2. Delegate call emitted by TypeScript when it downlevel's ES2015 to ES5.\n+   *   ```\n+   *   return _super.apply(this, tslib.__spread(arguments)) || this;\n+   *   ```\n+   *\n+   * @param statement a statement that may be a synthesized super call\n+   * @returns true if the statement looks like a synthesized super call\n+   */\n+  private isSynthesizedSuperReturnStatement(statement: ts.Statement): boolean {\n+    if (!ts.isReturnStatement(statement)) return false;\n+\n+    const expression = statement.expression;\n+    if (!expression) return false;\n+\n+    return this.isSynthesizedDefaultSuperCall(expression);\n+  }\n+\n+  /**\n+   * Identifies synthesized super calls which pass-through function arguments directly. The\n+   * synthetic delegate super call match the following patterns we intend to match:\n+   *\n+   * 1. Delegate call emitted by TypeScript when it emits ES5 directly.\n+   *   ```\n+   *   _super !== null && _super.apply(this, arguments) || this;\n+   *   ```\n+   *\n+   * 2. Delegate call emitted by TypeScript when it downlevel's ES2015 to ES5.\n+   *   ```\n+   *   _super.apply(this, tslib.__spread(arguments)) || this;\n+   *   ```\n+   *\n+   * @param expression an expression that may represent a default super call\n+   * @returns true if the expression corresponds with the above form\n+   */\n+  private isSynthesizedDefaultSuperCall(expression: ts.Expression): boolean {\n+    if (!isBinaryExpr(expression, ts.SyntaxKind.BarBarToken)) return false;\n+    if (expression.right.kind !== ts.SyntaxKind.ThisKeyword) return false;\n+\n+    const left = expression.left;\n+    if (isBinaryExpr(left, ts.SyntaxKind.AmpersandAmpersandToken)) {\n+      return isSuperNotNull(left.left) && this.isSuperApplyCall(left.right);\n+    } else {\n+      return this.isSuperApplyCall(left);\n+    }\n+  }\n+\n+  /**\n+   * Tests whether the expression corresponds to a `super` call passing through\n+   * function arguments without any modification. e.g.\n+   *\n+   * ```\n+   * _super !== null && _super.apply(this, arguments) || this;\n+   * ```\n+   *\n+   * This structure is generated by TypeScript when transforming ES2015 to ES5, see\n+   * https://github.com/Microsoft/TypeScript/blob/v3.2.2/src/compiler/transformers/es2015.ts#L1148-L1163\n+   *\n+   * Additionally, we also handle cases where `arguments` are wrapped by a TypeScript spread helper.\n+   * This can happen if ES2015 class output contain auto-generated constructors due to class\n+   * members. The ES2015 output will be using `super(...arguments)` to delegate to the superclass,\n+   * but once downleveled to ES5, the spread operator will be persisted through a TypeScript spread\n+   * helper. For example:\n+   *\n+   * ```\n+   * _super.apply(this, __spread(arguments)) || this;\n+   * ```\n+   *\n+   * More details can be found in: https://github.com/angular/angular/issues/38453.\n+   *\n+   * @param expression an expression that may represent a default super call\n+   * @returns true if the expression corresponds with the above form\n+   */\n+  private isSuperApplyCall(expression: ts.Expression): boolean {\n+    if (!ts.isCallExpression(expression) || expression.arguments.length !== 2) return false;\n+\n+    const targetFn = expression.expression;\n+    if (!ts.isPropertyAccessExpression(targetFn)) return false;\n+    if (!isSuperIdentifier(targetFn.expression)) return false;\n+    if (targetFn.name.text !== 'apply') return false;\n+\n+    const thisArgument = expression.arguments[0];\n+    if (thisArgument.kind !== ts.SyntaxKind.ThisKeyword) return false;\n+\n+    const argumentsExpr = expression.arguments[1];\n+\n+    // If the super is directly invoked with `arguments`, return `true`. This represents the\n+    // common TypeScript output where the delegate constructor super call matches the following\n+    // pattern: `super.apply(this, arguments)`.\n+    if (isArgumentsIdentifier(argumentsExpr)) {\n+      return true;\n+    }\n+\n+    // The other scenario we intend to detect: The `arguments` variable might be wrapped with the\n+    // TypeScript spread helper (either through tslib or inlined). This can happen if an explicit\n+    // delegate constructor uses `super(...arguments)` in ES2015 and is downleveled to ES5 using\n+    // `--downlevelIteration`. The output in such cases would not directly pass the function\n+    // `arguments` to the `super` call, but wrap it in a TS spread helper. The output would match\n+    // the following pattern: `super.apply(this, tslib.__spread(arguments))`. We check for such\n+    // constructs below, but perform the detection of the call expression definition as last as\n+    // that is the most expensive operation here.\n+    if (!ts.isCallExpression(argumentsExpr) || argumentsExpr.arguments.length !== 1 ||\n+        !isArgumentsIdentifier(argumentsExpr.arguments[0])) {\n+      return false;\n+    }\n+\n+    const argumentsCallExpr = argumentsExpr.expression;\n+    let argumentsCallDeclaration: Declaration|null = null;\n+\n+    // The `__spread` helper could be globally available, or accessed through a namespaced\n+    // import. Hence we support a property access here as long as it resolves to the actual\n+    // known TypeScript spread helper.\n+    if (ts.isIdentifier(argumentsCallExpr)) {\n+      argumentsCallDeclaration = this.getDeclarationOfIdentifier(argumentsCallExpr);\n+    } else if (\n+        ts.isPropertyAccessExpression(argumentsCallExpr) &&\n+        ts.isIdentifier(argumentsCallExpr.name)) {\n+      argumentsCallDeclaration = this.getDeclarationOfIdentifier(argumentsCallExpr.name);\n+    }\n+\n+    return argumentsCallDeclaration !== null &&\n+        argumentsCallDeclaration.known === KnownDeclaration.TsHelperSpread;\n+  }\n }\n \n ///////////// Internal Helpers /////////////\n@@ -422,135 +635,15 @@ function reflectArrayElement(element: ts.Expression) {\n   return ts.isObjectLiteralExpression(element) ? reflectObjectLiteral(element) : null;\n }\n \n-/**\n- * A constructor function may have been \"synthesized\" by TypeScript during JavaScript emit,\n- * in the case no user-defined constructor exists and e.g. property initializers are used.\n- * Those initializers need to be emitted into a constructor in JavaScript, so the TypeScript\n- * compiler generates a synthetic constructor.\n- *\n- * We need to identify such constructors as ngcc needs to be able to tell if a class did\n- * originally have a constructor in the TypeScript source. For ES5, we can not tell an\n- * empty constructor apart from a synthesized constructor, but fortunately that does not\n- * matter for the code generated by ngtsc.\n- *\n- * When a class has a superclass however, a synthesized constructor must not be considered\n- * as a user-defined constructor as that prevents a base factory call from being created by\n- * ngtsc, resulting in a factory function that does not inject the dependencies of the\n- * superclass. Hence, we identify a default synthesized super call in the constructor body,\n- * according to the structure that TypeScript's ES2015 to ES5 transformer generates in\n- * https://github.com/Microsoft/TypeScript/blob/v3.2.2/src/compiler/transformers/es2015.ts#L1082-L1098\n- *\n- * @param constructor a constructor function to test\n- * @returns true if the constructor appears to have been synthesized\n- */\n-function isSynthesizedConstructor(constructor: ts.FunctionDeclaration): boolean {\n-  if (!constructor.body) return false;\n-\n-  const firstStatement = constructor.body.statements[0];\n-  if (!firstStatement) return false;\n-\n-  return isSynthesizedSuperThisAssignment(firstStatement) ||\n-      isSynthesizedSuperReturnStatement(firstStatement);\n-}\n-\n-/**\n- * Identifies a synthesized super call of the form:\n- *\n- * ```\n- * var _this = _super !== null && _super.apply(this, arguments) || this;\n- * ```\n- *\n- * @param statement a statement that may be a synthesized super call\n- * @returns true if the statement looks like a synthesized super call\n- */\n-function isSynthesizedSuperThisAssignment(statement: ts.Statement): boolean {\n-  if (!ts.isVariableStatement(statement)) return false;\n-\n-  const variableDeclarations = statement.declarationList.declarations;\n-  if (variableDeclarations.length !== 1) return false;\n-\n-  const variableDeclaration = variableDeclarations[0];\n-  if (!ts.isIdentifier(variableDeclaration.name) ||\n-      !variableDeclaration.name.text.startsWith('_this'))\n-    return false;\n-\n-  const initializer = variableDeclaration.initializer;\n-  if (!initializer) return false;\n-\n-  return isSynthesizedDefaultSuperCall(initializer);\n-}\n-/**\n- * Identifies a synthesized super call of the form:\n- *\n- * ```\n- * return _super !== null && _super.apply(this, arguments) || this;\n- * ```\n- *\n- * @param statement a statement that may be a synthesized super call\n- * @returns true if the statement looks like a synthesized super call\n- */\n-function isSynthesizedSuperReturnStatement(statement: ts.Statement): boolean {\n-  if (!ts.isReturnStatement(statement)) return false;\n-\n-  const expression = statement.expression;\n-  if (!expression) return false;\n-\n-  return isSynthesizedDefaultSuperCall(expression);\n-}\n-\n-/**\n- * Tests whether the expression is of the form:\n- *\n- * ```\n- * _super !== null && _super.apply(this, arguments) || this;\n- * ```\n- *\n- * This structure is generated by TypeScript when transforming ES2015 to ES5, see\n- * https://github.com/Microsoft/TypeScript/blob/v3.2.2/src/compiler/transformers/es2015.ts#L1148-L1163\n- *\n- * @param expression an expression that may represent a default super call\n- * @returns true if the expression corresponds with the above form\n- */\n-function isSynthesizedDefaultSuperCall(expression: ts.Expression): boolean {\n-  if (!isBinaryExpr(expression, ts.SyntaxKind.BarBarToken)) return false;\n-  if (expression.right.kind !== ts.SyntaxKind.ThisKeyword) return false;\n-\n-  const left = expression.left;\n-  if (!isBinaryExpr(left, ts.SyntaxKind.AmpersandAmpersandToken)) return false;\n-\n-  return isSuperNotNull(left.left) && isSuperApplyCall(left.right);\n+function isArgumentsIdentifier(expression: ts.Expression): boolean {\n+  return ts.isIdentifier(expression) && expression.text === 'arguments';\n }\n \n function isSuperNotNull(expression: ts.Expression): boolean {\n   return isBinaryExpr(expression, ts.SyntaxKind.ExclamationEqualsEqualsToken) &&\n       isSuperIdentifier(expression.left);\n }\n \n-/**\n- * Tests whether the expression is of the form\n- *\n- * ```\n- * _super.apply(this, arguments)\n- * ```\n- *\n- * @param expression an expression that may represent a default super call\n- * @returns true if the expression corresponds with the above form\n- */\n-function isSuperApplyCall(expression: ts.Expression): boolean {\n-  if (!ts.isCallExpression(expression) || expression.arguments.length !== 2) return false;\n-\n-  const targetFn = expression.expression;\n-  if (!ts.isPropertyAccessExpression(targetFn)) return false;\n-  if (!isSuperIdentifier(targetFn.expression)) return false;\n-  if (targetFn.name.text !== 'apply') return false;\n-\n-  const thisArgument = expression.arguments[0];\n-  if (thisArgument.kind !== ts.SyntaxKind.ThisKeyword) return false;\n-\n-  const argumentsArgument = expression.arguments[1];\n-  return ts.isIdentifier(argumentsArgument) && argumentsArgument.text === 'arguments';\n-}\n-\n function isBinaryExpr(\n     expression: ts.Expression, operator: ts.BinaryOperator): expression is ts.BinaryExpression {\n   return ts.isBinaryExpression(expression) && expression.operatorToken.kind === operator;"
        },
        {
            "sha": "d2e1fcf02b76dcc2a263853021b9d990b25e5bba",
            "filename": "packages/compiler-cli/ngcc/test/host/commonjs_host_spec.ts",
            "status": "modified",
            "additions": 204,
            "deletions": 0,
            "changes": 204,
            "blob_url": "https://github.com/angular/angular/blob/3b9c802deefcc53ab2b759ac8650449bed75aa9a/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fcommonjs_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/3b9c802deefcc53ab2b759ac8650449bed75aa9a/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fcommonjs_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fcommonjs_host_spec.ts?ref=3b9c802deefcc53ab2b759ac8650449bed75aa9a",
            "patch": "@@ -1456,6 +1456,210 @@ exports.MissingClass2 = MissingClass2;\n             expect(decorators[0].args).toEqual([]);\n           });\n         });\n+\n+        function getConstructorParameters(\n+            constructor: string, mode?: 'inlined'|'inlined_with_suffix'|'imported') {\n+          let fileHeader = '';\n+\n+          switch (mode) {\n+            case 'imported':\n+              fileHeader = `const tslib = require('tslib');`;\n+              break;\n+            case 'inlined':\n+              fileHeader =\n+                  `var __spread = (this && this.__spread) || function (...args) { /* ... */ }`;\n+              break;\n+            case 'inlined_with_suffix':\n+              fileHeader =\n+                  `var __spread$1 = (this && this.__spread$1) || function (...args) { /* ... */ }`;\n+              break;\n+          }\n+          const file = {\n+            name: _('/synthesized_constructors.js'),\n+            contents: `\n+                ${fileHeader}\n+\n+                var TestClass = /** @class */ (function (_super) {\n+                  __extends(TestClass, _super);\n+                  ${constructor}\n+                  return TestClass;\n+                }(null));\n+\n+                exports.TestClass = TestClass;`,\n+          };\n+\n+          loadTestFiles([file]);\n+          const bundle = makeTestBundleProgram(file.name);\n+          const host =\n+              createHost(bundle, new CommonJsReflectionHost(new MockLogger(), false, bundle));\n+          const classNode =\n+              getDeclaration(bundle.program, file.name, 'TestClass', isNamedVariableDeclaration);\n+          return host.getConstructorParameters(classNode);\n+        }\n+\n+        describe('TS -> ES5: synthesized constructors', () => {\n+          it('recognizes _this assignment from super call', () => {\n+            const parameters = getConstructorParameters(`\n+              function TestClass() {\n+                var _this = _super !== null && _super.apply(this, arguments) || this;\n+                _this.synthesizedProperty = null;\n+                return _this;\n+              }\n+            `);\n+\n+            expect(parameters).toBeNull();\n+          });\n+\n+          it('recognizes super call as return statement', () => {\n+            const parameters = getConstructorParameters(`\n+              function TestClass() {\n+                return _super !== null && _super.apply(this, arguments) || this;\n+              }\n+            `);\n+\n+            expect(parameters).toBeNull();\n+          });\n+\n+          it('handles the case where a unique name was generated for _super or _this', () => {\n+            const parameters = getConstructorParameters(`\n+              function TestClass() {\n+                var _this_1 = _super_1 !== null && _super_1.apply(this, arguments) || this;\n+                _this_1._this = null;\n+                _this_1._super = null;\n+                return _this_1;\n+              }\n+            `);\n+\n+            expect(parameters).toBeNull();\n+          });\n+\n+          it('does not consider constructors with parameters as synthesized', () => {\n+            const parameters = getConstructorParameters(`\n+              function TestClass(arg) {\n+                return _super !== null && _super.apply(this, arguments) || this;\n+              }\n+            `);\n+\n+            expect(parameters!.length).toBe(1);\n+          });\n+\n+          it('does not consider manual super calls as synthesized', () => {\n+            const parameters = getConstructorParameters(`\n+              function TestClass() {\n+                return _super.call(this) || this;\n+              }\n+            `);\n+\n+            expect(parameters!.length).toBe(0);\n+          });\n+\n+          it('does not consider empty constructors as synthesized', () => {\n+            const parameters = getConstructorParameters(`function TestClass() {}`);\n+            expect(parameters!.length).toBe(0);\n+          });\n+        });\n+\n+        // See: https://github.com/angular/angular/issues/38453.\n+        describe('ES2015 -> ES5: synthesized constructors through TSC downleveling', () => {\n+          it('recognizes delegate super call using inline spread helper', () => {\n+            const parameters = getConstructorParameters(\n+                `\n+              function TestClass() {\n+                return _super.apply(this, __spread(arguments)) || this;\n+              }`,\n+                'inlined');\n+\n+            expect(parameters).toBeNull();\n+          });\n+\n+          it('recognizes delegate super call using inline spread helper with suffix', () => {\n+            const parameters = getConstructorParameters(\n+                `\n+              function TestClass() {\n+                return _super.apply(this, __spread$1(arguments)) || this;\n+              }`,\n+                'inlined_with_suffix');\n+\n+            expect(parameters).toBeNull();\n+          });\n+\n+          it('recognizes delegate super call using imported spread helper', () => {\n+            const parameters = getConstructorParameters(\n+                `\n+              function TestClass() {\n+                return _super.apply(this, tslib.__spread(arguments)) || this;\n+              }`,\n+                'imported');\n+\n+            expect(parameters).toBeNull();\n+          });\n+\n+          describe('with class member assignment', () => {\n+            it('recognizes delegate super call using inline spread helper', () => {\n+              const parameters = getConstructorParameters(\n+                  `\n+                function TestClass() {\n+                  var _this = _super.apply(this, __spread(arguments)) || this;\n+                  _this.synthesizedProperty = null;\n+                  return _this;\n+                }`,\n+                  'inlined');\n+\n+              expect(parameters).toBeNull();\n+            });\n+\n+            it('recognizes delegate super call using inline spread helper with suffix', () => {\n+              const parameters = getConstructorParameters(\n+                  `\n+                function TestClass() {\n+                  var _this = _super.apply(this, __spread$1(arguments)) || this;\n+                  _this.synthesizedProperty = null;\n+                  return _this;\n+                }`,\n+                  'inlined_with_suffix');\n+\n+              expect(parameters).toBeNull();\n+            });\n+\n+            it('recognizes delegate super call using imported spread helper', () => {\n+              const parameters = getConstructorParameters(\n+                  `\n+                function TestClass() {\n+                  var _this = _super.apply(this, tslib.__spread(arguments)) || this;\n+                  _this.synthesizedProperty = null;\n+                  return _this;\n+                }`,\n+                  'imported');\n+\n+              expect(parameters).toBeNull();\n+            });\n+          });\n+\n+          it('handles the case where a unique name was generated for _super or _this', () => {\n+            const parameters = getConstructorParameters(\n+                `\n+              function TestClass() {\n+                var _this_1 = _super_1.apply(this, __spread(arguments)) || this;\n+                _this_1._this = null;\n+                _this_1._super = null;\n+                return _this_1;\n+              }`,\n+                'inlined');\n+\n+            expect(parameters).toBeNull();\n+          });\n+\n+          it('does not consider constructors with parameters as synthesized', () => {\n+            const parameters = getConstructorParameters(\n+                `\n+              function TestClass(arg) {\n+                return _super.apply(this, __spread(arguments)) || this;\n+              }`,\n+                'inlined');\n+\n+            expect(parameters!.length).toBe(1);\n+          });\n+        });\n       });\n \n       describe('getDefinitionOfFunction()', () => {"
        },
        {
            "sha": "0fb7428196efa8e0eddbe599abf37f54ab5c3825",
            "filename": "packages/compiler-cli/ngcc/test/host/esm5_host_spec.ts",
            "status": "modified",
            "additions": 187,
            "deletions": 37,
            "changes": 224,
            "blob_url": "https://github.com/angular/angular/blob/3b9c802deefcc53ab2b759ac8650449bed75aa9a/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fesm5_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/3b9c802deefcc53ab2b759ac8650449bed75aa9a/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fesm5_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fesm5_host_spec.ts?ref=3b9c802deefcc53ab2b759ac8650449bed75aa9a",
            "patch": "@@ -1417,86 +1417,236 @@ runInEachFileSystem(() => {\n         });\n       });\n \n-      describe('synthesized constructors', () => {\n-        function getConstructorParameters(constructor: string) {\n-          const file = {\n-            name: _('/synthesized_constructors.js'),\n-            contents: `\n+      function getConstructorParameters(\n+          constructor: string,\n+          mode?: 'inlined'|'inlined_with_suffix'|'imported'|'imported_namespace') {\n+        let fileHeader = '';\n+\n+        switch (mode) {\n+          case 'imported':\n+            fileHeader = `import {__spread} from 'tslib';`;\n+            break;\n+          case 'imported_namespace':\n+            fileHeader = `import * as tslib from 'tslib';`;\n+            break;\n+          case 'inlined':\n+            fileHeader =\n+                `var __spread = (this && this.__spread) || function (...args) { /* ... */ }`;\n+            break;\n+          case 'inlined_with_suffix':\n+            fileHeader =\n+                `var __spread$1 = (this && this.__spread$1) || function (...args) { /* ... */ }`;\n+            break;\n+        }\n+\n+        const file = {\n+          name: _('/synthesized_constructors.js'),\n+          contents: `\n+            ${fileHeader}\n             var TestClass = /** @class */ (function (_super) {\n               __extends(TestClass, _super);\n               ${constructor}\n               return TestClass;\n             }(null));\n           `,\n-          };\n+        };\n \n-          loadTestFiles([file]);\n-          const bundle = makeTestBundleProgram(file.name);\n-          const host = createHost(bundle, new Esm5ReflectionHost(new MockLogger(), false, bundle));\n-          const classNode =\n-              getDeclaration(bundle.program, file.name, 'TestClass', isNamedVariableDeclaration);\n-          return host.getConstructorParameters(classNode);\n-        }\n+        loadTestFiles([file]);\n+        const bundle = makeTestBundleProgram(file.name);\n+        const host = createHost(bundle, new Esm5ReflectionHost(new MockLogger(), false, bundle));\n+        const classNode =\n+            getDeclaration(bundle.program, file.name, 'TestClass', isNamedVariableDeclaration);\n+        return host.getConstructorParameters(classNode);\n+      }\n \n+      describe('TS -> ES5: synthesized constructors', () => {\n         it('recognizes _this assignment from super call', () => {\n           const parameters = getConstructorParameters(`\n-          function TestClass() {\n-            var _this = _super !== null && _super.apply(this, arguments) || this;\n-            _this.synthesizedProperty = null;\n-            return _this;\n-          }`);\n+            function TestClass() {\n+              var _this = _super !== null && _super.apply(this, arguments) || this;\n+              _this.synthesizedProperty = null;\n+              return _this;\n+            }\n+          `);\n \n           expect(parameters).toBeNull();\n         });\n \n         it('recognizes super call as return statement', () => {\n           const parameters = getConstructorParameters(`\n-          function TestClass() {\n-            return _super !== null && _super.apply(this, arguments) || this;\n-          }`);\n+            function TestClass() {\n+              return _super !== null && _super.apply(this, arguments) || this;\n+            }\n+          `);\n \n           expect(parameters).toBeNull();\n         });\n \n         it('handles the case where a unique name was generated for _super or _this', () => {\n           const parameters = getConstructorParameters(`\n-          function TestClass() {\n-            var _this_1 = _super_1 !== null && _super_1.apply(this, arguments) || this;\n-            _this_1._this = null;\n-            _this_1._super = null;\n-            return _this_1;\n-          }`);\n+            function TestClass() {\n+              var _this_1 = _super_1 !== null && _super_1.apply(this, arguments) || this;\n+              _this_1._this = null;\n+              _this_1._super = null;\n+              return _this_1;\n+            }\n+          `);\n \n           expect(parameters).toBeNull();\n         });\n \n         it('does not consider constructors with parameters as synthesized', () => {\n           const parameters = getConstructorParameters(`\n-          function TestClass(arg) {\n-            return _super !== null && _super.apply(this, arguments) || this;\n-          }`);\n+            function TestClass(arg) {\n+              return _super !== null && _super.apply(this, arguments) || this;\n+            }\n+          `);\n \n           expect(parameters!.length).toBe(1);\n         });\n \n         it('does not consider manual super calls as synthesized', () => {\n           const parameters = getConstructorParameters(`\n-          function TestClass() {\n-            return _super.call(this) || this;\n-          }`);\n+            function TestClass() {\n+              return _super.call(this) || this;\n+            }\n+          `);\n \n           expect(parameters!.length).toBe(0);\n         });\n \n         it('does not consider empty constructors as synthesized', () => {\n-          const parameters = getConstructorParameters(`\n-          function TestClass() {\n-          }`);\n-\n+          const parameters = getConstructorParameters(`function TestClass() {}`);\n           expect(parameters!.length).toBe(0);\n         });\n       });\n \n+      // See: https://github.com/angular/angular/issues/38453.\n+      describe('ES2015 -> ES5: synthesized constructors through TSC downleveling', () => {\n+        it('recognizes delegate super call using inline spread helper', () => {\n+          const parameters = getConstructorParameters(\n+              `\n+            function TestClass() {\n+              return _super.apply(this, __spread(arguments)) || this;\n+            }`,\n+              'inlined');\n+\n+          expect(parameters).toBeNull();\n+        });\n+\n+        it('recognizes delegate super call using inline spread helper with suffix', () => {\n+          const parameters = getConstructorParameters(\n+              `\n+            function TestClass() {\n+              return _super.apply(this, __spread$1(arguments)) || this;\n+            }`,\n+              'inlined_with_suffix');\n+\n+          expect(parameters).toBeNull();\n+        });\n+\n+        it('recognizes delegate super call using imported spread helper', () => {\n+          const parameters = getConstructorParameters(\n+              `\n+            function TestClass() {\n+              return _super.apply(this, __spread(arguments)) || this;\n+            }`,\n+              'imported');\n+\n+          expect(parameters).toBeNull();\n+        });\n+\n+        it('recognizes delegate super call using namespace imported spread helper', () => {\n+          const parameters = getConstructorParameters(\n+              `\n+            function TestClass() {\n+              return _super.apply(this, tslib.__spread(arguments)) || this;\n+            }`,\n+              'imported_namespace');\n+\n+          expect(parameters).toBeNull();\n+        });\n+\n+        describe('with class member assignment', () => {\n+          it('recognizes delegate super call using inline spread helper', () => {\n+            const parameters = getConstructorParameters(\n+                `\n+              function TestClass() {\n+                var _this = _super.apply(this, __spread(arguments)) || this;\n+                _this.synthesizedProperty = null;\n+                return _this;\n+              }`,\n+                'inlined');\n+\n+            expect(parameters).toBeNull();\n+          });\n+\n+          it('recognizes delegate super call using inline spread helper with suffix', () => {\n+            const parameters = getConstructorParameters(\n+                `\n+              function TestClass() {\n+                var _this = _super.apply(this, __spread$1(arguments)) || this;\n+                _this.synthesizedProperty = null;\n+                return _this;\n+              }`,\n+                'inlined_with_suffix');\n+\n+            expect(parameters).toBeNull();\n+          });\n+\n+          it('recognizes delegate super call using imported spread helper', () => {\n+            const parameters = getConstructorParameters(\n+                `\n+              function TestClass() {\n+                var _this = _super.apply(this, __spread(arguments)) || this;\n+                _this.synthesizedProperty = null;\n+                return _this;\n+              }`,\n+                'imported');\n+\n+            expect(parameters).toBeNull();\n+          });\n+\n+          it('recognizes delegate super call using namespace imported spread helper', () => {\n+            const parameters = getConstructorParameters(\n+                `\n+              function TestClass() {\n+                var _this = _super.apply(this, tslib.__spread(arguments)) || this;\n+                _this.synthesizedProperty = null;\n+                return _this;\n+              }`,\n+                'imported_namespace');\n+\n+            expect(parameters).toBeNull();\n+          });\n+        });\n+\n+        it('handles the case where a unique name was generated for _super or _this', () => {\n+          const parameters = getConstructorParameters(\n+              `\n+            function TestClass() {\n+              var _this_1 = _super_1.apply(this, __spread(arguments)) || this;\n+              _this_1._this = null;\n+              _this_1._super = null;\n+              return _this_1;\n+            }`,\n+              'inlined');\n+\n+          expect(parameters).toBeNull();\n+        });\n+\n+        it('does not consider constructors with parameters as synthesized', () => {\n+          const parameters = getConstructorParameters(\n+              `\n+            function TestClass(arg) {\n+              return _super.apply(this, __spread(arguments)) || this;\n+            }`,\n+              'inlined');\n+\n+          expect(parameters!.length).toBe(1);\n+        });\n+      });\n+\n       describe('(returned parameters `decorators.args`)', () => {\n         it('should be an empty array if param decorator has no `args` property', () => {\n           loadTestFiles([INVALID_CTOR_DECORATOR_ARGS_FILE]);"
        },
        {
            "sha": "a25b09fb5a3bc9a5fc4ab2447b6ea21afa9ad92f",
            "filename": "packages/compiler-cli/ngcc/test/host/umd_host_spec.ts",
            "status": "modified",
            "additions": 225,
            "deletions": 0,
            "changes": 225,
            "blob_url": "https://github.com/angular/angular/blob/3b9c802deefcc53ab2b759ac8650449bed75aa9a/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fumd_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/3b9c802deefcc53ab2b759ac8650449bed75aa9a/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fumd_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fumd_host_spec.ts?ref=3b9c802deefcc53ab2b759ac8650449bed75aa9a",
            "patch": "@@ -1564,6 +1564,231 @@ runInEachFileSystem(() => {\n           expect(decorators[0].args).toEqual([]);\n         });\n       });\n+\n+      function getConstructorParameters(\n+          constructor: string, mode: 'inlined'|'inlined_with_suffix'|'imported' = 'imported') {\n+        let fileHeaderWithUmd = '';\n+\n+        switch (mode) {\n+          case 'imported':\n+            fileHeaderWithUmd = `\n+              (function (global, factory) {\n+                typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'))) :\n+                typeof define === 'function' && define.amd ? define('test', ['exports', 'tslib'], factory) :\n+                    (factory(global.test, global.tslib));\n+                }(this, (function (exports, tslib) { 'use strict';\n+            `;\n+            break;\n+          case 'inlined':\n+            fileHeaderWithUmd = `\n+              (function (global, factory) {\n+                typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports)) :\n+                typeof define === 'function' && define.amd ? define('test', ['exports'], factory) :\n+                    (factory(global.test));\n+                }(this, (function (exports) { 'use strict';\n+\n+                  var __spread = (this && this.__spread) || function (...args) { /* ... */ }\n+            `;\n+            break;\n+          case 'inlined_with_suffix':\n+            fileHeaderWithUmd = `            \n+              (function (global, factory) {\n+                typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports)) :\n+                typeof define === 'function' && define.amd ? define('test', ['exports'], factory) :\n+                    (factory(global.test));\n+                }(this, (function (exports) { 'use strict';\n+\n+                  var __spread$1 = (this && this.__spread$1) || function (...args) { /* ... */ }\n+              `;\n+            break;\n+        }\n+\n+        const file = {\n+          name: _('/synthesized_constructors.js'),\n+          contents: `\n+            ${fileHeaderWithUmd}\n+                var TestClass = /** @class */ (function (_super) {\n+                  __extends(TestClass, _super);\n+                  ${constructor}\n+                  return TestClass;\n+                }(null));\n+\n+                exports.TestClass = TestClass;\n+              })));\n+          `,\n+        };\n+\n+        loadTestFiles([file]);\n+        const bundle = makeTestBundleProgram(file.name);\n+        const host = createHost(bundle, new UmdReflectionHost(new MockLogger(), false, bundle));\n+        const classNode =\n+            getDeclaration(bundle.program, file.name, 'TestClass', isNamedVariableDeclaration);\n+        return host.getConstructorParameters(classNode);\n+      }\n+\n+      describe('TS -> ES5: synthesized constructors', () => {\n+        it('recognizes _this assignment from super call', () => {\n+          const parameters = getConstructorParameters(`\n+            function TestClass() {\n+              var _this = _super !== null && _super.apply(this, arguments) || this;\n+              _this.synthesizedProperty = null;\n+              return _this;\n+            }\n+          `);\n+\n+          expect(parameters).toBeNull();\n+        });\n+\n+        it('recognizes super call as return statement', () => {\n+          const parameters = getConstructorParameters(`\n+            function TestClass() {\n+              return _super !== null && _super.apply(this, arguments) || this;\n+            }\n+          `);\n+\n+          expect(parameters).toBeNull();\n+        });\n+\n+        it('handles the case where a unique name was generated for _super or _this', () => {\n+          const parameters = getConstructorParameters(`\n+            function TestClass() {\n+              var _this_1 = _super_1 !== null && _super_1.apply(this, arguments) || this;\n+              _this_1._this = null;\n+              _this_1._super = null;\n+              return _this_1;\n+            }\n+          `);\n+\n+          expect(parameters).toBeNull();\n+        });\n+\n+        it('does not consider constructors with parameters as synthesized', () => {\n+          const parameters = getConstructorParameters(`\n+            function TestClass(arg) {\n+              return _super !== null && _super.apply(this, arguments) || this;\n+            }\n+          `);\n+\n+          expect(parameters!.length).toBe(1);\n+        });\n+\n+        it('does not consider manual super calls as synthesized', () => {\n+          const parameters = getConstructorParameters(`\n+            function TestClass() {\n+              return _super.call(this) || this;\n+            }\n+          `);\n+\n+          expect(parameters!.length).toBe(0);\n+        });\n+\n+        it('does not consider empty constructors as synthesized', () => {\n+          const parameters = getConstructorParameters(`function TestClass() {}`);\n+          expect(parameters!.length).toBe(0);\n+        });\n+      });\n+\n+      // See: https://github.com/angular/angular/issues/38453.\n+      describe('ES2015 -> ES5: synthesized constructors through TSC downleveling', () => {\n+        it('recognizes delegate super call using inline spread helper', () => {\n+          const parameters = getConstructorParameters(\n+              `\n+            function TestClass() {\n+              return _super.apply(this, __spread(arguments)) || this;\n+            }`,\n+              'inlined');\n+\n+          expect(parameters).toBeNull();\n+        });\n+\n+        it('recognizes delegate super call using inline spread helper with suffix', () => {\n+          const parameters = getConstructorParameters(\n+              `\n+            function TestClass() {\n+              return _super.apply(this, __spread$1(arguments)) || this;\n+            }`,\n+              'inlined_with_suffix');\n+\n+          expect(parameters).toBeNull();\n+        });\n+\n+        it('recognizes delegate super call using imported spread helper', () => {\n+          const parameters = getConstructorParameters(\n+              `\n+            function TestClass() {\n+              return _super.apply(this, tslib_1.__spread(arguments)) || this;\n+            }`,\n+              'imported');\n+\n+          expect(parameters).toBeNull();\n+        });\n+\n+        describe('with class member assignment', () => {\n+          it('recognizes delegate super call using inline spread helper', () => {\n+            const parameters = getConstructorParameters(\n+                `\n+              function TestClass() {\n+                var _this = _super.apply(this, __spread(arguments)) || this;\n+                _this.synthesizedProperty = null;\n+                return _this;\n+              }`,\n+                'inlined');\n+\n+            expect(parameters).toBeNull();\n+          });\n+\n+          it('recognizes delegate super call using inline spread helper with suffix', () => {\n+            const parameters = getConstructorParameters(\n+                `\n+              function TestClass() {\n+                var _this = _super.apply(this, __spread$1(arguments)) || this;\n+                _this.synthesizedProperty = null;\n+                return _this;\n+              }`,\n+                'inlined_with_suffix');\n+\n+            expect(parameters).toBeNull();\n+          });\n+\n+          it('recognizes delegate super call using imported spread helper', () => {\n+            const parameters = getConstructorParameters(\n+                `\n+              function TestClass() {\n+                var _this = _super.apply(this, tslib_1.__spread(arguments)) || this;\n+                _this.synthesizedProperty = null;\n+                return _this;\n+              }`,\n+                'imported');\n+\n+            expect(parameters).toBeNull();\n+          });\n+        });\n+\n+        it('handles the case where a unique name was generated for _super or _this', () => {\n+          const parameters = getConstructorParameters(\n+              `\n+            function TestClass() {\n+              var _this_1 = _super_1.apply(this, __spread(arguments)) || this;\n+              _this_1._this = null;\n+              _this_1._super = null;\n+              return _this_1;\n+            }`,\n+              'inlined');\n+\n+          expect(parameters).toBeNull();\n+        });\n+\n+        it('does not consider constructors with parameters as synthesized', () => {\n+          const parameters = getConstructorParameters(\n+              `\n+            function TestClass(arg) {\n+              return _super.apply(this, __spread(arguments)) || this;\n+            }`,\n+              'inlined');\n+\n+          expect(parameters!.length).toBe(1);\n+        });\n+      });\n     });\n \n     describe('getDefinitionOfFunction()', () => {"
        },
        {
            "sha": "75575ebb135f7f5e9760961bd3cf5994976e7120",
            "filename": "packages/core/src/reflection/reflection_capabilities.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/3b9c802deefcc53ab2b759ac8650449bed75aa9a/packages%2Fcore%2Fsrc%2Freflection%2Freflection_capabilities.ts",
            "raw_url": "https://github.com/angular/angular/raw/3b9c802deefcc53ab2b759ac8650449bed75aa9a/packages%2Fcore%2Fsrc%2Freflection%2Freflection_capabilities.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Freflection%2Freflection_capabilities.ts?ref=3b9c802deefcc53ab2b759ac8650449bed75aa9a",
            "patch": "@@ -29,7 +29,7 @@ import {GetterFn, MethodFn, SetterFn} from './types';\n  * it intends to capture the pattern where existing constructors have been downleveled from\n  * ES2015 to ES5 using TypeScript w/ downlevel iteration. e.g.\n  *\n- *  * ```\n+ * ```\n  *   function MyClass() {\n  *     var _this = _super.apply(this, arguments) || this;\n  * ```"
        }
    ],
    "stats": {
        "total": 996,
        "additions": 834,
        "deletions": 162
    }
}