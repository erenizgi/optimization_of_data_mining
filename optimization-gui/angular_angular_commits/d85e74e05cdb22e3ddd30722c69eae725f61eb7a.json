{
    "author": "alxhub",
    "message": "refactor(language-service): specifically identify empty argument positions (#41581)\n\nThis commit changes `getTemplateAtTarget` to be able to identify when a\ncursor position is specifically within the argument span of a `MethodCall`\nor `SafeMethodCall` with no arguments. If the call had arguments, one of the\nargument expressions would be returned instead, but in a call with no\narguments the tightest node _is_ the `MethodCall`. Adding the additional\nargument context will allow for functionality that relies on tracking\nargument positions, like `getSignatureHelpItems`.\n\nPR Close #41581",
    "sha": "d85e74e05cdb22e3ddd30722c69eae725f61eb7a",
    "files": [
        {
            "sha": "f4d760c63954e67944107f5198eb8cd2a6e0924f",
            "filename": "packages/language-service/ivy/template_target.ts",
            "status": "modified",
            "additions": 30,
            "deletions": 3,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/d85e74e05cdb22e3ddd30722c69eae725f61eb7a/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "raw_url": "https://github.com/angular/angular/raw/d85e74e05cdb22e3ddd30722c69eae725f61eb7a/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts?ref=d85e74e05cdb22e3ddd30722c69eae725f61eb7a",
            "patch": "@@ -49,8 +49,8 @@ export interface TemplateTarget {\n export type TargetContext = SingleNodeTarget|MultiNodeTarget;\n \n /** Contexts which logically target only a single node in the template AST. */\n-export type SingleNodeTarget = RawExpression|RawTemplateNode|ElementInBodyContext|\n-    ElementInTagContext|AttributeInKeyContext|AttributeInValueContext;\n+export type SingleNodeTarget = RawExpression|MethodCallExpressionInArgContext|RawTemplateNode|\n+    ElementInBodyContext|ElementInTagContext|AttributeInKeyContext|AttributeInValueContext;\n \n /**\n  * Contexts which logically target multiple nodes in the template AST, which cannot be\n@@ -65,6 +65,7 @@ export type MultiNodeTarget = TwoWayBindingContext;\n  */\n export enum TargetNodeKind {\n   RawExpression,\n+  MethodCallExpressionInArgContext,\n   RawTemplateNode,\n   ElementInTagContext,\n   ElementInBodyContext,\n@@ -79,6 +80,21 @@ export enum TargetNodeKind {\n export interface RawExpression {\n   kind: TargetNodeKind.RawExpression;\n   node: e.AST;\n+  parents: e.AST[];\n+}\n+\n+/**\n+ * An `e.MethodCall` or `e.SafeMethodCall` expression with the cursor in a position where an\n+ * argument could appear.\n+ *\n+ * This is returned when the only matching node is the method call expression, but the cursor is\n+ * within the method call parentheses. For example, in the expression `foo(|)` there is no argument\n+ * expression that the cursor could be targeting, but the cursor is in a position where one could\n+ * appear.\n+ */\n+export interface MethodCallExpressionInArgContext {\n+  kind: TargetNodeKind.MethodCallExpressionInArgContext;\n+  node: e.MethodCall|e.SafeMethodCall;\n }\n \n /**\n@@ -158,10 +174,21 @@ export function getTargetAtPosition(template: t.Node[], position: number): Templ\n \n   // Given the candidate node, determine the full targeted context.\n   let nodeInContext: TargetContext;\n-  if (candidate instanceof e.AST) {\n+  if ((candidate instanceof e.MethodCall || candidate instanceof e.SafeMethodCall) &&\n+      isWithin(position, candidate.argumentSpan)) {\n+    nodeInContext = {\n+      kind: TargetNodeKind.MethodCallExpressionInArgContext,\n+      node: candidate,\n+    };\n+  } else if (candidate instanceof e.AST) {\n+    const parents = path.filter((value: e.AST|t.Node): value is e.AST => value instanceof e.AST);\n+    // Remove the current node from the parents list.\n+    parents.pop();\n+\n     nodeInContext = {\n       kind: TargetNodeKind.RawExpression,\n       node: candidate,\n+      parents,\n     };\n   } else if (candidate instanceof t.Element) {\n     // Elements have two contexts: the tag context (position is within the element tag) or the"
        },
        {
            "sha": "3099c851a31cdeab4c02a1aa24652ef1f94c676e",
            "filename": "packages/language-service/ivy/test/legacy/template_target_spec.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/d85e74e05cdb22e3ddd30722c69eae725f61eb7a/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/d85e74e05cdb22e3ddd30722c69eae725f61eb7a/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts?ref=d85e74e05cdb22e3ddd30722c69eae725f61eb7a",
            "patch": "@@ -549,6 +549,15 @@ describe('getTargetAtPosition for expression AST', () => {\n     expect(node).toBeInstanceOf(e.SafeMethodCall);\n   });\n \n+  it('should identify when in the argument position in a no-arg method call', () => {\n+    const {errors, nodes, position} = parse(`{{ title.toString(¦) }}`);\n+    expect(errors).toBe(null);\n+    const {context} = getTargetAtPosition(nodes, position)!;\n+    expect(context.kind).toEqual(TargetNodeKind.MethodCallExpressionInArgContext);\n+    const {node} = context as SingleNodeTarget;\n+    expect(node).toBeInstanceOf(e.MethodCall);\n+  });\n+\n   it('should locate literal primitive in interpolation', () => {\n     const {errors, nodes, position} = parse(`{{ title.indexOf('t¦') }}`);\n     expect(errors).toBe(null);"
        }
    ],
    "stats": {
        "total": 42,
        "additions": 39,
        "deletions": 3
    }
}