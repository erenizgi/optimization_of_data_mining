{
    "author": "JoostK",
    "message": "refactor(compiler-cli): carry type information into AST value types (#39961)\n\nThis change allows the `AstObject` and `AstValue` types to provide\ntheir represented type as a generic type argument, which is helpful\nfor documentation and discoverability purposes.\n\nPR Close #39961",
    "sha": "c0bccc39dbd4a07f96fdb235af3597f86b3327c3",
    "files": [
        {
            "sha": "51f8e4bdef23f5ef0a6aea9003bca94afdf57bee",
            "filename": "packages/compiler-cli/linker/src/ast/ast_value.ts",
            "status": "modified",
            "additions": 77,
            "deletions": 26,
            "changes": 103,
            "blob_url": "https://github.com/angular/angular/blob/c0bccc39dbd4a07f96fdb235af3597f86b3327c3/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Fast_value.ts",
            "raw_url": "https://github.com/angular/angular/raw/c0bccc39dbd4a07f96fdb235af3597f86b3327c3/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Fast_value.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Fast%2Fast_value.ts?ref=c0bccc39dbd4a07f96fdb235af3597f86b3327c3",
            "patch": "@@ -9,18 +9,60 @@ import * as o from '@angular/compiler';\n import {FatalLinkerError} from '../fatal_linker_error';\n import {AstHost, Range} from './ast_host';\n \n+/**\n+ * Represents only those types in `T` that are object types.\n+ */\n+type ObjectType<T> = Extract<T, object>;\n+\n+/**\n+ * Represents the value type of an object literal.\n+ */\n+type ObjectValueType<T> = T extends Record<string, infer R>? R : never;\n+\n+/**\n+ * Represents the value type of an array literal.\n+ */\n+type ArrayValueType<T> = T extends Array<infer R>? R : never;\n+\n+/**\n+ * Ensures that `This` has its generic type `Actual` conform to the expected generic type in\n+ * `Expected`, to disallow calling a method if the generic type does not conform.\n+ */\n+type ConformsTo<This, Actual, Expected> = Actual extends Expected ? This : never;\n+\n+/**\n+ * Ensures that `This` is an `AstValue` whose generic type conforms to `Expected`, to disallow\n+ * calling a method if the value's type does not conform.\n+ */\n+type HasValueType<This, Expected> =\n+    This extends AstValue<infer Actual, any>? ConformsTo<This, Actual, Expected>: never;\n+\n+/**\n+ * Represents only the string keys of type `T`.\n+ */\n+type PropertyKey<T> = keyof T&string;\n+\n /**\n  * This helper class wraps an object expression along with an `AstHost` object, exposing helper\n  * methods that make it easier to extract the properties of the object.\n+ *\n+ * The generic `T` is used as reference type of the expected structure that is represented by this\n+ * object. It does not achieve full type-safety for the provided operations in correspondence with\n+ * `T`; its main goal is to provide references to a documented type and ensure that the properties\n+ * that are read from the object are present.\n+ *\n+ * Unfortunately, the generic types are unable to prevent reading an optional property from the\n+ * object without first having called `has` to ensure that the property exists. This is one example\n+ * of where full type-safety is not achieved.\n  */\n-export class AstObject<TExpression> {\n+export class AstObject<T extends object, TExpression> {\n   /**\n    * Create a new `AstObject` from the given `expression` and `host`.\n    */\n-  static parse<TExpression>(expression: TExpression, host: AstHost<TExpression>):\n-      AstObject<TExpression> {\n+  static parse<T extends object, TExpression>(expression: TExpression, host: AstHost<TExpression>):\n+      AstObject<T, TExpression> {\n     const obj = host.parseObjectLiteral(expression);\n-    return new AstObject<TExpression>(expression, obj, host);\n+    return new AstObject(expression, obj, host);\n   }\n \n   private constructor(\n@@ -30,7 +72,7 @@ export class AstObject<TExpression> {\n   /**\n    * Returns true if the object has a property called `propertyName`.\n    */\n-  has(propertyName: string): boolean {\n+  has(propertyName: PropertyKey<T>): boolean {\n     return this.obj.has(propertyName);\n   }\n \n@@ -39,7 +81,8 @@ export class AstObject<TExpression> {\n    *\n    * Throws an error if there is no such property or the property is not a number.\n    */\n-  getNumber(propertyName: string): number {\n+  getNumber<K extends PropertyKey<T>>(this: ConformsTo<this, T[K], number>, propertyName: K):\n+      number {\n     return this.host.parseNumericLiteral(this.getRequiredProperty(propertyName));\n   }\n \n@@ -48,7 +91,8 @@ export class AstObject<TExpression> {\n    *\n    * Throws an error if there is no such property or the property is not a string.\n    */\n-  getString(propertyName: string): string {\n+  getString<K extends PropertyKey<T>>(this: ConformsTo<this, T[K], string>, propertyName: K):\n+      string {\n     return this.host.parseStringLiteral(this.getRequiredProperty(propertyName));\n   }\n \n@@ -57,16 +101,18 @@ export class AstObject<TExpression> {\n    *\n    * Throws an error if there is no such property or the property is not a boolean.\n    */\n-  getBoolean(propertyName: string): boolean {\n-    return this.host.parseBooleanLiteral(this.getRequiredProperty(propertyName));\n+  getBoolean<K extends PropertyKey<T>>(this: ConformsTo<this, T[K], boolean>, propertyName: K):\n+      boolean {\n+    return this.host.parseBooleanLiteral(this.getRequiredProperty(propertyName)) as any;\n   }\n \n   /**\n    * Returns the nested `AstObject` parsed from the property called `propertyName`.\n    *\n    * Throws an error if there is no such property or the property is not an object.\n    */\n-  getObject(propertyName: string): AstObject<TExpression> {\n+  getObject<K extends PropertyKey<T>>(this: ConformsTo<this, T[K], object>, propertyName: K):\n+      AstObject<ObjectType<T[K]>, TExpression> {\n     const expr = this.getRequiredProperty(propertyName);\n     const obj = this.host.parseObjectLiteral(expr);\n     return new AstObject(expr, obj, this.host);\n@@ -77,7 +123,8 @@ export class AstObject<TExpression> {\n    *\n    * Throws an error if there is no such property or the property is not an array.\n    */\n-  getArray(propertyName: string): AstValue<TExpression>[] {\n+  getArray<K extends PropertyKey<T>>(this: ConformsTo<this, T[K], unknown[]>, propertyName: K):\n+      AstValue<ArrayValueType<T[K]>, TExpression>[] {\n     const arr = this.host.parseArrayLiteral(this.getRequiredProperty(propertyName));\n     return arr.map(entry => new AstValue(entry, this.host));\n   }\n@@ -88,7 +135,7 @@ export class AstObject<TExpression> {\n    *\n    * Throws an error if there is no such property.\n    */\n-  getOpaque(propertyName: string): o.WrappedNodeExpr<TExpression> {\n+  getOpaque(propertyName: PropertyKey<T>): o.WrappedNodeExpr<TExpression> {\n     return new o.WrappedNodeExpr(this.getRequiredProperty(propertyName));\n   }\n \n@@ -97,7 +144,7 @@ export class AstObject<TExpression> {\n    *\n    * Throws an error if there is no such property.\n    */\n-  getNode(propertyName: string): TExpression {\n+  getNode(propertyName: PropertyKey<T>): TExpression {\n     return this.getRequiredProperty(propertyName);\n   }\n \n@@ -106,16 +153,16 @@ export class AstObject<TExpression> {\n    *\n    * Throws an error if there is no such property.\n    */\n-  getValue(propertyName: string): AstValue<TExpression> {\n+  getValue<K extends PropertyKey<T>>(propertyName: K): AstValue<T[K], TExpression> {\n     return new AstValue(this.getRequiredProperty(propertyName), this.host);\n   }\n \n   /**\n    * Converts the AstObject to a raw JavaScript object, mapping each property value (as an\n    * `AstValue`) to the generic type (`T`) via the `mapper` function.\n    */\n-  toLiteral<T>(mapper: (value: AstValue<TExpression>) => T): {[key: string]: T} {\n-    const result: {[key: string]: T} = {};\n+  toLiteral<V>(mapper: (value: AstValue<ObjectValueType<T>, TExpression>) => V): Record<string, V> {\n+    const result: Record<string, V> = {};\n     for (const [key, expression] of this.obj) {\n       result[key] = mapper(new AstValue(expression, this.host));\n     }\n@@ -126,15 +173,15 @@ export class AstObject<TExpression> {\n    * Converts the AstObject to a JavaScript Map, mapping each property value (as an\n    * `AstValue`) to the generic type (`T`) via the `mapper` function.\n    */\n-  toMap<T>(mapper: (value: AstValue<TExpression>) => T): Map<string, T> {\n-    const result = new Map<string, T>();\n+  toMap<V>(mapper: (value: AstValue<ObjectValueType<T>, TExpression>) => V): Map<string, V> {\n+    const result = new Map<string, V>();\n     for (const [key, expression] of this.obj) {\n       result.set(key, mapper(new AstValue(expression, this.host)));\n     }\n     return result;\n   }\n \n-  private getRequiredProperty(propertyName: string): TExpression {\n+  private getRequiredProperty(propertyName: PropertyKey<T>): TExpression {\n     if (!this.obj.has(propertyName)) {\n       throw new FatalLinkerError(\n           this.expression, `Expected property '${propertyName}' to be present.`);\n@@ -146,8 +193,12 @@ export class AstObject<TExpression> {\n /**\n  * This helper class wraps an `expression`, exposing methods that use the `host` to give\n  * access to the underlying value of the wrapped expression.\n+ *\n+ * The generic `T` is used as reference type of the expected type that is represented by this value.\n+ * It does not achieve full type-safety for the provided operations in correspondence with `T`; its\n+ * main goal is to provide references to a documented type.\n  */\n-export class AstValue<TExpression> {\n+export class AstValue<T, TExpression> {\n   constructor(readonly expression: TExpression, private host: AstHost<TExpression>) {}\n \n   /**\n@@ -168,7 +219,7 @@ export class AstValue<TExpression> {\n   /**\n    * Parse the number from this value, or error if it is not a number.\n    */\n-  getNumber(): number {\n+  getNumber(this: HasValueType<this, number>): number {\n     return this.host.parseNumericLiteral(this.expression);\n   }\n \n@@ -182,7 +233,7 @@ export class AstValue<TExpression> {\n   /**\n    * Parse the string from this value, or error if it is not a string.\n    */\n-  getString(): string {\n+  getString(this: HasValueType<this, string>): string {\n     return this.host.parseStringLiteral(this.expression);\n   }\n \n@@ -196,7 +247,7 @@ export class AstValue<TExpression> {\n   /**\n    * Parse the boolean from this value, or error if it is not a boolean.\n    */\n-  getBoolean(): boolean {\n+  getBoolean(this: HasValueType<this, boolean>): boolean {\n     return this.host.parseBooleanLiteral(this.expression);\n   }\n \n@@ -210,7 +261,7 @@ export class AstValue<TExpression> {\n   /**\n    * Parse this value into an `AstObject`, or error if it is not an object literal.\n    */\n-  getObject(): AstObject<TExpression> {\n+  getObject(this: HasValueType<this, object>): AstObject<ObjectType<T>, TExpression> {\n     return AstObject.parse(this.expression, this.host);\n   }\n \n@@ -224,7 +275,7 @@ export class AstValue<TExpression> {\n   /**\n    * Parse this value into an array of `AstValue` objects, or error if it is not an array literal.\n    */\n-  getArray(): AstValue<TExpression>[] {\n+  getArray(this: HasValueType<this, unknown[]>): AstValue<ArrayValueType<T>, TExpression>[] {\n     const arr = this.host.parseArrayLiteral(this.expression);\n     return arr.map(entry => new AstValue(entry, this.host));\n   }\n@@ -240,7 +291,7 @@ export class AstValue<TExpression> {\n    * Extract the return value as an `AstValue` from this value as a function expression, or error if\n    * it is not a function expression.\n    */\n-  getFunctionReturnValue(): AstValue<TExpression> {\n+  getFunctionReturnValue<R>(this: HasValueType<this, Function>): AstValue<R, TExpression> {\n     return new AstValue(this.host.parseReturnValue(this.expression), this.host);\n   }\n "
        },
        {
            "sha": "21ac16f2627989422d4a8cfcbfbb347494c39af5",
            "filename": "packages/compiler-cli/linker/src/file_linker/file_linker.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/c0bccc39dbd4a07f96fdb235af3597f86b3327c3/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Ffile_linker.ts",
            "raw_url": "https://github.com/angular/angular/raw/c0bccc39dbd4a07f96fdb235af3597f86b3327c3/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Ffile_linker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Ffile_linker.ts?ref=c0bccc39dbd4a07f96fdb235af3597f86b3327c3",
            "patch": "@@ -5,6 +5,7 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n+import {R3PartialDeclaration} from '@angular/compiler';\n import {AstObject} from '../ast/ast_value';\n import {DeclarationScope} from './declaration_scope';\n import {EmitScope} from './emit_scopes/emit_scope';\n@@ -53,7 +54,8 @@ export class FileLinker<TConstantScope, TStatement, TExpression> {\n               args.length}.`);\n     }\n \n-    const metaObj = AstObject.parse(args[0], this.linkerEnvironment.host);\n+    const metaObj =\n+        AstObject.parse<R3PartialDeclaration, TExpression>(args[0], this.linkerEnvironment.host);\n     const ngImport = metaObj.getNode('ngImport');\n     const emitScope = this.getEmitScope(ngImport, declarationScope);\n "
        },
        {
            "sha": "0dafc02d483195527cdd8401cb376198b9e3c4e3",
            "filename": "packages/compiler-cli/linker/src/file_linker/partial_linkers/partial_component_linker_1.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/c0bccc39dbd4a07f96fdb235af3597f86b3327c3/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_component_linker_1.ts",
            "raw_url": "https://github.com/angular/angular/raw/c0bccc39dbd4a07f96fdb235af3597f86b3327c3/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_component_linker_1.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_component_linker_1.ts?ref=c0bccc39dbd4a07f96fdb235af3597f86b3327c3",
            "patch": "@@ -5,7 +5,7 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {compileComponentFromMetadata, ConstantPool, DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig, makeBindingParser, parseTemplate, R3ComponentMetadata, R3UsedDirectiveMetadata} from '@angular/compiler';\n+import {compileComponentFromMetadata, ConstantPool, DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig, makeBindingParser, parseTemplate, R3ComponentMetadata, R3DeclareComponentMetadata, R3PartialDeclaration, R3UsedDirectiveMetadata} from '@angular/compiler';\n import {ChangeDetectionStrategy, ViewEncapsulation} from '@angular/compiler/src/core';\n import * as o from '@angular/compiler/src/output/output_ast';\n \n@@ -25,7 +25,7 @@ export class PartialComponentLinkerVersion1<TExpression> implements PartialLinke\n \n   linkPartialDeclaration(\n       sourceUrl: string, code: string, constantPool: ConstantPool,\n-      metaObj: AstObject<TExpression>): o.Expression {\n+      metaObj: AstObject<R3PartialDeclaration, TExpression>): o.Expression {\n     const meta = toR3ComponentMeta(metaObj, code, sourceUrl, this.options);\n     const def = compileComponentFromMetadata(meta, constantPool, makeBindingParser());\n     return def.expression;\n@@ -36,7 +36,7 @@ export class PartialComponentLinkerVersion1<TExpression> implements PartialLinke\n  * This function derives the `R3ComponentMetadata` from the provided AST object.\n  */\n export function toR3ComponentMeta<TExpression>(\n-    metaObj: AstObject<TExpression>, code: string, sourceUrl: string,\n+    metaObj: AstObject<R3DeclareComponentMetadata, TExpression>, code: string, sourceUrl: string,\n     options: LinkerOptions): R3ComponentMetadata {\n   let interpolation = DEFAULT_INTERPOLATION_CONFIG;\n   if (metaObj.has('interpolation')) {\n@@ -133,7 +133,8 @@ export function toR3ComponentMeta<TExpression>(\n /**\n  * Determines the `ViewEncapsulation` mode from the AST value's symbol name.\n  */\n-function parseEncapsulation<TExpression>(encapsulation: AstValue<TExpression>): ViewEncapsulation {\n+function parseEncapsulation<TExpression>(encapsulation: AstValue<ViewEncapsulation, TExpression>):\n+    ViewEncapsulation {\n   const symbolName = encapsulation.getSymbolName();\n   if (symbolName === null) {\n     throw new FatalLinkerError(\n@@ -149,7 +150,8 @@ function parseEncapsulation<TExpression>(encapsulation: AstValue<TExpression>):\n /**\n  * Determines the `ChangeDetectionStrategy` from the AST value's symbol name.\n  */\n-function parseChangeDetectionStrategy<TExpression>(changeDetectionStrategy: AstValue<TExpression>):\n+function parseChangeDetectionStrategy<TExpression>(\n+    changeDetectionStrategy: AstValue<ChangeDetectionStrategy, TExpression>):\n     ChangeDetectionStrategy {\n   const symbolName = changeDetectionStrategy.getSymbolName();\n   if (symbolName === null) {\n@@ -168,7 +170,8 @@ function parseChangeDetectionStrategy<TExpression>(changeDetectionStrategy: AstV\n /**\n  * Update the range to remove the start and end chars, which should be quotes around the template.\n  */\n-function getTemplateRange<TExpression>(templateNode: AstValue<TExpression>, code: string): Range {\n+function getTemplateRange<TExpression>(\n+    templateNode: AstValue<unknown, TExpression>, code: string): Range {\n   const {startPos, endPos, startLine, startCol} = templateNode.getRange();\n \n   if (!/[\"'`]/.test(code[startPos]) || code[startPos] !== code[endPos - 1]) {"
        },
        {
            "sha": "7fe5330434f13e6d7264a532602b28ef9a59565a",
            "filename": "packages/compiler-cli/linker/src/file_linker/partial_linkers/partial_directive_linker_1.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 6,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/c0bccc39dbd4a07f96fdb235af3597f86b3327c3/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_directive_linker_1.ts",
            "raw_url": "https://github.com/angular/angular/raw/c0bccc39dbd4a07f96fdb235af3597f86b3327c3/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_directive_linker_1.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_directive_linker_1.ts?ref=c0bccc39dbd4a07f96fdb235af3597f86b3327c3",
            "patch": "@@ -5,7 +5,7 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {compileDirectiveFromMetadata, ConstantPool, makeBindingParser, ParseLocation, ParseSourceFile, ParseSourceSpan, R3DirectiveMetadata, R3HostMetadata, R3QueryMetadata, R3Reference} from '@angular/compiler';\n+import {compileDirectiveFromMetadata, ConstantPool, makeBindingParser, ParseLocation, ParseSourceFile, ParseSourceSpan, R3DeclareDirectiveMetadata, R3DeclareQueryMetadata, R3DirectiveMetadata, R3HostMetadata, R3PartialDeclaration, R3QueryMetadata, R3Reference} from '@angular/compiler';\n import * as o from '@angular/compiler/src/output/output_ast';\n \n import {Range} from '../../ast/ast_host';\n@@ -20,7 +20,7 @@ import {PartialLinker} from './partial_linker';\n export class PartialDirectiveLinkerVersion1<TExpression> implements PartialLinker<TExpression> {\n   linkPartialDeclaration(\n       sourceUrl: string, code: string, constantPool: ConstantPool,\n-      metaObj: AstObject<TExpression>): o.Expression {\n+      metaObj: AstObject<R3PartialDeclaration, TExpression>): o.Expression {\n     const meta = toR3DirectiveMeta(metaObj, code, sourceUrl);\n     const def = compileDirectiveFromMetadata(meta, constantPool, makeBindingParser());\n     return def.expression;\n@@ -31,7 +31,8 @@ export class PartialDirectiveLinkerVersion1<TExpression> implements PartialLinke\n  * Derives the `R3DirectiveMetadata` structure from the AST object.\n  */\n export function toR3DirectiveMeta<TExpression>(\n-    metaObj: AstObject<TExpression>, code: string, sourceUrl: string): R3DirectiveMetadata {\n+    metaObj: AstObject<R3DeclareDirectiveMetadata, TExpression>, code: string,\n+    sourceUrl: string): R3DirectiveMetadata {\n   const typeExpr = metaObj.getValue('type');\n   const typeName = typeExpr.getSymbolName();\n   if (typeName === null) {\n@@ -73,7 +74,8 @@ export function toR3DirectiveMeta<TExpression>(\n /**\n  * Decodes the AST value for a single input to its representation as used in the metadata.\n  */\n-function toInputMapping<TExpression>(value: AstValue<TExpression>): string|[string, string] {\n+function toInputMapping<TExpression>(value: AstValue<string|[string, string], TExpression>):\n+    string|[string, string] {\n   if (value.isString()) {\n     return value.getString();\n   }\n@@ -90,7 +92,8 @@ function toInputMapping<TExpression>(value: AstValue<TExpression>): string|[stri\n /**\n  * Extracts the host metadata configuration from the AST metadata object.\n  */\n-function toHostMetadata<TExpression>(metaObj: AstObject<TExpression>): R3HostMetadata {\n+function toHostMetadata<TExpression>(metaObj: AstObject<R3DeclareDirectiveMetadata, TExpression>):\n+    R3HostMetadata {\n   if (!metaObj.has('host')) {\n     return {\n       attributes: {},\n@@ -127,7 +130,8 @@ function toHostMetadata<TExpression>(metaObj: AstObject<TExpression>): R3HostMet\n /**\n  * Extracts the metadata for a single query from an AST object.\n  */\n-function toQueryMetadata<TExpression>(obj: AstObject<TExpression>): R3QueryMetadata {\n+function toQueryMetadata<TExpression>(obj: AstObject<R3DeclareQueryMetadata, TExpression>):\n+    R3QueryMetadata {\n   let predicate: R3QueryMetadata['predicate'];\n   const predicateExpr = obj.getValue('predicate');\n   if (predicateExpr.isArray()) {"
        },
        {
            "sha": "35eb33e595ae96b6a4cf74a3cdac05f2b5a14009",
            "filename": "packages/compiler-cli/linker/src/file_linker/partial_linkers/partial_linker.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/c0bccc39dbd4a07f96fdb235af3597f86b3327c3/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_linker.ts",
            "raw_url": "https://github.com/angular/angular/raw/c0bccc39dbd4a07f96fdb235af3597f86b3327c3/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_linker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Fsrc%2Ffile_linker%2Fpartial_linkers%2Fpartial_linker.ts?ref=c0bccc39dbd4a07f96fdb235af3597f86b3327c3",
            "patch": "@@ -5,7 +5,7 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {ConstantPool} from '@angular/compiler';\n+import {ConstantPool, R3PartialDeclaration} from '@angular/compiler';\n import * as o from '@angular/compiler/src/output/output_ast';\n import {AstObject} from '../../ast/ast_value';\n \n@@ -21,5 +21,5 @@ export interface PartialLinker<TExpression> {\n    */\n   linkPartialDeclaration(\n       sourceUrl: string, code: string, constantPool: ConstantPool,\n-      metaObj: AstObject<TExpression>): o.Expression;\n+      metaObj: AstObject<R3PartialDeclaration, TExpression>): o.Expression;\n }"
        },
        {
            "sha": "d18dd143cdd149359283fcc8fcf436d5475cdf43",
            "filename": "packages/compiler-cli/linker/test/ast/ast_value_spec.ts",
            "status": "modified",
            "additions": 81,
            "deletions": 40,
            "changes": 121,
            "blob_url": "https://github.com/angular/angular/blob/c0bccc39dbd4a07f96fdb235af3597f86b3327c3/packages%2Fcompiler-cli%2Flinker%2Ftest%2Fast%2Fast_value_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/c0bccc39dbd4a07f96fdb235af3597f86b3327c3/packages%2Fcompiler-cli%2Flinker%2Ftest%2Fast%2Fast_value_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Flinker%2Ftest%2Fast%2Fast_value_spec.ts?ref=c0bccc39dbd4a07f96fdb235af3597f86b3327c3",
            "patch": "@@ -9,18 +9,28 @@ import {WrappedNodeExpr} from '@angular/compiler';\n import {TypeScriptAstFactory} from '@angular/compiler-cli/src/ngtsc/translator';\n import * as ts from 'typescript';\n \n+import {AstHost} from '../../src/ast/ast_host';\n import {AstObject, AstValue} from '../../src/ast/ast_value';\n import {TypeScriptAstHost} from '../../src/ast/typescript/typescript_ast_host';\n \n-const host = new TypeScriptAstHost();\n+interface TestObject {\n+  a: number;\n+  b: string;\n+  c: boolean;\n+  d: {x: number; y: string};\n+  e: number[];\n+  missing: unknown;\n+}\n+\n+const host: AstHost<ts.Expression> = new TypeScriptAstHost();\n const factory = new TypeScriptAstFactory();\n const nestedObj = factory.createObjectLiteral([\n   {propertyName: 'x', quoted: false, value: factory.createLiteral(42)},\n   {propertyName: 'y', quoted: false, value: factory.createLiteral('X')},\n ]);\n const nestedArray =\n     factory.createArrayLiteral([factory.createLiteral(1), factory.createLiteral(2)]);\n-const obj = AstObject.parse(\n+const obj = AstObject.parse<TestObject, ts.Expression>(\n     factory.createObjectLiteral([\n       {propertyName: 'a', quoted: false, value: factory.createLiteral(42)},\n       {propertyName: 'b', quoted: false, value: factory.createLiteral('X')},\n@@ -35,7 +45,10 @@ describe('AstObject', () => {\n     it('should return true if the property exists on the object', () => {\n       expect(obj.has('a')).toBe(true);\n       expect(obj.has('b')).toBe(true);\n-      expect(obj.has('z')).toBe(false);\n+      expect(obj.has('missing')).toBe(false);\n+\n+      // @ts-expect-error\n+      expect(obj.has('x')).toBe(false);\n     });\n   });\n \n@@ -45,6 +58,7 @@ describe('AstObject', () => {\n     });\n \n     it('should throw an error if the property is not a number', () => {\n+      // @ts-expect-error\n       expect(() => obj.getNumber('b'))\n           .toThrowError('Unsupported syntax, expected a numeric literal.');\n     });\n@@ -56,6 +70,7 @@ describe('AstObject', () => {\n     });\n \n     it('should throw an error if the property is not a string', () => {\n+      // @ts-expect-error\n       expect(() => obj.getString('a'))\n           .toThrowError('Unsupported syntax, expected a string literal.');\n     });\n@@ -67,6 +82,7 @@ describe('AstObject', () => {\n     });\n \n     it('should throw an error if the property is not a boolean', () => {\n+      // @ts-expect-error\n       expect(() => obj.getBoolean('b'))\n           .toThrowError('Unsupported syntax, expected a boolean literal.');\n     });\n@@ -78,6 +94,7 @@ describe('AstObject', () => {\n     });\n \n     it('should throw an error if the property is not an object expression', () => {\n+      // @ts-expect-error\n       expect(() => obj.getObject('b'))\n           .toThrowError('Unsupported syntax, expected an object literal.');\n     });\n@@ -93,6 +110,7 @@ describe('AstObject', () => {\n        });\n \n     it('should throw an error if the property is not an array of expressions', () => {\n+      // @ts-expect-error\n       expect(() => obj.getArray('b'))\n           .toThrowError('Unsupported syntax, expected an array literal.');\n     });\n@@ -105,7 +123,11 @@ describe('AstObject', () => {\n     });\n \n     it('should throw an error if the property does not exist', () => {\n-      expect(() => obj.getOpaque('x')).toThrowError('Expected property \\'x\\' to be present.');\n+      expect(() => obj.getOpaque('missing'))\n+          .toThrowError(`Expected property 'missing' to be present.`);\n+\n+      // @ts-expect-error\n+      expect(() => obj.getOpaque('x')).toThrowError(`Expected property 'x' to be present.`);\n     });\n   });\n \n@@ -115,7 +137,11 @@ describe('AstObject', () => {\n     });\n \n     it('should throw an error if the property does not exist', () => {\n-      expect(() => obj.getNode('x')).toThrowError('Expected property \\'x\\' to be present.');\n+      expect(() => obj.getNode('missing'))\n+          .toThrowError(`Expected property 'missing' to be present.`);\n+\n+      // @ts-expect-error\n+      expect(() => obj.getNode('x')).toThrowError(`Expected property 'x' to be present.`);\n     });\n   });\n \n@@ -126,7 +152,11 @@ describe('AstObject', () => {\n     });\n \n     it('should throw an error if the property does not exist', () => {\n-      expect(() => obj.getValue('x')).toThrowError('Expected property \\'x\\' to be present.');\n+      expect(() => obj.getValue('missing'))\n+          .toThrowError(`Expected property 'missing' to be present.`);\n+\n+      // @ts-expect-error\n+      expect(() => obj.getValue('x')).toThrowError(`Expected property 'x' to be present.`);\n     });\n   });\n \n@@ -156,126 +186,136 @@ describe('AstObject', () => {\n });\n \n describe('AstValue', () => {\n+  function createAstValue<T>(node: ts.Expression): AstValue<T, ts.Expression> {\n+    return new AstValue<T, ts.Expression>(node, host);\n+  }\n+\n   describe('getSymbolName', () => {\n     it('should return the name of an identifier', () => {\n-      expect(new AstValue(factory.createIdentifier('Foo'), host).getSymbolName()).toEqual('Foo');\n+      expect(createAstValue(factory.createIdentifier('Foo')).getSymbolName()).toEqual('Foo');\n     });\n \n     it('should return the name of a property access', () => {\n       const propertyAccess = factory.createPropertyAccess(\n           factory.createIdentifier('Foo'), factory.createIdentifier('Bar'));\n-      expect(new AstValue(propertyAccess, host).getSymbolName()).toEqual('Bar');\n+      expect(createAstValue(propertyAccess).getSymbolName()).toEqual('Bar');\n     });\n \n     it('should return null if no symbol name is available', () => {\n-      expect(new AstValue(factory.createLiteral('a'), host).getSymbolName()).toBeNull();\n+      expect(createAstValue(factory.createLiteral('a')).getSymbolName()).toBeNull();\n     });\n   });\n \n   describe('isNumber', () => {\n     it('should return true if the value is a number', () => {\n-      expect(new AstValue(factory.createLiteral(42), host).isNumber()).toEqual(true);\n+      expect(createAstValue(factory.createLiteral(42)).isNumber()).toEqual(true);\n     });\n \n     it('should return false if the value is not a number', () => {\n-      expect(new AstValue(factory.createLiteral('a'), host).isNumber()).toEqual(false);\n+      expect(createAstValue(factory.createLiteral('a')).isNumber()).toEqual(false);\n     });\n   });\n \n   describe('getNumber', () => {\n     it('should return the number value of the AstValue', () => {\n-      expect(new AstValue(factory.createLiteral(42), host).getNumber()).toEqual(42);\n+      expect(createAstValue<number>(factory.createLiteral(42)).getNumber()).toEqual(42);\n     });\n \n     it('should throw an error if the property is not a number', () => {\n-      expect(() => new AstValue(factory.createLiteral('a'), host).getNumber())\n+      // @ts-expect-error\n+      expect(() => createAstValue<string>(factory.createLiteral('a')).getNumber())\n           .toThrowError('Unsupported syntax, expected a numeric literal.');\n     });\n   });\n \n   describe('isString', () => {\n     it('should return true if the value is a string', () => {\n-      expect(new AstValue(factory.createLiteral('a'), host).isString()).toEqual(true);\n+      expect(createAstValue(factory.createLiteral('a')).isString()).toEqual(true);\n     });\n \n     it('should return false if the value is not a string', () => {\n-      expect(new AstValue(factory.createLiteral(42), host).isString()).toEqual(false);\n+      expect(createAstValue(factory.createLiteral(42)).isString()).toEqual(false);\n     });\n   });\n \n   describe('getString', () => {\n     it('should return the string value of the AstValue', () => {\n-      expect(new AstValue(factory.createLiteral('X'), host).getString()).toEqual('X');\n+      expect(createAstValue<string>(factory.createLiteral('X')).getString()).toEqual('X');\n     });\n \n     it('should throw an error if the property is not a string', () => {\n-      expect(() => new AstValue(factory.createLiteral(42), host).getString())\n+      // @ts-expect-error\n+      expect(() => createAstValue<number>(factory.createLiteral(42)).getString())\n           .toThrowError('Unsupported syntax, expected a string literal.');\n     });\n   });\n \n   describe('isBoolean', () => {\n     it('should return true if the value is a boolean', () => {\n-      expect(new AstValue(factory.createLiteral(true), host).isBoolean()).toEqual(true);\n+      expect(createAstValue(factory.createLiteral(true)).isBoolean()).toEqual(true);\n     });\n \n     it('should return false if the value is not a boolean', () => {\n-      expect(new AstValue(factory.createLiteral(42), host).isBoolean()).toEqual(false);\n+      expect(createAstValue(factory.createLiteral(42)).isBoolean()).toEqual(false);\n     });\n   });\n \n   describe('getBoolean', () => {\n     it('should return the boolean value of the AstValue', () => {\n-      expect(new AstValue(factory.createLiteral(true), host).getBoolean()).toEqual(true);\n+      expect(createAstValue<boolean>(factory.createLiteral(true)).getBoolean()).toEqual(true);\n     });\n \n     it('should throw an error if the property is not a boolean', () => {\n-      expect(() => new AstValue(factory.createLiteral(42), host).getBoolean())\n+      // @ts-expect-error\n+      expect(() => createAstValue<number>(factory.createLiteral(42)).getBoolean())\n           .toThrowError('Unsupported syntax, expected a boolean literal.');\n     });\n   });\n \n   describe('isObject', () => {\n     it('should return true if the value is an object literal', () => {\n-      expect(new AstValue(nestedObj, host).isObject()).toEqual(true);\n+      expect(createAstValue(nestedObj).isObject()).toEqual(true);\n     });\n \n     it('should return false if the value is not an object literal', () => {\n-      expect(new AstValue(factory.createLiteral(42), host).isObject()).toEqual(false);\n+      expect(createAstValue(factory.createLiteral(42)).isObject()).toEqual(false);\n     });\n   });\n \n   describe('getObject', () => {\n     it('should return the AstObject value of the AstValue', () => {\n-      expect(new AstValue(nestedObj, host).getObject()).toEqual(AstObject.parse(nestedObj, host));\n+      expect(createAstValue<object>(nestedObj).getObject())\n+          .toEqual(AstObject.parse(nestedObj, host));\n     });\n \n     it('should throw an error if the property is not an object literal', () => {\n-      expect(() => new AstValue(factory.createLiteral(42), host).getObject())\n+      // @ts-expect-error\n+      expect(() => createAstValue<number>(factory.createLiteral(42)).getObject())\n           .toThrowError('Unsupported syntax, expected an object literal.');\n     });\n   });\n \n   describe('isArray', () => {\n     it('should return true if the value is an array literal', () => {\n-      expect(new AstValue(nestedArray, host).isArray()).toEqual(true);\n+      expect(createAstValue(nestedArray).isArray()).toEqual(true);\n     });\n \n     it('should return false if the value is not an object literal', () => {\n-      expect(new AstValue(factory.createLiteral(42), host).isArray()).toEqual(false);\n+      expect(createAstValue(factory.createLiteral(42)).isArray()).toEqual(false);\n     });\n   });\n \n   describe('getArray', () => {\n     it('should return an array of AstValue objects from the AstValue', () => {\n-      expect(new AstValue(nestedArray, host).getArray()).toEqual([\n-        new AstValue(factory.createLiteral(1), host),\n-        new AstValue(factory.createLiteral(2), host),\n+      expect(createAstValue<number[]>(nestedArray).getArray()).toEqual([\n+        createAstValue(factory.createLiteral(1)),\n+        createAstValue(factory.createLiteral(2)),\n       ]);\n     });\n \n     it('should throw an error if the property is not an array', () => {\n-      expect(() => new AstValue(factory.createLiteral(42), host).getArray())\n+      // @ts-expect-error\n+      expect(() => createAstValue<number>(factory.createLiteral(42)).getArray())\n           .toThrowError('Unsupported syntax, expected an array literal.');\n     });\n   });\n@@ -285,11 +325,11 @@ describe('AstValue', () => {\n       const funcExpr = factory.createFunctionExpression(\n           'foo', [],\n           factory.createBlock([factory.createReturnStatement(factory.createLiteral(42))]));\n-      expect(new AstValue(funcExpr, host).isFunction()).toEqual(true);\n+      expect(createAstValue(funcExpr).isFunction()).toEqual(true);\n     });\n \n     it('should return false if the value is not a function expression', () => {\n-      expect(new AstValue(factory.createLiteral(42), host).isFunction()).toEqual(false);\n+      expect(createAstValue(factory.createLiteral(42)).isFunction()).toEqual(false);\n     });\n   });\n \n@@ -298,12 +338,13 @@ describe('AstValue', () => {\n       const funcExpr = factory.createFunctionExpression(\n           'foo', [],\n           factory.createBlock([factory.createReturnStatement(factory.createLiteral(42))]));\n-      expect(new AstValue(funcExpr, host).getFunctionReturnValue())\n-          .toEqual(new AstValue(factory.createLiteral(42), host));\n+      expect(createAstValue<Function>(funcExpr).getFunctionReturnValue())\n+          .toEqual(createAstValue(factory.createLiteral(42)));\n     });\n \n     it('should throw an error if the property is not a function expression', () => {\n-      expect(() => new AstValue(factory.createLiteral(42), host).getFunctionReturnValue())\n+      // @ts-expect-error\n+      expect(() => createAstValue<number>(factory.createLiteral(42)).getFunctionReturnValue())\n           .toThrowError('Unsupported syntax, expected a function.');\n     });\n \n@@ -312,17 +353,17 @@ describe('AstValue', () => {\n          const funcExpr = factory.createFunctionExpression(\n              'foo', [], factory.createBlock([factory.createExpressionStatement(\n                             factory.createLiteral('do nothing'))]));\n-         expect(() => new AstValue(funcExpr, host).getFunctionReturnValue())\n+         expect(() => createAstValue<Function>(funcExpr).getFunctionReturnValue())\n              .toThrowError(\n                  'Unsupported syntax, expected a function body with a single return statement.');\n        });\n   });\n \n   describe('getOpaque()', () => {\n     it('should return the value wrapped in a `WrappedNodeExpr`', () => {\n-      expect(new AstValue(factory.createLiteral(42), host).getOpaque())\n+      expect(createAstValue(factory.createLiteral(42)).getOpaque())\n           .toEqual(jasmine.any(WrappedNodeExpr));\n-      expect(new AstValue(factory.createLiteral(42), host).getOpaque().node)\n+      expect(createAstValue(factory.createLiteral(42)).getOpaque().node)\n           .toEqual(factory.createLiteral(42));\n     });\n   });\n@@ -339,7 +380,7 @@ describe('AstValue', () => {\n           (stmt.expression as ts.AssignmentExpression<ts.Token<ts.SyntaxKind.EqualsToken>>).right;\n \n       // Check that this string literal has the expected range.\n-      expect(new AstValue(mooString, host).getRange())\n+      expect(createAstValue(mooString).getRange())\n           .toEqual({startLine: 1, startCol: 4, startPos: 16, endPos: 21});\n     });\n   });"
        },
        {
            "sha": "7b4add4d7852355fe46773d34b09493210be2dc4",
            "filename": "packages/compiler/src/compiler.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/c0bccc39dbd4a07f96fdb235af3597f86b3327c3/packages%2Fcompiler%2Fsrc%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/c0bccc39dbd4a07f96fdb235af3597f86b3327c3/packages%2Fcompiler%2Fsrc%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fcompiler.ts?ref=c0bccc39dbd4a07f96fdb235af3597f86b3327c3",
            "patch": "@@ -91,6 +91,7 @@ export {ViewCompiler} from './view_compiler/view_compiler';\n export {getParseErrors, isSyntaxError, syntaxError, Version} from './util';\n export {SourceMap} from './output/source_map';\n export * from './injectable_compiler_2';\n+export * from './render3/partial/api';\n export * from './render3/view/api';\n export {BoundAttribute as TmplAstBoundAttribute, BoundEvent as TmplAstBoundEvent, BoundText as TmplAstBoundText, Content as TmplAstContent, Element as TmplAstElement, Icu as TmplAstIcu, Node as TmplAstNode, RecursiveVisitor as TmplAstRecursiveVisitor, Reference as TmplAstReference, Template as TmplAstTemplate, Text as TmplAstText, TextAttribute as TmplAstTextAttribute, Variable as TmplAstVariable} from './render3/r3_ast';\n export * from './render3/view/t2_api';"
        },
        {
            "sha": "501961883a18c9a07ac9eb3d0881d2885c1843ad",
            "filename": "packages/compiler/src/render3/partial/api.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 16,
            "changes": 32,
            "blob_url": "https://github.com/angular/angular/blob/c0bccc39dbd4a07f96fdb235af3597f86b3327c3/packages%2Fcompiler%2Fsrc%2Frender3%2Fpartial%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/c0bccc39dbd4a07f96fdb235af3597f86b3327c3/packages%2Fcompiler%2Fsrc%2Frender3%2Fpartial%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fpartial%2Fapi.ts?ref=c0bccc39dbd4a07f96fdb235af3597f86b3327c3",
            "patch": "@@ -6,23 +6,29 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n import {ChangeDetectionStrategy, ViewEncapsulation} from '../../core';\n-import {InterpolationConfig} from '../../ml_parser/interpolation_config';\n import * as o from '../../output/output_ast';\n \n+export interface R3PartialDeclaration {\n+  /**\n+   * Version number of the Angular compiler that was used to compile this declaration. The linker\n+   * will be able to detect which version a library is using and interpret its metadata accordingly.\n+   */\n+  version: string;\n+\n+  /**\n+   * A reference to the `@angular/core` ES module, which allows access\n+   * to all Angular exports, including Ivy instructions.\n+   */\n+  ngImport: o.Expression;\n+}\n+\n /**\n  * This interface describes the shape of the object that partial directive declarations are compiled\n  * into. This serves only as documentation, as conformance of this interface is not enforced during\n  * the generation of the partial declaration, nor when the linker applies full compilation from the\n  * partial declaration.\n  */\n-export interface R3DeclareDirectiveMetadata {\n-  /**\n-   * Version number of the metadata format. This is used to evolve the metadata\n-   * interface later - the linker will be able to detect which version a library\n-   * is using and interpret its metadata accordingly.\n-   */\n-  version: string;\n-\n+export interface R3DeclareDirectiveMetadata extends R3PartialDeclaration {\n   /**\n    * Unparsed selector of the directive.\n    */\n@@ -106,12 +112,6 @@ export interface R3DeclareDirectiveMetadata {\n    * Whether the directive implements the `ngOnChanges` hook. Defaults to false.\n    */\n   usesOnChanges?: boolean;\n-\n-  /**\n-   * A reference to the `@angular/core` ES module, which allows access\n-   * to all Angular exports, including Ivy instructions.\n-   */\n-  ngImport: o.Expression;\n }\n \n /**\n@@ -206,7 +206,7 @@ export interface R3DeclareComponentMetadata extends R3DeclareDirectiveMetadata {\n   /**\n    * Overrides the default interpolation start and end delimiters. Defaults to {{ and }}.\n    */\n-  interpolation?: InterpolationConfig;\n+  interpolation?: [string, string];\n \n   /**\n    * Whether whitespace in the template should be preserved. Defaults to false."
        }
    ],
    "stats": {
        "total": 296,
        "additions": 199,
        "deletions": 97
    }
}