{
    "author": "JoostK",
    "message": "refactor(compiler): cleanup distinction in parse logic (#44411)\n\nThis removes the special casing of parse-validation logic that was only\nused by Ivy.\n\nPR Close #44411",
    "sha": "f86e02e01e523174926c346397b323dcb2364b46",
    "files": [
        {
            "sha": "666644bf9dc25286918c1eb8cf229bb962b446b9",
            "filename": "packages/compiler/src/expression_parser/parser.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 72,
            "changes": 75,
            "blob_url": "https://github.com/angular/angular/blob/f86e02e01e523174926c346397b323dcb2364b46/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "raw_url": "https://github.com/angular/angular/raw/f86e02e01e523174926c346397b323dcb2364b46/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts?ref=f86e02e01e523174926c346397b323dcb2364b46",
            "patch": "@@ -9,7 +9,7 @@\n import * as chars from '../chars';\n import {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../ml_parser/interpolation_config';\n \n-import {AbsoluteSourceSpan, AST, AstVisitor, ASTWithSource, Binary, BindingPipe, Call, Chain, Conditional, EmptyExpr, ExpressionBinding, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralMapKey, LiteralPrimitive, NonNullAssert, ParserError, ParseSpan, PrefixNot, PropertyRead, PropertyWrite, Quote, RecursiveAstVisitor, SafeKeyedRead, SafePropertyRead, TemplateBinding, TemplateBindingIdentifier, ThisReceiver, Unary, VariableBinding} from './ast';\n+import {AbsoluteSourceSpan, AST, ASTWithSource, Binary, BindingPipe, Call, Chain, Conditional, EmptyExpr, ExpressionBinding, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralMapKey, LiteralPrimitive, NonNullAssert, ParserError, ParseSpan, PrefixNot, PropertyRead, PropertyWrite, Quote, RecursiveAstVisitor, SafeKeyedRead, SafePropertyRead, TemplateBinding, TemplateBindingIdentifier, ThisReceiver, Unary, VariableBinding} from './ast';\n import {EOF, isIdentifier, Lexer, Token, TokenType} from './lexer';\n \n export interface InterpolationPiece {\n@@ -34,8 +34,6 @@ export class Parser {\n \n   constructor(private _lexer: Lexer) {}\n \n-  simpleExpressionChecker = SimpleExpressionChecker;\n-\n   parseAction(\n       input: string, location: string, absoluteOffset: number,\n       interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n@@ -57,7 +55,7 @@ export class Parser {\n   }\n \n   private checkSimpleExpression(ast: AST): string[] {\n-    const checker = new this.simpleExpressionChecker();\n+    const checker = new SimpleExpressionChecker();\n     ast.visit(checker);\n     return checker.errors;\n   }\n@@ -366,10 +364,6 @@ export class Parser {\n   }\n }\n \n-export class IvyParser extends Parser {\n-  override simpleExpressionChecker = IvySimpleExpressionChecker;\n-}\n-\n /** Describes a stateful context an expression parser is in. */\n enum ParseContextFlags {\n   None = 0,\n@@ -1303,70 +1297,7 @@ export class _ParseAST {\n   }\n }\n \n-class SimpleExpressionChecker implements AstVisitor {\n-  errors: string[] = [];\n-\n-  visitImplicitReceiver(ast: ImplicitReceiver, context: any) {}\n-\n-  visitThisReceiver(ast: ThisReceiver, context: any) {}\n-\n-  visitInterpolation(ast: Interpolation, context: any) {}\n-\n-  visitLiteralPrimitive(ast: LiteralPrimitive, context: any) {}\n-\n-  visitPropertyRead(ast: PropertyRead, context: any) {}\n-\n-  visitPropertyWrite(ast: PropertyWrite, context: any) {}\n-\n-  visitSafePropertyRead(ast: SafePropertyRead, context: any) {}\n-\n-  visitCall(ast: Call, context: any) {}\n-\n-  visitLiteralArray(ast: LiteralArray, context: any) {\n-    this.visitAll(ast.expressions, context);\n-  }\n-\n-  visitLiteralMap(ast: LiteralMap, context: any) {\n-    this.visitAll(ast.values, context);\n-  }\n-\n-  visitUnary(ast: Unary, context: any) {}\n-\n-  visitBinary(ast: Binary, context: any) {}\n-\n-  visitPrefixNot(ast: PrefixNot, context: any) {}\n-\n-  visitNonNullAssert(ast: NonNullAssert, context: any) {}\n-\n-  visitConditional(ast: Conditional, context: any) {}\n-\n-  visitPipe(ast: BindingPipe, context: any) {\n-    this.errors.push('pipes');\n-  }\n-\n-  visitKeyedRead(ast: KeyedRead, context: any) {}\n-\n-  visitKeyedWrite(ast: KeyedWrite, context: any) {}\n-\n-  visitAll(asts: any[], context: any): any[] {\n-    return asts.map(node => node.visit(this, context));\n-  }\n-\n-  visitChain(ast: Chain, context: any) {}\n-\n-  visitQuote(ast: Quote, context: any) {}\n-\n-  visitSafeKeyedRead(ast: SafeKeyedRead, context: any) {}\n-}\n-\n-/**\n- * This class implements SimpleExpressionChecker used in View Engine and performs more strict checks\n- * to make sure host bindings do not contain pipes. In View Engine, having pipes in host bindings is\n- * not supported as well, but in some cases (like `!(value | async)`) the error is not triggered at\n- * compile time. In order to preserve View Engine behavior, more strict checks are introduced for\n- * Ivy mode only.\n- */\n-class IvySimpleExpressionChecker extends RecursiveAstVisitor implements SimpleExpressionChecker {\n+class SimpleExpressionChecker extends RecursiveAstVisitor {\n   errors: string[] = [];\n \n   override visitPipe() {"
        },
        {
            "sha": "9d24319752cea229075b1af8868cdf83a7323661",
            "filename": "packages/compiler/src/render3/view/template.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/f86e02e01e523174926c346397b323dcb2364b46/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "raw_url": "https://github.com/angular/angular/raw/f86e02e01e523174926c346397b323dcb2364b46/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts?ref=f86e02e01e523174926c346397b323dcb2364b46",
            "patch": "@@ -11,7 +11,7 @@ import {ConstantPool} from '../../constant_pool';\n import * as core from '../../core';\n import {AST, AstMemoryEfficientTransformer, BindingPipe, BindingType, Call, ImplicitReceiver, Interpolation, LiteralArray, LiteralMap, LiteralPrimitive, ParsedEventType, PropertyRead} from '../../expression_parser/ast';\n import {Lexer} from '../../expression_parser/lexer';\n-import {IvyParser} from '../../expression_parser/parser';\n+import {Parser} from '../../expression_parser/parser';\n import * as i18n from '../../i18n/i18n_ast';\n import * as html from '../../ml_parser/ast';\n import {HtmlParser} from '../../ml_parser/html_parser';\n@@ -2225,7 +2225,7 @@ const elementRegistry = new DomElementSchemaRegistry();\n  */\n export function makeBindingParser(\n     interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): BindingParser {\n-  return new BindingParser(new IvyParser(new Lexer()), interpolationConfig, elementRegistry, []);\n+  return new BindingParser(new Parser(new Lexer()), interpolationConfig, elementRegistry, []);\n }\n \n export function resolveSanitizationFn(context: core.SecurityContext, isAttribute?: boolean) {"
        },
        {
            "sha": "4c6a19790493132402eb5f17e370bbdf9e94b246",
            "filename": "packages/compiler/test/expression_parser/parser_spec.ts",
            "status": "modified",
            "additions": 50,
            "deletions": 62,
            "changes": 112,
            "blob_url": "https://github.com/angular/angular/blob/f86e02e01e523174926c346397b323dcb2364b46/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f86e02e01e523174926c346397b323dcb2364b46/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts?ref=f86e02e01e523174926c346397b323dcb2364b46",
            "patch": "@@ -8,10 +8,9 @@\n \n import {AbsoluteSourceSpan, ASTWithSource, BindingPipe, Call, EmptyExpr, Interpolation, ParserError, TemplateBinding, VariableBinding} from '@angular/compiler/src/expression_parser/ast';\n import {Lexer} from '@angular/compiler/src/expression_parser/lexer';\n-import {IvyParser, Parser, SplitInterpolation} from '@angular/compiler/src/expression_parser/parser';\n+import {Parser, SplitInterpolation} from '@angular/compiler/src/expression_parser/parser';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n \n-\n import {unparse, unparseWithSpan} from './utils/unparser';\n import {validate} from './utils/validator';\n \n@@ -1070,66 +1069,64 @@ describe('parser', () => {\n       expectError(validate(parseSimpleBinding('a = b')), 'Bindings cannot contain assignments');\n     });\n \n-    describe('Ivy-only validations', () => {\n-      it('should throw if a pipe is used inside a conditional', () => {\n-        expectError(\n-            validate(parseSimpleBindingIvy('(hasId | myPipe) ? \"my-id\" : \"\"')),\n-            'Host binding expression cannot contain pipes');\n-      });\n+    it('should throw if a pipe is used inside a conditional', () => {\n+      expectError(\n+          validate(parseSimpleBinding('(hasId | myPipe) ? \"my-id\" : \"\"')),\n+          'Host binding expression cannot contain pipes');\n+    });\n \n-      it('should throw if a pipe is used inside a call', () => {\n-        expectError(\n-            validate(parseSimpleBindingIvy('getId(true, id | myPipe)')),\n-            'Host binding expression cannot contain pipes');\n-      });\n+    it('should throw if a pipe is used inside a call', () => {\n+      expectError(\n+          validate(parseSimpleBinding('getId(true, id | myPipe)')),\n+          'Host binding expression cannot contain pipes');\n+    });\n \n-      it('should throw if a pipe is used inside a call to a property access', () => {\n-        expectError(\n-            validate(parseSimpleBindingIvy('idService.getId(true, id | myPipe)')),\n-            'Host binding expression cannot contain pipes');\n-      });\n+    it('should throw if a pipe is used inside a call to a property access', () => {\n+      expectError(\n+          validate(parseSimpleBinding('idService.getId(true, id | myPipe)')),\n+          'Host binding expression cannot contain pipes');\n+    });\n \n-      it('should throw if a pipe is used inside a call to a safe property access', () => {\n-        expectError(\n-            validate(parseSimpleBindingIvy('idService?.getId(true, id | myPipe)')),\n-            'Host binding expression cannot contain pipes');\n-      });\n+    it('should throw if a pipe is used inside a call to a safe property access', () => {\n+      expectError(\n+          validate(parseSimpleBinding('idService?.getId(true, id | myPipe)')),\n+          'Host binding expression cannot contain pipes');\n+    });\n \n-      it('should throw if a pipe is used inside a property access', () => {\n-        expectError(\n-            validate(parseSimpleBindingIvy('a[id | myPipe]')),\n-            'Host binding expression cannot contain pipes');\n-      });\n+    it('should throw if a pipe is used inside a property access', () => {\n+      expectError(\n+          validate(parseSimpleBinding('a[id | myPipe]')),\n+          'Host binding expression cannot contain pipes');\n+    });\n \n-      it('should throw if a pipe is used inside a keyed read expression', () => {\n-        expectError(\n-            validate(parseSimpleBindingIvy('a[id | myPipe].b')),\n-            'Host binding expression cannot contain pipes');\n-      });\n+    it('should throw if a pipe is used inside a keyed read expression', () => {\n+      expectError(\n+          validate(parseSimpleBinding('a[id | myPipe].b')),\n+          'Host binding expression cannot contain pipes');\n+    });\n \n-      it('should throw if a pipe is used inside a safe property read', () => {\n-        expectError(\n-            validate(parseSimpleBindingIvy('(id | myPipe)?.id')),\n-            'Host binding expression cannot contain pipes');\n-      });\n+    it('should throw if a pipe is used inside a safe property read', () => {\n+      expectError(\n+          validate(parseSimpleBinding('(id | myPipe)?.id')),\n+          'Host binding expression cannot contain pipes');\n+    });\n \n-      it('should throw if a pipe is used inside a non-null assertion', () => {\n-        expectError(\n-            validate(parseSimpleBindingIvy('[id | myPipe]!')),\n-            'Host binding expression cannot contain pipes');\n-      });\n+    it('should throw if a pipe is used inside a non-null assertion', () => {\n+      expectError(\n+          validate(parseSimpleBinding('[id | myPipe]!')),\n+          'Host binding expression cannot contain pipes');\n+    });\n \n-      it('should throw if a pipe is used inside a prefix not expression', () => {\n-        expectError(\n-            validate(parseSimpleBindingIvy('!(id | myPipe)')),\n-            'Host binding expression cannot contain pipes');\n-      });\n+    it('should throw if a pipe is used inside a prefix not expression', () => {\n+      expectError(\n+          validate(parseSimpleBinding('!(id | myPipe)')),\n+          'Host binding expression cannot contain pipes');\n+    });\n \n-      it('should throw if a pipe is used inside a binary expression', () => {\n-        expectError(\n-            validate(parseSimpleBindingIvy('(id | myPipe) === true')),\n-            'Host binding expression cannot contain pipes');\n-      });\n+    it('should throw if a pipe is used inside a binary expression', () => {\n+      expectError(\n+          validate(parseSimpleBinding('(id | myPipe) === true')),\n+          'Host binding expression cannot contain pipes');\n     });\n   });\n \n@@ -1171,10 +1168,6 @@ function createParser() {\n   return new Parser(new Lexer());\n }\n \n-function createIvyParser() {\n-  return new IvyParser(new Lexer());\n-}\n-\n function parseAction(text: string, location: any = null, offset: number = 0): ASTWithSource {\n   return createParser().parseAction(text, location, offset);\n }\n@@ -1218,11 +1211,6 @@ function parseSimpleBinding(text: string, location: any = null, offset: number =\n   return createParser().parseSimpleBinding(text, location, offset);\n }\n \n-function parseSimpleBindingIvy(\n-    text: string, location: any = null, offset: number = 0): ASTWithSource {\n-  return createIvyParser().parseSimpleBinding(text, location, offset);\n-}\n-\n function checkInterpolation(exp: string, expected?: string) {\n   const ast = parseInterpolation(exp);\n   if (expected == null) expected = exp;"
        }
    ],
    "stats": {
        "total": 191,
        "additions": 55,
        "deletions": 136
    }
}