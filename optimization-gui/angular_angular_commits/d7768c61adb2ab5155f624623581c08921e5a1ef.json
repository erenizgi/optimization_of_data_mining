{
    "author": "kapunahelewong",
    "message": "docs: edit copy for tick() in testing and api docs (#35697)\n\nFixes #35696\n\nPR Close #35697",
    "sha": "d7768c61adb2ab5155f624623581c08921e5a1ef",
    "files": [
        {
            "sha": "5f0d1a014f4e02dd8a9a3215291cc6c84c6d6b07",
            "filename": "packages/core/testing/src/fake_async.ts",
            "status": "modified",
            "additions": 41,
            "deletions": 24,
            "changes": 65,
            "blob_url": "https://github.com/angular/angular/blob/d7768c61adb2ab5155f624623581c08921e5a1ef/packages%2Fcore%2Ftesting%2Fsrc%2Ffake_async.ts",
            "raw_url": "https://github.com/angular/angular/raw/d7768c61adb2ab5155f624623581c08921e5a1ef/packages%2Fcore%2Ftesting%2Fsrc%2Ffake_async.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftesting%2Fsrc%2Ffake_async.ts?ref=d7768c61adb2ab5155f624623581c08921e5a1ef",
            "patch": "@@ -26,21 +26,25 @@ export function resetFakeAsyncZone(): void {\n }\n \n /**\n- * Wraps a function to be executed in the fakeAsync zone:\n- * - microtasks are manually executed by calling `flushMicrotasks()`,\n- * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n+ * Wraps a function to be executed in the `fakeAsync` zone:\n+ * - Microtasks are manually executed by calling `flushMicrotasks()`.\n+ * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\n  *\n- * If there are any pending timers at the end of the function, an exception will be thrown.\n+ * If there are any pending timers at the end of the function, an exception is thrown.\n  *\n- * Can be used to wrap inject() calls.\n+ * Can be used to wrap `inject()` calls.\n+ *\n+ * @param fn The function that you want to wrap in the `fakeAysnc` zone.\n  *\n  * @usageNotes\n  * ### Example\n  *\n  * {@example core/testing/ts/fake_async.ts region='basic'}\n  *\n- * @param fn\n- * @returns The function wrapped to be executed in the fakeAsync zone\n+ *\n+ * @returns The function wrapped to be executed in the `fakeAsync` zone.\n+ * Any arguments passed when calling this returned function will be passed through to the `fn`\n+ * function in the parameters when it is called.\n  *\n  * @publicApi\n  */\n@@ -52,23 +56,36 @@ export function fakeAsync(fn: Function): (...args: any[]) => any {\n }\n \n /**\n- * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n+ * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\n  *\n  * The microtasks queue is drained at the very start of this function and after any timer callback\n  * has been executed.\n  *\n+ * @param millis The number of milliseconds to advance the virtual timer.\n+ * @param tickOptions The options to pass to the `tick()` function.\n+ *\n  * @usageNotes\n+ *\n+ * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\n+ * which determines whether or not to invoke new macroTasks.\n+ *\n+ * If you provide a `tickOptions` object, but do not specify a\n+ * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\n+ * then `processNewMacroTasksSynchronously` defaults to true.\n+ *\n+ * If you omit the `tickOptions` parameter (`tick(100))`), then\n+ * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\n+ *\n  * ### Example\n  *\n  * {@example core/testing/ts/fake_async.ts region='basic'}\n  *\n- * @param millis, the number of millisecond to advance the virtual timer\n- * @param tickOptions, the options of tick with a flag called\n- * processNewMacroTasksSynchronously, whether to invoke the new macroTasks, by default is\n- * false, means the new macroTasks will be invoked\n- *\n- * For example,\n+ * The following example includes a nested timeout (new macroTask), and\n+ * the `tickOptions` parameter is allowed to default. In this case,\n+ * `processNewMacroTasksSynchronously` defaults to true, and the nested\n+ * function is executed on each tick.\n  *\n+ * ```\n  * it ('test with nested setTimeout', fakeAsync(() => {\n  *   let nestedTimeoutInvoked = false;\n  *   function funcWithNestedTimeout() {\n@@ -80,10 +97,12 @@ export function fakeAsync(fn: Function): (...args: any[]) => any {\n  *   tick();\n  *   expect(nestedTimeoutInvoked).toBe(true);\n  * }));\n+ * ```\n  *\n- * in this case, we have a nested timeout (new macroTask), when we tick, both the\n- * funcWithNestedTimeout and the nested timeout both will be invoked.\n+ * In the following case, `processNewMacroTasksSynchronously` is explicitly\n+ * set to false, so the nested timeout function is not invoked.\n  *\n+ * ```\n  * it ('test with nested setTimeout', fakeAsync(() => {\n  *   let nestedTimeoutInvoked = false;\n  *   function funcWithNestedTimeout() {\n@@ -95,9 +114,7 @@ export function fakeAsync(fn: Function): (...args: any[]) => any {\n  *   tick(0, {processNewMacroTasksSynchronously: false});\n  *   expect(nestedTimeoutInvoked).toBe(false);\n  * }));\n- *\n- * if we pass the tickOptions with processNewMacroTasksSynchronously to be false, the nested timeout\n- * will not be invoked.\n+ * ```\n  *\n  *\n  * @publicApi\n@@ -113,12 +130,12 @@ export function tick(\n }\n \n /**\n- * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n- * draining the macrotask queue until it is empty. The returned value is the milliseconds\n- * of time that would have been elapsed.\n+ * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone by\n+ * draining the macrotask queue until it is empty.\n  *\n- * @param maxTurns\n- * @returns The simulated time elapsed, in millis.\n+ * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\n+ *     throwing an error.\n+ * @returns The simulated time elapsed, in milliseconds.\n  *\n  * @publicApi\n  */"
        }
    ],
    "stats": {
        "total": 65,
        "additions": 41,
        "deletions": 24
    }
}