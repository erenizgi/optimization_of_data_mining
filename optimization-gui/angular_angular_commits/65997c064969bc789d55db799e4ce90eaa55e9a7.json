{
    "author": "petebacondarwin",
    "message": "refactor(ngcc): simplify and break up ES2015 functions with helpers (#38959)\n\nThe protected helper functions can then be overridden by subclasses of the\nEsm2015ReflectionHost.\n\nPR Close #38959",
    "sha": "65997c064969bc789d55db799e4ce90eaa55e9a7",
    "files": [
        {
            "sha": "f360c082c58ca1c70da418355a6be3b8b9b12769",
            "filename": "packages/compiler-cli/ngcc/src/host/esm2015_host.ts",
            "status": "modified",
            "additions": 61,
            "deletions": 47,
            "changes": 108,
            "blob_url": "https://github.com/angular/angular/blob/65997c064969bc789d55db799e4ce90eaa55e9a7/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fesm2015_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/65997c064969bc789d55db799e4ce90eaa55e9a7/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fesm2015_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fesm2015_host.ts?ref=65997c064969bc789d55db799e4ce90eaa55e9a7",
            "patch": "@@ -132,15 +132,8 @@ export class Esm2015ReflectionHost extends TypeScriptReflectionHost implements N\n     if (symbol !== undefined) {\n       return symbol;\n     }\n-\n-    if (declaration.parent !== undefined && isNamedVariableDeclaration(declaration.parent)) {\n-      const variableValue = this.getVariableValue(declaration.parent);\n-      if (variableValue !== null) {\n-        declaration = variableValue;\n-      }\n-    }\n-\n-    return this.getClassSymbolFromInnerDeclaration(declaration);\n+    const innerDeclaration = this.getInnerDeclarationFromAliasOrInner(declaration);\n+    return this.getClassSymbolFromInnerDeclaration(innerDeclaration);\n   }\n \n   /**\n@@ -243,13 +236,7 @@ export class Esm2015ReflectionHost extends TypeScriptReflectionHost implements N\n           clazz.name.text} to be a class declaration.`);\n     }\n \n-    if (classSymbol.adjacent !== undefined) {\n-      return this.getNameFromClassSymbolDeclaration(\n-          classSymbol, classSymbol.adjacent.valueDeclaration);\n-    } else {\n-      return this.getNameFromClassSymbolDeclaration(\n-          classSymbol, classSymbol.implementation.valueDeclaration);\n-    }\n+    return this.getAdjacentNameOfClassSymbol(classSymbol);\n   }\n \n   private getNameFromClassSymbolDeclaration(\n@@ -430,21 +417,8 @@ export class Esm2015ReflectionHost extends TypeScriptReflectionHost implements N\n    */\n   findClassSymbols(sourceFile: ts.SourceFile): NgccClassSymbol[] {\n     const classes: NgccClassSymbol[] = [];\n-    this.getModuleStatements(sourceFile).forEach(statement => {\n-      if (ts.isVariableStatement(statement)) {\n-        statement.declarationList.declarations.forEach(declaration => {\n-          const classSymbol = this.getClassSymbol(declaration);\n-          if (classSymbol) {\n-            classes.push(classSymbol);\n-          }\n-        });\n-      } else if (ts.isClassDeclaration(statement)) {\n-        const classSymbol = this.getClassSymbol(statement);\n-        if (classSymbol) {\n-          classes.push(classSymbol);\n-        }\n-      }\n-    });\n+    this.getModuleStatements(sourceFile)\n+        .forEach(statement => this.addClassSymbolsFromStatement(classes, statement));\n     return classes;\n   }\n \n@@ -569,6 +543,41 @@ export class Esm2015ReflectionHost extends TypeScriptReflectionHost implements N\n \n   ///////////// Protected Helpers /////////////\n \n+  /**\n+   * Extract all the \"classes\" from the `statement` and add them to the `classes` array.\n+   */\n+  protected addClassSymbolsFromStatement(classes: NgccClassSymbol[], statement: ts.Statement):\n+      void {\n+    if (ts.isVariableStatement(statement)) {\n+      statement.declarationList.declarations.forEach(declaration => {\n+        const classSymbol = this.getClassSymbol(declaration);\n+        if (classSymbol) {\n+          classes.push(classSymbol);\n+        }\n+      });\n+    } else if (ts.isClassDeclaration(statement)) {\n+      const classSymbol = this.getClassSymbol(statement);\n+      if (classSymbol) {\n+        classes.push(classSymbol);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Compute the inner declaration node of a \"class\" from the given `declaration` node.\n+   *\n+   * @param declaration a node that is either an inner declaration or an alias of a class.\n+   */\n+  protected getInnerDeclarationFromAliasOrInner(declaration: ts.Node): ts.Node {\n+    if (declaration.parent !== undefined && isNamedVariableDeclaration(declaration.parent)) {\n+      const variableValue = this.getVariableValue(declaration.parent);\n+      if (variableValue !== null) {\n+        declaration = variableValue;\n+      }\n+    }\n+    return declaration;\n+  }\n+\n   /**\n    * A class may be declared as a top level class declaration:\n    *\n@@ -611,7 +620,7 @@ export class Esm2015ReflectionHost extends TypeScriptReflectionHost implements N\n   protected getClassSymbolFromOuterDeclaration(declaration: ts.Node): NgccClassSymbol|undefined {\n     // Return a class symbol without an inner declaration if it is a regular \"top level\" class\n     if (isNamedClassDeclaration(declaration) && isTopLevel(declaration)) {\n-      return this.createClassSymbol(declaration, null);\n+      return this.createClassSymbol(declaration.name, null);\n     }\n \n     // Otherwise, an outer class declaration must be an initialized variable declaration:\n@@ -620,12 +629,11 @@ export class Esm2015ReflectionHost extends TypeScriptReflectionHost implements N\n     }\n \n     const innerDeclaration = getInnerClassDeclaration(skipClassAliases(declaration));\n-    if (innerDeclaration !== null) {\n-      return this.createClassSymbol(declaration, innerDeclaration);\n+    if (innerDeclaration === null) {\n+      return undefined;\n     }\n \n-\n-    return undefined;\n+    return this.createClassSymbol(declaration.name, innerDeclaration);\n   }\n \n   /**\n@@ -681,7 +689,7 @@ export class Esm2015ReflectionHost extends TypeScriptReflectionHost implements N\n       return undefined;\n     }\n \n-    return this.createClassSymbol(outerDeclaration, declaration);\n+    return this.createClassSymbol(outerDeclaration.name, declaration);\n   }\n \n   /**\n@@ -695,10 +703,10 @@ export class Esm2015ReflectionHost extends TypeScriptReflectionHost implements N\n    * @returns the `NgccClassSymbol` representing the class, or undefined if a `ts.Symbol` for any of\n    * the declarations could not be resolved.\n    */\n-  protected createClassSymbol(outerDeclaration: ClassDeclaration, innerDeclaration: ts.Node|null):\n+  protected createClassSymbol(outerDeclaration: ts.Identifier, innerDeclaration: ts.Node|null):\n       NgccClassSymbol|undefined {\n     const declarationSymbol =\n-        this.checker.getSymbolAtLocation(outerDeclaration.name) as ClassSymbol | undefined;\n+        this.checker.getSymbolAtLocation(outerDeclaration) as ClassSymbol | undefined;\n     if (declarationSymbol === undefined) {\n       return undefined;\n     }\n@@ -716,13 +724,9 @@ export class Esm2015ReflectionHost extends TypeScriptReflectionHost implements N\n       name: declarationSymbol.name,\n       declaration: declarationSymbol,\n       implementation: implementationSymbol,\n+      adjacent: this.getAdjacentSymbol(declarationSymbol, implementationSymbol),\n     };\n \n-    let adjacent = this.getAdjacentSymbol(declarationSymbol, implementationSymbol);\n-    if (adjacent !== null) {\n-      classSymbol.adjacent = adjacent;\n-    }\n-\n     return classSymbol;\n   }\n \n@@ -1166,8 +1170,7 @@ export class Esm2015ReflectionHost extends TypeScriptReflectionHost implements N\n \n     const outerDeclaration = classSymbol.declaration.valueDeclaration;\n     const innerDeclaration = classSymbol.implementation.valueDeclaration;\n-    const adjacentDeclaration =\n-        this.getAdjacentNameOfClass((classSymbol.declaration.valueDeclaration)).parent;\n+    const adjacentDeclaration = this.getAdjacentNameOfClassSymbol(classSymbol).parent;\n     const matchesClass = (identifier: ts.Identifier) => {\n       const decl = this.getDeclarationOfIdentifier(identifier);\n       return decl !== null &&\n@@ -2017,6 +2020,16 @@ export class Esm2015ReflectionHost extends TypeScriptReflectionHost implements N\n     }\n     return reflectEnumAssignment(innerExpression);\n   }\n+\n+  private getAdjacentNameOfClassSymbol(classSymbol: NgccClassSymbol): ts.Identifier {\n+    if (classSymbol.adjacent !== undefined) {\n+      return this.getNameFromClassSymbolDeclaration(\n+          classSymbol, classSymbol.adjacent.valueDeclaration);\n+    } else {\n+      return this.getNameFromClassSymbolDeclaration(\n+          classSymbol, classSymbol.implementation.valueDeclaration);\n+    }\n+  }\n }\n \n ///////////// Exported Helpers /////////////\n@@ -2305,6 +2318,7 @@ function isInitializedVariableClassDeclaration(node: ts.Node):\n     node is InitializedVariableClassDeclaration {\n   return isNamedVariableDeclaration(node) && node.initializer !== undefined;\n }\n+\n /**\n  * Handle a variable declaration of the form\n  *\n@@ -2364,7 +2378,7 @@ export function skipClassAliases(node: InitializedVariableClassDeclaration): ts.\n  * @param expression the node that represents the class whose declaration we are finding.\n  * @returns the declaration of the class or `null` if it is not a \"class\".\n  */\n-function getInnerClassDeclaration(expression: ts.Expression):\n+export function getInnerClassDeclaration(expression: ts.Expression):\n     ClassDeclaration<ts.ClassExpression|ts.ClassDeclaration|ts.FunctionDeclaration>|null {\n   if (ts.isClassExpression(expression) && hasNameIdentifier(expression)) {\n     return expression;"
        }
    ],
    "stats": {
        "total": 108,
        "additions": 61,
        "deletions": 47
    }
}