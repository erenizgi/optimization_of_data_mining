{
    "author": "gkalpak",
    "message": "fix(docs-infra): ensure `SwUpdatesService` is instantiated (#43766)\n\nIn 305d05545ad6037b3b8eccb8e53e09735836391e, we accidentally stopped\ninstantiating the `SwUpdatesService` service, which meant that we were\nno longer subscribing to ServiceWorker update events and proactively\nchecking for updates. We would still gets updates, because the\nServiceWorker automatically checks on each navigation request and when a\nnew ServiceWorker instance is created, but we would not proactively\nfetch updates and also miss `unrecoverable` errors.\n\nThis commit fixes this by exposing an `enable()` method from\n`SwUpdatesService`, which has to be explicitly called for the service to\nbe enabled, and ensures that the method is called when `AppComponent` is\ninitialized.\nThe commit also gets rid of the `SwUpdatesModule` (whose only purpose\nwas to provide `SwUpdatesService`) in favor of using `providedIn`.\n\nFixes #43695\n\nPR Close #43766",
    "sha": "0849a09fd16ac89f20c5418258f81ef7427bab9b",
    "files": [
        {
            "sha": "c30d15ca2d0e5e4cdff42f5849759f8078094132",
            "filename": "aio/src/app/app.component.spec.ts",
            "status": "modified",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/angular/angular/blob/0849a09fd16ac89f20c5418258f81ef7427bab9b/aio%2Fsrc%2Fapp%2Fapp.component.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/0849a09fd16ac89f20c5418258f81ef7427bab9b/aio%2Fsrc%2Fapp%2Fapp.component.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fsrc%2Fapp%2Fapp.component.spec.ts?ref=0849a09fd16ac89f20c5418258f81ef7427bab9b",
            "patch": "@@ -21,6 +21,7 @@ import { ScrollService } from 'app/shared/scroll.service';\n import { SearchResultsComponent } from 'app/shared/search-results/search-results.component';\n import { SelectComponent } from 'app/shared/select/select.component';\n import { TocItem, TocService } from 'app/shared/toc.service';\n+import { SwUpdatesService } from 'app/sw-updates/sw-updates.service';\n import { of, Subject, timer } from 'rxjs';\n import { first, mapTo } from 'rxjs/operators';\n import { MockLocationService } from 'testing/location.service';\n@@ -853,6 +854,19 @@ describe('AppComponent', () => {\n       });\n     });\n \n+    describe('SW updates', () => {\n+      it('should be enabled when the component is initialized',\n+        inject([SwUpdatesService], (swUpdates: TestSwUpdatesService) => {\n+          swUpdates.disable();\n+          expect(swUpdates.isEnabled).toBeFalse();\n+\n+          const fixture2 = TestBed.createComponent(AppComponent);\n+          fixture2.detectChanges();\n+          expect(swUpdates.isEnabled).toBeTrue();\n+        })\n+      );\n+    });\n+\n     describe('archive redirection', () => {\n       const redirectionPerMode: {[mode: string]: boolean} = {\n         archive: true,\n@@ -1291,6 +1305,7 @@ function createTestingModule(initialUrl: string, mode: string = 'stable') {\n       { provide: LocationService, useFactory: () => mockLocationService },\n       { provide: Logger, useClass: MockLogger },\n       { provide: SearchService, useClass: MockSearchService },\n+      { provide: SwUpdatesService, useClass: TestSwUpdatesService },\n       { provide: Deployment, useFactory: () => {\n         const deployment = new Deployment(mockLocationService as any);\n         deployment.mode = mode;\n@@ -1390,3 +1405,12 @@ class TestHttpClient {\n     return timer(1).pipe(mapTo(data));\n   }\n }\n+\n+type PublicPart<T> = {[K in keyof T]: T[K]};\n+class TestSwUpdatesService implements PublicPart<SwUpdatesService> {\n+  isEnabled = false;\n+\n+  disable() { this.isEnabled = false; }\n+  enable() { this.isEnabled = true; }\n+  ngOnDestroy() { this.disable(); }\n+}"
        },
        {
            "sha": "faa587f3663c2ded3c70d0152268e253e23a34ce",
            "filename": "aio/src/app/app.component.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/0849a09fd16ac89f20c5418258f81ef7427bab9b/aio%2Fsrc%2Fapp%2Fapp.component.ts",
            "raw_url": "https://github.com/angular/angular/raw/0849a09fd16ac89f20c5418258f81ef7427bab9b/aio%2Fsrc%2Fapp%2Fapp.component.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fsrc%2Fapp%2Fapp.component.ts?ref=0849a09fd16ac89f20c5418258f81ef7427bab9b",
            "patch": "@@ -19,6 +19,7 @@ import { Deployment } from 'app/shared/deployment.service';\n import { LocationService } from 'app/shared/location.service';\n import { ScrollService } from 'app/shared/scroll.service';\n import { TocService } from 'app/shared/toc.service';\n+import { SwUpdatesService } from 'app/sw-updates/sw-updates.service';\n import { BehaviorSubject, combineLatest, Observable } from 'rxjs';\n import { first, map } from 'rxjs/operators';\n \n@@ -113,6 +114,7 @@ export class AppComponent implements OnInit {\n     private navigationService: NavigationService,\n     private scrollService: ScrollService,\n     private searchService: SearchService,\n+    private swUpdatesService: SwUpdatesService,\n     private tocService: TocService\n   ) { }\n \n@@ -201,6 +203,9 @@ export class AppComponent implements OnInit {\n       .subscribe(() => this.updateShell());\n \n     this.locationService.currentUrl.subscribe(url => this.currentUrl = url);\n+\n+    // Start listening for SW version update events.\n+    this.swUpdatesService.enable();\n   }\n \n   onDocReady() {"
        },
        {
            "sha": "d5b9fe36aefd514b2a7ad5e857ea53f6be5eec1d",
            "filename": "aio/src/app/app.module.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/0849a09fd16ac89f20c5418258f81ef7427bab9b/aio%2Fsrc%2Fapp%2Fapp.module.ts",
            "raw_url": "https://github.com/angular/angular/raw/0849a09fd16ac89f20c5418258f81ef7427bab9b/aio%2Fsrc%2Fapp%2Fapp.module.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fsrc%2Fapp%2Fapp.module.ts?ref=0849a09fd16ac89f20c5418258f81ef7427bab9b",
            "patch": "@@ -45,7 +45,6 @@ import { WindowToken, windowProvider } from 'app/shared/window';\n import { CustomElementsModule } from 'app/custom-elements/custom-elements.module';\n import { SharedModule } from 'app/shared/shared.module';\n import { ThemeToggleComponent } from 'app/shared/theme-picker/theme-toggle.component';\n-import { SwUpdatesModule } from 'app/sw-updates/sw-updates.module';\n \n import { environment } from '../environments/environment';\n \n@@ -155,7 +154,6 @@ export const svgIconProviders = [\n     MatProgressBarModule,\n     MatSidenavModule,\n     MatToolbarModule,\n-    SwUpdatesModule,\n     SharedModule,\n     ServiceWorkerModule.register(\n         // Make sure service worker is loaded with a TrustedScriptURL"
        },
        {
            "sha": "065f871708c821977cce855d3ff67b5b31261eba",
            "filename": "aio/src/app/sw-updates/sw-updates.module.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 11,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/018af621415707b8e066f5a0a424e61c9fbf66e3/aio%2Fsrc%2Fapp%2Fsw-updates%2Fsw-updates.module.ts",
            "raw_url": "https://github.com/angular/angular/raw/018af621415707b8e066f5a0a424e61c9fbf66e3/aio%2Fsrc%2Fapp%2Fsw-updates%2Fsw-updates.module.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fsrc%2Fapp%2Fsw-updates%2Fsw-updates.module.ts?ref=018af621415707b8e066f5a0a424e61c9fbf66e3",
            "patch": "@@ -1,11 +0,0 @@\n-import { NgModule } from '@angular/core';\n-\n-import { SwUpdatesService } from './sw-updates.service';\n-\n-\n-@NgModule({\n-  providers: [\n-    SwUpdatesService\n-  ]\n-})\n-export class SwUpdatesModule {}"
        },
        {
            "sha": "09b7faddb7f92c0b88ca9f7159eb7bbc7c3e7edf",
            "filename": "aio/src/app/sw-updates/sw-updates.service.spec.ts",
            "status": "modified",
            "additions": 193,
            "deletions": 145,
            "changes": 338,
            "blob_url": "https://github.com/angular/angular/blob/0849a09fd16ac89f20c5418258f81ef7427bab9b/aio%2Fsrc%2Fapp%2Fsw-updates%2Fsw-updates.service.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/0849a09fd16ac89f20c5418258f81ef7427bab9b/aio%2Fsrc%2Fapp%2Fsw-updates%2Fsw-updates.service.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fsrc%2Fapp%2Fsw-updates%2Fsw-updates.service.spec.ts?ref=0849a09fd16ac89f20c5418258f81ef7427bab9b",
            "patch": "@@ -1,7 +1,7 @@\n import { ApplicationRef, ErrorHandler, Injector } from '@angular/core';\n import { discardPeriodicTasks, fakeAsync, tick } from '@angular/core/testing';\n import { SwUpdate } from '@angular/service-worker';\n-import { Subject } from 'rxjs';\n+import { BehaviorSubject, Subject } from 'rxjs';\n \n import { LocationService } from 'app/shared/location.service';\n import { Logger } from 'app/shared/logger.service';\n@@ -41,6 +41,8 @@ describe('SwUpdatesService', () => {\n     service = injector.get(SwUpdatesService);\n     swu = injector.get(SwUpdate) as unknown as MockSwUpdate;\n     checkInterval = (service as any).checkInterval;\n+\n+    service.enable();\n   };\n   const tearDown = () => service.ngOnDestroy();\n   const run = (specFn: VoidFunction, isSwUpdateEnabled = true) => () => {\n@@ -54,212 +56,258 @@ describe('SwUpdatesService', () => {\n     expect(service).toBeTruthy();\n   }));\n \n-  it('should start checking for updates when instantiated (once the app stabilizes)', run(() => {\n-    expect(swu.checkForUpdate).not.toHaveBeenCalled();\n+  describe('when enabled', () => {\n+    it('should start checking for updates when instantiated (once the app stabilizes)', run(() => {\n+      expect(swu.checkForUpdate).not.toHaveBeenCalled();\n \n-    appRef.isStable.next(false);\n-    expect(swu.checkForUpdate).not.toHaveBeenCalled();\n+      appRef.isStable.next(false);\n+      expect(swu.checkForUpdate).not.toHaveBeenCalled();\n \n-    appRef.isStable.next(true);\n-    expect(swu.checkForUpdate).toHaveBeenCalled();\n-  }));\n+      appRef.isStable.next(true);\n+      expect(swu.checkForUpdate).toHaveBeenCalled();\n+    }));\n \n-  it('should periodically check for updates', fakeAsync(run(() => {\n-    appRef.isStable.next(true);\n-    swu.checkForUpdate.calls.reset();\n+    it('should periodically check for updates', fakeAsync(run(() => {\n+      appRef.isStable.next(true);\n+      swu.checkForUpdate.calls.reset();\n \n-    tick(checkInterval);\n-    expect(swu.checkForUpdate).toHaveBeenCalledTimes(1);\n+      tick(checkInterval);\n+      expect(swu.checkForUpdate).toHaveBeenCalledTimes(1);\n \n-    tick(checkInterval);\n-    expect(swu.checkForUpdate).toHaveBeenCalledTimes(2);\n+      tick(checkInterval);\n+      expect(swu.checkForUpdate).toHaveBeenCalledTimes(2);\n \n-    appRef.isStable.next(false);\n+      appRef.isStable.next(false);\n \n-    tick(checkInterval);\n-    expect(swu.checkForUpdate).toHaveBeenCalledTimes(3);\n+      tick(checkInterval);\n+      expect(swu.checkForUpdate).toHaveBeenCalledTimes(3);\n \n-    discardPeriodicTasks();\n-  })));\n+      discardPeriodicTasks();\n+    })));\n \n-  it('should activate available updates immediately', fakeAsync(run(() => {\n-    appRef.isStable.next(true);\n-    expect(swu.activateUpdate).not.toHaveBeenCalled();\n+    it('should activate available updates immediately', fakeAsync(run(() => {\n+      appRef.isStable.next(true);\n+      expect(swu.activateUpdate).not.toHaveBeenCalled();\n \n-    swu.$$availableSubj.next({available: {hash: 'foo'}});\n-    expect(swu.activateUpdate).toHaveBeenCalled();\n-  })));\n+      swu.$$availableSubj.next({available: {hash: 'foo'}});\n+      expect(swu.activateUpdate).toHaveBeenCalled();\n+    })));\n \n-  it('should keep periodically checking for updates even after one is available/activated', fakeAsync(run(() => {\n-    appRef.isStable.next(true);\n-    swu.checkForUpdate.calls.reset();\n+    it('should keep periodically checking for updates even after one is available/activated', fakeAsync(run(() => {\n+      appRef.isStable.next(true);\n+      swu.checkForUpdate.calls.reset();\n \n-    tick(checkInterval);\n-    expect(swu.checkForUpdate).toHaveBeenCalledTimes(1);\n+      tick(checkInterval);\n+      expect(swu.checkForUpdate).toHaveBeenCalledTimes(1);\n \n-    swu.$$availableSubj.next({available: {hash: 'foo'}});\n+      swu.$$availableSubj.next({available: {hash: 'foo'}});\n \n-    tick(checkInterval);\n-    expect(swu.checkForUpdate).toHaveBeenCalledTimes(2);\n+      tick(checkInterval);\n+      expect(swu.checkForUpdate).toHaveBeenCalledTimes(2);\n \n-    tick(checkInterval);\n-    expect(swu.checkForUpdate).toHaveBeenCalledTimes(3);\n+      tick(checkInterval);\n+      expect(swu.checkForUpdate).toHaveBeenCalledTimes(3);\n \n-    discardPeriodicTasks();\n-  })));\n+      discardPeriodicTasks();\n+    })));\n \n-  it('should request a full page navigation when an update has been activated', run(() => {\n-    swu.$$availableSubj.next({available: {hash: 'foo'}});\n-    expect(location.fullPageNavigationNeeded).toHaveBeenCalledTimes(0);\n+    it('should request a full page navigation when an update has been activated', run(() => {\n+      swu.$$availableSubj.next({available: {hash: 'foo'}});\n+      expect(location.fullPageNavigationNeeded).toHaveBeenCalledTimes(0);\n \n-    swu.$$activatedSubj.next({current: {hash: 'bar'}});\n-    expect(location.fullPageNavigationNeeded).toHaveBeenCalledTimes(1);\n+      swu.$$activatedSubj.next({current: {hash: 'bar'}});\n+      expect(location.fullPageNavigationNeeded).toHaveBeenCalledTimes(1);\n \n-    swu.$$availableSubj.next({available: {hash: 'baz'}});\n-    expect(location.fullPageNavigationNeeded).toHaveBeenCalledTimes(1);\n+      swu.$$availableSubj.next({available: {hash: 'baz'}});\n+      expect(location.fullPageNavigationNeeded).toHaveBeenCalledTimes(1);\n \n-    swu.$$activatedSubj.next({current: {hash: 'qux'}});\n-    expect(location.fullPageNavigationNeeded).toHaveBeenCalledTimes(2);\n-  }));\n+      swu.$$activatedSubj.next({current: {hash: 'qux'}});\n+      expect(location.fullPageNavigationNeeded).toHaveBeenCalledTimes(2);\n+    }));\n \n-  it('should request a page reload when an unrecoverable state has been detected', run(() => {\n-    expect(location.reloadPage).toHaveBeenCalledTimes(0);\n+    it('should request a page reload when an unrecoverable state has been detected', run(() => {\n+      expect(location.reloadPage).toHaveBeenCalledTimes(0);\n \n-    swu.$$unrecoverableSubj.next({reason: 'Something bad happened'});\n-    expect(location.reloadPage).toHaveBeenCalledTimes(1);\n+      swu.$$unrecoverableSubj.next({reason: 'Something bad happened'});\n+      expect(location.reloadPage).toHaveBeenCalledTimes(1);\n \n-    swu.$$unrecoverableSubj.next({reason: 'Something worse happened'});\n-    expect(location.reloadPage).toHaveBeenCalledTimes(2);\n-  }));\n+      swu.$$unrecoverableSubj.next({reason: 'Something worse happened'});\n+      expect(location.reloadPage).toHaveBeenCalledTimes(2);\n+    }));\n \n-  it('should notify the `ErrorHandler` when an unrecoverable state has been detected', run(() => {\n-    expect(errorHandler.handleError).not.toHaveBeenCalled();\n+    it('should notify the `ErrorHandler` when an unrecoverable state has been detected', run(() => {\n+      expect(errorHandler.handleError).not.toHaveBeenCalled();\n \n-    swu.$$unrecoverableSubj.next({reason: 'Something bad happened'});\n-    expect(errorHandler.handleError).toHaveBeenCalledBefore(location.reloadPage);\n-    expect(errorHandler.handleError)\n-        .toHaveBeenCalledWith('Unrecoverable state: Something bad happened');\n+      swu.$$unrecoverableSubj.next({reason: 'Something bad happened'});\n+      expect(errorHandler.handleError).toHaveBeenCalledBefore(location.reloadPage);\n+      expect(errorHandler.handleError)\n+          .toHaveBeenCalledWith('Unrecoverable state: Something bad happened');\n \n-    (errorHandler.handleError as jasmine.Spy).calls.reset();\n-    location.reloadPage.calls.reset();\n+      (errorHandler.handleError as jasmine.Spy).calls.reset();\n+      location.reloadPage.calls.reset();\n \n-    swu.$$unrecoverableSubj.next({reason: 'Something worse happened'});\n-    expect(errorHandler.handleError).toHaveBeenCalledBefore(location.reloadPage);\n-    expect(errorHandler.handleError)\n-        .toHaveBeenCalledWith('Unrecoverable state: Something worse happened');\n+      swu.$$unrecoverableSubj.next({reason: 'Something worse happened'});\n+      expect(errorHandler.handleError).toHaveBeenCalledBefore(location.reloadPage);\n+      expect(errorHandler.handleError)\n+          .toHaveBeenCalledWith('Unrecoverable state: Something worse happened');\n \n-  }));\n+    }));\n \n-  describe('when `SwUpdate` is not enabled', () => {\n-    const runDeactivated = (specFn: VoidFunction) => run(specFn, false);\n+    describe('when `SwUpdate` is not enabled', () => {\n+      const runDeactivated = (specFn: VoidFunction) => run(specFn, false);\n \n-    it('should not check for updates', fakeAsync(runDeactivated(() => {\n-      appRef.isStable.next(true);\n+      it('should not check for updates', fakeAsync(runDeactivated(() => {\n+        appRef.isStable.next(true);\n \n-      tick(checkInterval);\n-      tick(checkInterval);\n+        tick(checkInterval);\n+        tick(checkInterval);\n \n-      swu.$$availableSubj.next({available: {hash: 'foo'}});\n-      swu.$$activatedSubj.next({current: {hash: 'bar'}});\n+        swu.$$availableSubj.next({available: {hash: 'foo'}});\n+        swu.$$activatedSubj.next({current: {hash: 'bar'}});\n \n-      tick(checkInterval);\n-      tick(checkInterval);\n+        tick(checkInterval);\n+        tick(checkInterval);\n \n-      expect(swu.checkForUpdate).not.toHaveBeenCalled();\n-    })));\n+        expect(swu.checkForUpdate).not.toHaveBeenCalled();\n+      })));\n \n-    it('should not activate available updates', fakeAsync(runDeactivated(() => {\n-      swu.$$availableSubj.next({available: {hash: 'foo'}});\n-      expect(swu.activateUpdate).not.toHaveBeenCalled();\n-    })));\n+      it('should not activate available updates', fakeAsync(runDeactivated(() => {\n+        swu.$$availableSubj.next({available: {hash: 'foo'}});\n+        expect(swu.activateUpdate).not.toHaveBeenCalled();\n+      })));\n \n-    it('should never request a full page navigation', runDeactivated(() => {\n-      swu.$$availableSubj.next({available: {hash: 'foo'}});\n-      swu.$$activatedSubj.next({current: {hash: 'bar'}});\n-      swu.$$availableSubj.next({available: {hash: 'baz'}});\n-      swu.$$activatedSubj.next({current: {hash: 'qux'}});\n+      it('should never request a full page navigation', runDeactivated(() => {\n+        swu.$$availableSubj.next({available: {hash: 'foo'}});\n+        swu.$$activatedSubj.next({current: {hash: 'bar'}});\n+        swu.$$availableSubj.next({available: {hash: 'baz'}});\n+        swu.$$activatedSubj.next({current: {hash: 'qux'}});\n \n-      expect(location.fullPageNavigationNeeded).not.toHaveBeenCalled();\n-    }));\n+        expect(location.fullPageNavigationNeeded).not.toHaveBeenCalled();\n+      }));\n \n-    it('should never request a page reload', runDeactivated(() => {\n-      swu.$$unrecoverableSubj.next({reason: 'Something bad happened'});\n-      swu.$$unrecoverableSubj.next({reason: 'Something worse happened'});\n+      it('should never request a page reload', runDeactivated(() => {\n+        swu.$$unrecoverableSubj.next({reason: 'Something bad happened'});\n+        swu.$$unrecoverableSubj.next({reason: 'Something worse happened'});\n \n-      expect(errorHandler.handleError).not.toHaveBeenCalled();\n-      expect(location.reloadPage).not.toHaveBeenCalled();\n-    }));\n-  });\n+        expect(errorHandler.handleError).not.toHaveBeenCalled();\n+        expect(location.reloadPage).not.toHaveBeenCalled();\n+      }));\n+    });\n \n-  describe('when destroyed', () => {\n-    it('should not schedule a new check for update (after current check)', fakeAsync(run(() => {\n-      appRef.isStable.next(true);\n-      expect(swu.checkForUpdate).toHaveBeenCalled();\n+    describe('and then disabled', () => {\n+      it('should not schedule a new check for update (after current check)', fakeAsync(run(() => {\n+        appRef.isStable.next(true);\n+        expect(swu.checkForUpdate).toHaveBeenCalled();\n \n-      service.ngOnDestroy();\n-      swu.checkForUpdate.calls.reset();\n+        service.disable();\n+        swu.checkForUpdate.calls.reset();\n \n-      tick(checkInterval);\n-      tick(checkInterval);\n+        tick(checkInterval);\n+        tick(checkInterval);\n \n-      expect(swu.checkForUpdate).not.toHaveBeenCalled();\n-    })));\n+        expect(swu.checkForUpdate).not.toHaveBeenCalled();\n+      })));\n \n-    it('should not schedule a new check for update (after activating an update)', fakeAsync(run(() => {\n-      appRef.isStable.next(true);\n-      expect(swu.checkForUpdate).toHaveBeenCalled();\n+      it('should not schedule a new check for update (after activating an update)', fakeAsync(run(() => {\n+        appRef.isStable.next(true);\n+        expect(swu.checkForUpdate).toHaveBeenCalled();\n \n-      service.ngOnDestroy();\n-      swu.checkForUpdate.calls.reset();\n+        service.disable();\n+        swu.checkForUpdate.calls.reset();\n \n-      swu.$$availableSubj.next({available: {hash: 'foo'}});\n-      swu.$$activatedSubj.next({current: {hash: 'baz'}});\n+        swu.$$availableSubj.next({available: {hash: 'foo'}});\n+        swu.$$activatedSubj.next({current: {hash: 'baz'}});\n \n-      tick(checkInterval);\n-      tick(checkInterval);\n+        tick(checkInterval);\n+        tick(checkInterval);\n \n-      expect(swu.checkForUpdate).not.toHaveBeenCalled();\n-    })));\n+        expect(swu.checkForUpdate).not.toHaveBeenCalled();\n+      })));\n \n-    it('should not activate available updates', fakeAsync(run(() => {\n-      service.ngOnDestroy();\n-      swu.$$availableSubj.next({available: {hash: 'foo'}});\n+      it('should not activate available updates', fakeAsync(run(() => {\n+        service.disable();\n+        swu.$$availableSubj.next({available: {hash: 'foo'}});\n \n-      expect(swu.activateUpdate).not.toHaveBeenCalled();\n-    })));\n+        expect(swu.activateUpdate).not.toHaveBeenCalled();\n+      })));\n \n-    it('should stop requesting full page navigations when updates are activated', run(() => {\n-      swu.$$availableSubj.next({available: {hash: 'foo'}});\n-      swu.$$activatedSubj.next({current: {hash: 'bar'}});\n-      expect(location.fullPageNavigationNeeded).toHaveBeenCalledTimes(1);\n+      it('should stop requesting full page navigations when updates are activated', run(() => {\n+        swu.$$availableSubj.next({available: {hash: 'foo'}});\n+        swu.$$activatedSubj.next({current: {hash: 'bar'}});\n+        expect(location.fullPageNavigationNeeded).toHaveBeenCalledTimes(1);\n \n-      service.ngOnDestroy();\n-      location.fullPageNavigationNeeded.calls.reset();\n+        service.disable();\n+        location.fullPageNavigationNeeded.calls.reset();\n \n-      swu.$$availableSubj.next({available: {hash: 'baz'}});\n-      swu.$$activatedSubj.next({current: {hash: 'qux'}});\n-      expect(location.fullPageNavigationNeeded).not.toHaveBeenCalled();\n-    }));\n+        swu.$$availableSubj.next({available: {hash: 'baz'}});\n+        swu.$$activatedSubj.next({current: {hash: 'qux'}});\n+        expect(location.fullPageNavigationNeeded).not.toHaveBeenCalled();\n+      }));\n \n-    it('should stop requesting page reloads when unrecoverable states are detected', run(() => {\n-      swu.$$unrecoverableSubj.next({reason: 'Something bad happened'});\n-      expect(errorHandler.handleError).toHaveBeenCalledTimes(1);\n-      expect(location.reloadPage).toHaveBeenCalledTimes(1);\n+      it('should stop requesting page reloads when unrecoverable states are detected', run(() => {\n+        swu.$$unrecoverableSubj.next({reason: 'Something bad happened'});\n+        expect(errorHandler.handleError).toHaveBeenCalledTimes(1);\n+        expect(location.reloadPage).toHaveBeenCalledTimes(1);\n \n-      service.ngOnDestroy();\n-      (errorHandler.handleError as jasmine.Spy).calls.reset();\n-      location.reloadPage.calls.reset();\n+        service.disable();\n+        (errorHandler.handleError as jasmine.Spy).calls.reset();\n+        location.reloadPage.calls.reset();\n \n-      swu.$$unrecoverableSubj.next({reason: 'Something worse happened'});\n-      expect(errorHandler.handleError).not.toHaveBeenCalled();\n-      expect(location.reloadPage).not.toHaveBeenCalled();\n+        swu.$$unrecoverableSubj.next({reason: 'Something worse happened'});\n+        expect(errorHandler.handleError).not.toHaveBeenCalled();\n+        expect(location.reloadPage).not.toHaveBeenCalled();\n+      }));\n+\n+      describe('and then enabled again', () => {\n+        it('should start scheduling new checks for updates again', fakeAsync(run(() => {\n+          appRef.isStable.next(true);\n+          service.disable();\n+          service.enable();\n+          swu.checkForUpdate.calls.reset();\n+\n+          tick(checkInterval);\n+\n+          expect(swu.checkForUpdate).toHaveBeenCalled();\n+        })));\n+\n+        it('should start scheduling new checks for updates (after activating an update) again', fakeAsync(run(() => {\n+          appRef.isStable.next(true);\n+          service.disable();\n+          service.enable();\n+          swu.checkForUpdate.calls.reset();\n+\n+          swu.$$availableSubj.next({available: {hash: 'foo'}});\n+          swu.$$activatedSubj.next({current: {hash: 'baz'}});\n+          tick(checkInterval);\n+\n+          expect(swu.checkForUpdate).toHaveBeenCalled();\n+        })));\n+\n+        it('should start activating available updates again', fakeAsync(run(() => {\n+          service.disable();\n+          service.enable();\n+\n+          swu.$$availableSubj.next({available: {hash: 'foo'}});\n+\n+          expect(swu.activateUpdate).toHaveBeenCalled();\n+        })));\n+      });\n+    });\n+  });\n+\n+  describe('when destroyed', () => {\n+    it('should disable itself', run(() => {\n+      const disableSpy = spyOn(service, 'disable');\n+\n+      service.ngOnDestroy();\n+      expect(disableSpy).toHaveBeenCalledOnceWith();\n     }));\n   });\n });\n \n // Mocks\n class MockApplicationRef {\n-  isStable = new Subject<boolean>();\n+  isStable = new BehaviorSubject(false);\n }\n \n class MockSwUpdate {"
        },
        {
            "sha": "94f62fdae173cef72a613ea0963ac37c79837e8a",
            "filename": "aio/src/app/sw-updates/sw-updates.service.ts",
            "status": "modified",
            "additions": 23,
            "deletions": 17,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/0849a09fd16ac89f20c5418258f81ef7427bab9b/aio%2Fsrc%2Fapp%2Fsw-updates%2Fsw-updates.service.ts",
            "raw_url": "https://github.com/angular/angular/raw/0849a09fd16ac89f20c5418258f81ef7427bab9b/aio%2Fsrc%2Fapp%2Fsw-updates%2Fsw-updates.service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/aio%2Fsrc%2Fapp%2Fsw-updates%2Fsw-updates.service.ts?ref=0849a09fd16ac89f20c5418258f81ef7427bab9b",
            "patch": "@@ -11,62 +11,68 @@ import { Logger } from 'app/shared/logger.service';\n  * SwUpdatesService\n  *\n  * @description\n- * 1. Checks for available ServiceWorker updates once instantiated.\n- * 2. Re-checks every 6 hours.\n- * 3. Whenever an update is available, it activates the update.\n+ * While enabled, this service will:\n+ * 1. Check for available ServiceWorker updates every 6 hours.\n+ * 2. Activate an update as soon as one is available.\n  */\n-@Injectable()\n+@Injectable({providedIn: 'root'})\n export class SwUpdatesService implements OnDestroy {\n   private checkInterval = 1000 * 60 * 60 * 6;  // 6 hours\n-  private onDestroy = new Subject<void>();\n+  private onDisable = new Subject<void>();\n \n   constructor(\n-      appRef: ApplicationRef, errorHandler: ErrorHandler, location: LocationService,\n-      private logger: Logger, private swu: SwUpdate) {\n-    if (!swu.isEnabled) {\n+      private appRef: ApplicationRef, private errorHandler: ErrorHandler,\n+      private location: LocationService, private logger: Logger, private swu: SwUpdate) {}\n+\n+  disable() {\n+    this.onDisable.next();\n+  }\n+\n+  enable() {\n+    if (!this.swu.isEnabled) {\n       return;\n     }\n \n     // Periodically check for updates (after the app is stabilized).\n-    const appIsStable = appRef.isStable.pipe(first(v => v));\n+    const appIsStable = this.appRef.isStable.pipe(first(v => v));\n     concat(appIsStable, interval(this.checkInterval))\n         .pipe(\n             tap(() => this.log('Checking for update...')),\n-            takeUntil(this.onDestroy),\n+            takeUntil(this.onDisable),\n         )\n         .subscribe(() => this.swu.checkForUpdate());\n \n     // Activate available updates.\n     this.swu.available\n         .pipe(\n             tap(evt => this.log(`Update available: ${JSON.stringify(evt)}`)),\n-            takeUntil(this.onDestroy),\n+            takeUntil(this.onDisable),\n         )\n         .subscribe(() => this.swu.activateUpdate());\n \n     // Request a full page navigation once an update has been activated.\n     this.swu.activated\n         .pipe(\n             tap(evt => this.log(`Update activated: ${JSON.stringify(evt)}`)),\n-            takeUntil(this.onDestroy),\n+            takeUntil(this.onDisable),\n         )\n-        .subscribe(() => location.fullPageNavigationNeeded());\n+        .subscribe(() => this.location.fullPageNavigationNeeded());\n \n     // Request an immediate page reload once an unrecoverable state has been detected.\n     this.swu.unrecoverable\n         .pipe(\n             tap(evt => {\n               const errorMsg = `Unrecoverable state: ${evt.reason}`;\n-              errorHandler.handleError(errorMsg);\n+              this.errorHandler.handleError(errorMsg);\n               this.log(`${errorMsg}\\nReloading...`);\n             }),\n-            takeUntil(this.onDestroy),\n+            takeUntil(this.onDisable),\n         )\n-        .subscribe(() => location.reloadPage());\n+        .subscribe(() => this.location.reloadPage());\n   }\n \n   ngOnDestroy() {\n-    this.onDestroy.next();\n+    this.disable();\n   }\n \n   private log(message: string) {"
        }
    ],
    "stats": {
        "total": 420,
        "additions": 245,
        "deletions": 175
    }
}