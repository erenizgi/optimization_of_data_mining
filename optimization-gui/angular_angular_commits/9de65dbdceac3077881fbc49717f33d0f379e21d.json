{
    "author": "petebacondarwin",
    "message": "fix(compiler): should not break a text token on a non-valid start tag (#42605)\n\nPreviously the lexer would break out of consuming a text token if it contains\na `<` character. Then if the next characters did not indicate an HTML syntax\nitem, such as a tag or comment, then it would start a new text token. These\nconsecutive text tokens are then merged into each other in a post tokenization\nstep.\n\nIn the commit before this, interpolation no longer leaks across text tokens.\nThe approach given above to handling `<` characters that appear in text is\nno longer adequate. This change ensures that the lexer only breaks out of\na text token if the next characters indicate a valid HTML tag, comment,\nCDATA etc.\n\nPR Close #42605",
    "sha": "9de65dbdceac3077881fbc49717f33d0f379e21d",
    "files": [
        {
            "sha": "8d832f4d2a21b58ba65aa01eca62509ccc2f7763",
            "filename": "packages/compiler/src/ml_parser/lexer.ts",
            "status": "modified",
            "additions": 20,
            "deletions": 1,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/9de65dbdceac3077881fbc49717f33d0f379e21d/packages%2Fcompiler%2Fsrc%2Fml_parser%2Flexer.ts",
            "raw_url": "https://github.com/angular/angular/raw/9de65dbdceac3077881fbc49717f33d0f379e21d/packages%2Fcompiler%2Fsrc%2Fml_parser%2Flexer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fml_parser%2Flexer.ts?ref=9de65dbdceac3077881fbc49717f33d0f379e21d",
            "patch": "@@ -721,7 +721,7 @@ class _Tokenizer {\n   }\n \n   private _isTextEnd(): boolean {\n-    if (this._cursor.peek() === chars.$LT || this._cursor.peek() === chars.$EOF) {\n+    if (this._isTagStart() || this._cursor.peek() === chars.$EOF) {\n       return true;\n     }\n \n@@ -740,6 +740,25 @@ class _Tokenizer {\n     return false;\n   }\n \n+  /**\n+   * Returns true if the current cursor is pointing to the start of a tag\n+   * (opening/closing/comments/cdata/etc).\n+   */\n+  private _isTagStart(): boolean {\n+    if (this._cursor.peek() === chars.$LT) {\n+      // We assume that `<` followed by whitespace is not the start of an HTML element.\n+      const tmp = this._cursor.clone();\n+      tmp.advance();\n+      // If the next character is alphabetic, ! nor / then it is a tag start\n+      const code = tmp.peek();\n+      if ((chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||\n+          code === chars.$SLASH || code === chars.$BANG) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n   private _readUntil(char: number): string {\n     const start = this._cursor.clone();\n     this._attemptUntilChar(char);"
        },
        {
            "sha": "5c795ed95964a0ff07450fd6c4dc80a86f49551d",
            "filename": "packages/compiler/test/ml_parser/lexer_spec.ts",
            "status": "modified",
            "additions": 37,
            "deletions": 1,
            "changes": 38,
            "blob_url": "https://github.com/angular/angular/blob/9de65dbdceac3077881fbc49717f33d0f379e21d/packages%2Fcompiler%2Ftest%2Fml_parser%2Flexer_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/9de65dbdceac3077881fbc49717f33d0f379e21d/packages%2Fcompiler%2Ftest%2Fml_parser%2Flexer_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fml_parser%2Flexer_spec.ts?ref=9de65dbdceac3077881fbc49717f33d0f379e21d",
            "patch": "@@ -612,7 +612,7 @@ import {ParseLocation, ParseSourceFile, ParseSourceSpan} from '../../src/parse_u\n         ]);\n       });\n \n-      it('should parse valid start tag in interpolation', () => {\n+      it('should break out of interpolation in text token on valid start tag', () => {\n         expect(tokenizeAndHumanizeParts('{{ a <b && c > d }}')).toEqual([\n           [lex.TokenType.TEXT, '{{ a '],\n           [lex.TokenType.TAG_OPEN_START, '', 'b'],\n@@ -624,6 +624,42 @@ import {ParseLocation, ParseSourceFile, ParseSourceSpan} from '../../src/parse_u\n         ]);\n       });\n \n+      it('should break out of interpolation in text token on valid comment', () => {\n+        expect(tokenizeAndHumanizeParts('{{ a }<!---->}')).toEqual([\n+          [lex.TokenType.TEXT, '{{ a }'],\n+          [lex.TokenType.COMMENT_START],\n+          [lex.TokenType.RAW_TEXT, ''],\n+          [lex.TokenType.COMMENT_END],\n+          [lex.TokenType.TEXT, '}'],\n+          [lex.TokenType.EOF],\n+        ]);\n+      });\n+\n+      it('should break out of interpolation in text token on valid CDATA', () => {\n+        expect(tokenizeAndHumanizeParts('{{ a }<![CDATA[]]>}')).toEqual([\n+          [lex.TokenType.TEXT, '{{ a }'],\n+          [lex.TokenType.CDATA_START],\n+          [lex.TokenType.RAW_TEXT, ''],\n+          [lex.TokenType.CDATA_END],\n+          [lex.TokenType.TEXT, '}'],\n+          [lex.TokenType.EOF],\n+        ]);\n+      });\n+\n+      it('should ignore invalid start tag in interpolation', () => {\n+        // Note that if the `<=` is considered an \"end of text\" then the following `{` would\n+        // incorrectly be considered part of an ICU.\n+        expect(tokenizeAndHumanizeParts(`<code>{{'<={'}}</code>`, {tokenizeExpansionForms: true}))\n+            .toEqual([\n+              [lex.TokenType.TAG_OPEN_START, '', 'code'],\n+              [lex.TokenType.TAG_OPEN_END],\n+              [lex.TokenType.TEXT, '{{\\'<={\\'}}'],\n+              [lex.TokenType.TAG_CLOSE, '', 'code'],\n+              [lex.TokenType.EOF],\n+            ]);\n+      });\n+\n+\n       it('should parse start tags quotes in place of an attribute name as text', () => {\n         expect(tokenizeAndHumanizeParts('<t \">')).toEqual([\n           [lex.TokenType.INCOMPLETE_TAG_OPEN, '', 't'],"
        }
    ],
    "stats": {
        "total": 59,
        "additions": 57,
        "deletions": 2
    }
}