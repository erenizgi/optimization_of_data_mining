{
    "author": "crisbeto",
    "message": "fix(compiler): handle strings inside bindings that contain binding characters (#39826)\n\nCurrently the compiler treats something like `{{  '{{a}}' }}` as a nested\nbinding and throws an error, because it doesn't account for quotes\nwhen it looks for binding characters. These changes add a bit of\nlogic to skip over text inside quotes when parsing.\n\nFixes #39601.\n\nPR Close #39826",
    "sha": "dc6d40e5bcf7d4dab61776b94a83024a0943f3b3",
    "files": [
        {
            "sha": "feb3c3c3c78b9e3767c7eecdb24dc8af222b2ca6",
            "filename": "packages/compiler/src/expression_parser/parser.ts",
            "status": "modified",
            "additions": 32,
            "deletions": 3,
            "changes": 35,
            "blob_url": "https://github.com/angular/angular/blob/dc6d40e5bcf7d4dab61776b94a83024a0943f3b3/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "raw_url": "https://github.com/angular/angular/raw/dc6d40e5bcf7d4dab61776b94a83024a0943f3b3/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts?ref=dc6d40e5bcf7d4dab61776b94a83024a0943f3b3",
            "patch": "@@ -244,10 +244,10 @@ export class Parser {\n \n         atInterpolation = true;\n       } else {\n-        // parse from starting {{ to ending }}\n+        // parse from starting {{ to ending }} while ignoring content inside quotes.\n         const fullStart = i;\n         const exprStart = fullStart + interpStart.length;\n-        const exprEnd = input.indexOf(interpEnd, exprStart);\n+        const exprEnd = this._getExpressiondEndIndex(input, interpEnd, exprStart);\n         if (exprEnd === -1) {\n           // Could not find the end of the interpolation; do not parse an expression.\n           // Instead we should extend the content on the last raw string.\n@@ -340,10 +340,39 @@ export class Parser {\n \n     return errLocation.length;\n   }\n+\n+  /**\n+   * Finds the index of the end of an interpolation expression\n+   * while ignoring comments and quoted content.\n+   */\n+  private _getExpressiondEndIndex(input: string, expressionEnd: string, start: number): number {\n+    let currentQuote: string|null = null;\n+    let escapeCount = 0;\n+    for (let i = start; i < input.length; i++) {\n+      const char = input[i];\n+      // Skip the characters inside quotes. Note that we only care about the\n+      // outer-most quotes matching up and we need to account for escape characters.\n+      if (isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) &&\n+          escapeCount % 2 === 0) {\n+        currentQuote = currentQuote === null ? char : null;\n+      } else if (currentQuote === null) {\n+        if (input.startsWith(expressionEnd, i)) {\n+          return i;\n+        }\n+        // Nothing else in the expression matters after we've\n+        // hit a comment so look directly for the end token.\n+        if (input.startsWith('//', i)) {\n+          return input.indexOf(expressionEnd, i);\n+        }\n+      }\n+      escapeCount = char === '\\\\' ? escapeCount + 1 : 0;\n+    }\n+    return -1;\n+  }\n }\n \n export class IvyParser extends Parser {\n-  simpleExpressionChecker = IvySimpleExpressionChecker;  //\n+  simpleExpressionChecker = IvySimpleExpressionChecker;\n }\n \n /** Describes a stateful context an expression parser is in. */"
        },
        {
            "sha": "2acde1d89fa22798afa2c41251263eced6a6a094",
            "filename": "packages/compiler/test/expression_parser/parser_spec.ts",
            "status": "modified",
            "additions": 39,
            "deletions": 1,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/dc6d40e5bcf7d4dab61776b94a83024a0943f3b3/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/dc6d40e5bcf7d4dab61776b94a83024a0943f3b3/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts?ref=dc6d40e5bcf7d4dab61776b94a83024a0943f3b3",
            "patch": "@@ -838,6 +838,37 @@ describe('parser', () => {\n       expect(ast.expressions[0].name).toEqual('a');\n     });\n \n+    it('should parse interpolation inside quotes', () => {\n+      const ast = parseInterpolation('\"{{a}}\"')!.ast as Interpolation;\n+      expect(ast.strings).toEqual(['\"', '\"']);\n+      expect(ast.expressions.length).toEqual(1);\n+      expect(ast.expressions[0].name).toEqual('a');\n+    });\n+\n+    it('should parse interpolation with interpolation characters inside quotes', () => {\n+      checkInterpolation('{{\"{{a}}\"}}', '{{ \"{{a}}\" }}');\n+      checkInterpolation('{{\"{{\"}}', '{{ \"{{\" }}');\n+      checkInterpolation('{{\"}}\"}}', '{{ \"}}\" }}');\n+      checkInterpolation('{{\"{\"}}', '{{ \"{\" }}');\n+      checkInterpolation('{{\"}\"}}', '{{ \"}\" }}');\n+    });\n+\n+    it('should parse interpolation with escaped quotes', () => {\n+      checkInterpolation(`{{'It\\\\'s just Angular'}}`, `{{ \"It's just Angular\" }}`);\n+      checkInterpolation(`{{'It\\\\'s {{ just Angular'}}`, `{{ \"It's {{ just Angular\" }}`);\n+      checkInterpolation(`{{'It\\\\'s }} just Angular'}}`, `{{ \"It's }} just Angular\" }}`);\n+    });\n+\n+    it('should parse interpolation with escaped backslashes', () => {\n+      checkInterpolation(`{{foo.split('\\\\\\\\')}}`, `{{ foo.split(\"\\\\\") }}`);\n+      checkInterpolation(`{{foo.split('\\\\\\\\\\\\\\\\')}}`, `{{ foo.split(\"\\\\\\\\\") }}`);\n+      checkInterpolation(`{{foo.split('\\\\\\\\\\\\\\\\\\\\\\\\')}}`, `{{ foo.split(\"\\\\\\\\\\\\\") }}`);\n+    });\n+\n+    it('should not parse interpolation with mismatching quotes', () => {\n+      expect(parseInterpolation(`{{ \"{{a}}' }}`)).toBeNull();\n+    });\n+\n     it('should parse prefix/suffix with multiple interpolation', () => {\n       const originalExp = 'before {{ a }} middle {{ b }} after';\n       const ast = parseInterpolation(originalExp)!.ast;\n@@ -895,6 +926,10 @@ describe('parser', () => {\n       it('should retain // in nested, unterminated strings', () => {\n         checkInterpolation(`{{ \"a\\'b\\`\" //comment}}`, `{{ \"a\\'b\\`\" }}`);\n       });\n+\n+      it('should ignore quotes inside a comment', () => {\n+        checkInterpolation(`\"{{name // \" }}\"`, `\"{{ name }}\"`);\n+      });\n     });\n   });\n \n@@ -1075,8 +1110,11 @@ function parseSimpleBindingIvy(\n }\n \n function checkInterpolation(exp: string, expected?: string) {\n-  const ast = parseInterpolation(exp)!;\n+  const ast = parseInterpolation(exp);\n   if (expected == null) expected = exp;\n+  if (ast === null) {\n+    throw Error(`Failed to parse expression \"${exp}\"`);\n+  }\n   expect(unparse(ast)).toEqual(expected);\n   validate(ast);\n }"
        },
        {
            "sha": "69a0c3e75441b6fb7c840b7fb6cf81c10e337865",
            "filename": "packages/compiler/test/template_parser/template_parser_spec.ts",
            "status": "modified",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/angular/angular/blob/dc6d40e5bcf7d4dab61776b94a83024a0943f3b3/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Ftemplate_parser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/dc6d40e5bcf7d4dab61776b94a83024a0943f3b3/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Ftemplate_parser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Ftemplate_parser%2Ftemplate_parser_spec.ts?ref=dc6d40e5bcf7d4dab61776b94a83024a0943f3b3",
            "patch": "@@ -540,6 +540,54 @@ describe('TemplateParser', () => {\n       expect(humanizeTplAst(parse('{{a}}', []))).toEqual([[BoundTextAst, '{{ a }}']]);\n     });\n \n+    it('should parse bound text nodes inside quotes', () => {\n+      expect(humanizeTplAst(parse('\"{{a}}\"', []))).toEqual([[BoundTextAst, '\"{{ a }}\"']]);\n+    });\n+\n+    it('should parse bound text nodes with interpolations inside quotes', () => {\n+      expect(humanizeTplAst(parse('{{ \"{{a}}\" }}', []))).toEqual([[BoundTextAst, '{{ \"{{a}}\" }}']]);\n+      expect(humanizeTplAst(parse('{{\"{{\"}}', []))).toEqual([[BoundTextAst, '{{ \"{{\" }}']]);\n+      expect(humanizeTplAst(parse('{{\"}}\"}}', []))).toEqual([[BoundTextAst, '{{ \"}}\" }}']]);\n+      expect(humanizeTplAst(parse('{{\"{\"}}', []))).toEqual([[BoundTextAst, '{{ \"{\" }}']]);\n+      expect(humanizeTplAst(parse('{{\"}\"}}', []))).toEqual([[BoundTextAst, '{{ \"}\" }}']]);\n+    });\n+\n+    it('should parse bound text nodes with escaped quotes', () => {\n+      expect(humanizeTplAst(parse(`{{'It\\\\'s just Angular'}}`, []))).toEqual([\n+        [BoundTextAst, `{{ \"It's just Angular\" }}`]\n+      ]);\n+\n+      expect(humanizeTplAst(parse(`{{'It\\\\'s {{ just Angular'}}`, []))).toEqual([\n+        [BoundTextAst, `{{ \"It's {{ just Angular\" }}`]\n+      ]);\n+\n+      expect(humanizeTplAst(parse(`{{'It\\\\'s }} just Angular'}}`, []))).toEqual([\n+        [BoundTextAst, `{{ \"It's }} just Angular\" }}`]\n+      ]);\n+    });\n+\n+    it('should not parse bound text nodes with mismatching quotes', () => {\n+      expect(humanizeTplAst(parse(`{{ \"{{a}}' }}`, []))).toEqual([[TextAst, `{{ \"{{a}}' }}`]]);\n+    });\n+\n+    it('should parse interpolation with escaped backslashes', () => {\n+      expect(humanizeTplAst(parse(`{{foo.split('\\\\\\\\')}}`, []))).toEqual([\n+        [BoundTextAst, `{{ foo.split(\"\\\\\") }}`]\n+      ]);\n+      expect(humanizeTplAst(parse(`{{foo.split('\\\\\\\\\\\\\\\\')}}`, []))).toEqual([\n+        [BoundTextAst, `{{ foo.split(\"\\\\\\\\\") }}`]\n+      ]);\n+      expect(humanizeTplAst(parse(`{{foo.split('\\\\\\\\\\\\\\\\\\\\\\\\')}}`, []))).toEqual([\n+        [BoundTextAst, `{{ foo.split(\"\\\\\\\\\\\\\") }}`]\n+      ]);\n+    });\n+\n+    it('should ignore quotes inside a comment', () => {\n+      expect(humanizeTplAst(parse(`\"{{name // \" }}\"`, []))).toEqual([\n+        [BoundTextAst, `\"{{ name }}\"`]\n+      ]);\n+    });\n+\n     it('should parse with custom interpolation config',\n        inject([TemplateParser], (parser: TemplateParser) => {\n          const component = CompileDirectiveMetadata.create({"
        },
        {
            "sha": "952006c5a9a2a46583d3f596afea0586291e2e34",
            "filename": "packages/core/test/acceptance/text_spec.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/dc6d40e5bcf7d4dab61776b94a83024a0943f3b3/packages%2Fcore%2Ftest%2Facceptance%2Ftext_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/dc6d40e5bcf7d4dab61776b94a83024a0943f3b3/packages%2Fcore%2Ftest%2Facceptance%2Ftext_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Ftext_spec.ts?ref=dc6d40e5bcf7d4dab61776b94a83024a0943f3b3",
            "patch": "@@ -171,4 +171,18 @@ describe('text instructions', () => {\n     // `Symbol(hello)_p.sc8s398cplk`, whereas the native one is `Symbol(hello)`.\n     expect(fixture.nativeElement.textContent).toContain('Symbol(hello)');\n   });\n+\n+  it('should handle binding syntax used inside quoted text', () => {\n+    @Component({\n+      template: `{{'Interpolations look like {{this}}'}}`,\n+    })\n+    class App {\n+    }\n+\n+    TestBed.configureTestingModule({declarations: [App]});\n+    const fixture = TestBed.createComponent(App);\n+    fixture.detectChanges();\n+\n+    expect(fixture.nativeElement.textContent).toBe('Interpolations look like {{this}}');\n+  });\n });"
        }
    ],
    "stats": {
        "total": 137,
        "additions": 133,
        "deletions": 4
    }
}