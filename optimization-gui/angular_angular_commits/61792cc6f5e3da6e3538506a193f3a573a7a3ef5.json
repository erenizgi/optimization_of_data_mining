{
    "author": "ngwattcos",
    "message": "refactor(compiler): remove unused files in css_parser/ and corresponding spec tests (#37463)\n\nReasons for change:\n- css_parser, css_ast, and css_lexer are not used anywhere and there are\nno entry points from compiler.ts\n- tested by building Angular and building/running aio with build-local\n\nPR Close #37463",
    "sha": "61792cc6f5e3da6e3538506a193f3a573a7a3ef5",
    "files": [
        {
            "sha": "b36b8195ab5ba9b9ce76403ddc2e2e4813e651bf",
            "filename": "packages/compiler/src/css_parser/css_ast.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 264,
            "changes": 264,
            "blob_url": "https://github.com/angular/angular/blob/d8e06f96766d65d333b533f9884cc123c48321e4/packages%2Fcompiler%2Fsrc%2Fcss_parser%2Fcss_ast.ts",
            "raw_url": "https://github.com/angular/angular/raw/d8e06f96766d65d333b533f9884cc123c48321e4/packages%2Fcompiler%2Fsrc%2Fcss_parser%2Fcss_ast.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fcss_parser%2Fcss_ast.ts?ref=d8e06f96766d65d333b533f9884cc123c48321e4",
            "patch": "@@ -1,264 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ParseLocation, ParseSourceSpan} from '../parse_util';\n-\n-import {CssToken, CssTokenType} from './css_lexer';\n-\n-export enum BlockType {\n-  Import,\n-  Charset,\n-  Namespace,\n-  Supports,\n-  Keyframes,\n-  MediaQuery,\n-  Selector,\n-  FontFace,\n-  Page,\n-  Document,\n-  Viewport,\n-  Unsupported\n-}\n-\n-export interface CssAstVisitor {\n-  visitCssValue(ast: CssStyleValueAst, context?: any): any;\n-  visitCssInlineRule(ast: CssInlineRuleAst, context?: any): any;\n-  visitCssAtRulePredicate(ast: CssAtRulePredicateAst, context?: any): any;\n-  visitCssKeyframeRule(ast: CssKeyframeRuleAst, context?: any): any;\n-  visitCssKeyframeDefinition(ast: CssKeyframeDefinitionAst, context?: any): any;\n-  visitCssMediaQueryRule(ast: CssMediaQueryRuleAst, context?: any): any;\n-  visitCssSelectorRule(ast: CssSelectorRuleAst, context?: any): any;\n-  visitCssSelector(ast: CssSelectorAst, context?: any): any;\n-  visitCssSimpleSelector(ast: CssSimpleSelectorAst, context?: any): any;\n-  visitCssPseudoSelector(ast: CssPseudoSelectorAst, context?: any): any;\n-  visitCssDefinition(ast: CssDefinitionAst, context?: any): any;\n-  visitCssBlock(ast: CssBlockAst, context?: any): any;\n-  visitCssStylesBlock(ast: CssStylesBlockAst, context?: any): any;\n-  visitCssStyleSheet(ast: CssStyleSheetAst, context?: any): any;\n-  visitCssUnknownRule(ast: CssUnknownRuleAst, context?: any): any;\n-  visitCssUnknownTokenList(ast: CssUnknownTokenListAst, context?: any): any;\n-}\n-\n-export abstract class CssAst {\n-  constructor(public location: ParseSourceSpan) {}\n-  get start(): ParseLocation {\n-    return this.location.start;\n-  }\n-  get end(): ParseLocation {\n-    return this.location.end;\n-  }\n-  abstract visit(visitor: CssAstVisitor, context?: any): any;\n-}\n-\n-export class CssStyleValueAst extends CssAst {\n-  constructor(location: ParseSourceSpan, public tokens: CssToken[], public strValue: string) {\n-    super(location);\n-  }\n-  visit(visitor: CssAstVisitor, context?: any): any {\n-    return visitor.visitCssValue(this);\n-  }\n-}\n-\n-export abstract class CssRuleAst extends CssAst {\n-  constructor(location: ParseSourceSpan) {\n-    super(location);\n-  }\n-}\n-\n-export class CssBlockRuleAst extends CssRuleAst {\n-  constructor(\n-      public location: ParseSourceSpan, public type: BlockType, public block: CssBlockAst,\n-      public name: CssToken|null = null) {\n-    super(location);\n-  }\n-  visit(visitor: CssAstVisitor, context?: any): any {\n-    return visitor.visitCssBlock(this.block, context);\n-  }\n-}\n-\n-export class CssKeyframeRuleAst extends CssBlockRuleAst {\n-  constructor(location: ParseSourceSpan, name: CssToken, block: CssBlockAst) {\n-    super(location, BlockType.Keyframes, block, name);\n-  }\n-  visit(visitor: CssAstVisitor, context?: any): any {\n-    return visitor.visitCssKeyframeRule(this, context);\n-  }\n-}\n-\n-export class CssKeyframeDefinitionAst extends CssBlockRuleAst {\n-  constructor(location: ParseSourceSpan, public steps: CssToken[], block: CssBlockAst) {\n-    super(location, BlockType.Keyframes, block, mergeTokens(steps, ','));\n-  }\n-  visit(visitor: CssAstVisitor, context?: any): any {\n-    return visitor.visitCssKeyframeDefinition(this, context);\n-  }\n-}\n-\n-export class CssBlockDefinitionRuleAst extends CssBlockRuleAst {\n-  constructor(\n-      location: ParseSourceSpan, public strValue: string, type: BlockType,\n-      public query: CssAtRulePredicateAst, block: CssBlockAst) {\n-    super(location, type, block);\n-    const firstCssToken: CssToken = query.tokens[0];\n-    this.name = new CssToken(\n-        firstCssToken.index, firstCssToken.column, firstCssToken.line, CssTokenType.Identifier,\n-        this.strValue);\n-  }\n-  visit(visitor: CssAstVisitor, context?: any): any {\n-    return visitor.visitCssBlock(this.block, context);\n-  }\n-}\n-\n-export class CssMediaQueryRuleAst extends CssBlockDefinitionRuleAst {\n-  constructor(\n-      location: ParseSourceSpan, strValue: string, query: CssAtRulePredicateAst,\n-      block: CssBlockAst) {\n-    super(location, strValue, BlockType.MediaQuery, query, block);\n-  }\n-  visit(visitor: CssAstVisitor, context?: any): any {\n-    return visitor.visitCssMediaQueryRule(this, context);\n-  }\n-}\n-\n-export class CssAtRulePredicateAst extends CssAst {\n-  constructor(location: ParseSourceSpan, public strValue: string, public tokens: CssToken[]) {\n-    super(location);\n-  }\n-  visit(visitor: CssAstVisitor, context?: any): any {\n-    return visitor.visitCssAtRulePredicate(this, context);\n-  }\n-}\n-\n-export class CssInlineRuleAst extends CssRuleAst {\n-  constructor(location: ParseSourceSpan, public type: BlockType, public value: CssStyleValueAst) {\n-    super(location);\n-  }\n-  visit(visitor: CssAstVisitor, context?: any): any {\n-    return visitor.visitCssInlineRule(this, context);\n-  }\n-}\n-\n-export class CssSelectorRuleAst extends CssBlockRuleAst {\n-  public strValue: string;\n-\n-  constructor(location: ParseSourceSpan, public selectors: CssSelectorAst[], block: CssBlockAst) {\n-    super(location, BlockType.Selector, block);\n-    this.strValue = selectors.map(selector => selector.strValue).join(',');\n-  }\n-  visit(visitor: CssAstVisitor, context?: any): any {\n-    return visitor.visitCssSelectorRule(this, context);\n-  }\n-}\n-\n-export class CssDefinitionAst extends CssAst {\n-  constructor(\n-      location: ParseSourceSpan, public property: CssToken, public value: CssStyleValueAst) {\n-    super(location);\n-  }\n-  visit(visitor: CssAstVisitor, context?: any): any {\n-    return visitor.visitCssDefinition(this, context);\n-  }\n-}\n-\n-export abstract class CssSelectorPartAst extends CssAst {\n-  constructor(location: ParseSourceSpan) {\n-    super(location);\n-  }\n-}\n-\n-export class CssSelectorAst extends CssSelectorPartAst {\n-  public strValue: string;\n-  constructor(location: ParseSourceSpan, public selectorParts: CssSimpleSelectorAst[]) {\n-    super(location);\n-    this.strValue = selectorParts.map(part => part.strValue).join('');\n-  }\n-  visit(visitor: CssAstVisitor, context?: any): any {\n-    return visitor.visitCssSelector(this, context);\n-  }\n-}\n-\n-export class CssSimpleSelectorAst extends CssSelectorPartAst {\n-  constructor(\n-      location: ParseSourceSpan, public tokens: CssToken[], public strValue: string,\n-      public pseudoSelectors: CssPseudoSelectorAst[], public operator: CssToken) {\n-    super(location);\n-  }\n-  visit(visitor: CssAstVisitor, context?: any): any {\n-    return visitor.visitCssSimpleSelector(this, context);\n-  }\n-}\n-\n-export class CssPseudoSelectorAst extends CssSelectorPartAst {\n-  constructor(\n-      location: ParseSourceSpan, public strValue: string, public name: string,\n-      public tokens: CssToken[], public innerSelectors: CssSelectorAst[]) {\n-    super(location);\n-  }\n-  visit(visitor: CssAstVisitor, context?: any): any {\n-    return visitor.visitCssPseudoSelector(this, context);\n-  }\n-}\n-\n-export class CssBlockAst extends CssAst {\n-  constructor(location: ParseSourceSpan, public entries: CssAst[]) {\n-    super(location);\n-  }\n-  visit(visitor: CssAstVisitor, context?: any): any {\n-    return visitor.visitCssBlock(this, context);\n-  }\n-}\n-\n-/*\n- a style block is different from a standard block because it contains\n- css prop:value definitions. A regular block can contain a list of Ast entries.\n- */\n-export class CssStylesBlockAst extends CssBlockAst {\n-  constructor(location: ParseSourceSpan, public definitions: CssDefinitionAst[]) {\n-    super(location, definitions);\n-  }\n-  visit(visitor: CssAstVisitor, context?: any): any {\n-    return visitor.visitCssStylesBlock(this, context);\n-  }\n-}\n-\n-export class CssStyleSheetAst extends CssAst {\n-  constructor(location: ParseSourceSpan, public rules: CssAst[]) {\n-    super(location);\n-  }\n-  visit(visitor: CssAstVisitor, context?: any): any {\n-    return visitor.visitCssStyleSheet(this, context);\n-  }\n-}\n-\n-export class CssUnknownRuleAst extends CssRuleAst {\n-  constructor(location: ParseSourceSpan, public ruleName: string, public tokens: CssToken[]) {\n-    super(location);\n-  }\n-  visit(visitor: CssAstVisitor, context?: any): any {\n-    return visitor.visitCssUnknownRule(this, context);\n-  }\n-}\n-\n-export class CssUnknownTokenListAst extends CssRuleAst {\n-  constructor(location: ParseSourceSpan, public name: string, public tokens: CssToken[]) {\n-    super(location);\n-  }\n-  visit(visitor: CssAstVisitor, context?: any): any {\n-    return visitor.visitCssUnknownTokenList(this, context);\n-  }\n-}\n-\n-export function mergeTokens(tokens: CssToken[], separator: string = ''): CssToken {\n-  const mainToken = tokens[0];\n-  let str = mainToken.strValue;\n-  for (let i = 1; i < tokens.length; i++) {\n-    str += separator + tokens[i].strValue;\n-  }\n-\n-  return new CssToken(mainToken.index, mainToken.column, mainToken.line, mainToken.type, str);\n-}"
        },
        {
            "sha": "c9142e8143d5ad5946bf04c7d9e3c1617868e717",
            "filename": "packages/compiler/src/css_parser/css_lexer.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 725,
            "changes": 725,
            "blob_url": "https://github.com/angular/angular/blob/d8e06f96766d65d333b533f9884cc123c48321e4/packages%2Fcompiler%2Fsrc%2Fcss_parser%2Fcss_lexer.ts",
            "raw_url": "https://github.com/angular/angular/raw/d8e06f96766d65d333b533f9884cc123c48321e4/packages%2Fcompiler%2Fsrc%2Fcss_parser%2Fcss_lexer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fcss_parser%2Fcss_lexer.ts?ref=d8e06f96766d65d333b533f9884cc123c48321e4",
            "patch": "@@ -1,725 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-\n-import * as chars from '../chars';\n-\n-export enum CssTokenType {\n-  EOF,\n-  String,\n-  Comment,\n-  Identifier,\n-  Number,\n-  IdentifierOrNumber,\n-  AtKeyword,\n-  Character,\n-  Whitespace,\n-  Invalid\n-}\n-\n-export enum CssLexerMode {\n-  ALL,\n-  ALL_TRACK_WS,\n-  SELECTOR,\n-  PSEUDO_SELECTOR,\n-  PSEUDO_SELECTOR_WITH_ARGUMENTS,\n-  ATTRIBUTE_SELECTOR,\n-  AT_RULE_QUERY,\n-  MEDIA_QUERY,\n-  BLOCK,\n-  KEYFRAME_BLOCK,\n-  STYLE_BLOCK,\n-  STYLE_VALUE,\n-  STYLE_VALUE_FUNCTION,\n-  STYLE_CALC_FUNCTION\n-}\n-\n-export class LexedCssResult {\n-  constructor(public error: Error|null, public token: CssToken) {}\n-}\n-\n-export function generateErrorMessage(\n-    input: string, message: string, errorValue: string, index: number, row: number,\n-    column: number): string {\n-  return `${message} at column ${row}:${column} in expression [` +\n-      findProblemCode(input, errorValue, index, column) + ']';\n-}\n-\n-export function findProblemCode(\n-    input: string, errorValue: string, index: number, column: number): string {\n-  let endOfProblemLine = index;\n-  let current = charCode(input, index);\n-  while (current > 0 && !isNewline(current)) {\n-    current = charCode(input, ++endOfProblemLine);\n-  }\n-  const choppedString = input.substring(0, endOfProblemLine);\n-  let pointerPadding = '';\n-  for (let i = 0; i < column; i++) {\n-    pointerPadding += ' ';\n-  }\n-  let pointerString = '';\n-  for (let i = 0; i < errorValue.length; i++) {\n-    pointerString += '^';\n-  }\n-  return choppedString + '\\n' + pointerPadding + pointerString + '\\n';\n-}\n-\n-export class CssToken {\n-  numValue: number;\n-  constructor(\n-      public index: number, public column: number, public line: number, public type: CssTokenType,\n-      public strValue: string) {\n-    this.numValue = charCode(strValue, 0);\n-  }\n-}\n-\n-export class CssLexer {\n-  scan(text: string, trackComments: boolean = false): CssScanner {\n-    return new CssScanner(text, trackComments);\n-  }\n-}\n-\n-export function cssScannerError(token: CssToken, message: string): Error {\n-  const error = Error('CssParseError: ' + message);\n-  (error as any)[ERROR_RAW_MESSAGE] = message;\n-  (error as any)[ERROR_TOKEN] = token;\n-  return error;\n-}\n-\n-const ERROR_TOKEN = 'ngToken';\n-const ERROR_RAW_MESSAGE = 'ngRawMessage';\n-\n-export function getRawMessage(error: Error): string {\n-  return (error as any)[ERROR_RAW_MESSAGE];\n-}\n-\n-export function getToken(error: Error): CssToken {\n-  return (error as any)[ERROR_TOKEN];\n-}\n-\n-function _trackWhitespace(mode: CssLexerMode) {\n-  switch (mode) {\n-    case CssLexerMode.SELECTOR:\n-    case CssLexerMode.PSEUDO_SELECTOR:\n-    case CssLexerMode.ALL_TRACK_WS:\n-    case CssLexerMode.STYLE_VALUE:\n-      return true;\n-\n-    default:\n-      return false;\n-  }\n-}\n-\n-export class CssScanner {\n-  // TODO(issue/24571): remove '!'.\n-  peek!: number;\n-  peekPeek: number;\n-  length: number = 0;\n-  index: number = -1;\n-  column: number = -1;\n-  line: number = 0;\n-\n-  /** @internal */\n-  _currentMode: CssLexerMode = CssLexerMode.BLOCK;\n-  /** @internal */\n-  _currentError: Error|null = null;\n-\n-  constructor(public input: string, private _trackComments: boolean = false) {\n-    this.length = this.input.length;\n-    this.peekPeek = this.peekAt(0);\n-    this.advance();\n-  }\n-\n-  getMode(): CssLexerMode {\n-    return this._currentMode;\n-  }\n-\n-  setMode(mode: CssLexerMode) {\n-    if (this._currentMode != mode) {\n-      if (_trackWhitespace(this._currentMode) && !_trackWhitespace(mode)) {\n-        this.consumeWhitespace();\n-      }\n-      this._currentMode = mode;\n-    }\n-  }\n-\n-  advance(): void {\n-    if (isNewline(this.peek)) {\n-      this.column = 0;\n-      this.line++;\n-    } else {\n-      this.column++;\n-    }\n-\n-    this.index++;\n-    this.peek = this.peekPeek;\n-    this.peekPeek = this.peekAt(this.index + 1);\n-  }\n-\n-  peekAt(index: number): number {\n-    return index >= this.length ? chars.$EOF : this.input.charCodeAt(index);\n-  }\n-\n-  consumeEmptyStatements(): void {\n-    this.consumeWhitespace();\n-    while (this.peek == chars.$SEMICOLON) {\n-      this.advance();\n-      this.consumeWhitespace();\n-    }\n-  }\n-\n-  consumeWhitespace(): void {\n-    while (chars.isWhitespace(this.peek) || isNewline(this.peek)) {\n-      this.advance();\n-      if (!this._trackComments && isCommentStart(this.peek, this.peekPeek)) {\n-        this.advance();  // /\n-        this.advance();  // *\n-        while (!isCommentEnd(this.peek, this.peekPeek)) {\n-          if (this.peek == chars.$EOF) {\n-            this.error('Unterminated comment');\n-          }\n-          this.advance();\n-        }\n-        this.advance();  // *\n-        this.advance();  // /\n-      }\n-    }\n-  }\n-\n-  consume(type: CssTokenType, value: string|null = null): LexedCssResult {\n-    const mode = this._currentMode;\n-\n-    this.setMode(_trackWhitespace(mode) ? CssLexerMode.ALL_TRACK_WS : CssLexerMode.ALL);\n-\n-    const previousIndex = this.index;\n-    const previousLine = this.line;\n-    const previousColumn = this.column;\n-\n-    let next: CssToken = undefined!;\n-    const output = this.scan();\n-    if (output != null) {\n-      // just incase the inner scan method returned an error\n-      if (output.error != null) {\n-        this.setMode(mode);\n-        return output;\n-      }\n-\n-      next = output.token;\n-    }\n-\n-    if (next == null) {\n-      next = new CssToken(this.index, this.column, this.line, CssTokenType.EOF, 'end of file');\n-    }\n-\n-    let isMatchingType: boolean = false;\n-    if (type == CssTokenType.IdentifierOrNumber) {\n-      // TODO (matsko): implement array traversal for lookup here\n-      isMatchingType = next.type == CssTokenType.Number || next.type == CssTokenType.Identifier;\n-    } else {\n-      isMatchingType = next.type == type;\n-    }\n-\n-    // before throwing the error we need to bring back the former\n-    // mode so that the parser can recover...\n-    this.setMode(mode);\n-\n-    let error: Error|null = null;\n-    if (!isMatchingType || (value != null && value != next.strValue)) {\n-      let errorMessage =\n-          CssTokenType[next.type] + ' does not match expected ' + CssTokenType[type] + ' value';\n-\n-      if (value != null) {\n-        errorMessage += ' (\"' + next.strValue + '\" should match \"' + value + '\")';\n-      }\n-\n-      error = cssScannerError(\n-          next,\n-          generateErrorMessage(\n-              this.input, errorMessage, next.strValue, previousIndex, previousLine,\n-              previousColumn));\n-    }\n-\n-    return new LexedCssResult(error, next);\n-  }\n-\n-\n-  scan(): LexedCssResult|null {\n-    const trackWS = _trackWhitespace(this._currentMode);\n-    if (this.index == 0 && !trackWS) {  // first scan\n-      this.consumeWhitespace();\n-    }\n-\n-    const token = this._scan();\n-    if (token == null) return null;\n-\n-    const error = this._currentError!;\n-    this._currentError = null;\n-\n-    if (!trackWS) {\n-      this.consumeWhitespace();\n-    }\n-    return new LexedCssResult(error, token);\n-  }\n-\n-  /** @internal */\n-  _scan(): CssToken|null {\n-    let peek = this.peek;\n-    let peekPeek = this.peekPeek;\n-    if (peek == chars.$EOF) return null;\n-\n-    if (isCommentStart(peek, peekPeek)) {\n-      // even if comments are not tracked we still lex the\n-      // comment so we can move the pointer forward\n-      const commentToken = this.scanComment();\n-      if (this._trackComments) {\n-        return commentToken;\n-      }\n-    }\n-\n-    if (_trackWhitespace(this._currentMode) && (chars.isWhitespace(peek) || isNewline(peek))) {\n-      return this.scanWhitespace();\n-    }\n-\n-    peek = this.peek;\n-    peekPeek = this.peekPeek;\n-    if (peek == chars.$EOF) return null;\n-\n-    if (isStringStart(peek, peekPeek)) {\n-      return this.scanString();\n-    }\n-\n-    // something like url(cool)\n-    if (this._currentMode == CssLexerMode.STYLE_VALUE_FUNCTION) {\n-      return this.scanCssValueFunction();\n-    }\n-\n-    const isModifier = peek == chars.$PLUS || peek == chars.$MINUS;\n-    const digitA = isModifier ? false : chars.isDigit(peek);\n-    const digitB = chars.isDigit(peekPeek);\n-    if (digitA || (isModifier && (peekPeek == chars.$PERIOD || digitB)) ||\n-        (peek == chars.$PERIOD && digitB)) {\n-      return this.scanNumber();\n-    }\n-\n-    if (peek == chars.$AT) {\n-      return this.scanAtExpression();\n-    }\n-\n-    if (isIdentifierStart(peek, peekPeek)) {\n-      return this.scanIdentifier();\n-    }\n-\n-    if (isValidCssCharacter(peek, this._currentMode)) {\n-      return this.scanCharacter();\n-    }\n-\n-    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`);\n-  }\n-\n-  scanComment(): CssToken|null {\n-    if (this.assertCondition(\n-            isCommentStart(this.peek, this.peekPeek), 'Expected comment start value')) {\n-      return null;\n-    }\n-\n-    const start = this.index;\n-    const startingColumn = this.column;\n-    const startingLine = this.line;\n-\n-    this.advance();  // /\n-    this.advance();  // *\n-\n-    while (!isCommentEnd(this.peek, this.peekPeek)) {\n-      if (this.peek == chars.$EOF) {\n-        this.error('Unterminated comment');\n-      }\n-      this.advance();\n-    }\n-\n-    this.advance();  // *\n-    this.advance();  // /\n-\n-    const str = this.input.substring(start, this.index);\n-    return new CssToken(start, startingColumn, startingLine, CssTokenType.Comment, str);\n-  }\n-\n-  scanWhitespace(): CssToken {\n-    const start = this.index;\n-    const startingColumn = this.column;\n-    const startingLine = this.line;\n-    while (chars.isWhitespace(this.peek) && this.peek != chars.$EOF) {\n-      this.advance();\n-    }\n-    const str = this.input.substring(start, this.index);\n-    return new CssToken(start, startingColumn, startingLine, CssTokenType.Whitespace, str);\n-  }\n-\n-  scanString(): CssToken|null {\n-    if (this.assertCondition(\n-            isStringStart(this.peek, this.peekPeek), 'Unexpected non-string starting value')) {\n-      return null;\n-    }\n-\n-    const target = this.peek;\n-    const start = this.index;\n-    const startingColumn = this.column;\n-    const startingLine = this.line;\n-    let previous = target;\n-    this.advance();\n-\n-    while (!isCharMatch(target, previous, this.peek)) {\n-      if (this.peek == chars.$EOF || isNewline(this.peek)) {\n-        this.error('Unterminated quote');\n-      }\n-      previous = this.peek;\n-      this.advance();\n-    }\n-\n-    if (this.assertCondition(this.peek == target, 'Unterminated quote')) {\n-      return null;\n-    }\n-    this.advance();\n-\n-    const str = this.input.substring(start, this.index);\n-    return new CssToken(start, startingColumn, startingLine, CssTokenType.String, str);\n-  }\n-\n-  scanNumber(): CssToken {\n-    const start = this.index;\n-    const startingColumn = this.column;\n-    if (this.peek == chars.$PLUS || this.peek == chars.$MINUS) {\n-      this.advance();\n-    }\n-    let periodUsed = false;\n-    while (chars.isDigit(this.peek) || this.peek == chars.$PERIOD) {\n-      if (this.peek == chars.$PERIOD) {\n-        if (periodUsed) {\n-          this.error('Unexpected use of a second period value');\n-        }\n-        periodUsed = true;\n-      }\n-      this.advance();\n-    }\n-    const strValue = this.input.substring(start, this.index);\n-    return new CssToken(start, startingColumn, this.line, CssTokenType.Number, strValue);\n-  }\n-\n-  scanIdentifier(): CssToken|null {\n-    if (this.assertCondition(\n-            isIdentifierStart(this.peek, this.peekPeek), 'Expected identifier starting value')) {\n-      return null;\n-    }\n-\n-    const start = this.index;\n-    const startingColumn = this.column;\n-    while (isIdentifierPart(this.peek)) {\n-      this.advance();\n-    }\n-    const strValue = this.input.substring(start, this.index);\n-    return new CssToken(start, startingColumn, this.line, CssTokenType.Identifier, strValue);\n-  }\n-\n-  scanCssValueFunction(): CssToken {\n-    const start = this.index;\n-    const startingColumn = this.column;\n-    let parenBalance = 1;\n-    while (this.peek != chars.$EOF && parenBalance > 0) {\n-      this.advance();\n-      if (this.peek == chars.$LPAREN) {\n-        parenBalance++;\n-      } else if (this.peek == chars.$RPAREN) {\n-        parenBalance--;\n-      }\n-    }\n-    const strValue = this.input.substring(start, this.index);\n-    return new CssToken(start, startingColumn, this.line, CssTokenType.Identifier, strValue);\n-  }\n-\n-  scanCharacter(): CssToken|null {\n-    const start = this.index;\n-    const startingColumn = this.column;\n-    if (this.assertCondition(\n-            isValidCssCharacter(this.peek, this._currentMode),\n-            charStr(this.peek) + ' is not a valid CSS character')) {\n-      return null;\n-    }\n-\n-    const c = this.input.substring(start, start + 1);\n-    this.advance();\n-\n-    return new CssToken(start, startingColumn, this.line, CssTokenType.Character, c);\n-  }\n-\n-  scanAtExpression(): CssToken|null {\n-    if (this.assertCondition(this.peek == chars.$AT, 'Expected @ value')) {\n-      return null;\n-    }\n-\n-    const start = this.index;\n-    const startingColumn = this.column;\n-    this.advance();\n-    if (isIdentifierStart(this.peek, this.peekPeek)) {\n-      const ident = this.scanIdentifier()!;\n-      const strValue = '@' + ident.strValue;\n-      return new CssToken(start, startingColumn, this.line, CssTokenType.AtKeyword, strValue);\n-    } else {\n-      return this.scanCharacter();\n-    }\n-  }\n-\n-  assertCondition(status: boolean, errorMessage: string): boolean {\n-    if (!status) {\n-      this.error(errorMessage);\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  error(message: string, errorTokenValue: string|null = null, doNotAdvance: boolean = false):\n-      CssToken {\n-    const index: number = this.index;\n-    const column: number = this.column;\n-    const line: number = this.line;\n-    errorTokenValue = errorTokenValue || String.fromCharCode(this.peek);\n-    const invalidToken = new CssToken(index, column, line, CssTokenType.Invalid, errorTokenValue);\n-    const errorMessage =\n-        generateErrorMessage(this.input, message, errorTokenValue, index, line, column);\n-    if (!doNotAdvance) {\n-      this.advance();\n-    }\n-    this._currentError = cssScannerError(invalidToken, errorMessage);\n-    return invalidToken;\n-  }\n-}\n-\n-function isCharMatch(target: number, previous: number, code: number): boolean {\n-  return code == target && previous != chars.$BACKSLASH;\n-}\n-\n-function isCommentStart(code: number, next: number): boolean {\n-  return code == chars.$SLASH && next == chars.$STAR;\n-}\n-\n-function isCommentEnd(code: number, next: number): boolean {\n-  return code == chars.$STAR && next == chars.$SLASH;\n-}\n-\n-function isStringStart(code: number, next: number): boolean {\n-  let target = code;\n-  if (target == chars.$BACKSLASH) {\n-    target = next;\n-  }\n-  return target == chars.$DQ || target == chars.$SQ;\n-}\n-\n-function isIdentifierStart(code: number, next: number): boolean {\n-  let target = code;\n-  if (target == chars.$MINUS) {\n-    target = next;\n-  }\n-\n-  return chars.isAsciiLetter(target) || target == chars.$BACKSLASH || target == chars.$MINUS ||\n-      target == chars.$_;\n-}\n-\n-function isIdentifierPart(target: number): boolean {\n-  return chars.isAsciiLetter(target) || target == chars.$BACKSLASH || target == chars.$MINUS ||\n-      target == chars.$_ || chars.isDigit(target);\n-}\n-\n-function isValidPseudoSelectorCharacter(code: number): boolean {\n-  switch (code) {\n-    case chars.$LPAREN:\n-    case chars.$RPAREN:\n-      return true;\n-    default:\n-      return false;\n-  }\n-}\n-\n-function isValidKeyframeBlockCharacter(code: number): boolean {\n-  return code == chars.$PERCENT;\n-}\n-\n-function isValidAttributeSelectorCharacter(code: number): boolean {\n-  // value^*|$~=something\n-  switch (code) {\n-    case chars.$$:\n-    case chars.$PIPE:\n-    case chars.$CARET:\n-    case chars.$TILDA:\n-    case chars.$STAR:\n-    case chars.$EQ:\n-      return true;\n-    default:\n-      return false;\n-  }\n-}\n-\n-function isValidSelectorCharacter(code: number): boolean {\n-  // selector [ key   = value ]\n-  // IDENT    C IDENT C IDENT C\n-  // #id, .class, *+~>\n-  // tag:PSEUDO\n-  switch (code) {\n-    case chars.$HASH:\n-    case chars.$PERIOD:\n-    case chars.$TILDA:\n-    case chars.$STAR:\n-    case chars.$PLUS:\n-    case chars.$GT:\n-    case chars.$COLON:\n-    case chars.$PIPE:\n-    case chars.$COMMA:\n-    case chars.$LBRACKET:\n-    case chars.$RBRACKET:\n-      return true;\n-    default:\n-      return false;\n-  }\n-}\n-\n-function isValidStyleBlockCharacter(code: number): boolean {\n-  // key:value;\n-  // key:calc(something ... )\n-  switch (code) {\n-    case chars.$HASH:\n-    case chars.$SEMICOLON:\n-    case chars.$COLON:\n-    case chars.$PERCENT:\n-    case chars.$SLASH:\n-    case chars.$BACKSLASH:\n-    case chars.$BANG:\n-    case chars.$PERIOD:\n-    case chars.$LPAREN:\n-    case chars.$RPAREN:\n-      return true;\n-    default:\n-      return false;\n-  }\n-}\n-\n-function isValidMediaQueryRuleCharacter(code: number): boolean {\n-  // (min-width: 7.5em) and (orientation: landscape)\n-  switch (code) {\n-    case chars.$LPAREN:\n-    case chars.$RPAREN:\n-    case chars.$COLON:\n-    case chars.$PERCENT:\n-    case chars.$PERIOD:\n-      return true;\n-    default:\n-      return false;\n-  }\n-}\n-\n-function isValidAtRuleCharacter(code: number): boolean {\n-  // @document url(http://www.w3.org/page?something=on#hash),\n-  switch (code) {\n-    case chars.$LPAREN:\n-    case chars.$RPAREN:\n-    case chars.$COLON:\n-    case chars.$PERCENT:\n-    case chars.$PERIOD:\n-    case chars.$SLASH:\n-    case chars.$BACKSLASH:\n-    case chars.$HASH:\n-    case chars.$EQ:\n-    case chars.$QUESTION:\n-    case chars.$AMPERSAND:\n-    case chars.$STAR:\n-    case chars.$COMMA:\n-    case chars.$MINUS:\n-    case chars.$PLUS:\n-      return true;\n-    default:\n-      return false;\n-  }\n-}\n-\n-function isValidStyleFunctionCharacter(code: number): boolean {\n-  switch (code) {\n-    case chars.$PERIOD:\n-    case chars.$MINUS:\n-    case chars.$PLUS:\n-    case chars.$STAR:\n-    case chars.$SLASH:\n-    case chars.$LPAREN:\n-    case chars.$RPAREN:\n-    case chars.$COMMA:\n-      return true;\n-    default:\n-      return false;\n-  }\n-}\n-\n-function isValidBlockCharacter(code: number): boolean {\n-  // @something { }\n-  // IDENT\n-  return code == chars.$AT;\n-}\n-\n-function isValidCssCharacter(code: number, mode: CssLexerMode): boolean {\n-  switch (mode) {\n-    case CssLexerMode.ALL:\n-    case CssLexerMode.ALL_TRACK_WS:\n-      return true;\n-\n-    case CssLexerMode.SELECTOR:\n-      return isValidSelectorCharacter(code);\n-\n-    case CssLexerMode.PSEUDO_SELECTOR_WITH_ARGUMENTS:\n-      return isValidPseudoSelectorCharacter(code);\n-\n-    case CssLexerMode.ATTRIBUTE_SELECTOR:\n-      return isValidAttributeSelectorCharacter(code);\n-\n-    case CssLexerMode.MEDIA_QUERY:\n-      return isValidMediaQueryRuleCharacter(code);\n-\n-    case CssLexerMode.AT_RULE_QUERY:\n-      return isValidAtRuleCharacter(code);\n-\n-    case CssLexerMode.KEYFRAME_BLOCK:\n-      return isValidKeyframeBlockCharacter(code);\n-\n-    case CssLexerMode.STYLE_BLOCK:\n-    case CssLexerMode.STYLE_VALUE:\n-      return isValidStyleBlockCharacter(code);\n-\n-    case CssLexerMode.STYLE_CALC_FUNCTION:\n-      return isValidStyleFunctionCharacter(code);\n-\n-    case CssLexerMode.BLOCK:\n-      return isValidBlockCharacter(code);\n-\n-    default:\n-      return false;\n-  }\n-}\n-\n-function charCode(input: string, index: number): number {\n-  return index >= input.length ? chars.$EOF : input.charCodeAt(index);\n-}\n-\n-function charStr(code: number): string {\n-  return String.fromCharCode(code);\n-}\n-\n-export function isNewline(code: number): boolean {\n-  switch (code) {\n-    case chars.$FF:\n-    case chars.$CR:\n-    case chars.$LF:\n-    case chars.$VTAB:\n-      return true;\n-\n-    default:\n-      return false;\n-  }\n-}"
        },
        {
            "sha": "64ba7752d5f17214a213e8feb497e1286f1fcf1a",
            "filename": "packages/compiler/src/css_parser/css_parser.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 918,
            "changes": 918,
            "blob_url": "https://github.com/angular/angular/blob/d8e06f96766d65d333b533f9884cc123c48321e4/packages%2Fcompiler%2Fsrc%2Fcss_parser%2Fcss_parser.ts",
            "raw_url": "https://github.com/angular/angular/raw/d8e06f96766d65d333b533f9884cc123c48321e4/packages%2Fcompiler%2Fsrc%2Fcss_parser%2Fcss_parser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fcss_parser%2Fcss_parser.ts?ref=d8e06f96766d65d333b533f9884cc123c48321e4",
            "patch": "@@ -1,918 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as chars from '../chars';\n-import {ParseError, ParseLocation, ParseSourceFile, ParseSourceSpan} from '../parse_util';\n-\n-import {BlockType, CssAst, CssAtRulePredicateAst, CssBlockAst, CssBlockDefinitionRuleAst, CssBlockRuleAst, CssDefinitionAst, CssInlineRuleAst, CssKeyframeDefinitionAst, CssKeyframeRuleAst, CssMediaQueryRuleAst, CssPseudoSelectorAst, CssRuleAst, CssSelectorAst, CssSelectorRuleAst, CssSimpleSelectorAst, CssStylesBlockAst, CssStyleSheetAst, CssStyleValueAst, CssUnknownRuleAst, CssUnknownTokenListAst, mergeTokens} from './css_ast';\n-import {CssLexer, CssLexerMode, CssScanner, CssToken, CssTokenType, generateErrorMessage, getRawMessage, isNewline} from './css_lexer';\n-\n-const SPACE_OPERATOR = ' ';\n-\n-export {CssToken} from './css_lexer';\n-export {BlockType} from './css_ast';\n-\n-const SLASH_CHARACTER = '/';\n-const GT_CHARACTER = '>';\n-const TRIPLE_GT_OPERATOR_STR = '>>>';\n-const DEEP_OPERATOR_STR = '/deep/';\n-\n-const EOF_DELIM_FLAG = 1;\n-const RBRACE_DELIM_FLAG = 2;\n-const LBRACE_DELIM_FLAG = 4;\n-const COMMA_DELIM_FLAG = 8;\n-const COLON_DELIM_FLAG = 16;\n-const SEMICOLON_DELIM_FLAG = 32;\n-const NEWLINE_DELIM_FLAG = 64;\n-const RPAREN_DELIM_FLAG = 128;\n-const LPAREN_DELIM_FLAG = 256;\n-const SPACE_DELIM_FLAG = 512;\n-\n-function _pseudoSelectorSupportsInnerSelectors(name: string): boolean {\n-  return ['not', 'host', 'host-context'].indexOf(name) >= 0;\n-}\n-\n-function isSelectorOperatorCharacter(code: number): boolean {\n-  switch (code) {\n-    case chars.$SLASH:\n-    case chars.$TILDA:\n-    case chars.$PLUS:\n-    case chars.$GT:\n-      return true;\n-    default:\n-      return chars.isWhitespace(code);\n-  }\n-}\n-\n-function getDelimFromCharacter(code: number): number {\n-  switch (code) {\n-    case chars.$EOF:\n-      return EOF_DELIM_FLAG;\n-    case chars.$COMMA:\n-      return COMMA_DELIM_FLAG;\n-    case chars.$COLON:\n-      return COLON_DELIM_FLAG;\n-    case chars.$SEMICOLON:\n-      return SEMICOLON_DELIM_FLAG;\n-    case chars.$RBRACE:\n-      return RBRACE_DELIM_FLAG;\n-    case chars.$LBRACE:\n-      return LBRACE_DELIM_FLAG;\n-    case chars.$RPAREN:\n-      return RPAREN_DELIM_FLAG;\n-    case chars.$SPACE:\n-    case chars.$TAB:\n-      return SPACE_DELIM_FLAG;\n-    default:\n-      return isNewline(code) ? NEWLINE_DELIM_FLAG : 0;\n-  }\n-}\n-\n-function characterContainsDelimiter(code: number, delimiters: number): boolean {\n-  return (getDelimFromCharacter(code) & delimiters) > 0;\n-}\n-\n-export class ParsedCssResult {\n-  constructor(public errors: CssParseError[], public ast: CssStyleSheetAst) {}\n-}\n-\n-export class CssParser {\n-  private _errors: CssParseError[] = [];\n-  // TODO(issue/24571): remove '!'.\n-  private _file!: ParseSourceFile;\n-  // TODO(issue/24571): remove '!'.\n-  private _scanner!: CssScanner;\n-  // TODO(issue/24571): remove '!'.\n-  private _lastToken!: CssToken;\n-\n-  /**\n-   * @param css the CSS code that will be parsed\n-   * @param url the name of the CSS file containing the CSS source code\n-   */\n-  parse(css: string, url: string): ParsedCssResult {\n-    const lexer = new CssLexer();\n-    this._file = new ParseSourceFile(css, url);\n-    this._scanner = lexer.scan(css, false);\n-\n-    const ast = this._parseStyleSheet(EOF_DELIM_FLAG);\n-\n-    const errors = this._errors;\n-    this._errors = [];\n-\n-    const result = new ParsedCssResult(errors, ast);\n-    this._file = null as any;\n-    this._scanner = null as any;\n-    return result;\n-  }\n-\n-  /** @internal */\n-  _parseStyleSheet(delimiters: number): CssStyleSheetAst {\n-    const results: CssRuleAst[] = [];\n-    this._scanner.consumeEmptyStatements();\n-    while (this._scanner.peek != chars.$EOF) {\n-      this._scanner.setMode(CssLexerMode.BLOCK);\n-      results.push(this._parseRule(delimiters));\n-    }\n-    let span: ParseSourceSpan|null = null;\n-    if (results.length > 0) {\n-      const firstRule = results[0];\n-      // we collect the last token like so incase there was an\n-      // EOF token that was emitted sometime during the lexing\n-      span = this._generateSourceSpan(firstRule, this._lastToken);\n-    }\n-    return new CssStyleSheetAst(span!, results);\n-  }\n-\n-  /** @internal */\n-  _getSourceContent(): string {\n-    return this._scanner != null ? this._scanner.input : '';\n-  }\n-\n-  /** @internal */\n-  _extractSourceContent(start: number, end: number): string {\n-    return this._getSourceContent().substring(start, end + 1);\n-  }\n-\n-  /** @internal */\n-  _generateSourceSpan(start: CssToken|CssAst, end: CssToken|CssAst|null = null): ParseSourceSpan {\n-    let startLoc: ParseLocation;\n-    if (start instanceof CssAst) {\n-      startLoc = start.location.start;\n-    } else {\n-      let token = start;\n-      if (token == null) {\n-        // the data here is invalid, however, if and when this does\n-        // occur, any other errors associated with this will be collected\n-        token = this._lastToken;\n-      }\n-      startLoc = new ParseLocation(this._file, token.index, token.line, token.column);\n-    }\n-\n-    if (end == null) {\n-      end = this._lastToken;\n-    }\n-\n-    let endLine: number = -1;\n-    let endColumn: number = -1;\n-    let endIndex: number = -1;\n-    if (end instanceof CssAst) {\n-      endLine = end.location.end.line!;\n-      endColumn = end.location.end.col!;\n-      endIndex = end.location.end.offset!;\n-    } else if (end instanceof CssToken) {\n-      endLine = end.line;\n-      endColumn = end.column;\n-      endIndex = end.index;\n-    }\n-\n-    const endLoc = new ParseLocation(this._file, endIndex, endLine, endColumn);\n-    return new ParseSourceSpan(startLoc, endLoc);\n-  }\n-\n-  /** @internal */\n-  _resolveBlockType(token: CssToken): BlockType {\n-    switch (token.strValue) {\n-      case '@-o-keyframes':\n-      case '@-moz-keyframes':\n-      case '@-webkit-keyframes':\n-      case '@keyframes':\n-        return BlockType.Keyframes;\n-\n-      case '@charset':\n-        return BlockType.Charset;\n-\n-      case '@import':\n-        return BlockType.Import;\n-\n-      case '@namespace':\n-        return BlockType.Namespace;\n-\n-      case '@page':\n-        return BlockType.Page;\n-\n-      case '@document':\n-        return BlockType.Document;\n-\n-      case '@media':\n-        return BlockType.MediaQuery;\n-\n-      case '@font-face':\n-        return BlockType.FontFace;\n-\n-      case '@viewport':\n-        return BlockType.Viewport;\n-\n-      case '@supports':\n-        return BlockType.Supports;\n-\n-      default:\n-        return BlockType.Unsupported;\n-    }\n-  }\n-\n-  /** @internal */\n-  _parseRule(delimiters: number): CssRuleAst {\n-    if (this._scanner.peek == chars.$AT) {\n-      return this._parseAtRule(delimiters);\n-    }\n-    return this._parseSelectorRule(delimiters);\n-  }\n-\n-  /** @internal */\n-  _parseAtRule(delimiters: number): CssRuleAst {\n-    const start = this._getScannerIndex();\n-\n-    this._scanner.setMode(CssLexerMode.BLOCK);\n-    const token = this._scan();\n-    const startToken = token;\n-\n-    this._assertCondition(\n-        token.type == CssTokenType.AtKeyword,\n-        `The CSS Rule ${token.strValue} is not a valid [@] rule.`, token);\n-\n-    let block: CssBlockAst;\n-    const type = this._resolveBlockType(token);\n-    let span: ParseSourceSpan;\n-    let tokens: CssToken[];\n-    let endToken: CssToken;\n-    let end: number;\n-    let strValue: string;\n-    let query: CssAtRulePredicateAst;\n-    switch (type) {\n-      case BlockType.Charset:\n-      case BlockType.Namespace:\n-      case BlockType.Import:\n-        let value = this._parseValue(delimiters);\n-        this._scanner.setMode(CssLexerMode.BLOCK);\n-        this._scanner.consumeEmptyStatements();\n-        span = this._generateSourceSpan(startToken, value);\n-        return new CssInlineRuleAst(span, type, value);\n-\n-      case BlockType.Viewport:\n-      case BlockType.FontFace:\n-        block = this._parseStyleBlock(delimiters)!;\n-        span = this._generateSourceSpan(startToken, block);\n-        return new CssBlockRuleAst(span, type, block);\n-\n-      case BlockType.Keyframes:\n-        tokens = this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG);\n-        // keyframes only have one identifier name\n-        let name = tokens[0];\n-        block = this._parseKeyframeBlock(delimiters);\n-        span = this._generateSourceSpan(startToken, block);\n-        return new CssKeyframeRuleAst(span, name, block);\n-\n-      case BlockType.MediaQuery:\n-        this._scanner.setMode(CssLexerMode.MEDIA_QUERY);\n-        tokens = this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG);\n-        endToken = tokens[tokens.length - 1];\n-        // we do not track the whitespace after the mediaQuery predicate ends\n-        // so we have to calculate the end string value on our own\n-        end = endToken.index + endToken.strValue.length - 1;\n-        strValue = this._extractSourceContent(start, end);\n-        span = this._generateSourceSpan(startToken, endToken);\n-        query = new CssAtRulePredicateAst(span, strValue, tokens);\n-        block = this._parseBlock(delimiters);\n-        strValue = this._extractSourceContent(start, this._getScannerIndex() - 1);\n-        span = this._generateSourceSpan(startToken, block);\n-        return new CssMediaQueryRuleAst(span, strValue, query, block);\n-\n-      case BlockType.Document:\n-      case BlockType.Supports:\n-      case BlockType.Page:\n-        this._scanner.setMode(CssLexerMode.AT_RULE_QUERY);\n-        tokens = this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG);\n-        endToken = tokens[tokens.length - 1];\n-        // we do not track the whitespace after this block rule predicate ends\n-        // so we have to calculate the end string value on our own\n-        end = endToken.index + endToken.strValue.length - 1;\n-        strValue = this._extractSourceContent(start, end);\n-        span = this._generateSourceSpan(startToken, tokens[tokens.length - 1]);\n-        query = new CssAtRulePredicateAst(span, strValue, tokens);\n-        block = this._parseBlock(delimiters);\n-        strValue = this._extractSourceContent(start, block.end.offset!);\n-        span = this._generateSourceSpan(startToken, block);\n-        return new CssBlockDefinitionRuleAst(span, strValue, type, query, block);\n-\n-      // if a custom @rule { ... } is used it should still tokenize the insides\n-      default:\n-        let listOfTokens: CssToken[] = [];\n-        let tokenName = token.strValue;\n-        this._scanner.setMode(CssLexerMode.ALL);\n-        this._error(\n-            generateErrorMessage(\n-                this._getSourceContent(),\n-                `The CSS \"at\" rule \"${tokenName}\" is not allowed to used here`, token.strValue,\n-                token.index, token.line, token.column),\n-            token);\n-\n-        this._collectUntilDelim(delimiters | LBRACE_DELIM_FLAG | SEMICOLON_DELIM_FLAG)\n-            .forEach((token) => {\n-              listOfTokens.push(token);\n-            });\n-        if (this._scanner.peek == chars.$LBRACE) {\n-          listOfTokens.push(this._consume(CssTokenType.Character, '{'));\n-          this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG)\n-              .forEach((token) => {\n-                listOfTokens.push(token);\n-              });\n-          listOfTokens.push(this._consume(CssTokenType.Character, '}'));\n-        }\n-        endToken = listOfTokens[listOfTokens.length - 1];\n-        span = this._generateSourceSpan(startToken, endToken);\n-        return new CssUnknownRuleAst(span, tokenName, listOfTokens);\n-    }\n-  }\n-\n-  /** @internal */\n-  _parseSelectorRule(delimiters: number): CssRuleAst {\n-    const start = this._getScannerIndex();\n-    const selectors = this._parseSelectors(delimiters);\n-    const block = this._parseStyleBlock(delimiters);\n-    let ruleAst: CssRuleAst;\n-    let span: ParseSourceSpan;\n-    const startSelector = selectors[0];\n-    if (block != null) {\n-      span = this._generateSourceSpan(startSelector, block);\n-      ruleAst = new CssSelectorRuleAst(span, selectors, block);\n-    } else {\n-      const name = this._extractSourceContent(start, this._getScannerIndex() - 1);\n-      const innerTokens: CssToken[] = [];\n-      selectors.forEach((selector: CssSelectorAst) => {\n-        selector.selectorParts.forEach((part: CssSimpleSelectorAst) => {\n-          part.tokens.forEach((token: CssToken) => {\n-            innerTokens.push(token);\n-          });\n-        });\n-      });\n-      const endToken = innerTokens[innerTokens.length - 1];\n-      span = this._generateSourceSpan(startSelector, endToken);\n-      ruleAst = new CssUnknownTokenListAst(span, name, innerTokens);\n-    }\n-    this._scanner.setMode(CssLexerMode.BLOCK);\n-    this._scanner.consumeEmptyStatements();\n-    return ruleAst;\n-  }\n-\n-  /** @internal */\n-  _parseSelectors(delimiters: number): CssSelectorAst[] {\n-    delimiters |= LBRACE_DELIM_FLAG | SEMICOLON_DELIM_FLAG;\n-\n-    const selectors: CssSelectorAst[] = [];\n-    let isParsingSelectors = true;\n-    while (isParsingSelectors) {\n-      selectors.push(this._parseSelector(delimiters));\n-\n-      isParsingSelectors = !characterContainsDelimiter(this._scanner.peek, delimiters);\n-\n-      if (isParsingSelectors) {\n-        this._consume(CssTokenType.Character, ',');\n-        isParsingSelectors = !characterContainsDelimiter(this._scanner.peek, delimiters);\n-        if (isParsingSelectors) {\n-          this._scanner.consumeWhitespace();\n-        }\n-      }\n-    }\n-\n-    return selectors;\n-  }\n-\n-  /** @internal */\n-  _scan(): CssToken {\n-    const output = this._scanner.scan()!;\n-    const token = output.token;\n-    const error = output.error;\n-    if (error != null) {\n-      this._error(getRawMessage(error), token);\n-    }\n-    this._lastToken = token;\n-    return token;\n-  }\n-\n-  /** @internal */\n-  _getScannerIndex(): number {\n-    return this._scanner.index;\n-  }\n-\n-  /** @internal */\n-  _consume(type: CssTokenType, value: string|null = null): CssToken {\n-    const output = this._scanner.consume(type, value);\n-    const token = output.token;\n-    const error = output.error;\n-    if (error != null) {\n-      this._error(getRawMessage(error), token);\n-    }\n-    this._lastToken = token;\n-    return token;\n-  }\n-\n-  /** @internal */\n-  _parseKeyframeBlock(delimiters: number): CssBlockAst {\n-    delimiters |= RBRACE_DELIM_FLAG;\n-    this._scanner.setMode(CssLexerMode.KEYFRAME_BLOCK);\n-\n-    const startToken = this._consume(CssTokenType.Character, '{');\n-\n-    const definitions: CssKeyframeDefinitionAst[] = [];\n-    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n-      definitions.push(this._parseKeyframeDefinition(delimiters));\n-    }\n-\n-    const endToken = this._consume(CssTokenType.Character, '}');\n-\n-    const span = this._generateSourceSpan(startToken, endToken);\n-    return new CssBlockAst(span, definitions);\n-  }\n-\n-  /** @internal */\n-  _parseKeyframeDefinition(delimiters: number): CssKeyframeDefinitionAst {\n-    const start = this._getScannerIndex();\n-    const stepTokens: CssToken[] = [];\n-    delimiters |= LBRACE_DELIM_FLAG;\n-    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n-      stepTokens.push(this._parseKeyframeLabel(delimiters | COMMA_DELIM_FLAG));\n-      if (this._scanner.peek != chars.$LBRACE) {\n-        this._consume(CssTokenType.Character, ',');\n-      }\n-    }\n-    const stylesBlock = this._parseStyleBlock(delimiters | RBRACE_DELIM_FLAG);\n-    const span = this._generateSourceSpan(stepTokens[0], stylesBlock);\n-    const ast = new CssKeyframeDefinitionAst(span, stepTokens, stylesBlock!);\n-\n-    this._scanner.setMode(CssLexerMode.BLOCK);\n-    return ast;\n-  }\n-\n-  /** @internal */\n-  _parseKeyframeLabel(delimiters: number): CssToken {\n-    this._scanner.setMode(CssLexerMode.KEYFRAME_BLOCK);\n-    return mergeTokens(this._collectUntilDelim(delimiters));\n-  }\n-\n-  /** @internal */\n-  _parsePseudoSelector(delimiters: number): CssPseudoSelectorAst {\n-    const start = this._getScannerIndex();\n-\n-    delimiters &= ~COMMA_DELIM_FLAG;\n-\n-    // we keep the original value since we may use it to recurse when :not, :host are used\n-    const startingDelims = delimiters;\n-\n-    const startToken = this._consume(CssTokenType.Character, ':');\n-    const tokens = [startToken];\n-\n-    if (this._scanner.peek == chars.$COLON) {  // ::something\n-      tokens.push(this._consume(CssTokenType.Character, ':'));\n-    }\n-\n-    const innerSelectors: CssSelectorAst[] = [];\n-\n-    this._scanner.setMode(CssLexerMode.PSEUDO_SELECTOR);\n-\n-    // host, host-context, lang, not, nth-child are all identifiers\n-    const pseudoSelectorToken = this._consume(CssTokenType.Identifier);\n-    const pseudoSelectorName = pseudoSelectorToken.strValue;\n-    tokens.push(pseudoSelectorToken);\n-\n-    // host(), lang(), nth-child(), etc...\n-    if (this._scanner.peek == chars.$LPAREN) {\n-      this._scanner.setMode(CssLexerMode.PSEUDO_SELECTOR_WITH_ARGUMENTS);\n-\n-      const openParenToken = this._consume(CssTokenType.Character, '(');\n-      tokens.push(openParenToken);\n-\n-      // :host(innerSelector(s)), :not(selector), etc...\n-      if (_pseudoSelectorSupportsInnerSelectors(pseudoSelectorName)) {\n-        let innerDelims = startingDelims | LPAREN_DELIM_FLAG | RPAREN_DELIM_FLAG;\n-        if (pseudoSelectorName == 'not') {\n-          // the inner selector inside of :not(...) can only be one\n-          // CSS selector (no commas allowed) ... This is according\n-          // to the CSS specification\n-          innerDelims |= COMMA_DELIM_FLAG;\n-        }\n-\n-        // :host(a, b, c) {\n-        this._parseSelectors(innerDelims).forEach((selector, index) => {\n-          innerSelectors.push(selector);\n-        });\n-      } else {\n-        // this branch is for things like \"en-us, 2k + 1, etc...\"\n-        // which all end up in pseudoSelectors like :lang, :nth-child, etc..\n-        const innerValueDelims = delimiters | LBRACE_DELIM_FLAG | COLON_DELIM_FLAG |\n-            RPAREN_DELIM_FLAG | LPAREN_DELIM_FLAG;\n-        while (!characterContainsDelimiter(this._scanner.peek, innerValueDelims)) {\n-          const token = this._scan();\n-          tokens.push(token);\n-        }\n-      }\n-\n-      const closeParenToken = this._consume(CssTokenType.Character, ')');\n-      tokens.push(closeParenToken);\n-    }\n-\n-    const end = this._getScannerIndex() - 1;\n-    const strValue = this._extractSourceContent(start, end);\n-\n-    const endToken = tokens[tokens.length - 1];\n-    const span = this._generateSourceSpan(startToken, endToken);\n-    return new CssPseudoSelectorAst(span, strValue, pseudoSelectorName, tokens, innerSelectors);\n-  }\n-\n-  /** @internal */\n-  _parseSimpleSelector(delimiters: number): CssSimpleSelectorAst {\n-    const start = this._getScannerIndex();\n-\n-    delimiters |= COMMA_DELIM_FLAG;\n-\n-    this._scanner.setMode(CssLexerMode.SELECTOR);\n-    const selectorCssTokens: CssToken[] = [];\n-    const pseudoSelectors: CssPseudoSelectorAst[] = [];\n-\n-    let previousToken: CssToken = undefined!;\n-\n-    const selectorPartDelimiters = delimiters | SPACE_DELIM_FLAG;\n-    let loopOverSelector = !characterContainsDelimiter(this._scanner.peek, selectorPartDelimiters);\n-\n-    let hasAttributeError = false;\n-    while (loopOverSelector) {\n-      const peek = this._scanner.peek;\n-\n-      switch (peek) {\n-        case chars.$COLON:\n-          let innerPseudo = this._parsePseudoSelector(delimiters);\n-          pseudoSelectors.push(innerPseudo);\n-          this._scanner.setMode(CssLexerMode.SELECTOR);\n-          break;\n-\n-        case chars.$LBRACKET:\n-          // we set the mode after the scan because attribute mode does not\n-          // allow attribute [] values. And this also will catch any errors\n-          // if an extra \"[\" is used inside.\n-          selectorCssTokens.push(this._scan());\n-          this._scanner.setMode(CssLexerMode.ATTRIBUTE_SELECTOR);\n-          break;\n-\n-        case chars.$RBRACKET:\n-          if (this._scanner.getMode() != CssLexerMode.ATTRIBUTE_SELECTOR) {\n-            hasAttributeError = true;\n-          }\n-          // we set the mode early because attribute mode does not\n-          // allow attribute [] values\n-          this._scanner.setMode(CssLexerMode.SELECTOR);\n-          selectorCssTokens.push(this._scan());\n-          break;\n-\n-        default:\n-          if (isSelectorOperatorCharacter(peek)) {\n-            loopOverSelector = false;\n-            continue;\n-          }\n-\n-          let token = this._scan();\n-          previousToken = token;\n-          selectorCssTokens.push(token);\n-          break;\n-      }\n-\n-      loopOverSelector = !characterContainsDelimiter(this._scanner.peek, selectorPartDelimiters);\n-    }\n-\n-    hasAttributeError =\n-        hasAttributeError || this._scanner.getMode() == CssLexerMode.ATTRIBUTE_SELECTOR;\n-    if (hasAttributeError) {\n-      this._error(\n-          `Unbalanced CSS attribute selector at column ${previousToken.line}:${\n-              previousToken.column}`,\n-          previousToken);\n-    }\n-\n-    let end = this._getScannerIndex() - 1;\n-\n-    // this happens if the selector is not directly followed by\n-    // a comma or curly brace without a space in between\n-    let operator: CssToken|null = null;\n-    let operatorScanCount = 0;\n-    let lastOperatorToken: CssToken|null = null;\n-    if (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n-      while (operator == null && !characterContainsDelimiter(this._scanner.peek, delimiters) &&\n-             isSelectorOperatorCharacter(this._scanner.peek)) {\n-        let token = this._scan();\n-        const tokenOperator = token.strValue;\n-        operatorScanCount++;\n-        lastOperatorToken = token;\n-        if (tokenOperator != SPACE_OPERATOR) {\n-          switch (tokenOperator) {\n-            case SLASH_CHARACTER:\n-              // /deep/ operator\n-              let deepToken = this._consume(CssTokenType.Identifier);\n-              let deepSlash = this._consume(CssTokenType.Character);\n-              let index = lastOperatorToken.index;\n-              let line = lastOperatorToken.line;\n-              let column = lastOperatorToken.column;\n-              if (deepToken != null && deepToken.strValue.toLowerCase() == 'deep' &&\n-                  deepSlash.strValue == SLASH_CHARACTER) {\n-                token = new CssToken(\n-                    lastOperatorToken.index, lastOperatorToken.column, lastOperatorToken.line,\n-                    CssTokenType.Identifier, DEEP_OPERATOR_STR);\n-              } else {\n-                const text = SLASH_CHARACTER + deepToken.strValue + deepSlash.strValue;\n-                this._error(\n-                    generateErrorMessage(\n-                        this._getSourceContent(), `${text} is an invalid CSS operator`, text, index,\n-                        line, column),\n-                    lastOperatorToken);\n-                token = new CssToken(index, column, line, CssTokenType.Invalid, text);\n-              }\n-              break;\n-\n-            case GT_CHARACTER:\n-              // >>> operator\n-              if (this._scanner.peek == chars.$GT && this._scanner.peekPeek == chars.$GT) {\n-                this._consume(CssTokenType.Character, GT_CHARACTER);\n-                this._consume(CssTokenType.Character, GT_CHARACTER);\n-                token = new CssToken(\n-                    lastOperatorToken.index, lastOperatorToken.column, lastOperatorToken.line,\n-                    CssTokenType.Identifier, TRIPLE_GT_OPERATOR_STR);\n-              }\n-              break;\n-          }\n-\n-          operator = token;\n-        }\n-      }\n-\n-      // so long as there is an operator then we can have an\n-      // ending value that is beyond the selector value ...\n-      // otherwise it's just a bunch of trailing whitespace\n-      if (operator != null) {\n-        end = operator.index;\n-      }\n-    }\n-\n-    this._scanner.consumeWhitespace();\n-\n-    const strValue = this._extractSourceContent(start, end);\n-\n-    // if we do come across one or more spaces inside of\n-    // the operators loop then an empty space is still a\n-    // valid operator to use if something else was not found\n-    if (operator == null && operatorScanCount > 0 && this._scanner.peek != chars.$LBRACE) {\n-      operator = lastOperatorToken;\n-    }\n-\n-    // please note that `endToken` is reassigned multiple times below\n-    // so please do not optimize the if statements into if/elseif\n-    let startTokenOrAst: CssToken|CssAst|null = null;\n-    let endTokenOrAst: CssToken|CssAst|null = null;\n-    if (selectorCssTokens.length > 0) {\n-      startTokenOrAst = startTokenOrAst || selectorCssTokens[0];\n-      endTokenOrAst = selectorCssTokens[selectorCssTokens.length - 1];\n-    }\n-    if (pseudoSelectors.length > 0) {\n-      startTokenOrAst = startTokenOrAst || pseudoSelectors[0];\n-      endTokenOrAst = pseudoSelectors[pseudoSelectors.length - 1];\n-    }\n-    if (operator != null) {\n-      startTokenOrAst = startTokenOrAst || operator;\n-      endTokenOrAst = operator;\n-    }\n-\n-    const span = this._generateSourceSpan(startTokenOrAst!, endTokenOrAst);\n-    return new CssSimpleSelectorAst(span, selectorCssTokens, strValue, pseudoSelectors, operator!);\n-  }\n-\n-  /** @internal */\n-  _parseSelector(delimiters: number): CssSelectorAst {\n-    delimiters |= COMMA_DELIM_FLAG;\n-    this._scanner.setMode(CssLexerMode.SELECTOR);\n-\n-    const simpleSelectors: CssSimpleSelectorAst[] = [];\n-    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n-      simpleSelectors.push(this._parseSimpleSelector(delimiters));\n-      this._scanner.consumeWhitespace();\n-    }\n-\n-    const firstSelector = simpleSelectors[0];\n-    const lastSelector = simpleSelectors[simpleSelectors.length - 1];\n-    const span = this._generateSourceSpan(firstSelector, lastSelector);\n-    return new CssSelectorAst(span, simpleSelectors);\n-  }\n-\n-  /** @internal */\n-  _parseValue(delimiters: number): CssStyleValueAst {\n-    delimiters |= RBRACE_DELIM_FLAG | SEMICOLON_DELIM_FLAG | NEWLINE_DELIM_FLAG;\n-\n-    this._scanner.setMode(CssLexerMode.STYLE_VALUE);\n-    const start = this._getScannerIndex();\n-\n-    const tokens: CssToken[] = [];\n-    let wsStr = '';\n-    let previous: CssToken = undefined!;\n-    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n-      let token: CssToken;\n-      if (previous != null && previous.type == CssTokenType.Identifier &&\n-          this._scanner.peek == chars.$LPAREN) {\n-        token = this._consume(CssTokenType.Character, '(');\n-        tokens.push(token);\n-\n-        this._scanner.setMode(CssLexerMode.STYLE_VALUE_FUNCTION);\n-\n-        token = this._scan();\n-        tokens.push(token);\n-\n-        this._scanner.setMode(CssLexerMode.STYLE_VALUE);\n-\n-        token = this._consume(CssTokenType.Character, ')');\n-        tokens.push(token);\n-      } else {\n-        token = this._scan();\n-        if (token.type == CssTokenType.Whitespace) {\n-          wsStr += token.strValue;\n-        } else {\n-          wsStr = '';\n-          tokens.push(token);\n-        }\n-      }\n-      previous = token;\n-    }\n-\n-    const end = this._getScannerIndex() - 1;\n-    this._scanner.consumeWhitespace();\n-\n-    const code = this._scanner.peek;\n-    if (code == chars.$SEMICOLON) {\n-      this._consume(CssTokenType.Character, ';');\n-    } else if (code != chars.$RBRACE) {\n-      this._error(\n-          generateErrorMessage(\n-              this._getSourceContent(), `The CSS key/value definition did not end with a semicolon`,\n-              previous.strValue, previous.index, previous.line, previous.column),\n-          previous);\n-    }\n-\n-    const strValue = this._extractSourceContent(start, end);\n-    const startToken = tokens[0];\n-    const endToken = tokens[tokens.length - 1];\n-    const span = this._generateSourceSpan(startToken, endToken);\n-    return new CssStyleValueAst(span, tokens, strValue);\n-  }\n-\n-  /** @internal */\n-  _collectUntilDelim(delimiters: number, assertType: CssTokenType|null = null): CssToken[] {\n-    const tokens: CssToken[] = [];\n-    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n-      const val = assertType != null ? this._consume(assertType) : this._scan();\n-      tokens.push(val);\n-    }\n-    return tokens;\n-  }\n-\n-  /** @internal */\n-  _parseBlock(delimiters: number): CssBlockAst {\n-    delimiters |= RBRACE_DELIM_FLAG;\n-\n-    this._scanner.setMode(CssLexerMode.BLOCK);\n-\n-    const startToken = this._consume(CssTokenType.Character, '{');\n-    this._scanner.consumeEmptyStatements();\n-\n-    const results: CssRuleAst[] = [];\n-    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n-      results.push(this._parseRule(delimiters));\n-    }\n-\n-    const endToken = this._consume(CssTokenType.Character, '}');\n-\n-    this._scanner.setMode(CssLexerMode.BLOCK);\n-    this._scanner.consumeEmptyStatements();\n-\n-    const span = this._generateSourceSpan(startToken, endToken);\n-    return new CssBlockAst(span, results);\n-  }\n-\n-  /** @internal */\n-  _parseStyleBlock(delimiters: number): CssStylesBlockAst|null {\n-    delimiters |= RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG;\n-\n-    this._scanner.setMode(CssLexerMode.STYLE_BLOCK);\n-\n-    const startToken = this._consume(CssTokenType.Character, '{');\n-    if (startToken.numValue != chars.$LBRACE) {\n-      return null;\n-    }\n-\n-    const definitions: CssDefinitionAst[] = [];\n-    this._scanner.consumeEmptyStatements();\n-\n-    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n-      definitions.push(this._parseDefinition(delimiters));\n-      this._scanner.consumeEmptyStatements();\n-    }\n-\n-    const endToken = this._consume(CssTokenType.Character, '}');\n-\n-    this._scanner.setMode(CssLexerMode.STYLE_BLOCK);\n-    this._scanner.consumeEmptyStatements();\n-\n-    const span = this._generateSourceSpan(startToken, endToken);\n-    return new CssStylesBlockAst(span, definitions);\n-  }\n-\n-  /** @internal */\n-  _parseDefinition(delimiters: number): CssDefinitionAst {\n-    this._scanner.setMode(CssLexerMode.STYLE_BLOCK);\n-\n-    let prop = this._consume(CssTokenType.Identifier);\n-    let parseValue: boolean = false;\n-    let value: CssStyleValueAst|null = null;\n-    let endToken: CssToken|CssStyleValueAst = prop;\n-\n-    // the colon value separates the prop from the style.\n-    // there are a few cases as to what could happen if it\n-    // is missing\n-    switch (this._scanner.peek) {\n-      case chars.$SEMICOLON:\n-      case chars.$RBRACE:\n-      case chars.$EOF:\n-        parseValue = false;\n-        break;\n-\n-      default:\n-        let propStr = [prop.strValue];\n-        if (this._scanner.peek != chars.$COLON) {\n-          // this will throw the error\n-          const nextValue = this._consume(CssTokenType.Character, ':');\n-          propStr.push(nextValue.strValue);\n-\n-          const remainingTokens = this._collectUntilDelim(\n-              delimiters | COLON_DELIM_FLAG | SEMICOLON_DELIM_FLAG, CssTokenType.Identifier);\n-          if (remainingTokens.length > 0) {\n-            remainingTokens.forEach((token) => {\n-              propStr.push(token.strValue);\n-            });\n-          }\n-\n-          endToken = prop =\n-              new CssToken(prop.index, prop.column, prop.line, prop.type, propStr.join(' '));\n-        }\n-\n-        // this means we've reached the end of the definition and/or block\n-        if (this._scanner.peek == chars.$COLON) {\n-          this._consume(CssTokenType.Character, ':');\n-          parseValue = true;\n-        }\n-        break;\n-    }\n-\n-    if (parseValue) {\n-      value = this._parseValue(delimiters);\n-      endToken = value;\n-    } else {\n-      this._error(\n-          generateErrorMessage(\n-              this._getSourceContent(), `The CSS property was not paired with a style value`,\n-              prop.strValue, prop.index, prop.line, prop.column),\n-          prop);\n-    }\n-\n-    const span = this._generateSourceSpan(prop, endToken);\n-    return new CssDefinitionAst(span, prop, value!);\n-  }\n-\n-  /** @internal */\n-  _assertCondition(status: boolean, errorMessage: string, problemToken: CssToken): boolean {\n-    if (!status) {\n-      this._error(errorMessage, problemToken);\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  /** @internal */\n-  _error(message: string, problemToken: CssToken) {\n-    const length = problemToken.strValue.length;\n-    const error = CssParseError.create(\n-        this._file, 0, problemToken.line, problemToken.column, length, message);\n-    this._errors.push(error);\n-  }\n-}\n-\n-export class CssParseError extends ParseError {\n-  static create(\n-      file: ParseSourceFile, offset: number, line: number, col: number, length: number,\n-      errMsg: string): CssParseError {\n-    const start = new ParseLocation(file, offset, line, col);\n-    const end = new ParseLocation(file, offset, line, col + length);\n-    const span = new ParseSourceSpan(start, end);\n-    return new CssParseError(span, 'CSS Parse Error: ' + errMsg);\n-  }\n-\n-  constructor(span: ParseSourceSpan, message: string) {\n-    super(span, message);\n-  }\n-}"
        },
        {
            "sha": "13f19b83301be6d23909a67f02cee91977992bed",
            "filename": "packages/compiler/test/css_parser/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 30,
            "changes": 30,
            "blob_url": "https://github.com/angular/angular/blob/d8e06f96766d65d333b533f9884cc123c48321e4/packages%2Fcompiler%2Ftest%2Fcss_parser%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/d8e06f96766d65d333b533f9884cc123c48321e4/packages%2Fcompiler%2Ftest%2Fcss_parser%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fcss_parser%2FBUILD.bazel?ref=d8e06f96766d65d333b533f9884cc123c48321e4",
            "patch": "@@ -1,30 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"jasmine_node_test\", \"karma_web_test_suite\", \"ts_library\")\n-\n-ts_library(\n-    name = \"css_parser_lib\",\n-    testonly = True,\n-    srcs = glob([\"**/*.ts\"]),\n-    deps = [\n-        \"//packages:types\",\n-        \"//packages/compiler\",\n-        \"//packages/compiler/testing\",\n-        \"//packages/core/testing\",\n-        \"//packages/platform-browser\",\n-        \"//packages/platform-browser/testing\",\n-    ],\n-)\n-\n-jasmine_node_test(\n-    name = \"css_parser\",\n-    bootstrap = [\"//tools/testing:node_es5\"],\n-    deps = [\n-        \":css_parser_lib\",\n-    ],\n-)\n-\n-karma_web_test_suite(\n-    name = \"css_parser_web\",\n-    deps = [\n-        \":css_parser_lib\",\n-    ],\n-)"
        },
        {
            "sha": "20879d7a42dd968679134b4939de51940aafe3af",
            "filename": "packages/compiler/test/css_parser/css_lexer_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 387,
            "changes": 387,
            "blob_url": "https://github.com/angular/angular/blob/d8e06f96766d65d333b533f9884cc123c48321e4/packages%2Fcompiler%2Ftest%2Fcss_parser%2Fcss_lexer_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/d8e06f96766d65d333b533f9884cc123c48321e4/packages%2Fcompiler%2Ftest%2Fcss_parser%2Fcss_lexer_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fcss_parser%2Fcss_lexer_spec.ts?ref=d8e06f96766d65d333b533f9884cc123c48321e4",
            "patch": "@@ -1,387 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {describe, expect, it} from '../../../core/testing/src/testing_internal';\n-import {CssLexer, CssLexerMode, cssScannerError, CssToken, CssTokenType, getRawMessage, getToken} from '../../src/css_parser/css_lexer';\n-\n-(function() {\n-function tokenize(\n-    code: string, trackComments: boolean = false,\n-    mode: CssLexerMode = CssLexerMode.ALL): CssToken[] {\n-  const scanner = new CssLexer().scan(code, trackComments);\n-  scanner.setMode(mode);\n-\n-  const tokens: CssToken[] = [];\n-  let output = scanner.scan();\n-  while (output != null) {\n-    const error = output.error;\n-    if (error != null) {\n-      throw cssScannerError(getToken(error), getRawMessage(error));\n-    }\n-    tokens.push(output.token);\n-    output = scanner.scan();\n-  }\n-\n-  return tokens;\n-}\n-\n-describe('CssLexer', () => {\n-  it('should lex newline characters as whitespace when whitespace mode is on', () => {\n-    const newlines = ['\\n', '\\r\\n', '\\r', '\\f'];\n-    newlines.forEach((line) => {\n-      const token = tokenize(line, false, CssLexerMode.ALL_TRACK_WS)[0];\n-      expect(token.type).toEqual(CssTokenType.Whitespace);\n-    });\n-  });\n-\n-  it('should combined newline characters as one newline token when whitespace mode is on', () => {\n-    const newlines = ['\\n', '\\r\\n', '\\r', '\\f'].join('');\n-    const tokens = tokenize(newlines, false, CssLexerMode.ALL_TRACK_WS);\n-    expect(tokens.length).toEqual(1);\n-    expect(tokens[0].type).toEqual(CssTokenType.Whitespace);\n-  });\n-\n-  it('should not consider whitespace or newline values at all when whitespace mode is off', () => {\n-    const newlines = ['\\n', '\\r\\n', '\\r', '\\f'].join('');\n-    const tokens = tokenize(newlines);\n-    expect(tokens.length).toEqual(0);\n-  });\n-\n-  it('should lex simple selectors and their inner properties', () => {\n-    const cssCode = '\\n' +\n-        '  .selector { my-prop: my-value; }\\n';\n-    const tokens = tokenize(cssCode);\n-\n-    expect(tokens[0].type).toEqual(CssTokenType.Character);\n-    expect(tokens[0].strValue).toEqual('.');\n-\n-    expect(tokens[1].type).toEqual(CssTokenType.Identifier);\n-    expect(tokens[1].strValue).toEqual('selector');\n-\n-    expect(tokens[2].type).toEqual(CssTokenType.Character);\n-    expect(tokens[2].strValue).toEqual('{');\n-\n-    expect(tokens[3].type).toEqual(CssTokenType.Identifier);\n-    expect(tokens[3].strValue).toEqual('my-prop');\n-\n-    expect(tokens[4].type).toEqual(CssTokenType.Character);\n-    expect(tokens[4].strValue).toEqual(':');\n-\n-    expect(tokens[5].type).toEqual(CssTokenType.Identifier);\n-    expect(tokens[5].strValue).toEqual('my-value');\n-\n-    expect(tokens[6].type).toEqual(CssTokenType.Character);\n-    expect(tokens[6].strValue).toEqual(';');\n-\n-    expect(tokens[7].type).toEqual(CssTokenType.Character);\n-    expect(tokens[7].strValue).toEqual('}');\n-  });\n-\n-  it('should capture the column and line values for each token', () => {\n-    const cssCode = '#id {\\n' +\n-        '  prop:value;\\n' +\n-        '}';\n-\n-    const tokens = tokenize(cssCode);\n-\n-    // #\n-    expect(tokens[0].type).toEqual(CssTokenType.Character);\n-    expect(tokens[0].column).toEqual(0);\n-    expect(tokens[0].line).toEqual(0);\n-\n-    // id\n-    expect(tokens[1].type).toEqual(CssTokenType.Identifier);\n-    expect(tokens[1].column).toEqual(1);\n-    expect(tokens[1].line).toEqual(0);\n-\n-    // {\n-    expect(tokens[2].type).toEqual(CssTokenType.Character);\n-    expect(tokens[2].column).toEqual(4);\n-    expect(tokens[2].line).toEqual(0);\n-\n-    // prop\n-    expect(tokens[3].type).toEqual(CssTokenType.Identifier);\n-    expect(tokens[3].column).toEqual(2);\n-    expect(tokens[3].line).toEqual(1);\n-\n-    // :\n-    expect(tokens[4].type).toEqual(CssTokenType.Character);\n-    expect(tokens[4].column).toEqual(6);\n-    expect(tokens[4].line).toEqual(1);\n-\n-    // value\n-    expect(tokens[5].type).toEqual(CssTokenType.Identifier);\n-    expect(tokens[5].column).toEqual(7);\n-    expect(tokens[5].line).toEqual(1);\n-\n-    // ;\n-    expect(tokens[6].type).toEqual(CssTokenType.Character);\n-    expect(tokens[6].column).toEqual(12);\n-    expect(tokens[6].line).toEqual(1);\n-\n-    // }\n-    expect(tokens[7].type).toEqual(CssTokenType.Character);\n-    expect(tokens[7].column).toEqual(0);\n-    expect(tokens[7].line).toEqual(2);\n-  });\n-\n-  it('should lex quoted strings and escape accordingly', () => {\n-    const cssCode = 'prop: \\'some { value } \\\\\\' that is quoted\\'';\n-    const tokens = tokenize(cssCode);\n-\n-    expect(tokens[0].type).toEqual(CssTokenType.Identifier);\n-    expect(tokens[1].type).toEqual(CssTokenType.Character);\n-    expect(tokens[2].type).toEqual(CssTokenType.String);\n-    expect(tokens[2].strValue).toEqual('\\'some { value } \\\\\\' that is quoted\\'');\n-  });\n-\n-  it('should treat attribute operators as regular characters', () => {\n-    tokenize('^|~+*').forEach((token) => {\n-      expect(token.type).toEqual(CssTokenType.Character);\n-    });\n-  });\n-\n-  it('should lex numbers properly and set them as numbers', () => {\n-    const cssCode = '0 1 -2 3.0 -4.001';\n-    const tokens = tokenize(cssCode);\n-\n-    expect(tokens[0].type).toEqual(CssTokenType.Number);\n-    expect(tokens[0].strValue).toEqual('0');\n-\n-    expect(tokens[1].type).toEqual(CssTokenType.Number);\n-    expect(tokens[1].strValue).toEqual('1');\n-\n-    expect(tokens[2].type).toEqual(CssTokenType.Number);\n-    expect(tokens[2].strValue).toEqual('-2');\n-\n-    expect(tokens[3].type).toEqual(CssTokenType.Number);\n-    expect(tokens[3].strValue).toEqual('3.0');\n-\n-    expect(tokens[4].type).toEqual(CssTokenType.Number);\n-    expect(tokens[4].strValue).toEqual('-4.001');\n-  });\n-\n-  it('should lex @keywords', () => {\n-    const cssCode = '@import()@something';\n-    const tokens = tokenize(cssCode);\n-\n-    expect(tokens[0].type).toEqual(CssTokenType.AtKeyword);\n-    expect(tokens[0].strValue).toEqual('@import');\n-\n-    expect(tokens[1].type).toEqual(CssTokenType.Character);\n-    expect(tokens[1].strValue).toEqual('(');\n-\n-    expect(tokens[2].type).toEqual(CssTokenType.Character);\n-    expect(tokens[2].strValue).toEqual(')');\n-\n-    expect(tokens[3].type).toEqual(CssTokenType.AtKeyword);\n-    expect(tokens[3].strValue).toEqual('@something');\n-  });\n-\n-  it('should still lex a number even if it has a dimension suffix', () => {\n-    const cssCode = '40% is 40 percent';\n-    const tokens = tokenize(cssCode);\n-\n-    expect(tokens[0].type).toEqual(CssTokenType.Number);\n-    expect(tokens[0].strValue).toEqual('40');\n-\n-    expect(tokens[1].type).toEqual(CssTokenType.Character);\n-    expect(tokens[1].strValue).toEqual('%');\n-\n-    expect(tokens[2].type).toEqual(CssTokenType.Identifier);\n-    expect(tokens[2].strValue).toEqual('is');\n-\n-    expect(tokens[3].type).toEqual(CssTokenType.Number);\n-    expect(tokens[3].strValue).toEqual('40');\n-  });\n-\n-  it('should allow escaped character and unicode character-strings in CSS selectors', () => {\n-    const cssCode = '\\\\123456 .some\\\\thing \\{\\}';\n-    const tokens = tokenize(cssCode);\n-\n-    expect(tokens[0].type).toEqual(CssTokenType.Identifier);\n-    expect(tokens[0].strValue).toEqual('\\\\123456');\n-\n-    expect(tokens[1].type).toEqual(CssTokenType.Character);\n-    expect(tokens[2].type).toEqual(CssTokenType.Identifier);\n-    expect(tokens[2].strValue).toEqual('some\\\\thing');\n-  });\n-\n-  it('should distinguish identifiers and numbers from special characters', () => {\n-    const cssCode = 'one*two=-4+three-4-equals_value$';\n-    const tokens = tokenize(cssCode);\n-\n-    expect(tokens[0].type).toEqual(CssTokenType.Identifier);\n-    expect(tokens[0].strValue).toEqual('one');\n-\n-    expect(tokens[1].type).toEqual(CssTokenType.Character);\n-    expect(tokens[1].strValue).toEqual('*');\n-\n-    expect(tokens[2].type).toEqual(CssTokenType.Identifier);\n-    expect(tokens[2].strValue).toEqual('two');\n-\n-    expect(tokens[3].type).toEqual(CssTokenType.Character);\n-    expect(tokens[3].strValue).toEqual('=');\n-\n-    expect(tokens[4].type).toEqual(CssTokenType.Number);\n-    expect(tokens[4].strValue).toEqual('-4');\n-\n-    expect(tokens[5].type).toEqual(CssTokenType.Character);\n-    expect(tokens[5].strValue).toEqual('+');\n-\n-    expect(tokens[6].type).toEqual(CssTokenType.Identifier);\n-    expect(tokens[6].strValue).toEqual('three-4-equals_value');\n-\n-    expect(tokens[7].type).toEqual(CssTokenType.Character);\n-    expect(tokens[7].strValue).toEqual('$');\n-  });\n-\n-  it('should filter out comments and whitespace by default', () => {\n-    const cssCode = '.selector /* comment */ { /* value */ }';\n-    const tokens = tokenize(cssCode);\n-\n-    expect(tokens[0].strValue).toEqual('.');\n-    expect(tokens[1].strValue).toEqual('selector');\n-    expect(tokens[2].strValue).toEqual('{');\n-    expect(tokens[3].strValue).toEqual('}');\n-  });\n-\n-  it('should track comments when the flag is set to true', () => {\n-    const cssCode = '.selector /* comment */ { /* value */ }';\n-    const trackComments = true;\n-    const tokens = tokenize(cssCode, trackComments, CssLexerMode.ALL_TRACK_WS);\n-\n-    expect(tokens[0].strValue).toEqual('.');\n-    expect(tokens[1].strValue).toEqual('selector');\n-    expect(tokens[2].strValue).toEqual(' ');\n-\n-    expect(tokens[3].type).toEqual(CssTokenType.Comment);\n-    expect(tokens[3].strValue).toEqual('/* comment */');\n-\n-    expect(tokens[4].strValue).toEqual(' ');\n-    expect(tokens[5].strValue).toEqual('{');\n-    expect(tokens[6].strValue).toEqual(' ');\n-\n-    expect(tokens[7].type).toEqual(CssTokenType.Comment);\n-    expect(tokens[7].strValue).toEqual('/* value */');\n-  });\n-\n-  describe('Selector Mode', () => {\n-    it('should throw an error if a selector is being parsed while in the wrong mode', () => {\n-      const cssCode = '.class > tag';\n-\n-      let capturedMessage: string|null = null;\n-      try {\n-        tokenize(cssCode, false, CssLexerMode.STYLE_BLOCK);\n-      } catch (e) {\n-        capturedMessage = getRawMessage(e);\n-      }\n-\n-      expect(capturedMessage).toMatch(/Unexpected character \\[\\>\\] at column 0:7 in expression/g);\n-\n-      capturedMessage = null;\n-      try {\n-        tokenize(cssCode, false, CssLexerMode.SELECTOR);\n-      } catch (e) {\n-        capturedMessage = getRawMessage(e);\n-      }\n-\n-      expect(capturedMessage).toEqual(null);\n-    });\n-  });\n-\n-  describe('Attribute Mode', () => {\n-    it('should consider attribute selectors as valid input and throw when an invalid modifier is used',\n-       () => {\n-         function tokenizeAttr(modifier: string) {\n-           const cssCode = 'value' + modifier + '=\\'something\\'';\n-           return tokenize(cssCode, false, CssLexerMode.ATTRIBUTE_SELECTOR);\n-         }\n-\n-         expect(tokenizeAttr('*').length).toEqual(4);\n-         expect(tokenizeAttr('|').length).toEqual(4);\n-         expect(tokenizeAttr('^').length).toEqual(4);\n-         expect(tokenizeAttr('$').length).toEqual(4);\n-         expect(tokenizeAttr('~').length).toEqual(4);\n-         expect(tokenizeAttr('').length).toEqual(3);\n-\n-         expect(() => {\n-           tokenizeAttr('+');\n-         }).toThrow();\n-       });\n-  });\n-\n-  describe('Media Query Mode', () => {\n-    it('should validate media queries with a reduced subset of valid characters', () => {\n-      function tokenizeQuery(code: string) {\n-        return tokenize(code, false, CssLexerMode.MEDIA_QUERY);\n-      }\n-\n-      // the reason why the numbers are so high is because MediaQueries keep\n-      // track of the whitespace values\n-      expect(tokenizeQuery('(prop: value)').length).toEqual(5);\n-      expect(tokenizeQuery('(prop: value) and (prop2: value2)').length).toEqual(11);\n-      expect(tokenizeQuery('tv and (prop: value)').length).toEqual(7);\n-      expect(tokenizeQuery('print and ((prop: value) or (prop2: value2))').length).toEqual(15);\n-      expect(tokenizeQuery('(content: \\'something $ crazy inside &\\')').length).toEqual(5);\n-\n-      expect(() => {\n-        tokenizeQuery('(max-height: 10 + 20)');\n-      }).toThrow();\n-\n-      expect(() => {\n-        tokenizeQuery('(max-height: fifty < 100)');\n-      }).toThrow();\n-    });\n-  });\n-\n-  describe('Pseudo Selector Mode', () => {\n-    it('should validate pseudo selector identifiers with a reduced subset of valid characters',\n-       () => {\n-         function tokenizePseudo(code: string, withArgs = false): CssToken[] {\n-           const mode = withArgs ? CssLexerMode.PSEUDO_SELECTOR_WITH_ARGUMENTS :\n-                                   CssLexerMode.PSEUDO_SELECTOR;\n-           return tokenize(code, false, mode);\n-         }\n-\n-         expect(tokenizePseudo('hover').length).toEqual(1);\n-         expect(tokenizePseudo('focus').length).toEqual(1);\n-         expect(tokenizePseudo('lang(en-us)', true).length).toEqual(4);\n-\n-         expect(() => {\n-           tokenizePseudo('lang(something:broken)', true);\n-         }).toThrow();\n-\n-         expect(() => {\n-           tokenizePseudo('not(.selector)', true);\n-         }).toThrow();\n-       });\n-  });\n-\n-  describe(\n-      'Style Block Mode', () => {\n-        it(\n-            'should style blocks with a reduced subset of valid characters', () => {\n-              function tokenizeStyles(code: string) {\n-                return tokenize(code, false, CssLexerMode.STYLE_BLOCK);\n-              }\n-\n-              expect(tokenizeStyles(`\n-          key: value;\n-          prop: 100;\n-          style: value3!important;\n-        `).length).toEqual(14);\n-\n-              expect(() => tokenizeStyles(` key$: value; `)).toThrow();\n-              expect(() => tokenizeStyles(` key: value$; `)).toThrow();\n-              expect(() => tokenizeStyles(` key: value + 10; `)).toThrow();\n-              expect(() => tokenizeStyles(` key: &value; `)).toThrow();\n-            });\n-      });\n-});\n-})();"
        },
        {
            "sha": "3020ee87ee9adb384ac7790aa41f2092b520bc65",
            "filename": "packages/compiler/test/css_parser/css_parser_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 802,
            "changes": 802,
            "blob_url": "https://github.com/angular/angular/blob/d8e06f96766d65d333b533f9884cc123c48321e4/packages%2Fcompiler%2Ftest%2Fcss_parser%2Fcss_parser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/d8e06f96766d65d333b533f9884cc123c48321e4/packages%2Fcompiler%2Ftest%2Fcss_parser%2Fcss_parser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fcss_parser%2Fcss_parser_spec.ts?ref=d8e06f96766d65d333b533f9884cc123c48321e4",
            "patch": "@@ -1,802 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-\n-import {describe, expect, it} from '../../../core/testing/src/testing_internal';\n-import {CssBlockAst, CssBlockDefinitionRuleAst, CssBlockRuleAst, CssDefinitionAst, CssInlineRuleAst, CssKeyframeDefinitionAst, CssKeyframeRuleAst, CssMediaQueryRuleAst, CssSelectorRuleAst, CssStyleSheetAst, CssStyleValueAst} from '../../src/css_parser/css_ast';\n-import {BlockType, CssParseError, CssParser, CssToken, ParsedCssResult} from '../../src/css_parser/css_parser';\n-import {ParseLocation} from '../../src/parse_util';\n-\n-export function assertTokens(tokens: CssToken[], valuesArr: string[]) {\n-  for (let i = 0; i < tokens.length; i++) {\n-    expect(tokens[i].strValue == valuesArr[i]);\n-  }\n-}\n-\n-{\n-  describe('CssParser', () => {\n-    function parse(css: string): ParsedCssResult {\n-      return new CssParser().parse(css, 'some-fake-css-file.css');\n-    }\n-\n-    function makeAst(css: string): CssStyleSheetAst {\n-      const output = parse(css);\n-      const errors = output.errors;\n-      if (errors.length > 0) {\n-        throw new Error(errors.map((error: CssParseError) => error.msg).join(', '));\n-      }\n-      return output.ast;\n-    }\n-\n-    it('should parse CSS into a stylesheet Ast', () => {\n-      const styles = '.selector { prop: value123; }';\n-\n-      const ast = makeAst(styles);\n-      expect(ast.rules.length).toEqual(1);\n-\n-      const rule = <CssSelectorRuleAst>ast.rules[0];\n-      const selector = rule.selectors[0];\n-      expect(selector.strValue).toEqual('.selector');\n-\n-      const block: CssBlockAst = rule.block;\n-      expect(block.entries.length).toEqual(1);\n-\n-      const definition = <CssDefinitionAst>block.entries[0];\n-      expect(definition.property.strValue).toEqual('prop');\n-\n-      const value = <CssStyleValueAst>definition.value;\n-      expect(value.tokens[0].strValue).toEqual('value123');\n-    });\n-\n-    it('should parse multiple CSS selectors sharing the same set of styles', () => {\n-      const styles = `\n-        .class, #id, tag, [attr], key + value, * value, :-moz-any-link {\n-          prop: value123;\n-        }\n-      `;\n-\n-      const ast = makeAst(styles);\n-      expect(ast.rules.length).toEqual(1);\n-\n-      const rule = <CssSelectorRuleAst>ast.rules[0];\n-      expect(rule.selectors.length).toBe(7);\n-\n-      const classRule = rule.selectors[0];\n-      const idRule = rule.selectors[1];\n-      const tagRule = rule.selectors[2];\n-      const attrRule = rule.selectors[3];\n-      const plusOpRule = rule.selectors[4];\n-      const starOpRule = rule.selectors[5];\n-      const mozRule = rule.selectors[6];\n-\n-      assertTokens(classRule.selectorParts[0].tokens, ['.', 'class']);\n-      assertTokens(idRule.selectorParts[0].tokens, ['.', 'class']);\n-      assertTokens(attrRule.selectorParts[0].tokens, ['[', 'attr', ']']);\n-\n-      assertTokens(plusOpRule.selectorParts[0].tokens, ['key']);\n-      expect(plusOpRule.selectorParts[0].operator.strValue).toEqual('+');\n-      assertTokens(plusOpRule.selectorParts[1].tokens, ['value']);\n-\n-      assertTokens(starOpRule.selectorParts[0].tokens, ['*']);\n-      assertTokens(starOpRule.selectorParts[1].tokens, ['value']);\n-\n-      assertTokens(mozRule.selectorParts[0].pseudoSelectors[0].tokens, [':', '-moz-any-link']);\n-\n-      const style1 = <CssDefinitionAst>rule.block.entries[0];\n-      expect(style1.property.strValue).toEqual('prop');\n-      assertTokens(style1.value.tokens, ['value123']);\n-    });\n-\n-    it('should parse keyframe rules', () => {\n-      const styles = `\n-        @keyframes rotateMe {\n-          from {\n-            transform: rotate(-360deg);\n-          }\n-          50% {\n-            transform: rotate(0deg);\n-          }\n-          to {\n-            transform: rotate(360deg);\n-          }\n-        }\n-      `;\n-\n-      const ast = makeAst(styles);\n-      expect(ast.rules.length).toEqual(1);\n-\n-      const rule = <CssKeyframeRuleAst>ast.rules[0];\n-      expect(rule.name!.strValue).toEqual('rotateMe');\n-\n-      const block = <CssBlockAst>rule.block;\n-      const fromRule = <CssKeyframeDefinitionAst>block.entries[0];\n-\n-      expect(fromRule.name!.strValue).toEqual('from');\n-      const fromStyle = <CssDefinitionAst>(<CssBlockAst>fromRule.block).entries[0];\n-      expect(fromStyle.property.strValue).toEqual('transform');\n-      assertTokens(fromStyle.value.tokens, ['rotate', '(', '-360', 'deg', ')']);\n-\n-      const midRule = <CssKeyframeDefinitionAst>block.entries[1];\n-\n-      expect(midRule.name!.strValue).toEqual('50%');\n-      const midStyle = <CssDefinitionAst>(<CssBlockAst>midRule.block).entries[0];\n-      expect(midStyle.property.strValue).toEqual('transform');\n-      assertTokens(midStyle.value.tokens, ['rotate', '(', '0', 'deg', ')']);\n-\n-      const toRule = <CssKeyframeDefinitionAst>block.entries[2];\n-\n-      expect(toRule.name!.strValue).toEqual('to');\n-      const toStyle = <CssDefinitionAst>(<CssBlockAst>toRule.block).entries[0];\n-      expect(toStyle.property.strValue).toEqual('transform');\n-      assertTokens(toStyle.value.tokens, ['rotate', '(', '360', 'deg', ')']);\n-    });\n-\n-    it('should parse media queries into a stylesheet Ast', () => {\n-      const styles = `\n-        @media all and (max-width:100px) {\n-          .selector {\n-            prop: value123;\n-          }\n-        }\n-      `;\n-\n-      const ast = makeAst(styles);\n-      expect(ast.rules.length).toEqual(1);\n-\n-      const rule = <CssMediaQueryRuleAst>ast.rules[0];\n-      assertTokens(rule.query.tokens, ['all', 'and', '(', 'max-width', ':', '100', 'px', ')']);\n-\n-      const block = <CssBlockAst>rule.block;\n-      expect(block.entries.length).toEqual(1);\n-\n-      const rule2 = <CssSelectorRuleAst>block.entries[0];\n-      expect(rule2.selectors[0].strValue).toEqual('.selector');\n-\n-      const block2 = <CssBlockAst>rule2.block;\n-      expect(block2.entries.length).toEqual(1);\n-    });\n-\n-    it('should parse inline CSS values', () => {\n-      const styles = `\n-        @import url('remote.css');\n-        @charset \"UTF-8\";\n-        @namespace ng url(http://angular.io/namespace/ng);\n-      `;\n-\n-      const ast = makeAst(styles);\n-\n-      const importRule = <CssInlineRuleAst>ast.rules[0];\n-      expect(importRule.type).toEqual(BlockType.Import);\n-      assertTokens(importRule.value.tokens, ['url', '(', 'remote', '.', 'css', ')']);\n-\n-      const charsetRule = <CssInlineRuleAst>ast.rules[1];\n-      expect(charsetRule.type).toEqual(BlockType.Charset);\n-      assertTokens(charsetRule.value.tokens, ['UTF-8']);\n-\n-      const namespaceRule = <CssInlineRuleAst>ast.rules[2];\n-      expect(namespaceRule.type).toEqual(BlockType.Namespace);\n-      assertTokens(\n-          namespaceRule.value.tokens, ['ng', 'url', '(', 'http://angular.io/namespace/ng', ')']);\n-    });\n-\n-    it('should parse CSS values that contain functions and leave the inner function data untokenized',\n-       () => {\n-         const styles = `\n-        .class {\n-          background: url(matias.css);\n-          animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);\n-          height: calc(100% - 50px);\n-          background-image: linear-gradient( 45deg, rgba(100, 0, 0, 0.5), black );\n-        }\n-      `;\n-\n-         const ast = makeAst(styles);\n-         expect(ast.rules.length).toEqual(1);\n-\n-         const defs = (<CssSelectorRuleAst>ast.rules[0]).block.entries;\n-         expect(defs.length).toEqual(4);\n-\n-         assertTokens((<CssDefinitionAst>defs[0]).value.tokens, ['url', '(', 'matias.css', ')']);\n-         assertTokens(\n-             (<CssDefinitionAst>defs[1]).value.tokens,\n-             ['cubic-bezier', '(', '0.755, 0.050, 0.855, 0.060', ')']);\n-         assertTokens((<CssDefinitionAst>defs[2]).value.tokens, ['calc', '(', '100% - 50px', ')']);\n-         assertTokens(\n-             (<CssDefinitionAst>defs[3]).value.tokens,\n-             ['linear-gradient', '(', '45deg, rgba(100, 0, 0, 0.5), black', ')']);\n-       });\n-\n-    it('should parse un-named block-level CSS values', () => {\n-      const styles = `\n-        @font-face {\n-          font-family: \"Matias\";\n-          font-weight: bold;\n-          src: url(font-face.ttf);\n-        }\n-        @viewport {\n-          max-width: 100px;\n-          min-height: 1000px;\n-        }\n-      `;\n-\n-      const ast = makeAst(styles);\n-\n-      const fontFaceRule = <CssBlockRuleAst>ast.rules[0];\n-      expect(fontFaceRule.type).toEqual(BlockType.FontFace);\n-      expect(fontFaceRule.block.entries.length).toEqual(3);\n-\n-      const viewportRule = <CssBlockRuleAst>ast.rules[1];\n-      expect(viewportRule.type).toEqual(BlockType.Viewport);\n-      expect(viewportRule.block.entries.length).toEqual(2);\n-    });\n-\n-    it('should parse multiple levels of semicolons', () => {\n-      const styles = `\n-        ;;;\n-        @import url('something something')\n-        ;;;;;;;;\n-        ;;;;;;;;\n-        ;@font-face {\n-          ;src   :   url(font-face.ttf);;;;;;;;\n-          ;;;-webkit-animation:my-animation\n-        };;;\n-        @media all and (max-width:100px)\n-        {;\n-          .selector {prop: value123;};\n-          ;.selector2{prop:1}}\n-      `;\n-\n-      const ast = makeAst(styles);\n-\n-      const importRule = <CssInlineRuleAst>ast.rules[0];\n-      expect(importRule.type).toEqual(BlockType.Import);\n-      assertTokens(importRule.value.tokens, ['url', '(', 'something something', ')']);\n-\n-      const fontFaceRule = <CssBlockRuleAst>ast.rules[1];\n-      expect(fontFaceRule.type).toEqual(BlockType.FontFace);\n-      expect(fontFaceRule.block.entries.length).toEqual(2);\n-\n-      const mediaQueryRule = <CssMediaQueryRuleAst>ast.rules[2];\n-      assertTokens(\n-          mediaQueryRule.query.tokens, ['all', 'and', '(', 'max-width', ':', '100', 'px', ')']);\n-      expect(mediaQueryRule.block.entries.length).toEqual(2);\n-    });\n-\n-    it('should throw an error if an unknown @value block rule is parsed', () => {\n-      const styles = `\n-        @matias { hello: there; }\n-      `;\n-\n-      expect(() => {\n-        makeAst(styles);\n-      }).toThrowError(/^CSS Parse Error: The CSS \"at\" rule \"@matias\" is not allowed to used here/g);\n-    });\n-\n-    it('should parse empty rules', () => {\n-      const styles = `\n-        .empty-rule { }\n-        .somewhat-empty-rule { /* property: value; */ }\n-        .non-empty-rule { property: value; }\n-      `;\n-\n-      const ast = makeAst(styles);\n-\n-      const rules = ast.rules;\n-      expect((<CssSelectorRuleAst>rules[0]).block.entries.length).toEqual(0);\n-      expect((<CssSelectorRuleAst>rules[1]).block.entries.length).toEqual(0);\n-      expect((<CssSelectorRuleAst>rules[2]).block.entries.length).toEqual(1);\n-    });\n-\n-    it('should parse the @document rule', () => {\n-      const styles = `\n-        @document url(http://www.w3.org/),\n-                       url-prefix(http://www.w3.org/Style/),\n-                       domain(mozilla.org),\n-                       regexp(\"https:.*\")\n-        {\n-          /* CSS rules here apply to:\n-             - The page \"http://www.w3.org/\".\n-             - Any page whose URL begins with \"http://www.w3.org/Style/\"\n-             - Any page whose URL's host is \"mozilla.org\" or ends with\n-               \".mozilla.org\"\n-             - Any page whose URL starts with \"https:\" */\n-\n-          /* make the above-mentioned pages really ugly */\n-          body {\n-            color: purple;\n-            background: yellow;\n-          }\n-        }\n-      `;\n-\n-      const ast = makeAst(styles);\n-\n-      const rules = ast.rules;\n-      const documentRule = <CssBlockDefinitionRuleAst>rules[0];\n-      expect(documentRule.type).toEqual(BlockType.Document);\n-\n-      const rule = <CssSelectorRuleAst>documentRule.block.entries[0];\n-      expect(rule.strValue).toEqual('body');\n-    });\n-\n-    it('should parse the @page rule', () => {\n-      const styles = `\n-        @page one {\n-          .selector { prop: value; }\n-        }\n-        @page two {\n-          .selector2 { prop: value2; }\n-        }\n-      `;\n-\n-      const ast = makeAst(styles);\n-\n-      const rules = ast.rules;\n-\n-      const pageRule1 = <CssBlockDefinitionRuleAst>rules[0];\n-      expect(pageRule1.query.strValue).toEqual('@page one');\n-      expect(pageRule1.query.tokens[0].strValue).toEqual('one');\n-      expect(pageRule1.type).toEqual(BlockType.Page);\n-\n-      const pageRule2 = <CssBlockDefinitionRuleAst>rules[1];\n-      expect(pageRule2.query.strValue).toEqual('@page two');\n-      expect(pageRule2.query.tokens[0].strValue).toEqual('two');\n-      expect(pageRule2.type).toEqual(BlockType.Page);\n-\n-      const selectorOne = <CssSelectorRuleAst>pageRule1.block.entries[0];\n-      expect(selectorOne.strValue).toEqual('.selector');\n-\n-      const selectorTwo = <CssSelectorRuleAst>pageRule2.block.entries[0];\n-      expect(selectorTwo.strValue).toEqual('.selector2');\n-    });\n-\n-    it('should parse the @supports rule', () => {\n-      const styles = `\n-        @supports (animation-name: \"rotate\") {\n-          a:hover { animation: rotate 1s; }\n-        }\n-      `;\n-\n-      const ast = makeAst(styles);\n-\n-      const rules = ast.rules;\n-\n-      const supportsRule = <CssBlockDefinitionRuleAst>rules[0];\n-      assertTokens(supportsRule.query.tokens, ['(', 'animation-name', ':', 'rotate', ')']);\n-      expect(supportsRule.type).toEqual(BlockType.Supports);\n-\n-      const selectorOne = <CssSelectorRuleAst>supportsRule.block.entries[0];\n-      expect(selectorOne.strValue).toEqual('a:hover');\n-    });\n-\n-    it('should collect multiple errors during parsing', () => {\n-      const styles = `\n-        .class$value { something: something }\n-        @custom { something: something }\n-        #id { cool^: value }\n-      `;\n-\n-      const output = parse(styles);\n-      expect(output.errors.length).toEqual(3);\n-    });\n-\n-    it('should recover from selector errors and continue parsing', () => {\n-      const styles = `\n-        tag& { key: value; }\n-        .%tag { key: value; }\n-        #tag$ { key: value; }\n-      `;\n-\n-      const output = parse(styles);\n-      const errors = output.errors;\n-      const ast = output.ast;\n-\n-      expect(errors.length).toEqual(3);\n-\n-      expect(ast.rules.length).toEqual(3);\n-\n-      const rule1 = <CssSelectorRuleAst>ast.rules[0];\n-      expect(rule1.selectors[0].strValue).toEqual('tag&');\n-      expect(rule1.block.entries.length).toEqual(1);\n-\n-      const rule2 = <CssSelectorRuleAst>ast.rules[1];\n-      expect(rule2.selectors[0].strValue).toEqual('.%tag');\n-      expect(rule2.block.entries.length).toEqual(1);\n-\n-      const rule3 = <CssSelectorRuleAst>ast.rules[2];\n-      expect(rule3.selectors[0].strValue).toEqual('#tag$');\n-      expect(rule3.block.entries.length).toEqual(1);\n-    });\n-\n-    it('should throw an error when parsing invalid CSS Selectors', () => {\n-      const styles = '.class[[prop%=value}] { style: val; }';\n-      const output = parse(styles);\n-      const errors = output.errors;\n-\n-      expect(errors.length).toEqual(3);\n-\n-      expect(errors[0].msg).toMatch(/Unexpected character \\[\\[\\] at column 0:7/g);\n-\n-      expect(errors[1].msg).toMatch(/Unexpected character \\[%\\] at column 0:12/g);\n-\n-      expect(errors[2].msg).toMatch(/Unexpected character \\[}\\] at column 0:19/g);\n-    });\n-\n-    it('should throw an error if an attribute selector is not closed properly', () => {\n-      const styles = '.class[prop=value { style: val; }';\n-      const output = parse(styles);\n-      const errors = output.errors;\n-\n-      expect(errors[0].msg).toMatch(/Unbalanced CSS attribute selector at column 0:12/g);\n-    });\n-\n-    it('should throw an error if a pseudo function selector is not closed properly', () => {\n-      const styles = 'body:lang(en { key:value; }';\n-      const output = parse(styles);\n-      const errors = output.errors;\n-\n-      expect(errors[0].msg)\n-          .toMatch(/Character does not match expected Character value \\(\"{\" should match \"\\)\"\\)/);\n-    });\n-\n-    it('should raise an error when a semi colon is missing from a CSS style/pair that isn\\'t the last entry',\n-       () => {\n-         const styles = `.class {\n-        color: red\n-        background: blue\n-      }`;\n-\n-         const output = parse(styles);\n-         const errors = output.errors;\n-\n-         expect(errors.length).toEqual(1);\n-\n-         expect(errors[0].msg)\n-             .toMatch(/The CSS key\\/value definition did not end with a semicolon at column 1:15/g);\n-       });\n-\n-    it('should parse the inner value of a :not() pseudo-selector as a CSS selector', () => {\n-      const styles = `div:not(.ignore-this-div) {\n-        prop: value;\n-      }`;\n-\n-      const output = parse(styles);\n-      const errors = output.errors;\n-      const ast = output.ast;\n-\n-      expect(errors.length).toEqual(0);\n-\n-      const rule1 = <CssSelectorRuleAst>ast.rules[0];\n-      expect(rule1.selectors.length).toEqual(1);\n-\n-      const simpleSelector = rule1.selectors[0].selectorParts[0];\n-      assertTokens(simpleSelector.tokens, ['div']);\n-\n-      const pseudoSelector = simpleSelector.pseudoSelectors[0];\n-      expect(pseudoSelector.name).toEqual('not');\n-      assertTokens(pseudoSelector.tokens, ['.', 'ignore-this-div']);\n-    });\n-\n-    it('should parse the inner selectors of a :host-context selector', () => {\n-      const styles = `body > :host-context(.a, .b, .c:hover) {\n-        prop: value;\n-      }`;\n-\n-      const output = parse(styles);\n-      const errors = output.errors;\n-      const ast = output.ast;\n-\n-      expect(errors.length).toEqual(0);\n-\n-      const rule1 = <CssSelectorRuleAst>ast.rules[0];\n-      expect(rule1.selectors.length).toEqual(1);\n-\n-      const simpleSelector = rule1.selectors[0].selectorParts[1];\n-      const innerSelectors = simpleSelector.pseudoSelectors[0].innerSelectors;\n-\n-      assertTokens(innerSelectors[0].selectorParts[0].tokens, ['.', 'a']);\n-      assertTokens(innerSelectors[1].selectorParts[0].tokens, ['.', 'b']);\n-\n-      const finalSelector = innerSelectors[2].selectorParts[0];\n-      assertTokens(finalSelector.tokens, ['.', 'c', ':', 'hover']);\n-      assertTokens(finalSelector.pseudoSelectors[0].tokens, [':', 'hover']);\n-    });\n-\n-    it('should raise parse errors when CSS key/value pairs are invalid', () => {\n-      const styles = `.class {\n-        background color: value;\n-        color: value\n-        font-size;\n-        font-weight\n-      }`;\n-\n-      const output = parse(styles);\n-      const errors = output.errors;\n-\n-      expect(errors.length).toEqual(4);\n-\n-      expect(errors[0].msg)\n-          .toMatch(\n-              /Identifier does not match expected Character value \\(\"color\" should match \":\"\\) at column 1:19/g);\n-\n-      expect(errors[1].msg)\n-          .toMatch(/The CSS key\\/value definition did not end with a semicolon at column 2:15/g);\n-\n-      expect(errors[2].msg)\n-          .toMatch(/The CSS property was not paired with a style value at column 3:8/g);\n-\n-      expect(errors[3].msg)\n-          .toMatch(/The CSS property was not paired with a style value at column 4:8/g);\n-    });\n-\n-    it('should recover from CSS key/value parse errors', () => {\n-      const styles = `\n-        .problem-class { background color: red; color: white; }\n-        .good-boy-class { background-color: red; color: white; }\n-       `;\n-\n-      const output = parse(styles);\n-      const ast = output.ast;\n-\n-      expect(ast.rules.length).toEqual(2);\n-\n-      const rule1 = <CssSelectorRuleAst>ast.rules[0];\n-      expect(rule1.block.entries.length).toEqual(2);\n-\n-      const style1 = <CssDefinitionAst>rule1.block.entries[0];\n-      expect(style1.property.strValue).toEqual('background color');\n-      assertTokens(style1.value.tokens, ['red']);\n-\n-      const style2 = <CssDefinitionAst>rule1.block.entries[1];\n-      expect(style2.property.strValue).toEqual('color');\n-      assertTokens(style2.value.tokens, ['white']);\n-    });\n-\n-    describe('location offsets', () => {\n-      let styles: string;\n-\n-      function assertMatchesOffsetAndChar(\n-          location: ParseLocation, expectedOffset: number, expectedChar: string): void {\n-        expect(location.offset).toEqual(expectedOffset);\n-        expect(styles[expectedOffset]).toEqual(expectedChar);\n-      }\n-\n-      it('should collect the source span location of each AST node with regular selectors', () => {\n-        styles = '.problem-class { border-top-right: 1px; color: white; }\\n';\n-        styles += '#good-boy-rule_ { background-color: #fe4; color: teal; }';\n-\n-        const output = parse(styles);\n-        const ast = output.ast;\n-        assertMatchesOffsetAndChar(ast.location.start, 0, '.');\n-        assertMatchesOffsetAndChar(ast.location.end, 111, '}');\n-\n-        const rule1 = <CssSelectorRuleAst>ast.rules[0];\n-        assertMatchesOffsetAndChar(rule1.location.start, 0, '.');\n-        assertMatchesOffsetAndChar(rule1.location.end, 54, '}');\n-\n-        const rule2 = <CssSelectorRuleAst>ast.rules[1];\n-        assertMatchesOffsetAndChar(rule2.location.start, 56, '#');\n-        assertMatchesOffsetAndChar(rule2.location.end, 111, '}');\n-\n-        const selector1 = rule1.selectors[0];\n-        assertMatchesOffsetAndChar(selector1.location.start, 0, '.');\n-        assertMatchesOffsetAndChar(selector1.location.end, 1, 'p');  // problem-class\n-\n-        const selector2 = rule2.selectors[0];\n-        assertMatchesOffsetAndChar(selector2.location.start, 56, '#');\n-        assertMatchesOffsetAndChar(selector2.location.end, 57, 'g');  // good-boy-rule_\n-\n-        const block1 = rule1.block;\n-        assertMatchesOffsetAndChar(block1.location.start, 15, '{');\n-        assertMatchesOffsetAndChar(block1.location.end, 54, '}');\n-\n-        const block2 = rule2.block;\n-        assertMatchesOffsetAndChar(block2.location.start, 72, '{');\n-        assertMatchesOffsetAndChar(block2.location.end, 111, '}');\n-\n-        const block1def1 = <CssDefinitionAst>block1.entries[0];\n-        assertMatchesOffsetAndChar(block1def1.location.start, 17, 'b');  // border-top-right\n-        assertMatchesOffsetAndChar(block1def1.location.end, 36, 'p');    // px\n-\n-        const block1def2 = <CssDefinitionAst>block1.entries[1];\n-        assertMatchesOffsetAndChar(block1def2.location.start, 40, 'c');  // color\n-        assertMatchesOffsetAndChar(block1def2.location.end, 47, 'w');    // white\n-\n-        const block2def1 = <CssDefinitionAst>block2.entries[0];\n-        assertMatchesOffsetAndChar(block2def1.location.start, 74, 'b');  // background-color\n-        assertMatchesOffsetAndChar(block2def1.location.end, 93, 'f');    // fe4\n-\n-        const block2def2 = <CssDefinitionAst>block2.entries[1];\n-        assertMatchesOffsetAndChar(block2def2.location.start, 98, 'c');  // color\n-        assertMatchesOffsetAndChar(block2def2.location.end, 105, 't');   // teal\n-\n-        const block1value1 = block1def1.value;\n-        assertMatchesOffsetAndChar(block1value1.location.start, 35, '1');\n-        assertMatchesOffsetAndChar(block1value1.location.end, 36, 'p');\n-\n-        const block1value2 = block1def2.value;\n-        assertMatchesOffsetAndChar(block1value2.location.start, 47, 'w');\n-        assertMatchesOffsetAndChar(block1value2.location.end, 47, 'w');\n-\n-        const block2value1 = block2def1.value;\n-        assertMatchesOffsetAndChar(block2value1.location.start, 92, '#');\n-        assertMatchesOffsetAndChar(block2value1.location.end, 93, 'f');\n-\n-        const block2value2 = block2def2.value;\n-        assertMatchesOffsetAndChar(block2value2.location.start, 105, 't');\n-        assertMatchesOffsetAndChar(block2value2.location.end, 105, 't');\n-      });\n-\n-      it('should collect the source span location of each AST node with media query data', () => {\n-        styles = '@media (all and max-width: 100px) { a { display:none; } }';\n-\n-        const output = parse(styles);\n-        const ast = output.ast;\n-\n-        const mediaQuery = <CssMediaQueryRuleAst>ast.rules[0];\n-        assertMatchesOffsetAndChar(mediaQuery.location.start, 0, '@');\n-        assertMatchesOffsetAndChar(mediaQuery.location.end, 56, '}');\n-\n-        const predicate = mediaQuery.query;\n-        assertMatchesOffsetAndChar(predicate.location.start, 0, '@');\n-        assertMatchesOffsetAndChar(predicate.location.end, 32, ')');\n-\n-        const rule = <CssSelectorRuleAst>mediaQuery.block.entries[0];\n-        assertMatchesOffsetAndChar(rule.location.start, 36, 'a');\n-        assertMatchesOffsetAndChar(rule.location.end, 54, '}');\n-      });\n-\n-      it('should collect the source span location of each AST node with keyframe data', () => {\n-        styles = '@keyframes rotateAndZoomOut { ';\n-        styles += 'from { transform: rotate(0deg); } ';\n-        styles += '100% { transform: rotate(360deg) scale(2); }';\n-        styles += '}';\n-\n-        const output = parse(styles);\n-        const ast = output.ast;\n-\n-        const keyframes = <CssKeyframeRuleAst>ast.rules[0];\n-        assertMatchesOffsetAndChar(keyframes.location.start, 0, '@');\n-        assertMatchesOffsetAndChar(keyframes.location.end, 108, '}');\n-\n-        const step1 = <CssKeyframeDefinitionAst>keyframes.block.entries[0];\n-        assertMatchesOffsetAndChar(step1.location.start, 30, 'f');\n-        assertMatchesOffsetAndChar(step1.location.end, 62, '}');\n-\n-        const step2 = <CssKeyframeDefinitionAst>keyframes.block.entries[1];\n-        assertMatchesOffsetAndChar(step2.location.start, 64, '1');\n-        assertMatchesOffsetAndChar(step2.location.end, 107, '}');\n-      });\n-\n-      it('should collect the source span location of each AST node with an inline rule', () => {\n-        styles = '@import url(something.css)';\n-\n-        const output = parse(styles);\n-        const ast = output.ast;\n-\n-        const rule = <CssInlineRuleAst>ast.rules[0];\n-        assertMatchesOffsetAndChar(rule.location.start, 0, '@');\n-        assertMatchesOffsetAndChar(rule.location.end, 25, ')');\n-\n-        const value = rule.value;\n-        assertMatchesOffsetAndChar(value.location.start, 8, 'u');\n-        assertMatchesOffsetAndChar(value.location.end, 25, ')');\n-      });\n-\n-      it('should property collect the start/end locations with an invalid stylesheet', () => {\n-        styles = '#id { something: value';\n-\n-        const output = parse(styles);\n-        const ast = output.ast;\n-\n-        assertMatchesOffsetAndChar(ast.location.start, 0, '#');\n-        assertMatchesOffsetAndChar(ast.location.end, 22, undefined!);\n-      });\n-    });\n-\n-    it('should parse minified CSS content properly', () => {\n-      // this code was taken from the angular.io webpage's CSS code\n-      const styles = `\n-.is-hidden{display:none!important}\n-.is-visible{display:block!important}\n-.is-visually-hidden{height:1px;width:1px;overflow:hidden;opacity:0.01;position:absolute;bottom:0;right:0;z-index:1}\n-.grid-fluid,.grid-fixed{margin:0 auto}\n-.grid-fluid .c1,.grid-fixed .c1,.grid-fluid .c2,.grid-fixed .c2,.grid-fluid .c3,.grid-fixed .c3,.grid-fluid .c4,.grid-fixed .c4,.grid-fluid .c5,.grid-fixed .c5,.grid-fluid .c6,.grid-fixed .c6,.grid-fluid .c7,.grid-fixed .c7,.grid-fluid .c8,.grid-fixed .c8,.grid-fluid .c9,.grid-fixed .c9,.grid-fluid .c10,.grid-fixed .c10,.grid-fluid .c11,.grid-fixed .c11,.grid-fluid .c12,.grid-fixed .c12{display:inline;float:left}\n-.grid-fluid .c1.grid-right,.grid-fixed .c1.grid-right,.grid-fluid .c2.grid-right,.grid-fixed .c2.grid-right,.grid-fluid .c3.grid-right,.grid-fixed .c3.grid-right,.grid-fluid .c4.grid-right,.grid-fixed .c4.grid-right,.grid-fluid .c5.grid-right,.grid-fixed .c5.grid-right,.grid-fluid .c6.grid-right,.grid-fixed .c6.grid-right,.grid-fluid .c7.grid-right,.grid-fixed .c7.grid-right,.grid-fluid .c8.grid-right,.grid-fixed .c8.grid-right,.grid-fluid .c9.grid-right,.grid-fixed .c9.grid-right,.grid-fluid .c10.grid-right,.grid-fixed .c10.grid-right,.grid-fluid .c11.grid-right,.grid-fixed .c11.grid-right,.grid-fluid .c12.grid-right,.grid-fixed .c12.grid-right{float:right}\n-.grid-fluid .c1.nb,.grid-fixed .c1.nb,.grid-fluid .c2.nb,.grid-fixed .c2.nb,.grid-fluid .c3.nb,.grid-fixed .c3.nb,.grid-fluid .c4.nb,.grid-fixed .c4.nb,.grid-fluid .c5.nb,.grid-fixed .c5.nb,.grid-fluid .c6.nb,.grid-fixed .c6.nb,.grid-fluid .c7.nb,.grid-fixed .c7.nb,.grid-fluid .c8.nb,.grid-fixed .c8.nb,.grid-fluid .c9.nb,.grid-fixed .c9.nb,.grid-fluid .c10.nb,.grid-fixed .c10.nb,.grid-fluid .c11.nb,.grid-fixed .c11.nb,.grid-fluid .c12.nb,.grid-fixed .c12.nb{margin-left:0}\n-.grid-fluid .c1.na,.grid-fixed .c1.na,.grid-fluid .c2.na,.grid-fixed .c2.na,.grid-fluid .c3.na,.grid-fixed .c3.na,.grid-fluid .c4.na,.grid-fixed .c4.na,.grid-fluid .c5.na,.grid-fixed .c5.na,.grid-fluid .c6.na,.grid-fixed .c6.na,.grid-fluid .c7.na,.grid-fixed .c7.na,.grid-fluid .c8.na,.grid-fixed .c8.na,.grid-fluid .c9.na,.grid-fixed .c9.na,.grid-fluid .c10.na,.grid-fixed .c10.na,.grid-fluid .c11.na,.grid-fixed .c11.na,.grid-fluid .c12.na,.grid-fixed .c12.na{margin-right:0}\n-       `;\n-\n-      const output = parse(styles);\n-      const errors = output.errors;\n-      expect(errors.length).toEqual(0);\n-\n-      const ast = output.ast;\n-      expect(ast.rules.length).toEqual(8);\n-    });\n-\n-    it('should parse a snippet of keyframe code from animate.css properly', () => {\n-      // this code was taken from the angular.io webpage's CSS code\n-      const styles = `\n-@charset \"UTF-8\";\n-\n-/*!\n- * animate.css -http://daneden.me/animate\n- * Version - 3.5.1\n- * Licensed under the MIT license - http://opensource.org/licenses/MIT\n- *\n- * Copyright (c) 2016 Daniel Eden\n- */\n-\n-.animated {\n-  -webkit-animation-duration: 1s;\n-  animation-duration: 1s;\n-  -webkit-animation-fill-mode: both;\n-  animation-fill-mode: both;\n-}\n-\n-.animated.infinite {\n-  -webkit-animation-iteration-count: infinite;\n-  animation-iteration-count: infinite;\n-}\n-\n-.animated.hinge {\n-  -webkit-animation-duration: 2s;\n-  animation-duration: 2s;\n-}\n-\n-.animated.flipOutX,\n-.animated.flipOutY,\n-.animated.bounceIn,\n-.animated.bounceOut {\n-  -webkit-animation-duration: .75s;\n-  animation-duration: .75s;\n-}\n-\n-@-webkit-keyframes bounce {\n-  from, 20%, 53%, 80%, to {\n-    -webkit-animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);\n-    animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);\n-    -webkit-transform: translate3d(0,0,0);\n-    transform: translate3d(0,0,0);\n-  }\n-\n-  40%, 43% {\n-    -webkit-animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);\n-    animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);\n-    -webkit-transform: translate3d(0, -30px, 0);\n-    transform: translate3d(0, -30px, 0);\n-  }\n-\n-  70% {\n-    -webkit-animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);\n-    animation-timing-function: cubic-bezier(0.755, 0.050, 0.855, 0.060);\n-    -webkit-transform: translate3d(0, -15px, 0);\n-    transform: translate3d(0, -15px, 0);\n-  }\n-\n-  90% {\n-    -webkit-transform: translate3d(0,-4px,0);\n-    transform: translate3d(0,-4px,0);\n-  }\n-}\n-       `;\n-\n-      const output = parse(styles);\n-      const errors = output.errors;\n-      expect(errors.length).toEqual(0);\n-\n-      const ast = output.ast;\n-      expect(ast.rules.length).toEqual(6);\n-\n-      const finalRule = <CssBlockRuleAst>ast.rules[ast.rules.length - 1];\n-      expect(finalRule.type).toEqual(BlockType.Keyframes);\n-      expect(finalRule.block.entries.length).toEqual(4);\n-    });\n-  });\n-}"
        },
        {
            "sha": "9c6d485fd0ad9f7f9252482392cb3588c317a058",
            "filename": "packages/compiler/test/css_parser/css_visitor_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 333,
            "changes": 333,
            "blob_url": "https://github.com/angular/angular/blob/d8e06f96766d65d333b533f9884cc123c48321e4/packages%2Fcompiler%2Ftest%2Fcss_parser%2Fcss_visitor_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/d8e06f96766d65d333b533f9884cc123c48321e4/packages%2Fcompiler%2Ftest%2Fcss_parser%2Fcss_visitor_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fcss_parser%2Fcss_visitor_spec.ts?ref=d8e06f96766d65d333b533f9884cc123c48321e4",
            "patch": "@@ -1,333 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-\n-import {beforeEach, describe, expect, it} from '../../../core/testing/src/testing_internal';\n-import {CssAst, CssAstVisitor, CssAtRulePredicateAst, CssBlockAst, CssDefinitionAst, CssInlineRuleAst, CssKeyframeDefinitionAst, CssKeyframeRuleAst, CssMediaQueryRuleAst, CssPseudoSelectorAst, CssRuleAst, CssSelectorAst, CssSelectorRuleAst, CssSimpleSelectorAst, CssStylesBlockAst, CssStyleSheetAst, CssStyleValueAst, CssUnknownRuleAst, CssUnknownTokenListAst} from '../../src/css_parser/css_ast';\n-import {BlockType, CssParseError, CssParser, CssToken} from '../../src/css_parser/css_parser';\n-\n-function _assertTokens(tokens: CssToken[], valuesArr: string[]): void {\n-  expect(tokens.length).toEqual(valuesArr.length);\n-  for (let i = 0; i < tokens.length; i++) {\n-    expect(tokens[i].strValue == valuesArr[i]);\n-  }\n-}\n-\n-class MyVisitor implements CssAstVisitor {\n-  captures: {[key: string]: any[]} = {};\n-\n-  /**\n-   * @internal\n-   */\n-  _capture(method: string, ast: CssAst, context: any) {\n-    this.captures[method] = this.captures[method] || [];\n-    this.captures[method].push([ast, context]);\n-  }\n-\n-  constructor(ast: CssStyleSheetAst, context: any) {\n-    ast.visit(this, context);\n-  }\n-\n-  visitCssValue(ast: CssStyleValueAst, context: any): void {\n-    this._capture('visitCssValue', ast, context);\n-  }\n-\n-  visitCssInlineRule(ast: CssInlineRuleAst, context: any): void {\n-    this._capture('visitCssInlineRule', ast, context);\n-  }\n-\n-  visitCssAtRulePredicate(ast: CssAtRulePredicateAst, context: any): void {\n-    this._capture('visitCssAtRulePredicate', ast, context);\n-  }\n-\n-  visitCssKeyframeRule(ast: CssKeyframeRuleAst, context: any): void {\n-    this._capture('visitCssKeyframeRule', ast, context);\n-    ast.block.visit(this, context);\n-  }\n-\n-  visitCssKeyframeDefinition(ast: CssKeyframeDefinitionAst, context: any): void {\n-    this._capture('visitCssKeyframeDefinition', ast, context);\n-    ast.block.visit(this, context);\n-  }\n-\n-  visitCssMediaQueryRule(ast: CssMediaQueryRuleAst, context: any): void {\n-    this._capture('visitCssMediaQueryRule', ast, context);\n-    ast.query.visit(this, context);\n-    ast.block.visit(this, context);\n-  }\n-\n-  visitCssSelectorRule(ast: CssSelectorRuleAst, context: any): void {\n-    this._capture('visitCssSelectorRule', ast, context);\n-    ast.selectors.forEach((selAst: CssSelectorAst) => {\n-      selAst.visit(this, context);\n-    });\n-    ast.block.visit(this, context);\n-  }\n-\n-  visitCssSelector(ast: CssSelectorAst, context: any): void {\n-    this._capture('visitCssSelector', ast, context);\n-    ast.selectorParts.forEach((simpleAst: CssSimpleSelectorAst) => {\n-      simpleAst.visit(this, context);\n-    });\n-  }\n-\n-  visitCssSimpleSelector(ast: CssSimpleSelectorAst, context: any): void {\n-    this._capture('visitCssSimpleSelector', ast, context);\n-    ast.pseudoSelectors.forEach((pseudoAst: CssPseudoSelectorAst) => {\n-      pseudoAst.visit(this, context);\n-    });\n-  }\n-\n-  visitCssDefinition(ast: CssDefinitionAst, context: any): void {\n-    this._capture('visitCssDefinition', ast, context);\n-    ast.value.visit(this, context);\n-  }\n-\n-  visitCssBlock(ast: CssBlockAst, context: any): void {\n-    this._capture('visitCssBlock', ast, context);\n-    ast.entries.forEach((entryAst: CssAst) => {\n-      entryAst.visit(this, context);\n-    });\n-  }\n-\n-  visitCssStylesBlock(ast: CssStylesBlockAst, context: any): void {\n-    this._capture('visitCssStylesBlock', ast, context);\n-    ast.definitions.forEach((definitionAst: CssDefinitionAst) => {\n-      definitionAst.visit(this, context);\n-    });\n-  }\n-\n-  visitCssStyleSheet(ast: CssStyleSheetAst, context: any): void {\n-    this._capture('visitCssStyleSheet', ast, context);\n-    ast.rules.forEach((ruleAst: CssRuleAst) => {\n-      ruleAst.visit(this, context);\n-    });\n-  }\n-\n-  visitCssUnknownRule(ast: CssUnknownRuleAst, context: any): void {\n-    this._capture('visitCssUnknownRule', ast, context);\n-  }\n-\n-  visitCssUnknownTokenList(ast: CssUnknownTokenListAst, context: any): void {\n-    this._capture('visitCssUnknownTokenList', ast, context);\n-  }\n-\n-  visitCssPseudoSelector(ast: CssPseudoSelectorAst, context: any): void {\n-    this._capture('visitCssPseudoSelector', ast, context);\n-  }\n-}\n-\n-function _getCaptureAst(capture: any[], index = 0): CssAst {\n-  return <CssAst>capture[index][0];\n-}\n-\n-(function() {\n-function parse(cssCode: string, ignoreErrors: boolean = false) {\n-  const output = new CssParser().parse(cssCode, 'some-fake-css-file.css');\n-  const errors = output.errors;\n-  if (errors.length > 0 && !ignoreErrors) {\n-    throw new Error(errors.map((error: CssParseError) => error.msg).join(', '));\n-  }\n-  return output.ast;\n-}\n-\n-describe('CSS parsing and visiting', () => {\n-  let ast: CssStyleSheetAst;\n-  const context = {};\n-\n-  beforeEach(() => {\n-    const cssCode = `\n-        .rule1 { prop1: value1 }\n-        .rule2 { prop2: value2 }\n-\n-        @media all (max-width: 100px) {\n-          #id { prop3 :value3; }\n-        }\n-\n-        @import url(file.css);\n-\n-        @keyframes rotate {\n-          from {\n-            prop4: value4;\n-          }\n-          50%, 100% {\n-            prop5: value5;\n-          }\n-        }\n-      `;\n-    ast = parse(cssCode);\n-  });\n-\n-  it('should parse and visit a stylesheet', () => {\n-    const visitor = new MyVisitor(ast, context);\n-    const captures = visitor.captures['visitCssStyleSheet'];\n-\n-    expect(captures.length).toEqual(1);\n-\n-    const capture = captures[0];\n-    expect(capture[0]).toEqual(ast);\n-    expect(capture[1]).toEqual(context);\n-  });\n-\n-  it('should parse and visit each of the stylesheet selectors', () => {\n-    const visitor = new MyVisitor(ast, context);\n-    const captures = visitor.captures['visitCssSelectorRule'];\n-\n-    expect(captures.length).toEqual(3);\n-\n-    const rule1 = <CssSelectorRuleAst>_getCaptureAst(captures, 0);\n-    expect(rule1).toEqual(ast.rules[0] as CssSelectorRuleAst);\n-\n-    const firstSelector = rule1.selectors[0];\n-    const firstSimpleSelector = firstSelector.selectorParts[0];\n-    _assertTokens(firstSimpleSelector.tokens, ['.', 'rule1']);\n-\n-    const rule2 = <CssSelectorRuleAst>_getCaptureAst(captures, 1);\n-    expect(rule2).toEqual(ast.rules[1] as CssSelectorRuleAst);\n-\n-    const secondSelector = rule2.selectors[0];\n-    const secondSimpleSelector = secondSelector.selectorParts[0];\n-    _assertTokens(secondSimpleSelector.tokens, ['.', 'rule2']);\n-\n-    const rule3 = <CssSelectorRuleAst>_getCaptureAst(captures, 2);\n-    expect(rule3).toEqual(\n-        (ast.rules[2] as CssSelectorRuleAst).block.entries[0] as CssSelectorRuleAst);\n-\n-    const thirdSelector = rule3.selectors[0];\n-    const thirdSimpleSelector = thirdSelector.selectorParts[0];\n-    _assertTokens(thirdSimpleSelector.tokens, ['#', 'rule3']);\n-  });\n-\n-  it('should parse and visit each of the stylesheet style key/value definitions', () => {\n-    const visitor = new MyVisitor(ast, context);\n-    const captures = visitor.captures['visitCssDefinition'];\n-\n-    expect(captures.length).toEqual(5);\n-\n-    const def1 = <CssDefinitionAst>_getCaptureAst(captures, 0);\n-    expect(def1.property.strValue).toEqual('prop1');\n-    expect(def1.value.tokens[0].strValue).toEqual('value1');\n-\n-    const def2 = <CssDefinitionAst>_getCaptureAst(captures, 1);\n-    expect(def2.property.strValue).toEqual('prop2');\n-    expect(def2.value.tokens[0].strValue).toEqual('value2');\n-\n-    const def3 = <CssDefinitionAst>_getCaptureAst(captures, 2);\n-    expect(def3.property.strValue).toEqual('prop3');\n-    expect(def3.value.tokens[0].strValue).toEqual('value3');\n-\n-    const def4 = <CssDefinitionAst>_getCaptureAst(captures, 3);\n-    expect(def4.property.strValue).toEqual('prop4');\n-    expect(def4.value.tokens[0].strValue).toEqual('value4');\n-\n-    const def5 = <CssDefinitionAst>_getCaptureAst(captures, 4);\n-    expect(def5.property.strValue).toEqual('prop5');\n-    expect(def5.value.tokens[0].strValue).toEqual('value5');\n-  });\n-\n-  it('should parse and visit the associated media query values', () => {\n-    const visitor = new MyVisitor(ast, context);\n-    const captures = visitor.captures['visitCssMediaQueryRule'];\n-\n-    expect(captures.length).toEqual(1);\n-\n-    const query1 = <CssMediaQueryRuleAst>_getCaptureAst(captures, 0);\n-    _assertTokens(query1.query.tokens, ['all', 'and', '(', 'max-width', '100', 'px', ')']);\n-    expect(query1.block.entries.length).toEqual(1);\n-  });\n-\n-  it('should capture the media query predicate', () => {\n-    const visitor = new MyVisitor(ast, context);\n-    const captures = visitor.captures['visitCssAtRulePredicate'];\n-\n-    expect(captures.length).toEqual(1);\n-\n-    const predicate = <CssAtRulePredicateAst>_getCaptureAst(captures, 0);\n-    expect(predicate.strValue).toEqual('@media all (max-width: 100px)');\n-  });\n-\n-  it('should parse and visit the associated \"@inline\" rule values', () => {\n-    const visitor = new MyVisitor(ast, context);\n-    const captures = visitor.captures['visitCssInlineRule'];\n-\n-    expect(captures.length).toEqual(1);\n-\n-    const inline1 = <CssInlineRuleAst>_getCaptureAst(captures, 0);\n-    expect(inline1.type).toEqual(BlockType.Import);\n-    _assertTokens(inline1.value.tokens, ['url', '(', 'file.css', ')']);\n-  });\n-\n-  it('should parse and visit the keyframe blocks', () => {\n-    const visitor = new MyVisitor(ast, context);\n-    const captures = visitor.captures['visitCssKeyframeRule'];\n-\n-    expect(captures.length).toEqual(1);\n-\n-    const keyframe1 = <CssKeyframeRuleAst>_getCaptureAst(captures, 0);\n-    expect(keyframe1.name!.strValue).toEqual('rotate');\n-    expect(keyframe1.block.entries.length).toEqual(2);\n-  });\n-\n-  it('should parse and visit the associated keyframe rules', () => {\n-    const visitor = new MyVisitor(ast, context);\n-    const captures = visitor.captures['visitCssKeyframeDefinition'];\n-\n-    expect(captures.length).toEqual(2);\n-\n-    const def1 = <CssKeyframeDefinitionAst>_getCaptureAst(captures, 0);\n-    _assertTokens(def1.steps, ['from']);\n-    expect(def1.block.entries.length).toEqual(1);\n-\n-    const def2 = <CssKeyframeDefinitionAst>_getCaptureAst(captures, 1);\n-    _assertTokens(def2.steps, ['50%', '100%']);\n-    expect(def2.block.entries.length).toEqual(1);\n-  });\n-\n-  it('should visit an unknown `@` rule', () => {\n-    const cssCode = `\n-        @someUnknownRule param {\n-          one two three\n-        }\n-      `;\n-    ast = parse(cssCode, true);\n-    const visitor = new MyVisitor(ast, context);\n-    const captures = visitor.captures['visitCssUnknownRule'];\n-\n-    expect(captures.length).toEqual(1);\n-\n-    const rule = <CssUnknownRuleAst>_getCaptureAst(captures, 0);\n-    expect(rule.ruleName).toEqual('@someUnknownRule');\n-\n-    _assertTokens(rule.tokens, ['param', '{', 'one', 'two', 'three', '}']);\n-  });\n-\n-  it('should collect an invalid list of tokens before a valid selector', () => {\n-    const cssCode = 'one two three four five; selector { }';\n-    ast = parse(cssCode, true);\n-    const visitor = new MyVisitor(ast, context);\n-    const captures = visitor.captures['visitCssUnknownTokenList'];\n-\n-    expect(captures.length).toEqual(1);\n-\n-    const rule = <CssUnknownTokenListAst>_getCaptureAst(captures, 0);\n-    _assertTokens(rule.tokens, ['one', 'two', 'three', 'four', 'five']);\n-  });\n-\n-  it('should collect an invalid list of tokens after a valid selector', () => {\n-    const cssCode = 'selector { } six seven eight';\n-    ast = parse(cssCode, true);\n-    const visitor = new MyVisitor(ast, context);\n-    const captures = visitor.captures['visitCssUnknownTokenList'];\n-\n-    expect(captures.length).toEqual(1);\n-\n-    const rule = <CssUnknownTokenListAst>_getCaptureAst(captures, 0);\n-    _assertTokens(rule.tokens, ['six', 'seven', 'eight']);\n-  });\n-});\n-})();"
        }
    ],
    "stats": {
        "total": 3459,
        "additions": 0,
        "deletions": 3459
    }
}