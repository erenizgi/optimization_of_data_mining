{
    "author": "petebacondarwin",
    "message": "fix(ngcc): support inline export declarations in UMD files (#38959)\n\nPreviously, any declarations that were defined \"inline\" were not\nrecognised by the `UmdReflectionHost`.\n\nFor example, the following syntax was completely unrecognized:\n\n```ts\nvar Foo_1;\nexports.Foo = Foo_1 = (function() {\n  function Foo() {}\n  return Foo;\n})();\nexports.Foo = Foo_1 = __decorate(SomeDecorator, Foo);\n```\n\nSuch inline classes were ignored and not processed by ngcc.\n\nThis lack of processing led to failures in Ivy applications that relied\non UMD formats of libraries such as `syncfusion/ej2-angular-ui-components`.\n\nNow all known inline UMD exports are recognized and processed accordingly.\n\nFixes #38947\n\nPR Close #38959",
    "sha": "f4fee86f776e1f72757c975876f905c74588c13a",
    "files": [
        {
            "sha": "c4d7c89cbe1f9b2a4657f11783900957d78d8cae",
            "filename": "packages/compiler-cli/ngcc/src/host/esm2015_host.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 11,
            "changes": 29,
            "blob_url": "https://github.com/angular/angular/blob/f4fee86f776e1f72757c975876f905c74588c13a/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fesm2015_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/f4fee86f776e1f72757c975876f905c74588c13a/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fesm2015_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fesm2015_host.ts?ref=f4fee86f776e1f72757c975876f905c74588c13a",
            "patch": "@@ -419,10 +419,10 @@ export class Esm2015ReflectionHost extends TypeScriptReflectionHost implements N\n    * @returns An array of class symbols.\n    */\n   findClassSymbols(sourceFile: ts.SourceFile): NgccClassSymbol[] {\n-    const classes: NgccClassSymbol[] = [];\n+    const classes = new Map<ts.Symbol, NgccClassSymbol>();\n     this.getModuleStatements(sourceFile)\n         .forEach(statement => this.addClassSymbolsFromStatement(classes, statement));\n-    return classes;\n+    return Array.from(classes.values());\n   }\n \n   /**\n@@ -462,20 +462,27 @@ export class Esm2015ReflectionHost extends TypeScriptReflectionHost implements N\n           declaration.getText()} in ${declaration.getSourceFile().fileName}`);\n     }\n \n+    const decl = this.getDeclarationOfIdentifier(declaration.name);\n+    if (decl === null) {\n+      throw new Error(\n+          `Cannot get the dts file for a node that cannot be associated with a declaration ${\n+              declaration.getText()} in ${declaration.getSourceFile().fileName}`);\n+    }\n+\n     // Try to retrieve the dts declaration from the public map\n     if (this.publicDtsDeclarationMap === null) {\n       this.publicDtsDeclarationMap = this.computePublicDtsDeclarationMap(this.src, this.dts);\n     }\n-    if (this.publicDtsDeclarationMap.has(declaration)) {\n-      return this.publicDtsDeclarationMap.get(declaration)!;\n+    if (this.publicDtsDeclarationMap.has(decl.node)) {\n+      return this.publicDtsDeclarationMap.get(decl.node)!;\n     }\n \n     // No public export, try the private map\n     if (this.privateDtsDeclarationMap === null) {\n       this.privateDtsDeclarationMap = this.computePrivateDtsDeclarationMap(this.src, this.dts);\n     }\n-    if (this.privateDtsDeclarationMap.has(declaration)) {\n-      return this.privateDtsDeclarationMap.get(declaration)!;\n+    if (this.privateDtsDeclarationMap.has(decl.node)) {\n+      return this.privateDtsDeclarationMap.get(decl.node)!;\n     }\n \n     // No declaration found at all\n@@ -547,21 +554,21 @@ export class Esm2015ReflectionHost extends TypeScriptReflectionHost implements N\n   ///////////// Protected Helpers /////////////\n \n   /**\n-   * Extract all the \"classes\" from the `statement` and add them to the `classes` array.\n+   * Extract all the \"classes\" from the `statement` and add them to the `classes` map.\n    */\n-  protected addClassSymbolsFromStatement(classes: NgccClassSymbol[], statement: ts.Statement):\n-      void {\n+  protected addClassSymbolsFromStatement(\n+      classes: Map<ts.Symbol, NgccClassSymbol>, statement: ts.Statement): void {\n     if (ts.isVariableStatement(statement)) {\n       statement.declarationList.declarations.forEach(declaration => {\n         const classSymbol = this.getClassSymbol(declaration);\n         if (classSymbol) {\n-          classes.push(classSymbol);\n+          classes.set(classSymbol.implementation, classSymbol);\n         }\n       });\n     } else if (ts.isClassDeclaration(statement)) {\n       const classSymbol = this.getClassSymbol(statement);\n       if (classSymbol) {\n-        classes.push(classSymbol);\n+        classes.set(classSymbol.implementation, classSymbol);\n       }\n     }\n   }"
        },
        {
            "sha": "4b49a2e66d6a8a3841fa5ffc24a2f185fd7a1b3e",
            "filename": "packages/compiler-cli/ngcc/src/host/umd_host.ts",
            "status": "modified",
            "additions": 178,
            "deletions": 15,
            "changes": 193,
            "blob_url": "https://github.com/angular/angular/blob/f4fee86f776e1f72757c975876f905c74588c13a/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fumd_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/f4fee86f776e1f72757c975876f905c74588c13a/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fumd_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fhost%2Fumd_host.ts?ref=f4fee86f776e1f72757c975876f905c74588c13a",
            "patch": "@@ -10,13 +10,14 @@ import * as ts from 'typescript';\n \n import {absoluteFrom} from '../../../src/ngtsc/file_system';\n import {Logger} from '../../../src/ngtsc/logging';\n-import {Declaration, DeclarationKind, Import} from '../../../src/ngtsc/reflection';\n+import {Declaration, DeclarationKind, Import, isNamedFunctionDeclaration} from '../../../src/ngtsc/reflection';\n import {BundleProgram} from '../packages/bundle_program';\n import {FactoryMap, getTsHelperFnFromIdentifier, stripExtension} from '../utils';\n \n-import {DefinePropertyReexportStatement, ExportDeclaration, ExportsStatement, extractGetterFnExpression, findNamespaceOfIdentifier, findRequireCallReference, isDefinePropertyReexportStatement, isExportsStatement, isExternalImport, isRequireCall, isWildcardReexportStatement, WildcardReexportStatement} from './commonjs_umd_utils';\n-import {isAssignment} from './esm2015_host';\n+import {DefinePropertyReexportStatement, ExportDeclaration, ExportsStatement, extractGetterFnExpression, findNamespaceOfIdentifier, findRequireCallReference, isDefinePropertyReexportStatement, isExportsAssignment, isExportsDeclaration, isExportsStatement, isExternalImport, isRequireCall, isWildcardReexportStatement, WildcardReexportStatement} from './commonjs_umd_utils';\n+import {getInnerClassDeclaration, getOuterNodeFromInnerDeclaration, isAssignment} from './esm2015_host';\n import {Esm5ReflectionHost} from './esm5_host';\n+import {NgccClassSymbol} from './ngcc_host';\n import {stripParentheses} from './utils';\n \n export class UmdReflectionHost extends Esm5ReflectionHost {\n@@ -45,8 +46,40 @@ export class UmdReflectionHost extends Esm5ReflectionHost {\n   }\n \n   getDeclarationOfIdentifier(id: ts.Identifier): Declaration|null {\n-    return this.getExportsDeclaration(id) || this.getUmdModuleDeclaration(id) ||\n-        this.getUmdDeclaration(id) || super.getDeclarationOfIdentifier(id);\n+    // First we try one of the the following:\n+    // 1. The `exports` identifier - referring to the current file/module.\n+    // 2. An identifier (e.g. `foo`) that refers to an imported UMD module.\n+    // 3. A UMD style export identifier (e.g. the `foo` of `exports.foo`).\n+    const declaration = this.getExportsDeclaration(id) || this.getUmdModuleDeclaration(id) ||\n+        this.getUmdDeclaration(id);\n+    if (declaration !== null) {\n+      return declaration;\n+    }\n+\n+    // Try to get the declaration using the super class.\n+    const superDeclaration = super.getDeclarationOfIdentifier(id);\n+    if (superDeclaration === null) {\n+      return null;\n+    }\n+\n+    // Check to see if the declaration is the inner node of a declaration IIFE.\n+    const outerNode = getOuterNodeFromInnerDeclaration(superDeclaration.node);\n+    if (outerNode === null) {\n+      return superDeclaration;\n+    }\n+\n+    // We are only interested if the outer declaration is of the form\n+    // `exports.<name> = <initializer>`.\n+    if (!isExportsAssignment(outerNode)) {\n+      return superDeclaration;\n+    }\n+\n+    return {\n+      kind: DeclarationKind.Inline,\n+      node: outerNode.left,\n+      known: null,\n+      viaModule: null,\n+    };\n   }\n \n   getExportsOfModule(module: ts.Node): Map<string, Declaration>|null {\n@@ -78,6 +111,102 @@ export class UmdReflectionHost extends Esm5ReflectionHost {\n     return umdModule !== null ? Array.from(umdModule.factoryFn.body.statements) : [];\n   }\n \n+  protected getClassSymbolFromOuterDeclaration(declaration: ts.Node): NgccClassSymbol|undefined {\n+    const superSymbol = super.getClassSymbolFromOuterDeclaration(declaration);\n+    if (superSymbol) {\n+      return superSymbol;\n+    }\n+\n+    if (!isExportsDeclaration(declaration)) {\n+      return undefined;\n+    }\n+\n+    let initializer = skipAliases(declaration.parent.right);\n+\n+    if (ts.isIdentifier(initializer)) {\n+      const implementation = this.getDeclarationOfIdentifier(initializer);\n+      if (implementation !== null) {\n+        const implementationSymbol = this.getClassSymbol(implementation.node);\n+        if (implementationSymbol !== null) {\n+          return implementationSymbol;\n+        }\n+      }\n+    }\n+\n+    const innerDeclaration = getInnerClassDeclaration(initializer);\n+    if (innerDeclaration !== null) {\n+      return this.createClassSymbol(declaration.name, innerDeclaration);\n+    }\n+\n+    return undefined;\n+  }\n+\n+\n+  protected getClassSymbolFromInnerDeclaration(declaration: ts.Node): NgccClassSymbol|undefined {\n+    const superClassSymbol = super.getClassSymbolFromInnerDeclaration(declaration);\n+    if (superClassSymbol !== undefined) {\n+      return superClassSymbol;\n+    }\n+\n+    if (!isNamedFunctionDeclaration(declaration)) {\n+      return undefined;\n+    }\n+\n+    const outerNode = getOuterNodeFromInnerDeclaration(declaration);\n+    if (outerNode === null || !isExportsAssignment(outerNode)) {\n+      return undefined;\n+    }\n+\n+    return this.createClassSymbol(outerNode.left.name, declaration);\n+  }\n+\n+  /**\n+   * Extract all \"classes\" from the `statement` and add them to the `classes` map.\n+   */\n+  protected addClassSymbolsFromStatement(\n+      classes: Map<ts.Symbol, NgccClassSymbol>, statement: ts.Statement): void {\n+    super.addClassSymbolsFromStatement(classes, statement);\n+\n+    // Also check for exports of the form: `exports.<name> = <class def>;`\n+    if (isExportsStatement(statement)) {\n+      const classSymbol = this.getClassSymbol(statement.expression.left);\n+      if (classSymbol) {\n+        classes.set(classSymbol.implementation, classSymbol);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Analyze the given statement to see if it corresponds with an exports declaration like\n+   * `exports.MyClass = MyClass_1 = <class def>;`. If so, the declaration of `MyClass_1`\n+   * is associated with the `MyClass` identifier.\n+   *\n+   * @param statement The statement that needs to be preprocessed.\n+   */\n+  protected preprocessStatement(statement: ts.Statement): void {\n+    super.preprocessStatement(statement);\n+\n+    if (!isExportsStatement(statement)) {\n+      return;\n+    }\n+\n+    const declaration = statement.expression.left;\n+    const initializer = statement.expression.right;\n+    if (!isAssignment(initializer) || !ts.isIdentifier(initializer.left) ||\n+        !this.isClass(declaration)) {\n+      return;\n+    }\n+\n+    const aliasedIdentifier = initializer.left;\n+\n+    const aliasedDeclaration = this.getDeclarationOfIdentifier(aliasedIdentifier);\n+    if (aliasedDeclaration === null || aliasedDeclaration.node === null) {\n+      throw new Error(\n+          `Unable to locate declaration of ${aliasedIdentifier.text} in \"${statement.getText()}\"`);\n+    }\n+    this.aliasedClassDeclarations.set(aliasedDeclaration.node, declaration.name);\n+  }\n+\n   private computeUmdModule(sourceFile: ts.SourceFile): UmdModule|null {\n     if (sourceFile.statements.length !== 1) {\n       throw new Error(\n@@ -93,7 +222,17 @@ export class UmdReflectionHost extends Esm5ReflectionHost {\n     for (const statement of this.getModuleStatements(sourceFile)) {\n       if (isExportsStatement(statement)) {\n         const exportDeclaration = this.extractBasicUmdExportDeclaration(statement);\n-        moduleMap.set(exportDeclaration.name, exportDeclaration.declaration);\n+        if (!moduleMap.has(exportDeclaration.name)) {\n+          // We assume that the first `exports.<name>` is the actual declaration, and that any\n+          // subsequent statements that match are decorating the original declaration.\n+          // For example:\n+          // ```\n+          // exports.foo = <declaration>;\n+          // exports.foo = __decorate(<decorator>, exports.foo);\n+          // ```\n+          // The declaration is the first line not the second.\n+          moduleMap.set(exportDeclaration.name, exportDeclaration.declaration);\n+        }\n       } else if (isWildcardReexportStatement(statement)) {\n         const reexports = this.extractUmdWildcardReexports(statement, sourceFile);\n         for (const reexport of reexports) {\n@@ -136,7 +275,13 @@ export class UmdReflectionHost extends Esm5ReflectionHost {\n   private extractBasicUmdExportDeclaration(statement: ExportsStatement): ExportDeclaration {\n     const name = statement.expression.left.name.text;\n     const exportExpression = skipAliases(statement.expression.right);\n-    return this.extractUmdExportDeclaration(name, exportExpression);\n+    const declaration = this.getDeclarationOfExpression(exportExpression) ?? {\n+      kind: DeclarationKind.Inline,\n+      node: statement.expression.left,\n+      known: null,\n+      viaModule: null,\n+    };\n+    return {name, declaration};\n   }\n \n   private extractUmdWildcardReexports(\n@@ -185,17 +330,20 @@ export class UmdReflectionHost extends Esm5ReflectionHost {\n     if (getterFnExpression === null) {\n       return null;\n     }\n-    return this.extractUmdExportDeclaration(name, getterFnExpression);\n-  }\n \n-  private extractUmdExportDeclaration(name: string, expression: ts.Expression): ExportDeclaration {\n-    const declaration = this.getDeclarationOfExpression(expression);\n+    const declaration = this.getDeclarationOfExpression(getterFnExpression);\n     if (declaration !== null) {\n       return {name, declaration};\n     }\n+\n     return {\n       name,\n-      declaration: {kind: DeclarationKind.Inline, node: expression, known: null, viaModule: null},\n+      declaration: {\n+        kind: DeclarationKind.Inline,\n+        node: getterFnExpression,\n+        known: null,\n+        viaModule: null,\n+      },\n     };\n   }\n \n@@ -214,6 +362,21 @@ export class UmdReflectionHost extends Esm5ReflectionHost {\n     if (nsIdentifier === null) {\n       return null;\n     }\n+\n+    if (nsIdentifier.parent.parent && isExportsAssignment(nsIdentifier.parent.parent)) {\n+      const initializer = nsIdentifier.parent.parent.right;\n+      if (ts.isIdentifier(initializer)) {\n+        return this.getDeclarationOfIdentifier(initializer);\n+      }\n+      return this.detectKnownDeclaration({\n+        kind: DeclarationKind.Inline,\n+        node: nsIdentifier.parent.parent.left,\n+        implementation: skipAliases(nsIdentifier.parent.parent.right),\n+        viaModule: null,\n+        known: null,\n+      });\n+    }\n+\n     const moduleDeclaration = this.getUmdModuleDeclaration(nsIdentifier);\n     if (moduleDeclaration === null || moduleDeclaration.node === null ||\n         !ts.isSourceFile(moduleDeclaration.node)) {\n@@ -242,7 +405,7 @@ export class UmdReflectionHost extends Esm5ReflectionHost {\n   }\n \n   private getExportsDeclaration(id: ts.Identifier): Declaration|null {\n-    if (!isExportIdentifier(id)) {\n+    if (!isExportsIdentifier(id)) {\n       return null;\n     }\n \n@@ -398,7 +561,7 @@ function getRequiredModulePath(wrapperFn: ts.FunctionExpression, paramIndex: num\n /**\n  * Is the `node` an identifier with the name \"exports\"?\n  */\n-export function isExportIdentifier(node: ts.Node): node is ts.Identifier {\n+function isExportsIdentifier(node: ts.Node): node is ts.Identifier {\n   return ts.isIdentifier(node) && node.text === 'exports';\n }\n \n@@ -412,7 +575,7 @@ export function isExportIdentifier(node: ts.Node): node is ts.Identifier {\n  * @param node the expression to parse\n  * @returns the original `node` or the far right expression of a series of assignments.\n  */\n-export function skipAliases(node: ts.Expression): ts.Expression {\n+function skipAliases(node: ts.Expression): ts.Expression {\n   while (isAssignment(node)) {\n     node = node.right;\n   }"
        },
        {
            "sha": "d208650d3ea77da787f2910ee9dc8fbf9203d2c7",
            "filename": "packages/compiler-cli/ngcc/test/host/umd_host_spec.ts",
            "status": "modified",
            "additions": 2305,
            "deletions": 2183,
            "changes": 4488,
            "blob_url": "https://github.com/angular/angular/blob/f4fee86f776e1f72757c975876f905c74588c13a/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fumd_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f4fee86f776e1f72757c975876f905c74588c13a/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fumd_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Fumd_host_spec.ts?ref=f4fee86f776e1f72757c975876f905c74588c13a"
        }
    ],
    "stats": {
        "total": 4710,
        "additions": 2501,
        "deletions": 2209
    }
}