{
    "author": "atscott",
    "message": "fix(language-service): Prevent matching nodes after finding a keySpan (#40047)\n\nIf we've already identified that we are within a `keySpan` of a node, we\nexit the visitor logic early. It can be the case that we have two nodes\nwhich technically match a given location when the end span of one node\ntouches the start of the keySpan for the candidate node. Because\nour `isWithin` logic is inclusive on both ends, we can match both nodes.\nThis change exits the visitor logic once we've identified a node where\nthe position is within its `keySpan`.\n\nPR Close #40047",
    "sha": "1bf1b685d6ac2f2dfea5363b6af604cf48050820",
    "files": [
        {
            "sha": "4a18374a3bf34c9a0894e59ad628e39ae2dcca32",
            "filename": "packages/language-service/ivy/template_target.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/1bf1b685d6ac2f2dfea5363b6af604cf48050820/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "raw_url": "https://github.com/angular/angular/raw/1bf1b685d6ac2f2dfea5363b6af604cf48050820/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts?ref=1bf1b685d6ac2f2dfea5363b6af604cf48050820",
            "patch": "@@ -100,6 +100,15 @@ class TemplateTargetVisitor implements t.Visitor {\n   private constructor(private readonly position: number) {}\n \n   visit(node: t.Node) {\n+    const last: t.Node|e.AST|undefined = this.path[this.path.length - 1];\n+    if (last && isTemplateNodeWithKeyAndValue(last) && isWithin(this.position, last.keySpan)) {\n+      // We've already identified that we are within a `keySpan` of a node.\n+      // We should stop processing nodes at this point to prevent matching\n+      // any other nodes. This can happen when the end span of a different node\n+      // touches the start of the keySpan for the candidate node. Because\n+      // our `isWithin` logic is inclusive on both ends, we can match both nodes.\n+      return;\n+    }\n     const {start, end} = getSpanIncludingEndTag(node);\n     if (isWithin(this.position, {start, end})) {\n       this.path.push(node);"
        },
        {
            "sha": "a2ac29fa8174c7baf74961379f536f430a9fde03",
            "filename": "packages/language-service/ivy/test/legacy/template_target_spec.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 7,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/1bf1b685d6ac2f2dfea5363b6af604cf48050820/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/1bf1b685d6ac2f2dfea5363b6af604cf48050820/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts?ref=1bf1b685d6ac2f2dfea5363b6af604cf48050820",
            "patch": "@@ -580,13 +580,10 @@ describe('findNodeAtPosition for microsyntax expression', () => {\n   it('should locate bound attribute key when cursor is at the start', () => {\n     const {errors, nodes, position} = parse(`<div *ngFor=\"let item Â¦of items\"></div>`);\n     expect(errors).toBe(null);\n-    // TODO(atscott): Fix this - we throw away the result because we match the variable node, after\n-    // the attribute binding, then throw away the result because we aren't in the variable key\n-    expect(getTargetAtPosition(nodes, position)).toBeNull();\n-    // const {node} = getTargetAtPosition(nodes, position)!;\n-    // expect(isTemplateNode(node!)).toBe(true);\n-    // expect(node).toBeInstanceOf(t.BoundAttribute);\n-    // expect((node as t.BoundAttribute).name).toBe('ngForOf');\n+    const {node} = getTargetAtPosition(nodes, position)!;\n+    expect(isTemplateNode(node!)).toBe(true);\n+    expect(node).toBeInstanceOf(t.BoundAttribute);\n+    expect((node as t.BoundAttribute).name).toBe('ngForOf');\n   });\n \n   it('should locate bound attribute key for trackBy', () => {"
        }
    ],
    "stats": {
        "total": 20,
        "additions": 13,
        "deletions": 7
    }
}