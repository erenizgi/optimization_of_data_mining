{
    "author": "JoostK",
    "message": "refactor(compiler): remove output AST functions (#44411)\n\nThese functions are not used anymore so they are removed.\n\nPR Close #44411",
    "sha": "c7ac2dfcf8dd11bc879496783e7e679c911d5e90",
    "files": [
        {
            "sha": "7af50339bb3ddd05c126533646816225954963d2",
            "filename": "packages/compiler/src/compiler.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/c7ac2dfcf8dd11bc879496783e7e679c911d5e90/packages%2Fcompiler%2Fsrc%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/c7ac2dfcf8dd11bc879496783e7e679c911d5e90/packages%2Fcompiler%2Fsrc%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fcompiler.ts?ref=c7ac2dfcf8dd11bc879496783e7e679c911d5e90",
            "patch": "@@ -53,7 +53,7 @@ export * from './ml_parser/tags';\n export {ParseTreeResult, TreeError} from './ml_parser/parser';\n export {LexerRange} from './ml_parser/lexer';\n export * from './ml_parser/xml_parser';\n-export {ArrayType, DYNAMIC_TYPE, BinaryOperator, BinaryOperatorExpr, BuiltinType, BuiltinTypeName, CommaExpr, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionType, ExpressionVisitor, ExternalExpr, ExternalReference, literalMap, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, NONE_TYPE, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, StatementVisitor, TaggedTemplateExpr, TemplateLiteral, TemplateLiteralElement, Type, TypeVisitor, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr, StmtModifier, Statement, STRING_TYPE, TypeofExpr, collectExternalReferences, jsDocComment, leadingComment, LeadingComment, JSDocComment, UnaryOperator, UnaryOperatorExpr, LocalizedString} from './output/output_ast';\n+export {ArrayType, DYNAMIC_TYPE, BinaryOperator, BinaryOperatorExpr, BuiltinType, BuiltinTypeName, CommaExpr, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionType, ExpressionVisitor, ExternalExpr, ExternalReference, literalMap, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, NONE_TYPE, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, StatementVisitor, TaggedTemplateExpr, TemplateLiteral, TemplateLiteralElement, Type, TypeVisitor, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr, StmtModifier, Statement, STRING_TYPE, TypeofExpr, jsDocComment, leadingComment, LeadingComment, JSDocComment, UnaryOperator, UnaryOperatorExpr, LocalizedString} from './output/output_ast';\n export {EmitterVisitorContext} from './output/abstract_emitter';\n export {JitEvaluator} from './output/output_jit';\n export * from './parse_util';"
        },
        {
            "sha": "24ade4e3a5159bc75fc64818efab6494cd8875e5",
            "filename": "packages/compiler/src/output/output_ast.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 288,
            "changes": 288,
            "blob_url": "https://github.com/angular/angular/blob/c7ac2dfcf8dd11bc879496783e7e679c911d5e90/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_ast.ts",
            "raw_url": "https://github.com/angular/angular/raw/c7ac2dfcf8dd11bc879496783e7e679c911d5e90/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_ast.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_ast.ts?ref=c7ac2dfcf8dd11bc879496783e7e679c911d5e90",
            "patch": "@@ -1083,213 +1083,6 @@ export interface StatementVisitor {\n   visitIfStmt(stmt: IfStmt, context: any): any;\n }\n \n-export class AstTransformer implements StatementVisitor, ExpressionVisitor {\n-  transformExpr(expr: Expression, context: any): Expression {\n-    return expr;\n-  }\n-\n-  transformStmt(stmt: Statement, context: any): Statement {\n-    return stmt;\n-  }\n-\n-  visitReadVarExpr(ast: ReadVarExpr, context: any): any {\n-    return this.transformExpr(ast, context);\n-  }\n-\n-  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any {\n-    return this.transformExpr(ast, context);\n-  }\n-\n-  visitTypeofExpr(expr: TypeofExpr, context: any): any {\n-    return this.transformExpr(\n-        new TypeofExpr(expr.expr.visitExpression(this, context), expr.type, expr.sourceSpan),\n-        context);\n-  }\n-\n-  visitWriteVarExpr(expr: WriteVarExpr, context: any): any {\n-    return this.transformExpr(\n-        new WriteVarExpr(\n-            expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan),\n-        context);\n-  }\n-\n-  visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any {\n-    return this.transformExpr(\n-        new WriteKeyExpr(\n-            expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context),\n-            expr.value.visitExpression(this, context), expr.type, expr.sourceSpan),\n-        context);\n-  }\n-\n-  visitWritePropExpr(expr: WritePropExpr, context: any): any {\n-    return this.transformExpr(\n-        new WritePropExpr(\n-            expr.receiver.visitExpression(this, context), expr.name,\n-            expr.value.visitExpression(this, context), expr.type, expr.sourceSpan),\n-        context);\n-  }\n-\n-  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any {\n-    return this.transformExpr(\n-        new InvokeFunctionExpr(\n-            ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context),\n-            ast.type, ast.sourceSpan),\n-        context);\n-  }\n-\n-  visitTaggedTemplateExpr(ast: TaggedTemplateExpr, context: any): any {\n-    return this.transformExpr(\n-        new TaggedTemplateExpr(\n-            ast.tag.visitExpression(this, context),\n-            new TemplateLiteral(\n-                ast.template.elements,\n-                ast.template.expressions.map((e) => e.visitExpression(this, context))),\n-            ast.type, ast.sourceSpan),\n-        context);\n-  }\n-\n-  visitInstantiateExpr(ast: InstantiateExpr, context: any): any {\n-    return this.transformExpr(\n-        new InstantiateExpr(\n-            ast.classExpr.visitExpression(this, context),\n-            this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan),\n-        context);\n-  }\n-\n-  visitLiteralExpr(ast: LiteralExpr, context: any): any {\n-    return this.transformExpr(ast, context);\n-  }\n-\n-  visitLocalizedString(ast: LocalizedString, context: any): any {\n-    return this.transformExpr(\n-        new LocalizedString(\n-            ast.metaBlock, ast.messageParts, ast.placeHolderNames,\n-            this.visitAllExpressions(ast.expressions, context), ast.sourceSpan),\n-        context);\n-  }\n-\n-  visitExternalExpr(ast: ExternalExpr, context: any): any {\n-    return this.transformExpr(ast, context);\n-  }\n-\n-  visitConditionalExpr(ast: ConditionalExpr, context: any): any {\n-    return this.transformExpr(\n-        new ConditionalExpr(\n-            ast.condition.visitExpression(this, context),\n-            ast.trueCase.visitExpression(this, context),\n-            ast.falseCase!.visitExpression(this, context), ast.type, ast.sourceSpan),\n-        context);\n-  }\n-\n-  visitNotExpr(ast: NotExpr, context: any): any {\n-    return this.transformExpr(\n-        new NotExpr(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n-  }\n-\n-  visitFunctionExpr(ast: FunctionExpr, context: any): any {\n-    return this.transformExpr(\n-        new FunctionExpr(\n-            ast.params, this.visitAllStatements(ast.statements, context), ast.type, ast.sourceSpan),\n-        context);\n-  }\n-\n-  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: any): any {\n-    return this.transformExpr(\n-        new UnaryOperatorExpr(\n-            ast.operator, ast.expr.visitExpression(this, context), ast.type, ast.sourceSpan),\n-        context);\n-  }\n-\n-  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any {\n-    return this.transformExpr(\n-        new BinaryOperatorExpr(\n-            ast.operator, ast.lhs.visitExpression(this, context),\n-            ast.rhs.visitExpression(this, context), ast.type, ast.sourceSpan),\n-        context);\n-  }\n-\n-  visitReadPropExpr(ast: ReadPropExpr, context: any): any {\n-    return this.transformExpr(\n-        new ReadPropExpr(\n-            ast.receiver.visitExpression(this, context), ast.name, ast.type, ast.sourceSpan),\n-        context);\n-  }\n-\n-  visitReadKeyExpr(ast: ReadKeyExpr, context: any): any {\n-    return this.transformExpr(\n-        new ReadKeyExpr(\n-            ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context),\n-            ast.type, ast.sourceSpan),\n-        context);\n-  }\n-\n-  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any {\n-    return this.transformExpr(\n-        new LiteralArrayExpr(\n-            this.visitAllExpressions(ast.entries, context), ast.type, ast.sourceSpan),\n-        context);\n-  }\n-\n-  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any {\n-    const entries = ast.entries.map(\n-        (entry): LiteralMapEntry => new LiteralMapEntry(\n-            entry.key, entry.value.visitExpression(this, context), entry.quoted));\n-    const mapType = new MapType(ast.valueType);\n-    return this.transformExpr(new LiteralMapExpr(entries, mapType, ast.sourceSpan), context);\n-  }\n-  visitCommaExpr(ast: CommaExpr, context: any): any {\n-    return this.transformExpr(\n-        new CommaExpr(this.visitAllExpressions(ast.parts, context), ast.sourceSpan), context);\n-  }\n-  visitAllExpressions<T extends Expression>(exprs: T[], context: any): T[] {\n-    return exprs.map(expr => expr.visitExpression(this, context));\n-  }\n-\n-  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any {\n-    const value = stmt.value && stmt.value.visitExpression(this, context);\n-    return this.transformStmt(\n-        new DeclareVarStmt(\n-            stmt.name, value, stmt.type, stmt.modifiers, stmt.sourceSpan, stmt.leadingComments),\n-        context);\n-  }\n-  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any {\n-    return this.transformStmt(\n-        new DeclareFunctionStmt(\n-            stmt.name, stmt.params, this.visitAllStatements(stmt.statements, context), stmt.type,\n-            stmt.modifiers, stmt.sourceSpan, stmt.leadingComments),\n-        context);\n-  }\n-\n-  visitExpressionStmt(stmt: ExpressionStatement, context: any): any {\n-    return this.transformStmt(\n-        new ExpressionStatement(\n-            stmt.expr.visitExpression(this, context), stmt.sourceSpan, stmt.leadingComments),\n-        context);\n-  }\n-\n-  visitReturnStmt(stmt: ReturnStatement, context: any): any {\n-    return this.transformStmt(\n-        new ReturnStatement(\n-            stmt.value.visitExpression(this, context), stmt.sourceSpan, stmt.leadingComments),\n-        context);\n-  }\n-\n-  visitIfStmt(stmt: IfStmt, context: any): any {\n-    return this.transformStmt(\n-        new IfStmt(\n-            stmt.condition.visitExpression(this, context),\n-            this.visitAllStatements(stmt.trueCase, context),\n-            this.visitAllStatements(stmt.falseCase, context), stmt.sourceSpan,\n-            stmt.leadingComments),\n-        context);\n-  }\n-\n-  visitAllStatements(stmts: Statement[], context: any): Statement[] {\n-    return stmts.map(stmt => stmt.visitStatement(this, context));\n-  }\n-}\n-\n-\n export class RecursiveAstVisitor implements StatementVisitor, ExpressionVisitor {\n   visitType(ast: Type, context: any): any {\n     return ast;\n@@ -1450,87 +1243,6 @@ export class RecursiveAstVisitor implements StatementVisitor, ExpressionVisitor\n   }\n }\n \n-export function findReadVarNames(stmts: Statement[]): Set<string> {\n-  const visitor = new _ReadVarVisitor();\n-  visitor.visitAllStatements(stmts, null);\n-  return visitor.varNames;\n-}\n-\n-class _ReadVarVisitor extends RecursiveAstVisitor {\n-  varNames = new Set<string>();\n-  override visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any {\n-    // Don't descend into nested functions\n-    return stmt;\n-  }\n-  override visitReadVarExpr(ast: ReadVarExpr, context: any): any {\n-    if (ast.name) {\n-      this.varNames.add(ast.name);\n-    }\n-    return null;\n-  }\n-}\n-\n-export function collectExternalReferences(stmts: Statement[]): ExternalReference[] {\n-  const visitor = new _FindExternalReferencesVisitor();\n-  visitor.visitAllStatements(stmts, null);\n-  return visitor.externalReferences;\n-}\n-\n-class _FindExternalReferencesVisitor extends RecursiveAstVisitor {\n-  externalReferences: ExternalReference[] = [];\n-  override visitExternalExpr(e: ExternalExpr, context: any) {\n-    this.externalReferences.push(e.value);\n-    return super.visitExternalExpr(e, context);\n-  }\n-}\n-\n-export function applySourceSpanToStatementIfNeeded(\n-    stmt: Statement, sourceSpan: ParseSourceSpan|null): Statement {\n-  if (!sourceSpan) {\n-    return stmt;\n-  }\n-  const transformer = new _ApplySourceSpanTransformer(sourceSpan);\n-  return stmt.visitStatement(transformer, null);\n-}\n-\n-export function applySourceSpanToExpressionIfNeeded(\n-    expr: Expression, sourceSpan: ParseSourceSpan|null): Expression {\n-  if (!sourceSpan) {\n-    return expr;\n-  }\n-  const transformer = new _ApplySourceSpanTransformer(sourceSpan);\n-  return expr.visitExpression(transformer, null);\n-}\n-\n-class _ApplySourceSpanTransformer extends AstTransformer {\n-  constructor(private sourceSpan: ParseSourceSpan) {\n-    super();\n-  }\n-  private _clone(obj: any): any {\n-    const clone = Object.create(obj.constructor.prototype);\n-    for (let prop of Object.keys(obj)) {\n-      clone[prop] = obj[prop];\n-    }\n-    return clone;\n-  }\n-\n-  override transformExpr(expr: Expression, context: any): Expression {\n-    if (!expr.sourceSpan) {\n-      expr = this._clone(expr);\n-      expr.sourceSpan = this.sourceSpan;\n-    }\n-    return expr;\n-  }\n-\n-  override transformStmt(stmt: Statement, context: any): Statement {\n-    if (!stmt.sourceSpan) {\n-      stmt = this._clone(stmt);\n-      stmt.sourceSpan = this.sourceSpan;\n-    }\n-    return stmt;\n-  }\n-}\n-\n export function leadingComment(\n     text: string, multiline: boolean = false, trailingNewline: boolean = true): LeadingComment {\n   return new LeadingComment(text, multiline, trailingNewline);"
        },
        {
            "sha": "d0130d17191a914bb801b841021f0b58b12f2c51",
            "filename": "packages/compiler/test/output/output_ast_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 25,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/d196cbc3322ac2ad9be61a80ab74f87079adeb91/packages%2Fcompiler%2Ftest%2Foutput%2Foutput_ast_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/d196cbc3322ac2ad9be61a80ab74f87079adeb91/packages%2Fcompiler%2Ftest%2Foutput%2Foutput_ast_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Foutput%2Foutput_ast_spec.ts?ref=d196cbc3322ac2ad9be61a80ab74f87079adeb91",
            "patch": "@@ -1,25 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as o from '../../src/output/output_ast';\n-\n-{\n-  describe('OutputAst', () => {\n-    describe('collectExternalReferences', () => {\n-      it('should find expressions of variable types', () => {\n-        const ref1 = new o.ExternalReference('aModule', 'name1');\n-        const ref2 = new o.ExternalReference('aModule', 'name2');\n-        const stmt =\n-            o.variable('test').set(o.NULL_EXPR).toDeclStmt(o.importType(ref1, [o.importType(ref2)!\n-            ]));\n-\n-        expect(o.collectExternalReferences([stmt])).toEqual([ref1, ref2]);\n-      });\n-    });\n-  });\n-}"
        }
    ],
    "stats": {
        "total": 315,
        "additions": 1,
        "deletions": 314
    }
}