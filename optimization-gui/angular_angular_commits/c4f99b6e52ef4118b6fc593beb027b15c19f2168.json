{
    "author": "alxhub",
    "message": "refactor(compiler-cli): move global completion into new CompletionEngine (#39278)\n\nThis commit refactors the previously introduced `getGlobalCompletions()` API\nfor the template type-checker in a couple ways:\n\n * The return type is adjusted to use a `Map` instead of an array, and\n   separate out the component context completion position. This allows for a\n   cleaner integration in the language service.\n * A new `CompletionEngine` class is introduced which powers autocompletion\n   for a single component, and can cache completion results.\n * The `CompletionEngine` for each component is itself cached on the\n   `TemplateTypeCheckerImpl` and is invalidated when the component template\n   is overridden or reset.\n\nThis refactoring simplifies the `TemplateTypeCheckerImpl` class by\nextracting the autocompletion logic, enables caching for better performance,\nand prepares for the introduction of other autocompletion APIs.\n\nPR Close #39278",
    "sha": "c4f99b6e52ef4118b6fc593beb027b15c19f2168",
    "files": [
        {
            "sha": "2199a91fc7340270221e00cce8dc81eebd1c5328",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/checker.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/c4f99b6e52ef4118b6fc593beb027b15c19f2168/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/c4f99b6e52ef4118b6fc593beb027b15c19f2168/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts?ref=c4f99b6e52ef4118b6fc593beb027b15c19f2168",
            "patch": "@@ -100,7 +100,7 @@ export interface TemplateTypeChecker {\n    * template variables which are in scope for that expression.\n    */\n   getGlobalCompletions(context: TmplAstTemplate|null, component: ts.ClassDeclaration):\n-      GlobalCompletion[];\n+      GlobalCompletion|null;\n }\n \n /**"
        },
        {
            "sha": "7fb996cfb49d5677480f189ea533aed064c35321",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/completion.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 17,
            "changes": 46,
            "blob_url": "https://github.com/angular/angular/blob/c4f99b6e52ef4118b6fc593beb027b15c19f2168/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fcompletion.ts",
            "raw_url": "https://github.com/angular/angular/raw/c4f99b6e52ef4118b6fc593beb027b15c19f2168/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fcompletion.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fcompletion.ts?ref=c4f99b6e52ef4118b6fc593beb027b15c19f2168",
            "patch": "@@ -13,34 +13,21 @@ import {ShimLocation} from './symbols';\n /**\n  * An autocompletion source of any kind.\n  */\n-export type Completion = CompletionContextComponent|CompletionReference|CompletionVariable;\n-\n-/**\n- * An autocompletion source that drives completion in a global context.\n- */\n-export type GlobalCompletion = CompletionContextComponent|CompletionReference|CompletionVariable;\n+export type Completion = ReferenceCompletion|VariableCompletion;\n \n /**\n  * Discriminant of an autocompletion source (a `Completion`).\n  */\n+\n export enum CompletionKind {\n-  ContextComponent,\n   Reference,\n   Variable,\n }\n \n-/**\n- * An autocompletion source backed by a shim file position where TS APIs can be used to retrieve\n- * completions for the context component of a template.\n- */\n-export interface CompletionContextComponent extends ShimLocation {\n-  kind: CompletionKind.ContextComponent;\n-}\n-\n /**\n  * An autocompletion result representing a local reference declared in the template.\n  */\n-export interface CompletionReference {\n+export interface ReferenceCompletion {\n   kind: CompletionKind.Reference;\n \n   /**\n@@ -52,11 +39,36 @@ export interface CompletionReference {\n /**\n  * An autocompletion result representing a variable declared in the template.\n  */\n-export interface CompletionVariable {\n+export interface VariableCompletion {\n   kind: CompletionKind.Variable;\n \n   /**\n    * The `TmplAstVariable` from the template which should be available as a completion.\n    */\n   node: TmplAstVariable;\n }\n+\n+/**\n+ * Autocompletion data for an expression in the global scope.\n+ *\n+ * Global completion is accomplished by merging data from two sources:\n+ *  * TypeScript completion of the component's class members.\n+ *  * Local references and variables that are in scope at a given template level.\n+ */\n+export interface GlobalCompletion {\n+  /**\n+   * A location within the type-checking shim where TypeScript's completion APIs can be used to\n+   * access completions for the template's component context (component class members).\n+   */\n+  componentContext: ShimLocation;\n+\n+  /**\n+   * `Map` of local references and variables that are visible at the requested level of the\n+   * template.\n+   *\n+   * Shadowing of references/variables from multiple levels of the template has already been\n+   * accounted for in the preparation of `templateContext`. Entries here shadow component members of\n+   * the same name (from the `componentContext` completions).\n+   */\n+  templateContext: Map<string, ReferenceCompletion|VariableCompletion>;\n+}"
        },
        {
            "sha": "ad8895d4de79be08a0e8756536e52ce68ed9c4ba",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts",
            "status": "modified",
            "additions": 34,
            "deletions": 39,
            "changes": 73,
            "blob_url": "https://github.com/angular/angular/blob/c4f99b6e52ef4118b6fc593beb027b15c19f2168/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/c4f99b6e52ef4118b6fc593beb027b15c19f2168/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts?ref=c4f99b6e52ef4118b6fc593beb027b15c19f2168",
            "patch": "@@ -20,6 +20,7 @@ import {CompletionKind, GlobalCompletion, OptimizeFor, ProgramTypeCheckAdapter,\n import {TemplateDiagnostic} from '../diagnostics';\n \n import {ExpressionIdentifier, findFirstMatchingNode} from './comments';\n+import {CompletionEngine} from './completion';\n import {InliningMode, ShimTypeCheckingData, TemplateData, TypeCheckContextImpl, TypeCheckingHost} from './context';\n import {findTypeCheckBlock, shouldReportDiagnostic, TemplateSourceResolver, translateDiagnostic} from './diagnostics';\n import {TemplateSourceManager} from './source';\n@@ -32,6 +33,16 @@ import {SymbolBuilder} from './template_symbol_builder';\n  */\n export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n   private state = new Map<AbsoluteFsPath, FileTypeCheckingData>();\n+\n+  /**\n+   * Stores the `CompletionEngine` which powers autocompletion for each component class.\n+   *\n+   * Must be invalidated whenever the component's template or the `ts.Program` changes. Invalidation\n+   * on template changes is performed within this `TemplateTypeCheckerImpl` instance. When the\n+   * `ts.Program` changes, the `TemplateTypeCheckerImpl` as a whole is destroyed and replaced.\n+   */\n+  private completionCache = new Map<ts.ClassDeclaration, CompletionEngine>();\n+\n   private isComplete = false;\n \n   constructor(\n@@ -51,6 +62,11 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n         fileRecord.isComplete = false;\n       }\n     }\n+\n+    // Ideally only those components with overridden templates would have their caches invalidated,\n+    // but the `TemplateTypeCheckerImpl` does not track the class for components with overrides. As\n+    // a quick workaround, clear the entire cache instead.\n+    this.completionCache.clear();\n   }\n \n   getTemplate(component: ts.ClassDeclaration): TmplAstNode[]|null {\n@@ -130,6 +146,9 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     fileRecord.isComplete = false;\n     this.isComplete = false;\n \n+    // Overriding a component's template invalidates its autocompletion results.\n+    this.completionCache.delete(component);\n+\n     return {nodes};\n   }\n \n@@ -209,51 +228,27 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n   }\n \n   getGlobalCompletions(context: TmplAstTemplate|null, component: ts.ClassDeclaration):\n-      GlobalCompletion[] {\n-    const {tcb, data, shimPath} = this.getLatestComponentState(component);\n-    if (tcb === null || data === null) {\n-      return [];\n+      GlobalCompletion|null {\n+    const engine = this.getOrCreateCompletionEngine(component);\n+    if (engine === null) {\n+      return null;\n     }\n+    return engine.getGlobalCompletions(context);\n+  }\n \n-    const {boundTarget} = data;\n-\n-    // Global completions are the union of two separate pieces: a `ContextComponentCompletion` which\n-    // is created from an expression within the TCB, and a list of named entities (variables and\n-    // references) which are visible within the given `context` template.\n-    const completions: GlobalCompletion[] = [];\n-\n-    const globalRead = findFirstMatchingNode(tcb, {\n-      filter: ts.isPropertyAccessExpression,\n-      withExpressionIdentifier: ExpressionIdentifier.COMPONENT_COMPLETION\n-    });\n-\n-    if (globalRead === null) {\n-      return [];\n+  private getOrCreateCompletionEngine(component: ts.ClassDeclaration): CompletionEngine|null {\n+    if (this.completionCache.has(component)) {\n+      return this.completionCache.get(component)!;\n     }\n \n-    completions.push({\n-      kind: CompletionKind.ContextComponent,\n-      shimPath,\n-      positionInShimFile: globalRead.name.getStart(),\n-    });\n-\n-    // Add completions for each entity in the template scope. Since each entity is uniquely named,\n-    // there is no special ordering applied here.\n-    for (const node of boundTarget.getEntitiesInTemplateScope(context)) {\n-      if (node instanceof TmplAstReference) {\n-        completions.push({\n-          kind: CompletionKind.Reference,\n-          node: node,\n-        });\n-      } else {\n-        completions.push({\n-          kind: CompletionKind.Variable,\n-          node: node,\n-        });\n-      }\n+    const {tcb, data, shimPath} = this.getLatestComponentState(component);\n+    if (tcb === null || data === null) {\n+      return null;\n     }\n \n-    return completions;\n+    const engine = new CompletionEngine(tcb, data, shimPath);\n+    this.completionCache.set(component, engine);\n+    return engine;\n   }\n \n   private maybeAdoptPriorResultsForFile(sf: ts.SourceFile): void {"
        },
        {
            "sha": "7421ef557a5fa2257d18add1330abb226764a27c",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/completion.ts",
            "status": "added",
            "additions": 82,
            "deletions": 0,
            "changes": 82,
            "blob_url": "https://github.com/angular/angular/blob/c4f99b6e52ef4118b6fc593beb027b15c19f2168/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcompletion.ts",
            "raw_url": "https://github.com/angular/angular/raw/c4f99b6e52ef4118b6fc593beb027b15c19f2168/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcompletion.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcompletion.ts?ref=c4f99b6e52ef4118b6fc593beb027b15c19f2168",
            "patch": "@@ -0,0 +1,82 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {TmplAstReference, TmplAstTemplate} from '@angular/compiler';\n+import * as ts from 'typescript';\n+\n+import {AbsoluteFsPath} from '../../file_system';\n+import {CompletionKind, GlobalCompletion, ReferenceCompletion, VariableCompletion} from '../api';\n+\n+import {ExpressionIdentifier, findFirstMatchingNode} from './comments';\n+import {TemplateData} from './context';\n+\n+/**\n+ * Powers autocompletion for a specific component.\n+ *\n+ * Internally caches autocompletion results, and must be discarded if the component template or\n+ * surrounding TS program have changed.\n+ */\n+export class CompletionEngine {\n+  /**\n+   * Cache of `GlobalCompletion`s for various levels of the template, including the root template\n+   * (`null`).\n+   */\n+  private globalCompletionCache = new Map<TmplAstTemplate|null, GlobalCompletion>();\n+\n+  constructor(private tcb: ts.Node, private data: TemplateData, private shimPath: AbsoluteFsPath) {}\n+\n+  /**\n+   * Get global completions within the given template context - either a `TmplAstTemplate` embedded\n+   * view, or `null` for the root template context.\n+   */\n+  getGlobalCompletions(context: TmplAstTemplate|null): GlobalCompletion|null {\n+    if (this.globalCompletionCache.has(context)) {\n+      return this.globalCompletionCache.get(context)!;\n+    }\n+\n+    // Find the component completion expression within the TCB. This looks like: `ctx. /* ... */;`\n+    const globalRead = findFirstMatchingNode(this.tcb, {\n+      filter: ts.isPropertyAccessExpression,\n+      withExpressionIdentifier: ExpressionIdentifier.COMPONENT_COMPLETION\n+    });\n+\n+    if (globalRead === null) {\n+      return null;\n+    }\n+\n+    const completion: GlobalCompletion = {\n+      componentContext: {\n+        shimPath: this.shimPath,\n+        // `globalRead.name` is an empty `ts.Identifier`, so its start position immediately follows\n+        // the `.` in `ctx.`. TS autocompletion APIs can then be used to access completion results\n+        // for the component context.\n+        positionInShimFile: globalRead.name.getStart(),\n+      },\n+      templateContext: new Map<string, ReferenceCompletion|VariableCompletion>(),\n+    };\n+\n+    // The bound template already has details about the references and variables in scope in the\n+    // `context` template - they just need to be converted to `Completion`s.\n+    for (const node of this.data.boundTarget.getEntitiesInTemplateScope(context)) {\n+      if (node instanceof TmplAstReference) {\n+        completion.templateContext.set(node.name, {\n+          kind: CompletionKind.Reference,\n+          node,\n+        });\n+      } else {\n+        completion.templateContext.set(node.name, {\n+          kind: CompletionKind.Variable,\n+          node,\n+        });\n+      }\n+    }\n+\n+    this.globalCompletionCache.set(context, completion);\n+    return completion;\n+  }\n+}"
        },
        {
            "sha": "7b8e6f6a4462debf575a9ced619d773b6b4e3ed1",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker__completion_spec.ts",
            "status": "modified",
            "additions": 101,
            "deletions": 100,
            "changes": 201,
            "blob_url": "https://github.com/angular/angular/blob/c4f99b6e52ef4118b6fc593beb027b15c19f2168/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__completion_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/c4f99b6e52ef4118b6fc593beb027b15c19f2168/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__completion_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__completion_spec.ts?ref=c4f99b6e52ef4118b6fc593beb027b15c19f2168",
            "patch": "@@ -12,127 +12,128 @@ import * as ts from 'typescript';\n import {absoluteFrom, getSourceFileOrError} from '../../file_system';\n import {runInEachFileSystem} from '../../file_system/testing';\n import {getTokenAtPosition} from '../../util/src/typescript';\n-import {CompletionKind, TypeCheckingConfig} from '../api';\n+import {CompletionKind, GlobalCompletion, TemplateTypeChecker, TypeCheckingConfig} from '../api';\n \n-import {getClass, setup as baseTestSetup, TypeCheckingTarget} from './test_utils';\n+import {getClass, setup, TypeCheckingTarget} from './test_utils';\n \n runInEachFileSystem(() => {\n   describe('TemplateTypeChecker.getGlobalCompletions()', () => {\n     it('should return a completion point in the TCB for the component context', () => {\n-      const MAIN_TS = absoluteFrom('/main.ts');\n-      const {templateTypeChecker, programStrategy} = setup([\n-        {\n-          fileName: MAIN_TS,\n-          templates: {'SomeCmp': `No special template needed`},\n-          source: `\n-            export class SomeCmp {}\n-          `,\n-        },\n-      ]);\n-      const sf = getSourceFileOrError(programStrategy.getProgram(), MAIN_TS);\n-      const SomeCmp = getClass(sf, 'SomeCmp');\n-\n-      const [global, ...rest] =\n-          templateTypeChecker.getGlobalCompletions(/* root template */ null, SomeCmp);\n-      expect(rest.length).toBe(0);\n-      if (global.kind !== CompletionKind.ContextComponent) {\n-        return fail(`Expected a ContextComponent completion`);\n-      }\n-      const tcbSf =\n-          getSourceFileOrError(programStrategy.getProgram(), absoluteFrom(global.shimPath));\n-      const node = getTokenAtPosition(tcbSf, global.positionInShimFile).parent;\n+      const {completions, program} = setupCompletions(`No special template needed`);\n+      expect(completions.templateContext.size).toBe(0);\n+      const {shimPath, positionInShimFile} = completions.componentContext;\n+      const tcbSf = getSourceFileOrError(program, shimPath);\n+      const node = getTokenAtPosition(tcbSf, positionInShimFile).parent;\n       if (!ts.isExpressionStatement(node)) {\n         return fail(`Expected a ts.ExpressionStatement`);\n       }\n       expect(node.expression.getText()).toEqual('ctx.');\n       // The position should be between the '.' and a following space.\n-      expect(tcbSf.text.substr(global.positionInShimFile - 1, 2)).toEqual('. ');\n+      expect(tcbSf.text.substr(positionInShimFile - 1, 2)).toEqual('. ');\n     });\n \n     it('should return additional completions for references and variables when available', () => {\n-      const MAIN_TS = absoluteFrom('/main.ts');\n-      const {templateTypeChecker, programStrategy} = setup([\n-        {\n-          fileName: MAIN_TS,\n-          templates: {\n-            'SomeCmp': `\n-              <div *ngFor=\"let user of users\">\n-                <div #innerRef></div>\n-                <div *ngIf=\"user\">\n-                  <div #notInScope></div>\n-                </div>\n-              </div>\n-              <div #topLevelRef></div>\n-          `\n-          },\n-          source: `\n-            export class SomeCmp {\n-              users: string[];\n-            }\n-          `,\n-        },\n-      ]);\n-      const sf = getSourceFileOrError(programStrategy.getProgram(), MAIN_TS);\n-      const SomeCmp = getClass(sf, 'SomeCmp');\n-\n-      const tmpl = templateTypeChecker.getTemplate(SomeCmp)!;\n-      const ngForTemplate = tmpl[0] as TmplAstTemplate;\n-\n-      const [contextCmp, ...rest] =\n-          templateTypeChecker.getGlobalCompletions(ngForTemplate, SomeCmp);\n-      if (contextCmp.kind !== CompletionKind.ContextComponent) {\n-        return fail(`Expected first completion to be a ContextComponent`);\n-      }\n-\n-      const completionKeys: string[] = [];\n-      for (const completion of rest) {\n-        if (completion.kind !== CompletionKind.Reference &&\n-            completion.kind !== CompletionKind.Variable) {\n-          return fail(`Unexpected CompletionKind, expected a Reference or Variable`);\n-        }\n-        completionKeys.push(completion.node.name);\n-      }\n-\n-      expect(new Set(completionKeys)).toEqual(new Set(['innerRef', 'user', 'topLevelRef']));\n+      const template = `\n+        <div *ngFor=\"let user of users\">\n+          <div #innerRef></div>\n+          <div *ngIf=\"user\">\n+            <div #notInScope></div>\n+          </div>\n+        </div>\n+        <div #topLevelRef></div>\n+      `;\n+      const members = `users: string[];`;\n+      // Embedded view in question is the first node in the template (index 0).\n+      const {completions} = setupCompletions(template, members, 0);\n+      expect(new Set(completions.templateContext.keys())).toEqual(new Set([\n+        'innerRef', 'user', 'topLevelRef'\n+      ]));\n     });\n \n     it('should support shadowing between outer and inner templates  ', () => {\n-      const MAIN_TS = absoluteFrom('/main.ts');\n-      const {templateTypeChecker, programStrategy} = setup([\n-        {\n-          fileName: MAIN_TS,\n-          templates: {\n-            'SomeCmp': `\n-              <div *ngFor=\"let user of users\">\n-                Within this template, 'user' should be a variable, not a reference.\n-              </div>\n-              <div #user>Out here, 'user' is the reference.</div>\n-          `\n-          },\n-          source: `\n-            export class SomeCmp {\n-              users: string[];\n-            }\n-          `,\n-        },\n-      ]);\n-      const sf = getSourceFileOrError(programStrategy.getProgram(), MAIN_TS);\n-      const SomeCmp = getClass(sf, 'SomeCmp');\n-\n-      const tmpl = templateTypeChecker.getTemplate(SomeCmp)!;\n-      const ngForTemplate = tmpl[0] as TmplAstTemplate;\n-\n-      const [_a, userAtTopLevel] =\n-          templateTypeChecker.getGlobalCompletions(/* root template */ null, SomeCmp);\n-      const [_b, userInNgFor] = templateTypeChecker.getGlobalCompletions(ngForTemplate, SomeCmp);\n+      const template = `\n+        <div *ngFor=\"let user of users\">\n+          Within this template, 'user' should be a variable, not a reference.\n+        </div>\n+        <div #user>Out here, 'user' is the reference.</div>\n+      `;\n+      const members = `users: string[];`;\n+      // Completions for the top level.\n+      const {completions: topLevel} = setupCompletions(template, members);\n+      // Completions within the embedded view at index 0.\n+      const {completions: inNgFor} = setupCompletions(template, members, 0);\n+\n+      expect(topLevel.templateContext.has('user')).toBeTrue();\n+      const userAtTopLevel = topLevel.templateContext.get('user')!;\n+      expect(inNgFor.templateContext.has('user')).toBeTrue();\n+      const userInNgFor = inNgFor.templateContext.get('user')!;\n \n       expect(userAtTopLevel.kind).toBe(CompletionKind.Reference);\n       expect(userInNgFor.kind).toBe(CompletionKind.Variable);\n     });\n+\n+    it('should invalidate cached completions when overrides change', () => {\n+      // The template starts with a #foo local reference.\n+      const {completions: before, templateTypeChecker, component} =\n+          setupCompletions('<div #foo></div>');\n+      expect(Array.from(before.templateContext.keys())).toEqual(['foo']);\n+\n+      // Override the template and change the name of the local reference to #bar. This should\n+      // invalidate any cached completions.\n+      templateTypeChecker.overrideComponentTemplate(component, '<div #bar></div>');\n+\n+      // Fresh completions should include the #bar reference instead.\n+      const afterOverride =\n+          templateTypeChecker.getGlobalCompletions(/* root template */ null, component)!;\n+      expect(afterOverride).toBeDefined();\n+      expect(Array.from(afterOverride.templateContext.keys())).toEqual(['bar']);\n+\n+      // Reset the template to its original. This should also invalidate any cached completions.\n+      templateTypeChecker.resetOverrides();\n+\n+      // Fresh completions should include the original #foo now.\n+      const afterReset =\n+          templateTypeChecker.getGlobalCompletions(/* root template */ null, component)!;\n+      expect(afterReset).toBeDefined();\n+      expect(Array.from(afterReset.templateContext.keys())).toEqual(['foo']);\n+    });\n   });\n });\n \n-function setup(targets: TypeCheckingTarget[], config?: Partial<TypeCheckingConfig>) {\n-  return baseTestSetup(\n-      targets, {inlining: false, config: {...config, enableTemplateTypeChecker: true}});\n+function setupCompletions(\n+    template: string, componentMembers: string = '', inChildTemplateAtIndex: number|null = null): {\n+  completions: GlobalCompletion,\n+  program: ts.Program,\n+  templateTypeChecker: TemplateTypeChecker,\n+  component: ts.ClassDeclaration,\n+} {\n+  const MAIN_TS = absoluteFrom('/main.ts');\n+  const {templateTypeChecker, programStrategy} = setup(\n+      [{\n+        fileName: MAIN_TS,\n+        templates: {'SomeCmp': template},\n+        source: `export class SomeCmp { ${componentMembers} }`,\n+      }],\n+      ({inlining: false, config: {enableTemplateTypeChecker: true}}));\n+  const sf = getSourceFileOrError(programStrategy.getProgram(), MAIN_TS);\n+  const SomeCmp = getClass(sf, 'SomeCmp');\n+\n+  let context: TmplAstTemplate|null = null;\n+  if (inChildTemplateAtIndex !== null) {\n+    const tmpl = templateTypeChecker.getTemplate(SomeCmp)![inChildTemplateAtIndex];\n+    if (!(tmpl instanceof TmplAstTemplate)) {\n+      throw new Error(\n+          `AssertionError: expected TmplAstTemplate at index ${inChildTemplateAtIndex}`);\n+    }\n+    context = tmpl;\n+  }\n+\n+  const completions = templateTypeChecker.getGlobalCompletions(context, SomeCmp)!;\n+  expect(completions).toBeDefined();\n+  return {\n+    completions,\n+    program: programStrategy.getProgram(),\n+    templateTypeChecker,\n+    component: SomeCmp,\n+  };\n }"
        }
    ],
    "stats": {
        "total": 404,
        "additions": 247,
        "deletions": 157
    }
}