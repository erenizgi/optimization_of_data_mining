{
    "author": "atscott",
    "message": "refactor(compiler-cli): Return symbols for all matching outputs (#40144)\n\nThis commit ensures that the template type checker returns symbols for\nall outputs if a template output listener binds to more than one.\n\nPR Close #40144",
    "sha": "989b4a94d4330ac9755c87da2ac55d5dcd3877f6",
    "files": [
        {
            "sha": "d3fcc2f5c46f1065e72196b73f0fabd90632b5bb",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder.ts",
            "status": "modified",
            "additions": 48,
            "deletions": 49,
            "changes": 97,
            "blob_url": "https://github.com/angular/angular/blob/989b4a94d4330ac9755c87da2ac55d5dcd3877f6/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "raw_url": "https://github.com/angular/angular/raw/989b4a94d4330ac9755c87da2ac55d5dcd3877f6/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts?ref=989b4a94d4330ac9755c87da2ac55d5dcd3877f6",
            "patch": "@@ -173,72 +173,71 @@ export class SymbolBuilder {\n     // * _t1.addEventListener(handler);\n     // Even with strict null checks disabled, we still produce the access as a separate statement\n     // so that it can be found here.\n-    const outputFieldAccess = findFirstMatchingNode(\n+    const outputFieldAccesses = findAllMatchingNodes(\n         this.typeCheckBlock, {withSpan: eventBinding.keySpan, filter: isAccessExpression});\n-    if (outputFieldAccess === null) {\n-      return null;\n-    }\n-\n-    const consumer = this.templateData.boundTarget.getConsumerOfBinding(eventBinding);\n-    if (consumer === null) {\n-      return null;\n-    }\n \n-    if (consumer instanceof TmplAstTemplate || consumer instanceof TmplAstElement) {\n-      if (!ts.isPropertyAccessExpression(outputFieldAccess) ||\n-          outputFieldAccess.name.text !== 'addEventListener') {\n-        return null;\n+    const bindings: BindingSymbol[] = [];\n+    for (const outputFieldAccess of outputFieldAccesses) {\n+      const consumer = this.templateData.boundTarget.getConsumerOfBinding(eventBinding);\n+      if (consumer === null) {\n+        continue;\n       }\n \n-      const addEventListener = outputFieldAccess.name;\n-      const tsSymbol = this.getTypeChecker().getSymbolAtLocation(addEventListener);\n-      const tsType = this.getTypeChecker().getTypeAtLocation(addEventListener);\n-      const positionInShimFile = this.getShimPositionForNode(addEventListener);\n-      const target = this.getSymbol(consumer);\n+      if (consumer instanceof TmplAstTemplate || consumer instanceof TmplAstElement) {\n+        if (!ts.isPropertyAccessExpression(outputFieldAccess) ||\n+            outputFieldAccess.name.text !== 'addEventListener') {\n+          continue;\n+        }\n \n-      if (target === null || tsSymbol === undefined) {\n-        return null;\n-      }\n+        const addEventListener = outputFieldAccess.name;\n+        const tsSymbol = this.getTypeChecker().getSymbolAtLocation(addEventListener);\n+        const tsType = this.getTypeChecker().getTypeAtLocation(addEventListener);\n+        const positionInShimFile = this.getShimPositionForNode(addEventListener);\n+        const target = this.getSymbol(consumer);\n \n-      return {\n-        kind: SymbolKind.Output,\n-        bindings: [{\n+        if (target === null || tsSymbol === undefined) {\n+          continue;\n+        }\n+\n+        bindings.push({\n           kind: SymbolKind.Binding,\n           tsSymbol,\n           tsType,\n           target,\n           shimLocation: {shimPath: this.shimPath, positionInShimFile},\n-        }],\n-      };\n-    } else {\n-      if (!ts.isElementAccessExpression(outputFieldAccess)) {\n-        return null;\n-      }\n-      const tsSymbol =\n-          this.getTypeChecker().getSymbolAtLocation(outputFieldAccess.argumentExpression);\n-      if (tsSymbol === undefined) {\n-        return null;\n-      }\n-\n-\n-      const target = this.getDirectiveSymbolForAccessExpression(outputFieldAccess, consumer);\n-      if (target === null) {\n-        return null;\n-      }\n-\n-      const positionInShimFile = this.getShimPositionForNode(outputFieldAccess);\n-      const tsType = this.getTypeChecker().getTypeAtLocation(outputFieldAccess);\n-      return {\n-        kind: SymbolKind.Output,\n-        bindings: [{\n+        });\n+      } else {\n+        if (!ts.isElementAccessExpression(outputFieldAccess)) {\n+          continue;\n+        }\n+        const tsSymbol =\n+            this.getTypeChecker().getSymbolAtLocation(outputFieldAccess.argumentExpression);\n+        if (tsSymbol === undefined) {\n+          continue;\n+        }\n+\n+\n+        const target = this.getDirectiveSymbolForAccessExpression(outputFieldAccess, consumer);\n+        if (target === null) {\n+          continue;\n+        }\n+\n+        const positionInShimFile = this.getShimPositionForNode(outputFieldAccess);\n+        const tsType = this.getTypeChecker().getTypeAtLocation(outputFieldAccess);\n+        bindings.push({\n           kind: SymbolKind.Binding,\n           tsSymbol,\n           tsType,\n           target,\n           shimLocation: {shimPath: this.shimPath, positionInShimFile},\n-        }],\n-      };\n+        });\n+      }\n     }\n+    if (bindings.length === 0) {\n+      return null;\n+    }\n+\n+    return {kind: SymbolKind.Output, bindings};\n   }\n \n   private getSymbolOfInputBinding(binding: TmplAstBoundAttribute|"
        },
        {
            "sha": "a1fcef7a11cc053fca4a0195d4ffeb18f4065999",
            "filename": "packages/language-service/ivy/test/definitions_spec.ts",
            "status": "modified",
            "additions": 50,
            "deletions": 0,
            "changes": 50,
            "blob_url": "https://github.com/angular/angular/blob/989b4a94d4330ac9755c87da2ac55d5dcd3877f6/packages%2Flanguage-service%2Fivy%2Ftest%2Fdefinitions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/989b4a94d4330ac9755c87da2ac55d5dcd3877f6/packages%2Flanguage-service%2Fivy%2Ftest%2Fdefinitions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fdefinitions_spec.ts?ref=989b4a94d4330ac9755c87da2ac55d5dcd3877f6",
            "patch": "@@ -87,6 +87,56 @@ describe('definitions', () => {\n     assertFileNames([def, def2], ['dir2.ts', 'dir.ts']);\n   });\n \n+  it('gets definitions for all outputs when attribute matches more than one', () => {\n+    initMockFileSystem('Native');\n+    const {cursor, text} = extractCursorInfo('<div dir (someEvÂ¦ent)=\"doSomething()\"></div>');\n+    const templateFile = {contents: text, name: absoluteFrom('/app.html')};\n+    const dirFile = {\n+      name: absoluteFrom('/dir.ts'),\n+      contents: `\n+      import {Directive, Output, EventEmitter} from '@angular/core';\n+\n+      @Directive({selector: '[dir]'})\n+      export class MyDir {\n+        @Output() someEvent = new EventEmitter<void>();\n+      }`,\n+    };\n+    const dirFile2 = {\n+      name: absoluteFrom('/dir2.ts'),\n+      contents: `\n+      import {Directive, Output, EventEmitter} from '@angular/core';\n+\n+      @Directive({selector: '[dir]'})\n+      export class MyDir2 {\n+        @Output() someEvent = new EventEmitter<void>();\n+      }`,\n+    };\n+    const appFile = {\n+      name: absoluteFrom('/app.ts'),\n+      contents: `\n+        import {Component, NgModule} from '@angular/core';\n+        import {CommonModule} from '@angular/common';\n+\n+        @Component({templateUrl: 'app.html'})\n+        export class AppCmp {\n+          doSomething() {}\n+        }\n+      `\n+    };\n+    const env = createModuleWithDeclarations([appFile, dirFile, dirFile2], [templateFile]);\n+    const {textSpan, definitions} =\n+        getDefinitionsAndAssertBoundSpan(env, absoluteFrom('/app.html'), cursor);\n+    expect(text.substr(textSpan.start, textSpan.length)).toEqual('someEvent');\n+\n+    expect(definitions.length).toEqual(2);\n+    const [def, def2] = definitions;\n+    expect(def.textSpan).toContain('someEvent');\n+    expect(def2.textSpan).toContain('someEvent');\n+    // TODO(atscott): investigate why the text span includes more than just 'someEvent'\n+    // assertTextSpans([def, def2], ['someEvent']);\n+    assertFileNames([def, def2], ['dir2.ts', 'dir.ts']);\n+  });\n+\n   function getDefinitionsAndAssertBoundSpan(\n       env: LanguageServiceTestEnvironment, fileName: AbsoluteFsPath, cursor: number) {\n     env.expectNoSourceDiagnostics();"
        }
    ],
    "stats": {
        "total": 147,
        "additions": 98,
        "deletions": 49
    }
}