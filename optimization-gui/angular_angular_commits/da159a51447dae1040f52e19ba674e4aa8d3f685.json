{
    "author": "JoostK",
    "message": "refactor(compiler): cleanup AST fixup of listener instructions (#44411)\n\nThis commit refactors the generation of listener instructions to no\nlonger fixup the output AST that was designed for ViewEngine.\n\nPR Close #44411",
    "sha": "da159a51447dae1040f52e19ba674e4aa8d3f685",
    "files": [
        {
            "sha": "e105a81853566c5dc574b5a78694c030a7d4f30c",
            "filename": "packages/compiler/src/compiler_util/expression_converter.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 67,
            "changes": 72,
            "blob_url": "https://github.com/angular/angular/blob/da159a51447dae1040f52e19ba674e4aa8d3f685/packages%2Fcompiler%2Fsrc%2Fcompiler_util%2Fexpression_converter.ts",
            "raw_url": "https://github.com/angular/angular/raw/da159a51447dae1040f52e19ba674e4aa8d3f685/packages%2Fcompiler%2Fsrc%2Fcompiler_util%2Fexpression_converter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fcompiler_util%2Fexpression_converter.ts?ref=da159a51447dae1040f52e19ba674e4aa8d3f685",
            "patch": "@@ -22,49 +22,6 @@ export interface LocalResolver {\n   maybeRestoreView(): void;\n }\n \n-export class ConvertActionBindingResult {\n-  /**\n-   * Store statements which are render3 compatible.\n-   */\n-  render3Stmts: o.Statement[];\n-  constructor(\n-      /**\n-       * Render2 compatible statements,\n-       */\n-      public stmts: o.Statement[],\n-      /**\n-       * Variable name used with render2 compatible statements.\n-       */\n-      public allowDefault: o.ReadVarExpr) {\n-    /**\n-     * This is bit of a hack. It converts statements which render2 expects to statements which are\n-     * expected by render3.\n-     *\n-     * Example: `<div click=\"doSomething($event)\">` will generate:\n-     *\n-     * Render3:\n-     * ```\n-     * const pd_b:any = ((<any>ctx.doSomething($event)) !== false);\n-     * return pd_b;\n-     * ```\n-     *\n-     * but render2 expects:\n-     * ```\n-     * return ctx.doSomething($event);\n-     * ```\n-     */\n-    // TODO(misko): remove this hack once we no longer support ViewEngine.\n-    this.render3Stmts = stmts.map((statement: o.Statement) => {\n-      if (statement instanceof o.DeclareVarStmt && statement.name == allowDefault.name &&\n-          statement.value instanceof o.BinaryOperatorExpr) {\n-        const lhs = statement.value.lhs as o.CastExpr;\n-        return new o.ReturnStatement(lhs.value);\n-      }\n-      return statement;\n-    });\n-  }\n-}\n-\n export type InterpolationFunction = (args: o.Expression[]) => o.Expression;\n \n /**\n@@ -75,7 +32,7 @@ export function convertActionBinding(\n     localResolver: LocalResolver|null, implicitReceiver: o.Expression, action: cdAst.AST,\n     bindingId: string, interpolationFunction?: InterpolationFunction,\n     baseSourceSpan?: ParseSourceSpan, implicitReceiverAccesses?: Set<string>,\n-    globals?: Set<string>): ConvertActionBindingResult {\n+    globals?: Set<string>): o.Statement[] {\n   if (!localResolver) {\n     localResolver = new DefaultLocalResolver(globals);\n   }\n@@ -114,20 +71,14 @@ export function convertActionBinding(\n   }\n \n   const lastIndex = actionStmts.length - 1;\n-  let preventDefaultVar: o.ReadVarExpr = null!;\n   if (lastIndex >= 0) {\n     const lastStatement = actionStmts[lastIndex];\n-    const returnExpr = convertStmtIntoExpression(lastStatement);\n-    if (returnExpr) {\n-      // Note: We need to cast the result of the method call to dynamic,\n-      // as it might be a void method!\n-      preventDefaultVar = createPreventDefaultVar(bindingId);\n-      actionStmts[lastIndex] =\n-          preventDefaultVar.set(returnExpr.cast(o.DYNAMIC_TYPE).notIdentical(o.literal(false)))\n-              .toDeclStmt(null, [o.StmtModifier.Final]);\n+    // Ensure that the value of the last expression statement is returned\n+    if (lastStatement instanceof o.ExpressionStatement) {\n+      actionStmts[lastIndex] = new o.ReturnStatement(lastStatement.expr);\n     }\n   }\n-  return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n+  return actionStmts;\n }\n \n export interface BuiltinConverter {\n@@ -959,19 +910,6 @@ function createCurrValueExpr(bindingId: string): o.ReadVarExpr {\n   return o.variable(`currVal_${bindingId}`);  // fix syntax highlighting: `\n }\n \n-function createPreventDefaultVar(bindingId: string): o.ReadVarExpr {\n-  return o.variable(`pd_${bindingId}`);\n-}\n-\n-function convertStmtIntoExpression(stmt: o.Statement): o.Expression|null {\n-  if (stmt instanceof o.ExpressionStatement) {\n-    return stmt.expr;\n-  } else if (stmt instanceof o.ReturnStatement) {\n-    return stmt.value;\n-  }\n-  return null;\n-}\n-\n export class BuiltinFunctionCall extends cdAst.Call {\n   constructor(\n       span: cdAst.ParseSpan, sourceSpan: cdAst.AbsoluteSourceSpan, args: cdAst.AST[],"
        },
        {
            "sha": "73b8f9cb4c90ff0d6164879d008a97c76ea24dd8",
            "filename": "packages/compiler/src/jit_compiler_facade.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/da159a51447dae1040f52e19ba674e4aa8d3f685/packages%2Fcompiler%2Fsrc%2Fjit_compiler_facade.ts",
            "raw_url": "https://github.com/angular/angular/raw/da159a51447dae1040f52e19ba674e4aa8d3f685/packages%2Fcompiler%2Fsrc%2Fjit_compiler_facade.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fjit_compiler_facade.ts?ref=da159a51447dae1040f52e19ba674e4aa8d3f685",
            "patch": "@@ -26,7 +26,6 @@ import {compileComponentFromMetadata, compileDirectiveFromMetadata, ParsedHostBi\n import {makeBindingParser, parseTemplate} from './render3/view/template';\n import {ResourceLoader} from './resource_loader';\n import {DomElementSchemaRegistry} from './schema/dom_element_schema_registry';\n-import {resolveForwardRef} from './util';\n \n export class CompilerFacadeImpl implements CompilerFacade {\n   FactoryTarget = FactoryTarget as any;"
        },
        {
            "sha": "7f287645ddeebfb0c28ca9b1ad5d11fa223a2653",
            "filename": "packages/compiler/src/render3/view/template.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/da159a51447dae1040f52e19ba674e4aa8d3f685/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "raw_url": "https://github.com/angular/angular/raw/da159a51447dae1040f52e19ba674e4aa8d3f685/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts?ref=da159a51447dae1040f52e19ba674e4aa8d3f685",
            "patch": "@@ -77,7 +77,7 @@ export function prepareEventListenerParameters(\n   const implicitReceiverExpr = (scope === null || scope.bindingLevel === 0) ?\n       o.variable(CONTEXT_NAME) :\n       scope.getOrCreateSharedContextVar(0);\n-  const bindingExpr = convertActionBinding(\n+  const bindingStatements = convertActionBinding(\n       scope, implicitReceiverExpr, handler, 'b', () => error('Unexpected interpolation'),\n       eventAst.handlerSpan, implicitReceiverAccesses, EVENT_BINDING_SCOPE_GLOBALS);\n   const statements = [];\n@@ -87,7 +87,7 @@ export function prepareEventListenerParameters(\n     statements.push(...scope.variableDeclarations());\n     statements.unshift(...scope.restoreViewStatement());\n   }\n-  statements.push(...bindingExpr.render3Stmts);\n+  statements.push(...bindingStatements);\n \n   const eventName: string =\n       type === ParsedEventType.Animation ? prepareSyntheticListenerName(name, phase!) : name;"
        },
        {
            "sha": "cbfcf6e1be1c9295fc3c03031bcb6ac135b4fdc1",
            "filename": "packages/compiler/src/util.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 90,
            "changes": 90,
            "blob_url": "https://github.com/angular/angular/blob/da159a51447dae1040f52e19ba674e4aa8d3f685/packages%2Fcompiler%2Fsrc%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/da159a51447dae1040f52e19ba674e4aa8d3f685/packages%2Fcompiler%2Fsrc%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Futil.ts?ref=da159a51447dae1040f52e19ba674e4aa8d3f685",
            "patch": "@@ -26,75 +26,10 @@ function _splitAt(input: string, character: string, defaultValues: string[]): st\n   return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n }\n \n-export function visitValue(value: any, visitor: ValueVisitor, context: any): any {\n-  if (Array.isArray(value)) {\n-    return visitor.visitArray(<any[]>value, context);\n-  }\n-\n-  if (isStrictStringMap(value)) {\n-    return visitor.visitStringMap(<{[key: string]: any}>value, context);\n-  }\n-\n-  if (value == null || typeof value == 'string' || typeof value == 'number' ||\n-      typeof value == 'boolean') {\n-    return visitor.visitPrimitive(value, context);\n-  }\n-\n-  return visitor.visitOther(value, context);\n-}\n-\n-export function isDefined(val: any): boolean {\n-  return val !== null && val !== undefined;\n-}\n-\n export function noUndefined<T>(val: T|undefined): T {\n   return val === undefined ? null! : val;\n }\n \n-export interface ValueVisitor {\n-  visitArray(arr: any[], context: any): any;\n-  visitStringMap(map: {[key: string]: any}, context: any): any;\n-  visitPrimitive(value: any, context: any): any;\n-  visitOther(value: any, context: any): any;\n-}\n-\n-export class ValueTransformer implements ValueVisitor {\n-  visitArray(arr: any[], context: any): any {\n-    return arr.map(value => visitValue(value, this, context));\n-  }\n-  visitStringMap(map: {[key: string]: any}, context: any): any {\n-    const result: {[key: string]: any} = {};\n-    Object.keys(map).forEach(key => {\n-      result[key] = visitValue(map[key], this, context);\n-    });\n-    return result;\n-  }\n-  visitPrimitive(value: any, context: any): any {\n-    return value;\n-  }\n-  visitOther(value: any, context: any): any {\n-    return value;\n-  }\n-}\n-\n-export type SyncAsync<T> = T|Promise<T>;\n-\n-export const SyncAsync = {\n-  assertSync: <T>(value: SyncAsync<T>): T => {\n-    if (isPromise(value)) {\n-      throw new Error(`Illegal state: value cannot be a promise`);\n-    }\n-    return value;\n-  },\n-  then: <T, R>(value: SyncAsync<T>, cb: (value: T) => R | Promise<R>| SyncAsync<R>):\n-      SyncAsync<R> => {\n-        return isPromise(value) ? value.then(cb) : cb(value);\n-      },\n-  all: <T>(syncAsyncValues: SyncAsync<T>[]): SyncAsync<T[]> => {\n-    return syncAsyncValues.some(isPromise) ? Promise.all(syncAsyncValues) : syncAsyncValues as T[];\n-  }\n-};\n-\n export function error(msg: string): never {\n   throw new Error(`Internal Error: ${msg}`);\n }\n@@ -104,11 +39,6 @@ export function escapeRegExp(s: string): string {\n   return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n }\n \n-const STRING_MAP_PROTO = Object.getPrototypeOf({});\n-function isStrictStringMap(obj: any): boolean {\n-  return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n-}\n-\n export type Byte = number;\n \n export function utf8Encode(str: string): Byte[] {\n@@ -180,26 +110,6 @@ export function stringify(token: any): string {\n   return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n }\n \n-/**\n- * Lazily retrieves the reference value from a forwardRef.\n- */\n-export function resolveForwardRef(type: any): any {\n-  if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__')) {\n-    return type();\n-  } else {\n-    return type;\n-  }\n-}\n-\n-/**\n- * Determine if the argument is shaped like a Promise\n- */\n-export function isPromise<T = any>(obj: any): obj is Promise<T> {\n-  // allow any Promise/A+ compliant thenable.\n-  // It's up to the caller to ensure that obj.then conforms to the spec\n-  return !!obj && typeof obj.then === 'function';\n-}\n-\n export class Version {\n   public readonly major: string;\n   public readonly minor: string;"
        },
        {
            "sha": "423ba553453639db1614e8c83f50dcf2dfb6ae78",
            "filename": "packages/core/test/util/lang_spec.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 33,
            "changes": 45,
            "blob_url": "https://github.com/angular/angular/blob/da159a51447dae1040f52e19ba674e4aa8d3f685/packages%2Fcore%2Ftest%2Futil%2Flang_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/da159a51447dae1040f52e19ba674e4aa8d3f685/packages%2Fcore%2Ftest%2Futil%2Flang_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Futil%2Flang_spec.ts?ref=da159a51447dae1040f52e19ba674e4aa8d3f685",
            "patch": "@@ -5,43 +5,22 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {isObservable, isPromise} from '@angular/core/src/util/lang';\n+import {isObservable} from '@angular/core/src/util/lang';\n import {of} from 'rxjs';\n \n-{\n-  describe('isPromise', () => {\n-    it('should be true for native Promises',\n-       () => expect(isPromise(Promise.resolve(true))).toEqual(true));\n+describe('isObservable', () => {\n+  it('should be true for an Observable', () => expect(isObservable(of(true))).toEqual(true));\n \n-    it('should be true for thenables', () => expect(isPromise({then: () => {}})).toEqual(true));\n+  it('should be true if the argument is the object with subscribe function',\n+     () => expect(isObservable({subscribe: () => {}})).toEqual(true));\n \n-    it('should be false if \"then\" is not a function',\n-       () => expect(isPromise({then: 0})).toEqual(false));\n+  it('should be false if the argument is undefined',\n+     () => expect(isObservable(undefined)).toEqual(false));\n \n-    it('should be false if the argument has no \"then\" function',\n-       () => expect(isPromise({})).toEqual(false));\n+  it('should be false if the argument is null', () => expect(isObservable(null)).toEqual(false));\n \n-    it('should be false if the argument is undefined or null', () => {\n-      expect(isPromise(undefined)).toEqual(false);\n-      expect(isPromise(null)).toEqual(false);\n-    });\n-  });\n+  it('should be false if the argument is an object', () => expect(isObservable({})).toEqual(false));\n \n-  describe('isObservable', () => {\n-    it('should be true for an Observable', () => expect(isObservable(of(true))).toEqual(true));\n-\n-    it('should be true if the argument is the object with subscribe function',\n-       () => expect(isObservable({subscribe: () => {}})).toEqual(true));\n-\n-    it('should be false if the argument is undefined',\n-       () => expect(isObservable(undefined)).toEqual(false));\n-\n-    it('should be false if the argument is null', () => expect(isObservable(null)).toEqual(false));\n-\n-    it('should be false if the argument is an object',\n-       () => expect(isObservable({})).toEqual(false));\n-\n-    it('should be false if the argument is a function',\n-       () => expect(isObservable(() => {})).toEqual(false));\n-  });\n-}\n+  it('should be false if the argument is a function',\n+     () => expect(isObservable(() => {})).toEqual(false));\n+});"
        }
    ],
    "stats": {
        "total": 212,
        "additions": 19,
        "deletions": 193
    }
}