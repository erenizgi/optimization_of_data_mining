{
    "author": "alxhub",
    "message": "refactor(compiler): delete View Engine components of @angular/compiler (#44368)\n\nThis commit finishes the removal of View Engine from the codebase, deleting\nthose pieces of @angular/compiler which were only used for VE.\n\nCo-Authored-By: JoostK <joost.koehoorn@gmail.com>\n\nPR Close #44368",
    "sha": "43db24302c69dedd24e4ee49e00273f33840b530",
    "files": [
        {
            "sha": "2d1da6a05338b703d9def5ae7a1564a0317f1eb2",
            "filename": "packages/bazel/src/ngc-wrapped/index.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fbazel%2Fsrc%2Fngc-wrapped%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fbazel%2Fsrc%2Fngc-wrapped%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbazel%2Fsrc%2Fngc-wrapped%2Findex.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import type {AngularCompilerOptions, CompilerHost as NgCompilerHost, TsEmitCallback, Program, Diagnostics, Diagnostic as NgDiagnostic, CompilerOptions} from '@angular/compiler-cli';\n+import type {AngularCompilerOptions, CompilerHost as NgCompilerHost, TsEmitCallback, Program, CompilerOptions} from '@angular/compiler-cli';\n import {BazelOptions, CachedFileLoader, CompilerHost, constructManifest, debug, FileCache, FileLoader, parseTsconfig, resolveNormalizedPath, runAsWorker, runWorkerLoop, UncachedFileLoader} from '@bazel/typescript';\n import * as fs from 'fs';\n import * as path from 'path';\n@@ -195,9 +195,9 @@ export function compile({\n         bazelOpts: BazelOptions,\n         files: string[],\n         expectedOuts: string[],\n-  gatherDiagnostics?: (program: Program) => Diagnostics,\n+  gatherDiagnostics?: (program: Program) => readonly ts.Diagnostic[],\n   bazelHost?: CompilerHost, ng: CompilerCliModule,\n-}): {diagnostics: Diagnostics, program: Program} {\n+}): {diagnostics: readonly ts.Diagnostic[], program: Program} {\n   let fileLoader: FileLoader;\n \n   if (bazelOpts.maxCacheSizeMb !== undefined) {\n@@ -449,15 +449,15 @@ function convertToForwardSlashPath(filePath: string): string {\n \n function gatherDiagnosticsForInputsOnly(\n     options: CompilerOptions, bazelOpts: BazelOptions, ngProgram: Program,\n-    ng: CompilerCliModule): (NgDiagnostic|ts.Diagnostic)[] {\n+    ng: CompilerCliModule): ts.Diagnostic[] {\n   const tsProgram = ngProgram.getTsProgram();\n \n   // For the Ivy compiler, track the amount of time spent fetching TypeScript diagnostics.\n   let previousPhase = ng.PerfPhase.Unaccounted;\n   if (ngProgram instanceof ng.NgtscProgram) {\n     previousPhase = ngProgram.compiler.perfRecorder.phase(ng.PerfPhase.TypeScriptDiagnostics);\n   }\n-  const diagnostics: (NgDiagnostic|ts.Diagnostic)[] = [];\n+  const diagnostics: ts.Diagnostic[] = [];\n   // These checks mirror ts.getPreEmitDiagnostics, with the important\n   // exception of avoiding b/30708240, which is that if you call\n   // program.getDeclarationDiagnostics() it somehow corrupts the emit."
        },
        {
            "sha": "fe51efa864e3eed8bd0ca7141675da92c19549cb",
            "filename": "packages/common/test/pipes/date_pipe_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcommon%2Ftest%2Fpipes%2Fdate_pipe_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcommon%2Ftest%2Fpipes%2Fdate_pipe_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Ftest%2Fpipes%2Fdate_pipe_spec.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -9,7 +9,6 @@\n import {DatePipe} from '@angular/common';\n import localeEn from '@angular/common/locales/en';\n import localeEnExtra from '@angular/common/locales/extra/en';\n-import {PipeResolver} from '@angular/compiler/src/pipe_resolver';\n import {ɵregisterLocaleData, ɵunregisterLocaleData} from '@angular/core';\n \n {"
        },
        {
            "sha": "b03cef64438b495c353ebd3661fd40920ffc11ff",
            "filename": "packages/common/test/pipes/i18n_plural_pipe_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcommon%2Ftest%2Fpipes%2Fi18n_plural_pipe_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcommon%2Ftest%2Fpipes%2Fi18n_plural_pipe_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Ftest%2Fpipes%2Fi18n_plural_pipe_spec.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -7,7 +7,6 @@\n  */\n \n import {I18nPluralPipe, NgLocalization} from '@angular/common';\n-import {PipeResolver} from '@angular/compiler/src/pipe_resolver';\n \n {\n   describe('I18nPluralPipe', () => {"
        },
        {
            "sha": "4a26cba763b0c0f3e685fc451704efc2df6a3c67",
            "filename": "packages/common/test/pipes/i18n_select_pipe_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcommon%2Ftest%2Fpipes%2Fi18n_select_pipe_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcommon%2Ftest%2Fpipes%2Fi18n_select_pipe_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Ftest%2Fpipes%2Fi18n_select_pipe_spec.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -7,7 +7,6 @@\n  */\n \n import {I18nSelectPipe} from '@angular/common';\n-import {PipeResolver} from '@angular/compiler/src/pipe_resolver';\n \n {\n   describe('I18nSelectPipe', () => {"
        },
        {
            "sha": "d0d8e636501828de150649e3638d66ae2ba129b1",
            "filename": "packages/compiler-cli/index.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Findex.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -7,7 +7,6 @@\n  */\n import {NodeJSFileSystem, setFileSystem} from './src/ngtsc/file_system';\n \n-export {AotCompilerHost, AotCompilerHost as StaticReflectorHost, StaticReflector, StaticSymbol} from '@angular/compiler';\n export {VERSION} from './src/version';\n \n export * from './src/transformers/api';\n@@ -18,8 +17,6 @@ export * from './src/perform_compile';\n // TODO(tbosch): remove this once usages in G3 are changed to `CompilerOptions`\n export {CompilerOptions as AngularCompilerOptions} from './src/transformers/api';\n \n-export {ngToTsDiagnostic} from './src/transformers/util';\n-\n // Internal exports needed for packages relying on the compiler-cli.\n // TODO: Remove this when the CLI has switched to the private entry-point.\n export * from './private/tooling';"
        },
        {
            "sha": "8146405d9c0628e45c94888d1d4a8f5d4bd8ba9f",
            "filename": "packages/compiler-cli/src/main.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Fsrc%2Fmain.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Fsrc%2Fmain.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fmain.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -9,7 +9,7 @@\n import ts from 'typescript';\n import type {TsickleHost} from 'tsickle';\n import yargs from 'yargs';\n-import {Diagnostics, exitCodeFromResult, formatDiagnostics, ParsedConfiguration, performCompilation, readConfiguration} from './perform_compile';\n+import {exitCodeFromResult, formatDiagnostics, ParsedConfiguration, performCompilation, readConfiguration} from './perform_compile';\n import {createPerformWatchHost, performWatchCompilation} from './perform_watch';\n import * as api from './transformers/api';\n import {GENERATED_FILES} from './transformers/util';\n@@ -57,7 +57,7 @@ export function mainDiagnosticsForTest(\n     programReuse?: {program: api.Program|undefined}, modifiedResourceFiles?: Set<string>|null,\n     tsickle?: TsickleModule): {\n   exitCode: number,\n-  diagnostics: ReadonlyArray<ts.Diagnostic|api.Diagnostic>,\n+  diagnostics: ReadonlyArray<ts.Diagnostic>,\n } {\n   let {rootNames, options, errors: configErrors, emitFlags} =\n       config || readNgcCommandLineAndConfiguration(args);\n@@ -223,7 +223,7 @@ function getFormatDiagnosticsHost(options?: api.CompilerOptions): ts.FormatDiagn\n }\n \n function reportErrorsAndExit(\n-    allDiagnostics: Diagnostics, options?: api.CompilerOptions,\n+    allDiagnostics: ReadonlyArray<ts.Diagnostic>, options?: api.CompilerOptions,\n     consoleError: (s: string) => void = console.error): number {\n   const errorsAndWarnings =\n       allDiagnostics.filter(d => d.category !== ts.DiagnosticCategory.Message);\n@@ -239,8 +239,8 @@ export function watchMode(\n }\n \n function printDiagnostics(\n-    diagnostics: ReadonlyArray<ts.Diagnostic|api.Diagnostic>,\n-    options: api.CompilerOptions|undefined, consoleError: (s: string) => void): void {\n+    diagnostics: ReadonlyArray<ts.Diagnostic>, options: api.CompilerOptions|undefined,\n+    consoleError: (s: string) => void): void {\n   if (diagnostics.length === 0) {\n     return;\n   }"
        },
        {
            "sha": "a52c8cce33922181e8f72794703977bd9e9674d1",
            "filename": "packages/compiler-cli/src/ngtsc/program.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 13,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fprogram.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fprogram.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fprogram.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {GeneratedFile, HtmlParser, MessageBundle} from '@angular/compiler';\n+import {HtmlParser, MessageBundle} from '@angular/compiler';\n import ts from 'typescript';\n \n import * as api from '../transformers/api';\n@@ -179,18 +179,18 @@ export class NgtscProgram implements api.Program {\n   }\n \n   getNgOptionDiagnostics(cancellationToken?: ts.CancellationToken|\n-                         undefined): readonly(ts.Diagnostic|api.Diagnostic)[] {\n+                         undefined): readonly ts.Diagnostic[] {\n     return this.compiler.getOptionDiagnostics();\n   }\n \n   getNgStructuralDiagnostics(cancellationToken?: ts.CancellationToken|\n-                             undefined): readonly api.Diagnostic[] {\n+                             undefined): readonly ts.Diagnostic[] {\n     return [];\n   }\n \n   getNgSemanticDiagnostics(\n-      fileName?: string|undefined, cancellationToken?: ts.CancellationToken|undefined):\n-      readonly(ts.Diagnostic|api.Diagnostic)[] {\n+      fileName?: string|undefined,\n+      cancellationToken?: ts.CancellationToken|undefined): readonly ts.Diagnostic[] {\n     let sf: ts.SourceFile|undefined = undefined;\n     if (fileName !== undefined) {\n       sf = this.tsProgram.getSourceFile(fileName);\n@@ -337,14 +337,6 @@ export class NgtscProgram implements api.Program {\n     return this.compiler.getIndexedComponents();\n   }\n \n-  getLibrarySummaries(): Map<string, api.LibrarySummary> {\n-    throw new Error('Method not implemented.');\n-  }\n-\n-  getEmittedGeneratedFiles(): Map<string, GeneratedFile> {\n-    throw new Error('Method not implemented.');\n-  }\n-\n   getEmittedSourceFiles(): Map<string, ts.SourceFile> {\n     throw new Error('Method not implemented.');\n   }"
        },
        {
            "sha": "b4b0a39a5793ac4d69eca88b60ec559e10f6a60d",
            "filename": "packages/compiler-cli/src/perform_compile.ts",
            "status": "modified",
            "additions": 25,
            "deletions": 87,
            "changes": 112,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Fsrc%2Fperform_compile.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Fsrc%2Fperform_compile.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fperform_compile.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -6,99 +6,31 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {isSyntaxError, Position} from '@angular/compiler';\n+import {isSyntaxError} from '@angular/compiler';\n import ts from 'typescript';\n \n import {absoluteFrom, AbsoluteFsPath, FileSystem, getFileSystem, ReadonlyFileSystem, relative, resolve} from '../src/ngtsc/file_system';\n-import {NgCompilerOptions} from './ngtsc/core/api';\n \n+import {NgCompilerOptions} from './ngtsc/core/api';\n import {replaceTsWithNgInErrors} from './ngtsc/diagnostics';\n import * as api from './transformers/api';\n import * as ng from './transformers/entry_points';\n import {createMessageDiagnostic} from './transformers/util';\n \n-export type Diagnostics = ReadonlyArray<ts.Diagnostic|api.Diagnostic>;\n-\n const defaultFormatHost: ts.FormatDiagnosticsHost = {\n   getCurrentDirectory: () => ts.sys.getCurrentDirectory(),\n   getCanonicalFileName: fileName => fileName,\n   getNewLine: () => ts.sys.newLine\n };\n \n-function displayFileName(fileName: string, host: ts.FormatDiagnosticsHost): string {\n-  return relative(\n-      resolve(host.getCurrentDirectory()), resolve(host.getCanonicalFileName(fileName)));\n-}\n-\n-export function formatDiagnosticPosition(\n-    position: Position, host: ts.FormatDiagnosticsHost = defaultFormatHost): string {\n-  return `${displayFileName(position.fileName, host)}(${position.line + 1},${position.column + 1})`;\n-}\n-\n-export function flattenDiagnosticMessageChain(\n-    chain: api.DiagnosticMessageChain, host: ts.FormatDiagnosticsHost = defaultFormatHost,\n-    indent = 0): string {\n-  const newLine = host.getNewLine();\n-  let result = '';\n-  if (indent) {\n-    result += newLine;\n-\n-    for (let i = 0; i < indent; i++) {\n-      result += '  ';\n-    }\n-  }\n-  result += chain.messageText;\n-\n-  const position = chain.position;\n-  // add position if available, and we are not at the depest frame\n-  if (position && indent !== 0) {\n-    result += ` at ${formatDiagnosticPosition(position, host)}`;\n-  }\n-\n-  indent++;\n-  if (chain.next) {\n-    for (const kid of chain.next) {\n-      result += flattenDiagnosticMessageChain(kid, host, indent);\n-    }\n-  }\n-  return result;\n-}\n-\n-export function formatDiagnostic(\n-    diagnostic: api.Diagnostic, host: ts.FormatDiagnosticsHost = defaultFormatHost) {\n-  let result = '';\n-  const newLine = host.getNewLine();\n-  const span = diagnostic.span;\n-  if (span) {\n-    result += `${\n-        formatDiagnosticPosition(\n-            {fileName: span.start.file.url, line: span.start.line, column: span.start.col},\n-            host)}: `;\n-  } else if (diagnostic.position) {\n-    result += `${formatDiagnosticPosition(diagnostic.position, host)}: `;\n-  }\n-  if (diagnostic.span && diagnostic.span.details) {\n-    result += `${diagnostic.span.details}, ${diagnostic.messageText}${newLine}`;\n-  } else if (diagnostic.chain) {\n-    result += `${flattenDiagnosticMessageChain(diagnostic.chain, host)}.${newLine}`;\n-  } else {\n-    result += `${diagnostic.messageText}${newLine}`;\n-  }\n-  return result;\n-}\n-\n export function formatDiagnostics(\n-    diags: Diagnostics, host: ts.FormatDiagnosticsHost = defaultFormatHost): string {\n+    diags: ReadonlyArray<ts.Diagnostic>,\n+    host: ts.FormatDiagnosticsHost = defaultFormatHost): string {\n   if (diags && diags.length) {\n     return diags\n-        .map(diagnostic => {\n-          if (api.isTsDiagnostic(diagnostic)) {\n-            return replaceTsWithNgInErrors(\n-                ts.formatDiagnosticsWithColorAndContext([diagnostic], host));\n-          } else {\n-            return formatDiagnostic(diagnostic, host);\n-          }\n-        })\n+        .map(\n+            diagnostic => replaceTsWithNgInErrors(\n+                ts.formatDiagnosticsWithColorAndContext([diagnostic], host)))\n         .join('');\n   } else {\n     return '';\n@@ -264,12 +196,12 @@ function getExtendedConfigPathWorker(\n }\n \n export interface PerformCompilationResult {\n-  diagnostics: Diagnostics;\n+  diagnostics: ReadonlyArray<ts.Diagnostic>;\n   program?: api.Program;\n   emitResult?: ts.EmitResult;\n }\n \n-export function exitCodeFromResult(diags: Diagnostics|undefined): number {\n+export function exitCodeFromResult(diags: ReadonlyArray<ts.Diagnostic>|undefined): number {\n   if (!diags) return 0;\n   if (diags.every((diag) => diag.category !== ts.DiagnosticCategory.Error)) {\n     // If we have a result and didn't get any errors, we succeeded.\n@@ -298,14 +230,14 @@ export function performCompilation({\n   oldProgram?: api.Program,\n   emitCallback?: api.TsEmitCallback,\n   mergeEmitResultsCallback?: api.TsMergeEmitResultsCallback,\n-  gatherDiagnostics?: (program: api.Program) => Diagnostics,\n+  gatherDiagnostics?: (program: api.Program) => ReadonlyArray<ts.Diagnostic>,\n   customTransformers?: api.CustomTransformers,\n   emitFlags?: api.EmitFlags,\n   modifiedResourceFiles?: Set<string>| null,\n }): PerformCompilationResult {\n   let program: api.Program|undefined;\n   let emitResult: ts.EmitResult|undefined;\n-  let allDiagnostics: Array<ts.Diagnostic|api.Diagnostic> = [];\n+  let allDiagnostics: Array<ts.Diagnostic> = [];\n   try {\n     if (!host) {\n       host = ng.createCompilerHost({options});\n@@ -344,15 +276,21 @@ export function performCompilation({\n       program = undefined;\n       code = api.UNKNOWN_ERROR_CODE;\n     }\n-    allDiagnostics.push(\n-        {category: ts.DiagnosticCategory.Error, messageText: errMsg, code, source: api.SOURCE});\n+    allDiagnostics.push({\n+      category: ts.DiagnosticCategory.Error,\n+      messageText: errMsg,\n+      code,\n+      file: undefined,\n+      start: undefined,\n+      length: undefined,\n+    });\n     return {diagnostics: allDiagnostics, program};\n   }\n }\n-export function defaultGatherDiagnostics(program: api.Program): Diagnostics {\n-  const allDiagnostics: Array<ts.Diagnostic|api.Diagnostic> = [];\n+export function defaultGatherDiagnostics(program: api.Program): ReadonlyArray<ts.Diagnostic> {\n+  const allDiagnostics: Array<ts.Diagnostic> = [];\n \n-  function checkDiagnostics(diags: Diagnostics|undefined) {\n+  function checkDiagnostics(diags: ReadonlyArray<ts.Diagnostic>|undefined) {\n     if (diags) {\n       allDiagnostics.push(...diags);\n       return !hasErrors(diags);\n@@ -367,7 +305,7 @@ export function defaultGatherDiagnostics(program: api.Program): Diagnostics {\n \n   // Check syntactic diagnostics\n   checkOtherDiagnostics =\n-      checkOtherDiagnostics && checkDiagnostics(program.getTsSyntacticDiagnostics() as Diagnostics);\n+      checkOtherDiagnostics && checkDiagnostics(program.getTsSyntacticDiagnostics());\n \n   // Check TypeScript semantic and Angular structure diagnostics\n   checkOtherDiagnostics =\n@@ -377,11 +315,11 @@ export function defaultGatherDiagnostics(program: api.Program): Diagnostics {\n \n   // Check Angular semantic diagnostics\n   checkOtherDiagnostics =\n-      checkOtherDiagnostics && checkDiagnostics(program.getNgSemanticDiagnostics() as Diagnostics);\n+      checkOtherDiagnostics && checkDiagnostics(program.getNgSemanticDiagnostics());\n \n   return allDiagnostics;\n }\n \n-function hasErrors(diags: Diagnostics) {\n+function hasErrors(diags: ReadonlyArray<ts.Diagnostic>) {\n   return diags.some(d => d.category === ts.DiagnosticCategory.Error);\n }"
        },
        {
            "sha": "766bff1e27cf54cfa5301085ee91e17ca1ce6ac0",
            "filename": "packages/compiler-cli/src/perform_watch.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 8,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Fsrc%2Fperform_watch.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Fsrc%2Fperform_watch.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fperform_watch.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -10,12 +10,12 @@ import * as chokidar from 'chokidar';\n import * as path from 'path';\n import ts from 'typescript';\n \n-import {Diagnostics, exitCodeFromResult, ParsedConfiguration, performCompilation, PerformCompilationResult, readConfiguration} from './perform_compile';\n+import {exitCodeFromResult, ParsedConfiguration, performCompilation, PerformCompilationResult, readConfiguration} from './perform_compile';\n import * as api from './transformers/api';\n import {createCompilerHost} from './transformers/entry_points';\n import {createMessageDiagnostic} from './transformers/util';\n \n-function totalCompilationTimeDiagnostic(timeInMillis: number): api.Diagnostic {\n+function totalCompilationTimeDiagnostic(timeInMillis: number): ts.Diagnostic {\n   let duration: string;\n   if (timeInMillis > 1000) {\n     duration = `${(timeInMillis / 1000).toPrecision(2)}s`;\n@@ -27,6 +27,9 @@ function totalCompilationTimeDiagnostic(timeInMillis: number): api.Diagnostic {\n     messageText: `Total time: ${duration}`,\n     code: api.DEFAULT_ERROR_CODE,\n     source: api.SOURCE,\n+    file: undefined,\n+    start: undefined,\n+    length: undefined,\n   };\n }\n \n@@ -37,7 +40,7 @@ export enum FileChangeEvent {\n }\n \n export interface PerformWatchHost {\n-  reportDiagnostics(diagnostics: Diagnostics): void;\n+  reportDiagnostics(diagnostics: ReadonlyArray<ts.Diagnostic>): void;\n   readConfiguration(): ParsedConfiguration;\n   createCompilerHost(options: api.CompilerOptions): api.CompilerHost;\n   createEmitCallback(options: api.CompilerOptions): api.TsEmitCallback|undefined;\n@@ -49,7 +52,7 @@ export interface PerformWatchHost {\n }\n \n export function createPerformWatchHost(\n-    configFileName: string, reportDiagnostics: (diagnostics: Diagnostics) => void,\n+    configFileName: string, reportDiagnostics: (diagnostics: ReadonlyArray<ts.Diagnostic>) => void,\n     existingOptions?: ts.CompilerOptions,\n     createEmitCallback?: (options: api.CompilerOptions) =>\n         api.TsEmitCallback | undefined): PerformWatchHost {\n@@ -64,7 +67,10 @@ export function createPerformWatchHost(\n           category: ts.DiagnosticCategory.Error,\n           messageText: 'Invalid configuration option. baseDir not specified',\n           source: api.SOURCE,\n-          code: api.DEFAULT_ERROR_CODE\n+          code: api.DEFAULT_ERROR_CODE,\n+          file: undefined,\n+          start: undefined,\n+          length: undefined,\n         }]);\n         return {close: () => {}};\n       }\n@@ -112,8 +118,11 @@ interface QueuedCompilationInfo {\n /**\n  * The logic in this function is adapted from `tsc.ts` from TypeScript.\n  */\n-export function performWatchCompilation(host: PerformWatchHost):\n-    {close: () => void, ready: (cb: () => void) => void, firstCompileResult: Diagnostics} {\n+export function performWatchCompilation(host: PerformWatchHost): {\n+  close: () => void,\n+  ready: (cb: () => void) => void,\n+  firstCompileResult: ReadonlyArray<ts.Diagnostic>\n+} {\n   let cachedProgram: api.Program|undefined;            // Program cached from last compilation\n   let cachedCompilerHost: api.CompilerHost|undefined;  // CompilerHost cached from last compilation\n   let cachedOptions: ParsedConfiguration|undefined;  // CompilerOptions cached from last compilation\n@@ -154,7 +163,7 @@ export function performWatchCompilation(host: PerformWatchHost):\n   }\n \n   // Invoked to perform initial compilation or re-compilation in watch mode\n-  function doCompilation(): Diagnostics {\n+  function doCompilation(): ReadonlyArray<ts.Diagnostic> {\n     if (!cachedOptions) {\n       cachedOptions = host.readConfiguration();\n     }"
        },
        {
            "sha": "3d07af881b32c0f4b42963ed91dc84dfcb9601e4",
            "filename": "packages/compiler-cli/src/transformers/api.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 43,
            "changes": 47,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fapi.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -6,7 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {GeneratedFile, ParseSourceSpan, Position} from '@angular/compiler';\n import ts from 'typescript';\n \n import {ExtendedTsCompilerHost, NgCompilerOptions} from '../ngtsc/core/api';\n@@ -15,30 +14,10 @@ export const DEFAULT_ERROR_CODE = 100;\n export const UNKNOWN_ERROR_CODE = 500;\n export const SOURCE = 'angular' as 'angular';\n \n-export interface DiagnosticMessageChain {\n-  messageText: string;\n-  position?: Position;\n-  next?: DiagnosticMessageChain[];\n-}\n-\n-export interface Diagnostic {\n-  messageText: string;\n-  span?: ParseSourceSpan;\n-  position?: Position;\n-  chain?: DiagnosticMessageChain;\n-  category: ts.DiagnosticCategory;\n-  code: number;\n-  source: 'angular';\n-}\n-\n export function isTsDiagnostic(diagnostic: any): diagnostic is ts.Diagnostic {\n   return diagnostic != null && diagnostic.source !== 'angular';\n }\n \n-export function isNgDiagnostic(diagnostic: any): diagnostic is Diagnostic {\n-  return diagnostic != null && diagnostic.source === 'angular';\n-}\n-\n export interface CompilerOptions extends NgCompilerOptions, ts.CompilerOptions {\n   // NOTE: These comments and aio/content/guides/aot-compiler.md should be kept in sync.\n \n@@ -190,12 +169,6 @@ export interface TsMergeEmitResultsCallback {\n   (results: ts.EmitResult[]): ts.EmitResult;\n }\n \n-export interface LibrarySummary {\n-  fileName: string;\n-  text: string;\n-  sourceFile?: ts.SourceFile;\n-}\n-\n export interface LazyRoute {\n   route: string;\n   module: {name: string, filePath: string};\n@@ -220,8 +193,7 @@ export interface Program {\n   /**\n    * Retrieve options diagnostics for the Angular options used to create the program.\n    */\n-  getNgOptionDiagnostics(cancellationToken?: ts.CancellationToken):\n-      ReadonlyArray<ts.Diagnostic|Diagnostic>;\n+  getNgOptionDiagnostics(cancellationToken?: ts.CancellationToken): ReadonlyArray<ts.Diagnostic>;\n \n   /**\n    * Retrieve the syntax diagnostics from TypeScript. This is faster than calling\n@@ -242,7 +214,8 @@ export interface Program {\n    *\n    * Angular structural information is required to produce these diagnostics.\n    */\n-  getNgStructuralDiagnostics(cancellationToken?: ts.CancellationToken): ReadonlyArray<Diagnostic>;\n+  getNgStructuralDiagnostics(cancellationToken?: ts.CancellationToken):\n+      ReadonlyArray<ts.Diagnostic>;\n \n   /**\n    * Retrieve the semantic diagnostics from TypeScript. This is equivalent to calling\n@@ -257,7 +230,7 @@ export interface Program {\n    * Angular structural information is required to produce these diagnostics.\n    */\n   getNgSemanticDiagnostics(fileName?: string, cancellationToken?: ts.CancellationToken):\n-      ReadonlyArray<ts.Diagnostic|Diagnostic>;\n+      ReadonlyArray<ts.Diagnostic>;\n \n   /**\n    * Load Angular structural information asynchronously. If this method is not called then the\n@@ -286,18 +259,6 @@ export interface Program {\n              mergeEmitResultsCallback?: TsMergeEmitResultsCallback\n            }): ts.EmitResult;\n \n-  /**\n-   * Returns the .d.ts / .ngsummary.json / .ngfactory.d.ts files of libraries that have been emitted\n-   * in this program or previous programs with paths that emulate the fact that these libraries\n-   * have been compiled before with no outDir.\n-   */\n-  getLibrarySummaries(): Map<string, LibrarySummary>;\n-\n-  /**\n-   * @internal\n-   */\n-  getEmittedGeneratedFiles(): Map<string, GeneratedFile>;\n-\n   /**\n    * @internal\n    */"
        },
        {
            "sha": "7e6dc95f5dab9d81ebe3636a9b06a71787c5f27b",
            "filename": "packages/compiler-cli/src/transformers/entry_points.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fentry_points.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fentry_points.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fentry_points.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -6,9 +6,5 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import ts from 'typescript';\n-\n-import {CompilerHost, CompilerOptions, Program} from './api';\n-\n export {createCompilerHost} from './compiler_host';\n export {createProgram} from './program';"
        },
        {
            "sha": "b4c838c45199fcfc100ad4bbd2395109590196cf",
            "filename": "packages/compiler-cli/src/transformers/program.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 12,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fprogram.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fprogram.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fprogram.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -11,22 +11,11 @@ import {NgtscProgram} from '../ngtsc/program';\n \n import {CompilerHost, CompilerOptions, Program} from './api';\n \n-/** Error message to show when attempting to build View Engine. */\n-const VE_DISABLED_MESSAGE = `\n-This compilation is using the View Engine compiler which is no longer supported by the Angular team\n-and is being removed. Please upgrade to the Ivy compiler by switching to \\`NgtscProgram\\`. See\n-https://angular.io/guide/ivy for more information.\n-`.trim().split('\\n').join(' ');\n-\n export function createProgram({rootNames, options, host, oldProgram}: {\n   rootNames: ReadonlyArray<string>,\n   options: CompilerOptions,\n   host: CompilerHost,\n   oldProgram?: Program\n }): Program {\n-  if (options.enableIvy !== false) {\n-    return new NgtscProgram(rootNames, options, host, oldProgram as NgtscProgram | undefined);\n-  } else {\n-    throw new Error(VE_DISABLED_MESSAGE);\n-  }\n+  return new NgtscProgram(rootNames, options, host, oldProgram as NgtscProgram | undefined);\n }"
        },
        {
            "sha": "1a471695c61fa9e7d2799a19dd1007f38929c794",
            "filename": "packages/compiler-cli/src/transformers/util.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 25,
            "changes": 31,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Futil.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -8,15 +8,15 @@\n \n import ts from 'typescript';\n \n-import {DEFAULT_ERROR_CODE, Diagnostic, SOURCE} from './api';\n+import {CompilerOptions, DEFAULT_ERROR_CODE, SOURCE} from './api';\n \n export const GENERATED_FILES = /(.*?)\\.(ngfactory|shim\\.ngstyle|ngstyle|ngsummary)\\.(js|d\\.ts|ts)$/;\n \n export function error(msg: string): never {\n   throw new Error(`Internal error: ${msg}`);\n }\n \n-export function createMessageDiagnostic(messageText: string): ts.Diagnostic&Diagnostic {\n+export function createMessageDiagnostic(messageText: string): ts.Diagnostic {\n   return {\n     file: undefined,\n     start: undefined,\n@@ -29,29 +29,10 @@ export function createMessageDiagnostic(messageText: string): ts.Diagnostic&Diag\n }\n \n /**\n- * Converts a ng.Diagnostic into a ts.Diagnostic.\n- * This looses some information, and also uses an incomplete object as `file`.\n+ * Strip multiline comment start and end markers from the `commentText` string.\n  *\n- * I.e. only use this where the API allows only a ts.Diagnostic.\n+ * This will also strip the JSDOC comment start marker (`/**`).\n  */\n-export function ngToTsDiagnostic(ng: Diagnostic): ts.Diagnostic {\n-  let file: ts.SourceFile|undefined;\n-  let start: number|undefined;\n-  let length: number|undefined;\n-  if (ng.span) {\n-    // Note: We can't use a real ts.SourceFile,\n-    // but we can at least mirror the properties `fileName` and `text`, which\n-    // are mostly used for error reporting.\n-    file = {fileName: ng.span.start.file.url, text: ng.span.start.file.content} as ts.SourceFile;\n-    start = ng.span.start.offset;\n-    length = ng.span.end.offset - start;\n-  }\n-  return {\n-    file,\n-    messageText: ng.messageText,\n-    category: ng.category,\n-    code: ng.code,\n-    start,\n-    length,\n-  };\n+export function stripComment(commentText: string): string {\n+  return commentText.replace(/^\\/\\*\\*?/, '').replace(/\\*\\/$/, '').trim();\n }"
        },
        {
            "sha": "177f1cb9b79afef7b096eb2a594ff2f40406be2f",
            "filename": "packages/compiler-cli/test/compliance/test_helpers/compile_test.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Ftest%2Fcompliance%2Ftest_helpers%2Fcompile_test.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Ftest%2Fcompliance%2Ftest_helpers%2Fcompile_test.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fcompliance%2Ftest_helpers%2Fcompile_test.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -10,7 +10,7 @@ import ts from 'typescript';\n import {AbsoluteFsPath, FileSystem, PathManipulation, ReadonlyFileSystem} from '../../../src/ngtsc/file_system';\n import {initMockFileSystem} from '../../../src/ngtsc/file_system/testing';\n import {loadStandardTestFiles, loadTestDirectory, NgtscTestCompilerHost} from '../../../src/ngtsc/testing';\n-import {Diagnostics, performCompilation} from '../../../src/perform_compile';\n+import {performCompilation} from '../../../src/perform_compile';\n import {CompilerOptions} from '../../../src/transformers/api';\n \n import {ConfigOptions} from './get_compliance_tests';\n@@ -150,7 +150,7 @@ function monkeyPatchReadFile(fs: ReadonlyFileSystem): void {\n  *\n  * @param diagnostics The diagnostics to parse.\n  */\n-function parseDiagnostics(diagnostics: Diagnostics): string[] {\n+function parseDiagnostics(diagnostics: readonly ts.Diagnostic[]): string[] {\n   return diagnostics.map(diagnostic => {\n     const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\\n');\n     if ('file' in diagnostic && diagnostic.file !== undefined && diagnostic.start !== undefined) {"
        },
        {
            "sha": "f985679a6d0337713bb7064bc9e15faf2e03f571",
            "filename": "packages/compiler-cli/test/ngc_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 2438,
            "changes": 2438,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler-cli%2Ftest%2Fngc_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler-cli%2Ftest%2Fngc_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngc_spec.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,2438 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as fs from 'fs';\n-import * as path from 'path';\n-import * as tsickle from 'tsickle';\n-import ts from 'typescript';\n-\n-import {main, mainDiagnosticsForTest, readCommandLineAndConfiguration, watchMode} from '../src/main';\n-\n-import {setup, stripAnsi} from './test_support';\n-\n-describe('ngc transformer command-line', () => {\n-  let basePath: string;\n-  let outDir: string;\n-  let write: (fileName: string, content: string) => void;\n-  let errorSpy: jasmine.Spy&((s: string) => void);\n-\n-  function shouldExist(fileName: string) {\n-    if (!fs.existsSync(path.resolve(outDir, fileName))) {\n-      throw new Error(`Expected ${fileName} to be emitted (outDir: ${outDir})`);\n-    }\n-  }\n-\n-  function shouldNotExist(fileName: string) {\n-    if (fs.existsSync(path.resolve(outDir, fileName))) {\n-      throw new Error(`Did not expect ${fileName} to be emitted (outDir: ${outDir})`);\n-    }\n-  }\n-\n-  function writeConfig(tsconfig: string = '{\"extends\": \"./tsconfig-base.json\"}') {\n-    write('tsconfig.json', tsconfig);\n-  }\n-\n-  beforeEach(() => {\n-    errorSpy = jasmine.createSpy('consoleError').and.callFake(console.error);\n-    const support = setup();\n-    basePath = support.basePath;\n-    outDir = path.join(basePath, 'built');\n-    process.chdir(basePath);\n-    write = (fileName: string, content: string) => {\n-      support.write(fileName, content);\n-    };\n-\n-    write('tsconfig-base.json', `{\n-      \"compilerOptions\": {\n-        \"experimentalDecorators\": true,\n-        \"skipLibCheck\": true,\n-        \"noImplicitAny\": true,\n-        \"types\": [],\n-        \"outDir\": \"built\",\n-        \"rootDir\": \".\",\n-        \"baseUrl\": \".\",\n-        \"declaration\": true,\n-        \"target\": \"es5\",\n-        \"newLine\": \"lf\",\n-        \"module\": \"es2015\",\n-        \"moduleResolution\": \"node\",\n-        \"lib\": [\"es6\", \"dom\"],\n-        \"typeRoots\": [\"node_modules/@types\"]\n-      },\n-      \"angularCompilerOptions\": {\n-        \"enableIvy\": false\n-      }\n-    }`);\n-  });\n-\n-  it('should compile without errors', () => {\n-    writeConfig();\n-    write('test.ts', 'export const A = 1;');\n-\n-    const exitCode = main(['-p', basePath], errorSpy);\n-    expect(errorSpy).not.toHaveBeenCalled();\n-    expect(exitCode).toBe(0);\n-  });\n-\n-  it('should respect the \"newLine\" compiler option when printing diagnostics', () => {\n-    writeConfig(`{\n-      \"extends\": \"./tsconfig-base.json\",\n-      \"compilerOptions\": {\n-        \"newLine\": \"CRLF\",\n-      }\n-    }`);\n-    write('test.ts', 'export NOT_VALID = true;');\n-\n-    // Stub the error spy because we don't want to call through and print the\n-    // expected error diagnostic.\n-    errorSpy.and.stub();\n-\n-    const exitCode = main(['-p', basePath], errorSpy);\n-    const errorText = stripAnsi(errorSpy.calls.mostRecent().args[0]);\n-    expect(errorText).toContain(\n-        `test.ts:1:1 - error TS1128: Declaration or statement expected.\\r\\n`);\n-    expect(exitCode).toBe(1);\n-  });\n-\n-  describe('decorator metadata', () => {\n-    it('should add metadata as decorators if \"annotationsAs\" is set to \"decorators\"', () => {\n-      writeConfig(`{\n-        \"extends\": \"./tsconfig-base.json\",\n-        \"compilerOptions\": {\n-          \"emitDecoratorMetadata\": true\n-        },\n-        \"angularCompilerOptions\": {\n-          \"annotationsAs\": \"decorators\"\n-        },\n-        \"files\": [\"mymodule.ts\"]\n-      }`);\n-      write('aclass.ts', `export class AClass {}`);\n-      write('mymodule.ts', `\n-        import {NgModule} from '@angular/core';\n-        import {AClass} from './aclass';\n-\n-        @NgModule({declarations: []})\n-        export class MyModule {\n-          constructor(importedClass: AClass) {}\n-        }\n-      `);\n-\n-      const exitCode = main(['-p', basePath], errorSpy);\n-      expect(exitCode).toEqual(0);\n-\n-      const mymodulejs = path.resolve(outDir, 'mymodule.js');\n-      const mymoduleSource = fs.readFileSync(mymodulejs, 'utf8');\n-      expect(mymoduleSource).toContain('MyModule = __decorate([');\n-      expect(mymoduleSource).toContain(`import { AClass } from './aclass';`);\n-      expect(mymoduleSource).toContain(`__metadata(\"design:paramtypes\", [AClass])`);\n-      expect(mymoduleSource).not.toContain('MyModule.ctorParameters');\n-      expect(mymoduleSource).not.toContain('MyModule.decorators');\n-    });\n-\n-    it('should add metadata for Angular-decorated classes as static fields', () => {\n-      writeConfig(`{\n-        \"extends\": \"./tsconfig-base.json\",\n-        \"files\": [\"mymodule.ts\"]\n-      }`);\n-      write('aclass.ts', `export class AClass {}`);\n-      write('mymodule.ts', `\n-        import {NgModule} from '@angular/core';\n-        import {AClass} from './aclass';\n-\n-        @NgModule({declarations: []})\n-        export class MyModule {\n-          constructor(importedClass: AClass) {}\n-        }\n-      `);\n-\n-      const exitCode = main(['-p', basePath], errorSpy);\n-      expect(exitCode).toEqual(0);\n-\n-      const mymodulejs = path.resolve(outDir, 'mymodule.js');\n-      const mymoduleSource = fs.readFileSync(mymodulejs, 'utf8');\n-      expect(mymoduleSource).not.toContain('__decorate');\n-      expect(mymoduleSource).toContain('args: [{ declarations: [] },] }');\n-      expect(mymoduleSource).not.toContain(`__metadata`);\n-      expect(mymoduleSource).toContain(`import { AClass } from './aclass';`);\n-      expect(mymoduleSource).toContain(`{ type: AClass }`);\n-    });\n-\n-    it('should not downlevel decorators for classes with custom decorators', () => {\n-      writeConfig(`{\n-        \"extends\": \"./tsconfig-base.json\",\n-        \"files\": [\"mymodule.ts\"]\n-      }`);\n-      write('aclass.ts', `export class AClass {}`);\n-      write('decorator.ts', `\n-        export function CustomDecorator(metadata: any) {\n-          return (...args: any[]) => {}\n-        }\n-      `);\n-      write('mymodule.ts', `\n-        import {AClass} from './aclass';\n-        import {CustomDecorator} from './decorator';\n-\n-        @CustomDecorator({declarations: []})\n-        export class MyModule {\n-          constructor(importedClass: AClass) {}\n-        }\n-      `);\n-\n-      const exitCode = main(['-p', basePath], errorSpy);\n-      expect(exitCode).toEqual(0);\n-\n-      const mymodulejs = path.resolve(outDir, 'mymodule.js');\n-      const mymoduleSource = fs.readFileSync(mymodulejs, 'utf8');\n-      expect(mymoduleSource).toContain('__decorate');\n-      expect(mymoduleSource).toContain('({ declarations: [] })');\n-      expect(mymoduleSource).not.toContain('AClass');\n-      expect(mymoduleSource).not.toContain('.ctorParameters =');\n-      expect(mymoduleSource).not.toContain('.decorators = ');\n-    });\n-  });\n-\n-  describe('errors', () => {\n-    beforeEach(() => {\n-      errorSpy.and.stub();\n-    });\n-\n-    it('should not print the stack trace if user input file does not exist', () => {\n-      writeConfig(`{\n-        \"extends\": \"./tsconfig-base.json\",\n-        \"files\": [\"test.ts\"]\n-      }`);\n-\n-      const exitCode = main(['-p', basePath], errorSpy);\n-      const errorText = stripAnsi(errorSpy.calls.mostRecent().args[0]);\n-      expect(errorText).toContain(\n-          `error TS6053: File '` + path.posix.join(basePath, 'test.ts') + `' not found.` +\n-          '\\n');\n-      expect(exitCode).toEqual(1);\n-    });\n-\n-    it('should not print the stack trace if user input file is malformed', () => {\n-      writeConfig();\n-      write('test.ts', 'foo;');\n-\n-      const exitCode = main(['-p', basePath], errorSpy);\n-      const errorText = stripAnsi(errorSpy.calls.mostRecent().args[0]);\n-      expect(errorText).toContain(\n-          `test.ts:1:1 - error TS2304: Cannot find name 'foo'.` +\n-          '\\n');\n-      expect(exitCode).toEqual(1);\n-    });\n-\n-    it('should not print the stack trace if cannot find the imported module', () => {\n-      writeConfig();\n-      write('test.ts', `import {MyClass} from './not-exist-deps';`);\n-\n-      const exitCode = main(['-p', basePath], errorSpy);\n-      const errorText = stripAnsi(errorSpy.calls.mostRecent().args[0]);\n-      expect(errorText).toContain(\n-          `test.ts:1:23 - error TS2307: Cannot find module './not-exist-deps' or its corresponding type declarations.` +\n-          '\\n');\n-      expect(exitCode).toEqual(1);\n-    });\n-\n-    it('should not print the stack trace if cannot import', () => {\n-      writeConfig();\n-      write('empty-deps.ts', 'export const A = 1;');\n-      write('test.ts', `import {MyClass} from './empty-deps';`);\n-\n-      const exitCode = main(['-p', basePath], errorSpy);\n-      const errorText = stripAnsi(errorSpy.calls.mostRecent().args[0]);\n-      expect(errorText).toContain(\n-          `test.ts:1:9 - error TS2305: Module '\"./empty-deps\"' has no exported member 'MyClass'.\\n`);\n-      expect(exitCode).toEqual(1);\n-    });\n-\n-    it('should not print the stack trace if type mismatches', () => {\n-      writeConfig();\n-      write('empty-deps.ts', 'export const A = \"abc\";');\n-      write('test.ts', `\n-        import {A} from './empty-deps';\n-        A();\n-      `);\n-\n-      const exitCode = main(['-p', basePath], errorSpy);\n-      const errorText = stripAnsi(errorSpy.calls.mostRecent().args[0]);\n-      expect(errorText).toContain(\n-          'test.ts:3:9 - error TS2349: This expression is not callable.\\n' +\n-          '  Type \\'String\\' has no call signatures.\\n');\n-      expect(exitCode).toEqual(1);\n-    });\n-\n-    it('should print the stack trace on compiler internal errors', () => {\n-      write('test.ts', 'export const A = 1;');\n-\n-      const exitCode = main(['-p', 'not-exist'], errorSpy);\n-      expect(errorSpy).toHaveBeenCalledTimes(1);\n-      expect(errorSpy.calls.mostRecent().args[0]).toContain('no such file or directory');\n-      expect(errorSpy.calls.mostRecent().args[0]).toMatch(/at Object\\.(fs\\.)?lstatSync/);\n-      expect(exitCode).toEqual(2);\n-    });\n-\n-    it('should report errors for ngfactory files that are not referenced by root files', () => {\n-      writeConfig(`{\n-          \"extends\": \"./tsconfig-base.json\",\n-          \"files\": [\"mymodule.ts\"]\n-        }`);\n-      write('mymodule.ts', `\n-        import {NgModule, Component} from '@angular/core';\n-\n-        @Component({template: '{{unknownProp}}'})\n-        export class MyComp {}\n-\n-        @NgModule({declarations: [MyComp]})\n-        export class MyModule {}\n-      `);\n-\n-      const exitCode = main(['-p', basePath], errorSpy);\n-      expect(errorSpy).toHaveBeenCalledTimes(1);\n-      expect(errorSpy.calls.mostRecent().args[0]).toContain('mymodule.ts.MyComp.html');\n-      expect(errorSpy.calls.mostRecent().args[0])\n-          .toContain(`Property 'unknownProp' does not exist on type 'MyComp'`);\n-\n-      expect(exitCode).toEqual(1);\n-    });\n-\n-    it('should report errors as coming from the html file, not the factory', () => {\n-      writeConfig(`{\n-          \"extends\": \"./tsconfig-base.json\",\n-          \"files\": [\"mymodule.ts\"]\n-        }`);\n-      write('my.component.ts', `\n-        import {Component} from '@angular/core';\n-        @Component({templateUrl: './my.component.html'})\n-        export class MyComp {}\n-      `);\n-      write('my.component.html', `<h1>\n-        {{unknownProp}}\n-       </h1>`);\n-      write('mymodule.ts', `\n-        import {NgModule} from '@angular/core';\n-        import {MyComp} from './my.component';\n-\n-        @NgModule({declarations: [MyComp]})\n-        export class MyModule {}\n-      `);\n-\n-      const exitCode = main(['-p', basePath], errorSpy);\n-      expect(errorSpy).toHaveBeenCalledTimes(1);\n-      expect(errorSpy.calls.mostRecent().args[0]).toContain('my.component.html(1,5):');\n-      expect(errorSpy.calls.mostRecent().args[0])\n-          .toContain(`Property 'unknownProp' does not exist on type 'MyComp'`);\n-\n-      expect(exitCode).toEqual(1);\n-    });\n-  });\n-\n-  it('should give a specific error when an Angular Ivy NgModule is imported', () => {\n-    writeConfig(`{\n-      \"extends\": \"./tsconfig-base.json\",\n-      \"files\": [\"mymodule.ts\"]\n-    }`);\n-    write('node_modules/test/index.d.ts', `\n-      export declare class FooModule {\n-        static ɵmod = null;\n-      }\n-    `);\n-    write('mymodule.ts', `\n-      import {NgModule} from '@angular/core';\n-      import {FooModule} from 'test';\n-\n-      @NgModule({\n-        imports: [FooModule],\n-      })\n-      export class TestModule {}\n-    `);\n-\n-    const exitCode = main(['-p', basePath], errorSpy);\n-    expect(errorSpy).toHaveBeenCalledTimes(1);\n-    const message = errorSpy.calls.mostRecent().args[0];\n-\n-    // The error message should mention Ivy specifically.\n-    expect(message).toContain('Angular Ivy');\n-  });\n-\n-  describe('compile ngfactory files', () => {\n-    it('should compile ngfactory files that are not referenced by root files', () => {\n-      writeConfig(`{\n-          \"extends\": \"./tsconfig-base.json\",\n-          \"files\": [\"mymodule.ts\"]\n-        }`);\n-      write('mymodule.ts', `\n-        import {CommonModule} from '@angular/common';\n-        import {NgModule} from '@angular/core';\n-\n-        @NgModule({\n-          imports: [CommonModule]\n-        })\n-        export class MyModule {}\n-      `);\n-\n-      const exitCode = main(['-p', basePath], errorSpy);\n-      expect(exitCode).toEqual(0);\n-\n-      expect(fs.existsSync(path.resolve(outDir, 'mymodule.ngfactory.js'))).toBe(true);\n-      expect(fs.existsSync(\n-                 path.resolve(outDir, 'node_modules', '@angular', 'core', 'core.ngfactory.js')))\n-          .toBe(true);\n-    });\n-\n-    describe('comments', () => {\n-      function compileAndRead(contents: string) {\n-        writeConfig(`{\n-          \"extends\": \"./tsconfig-base.json\",\n-          \"files\": [\"mymodule.ts\"],\n-          \"angularCompilerOptions\": {\"allowEmptyCodegenFiles\": true}\n-        }`);\n-        write('mymodule.ts', contents);\n-\n-        const exitCode = main(['-p', basePath], errorSpy);\n-        expect(exitCode).toEqual(0);\n-\n-        const modPath = path.resolve(outDir, 'mymodule.ngfactory.js');\n-        expect(fs.existsSync(modPath)).toBe(true);\n-        return fs.readFileSync(modPath, {encoding: 'UTF-8'});\n-      }\n-\n-      it('should be added', () => {\n-        const contents = compileAndRead(`\n-        import {CommonModule} from '@angular/common';\n-        import {NgModule} from '@angular/core';\n-\n-        @NgModule({\n-          imports: [CommonModule]\n-        })\n-        export class MyModule {}\n-      `);\n-        expect(contents).toContain(\n-            '/**\\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.');\n-        expect(contents).toContain('\\n * @suppress {suspiciousCode');\n-      });\n-\n-      it('should be merged with existing fileoverview comments', () => {\n-        const contents = compileAndRead(`/**\\n * @fileoverview Hello world.\\n */\n-\n-        import {CommonModule} from '@angular/common';\n-        import {NgModule} from '@angular/core';\n-\n-        @NgModule({\n-          imports: [CommonModule]\n-        })\n-        export class MyModule {}\n-      `);\n-        expect(contents).toContain('\\n * @fileoverview Hello world.\\n');\n-      });\n-\n-      it('should only pick file comments', () => {\n-        const contents = compileAndRead(`\n-          /** Comment on class. */\n-          class MyClass {\n-\n-          }\n-        `);\n-        expect(contents).toContain('@fileoverview');\n-        expect(contents).not.toContain('Comment on class.');\n-      });\n-\n-      it('should not be merged with @license comments', () => {\n-        const contents = compileAndRead(`/** @license Some license. */\n-\n-        import {CommonModule} from '@angular/common';\n-        import {NgModule} from '@angular/core';\n-\n-        @NgModule({\n-          imports: [CommonModule]\n-        })\n-        export class MyModule {}\n-      `);\n-        expect(contents).toContain('@fileoverview');\n-        expect(contents).not.toContain('@license');\n-      });\n-\n-      it('should be included in empty files', () => {\n-        const contents = compileAndRead(`/** My comment. */\n-\n-        import {Inject, Injectable, Optional} from '@angular/core';\n-\n-        @Injectable()\n-        export class NotAnAngularComponent {}\n-      `);\n-        expect(contents).toContain('My comment');\n-      });\n-    });\n-\n-    it('should compile with an explicit tsconfig reference', () => {\n-      writeConfig(`{\n-          \"extends\": \"./tsconfig-base.json\",\n-          \"files\": [\"mymodule.ts\"]\n-        }`);\n-      write('mymodule.ts', `\n-        import {CommonModule} from '@angular/common';\n-        import {NgModule} from '@angular/core';\n-\n-        @NgModule({\n-          imports: [CommonModule]\n-        })\n-        export class MyModule {}\n-      `);\n-\n-      const exitCode = main(['-p', path.join(basePath, 'tsconfig.json')], errorSpy);\n-      expect(exitCode).toEqual(0);\n-      expect(fs.existsSync(path.resolve(outDir, 'mymodule.ngfactory.js'))).toBe(true);\n-      expect(fs.existsSync(\n-                 path.resolve(outDir, 'node_modules', '@angular', 'core', 'core.ngfactory.js')))\n-          .toBe(true);\n-    });\n-\n-    describe(`emit generated files depending on the source file`, () => {\n-      const modules = ['comp', 'directive', 'module'];\n-      beforeEach(() => {\n-        write('src/comp.ts', `\n-              import {Component, ViewEncapsulation} from '@angular/core';\n-\n-              @Component({\n-                selector: 'comp-a',\n-                template: 'A',\n-                styleUrls: ['plain.css'],\n-                encapsulation: ViewEncapsulation.None\n-              })\n-              export class CompA {\n-              }\n-\n-              @Component({\n-                selector: 'comp-b',\n-                template: 'B',\n-                styleUrls: ['emulated.css']\n-              })\n-              export class CompB {\n-              }`);\n-        write('src/plain.css', 'div {}');\n-        write('src/emulated.css', 'div {}');\n-        write('src/directive.ts', `\n-              import {Directive, Input} from '@angular/core';\n-\n-              @Directive({\n-                selector: '[someDir]',\n-                host: {'[title]': 'someProp'},\n-              })\n-              export class SomeDirective {\n-                @Input() someProp: string;\n-              }`);\n-        write('src/module.ts', `\n-              import {NgModule} from '@angular/core';\n-\n-              import {CompA, CompB} from './comp';\n-              import {SomeDirective} from './directive';\n-\n-              @NgModule({\n-                declarations: [\n-                  CompA, CompB,\n-                  SomeDirective,\n-                ],\n-                exports: [\n-                  CompA, CompB,\n-                  SomeDirective,\n-                ],\n-              })\n-              export class SomeModule {\n-              }`);\n-      });\n-\n-      function expectJsDtsMetadataJsonToExist() {\n-        modules.forEach(moduleName => {\n-          shouldExist(moduleName + '.js');\n-          shouldExist(moduleName + '.d.ts');\n-          shouldExist(moduleName + '.metadata.json');\n-        });\n-      }\n-\n-      function expectAllGeneratedFilesToExist(enableSummariesForJit = true) {\n-        modules.forEach(moduleName => {\n-          if (/module|comp/.test(moduleName)) {\n-            shouldExist(moduleName + '.ngfactory.js');\n-            shouldExist(moduleName + '.ngfactory.d.ts');\n-          } else {\n-            shouldNotExist(moduleName + '.ngfactory.js');\n-            shouldNotExist(moduleName + '.ngfactory.d.ts');\n-          }\n-          if (enableSummariesForJit) {\n-            shouldExist(moduleName + '.ngsummary.js');\n-            shouldExist(moduleName + '.ngsummary.d.ts');\n-          } else {\n-            shouldNotExist(moduleName + '.ngsummary.js');\n-            shouldNotExist(moduleName + '.ngsummary.d.ts');\n-          }\n-          shouldExist(moduleName + '.ngsummary.json');\n-          shouldNotExist(moduleName + '.ngfactory.metadata.json');\n-          shouldNotExist(moduleName + '.ngsummary.metadata.json');\n-        });\n-        shouldExist('plain.css.ngstyle.js');\n-        shouldExist('plain.css.ngstyle.d.ts');\n-        shouldExist('emulated.css.shim.ngstyle.js');\n-        shouldExist('emulated.css.shim.ngstyle.d.ts');\n-      }\n-\n-      it('should emit generated files from sources with summariesForJit', () => {\n-        writeConfig(`{\n-            \"extends\": \"./tsconfig-base.json\",\n-            \"angularCompilerOptions\": {\n-              \"enableSummariesForJit\": true\n-            },\n-            \"include\": [\"src/**/*.ts\"]\n-          }`);\n-        const exitCode = main(['-p', path.join(basePath, 'tsconfig.json')], errorSpy);\n-        expect(exitCode).toEqual(0);\n-        outDir = path.resolve(basePath, 'built', 'src');\n-        expectJsDtsMetadataJsonToExist();\n-        expectAllGeneratedFilesToExist(true);\n-      });\n-\n-      it('should not emit generated files from sources without summariesForJit', () => {\n-        writeConfig(`{\n-            \"extends\": \"./tsconfig-base.json\",\n-            \"angularCompilerOptions\": {\n-              \"enableSummariesForJit\": false\n-            },\n-            \"include\": [\"src/**/*.ts\"]\n-          }`);\n-        const exitCode = main(['-p', path.join(basePath, 'tsconfig.json')], errorSpy);\n-        expect(exitCode).toEqual(0);\n-        outDir = path.resolve(basePath, 'built', 'src');\n-        expectJsDtsMetadataJsonToExist();\n-        expectAllGeneratedFilesToExist(false);\n-      });\n-\n-      it('should emit generated files from libraries', () => {\n-        // first only generate .d.ts / .js / .metadata.json files\n-        writeConfig(`{\n-            \"extends\": \"./tsconfig-base.json\",\n-            \"angularCompilerOptions\": {\n-              \"skipTemplateCodegen\": true\n-            },\n-            \"compilerOptions\": {\n-              \"outDir\": \"lib\"\n-            },\n-            \"include\": [\"src/**/*.ts\"]\n-          }`);\n-        let exitCode = main(['-p', path.join(basePath, 'tsconfig.json')], errorSpy);\n-        expect(exitCode).toEqual(0);\n-        outDir = path.resolve(basePath, 'lib', 'src');\n-        modules.forEach(moduleName => {\n-          shouldExist(moduleName + '.js');\n-          shouldExist(moduleName + '.d.ts');\n-          shouldExist(moduleName + '.metadata.json');\n-          shouldNotExist(moduleName + '.ngfactory.js');\n-          shouldNotExist(moduleName + '.ngfactory.d.ts');\n-          shouldNotExist(moduleName + '.ngsummary.js');\n-          shouldNotExist(moduleName + '.ngsummary.d.ts');\n-          shouldNotExist(moduleName + '.ngsummary.json');\n-          shouldNotExist(moduleName + '.ngfactory.metadata.json');\n-          shouldNotExist(moduleName + '.ngsummary.metadata.json');\n-        });\n-        shouldNotExist('src/plain.css.ngstyle.js');\n-        shouldNotExist('src/plain.css.ngstyle.d.ts');\n-        shouldNotExist('src/emulated.css.shim.ngstyle.js');\n-        shouldNotExist('src/emulated.css.shim.ngstyle.d.ts');\n-        // Then compile again, using the previous .metadata.json as input.\n-        writeConfig(`{\n-            \"extends\": \"./tsconfig-base.json\",\n-            \"angularCompilerOptions\": {\n-              \"skipTemplateCodegen\": false,\n-              \"enableSummariesForJit\": true\n-            },\n-            \"compilerOptions\": {\n-              \"outDir\": \"built\"\n-            },\n-            \"include\": [\"lib/**/*.d.ts\"]\n-          }`);\n-        write('lib/src/plain.css', 'div {}');\n-        write('lib/src/emulated.css', 'div {}');\n-        exitCode = main(['-p', path.join(basePath, 'tsconfig.json')], errorSpy);\n-        expect(exitCode).toEqual(0);\n-        outDir = path.resolve(basePath, 'built', 'lib', 'src');\n-        expectAllGeneratedFilesToExist();\n-      });\n-    });\n-\n-    describe('closure', () => {\n-      it('should not run tsickle by default', () => {\n-        writeConfig(`{\n-          \"extends\": \"./tsconfig-base.json\",\n-          \"files\": [\"mymodule.ts\"],\n-        }`);\n-        write('mymodule.ts', `\n-        import {NgModule, Component} from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {}\n-\n-        @NgModule({declarations: [MyComp]})\n-        export class MyModule {}\n-      `);\n-\n-        const exitCode =\n-            main(['-p', basePath], errorSpy, undefined, undefined, undefined, undefined, tsickle);\n-        expect(exitCode).toEqual(0);\n-\n-        const mymodulejs = path.resolve(outDir, 'mymodule.js');\n-        const mymoduleSource = fs.readFileSync(mymodulejs, 'utf8');\n-        expect(mymoduleSource).not.toContain('@fileoverview added by tsickle');\n-      });\n-\n-      it('should add closure annotations', () => {\n-        writeConfig(`{\n-          \"extends\": \"./tsconfig-base.json\",\n-          \"angularCompilerOptions\": {\n-            \"annotateForClosureCompiler\": true\n-          },\n-          \"files\": [\"mymodule.ts\"]\n-        }`);\n-        write('mymodule.ts', `\n-        import {NgModule, Component, Injectable} from '@angular/core';\n-\n-        @Injectable()\n-        export class InjectedClass {}\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(injected: InjectedClass) {}\n-          fn(p: any) {}\n-        }\n-\n-        @NgModule({declarations: [MyComp]})\n-        export class MyModule {}\n-      `);\n-\n-        const exitCode =\n-            main(['-p', basePath], errorSpy, undefined, undefined, undefined, undefined, tsickle);\n-        expect(exitCode).toEqual(0);\n-\n-        const mymodulejs = path.resolve(outDir, 'mymodule.js');\n-        const mymoduleSource = fs.readFileSync(mymodulejs, 'utf8');\n-        expect(mymoduleSource).toContain('@fileoverview added by tsickle');\n-        expect(mymoduleSource).toContain('@param {?} p');\n-        expect(mymoduleSource).toContain('@nocollapse');\n-      });\n-    });\n-\n-    it('should not rewrite imports when annotating with closure', () => {\n-      writeConfig(`{\n-        \"extends\": \"./tsconfig-base.json\",\n-        \"compilerOptions\": {\n-          \"paths\": {\n-            \"submodule\": [\"./src/submodule/public_api.ts\"]\n-          }\n-        },\n-        \"angularCompilerOptions\": {\n-          \"annotateForClosureCompiler\": true\n-        },\n-        \"files\": [\"mymodule.ts\"]\n-      }`);\n-      write('src/test.txt', ' ');\n-      write('src/submodule/public_api.ts', `\n-        export const A = 1;\n-      `);\n-      write('mymodule.ts', `\n-        import {NgModule, Component} from '@angular/core';\n-        import {A} from 'submodule';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          fn(p: any) { return A; }\n-        }\n-\n-        @NgModule({declarations: [MyComp]})\n-        export class MyModule {}\n-    `);\n-\n-      const exitCode =\n-          main(['-p', basePath], errorSpy, undefined, undefined, undefined, undefined, tsickle);\n-      expect(exitCode).toEqual(0);\n-      const mymodulejs = path.resolve(outDir, 'mymodule.js');\n-      const mymoduleSource = fs.readFileSync(mymodulejs, 'utf8');\n-      expect(mymoduleSource).toContain(`import { A } from 'submodule'`);\n-    });\n-\n-    describe('expression lowering', () => {\n-      beforeEach(() => {\n-        writeConfig(`{\n-            \"extends\": \"./tsconfig-base.json\",\n-            \"files\": [\"mymodule.ts\"]\n-          }`);\n-      });\n-\n-      function compile(): number {\n-        errorSpy.calls.reset();\n-        const result = main(['-p', path.join(basePath, 'tsconfig.json')], errorSpy);\n-        expect(errorSpy).not.toHaveBeenCalled();\n-        return result;\n-      }\n-\n-      it('should be able to lower a lambda expression in a provider', () => {\n-        write('mymodule.ts', `\n-          import {CommonModule} from '@angular/common';\n-          import {NgModule} from '@angular/core';\n-\n-          class Foo {}\n-\n-          @NgModule({\n-            imports: [CommonModule],\n-            providers: [{provide: 'someToken', useFactory: () => new Foo()}]\n-          })\n-          export class MyModule {}\n-        `);\n-        expect(compile()).toEqual(0);\n-\n-        const mymodulejs = path.resolve(outDir, 'mymodule.js');\n-        const mymoduleSource = fs.readFileSync(mymodulejs, 'utf8');\n-        expect(mymoduleSource).toContain('var ɵ0 = function () { return new Foo(); }');\n-        expect(mymoduleSource).toContain('export { ɵ0');\n-\n-        const mymodulefactory = path.resolve(outDir, 'mymodule.ngfactory.js');\n-        const mymodulefactorySource = fs.readFileSync(mymodulefactory, 'utf8');\n-        expect(mymodulefactorySource).toContain('\"someToken\", i1.ɵ0');\n-      });\n-\n-      it('should be able to lower a function expression in a provider', () => {\n-        write('mymodule.ts', `\n-          import {CommonModule} from '@angular/common';\n-          import {NgModule} from '@angular/core';\n-\n-          class Foo {}\n-\n-          @NgModule({\n-            imports: [CommonModule],\n-            providers: [{provide: 'someToken', useFactory: function() {return new Foo();}}]\n-          })\n-          export class MyModule {}\n-        `);\n-        expect(compile()).toEqual(0);\n-\n-        const mymodulejs = path.resolve(outDir, 'mymodule.js');\n-        const mymoduleSource = fs.readFileSync(mymodulejs, 'utf8');\n-        expect(mymoduleSource).toContain('var ɵ0 = function () { return new Foo(); }');\n-        expect(mymoduleSource).toContain('export { ɵ0');\n-\n-        const mymodulefactory = path.resolve(outDir, 'mymodule.ngfactory.js');\n-        const mymodulefactorySource = fs.readFileSync(mymodulefactory, 'utf8');\n-        expect(mymodulefactorySource).toContain('\"someToken\", i1.ɵ0');\n-      });\n-\n-      it('should able to lower multiple expressions', () => {\n-        write('mymodule.ts', `\n-          import {CommonModule} from '@angular/common';\n-          import {NgModule} from '@angular/core';\n-\n-          class Foo {}\n-\n-          @NgModule({\n-            imports: [CommonModule],\n-            providers: [\n-              {provide: 'someToken', useFactory: () => new Foo()},\n-              {provide: 'someToken', useFactory: () => new Foo()},\n-              {provide: 'someToken', useFactory: () => new Foo()},\n-              {provide: 'someToken', useFactory: () => new Foo()}\n-            ]\n-          })\n-          export class MyModule {}\n-        `);\n-        expect(compile()).toEqual(0);\n-        const mymodulejs = path.resolve(outDir, 'mymodule.js');\n-        const mymoduleSource = fs.readFileSync(mymodulejs, 'utf8');\n-        expect(mymoduleSource).toContain('ɵ0 = function () { return new Foo(); }');\n-        expect(mymoduleSource).toContain('ɵ1 = function () { return new Foo(); }');\n-        expect(mymoduleSource).toContain('ɵ2 = function () { return new Foo(); }');\n-        expect(mymoduleSource).toContain('ɵ3 = function () { return new Foo(); }');\n-        expect(mymoduleSource).toContain('export { ɵ0, ɵ1, ɵ2, ɵ3');\n-      });\n-\n-      it('should be able to lower an indirect expression', () => {\n-        write('mymodule.ts', `\n-          import {CommonModule} from '@angular/common';\n-          import {NgModule} from '@angular/core';\n-\n-          class Foo {}\n-\n-          const factory = () => new Foo();\n-\n-          @NgModule({\n-            imports: [CommonModule],\n-            providers: [{provide: 'someToken', useFactory: factory}]\n-          })\n-          export class MyModule {}\n-        `);\n-        expect(compile()).toEqual(0, 'Compile failed');\n-\n-        const mymodulejs = path.resolve(outDir, 'mymodule.js');\n-        const mymoduleSource = fs.readFileSync(mymodulejs, 'utf8');\n-        expect(mymoduleSource).toContain('var factory = function () { return new Foo(); }');\n-        expect(mymoduleSource).toContain('var ɵ0 = factory;');\n-        expect(mymoduleSource).toContain('export { ɵ0 };');\n-      });\n-\n-      it('should not lower a lambda that is already exported', () => {\n-        write('mymodule.ts', `\n-          import {CommonModule} from '@angular/common';\n-          import {NgModule} from '@angular/core';\n-\n-          export class Foo {}\n-\n-          export const factory = () => new Foo();\n-\n-          @NgModule({\n-            imports: [CommonModule],\n-            providers: [{provide: 'someToken', useFactory: factory}]\n-          })\n-          export class MyModule {}\n-        `);\n-        expect(compile()).toEqual(0);\n-\n-        const mymodulejs = path.resolve(outDir, 'mymodule.js');\n-        const mymoduleSource = fs.readFileSync(mymodulejs, 'utf8');\n-        expect(mymoduleSource).not.toContain('ɵ0');\n-      });\n-\n-      it('should lower an NgModule id', () => {\n-        write('mymodule.ts', `\n-          import {NgModule} from '@angular/core';\n-\n-          @NgModule({\n-            id: (() => 'test')(),\n-          })\n-          export class MyModule {}\n-        `);\n-        expect(compile()).toEqual(0);\n-\n-        const mymodulejs = path.resolve(outDir, 'mymodule.js');\n-        const mymoduleSource = fs.readFileSync(mymodulejs, 'utf8');\n-        expect(mymoduleSource).toContain('id: ɵ0');\n-        expect(mymoduleSource).toMatch(/ɵ0 = .*'test'/);\n-      });\n-\n-      it('should lower loadChildren', () => {\n-        write('mymodule.ts', `\n-          import {Component, NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          export function foo(): any {\n-            console.log('side-effect');\n-            return 'test';\n-          }\n-\n-          @Component({\n-            selector: 'route',\n-            template: 'route',\n-          })\n-          export class Route {}\n-\n-          @NgModule({\n-            declarations: [Route],\n-            imports: [\n-              RouterModule.forRoot([\n-                {path: '', pathMatch: 'full', component: Route, loadChildren: foo()}\n-              ]),\n-            ]\n-          })\n-          export class MyModule {}\n-        `);\n-        expect(compile()).toEqual(0);\n-\n-        const mymodulejs = path.resolve(outDir, 'mymodule.js');\n-        const mymoduleSource = fs.readFileSync(mymodulejs, 'utf8');\n-        expect(mymoduleSource).toContain('loadChildren: ɵ0');\n-        expect(mymoduleSource).toMatch(/ɵ0 = .*foo\\(\\)/);\n-      });\n-\n-      it('should lower loadChildren in an exported variable expression', () => {\n-        write('mymodule.ts', `\n-          import {Component, NgModule} from '@angular/core';\n-          import {RouterModule} from '@angular/router';\n-\n-          export function foo(): any {\n-            console.log('side-effect');\n-            return 'test';\n-          }\n-\n-          @Component({\n-            selector: 'route',\n-            template: 'route',\n-          })\n-          export class Route {}\n-\n-          export const routes = [\n-            {path: '', pathMatch: 'full', component: Route, loadChildren: foo()}\n-          ];\n-\n-          @NgModule({\n-            declarations: [Route],\n-            imports: [\n-              RouterModule.forRoot(routes),\n-            ]\n-          })\n-          export class MyModule {}\n-        `);\n-        expect(compile()).toEqual(0);\n-\n-        const mymodulejs = path.resolve(outDir, 'mymodule.js');\n-        const mymoduleSource = fs.readFileSync(mymodulejs, 'utf8');\n-        expect(mymoduleSource).toContain('loadChildren: ɵ0');\n-        expect(mymoduleSource).toMatch(/ɵ0 = .*foo\\(\\)/);\n-      });\n-\n-      it('should be able to lower supported expressions', () => {\n-        writeConfig(`{\n-          \"extends\": \"./tsconfig-base.json\",\n-          \"files\": [\"module.ts\"]\n-        }`);\n-        write('module.ts', `\n-          import {NgModule, InjectionToken} from '@angular/core';\n-          import {AppComponent} from './app';\n-\n-          export interface Info {\n-            route: string;\n-            data: string;\n-          }\n-\n-          export const T1 = new InjectionToken<string>('t1');\n-          export const T2 = new InjectionToken<string>('t2');\n-          export const T3 = new InjectionToken<number>('t3');\n-          export const T4 = new InjectionToken<Info[]>('t4');\n-\n-          enum SomeEnum {\n-            OK,\n-            Cancel\n-          }\n-\n-          function calculateString() {\n-            return 'someValue';\n-          }\n-\n-          const routeLikeData = [{\n-             route: '/home',\n-             data: calculateString()\n-          }];\n-\n-          @NgModule({\n-            declarations: [AppComponent],\n-            providers: [\n-              { provide: T1, useValue: calculateString() },\n-              { provide: T2, useFactory: () => 'someValue' },\n-              { provide: T3, useValue: SomeEnum.OK },\n-              { provide: T4, useValue: routeLikeData }\n-            ]\n-          })\n-          export class MyModule {}\n-        `);\n-        write('app.ts', `\n-          import {Component, Inject} from '@angular/core';\n-          import * as m from './module';\n-\n-          @Component({\n-            selector: 'my-app',\n-            template: ''\n-          })\n-          export class AppComponent {\n-            constructor(\n-              @Inject(m.T1) private t1: string,\n-              @Inject(m.T2) private t2: string,\n-              @Inject(m.T3) private t3: number,\n-              @Inject(m.T4) private t4: m.Info[],\n-            ) {}\n-          }\n-        `);\n-\n-        expect(main(['-p', basePath], errorSpy)).toBe(0);\n-        shouldExist('module.js');\n-      });\n-\n-      it('should allow to use lowering with export *', () => {\n-        write('mymodule.ts', `\n-          import {NgModule} from '@angular/core';\n-\n-          export * from './util';\n-\n-          // Note: the lambda will be lowered into an exported expression\n-          @NgModule({providers: [{provide: 'aToken', useValue: () => 2}]})\n-          export class MyModule {}\n-        `);\n-        write('util.ts', `\n-          // Note: The lambda will be lowered into an exported expression\n-          const x = () => 2;\n-\n-          export const y = x;\n-        `);\n-\n-        expect(compile()).toEqual(0);\n-\n-        const mymoduleSource = fs.readFileSync(path.resolve(outDir, 'mymodule.js'), 'utf8');\n-        expect(mymoduleSource).toContain('ɵ0');\n-\n-        const utilSource = fs.readFileSync(path.resolve(outDir, 'util.js'), 'utf8');\n-        expect(utilSource).toContain('ɵ0');\n-\n-        const mymoduleNgFactoryJs =\n-            fs.readFileSync(path.resolve(outDir, 'mymodule.ngfactory.js'), 'utf8');\n-        // check that the generated code refers to ɵ0 from mymodule, and not from util!\n-        expect(mymoduleNgFactoryJs).toContain(`import * as i1 from \"./mymodule\"`);\n-        expect(mymoduleNgFactoryJs).toContain(`\"aToken\", i1.ɵ0`);\n-      });\n-    });\n-\n-    function writeFlatModule(outFile: string) {\n-      writeConfig(`\n-      {\n-        \"extends\": \"./tsconfig-base.json\",\n-        \"angularCompilerOptions\": {\n-          \"flatModuleId\": \"flat_module\",\n-          \"flatModuleOutFile\": \"${outFile}\",\n-          \"skipTemplateCodegen\": true,\n-          \"enableResourceInlining\": true\n-        },\n-        \"files\": [\"public-api.ts\"]\n-      }\n-      `);\n-      write('public-api.ts', `\n-        export * from './src/flat.component';\n-        export * from './src/flat.module';`);\n-      write('src/flat.component.html', '<div>flat module component</div>');\n-      write('src/flat.component.ts', `\n-        import {Component} from '@angular/core';\n-\n-        @Component({\n-          selector: 'flat-comp',\n-          templateUrl: 'flat.component.html',\n-        })\n-        export class FlatComponent {\n-        }`);\n-      write('src/flat.module.ts', `\n-        import {NgModule} from '@angular/core';\n-\n-        import {FlatComponent} from './flat.component';\n-\n-        @NgModule({\n-          declarations: [\n-            FlatComponent,\n-          ],\n-          exports: [\n-            FlatComponent,\n-          ],\n-        })\n-        export class FlatModule {\n-        }`);\n-    }\n-\n-    it('should be able to generate a flat module library', () => {\n-      writeFlatModule('index.js');\n-\n-      const exitCode = main(['-p', path.join(basePath, 'tsconfig.json')], errorSpy);\n-      expect(exitCode).toEqual(0);\n-      shouldExist('index.js');\n-      shouldExist('index.metadata.json');\n-    });\n-\n-    it('should downlevel templates in flat module metadata', () => {\n-      writeFlatModule('index.js');\n-\n-      const exitCode = main(['-p', path.join(basePath, 'tsconfig.json')], errorSpy);\n-      expect(exitCode).toEqual(0);\n-      shouldExist('index.js');\n-      shouldExist('index.metadata.json');\n-\n-      const metadataPath = path.resolve(outDir, 'index.metadata.json');\n-      const metadataSource = fs.readFileSync(metadataPath, 'utf8');\n-      expect(metadataSource).not.toContain('templateUrl');\n-      expect(metadataSource).toContain('<div>flat module component</div>');\n-    });\n-\n-    describe('with tree example', () => {\n-      beforeEach(() => {\n-        writeConfig();\n-        write('index_aot.ts', `\n-          import {enableProdMode} from '@angular/core';\n-          import {platformBrowser} from '@angular/platform-browser';\n-\n-          import {AppModuleNgFactory} from './tree.ngfactory';\n-\n-          enableProdMode();\n-          platformBrowser().bootstrapModuleFactory(AppModuleNgFactory);`);\n-        write('tree.ts', `\n-          import {Component, NgModule} from '@angular/core';\n-          import {CommonModule} from '@angular/common';\n-\n-          @Component({\n-            selector: 'tree',\n-            inputs: ['data'],\n-            template:\n-                \\`<span [style.backgroundColor]=\"bgColor\"> {{data.value}} </span><tree *ngIf='data.right != null' [data]='data.right'></tree><tree *ngIf='data.left != null' [data]='data.left'></tree>\\`\n-          })\n-          export class TreeComponent {\n-            data: any;\n-            bgColor = 0;\n-          }\n-\n-          @NgModule({imports: [CommonModule], bootstrap: [TreeComponent], declarations: [TreeComponent]})\n-          export class AppModule {}\n-        `);\n-      });\n-\n-      it('should compile without error', () => {\n-        expect(main(['-p', path.join(basePath, 'tsconfig.json')], errorSpy)).toBe(0);\n-      });\n-    });\n-\n-    describe('with external symbol re-exports enabled', () => {\n-      it('should be able to compile multiple libraries with summaries', () => {\n-        // Note: we need to emit the generated code for the libraries\n-        // into the node_modules, as that is the only way that we\n-        // currently support when using summaries.\n-        // TODO(tbosch): add support for `paths` to our CompilerHost.fileNameToModuleName\n-        // and then use `paths` here instead of writing to node_modules.\n-\n-        // Angular\n-        write('tsconfig-ng.json', `{\n-          \"extends\": \"./tsconfig-base.json\",\n-          \"angularCompilerOptions\": {\n-            \"generateCodeForLibraries\": true,\n-            \"enableSummariesForJit\": true\n-          },\n-          \"compilerOptions\": {\n-            \"outDir\": \".\"\n-          },\n-          \"include\": [\"node_modules/@angular/core/**/*\"],\n-          \"exclude\": [\n-            \"node_modules/@angular/core/test/**\",\n-            \"node_modules/@angular/core/testing/**\"\n-          ]\n-        }`);\n-\n-        // Lib 1\n-        write('lib1/tsconfig-lib1.json', `{\n-          \"extends\": \"../tsconfig-base.json\",\n-          \"angularCompilerOptions\": {\n-            \"generateCodeForLibraries\": false,\n-            \"enableSummariesForJit\": true,\n-            \"createExternalSymbolFactoryReexports\": true\n-          },\n-          \"compilerOptions\": {\n-            \"rootDir\": \".\",\n-            \"outDir\": \"../node_modules/lib1_built\"\n-          }\n-        }`);\n-        write('lib1/module.ts', `\n-          import {NgModule} from '@angular/core';\n-          export function someFactory(): any { return null; }\n-          @NgModule({\n-            providers: [{provide: 'foo', useFactory: someFactory}]\n-          })\n-          export class Module {}\n-        `);\n-        write('lib1/class1.ts', `export class Class1 {}`);\n-\n-        // Lib 2\n-        write('lib2/tsconfig-lib2.json', `{\n-          \"extends\": \"../tsconfig-base.json\",\n-          \"angularCompilerOptions\": {\n-            \"generateCodeForLibraries\": false,\n-            \"enableSummariesForJit\": true,\n-            \"createExternalSymbolFactoryReexports\": true\n-          },\n-          \"compilerOptions\": {\n-            \"rootDir\": \".\",\n-            \"outDir\": \"../node_modules/lib2_built\"\n-          }\n-        }`);\n-        write('lib2/module.ts', `\n-          export {Module} from 'lib1_built/module';\n-        `);\n-        write('lib2/class2.ts', `\n-          import {Class1} from 'lib1_built/class1';\n-          export class Class2 {\n-            constructor(class1: Class1) {}\n-          }\n-        `);\n-\n-        // Application\n-        write('app/tsconfig-app.json', `{\n-          \"extends\": \"../tsconfig-base.json\",\n-          \"angularCompilerOptions\": {\n-            \"generateCodeForLibraries\": false,\n-            \"enableSummariesForJit\": true,\n-            \"createExternalSymbolFactoryReexports\": true\n-          },\n-          \"compilerOptions\": {\n-            \"rootDir\": \".\",\n-            \"outDir\": \"../built/app\"\n-          }\n-        }`);\n-        write('app/main.ts', `\n-          import {NgModule, Inject} from '@angular/core';\n-          import {Module} from 'lib2_built/module';\n-          @NgModule({\n-            imports: [Module]\n-          })\n-          export class AppModule {\n-            constructor(@Inject('foo') public foo: any) {}\n-          }\n-        `);\n-\n-        expect(main(['-p', path.join(basePath, 'lib1', 'tsconfig-lib1.json')], errorSpy)).toBe(0);\n-        expect(main(['-p', path.join(basePath, 'lib2', 'tsconfig-lib2.json')], errorSpy)).toBe(0);\n-        expect(main(['-p', path.join(basePath, 'app', 'tsconfig-app.json')], errorSpy)).toBe(0);\n-\n-        // library 1\n-        // make `shouldExist` / `shouldNotExist` relative to `node_modules`\n-        outDir = path.resolve(basePath, 'node_modules');\n-        shouldExist('lib1_built/module.js');\n-        shouldExist('lib1_built/module.ngsummary.json');\n-        shouldExist('lib1_built/module.ngsummary.js');\n-        shouldExist('lib1_built/module.ngsummary.d.ts');\n-        shouldExist('lib1_built/module.ngfactory.js');\n-        shouldExist('lib1_built/module.ngfactory.d.ts');\n-\n-        // library 2\n-        // make `shouldExist` / `shouldNotExist` relative to `node_modules`\n-        outDir = path.resolve(basePath, 'node_modules');\n-        shouldExist('lib2_built/module.js');\n-        shouldExist('lib2_built/module.ngsummary.json');\n-        shouldExist('lib2_built/module.ngsummary.js');\n-        shouldExist('lib2_built/module.ngsummary.d.ts');\n-        shouldExist('lib2_built/module.ngfactory.js');\n-        shouldExist('lib2_built/module.ngfactory.d.ts');\n-\n-        shouldExist('lib2_built/class2.ngsummary.json');\n-        shouldNotExist('lib2_built/class2.ngsummary.js');\n-        shouldNotExist('lib2_built/class2.ngsummary.d.ts');\n-        shouldExist('lib2_built/class2.ngfactory.js');\n-        shouldExist('lib2_built/class2.ngfactory.d.ts');\n-\n-        // app\n-        // make `shouldExist` / `shouldNotExist` relative to `built`\n-        outDir = path.resolve(basePath, 'built');\n-        shouldExist('app/main.js');\n-      });\n-\n-      it('should create external symbol re-exports', () => {\n-        writeConfig(`{\n-          \"extends\": \"./tsconfig-base.json\",\n-          \"angularCompilerOptions\": {\n-            \"generateCodeForLibraries\": false,\n-            \"createExternalSymbolFactoryReexports\": true\n-          }\n-        }`);\n-\n-        write('test.ts', `\n-          import {Injectable, NgZone} from '@angular/core';\n-\n-          @Injectable({providedIn: 'root'})\n-          export class MyService {\n-            constructor(public ngZone: NgZone) {}\n-          }\n-        `);\n-\n-        expect(main(['-p', basePath], errorSpy)).toBe(0);\n-\n-        shouldExist('test.js');\n-        shouldExist('test.metadata.json');\n-        shouldExist('test.ngsummary.json');\n-        shouldExist('test.ngfactory.js');\n-        shouldExist('test.ngfactory.d.ts');\n-\n-        const summaryJson = require(path.join(outDir, 'test.ngsummary.json'));\n-        const factoryOutput = fs.readFileSync(path.join(outDir, 'test.ngfactory.js'), 'utf8');\n-\n-        expect(summaryJson['symbols'][0].name).toBe('MyService');\n-        expect(summaryJson['symbols'][1])\n-            .toEqual(jasmine.objectContaining({name: 'NgZone', importAs: 'NgZone_1'}));\n-\n-        expect(factoryOutput).toContain(`export { NgZone as NgZone_1 } from \"@angular/core\";`);\n-      });\n-    });\n-\n-    it('should be able to compile multiple libraries with summaries', () => {\n-      // Lib 1\n-      write('lib1/tsconfig-lib1.json', `{\n-        \"extends\": \"../tsconfig-base.json\",\n-        \"angularCompilerOptions\": {\n-          \"generateCodeForLibraries\": false,\n-          \"enableSummariesForJit\": true\n-        },\n-        \"compilerOptions\": {\n-          \"rootDir\": \".\",\n-          \"outDir\": \"../node_modules/lib1_built\"\n-        }\n-      }`);\n-      write('lib1/module.ts', `\n-        import {NgModule} from '@angular/core';\n-\n-        export function someFactory(): any { return null; }\n-\n-        @NgModule({\n-          providers: [{provide: 'foo', useFactory: someFactory}]\n-        })\n-        export class Module {}\n-      `);\n-      write('lib1/class1.ts', `export class Class1 {}`);\n-\n-      // Lib 2\n-      write('lib2/tsconfig-lib2.json', `{\n-        \"extends\": \"../tsconfig-base.json\",\n-        \"angularCompilerOptions\": {\n-          \"generateCodeForLibraries\": false,\n-          \"enableSummariesForJit\": true\n-        },\n-        \"compilerOptions\": {\n-          \"rootDir\": \".\",\n-          \"outDir\": \"../node_modules/lib2_built\"\n-        }\n-      }`);\n-      write('lib2/module.ts', `export {Module} from 'lib1_built/module';`);\n-      write('lib2/class2.ts', `\n-        import {Class1} from 'lib1_built/class1';\n-\n-        export class Class2 {\n-          constructor(class1: Class1) {}\n-        }\n-      `);\n-\n-      // Application\n-      write('app/tsconfig-app.json', `{\n-        \"extends\": \"../tsconfig-base.json\",\n-        \"angularCompilerOptions\": {\n-          \"generateCodeForLibraries\": false,\n-          \"enableSummariesForJit\": true\n-        },\n-        \"compilerOptions\": {\n-          \"rootDir\": \".\",\n-          \"outDir\": \"../built/app\"\n-        }\n-      }`);\n-      write('app/main.ts', `\n-        import {NgModule, Inject} from '@angular/core';\n-        import {Module} from 'lib2_built/module';\n-\n-        @NgModule({\n-          imports: [Module]\n-        })\n-        export class AppModule {\n-          constructor(@Inject('foo') public foo: any) {}\n-        }\n-      `);\n-\n-      expect(main(['-p', path.join(basePath, 'lib1', 'tsconfig-lib1.json')], errorSpy)).toBe(0);\n-      expect(main(['-p', path.join(basePath, 'lib2', 'tsconfig-lib2.json')], errorSpy)).toBe(0);\n-      expect(main(['-p', path.join(basePath, 'app', 'tsconfig-app.json')], errorSpy)).toBe(0);\n-\n-      // library 1\n-      // make `shouldExist` / `shouldNotExist` relative to `node_modules`\n-      outDir = path.resolve(basePath, 'node_modules');\n-      shouldExist('lib1_built/module.js');\n-      shouldExist('lib1_built/module.ngsummary.json');\n-      shouldExist('lib1_built/module.ngsummary.js');\n-      shouldExist('lib1_built/module.ngsummary.d.ts');\n-      shouldExist('lib1_built/module.ngfactory.js');\n-      shouldExist('lib1_built/module.ngfactory.d.ts');\n-\n-      // library 2\n-      // make `shouldExist` / `shouldNotExist` relative to `node_modules`\n-      outDir = path.resolve(basePath, 'node_modules');\n-      shouldExist('lib2_built/module.js');\n-\n-      // \"module.ts\" re-exports an external symbol and will therefore\n-      // have a summary JSON file and its corresponding JIT summary.\n-      shouldExist('lib2_built/module.ngsummary.json');\n-      shouldExist('lib2_built/module.ngsummary.js');\n-      shouldExist('lib2_built/module.ngsummary.d.ts');\n-      // \"module.ts\" only re-exports an external symbol and the AOT compiler does not\n-      // need to generate anything. Therefore there should be no factory files.\n-      shouldNotExist('lib2_built/module.ngfactory.js');\n-      shouldNotExist('lib2_built/module.ngfactory.d.ts');\n-\n-      shouldExist('lib2_built/class2.ngsummary.json');\n-      shouldNotExist('lib2_built/class2.ngsummary.js');\n-      shouldNotExist('lib2_built/class2.ngsummary.d.ts');\n-      // We don't expect factories here because the \"class2.ts\" file\n-      // just exports a class that does not produce any AOT code.\n-      shouldNotExist('lib2_built/class2.ngfactory.js');\n-      shouldNotExist('lib2_built/class2.ngfactory.d.ts');\n-\n-      // app\n-      // make `shouldExist` / `shouldNotExist` relative to `built`\n-      outDir = path.resolve(basePath, 'built');\n-      shouldExist('app/main.js');\n-    });\n-\n-    describe('enableResourceInlining', () => {\n-      it('should inline templateUrl and styleUrl in JS and metadata', () => {\n-        writeConfig(`{\n-          \"extends\": \"./tsconfig-base.json\",\n-          \"files\": [\"mymodule.ts\"],\n-          \"angularCompilerOptions\": {\n-            \"enableResourceInlining\": true\n-          }\n-        }`);\n-        write('my.component.ts', `\n-        import {Component} from '@angular/core';\n-        @Component({\n-          templateUrl: './my.component.html',\n-          styleUrls: ['./my.component.css'],\n-        })\n-        export class MyComp {}\n-      `);\n-        write('my.component.html', `<h1>Some template content</h1>`);\n-        write('my.component.css', `h1 {color: blue}`);\n-        write('mymodule.ts', `\n-        import {NgModule} from '@angular/core';\n-        import {MyComp} from './my.component';\n-\n-        @NgModule({declarations: [MyComp]})\n-        export class MyModule {}\n-      `);\n-\n-        const exitCode = main(['-p', basePath]);\n-        expect(exitCode).toEqual(0);\n-        outDir = path.resolve(basePath, 'built');\n-        const outputJs = fs.readFileSync(path.join(outDir, 'my.component.js'), {encoding: 'utf-8'});\n-        expect(outputJs).not.toContain('templateUrl');\n-        expect(outputJs).not.toContain('styleUrls');\n-        expect(outputJs).toContain('Some template content');\n-        expect(outputJs).toContain('color: blue');\n-\n-        const outputMetadata =\n-            fs.readFileSync(path.join(outDir, 'my.component.metadata.json'), {encoding: 'utf-8'});\n-        expect(outputMetadata).not.toContain('templateUrl');\n-        expect(outputMetadata).not.toContain('styleUrls');\n-        expect(outputMetadata).toContain('Some template content');\n-        expect(outputMetadata).toContain('color: blue');\n-      });\n-    });\n-  });\n-\n-\n-  describe('expression lowering', () => {\n-    const shouldExist = (fileName: string) => {\n-      if (!fs.existsSync(path.resolve(basePath, fileName))) {\n-        throw new Error(`Expected ${fileName} to be emitted (basePath: ${basePath})`);\n-      }\n-    };\n-\n-    it('should be able to lower supported expressions', () => {\n-      writeConfig(`{\n-        \"extends\": \"./tsconfig-base.json\",\n-        \"files\": [\"module.ts\"]\n-      }`);\n-      write('module.ts', `\n-        import {NgModule, InjectionToken} from '@angular/core';\n-        import {AppComponent} from './app';\n-\n-        export interface Info {\n-          route: string;\n-          data: string;\n-        }\n-\n-        export const T1 = new InjectionToken<string>('t1');\n-        export const T2 = new InjectionToken<string>('t2');\n-        export const T3 = new InjectionToken<number>('t3');\n-        export const T4 = new InjectionToken<Info[]>('t4');\n-\n-        enum SomeEnum {\n-          OK,\n-          Cancel\n-        }\n-\n-        function calculateString() {\n-          return 'someValue';\n-        }\n-\n-        const routeLikeData = [{\n-           route: '/home',\n-           data: calculateString()\n-        }];\n-\n-        @NgModule({\n-          declarations: [AppComponent],\n-          providers: [\n-            { provide: T1, useValue: calculateString() },\n-            { provide: T2, useFactory: () => 'someValue' },\n-            { provide: T3, useValue: SomeEnum.OK },\n-            { provide: T4, useValue: routeLikeData }\n-          ]\n-        })\n-        export class MyModule {}\n-      `);\n-      write('app.ts', `\n-        import {Component, Inject} from '@angular/core';\n-        import * as m from './module';\n-\n-        @Component({\n-          selector: 'my-app',\n-          template: ''\n-        })\n-        export class AppComponent {\n-          constructor(\n-            @Inject(m.T1) private t1: string,\n-            @Inject(m.T2) private t2: string,\n-            @Inject(m.T3) private t3: number,\n-            @Inject(m.T4) private t4: m.Info[],\n-          ) {}\n-        }\n-      `);\n-\n-      expect(main(['-p', basePath], s => {})).toBe(0);\n-      shouldExist('built/module.js');\n-    });\n-  });\n-\n-  describe('watch mode', () => {\n-    let timer: (() => void)|undefined = undefined;\n-    let results: ((message: string) => void)|undefined = undefined;\n-    let originalTimeout: number;\n-\n-    function trigger() {\n-      const delay = 1000;\n-      setTimeout(() => {\n-        const t = timer;\n-        timer = undefined;\n-        if (!t) {\n-          fail('Unexpected state. Timer was not set.');\n-        } else {\n-          t();\n-        }\n-      }, delay);\n-    }\n-\n-    function whenResults(): Promise<string> {\n-      return new Promise(resolve => {\n-        results = message => {\n-          resolve(message);\n-          results = undefined;\n-        };\n-      });\n-    }\n-\n-    function errorSpy(message: string): void {\n-      if (results) results(message);\n-    }\n-\n-    beforeEach(() => {\n-      originalTimeout = jasmine.DEFAULT_TIMEOUT_INTERVAL;\n-      jasmine.DEFAULT_TIMEOUT_INTERVAL = 10000;\n-      const timerToken = 100;\n-      // TODO: @JiaLiPassion, need to wait @types/jasmine to handle optional method case\n-      // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/43486\n-      spyOn(ts.sys as any, 'setTimeout').and.callFake((callback: () => void) => {\n-        timer = callback;\n-        return timerToken;\n-      });\n-      // TODO: @JiaLiPassion, need to wait @types/jasmine to handle optional method case\n-      // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/43486\n-      spyOn(ts.sys as any, 'clearTimeout').and.callFake((token: number) => {\n-        if (token == timerToken) {\n-          timer = undefined;\n-        }\n-      });\n-\n-      write('greet.html', `<p class=\"greeting\"> Hello {{name}}!</p>`);\n-      write('greet.css', `p.greeting { color: #eee }`);\n-      write('greet.ts', `\n-        import {Component, Input} from '@angular/core';\n-\n-        @Component({\n-          selector: 'greet',\n-          templateUrl: 'greet.html',\n-          styleUrls: ['greet.css']\n-        })\n-        export class Greet {\n-          @Input()\n-          name: string;\n-        }\n-      `);\n-\n-      write('app.ts', `\n-        import {Component} from '@angular/core'\n-\n-        @Component({\n-          selector: 'my-app',\n-          template: \\`\n-            <div>\n-              <greet [name]='name'></greet>\n-            </div>\n-          \\`,\n-        })\n-        export class App {\n-          name:string;\n-          constructor() {\n-            this.name = \\`Angular!\\`\n-          }\n-        }`);\n-\n-      write('module.ts', `\n-        import {NgModule} from '@angular/core';\n-        import {Greet} from './greet';\n-        import {App} from './app';\n-\n-        @NgModule({\n-          declarations: [Greet, App]\n-        })\n-        export class MyModule {}\n-      `);\n-    });\n-\n-    afterEach(() => {\n-      jasmine.DEFAULT_TIMEOUT_INTERVAL = originalTimeout;\n-    });\n-\n-    function writeAppConfig(location: string) {\n-      writeConfig(`{\n-            \"extends\": \"./tsconfig-base.json\",\n-            \"compilerOptions\": {\n-              \"outDir\": \"${location}\"\n-            }\n-          }`);\n-    }\n-\n-    function expectRecompile(cb: () => void) {\n-      return (done: DoneFn) => {\n-        writeAppConfig('dist');\n-        const config = readCommandLineAndConfiguration(['-p', basePath]);\n-        const compile = watchMode(config.project, config.options, errorSpy);\n-\n-        return new Promise<void>(resolve => {\n-          compile.ready(() => {\n-            cb();\n-\n-            // Allow the watch callbacks to occur and trigger the timer.\n-            trigger();\n-\n-            // Expect the file to trigger a result.\n-            whenResults().then(message => {\n-              expect(message).toMatch(/File change detected/);\n-              compile.close();\n-              done();\n-              resolve();\n-            });\n-          });\n-        });\n-      };\n-    }\n-\n-    it('should recompile when config file changes', expectRecompile(() => writeAppConfig('dist2')));\n-\n-    it('should recompile when a ts file changes', expectRecompile(() => {\n-         write('greet.ts', `\n-          import {Component, Input} from '@angular/core';\n-\n-          @Component({\n-            selector: 'greet',\n-            templateUrl: 'greet.html',\n-            styleUrls: ['greet.css'],\n-          })\n-          export class Greet {\n-            @Input()\n-            name: string;\n-            age: number;\n-          }\n-        `);\n-       }));\n-\n-    it('should recompile when the html file changes', expectRecompile(() => {\n-         write('greet.html', '<p> Hello {{name}} again!</p>');\n-       }));\n-\n-    it('should recompile when the css file changes', expectRecompile(() => {\n-         write('greet.css', `p.greeting { color: blue }`);\n-       }));\n-  });\n-\n-  describe('regressions', () => {\n-    //#20479\n-    it('should not generate an invalid metadata file', () => {\n-      write('src/tsconfig.json', `{\n-        \"extends\": \"../tsconfig-base.json\",\n-        \"files\": [\"lib.ts\"],\n-        \"angularCompilerOptions\": {\n-          \"skipTemplateCodegen\": true\n-        }\n-      }`);\n-      write('src/lib.ts', `\n-        export namespace A{\n-          export class C1 {\n-          }\n-          export interface I1{\n-          }\n-        }`);\n-      expect(main(['-p', path.join(basePath, 'src/tsconfig.json')])).toBe(0);\n-      shouldNotExist('src/lib.metadata.json');\n-    });\n-\n-    //#19544\n-    it('should recognize @NgModule() directive with a redundant @Injectable()', () => {\n-      write('src/tsconfig.json', `{\n-        \"extends\": \"../tsconfig-base.json\",\n-        \"compilerOptions\": {\n-          \"outDir\": \"../dist\",\n-          \"rootDir\": \".\",\n-          \"rootDirs\": [\n-            \".\",\n-            \"../dist\"\n-          ]\n-        },\n-        \"files\": [\"test-module.ts\"]\n-      }`);\n-      write('src/test.component.ts', `\n-        import {Component} from '@angular/core';\n-\n-        @Component({\n-          template: '<p>hello</p>',\n-        })\n-        export class TestComponent {}\n-      `);\n-      write('src/test-module.ts', `\n-        import {Injectable, NgModule} from '@angular/core';\n-        import {TestComponent} from './test.component';\n-\n-        @NgModule({declarations: [TestComponent]})\n-        @Injectable()\n-        export class TestModule {}\n-      `);\n-      const messages: string[] = [];\n-      const exitCode =\n-          main(['-p', path.join(basePath, 'src/tsconfig.json')], message => messages.push(message));\n-      expect(exitCode).toBe(0, 'Compile failed unexpectedly.\\n  ' + messages.join('\\n  '));\n-    });\n-\n-    // #19765\n-    it('should not report an error when the resolved .css file is in outside rootDir', () => {\n-      write('src/tsconfig.json', `{\n-        \"extends\": \"../tsconfig-base.json\",\n-        \"compilerOptions\": {\n-          \"outDir\": \"../dist\",\n-          \"rootDir\": \".\",\n-          \"rootDirs\": [\n-            \".\",\n-            \"../dist\"\n-          ]\n-        },\n-        \"files\": [\"test-module.ts\"]\n-      }`);\n-      write('src/lib/test.component.ts', `\n-        import {Component} from '@angular/core';\n-\n-        @Component({\n-          template: '<p>hello</p>',\n-          styleUrls: ['./test.component.css']\n-        })\n-        export class TestComponent {}\n-      `);\n-      write('dist/dummy.txt', '');  // Force dist to be created\n-      write('dist/lib/test.component.css', `\n-        p { color: blue }\n-      `);\n-      write('src/test-module.ts', `\n-        import {NgModule} from '@angular/core';\n-        import {TestComponent} from './lib/test.component';\n-\n-        @NgModule({declarations: [TestComponent]})\n-        export class TestModule {}\n-      `);\n-      const messages: string[] = [];\n-      const exitCode =\n-          main(['-p', path.join(basePath, 'src/tsconfig.json')], message => messages.push(message));\n-      expect(exitCode).toBe(0, 'Compile failed unexpectedly.\\n  ' + messages.join('\\n  '));\n-    });\n-\n-    it('should emit all structural errors', () => {\n-      write('src/tsconfig.json', `{\n-        \"extends\": \"../tsconfig-base.json\",\n-        \"files\": [\"test-module.ts\"]\n-      }`);\n-      write('src/lib/indirect2.ts', `\n-        declare var f: any;\n-        export const t2 = f\\`<p>hello</p>\\`;\n-      `);\n-      write('src/lib/indirect1.ts', `\n-        import {t2} from './indirect2';\n-        export const t1 = t2 + ' ';\n-      `);\n-      write('src/lib/test.component.ts', `\n-        import {Component} from '@angular/core';\n-        import {t1} from './indirect1';\n-\n-        @Component({\n-          template: t1\n-        })\n-        export class TestComponent {}\n-      `);\n-      write('src/test-module.ts', `\n-        import {NgModule} from '@angular/core';\n-        import {TestComponent} from './lib/test.component';\n-\n-        @NgModule({declarations: [TestComponent]})\n-        export class TestModule {}\n-      `);\n-      const messages: string[] = [];\n-      const exitCode =\n-          main(['-p', path.join(basePath, 'src/tsconfig.json')], message => messages.push(message));\n-      expect(exitCode).toBe(1, 'Compile was expected to fail');\n-      expect(messages[0]).toContain('Tagged template expressions are not supported in metadata');\n-    });\n-\n-    // Regression: #20076\n-    it('should report template error messages', () => {\n-      write('src/tsconfig.json', `{\n-        \"extends\": \"../tsconfig-base.json\",\n-        \"files\": [\"test-module.ts\"]\n-      }`);\n-      write('src/lib/test.component.ts', `\n-        import {Component} from '@angular/core';\n-\n-        @Component({\n-          template: '{{thing.?stuff}}'\n-        })\n-        export class TestComponent {\n-          thing: string;\n-        }\n-      `);\n-      write('src/test-module.ts', `\n-        import {NgModule} from '@angular/core';\n-        import {TestComponent} from './lib/test.component';\n-\n-        @NgModule({declarations: [TestComponent]})\n-        export class TestModule {}\n-      `);\n-      const messages: string[] = [];\n-      const exitCode =\n-          main(['-p', path.join(basePath, 'src/tsconfig.json')], message => messages.push(message));\n-      expect(exitCode).toBe(1, 'Compile was expected to fail');\n-      expect(messages[0]).toContain('Parser Error: Unexpected token');\n-    });\n-\n-    // Regression test for #19979\n-    it('should not stack overflow on a recursive module export', () => {\n-      write('src/tsconfig.json', `{\n-        \"extends\": \"../tsconfig-base.json\",\n-        \"files\": [\"test-module.ts\"]\n-      }`);\n-\n-      write('src/test-module.ts', `\n-        import {Component, NgModule} from '@angular/core';\n-\n-        @Component({\n-          template: 'Hello'\n-        })\n-        export class MyFaultyComponent {}\n-\n-        @NgModule({\n-          exports: [MyFaultyModule],\n-          declarations: [MyFaultyComponent],\n-          providers: [],\n-        })\n-        export class MyFaultyModule { }\n-      `);\n-      const messages: string[] = [];\n-      expect(\n-          main(['-p', path.join(basePath, 'src/tsconfig.json')], message => messages.push(message)))\n-          .toBe(1, 'Compile was expected to fail');\n-      expect(messages[0]).toContain(`module 'MyFaultyModule' is exported recursively`);\n-    });\n-\n-    // Regression test for #19979\n-    it('should not stack overflow on a recursive module import', () => {\n-      write('src/tsconfig.json', `{\n-        \"extends\": \"../tsconfig-base.json\",\n-        \"files\": [\"test-module.ts\"]\n-      }`);\n-\n-      write('src/test-module.ts', `\n-        import {Component, NgModule, forwardRef} from '@angular/core';\n-\n-        @Component({\n-          template: 'Hello'\n-        })\n-        export class MyFaultyComponent {}\n-\n-        @NgModule({\n-          imports: [forwardRef(() => MyFaultyModule)]\n-        })\n-        export class MyFaultyImport {}\n-\n-        @NgModule({\n-          imports: [MyFaultyImport],\n-          declarations: [MyFaultyComponent]\n-        })\n-        export class MyFaultyModule { }\n-      `);\n-      const messages: string[] = [];\n-      expect(\n-          main(['-p', path.join(basePath, 'src/tsconfig.json')], message => messages.push(message)))\n-          .toBe(1, 'Compile was expected to fail');\n-      expect(messages[0]).toContain(`is imported recursively by the module 'MyFaultyImport`);\n-    });\n-\n-    // Regression test for #21273\n-    it('should not report errors for unknown property annotations', () => {\n-      write('src/tsconfig.json', `{\n-        \"extends\": \"../tsconfig-base.json\",\n-        \"files\": [\"test-module.ts\"]\n-      }`);\n-\n-      write('src/test-decorator.ts', `\n-        export function Convert(p: any): any {\n-          // Make sur this doesn't look like a macro function\n-          var r = p;\n-          return r;\n-        }\n-      `);\n-      write('src/test-module.ts', `\n-        import {Component, Input, NgModule} from '@angular/core';\n-        import {Convert} from './test-decorator';\n-\n-        @Component({template: '{{name}}'})\n-        export class TestComponent {\n-          @Input() @Convert(convert) name: string;\n-        }\n-\n-        function convert(n: any) { return n; }\n-\n-        @NgModule({declarations: [TestComponent]})\n-        export class TestModule {}\n-      `);\n-      const messages: string[] = [];\n-      expect(\n-          main(['-p', path.join(basePath, 'src/tsconfig.json')], message => messages.push(message)))\n-          .toBe(0, `Compile failed:\\n ${messages.join('\\n    ')}`);\n-    });\n-\n-    it('should allow using 2 classes with the same name in declarations with noEmitOnError=true',\n-       () => {\n-         write('src/tsconfig.json', `{\n-        \"extends\": \"../tsconfig-base.json\",\n-        \"compilerOptions\": {\n-          \"noEmitOnError\": true\n-        },\n-        \"files\": [\"test-module.ts\"]\n-      }`);\n-         function writeComp(fileName: string) {\n-           write(fileName, `\n-        import {Component} from '@angular/core';\n-\n-        @Component({selector: 'comp', template: ''})\n-        export class TestComponent {}\n-      `);\n-         }\n-         writeComp('src/comp1.ts');\n-         writeComp('src/comp2.ts');\n-         write('src/test-module.ts', `\n-        import {NgModule} from '@angular/core';\n-        import {TestComponent as Comp1} from './comp1';\n-        import {TestComponent as Comp2} from './comp2';\n-\n-        @NgModule({\n-          declarations: [Comp1, Comp2],\n-        })\n-        export class MyModule {}\n-      `);\n-         expect(main(['-p', path.join(basePath, 'src/tsconfig.json')])).toBe(0);\n-       });\n-\n-    it('should not type check a .js files from node_modules with allowJs', () => {\n-      write('src/tsconfig.json', `{\n-        \"extends\": \"../tsconfig-base.json\",\n-        \"compilerOptions\": {\n-          \"noEmitOnError\": true,\n-          \"allowJs\": true,\n-          \"declaration\": false\n-        },\n-        \"files\": [\"test-module.ts\"]\n-      }`);\n-      write('src/test-module.ts', `\n-        import {Component, NgModule} from '@angular/core';\n-        import 'my-library';\n-\n-        @Component({\n-          template: 'hello'\n-        })\n-        export class HelloCmp {}\n-\n-        @NgModule({\n-          declarations: [HelloCmp],\n-        })\n-        export class MyModule {}\n-      `);\n-      write('src/node_modules/t.txt', ``);\n-      write('src/node_modules/my-library/index.js', `\n-        export someVar = 1;\n-        export someOtherVar = undefined + 1;\n-      `);\n-      expect(main(['-p', path.join(basePath, 'src/tsconfig.json')])).toBe(0);\n-    });\n-  });\n-\n-  describe('formatted messages', () => {\n-    it('should emit a formatted error message for a structural error', () => {\n-      write('src/tsconfig.json', `{\n-        \"extends\": \"../tsconfig-base.json\",\n-        \"files\": [\"test-module.ts\"]\n-      }`);\n-      write('src/lib/indirect2.ts', `\n-        declare var f: any;\n-\n-        export const t2 = f\\`<p>hello</p>\\`;\n-      `);\n-      write('src/lib/indirect1.ts', `\n-        import {t2} from './indirect2';\n-        export const t1 = t2 + ' ';\n-      `);\n-      write('src/lib/test.component.ts', `\n-        import {Component} from '@angular/core';\n-        import {t1} from './indirect1';\n-\n-        @Component({\n-          template: t1,\n-          styleUrls: ['./test.component.css']\n-        })\n-        export class TestComponent {}\n-      `);\n-      write('src/test-module.ts', `\n-        import {NgModule} from '@angular/core';\n-        import {TestComponent} from './lib/test.component';\n-\n-        @NgModule({declarations: [TestComponent]})\n-        export class TestModule {}\n-      `);\n-      const messages: string[] = [];\n-      const exitCode =\n-          main(['-p', path.join(basePath, 'src/tsconfig.json')], message => messages.push(message));\n-      expect(exitCode).toBe(1, 'Compile was expected to fail');\n-      const srcPathWithSep = `lib/`;\n-      expect(messages[0])\n-          .toEqual(`${\n-              srcPathWithSep}test.component.ts(6,21): Error during template compile of 'TestComponent'\n-  Tagged template expressions are not supported in metadata in 't1'\n-    't1' references 't2' at ${srcPathWithSep}indirect1.ts(3,27)\n-      't2' contains the error at ${srcPathWithSep}indirect2.ts(4,27).\n-`);\n-    });\n-  });\n-\n-  describe('tree shakeable services', () => {\n-    function compileService(source: string, withTsickle = false): string {\n-      write('service.ts', source);\n-\n-      const exitCode = main(\n-          ['-p', path.join(basePath, 'tsconfig.json')], errorSpy, undefined, undefined, undefined,\n-          undefined, withTsickle ? tsickle : undefined);\n-      expect(exitCode).toEqual(0);\n-\n-      const servicePath = path.resolve(outDir, 'service.js');\n-      return fs.readFileSync(servicePath, 'utf8');\n-    }\n-\n-    beforeEach(() => {\n-      writeConfig(`{\n-        \"extends\": \"./tsconfig-base.json\",\n-        \"files\": [\"service.ts\"]\n-      }`);\n-      write('module.ts', `\n-        import {NgModule} from '@angular/core';\n-\n-        @NgModule({})\n-        export class Module {}\n-      `);\n-    });\n-\n-    describe(`doesn't break existing injectables`, () => {\n-      it('on simple services', () => {\n-        const source = compileService(`\n-        import {Injectable, NgModule} from '@angular/core';\n-\n-        @Injectable()\n-        export class Service {\n-          constructor(public param: string) {}\n-        }\n-\n-        @NgModule({\n-          providers: [{provide: Service, useValue: new Service('test')}],\n-        })\n-        export class ServiceModule {}\n-        `);\n-        expect(source).not.toMatch(/ɵprov/);\n-      });\n-      it('on a service with a base class service', () => {\n-        const source = compileService(`\n-        import {Injectable, NgModule} from '@angular/core';\n-\n-        @Injectable()\n-        export class Dep {}\n-\n-        export class Base {\n-          constructor(private dep: Dep) {}\n-        }\n-        @Injectable()\n-        export class Service extends Base {}\n-\n-        @NgModule({\n-          providers: [Service],\n-        })\n-        export class ServiceModule {}\n-        `);\n-        expect(source).not.toMatch(/ɵprov/);\n-      });\n-    });\n-\n-    it('compiles a basic Injectable definition', () => {\n-      const source = compileService(`\n-        import {Injectable} from '@angular/core';\n-        import {Module} from './module';\n-\n-        @Injectable({\n-          providedIn: Module,\n-        })\n-        export class Service {}\n-      `);\n-      expect(source).toMatch(/ɵprov = .+\\.ɵɵdefineInjectable\\(/);\n-      expect(source).toMatch(/ɵprov.*token: Service/);\n-      expect(source).toMatch(/ɵprov.*providedIn: .+\\.Module/);\n-    });\n-\n-    it('ɵprov in es5 mode is annotated @nocollapse when closure options are enabled', () => {\n-      writeConfig(`{\n-        \"extends\": \"./tsconfig-base.json\",\n-        \"angularCompilerOptions\": {\n-          \"annotateForClosureCompiler\": true\n-        },\n-        \"files\": [\"service.ts\"]\n-      }`);\n-      const input = `\n-        import {Injectable} from '@angular/core';\n-        import {Module} from './module';\n-\n-        @Injectable({\n-          providedIn: Module,\n-        })\n-        export class Service {}\n-      `;\n-\n-      const source = compileService(input, /* withTsickle */ true);\n-      expect(source).toMatch(/\\/\\*\\* @nocollapse \\*\\/ Service\\.ɵprov =/);\n-    });\n-\n-    it('compiles a useValue Injectable definition', () => {\n-      const source = compileService(`\n-        import {Injectable} from '@angular/core';\n-        import {Module} from './module';\n-\n-        export const CONST_SERVICE: Service = null;\n-\n-        @Injectable({\n-          providedIn: Module,\n-          useValue: CONST_SERVICE\n-        })\n-        export class Service {}\n-      `);\n-      expect(source).toMatch(/ɵprov.*return CONST_SERVICE/);\n-    });\n-\n-    it('compiles a useExisting Injectable definition', () => {\n-      const source = compileService(`\n-        import {Injectable} from '@angular/core';\n-        import {Module} from './module';\n-\n-        @Injectable()\n-        export class Existing {}\n-\n-        @Injectable({\n-          providedIn: Module,\n-          useExisting: Existing,\n-        })\n-        export class Service {}\n-      `);\n-      expect(source).toMatch(/ɵprov.*return ..\\.ɵɵinject\\(Existing\\)/);\n-    });\n-\n-    it('compiles a useFactory Injectable definition with optional dep', () => {\n-      const source = compileService(`\n-        import {Injectable, Optional} from '@angular/core';\n-        import {Module} from './module';\n-\n-        @Injectable()\n-        export class Existing {}\n-\n-        @Injectable({\n-          providedIn: Module,\n-          useFactory: (existing: Existing|null) => new Service(existing),\n-          deps: [[new Optional(), Existing]],\n-        })\n-        export class Service {\n-          constructor(e: Existing|null) {}\n-        }\n-      `);\n-      expect(source).toMatch(/ɵprov.*return ..\\(..\\.ɵɵinject\\(Existing, 8\\)/);\n-    });\n-\n-    it('compiles a useFactory Injectable definition with skip-self dep', () => {\n-      const source = compileService(`\n-        import {Injectable, SkipSelf} from '@angular/core';\n-        import {Module} from './module';\n-\n-        @Injectable()\n-        export class Existing {}\n-\n-        @Injectable({\n-          providedIn: Module,\n-          useFactory: (existing: Existing) => new Service(existing),\n-          deps: [[new SkipSelf(), Existing]],\n-        })\n-        export class Service {\n-          constructor(e: Existing) {}\n-        }\n-      `);\n-      expect(source).toMatch(/ɵprov.*return ..\\(..\\.ɵɵinject\\(Existing, 4\\)/);\n-    });\n-\n-    it('compiles a service that depends on a token', () => {\n-      const source = compileService(`\n-        import {Inject, Injectable, InjectionToken} from '@angular/core';\n-        import {Module} from './module';\n-\n-        export const TOKEN = new InjectionToken('desc', {providedIn: Module, factory: () => true});\n-\n-        @Injectable({\n-          providedIn: Module,\n-        })\n-        export class Service {\n-          constructor(@Inject(TOKEN) value: boolean) {}\n-        }\n-      `);\n-      expect(source).toMatch(/ɵprov = .+\\.ɵɵdefineInjectable\\(/);\n-      expect(source).toMatch(/ɵprov.*token: Service/);\n-      expect(source).toMatch(/ɵprov.*providedIn: .+\\.Module/);\n-    });\n-\n-    it('generates exports.* references when outputting commonjs', () => {\n-      writeConfig(`{\n-        \"extends\": \"./tsconfig-base.json\",\n-        \"compilerOptions\": {\n-          \"module\": \"commonjs\"\n-        },\n-        \"files\": [\"service.ts\"]\n-      }`);\n-      const source = compileService(`\n-        import {Inject, Injectable, InjectionToken} from '@angular/core';\n-        import {Module} from './module';\n-\n-        export const TOKEN = new InjectionToken<string>('test token', {\n-          providedIn: 'root',\n-          factory: () => 'this is a test',\n-        });\n-\n-        @Injectable({providedIn: 'root'})\n-        export class Service {\n-          constructor(@Inject(TOKEN) token: any) {}\n-        }\n-      `);\n-      expect(source).toMatch(/new Service\\(i0\\.ɵɵinject\\(exports\\.TOKEN\\)\\);/);\n-    });\n-\n-    it('compiles an injectable using `forwardRef` inside `providedIn`', () => {\n-      const source = compileService(`\n-        import {Injectable, forwardRef} from '@angular/core';\n-        import {Module} from './module';\n-\n-        @Injectable({\n-          providedIn: forwardRef(() => Module),\n-        })\n-        export class Service {}\n-      `);\n-\n-      expect(source).toMatch(/ɵprov = .+\\.ɵɵdefineInjectable\\(/);\n-      expect(source).toMatch(/ɵprov.*token: Service/);\n-      expect(source).toMatch(/ɵprov.*providedIn: .+\\.Module/);\n-    });\n-  });\n-\n-  it('libraries should not break strictMetadataEmit', () => {\n-    // first only generate .d.ts / .js / .metadata.json files\n-    writeConfig(`{\n-        \"extends\": \"./tsconfig-base.json\",\n-        \"angularCompilerOptions\": {\n-          \"skipTemplateCodegen\": true,\n-          \"strictMetadataEmit\": true,\n-          \"fullTemplateTypeCheck\": true\n-        },\n-        \"compilerOptions\": {\n-          \"outDir\": \"lib\"\n-        },\n-        \"files\": [\"main.ts\", \"test.d.ts\"]\n-      }`);\n-    write('main.ts', `\n-        import {Test} from './test';\n-        export const bar = Test.bar;\n-    `);\n-    write('test.d.ts', `\n-        declare export class Test {\n-          static bar: string;\n-        }\n-    `);\n-    let exitCode = main(['-p', path.join(basePath, 'tsconfig.json')], errorSpy);\n-    expect(exitCode).toEqual(0);\n-  });\n-\n-  describe('base directives', () => {\n-    it('should allow directives with no selector that are not in NgModules', () => {\n-      // first only generate .d.ts / .js / .metadata.json files\n-      writeConfig(`{\n-          \"extends\": \"./tsconfig-base.json\",\n-          \"files\": [\"main.ts\"]\n-        }`);\n-      write('main.ts', `\n-          import {Directive} from '@angular/core';\n-\n-          @Directive({})\n-          export class BaseDir {}\n-\n-          @Directive({})\n-          export abstract class AbstractBaseDir {}\n-\n-          @Directive()\n-          export abstract class EmptyDir {}\n-      `);\n-      let exitCode = main(['-p', path.join(basePath, 'tsconfig.json')], errorSpy);\n-      expect(exitCode).toEqual(0);\n-    });\n-\n-    it('should be able to use abstract directive in other compilation units', () => {\n-      writeConfig();\n-      write('lib1/tsconfig.json', JSON.stringify({\n-        extends: '../tsconfig-base.json',\n-        compilerOptions: {rootDir: '.', outDir: '../node_modules/lib1_built'},\n-      }));\n-      write('lib1/index.ts', `\n-        import {Directive} from '@angular/core';\n-\n-        @Directive()\n-        export class BaseClass {}\n-      `);\n-      write('index.ts', `\n-        import {NgModule, Directive} from '@angular/core';\n-        import {BaseClass} from 'lib1_built';\n-\n-        @Directive({selector: 'my-dir'})\n-        export class MyDirective extends BaseClass {}\n-\n-        @NgModule({declarations: [MyDirective]})\n-        export class AppModule {}\n-      `);\n-\n-      expect(main(['-p', path.join(basePath, 'lib1/tsconfig.json')], errorSpy)).toBe(0);\n-      expect(main(['-p', path.join(basePath, 'tsconfig.json')], errorSpy)).toBe(0);\n-    });\n-  });\n-});"
        },
        {
            "sha": "65fc6b1636496fd7b661df9bd0adef8731b4f293",
            "filename": "packages/compiler-cli/test/ngtsc/scope_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fscope_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fscope_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fscope_spec.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -6,7 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {Diagnostic} from '@angular/compiler-cli';\n import ts from 'typescript';\n \n import {ErrorCode, ngErrorCode} from '../../src/ngtsc/diagnostics';\n@@ -388,7 +387,7 @@ runInEachFileSystem(() => {\n   });\n \n   function diagnosticToNode<T extends ts.Node>(\n-      diagnostic: ts.Diagnostic|Diagnostic|ts.DiagnosticRelatedInformation,\n+      diagnostic: ts.Diagnostic|ts.DiagnosticRelatedInformation,\n       guard: (node: ts.Node) => node is T): T {\n     const diag = diagnostic as ts.Diagnostic | ts.DiagnosticRelatedInformation;\n     if (diag.file === undefined) {"
        },
        {
            "sha": "62270e5676b5a0c1f2bff993e05ab035e04fc704",
            "filename": "packages/compiler-cli/test/perform_watch_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Ftest%2Fperform_watch_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Ftest%2Fperform_watch_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fperform_watch_spec.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -234,11 +234,11 @@ class MockWatchHost {\n   nextTimeoutListenerId = 1;\n   timeoutListeners: {[id: string]: (() => void)} = {};\n   fileChangeListeners: Array<((event: FileChangeEvent, fileName: string) => void)|null> = [];\n-  diagnostics: ng.Diagnostic[] = [];\n+  diagnostics: ts.Diagnostic[] = [];\n   constructor(public config: ng.ParsedConfiguration) {}\n \n-  reportDiagnostics(diags: ng.Diagnostics) {\n-    this.diagnostics.push(...(diags as ng.Diagnostic[]));\n+  reportDiagnostics(diags: readonly ts.Diagnostic[]) {\n+    this.diagnostics.push(...diags);\n   }\n   readConfiguration() {\n     return this.config;"
        },
        {
            "sha": "e0dff2785bfa62642f48cf3bc7abff3ebca193b9",
            "filename": "packages/compiler-cli/test/test_support.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Ftest%2Ftest_support.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler-cli%2Ftest%2Ftest_support.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Ftest_support.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -156,7 +156,7 @@ export function setup(): TestSupport {\n   return createTestSupportFor(tmpDirPath);\n }\n \n-export function expectNoDiagnostics(options: ng.CompilerOptions, diags: ng.Diagnostics) {\n+export function expectNoDiagnostics(options: ng.CompilerOptions, diags: readonly ts.Diagnostic[]) {\n   const errorDiags = diags.filter(d => d.category !== ts.DiagnosticCategory.Message);\n   if (errorDiags.length) {\n     throw new Error(`Expected no diagnostics: ${ng.formatDiagnostics(errorDiags)}`);"
        },
        {
            "sha": "204bc0786521e3a55ae36ebc9ed17cdae3ec7f8f",
            "filename": "packages/compiler/src/aot/compiler.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 880,
            "changes": 880,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Faot%2Fcompiler.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,880 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompileDirectiveMetadata, CompileInjectableMetadata, CompileNgModuleMetadata, CompilePipeMetadata, CompilePipeSummary, CompileProviderMetadata, CompileShallowModuleMetadata, CompileStylesheetMetadata, CompileTypeMetadata, CompileTypeSummary, componentFactoryName, flatten, templateSourceUrl} from '../compile_metadata';\n-import {CompilerConfig} from '../config';\n-import {ConstantPool, OutputContext} from '../constant_pool';\n-import {ViewEncapsulation} from '../core';\n-import {MessageBundle} from '../i18n/message_bundle';\n-import {createTokenForExternalReference, Identifiers} from '../identifiers';\n-import {InjectableCompiler} from '../injectable_compiler';\n-import {CompileMetadataResolver} from '../metadata_resolver';\n-import {HtmlParser} from '../ml_parser/html_parser';\n-import {InterpolationConfig} from '../ml_parser/interpolation_config';\n-import {NgModuleCompiler} from '../ng_module_compiler';\n-import {OutputEmitter} from '../output/abstract_emitter';\n-import * as o from '../output/output_ast';\n-import {CompileIdentifierMetadata, identifierName, ParseError, syntaxError} from '../parse_util';\n-import {CompiledStylesheet, StyleCompiler} from '../style_compiler';\n-import {SummaryResolver} from '../summary_resolver';\n-import {TemplateAst} from '../template_parser/template_ast';\n-import {TemplateParser} from '../template_parser/template_parser';\n-import {newArray, ValueVisitor, visitValue} from '../util';\n-import {TypeCheckCompiler} from '../view_compiler/type_check_compiler';\n-import {ViewCompiler, ViewCompileResult} from '../view_compiler/view_compiler';\n-\n-import {AotCompilerHost} from './compiler_host';\n-import {AotCompilerOptions} from './compiler_options';\n-import {GeneratedFile} from './generated_file';\n-import {PartialModule} from './partial_module';\n-import {StaticReflector} from './static_reflector';\n-import {StaticSymbol} from './static_symbol';\n-import {StaticSymbolResolver} from './static_symbol_resolver';\n-import {createForJitStub, serializeSummaries} from './summary_serializer';\n-import {ngfactoryFilePath, normalizeGenFileSuffix, splitTypescriptSuffix, summaryFileName, summaryForJitFileName} from './util';\n-\n-const enum StubEmitFlags {\n-  Basic = 1 << 0,\n-  TypeCheck = 1 << 1,\n-  All = TypeCheck | Basic\n-}\n-\n-export class AotCompiler {\n-  private _templateAstCache =\n-      new Map<StaticSymbol, {template: TemplateAst[], pipes: CompilePipeSummary[]}>();\n-  private _analyzedFiles = new Map<string, NgAnalyzedFile>();\n-  private _analyzedFilesForInjectables = new Map<string, NgAnalyzedFileWithInjectables>();\n-\n-  constructor(\n-      private _config: CompilerConfig, private _options: AotCompilerOptions,\n-      private _host: AotCompilerHost, readonly reflector: StaticReflector,\n-      private _metadataResolver: CompileMetadataResolver, private _templateParser: TemplateParser,\n-      private _styleCompiler: StyleCompiler, private _viewCompiler: ViewCompiler,\n-      private _typeCheckCompiler: TypeCheckCompiler, private _ngModuleCompiler: NgModuleCompiler,\n-      private _injectableCompiler: InjectableCompiler, private _outputEmitter: OutputEmitter,\n-      private _summaryResolver: SummaryResolver<StaticSymbol>,\n-      private _symbolResolver: StaticSymbolResolver) {}\n-\n-  clearCache() {\n-    this._metadataResolver.clearCache();\n-  }\n-\n-  analyzeModulesSync(rootFiles: string[]): NgAnalyzedModules {\n-    const analyzeResult = analyzeAndValidateNgModules(\n-        rootFiles, this._host, this._symbolResolver, this._metadataResolver);\n-    analyzeResult.ngModules.forEach(\n-        ngModule => this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(\n-            ngModule.type.reference, true));\n-    return analyzeResult;\n-  }\n-\n-  analyzeModulesAsync(rootFiles: string[]): Promise<NgAnalyzedModules> {\n-    const analyzeResult = analyzeAndValidateNgModules(\n-        rootFiles, this._host, this._symbolResolver, this._metadataResolver);\n-    return Promise\n-        .all(analyzeResult.ngModules.map(\n-            ngModule => this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(\n-                ngModule.type.reference, false)))\n-        .then(() => analyzeResult);\n-  }\n-\n-  private _analyzeFile(fileName: string): NgAnalyzedFile {\n-    let analyzedFile = this._analyzedFiles.get(fileName);\n-    if (!analyzedFile) {\n-      analyzedFile =\n-          analyzeFile(this._host, this._symbolResolver, this._metadataResolver, fileName);\n-      this._analyzedFiles.set(fileName, analyzedFile);\n-    }\n-    return analyzedFile;\n-  }\n-\n-  private _analyzeFileForInjectables(fileName: string): NgAnalyzedFileWithInjectables {\n-    let analyzedFile = this._analyzedFilesForInjectables.get(fileName);\n-    if (!analyzedFile) {\n-      analyzedFile = analyzeFileForInjectables(\n-          this._host, this._symbolResolver, this._metadataResolver, fileName);\n-      this._analyzedFilesForInjectables.set(fileName, analyzedFile);\n-    }\n-    return analyzedFile;\n-  }\n-\n-  findGeneratedFileNames(fileName: string): string[] {\n-    const genFileNames: string[] = [];\n-    const file = this._analyzeFile(fileName);\n-    // Make sure we create a .ngfactory if we have a injectable/directive/pipe/NgModule\n-    // or a reference to a non source file.\n-    // Note: This is overestimating the required .ngfactory files as the real calculation is harder.\n-    // Only do this for StubEmitFlags.Basic, as adding a type check block\n-    // does not change this file (as we generate type check blocks based on NgModules).\n-    if (this._options.allowEmptyCodegenFiles || file.directives.length || file.pipes.length ||\n-        file.injectables.length || file.ngModules.length || file.exportsNonSourceFiles) {\n-      genFileNames.push(ngfactoryFilePath(file.fileName, true));\n-      if (this._options.enableSummariesForJit) {\n-        genFileNames.push(summaryForJitFileName(file.fileName, true));\n-      }\n-    }\n-    const fileSuffix = normalizeGenFileSuffix(splitTypescriptSuffix(file.fileName, true)[1]);\n-    file.directives.forEach((dirSymbol) => {\n-      const compMeta =\n-          this._metadataResolver.getNonNormalizedDirectiveMetadata(dirSymbol)!.metadata;\n-      if (!compMeta.isComponent) {\n-        return;\n-      }\n-      // Note: compMeta is a component and therefore template is non null.\n-      compMeta.template !.styleUrls.forEach((styleUrl) => {\n-        const normalizedUrl = this._host.resourceNameToFileName(styleUrl, file.fileName);\n-        if (!normalizedUrl) {\n-          throw syntaxError(`Couldn't resolve resource ${styleUrl} relative to ${file.fileName}`);\n-        }\n-        const needsShim = (compMeta.template !.encapsulation ||\n-                           this._config.defaultEncapsulation) === ViewEncapsulation.Emulated;\n-        genFileNames.push(_stylesModuleUrl(normalizedUrl, needsShim, fileSuffix));\n-        if (this._options.allowEmptyCodegenFiles) {\n-          genFileNames.push(_stylesModuleUrl(normalizedUrl, !needsShim, fileSuffix));\n-        }\n-      });\n-    });\n-    return genFileNames;\n-  }\n-\n-  emitBasicStub(genFileName: string, originalFileName?: string): GeneratedFile {\n-    const outputCtx = this._createOutputContext(genFileName);\n-    if (genFileName.endsWith('.ngfactory.ts')) {\n-      if (!originalFileName) {\n-        throw new Error(\n-            `Assertion error: require the original file for .ngfactory.ts stubs. File: ${\n-                genFileName}`);\n-      }\n-      const originalFile = this._analyzeFile(originalFileName);\n-      this._createNgFactoryStub(outputCtx, originalFile, StubEmitFlags.Basic);\n-    } else if (genFileName.endsWith('.ngsummary.ts')) {\n-      if (this._options.enableSummariesForJit) {\n-        if (!originalFileName) {\n-          throw new Error(\n-              `Assertion error: require the original file for .ngsummary.ts stubs. File: ${\n-                  genFileName}`);\n-        }\n-        const originalFile = this._analyzeFile(originalFileName);\n-        _createEmptyStub(outputCtx);\n-        originalFile.ngModules.forEach(ngModule => {\n-          // create exports that user code can reference\n-          createForJitStub(outputCtx, ngModule.type.reference);\n-        });\n-      }\n-    } else if (genFileName.endsWith('.ngstyle.ts')) {\n-      _createEmptyStub(outputCtx);\n-    }\n-    // Note: for the stubs, we don't need a property srcFileUrl,\n-    // as later on in emitAllImpls we will create the proper GeneratedFiles with the\n-    // correct srcFileUrl.\n-    // This is good as e.g. for .ngstyle.ts files we can't derive\n-    // the url of components based on the genFileUrl.\n-    return this._codegenSourceModule('unknown', outputCtx);\n-  }\n-\n-  emitTypeCheckStub(genFileName: string, originalFileName: string): GeneratedFile|null {\n-    const originalFile = this._analyzeFile(originalFileName);\n-    const outputCtx = this._createOutputContext(genFileName);\n-    if (genFileName.endsWith('.ngfactory.ts')) {\n-      this._createNgFactoryStub(outputCtx, originalFile, StubEmitFlags.TypeCheck);\n-    }\n-    return outputCtx.statements.length > 0 ?\n-        this._codegenSourceModule(originalFile.fileName, outputCtx) :\n-        null;\n-  }\n-\n-  loadFilesAsync(fileNames: string[], tsFiles: string[]): Promise<\n-      {analyzedModules: NgAnalyzedModules, analyzedInjectables: NgAnalyzedFileWithInjectables[]}> {\n-    const files = fileNames.map(fileName => this._analyzeFile(fileName));\n-    const loadingPromises: Promise<NgAnalyzedModules>[] = [];\n-    files.forEach(\n-        file => file.ngModules.forEach(\n-            ngModule =>\n-                loadingPromises.push(this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(\n-                    ngModule.type.reference, false))));\n-    const analyzedInjectables = tsFiles.map(tsFile => this._analyzeFileForInjectables(tsFile));\n-    return Promise.all(loadingPromises).then(_ => ({\n-                                               analyzedModules: mergeAndValidateNgFiles(files),\n-                                               analyzedInjectables: analyzedInjectables,\n-                                             }));\n-  }\n-\n-  loadFilesSync(fileNames: string[], tsFiles: string[]):\n-      {analyzedModules: NgAnalyzedModules, analyzedInjectables: NgAnalyzedFileWithInjectables[]} {\n-    const files = fileNames.map(fileName => this._analyzeFile(fileName));\n-    files.forEach(\n-        file => file.ngModules.forEach(\n-            ngModule => this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(\n-                ngModule.type.reference, true)));\n-    const analyzedInjectables = tsFiles.map(tsFile => this._analyzeFileForInjectables(tsFile));\n-    return {\n-      analyzedModules: mergeAndValidateNgFiles(files),\n-      analyzedInjectables: analyzedInjectables,\n-    };\n-  }\n-\n-  private _createNgFactoryStub(\n-      outputCtx: OutputContext, file: NgAnalyzedFile, emitFlags: StubEmitFlags) {\n-    let componentId = 0;\n-    file.ngModules.forEach((ngModuleMeta, ngModuleIndex) => {\n-      // Note: the code below needs to executed for StubEmitFlags.Basic and StubEmitFlags.TypeCheck,\n-      // so we don't change the .ngfactory file too much when adding the type-check block.\n-\n-      // create exports that user code can reference\n-      this._ngModuleCompiler.createStub(outputCtx, ngModuleMeta.type.reference);\n-\n-      // add references to the symbols from the metadata.\n-      // These can be used by the type check block for components,\n-      // and they also cause TypeScript to include these files into the program too,\n-      // which will make them part of the analyzedFiles.\n-      const externalReferences: StaticSymbol[] = [\n-        // Add references that are available from all the modules and imports.\n-        ...ngModuleMeta.transitiveModule.directives.map(d => d.reference),\n-        ...ngModuleMeta.transitiveModule.pipes.map(d => d.reference),\n-        ...ngModuleMeta.importedModules.map(m => m.type.reference),\n-        ...ngModuleMeta.exportedModules.map(m => m.type.reference),\n-\n-        // Add references that might be inserted by the template compiler.\n-        ...this._externalIdentifierReferences([Identifiers.TemplateRef, Identifiers.ElementRef]),\n-      ];\n-\n-      const externalReferenceVars = new Map<any, string>();\n-      externalReferences.forEach((ref, typeIndex) => {\n-        externalReferenceVars.set(ref, `_decl${ngModuleIndex}_${typeIndex}`);\n-      });\n-      externalReferenceVars.forEach((varName, reference) => {\n-        outputCtx.statements.push(\n-            o.variable(varName)\n-                .set(o.NULL_EXPR.cast(o.DYNAMIC_TYPE))\n-                .toDeclStmt(o.expressionType(outputCtx.importExpr(\n-                    reference, /* typeParams */ null, /* useSummaries */ false))));\n-      });\n-\n-      if (emitFlags & StubEmitFlags.TypeCheck) {\n-        // add the type-check block for all components of the NgModule\n-        ngModuleMeta.declaredDirectives.forEach((dirId) => {\n-          const compMeta = this._metadataResolver.getDirectiveMetadata(dirId.reference);\n-          if (!compMeta.isComponent) {\n-            return;\n-          }\n-          componentId++;\n-          this._createTypeCheckBlock(\n-              outputCtx, `${compMeta.type.reference.name}_Host_${componentId}`, ngModuleMeta,\n-              this._metadataResolver.getHostComponentMetadata(compMeta), [compMeta.type],\n-              externalReferenceVars);\n-          this._createTypeCheckBlock(\n-              outputCtx, `${compMeta.type.reference.name}_${componentId}`, ngModuleMeta, compMeta,\n-              ngModuleMeta.transitiveModule.directives, externalReferenceVars);\n-        });\n-      }\n-    });\n-\n-    if (outputCtx.statements.length === 0) {\n-      _createEmptyStub(outputCtx);\n-    }\n-  }\n-\n-  private _externalIdentifierReferences(references: o.ExternalReference[]): StaticSymbol[] {\n-    const result: StaticSymbol[] = [];\n-    for (let reference of references) {\n-      const token = createTokenForExternalReference(this.reflector, reference);\n-      if (token.identifier) {\n-        result.push(token.identifier.reference);\n-      }\n-    }\n-    return result;\n-  }\n-\n-  private _createTypeCheckBlock(\n-      ctx: OutputContext, componentId: string, moduleMeta: CompileNgModuleMetadata,\n-      compMeta: CompileDirectiveMetadata, directives: CompileIdentifierMetadata[],\n-      externalReferenceVars: Map<any, string>) {\n-    const {template: parsedTemplate, pipes: usedPipes} =\n-        this._parseTemplate(compMeta, moduleMeta, directives);\n-    ctx.statements.push(...this._typeCheckCompiler.compileComponent(\n-        componentId, compMeta, parsedTemplate, usedPipes, externalReferenceVars, ctx));\n-  }\n-\n-  emitMessageBundle(analyzeResult: NgAnalyzedModules, locale: string|null): MessageBundle {\n-    const errors: ParseError[] = [];\n-    const htmlParser = new HtmlParser();\n-\n-    // TODO(vicb): implicit tags & attributes\n-    const messageBundle = new MessageBundle(htmlParser, [], {}, locale);\n-\n-    analyzeResult.files.forEach(file => {\n-      const compMetas: CompileDirectiveMetadata[] = [];\n-      file.directives.forEach(directiveType => {\n-        const dirMeta = this._metadataResolver.getDirectiveMetadata(directiveType);\n-        if (dirMeta && dirMeta.isComponent) {\n-          compMetas.push(dirMeta);\n-        }\n-      });\n-      compMetas.forEach(compMeta => {\n-        const html = compMeta.template !.template !;\n-        // Template URL points to either an HTML or TS file depending on whether\n-        // the file is used with `templateUrl:` or `template:`, respectively.\n-        const templateUrl = compMeta.template !.templateUrl!;\n-        const interpolationConfig =\n-            InterpolationConfig.fromArray(compMeta.template !.interpolation);\n-        errors.push(...messageBundle.updateFromTemplate(html, templateUrl, interpolationConfig)!);\n-      });\n-    });\n-\n-    if (errors.length) {\n-      throw new Error(errors.map(e => e.toString()).join('\\n'));\n-    }\n-\n-    return messageBundle;\n-  }\n-\n-  emitAllPartialModules2(files: NgAnalyzedFileWithInjectables[]): PartialModule[] {\n-    // Using reduce like this is a select many pattern (where map is a select pattern)\n-    return files.reduce<PartialModule[]>((r, file) => {\n-      r.push(...this._emitPartialModule2(file.fileName, file.injectables));\n-      return r;\n-    }, []);\n-  }\n-\n-  private _emitPartialModule2(fileName: string, injectables: CompileInjectableMetadata[]):\n-      PartialModule[] {\n-    const context = this._createOutputContext(fileName);\n-\n-    injectables.forEach(injectable => this._injectableCompiler.compile(injectable, context));\n-\n-    if (context.statements && context.statements.length > 0) {\n-      return [{fileName, statements: [...context.constantPool.statements, ...context.statements]}];\n-    }\n-    return [];\n-  }\n-\n-  emitAllImpls(analyzeResult: NgAnalyzedModules): GeneratedFile[] {\n-    const {ngModuleByPipeOrDirective, files} = analyzeResult;\n-    const sourceModules = files.map(\n-        file => this._compileImplFile(\n-            file.fileName, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules,\n-            file.injectables));\n-    return flatten(sourceModules);\n-  }\n-\n-  private _compileImplFile(\n-      srcFileUrl: string, ngModuleByPipeOrDirective: Map<StaticSymbol, CompileNgModuleMetadata>,\n-      directives: StaticSymbol[], pipes: StaticSymbol[], ngModules: CompileNgModuleMetadata[],\n-      injectables: CompileInjectableMetadata[]): GeneratedFile[] {\n-    const fileSuffix = normalizeGenFileSuffix(splitTypescriptSuffix(srcFileUrl, true)[1]);\n-    const generatedFiles: GeneratedFile[] = [];\n-\n-    const outputCtx = this._createOutputContext(ngfactoryFilePath(srcFileUrl, true));\n-\n-    generatedFiles.push(\n-        ...this._createSummary(srcFileUrl, directives, pipes, ngModules, injectables, outputCtx));\n-\n-    // compile all ng modules\n-    ngModules.forEach((ngModuleMeta) => this._compileModule(outputCtx, ngModuleMeta));\n-\n-    // compile components\n-    directives.forEach((dirType) => {\n-      const compMeta = this._metadataResolver.getDirectiveMetadata(<any>dirType);\n-      if (!compMeta.isComponent) {\n-        return;\n-      }\n-      const ngModule = ngModuleByPipeOrDirective.get(dirType);\n-      if (!ngModule) {\n-        throw new Error(`Internal Error: cannot determine the module for component ${\n-            identifierName(compMeta.type)}!`);\n-      }\n-\n-      // compile styles\n-      const componentStylesheet = this._styleCompiler.compileComponent(outputCtx, compMeta);\n-      // Note: compMeta is a component and therefore template is non null.\n-      compMeta.template !.externalStylesheets.forEach((stylesheetMeta) => {\n-        // Note: fill non shim and shim style files as they might\n-        // be shared by component with and without ViewEncapsulation.\n-        const shim = this._styleCompiler.needsStyleShim(compMeta);\n-        generatedFiles.push(\n-            this._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, shim, fileSuffix));\n-        if (this._options.allowEmptyCodegenFiles) {\n-          generatedFiles.push(\n-              this._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, !shim, fileSuffix));\n-        }\n-      });\n-\n-      // compile components\n-      const compViewVars = this._compileComponent(\n-          outputCtx, compMeta, ngModule, ngModule.transitiveModule.directives, componentStylesheet,\n-          fileSuffix);\n-      this._compileComponentFactory(outputCtx, compMeta, ngModule, fileSuffix);\n-    });\n-    if (outputCtx.statements.length > 0 || this._options.allowEmptyCodegenFiles) {\n-      const srcModule = this._codegenSourceModule(srcFileUrl, outputCtx);\n-      generatedFiles.unshift(srcModule);\n-    }\n-    return generatedFiles;\n-  }\n-\n-  private _createSummary(\n-      srcFileName: string, directives: StaticSymbol[], pipes: StaticSymbol[],\n-      ngModules: CompileNgModuleMetadata[], injectables: CompileInjectableMetadata[],\n-      ngFactoryCtx: OutputContext): GeneratedFile[] {\n-    const symbolSummaries = this._symbolResolver.getSymbolsOf(srcFileName)\n-                                .map(symbol => this._symbolResolver.resolveSymbol(symbol));\n-    const typeData: {\n-      summary: CompileTypeSummary,\n-      metadata: CompileNgModuleMetadata|CompileDirectiveMetadata|CompilePipeMetadata|\n-      CompileTypeMetadata\n-    }[] =\n-        [\n-          ...ngModules.map(\n-              meta => ({\n-                summary: this._metadataResolver.getNgModuleSummary(meta.type.reference)!,\n-                metadata: this._metadataResolver.getNgModuleMetadata(meta.type.reference)!\n-              })),\n-          ...directives.map(ref => ({\n-                              summary: this._metadataResolver.getDirectiveSummary(ref)!,\n-                              metadata: this._metadataResolver.getDirectiveMetadata(ref)!\n-                            })),\n-          ...pipes.map(ref => ({\n-                         summary: this._metadataResolver.getPipeSummary(ref)!,\n-                         metadata: this._metadataResolver.getPipeMetadata(ref)!\n-                       })),\n-          ...injectables.map(\n-              ref => ({\n-                summary: this._metadataResolver.getInjectableSummary(ref.symbol)!,\n-                metadata: this._metadataResolver.getInjectableSummary(ref.symbol)!.type\n-              }))\n-        ];\n-    const forJitOutputCtx = this._options.enableSummariesForJit ?\n-        this._createOutputContext(summaryForJitFileName(srcFileName, true)) :\n-        null;\n-    const {json, exportAs} = serializeSummaries(\n-        srcFileName, forJitOutputCtx, this._summaryResolver, this._symbolResolver, symbolSummaries,\n-        typeData, this._options.createExternalSymbolFactoryReexports);\n-    exportAs.forEach((entry) => {\n-      ngFactoryCtx.statements.push(\n-          o.variable(entry.exportAs).set(ngFactoryCtx.importExpr(entry.symbol)).toDeclStmt(null, [\n-            o.StmtModifier.Exported\n-          ]));\n-    });\n-    const summaryJson = new GeneratedFile(srcFileName, summaryFileName(srcFileName), json);\n-    const result = [summaryJson];\n-    if (forJitOutputCtx) {\n-      result.push(this._codegenSourceModule(srcFileName, forJitOutputCtx));\n-    }\n-    return result;\n-  }\n-\n-  private _compileModule(outputCtx: OutputContext, ngModule: CompileNgModuleMetadata): void {\n-    const providers: CompileProviderMetadata[] = [];\n-\n-    if (this._options.locale) {\n-      const normalizedLocale = this._options.locale.replace(/_/g, '-');\n-      providers.push({\n-        token: createTokenForExternalReference(this.reflector, Identifiers.LOCALE_ID),\n-        useValue: normalizedLocale,\n-      });\n-    }\n-\n-    if (this._options.i18nFormat) {\n-      providers.push({\n-        token: createTokenForExternalReference(this.reflector, Identifiers.TRANSLATIONS_FORMAT),\n-        useValue: this._options.i18nFormat\n-      });\n-    }\n-\n-    this._ngModuleCompiler.compile(outputCtx, ngModule, providers);\n-  }\n-\n-  private _compileComponentFactory(\n-      outputCtx: OutputContext, compMeta: CompileDirectiveMetadata,\n-      ngModule: CompileNgModuleMetadata, fileSuffix: string): void {\n-    const hostMeta = this._metadataResolver.getHostComponentMetadata(compMeta);\n-    const hostViewFactoryVar =\n-        this._compileComponent(outputCtx, hostMeta, ngModule, [compMeta.type], null, fileSuffix)\n-            .viewClassVar;\n-    const compFactoryVar = componentFactoryName(compMeta.type.reference);\n-    const inputsExprs: o.LiteralMapEntry[] = [];\n-    for (let propName in compMeta.inputs) {\n-      const templateName = compMeta.inputs[propName];\n-      // Don't quote so that the key gets minified...\n-      inputsExprs.push(new o.LiteralMapEntry(propName, o.literal(templateName), false));\n-    }\n-    const outputsExprs: o.LiteralMapEntry[] = [];\n-    for (let propName in compMeta.outputs) {\n-      const templateName = compMeta.outputs[propName];\n-      // Don't quote so that the key gets minified...\n-      outputsExprs.push(new o.LiteralMapEntry(propName, o.literal(templateName), false));\n-    }\n-\n-    outputCtx.statements.push(\n-        o.variable(compFactoryVar)\n-            .set(o.importExpr(Identifiers.createComponentFactory).callFn([\n-              o.literal(compMeta.selector), outputCtx.importExpr(compMeta.type.reference),\n-              o.variable(hostViewFactoryVar), new o.LiteralMapExpr(inputsExprs),\n-              new o.LiteralMapExpr(outputsExprs),\n-              o.literalArr(\n-                  compMeta.template !.ngContentSelectors.map(selector => o.literal(selector)))\n-            ]))\n-            .toDeclStmt(\n-                o.importType(\n-                    Identifiers.ComponentFactory,\n-                    [o.expressionType(outputCtx.importExpr(compMeta.type.reference))!],\n-                    [o.TypeModifier.Const]),\n-                [o.StmtModifier.Final, o.StmtModifier.Exported]));\n-  }\n-\n-  private _compileComponent(\n-      outputCtx: OutputContext, compMeta: CompileDirectiveMetadata,\n-      ngModule: CompileNgModuleMetadata, directiveIdentifiers: CompileIdentifierMetadata[],\n-      componentStyles: CompiledStylesheet|null, fileSuffix: string): ViewCompileResult {\n-    const {template: parsedTemplate, pipes: usedPipes} =\n-        this._parseTemplate(compMeta, ngModule, directiveIdentifiers);\n-    const stylesExpr = componentStyles ? o.variable(componentStyles.stylesVar) : o.literalArr([]);\n-    const viewResult = this._viewCompiler.compileComponent(\n-        outputCtx, compMeta, parsedTemplate, stylesExpr, usedPipes);\n-    if (componentStyles) {\n-      _resolveStyleStatements(\n-          this._symbolResolver, componentStyles, this._styleCompiler.needsStyleShim(compMeta),\n-          fileSuffix);\n-    }\n-    return viewResult;\n-  }\n-\n-  private _parseTemplate(\n-      compMeta: CompileDirectiveMetadata, ngModule: CompileNgModuleMetadata,\n-      directiveIdentifiers: CompileIdentifierMetadata[]):\n-      {template: TemplateAst[], pipes: CompilePipeSummary[]} {\n-    if (this._templateAstCache.has(compMeta.type.reference)) {\n-      return this._templateAstCache.get(compMeta.type.reference)!;\n-    }\n-    const preserveWhitespaces = compMeta!.template !.preserveWhitespaces;\n-    const directives =\n-        directiveIdentifiers.map(dir => this._metadataResolver.getDirectiveSummary(dir.reference));\n-    const pipes = ngModule.transitiveModule.pipes.map(\n-        pipe => this._metadataResolver.getPipeSummary(pipe.reference));\n-    const result = this._templateParser.parse(\n-        compMeta, compMeta.template !.htmlAst!, directives, pipes, ngModule.schemas,\n-        templateSourceUrl(ngModule.type, compMeta, compMeta.template !), preserveWhitespaces);\n-    this._templateAstCache.set(compMeta.type.reference, result);\n-    return result;\n-  }\n-\n-  private _createOutputContext(genFilePath: string): OutputContext {\n-    const importExpr =\n-        (symbol: StaticSymbol, typeParams: o.Type[]|null = null, useSummaries: boolean = true) => {\n-          if (!(symbol instanceof StaticSymbol)) {\n-            throw new Error(`Internal error: unknown identifier ${JSON.stringify(symbol)}`);\n-          }\n-          const arity = this._symbolResolver.getTypeArity(symbol) || 0;\n-          const {filePath, name, members} =\n-              this._symbolResolver.getImportAs(symbol, useSummaries) || symbol;\n-          const importModule = this._fileNameToModuleName(filePath, genFilePath);\n-\n-          // It should be good enough to compare filePath to genFilePath and if they are equal\n-          // there is a self reference. However, ngfactory files generate to .ts but their\n-          // symbols have .d.ts so a simple compare is insufficient. They should be canonical\n-          // and is tracked by #17705.\n-          const selfReference = this._fileNameToModuleName(genFilePath, genFilePath);\n-          const moduleName = importModule === selfReference ? null : importModule;\n-\n-          // If we are in a type expression that refers to a generic type then supply\n-          // the required type parameters. If there were not enough type parameters\n-          // supplied, supply any as the type. Outside a type expression the reference\n-          // should not supply type parameters and be treated as a simple value reference\n-          // to the constructor function itself.\n-          const suppliedTypeParams = typeParams || [];\n-          const missingTypeParamsCount = arity - suppliedTypeParams.length;\n-          const allTypeParams =\n-              suppliedTypeParams.concat(newArray(missingTypeParamsCount, o.DYNAMIC_TYPE));\n-          return members.reduce(\n-              (expr, memberName) => expr.prop(memberName),\n-              <o.Expression>o.importExpr(\n-                  new o.ExternalReference(moduleName, name, null), allTypeParams));\n-        };\n-\n-    return {statements: [], genFilePath, importExpr, constantPool: new ConstantPool()};\n-  }\n-\n-  private _fileNameToModuleName(importedFilePath: string, containingFilePath: string): string {\n-    return this._summaryResolver.getKnownModuleName(importedFilePath) ||\n-        this._symbolResolver.getKnownModuleName(importedFilePath) ||\n-        this._host.fileNameToModuleName(importedFilePath, containingFilePath);\n-  }\n-\n-  private _codegenStyles(\n-      srcFileUrl: string, compMeta: CompileDirectiveMetadata,\n-      stylesheetMetadata: CompileStylesheetMetadata, isShimmed: boolean,\n-      fileSuffix: string): GeneratedFile {\n-    const outputCtx = this._createOutputContext(\n-        _stylesModuleUrl(stylesheetMetadata.moduleUrl!, isShimmed, fileSuffix));\n-    const compiledStylesheet =\n-        this._styleCompiler.compileStyles(outputCtx, compMeta, stylesheetMetadata, isShimmed);\n-    _resolveStyleStatements(this._symbolResolver, compiledStylesheet, isShimmed, fileSuffix);\n-    return this._codegenSourceModule(srcFileUrl, outputCtx);\n-  }\n-\n-  private _codegenSourceModule(srcFileUrl: string, ctx: OutputContext): GeneratedFile {\n-    return new GeneratedFile(srcFileUrl, ctx.genFilePath, ctx.statements);\n-  }\n-}\n-\n-function _createEmptyStub(outputCtx: OutputContext) {\n-  // Note: We need to produce at least one import statement so that\n-  // TypeScript knows that the file is an es6 module. Otherwise our generated\n-  // exports / imports won't be emitted properly by TypeScript.\n-  outputCtx.statements.push(o.importExpr(Identifiers.ComponentFactory).toStmt());\n-}\n-\n-\n-function _resolveStyleStatements(\n-    symbolResolver: StaticSymbolResolver, compileResult: CompiledStylesheet, needsShim: boolean,\n-    fileSuffix: string): void {\n-  compileResult.dependencies.forEach((dep) => {\n-    dep.setValue(symbolResolver.getStaticSymbol(\n-        _stylesModuleUrl(dep.moduleUrl, needsShim, fileSuffix), dep.name));\n-  });\n-}\n-\n-function _stylesModuleUrl(stylesheetUrl: string, shim: boolean, suffix: string): string {\n-  return `${stylesheetUrl}${shim ? '.shim' : ''}.ngstyle${suffix}`;\n-}\n-\n-export interface NgAnalyzedModules {\n-  ngModules: CompileNgModuleMetadata[];\n-  ngModuleByPipeOrDirective: Map<StaticSymbol, CompileNgModuleMetadata>;\n-  files: NgAnalyzedFile[];\n-  symbolsMissingModule?: StaticSymbol[];\n-}\n-\n-export interface NgAnalyzedFileWithInjectables {\n-  fileName: string;\n-  injectables: CompileInjectableMetadata[];\n-  shallowModules: CompileShallowModuleMetadata[];\n-}\n-\n-export interface NgAnalyzedFile {\n-  fileName: string;\n-  directives: StaticSymbol[];\n-  abstractDirectives: StaticSymbol[];\n-  pipes: StaticSymbol[];\n-  ngModules: CompileNgModuleMetadata[];\n-  injectables: CompileInjectableMetadata[];\n-  exportsNonSourceFiles: boolean;\n-}\n-\n-export interface NgAnalyzeModulesHost {\n-  isSourceFile(filePath: string): boolean;\n-}\n-\n-export function analyzeNgModules(\n-    fileNames: string[], host: NgAnalyzeModulesHost, staticSymbolResolver: StaticSymbolResolver,\n-    metadataResolver: CompileMetadataResolver): NgAnalyzedModules {\n-  const files = _analyzeFilesIncludingNonProgramFiles(\n-      fileNames, host, staticSymbolResolver, metadataResolver);\n-  return mergeAnalyzedFiles(files);\n-}\n-\n-export function analyzeAndValidateNgModules(\n-    fileNames: string[], host: NgAnalyzeModulesHost, staticSymbolResolver: StaticSymbolResolver,\n-    metadataResolver: CompileMetadataResolver): NgAnalyzedModules {\n-  return validateAnalyzedModules(\n-      analyzeNgModules(fileNames, host, staticSymbolResolver, metadataResolver));\n-}\n-\n-function validateAnalyzedModules(analyzedModules: NgAnalyzedModules): NgAnalyzedModules {\n-  if (analyzedModules.symbolsMissingModule && analyzedModules.symbolsMissingModule.length) {\n-    const messages = analyzedModules.symbolsMissingModule.map(\n-        s => `Cannot determine the module for class ${s.name} in ${s.filePath}! Add ${\n-            s.name} to the NgModule to fix it.`);\n-    throw syntaxError(messages.join('\\n'));\n-  }\n-  return analyzedModules;\n-}\n-\n-// Analyzes all of the program files,\n-// including files that are not part of the program\n-// but are referenced by an NgModule.\n-function _analyzeFilesIncludingNonProgramFiles(\n-    fileNames: string[], host: NgAnalyzeModulesHost, staticSymbolResolver: StaticSymbolResolver,\n-    metadataResolver: CompileMetadataResolver): NgAnalyzedFile[] {\n-  const seenFiles = new Set<string>();\n-  const files: NgAnalyzedFile[] = [];\n-\n-  const visitFile = (fileName: string) => {\n-    if (seenFiles.has(fileName) || !host.isSourceFile(fileName)) {\n-      return false;\n-    }\n-    seenFiles.add(fileName);\n-    const analyzedFile = analyzeFile(host, staticSymbolResolver, metadataResolver, fileName);\n-    files.push(analyzedFile);\n-    analyzedFile.ngModules.forEach(ngModule => {\n-      ngModule.transitiveModule.modules.forEach(modMeta => visitFile(modMeta.reference.filePath));\n-    });\n-  };\n-  fileNames.forEach((fileName) => visitFile(fileName));\n-  return files;\n-}\n-\n-export function analyzeFile(\n-    host: NgAnalyzeModulesHost, staticSymbolResolver: StaticSymbolResolver,\n-    metadataResolver: CompileMetadataResolver, fileName: string): NgAnalyzedFile {\n-  const abstractDirectives: StaticSymbol[] = [];\n-  const directives: StaticSymbol[] = [];\n-  const pipes: StaticSymbol[] = [];\n-  const injectables: CompileInjectableMetadata[] = [];\n-  const ngModules: CompileNgModuleMetadata[] = [];\n-  const hasDecorators = staticSymbolResolver.hasDecorators(fileName);\n-  let exportsNonSourceFiles = false;\n-  const isDeclarationFile = fileName.endsWith('.d.ts');\n-  // Don't analyze .d.ts files that have no decorators as a shortcut\n-  // to speed up the analysis. This prevents us from\n-  // resolving the references in these files.\n-  // Note: exportsNonSourceFiles is only needed when compiling with summaries,\n-  // which is not the case when .d.ts files are treated as input files.\n-  if (!isDeclarationFile || hasDecorators) {\n-    staticSymbolResolver.getSymbolsOf(fileName).forEach((symbol) => {\n-      const resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\n-      const symbolMeta = resolvedSymbol.metadata;\n-      if (!symbolMeta || symbolMeta.__symbolic === 'error') {\n-        return;\n-      }\n-      let isNgSymbol = false;\n-      if (symbolMeta.__symbolic === 'class') {\n-        if (metadataResolver.isDirective(symbol)) {\n-          isNgSymbol = true;\n-          // This directive either has a selector or doesn't. Selector-less directives get tracked\n-          // in abstractDirectives, not directives. The compiler doesn't deal with selector-less\n-          // directives at all, really, other than to persist their metadata. This is done so that\n-          // apps will have an easier time migrating to Ivy, which requires the selector-less\n-          // annotations to be applied.\n-          if (!metadataResolver.isAbstractDirective(symbol)) {\n-            // The directive is an ordinary directive.\n-            directives.push(symbol);\n-          } else {\n-            // The directive has no selector and is an \"abstract\" directive, so track it\n-            // accordingly.\n-            abstractDirectives.push(symbol);\n-          }\n-        } else if (metadataResolver.isPipe(symbol)) {\n-          isNgSymbol = true;\n-          pipes.push(symbol);\n-        } else if (metadataResolver.isNgModule(symbol)) {\n-          const ngModule = metadataResolver.getNgModuleMetadata(symbol, false);\n-          if (ngModule) {\n-            isNgSymbol = true;\n-            ngModules.push(ngModule);\n-          }\n-        } else if (metadataResolver.isInjectable(symbol)) {\n-          isNgSymbol = true;\n-          const injectable = metadataResolver.getInjectableMetadata(symbol, null, false);\n-          if (injectable) {\n-            injectables.push(injectable);\n-          }\n-        }\n-      }\n-      if (!isNgSymbol) {\n-        exportsNonSourceFiles =\n-            exportsNonSourceFiles || isValueExportingNonSourceFile(host, symbolMeta);\n-      }\n-    });\n-  }\n-  return {\n-    fileName,\n-    directives,\n-    abstractDirectives,\n-    pipes,\n-    ngModules,\n-    injectables,\n-    exportsNonSourceFiles,\n-  };\n-}\n-\n-export function analyzeFileForInjectables(\n-    host: NgAnalyzeModulesHost, staticSymbolResolver: StaticSymbolResolver,\n-    metadataResolver: CompileMetadataResolver, fileName: string): NgAnalyzedFileWithInjectables {\n-  const injectables: CompileInjectableMetadata[] = [];\n-  const shallowModules: CompileShallowModuleMetadata[] = [];\n-  if (staticSymbolResolver.hasDecorators(fileName)) {\n-    staticSymbolResolver.getSymbolsOf(fileName).forEach((symbol) => {\n-      const resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\n-      const symbolMeta = resolvedSymbol.metadata;\n-      if (!symbolMeta || symbolMeta.__symbolic === 'error') {\n-        return;\n-      }\n-      if (symbolMeta.__symbolic === 'class') {\n-        if (metadataResolver.isInjectable(symbol)) {\n-          const injectable = metadataResolver.getInjectableMetadata(symbol, null, false);\n-          if (injectable) {\n-            injectables.push(injectable);\n-          }\n-        } else if (metadataResolver.isNgModule(symbol)) {\n-          const module = metadataResolver.getShallowModuleMetadata(symbol);\n-          if (module) {\n-            shallowModules.push(module);\n-          }\n-        }\n-      }\n-    });\n-  }\n-  return {fileName, injectables, shallowModules};\n-}\n-\n-function isValueExportingNonSourceFile(host: NgAnalyzeModulesHost, metadata: any): boolean {\n-  let exportsNonSourceFiles = false;\n-\n-  class Visitor implements ValueVisitor {\n-    visitArray(arr: any[], context: any): any {\n-      arr.forEach(v => visitValue(v, this, context));\n-    }\n-    visitStringMap(map: {[key: string]: any}, context: any): any {\n-      Object.keys(map).forEach((key) => visitValue(map[key], this, context));\n-    }\n-    visitPrimitive(value: any, context: any): any {}\n-    visitOther(value: any, context: any): any {\n-      if (value instanceof StaticSymbol && !host.isSourceFile(value.filePath)) {\n-        exportsNonSourceFiles = true;\n-      }\n-    }\n-  }\n-\n-  visitValue(metadata, new Visitor(), null);\n-  return exportsNonSourceFiles;\n-}\n-\n-export function mergeAnalyzedFiles(analyzedFiles: NgAnalyzedFile[]): NgAnalyzedModules {\n-  const allNgModules: CompileNgModuleMetadata[] = [];\n-  const ngModuleByPipeOrDirective = new Map<StaticSymbol, CompileNgModuleMetadata>();\n-  const allPipesAndDirectives = new Set<StaticSymbol>();\n-\n-  analyzedFiles.forEach(af => {\n-    af.ngModules.forEach(ngModule => {\n-      allNgModules.push(ngModule);\n-      ngModule.declaredDirectives.forEach(\n-          d => ngModuleByPipeOrDirective.set(d.reference, ngModule));\n-      ngModule.declaredPipes.forEach(p => ngModuleByPipeOrDirective.set(p.reference, ngModule));\n-    });\n-    af.directives.forEach(d => allPipesAndDirectives.add(d));\n-    af.pipes.forEach(p => allPipesAndDirectives.add(p));\n-  });\n-\n-  const symbolsMissingModule: StaticSymbol[] = [];\n-  allPipesAndDirectives.forEach(ref => {\n-    if (!ngModuleByPipeOrDirective.has(ref)) {\n-      symbolsMissingModule.push(ref);\n-    }\n-  });\n-  return {\n-    ngModules: allNgModules,\n-    ngModuleByPipeOrDirective,\n-    symbolsMissingModule,\n-    files: analyzedFiles\n-  };\n-}\n-\n-function mergeAndValidateNgFiles(files: NgAnalyzedFile[]): NgAnalyzedModules {\n-  return validateAnalyzedModules(mergeAnalyzedFiles(files));\n-}"
        },
        {
            "sha": "7743555b169fb84bbc708232214b1ee5367a027d",
            "filename": "packages/compiler/src/aot/compiler_factory.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 103,
            "changes": 103,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fcompiler_factory.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fcompiler_factory.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Faot%2Fcompiler_factory.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,103 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompilerConfig} from '../config';\n-import {ViewEncapsulation} from '../core';\n-import {DirectiveNormalizer} from '../directive_normalizer';\n-import {DirectiveResolver} from '../directive_resolver';\n-import {Lexer} from '../expression_parser/lexer';\n-import {Parser} from '../expression_parser/parser';\n-import {I18NHtmlParser} from '../i18n/i18n_html_parser';\n-import {InjectableCompiler} from '../injectable_compiler';\n-import {CompileMetadataResolver} from '../metadata_resolver';\n-import {HtmlParser} from '../ml_parser/html_parser';\n-import {NgModuleCompiler} from '../ng_module_compiler';\n-import {NgModuleResolver} from '../ng_module_resolver';\n-import {TypeScriptEmitter} from '../output/ts_emitter';\n-import {syntaxError} from '../parse_util';\n-import {PipeResolver} from '../pipe_resolver';\n-import {DomElementSchemaRegistry} from '../schema/dom_element_schema_registry';\n-import {StyleCompiler} from '../style_compiler';\n-import {TemplateParser} from '../template_parser/template_parser';\n-import {UrlResolver} from '../url_resolver';\n-import {TypeCheckCompiler} from '../view_compiler/type_check_compiler';\n-import {ViewCompiler} from '../view_compiler/view_compiler';\n-\n-import {AotCompiler} from './compiler';\n-import {AotCompilerHost} from './compiler_host';\n-import {AotCompilerOptions} from './compiler_options';\n-import {StaticReflector} from './static_reflector';\n-import {StaticSymbolCache} from './static_symbol';\n-import {StaticSymbolResolver} from './static_symbol_resolver';\n-import {AotSummaryResolver} from './summary_resolver';\n-\n-export function createAotUrlResolver(\n-    host: {resourceNameToFileName(resourceName: string, containingFileName: string): string|null;}):\n-    UrlResolver {\n-  return {\n-    resolve: (basePath: string, url: string) => {\n-      const filePath = host.resourceNameToFileName(url, basePath);\n-      if (!filePath) {\n-        throw syntaxError(`Couldn't resolve resource ${url} from ${basePath}`);\n-      }\n-      return filePath;\n-    }\n-  };\n-}\n-\n-/**\n- * Creates a new AotCompiler based on options and a host.\n- */\n-export function createAotCompiler(\n-    compilerHost: AotCompilerHost, options: AotCompilerOptions,\n-    errorCollector?: (error: any, type?: any) =>\n-        void): {compiler: AotCompiler, reflector: StaticReflector} {\n-  let translations: string = options.translations || '';\n-\n-  const urlResolver = createAotUrlResolver(compilerHost);\n-  const symbolCache = new StaticSymbolCache();\n-  const summaryResolver = new AotSummaryResolver(compilerHost, symbolCache);\n-  const symbolResolver = new StaticSymbolResolver(compilerHost, symbolCache, summaryResolver);\n-  const staticReflector =\n-      new StaticReflector(summaryResolver, symbolResolver, [], [], errorCollector);\n-  let htmlParser: I18NHtmlParser;\n-  if (!!options.enableIvy) {\n-    // Ivy handles i18n at the compiler level so we must use a regular parser\n-    htmlParser = new HtmlParser() as I18NHtmlParser;\n-  } else {\n-    htmlParser = new I18NHtmlParser(\n-        new HtmlParser(), translations, options.i18nFormat, options.missingTranslation, console);\n-  }\n-  const config = new CompilerConfig({\n-    defaultEncapsulation: ViewEncapsulation.Emulated,\n-    useJit: false,\n-    missingTranslation: options.missingTranslation,\n-    preserveWhitespaces: options.preserveWhitespaces,\n-    strictInjectionParameters: options.strictInjectionParameters,\n-  });\n-  const normalizer = new DirectiveNormalizer(\n-      {get: (url: string) => compilerHost.loadResource(url)}, urlResolver, htmlParser, config);\n-  const expressionParser = new Parser(new Lexer());\n-  const elementSchemaRegistry = new DomElementSchemaRegistry();\n-  const tmplParser = new TemplateParser(\n-      config, staticReflector, expressionParser, elementSchemaRegistry, htmlParser, console, []);\n-  const resolver = new CompileMetadataResolver(\n-      config, htmlParser, new NgModuleResolver(staticReflector),\n-      new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver,\n-      elementSchemaRegistry, normalizer, console, symbolCache, staticReflector, errorCollector);\n-  // TODO(vicb): do not pass options.i18nFormat here\n-  const viewCompiler = new ViewCompiler(staticReflector);\n-  const typeCheckCompiler = new TypeCheckCompiler(options, staticReflector);\n-  const compiler = new AotCompiler(\n-      config, options, compilerHost, staticReflector, resolver, tmplParser,\n-      new StyleCompiler(urlResolver), viewCompiler, typeCheckCompiler,\n-      new NgModuleCompiler(staticReflector),\n-      new InjectableCompiler(staticReflector, !!options.enableIvy), new TypeScriptEmitter(),\n-      summaryResolver, symbolResolver);\n-  return {compiler, reflector: staticReflector};\n-}"
        },
        {
            "sha": "82c4bb6e65afa4dfcc23d2bf5f5723ad71054c58",
            "filename": "packages/compiler/src/aot/compiler_host.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 33,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fcompiler_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fcompiler_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Faot%2Fcompiler_host.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,33 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {StaticSymbolResolverHost} from './static_symbol_resolver';\n-import {AotSummaryResolverHost} from './summary_resolver';\n-\n-/**\n- * The host of the AotCompiler disconnects the implementation from TypeScript / other language\n- * services and from underlying file systems.\n- */\n-export interface AotCompilerHost extends StaticSymbolResolverHost, AotSummaryResolverHost {\n-  /**\n-   * Converts a file path to a module name that can be used as an `import.\n-   * I.e. `path/to/importedFile.ts` should be imported by `path/to/containingFile.ts`.\n-   *\n-   * See ImportResolver.\n-   */\n-  fileNameToModuleName(importedFilePath: string, containingFilePath: string): string;\n-  /**\n-   * Converts a path that refers to a resource into an absolute filePath\n-   * that can be later on used for loading the resource via `loadResource.\n-   */\n-  resourceNameToFileName(resourceName: string, containingFileName: string): string|null;\n-  /**\n-   * Loads a resource (e.g. html / css)\n-   */\n-  loadResource(path: string): Promise<string>|string;\n-}"
        },
        {
            "sha": "72bcf6396629918623ba76027f93eb5f99c418c3",
            "filename": "packages/compiler/src/aot/compiler_options.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 24,
            "changes": 24,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fcompiler_options.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fcompiler_options.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Faot%2Fcompiler_options.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,24 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {MissingTranslationStrategy} from '../core';\n-\n-export interface AotCompilerOptions {\n-  locale?: string;\n-  i18nFormat?: string;\n-  i18nUseExternalIds?: boolean;\n-  translations?: string;\n-  missingTranslation?: MissingTranslationStrategy;\n-  enableSummariesForJit?: boolean;\n-  preserveWhitespaces?: boolean;\n-  fullTemplateTypeCheck?: boolean;\n-  allowEmptyCodegenFiles?: boolean;\n-  strictInjectionParameters?: boolean;\n-  enableIvy?: boolean|'ngtsc';\n-  createExternalSymbolFactoryReexports?: boolean;\n-}"
        },
        {
            "sha": "7008329a08b4760d034a82c62f33ba641bdf4fc0",
            "filename": "packages/compiler/src/aot/formatted_error.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 66,
            "changes": 66,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fformatted_error.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fformatted_error.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Faot%2Fformatted_error.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,66 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {syntaxError} from '../parse_util';\n-\n-export interface Position {\n-  fileName: string;\n-  line: number;\n-  column: number;\n-}\n-\n-export interface FormattedMessageChain {\n-  message: string;\n-  position?: Position;\n-  next?: FormattedMessageChain[];\n-}\n-\n-export type FormattedError = Error&{\n-  chain: FormattedMessageChain;\n-  position?: Position;\n-};\n-\n-const FORMATTED_MESSAGE = 'ngFormattedMessage';\n-\n-function indentStr(level: number): string {\n-  if (level <= 0) return '';\n-  if (level < 6) return ['', ' ', '  ', '   ', '    ', '     '][level];\n-  const half = indentStr(Math.floor(level / 2));\n-  return half + half + (level % 2 === 1 ? ' ' : '');\n-}\n-\n-function formatChain(chain: FormattedMessageChain|undefined, indent: number = 0): string {\n-  if (!chain) return '';\n-  const position = chain.position ?\n-      `${chain.position.fileName}(${chain.position.line + 1},${chain.position.column + 1})` :\n-      '';\n-  const prefix = position && indent === 0 ? `${position}: ` : '';\n-  const postfix = position && indent !== 0 ? ` at ${position}` : '';\n-  let message = `${prefix}${chain.message}${postfix}`;\n-\n-  if (chain.next) {\n-    for (const kid of chain.next) {\n-      message += '\\n' + formatChain(kid, indent + 2);\n-    }\n-  }\n-\n-  return `${indentStr(indent)}${message}`;\n-}\n-\n-export function formattedError(chain: FormattedMessageChain): FormattedError {\n-  const message = formatChain(chain) + '.';\n-  const error = syntaxError(message) as FormattedError;\n-  (error as any)[FORMATTED_MESSAGE] = true;\n-  error.chain = chain;\n-  error.position = chain.position;\n-  return error;\n-}\n-\n-export function isFormattedError(error: Error): error is FormattedError {\n-  return !!(error as any)[FORMATTED_MESSAGE];\n-}"
        },
        {
            "sha": "2a69a65ef3ab9f90e64a311c1a791fd807d2391f",
            "filename": "packages/compiler/src/aot/generated_file.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 48,
            "changes": 48,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fgenerated_file.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fgenerated_file.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Faot%2Fgenerated_file.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,48 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {areAllEquivalent, Statement} from '../output/output_ast';\n-import {TypeScriptEmitter} from '../output/ts_emitter';\n-\n-export class GeneratedFile {\n-  public source: string|null;\n-  public stmts: Statement[]|null;\n-\n-  constructor(\n-      public srcFileUrl: string, public genFileUrl: string, sourceOrStmts: string|Statement[]) {\n-    if (typeof sourceOrStmts === 'string') {\n-      this.source = sourceOrStmts;\n-      this.stmts = null;\n-    } else {\n-      this.source = null;\n-      this.stmts = sourceOrStmts;\n-    }\n-  }\n-\n-  isEquivalent(other: GeneratedFile): boolean {\n-    if (this.genFileUrl !== other.genFileUrl) {\n-      return false;\n-    }\n-    if (this.source) {\n-      return this.source === other.source;\n-    }\n-    if (other.stmts == null) {\n-      return false;\n-    }\n-    // Note: the constructor guarantees that if this.source is not filled,\n-    // then this.stmts is.\n-    return areAllEquivalent(this.stmts!, other.stmts!);\n-  }\n-}\n-\n-export function toTypeScript(file: GeneratedFile, preamble: string = ''): string {\n-  if (!file.stmts) {\n-    throw new Error(`Illegal state: No stmts present on GeneratedFile ${file.genFileUrl}`);\n-  }\n-  return new TypeScriptEmitter().emitStatements(file.genFileUrl, file.stmts, preamble);\n-}"
        },
        {
            "sha": "105af12e2a887a806397dbff9fb9c9f834900377",
            "filename": "packages/compiler/src/aot/partial_module.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 14,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fpartial_module.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fpartial_module.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Faot%2Fpartial_module.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,14 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as o from '../output/output_ast';\n-\n-export interface PartialModule {\n-  fileName: string;\n-  statements: o.Statement[];\n-}"
        },
        {
            "sha": "e2e7b1e4f1852cc5ea1d7a72f2cb6bcd10dbd2bc",
            "filename": "packages/compiler/src/aot/static_reflector.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 1090,
            "changes": 1090,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fstatic_reflector.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fstatic_reflector.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Faot%2Fstatic_reflector.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,1090 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompileSummaryKind} from '../compile_metadata';\n-import {CompileReflector} from '../compile_reflector';\n-import {createAttribute, createComponent, createContentChild, createContentChildren, createDirective, createHost, createHostBinding, createHostListener, createInject, createInjectable, createInput, createNgModule, createOptional, createOutput, createPipe, createSelf, createSkipSelf, createViewChild, createViewChildren, MetadataFactory} from '../core';\n-import * as o from '../output/output_ast';\n-import {syntaxError} from '../parse_util';\n-import {SummaryResolver} from '../summary_resolver';\n-\n-import {formattedError, FormattedMessageChain} from './formatted_error';\n-import {StaticSymbol} from './static_symbol';\n-import {StaticSymbolResolver} from './static_symbol_resolver';\n-\n-const ANGULAR_CORE = '@angular/core';\n-const ANGULAR_ROUTER = '@angular/router';\n-\n-const HIDDEN_KEY = /^\\$.*\\$$/;\n-\n-const IGNORE = {\n-  __symbolic: 'ignore'\n-};\n-\n-const USE_VALUE = 'useValue';\n-const PROVIDE = 'provide';\n-const REFERENCE_SET = new Set([USE_VALUE, 'useFactory', 'data', 'id', 'loadChildren']);\n-const TYPEGUARD_POSTFIX = 'TypeGuard';\n-const USE_IF = 'UseIf';\n-\n-function shouldIgnore(value: any): boolean {\n-  return value && value.__symbolic == 'ignore';\n-}\n-\n-/**\n- * A static reflector implements enough of the Reflector API that is necessary to compile\n- * templates statically.\n- */\n-export class StaticReflector implements CompileReflector {\n-  private annotationCache = new Map<StaticSymbol, any[]>();\n-  private shallowAnnotationCache = new Map<StaticSymbol, any[]>();\n-  private propertyCache = new Map<StaticSymbol, {[key: string]: any[]}>();\n-  private parameterCache = new Map<StaticSymbol, any[]>();\n-  private methodCache = new Map<StaticSymbol, {[key: string]: boolean}>();\n-  private staticCache = new Map<StaticSymbol, string[]>();\n-  private conversionMap = new Map<StaticSymbol, (context: StaticSymbol, args: any[]) => any>();\n-  private resolvedExternalReferences = new Map<string, StaticSymbol>();\n-  // TODO(issue/24571): remove '!'.\n-  private injectionToken!: StaticSymbol;\n-  // TODO(issue/24571): remove '!'.\n-  private opaqueToken!: StaticSymbol;\n-  // TODO(issue/24571): remove '!'.\n-  ROUTES!: StaticSymbol;\n-  // TODO(issue/24571): remove '!'.\n-  private ANALYZE_FOR_ENTRY_COMPONENTS!: StaticSymbol;\n-  private annotationForParentClassWithSummaryKind =\n-      new Map<CompileSummaryKind, MetadataFactory<any>[]>();\n-\n-  constructor(\n-      private summaryResolver: SummaryResolver<StaticSymbol>,\n-      private symbolResolver: StaticSymbolResolver,\n-      knownMetadataClasses: {name: string, filePath: string, ctor: any}[] = [],\n-      knownMetadataFunctions: {name: string, filePath: string, fn: any}[] = [],\n-      private errorRecorder?: (error: any, fileName?: string) => void) {\n-    this.initializeConversionMap();\n-    knownMetadataClasses.forEach(\n-        (kc) => this._registerDecoratorOrConstructor(\n-            this.getStaticSymbol(kc.filePath, kc.name), kc.ctor));\n-    knownMetadataFunctions.forEach(\n-        (kf) => this._registerFunction(this.getStaticSymbol(kf.filePath, kf.name), kf.fn));\n-    this.annotationForParentClassWithSummaryKind.set(\n-        CompileSummaryKind.Directive, [createDirective, createComponent]);\n-    this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Pipe, [createPipe]);\n-    this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.NgModule, [createNgModule]);\n-    this.annotationForParentClassWithSummaryKind.set(\n-        CompileSummaryKind.Injectable,\n-        [createInjectable, createPipe, createDirective, createComponent, createNgModule]);\n-  }\n-\n-  componentModuleUrl(typeOrFunc: StaticSymbol): string {\n-    const staticSymbol = this.findSymbolDeclaration(typeOrFunc);\n-    return this.symbolResolver.getResourcePath(staticSymbol);\n-  }\n-\n-  /**\n-   * Invalidate the specified `symbols` on program change.\n-   * @param symbols\n-   */\n-  invalidateSymbols(symbols: StaticSymbol[]) {\n-    for (const symbol of symbols) {\n-      this.annotationCache.delete(symbol);\n-      this.shallowAnnotationCache.delete(symbol);\n-      this.propertyCache.delete(symbol);\n-      this.parameterCache.delete(symbol);\n-      this.methodCache.delete(symbol);\n-      this.staticCache.delete(symbol);\n-      this.conversionMap.delete(symbol);\n-    }\n-  }\n-\n-  resolveExternalReference(ref: o.ExternalReference, containingFile?: string): StaticSymbol {\n-    let key: string|undefined = undefined;\n-    if (!containingFile) {\n-      key = `${ref.moduleName}:${ref.name}`;\n-      const declarationSymbol = this.resolvedExternalReferences.get(key);\n-      if (declarationSymbol) return declarationSymbol;\n-    }\n-    const refSymbol =\n-        this.symbolResolver.getSymbolByModule(ref.moduleName!, ref.name!, containingFile);\n-    const declarationSymbol = this.findSymbolDeclaration(refSymbol);\n-    if (!containingFile) {\n-      this.symbolResolver.recordModuleNameForFileName(refSymbol.filePath, ref.moduleName!);\n-      this.symbolResolver.recordImportAs(declarationSymbol, refSymbol);\n-    }\n-    if (key) {\n-      this.resolvedExternalReferences.set(key, declarationSymbol);\n-    }\n-    return declarationSymbol;\n-  }\n-\n-  findDeclaration(moduleUrl: string, name: string, containingFile?: string): StaticSymbol {\n-    return this.findSymbolDeclaration(\n-        this.symbolResolver.getSymbolByModule(moduleUrl, name, containingFile));\n-  }\n-\n-  tryFindDeclaration(moduleUrl: string, name: string, containingFile?: string): StaticSymbol {\n-    return this.symbolResolver.ignoreErrorsFor(\n-        () => this.findDeclaration(moduleUrl, name, containingFile));\n-  }\n-\n-  findSymbolDeclaration(symbol: StaticSymbol): StaticSymbol {\n-    const resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\n-    if (resolvedSymbol) {\n-      let resolvedMetadata = resolvedSymbol.metadata;\n-      if (resolvedMetadata && resolvedMetadata.__symbolic === 'resolved') {\n-        resolvedMetadata = resolvedMetadata.symbol;\n-      }\n-      if (resolvedMetadata instanceof StaticSymbol) {\n-        return this.findSymbolDeclaration(resolvedSymbol.metadata);\n-      }\n-    }\n-    return symbol;\n-  }\n-\n-  public tryAnnotations(type: StaticSymbol): any[] {\n-    const originalRecorder = this.errorRecorder;\n-    this.errorRecorder = (error: any, fileName?: string) => {};\n-    try {\n-      return this.annotations(type);\n-    } finally {\n-      this.errorRecorder = originalRecorder;\n-    }\n-  }\n-\n-  public annotations(type: StaticSymbol): any[] {\n-    return this._annotations(\n-        type, (type: StaticSymbol, decorators: any) => this.simplify(type, decorators),\n-        this.annotationCache);\n-  }\n-\n-  public shallowAnnotations(type: StaticSymbol): any[] {\n-    return this._annotations(\n-        type, (type: StaticSymbol, decorators: any) => this.simplify(type, decorators, true),\n-        this.shallowAnnotationCache);\n-  }\n-\n-  private _annotations(\n-      type: StaticSymbol, simplify: (type: StaticSymbol, decorators: any) => any,\n-      annotationCache: Map<StaticSymbol, any[]>): any[] {\n-    let annotations = annotationCache.get(type);\n-    if (!annotations) {\n-      annotations = [];\n-      const classMetadata = this.getTypeMetadata(type);\n-      const parentType = this.findParentType(type, classMetadata);\n-      if (parentType) {\n-        const parentAnnotations = this.annotations(parentType);\n-        annotations.push(...parentAnnotations);\n-      }\n-      let ownAnnotations: any[] = [];\n-      if (classMetadata['decorators']) {\n-        ownAnnotations = simplify(type, classMetadata['decorators']);\n-        if (ownAnnotations) {\n-          annotations.push(...ownAnnotations);\n-        }\n-      }\n-      if (parentType && !this.summaryResolver.isLibraryFile(type.filePath) &&\n-          this.summaryResolver.isLibraryFile(parentType.filePath)) {\n-        const summary = this.summaryResolver.resolveSummary(parentType);\n-        if (summary && summary.type) {\n-          const requiredAnnotationTypes =\n-              this.annotationForParentClassWithSummaryKind.get(summary.type.summaryKind!)!;\n-          const typeHasRequiredAnnotation = requiredAnnotationTypes.some(\n-              (requiredType) => ownAnnotations.some(ann => requiredType.isTypeOf(ann)));\n-          if (!typeHasRequiredAnnotation) {\n-            this.reportError(\n-                formatMetadataError(\n-                    metadataError(\n-                        `Class ${type.name} in ${type.filePath} extends from a ${\n-                            CompileSummaryKind[summary.type.summaryKind!\n-            ]} in another compilation unit without duplicating the decorator`,\n-                        /* summary */ undefined,\n-                        `Please add a ${\n-                            requiredAnnotationTypes.map((type) => type.ngMetadataName)\n-                                .join(' or ')} decorator to the class`),\n-                    type),\n-                type);\n-          }\n-        }\n-      }\n-      annotationCache.set(type, annotations.filter(ann => !!ann));\n-    }\n-    return annotations;\n-  }\n-\n-  public propMetadata(type: StaticSymbol): {[key: string]: any[]} {\n-    let propMetadata = this.propertyCache.get(type);\n-    if (!propMetadata) {\n-      const classMetadata = this.getTypeMetadata(type);\n-      propMetadata = {};\n-      const parentType = this.findParentType(type, classMetadata);\n-      if (parentType) {\n-        const parentPropMetadata = this.propMetadata(parentType);\n-        Object.keys(parentPropMetadata).forEach((parentProp) => {\n-          propMetadata![parentProp] = parentPropMetadata[parentProp];\n-        });\n-      }\n-\n-      const members = classMetadata['members'] || {};\n-      Object.keys(members).forEach((propName) => {\n-        const propData = members[propName];\n-        const prop = (<any[]>propData)\n-                         .find(a => a['__symbolic'] == 'property' || a['__symbolic'] == 'method');\n-        const decorators: any[] = [];\n-        // hasOwnProperty() is used here to make sure we do not look up methods\n-        // on `Object.prototype`.\n-        if (propMetadata?.hasOwnProperty(propName)) {\n-          decorators.push(...propMetadata![propName]);\n-        }\n-        propMetadata![propName] = decorators;\n-        if (prop && prop['decorators']) {\n-          decorators.push(...this.simplify(type, prop['decorators']));\n-        }\n-      });\n-      this.propertyCache.set(type, propMetadata);\n-    }\n-    return propMetadata;\n-  }\n-\n-  public parameters(type: StaticSymbol): any[] {\n-    if (!(type instanceof StaticSymbol)) {\n-      this.reportError(\n-          new Error(`parameters received ${JSON.stringify(type)} which is not a StaticSymbol`),\n-          type);\n-      return [];\n-    }\n-    try {\n-      let parameters = this.parameterCache.get(type);\n-      if (!parameters) {\n-        const classMetadata = this.getTypeMetadata(type);\n-        const parentType = this.findParentType(type, classMetadata);\n-        const members = classMetadata ? classMetadata['members'] : null;\n-        const ctorData = members ? members['__ctor__'] : null;\n-        if (ctorData) {\n-          const ctor = (<any[]>ctorData).find(a => a['__symbolic'] == 'constructor');\n-          const rawParameterTypes = <any[]>ctor['parameters'] || [];\n-          const parameterDecorators = <any[]>this.simplify(type, ctor['parameterDecorators'] || []);\n-          parameters = [];\n-          rawParameterTypes.forEach((rawParamType, index) => {\n-            const nestedResult: any[] = [];\n-            const paramType = this.trySimplify(type, rawParamType);\n-            if (paramType) nestedResult.push(paramType);\n-            const decorators = parameterDecorators ? parameterDecorators[index] : null;\n-            if (decorators) {\n-              nestedResult.push(...decorators);\n-            }\n-            parameters!.push(nestedResult);\n-          });\n-        } else if (parentType) {\n-          parameters = this.parameters(parentType);\n-        }\n-        if (!parameters) {\n-          parameters = [];\n-        }\n-        this.parameterCache.set(type, parameters);\n-      }\n-      return parameters;\n-    } catch (e) {\n-      console.error(`Failed on type ${JSON.stringify(type)} with error ${e}`);\n-      throw e;\n-    }\n-  }\n-\n-  private _methodNames(type: any): {[key: string]: boolean} {\n-    let methodNames = this.methodCache.get(type);\n-    if (!methodNames) {\n-      const classMetadata = this.getTypeMetadata(type);\n-      methodNames = {};\n-      const parentType = this.findParentType(type, classMetadata);\n-      if (parentType) {\n-        const parentMethodNames = this._methodNames(parentType);\n-        Object.keys(parentMethodNames).forEach((parentProp) => {\n-          methodNames![parentProp] = parentMethodNames[parentProp];\n-        });\n-      }\n-\n-      const members = classMetadata['members'] || {};\n-      Object.keys(members).forEach((propName) => {\n-        const propData = members[propName];\n-        const isMethod = (<any[]>propData).some(a => a['__symbolic'] == 'method');\n-        methodNames![propName] = methodNames![propName] || isMethod;\n-      });\n-      this.methodCache.set(type, methodNames);\n-    }\n-    return methodNames;\n-  }\n-\n-  private _staticMembers(type: StaticSymbol): string[] {\n-    let staticMembers = this.staticCache.get(type);\n-    if (!staticMembers) {\n-      const classMetadata = this.getTypeMetadata(type);\n-      const staticMemberData = classMetadata['statics'] || {};\n-      staticMembers = Object.keys(staticMemberData);\n-      this.staticCache.set(type, staticMembers);\n-    }\n-    return staticMembers;\n-  }\n-\n-\n-  private findParentType(type: StaticSymbol, classMetadata: any): StaticSymbol|undefined {\n-    const parentType = this.trySimplify(type, classMetadata['extends']);\n-    if (parentType instanceof StaticSymbol) {\n-      return parentType;\n-    }\n-  }\n-\n-  hasLifecycleHook(type: any, lcProperty: string): boolean {\n-    if (!(type instanceof StaticSymbol)) {\n-      this.reportError(\n-          new Error(\n-              `hasLifecycleHook received ${JSON.stringify(type)} which is not a StaticSymbol`),\n-          type);\n-    }\n-    try {\n-      return !!this._methodNames(type)[lcProperty];\n-    } catch (e) {\n-      console.error(`Failed on type ${JSON.stringify(type)} with error ${e}`);\n-      throw e;\n-    }\n-  }\n-\n-  guards(type: any): {[key: string]: StaticSymbol} {\n-    if (!(type instanceof StaticSymbol)) {\n-      this.reportError(\n-          new Error(`guards received ${JSON.stringify(type)} which is not a StaticSymbol`), type);\n-      return {};\n-    }\n-    const staticMembers = this._staticMembers(type);\n-    const result: {[key: string]: StaticSymbol} = {};\n-    for (let name of staticMembers) {\n-      if (name.endsWith(TYPEGUARD_POSTFIX)) {\n-        let property = name.substr(0, name.length - TYPEGUARD_POSTFIX.length);\n-        let value: any;\n-        if (property.endsWith(USE_IF)) {\n-          property = name.substr(0, property.length - USE_IF.length);\n-          value = USE_IF;\n-        } else {\n-          value = this.getStaticSymbol(type.filePath, type.name, [name]);\n-        }\n-        result[property] = value;\n-      }\n-    }\n-    return result;\n-  }\n-\n-  private _registerDecoratorOrConstructor(type: StaticSymbol, ctor: any): void {\n-    this.conversionMap.set(type, (context: StaticSymbol, args: any[]) => new ctor(...args));\n-  }\n-\n-  private _registerFunction(type: StaticSymbol, fn: any): void {\n-    this.conversionMap.set(type, (context: StaticSymbol, args: any[]) => fn.apply(undefined, args));\n-  }\n-\n-  private initializeConversionMap(): void {\n-    this._registerDecoratorOrConstructor(\n-        this.findDeclaration(ANGULAR_CORE, 'Injectable'), createInjectable);\n-    this.injectionToken = this.findDeclaration(ANGULAR_CORE, 'InjectionToken');\n-    this.opaqueToken = this.findDeclaration(ANGULAR_CORE, 'OpaqueToken');\n-    this.ROUTES = this.tryFindDeclaration(ANGULAR_ROUTER, 'ROUTES');\n-    this.ANALYZE_FOR_ENTRY_COMPONENTS =\n-        this.findDeclaration(ANGULAR_CORE, 'ANALYZE_FOR_ENTRY_COMPONENTS');\n-\n-    this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), createHost);\n-    this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), createSelf);\n-    this._registerDecoratorOrConstructor(\n-        this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), createSkipSelf);\n-    this._registerDecoratorOrConstructor(\n-        this.findDeclaration(ANGULAR_CORE, 'Inject'), createInject);\n-    this._registerDecoratorOrConstructor(\n-        this.findDeclaration(ANGULAR_CORE, 'Optional'), createOptional);\n-    this._registerDecoratorOrConstructor(\n-        this.findDeclaration(ANGULAR_CORE, 'Attribute'), createAttribute);\n-    this._registerDecoratorOrConstructor(\n-        this.findDeclaration(ANGULAR_CORE, 'ContentChild'), createContentChild);\n-    this._registerDecoratorOrConstructor(\n-        this.findDeclaration(ANGULAR_CORE, 'ContentChildren'), createContentChildren);\n-    this._registerDecoratorOrConstructor(\n-        this.findDeclaration(ANGULAR_CORE, 'ViewChild'), createViewChild);\n-    this._registerDecoratorOrConstructor(\n-        this.findDeclaration(ANGULAR_CORE, 'ViewChildren'), createViewChildren);\n-    this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Input'), createInput);\n-    this._registerDecoratorOrConstructor(\n-        this.findDeclaration(ANGULAR_CORE, 'Output'), createOutput);\n-    this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Pipe'), createPipe);\n-    this._registerDecoratorOrConstructor(\n-        this.findDeclaration(ANGULAR_CORE, 'HostBinding'), createHostBinding);\n-    this._registerDecoratorOrConstructor(\n-        this.findDeclaration(ANGULAR_CORE, 'HostListener'), createHostListener);\n-    this._registerDecoratorOrConstructor(\n-        this.findDeclaration(ANGULAR_CORE, 'Directive'), createDirective);\n-    this._registerDecoratorOrConstructor(\n-        this.findDeclaration(ANGULAR_CORE, 'Component'), createComponent);\n-    this._registerDecoratorOrConstructor(\n-        this.findDeclaration(ANGULAR_CORE, 'NgModule'), createNgModule);\n-\n-    // Note: Some metadata classes can be used directly with Provider.deps.\n-    this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), createHost);\n-    this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), createSelf);\n-    this._registerDecoratorOrConstructor(\n-        this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), createSkipSelf);\n-    this._registerDecoratorOrConstructor(\n-        this.findDeclaration(ANGULAR_CORE, 'Optional'), createOptional);\n-  }\n-\n-  /**\n-   * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n-   * All types passed to the StaticResolver should be pseudo-types returned by this method.\n-   *\n-   * @param declarationFile the absolute path of the file where the symbol is declared\n-   * @param name the name of the type.\n-   */\n-  getStaticSymbol(declarationFile: string, name: string, members?: string[]): StaticSymbol {\n-    return this.symbolResolver.getStaticSymbol(declarationFile, name, members);\n-  }\n-\n-  /**\n-   * Simplify but discard any errors\n-   */\n-  private trySimplify(context: StaticSymbol, value: any): any {\n-    const originalRecorder = this.errorRecorder;\n-    this.errorRecorder = (error: any, fileName?: string) => {};\n-    const result = this.simplify(context, value);\n-    this.errorRecorder = originalRecorder;\n-    return result;\n-  }\n-\n-  /** @internal */\n-  public simplify(context: StaticSymbol, value: any, lazy: boolean = false): any {\n-    const self = this;\n-    let scope = BindingScope.empty;\n-    const calling = new Map<StaticSymbol, boolean>();\n-    const rootContext = context;\n-\n-    function simplifyInContext(\n-        context: StaticSymbol, value: any, depth: number, references: number): any {\n-      function resolveReferenceValue(staticSymbol: StaticSymbol): any {\n-        const resolvedSymbol = self.symbolResolver.resolveSymbol(staticSymbol);\n-        return resolvedSymbol ? resolvedSymbol.metadata : null;\n-      }\n-\n-      function simplifyEagerly(value: any): any {\n-        return simplifyInContext(context, value, depth, 0);\n-      }\n-\n-      function simplifyLazily(value: any): any {\n-        return simplifyInContext(context, value, depth, references + 1);\n-      }\n-\n-      function simplifyNested(nestedContext: StaticSymbol, value: any): any {\n-        if (nestedContext === context) {\n-          // If the context hasn't changed let the exception propagate unmodified.\n-          return simplifyInContext(nestedContext, value, depth + 1, references);\n-        }\n-        try {\n-          return simplifyInContext(nestedContext, value, depth + 1, references);\n-        } catch (e) {\n-          if (isMetadataError(e)) {\n-            // Propagate the message text up but add a message to the chain that explains how we got\n-            // here.\n-            // e.chain implies e.symbol\n-            const summaryMsg = e.chain ? 'references \\'' + e.symbol!.name + '\\'' : errorSummary(e);\n-            const summary = `'${nestedContext.name}' ${summaryMsg}`;\n-            const chain = {message: summary, position: e.position, next: e.chain};\n-            // TODO(chuckj): retrieve the position information indirectly from the collectors node\n-            // map if the metadata is from a .ts file.\n-            self.error(\n-                {\n-                  message: e.message,\n-                  advise: e.advise,\n-                  context: e.context,\n-                  chain,\n-                  symbol: nestedContext\n-                },\n-                context);\n-          } else {\n-            // It is probably an internal error.\n-            throw e;\n-          }\n-        }\n-      }\n-\n-      function simplifyCall(\n-          functionSymbol: StaticSymbol, targetFunction: any, args: any[], targetExpression: any) {\n-        if (targetFunction && targetFunction['__symbolic'] == 'function') {\n-          if (calling.get(functionSymbol)) {\n-            self.error(\n-                {\n-                  message: 'Recursion is not supported',\n-                  summary: `called '${functionSymbol.name}' recursively`,\n-                  value: targetFunction\n-                },\n-                functionSymbol);\n-          }\n-          try {\n-            const value = targetFunction['value'];\n-            if (value && (depth != 0 || value.__symbolic != 'error')) {\n-              const parameters: string[] = targetFunction['parameters'];\n-              const defaults: any[] = targetFunction.defaults;\n-              args = args.map(arg => simplifyNested(context, arg))\n-                         .map(arg => shouldIgnore(arg) ? undefined : arg);\n-              if (defaults && defaults.length > args.length) {\n-                args.push(...defaults.slice(args.length).map((value: any) => simplify(value)));\n-              }\n-              calling.set(functionSymbol, true);\n-              const functionScope = BindingScope.build();\n-              for (let i = 0; i < parameters.length; i++) {\n-                functionScope.define(parameters[i], args[i]);\n-              }\n-              const oldScope = scope;\n-              let result: any;\n-              try {\n-                scope = functionScope.done();\n-                result = simplifyNested(functionSymbol, value);\n-              } finally {\n-                scope = oldScope;\n-              }\n-              return result;\n-            }\n-          } finally {\n-            calling.delete(functionSymbol);\n-          }\n-        }\n-\n-        if (depth === 0) {\n-          // If depth is 0 we are evaluating the top level expression that is describing element\n-          // decorator. In this case, it is a decorator we don't understand, such as a custom\n-          // non-angular decorator, and we should just ignore it.\n-          return IGNORE;\n-        }\n-        let position: Position|undefined = undefined;\n-        if (targetExpression && targetExpression.__symbolic == 'resolved') {\n-          const line = targetExpression.line;\n-          const character = targetExpression.character;\n-          const fileName = targetExpression.fileName;\n-          if (fileName != null && line != null && character != null) {\n-            position = {fileName, line, column: character};\n-          }\n-        }\n-        self.error(\n-            {\n-              message: FUNCTION_CALL_NOT_SUPPORTED,\n-              context: functionSymbol,\n-              value: targetFunction,\n-              position\n-            },\n-            context);\n-      }\n-\n-      function simplify(expression: any): any {\n-        if (isPrimitive(expression)) {\n-          return expression;\n-        }\n-        if (Array.isArray(expression)) {\n-          const result: any[] = [];\n-          for (const item of (<any>expression)) {\n-            // Check for a spread expression\n-            if (item && item.__symbolic === 'spread') {\n-              // We call with references as 0 because we require the actual value and cannot\n-              // tolerate a reference here.\n-              const spreadArray = simplifyEagerly(item.expression);\n-              if (Array.isArray(spreadArray)) {\n-                for (const spreadItem of spreadArray) {\n-                  result.push(spreadItem);\n-                }\n-                continue;\n-              }\n-            }\n-            const value = simplify(item);\n-            if (shouldIgnore(value)) {\n-              continue;\n-            }\n-            result.push(value);\n-          }\n-          return result;\n-        }\n-        if (expression instanceof StaticSymbol) {\n-          // Stop simplification at builtin symbols or if we are in a reference context and\n-          // the symbol doesn't have members.\n-          if (expression === self.injectionToken || self.conversionMap.has(expression) ||\n-              (references > 0 && !expression.members.length)) {\n-            return expression;\n-          } else {\n-            const staticSymbol = expression;\n-            const declarationValue = resolveReferenceValue(staticSymbol);\n-            if (declarationValue != null) {\n-              return simplifyNested(staticSymbol, declarationValue);\n-            } else {\n-              return staticSymbol;\n-            }\n-          }\n-        }\n-        if (expression) {\n-          if (expression['__symbolic']) {\n-            let staticSymbol: StaticSymbol;\n-            switch (expression['__symbolic']) {\n-              case 'binop':\n-                let left = simplify(expression['left']);\n-                if (shouldIgnore(left)) return left;\n-                let right = simplify(expression['right']);\n-                if (shouldIgnore(right)) return right;\n-                switch (expression['operator']) {\n-                  case '&&':\n-                    return left && right;\n-                  case '||':\n-                    return left || right;\n-                  case '|':\n-                    return left | right;\n-                  case '^':\n-                    return left ^ right;\n-                  case '&':\n-                    return left & right;\n-                  case '==':\n-                    return left == right;\n-                  case '!=':\n-                    return left != right;\n-                  case '===':\n-                    return left === right;\n-                  case '!==':\n-                    return left !== right;\n-                  case '<':\n-                    return left < right;\n-                  case '>':\n-                    return left > right;\n-                  case '<=':\n-                    return left <= right;\n-                  case '>=':\n-                    return left >= right;\n-                  case '<<':\n-                    return left << right;\n-                  case '>>':\n-                    return left >> right;\n-                  case '+':\n-                    return left + right;\n-                  case '-':\n-                    return left - right;\n-                  case '*':\n-                    return left * right;\n-                  case '/':\n-                    return left / right;\n-                  case '%':\n-                    return left % right;\n-                  case '??':\n-                    return left ?? right;\n-                }\n-                return null;\n-              case 'if':\n-                let condition = simplify(expression['condition']);\n-                return condition ? simplify(expression['thenExpression']) :\n-                                   simplify(expression['elseExpression']);\n-              case 'pre':\n-                let operand = simplify(expression['operand']);\n-                if (shouldIgnore(operand)) return operand;\n-                switch (expression['operator']) {\n-                  case '+':\n-                    return operand;\n-                  case '-':\n-                    return -operand;\n-                  case '!':\n-                    return !operand;\n-                  case '~':\n-                    return ~operand;\n-                }\n-                return null;\n-              case 'index':\n-                let indexTarget = simplifyEagerly(expression['expression']);\n-                let index = simplifyEagerly(expression['index']);\n-                if (indexTarget && isPrimitive(index)) return indexTarget[index];\n-                return null;\n-              case 'select':\n-                const member = expression['member'];\n-                let selectContext = context;\n-                let selectTarget = simplify(expression['expression']);\n-                if (selectTarget instanceof StaticSymbol) {\n-                  const members = selectTarget.members.concat(member);\n-                  selectContext =\n-                      self.getStaticSymbol(selectTarget.filePath, selectTarget.name, members);\n-                  const declarationValue = resolveReferenceValue(selectContext);\n-                  if (declarationValue != null) {\n-                    return simplifyNested(selectContext, declarationValue);\n-                  } else {\n-                    return selectContext;\n-                  }\n-                }\n-                if (selectTarget && isPrimitive(member))\n-                  return simplifyNested(selectContext, selectTarget[member]);\n-                return null;\n-              case 'reference':\n-                // Note: This only has to deal with variable references, as symbol references have\n-                // been converted into 'resolved'\n-                // in the StaticSymbolResolver.\n-                const name: string = expression['name'];\n-                const localValue = scope.resolve(name);\n-                if (localValue != BindingScope.missing) {\n-                  return localValue;\n-                }\n-                break;\n-              case 'resolved':\n-                try {\n-                  return simplify(expression.symbol);\n-                } catch (e) {\n-                  // If an error is reported evaluating the symbol record the position of the\n-                  // reference in the error so it can\n-                  // be reported in the error message generated from the exception.\n-                  if (isMetadataError(e) && expression.fileName != null &&\n-                      expression.line != null && expression.character != null) {\n-                    e.position = {\n-                      fileName: expression.fileName,\n-                      line: expression.line,\n-                      column: expression.character\n-                    };\n-                  }\n-                  throw e;\n-                }\n-              case 'class':\n-                return context;\n-              case 'function':\n-                return context;\n-              case 'new':\n-              case 'call':\n-                // Determine if the function is a built-in conversion\n-                staticSymbol = simplifyInContext(\n-                    context, expression['expression'], depth + 1, /* references */ 0);\n-                if (staticSymbol instanceof StaticSymbol) {\n-                  if (staticSymbol === self.injectionToken || staticSymbol === self.opaqueToken) {\n-                    // if somebody calls new InjectionToken, don't create an InjectionToken,\n-                    // but rather return the symbol to which the InjectionToken is assigned to.\n-\n-                    // OpaqueToken is supported too as it is required by the language service to\n-                    // support v4 and prior versions of Angular.\n-                    return context;\n-                  }\n-                  const argExpressions: any[] = expression['arguments'] || [];\n-                  let converter = self.conversionMap.get(staticSymbol);\n-                  if (converter) {\n-                    const args = argExpressions.map(arg => simplifyNested(context, arg))\n-                                     .map(arg => shouldIgnore(arg) ? undefined : arg);\n-                    return converter(context, args);\n-                  } else {\n-                    // Determine if the function is one we can simplify.\n-                    const targetFunction = resolveReferenceValue(staticSymbol);\n-                    return simplifyCall(\n-                        staticSymbol, targetFunction, argExpressions, expression['expression']);\n-                  }\n-                }\n-                return IGNORE;\n-              case 'error':\n-                let message = expression.message;\n-                if (expression['line'] != null) {\n-                  self.error(\n-                      {\n-                        message,\n-                        context: expression.context,\n-                        value: expression,\n-                        position: {\n-                          fileName: expression['fileName'],\n-                          line: expression['line'],\n-                          column: expression['character']\n-                        }\n-                      },\n-                      context);\n-                } else {\n-                  self.error({message, context: expression.context}, context);\n-                }\n-                return IGNORE;\n-              case 'ignore':\n-                return expression;\n-            }\n-            return null;\n-          }\n-          return mapStringMap(expression, (value, name) => {\n-            if (REFERENCE_SET.has(name)) {\n-              if (name === USE_VALUE && PROVIDE in expression) {\n-                // If this is a provider expression, check for special tokens that need the value\n-                // during analysis.\n-                const provide = simplify(expression.provide);\n-                if (provide === self.ROUTES || provide == self.ANALYZE_FOR_ENTRY_COMPONENTS) {\n-                  return simplify(value);\n-                }\n-              }\n-              return simplifyLazily(value);\n-            }\n-            return simplify(value);\n-          });\n-        }\n-        return IGNORE;\n-      }\n-\n-      return simplify(value);\n-    }\n-\n-    let result: any;\n-    try {\n-      result = simplifyInContext(context, value, 0, lazy ? 1 : 0);\n-    } catch (e) {\n-      if (this.errorRecorder) {\n-        this.reportError(e, context);\n-      } else {\n-        throw formatMetadataError(e, context);\n-      }\n-    }\n-    if (shouldIgnore(result)) {\n-      return undefined;\n-    }\n-    return result;\n-  }\n-\n-  private getTypeMetadata(type: StaticSymbol): {[key: string]: any} {\n-    const resolvedSymbol = this.symbolResolver.resolveSymbol(type);\n-    return resolvedSymbol && resolvedSymbol.metadata ? resolvedSymbol.metadata :\n-                                                       {__symbolic: 'class'};\n-  }\n-\n-  private reportError(error: Error, context: StaticSymbol, path?: string) {\n-    if (this.errorRecorder) {\n-      this.errorRecorder(\n-          formatMetadataError(error, context), (context && context.filePath) || path);\n-    } else {\n-      throw error;\n-    }\n-  }\n-\n-  private error(\n-      {message, summary, advise, position, context, value, symbol, chain}: {\n-        message: string,\n-        summary?: string,\n-        advise?: string,\n-        position?: Position,\n-        context?: any,\n-        value?: any,\n-        symbol?: StaticSymbol,\n-        chain?: MetadataMessageChain\n-      },\n-      reportingContext: StaticSymbol) {\n-    this.reportError(\n-        metadataError(message, summary, advise, position, symbol, context, chain),\n-        reportingContext);\n-  }\n-}\n-\n-interface Position {\n-  fileName: string;\n-  line: number;\n-  column: number;\n-}\n-\n-interface MetadataMessageChain {\n-  message: string;\n-  summary?: string;\n-  position?: Position;\n-  context?: any;\n-  symbol?: StaticSymbol;\n-  next?: MetadataMessageChain;\n-}\n-\n-type MetadataError = Error&{\n-  position?: Position;\n-  advise?: string;\n-  summary?: string;\n-  context?: any;\n-  symbol?: StaticSymbol;\n-  chain?: MetadataMessageChain;\n-};\n-\n-const METADATA_ERROR = 'ngMetadataError';\n-\n-function metadataError(\n-    message: string, summary?: string, advise?: string, position?: Position, symbol?: StaticSymbol,\n-    context?: any, chain?: MetadataMessageChain): MetadataError {\n-  const error = syntaxError(message) as MetadataError;\n-  (error as any)[METADATA_ERROR] = true;\n-  if (advise) error.advise = advise;\n-  if (position) error.position = position;\n-  if (summary) error.summary = summary;\n-  if (context) error.context = context;\n-  if (chain) error.chain = chain;\n-  if (symbol) error.symbol = symbol;\n-  return error;\n-}\n-\n-function isMetadataError(error: Error): error is MetadataError {\n-  return !!(error as any)[METADATA_ERROR];\n-}\n-\n-const REFERENCE_TO_NONEXPORTED_CLASS = 'Reference to non-exported class';\n-const VARIABLE_NOT_INITIALIZED = 'Variable not initialized';\n-const DESTRUCTURE_NOT_SUPPORTED = 'Destructuring not supported';\n-const COULD_NOT_RESOLVE_TYPE = 'Could not resolve type';\n-const FUNCTION_CALL_NOT_SUPPORTED = 'Function call not supported';\n-const REFERENCE_TO_LOCAL_SYMBOL = 'Reference to a local symbol';\n-const LAMBDA_NOT_SUPPORTED = 'Lambda not supported';\n-\n-function expandedMessage(message: string, context: any): string {\n-  switch (message) {\n-    case REFERENCE_TO_NONEXPORTED_CLASS:\n-      if (context && context.className) {\n-        return `References to a non-exported class are not supported in decorators but ${\n-            context.className} was referenced.`;\n-      }\n-      break;\n-    case VARIABLE_NOT_INITIALIZED:\n-      return 'Only initialized variables and constants can be referenced in decorators because the value of this variable is needed by the template compiler';\n-    case DESTRUCTURE_NOT_SUPPORTED:\n-      return 'Referencing an exported destructured variable or constant is not supported in decorators and this value is needed by the template compiler';\n-    case COULD_NOT_RESOLVE_TYPE:\n-      if (context && context.typeName) {\n-        return `Could not resolve type ${context.typeName}`;\n-      }\n-      break;\n-    case FUNCTION_CALL_NOT_SUPPORTED:\n-      if (context && context.name) {\n-        return `Function calls are not supported in decorators but '${context.name}' was called`;\n-      }\n-      return 'Function calls are not supported in decorators';\n-    case REFERENCE_TO_LOCAL_SYMBOL:\n-      if (context && context.name) {\n-        return `Reference to a local (non-exported) symbols are not supported in decorators but '${\n-            context.name}' was referenced`;\n-      }\n-      break;\n-    case LAMBDA_NOT_SUPPORTED:\n-      return `Function expressions are not supported in decorators`;\n-  }\n-  return message;\n-}\n-\n-function messageAdvise(message: string, context: any): string|undefined {\n-  switch (message) {\n-    case REFERENCE_TO_NONEXPORTED_CLASS:\n-      if (context && context.className) {\n-        return `Consider exporting '${context.className}'`;\n-      }\n-      break;\n-    case DESTRUCTURE_NOT_SUPPORTED:\n-      return 'Consider simplifying to avoid destructuring';\n-    case REFERENCE_TO_LOCAL_SYMBOL:\n-      if (context && context.name) {\n-        return `Consider exporting '${context.name}'`;\n-      }\n-      break;\n-    case LAMBDA_NOT_SUPPORTED:\n-      return `Consider changing the function expression into an exported function`;\n-  }\n-  return undefined;\n-}\n-\n-function errorSummary(error: MetadataError): string {\n-  if (error.summary) {\n-    return error.summary;\n-  }\n-  switch (error.message) {\n-    case REFERENCE_TO_NONEXPORTED_CLASS:\n-      if (error.context && error.context.className) {\n-        return `references non-exported class ${error.context.className}`;\n-      }\n-      break;\n-    case VARIABLE_NOT_INITIALIZED:\n-      return 'is not initialized';\n-    case DESTRUCTURE_NOT_SUPPORTED:\n-      return 'is a destructured variable';\n-    case COULD_NOT_RESOLVE_TYPE:\n-      return 'could not be resolved';\n-    case FUNCTION_CALL_NOT_SUPPORTED:\n-      if (error.context && error.context.name) {\n-        return `calls '${error.context.name}'`;\n-      }\n-      return `calls a function`;\n-    case REFERENCE_TO_LOCAL_SYMBOL:\n-      if (error.context && error.context.name) {\n-        return `references local variable ${error.context.name}`;\n-      }\n-      return `references a local variable`;\n-  }\n-  return 'contains the error';\n-}\n-\n-function mapStringMap(input: {[key: string]: any}, transform: (value: any, key: string) => any):\n-    {[key: string]: any} {\n-  if (!input) return {};\n-  const result: {[key: string]: any} = {};\n-  Object.keys(input).forEach((key) => {\n-    const value = transform(input[key], key);\n-    if (!shouldIgnore(value)) {\n-      if (HIDDEN_KEY.test(key)) {\n-        Object.defineProperty(result, key, {enumerable: false, configurable: true, value: value});\n-      } else {\n-        result[key] = value;\n-      }\n-    }\n-  });\n-  return result;\n-}\n-\n-function isPrimitive(o: any): boolean {\n-  return o === null || (typeof o !== 'function' && typeof o !== 'object');\n-}\n-\n-interface BindingScopeBuilder {\n-  define(name: string, value: any): BindingScopeBuilder;\n-  done(): BindingScope;\n-}\n-\n-abstract class BindingScope {\n-  abstract resolve(name: string): any;\n-  public static missing = {};\n-  public static empty: BindingScope = {resolve: name => BindingScope.missing};\n-\n-  public static build(): BindingScopeBuilder {\n-    const current = new Map<string, any>();\n-    return {\n-      define: function(name, value) {\n-        current.set(name, value);\n-        return this;\n-      },\n-      done: function() {\n-        return current.size > 0 ? new PopulatedScope(current) : BindingScope.empty;\n-      }\n-    };\n-  }\n-}\n-\n-class PopulatedScope extends BindingScope {\n-  constructor(private bindings: Map<string, any>) {\n-    super();\n-  }\n-\n-  override resolve(name: string): any {\n-    return this.bindings.has(name) ? this.bindings.get(name) : BindingScope.missing;\n-  }\n-}\n-\n-function formatMetadataMessageChain(\n-    chain: MetadataMessageChain, advise: string|undefined): FormattedMessageChain {\n-  const expanded = expandedMessage(chain.message, chain.context);\n-  const nesting = chain.symbol ? ` in '${chain.symbol.name}'` : '';\n-  const message = `${expanded}${nesting}`;\n-  const position = chain.position;\n-  const next: FormattedMessageChain|undefined = chain.next ?\n-      formatMetadataMessageChain(chain.next, advise) :\n-      advise ? {message: advise} : undefined;\n-  return {message, position, next: next ? [next] : undefined};\n-}\n-\n-function formatMetadataError(e: Error, context: StaticSymbol): Error {\n-  if (isMetadataError(e)) {\n-    // Produce a formatted version of the and leaving enough information in the original error\n-    // to recover the formatting information to eventually produce a diagnostic error message.\n-    const position = e.position;\n-    const chain: MetadataMessageChain = {\n-      message: `Error during template compile of '${context.name}'`,\n-      position: position,\n-      next: {message: e.message, next: e.chain, context: e.context, symbol: e.symbol}\n-    };\n-    const advise = e.advise || messageAdvise(e.message, e.context);\n-    return formattedError(formatMetadataMessageChain(chain, advise));\n-  }\n-  return e;\n-}"
        },
        {
            "sha": "8444b03a35d53429eb83b30f10b65f7bd9d9deff",
            "filename": "packages/compiler/src/aot/static_symbol.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 43,
            "changes": 43,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fstatic_symbol.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fstatic_symbol.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Faot%2Fstatic_symbol.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,43 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-/**\n- * A token representing the a reference to a static type.\n- *\n- * This token is unique for a filePath and name and can be used as a hash table key.\n- */\n-export class StaticSymbol {\n-  constructor(public filePath: string, public name: string, public members: string[]) {}\n-\n-  assertNoMembers() {\n-    if (this.members.length) {\n-      throw new Error(\n-          `Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);\n-    }\n-  }\n-}\n-\n-/**\n- * A cache of static symbol used by the StaticReflector to return the same symbol for the\n- * same symbol values.\n- */\n-export class StaticSymbolCache {\n-  private cache = new Map<string, StaticSymbol>();\n-\n-  get(declarationFile: string, name: string, members?: string[]): StaticSymbol {\n-    members = members || [];\n-    const memberSuffix = members.length ? `.${members.join('.')}` : '';\n-    const key = `\"${declarationFile}\".${name}${memberSuffix}`;\n-    let result = this.cache.get(key);\n-    if (!result) {\n-      result = new StaticSymbol(declarationFile, name, members);\n-      this.cache.set(key, result);\n-    }\n-    return result;\n-  }\n-}"
        },
        {
            "sha": "4389e6c293b52c9f9a1b88093b62644543cbdd32",
            "filename": "packages/compiler/src/aot/static_symbol_resolver.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 548,
            "changes": 548,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fstatic_symbol_resolver.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fstatic_symbol_resolver.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Faot%2Fstatic_symbol_resolver.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,548 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {SummaryResolver} from '../summary_resolver';\n-import {ValueTransformer, visitValue} from '../util';\n-\n-import {StaticSymbol, StaticSymbolCache} from './static_symbol';\n-import {isGeneratedFile, stripSummaryForJitFileSuffix, stripSummaryForJitNameSuffix, summaryForJitFileName, summaryForJitName} from './util';\n-\n-const TS = /^(?!.*\\.d\\.ts$).*\\.ts$/;\n-\n-export class ResolvedStaticSymbol {\n-  constructor(public symbol: StaticSymbol, public metadata: any) {}\n-}\n-\n-/**\n- * The host of the SymbolResolverHost disconnects the implementation from TypeScript / other\n- * language\n- * services and from underlying file systems.\n- */\n-export interface StaticSymbolResolverHost {\n-  /**\n-   * Return a ModuleMetadata for the given module.\n-   * Angular CLI will produce this metadata for a module whenever a .d.ts files is\n-   * produced and the module has exported variables or classes with decorators. Module metadata can\n-   * also be produced directly from TypeScript sources by using MetadataCollector in tools/metadata.\n-   *\n-   * @param modulePath is a string identifier for a module as an absolute path.\n-   * @returns the metadata for the given module.\n-   */\n-  getMetadataFor(modulePath: string): {[key: string]: any}[]|undefined;\n-\n-  /**\n-   * Converts a module name that is used in an `import` to a file path.\n-   * I.e.\n-   * `path/to/containingFile.ts` containing `import {...} from 'module-name'`.\n-   */\n-  moduleNameToFileName(moduleName: string, containingFile?: string): string|null;\n-\n-  /**\n-   * Get a file suitable for display to the user that should be relative to the project directory\n-   * or the current directory.\n-   */\n-  getOutputName(filePath: string): string;\n-}\n-\n-const SUPPORTED_SCHEMA_VERSION = 4;\n-\n-/**\n- * This class is responsible for loading metadata per symbol,\n- * and normalizing references between symbols.\n- *\n- * Internally, it only uses symbols without members,\n- * and deduces the values for symbols with members based\n- * on these symbols.\n- */\n-export class StaticSymbolResolver {\n-  private metadataCache = new Map<string, {[key: string]: any}>();\n-  // Note: this will only contain StaticSymbols without members!\n-  private resolvedSymbols = new Map<StaticSymbol, ResolvedStaticSymbol>();\n-  // Note: this will only contain StaticSymbols without members!\n-  private importAs = new Map<StaticSymbol, StaticSymbol>();\n-  private symbolResourcePaths = new Map<StaticSymbol, string>();\n-  private symbolFromFile = new Map<string, StaticSymbol[]>();\n-  private knownFileNameToModuleNames = new Map<string, string>();\n-\n-  constructor(\n-      private host: StaticSymbolResolverHost, private staticSymbolCache: StaticSymbolCache,\n-      private summaryResolver: SummaryResolver<StaticSymbol>,\n-      private errorRecorder?: (error: any, fileName?: string) => void) {}\n-\n-  resolveSymbol(staticSymbol: StaticSymbol): ResolvedStaticSymbol {\n-    if (staticSymbol.members.length > 0) {\n-      return this._resolveSymbolMembers(staticSymbol)!;\n-    }\n-    // Note: always ask for a summary first,\n-    // as we might have read shallow metadata via a .d.ts file\n-    // for the symbol.\n-    const resultFromSummary = this._resolveSymbolFromSummary(staticSymbol)!;\n-    if (resultFromSummary) {\n-      return resultFromSummary;\n-    }\n-    const resultFromCache = this.resolvedSymbols.get(staticSymbol);\n-    if (resultFromCache) {\n-      return resultFromCache;\n-    }\n-    // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n-    // have summaries, only .d.ts files. So we always need to check both, the summary\n-    // and metadata.\n-    this._createSymbolsOf(staticSymbol.filePath);\n-    return this.resolvedSymbols.get(staticSymbol)!;\n-  }\n-\n-  /**\n-   * getImportAs produces a symbol that can be used to import the given symbol.\n-   * The import might be different than the symbol if the symbol is exported from\n-   * a library with a summary; in which case we want to import the symbol from the\n-   * ngfactory re-export instead of directly to avoid introducing a direct dependency\n-   * on an otherwise indirect dependency.\n-   *\n-   * @param staticSymbol the symbol for which to generate a import symbol\n-   */\n-  getImportAs(staticSymbol: StaticSymbol, useSummaries: boolean = true): StaticSymbol|null {\n-    if (staticSymbol.members.length) {\n-      const baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);\n-      const baseImportAs = this.getImportAs(baseSymbol, useSummaries);\n-      return baseImportAs ?\n-          this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) :\n-          null;\n-    }\n-    const summarizedFileName = stripSummaryForJitFileSuffix(staticSymbol.filePath);\n-    if (summarizedFileName !== staticSymbol.filePath) {\n-      const summarizedName = stripSummaryForJitNameSuffix(staticSymbol.name);\n-      const baseSymbol =\n-          this.getStaticSymbol(summarizedFileName, summarizedName, staticSymbol.members);\n-      const baseImportAs = this.getImportAs(baseSymbol, useSummaries);\n-      return baseImportAs ? this.getStaticSymbol(\n-                                summaryForJitFileName(baseImportAs.filePath),\n-                                summaryForJitName(baseImportAs.name), baseSymbol.members) :\n-                            null;\n-    }\n-    let result = (useSummaries && this.summaryResolver.getImportAs(staticSymbol)) || null;\n-    if (!result) {\n-      result = this.importAs.get(staticSymbol)!;\n-    }\n-    return result;\n-  }\n-\n-  /**\n-   * getResourcePath produces the path to the original location of the symbol and should\n-   * be used to determine the relative location of resource references recorded in\n-   * symbol metadata.\n-   */\n-  getResourcePath(staticSymbol: StaticSymbol): string {\n-    return this.symbolResourcePaths.get(staticSymbol) || staticSymbol.filePath;\n-  }\n-\n-  /**\n-   * getTypeArity returns the number of generic type parameters the given symbol\n-   * has. If the symbol is not a type the result is null.\n-   */\n-  getTypeArity(staticSymbol: StaticSymbol): number|null {\n-    // If the file is a factory/ngsummary file, don't resolve the symbol as doing so would\n-    // cause the metadata for an factory/ngsummary file to be loaded which doesn't exist.\n-    // All references to generated classes must include the correct arity whenever\n-    // generating code.\n-    if (isGeneratedFile(staticSymbol.filePath)) {\n-      return null;\n-    }\n-    let resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(staticSymbol));\n-    while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n-      resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(resolvedSymbol.metadata));\n-    }\n-    return (resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity) || null;\n-  }\n-\n-  getKnownModuleName(filePath: string): string|null {\n-    return this.knownFileNameToModuleNames.get(filePath) || null;\n-  }\n-\n-  recordImportAs(sourceSymbol: StaticSymbol, targetSymbol: StaticSymbol) {\n-    sourceSymbol.assertNoMembers();\n-    targetSymbol.assertNoMembers();\n-    this.importAs.set(sourceSymbol, targetSymbol);\n-  }\n-\n-  recordModuleNameForFileName(fileName: string, moduleName: string) {\n-    this.knownFileNameToModuleNames.set(fileName, moduleName);\n-  }\n-\n-  /**\n-   * Invalidate all information derived from the given file and return the\n-   * static symbols contained in the file.\n-   *\n-   * @param fileName the file to invalidate\n-   */\n-  invalidateFile(fileName: string): StaticSymbol[] {\n-    this.metadataCache.delete(fileName);\n-    const symbols = this.symbolFromFile.get(fileName);\n-    if (!symbols) {\n-      return [];\n-    }\n-    this.symbolFromFile.delete(fileName);\n-    for (const symbol of symbols) {\n-      this.resolvedSymbols.delete(symbol);\n-      this.importAs.delete(symbol);\n-      this.symbolResourcePaths.delete(symbol);\n-    }\n-    return symbols;\n-  }\n-\n-  /** @internal */\n-  ignoreErrorsFor<T>(cb: () => T) {\n-    const recorder = this.errorRecorder;\n-    this.errorRecorder = () => {};\n-    try {\n-      return cb();\n-    } finally {\n-      this.errorRecorder = recorder;\n-    }\n-  }\n-\n-  private _resolveSymbolMembers(staticSymbol: StaticSymbol): ResolvedStaticSymbol|null {\n-    const members = staticSymbol.members;\n-    const baseResolvedSymbol =\n-        this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));\n-    if (!baseResolvedSymbol) {\n-      return null;\n-    }\n-    let baseMetadata = unwrapResolvedMetadata(baseResolvedSymbol.metadata);\n-    if (baseMetadata instanceof StaticSymbol) {\n-      return new ResolvedStaticSymbol(\n-          staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));\n-    } else if (baseMetadata && baseMetadata.__symbolic === 'class') {\n-      if (baseMetadata.statics && members.length === 1) {\n-        return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);\n-      }\n-    } else {\n-      let value = baseMetadata;\n-      for (let i = 0; i < members.length && value; i++) {\n-        value = value[members[i]];\n-      }\n-      return new ResolvedStaticSymbol(staticSymbol, value);\n-    }\n-    return null;\n-  }\n-\n-  private _resolveSymbolFromSummary(staticSymbol: StaticSymbol): ResolvedStaticSymbol|null {\n-    const summary = this.summaryResolver.resolveSummary(staticSymbol);\n-    return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;\n-  }\n-\n-  /**\n-   * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n-   * All types passed to the StaticResolver should be pseudo-types returned by this method.\n-   *\n-   * @param declarationFile the absolute path of the file where the symbol is declared\n-   * @param name the name of the type.\n-   * @param members a symbol for a static member of the named type\n-   */\n-  getStaticSymbol(declarationFile: string, name: string, members?: string[]): StaticSymbol {\n-    return this.staticSymbolCache.get(declarationFile, name, members);\n-  }\n-\n-  /**\n-   * hasDecorators checks a file's metadata for the presence of decorators without evaluating the\n-   * metadata.\n-   *\n-   * @param filePath the absolute path to examine for decorators.\n-   * @returns true if any class in the file has a decorator.\n-   */\n-  hasDecorators(filePath: string): boolean {\n-    const metadata = this.getModuleMetadata(filePath);\n-    if (metadata['metadata']) {\n-      return Object.keys(metadata['metadata']).some((metadataKey) => {\n-        const entry = metadata['metadata'][metadataKey];\n-        return entry && entry.__symbolic === 'class' && entry.decorators;\n-      });\n-    }\n-    return false;\n-  }\n-\n-  getSymbolsOf(filePath: string): StaticSymbol[] {\n-    const summarySymbols = this.summaryResolver.getSymbolsOf(filePath);\n-    if (summarySymbols) {\n-      return summarySymbols;\n-    }\n-    // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n-    // have summaries, only .d.ts files, but `summaryResolver.isLibraryFile` returns true.\n-    this._createSymbolsOf(filePath);\n-    return this.symbolFromFile.get(filePath) || [];\n-  }\n-\n-  private _createSymbolsOf(filePath: string) {\n-    if (this.symbolFromFile.has(filePath)) {\n-      return;\n-    }\n-    const resolvedSymbols: ResolvedStaticSymbol[] = [];\n-    const metadata = this.getModuleMetadata(filePath);\n-    if (metadata['importAs']) {\n-      // Index bundle indices should use the importAs module name defined\n-      // in the bundle.\n-      this.knownFileNameToModuleNames.set(filePath, metadata['importAs']);\n-    }\n-    // handle the symbols in one of the re-export location\n-    if (metadata['exports']) {\n-      for (const moduleExport of metadata['exports']) {\n-        // handle the symbols in the list of explicitly re-exported symbols.\n-        if (moduleExport.export) {\n-          moduleExport.export.forEach((exportSymbol: any) => {\n-            let symbolName: string;\n-            if (typeof exportSymbol === 'string') {\n-              symbolName = exportSymbol;\n-            } else {\n-              symbolName = exportSymbol.as;\n-            }\n-            symbolName = unescapeIdentifier(symbolName);\n-            let symName = symbolName;\n-            if (typeof exportSymbol !== 'string') {\n-              symName = unescapeIdentifier(exportSymbol.name);\n-            }\n-            const resolvedModule = this.resolveModule(moduleExport.from, filePath);\n-            if (resolvedModule) {\n-              const targetSymbol = this.getStaticSymbol(resolvedModule, symName);\n-              const sourceSymbol = this.getStaticSymbol(filePath, symbolName);\n-              resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\n-            }\n-          });\n-        } else {\n-          // Handle the symbols loaded by 'export *' directives.\n-          const resolvedModule = this.resolveModule(moduleExport.from, filePath);\n-          if (resolvedModule && resolvedModule !== filePath) {\n-            const nestedExports = this.getSymbolsOf(resolvedModule);\n-            nestedExports.forEach((targetSymbol) => {\n-              const sourceSymbol = this.getStaticSymbol(filePath, targetSymbol.name);\n-              resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\n-            });\n-          }\n-        }\n-      }\n-    }\n-\n-    // handle the actual metadata. Has to be after the exports\n-    // as there might be collisions in the names, and we want the symbols\n-    // of the current module to win ofter reexports.\n-    if (metadata['metadata']) {\n-      // handle direct declarations of the symbol\n-      const topLevelSymbolNames =\n-          new Set<string>(Object.keys(metadata['metadata']).map(unescapeIdentifier));\n-      const origins: {[index: string]: string} = metadata['origins'] || {};\n-      Object.keys(metadata['metadata']).forEach((metadataKey) => {\n-        const symbolMeta = metadata['metadata'][metadataKey];\n-        const name = unescapeIdentifier(metadataKey);\n-\n-        const symbol = this.getStaticSymbol(filePath, name);\n-\n-        const origin = origins.hasOwnProperty(metadataKey) && origins[metadataKey];\n-        if (origin) {\n-          // If the symbol is from a bundled index, use the declaration location of the\n-          // symbol so relative references (such as './my.html') will be calculated\n-          // correctly.\n-          const originFilePath = this.resolveModule(origin, filePath);\n-          if (!originFilePath) {\n-            this.reportError(new Error(`Couldn't resolve original symbol for ${origin} from ${\n-                this.host.getOutputName(filePath)}`));\n-          } else {\n-            this.symbolResourcePaths.set(symbol, originFilePath);\n-          }\n-        }\n-        resolvedSymbols.push(\n-            this.createResolvedSymbol(symbol, filePath, topLevelSymbolNames, symbolMeta));\n-      });\n-    }\n-    const uniqueSymbols = new Set<StaticSymbol>();\n-    for (const resolvedSymbol of resolvedSymbols) {\n-      this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol);\n-      uniqueSymbols.add(resolvedSymbol.symbol);\n-    }\n-    this.symbolFromFile.set(filePath, Array.from(uniqueSymbols));\n-  }\n-\n-  private createResolvedSymbol(\n-      sourceSymbol: StaticSymbol, topLevelPath: string, topLevelSymbolNames: Set<string>,\n-      metadata: any): ResolvedStaticSymbol {\n-    // For classes that don't have Angular summaries / metadata,\n-    // we only keep their arity, but nothing else\n-    // (e.g. their constructor parameters).\n-    // We do this to prevent introducing deep imports\n-    // as we didn't generate .ngfactory.ts files with proper reexports.\n-    const isTsFile = TS.test(sourceSymbol.filePath);\n-    if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && !isTsFile && metadata &&\n-        metadata['__symbolic'] === 'class') {\n-      const transformedMeta = {__symbolic: 'class', arity: metadata.arity};\n-      return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n-    }\n-\n-    let _originalFileMemo: string|undefined;\n-    const getOriginalName: () => string = () => {\n-      if (!_originalFileMemo) {\n-        // Guess what the original file name is from the reference. If it has a `.d.ts` extension\n-        // replace it with `.ts`. If it already has `.ts` just leave it in place. If it doesn't have\n-        // .ts or .d.ts, append `.ts'. Also, if it is in `node_modules`, trim the `node_module`\n-        // location as it is not important to finding the file.\n-        _originalFileMemo =\n-            this.host.getOutputName(topLevelPath.replace(/((\\.ts)|(\\.d\\.ts)|)$/, '.ts')\n-                                        .replace(/^.*node_modules[/\\\\]/, ''));\n-      }\n-      return _originalFileMemo;\n-    };\n-\n-    const self = this;\n-\n-    class ReferenceTransformer extends ValueTransformer {\n-      override visitStringMap(map: {[key: string]: any}, functionParams: string[]): any {\n-        const symbolic = map['__symbolic'];\n-        if (symbolic === 'function') {\n-          const oldLen = functionParams.length;\n-          functionParams.push(...(map['parameters'] || []));\n-          const result = super.visitStringMap(map, functionParams);\n-          functionParams.length = oldLen;\n-          return result;\n-        } else if (symbolic === 'reference') {\n-          const module = map['module'];\n-          const name = map['name'] ? unescapeIdentifier(map['name']) : map['name'];\n-          if (!name) {\n-            return null;\n-          }\n-          let filePath: string;\n-          if (module) {\n-            filePath = self.resolveModule(module, sourceSymbol.filePath)!;\n-            if (!filePath) {\n-              return {\n-                __symbolic: 'error',\n-                message: `Could not resolve ${module} relative to ${\n-                    self.host.getMetadataFor(sourceSymbol.filePath)}.`,\n-                line: map['line'],\n-                character: map['character'],\n-                fileName: getOriginalName()\n-              };\n-            }\n-            return {\n-              __symbolic: 'resolved',\n-              symbol: self.getStaticSymbol(filePath, name),\n-              line: map['line'],\n-              character: map['character'],\n-              fileName: getOriginalName()\n-            };\n-          } else if (functionParams.indexOf(name) >= 0) {\n-            // reference to a function parameter\n-            return {__symbolic: 'reference', name: name};\n-          } else {\n-            if (topLevelSymbolNames.has(name)) {\n-              return self.getStaticSymbol(topLevelPath, name);\n-            }\n-            // ambient value\n-            null;\n-          }\n-        } else if (symbolic === 'error') {\n-          return {...map, fileName: getOriginalName()};\n-        } else {\n-          return super.visitStringMap(map, functionParams);\n-        }\n-      }\n-    }\n-    const transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);\n-    let unwrappedTransformedMeta = unwrapResolvedMetadata(transformedMeta);\n-    if (unwrappedTransformedMeta instanceof StaticSymbol) {\n-      return this.createExport(sourceSymbol, unwrappedTransformedMeta);\n-    }\n-    return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n-  }\n-\n-  private createExport(sourceSymbol: StaticSymbol, targetSymbol: StaticSymbol):\n-      ResolvedStaticSymbol {\n-    sourceSymbol.assertNoMembers();\n-    targetSymbol.assertNoMembers();\n-    if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) &&\n-        this.summaryResolver.isLibraryFile(targetSymbol.filePath)) {\n-      // This case is for an ng library importing symbols from a plain ts library\n-      // transitively.\n-      // Note: We rely on the fact that we discover symbols in the direction\n-      // from source files to library files\n-      this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);\n-    }\n-    return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);\n-  }\n-\n-  private reportError(error: Error, context?: StaticSymbol, path?: string) {\n-    if (this.errorRecorder) {\n-      this.errorRecorder(error, (context && context.filePath) || path);\n-    } else {\n-      throw error;\n-    }\n-  }\n-\n-  /**\n-   * @param module an absolute path to a module file.\n-   */\n-  private getModuleMetadata(module: string): {[key: string]: any} {\n-    let moduleMetadata = this.metadataCache.get(module);\n-    if (!moduleMetadata) {\n-      const moduleMetadatas = this.host.getMetadataFor(module);\n-      if (moduleMetadatas) {\n-        let maxVersion = -1;\n-        moduleMetadatas.forEach((md) => {\n-          if (md && md['version'] > maxVersion) {\n-            maxVersion = md['version'];\n-            moduleMetadata = md;\n-          }\n-        });\n-      }\n-      if (!moduleMetadata) {\n-        moduleMetadata =\n-            {__symbolic: 'module', version: SUPPORTED_SCHEMA_VERSION, module: module, metadata: {}};\n-      }\n-      if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {\n-        const errorMessage = moduleMetadata['version'] == 2 ?\n-            `Unsupported metadata version ${moduleMetadata['version']} for module ${\n-                module}. This module should be compiled with a newer version of ngc` :\n-            `Metadata version mismatch for module ${\n-                this.host.getOutputName(module)}, found version ${\n-                moduleMetadata['version']}, expected ${SUPPORTED_SCHEMA_VERSION}`;\n-        this.reportError(new Error(errorMessage));\n-      }\n-      this.metadataCache.set(module, moduleMetadata);\n-    }\n-    return moduleMetadata;\n-  }\n-\n-\n-  getSymbolByModule(module: string, symbolName: string, containingFile?: string): StaticSymbol {\n-    const filePath = this.resolveModule(module, containingFile);\n-    if (!filePath) {\n-      this.reportError(new Error(`Could not resolve module ${module}${\n-          containingFile ? ' relative to ' + this.host.getOutputName(containingFile) : ''}`));\n-      return this.getStaticSymbol(`ERROR:${module}`, symbolName);\n-    }\n-    return this.getStaticSymbol(filePath, symbolName);\n-  }\n-\n-  private resolveModule(module: string, containingFile?: string): string|null {\n-    try {\n-      return this.host.moduleNameToFileName(module, containingFile);\n-    } catch (e) {\n-      console.error(`Could not resolve module '${module}' relative to file ${containingFile}`);\n-      this.reportError(e, undefined, containingFile);\n-    }\n-    return null;\n-  }\n-}\n-\n-// Remove extra underscore from escaped identifier.\n-// See https://github.com/Microsoft/TypeScript/blob/master/src/compiler/utilities.ts\n-export function unescapeIdentifier(identifier: string): string {\n-  return identifier.startsWith('___') ? identifier.substr(1) : identifier;\n-}\n-\n-export function unwrapResolvedMetadata(metadata: any): any {\n-  if (metadata && metadata.__symbolic === 'resolved') {\n-    return metadata.symbol;\n-  }\n-  return metadata;\n-}"
        },
        {
            "sha": "960d20ea8b3dc78347a4c43354830c4515a97c1c",
            "filename": "packages/compiler/src/aot/summary_resolver.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 132,
            "changes": 132,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fsummary_resolver.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fsummary_resolver.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Faot%2Fsummary_resolver.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,132 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Summary, SummaryResolver} from '../summary_resolver';\n-\n-import {StaticSymbol, StaticSymbolCache} from './static_symbol';\n-import {deserializeSummaries} from './summary_serializer';\n-import {stripGeneratedFileSuffix, summaryFileName} from './util';\n-\n-export interface AotSummaryResolverHost {\n-  /**\n-   * Loads an NgModule/Directive/Pipe summary file\n-   */\n-  loadSummary(filePath: string): string|null;\n-\n-  /**\n-   * Returns whether a file is a source file or not.\n-   */\n-  isSourceFile(sourceFilePath: string): boolean;\n-  /**\n-   * Converts a file name into a representation that should be stored in a summary file.\n-   * This has to include changing the suffix as well.\n-   * E.g.\n-   * `some_file.ts` -> `some_file.d.ts`\n-   *\n-   * @param referringSrcFileName the soure file that refers to fileName\n-   */\n-  toSummaryFileName(fileName: string, referringSrcFileName: string): string;\n-\n-  /**\n-   * Converts a fileName that was processed by `toSummaryFileName` back into a real fileName\n-   * given the fileName of the library that is referrig to it.\n-   */\n-  fromSummaryFileName(fileName: string, referringLibFileName: string): string;\n-}\n-\n-export class AotSummaryResolver implements SummaryResolver<StaticSymbol> {\n-  // Note: this will only contain StaticSymbols without members!\n-  private summaryCache = new Map<StaticSymbol, Summary<StaticSymbol>>();\n-  private loadedFilePaths = new Map<string, boolean>();\n-  // Note: this will only contain StaticSymbols without members!\n-  private importAs = new Map<StaticSymbol, StaticSymbol>();\n-  private knownFileNameToModuleNames = new Map<string, string>();\n-\n-  constructor(private host: AotSummaryResolverHost, private staticSymbolCache: StaticSymbolCache) {}\n-\n-  isLibraryFile(filePath: string): boolean {\n-    // Note: We need to strip the .ngfactory. file path,\n-    // so this method also works for generated files\n-    // (for which host.isSourceFile will always return false).\n-    return !this.host.isSourceFile(stripGeneratedFileSuffix(filePath));\n-  }\n-\n-  toSummaryFileName(filePath: string, referringSrcFileName: string) {\n-    return this.host.toSummaryFileName(filePath, referringSrcFileName);\n-  }\n-\n-  fromSummaryFileName(fileName: string, referringLibFileName: string) {\n-    return this.host.fromSummaryFileName(fileName, referringLibFileName);\n-  }\n-\n-  resolveSummary(staticSymbol: StaticSymbol): Summary<StaticSymbol>|null {\n-    const rootSymbol = staticSymbol.members.length ?\n-        this.staticSymbolCache.get(staticSymbol.filePath, staticSymbol.name) :\n-        staticSymbol;\n-    let summary = this.summaryCache.get(rootSymbol);\n-    if (!summary) {\n-      this._loadSummaryFile(staticSymbol.filePath);\n-      summary = this.summaryCache.get(staticSymbol)!;\n-    }\n-    return (rootSymbol === staticSymbol && summary) || null;\n-  }\n-\n-  getSymbolsOf(filePath: string): StaticSymbol[]|null {\n-    if (this._loadSummaryFile(filePath)) {\n-      return Array.from(this.summaryCache.keys()).filter((symbol) => symbol.filePath === filePath);\n-    }\n-    return null;\n-  }\n-\n-  getImportAs(staticSymbol: StaticSymbol): StaticSymbol {\n-    staticSymbol.assertNoMembers();\n-    return this.importAs.get(staticSymbol)!;\n-  }\n-\n-  /**\n-   * Converts a file path to a module name that can be used as an `import`.\n-   */\n-  getKnownModuleName(importedFilePath: string): string|null {\n-    return this.knownFileNameToModuleNames.get(importedFilePath) || null;\n-  }\n-\n-  addSummary(summary: Summary<StaticSymbol>) {\n-    this.summaryCache.set(summary.symbol, summary);\n-  }\n-\n-  private _loadSummaryFile(filePath: string): boolean {\n-    let hasSummary = this.loadedFilePaths.get(filePath);\n-    if (hasSummary != null) {\n-      return hasSummary;\n-    }\n-    let json: string|null = null;\n-    if (this.isLibraryFile(filePath)) {\n-      const summaryFilePath = summaryFileName(filePath);\n-      try {\n-        json = this.host.loadSummary(summaryFilePath);\n-      } catch (e) {\n-        console.error(`Error loading summary file ${summaryFilePath}`);\n-        throw e;\n-      }\n-    }\n-    hasSummary = json != null;\n-    this.loadedFilePaths.set(filePath, hasSummary);\n-    if (json) {\n-      const {moduleName, summaries, importAs} =\n-          deserializeSummaries(this.staticSymbolCache, this, filePath, json);\n-      summaries.forEach((summary) => this.summaryCache.set(summary.symbol, summary));\n-      if (moduleName) {\n-        this.knownFileNameToModuleNames.set(filePath, moduleName);\n-      }\n-      importAs.forEach((importAs) => {\n-        this.importAs.set(importAs.symbol, importAs.importAs);\n-      });\n-    }\n-    return hasSummary;\n-  }\n-}"
        },
        {
            "sha": "0587276e08dc2f0e9f52457d560e7393607632b2",
            "filename": "packages/compiler/src/aot/summary_serializer.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 508,
            "changes": 508,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fsummary_serializer.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Fsummary_serializer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Faot%2Fsummary_serializer.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,508 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import {CompileDirectiveMetadata, CompileDirectiveSummary, CompileNgModuleMetadata, CompileNgModuleSummary, CompilePipeMetadata, CompileProviderMetadata, CompileSummaryKind, CompileTypeMetadata, CompileTypeSummary} from '../compile_metadata';\n-import {OutputContext} from '../constant_pool';\n-import * as o from '../output/output_ast';\n-import {Summary, SummaryResolver} from '../summary_resolver';\n-import {ValueTransformer, ValueVisitor, visitValue} from '../util';\n-\n-import {StaticSymbol, StaticSymbolCache} from './static_symbol';\n-import {ResolvedStaticSymbol, StaticSymbolResolver, unwrapResolvedMetadata} from './static_symbol_resolver';\n-import {isLoweredSymbol, ngfactoryFilePath, summaryForJitFileName, summaryForJitName} from './util';\n-\n-export function serializeSummaries(\n-    srcFileName: string, forJitCtx: OutputContext|null,\n-    summaryResolver: SummaryResolver<StaticSymbol>, symbolResolver: StaticSymbolResolver,\n-    symbols: ResolvedStaticSymbol[], types: {\n-      summary: CompileTypeSummary,\n-      metadata: CompileNgModuleMetadata|CompileDirectiveMetadata|CompilePipeMetadata|\n-      CompileTypeMetadata\n-    }[],\n-    createExternalSymbolReexports =\n-        false): {json: string, exportAs: {symbol: StaticSymbol, exportAs: string}[]} {\n-  const toJsonSerializer = new ToJsonSerializer(symbolResolver, summaryResolver, srcFileName);\n-\n-  // for symbols, we use everything except for the class metadata itself\n-  // (we keep the statics though), as the class metadata is contained in the\n-  // CompileTypeSummary.\n-  symbols.forEach(\n-      (resolvedSymbol) => toJsonSerializer.addSummary(\n-          {symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata}));\n-\n-  // Add type summaries.\n-  types.forEach(({summary, metadata}) => {\n-    toJsonSerializer.addSummary(\n-        {symbol: summary.type.reference, metadata: undefined, type: summary});\n-  });\n-  const {json, exportAs} = toJsonSerializer.serialize(createExternalSymbolReexports);\n-  if (forJitCtx) {\n-    const forJitSerializer = new ForJitSerializer(forJitCtx, symbolResolver, summaryResolver);\n-    types.forEach(({summary, metadata}) => {\n-      forJitSerializer.addSourceType(summary, metadata);\n-    });\n-    toJsonSerializer.unprocessedSymbolSummariesBySymbol.forEach((summary) => {\n-      if (summaryResolver.isLibraryFile(summary.symbol.filePath) && summary.type) {\n-        forJitSerializer.addLibType(summary.type);\n-      }\n-    });\n-    forJitSerializer.serialize(exportAs);\n-  }\n-  return {json, exportAs};\n-}\n-\n-export function deserializeSummaries(\n-    symbolCache: StaticSymbolCache, summaryResolver: SummaryResolver<StaticSymbol>,\n-    libraryFileName: string, json: string): {\n-  moduleName: string|null,\n-  summaries: Summary<StaticSymbol>[],\n-  importAs: {symbol: StaticSymbol, importAs: StaticSymbol}[]\n-} {\n-  const deserializer = new FromJsonDeserializer(symbolCache, summaryResolver);\n-  return deserializer.deserialize(libraryFileName, json);\n-}\n-\n-export function createForJitStub(outputCtx: OutputContext, reference: StaticSymbol) {\n-  return createSummaryForJitFunction(outputCtx, reference, o.NULL_EXPR);\n-}\n-\n-function createSummaryForJitFunction(\n-    outputCtx: OutputContext, reference: StaticSymbol, value: o.Expression) {\n-  const fnName = summaryForJitName(reference.name);\n-  outputCtx.statements.push(\n-      o.fn([], [new o.ReturnStatement(value)], new o.ArrayType(o.DYNAMIC_TYPE)).toDeclStmt(fnName, [\n-        o.StmtModifier.Final, o.StmtModifier.Exported\n-      ]));\n-}\n-\n-const enum SerializationFlags {\n-  None = 0,\n-  ResolveValue = 1,\n-}\n-\n-class ToJsonSerializer extends ValueTransformer {\n-  // Note: This only contains symbols without members.\n-  private symbols: StaticSymbol[] = [];\n-  private indexBySymbol = new Map<StaticSymbol, number>();\n-  private reexportedBy = new Map<StaticSymbol, StaticSymbol>();\n-  // This now contains a `__symbol: number` in the place of\n-  // StaticSymbols, but otherwise has the same shape as the original objects.\n-  private processedSummaryBySymbol = new Map<StaticSymbol, any>();\n-  private processedSummaries: any[] = [];\n-  private moduleName: string|null;\n-\n-  unprocessedSymbolSummariesBySymbol = new Map<StaticSymbol, Summary<StaticSymbol>>();\n-\n-  constructor(\n-      private symbolResolver: StaticSymbolResolver,\n-      private summaryResolver: SummaryResolver<StaticSymbol>, private srcFileName: string) {\n-    super();\n-    this.moduleName = symbolResolver.getKnownModuleName(srcFileName);\n-  }\n-\n-  addSummary(summary: Summary<StaticSymbol>) {\n-    let unprocessedSummary = this.unprocessedSymbolSummariesBySymbol.get(summary.symbol);\n-    let processedSummary = this.processedSummaryBySymbol.get(summary.symbol);\n-    if (!unprocessedSummary) {\n-      unprocessedSummary = {symbol: summary.symbol, metadata: undefined};\n-      this.unprocessedSymbolSummariesBySymbol.set(summary.symbol, unprocessedSummary);\n-      processedSummary = {symbol: this.processValue(summary.symbol, SerializationFlags.None)};\n-      this.processedSummaries.push(processedSummary);\n-      this.processedSummaryBySymbol.set(summary.symbol, processedSummary);\n-    }\n-    if (!unprocessedSummary.metadata && summary.metadata) {\n-      let metadata = summary.metadata || {};\n-      if (metadata.__symbolic === 'class') {\n-        // For classes, we keep everything except their class decorators.\n-        // We need to keep e.g. the ctor args, method names, method decorators\n-        // so that the class can be extended in another compilation unit.\n-        // We don't keep the class decorators as\n-        // 1) they refer to data\n-        //   that should not cause a rebuild of downstream compilation units\n-        //   (e.g. inline templates of @Component, or @NgModule.declarations)\n-        // 2) their data is already captured in TypeSummaries, e.g. DirectiveSummary.\n-        const clone: {[key: string]: any} = {};\n-        Object.keys(metadata).forEach((propName) => {\n-          if (propName !== 'decorators') {\n-            clone[propName] = metadata[propName];\n-          }\n-        });\n-        metadata = clone;\n-      } else if (isCall(metadata)) {\n-        if (!isFunctionCall(metadata) && !isMethodCallOnVariable(metadata)) {\n-          // Don't store complex calls as we won't be able to simplify them anyways later on.\n-          metadata = {\n-            __symbolic: 'error',\n-            message: 'Complex function calls are not supported.',\n-          };\n-        }\n-      }\n-      // Note: We need to keep storing ctor calls for e.g.\n-      // `export const x = new InjectionToken(...)`\n-      unprocessedSummary.metadata = metadata;\n-      processedSummary.metadata = this.processValue(metadata, SerializationFlags.ResolveValue);\n-      if (metadata instanceof StaticSymbol &&\n-          this.summaryResolver.isLibraryFile(metadata.filePath)) {\n-        const declarationSymbol = this.symbols[this.indexBySymbol.get(metadata)!];\n-        if (!isLoweredSymbol(declarationSymbol.name)) {\n-          // Note: symbols that were introduced during codegen in the user file can have a reexport\n-          // if a user used `export *`. However, we can't rely on this as tsickle will change\n-          // `export *` into named exports, using only the information from the typechecker.\n-          // As we introduce the new symbols after typecheck, Tsickle does not know about them,\n-          // and omits them when expanding `export *`.\n-          // So we have to keep reexporting these symbols manually via .ngfactory files.\n-          this.reexportedBy.set(declarationSymbol, summary.symbol);\n-        }\n-      }\n-    }\n-    if (!unprocessedSummary.type && summary.type) {\n-      unprocessedSummary.type = summary.type;\n-      // Note: We don't add the summaries of all referenced symbols as for the ResolvedSymbols,\n-      // as the type summaries already contain the transitive data that they require\n-      // (in a minimal way).\n-      processedSummary.type = this.processValue(summary.type, SerializationFlags.None);\n-      // except for reexported directives / pipes, so we need to store\n-      // their summaries explicitly.\n-      if (summary.type.summaryKind === CompileSummaryKind.NgModule) {\n-        const ngModuleSummary = <CompileNgModuleSummary>summary.type;\n-        ngModuleSummary.exportedDirectives.concat(ngModuleSummary.exportedPipes).forEach((id) => {\n-          const symbol: StaticSymbol = id.reference;\n-          if (this.summaryResolver.isLibraryFile(symbol.filePath) &&\n-              !this.unprocessedSymbolSummariesBySymbol.has(symbol)) {\n-            const summary = this.summaryResolver.resolveSummary(symbol);\n-            if (summary) {\n-              this.addSummary(summary);\n-            }\n-          }\n-        });\n-      }\n-    }\n-  }\n-\n-  /**\n-   * @param createExternalSymbolReexports Whether external static symbols should be re-exported.\n-   * This can be enabled if external symbols should be re-exported by the current module in\n-   * order to avoid dynamically generated module dependencies which can break strict dependency\n-   * enforcements (as in Google3). Read more here: https://github.com/angular/angular/issues/25644\n-   */\n-  serialize(createExternalSymbolReexports: boolean):\n-      {json: string, exportAs: {symbol: StaticSymbol, exportAs: string}[]} {\n-    const exportAs: {symbol: StaticSymbol, exportAs: string}[] = [];\n-    const json = JSON.stringify({\n-      moduleName: this.moduleName,\n-      summaries: this.processedSummaries,\n-      symbols: this.symbols.map((symbol, index) => {\n-        symbol.assertNoMembers();\n-        let importAs: string|number = undefined!;\n-        if (this.summaryResolver.isLibraryFile(symbol.filePath)) {\n-          const reexportSymbol = this.reexportedBy.get(symbol);\n-          if (reexportSymbol) {\n-            // In case the given external static symbol is already manually exported by the\n-            // user, we just proxy the external static symbol reference to the manual export.\n-            // This ensures that the AOT compiler imports the external symbol through the\n-            // user export and does not introduce another dependency which is not needed.\n-            importAs = this.indexBySymbol.get(reexportSymbol)!;\n-          } else if (createExternalSymbolReexports) {\n-            // In this case, the given external static symbol is *not* manually exported by\n-            // the user, and we manually create a re-export in the factory file so that we\n-            // don't introduce another module dependency. This is useful when running within\n-            // Bazel so that the AOT compiler does not introduce any module dependencies\n-            // which can break the strict dependency enforcement. (e.g. as in Google3)\n-            // Read more about this here: https://github.com/angular/angular/issues/25644\n-            const summary = this.unprocessedSymbolSummariesBySymbol.get(symbol);\n-            if (!summary || !summary.metadata || summary.metadata.__symbolic !== 'interface') {\n-              importAs = `${symbol.name}_${index}`;\n-              exportAs.push({symbol, exportAs: importAs});\n-            }\n-          }\n-        }\n-        return {\n-          __symbol: index,\n-          name: symbol.name,\n-          filePath: this.summaryResolver.toSummaryFileName(symbol.filePath, this.srcFileName),\n-          importAs: importAs\n-        };\n-      })\n-    });\n-    return {json, exportAs};\n-  }\n-\n-  private processValue(value: any, flags: SerializationFlags): any {\n-    return visitValue(value, this, flags);\n-  }\n-\n-  override visitOther(value: any, context: any): any {\n-    if (value instanceof StaticSymbol) {\n-      let baseSymbol = this.symbolResolver.getStaticSymbol(value.filePath, value.name);\n-      const index = this.visitStaticSymbol(baseSymbol, context);\n-      return {__symbol: index, members: value.members};\n-    }\n-  }\n-\n-  /**\n-   * Strip line and character numbers from ngsummaries.\n-   * Emitting them causes white spaces changes to retrigger upstream\n-   * recompilations in bazel.\n-   * TODO: find out a way to have line and character numbers in errors without\n-   * excessive recompilation in bazel.\n-   */\n-  override visitStringMap(map: {[key: string]: any}, context: any): any {\n-    if (map['__symbolic'] === 'resolved') {\n-      return visitValue(map['symbol'], this, context);\n-    }\n-    if (map['__symbolic'] === 'error') {\n-      delete map['line'];\n-      delete map['character'];\n-    }\n-    return super.visitStringMap(map, context);\n-  }\n-\n-  /**\n-   * Returns null if the options.resolveValue is true, and the summary for the symbol\n-   * resolved to a type or could not be resolved.\n-   */\n-  private visitStaticSymbol(baseSymbol: StaticSymbol, flags: SerializationFlags): number {\n-    let index: number|undefined|null = this.indexBySymbol.get(baseSymbol);\n-    let summary: Summary<StaticSymbol>|null = null;\n-    if (flags & SerializationFlags.ResolveValue &&\n-        this.summaryResolver.isLibraryFile(baseSymbol.filePath)) {\n-      if (this.unprocessedSymbolSummariesBySymbol.has(baseSymbol)) {\n-        // the summary for this symbol was already added\n-        // -> nothing to do.\n-        return index!;\n-      }\n-      summary = this.loadSummary(baseSymbol);\n-      if (summary && summary.metadata instanceof StaticSymbol) {\n-        // The summary is a reexport\n-        index = this.visitStaticSymbol(summary.metadata, flags);\n-        // reset the summary as it is just a reexport, so we don't want to store it.\n-        summary = null;\n-      }\n-    } else if (index != null) {\n-      // Note: == on purpose to compare with undefined!\n-      // No summary and the symbol is already added -> nothing to do.\n-      return index;\n-    }\n-    // Note: == on purpose to compare with undefined!\n-    if (index == null) {\n-      index = this.symbols.length;\n-      this.symbols.push(baseSymbol);\n-    }\n-    this.indexBySymbol.set(baseSymbol, index);\n-    if (summary) {\n-      this.addSummary(summary);\n-    }\n-    return index;\n-  }\n-\n-  private loadSummary(symbol: StaticSymbol): Summary<StaticSymbol>|null {\n-    let summary = this.summaryResolver.resolveSummary(symbol);\n-    if (!summary) {\n-      // some symbols might originate from a plain typescript library\n-      // that just exported .d.ts and .metadata.json files, i.e. where no summary\n-      // files were created.\n-      const resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\n-      if (resolvedSymbol) {\n-        summary = {symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata};\n-      }\n-    }\n-    return summary;\n-  }\n-}\n-\n-class ForJitSerializer {\n-  private data: Array<{\n-    summary: CompileTypeSummary,\n-    metadata: CompileNgModuleMetadata|CompileDirectiveMetadata|CompilePipeMetadata|\n-    CompileTypeMetadata|null,\n-    isLibrary: boolean\n-  }> = [];\n-\n-  constructor(\n-      private outputCtx: OutputContext, private symbolResolver: StaticSymbolResolver,\n-      private summaryResolver: SummaryResolver<StaticSymbol>) {}\n-\n-  addSourceType(\n-      summary: CompileTypeSummary,\n-      metadata: CompileNgModuleMetadata|CompileDirectiveMetadata|CompilePipeMetadata|\n-      CompileTypeMetadata) {\n-    this.data.push({summary, metadata, isLibrary: false});\n-  }\n-\n-  addLibType(summary: CompileTypeSummary) {\n-    this.data.push({summary, metadata: null, isLibrary: true});\n-  }\n-\n-  serialize(exportAsArr: {symbol: StaticSymbol, exportAs: string}[]): void {\n-    const exportAsBySymbol = new Map<StaticSymbol, string>();\n-    for (const {symbol, exportAs} of exportAsArr) {\n-      exportAsBySymbol.set(symbol, exportAs);\n-    }\n-    const ngModuleSymbols = new Set<StaticSymbol>();\n-\n-    for (const {summary, metadata, isLibrary} of this.data) {\n-      if (summary.summaryKind === CompileSummaryKind.NgModule) {\n-        // collect the symbols that refer to NgModule classes.\n-        // Note: we can't just rely on `summary.type.summaryKind` to determine this as\n-        // we don't add the summaries of all referenced symbols when we serialize type summaries.\n-        // See serializeSummaries for details.\n-        ngModuleSymbols.add(summary.type.reference);\n-        const modSummary = <CompileNgModuleSummary>summary;\n-        for (const mod of modSummary.modules) {\n-          ngModuleSymbols.add(mod.reference);\n-        }\n-      }\n-      if (!isLibrary) {\n-        const fnName = summaryForJitName(summary.type.reference.name);\n-        createSummaryForJitFunction(\n-            this.outputCtx, summary.type.reference,\n-            this.serializeSummaryWithDeps(summary, metadata!));\n-      }\n-    }\n-\n-    ngModuleSymbols.forEach((ngModuleSymbol) => {\n-      if (this.summaryResolver.isLibraryFile(ngModuleSymbol.filePath)) {\n-        let exportAs = exportAsBySymbol.get(ngModuleSymbol) || ngModuleSymbol.name;\n-        const jitExportAsName = summaryForJitName(exportAs);\n-        this.outputCtx.statements.push(o.variable(jitExportAsName)\n-                                           .set(this.serializeSummaryRef(ngModuleSymbol))\n-                                           .toDeclStmt(null, [o.StmtModifier.Exported]));\n-      }\n-    });\n-  }\n-\n-  private serializeSummaryWithDeps(\n-      summary: CompileTypeSummary,\n-      metadata: CompileNgModuleMetadata|CompileDirectiveMetadata|CompilePipeMetadata|\n-      CompileTypeMetadata): o.Expression {\n-    const expressions: o.Expression[] = [this.serializeSummary(summary)];\n-    let providers: CompileProviderMetadata[] = [];\n-    if (metadata instanceof CompileNgModuleMetadata) {\n-      expressions.push(...\n-                       // For directives / pipes, we only add the declared ones,\n-                       // and rely on transitively importing NgModules to get the transitive\n-                       // summaries.\n-                       metadata.declaredDirectives.concat(metadata.declaredPipes)\n-                           .map(type => type.reference)\n-                           // For modules,\n-                           // we also add the summaries for modules\n-                           // from libraries.\n-                           // This is ok as we produce reexports for all transitive modules.\n-                           .concat(metadata.transitiveModule.modules.map(type => type.reference)\n-                                       .filter(ref => ref !== metadata.type.reference))\n-                           .map((ref) => this.serializeSummaryRef(ref)));\n-      // Note: We don't use `NgModuleSummary.providers`, as that one is transitive,\n-      // and we already have transitive modules.\n-      providers = metadata.providers;\n-    } else if (summary.summaryKind === CompileSummaryKind.Directive) {\n-      const dirSummary = <CompileDirectiveSummary>summary;\n-      providers = dirSummary.providers.concat(dirSummary.viewProviders);\n-    }\n-    // Note: We can't just refer to the `ngsummary.ts` files for `useClass` providers (as we do for\n-    // declaredDirectives / declaredPipes), as we allow\n-    // providers without ctor arguments to skip the `@Injectable` decorator,\n-    // i.e. we didn't generate .ngsummary.ts files for these.\n-    expressions.push(\n-        ...providers.filter(provider => !!provider.useClass).map(provider => this.serializeSummary({\n-          summaryKind: CompileSummaryKind.Injectable,\n-          type: provider.useClass\n-        } as CompileTypeSummary)));\n-    return o.literalArr(expressions);\n-  }\n-\n-  private serializeSummaryRef(typeSymbol: StaticSymbol): o.Expression {\n-    const jitImportedSymbol = this.symbolResolver.getStaticSymbol(\n-        summaryForJitFileName(typeSymbol.filePath), summaryForJitName(typeSymbol.name));\n-    return this.outputCtx.importExpr(jitImportedSymbol);\n-  }\n-\n-  private serializeSummary(data: {[key: string]: any}): o.Expression {\n-    const outputCtx = this.outputCtx;\n-\n-    class Transformer implements ValueVisitor {\n-      visitArray(arr: any[], context: any): any {\n-        return o.literalArr(arr.map(entry => visitValue(entry, this, context)));\n-      }\n-      visitStringMap(map: {[key: string]: any}, context: any): any {\n-        return new o.LiteralMapExpr(Object.keys(map).map(\n-            (key) => new o.LiteralMapEntry(key, visitValue(map[key], this, context), false)));\n-      }\n-      visitPrimitive(value: any, context: any): any {\n-        return o.literal(value);\n-      }\n-      visitOther(value: any, context: any): any {\n-        if (value instanceof StaticSymbol) {\n-          return outputCtx.importExpr(value);\n-        } else {\n-          throw new Error(`Illegal State: Encountered value ${value}`);\n-        }\n-      }\n-    }\n-\n-    return visitValue(data, new Transformer(), null);\n-  }\n-}\n-\n-class FromJsonDeserializer extends ValueTransformer {\n-  // TODO(issue/24571): remove '!'.\n-  private symbols!: StaticSymbol[];\n-\n-  constructor(\n-      private symbolCache: StaticSymbolCache,\n-      private summaryResolver: SummaryResolver<StaticSymbol>) {\n-    super();\n-  }\n-\n-  deserialize(libraryFileName: string, json: string): {\n-    moduleName: string|null,\n-    summaries: Summary<StaticSymbol>[],\n-    importAs: {symbol: StaticSymbol, importAs: StaticSymbol}[]\n-  } {\n-    const data = JSON.parse(json) as {moduleName: string | null, summaries: any[], symbols: any[]};\n-    const allImportAs: {symbol: StaticSymbol, importAs: StaticSymbol}[] = [];\n-    this.symbols = data.symbols.map(\n-        (serializedSymbol) => this.symbolCache.get(\n-            this.summaryResolver.fromSummaryFileName(serializedSymbol.filePath, libraryFileName),\n-            serializedSymbol.name));\n-    data.symbols.forEach((serializedSymbol, index) => {\n-      const symbol = this.symbols[index];\n-      const importAs = serializedSymbol.importAs;\n-      if (typeof importAs === 'number') {\n-        allImportAs.push({symbol, importAs: this.symbols[importAs]});\n-      } else if (typeof importAs === 'string') {\n-        allImportAs.push(\n-            {symbol, importAs: this.symbolCache.get(ngfactoryFilePath(libraryFileName), importAs)});\n-      }\n-    });\n-    const summaries = visitValue(data.summaries, this, null) as Summary<StaticSymbol>[];\n-    return {moduleName: data.moduleName, summaries, importAs: allImportAs};\n-  }\n-\n-  override visitStringMap(map: {[key: string]: any}, context: any): any {\n-    if ('__symbol' in map) {\n-      const baseSymbol = this.symbols[map['__symbol']];\n-      const members = map['members'];\n-      return members.length ? this.symbolCache.get(baseSymbol.filePath, baseSymbol.name, members) :\n-                              baseSymbol;\n-    } else {\n-      return super.visitStringMap(map, context);\n-    }\n-  }\n-}\n-\n-function isCall(metadata: any): boolean {\n-  return metadata && metadata.__symbolic === 'call';\n-}\n-\n-function isFunctionCall(metadata: any): boolean {\n-  return isCall(metadata) && unwrapResolvedMetadata(metadata.expression) instanceof StaticSymbol;\n-}\n-\n-function isMethodCallOnVariable(metadata: any): boolean {\n-  return isCall(metadata) && metadata.expression && metadata.expression.__symbolic === 'select' &&\n-      unwrapResolvedMetadata(metadata.expression.expression) instanceof StaticSymbol;\n-}"
        },
        {
            "sha": "bd5b48888b1b9e86c439269515bccf6bb34b8290",
            "filename": "packages/compiler/src/aot/util.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 75,
            "changes": 75,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Faot%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Faot%2Futil.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,75 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-const STRIP_SRC_FILE_SUFFIXES = /(\\.ts|\\.d\\.ts|\\.js|\\.jsx|\\.tsx)$/;\n-const GENERATED_FILE = /\\.ngfactory\\.|\\.ngsummary\\./;\n-const JIT_SUMMARY_FILE = /\\.ngsummary\\./;\n-const JIT_SUMMARY_NAME = /NgSummary$/;\n-\n-export function ngfactoryFilePath(filePath: string, forceSourceFile = false): string {\n-  const urlWithSuffix = splitTypescriptSuffix(filePath, forceSourceFile);\n-  return `${urlWithSuffix[0]}.ngfactory${normalizeGenFileSuffix(urlWithSuffix[1])}`;\n-}\n-\n-export function stripGeneratedFileSuffix(filePath: string): string {\n-  return filePath.replace(GENERATED_FILE, '.');\n-}\n-\n-export function isGeneratedFile(filePath: string): boolean {\n-  return GENERATED_FILE.test(filePath);\n-}\n-\n-export function splitTypescriptSuffix(path: string, forceSourceFile = false): string[] {\n-  if (path.endsWith('.d.ts')) {\n-    return [path.slice(0, -5), forceSourceFile ? '.ts' : '.d.ts'];\n-  }\n-\n-  const lastDot = path.lastIndexOf('.');\n-\n-  if (lastDot !== -1) {\n-    return [path.substring(0, lastDot), path.substring(lastDot)];\n-  }\n-\n-  return [path, ''];\n-}\n-\n-export function normalizeGenFileSuffix(srcFileSuffix: string): string {\n-  return srcFileSuffix === '.tsx' ? '.ts' : srcFileSuffix;\n-}\n-\n-export function summaryFileName(fileName: string): string {\n-  const fileNameWithoutSuffix = fileName.replace(STRIP_SRC_FILE_SUFFIXES, '');\n-  return `${fileNameWithoutSuffix}.ngsummary.json`;\n-}\n-\n-export function summaryForJitFileName(fileName: string, forceSourceFile = false): string {\n-  const urlWithSuffix = splitTypescriptSuffix(stripGeneratedFileSuffix(fileName), forceSourceFile);\n-  return `${urlWithSuffix[0]}.ngsummary${urlWithSuffix[1]}`;\n-}\n-\n-export function stripSummaryForJitFileSuffix(filePath: string): string {\n-  return filePath.replace(JIT_SUMMARY_FILE, '.');\n-}\n-\n-export function summaryForJitName(symbolName: string): string {\n-  return `${symbolName}NgSummary`;\n-}\n-\n-export function stripSummaryForJitNameSuffix(symbolName: string): string {\n-  return symbolName.replace(JIT_SUMMARY_NAME, '');\n-}\n-\n-const LOWERED_SYMBOL = /\\u0275\\d+/;\n-\n-export function isLoweredSymbol(name: string) {\n-  return LOWERED_SYMBOL.test(name);\n-}\n-\n-export function createLoweredSymbol(id: number): string {\n-  return `\\u0275${id}`;\n-}"
        },
        {
            "sha": "f24046ab4dc7f6d786a188eb4943162601673e45",
            "filename": "packages/compiler/src/compile_metadata.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 755,
            "changes": 755,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fcompile_metadata.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fcompile_metadata.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fcompile_metadata.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,755 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {StaticSymbol} from './aot/static_symbol';\n-import {ChangeDetectionStrategy, SchemaMetadata, Type, ViewEncapsulation} from './core';\n-import {LifecycleHooks} from './lifecycle_reflector';\n-import {ParseTreeResult as HtmlParseTreeResult} from './ml_parser/parser';\n-import {CompileIdentifierMetadata, identifierName, sanitizeIdentifier} from './parse_util';\n-import {splitAtColon} from './util';\n-\n-// group 0: \"[prop] or (event) or @trigger\"\n-// group 1: \"prop\" from \"[prop]\"\n-// group 2: \"event\" from \"(event)\"\n-// group 3: \"@trigger\" from \"@trigger\"\n-const HOST_REG_EXP = /^(?:(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\)))|(\\@[-\\w]+)$/;\n-\n-export function viewClassName(compType: any, embeddedTemplateIndex: number): string {\n-  return `View_${identifierName({reference: compType})}_${embeddedTemplateIndex}`;\n-}\n-\n-export function rendererTypeName(compType: any): string {\n-  return `RenderType_${identifierName({reference: compType})}`;\n-}\n-\n-export function hostViewClassName(compType: any): string {\n-  return `HostView_${identifierName({reference: compType})}`;\n-}\n-\n-export function componentFactoryName(compType: any): string {\n-  return `${identifierName({reference: compType})}NgFactory`;\n-}\n-\n-export interface ProxyClass {\n-  setDelegate(delegate: any): void;\n-}\n-\n-export enum CompileSummaryKind {\n-  Pipe,\n-  Directive,\n-  NgModule,\n-  Injectable\n-}\n-\n-/**\n- * A CompileSummary is the data needed to use a directive / pipe / module\n- * in other modules / components. However, this data is not enough to compile\n- * the directive / module itself.\n- */\n-export interface CompileTypeSummary {\n-  summaryKind: CompileSummaryKind|null;\n-  type: CompileTypeMetadata;\n-}\n-\n-export interface CompileDiDependencyMetadata {\n-  isAttribute?: boolean;\n-  isSelf?: boolean;\n-  isHost?: boolean;\n-  isSkipSelf?: boolean;\n-  isOptional?: boolean;\n-  isValue?: boolean;\n-  token?: CompileTokenMetadata;\n-  value?: any;\n-}\n-\n-export interface CompileProviderMetadata {\n-  token: CompileTokenMetadata;\n-  useClass?: CompileTypeMetadata;\n-  useValue?: any;\n-  useExisting?: CompileTokenMetadata;\n-  useFactory?: CompileFactoryMetadata;\n-  deps?: CompileDiDependencyMetadata[];\n-  multi?: boolean;\n-}\n-\n-export interface CompileFactoryMetadata extends CompileIdentifierMetadata {\n-  diDeps: CompileDiDependencyMetadata[];\n-  reference: any;\n-}\n-\n-export function tokenName(token: CompileTokenMetadata) {\n-  return token.value != null ? sanitizeIdentifier(token.value) : identifierName(token.identifier);\n-}\n-\n-export function tokenReference(token: CompileTokenMetadata) {\n-  if (token.identifier != null) {\n-    return token.identifier.reference;\n-  } else {\n-    return token.value;\n-  }\n-}\n-\n-export interface CompileTokenMetadata {\n-  value?: any;\n-  identifier?: CompileIdentifierMetadata|CompileTypeMetadata;\n-}\n-\n-export interface CompileInjectableMetadata {\n-  symbol: StaticSymbol;\n-  type: CompileTypeMetadata;\n-\n-  providedIn?: StaticSymbol;\n-\n-  useValue?: any;\n-  useClass?: StaticSymbol;\n-  useExisting?: StaticSymbol;\n-  useFactory?: StaticSymbol;\n-  deps?: any[];\n-}\n-\n-/**\n- * Metadata regarding compilation of a type.\n- */\n-export interface CompileTypeMetadata extends CompileIdentifierMetadata {\n-  diDeps: CompileDiDependencyMetadata[];\n-  lifecycleHooks: LifecycleHooks[];\n-  reference: any;\n-}\n-\n-export interface CompileQueryMetadata {\n-  selectors: Array<CompileTokenMetadata>;\n-  descendants: boolean;\n-  first: boolean;\n-  propertyName: string;\n-  read: CompileTokenMetadata;\n-  static?: boolean;\n-  emitDistinctChangesOnly?: boolean;\n-}\n-\n-/**\n- * Metadata about a stylesheet\n- */\n-export class CompileStylesheetMetadata {\n-  moduleUrl: string|null;\n-  styles: string[];\n-  styleUrls: string[];\n-  constructor(\n-      {moduleUrl, styles, styleUrls}:\n-          {moduleUrl?: string, styles?: string[], styleUrls?: string[]} = {}) {\n-    this.moduleUrl = moduleUrl || null;\n-    this.styles = _normalizeArray(styles);\n-    this.styleUrls = _normalizeArray(styleUrls);\n-  }\n-}\n-\n-/**\n- * Summary Metadata regarding compilation of a template.\n- */\n-export interface CompileTemplateSummary {\n-  ngContentSelectors: string[];\n-  encapsulation: ViewEncapsulation|null;\n-  styles: string[];\n-  animations: any[]|null;\n-}\n-\n-/**\n- * Metadata regarding compilation of a template.\n- */\n-export class CompileTemplateMetadata {\n-  encapsulation: ViewEncapsulation|null;\n-  template: string|null;\n-  templateUrl: string|null;\n-  htmlAst: HtmlParseTreeResult|null;\n-  isInline: boolean;\n-  styles: string[];\n-  styleUrls: string[];\n-  externalStylesheets: CompileStylesheetMetadata[];\n-  animations: any[];\n-  ngContentSelectors: string[];\n-  interpolation: [string, string]|null;\n-  preserveWhitespaces: boolean;\n-  constructor({\n-    encapsulation,\n-    template,\n-    templateUrl,\n-    htmlAst,\n-    styles,\n-    styleUrls,\n-    externalStylesheets,\n-    animations,\n-    ngContentSelectors,\n-    interpolation,\n-    isInline,\n-    preserveWhitespaces\n-  }: {\n-    encapsulation: ViewEncapsulation|null,\n-    template: string|null,\n-    templateUrl: string|null,\n-    htmlAst: HtmlParseTreeResult|null,\n-    styles: string[],\n-    styleUrls: string[],\n-    externalStylesheets: CompileStylesheetMetadata[],\n-    ngContentSelectors: string[],\n-    animations: any[],\n-    interpolation: [string, string]|null,\n-    isInline: boolean,\n-    preserveWhitespaces: boolean\n-  }) {\n-    this.encapsulation = encapsulation;\n-    this.template = template;\n-    this.templateUrl = templateUrl;\n-    this.htmlAst = htmlAst;\n-    this.styles = _normalizeArray(styles);\n-    this.styleUrls = _normalizeArray(styleUrls);\n-    this.externalStylesheets = _normalizeArray(externalStylesheets);\n-    this.animations = animations ? flatten(animations) : [];\n-    this.ngContentSelectors = ngContentSelectors || [];\n-    if (interpolation && interpolation.length != 2) {\n-      throw new Error(`'interpolation' should have a start and an end symbol.`);\n-    }\n-    this.interpolation = interpolation;\n-    this.isInline = isInline;\n-    this.preserveWhitespaces = preserveWhitespaces;\n-  }\n-\n-  toSummary(): CompileTemplateSummary {\n-    return {\n-      ngContentSelectors: this.ngContentSelectors,\n-      encapsulation: this.encapsulation,\n-      styles: this.styles,\n-      animations: this.animations\n-    };\n-  }\n-}\n-\n-export interface CompileEntryComponentMetadata {\n-  componentType: any;\n-  componentFactory: StaticSymbol|object;\n-}\n-\n-// Note: This should only use interfaces as nested data types\n-// as we need to be able to serialize this from/to JSON!\n-export interface CompileDirectiveSummary extends CompileTypeSummary {\n-  type: CompileTypeMetadata;\n-  isComponent: boolean;\n-  selector: string|null;\n-  exportAs: string|null;\n-  inputs: {[key: string]: string};\n-  outputs: {[key: string]: string};\n-  hostListeners: {[key: string]: string};\n-  hostProperties: {[key: string]: string};\n-  hostAttributes: {[key: string]: string};\n-  providers: CompileProviderMetadata[];\n-  viewProviders: CompileProviderMetadata[];\n-  queries: CompileQueryMetadata[];\n-  guards: {[key: string]: any};\n-  viewQueries: CompileQueryMetadata[];\n-  entryComponents: CompileEntryComponentMetadata[];\n-  changeDetection: ChangeDetectionStrategy|null;\n-  template: CompileTemplateSummary|null;\n-  componentViewType: StaticSymbol|ProxyClass|null;\n-  rendererType: StaticSymbol|object|null;\n-  componentFactory: StaticSymbol|object|null;\n-}\n-\n-/**\n- * Metadata regarding compilation of a directive.\n- */\n-export class CompileDirectiveMetadata {\n-  static create({\n-    isHost,\n-    type,\n-    isComponent,\n-    selector,\n-    exportAs,\n-    changeDetection,\n-    inputs,\n-    outputs,\n-    host,\n-    providers,\n-    viewProviders,\n-    queries,\n-    guards,\n-    viewQueries,\n-    entryComponents,\n-    template,\n-    componentViewType,\n-    rendererType,\n-    componentFactory\n-  }: {\n-    isHost: boolean,\n-    type: CompileTypeMetadata,\n-    isComponent: boolean,\n-    selector: string|null,\n-    exportAs: string|null,\n-    changeDetection: ChangeDetectionStrategy|null,\n-    inputs: string[],\n-    outputs: string[],\n-    host: {[key: string]: string},\n-    providers: CompileProviderMetadata[],\n-    viewProviders: CompileProviderMetadata[],\n-    queries: CompileQueryMetadata[],\n-    guards: {[key: string]: any};\n-    viewQueries: CompileQueryMetadata[],\n-    entryComponents: CompileEntryComponentMetadata[],\n-    template: CompileTemplateMetadata,\n-    componentViewType: StaticSymbol|ProxyClass|null,\n-    rendererType: StaticSymbol|object|null,\n-    componentFactory: StaticSymbol|object|null,\n-  }): CompileDirectiveMetadata {\n-    const hostListeners: {[key: string]: string} = {};\n-    const hostProperties: {[key: string]: string} = {};\n-    const hostAttributes: {[key: string]: string} = {};\n-    if (host != null) {\n-      Object.keys(host).forEach(key => {\n-        const value = host[key];\n-        const matches = key.match(HOST_REG_EXP);\n-        if (matches === null) {\n-          hostAttributes[key] = value;\n-        } else if (matches[1] != null) {\n-          hostProperties[matches[1]] = value;\n-        } else if (matches[2] != null) {\n-          hostListeners[matches[2]] = value;\n-        }\n-      });\n-    }\n-    const inputsMap: {[key: string]: string} = {};\n-    if (inputs != null) {\n-      inputs.forEach((bindConfig: string) => {\n-        // canonical syntax: `dirProp: elProp`\n-        // if there is no `:`, use dirProp = elProp\n-        const parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n-        inputsMap[parts[0]] = parts[1];\n-      });\n-    }\n-    const outputsMap: {[key: string]: string} = {};\n-    if (outputs != null) {\n-      outputs.forEach((bindConfig: string) => {\n-        // canonical syntax: `dirProp: elProp`\n-        // if there is no `:`, use dirProp = elProp\n-        const parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n-        outputsMap[parts[0]] = parts[1];\n-      });\n-    }\n-\n-    return new CompileDirectiveMetadata({\n-      isHost,\n-      type,\n-      isComponent: !!isComponent,\n-      selector,\n-      exportAs,\n-      changeDetection,\n-      inputs: inputsMap,\n-      outputs: outputsMap,\n-      hostListeners,\n-      hostProperties,\n-      hostAttributes,\n-      providers,\n-      viewProviders,\n-      queries,\n-      guards,\n-      viewQueries,\n-      entryComponents,\n-      template,\n-      componentViewType,\n-      rendererType,\n-      componentFactory,\n-    });\n-  }\n-  isHost: boolean;\n-  type: CompileTypeMetadata;\n-  isComponent: boolean;\n-  selector: string|null;\n-  exportAs: string|null;\n-  changeDetection: ChangeDetectionStrategy|null;\n-  inputs: {[key: string]: string};\n-  outputs: {[key: string]: string};\n-  hostListeners: {[key: string]: string};\n-  hostProperties: {[key: string]: string};\n-  hostAttributes: {[key: string]: string};\n-  providers: CompileProviderMetadata[];\n-  viewProviders: CompileProviderMetadata[];\n-  queries: CompileQueryMetadata[];\n-  guards: {[key: string]: any};\n-  viewQueries: CompileQueryMetadata[];\n-  entryComponents: CompileEntryComponentMetadata[];\n-\n-  template: CompileTemplateMetadata|null;\n-\n-  componentViewType: StaticSymbol|ProxyClass|null;\n-  rendererType: StaticSymbol|object|null;\n-  componentFactory: StaticSymbol|object|null;\n-\n-  constructor({\n-    isHost,\n-    type,\n-    isComponent,\n-    selector,\n-    exportAs,\n-    changeDetection,\n-    inputs,\n-    outputs,\n-    hostListeners,\n-    hostProperties,\n-    hostAttributes,\n-    providers,\n-    viewProviders,\n-    queries,\n-    guards,\n-    viewQueries,\n-    entryComponents,\n-    template,\n-    componentViewType,\n-    rendererType,\n-    componentFactory\n-  }: {\n-    isHost: boolean,\n-    type: CompileTypeMetadata,\n-    isComponent: boolean,\n-    selector: string|null,\n-    exportAs: string|null,\n-    changeDetection: ChangeDetectionStrategy|null,\n-    inputs: {[key: string]: string},\n-    outputs: {[key: string]: string},\n-    hostListeners: {[key: string]: string},\n-    hostProperties: {[key: string]: string},\n-    hostAttributes: {[key: string]: string},\n-    providers: CompileProviderMetadata[],\n-    viewProviders: CompileProviderMetadata[],\n-    queries: CompileQueryMetadata[],\n-    guards: {[key: string]: any},\n-    viewQueries: CompileQueryMetadata[],\n-    entryComponents: CompileEntryComponentMetadata[],\n-    template: CompileTemplateMetadata|null,\n-    componentViewType: StaticSymbol|ProxyClass|null,\n-    rendererType: StaticSymbol|object|null,\n-    componentFactory: StaticSymbol|object|null,\n-  }) {\n-    this.isHost = !!isHost;\n-    this.type = type;\n-    this.isComponent = isComponent;\n-    this.selector = selector;\n-    this.exportAs = exportAs;\n-    this.changeDetection = changeDetection;\n-    this.inputs = inputs;\n-    this.outputs = outputs;\n-    this.hostListeners = hostListeners;\n-    this.hostProperties = hostProperties;\n-    this.hostAttributes = hostAttributes;\n-    this.providers = _normalizeArray(providers);\n-    this.viewProviders = _normalizeArray(viewProviders);\n-    this.queries = _normalizeArray(queries);\n-    this.guards = guards;\n-    this.viewQueries = _normalizeArray(viewQueries);\n-    this.entryComponents = _normalizeArray(entryComponents);\n-    this.template = template;\n-\n-    this.componentViewType = componentViewType;\n-    this.rendererType = rendererType;\n-    this.componentFactory = componentFactory;\n-  }\n-\n-  toSummary(): CompileDirectiveSummary {\n-    return {\n-      summaryKind: CompileSummaryKind.Directive,\n-      type: this.type,\n-      isComponent: this.isComponent,\n-      selector: this.selector,\n-      exportAs: this.exportAs,\n-      inputs: this.inputs,\n-      outputs: this.outputs,\n-      hostListeners: this.hostListeners,\n-      hostProperties: this.hostProperties,\n-      hostAttributes: this.hostAttributes,\n-      providers: this.providers,\n-      viewProviders: this.viewProviders,\n-      queries: this.queries,\n-      guards: this.guards,\n-      viewQueries: this.viewQueries,\n-      entryComponents: this.entryComponents,\n-      changeDetection: this.changeDetection,\n-      template: this.template && this.template.toSummary(),\n-      componentViewType: this.componentViewType,\n-      rendererType: this.rendererType,\n-      componentFactory: this.componentFactory\n-    };\n-  }\n-}\n-\n-export interface CompilePipeSummary extends CompileTypeSummary {\n-  type: CompileTypeMetadata;\n-  name: string;\n-  pure: boolean;\n-}\n-\n-export class CompilePipeMetadata {\n-  type: CompileTypeMetadata;\n-  name: string;\n-  pure: boolean;\n-\n-  constructor({type, name, pure}: {\n-    type: CompileTypeMetadata,\n-    name: string,\n-    pure: boolean,\n-  }) {\n-    this.type = type;\n-    this.name = name;\n-    this.pure = !!pure;\n-  }\n-\n-  toSummary(): CompilePipeSummary {\n-    return {\n-      summaryKind: CompileSummaryKind.Pipe,\n-      type: this.type,\n-      name: this.name,\n-      pure: this.pure\n-    };\n-  }\n-}\n-\n-// Note: This should only use interfaces as nested data types\n-// as we need to be able to serialize this from/to JSON!\n-export interface CompileNgModuleSummary extends CompileTypeSummary {\n-  type: CompileTypeMetadata;\n-\n-  // Note: This is transitive over the exported modules.\n-  exportedDirectives: CompileIdentifierMetadata[];\n-  // Note: This is transitive over the exported modules.\n-  exportedPipes: CompileIdentifierMetadata[];\n-\n-  // Note: This is transitive.\n-  entryComponents: CompileEntryComponentMetadata[];\n-  // Note: This is transitive.\n-  providers: {provider: CompileProviderMetadata, module: CompileIdentifierMetadata}[];\n-  // Note: This is transitive.\n-  modules: CompileTypeMetadata[];\n-}\n-\n-export class CompileShallowModuleMetadata {\n-  // TODO(issue/24571): remove '!'.\n-  type!: CompileTypeMetadata;\n-\n-  rawExports: any;\n-  rawImports: any;\n-  rawProviders: any;\n-}\n-\n-/**\n- * Metadata regarding compilation of a module.\n- */\n-export class CompileNgModuleMetadata {\n-  type: CompileTypeMetadata;\n-  declaredDirectives: CompileIdentifierMetadata[];\n-  exportedDirectives: CompileIdentifierMetadata[];\n-  declaredPipes: CompileIdentifierMetadata[];\n-\n-  exportedPipes: CompileIdentifierMetadata[];\n-  entryComponents: CompileEntryComponentMetadata[];\n-  bootstrapComponents: CompileIdentifierMetadata[];\n-  providers: CompileProviderMetadata[];\n-\n-  importedModules: CompileNgModuleSummary[];\n-  exportedModules: CompileNgModuleSummary[];\n-  schemas: SchemaMetadata[];\n-  id: string|null;\n-\n-  transitiveModule: TransitiveCompileNgModuleMetadata;\n-\n-  constructor({\n-    type,\n-    providers,\n-    declaredDirectives,\n-    exportedDirectives,\n-    declaredPipes,\n-    exportedPipes,\n-    entryComponents,\n-    bootstrapComponents,\n-    importedModules,\n-    exportedModules,\n-    schemas,\n-    transitiveModule,\n-    id\n-  }: {\n-    type: CompileTypeMetadata,\n-    providers: CompileProviderMetadata[],\n-    declaredDirectives: CompileIdentifierMetadata[],\n-    exportedDirectives: CompileIdentifierMetadata[],\n-    declaredPipes: CompileIdentifierMetadata[],\n-    exportedPipes: CompileIdentifierMetadata[],\n-    entryComponents: CompileEntryComponentMetadata[],\n-    bootstrapComponents: CompileIdentifierMetadata[],\n-    importedModules: CompileNgModuleSummary[],\n-    exportedModules: CompileNgModuleSummary[],\n-    transitiveModule: TransitiveCompileNgModuleMetadata,\n-    schemas: SchemaMetadata[],\n-    id: string|null\n-  }) {\n-    this.type = type || null;\n-    this.declaredDirectives = _normalizeArray(declaredDirectives);\n-    this.exportedDirectives = _normalizeArray(exportedDirectives);\n-    this.declaredPipes = _normalizeArray(declaredPipes);\n-    this.exportedPipes = _normalizeArray(exportedPipes);\n-    this.providers = _normalizeArray(providers);\n-    this.entryComponents = _normalizeArray(entryComponents);\n-    this.bootstrapComponents = _normalizeArray(bootstrapComponents);\n-    this.importedModules = _normalizeArray(importedModules);\n-    this.exportedModules = _normalizeArray(exportedModules);\n-    this.schemas = _normalizeArray(schemas);\n-    this.id = id || null;\n-    this.transitiveModule = transitiveModule || null;\n-  }\n-\n-  toSummary(): CompileNgModuleSummary {\n-    const module = this.transitiveModule!;\n-    return {\n-      summaryKind: CompileSummaryKind.NgModule,\n-      type: this.type,\n-      entryComponents: module.entryComponents,\n-      providers: module.providers,\n-      modules: module.modules,\n-      exportedDirectives: module.exportedDirectives,\n-      exportedPipes: module.exportedPipes\n-    };\n-  }\n-}\n-\n-export class TransitiveCompileNgModuleMetadata {\n-  directivesSet = new Set<any>();\n-  directives: CompileIdentifierMetadata[] = [];\n-  exportedDirectivesSet = new Set<any>();\n-  exportedDirectives: CompileIdentifierMetadata[] = [];\n-  pipesSet = new Set<any>();\n-  pipes: CompileIdentifierMetadata[] = [];\n-  exportedPipesSet = new Set<any>();\n-  exportedPipes: CompileIdentifierMetadata[] = [];\n-  modulesSet = new Set<any>();\n-  modules: CompileTypeMetadata[] = [];\n-  entryComponentsSet = new Set<any>();\n-  entryComponents: CompileEntryComponentMetadata[] = [];\n-\n-  providers: {provider: CompileProviderMetadata, module: CompileIdentifierMetadata}[] = [];\n-\n-  addProvider(provider: CompileProviderMetadata, module: CompileIdentifierMetadata) {\n-    this.providers.push({provider: provider, module: module});\n-  }\n-\n-  addDirective(id: CompileIdentifierMetadata) {\n-    if (!this.directivesSet.has(id.reference)) {\n-      this.directivesSet.add(id.reference);\n-      this.directives.push(id);\n-    }\n-  }\n-  addExportedDirective(id: CompileIdentifierMetadata) {\n-    if (!this.exportedDirectivesSet.has(id.reference)) {\n-      this.exportedDirectivesSet.add(id.reference);\n-      this.exportedDirectives.push(id);\n-    }\n-  }\n-  addPipe(id: CompileIdentifierMetadata) {\n-    if (!this.pipesSet.has(id.reference)) {\n-      this.pipesSet.add(id.reference);\n-      this.pipes.push(id);\n-    }\n-  }\n-  addExportedPipe(id: CompileIdentifierMetadata) {\n-    if (!this.exportedPipesSet.has(id.reference)) {\n-      this.exportedPipesSet.add(id.reference);\n-      this.exportedPipes.push(id);\n-    }\n-  }\n-  addModule(id: CompileTypeMetadata) {\n-    if (!this.modulesSet.has(id.reference)) {\n-      this.modulesSet.add(id.reference);\n-      this.modules.push(id);\n-    }\n-  }\n-  addEntryComponent(ec: CompileEntryComponentMetadata) {\n-    if (!this.entryComponentsSet.has(ec.componentType)) {\n-      this.entryComponentsSet.add(ec.componentType);\n-      this.entryComponents.push(ec);\n-    }\n-  }\n-}\n-\n-function _normalizeArray(obj: any[]|undefined|null): any[] {\n-  return obj || [];\n-}\n-\n-export class ProviderMeta {\n-  token: any;\n-  useClass: Type|null;\n-  useValue: any;\n-  useExisting: any;\n-  useFactory: Function|null;\n-  dependencies: Object[]|null;\n-  multi: boolean;\n-\n-  constructor(token: any, {useClass, useValue, useExisting, useFactory, deps, multi}: {\n-    useClass?: Type,\n-    useValue?: any,\n-    useExisting?: any,\n-    useFactory?: Function|null,\n-    deps?: Object[]|null,\n-    multi?: boolean\n-  }) {\n-    this.token = token;\n-    this.useClass = useClass || null;\n-    this.useValue = useValue;\n-    this.useExisting = useExisting;\n-    this.useFactory = useFactory || null;\n-    this.dependencies = deps || null;\n-    this.multi = !!multi;\n-  }\n-}\n-\n-export function flatten<T>(list: Array<T|T[]>): T[] {\n-  return list.reduce((flat: any[], item: T|T[]): T[] => {\n-    const flatItem = Array.isArray(item) ? flatten(item) : item;\n-    return (<T[]>flat).concat(flatItem);\n-  }, []);\n-}\n-\n-function jitSourceUrl(url: string) {\n-  // Note: We need 3 \"/\" so that ng shows up as a separate domain\n-  // in the chrome dev tools.\n-  return url.replace(/(\\w+:\\/\\/[\\w:-]+)?(\\/+)?/, 'ng:///');\n-}\n-\n-export function templateSourceUrl(\n-    ngModuleType: CompileIdentifierMetadata, compMeta: {type: CompileIdentifierMetadata},\n-    templateMeta: {isInline: boolean, templateUrl: string|null}) {\n-  let url: string;\n-  if (templateMeta.isInline) {\n-    if (compMeta.type.reference instanceof StaticSymbol) {\n-      // Note: a .ts file might contain multiple components with inline templates,\n-      // so we need to give them unique urls, as these will be used for sourcemaps.\n-      url = `${compMeta.type.reference.filePath}.${compMeta.type.reference.name}.html`;\n-    } else {\n-      url = `${identifierName(ngModuleType)}/${identifierName(compMeta.type)}.html`;\n-    }\n-  } else {\n-    url = templateMeta.templateUrl!;\n-  }\n-  return compMeta.type.reference instanceof StaticSymbol ? url : jitSourceUrl(url);\n-}\n-\n-export function sharedStylesheetJitUrl(meta: CompileStylesheetMetadata, id: number) {\n-  const pathParts = meta.moduleUrl!.split(/\\/\\\\/g);\n-  const baseName = pathParts[pathParts.length - 1];\n-  return jitSourceUrl(`css/${id}${baseName}.ngstyle.js`);\n-}\n-\n-export function ngModuleJitUrl(moduleMeta: CompileNgModuleMetadata): string {\n-  return jitSourceUrl(`${identifierName(moduleMeta.type)}/module.ngfactory.js`);\n-}\n-\n-export function templateJitUrl(\n-    ngModuleType: CompileIdentifierMetadata, compMeta: CompileDirectiveMetadata): string {\n-  return jitSourceUrl(\n-      `${identifierName(ngModuleType)}/${identifierName(compMeta.type)}.ngfactory.js`);\n-}"
        },
        {
            "sha": "251b5db7ab6410dddd495190e71ecea0ed721d65",
            "filename": "packages/compiler/src/compile_reflector.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 25,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fcompile_reflector.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fcompile_reflector.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fcompile_reflector.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,25 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Component} from './core';\n-import * as o from './output/output_ast';\n-\n-/**\n- * Provides access to reflection data about symbols that the compiler needs.\n- */\n-export abstract class CompileReflector {\n-  abstract parameters(typeOrFunc: /*Type*/ any): any[][];\n-  abstract annotations(typeOrFunc: /*Type*/ any): any[];\n-  abstract shallowAnnotations(typeOrFunc: /*Type*/ any): any[];\n-  abstract tryAnnotations(typeOrFunc: /*Type*/ any): any[];\n-  abstract propMetadata(typeOrFunc: /*Type*/ any): {[key: string]: any[]};\n-  abstract hasLifecycleHook(type: any, lcProperty: string): boolean;\n-  abstract guards(typeOrFunc: /* Type */ any): {[key: string]: any};\n-  abstract componentModuleUrl(type: /*Type*/ any, cmpMetadata: Component): string;\n-  abstract resolveExternalReference(ref: o.ExternalReference): any;\n-}"
        },
        {
            "sha": "cc5f99950c8c29ffa72b18ee610a1eb3f5df0ba1",
            "filename": "packages/compiler/src/compiler.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 28,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fcompiler.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -35,40 +35,17 @@ export {CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, SchemaMetadata} from './core';\n export {core};\n \n export * from './version';\n-export * from './template_parser/template_ast';\n export {CompilerConfig, preserveWhitespacesDefault} from './config';\n-export * from './compile_metadata';\n-export * from './aot/compiler_factory';\n-export * from './aot/compiler';\n-export * from './aot/generated_file';\n-export * from './aot/compiler_options';\n-export * from './aot/compiler_host';\n-export * from './aot/formatted_error';\n-export * from './aot/partial_module';\n-export * from './aot/static_reflector';\n-export * from './aot/static_symbol';\n-export * from './aot/static_symbol_resolver';\n-export * from './aot/summary_resolver';\n-export {isLoweredSymbol, createLoweredSymbol} from './aot/util';\n export * from './ast_path';\n-export * from './summary_resolver';\n export {Identifiers} from './identifiers';\n-export {JitCompiler} from './jit/compiler';\n-export * from './compile_reflector';\n-export * from './url_resolver';\n export * from './resource_loader';\n export {ConstantPool} from './constant_pool';\n-export {DirectiveResolver} from './directive_resolver';\n-export {PipeResolver} from './pipe_resolver';\n-export {NgModuleResolver} from './ng_module_resolver';\n export {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './ml_parser/interpolation_config';\n export * from './schema/element_schema_registry';\n export * from './i18n/index';\n-export * from './directive_normalizer';\n export * from './expression_parser/ast';\n export * from './expression_parser/lexer';\n export * from './expression_parser/parser';\n-export * from './metadata_resolver';\n export * from './ml_parser/ast';\n export * from './ml_parser/html_parser';\n export * from './ml_parser/html_tags';\n@@ -77,17 +54,12 @@ export * from './ml_parser/tags';\n export {ParseTreeResult, TreeError} from './ml_parser/parser';\n export {LexerRange} from './ml_parser/lexer';\n export * from './ml_parser/xml_parser';\n-export {NgModuleCompiler} from './ng_module_compiler';\n export {ArrayType, AssertNotNull, DYNAMIC_TYPE, BinaryOperator, BinaryOperatorExpr, BuiltinMethod, BuiltinType, BuiltinTypeName, BuiltinVar, CastExpr, ClassField, ClassMethod, ClassStmt, CommaExpr, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionType, ExpressionVisitor, ExternalExpr, ExternalReference, literalMap, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, NONE_TYPE, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, StatementVisitor, TaggedTemplateExpr, TemplateLiteral, TemplateLiteralElement, ThrowStmt, TryCatchStmt, Type, TypeVisitor, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr, StmtModifier, Statement, STRING_TYPE, TypeofExpr, collectExternalReferences, jsDocComment, leadingComment, LeadingComment, JSDocComment, UnaryOperator, UnaryOperatorExpr, LocalizedString} from './output/output_ast';\n export {EmitterVisitorContext} from './output/abstract_emitter';\n export {JitEvaluator} from './output/output_jit';\n-export * from './output/ts_emitter';\n export * from './parse_util';\n export * from './schema/dom_element_schema_registry';\n export * from './selector';\n-export * from './style_compiler';\n-export * from './template_parser/template_parser';\n-export {ViewCompiler} from './view_compiler/view_compiler';\n export {Version} from './util';\n export {SourceMap} from './output/source_map';\n export * from './injectable_compiler_2';"
        },
        {
            "sha": "3976338d81224d4f2a8041e7a752e5473aa3aeff",
            "filename": "packages/compiler/src/directive_normalizer.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 329,
            "changes": 329,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fdirective_normalizer.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fdirective_normalizer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fdirective_normalizer.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,329 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompileDirectiveMetadata, CompileStylesheetMetadata, CompileTemplateMetadata, templateSourceUrl} from './compile_metadata';\n-import {CompilerConfig, preserveWhitespacesDefault} from './config';\n-import {ViewEncapsulation} from './core';\n-import * as html from './ml_parser/ast';\n-import {HtmlParser} from './ml_parser/html_parser';\n-import {InterpolationConfig} from './ml_parser/interpolation_config';\n-import {ParseTreeResult as HtmlParseTreeResult} from './ml_parser/parser';\n-import {syntaxError} from './parse_util';\n-import {ResourceLoader} from './resource_loader';\n-import {extractStyleUrls, isStyleUrlResolvable} from './style_url_resolver';\n-import {PreparsedElementType, preparseElement} from './template_parser/template_preparser';\n-import {UrlResolver} from './url_resolver';\n-import {isDefined, stringify, SyncAsync} from './util';\n-\n-export interface PrenormalizedTemplateMetadata {\n-  ngModuleType: any;\n-  componentType: any;\n-  moduleUrl: string;\n-  template: string|null;\n-  templateUrl: string|null;\n-  styles: string[];\n-  styleUrls: string[];\n-  interpolation: [string, string]|null;\n-  encapsulation: ViewEncapsulation|null;\n-  animations: any[];\n-  preserveWhitespaces: boolean|null;\n-}\n-\n-export class DirectiveNormalizer {\n-  private _resourceLoaderCache = new Map<string, SyncAsync<string>>();\n-\n-  constructor(\n-      private _resourceLoader: ResourceLoader, private _urlResolver: UrlResolver,\n-      private _htmlParser: HtmlParser, private _config: CompilerConfig) {}\n-\n-  clearCache(): void {\n-    this._resourceLoaderCache.clear();\n-  }\n-\n-  clearCacheFor(normalizedDirective: CompileDirectiveMetadata): void {\n-    if (!normalizedDirective.isComponent) {\n-      return;\n-    }\n-    const template = normalizedDirective.template !;\n-    this._resourceLoaderCache.delete(template.templateUrl!);\n-    template.externalStylesheets.forEach((stylesheet) => {\n-      this._resourceLoaderCache.delete(stylesheet.moduleUrl!);\n-    });\n-  }\n-\n-  private _fetch(url: string): SyncAsync<string> {\n-    let result = this._resourceLoaderCache.get(url);\n-    if (!result) {\n-      result = this._resourceLoader.get(url);\n-      this._resourceLoaderCache.set(url, result);\n-    }\n-    return result;\n-  }\n-\n-  normalizeTemplate(prenormData: PrenormalizedTemplateMetadata):\n-      SyncAsync<CompileTemplateMetadata> {\n-    if (isDefined(prenormData.template)) {\n-      if (isDefined(prenormData.templateUrl)) {\n-        throw syntaxError(`'${\n-            stringify(prenormData\n-                          .componentType)}' component cannot define both template and templateUrl`);\n-      }\n-      if (typeof prenormData.template !== 'string') {\n-        throw syntaxError(`The template specified for component ${\n-            stringify(prenormData.componentType)} is not a string`);\n-      }\n-    } else if (isDefined(prenormData.templateUrl)) {\n-      if (typeof prenormData.templateUrl !== 'string') {\n-        throw syntaxError(`The templateUrl specified for component ${\n-            stringify(prenormData.componentType)} is not a string`);\n-      }\n-    } else {\n-      throw syntaxError(\n-          `No template specified for component ${stringify(prenormData.componentType)}`);\n-    }\n-\n-    if (isDefined(prenormData.preserveWhitespaces) &&\n-        typeof prenormData.preserveWhitespaces !== 'boolean') {\n-      throw syntaxError(`The preserveWhitespaces option for component ${\n-          stringify(prenormData.componentType)} must be a boolean`);\n-    }\n-\n-    return SyncAsync.then(\n-        this._preParseTemplate(prenormData),\n-        (preparsedTemplate) => this._normalizeTemplateMetadata(prenormData, preparsedTemplate));\n-  }\n-\n-  private _preParseTemplate(prenomData: PrenormalizedTemplateMetadata):\n-      SyncAsync<PreparsedTemplate> {\n-    let template: SyncAsync<string>;\n-    let templateUrl: string;\n-    if (prenomData.template != null) {\n-      template = prenomData.template;\n-      templateUrl = prenomData.moduleUrl;\n-    } else {\n-      templateUrl = this._urlResolver.resolve(prenomData.moduleUrl, prenomData.templateUrl!);\n-      template = this._fetch(templateUrl);\n-    }\n-    return SyncAsync.then(\n-        template, (template) => this._preparseLoadedTemplate(prenomData, template, templateUrl));\n-  }\n-\n-  private _preparseLoadedTemplate(\n-      prenormData: PrenormalizedTemplateMetadata, template: string,\n-      templateAbsUrl: string): PreparsedTemplate {\n-    const isInline = !!prenormData.template;\n-    const interpolationConfig = InterpolationConfig.fromArray(prenormData.interpolation!);\n-    const templateUrl = templateSourceUrl(\n-        {reference: prenormData.ngModuleType}, {type: {reference: prenormData.componentType}},\n-        {isInline, templateUrl: templateAbsUrl});\n-    const rootNodesAndErrors = this._htmlParser.parse(\n-        template, templateUrl, {tokenizeExpansionForms: true, interpolationConfig});\n-    if (rootNodesAndErrors.errors.length > 0) {\n-      const errorString = rootNodesAndErrors.errors.join('\\n');\n-      throw syntaxError(`Template parse errors:\\n${errorString}`);\n-    }\n-\n-    const templateMetadataStyles = this._normalizeStylesheet(new CompileStylesheetMetadata(\n-        {styles: prenormData.styles, moduleUrl: prenormData.moduleUrl}));\n-\n-    const visitor = new TemplatePreparseVisitor();\n-    html.visitAll(visitor, rootNodesAndErrors.rootNodes);\n-    const templateStyles = this._normalizeStylesheet(new CompileStylesheetMetadata(\n-        {styles: visitor.styles, styleUrls: visitor.styleUrls, moduleUrl: templateAbsUrl}));\n-\n-    const styles = templateMetadataStyles.styles.concat(templateStyles.styles);\n-\n-    const inlineStyleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);\n-    const styleUrls = this\n-                          ._normalizeStylesheet(new CompileStylesheetMetadata(\n-                              {styleUrls: prenormData.styleUrls, moduleUrl: prenormData.moduleUrl}))\n-                          .styleUrls;\n-    return {\n-      template,\n-      templateUrl: templateAbsUrl,\n-      isInline,\n-      htmlAst: rootNodesAndErrors,\n-      styles,\n-      inlineStyleUrls,\n-      styleUrls,\n-      ngContentSelectors: visitor.ngContentSelectors,\n-    };\n-  }\n-\n-  private _normalizeTemplateMetadata(\n-      prenormData: PrenormalizedTemplateMetadata,\n-      preparsedTemplate: PreparsedTemplate): SyncAsync<CompileTemplateMetadata> {\n-    return SyncAsync.then(\n-        this._loadMissingExternalStylesheets(\n-            preparsedTemplate.styleUrls.concat(preparsedTemplate.inlineStyleUrls)),\n-        (externalStylesheets) => this._normalizeLoadedTemplateMetadata(\n-            prenormData, preparsedTemplate, externalStylesheets));\n-  }\n-\n-  private _normalizeLoadedTemplateMetadata(\n-      prenormData: PrenormalizedTemplateMetadata, preparsedTemplate: PreparsedTemplate,\n-      stylesheets: Map<string, CompileStylesheetMetadata>): CompileTemplateMetadata {\n-    // Algorithm:\n-    // - produce exactly 1 entry per original styleUrl in\n-    // CompileTemplateMetadata.externalStylesheets with all styles inlined\n-    // - inline all styles that are referenced by the template into CompileTemplateMetadata.styles.\n-    // Reason: be able to determine how many stylesheets there are even without loading\n-    // the template nor the stylesheets, so we can create a stub for TypeScript always synchronously\n-    // (as resource loading may be async)\n-\n-    const styles = [...preparsedTemplate.styles];\n-    this._inlineStyles(preparsedTemplate.inlineStyleUrls, stylesheets, styles);\n-    const styleUrls = preparsedTemplate.styleUrls;\n-\n-    const externalStylesheets = styleUrls.map(styleUrl => {\n-      const stylesheet = stylesheets.get(styleUrl)!;\n-      const styles = [...stylesheet.styles];\n-      this._inlineStyles(stylesheet.styleUrls, stylesheets, styles);\n-      return new CompileStylesheetMetadata({moduleUrl: styleUrl, styles: styles});\n-    });\n-\n-    let encapsulation = prenormData.encapsulation;\n-    if (encapsulation == null) {\n-      encapsulation = this._config.defaultEncapsulation;\n-    }\n-    if (encapsulation === ViewEncapsulation.Emulated && styles.length === 0 &&\n-        styleUrls.length === 0) {\n-      encapsulation = ViewEncapsulation.None;\n-    }\n-    return new CompileTemplateMetadata({\n-      encapsulation,\n-      template: preparsedTemplate.template,\n-      templateUrl: preparsedTemplate.templateUrl,\n-      htmlAst: preparsedTemplate.htmlAst,\n-      styles,\n-      styleUrls,\n-      ngContentSelectors: preparsedTemplate.ngContentSelectors,\n-      animations: prenormData.animations,\n-      interpolation: prenormData.interpolation,\n-      isInline: preparsedTemplate.isInline,\n-      externalStylesheets,\n-      preserveWhitespaces: preserveWhitespacesDefault(\n-          prenormData.preserveWhitespaces, this._config.preserveWhitespaces),\n-    });\n-  }\n-\n-  private _inlineStyles(\n-      styleUrls: string[], stylesheets: Map<string, CompileStylesheetMetadata>,\n-      targetStyles: string[]) {\n-    styleUrls.forEach(styleUrl => {\n-      const stylesheet = stylesheets.get(styleUrl)!;\n-      stylesheet.styles.forEach(style => targetStyles.push(style));\n-      this._inlineStyles(stylesheet.styleUrls, stylesheets, targetStyles);\n-    });\n-  }\n-\n-  private _loadMissingExternalStylesheets(\n-      styleUrls: string[],\n-      loadedStylesheets:\n-          Map<string, CompileStylesheetMetadata> = new Map<string, CompileStylesheetMetadata>()):\n-      SyncAsync<Map<string, CompileStylesheetMetadata>> {\n-    return SyncAsync.then(\n-        SyncAsync.all(styleUrls.filter((styleUrl) => !loadedStylesheets.has(styleUrl))\n-                          .map(\n-                              styleUrl => SyncAsync.then(\n-                                  this._fetch(styleUrl),\n-                                  (loadedStyle) => {\n-                                    const stylesheet =\n-                                        this._normalizeStylesheet(new CompileStylesheetMetadata(\n-                                            {styles: [loadedStyle], moduleUrl: styleUrl}));\n-                                    loadedStylesheets.set(styleUrl, stylesheet);\n-                                    return this._loadMissingExternalStylesheets(\n-                                        stylesheet.styleUrls, loadedStylesheets);\n-                                  }))),\n-        (_) => loadedStylesheets);\n-  }\n-\n-  private _normalizeStylesheet(stylesheet: CompileStylesheetMetadata): CompileStylesheetMetadata {\n-    const moduleUrl = stylesheet.moduleUrl!;\n-    const allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable)\n-                             .map(url => this._urlResolver.resolve(moduleUrl, url));\n-\n-    const allStyles = stylesheet.styles.map(style => {\n-      const styleWithImports = extractStyleUrls(this._urlResolver, moduleUrl, style);\n-      allStyleUrls.push(...styleWithImports.styleUrls);\n-      return styleWithImports.style;\n-    });\n-\n-    return new CompileStylesheetMetadata(\n-        {styles: allStyles, styleUrls: allStyleUrls, moduleUrl: moduleUrl});\n-  }\n-}\n-\n-interface PreparsedTemplate {\n-  template: string;\n-  templateUrl: string;\n-  isInline: boolean;\n-  htmlAst: HtmlParseTreeResult;\n-  styles: string[];\n-  inlineStyleUrls: string[];\n-  styleUrls: string[];\n-  ngContentSelectors: string[];\n-}\n-\n-class TemplatePreparseVisitor implements html.Visitor {\n-  ngContentSelectors: string[] = [];\n-  styles: string[] = [];\n-  styleUrls: string[] = [];\n-  ngNonBindableStackCount: number = 0;\n-\n-  visitElement(ast: html.Element, context: any): any {\n-    const preparsedElement = preparseElement(ast);\n-    switch (preparsedElement.type) {\n-      case PreparsedElementType.NG_CONTENT:\n-        if (this.ngNonBindableStackCount === 0) {\n-          this.ngContentSelectors.push(preparsedElement.selectAttr);\n-        }\n-        break;\n-      case PreparsedElementType.STYLE:\n-        let textContent = '';\n-        ast.children.forEach(child => {\n-          if (child instanceof html.Text) {\n-            textContent += child.value;\n-          }\n-        });\n-        this.styles.push(textContent);\n-        break;\n-      case PreparsedElementType.STYLESHEET:\n-        this.styleUrls.push(preparsedElement.hrefAttr);\n-        break;\n-      default:\n-        break;\n-    }\n-    if (preparsedElement.nonBindable) {\n-      this.ngNonBindableStackCount++;\n-    }\n-    html.visitAll(this, ast.children);\n-    if (preparsedElement.nonBindable) {\n-      this.ngNonBindableStackCount--;\n-    }\n-    return null;\n-  }\n-\n-  visitExpansion(ast: html.Expansion, context: any): any {\n-    html.visitAll(this, ast.cases);\n-  }\n-\n-  visitExpansionCase(ast: html.ExpansionCase, context: any): any {\n-    html.visitAll(this, ast.expression);\n-  }\n-\n-  visitComment(ast: html.Comment, context: any): any {\n-    return null;\n-  }\n-  visitAttribute(ast: html.Attribute, context: any): any {\n-    return null;\n-  }\n-  visitText(ast: html.Text, context: any): any {\n-    return null;\n-  }\n-}"
        },
        {
            "sha": "a4c8a09a8d5fecdba538addf10805b14fa70d531",
            "filename": "packages/compiler/src/directive_resolver.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 191,
            "changes": 191,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fdirective_resolver.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fdirective_resolver.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fdirective_resolver.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,191 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompileReflector} from './compile_reflector';\n-import {Component, createComponent, createContentChild, createContentChildren, createDirective, createHostBinding, createHostListener, createInput, createOutput, createViewChild, createViewChildren, Directive, Type} from './core';\n-import {resolveForwardRef, splitAtColon, stringify} from './util';\n-\n-const QUERY_METADATA_IDENTIFIERS = [\n-  createViewChild,\n-  createViewChildren,\n-  createContentChild,\n-  createContentChildren,\n-];\n-\n-/*\n- * Resolve a `Type` for {@link Directive}.\n- *\n- * This interface can be overridden by the application developer to create custom behavior.\n- *\n- * See {@link Compiler}\n- */\n-export class DirectiveResolver {\n-  constructor(private _reflector: CompileReflector) {}\n-\n-  isDirective(type: Type) {\n-    const typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n-    return typeMetadata && typeMetadata.some(isDirectiveMetadata);\n-  }\n-\n-  /**\n-   * Return {@link Directive} for a given `Type`.\n-   */\n-  resolve(type: Type): Directive;\n-  resolve(type: Type, throwIfNotFound: true): Directive;\n-  resolve(type: Type, throwIfNotFound: boolean): Directive|null;\n-  resolve(type: Type, throwIfNotFound = true): Directive|null {\n-    const typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n-    if (typeMetadata) {\n-      const metadata = findLast(typeMetadata, isDirectiveMetadata);\n-      if (metadata) {\n-        const propertyMetadata = this._reflector.propMetadata(type);\n-        const guards = this._reflector.guards(type);\n-        return this._mergeWithPropertyMetadata(metadata, propertyMetadata, guards, type);\n-      }\n-    }\n-\n-    if (throwIfNotFound) {\n-      throw new Error(`No Directive annotation found on ${stringify(type)}`);\n-    }\n-\n-    return null;\n-  }\n-\n-  private _mergeWithPropertyMetadata(\n-      dm: Directive, propertyMetadata: {[key: string]: any[]}, guards: {[key: string]: any},\n-      directiveType: Type): Directive {\n-    const inputs: string[] = [];\n-    const outputs: string[] = [];\n-    const host: {[key: string]: string} = {};\n-    const queries: {[key: string]: any} = {};\n-    Object.keys(propertyMetadata).forEach((propName: string) => {\n-      const input = findLast(propertyMetadata[propName], (a) => createInput.isTypeOf(a));\n-      if (input) {\n-        if (input.bindingPropertyName) {\n-          inputs.push(`${propName}: ${input.bindingPropertyName}`);\n-        } else {\n-          inputs.push(propName);\n-        }\n-      }\n-      const output = findLast(propertyMetadata[propName], (a) => createOutput.isTypeOf(a));\n-      if (output) {\n-        if (output.bindingPropertyName) {\n-          outputs.push(`${propName}: ${output.bindingPropertyName}`);\n-        } else {\n-          outputs.push(propName);\n-        }\n-      }\n-      const hostBindings = propertyMetadata[propName].filter(a => createHostBinding.isTypeOf(a));\n-      hostBindings.forEach(hostBinding => {\n-        if (hostBinding.hostPropertyName) {\n-          const startWith = hostBinding.hostPropertyName[0];\n-          if (startWith === '(') {\n-            throw new Error(`@HostBinding can not bind to events. Use @HostListener instead.`);\n-          } else if (startWith === '[') {\n-            throw new Error(\n-                `@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.`);\n-          }\n-          host[`[${hostBinding.hostPropertyName}]`] = propName;\n-        } else {\n-          host[`[${propName}]`] = propName;\n-        }\n-      });\n-      const hostListeners = propertyMetadata[propName].filter(a => createHostListener.isTypeOf(a));\n-      hostListeners.forEach(hostListener => {\n-        const args = hostListener.args || [];\n-        host[`(${hostListener.eventName})`] = `${propName}(${args.join(',')})`;\n-      });\n-      const query = findLast(\n-          propertyMetadata[propName], (a) => QUERY_METADATA_IDENTIFIERS.some(i => i.isTypeOf(a)));\n-      if (query) {\n-        queries[propName] = query;\n-      }\n-    });\n-    return this._merge(dm, inputs, outputs, host, queries, guards, directiveType);\n-  }\n-\n-  private _extractPublicName(def: string) {\n-    return splitAtColon(def, [null!, def])[1].trim();\n-  }\n-\n-  private _dedupeBindings(bindings: string[]): string[] {\n-    const names = new Set<string>();\n-    const publicNames = new Set<string>();\n-    const reversedResult: string[] = [];\n-    // go last to first to allow later entries to overwrite previous entries\n-    for (let i = bindings.length - 1; i >= 0; i--) {\n-      const binding = bindings[i];\n-      const name = this._extractPublicName(binding);\n-      publicNames.add(name);\n-      if (!names.has(name)) {\n-        names.add(name);\n-        reversedResult.push(binding);\n-      }\n-    }\n-    return reversedResult.reverse();\n-  }\n-\n-  private _merge(\n-      directive: Directive, inputs: string[], outputs: string[], host: {[key: string]: string},\n-      queries: {[key: string]: any}, guards: {[key: string]: any}, directiveType: Type): Directive {\n-    const mergedInputs =\n-        this._dedupeBindings(directive.inputs ? directive.inputs.concat(inputs) : inputs);\n-    const mergedOutputs =\n-        this._dedupeBindings(directive.outputs ? directive.outputs.concat(outputs) : outputs);\n-    const mergedHost = directive.host ? {...directive.host, ...host} : host;\n-    const mergedQueries = directive.queries ? {...directive.queries, ...queries} : queries;\n-    if (createComponent.isTypeOf(directive)) {\n-      const comp = directive as Component;\n-      return createComponent({\n-        selector: comp.selector,\n-        inputs: mergedInputs,\n-        outputs: mergedOutputs,\n-        host: mergedHost,\n-        exportAs: comp.exportAs,\n-        moduleId: comp.moduleId,\n-        queries: mergedQueries,\n-        changeDetection: comp.changeDetection,\n-        providers: comp.providers,\n-        viewProviders: comp.viewProviders,\n-        entryComponents: comp.entryComponents,\n-        template: comp.template,\n-        templateUrl: comp.templateUrl,\n-        styles: comp.styles,\n-        styleUrls: comp.styleUrls,\n-        encapsulation: comp.encapsulation,\n-        animations: comp.animations,\n-        interpolation: comp.interpolation,\n-        preserveWhitespaces: directive.preserveWhitespaces,\n-      });\n-    } else {\n-      return createDirective({\n-        selector: directive.selector,\n-        inputs: mergedInputs,\n-        outputs: mergedOutputs,\n-        host: mergedHost,\n-        exportAs: directive.exportAs,\n-        queries: mergedQueries,\n-        providers: directive.providers,\n-        guards\n-      });\n-    }\n-  }\n-}\n-\n-function isDirectiveMetadata(type: any): type is Directive {\n-  return createDirective.isTypeOf(type) || createComponent.isTypeOf(type);\n-}\n-\n-export function findLast<T>(arr: T[], condition: (value: T) => boolean): T|null {\n-  for (let i = arr.length - 1; i >= 0; i--) {\n-    if (condition(arr[i])) {\n-      return arr[i];\n-    }\n-  }\n-  return null;\n-}"
        },
        {
            "sha": "b574db85d0f4e7a90f4bbbb027728d01af0f4f90",
            "filename": "packages/compiler/src/i18n/extractor.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 123,
            "changes": 123,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fi18n%2Fextractor.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fi18n%2Fextractor.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fi18n%2Fextractor.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,123 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-\n-/**\n- * Extract i18n messages from source code\n- */\n-import {analyzeAndValidateNgModules} from '../aot/compiler';\n-import {createAotUrlResolver} from '../aot/compiler_factory';\n-import {StaticReflector} from '../aot/static_reflector';\n-import {StaticSymbolCache} from '../aot/static_symbol';\n-import {StaticSymbolResolver, StaticSymbolResolverHost} from '../aot/static_symbol_resolver';\n-import {AotSummaryResolver, AotSummaryResolverHost} from '../aot/summary_resolver';\n-import {CompileDirectiveMetadata} from '../compile_metadata';\n-import {CompilerConfig} from '../config';\n-import {ViewEncapsulation} from '../core';\n-import {DirectiveNormalizer} from '../directive_normalizer';\n-import {DirectiveResolver} from '../directive_resolver';\n-import {CompileMetadataResolver} from '../metadata_resolver';\n-import {HtmlParser} from '../ml_parser/html_parser';\n-import {InterpolationConfig} from '../ml_parser/interpolation_config';\n-import {NgModuleResolver} from '../ng_module_resolver';\n-import {ParseError} from '../parse_util';\n-import {PipeResolver} from '../pipe_resolver';\n-import {DomElementSchemaRegistry} from '../schema/dom_element_schema_registry';\n-\n-import {MessageBundle} from './message_bundle';\n-\n-\n-\n-/**\n- * The host of the Extractor disconnects the implementation from TypeScript / other language\n- * services and from underlying file systems.\n- */\n-export interface ExtractorHost extends StaticSymbolResolverHost, AotSummaryResolverHost {\n-  /**\n-   * Converts a path that refers to a resource into an absolute filePath\n-   * that can be later on used for loading the resource via `loadResource.\n-   */\n-  resourceNameToFileName(path: string, containingFile: string): string|null;\n-  /**\n-   * Loads a resource (e.g. html / css)\n-   */\n-  loadResource(path: string): Promise<string>|string;\n-}\n-\n-export class Extractor {\n-  constructor(\n-      public host: ExtractorHost, private staticSymbolResolver: StaticSymbolResolver,\n-      private messageBundle: MessageBundle, private metadataResolver: CompileMetadataResolver) {}\n-\n-  extract(rootFiles: string[]): Promise<MessageBundle> {\n-    const {files, ngModules} = analyzeAndValidateNgModules(\n-        rootFiles, this.host, this.staticSymbolResolver, this.metadataResolver);\n-    return Promise\n-        .all(ngModules.map(\n-            ngModule => this.metadataResolver.loadNgModuleDirectiveAndPipeMetadata(\n-                ngModule.type.reference, false)))\n-        .then(() => {\n-          const errors: ParseError[] = [];\n-\n-          files.forEach(file => {\n-            const compMetas: CompileDirectiveMetadata[] = [];\n-            file.directives.forEach(directiveType => {\n-              const dirMeta = this.metadataResolver.getDirectiveMetadata(directiveType);\n-              if (dirMeta && dirMeta.isComponent) {\n-                compMetas.push(dirMeta);\n-              }\n-            });\n-            compMetas.forEach(compMeta => {\n-              const html = compMeta.template !.template !;\n-              // Template URL points to either an HTML or TS file depending on\n-              // whether the file is used with `templateUrl:` or `template:`,\n-              // respectively.\n-              const templateUrl = compMeta.template !.templateUrl!;\n-              const interpolationConfig =\n-                  InterpolationConfig.fromArray(compMeta.template !.interpolation);\n-              errors.push(...this.messageBundle.updateFromTemplate(\n-                  html, templateUrl, interpolationConfig)!);\n-            });\n-          });\n-\n-          if (errors.length) {\n-            throw new Error(errors.map(e => e.toString()).join('\\n'));\n-          }\n-\n-          return this.messageBundle;\n-        });\n-  }\n-\n-  static create(host: ExtractorHost, locale: string|null):\n-      {extractor: Extractor, staticReflector: StaticReflector} {\n-    const htmlParser = new HtmlParser();\n-\n-    const urlResolver = createAotUrlResolver(host);\n-    const symbolCache = new StaticSymbolCache();\n-    const summaryResolver = new AotSummaryResolver(host, symbolCache);\n-    const staticSymbolResolver = new StaticSymbolResolver(host, symbolCache, summaryResolver);\n-    const staticReflector = new StaticReflector(summaryResolver, staticSymbolResolver);\n-\n-    const config =\n-        new CompilerConfig({defaultEncapsulation: ViewEncapsulation.Emulated, useJit: false});\n-\n-    const normalizer = new DirectiveNormalizer(\n-        {get: (url: string) => host.loadResource(url)}, urlResolver, htmlParser, config);\n-    const elementSchemaRegistry = new DomElementSchemaRegistry();\n-    const resolver = new CompileMetadataResolver(\n-        config, htmlParser, new NgModuleResolver(staticReflector),\n-        new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver,\n-        elementSchemaRegistry, normalizer, console, symbolCache, staticReflector);\n-\n-    // TODO(vicb): implicit tags & attributes\n-    const messageBundle = new MessageBundle(htmlParser, [], {}, locale);\n-\n-    const extractor = new Extractor(host, staticSymbolResolver, messageBundle, resolver);\n-    return {extractor, staticReflector};\n-  }\n-}"
        },
        {
            "sha": "6af92a7321d0baa9359f3bc5b673011672a92bda",
            "filename": "packages/compiler/src/i18n/index.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Fi18n%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Fi18n%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fi18n%2Findex.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -6,7 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n export {computeMsgId} from './digest';\n-export {Extractor, ExtractorHost} from './extractor';\n export {I18NHtmlParser} from './i18n_html_parser';\n export {MessageBundle} from './message_bundle';\n export {Serializer} from './serializers/serializer';"
        },
        {
            "sha": "c7d0209ce8c4fd9a18daa849055b782dbe8467dd",
            "filename": "packages/compiler/src/identifiers.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 25,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Fidentifiers.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Fidentifiers.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fidentifiers.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -6,8 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {CompileTokenMetadata} from './compile_metadata';\n-import {CompileReflector} from './compile_reflector';\n import * as o from './output/output_ast';\n \n const CORE = '@angular/core';\n@@ -95,20 +93,6 @@ export class Identifiers {\n   static EMPTY_ARRAY: o.ExternalReference = {name: 'ɵEMPTY_ARRAY', moduleName: CORE};\n   static EMPTY_MAP: o.ExternalReference = {name: 'ɵEMPTY_MAP', moduleName: CORE};\n   static Renderer: o.ExternalReference = {name: 'Renderer', moduleName: CORE};\n-  static viewDef: o.ExternalReference = {name: 'ɵvid', moduleName: CORE};\n-  static elementDef: o.ExternalReference = {name: 'ɵeld', moduleName: CORE};\n-  static anchorDef: o.ExternalReference = {name: 'ɵand', moduleName: CORE};\n-  static textDef: o.ExternalReference = {name: 'ɵted', moduleName: CORE};\n-  static directiveDef: o.ExternalReference = {name: 'ɵdid', moduleName: CORE};\n-  static providerDef: o.ExternalReference = {name: 'ɵprd', moduleName: CORE};\n-  static queryDef: o.ExternalReference = {name: 'ɵqud', moduleName: CORE};\n-  static pureArrayDef: o.ExternalReference = {name: 'ɵpad', moduleName: CORE};\n-  static pureObjectDef: o.ExternalReference = {name: 'ɵpod', moduleName: CORE};\n-  static purePipeDef: o.ExternalReference = {name: 'ɵppd', moduleName: CORE};\n-  static pipeDef: o.ExternalReference = {name: 'ɵpid', moduleName: CORE};\n-  static nodeValue: o.ExternalReference = {name: 'ɵnov', moduleName: CORE};\n-  static ngContentDef: o.ExternalReference = {name: 'ɵncd', moduleName: CORE};\n-  static createRendererType2: o.ExternalReference = {name: 'ɵcrt', moduleName: CORE};\n   // type only\n   static RendererType2: o.ExternalReference = {\n     name: 'RendererType2',\n@@ -122,12 +106,3 @@ export class Identifiers {\n   };\n   static createComponentFactory: o.ExternalReference = {name: 'ɵccf', moduleName: CORE};\n }\n-\n-export function createTokenForReference(reference: any): CompileTokenMetadata {\n-  return {identifier: {reference: reference}};\n-}\n-\n-export function createTokenForExternalReference(\n-    reflector: CompileReflector, reference: o.ExternalReference): CompileTokenMetadata {\n-  return createTokenForReference(reflector.resolveExternalReference(reference));\n-}"
        },
        {
            "sha": "8af182b7b33b58bf894a4017a51d3fc57a4d95ab",
            "filename": "packages/compiler/src/injectable_compiler.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 135,
            "changes": 135,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Finjectable_compiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Finjectable_compiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Finjectable_compiler.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,135 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {StaticSymbol} from './aot/static_symbol';\n-import {CompileInjectableMetadata} from './compile_metadata';\n-import {CompileReflector} from './compile_reflector';\n-import {OutputContext} from './constant_pool';\n-import {InjectFlags} from './core';\n-import {Identifiers} from './identifiers';\n-import * as o from './output/output_ast';\n-import {convertValueToOutputAst} from './output/value_util';\n-import {identifierName} from './parse_util';\n-import {Identifiers as R3} from './render3/r3_identifiers';\n-\n-type MapEntry = {\n-  key: string,\n-  quoted: boolean,\n-  value: o.Expression\n-};\n-type MapLiteral = MapEntry[];\n-\n-function mapEntry(key: string, value: o.Expression): MapEntry {\n-  return {key, value, quoted: false};\n-}\n-\n-export class InjectableCompiler {\n-  private tokenInjector: StaticSymbol;\n-  constructor(private reflector: CompileReflector, private alwaysGenerateDef: boolean) {\n-    this.tokenInjector = reflector.resolveExternalReference(Identifiers.Injector);\n-  }\n-\n-  private depsArray(deps: any[], ctx: OutputContext): o.Expression[] {\n-    return deps.map(dep => {\n-      let token = dep;\n-      let args = [token];\n-      let flags: InjectFlags = InjectFlags.Default;\n-      if (Array.isArray(dep)) {\n-        for (let i = 0; i < dep.length; i++) {\n-          const v = dep[i];\n-          if (v) {\n-            if (v.ngMetadataName === 'Optional') {\n-              flags |= InjectFlags.Optional;\n-            } else if (v.ngMetadataName === 'SkipSelf') {\n-              flags |= InjectFlags.SkipSelf;\n-            } else if (v.ngMetadataName === 'Self') {\n-              flags |= InjectFlags.Self;\n-            } else if (v.ngMetadataName === 'Inject') {\n-              token = v.token;\n-            } else {\n-              token = v;\n-            }\n-          }\n-        }\n-      }\n-\n-      let tokenExpr: o.Expression;\n-      if (typeof token === 'string') {\n-        tokenExpr = o.literal(token);\n-      } else if (token === this.tokenInjector) {\n-        tokenExpr = o.importExpr(Identifiers.INJECTOR);\n-      } else {\n-        tokenExpr = ctx.importExpr(token);\n-      }\n-\n-      if (flags !== InjectFlags.Default) {\n-        args = [tokenExpr, o.literal(flags)];\n-      } else {\n-        args = [tokenExpr];\n-      }\n-      return o.importExpr(Identifiers.inject).callFn(args);\n-    });\n-  }\n-\n-  factoryFor(injectable: CompileInjectableMetadata, ctx: OutputContext): o.Expression {\n-    let retValue: o.Expression;\n-    if (injectable.useExisting) {\n-      retValue = o.importExpr(Identifiers.inject).callFn([ctx.importExpr(injectable.useExisting)]);\n-    } else if (injectable.useFactory) {\n-      const deps = injectable.deps || [];\n-      if (deps.length > 0) {\n-        retValue = ctx.importExpr(injectable.useFactory).callFn(this.depsArray(deps, ctx));\n-      } else {\n-        return ctx.importExpr(injectable.useFactory);\n-      }\n-    } else if (injectable.useValue) {\n-      retValue = convertValueToOutputAst(ctx, injectable.useValue);\n-    } else {\n-      const clazz = injectable.useClass || injectable.symbol;\n-      const depArgs = this.depsArray(this.reflector.parameters(clazz), ctx);\n-      retValue = new o.InstantiateExpr(ctx.importExpr(clazz), depArgs);\n-    }\n-    return o.fn(\n-        [], [new o.ReturnStatement(retValue)], undefined, undefined,\n-        injectable.symbol.name + '_Factory');\n-  }\n-\n-  injectableDef(injectable: CompileInjectableMetadata, ctx: OutputContext): o.Expression {\n-    let providedIn: o.Expression = o.NULL_EXPR;\n-    if (injectable.providedIn !== undefined) {\n-      if (injectable.providedIn === null) {\n-        providedIn = o.NULL_EXPR;\n-      } else if (typeof injectable.providedIn === 'string') {\n-        providedIn = o.literal(injectable.providedIn);\n-      } else {\n-        providedIn = ctx.importExpr(injectable.providedIn);\n-      }\n-    }\n-    const def: MapLiteral = [\n-      mapEntry('factory', this.factoryFor(injectable, ctx)),\n-      mapEntry('token', ctx.importExpr(injectable.type.reference)),\n-      mapEntry('providedIn', providedIn),\n-    ];\n-    return o.importExpr(R3.ɵɵdefineInjectable).callFn([o.literalMap(def)], undefined, true);\n-  }\n-\n-  compile(injectable: CompileInjectableMetadata, ctx: OutputContext): void {\n-    if (this.alwaysGenerateDef || injectable.providedIn !== undefined) {\n-      const className = identifierName(injectable.type)!;\n-      const clazz = new o.ClassStmt(\n-          className, null,\n-          [\n-            new o.ClassField(\n-                'ɵprov', o.INFERRED_TYPE, [o.StmtModifier.Static],\n-                this.injectableDef(injectable, ctx)),\n-          ],\n-          [], new o.ClassMethod(null, [], []), []);\n-      ctx.statements.push(clazz);\n-    }\n-  }\n-}"
        },
        {
            "sha": "ded36fc38fafde409cafb9678f12b66e777a09f3",
            "filename": "packages/compiler/src/jit/compiler.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 365,
            "changes": 365,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fjit%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fjit%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fjit%2Fcompiler.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,365 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompileDirectiveMetadata, CompileNgModuleMetadata, CompilePipeSummary, CompileProviderMetadata, CompileTypeSummary, ngModuleJitUrl, ProxyClass, sharedStylesheetJitUrl, templateJitUrl, templateSourceUrl} from '../compile_metadata';\n-import {CompileReflector} from '../compile_reflector';\n-import {CompilerConfig} from '../config';\n-import {ConstantPool, OutputContext} from '../constant_pool';\n-import {Type} from '../core';\n-import {CompileMetadataResolver} from '../metadata_resolver';\n-import {NgModuleCompiler} from '../ng_module_compiler';\n-import * as ir from '../output/output_ast';\n-import {interpretStatements} from '../output/output_interpreter';\n-import {JitEvaluator} from '../output/output_jit';\n-import {CompileIdentifierMetadata, identifierName} from '../parse_util';\n-import {CompiledStylesheet, StyleCompiler} from '../style_compiler';\n-import {SummaryResolver} from '../summary_resolver';\n-import {TemplateAst} from '../template_parser/template_ast';\n-import {TemplateParser} from '../template_parser/template_parser';\n-import {Console, stringify, SyncAsync} from '../util';\n-import {ViewCompiler} from '../view_compiler/view_compiler';\n-\n-export interface ModuleWithComponentFactories {\n-  ngModuleFactory: object;\n-  componentFactories: object[];\n-}\n-\n-/**\n- * An internal module of the Angular compiler that begins with component types,\n- * extracts templates, and eventually produces a compiled version of the component\n- * ready for linking into an application.\n- *\n- * @security  When compiling templates at runtime, you must ensure that the entire template comes\n- * from a trusted source. Attacker-controlled data introduced by a template could expose your\n- * application to XSS risks.  For more detail, see the [Security Guide](https://g.co/ng/security).\n- */\n-export class JitCompiler {\n-  private _compiledTemplateCache = new Map<Type, CompiledTemplate>();\n-  private _compiledHostTemplateCache = new Map<Type, CompiledTemplate>();\n-  private _compiledDirectiveWrapperCache = new Map<Type, Type>();\n-  private _compiledNgModuleCache = new Map<Type, object>();\n-  private _sharedStylesheetCount = 0;\n-  private _addedAotSummaries = new Set<() => any[]>();\n-\n-  constructor(\n-      private _metadataResolver: CompileMetadataResolver, private _templateParser: TemplateParser,\n-      private _styleCompiler: StyleCompiler, private _viewCompiler: ViewCompiler,\n-      private _ngModuleCompiler: NgModuleCompiler, private _summaryResolver: SummaryResolver<Type>,\n-      private _reflector: CompileReflector, private _jitEvaluator: JitEvaluator,\n-      private _compilerConfig: CompilerConfig, private _console: Console,\n-      private getExtraNgModuleProviders: (ngModule: any) => CompileProviderMetadata[]) {}\n-\n-  compileModuleSync(moduleType: Type): object {\n-    return SyncAsync.assertSync(this._compileModuleAndComponents(moduleType, true));\n-  }\n-\n-  compileModuleAsync(moduleType: Type): Promise<object> {\n-    return Promise.resolve(this._compileModuleAndComponents(moduleType, false));\n-  }\n-\n-  compileModuleAndAllComponentsSync(moduleType: Type): ModuleWithComponentFactories {\n-    return SyncAsync.assertSync(this._compileModuleAndAllComponents(moduleType, true));\n-  }\n-\n-  compileModuleAndAllComponentsAsync(moduleType: Type): Promise<ModuleWithComponentFactories> {\n-    return Promise.resolve(this._compileModuleAndAllComponents(moduleType, false));\n-  }\n-\n-  getComponentFactory(component: Type): object {\n-    const summary = this._metadataResolver.getDirectiveSummary(component);\n-    return summary.componentFactory as object;\n-  }\n-\n-  loadAotSummaries(summaries: () => any[]) {\n-    this.clearCache();\n-    this._addAotSummaries(summaries);\n-  }\n-\n-  private _addAotSummaries(fn: () => any[]) {\n-    if (this._addedAotSummaries.has(fn)) {\n-      return;\n-    }\n-    this._addedAotSummaries.add(fn);\n-    const summaries = fn();\n-    for (let i = 0; i < summaries.length; i++) {\n-      const entry = summaries[i];\n-      if (typeof entry === 'function') {\n-        this._addAotSummaries(entry);\n-      } else {\n-        const summary = entry as CompileTypeSummary;\n-        this._summaryResolver.addSummary(\n-            {symbol: summary.type.reference, metadata: null, type: summary});\n-      }\n-    }\n-  }\n-\n-  hasAotSummary(ref: Type) {\n-    return !!this._summaryResolver.resolveSummary(ref);\n-  }\n-\n-  private _filterJitIdentifiers(ids: CompileIdentifierMetadata[]): any[] {\n-    return ids.map(mod => mod.reference).filter((ref) => !this.hasAotSummary(ref));\n-  }\n-\n-  private _compileModuleAndComponents(moduleType: Type, isSync: boolean): SyncAsync<object> {\n-    return SyncAsync.then(this._loadModules(moduleType, isSync), () => {\n-      this._compileComponents(moduleType, null);\n-      return this._compileModule(moduleType);\n-    });\n-  }\n-\n-  private _compileModuleAndAllComponents(moduleType: Type, isSync: boolean):\n-      SyncAsync<ModuleWithComponentFactories> {\n-    return SyncAsync.then(this._loadModules(moduleType, isSync), () => {\n-      const componentFactories: object[] = [];\n-      this._compileComponents(moduleType, componentFactories);\n-      return {\n-        ngModuleFactory: this._compileModule(moduleType),\n-        componentFactories: componentFactories\n-      };\n-    });\n-  }\n-\n-  private _loadModules(mainModule: any, isSync: boolean): SyncAsync<any> {\n-    const loading: Promise<any>[] = [];\n-    const mainNgModule = this._metadataResolver.getNgModuleMetadata(mainModule)!;\n-    // Note: for runtime compilation, we want to transitively compile all modules,\n-    // so we also need to load the declared directives / pipes for all nested modules.\n-    this._filterJitIdentifiers(mainNgModule.transitiveModule.modules).forEach((nestedNgModule) => {\n-      // getNgModuleMetadata only returns null if the value passed in is not an NgModule\n-      const moduleMeta = this._metadataResolver.getNgModuleMetadata(nestedNgModule)!;\n-      this._filterJitIdentifiers(moduleMeta.declaredDirectives).forEach((ref) => {\n-        const promise =\n-            this._metadataResolver.loadDirectiveMetadata(moduleMeta.type.reference, ref, isSync);\n-        if (promise) {\n-          loading.push(promise);\n-        }\n-      });\n-      this._filterJitIdentifiers(moduleMeta.declaredPipes)\n-          .forEach((ref) => this._metadataResolver.getOrLoadPipeMetadata(ref));\n-    });\n-    return SyncAsync.all(loading);\n-  }\n-\n-  private _compileModule(moduleType: Type): object {\n-    let ngModuleFactory = this._compiledNgModuleCache.get(moduleType)!;\n-    if (!ngModuleFactory) {\n-      const moduleMeta = this._metadataResolver.getNgModuleMetadata(moduleType)!;\n-      // Always provide a bound Compiler\n-      const extraProviders = this.getExtraNgModuleProviders(moduleMeta.type.reference);\n-      const outputCtx = createOutputContext();\n-      const compileResult = this._ngModuleCompiler.compile(outputCtx, moduleMeta, extraProviders);\n-      ngModuleFactory = this._interpretOrJit(\n-          ngModuleJitUrl(moduleMeta), outputCtx.statements)[compileResult.ngModuleFactoryVar];\n-      this._compiledNgModuleCache.set(moduleMeta.type.reference, ngModuleFactory);\n-    }\n-    return ngModuleFactory;\n-  }\n-\n-  /**\n-   * @internal\n-   */\n-  _compileComponents(mainModule: Type, allComponentFactories: object[]|null) {\n-    const ngModule = this._metadataResolver.getNgModuleMetadata(mainModule)!;\n-    const moduleByJitDirective = new Map<any, CompileNgModuleMetadata>();\n-    const templates = new Set<CompiledTemplate>();\n-\n-    const transJitModules = this._filterJitIdentifiers(ngModule.transitiveModule.modules);\n-    transJitModules.forEach((localMod) => {\n-      const localModuleMeta = this._metadataResolver.getNgModuleMetadata(localMod)!;\n-      this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach((dirRef) => {\n-        moduleByJitDirective.set(dirRef, localModuleMeta);\n-        const dirMeta = this._metadataResolver.getDirectiveMetadata(dirRef);\n-        if (dirMeta.isComponent) {\n-          templates.add(this._createCompiledTemplate(dirMeta, localModuleMeta));\n-          if (allComponentFactories) {\n-            const template =\n-                this._createCompiledHostTemplate(dirMeta.type.reference, localModuleMeta);\n-            templates.add(template);\n-            allComponentFactories.push(dirMeta.componentFactory as object);\n-          }\n-        }\n-      });\n-    });\n-    transJitModules.forEach((localMod) => {\n-      const localModuleMeta = this._metadataResolver.getNgModuleMetadata(localMod)!;\n-      this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach((dirRef) => {\n-        const dirMeta = this._metadataResolver.getDirectiveMetadata(dirRef);\n-        if (dirMeta.isComponent) {\n-          dirMeta.entryComponents.forEach((entryComponentType) => {\n-            const moduleMeta = moduleByJitDirective.get(entryComponentType.componentType)!;\n-            templates.add(\n-                this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n-          });\n-        }\n-      });\n-      localModuleMeta.entryComponents.forEach((entryComponentType) => {\n-        if (!this.hasAotSummary(entryComponentType.componentType)) {\n-          const moduleMeta = moduleByJitDirective.get(entryComponentType.componentType)!;\n-          templates.add(\n-              this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n-        }\n-      });\n-    });\n-    templates.forEach((template) => this._compileTemplate(template));\n-  }\n-\n-  clearCacheFor(type: Type) {\n-    this._compiledNgModuleCache.delete(type);\n-    this._metadataResolver.clearCacheFor(type);\n-    this._compiledHostTemplateCache.delete(type);\n-    const compiledTemplate = this._compiledTemplateCache.get(type);\n-    if (compiledTemplate) {\n-      this._compiledTemplateCache.delete(type);\n-    }\n-  }\n-\n-  clearCache(): void {\n-    // Note: don't clear the _addedAotSummaries, as they don't change!\n-    this._metadataResolver.clearCache();\n-    this._compiledTemplateCache.clear();\n-    this._compiledHostTemplateCache.clear();\n-    this._compiledNgModuleCache.clear();\n-  }\n-\n-  private _createCompiledHostTemplate(compType: Type, ngModule: CompileNgModuleMetadata):\n-      CompiledTemplate {\n-    if (!ngModule) {\n-      throw new Error(`Component ${\n-          stringify(\n-              compType)} is not part of any NgModule or the module has not been imported into your module.`);\n-    }\n-    let compiledTemplate = this._compiledHostTemplateCache.get(compType);\n-    if (!compiledTemplate) {\n-      const compMeta = this._metadataResolver.getDirectiveMetadata(compType);\n-      assertComponent(compMeta);\n-\n-      const hostMeta = this._metadataResolver.getHostComponentMetadata(\n-          compMeta, (compMeta.componentFactory as any).viewDefFactory);\n-      compiledTemplate =\n-          new CompiledTemplate(true, compMeta.type, hostMeta, ngModule, [compMeta.type]);\n-      this._compiledHostTemplateCache.set(compType, compiledTemplate);\n-    }\n-    return compiledTemplate;\n-  }\n-\n-  private _createCompiledTemplate(\n-      compMeta: CompileDirectiveMetadata, ngModule: CompileNgModuleMetadata): CompiledTemplate {\n-    let compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);\n-    if (!compiledTemplate) {\n-      assertComponent(compMeta);\n-      compiledTemplate = new CompiledTemplate(\n-          false, compMeta.type, compMeta, ngModule, ngModule.transitiveModule.directives);\n-      this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);\n-    }\n-    return compiledTemplate;\n-  }\n-\n-  private _compileTemplate(template: CompiledTemplate) {\n-    if (template.isCompiled) {\n-      return;\n-    }\n-    const compMeta = template.compMeta;\n-    const externalStylesheetsByModuleUrl = new Map<string, CompiledStylesheet>();\n-    const outputContext = createOutputContext();\n-    const componentStylesheet = this._styleCompiler.compileComponent(outputContext, compMeta);\n-    compMeta.template !.externalStylesheets.forEach((stylesheetMeta) => {\n-      const compiledStylesheet =\n-          this._styleCompiler.compileStyles(createOutputContext(), compMeta, stylesheetMeta);\n-      externalStylesheetsByModuleUrl.set(stylesheetMeta.moduleUrl!, compiledStylesheet);\n-    });\n-    this._resolveStylesCompileResult(componentStylesheet, externalStylesheetsByModuleUrl);\n-    const pipes = template.ngModule.transitiveModule.pipes.map(\n-        pipe => this._metadataResolver.getPipeSummary(pipe.reference));\n-    const {template: parsedTemplate, pipes: usedPipes} =\n-        this._parseTemplate(compMeta, template.ngModule, template.directives);\n-    const compileResult = this._viewCompiler.compileComponent(\n-        outputContext, compMeta, parsedTemplate, ir.variable(componentStylesheet.stylesVar),\n-        usedPipes);\n-    const evalResult = this._interpretOrJit(\n-        templateJitUrl(template.ngModule.type, template.compMeta), outputContext.statements);\n-    const viewClass = evalResult[compileResult.viewClassVar];\n-    const rendererType = evalResult[compileResult.rendererTypeVar];\n-    template.compiled(viewClass, rendererType);\n-  }\n-\n-  private _parseTemplate(\n-      compMeta: CompileDirectiveMetadata, ngModule: CompileNgModuleMetadata,\n-      directiveIdentifiers: CompileIdentifierMetadata[]):\n-      {template: TemplateAst[], pipes: CompilePipeSummary[]} {\n-    // Note: ! is ok here as components always have a template.\n-    const preserveWhitespaces = compMeta.template !.preserveWhitespaces;\n-    const directives =\n-        directiveIdentifiers.map(dir => this._metadataResolver.getDirectiveSummary(dir.reference));\n-    const pipes = ngModule.transitiveModule.pipes.map(\n-        pipe => this._metadataResolver.getPipeSummary(pipe.reference));\n-    return this._templateParser.parse(\n-        compMeta, compMeta.template !.htmlAst!, directives, pipes, ngModule.schemas,\n-        templateSourceUrl(ngModule.type, compMeta, compMeta.template !), preserveWhitespaces);\n-  }\n-\n-  private _resolveStylesCompileResult(\n-      result: CompiledStylesheet, externalStylesheetsByModuleUrl: Map<string, CompiledStylesheet>) {\n-    result.dependencies.forEach((dep, i) => {\n-      const nestedCompileResult = externalStylesheetsByModuleUrl.get(dep.moduleUrl)!;\n-      const nestedStylesArr = this._resolveAndEvalStylesCompileResult(\n-          nestedCompileResult, externalStylesheetsByModuleUrl);\n-      dep.setValue(nestedStylesArr);\n-    });\n-  }\n-\n-  private _resolveAndEvalStylesCompileResult(\n-      result: CompiledStylesheet,\n-      externalStylesheetsByModuleUrl: Map<string, CompiledStylesheet>): string[] {\n-    this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);\n-    return this._interpretOrJit(\n-        sharedStylesheetJitUrl(result.meta, this._sharedStylesheetCount++),\n-        result.outputCtx.statements)[result.stylesVar];\n-  }\n-\n-  private _interpretOrJit(sourceUrl: string, statements: ir.Statement[]): any {\n-    if (!this._compilerConfig.useJit) {\n-      return interpretStatements(statements, this._reflector);\n-    } else {\n-      return this._jitEvaluator.evaluateStatements(\n-          sourceUrl, statements, this._reflector, this._compilerConfig.jitDevMode);\n-    }\n-  }\n-}\n-\n-class CompiledTemplate {\n-  private _viewClass: Function = null!;\n-  isCompiled = false;\n-\n-  constructor(\n-      public isHost: boolean, public compType: CompileIdentifierMetadata,\n-      public compMeta: CompileDirectiveMetadata, public ngModule: CompileNgModuleMetadata,\n-      public directives: CompileIdentifierMetadata[]) {}\n-\n-  compiled(viewClass: Function, rendererType: any) {\n-    this._viewClass = viewClass;\n-    (<ProxyClass>this.compMeta.componentViewType).setDelegate(viewClass);\n-    for (let prop in rendererType) {\n-      (<any>this.compMeta.rendererType)[prop] = rendererType[prop];\n-    }\n-    this.isCompiled = true;\n-  }\n-}\n-\n-function assertComponent(meta: CompileDirectiveMetadata) {\n-  if (!meta.isComponent) {\n-    throw new Error(\n-        `Could not compile '${identifierName(meta.type)}' because it is not a component.`);\n-  }\n-}\n-\n-function createOutputContext(): OutputContext {\n-  const importExpr = (symbol: any) =>\n-      ir.importExpr({name: identifierName(symbol), moduleName: null, runtime: symbol});\n-  return {statements: [], genFilePath: '', importExpr, constantPool: new ConstantPool()};\n-}"
        },
        {
            "sha": "90ff55772d75d46d3e708ea0caed5f5dc4fff5b3",
            "filename": "packages/compiler/src/lifecycle_reflector.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 63,
            "changes": 63,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Flifecycle_reflector.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Flifecycle_reflector.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Flifecycle_reflector.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,63 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompileReflector} from './compile_reflector';\n-\n-export enum LifecycleHooks {\n-  OnInit,\n-  OnDestroy,\n-  DoCheck,\n-  OnChanges,\n-  AfterContentInit,\n-  AfterContentChecked,\n-  AfterViewInit,\n-  AfterViewChecked\n-}\n-\n-export const LIFECYCLE_HOOKS_VALUES = [\n-  LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,\n-  LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,\n-  LifecycleHooks.AfterViewChecked\n-];\n-\n-export function hasLifecycleHook(\n-    reflector: CompileReflector, hook: LifecycleHooks, token: any): boolean {\n-  return reflector.hasLifecycleHook(token, getHookName(hook));\n-}\n-\n-export function getAllLifecycleHooks(reflector: CompileReflector, token: any): LifecycleHooks[] {\n-  return LIFECYCLE_HOOKS_VALUES.filter(hook => hasLifecycleHook(reflector, hook, token));\n-}\n-\n-function getHookName(hook: LifecycleHooks): string {\n-  switch (hook) {\n-    case LifecycleHooks.OnInit:\n-      return 'ngOnInit';\n-    case LifecycleHooks.OnDestroy:\n-      return 'ngOnDestroy';\n-    case LifecycleHooks.DoCheck:\n-      return 'ngDoCheck';\n-    case LifecycleHooks.OnChanges:\n-      return 'ngOnChanges';\n-    case LifecycleHooks.AfterContentInit:\n-      return 'ngAfterContentInit';\n-    case LifecycleHooks.AfterContentChecked:\n-      return 'ngAfterContentChecked';\n-    case LifecycleHooks.AfterViewInit:\n-      return 'ngAfterViewInit';\n-    case LifecycleHooks.AfterViewChecked:\n-      return 'ngAfterViewChecked';\n-    default:\n-      // This default case is not needed by TypeScript compiler, as the switch is exhaustive.\n-      // However Closure Compiler does not understand that and reports an error in typed mode.\n-      // The `throw new Error` below works around the problem, and the unexpected: never variable\n-      // makes sure tsc still checks this code is unreachable.\n-      const unexpected: never = hook;\n-      throw new Error(`unexpected ${unexpected}`);\n-  }\n-}"
        },
        {
            "sha": "5127191c4a7d9c99586c212f684eca9561ad0964",
            "filename": "packages/compiler/src/metadata_resolver.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 1293,
            "changes": 1293,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fmetadata_resolver.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fmetadata_resolver.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fmetadata_resolver.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,1293 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {StaticSymbol, StaticSymbolCache} from './aot/static_symbol';\n-import {ngfactoryFilePath} from './aot/util';\n-import {assertArrayOfStrings, assertInterpolationSymbols} from './assertions';\n-import * as cpl from './compile_metadata';\n-import {CompileReflector} from './compile_reflector';\n-import {CompilerConfig} from './config';\n-import {ChangeDetectionStrategy, Component, createAttribute, createComponent, createHost, createInject, createInjectable, createInjectionToken, createNgModule, createOptional, createSelf, createSkipSelf, Directive, Injectable, ModuleWithProviders, Provider, Query, SchemaMetadata, Type, ViewEncapsulation} from './core';\n-import {DirectiveNormalizer} from './directive_normalizer';\n-import {DirectiveResolver, findLast} from './directive_resolver';\n-import {Identifiers} from './identifiers';\n-import {getAllLifecycleHooks} from './lifecycle_reflector';\n-import {HtmlParser} from './ml_parser/html_parser';\n-import {NgModuleResolver} from './ng_module_resolver';\n-import {CompileIdentifierMetadata, identifierName, syntaxError} from './parse_util';\n-import {PipeResolver} from './pipe_resolver';\n-import {ElementSchemaRegistry} from './schema/element_schema_registry';\n-import {CssSelector} from './selector';\n-import {SummaryResolver} from './summary_resolver';\n-import {Console, isPromise, noUndefined, resolveForwardRef, stringify, SyncAsync, ValueTransformer, visitValue} from './util';\n-\n-export type ErrorCollector = (error: any, type?: any) => void;\n-\n-export const ERROR_COMPONENT_TYPE = 'ngComponentType';\n-\n-const MISSING_NG_MODULE_METADATA_ERROR_DATA = 'ngMissingNgModuleMetadataErrorData';\n-export interface MissingNgModuleMetadataErrorData {\n-  fileName: string;\n-  className: string;\n-}\n-\n-\n-export function getMissingNgModuleMetadataErrorData(error: any): MissingNgModuleMetadataErrorData|\n-    null {\n-  return error[MISSING_NG_MODULE_METADATA_ERROR_DATA] ?? null;\n-}\n-\n-// Design notes:\n-// - don't lazily create metadata:\n-//   For some metadata, we need to do async work sometimes,\n-//   so the user has to kick off this loading.\n-//   But we want to report errors even when the async work is\n-//   not required to check that the user would have been able\n-//   to wait correctly.\n-export class CompileMetadataResolver {\n-  private _nonNormalizedDirectiveCache =\n-      new Map<Type, {annotation: Directive, metadata: cpl.CompileDirectiveMetadata}>();\n-  private _directiveCache = new Map<Type, cpl.CompileDirectiveMetadata>();\n-  private _summaryCache = new Map<Type, cpl.CompileTypeSummary|null>();\n-  private _pipeCache = new Map<Type, cpl.CompilePipeMetadata>();\n-  private _ngModuleCache = new Map<Type, cpl.CompileNgModuleMetadata>();\n-  private _ngModuleOfTypes = new Map<Type, Type>();\n-  private _shallowModuleCache = new Map<Type, cpl.CompileShallowModuleMetadata>();\n-\n-  constructor(\n-      private _config: CompilerConfig, private _htmlParser: HtmlParser,\n-      private _ngModuleResolver: NgModuleResolver, private _directiveResolver: DirectiveResolver,\n-      private _pipeResolver: PipeResolver, private _summaryResolver: SummaryResolver<any>,\n-      private _schemaRegistry: ElementSchemaRegistry,\n-      private _directiveNormalizer: DirectiveNormalizer, private _console: Console,\n-      private _staticSymbolCache: StaticSymbolCache, private _reflector: CompileReflector,\n-      private _errorCollector?: ErrorCollector) {}\n-\n-  getReflector(): CompileReflector {\n-    return this._reflector;\n-  }\n-\n-  clearCacheFor(type: Type) {\n-    const dirMeta = this._directiveCache.get(type);\n-    this._directiveCache.delete(type);\n-    this._nonNormalizedDirectiveCache.delete(type);\n-    this._summaryCache.delete(type);\n-    this._pipeCache.delete(type);\n-    this._ngModuleOfTypes.delete(type);\n-    // Clear all of the NgModule as they contain transitive information!\n-    this._ngModuleCache.clear();\n-    if (dirMeta) {\n-      this._directiveNormalizer.clearCacheFor(dirMeta);\n-    }\n-  }\n-\n-  clearCache(): void {\n-    this._directiveCache.clear();\n-    this._nonNormalizedDirectiveCache.clear();\n-    this._summaryCache.clear();\n-    this._pipeCache.clear();\n-    this._ngModuleCache.clear();\n-    this._ngModuleOfTypes.clear();\n-    this._directiveNormalizer.clearCache();\n-  }\n-\n-  private _createProxyClass(baseType: any, name: string): cpl.ProxyClass {\n-    let delegate: any = null;\n-    const proxyClass: cpl.ProxyClass = <any>function(this: unknown) {\n-      if (!delegate) {\n-        throw new Error(\n-            `Illegal state: Class ${name} for type ${stringify(baseType)} is not compiled yet!`);\n-      }\n-      return delegate.apply(this, arguments);\n-    };\n-    proxyClass.setDelegate = (d) => {\n-      delegate = d;\n-      (<any>proxyClass).prototype = d.prototype;\n-    };\n-    // Make stringify work correctly\n-    (<any>proxyClass).overriddenName = name;\n-    return proxyClass;\n-  }\n-\n-  private getGeneratedClass(dirType: any, name: string): StaticSymbol|cpl.ProxyClass {\n-    if (dirType instanceof StaticSymbol) {\n-      return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), name);\n-    } else {\n-      return this._createProxyClass(dirType, name);\n-    }\n-  }\n-\n-  private getComponentViewClass(dirType: any): StaticSymbol|cpl.ProxyClass {\n-    return this.getGeneratedClass(dirType, cpl.viewClassName(dirType, 0));\n-  }\n-\n-  getHostComponentViewClass(dirType: any): StaticSymbol|cpl.ProxyClass {\n-    return this.getGeneratedClass(dirType, cpl.hostViewClassName(dirType));\n-  }\n-\n-  getHostComponentType(dirType: any): StaticSymbol|cpl.ProxyClass {\n-    const name = `${identifierName({reference: dirType})}_Host`;\n-    if (dirType instanceof StaticSymbol) {\n-      return this._staticSymbolCache.get(dirType.filePath, name);\n-    }\n-\n-    return this._createProxyClass(dirType, name);\n-  }\n-\n-  private getRendererType(dirType: any): StaticSymbol|object {\n-    if (dirType instanceof StaticSymbol) {\n-      return this._staticSymbolCache.get(\n-          ngfactoryFilePath(dirType.filePath), cpl.rendererTypeName(dirType));\n-    } else {\n-      // returning an object as proxy,\n-      // that we fill later during runtime compilation.\n-      return <any>{};\n-    }\n-  }\n-\n-  private getComponentFactory(\n-      selector: string, dirType: any, inputs: {[key: string]: string}|null,\n-      outputs: {[key: string]: string}): StaticSymbol|object {\n-    if (dirType instanceof StaticSymbol) {\n-      return this._staticSymbolCache.get(\n-          ngfactoryFilePath(dirType.filePath), cpl.componentFactoryName(dirType));\n-    } else {\n-      const hostView = this.getHostComponentViewClass(dirType);\n-      // Note: ngContentSelectors will be filled later once the template is\n-      // loaded.\n-      const createComponentFactory =\n-          this._reflector.resolveExternalReference(Identifiers.createComponentFactory);\n-      return createComponentFactory(selector, dirType, <any>hostView, inputs, outputs, []);\n-    }\n-  }\n-\n-  private initComponentFactory(factory: StaticSymbol|object, ngContentSelectors: string[]) {\n-    if (!(factory instanceof StaticSymbol)) {\n-      (factory as any).ngContentSelectors.push(...ngContentSelectors);\n-    }\n-  }\n-\n-  private _loadSummary(type: any, kind: cpl.CompileSummaryKind): cpl.CompileTypeSummary|null {\n-    let typeSummary = this._summaryCache.get(type);\n-    if (!typeSummary) {\n-      const summary = this._summaryResolver.resolveSummary(type);\n-      typeSummary = summary ? summary.type : null;\n-      this._summaryCache.set(type, typeSummary || null);\n-    }\n-    return typeSummary && typeSummary.summaryKind === kind ? typeSummary : null;\n-  }\n-\n-  getHostComponentMetadata(\n-      compMeta: cpl.CompileDirectiveMetadata,\n-      hostViewType?: StaticSymbol|cpl.ProxyClass): cpl.CompileDirectiveMetadata {\n-    const hostType = this.getHostComponentType(compMeta.type.reference);\n-    if (!hostViewType) {\n-      hostViewType = this.getHostComponentViewClass(hostType);\n-    }\n-    // Note: ! is ok here as this method should only be called with normalized directive\n-    // metadata, which always fills in the selector.\n-    const template = CssSelector.parse(compMeta.selector!)[0].getMatchingElementTemplate();\n-    const templateUrl = '';\n-    const htmlAst = this._htmlParser.parse(template, templateUrl);\n-    return cpl.CompileDirectiveMetadata.create({\n-      isHost: true,\n-      type: {reference: hostType, diDeps: [], lifecycleHooks: []},\n-      template: new cpl.CompileTemplateMetadata({\n-        encapsulation: ViewEncapsulation.None,\n-        template,\n-        templateUrl,\n-        htmlAst,\n-        styles: [],\n-        styleUrls: [],\n-        ngContentSelectors: [],\n-        animations: [],\n-        isInline: true,\n-        externalStylesheets: [],\n-        interpolation: null,\n-        preserveWhitespaces: false,\n-      }),\n-      exportAs: null,\n-      changeDetection: ChangeDetectionStrategy.Default,\n-      inputs: [],\n-      outputs: [],\n-      host: {},\n-      isComponent: true,\n-      selector: '*',\n-      providers: [],\n-      viewProviders: [],\n-      queries: [],\n-      guards: {},\n-      viewQueries: [],\n-      componentViewType: hostViewType,\n-      rendererType: {id: '__Host__', encapsulation: ViewEncapsulation.None, styles: [], data: {}} as\n-          object,\n-      entryComponents: [],\n-      componentFactory: null\n-    });\n-  }\n-\n-  loadDirectiveMetadata(ngModuleType: any, directiveType: any, isSync: boolean): SyncAsync<null> {\n-    if (this._directiveCache.has(directiveType)) {\n-      return null;\n-    }\n-    directiveType = resolveForwardRef(directiveType);\n-    const {annotation, metadata} = this.getNonNormalizedDirectiveMetadata(directiveType)!;\n-\n-    const createDirectiveMetadata = (templateMetadata: cpl.CompileTemplateMetadata|null) => {\n-      const normalizedDirMeta = new cpl.CompileDirectiveMetadata({\n-        isHost: false,\n-        type: metadata.type,\n-        isComponent: metadata.isComponent,\n-        selector: metadata.selector,\n-        exportAs: metadata.exportAs,\n-        changeDetection: metadata.changeDetection,\n-        inputs: metadata.inputs,\n-        outputs: metadata.outputs,\n-        hostListeners: metadata.hostListeners,\n-        hostProperties: metadata.hostProperties,\n-        hostAttributes: metadata.hostAttributes,\n-        providers: metadata.providers,\n-        viewProviders: metadata.viewProviders,\n-        queries: metadata.queries,\n-        guards: metadata.guards,\n-        viewQueries: metadata.viewQueries,\n-        entryComponents: metadata.entryComponents,\n-        componentViewType: metadata.componentViewType,\n-        rendererType: metadata.rendererType,\n-        componentFactory: metadata.componentFactory,\n-        template: templateMetadata\n-      });\n-      if (templateMetadata) {\n-        this.initComponentFactory(metadata.componentFactory!, templateMetadata.ngContentSelectors);\n-      }\n-      this._directiveCache.set(directiveType, normalizedDirMeta);\n-      this._summaryCache.set(directiveType, normalizedDirMeta.toSummary());\n-      return null;\n-    };\n-\n-    if (metadata.isComponent) {\n-      const template = metadata.template !;\n-      const templateMeta = this._directiveNormalizer.normalizeTemplate({\n-        ngModuleType,\n-        componentType: directiveType,\n-        moduleUrl: this._reflector.componentModuleUrl(directiveType, annotation),\n-        encapsulation: template.encapsulation,\n-        template: template.template,\n-        templateUrl: template.templateUrl,\n-        styles: template.styles,\n-        styleUrls: template.styleUrls,\n-        animations: template.animations,\n-        interpolation: template.interpolation,\n-        preserveWhitespaces: template.preserveWhitespaces\n-      });\n-      if (isPromise(templateMeta) && isSync) {\n-        this._reportError(componentStillLoadingError(directiveType), directiveType);\n-        return null;\n-      }\n-      return SyncAsync.then(templateMeta, createDirectiveMetadata);\n-    } else {\n-      // directive\n-      createDirectiveMetadata(null);\n-      return null;\n-    }\n-  }\n-\n-  getNonNormalizedDirectiveMetadata(directiveType: any):\n-      {annotation: Directive, metadata: cpl.CompileDirectiveMetadata}|null {\n-    directiveType = resolveForwardRef(directiveType);\n-    if (!directiveType) {\n-      return null;\n-    }\n-    let cacheEntry = this._nonNormalizedDirectiveCache.get(directiveType);\n-    if (cacheEntry) {\n-      return cacheEntry;\n-    }\n-    const dirMeta = this._directiveResolver.resolve(directiveType, false);\n-    if (!dirMeta) {\n-      return null;\n-    }\n-    let nonNormalizedTemplateMetadata: cpl.CompileTemplateMetadata = undefined!;\n-\n-    if (createComponent.isTypeOf(dirMeta)) {\n-      // component\n-      const compMeta = dirMeta as Component;\n-      assertArrayOfStrings('styles', compMeta.styles);\n-      assertArrayOfStrings('styleUrls', compMeta.styleUrls);\n-      assertInterpolationSymbols('interpolation', compMeta.interpolation);\n-\n-      const animations = compMeta.animations;\n-\n-      nonNormalizedTemplateMetadata = new cpl.CompileTemplateMetadata({\n-        encapsulation: noUndefined(compMeta.encapsulation),\n-        template: noUndefined(compMeta.template),\n-        templateUrl: noUndefined(compMeta.templateUrl),\n-        htmlAst: null,\n-        styles: compMeta.styles || [],\n-        styleUrls: compMeta.styleUrls || [],\n-        animations: animations || [],\n-        interpolation: noUndefined(compMeta.interpolation),\n-        isInline: !!compMeta.template,\n-        externalStylesheets: [],\n-        ngContentSelectors: [],\n-        preserveWhitespaces: noUndefined(dirMeta.preserveWhitespaces),\n-      });\n-    }\n-\n-    let changeDetectionStrategy: ChangeDetectionStrategy = null!;\n-    let viewProviders: cpl.CompileProviderMetadata[] = [];\n-    let entryComponentMetadata: cpl.CompileEntryComponentMetadata[] = [];\n-    let selector = dirMeta.selector;\n-\n-    if (createComponent.isTypeOf(dirMeta)) {\n-      // Component\n-      const compMeta = dirMeta as Component;\n-      changeDetectionStrategy = compMeta.changeDetection!;\n-      if (compMeta.viewProviders) {\n-        viewProviders = this._getProvidersMetadata(\n-            compMeta.viewProviders, entryComponentMetadata,\n-            `viewProviders for \"${stringifyType(directiveType)}\"`, [], directiveType);\n-      }\n-      if (compMeta.entryComponents) {\n-        entryComponentMetadata = flattenAndDedupeArray(compMeta.entryComponents)\n-                                     .map((type) => this._getEntryComponentMetadata(type)!)\n-                                     .concat(entryComponentMetadata);\n-      }\n-      if (!selector) {\n-        selector = this._schemaRegistry.getDefaultComponentElementName();\n-      }\n-    } else {\n-      // Directive\n-      if (!selector) {\n-        selector = null!;\n-      }\n-    }\n-\n-    let providers: cpl.CompileProviderMetadata[] = [];\n-    if (dirMeta.providers != null) {\n-      providers = this._getProvidersMetadata(\n-          dirMeta.providers, entryComponentMetadata,\n-          `providers for \"${stringifyType(directiveType)}\"`, [], directiveType);\n-    }\n-    let queries: cpl.CompileQueryMetadata[] = [];\n-    let viewQueries: cpl.CompileQueryMetadata[] = [];\n-    if (dirMeta.queries != null) {\n-      queries = this._getQueriesMetadata(dirMeta.queries, false, directiveType);\n-      viewQueries = this._getQueriesMetadata(dirMeta.queries, true, directiveType);\n-    }\n-\n-    const metadata = cpl.CompileDirectiveMetadata.create({\n-      isHost: false,\n-      selector: selector,\n-      exportAs: noUndefined(dirMeta.exportAs),\n-      isComponent: !!nonNormalizedTemplateMetadata,\n-      type: this._getTypeMetadata(directiveType),\n-      template: nonNormalizedTemplateMetadata,\n-      changeDetection: changeDetectionStrategy,\n-      inputs: dirMeta.inputs || [],\n-      outputs: dirMeta.outputs || [],\n-      host: dirMeta.host || {},\n-      providers: providers || [],\n-      viewProviders: viewProviders || [],\n-      queries: queries || [],\n-      guards: dirMeta.guards || {},\n-      viewQueries: viewQueries || [],\n-      entryComponents: entryComponentMetadata,\n-      componentViewType: nonNormalizedTemplateMetadata ? this.getComponentViewClass(directiveType) :\n-                                                         null,\n-      rendererType: nonNormalizedTemplateMetadata ? this.getRendererType(directiveType) : null,\n-      componentFactory: null\n-    });\n-    if (nonNormalizedTemplateMetadata) {\n-      metadata.componentFactory =\n-          this.getComponentFactory(selector, directiveType, metadata.inputs, metadata.outputs);\n-    }\n-    cacheEntry = {metadata, annotation: dirMeta};\n-    this._nonNormalizedDirectiveCache.set(directiveType, cacheEntry);\n-    return cacheEntry;\n-  }\n-\n-  /**\n-   * Gets the metadata for the given directive.\n-   * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n-   */\n-  getDirectiveMetadata(directiveType: any): cpl.CompileDirectiveMetadata {\n-    const dirMeta = this._directiveCache.get(directiveType)!;\n-    if (!dirMeta) {\n-      this._reportError(\n-          syntaxError(\n-              `Illegal state: getDirectiveMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Directive ${\n-                  stringifyType(directiveType)}.`),\n-          directiveType);\n-    }\n-    return dirMeta;\n-  }\n-\n-  getDirectiveSummary(dirType: any): cpl.CompileDirectiveSummary {\n-    const dirSummary =\n-        <cpl.CompileDirectiveSummary>this._loadSummary(dirType, cpl.CompileSummaryKind.Directive);\n-    if (!dirSummary) {\n-      this._reportError(\n-          syntaxError(\n-              `Illegal state: Could not load the summary for directive ${stringifyType(dirType)}.`),\n-          dirType);\n-    }\n-    return dirSummary;\n-  }\n-\n-  isDirective(type: any) {\n-    return !!this._loadSummary(type, cpl.CompileSummaryKind.Directive) ||\n-        this._directiveResolver.isDirective(type);\n-  }\n-\n-  isAbstractDirective(type: any): boolean {\n-    const summary =\n-        this._loadSummary(type, cpl.CompileSummaryKind.Directive) as cpl.CompileDirectiveSummary;\n-    if (summary && !summary.isComponent) {\n-      return !summary.selector;\n-    }\n-\n-    const meta = this._directiveResolver.resolve(type, false);\n-    if (meta && !createComponent.isTypeOf(meta)) {\n-      return !meta.selector;\n-    }\n-\n-    return false;\n-  }\n-\n-  isPipe(type: any) {\n-    return !!this._loadSummary(type, cpl.CompileSummaryKind.Pipe) ||\n-        this._pipeResolver.isPipe(type);\n-  }\n-\n-  isNgModule(type: any) {\n-    return !!this._loadSummary(type, cpl.CompileSummaryKind.NgModule) ||\n-        this._ngModuleResolver.isNgModule(type);\n-  }\n-\n-  getNgModuleSummary(moduleType: any, alreadyCollecting: Set<any>|null = null):\n-      cpl.CompileNgModuleSummary|null {\n-    let moduleSummary: cpl.CompileNgModuleSummary|null =\n-        <cpl.CompileNgModuleSummary>this._loadSummary(moduleType, cpl.CompileSummaryKind.NgModule);\n-    if (!moduleSummary) {\n-      const moduleMeta = this.getNgModuleMetadata(moduleType, false, alreadyCollecting);\n-      moduleSummary = moduleMeta ? moduleMeta.toSummary() : null;\n-      if (moduleSummary) {\n-        this._summaryCache.set(moduleType, moduleSummary);\n-      }\n-    }\n-    return moduleSummary;\n-  }\n-\n-  /**\n-   * Loads the declared directives and pipes of an NgModule.\n-   */\n-  loadNgModuleDirectiveAndPipeMetadata(moduleType: any, isSync: boolean, throwIfNotFound = true):\n-      Promise<any> {\n-    const ngModule = this.getNgModuleMetadata(moduleType, throwIfNotFound);\n-    const loading: Promise<any>[] = [];\n-    if (ngModule) {\n-      ngModule.declaredDirectives.forEach((id) => {\n-        const promise = this.loadDirectiveMetadata(moduleType, id.reference, isSync);\n-        if (promise) {\n-          loading.push(promise);\n-        }\n-      });\n-      ngModule.declaredPipes.forEach((id) => this._loadPipeMetadata(id.reference));\n-    }\n-    return Promise.all(loading);\n-  }\n-\n-  getShallowModuleMetadata(moduleType: any): cpl.CompileShallowModuleMetadata|null {\n-    let compileMeta = this._shallowModuleCache.get(moduleType);\n-    if (compileMeta) {\n-      return compileMeta;\n-    }\n-\n-    const ngModuleMeta =\n-        findLast(this._reflector.shallowAnnotations(moduleType), createNgModule.isTypeOf);\n-\n-    compileMeta = {\n-      type: this._getTypeMetadata(moduleType),\n-      rawExports: ngModuleMeta.exports,\n-      rawImports: ngModuleMeta.imports,\n-      rawProviders: ngModuleMeta.providers,\n-    };\n-\n-    this._shallowModuleCache.set(moduleType, compileMeta);\n-    return compileMeta;\n-  }\n-\n-  getNgModuleMetadata(\n-      moduleType: any, throwIfNotFound = true,\n-      alreadyCollecting: Set<any>|null = null): cpl.CompileNgModuleMetadata|null {\n-    moduleType = resolveForwardRef(moduleType);\n-    let compileMeta = this._ngModuleCache.get(moduleType);\n-    if (compileMeta) {\n-      return compileMeta;\n-    }\n-    const meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);\n-    if (!meta) {\n-      return null;\n-    }\n-    const declaredDirectives: CompileIdentifierMetadata[] = [];\n-    const exportedNonModuleIdentifiers: CompileIdentifierMetadata[] = [];\n-    const declaredPipes: CompileIdentifierMetadata[] = [];\n-    const importedModules: cpl.CompileNgModuleSummary[] = [];\n-    const exportedModules: cpl.CompileNgModuleSummary[] = [];\n-    const providers: cpl.CompileProviderMetadata[] = [];\n-    const entryComponents: cpl.CompileEntryComponentMetadata[] = [];\n-    const bootstrapComponents: CompileIdentifierMetadata[] = [];\n-    const schemas: SchemaMetadata[] = [];\n-\n-    if (meta.imports) {\n-      flattenAndDedupeArray(meta.imports).forEach((importedType) => {\n-        let importedModuleType: Type = undefined!;\n-        if (isValidType(importedType)) {\n-          importedModuleType = importedType;\n-        } else if (importedType && importedType.ngModule) {\n-          const moduleWithProviders: ModuleWithProviders = importedType;\n-          importedModuleType = moduleWithProviders.ngModule;\n-          if (moduleWithProviders.providers) {\n-            providers.push(...this._getProvidersMetadata(\n-                moduleWithProviders.providers, entryComponents,\n-                `provider for the NgModule '${stringifyType(importedModuleType)}'`, [],\n-                importedType));\n-          }\n-        }\n-\n-        if (importedModuleType) {\n-          if (this._checkSelfImport(moduleType, importedModuleType)) return;\n-          if (!alreadyCollecting) alreadyCollecting = new Set();\n-          if (alreadyCollecting.has(importedModuleType)) {\n-            this._reportError(\n-                syntaxError(`${this._getTypeDescriptor(importedModuleType)} '${\n-                    stringifyType(importedType)}' is imported recursively by the module '${\n-                    stringifyType(moduleType)}'.`),\n-                moduleType);\n-            return;\n-          }\n-          alreadyCollecting.add(importedModuleType);\n-          const importedModuleSummary =\n-              this.getNgModuleSummary(importedModuleType, alreadyCollecting);\n-          alreadyCollecting.delete(importedModuleType);\n-          if (!importedModuleSummary) {\n-            const err = syntaxError(`Unexpected ${this._getTypeDescriptor(importedType)} '${\n-                stringifyType(importedType)}' imported by the module '${\n-                stringifyType(moduleType)}'. Please add a @NgModule annotation.`);\n-            // If possible, record additional context for this error to enable more useful\n-            // diagnostics on the compiler side.\n-            if (importedType instanceof StaticSymbol) {\n-              (err as any)[MISSING_NG_MODULE_METADATA_ERROR_DATA] = {\n-                fileName: importedType.filePath,\n-                className: importedType.name,\n-              } as MissingNgModuleMetadataErrorData;\n-            }\n-            this._reportError(err, moduleType);\n-            return;\n-          }\n-          importedModules.push(importedModuleSummary);\n-        } else {\n-          this._reportError(\n-              syntaxError(\n-                  `Unexpected value '${stringifyType(importedType)}' imported by the module '${\n-                      stringifyType(moduleType)}'`),\n-              moduleType);\n-          return;\n-        }\n-      });\n-    }\n-\n-    if (meta.exports) {\n-      flattenAndDedupeArray(meta.exports).forEach((exportedType) => {\n-        if (!isValidType(exportedType)) {\n-          this._reportError(\n-              syntaxError(\n-                  `Unexpected value '${stringifyType(exportedType)}' exported by the module '${\n-                      stringifyType(moduleType)}'`),\n-              moduleType);\n-          return;\n-        }\n-        if (!alreadyCollecting) alreadyCollecting = new Set();\n-        if (alreadyCollecting.has(exportedType)) {\n-          this._reportError(\n-              syntaxError(`${this._getTypeDescriptor(exportedType)} '${\n-                  stringify(exportedType)}' is exported recursively by the module '${\n-                  stringifyType(moduleType)}'`),\n-              moduleType);\n-          return;\n-        }\n-        alreadyCollecting.add(exportedType);\n-        const exportedModuleSummary = this.getNgModuleSummary(exportedType, alreadyCollecting);\n-        alreadyCollecting.delete(exportedType);\n-        if (exportedModuleSummary) {\n-          exportedModules.push(exportedModuleSummary);\n-        } else {\n-          exportedNonModuleIdentifiers.push(this._getIdentifierMetadata(exportedType));\n-        }\n-      });\n-    }\n-\n-    // Note: This will be modified later, so we rely on\n-    // getting a new instance every time!\n-    const transitiveModule = this._getTransitiveNgModuleMetadata(importedModules, exportedModules);\n-    if (meta.declarations) {\n-      flattenAndDedupeArray(meta.declarations).forEach((declaredType) => {\n-        if (!isValidType(declaredType)) {\n-          this._reportError(\n-              syntaxError(\n-                  `Unexpected value '${stringifyType(declaredType)}' declared by the module '${\n-                      stringifyType(moduleType)}'`),\n-              moduleType);\n-          return;\n-        }\n-        const declaredIdentifier = this._getIdentifierMetadata(declaredType);\n-        if (this.isDirective(declaredType)) {\n-          if (this.isAbstractDirective(declaredType)) {\n-            this._reportError(\n-                syntaxError(\n-                    `Directive ${stringifyType(declaredType)} has no selector, please add it!`),\n-                declaredType);\n-          }\n-          transitiveModule.addDirective(declaredIdentifier);\n-          declaredDirectives.push(declaredIdentifier);\n-          this._addTypeToModule(declaredType, moduleType);\n-        } else if (this.isPipe(declaredType)) {\n-          transitiveModule.addPipe(declaredIdentifier);\n-          transitiveModule.pipes.push(declaredIdentifier);\n-          declaredPipes.push(declaredIdentifier);\n-          this._addTypeToModule(declaredType, moduleType);\n-        } else {\n-          this._reportError(\n-              syntaxError(`Unexpected ${this._getTypeDescriptor(declaredType)} '${\n-                  stringifyType(declaredType)}' declared by the module '${\n-                  stringifyType(\n-                      moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`),\n-              moduleType);\n-          return;\n-        }\n-      });\n-    }\n-\n-    const exportedDirectives: CompileIdentifierMetadata[] = [];\n-    const exportedPipes: CompileIdentifierMetadata[] = [];\n-    exportedNonModuleIdentifiers.forEach((exportedId) => {\n-      if (transitiveModule.directivesSet.has(exportedId.reference)) {\n-        exportedDirectives.push(exportedId);\n-        transitiveModule.addExportedDirective(exportedId);\n-      } else if (transitiveModule.pipesSet.has(exportedId.reference)) {\n-        exportedPipes.push(exportedId);\n-        transitiveModule.addExportedPipe(exportedId);\n-      } else {\n-        this._reportError(\n-            syntaxError(`Can't export ${this._getTypeDescriptor(exportedId.reference)} ${\n-                stringifyType(exportedId.reference)} from ${\n-                stringifyType(moduleType)} as it was neither declared nor imported!`),\n-            moduleType);\n-        return;\n-      }\n-    });\n-\n-    // The providers of the module have to go last\n-    // so that they overwrite any other provider we already added.\n-    if (meta.providers) {\n-      providers.push(...this._getProvidersMetadata(\n-          meta.providers, entryComponents,\n-          `provider for the NgModule '${stringifyType(moduleType)}'`, [], moduleType));\n-    }\n-\n-    if (meta.entryComponents) {\n-      entryComponents.push(...flattenAndDedupeArray(meta.entryComponents)\n-                               .map(type => this._getEntryComponentMetadata(type)!));\n-    }\n-\n-    if (meta.bootstrap) {\n-      flattenAndDedupeArray(meta.bootstrap).forEach(type => {\n-        if (!isValidType(type)) {\n-          this._reportError(\n-              syntaxError(`Unexpected value '${\n-                  stringifyType(type)}' used in the bootstrap property of module '${\n-                  stringifyType(moduleType)}'`),\n-              moduleType);\n-          return;\n-        }\n-        bootstrapComponents.push(this._getIdentifierMetadata(type));\n-      });\n-    }\n-\n-    entryComponents.push(\n-        ...bootstrapComponents.map(type => this._getEntryComponentMetadata(type.reference)!));\n-\n-    if (meta.schemas) {\n-      schemas.push(...flattenAndDedupeArray(meta.schemas));\n-    }\n-\n-    compileMeta = new cpl.CompileNgModuleMetadata({\n-      type: this._getTypeMetadata(moduleType),\n-      providers,\n-      entryComponents,\n-      bootstrapComponents,\n-      schemas,\n-      declaredDirectives,\n-      exportedDirectives,\n-      declaredPipes,\n-      exportedPipes,\n-      importedModules,\n-      exportedModules,\n-      transitiveModule,\n-      id: meta.id || null,\n-    });\n-\n-    entryComponents.forEach((id) => transitiveModule.addEntryComponent(id));\n-    providers.forEach((provider) => transitiveModule.addProvider(provider, compileMeta!.type));\n-    transitiveModule.addModule(compileMeta.type);\n-    this._ngModuleCache.set(moduleType, compileMeta);\n-    return compileMeta;\n-  }\n-\n-  private _checkSelfImport(moduleType: Type, importedModuleType: Type): boolean {\n-    if (moduleType === importedModuleType) {\n-      this._reportError(\n-          syntaxError(`'${stringifyType(moduleType)}' module can't import itself`), moduleType);\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  private _getTypeDescriptor(type: Type): string {\n-    if (isValidType(type)) {\n-      if (this.isDirective(type)) {\n-        return 'directive';\n-      }\n-\n-      if (this.isPipe(type)) {\n-        return 'pipe';\n-      }\n-\n-      if (this.isNgModule(type)) {\n-        return 'module';\n-      }\n-    }\n-\n-    if ((type as any).provide) {\n-      return 'provider';\n-    }\n-\n-    return 'value';\n-  }\n-\n-\n-  private _addTypeToModule(type: Type, moduleType: Type) {\n-    const oldModule = this._ngModuleOfTypes.get(type);\n-    if (oldModule && oldModule !== moduleType) {\n-      this._reportError(\n-          syntaxError(\n-              `Type ${stringifyType(type)} is part of the declarations of 2 modules: ${\n-                  stringifyType(oldModule)} and ${stringifyType(moduleType)}! ` +\n-              `Please consider moving ${stringifyType(type)} to a higher module that imports ${\n-                  stringifyType(oldModule)} and ${stringifyType(moduleType)}. ` +\n-              `You can also create a new NgModule that exports and includes ${\n-                  stringifyType(type)} then import that NgModule in ${\n-                  stringifyType(oldModule)} and ${stringifyType(moduleType)}.`),\n-          moduleType);\n-      return;\n-    }\n-    this._ngModuleOfTypes.set(type, moduleType);\n-  }\n-\n-  private _getTransitiveNgModuleMetadata(\n-      importedModules: cpl.CompileNgModuleSummary[],\n-      exportedModules: cpl.CompileNgModuleSummary[]): cpl.TransitiveCompileNgModuleMetadata {\n-    // collect `providers` / `entryComponents` from all imported and all exported modules\n-    const result = new cpl.TransitiveCompileNgModuleMetadata();\n-    const modulesByToken = new Map<any, Set<any>>();\n-    importedModules.concat(exportedModules).forEach((modSummary) => {\n-      modSummary.modules.forEach((mod) => result.addModule(mod));\n-      modSummary.entryComponents.forEach((comp) => result.addEntryComponent(comp));\n-      const addedTokens = new Set<any>();\n-      modSummary.providers.forEach((entry) => {\n-        const tokenRef = cpl.tokenReference(entry.provider.token);\n-        let prevModules = modulesByToken.get(tokenRef);\n-        if (!prevModules) {\n-          prevModules = new Set<any>();\n-          modulesByToken.set(tokenRef, prevModules);\n-        }\n-        const moduleRef = entry.module.reference;\n-        // Note: the providers of one module may still contain multiple providers\n-        // per token (e.g. for multi providers), and we need to preserve these.\n-        if (addedTokens.has(tokenRef) || !prevModules.has(moduleRef)) {\n-          prevModules.add(moduleRef);\n-          addedTokens.add(tokenRef);\n-          result.addProvider(entry.provider, entry.module);\n-        }\n-      });\n-    });\n-    exportedModules.forEach((modSummary) => {\n-      modSummary.exportedDirectives.forEach((id) => result.addExportedDirective(id));\n-      modSummary.exportedPipes.forEach((id) => result.addExportedPipe(id));\n-    });\n-    importedModules.forEach((modSummary) => {\n-      modSummary.exportedDirectives.forEach((id) => result.addDirective(id));\n-      modSummary.exportedPipes.forEach((id) => result.addPipe(id));\n-    });\n-    return result;\n-  }\n-\n-  private _getIdentifierMetadata(type: Type): CompileIdentifierMetadata {\n-    type = resolveForwardRef(type);\n-    return {reference: type};\n-  }\n-\n-  isInjectable(type: any): boolean {\n-    const annotations = this._reflector.tryAnnotations(type);\n-    return annotations.some(ann => createInjectable.isTypeOf(ann));\n-  }\n-\n-  getInjectableSummary(type: any): cpl.CompileTypeSummary {\n-    return {\n-      summaryKind: cpl.CompileSummaryKind.Injectable,\n-      type: this._getTypeMetadata(type, null, false)\n-    };\n-  }\n-\n-  getInjectableMetadata(\n-      type: any, dependencies: any[]|null = null,\n-      throwOnUnknownDeps: boolean = true): cpl.CompileInjectableMetadata|null {\n-    const typeSummary = this._loadSummary(type, cpl.CompileSummaryKind.Injectable);\n-    const typeMetadata = typeSummary ?\n-        typeSummary.type :\n-        this._getTypeMetadata(type, dependencies, throwOnUnknownDeps);\n-\n-    const annotations: Injectable[] =\n-        this._reflector.annotations(type).filter(ann => createInjectable.isTypeOf(ann));\n-\n-    if (annotations.length === 0) {\n-      return null;\n-    }\n-\n-    const meta = annotations[annotations.length - 1];\n-    return {\n-      symbol: type,\n-      type: typeMetadata,\n-      providedIn: meta.providedIn,\n-      useValue: meta.useValue,\n-      useClass: meta.useClass,\n-      useExisting: meta.useExisting,\n-      useFactory: meta.useFactory,\n-      deps: meta.deps,\n-    };\n-  }\n-\n-  private _getTypeMetadata(type: Type, dependencies: any[]|null = null, throwOnUnknownDeps = true):\n-      cpl.CompileTypeMetadata {\n-    const identifier = this._getIdentifierMetadata(type);\n-    return {\n-      reference: identifier.reference,\n-      diDeps: this._getDependenciesMetadata(identifier.reference, dependencies, throwOnUnknownDeps),\n-      lifecycleHooks: getAllLifecycleHooks(this._reflector, identifier.reference),\n-    };\n-  }\n-\n-  private _getFactoryMetadata(factory: Function, dependencies: any[]|null = null):\n-      cpl.CompileFactoryMetadata {\n-    factory = resolveForwardRef(factory);\n-    return {reference: factory, diDeps: this._getDependenciesMetadata(factory, dependencies)};\n-  }\n-\n-  /**\n-   * Gets the metadata for the given pipe.\n-   * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n-   */\n-  getPipeMetadata(pipeType: any): cpl.CompilePipeMetadata|null {\n-    const pipeMeta = this._pipeCache.get(pipeType);\n-    if (!pipeMeta) {\n-      this._reportError(\n-          syntaxError(\n-              `Illegal state: getPipeMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Pipe ${\n-                  stringifyType(pipeType)}.`),\n-          pipeType);\n-    }\n-    return pipeMeta || null;\n-  }\n-\n-  getPipeSummary(pipeType: any): cpl.CompilePipeSummary {\n-    const pipeSummary =\n-        <cpl.CompilePipeSummary>this._loadSummary(pipeType, cpl.CompileSummaryKind.Pipe);\n-    if (!pipeSummary) {\n-      this._reportError(\n-          syntaxError(\n-              `Illegal state: Could not load the summary for pipe ${stringifyType(pipeType)}.`),\n-          pipeType);\n-    }\n-    return pipeSummary;\n-  }\n-\n-  getOrLoadPipeMetadata(pipeType: any): cpl.CompilePipeMetadata {\n-    let pipeMeta = this._pipeCache.get(pipeType);\n-    if (!pipeMeta) {\n-      pipeMeta = this._loadPipeMetadata(pipeType);\n-    }\n-    return pipeMeta;\n-  }\n-\n-  private _loadPipeMetadata(pipeType: any): cpl.CompilePipeMetadata {\n-    pipeType = resolveForwardRef(pipeType);\n-    const pipeAnnotation = this._pipeResolver.resolve(pipeType)!;\n-\n-    const pipeMeta = new cpl.CompilePipeMetadata({\n-      type: this._getTypeMetadata(pipeType),\n-      name: pipeAnnotation.name,\n-      pure: !!pipeAnnotation.pure\n-    });\n-    this._pipeCache.set(pipeType, pipeMeta);\n-    this._summaryCache.set(pipeType, pipeMeta.toSummary());\n-    return pipeMeta;\n-  }\n-\n-  private _getDependenciesMetadata(\n-      typeOrFunc: Type|Function, dependencies: any[]|null,\n-      throwOnUnknownDeps = true): cpl.CompileDiDependencyMetadata[] {\n-    let hasUnknownDeps = false;\n-    const params = dependencies || this._reflector.parameters(typeOrFunc) || [];\n-\n-    const dependenciesMetadata: cpl.CompileDiDependencyMetadata[] = params.map((param) => {\n-      let isAttribute = false;\n-      let isHost = false;\n-      let isSelf = false;\n-      let isSkipSelf = false;\n-      let isOptional = false;\n-      let token: any = null;\n-      if (Array.isArray(param)) {\n-        param.forEach((paramEntry: any) => {\n-          if (createHost.isTypeOf(paramEntry)) {\n-            isHost = true;\n-          } else if (createSelf.isTypeOf(paramEntry)) {\n-            isSelf = true;\n-          } else if (createSkipSelf.isTypeOf(paramEntry)) {\n-            isSkipSelf = true;\n-          } else if (createOptional.isTypeOf(paramEntry)) {\n-            isOptional = true;\n-          } else if (createAttribute.isTypeOf(paramEntry)) {\n-            isAttribute = true;\n-            token = (paramEntry as any).attributeName;\n-          } else if (createInject.isTypeOf(paramEntry)) {\n-            token = (paramEntry as any).token;\n-          } else if (\n-              createInjectionToken.isTypeOf(paramEntry) ||\n-              (paramEntry as any) instanceof StaticSymbol) {\n-            token = paramEntry;\n-          } else if (isValidType(paramEntry) && token == null) {\n-            token = paramEntry;\n-          }\n-        });\n-      } else {\n-        token = param;\n-      }\n-      if (token == null) {\n-        hasUnknownDeps = true;\n-        return {};\n-      }\n-\n-      return {\n-        isAttribute,\n-        isHost,\n-        isSelf,\n-        isSkipSelf,\n-        isOptional,\n-        token: this._getTokenMetadata(token)\n-      };\n-    });\n-\n-    if (hasUnknownDeps) {\n-      const depsTokens =\n-          dependenciesMetadata.map((dep) => dep.token ? stringifyType(dep.token) : '?').join(', ');\n-      const message =\n-          `Can't resolve all parameters for ${stringifyType(typeOrFunc)}: (${depsTokens}).`;\n-      if (throwOnUnknownDeps || this._config.strictInjectionParameters) {\n-        this._reportError(syntaxError(message), typeOrFunc);\n-      }\n-    }\n-\n-    return dependenciesMetadata;\n-  }\n-\n-  private _getTokenMetadata(token: any): cpl.CompileTokenMetadata {\n-    token = resolveForwardRef(token);\n-    let compileToken: cpl.CompileTokenMetadata;\n-    if (typeof token === 'string') {\n-      compileToken = {value: token};\n-    } else {\n-      compileToken = {identifier: {reference: token}};\n-    }\n-    return compileToken;\n-  }\n-\n-  private _getProvidersMetadata(\n-      providers: Provider[], targetEntryComponents: cpl.CompileEntryComponentMetadata[],\n-      debugInfo?: string, compileProviders: cpl.CompileProviderMetadata[] = [],\n-      type?: any): cpl.CompileProviderMetadata[] {\n-    providers.forEach((provider: any, providerIdx: number) => {\n-      if (Array.isArray(provider)) {\n-        this._getProvidersMetadata(provider, targetEntryComponents, debugInfo, compileProviders);\n-      } else {\n-        provider = resolveForwardRef(provider);\n-        let providerMeta: cpl.ProviderMeta = undefined!;\n-        if (provider && typeof provider === 'object' && provider.hasOwnProperty('provide')) {\n-          this._validateProvider(provider);\n-          providerMeta = new cpl.ProviderMeta(provider.provide, provider);\n-        } else if (isValidType(provider)) {\n-          providerMeta = new cpl.ProviderMeta(provider, {useClass: provider});\n-        } else if (provider === void 0) {\n-          this._reportError(syntaxError(\n-              `Encountered undefined provider! Usually this means you have a circular dependencies. This might be caused by using 'barrel' index.ts files.`));\n-          return;\n-        } else {\n-          const providersInfo =\n-              providers\n-                  .reduce(\n-                      (soFar: string[], seenProvider: any, seenProviderIdx: number) => {\n-                        if (seenProviderIdx < providerIdx) {\n-                          soFar.push(`${stringifyType(seenProvider)}`);\n-                        } else if (seenProviderIdx == providerIdx) {\n-                          soFar.push(`?${stringifyType(seenProvider)}?`);\n-                        } else if (seenProviderIdx == providerIdx + 1) {\n-                          soFar.push('...');\n-                        }\n-                        return soFar;\n-                      },\n-                      [])\n-                  .join(', ');\n-          this._reportError(\n-              syntaxError(`Invalid ${\n-                  debugInfo ?\n-                      debugInfo :\n-                      'provider'} - only instances of Provider and Type are allowed, got: [${\n-                  providersInfo}]`),\n-              type);\n-          return;\n-        }\n-        if (providerMeta.token ===\n-            this._reflector.resolveExternalReference(Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS)) {\n-          targetEntryComponents.push(...this._getEntryComponentsFromProvider(providerMeta, type));\n-        } else {\n-          compileProviders.push(this.getProviderMetadata(providerMeta));\n-        }\n-      }\n-    });\n-    return compileProviders;\n-  }\n-\n-  private _validateProvider(provider: any): void {\n-    if (provider.hasOwnProperty('useClass') && provider.useClass == null) {\n-      this._reportError(syntaxError(`Invalid provider for ${\n-          stringifyType(provider.provide)}. useClass cannot be ${provider.useClass}.\n-           Usually it happens when:\n-           1. There's a circular dependency (might be caused by using index.ts (barrel) files).\n-           2. Class was used before it was declared. Use forwardRef in this case.`));\n-    }\n-  }\n-\n-  private _getEntryComponentsFromProvider(provider: cpl.ProviderMeta, type?: any):\n-      cpl.CompileEntryComponentMetadata[] {\n-    const components: cpl.CompileEntryComponentMetadata[] = [];\n-    const collectedIdentifiers: CompileIdentifierMetadata[] = [];\n-\n-    if (provider.useFactory || provider.useExisting || provider.useClass) {\n-      this._reportError(\n-          syntaxError(`The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!`), type);\n-      return [];\n-    }\n-\n-    if (!provider.multi) {\n-      this._reportError(\n-          syntaxError(`The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!`),\n-          type);\n-      return [];\n-    }\n-\n-    extractIdentifiers(provider.useValue, collectedIdentifiers);\n-    collectedIdentifiers.forEach((identifier) => {\n-      const entry = this._getEntryComponentMetadata(identifier.reference, false);\n-      if (entry) {\n-        components.push(entry);\n-      }\n-    });\n-    return components;\n-  }\n-\n-  private _getEntryComponentMetadata(dirType: any, throwIfNotFound = true):\n-      cpl.CompileEntryComponentMetadata|null {\n-    const dirMeta = this.getNonNormalizedDirectiveMetadata(dirType);\n-    if (dirMeta && dirMeta.metadata.isComponent) {\n-      return {componentType: dirType, componentFactory: dirMeta.metadata.componentFactory!};\n-    }\n-    const dirSummary =\n-        <cpl.CompileDirectiveSummary>this._loadSummary(dirType, cpl.CompileSummaryKind.Directive);\n-    if (dirSummary && dirSummary.isComponent) {\n-      return {componentType: dirType, componentFactory: dirSummary.componentFactory!};\n-    }\n-    if (throwIfNotFound) {\n-      throw syntaxError(`${dirType.name} cannot be used as an entry component.`);\n-    }\n-    return null;\n-  }\n-\n-  private _getInjectableTypeMetadata(type: Type, dependencies: any[]|null = null):\n-      cpl.CompileTypeMetadata {\n-    const typeSummary = this._loadSummary(type, cpl.CompileSummaryKind.Injectable);\n-    if (typeSummary) {\n-      return typeSummary.type;\n-    }\n-    return this._getTypeMetadata(type, dependencies);\n-  }\n-\n-  getProviderMetadata(provider: cpl.ProviderMeta): cpl.CompileProviderMetadata {\n-    let compileDeps: cpl.CompileDiDependencyMetadata[] = undefined!;\n-    let compileTypeMetadata: cpl.CompileTypeMetadata = null!;\n-    let compileFactoryMetadata: cpl.CompileFactoryMetadata = null!;\n-    let token: cpl.CompileTokenMetadata = this._getTokenMetadata(provider.token);\n-\n-    if (provider.useClass) {\n-      compileTypeMetadata =\n-          this._getInjectableTypeMetadata(provider.useClass, provider.dependencies);\n-      compileDeps = compileTypeMetadata.diDeps;\n-      if (provider.token === provider.useClass) {\n-        // use the compileTypeMetadata as it contains information about lifecycleHooks...\n-        token = {identifier: compileTypeMetadata};\n-      }\n-    } else if (provider.useFactory) {\n-      compileFactoryMetadata = this._getFactoryMetadata(provider.useFactory, provider.dependencies);\n-      compileDeps = compileFactoryMetadata.diDeps;\n-    }\n-\n-    return {\n-      token: token,\n-      useClass: compileTypeMetadata,\n-      useValue: provider.useValue,\n-      useFactory: compileFactoryMetadata,\n-      useExisting: provider.useExisting ? this._getTokenMetadata(provider.useExisting) : undefined,\n-      deps: compileDeps,\n-      multi: provider.multi\n-    };\n-  }\n-\n-  private _getQueriesMetadata(\n-      queries: {[key: string]: Query}, isViewQuery: boolean,\n-      directiveType: Type): cpl.CompileQueryMetadata[] {\n-    const res: cpl.CompileQueryMetadata[] = [];\n-\n-    Object.keys(queries).forEach((propertyName: string) => {\n-      const query = queries[propertyName];\n-      if (query.isViewQuery === isViewQuery) {\n-        res.push(this._getQueryMetadata(query, propertyName, directiveType));\n-      }\n-    });\n-\n-    return res;\n-  }\n-\n-  private _queryVarBindings(selector: any): string[] {\n-    return selector.split(/\\s*,\\s*/);\n-  }\n-\n-  private _getQueryMetadata(q: Query, propertyName: string, typeOrFunc: Type|Function):\n-      cpl.CompileQueryMetadata {\n-    let selectors: cpl.CompileTokenMetadata[];\n-    if (typeof q.selector === 'string') {\n-      selectors =\n-          this._queryVarBindings(q.selector).map(varName => this._getTokenMetadata(varName));\n-    } else {\n-      if (!q.selector) {\n-        this._reportError(\n-            syntaxError(`Can't construct a query for the property \"${propertyName}\" of \"${\n-                stringifyType(typeOrFunc)}\" since the query selector wasn't defined.`),\n-            typeOrFunc);\n-        selectors = [];\n-      } else {\n-        selectors = [this._getTokenMetadata(q.selector)];\n-      }\n-    }\n-\n-    return {\n-      selectors,\n-      first: q.first,\n-      descendants: q.descendants,\n-      emitDistinctChangesOnly: q.emitDistinctChangesOnly,\n-      propertyName,\n-      read: q.read ? this._getTokenMetadata(q.read) : null!,\n-      static: q.static\n-    };\n-  }\n-\n-  private _reportError(error: any, type?: any, otherType?: any) {\n-    if (this._errorCollector) {\n-      this._errorCollector(error, type);\n-      if (otherType) {\n-        this._errorCollector(error, otherType);\n-      }\n-    } else {\n-      throw error;\n-    }\n-  }\n-}\n-\n-function flattenArray(tree: any[], out: Array<any> = []): Array<any> {\n-  if (tree) {\n-    for (let i = 0; i < tree.length; i++) {\n-      const item = resolveForwardRef(tree[i]);\n-      if (Array.isArray(item)) {\n-        flattenArray(item, out);\n-      } else {\n-        out.push(item);\n-      }\n-    }\n-  }\n-  return out;\n-}\n-\n-function dedupeArray(array: any[]): Array<any> {\n-  if (array) {\n-    return Array.from(new Set(array));\n-  }\n-  return [];\n-}\n-\n-function flattenAndDedupeArray(tree: any[]): Array<any> {\n-  return dedupeArray(flattenArray(tree));\n-}\n-\n-function isValidType(value: any): boolean {\n-  return (value instanceof StaticSymbol) || (value instanceof Type);\n-}\n-\n-function extractIdentifiers(value: any, targetIdentifiers: CompileIdentifierMetadata[]) {\n-  visitValue(value, new _CompileValueConverter(), targetIdentifiers);\n-}\n-\n-class _CompileValueConverter extends ValueTransformer {\n-  override visitOther(value: any, targetIdentifiers: CompileIdentifierMetadata[]): any {\n-    targetIdentifiers.push({reference: value});\n-  }\n-}\n-\n-function stringifyType(type: any): string {\n-  if (type instanceof StaticSymbol) {\n-    return `${type.name} in ${type.filePath}`;\n-  } else {\n-    return stringify(type);\n-  }\n-}\n-\n-/**\n- * Indicates that a component is still being loaded in a synchronous compile.\n- */\n-function componentStillLoadingError(compType: Type) {\n-  const error =\n-      Error(`Can't compile synchronously as ${stringify(compType)} is still being loaded!`);\n-  (error as any)[ERROR_COMPONENT_TYPE] = compType;\n-  return error;\n-}"
        },
        {
            "sha": "4359a7170ed2caa3f3d553a0d7648452d7b340e5",
            "filename": "packages/compiler/src/ng_module_compiler.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 86,
            "changes": 86,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fng_module_compiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fng_module_compiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fng_module_compiler.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,86 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompileNgModuleMetadata, CompileProviderMetadata} from './compile_metadata';\n-import {CompileReflector} from './compile_reflector';\n-import {OutputContext} from './constant_pool';\n-import {NodeFlags} from './core';\n-import {Identifiers} from './identifiers';\n-import * as o from './output/output_ast';\n-import {identifierName, typeSourceSpan} from './parse_util';\n-import {NgModuleProviderAnalyzer} from './provider_analyzer';\n-import {componentFactoryResolverProviderDef, depDef, providerDef} from './view_compiler/provider_compiler';\n-\n-export class NgModuleCompileResult {\n-  constructor(public ngModuleFactoryVar: string) {}\n-}\n-\n-const LOG_VAR = o.variable('_l');\n-\n-export class NgModuleCompiler {\n-  constructor(private reflector: CompileReflector) {}\n-  compile(\n-      ctx: OutputContext, ngModuleMeta: CompileNgModuleMetadata,\n-      extraProviders: CompileProviderMetadata[]): NgModuleCompileResult {\n-    const sourceSpan = typeSourceSpan('NgModule', ngModuleMeta.type);\n-    const entryComponentFactories = ngModuleMeta.transitiveModule.entryComponents;\n-    const bootstrapComponents = ngModuleMeta.bootstrapComponents;\n-    const providerParser =\n-        new NgModuleProviderAnalyzer(this.reflector, ngModuleMeta, extraProviders, sourceSpan);\n-    const providerDefs =\n-        [componentFactoryResolverProviderDef(\n-             this.reflector, ctx, NodeFlags.None, entryComponentFactories)]\n-            .concat(providerParser.parse().map((provider) => providerDef(ctx, provider)))\n-            .map(({providerExpr, depsExpr, flags, tokenExpr}) => {\n-              return o.importExpr(Identifiers.moduleProviderDef).callFn([\n-                o.literal(flags), tokenExpr, providerExpr, depsExpr\n-              ]);\n-            });\n-\n-    const ngModuleDef = o.importExpr(Identifiers.moduleDef).callFn([o.literalArr(providerDefs)]);\n-    const ngModuleDefFactory =\n-        o.fn([new o.FnParam(LOG_VAR.name!)], [new o.ReturnStatement(ngModuleDef)], o.INFERRED_TYPE);\n-\n-    const ngModuleFactoryVar = `${identifierName(ngModuleMeta.type)}NgFactory`;\n-    this._createNgModuleFactory(\n-        ctx, ngModuleMeta.type.reference, o.importExpr(Identifiers.createModuleFactory).callFn([\n-          ctx.importExpr(ngModuleMeta.type.reference),\n-          o.literalArr(bootstrapComponents.map(id => ctx.importExpr(id.reference))),\n-          ngModuleDefFactory\n-        ]));\n-\n-    if (ngModuleMeta.id) {\n-      const id = typeof ngModuleMeta.id === 'string' ? o.literal(ngModuleMeta.id) :\n-                                                       ctx.importExpr(ngModuleMeta.id);\n-      const registerFactoryStmt = o.importExpr(Identifiers.RegisterModuleFactoryFn)\n-                                      .callFn([id, o.variable(ngModuleFactoryVar)])\n-                                      .toStmt();\n-      ctx.statements.push(registerFactoryStmt);\n-    }\n-\n-    return new NgModuleCompileResult(ngModuleFactoryVar);\n-  }\n-\n-  createStub(ctx: OutputContext, ngModuleReference: any) {\n-    this._createNgModuleFactory(ctx, ngModuleReference, o.NULL_EXPR);\n-  }\n-\n-  private _createNgModuleFactory(ctx: OutputContext, reference: any, value: o.Expression) {\n-    const ngModuleFactoryVar = `${identifierName({reference: reference})}NgFactory`;\n-    const ngModuleFactoryStmt =\n-        o.variable(ngModuleFactoryVar)\n-            .set(value)\n-            .toDeclStmt(\n-                o.importType(\n-                    Identifiers.NgModuleFactory, [o.expressionType(ctx.importExpr(reference))!],\n-                    [o.TypeModifier.Const]),\n-                [o.StmtModifier.Final, o.StmtModifier.Exported]);\n-\n-    ctx.statements.push(ngModuleFactoryStmt);\n-  }\n-}"
        },
        {
            "sha": "3952b3881122f4c9368109960c1719631a147d7e",
            "filename": "packages/compiler/src/ng_module_resolver.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 38,
            "changes": 38,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fng_module_resolver.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fng_module_resolver.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fng_module_resolver.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,38 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompileReflector} from './compile_reflector';\n-import {createNgModule, NgModule, Type} from './core';\n-import {findLast} from './directive_resolver';\n-import {stringify} from './util';\n-\n-\n-/**\n- * Resolves types to {@link NgModule}.\n- */\n-export class NgModuleResolver {\n-  constructor(private _reflector: CompileReflector) {}\n-\n-  isNgModule(type: any) {\n-    return this._reflector.annotations(type).some(createNgModule.isTypeOf);\n-  }\n-\n-  resolve(type: Type, throwIfNotFound = true): NgModule|null {\n-    const ngModuleMeta: NgModule =\n-        findLast(this._reflector.annotations(type), createNgModule.isTypeOf);\n-\n-    if (ngModuleMeta) {\n-      return ngModuleMeta;\n-    } else {\n-      if (throwIfNotFound) {\n-        throw new Error(`No NgModule metadata found for '${stringify(type)}'.`);\n-      }\n-      return null;\n-    }\n-  }\n-}"
        },
        {
            "sha": "b3fdc719c6ff6a6771278133ce63a438c4c1f31f",
            "filename": "packages/compiler/src/output/js_emitter.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 77,
            "changes": 77,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Foutput%2Fjs_emitter.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Foutput%2Fjs_emitter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Foutput%2Fjs_emitter.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,77 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import {EmitterVisitorContext, OutputEmitter} from './abstract_emitter';\n-import {AbstractJsEmitterVisitor} from './abstract_js_emitter';\n-import * as o from './output_ast';\n-\n-export class JavaScriptEmitter implements OutputEmitter {\n-  emitStatements(genFilePath: string, stmts: o.Statement[], preamble: string = ''): string {\n-    const converter = new JsEmitterVisitor();\n-    const ctx = EmitterVisitorContext.createRoot();\n-    converter.visitAllStatements(stmts, ctx);\n-\n-    const preambleLines = preamble ? preamble.split('\\n') : [];\n-    converter.importsWithPrefixes.forEach((prefix, importedModuleName) => {\n-      // Note: can't write the real word for import as it screws up system.js auto detection...\n-      preambleLines.push(\n-          `var ${prefix} = req` +\n-          `uire('${importedModuleName}');`);\n-    });\n-\n-    const sm = ctx.toSourceMapGenerator(genFilePath, preambleLines.length).toJsComment();\n-    const lines = [...preambleLines, ctx.toSource(), sm];\n-    if (sm) {\n-      // always add a newline at the end, as some tools have bugs without it.\n-      lines.push('');\n-    }\n-    return lines.join('\\n');\n-  }\n-}\n-\n-class JsEmitterVisitor extends AbstractJsEmitterVisitor {\n-  importsWithPrefixes = new Map<string, string>();\n-\n-  override visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any {\n-    const {name, moduleName} = ast.value;\n-    if (moduleName) {\n-      let prefix = this.importsWithPrefixes.get(moduleName);\n-      if (prefix == null) {\n-        prefix = `i${this.importsWithPrefixes.size}`;\n-        this.importsWithPrefixes.set(moduleName, prefix);\n-      }\n-      ctx.print(ast, `${prefix}.`);\n-    }\n-    ctx.print(ast, name!);\n-    return null;\n-  }\n-  override visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any {\n-    super.visitDeclareVarStmt(stmt, ctx);\n-    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n-      ctx.println(stmt, exportVar(stmt.name));\n-    }\n-    return null;\n-  }\n-  override visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: EmitterVisitorContext): any {\n-    super.visitDeclareFunctionStmt(stmt, ctx);\n-    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n-      ctx.println(stmt, exportVar(stmt.name));\n-    }\n-    return null;\n-  }\n-  override visitDeclareClassStmt(stmt: o.ClassStmt, ctx: EmitterVisitorContext): any {\n-    super.visitDeclareClassStmt(stmt, ctx);\n-    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n-      ctx.println(stmt, exportVar(stmt.name));\n-    }\n-    return null;\n-  }\n-}\n-\n-function exportVar(varName: string): string {\n-  return `Object.defineProperty(exports, '${varName}', { get: function() { return ${varName}; }});`;\n-}"
        },
        {
            "sha": "d8fc45c5415a5864f1b6b09662b64df9ceecf507",
            "filename": "packages/compiler/src/output/output_interpreter.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 368,
            "changes": 368,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_interpreter.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_interpreter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_interpreter.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,368 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import {CompileReflector} from '../compile_reflector';\n-import * as o from './output_ast';\n-import {debugOutputAstAsTypeScript} from './ts_emitter';\n-\n-export function interpretStatements(\n-    statements: o.Statement[], reflector: CompileReflector): {[key: string]: any} {\n-  const ctx = new _ExecutionContext(null, null, null, new Map<string, any>());\n-  const visitor = new StatementInterpreter(reflector);\n-  visitor.visitAllStatements(statements, ctx);\n-  const result: {[key: string]: any} = {};\n-  ctx.exports.forEach((exportName) => {\n-    result[exportName] = ctx.vars.get(exportName);\n-  });\n-  return result;\n-}\n-\n-function _executeFunctionStatements(\n-    varNames: string[], varValues: any[], statements: o.Statement[], ctx: _ExecutionContext,\n-    visitor: StatementInterpreter): any {\n-  const childCtx = ctx.createChildWihtLocalVars();\n-  for (let i = 0; i < varNames.length; i++) {\n-    childCtx.vars.set(varNames[i], varValues[i]);\n-  }\n-  const result = visitor.visitAllStatements(statements, childCtx);\n-  return result ? result.value : null;\n-}\n-\n-class _ExecutionContext {\n-  exports: string[] = [];\n-\n-  constructor(\n-      public parent: _ExecutionContext|null, public instance: Object|null,\n-      public className: string|null, public vars: Map<string, any>) {}\n-\n-  createChildWihtLocalVars(): _ExecutionContext {\n-    return new _ExecutionContext(this, this.instance, this.className, new Map<string, any>());\n-  }\n-}\n-\n-class ReturnValue {\n-  constructor(public value: any) {}\n-}\n-\n-function createDynamicClass(\n-    _classStmt: o.ClassStmt, _ctx: _ExecutionContext, _visitor: StatementInterpreter): Function {\n-  const propertyDescriptors: {[key: string]: any} = {};\n-\n-  _classStmt.getters.forEach((getter: o.ClassGetter) => {\n-    // Note: use `function` instead of arrow function to capture `this`\n-    propertyDescriptors[getter.name] = {\n-      configurable: false,\n-      get: function() {\n-        const instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n-        return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);\n-      }\n-    };\n-  });\n-  _classStmt.methods.forEach(function(method: o.ClassMethod) {\n-    const paramNames = method.params.map(param => param.name);\n-    // Note: use `function` instead of arrow function to capture `this`\n-    propertyDescriptors[method.name!] = {\n-      writable: false,\n-      configurable: false,\n-      value: function(...args: any[]) {\n-        const instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n-        return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);\n-      }\n-    };\n-  });\n-\n-  const ctorParamNames = _classStmt.constructorMethod.params.map(param => param.name);\n-  // Note: use `function` instead of arrow function to capture `this`\n-  const ctor = function(this: Object, ...args: any[]) {\n-    const instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n-    _classStmt.fields.forEach((field) => {\n-      (this as any)[field.name] = undefined;\n-    });\n-    _executeFunctionStatements(\n-        ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);\n-  };\n-  const superClass = _classStmt.parent ? _classStmt.parent.visitExpression(_visitor, _ctx) : Object;\n-  ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);\n-  return ctor;\n-}\n-\n-class StatementInterpreter implements o.StatementVisitor, o.ExpressionVisitor {\n-  constructor(private reflector: CompileReflector) {}\n-  debugAst(ast: o.Expression|o.Statement|o.Type): string {\n-    return debugOutputAstAsTypeScript(ast);\n-  }\n-\n-  visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: _ExecutionContext): any {\n-    const initialValue = stmt.value ? stmt.value.visitExpression(this, ctx) : undefined;\n-    ctx.vars.set(stmt.name, initialValue);\n-    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n-      ctx.exports.push(stmt.name);\n-    }\n-    return null;\n-  }\n-  visitWriteVarExpr(expr: o.WriteVarExpr, ctx: _ExecutionContext): any {\n-    const value = expr.value.visitExpression(this, ctx);\n-    let currCtx = ctx;\n-    while (currCtx != null) {\n-      if (currCtx.vars.has(expr.name)) {\n-        currCtx.vars.set(expr.name, value);\n-        return value;\n-      }\n-      currCtx = currCtx.parent!;\n-    }\n-    throw new Error(`Not declared variable ${expr.name}`);\n-  }\n-  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: _ExecutionContext): never {\n-    throw new Error('Cannot interpret a WrappedNodeExpr.');\n-  }\n-  visitTypeofExpr(ast: o.TypeofExpr, ctx: _ExecutionContext): never {\n-    throw new Error('Cannot interpret a TypeofExpr');\n-  }\n-  visitReadVarExpr(ast: o.ReadVarExpr, ctx: _ExecutionContext): any {\n-    let varName = ast.name!;\n-    if (ast.builtin != null) {\n-      switch (ast.builtin) {\n-        case o.BuiltinVar.Super:\n-          return Object.getPrototypeOf(ctx.instance);\n-        case o.BuiltinVar.This:\n-          return ctx.instance;\n-        case o.BuiltinVar.CatchError:\n-          varName = CATCH_ERROR_VAR;\n-          break;\n-        case o.BuiltinVar.CatchStack:\n-          varName = CATCH_STACK_VAR;\n-          break;\n-        default:\n-          throw new Error(`Unknown builtin variable ${ast.builtin}`);\n-      }\n-    }\n-    let currCtx = ctx;\n-    while (currCtx != null) {\n-      if (currCtx.vars.has(varName)) {\n-        return currCtx.vars.get(varName);\n-      }\n-      currCtx = currCtx.parent!;\n-    }\n-    throw new Error(`Not declared variable ${varName}`);\n-  }\n-  visitWriteKeyExpr(expr: o.WriteKeyExpr, ctx: _ExecutionContext): any {\n-    const receiver = expr.receiver.visitExpression(this, ctx);\n-    const index = expr.index.visitExpression(this, ctx);\n-    const value = expr.value.visitExpression(this, ctx);\n-    receiver[index] = value;\n-    return value;\n-  }\n-  visitWritePropExpr(expr: o.WritePropExpr, ctx: _ExecutionContext): any {\n-    const receiver = expr.receiver.visitExpression(this, ctx);\n-    const value = expr.value.visitExpression(this, ctx);\n-    receiver[expr.name] = value;\n-    return value;\n-  }\n-\n-  visitInvokeFunctionExpr(stmt: o.InvokeFunctionExpr, ctx: _ExecutionContext): any {\n-    const args = this.visitAllExpressions(stmt.args, ctx);\n-    const fnExpr = stmt.fn as (o.Expression & {receiver: o.Expression | undefined});\n-    if (fnExpr instanceof o.ReadVarExpr && fnExpr.builtin === o.BuiltinVar.Super) {\n-      ctx.instance!.constructor.prototype.constructor.apply(ctx.instance, args);\n-      return null;\n-    } else {\n-      const fn = fnExpr.visitExpression(this, ctx);\n-      let context: any = null;\n-      if (fnExpr.receiver) {\n-        context = fnExpr.receiver.visitExpression(this, ctx);\n-      }\n-      return fn.apply(context, args);\n-    }\n-  }\n-  visitTaggedTemplateExpr(expr: o.TaggedTemplateExpr, ctx: _ExecutionContext): any {\n-    const templateElements = expr.template.elements.map((e) => e.text);\n-    Object.defineProperty(\n-        templateElements, 'raw', {value: expr.template.elements.map((e) => e.rawText)});\n-    const args = this.visitAllExpressions(expr.template.expressions, ctx);\n-    args.unshift(templateElements);\n-    const tag = expr.tag.visitExpression(this, ctx);\n-    return tag.apply(null, args);\n-  }\n-  visitReturnStmt(stmt: o.ReturnStatement, ctx: _ExecutionContext): any {\n-    return new ReturnValue(stmt.value.visitExpression(this, ctx));\n-  }\n-  visitDeclareClassStmt(stmt: o.ClassStmt, ctx: _ExecutionContext): any {\n-    const clazz = createDynamicClass(stmt, ctx, this);\n-    ctx.vars.set(stmt.name, clazz);\n-    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n-      ctx.exports.push(stmt.name);\n-    }\n-    return null;\n-  }\n-  visitExpressionStmt(stmt: o.ExpressionStatement, ctx: _ExecutionContext): any {\n-    return stmt.expr.visitExpression(this, ctx);\n-  }\n-  visitIfStmt(stmt: o.IfStmt, ctx: _ExecutionContext): any {\n-    const condition = stmt.condition.visitExpression(this, ctx);\n-    if (condition) {\n-      return this.visitAllStatements(stmt.trueCase, ctx);\n-    } else if (stmt.falseCase != null) {\n-      return this.visitAllStatements(stmt.falseCase, ctx);\n-    }\n-    return null;\n-  }\n-  visitTryCatchStmt(stmt: o.TryCatchStmt, ctx: _ExecutionContext): any {\n-    try {\n-      return this.visitAllStatements(stmt.bodyStmts, ctx);\n-    } catch (e) {\n-      const childCtx = ctx.createChildWihtLocalVars();\n-      childCtx.vars.set(CATCH_ERROR_VAR, e);\n-      childCtx.vars.set(CATCH_STACK_VAR, e.stack);\n-      return this.visitAllStatements(stmt.catchStmts, childCtx);\n-    }\n-  }\n-  visitThrowStmt(stmt: o.ThrowStmt, ctx: _ExecutionContext): any {\n-    throw stmt.error.visitExpression(this, ctx);\n-  }\n-  visitInstantiateExpr(ast: o.InstantiateExpr, ctx: _ExecutionContext): any {\n-    const args = this.visitAllExpressions(ast.args, ctx);\n-    const clazz = ast.classExpr.visitExpression(this, ctx);\n-    return new clazz(...args);\n-  }\n-  visitLiteralExpr(ast: o.LiteralExpr, ctx: _ExecutionContext): any {\n-    return ast.value;\n-  }\n-  visitLocalizedString(ast: o.LocalizedString, context: any): any {\n-    return null;\n-  }\n-  visitExternalExpr(ast: o.ExternalExpr, ctx: _ExecutionContext): any {\n-    return this.reflector.resolveExternalReference(ast.value);\n-  }\n-  visitConditionalExpr(ast: o.ConditionalExpr, ctx: _ExecutionContext): any {\n-    if (ast.condition.visitExpression(this, ctx)) {\n-      return ast.trueCase.visitExpression(this, ctx);\n-    } else if (ast.falseCase != null) {\n-      return ast.falseCase.visitExpression(this, ctx);\n-    }\n-    return null;\n-  }\n-  visitNotExpr(ast: o.NotExpr, ctx: _ExecutionContext): any {\n-    return !ast.condition.visitExpression(this, ctx);\n-  }\n-  visitAssertNotNullExpr(ast: o.AssertNotNull, ctx: _ExecutionContext): any {\n-    return ast.condition.visitExpression(this, ctx);\n-  }\n-  visitCastExpr(ast: o.CastExpr, ctx: _ExecutionContext): any {\n-    return ast.value.visitExpression(this, ctx);\n-  }\n-  visitFunctionExpr(ast: o.FunctionExpr, ctx: _ExecutionContext): any {\n-    const paramNames = ast.params.map((param) => param.name);\n-    return _declareFn(paramNames, ast.statements, ctx, this);\n-  }\n-  visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: _ExecutionContext): any {\n-    const paramNames = stmt.params.map((param) => param.name);\n-    ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));\n-    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n-      ctx.exports.push(stmt.name);\n-    }\n-    return null;\n-  }\n-  visitUnaryOperatorExpr(ast: o.UnaryOperatorExpr, ctx: _ExecutionContext): any {\n-    const rhs = () => ast.expr.visitExpression(this, ctx);\n-\n-    switch (ast.operator) {\n-      case o.UnaryOperator.Plus:\n-        return +rhs();\n-      case o.UnaryOperator.Minus:\n-        return -rhs();\n-      default:\n-        throw new Error(`Unknown operator ${ast.operator}`);\n-    }\n-  }\n-  visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, ctx: _ExecutionContext): any {\n-    const lhs = () => ast.lhs.visitExpression(this, ctx);\n-    const rhs = () => ast.rhs.visitExpression(this, ctx);\n-\n-    switch (ast.operator) {\n-      case o.BinaryOperator.Equals:\n-        return lhs() == rhs();\n-      case o.BinaryOperator.Identical:\n-        return lhs() === rhs();\n-      case o.BinaryOperator.NotEquals:\n-        return lhs() != rhs();\n-      case o.BinaryOperator.NotIdentical:\n-        return lhs() !== rhs();\n-      case o.BinaryOperator.And:\n-        return lhs() && rhs();\n-      case o.BinaryOperator.Or:\n-        return lhs() || rhs();\n-      case o.BinaryOperator.Plus:\n-        return lhs() + rhs();\n-      case o.BinaryOperator.Minus:\n-        return lhs() - rhs();\n-      case o.BinaryOperator.Divide:\n-        return lhs() / rhs();\n-      case o.BinaryOperator.Multiply:\n-        return lhs() * rhs();\n-      case o.BinaryOperator.Modulo:\n-        return lhs() % rhs();\n-      case o.BinaryOperator.Lower:\n-        return lhs() < rhs();\n-      case o.BinaryOperator.LowerEquals:\n-        return lhs() <= rhs();\n-      case o.BinaryOperator.Bigger:\n-        return lhs() > rhs();\n-      case o.BinaryOperator.BiggerEquals:\n-        return lhs() >= rhs();\n-      case o.BinaryOperator.NullishCoalesce:\n-        return lhs() ?? rhs();\n-      default:\n-        throw new Error(`Unknown operator ${ast.operator}`);\n-    }\n-  }\n-  visitReadPropExpr(ast: o.ReadPropExpr, ctx: _ExecutionContext): any {\n-    let result: any;\n-    const receiver = ast.receiver.visitExpression(this, ctx);\n-    result = receiver[ast.name];\n-    return result;\n-  }\n-  visitReadKeyExpr(ast: o.ReadKeyExpr, ctx: _ExecutionContext): any {\n-    const receiver = ast.receiver.visitExpression(this, ctx);\n-    const prop = ast.index.visitExpression(this, ctx);\n-    return receiver[prop];\n-  }\n-  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, ctx: _ExecutionContext): any {\n-    return this.visitAllExpressions(ast.entries, ctx);\n-  }\n-  visitLiteralMapExpr(ast: o.LiteralMapExpr, ctx: _ExecutionContext): any {\n-    const result: {[k: string]: any} = {};\n-    ast.entries.forEach(entry => result[entry.key] = entry.value.visitExpression(this, ctx));\n-    return result;\n-  }\n-  visitCommaExpr(ast: o.CommaExpr, context: any): any {\n-    const values = this.visitAllExpressions(ast.parts, context);\n-    return values[values.length - 1];\n-  }\n-  visitAllExpressions(expressions: o.Expression[], ctx: _ExecutionContext): any {\n-    return expressions.map((expr) => expr.visitExpression(this, ctx));\n-  }\n-\n-  visitAllStatements(statements: o.Statement[], ctx: _ExecutionContext): ReturnValue|null {\n-    for (let i = 0; i < statements.length; i++) {\n-      const stmt = statements[i];\n-      const val = stmt.visitStatement(this, ctx);\n-      if (val instanceof ReturnValue) {\n-        return val;\n-      }\n-    }\n-    return null;\n-  }\n-}\n-\n-function _declareFn(\n-    varNames: string[], statements: o.Statement[], ctx: _ExecutionContext,\n-    visitor: StatementInterpreter): Function {\n-  return (...args: any[]) => _executeFunctionStatements(varNames, args, statements, ctx, visitor);\n-}\n-\n-const CATCH_ERROR_VAR = 'error';\n-const CATCH_STACK_VAR = 'stack';"
        },
        {
            "sha": "ab1d70e18a22e064b798ec37943a402cb0838da0",
            "filename": "packages/compiler/src/output/output_jit.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_jit.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_jit.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_jit.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -6,14 +6,17 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {CompileReflector} from '../compile_reflector';\n import {identifierName} from '../parse_util';\n \n import {EmitterVisitorContext} from './abstract_emitter';\n import {AbstractJsEmitterVisitor} from './abstract_js_emitter';\n import * as o from './output_ast';\n import {newTrustedFunctionForJIT} from './output_jit_trusted_types';\n \n+export interface ExternalReferenceResolver {\n+  resolveExternalReference(ref: o.ExternalReference): unknown;\n+}\n+\n /**\n  * A helper class to manage the evaluation of JIT generated code.\n  */\n@@ -22,15 +25,15 @@ export class JitEvaluator {\n    *\n    * @param sourceUrl The URL of the generated code.\n    * @param statements An array of Angular statement AST nodes to be evaluated.\n-   * @param reflector A helper used when converting the statements to executable code.\n+   * @param refResolver Resolves `o.ExternalReference`s into values.\n    * @param createSourceMaps If true then create a source-map for the generated code and include it\n    * inline as a source-map comment.\n    * @returns A map of all the variables in the generated code.\n    */\n   evaluateStatements(\n-      sourceUrl: string, statements: o.Statement[], reflector: CompileReflector,\n+      sourceUrl: string, statements: o.Statement[], refResolver: ExternalReferenceResolver,\n       createSourceMaps: boolean): {[key: string]: any} {\n-    const converter = new JitEmitterVisitor(reflector);\n+    const converter = new JitEmitterVisitor(refResolver);\n     const ctx = EmitterVisitorContext.createRoot();\n     // Ensure generated code is in strict mode\n     if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\n@@ -101,7 +104,7 @@ export class JitEmitterVisitor extends AbstractJsEmitterVisitor {\n   private _evalArgValues: any[] = [];\n   private _evalExportedVars: string[] = [];\n \n-  constructor(private reflector: CompileReflector) {\n+  constructor(private refResolver: ExternalReferenceResolver) {\n     super();\n   }\n \n@@ -120,7 +123,7 @@ export class JitEmitterVisitor extends AbstractJsEmitterVisitor {\n   }\n \n   override visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any {\n-    this._emitReferenceToExternal(ast, this.reflector.resolveExternalReference(ast.value), ctx);\n+    this._emitReferenceToExternal(ast, this.refResolver.resolveExternalReference(ast.value), ctx);\n     return null;\n   }\n "
        },
        {
            "sha": "27ff79035ed42155e68f4851e76d31eb52b05058",
            "filename": "packages/compiler/src/output/ts_emitter.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 441,
            "changes": 441,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Foutput%2Fts_emitter.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Foutput%2Fts_emitter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Foutput%2Fts_emitter.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,441 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {AbstractEmitterVisitor, CATCH_ERROR_VAR, CATCH_STACK_VAR, EmitterVisitorContext, OutputEmitter} from './abstract_emitter';\n-import * as o from './output_ast';\n-\n-export function debugOutputAstAsTypeScript(ast: o.Statement|o.Expression|o.Type|any[]): string {\n-  const converter = new _TsEmitterVisitor();\n-  const ctx = EmitterVisitorContext.createRoot();\n-  const asts: any[] = Array.isArray(ast) ? ast : [ast];\n-\n-  asts.forEach((ast) => {\n-    if (ast instanceof o.Statement) {\n-      ast.visitStatement(converter, ctx);\n-    } else if (ast instanceof o.Expression) {\n-      ast.visitExpression(converter, ctx);\n-    } else if (ast instanceof o.Type) {\n-      ast.visitType(converter, ctx);\n-    } else {\n-      throw new Error(`Don't know how to print debug info for ${ast}`);\n-    }\n-  });\n-  return ctx.toSource();\n-}\n-\n-export type ReferenceFilter = (reference: o.ExternalReference) => boolean;\n-\n-export class TypeScriptEmitter implements OutputEmitter {\n-  emitStatementsAndContext(\n-      genFilePath: string, stmts: o.Statement[], preamble: string = '',\n-      emitSourceMaps: boolean = true, referenceFilter?: ReferenceFilter,\n-      importFilter?: ReferenceFilter): {sourceText: string, context: EmitterVisitorContext} {\n-    const converter = new _TsEmitterVisitor(referenceFilter, importFilter);\n-\n-    const ctx = EmitterVisitorContext.createRoot();\n-\n-    converter.visitAllStatements(stmts, ctx);\n-\n-    const preambleLines = preamble ? preamble.split('\\n') : [];\n-    converter.reexports.forEach((reexports, exportedModuleName) => {\n-      const reexportsCode =\n-          reexports.map(reexport => `${reexport.name} as ${reexport.as}`).join(',');\n-      preambleLines.push(`export {${reexportsCode}} from '${exportedModuleName}';`);\n-    });\n-\n-    converter.importsWithPrefixes.forEach((prefix, importedModuleName) => {\n-      // Note: can't write the real word for import as it screws up system.js auto detection...\n-      preambleLines.push(\n-          `imp` +\n-          `ort * as ${prefix} from '${importedModuleName}';`);\n-    });\n-\n-    const sm = emitSourceMaps ?\n-        ctx.toSourceMapGenerator(genFilePath, preambleLines.length).toJsComment() :\n-        '';\n-    const lines = [...preambleLines, ctx.toSource(), sm];\n-    if (sm) {\n-      // always add a newline at the end, as some tools have bugs without it.\n-      lines.push('');\n-    }\n-    ctx.setPreambleLineCount(preambleLines.length);\n-    return {sourceText: lines.join('\\n'), context: ctx};\n-  }\n-\n-  emitStatements(genFilePath: string, stmts: o.Statement[], preamble: string = '') {\n-    return this.emitStatementsAndContext(genFilePath, stmts, preamble).sourceText;\n-  }\n-}\n-\n-\n-class _TsEmitterVisitor extends AbstractEmitterVisitor implements o.TypeVisitor {\n-  private typeExpression = 0;\n-\n-  constructor(private referenceFilter?: ReferenceFilter, private importFilter?: ReferenceFilter) {\n-    super(false);\n-  }\n-\n-  importsWithPrefixes = new Map<string, string>();\n-  reexports = new Map<string, {name: string, as: string}[]>();\n-\n-  visitType(t: o.Type|null, ctx: EmitterVisitorContext, defaultType: string = 'any') {\n-    if (t) {\n-      this.typeExpression++;\n-      t.visitType(this, ctx);\n-      this.typeExpression--;\n-    } else {\n-      ctx.print(null, defaultType);\n-    }\n-  }\n-\n-  override visitLiteralExpr(ast: o.LiteralExpr, ctx: EmitterVisitorContext): any {\n-    const value = ast.value;\n-    if (value == null && ast.type != o.INFERRED_TYPE) {\n-      ctx.print(ast, `(${value} as any)`);\n-      return null;\n-    }\n-    return super.visitLiteralExpr(ast, ctx);\n-  }\n-\n-\n-  // Temporary workaround to support strictNullCheck enabled consumers of ngc emit.\n-  // In SNC mode, [] have the type never[], so we cast here to any[].\n-  // TODO: narrow the cast to a more explicit type, or use a pattern that does not\n-  // start with [].concat. see https://github.com/angular/angular/pull/11846\n-  override visitLiteralArrayExpr(ast: o.LiteralArrayExpr, ctx: EmitterVisitorContext): any {\n-    if (ast.entries.length === 0) {\n-      ctx.print(ast, '(');\n-    }\n-    const result = super.visitLiteralArrayExpr(ast, ctx);\n-    if (ast.entries.length === 0) {\n-      ctx.print(ast, ' as any[])');\n-    }\n-    return result;\n-  }\n-\n-  override visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any {\n-    this._visitIdentifier(ast.value, ast.typeParams, ctx);\n-    return null;\n-  }\n-\n-  override visitAssertNotNullExpr(ast: o.AssertNotNull, ctx: EmitterVisitorContext): any {\n-    const result = super.visitAssertNotNullExpr(ast, ctx);\n-    ctx.print(ast, '!');\n-    return result;\n-  }\n-\n-  override visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any {\n-    if (stmt.hasModifier(o.StmtModifier.Exported) && stmt.value instanceof o.ExternalExpr &&\n-        !stmt.type) {\n-      // check for a reexport\n-      const {name, moduleName} = stmt.value.value;\n-      if (moduleName) {\n-        let reexports = this.reexports.get(moduleName);\n-        if (!reexports) {\n-          reexports = [];\n-          this.reexports.set(moduleName, reexports);\n-        }\n-        reexports.push({name: name!, as: stmt.name});\n-        return null;\n-      }\n-    }\n-    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n-      ctx.print(stmt, `export `);\n-    }\n-    if (stmt.hasModifier(o.StmtModifier.Final)) {\n-      ctx.print(stmt, `const`);\n-    } else {\n-      ctx.print(stmt, `var`);\n-    }\n-    ctx.print(stmt, ` ${stmt.name}`);\n-    this._printColonType(stmt.type, ctx);\n-    if (stmt.value) {\n-      ctx.print(stmt, ` = `);\n-      stmt.value.visitExpression(this, ctx);\n-    }\n-    ctx.println(stmt, `;`);\n-    return null;\n-  }\n-\n-  override visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): never {\n-    throw new Error('Cannot visit a WrappedNodeExpr when outputting Typescript.');\n-  }\n-\n-  override visitCastExpr(ast: o.CastExpr, ctx: EmitterVisitorContext): any {\n-    ctx.print(ast, `(<`);\n-    ast.type!.visitType(this, ctx);\n-    ctx.print(ast, `>`);\n-    ast.value.visitExpression(this, ctx);\n-    ctx.print(ast, `)`);\n-    return null;\n-  }\n-\n-  override visitInstantiateExpr(ast: o.InstantiateExpr, ctx: EmitterVisitorContext): any {\n-    ctx.print(ast, `new `);\n-    this.typeExpression++;\n-    ast.classExpr.visitExpression(this, ctx);\n-    this.typeExpression--;\n-    ctx.print(ast, `(`);\n-    this.visitAllExpressions(ast.args, ctx, ',');\n-    ctx.print(ast, `)`);\n-    return null;\n-  }\n-\n-  override visitDeclareClassStmt(stmt: o.ClassStmt, ctx: EmitterVisitorContext): any {\n-    ctx.pushClass(stmt);\n-    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n-      ctx.print(stmt, `export `);\n-    }\n-    ctx.print(stmt, `class ${stmt.name}`);\n-    if (stmt.parent != null) {\n-      ctx.print(stmt, ` extends `);\n-      this.typeExpression++;\n-      stmt.parent.visitExpression(this, ctx);\n-      this.typeExpression--;\n-    }\n-    ctx.println(stmt, ` {`);\n-    ctx.incIndent();\n-    stmt.fields.forEach((field) => this._visitClassField(field, ctx));\n-    if (stmt.constructorMethod != null) {\n-      this._visitClassConstructor(stmt, ctx);\n-    }\n-    stmt.getters.forEach((getter) => this._visitClassGetter(getter, ctx));\n-    stmt.methods.forEach((method) => this._visitClassMethod(method, ctx));\n-    ctx.decIndent();\n-    ctx.println(stmt, `}`);\n-    ctx.popClass();\n-    return null;\n-  }\n-\n-  private _visitClassField(field: o.ClassField, ctx: EmitterVisitorContext) {\n-    if (field.hasModifier(o.StmtModifier.Private)) {\n-      // comment out as a workaround for #10967\n-      ctx.print(null, `/*private*/ `);\n-    }\n-    if (field.hasModifier(o.StmtModifier.Static)) {\n-      ctx.print(null, 'static ');\n-    }\n-    ctx.print(null, field.name);\n-    this._printColonType(field.type, ctx);\n-    if (field.initializer) {\n-      ctx.print(null, ' = ');\n-      field.initializer.visitExpression(this, ctx);\n-    }\n-    ctx.println(null, `;`);\n-  }\n-\n-  private _visitClassGetter(getter: o.ClassGetter, ctx: EmitterVisitorContext) {\n-    if (getter.hasModifier(o.StmtModifier.Private)) {\n-      ctx.print(null, `private `);\n-    }\n-    ctx.print(null, `get ${getter.name}()`);\n-    this._printColonType(getter.type, ctx);\n-    ctx.println(null, ` {`);\n-    ctx.incIndent();\n-    this.visitAllStatements(getter.body, ctx);\n-    ctx.decIndent();\n-    ctx.println(null, `}`);\n-  }\n-\n-  private _visitClassConstructor(stmt: o.ClassStmt, ctx: EmitterVisitorContext) {\n-    ctx.print(stmt, `constructor(`);\n-    this._visitParams(stmt.constructorMethod.params, ctx);\n-    ctx.println(stmt, `) {`);\n-    ctx.incIndent();\n-    this.visitAllStatements(stmt.constructorMethod.body, ctx);\n-    ctx.decIndent();\n-    ctx.println(stmt, `}`);\n-  }\n-\n-  private _visitClassMethod(method: o.ClassMethod, ctx: EmitterVisitorContext) {\n-    if (method.hasModifier(o.StmtModifier.Private)) {\n-      ctx.print(null, `private `);\n-    }\n-    ctx.print(null, `${method.name}(`);\n-    this._visitParams(method.params, ctx);\n-    ctx.print(null, `)`);\n-    this._printColonType(method.type, ctx, 'void');\n-    ctx.println(null, ` {`);\n-    ctx.incIndent();\n-    this.visitAllStatements(method.body, ctx);\n-    ctx.decIndent();\n-    ctx.println(null, `}`);\n-  }\n-\n-  override visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any {\n-    if (ast.name) {\n-      ctx.print(ast, 'function ');\n-      ctx.print(ast, ast.name);\n-    }\n-    ctx.print(ast, `(`);\n-    this._visitParams(ast.params, ctx);\n-    ctx.print(ast, `)`);\n-    this._printColonType(ast.type, ctx, 'void');\n-    if (!ast.name) {\n-      ctx.print(ast, ` => `);\n-    }\n-    ctx.println(ast, '{');\n-    ctx.incIndent();\n-    this.visitAllStatements(ast.statements, ctx);\n-    ctx.decIndent();\n-    ctx.print(ast, `}`);\n-\n-    return null;\n-  }\n-\n-  override visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: EmitterVisitorContext): any {\n-    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n-      ctx.print(stmt, `export `);\n-    }\n-    ctx.print(stmt, `function ${stmt.name}(`);\n-    this._visitParams(stmt.params, ctx);\n-    ctx.print(stmt, `)`);\n-    this._printColonType(stmt.type, ctx, 'void');\n-    ctx.println(stmt, ` {`);\n-    ctx.incIndent();\n-    this.visitAllStatements(stmt.statements, ctx);\n-    ctx.decIndent();\n-    ctx.println(stmt, `}`);\n-    return null;\n-  }\n-\n-  override visitTryCatchStmt(stmt: o.TryCatchStmt, ctx: EmitterVisitorContext): any {\n-    ctx.println(stmt, `try {`);\n-    ctx.incIndent();\n-    this.visitAllStatements(stmt.bodyStmts, ctx);\n-    ctx.decIndent();\n-    ctx.println(stmt, `} catch (${CATCH_ERROR_VAR.name}) {`);\n-    ctx.incIndent();\n-    const catchStmts =\n-        [<o.Statement>CATCH_STACK_VAR.set(CATCH_ERROR_VAR.prop('stack', null)).toDeclStmt(null, [\n-          o.StmtModifier.Final\n-        ])].concat(stmt.catchStmts);\n-    this.visitAllStatements(catchStmts, ctx);\n-    ctx.decIndent();\n-    ctx.println(stmt, `}`);\n-    return null;\n-  }\n-\n-  visitBuiltinType(type: o.BuiltinType, ctx: EmitterVisitorContext): any {\n-    let typeStr: string;\n-    switch (type.name) {\n-      case o.BuiltinTypeName.Bool:\n-        typeStr = 'boolean';\n-        break;\n-      case o.BuiltinTypeName.Dynamic:\n-        typeStr = 'any';\n-        break;\n-      case o.BuiltinTypeName.Function:\n-        typeStr = 'Function';\n-        break;\n-      case o.BuiltinTypeName.Number:\n-        typeStr = 'number';\n-        break;\n-      case o.BuiltinTypeName.Int:\n-        typeStr = 'number';\n-        break;\n-      case o.BuiltinTypeName.String:\n-        typeStr = 'string';\n-        break;\n-      case o.BuiltinTypeName.None:\n-        typeStr = 'never';\n-        break;\n-      default:\n-        throw new Error(`Unsupported builtin type ${type.name}`);\n-    }\n-    ctx.print(null, typeStr);\n-    return null;\n-  }\n-\n-  visitExpressionType(ast: o.ExpressionType, ctx: EmitterVisitorContext): any {\n-    ast.value.visitExpression(this, ctx);\n-    if (ast.typeParams !== null) {\n-      ctx.print(null, '<');\n-      this.visitAllObjects(type => this.visitType(type, ctx), ast.typeParams, ctx, ',');\n-      ctx.print(null, '>');\n-    }\n-    return null;\n-  }\n-\n-  visitArrayType(type: o.ArrayType, ctx: EmitterVisitorContext): any {\n-    this.visitType(type.of, ctx);\n-    ctx.print(null, `[]`);\n-    return null;\n-  }\n-\n-  visitMapType(type: o.MapType, ctx: EmitterVisitorContext): any {\n-    ctx.print(null, `{[key: string]:`);\n-    this.visitType(type.valueType, ctx);\n-    ctx.print(null, `}`);\n-    return null;\n-  }\n-\n-  override getBuiltinMethodName(method: o.BuiltinMethod): string {\n-    let name: string;\n-    switch (method) {\n-      case o.BuiltinMethod.ConcatArray:\n-        name = 'concat';\n-        break;\n-      case o.BuiltinMethod.SubscribeObservable:\n-        name = 'subscribe';\n-        break;\n-      case o.BuiltinMethod.Bind:\n-        name = 'bind';\n-        break;\n-      default:\n-        throw new Error(`Unknown builtin method: ${method}`);\n-    }\n-    return name;\n-  }\n-\n-  private _visitParams(params: o.FnParam[], ctx: EmitterVisitorContext): void {\n-    this.visitAllObjects(param => {\n-      ctx.print(null, param.name);\n-      this._printColonType(param.type, ctx);\n-    }, params, ctx, ',');\n-  }\n-\n-  private _visitIdentifier(\n-      value: o.ExternalReference, typeParams: o.Type[]|null, ctx: EmitterVisitorContext): void {\n-    const {name, moduleName} = value;\n-    if (this.referenceFilter && this.referenceFilter(value)) {\n-      ctx.print(null, '(null as any)');\n-      return;\n-    }\n-    if (moduleName && (!this.importFilter || !this.importFilter(value))) {\n-      let prefix = this.importsWithPrefixes.get(moduleName);\n-      if (prefix == null) {\n-        prefix = `i${this.importsWithPrefixes.size}`;\n-        this.importsWithPrefixes.set(moduleName, prefix);\n-      }\n-      ctx.print(null, `${prefix}.`);\n-    }\n-    ctx.print(null, name!);\n-\n-    if (this.typeExpression > 0) {\n-      // If we are in a type expression that refers to a generic type then supply\n-      // the required type parameters. If there were not enough type parameters\n-      // supplied, supply any as the type. Outside a type expression the reference\n-      // should not supply type parameters and be treated as a simple value reference\n-      // to the constructor function itself.\n-      const suppliedParameters = typeParams || [];\n-      if (suppliedParameters.length > 0) {\n-        ctx.print(null, `<`);\n-        this.visitAllObjects(type => type.visitType(this, ctx), typeParams!, ctx, ',');\n-        ctx.print(null, `>`);\n-      }\n-    }\n-  }\n-\n-  private _printColonType(type: o.Type|null, ctx: EmitterVisitorContext, defaultType?: string) {\n-    if (type !== o.INFERRED_TYPE) {\n-      ctx.print(null, ':');\n-      this.visitType(type, ctx, defaultType);\n-    }\n-  }\n-}"
        },
        {
            "sha": "904c50b2aae1882d0cd5a3877fa9ce165952aaf6",
            "filename": "packages/compiler/src/output/value_util.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 58,
            "changes": 58,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Foutput%2Fvalue_util.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Foutput%2Fvalue_util.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Foutput%2Fvalue_util.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,58 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-\n-import {OutputContext} from '../constant_pool';\n-import {ValueTransformer, visitValue} from '../util';\n-\n-import * as o from './output_ast';\n-\n-export const QUOTED_KEYS = '$quoted$';\n-\n-export function convertValueToOutputAst(\n-    ctx: OutputContext, value: any, type: o.Type|null = null): o.Expression {\n-  return visitValue(value, new _ValueOutputAstTransformer(ctx), type);\n-}\n-\n-class _ValueOutputAstTransformer implements ValueTransformer {\n-  constructor(private ctx: OutputContext) {}\n-  visitArray(arr: any[], type: o.Type): o.Expression {\n-    const values: o.Expression[] = [];\n-    // Note Array.map() must not be used to convert the values because it will\n-    // skip over empty elements in arrays constructed using `new Array(length)`,\n-    // resulting in `undefined` elements. This breaks the type guarantee that\n-    // all values in `o.LiteralArrayExpr` are of type `o.Expression`.\n-    // See test case in `value_util_spec.ts`.\n-    for (let i = 0; i < arr.length; ++i) {\n-      values.push(visitValue(arr[i], this, null /* context */));\n-    }\n-    return o.literalArr(values, type);\n-  }\n-\n-  visitStringMap(map: {[key: string]: any}, type: o.MapType): o.Expression {\n-    const entries: o.LiteralMapEntry[] = [];\n-    const quotedSet = new Set<string>(map && map[QUOTED_KEYS]);\n-    Object.keys(map).forEach(key => {\n-      entries.push(\n-          new o.LiteralMapEntry(key, visitValue(map[key], this, null), quotedSet.has(key)));\n-    });\n-    return new o.LiteralMapExpr(entries, type);\n-  }\n-\n-  visitPrimitive(value: any, type: o.Type): o.Expression {\n-    return o.literal(value, type);\n-  }\n-\n-  visitOther(value: any, type: o.Type): o.Expression {\n-    if (value instanceof o.Expression) {\n-      return value;\n-    } else {\n-      return this.ctx.importExpr(value);\n-    }\n-  }\n-}"
        },
        {
            "sha": "4dc2b285ed4182b990b34a44ca94436ad1366851",
            "filename": "packages/compiler/src/parse_util.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 22,
            "changes": 22,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Fparse_util.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Fparse_util.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fparse_util.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -5,7 +5,6 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {StaticSymbol} from './aot/static_symbol';\n import * as chars from './chars';\n import {stringify} from './util';\n \n@@ -155,15 +154,6 @@ export class ParseError {\n   }\n }\n \n-export function typeSourceSpan(kind: string, type: CompileIdentifierMetadata): ParseSourceSpan {\n-  const moduleUrl = identifierModuleUrl(type);\n-  const sourceFileName = moduleUrl != null ? `in ${kind} ${identifierName(type)} in ${moduleUrl}` :\n-                                             `in ${kind} ${identifierName(type)}`;\n-  const sourceFile = new ParseSourceFile('', sourceFileName);\n-  return new ParseSourceSpan(\n-      new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n-}\n-\n /**\n  * Generates Source Span object for a given R3 Type for JIT mode.\n  *\n@@ -206,9 +196,6 @@ export function identifierName(compileIdentifier: CompileIdentifierMetadata|null\n     return null;\n   }\n   const ref = compileIdentifier.reference;\n-  if (ref instanceof StaticSymbol) {\n-    return ref.name;\n-  }\n   if (ref['__anonymousType']) {\n     return ref['__anonymousType'];\n   }\n@@ -228,15 +215,6 @@ export function identifierName(compileIdentifier: CompileIdentifierMetadata|null\n   return identifier;\n }\n \n-export function identifierModuleUrl(compileIdentifier: CompileIdentifierMetadata): string {\n-  const ref = compileIdentifier.reference;\n-  if (ref instanceof StaticSymbol) {\n-    return ref.filePath;\n-  }\n-  // Runtime type\n-  return `./${stringify(ref)}`;\n-}\n-\n export interface CompileIdentifierMetadata {\n   reference: any;\n }"
        },
        {
            "sha": "876d05d9cf7e0ae63b181cea9678da009a38a123",
            "filename": "packages/compiler/src/pipe_resolver.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 45,
            "changes": 45,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fpipe_resolver.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fpipe_resolver.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fpipe_resolver.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,45 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompileReflector} from './compile_reflector';\n-import {createPipe, Pipe, Type} from './core';\n-import {findLast} from './directive_resolver';\n-import {resolveForwardRef, stringify} from './util';\n-\n-/**\n- * Resolve a `Type` for {@link Pipe}.\n- *\n- * This interface can be overridden by the application developer to create custom behavior.\n- *\n- * See {@link Compiler}\n- */\n-export class PipeResolver {\n-  constructor(private _reflector: CompileReflector) {}\n-\n-  isPipe(type: Type) {\n-    const typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n-    return typeMetadata && typeMetadata.some(createPipe.isTypeOf);\n-  }\n-\n-  /**\n-   * Return {@link Pipe} for a given `Type`.\n-   */\n-  resolve(type: Type, throwIfNotFound = true): Pipe|null {\n-    const metas = this._reflector.annotations(resolveForwardRef(type));\n-    if (metas) {\n-      const annotation = findLast(metas, createPipe.isTypeOf);\n-      if (annotation) {\n-        return annotation;\n-      }\n-    }\n-    if (throwIfNotFound) {\n-      throw new Error(`No Pipe decorator found on ${stringify(type)}`);\n-    }\n-    return null;\n-  }\n-}"
        },
        {
            "sha": "24e6c2395a728edca8751d26ccdc4504c2d02884",
            "filename": "packages/compiler/src/provider_analyzer.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 543,
            "changes": 543,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fprovider_analyzer.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fprovider_analyzer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fprovider_analyzer.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,543 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-\n-import {CompileDiDependencyMetadata, CompileDirectiveMetadata, CompileDirectiveSummary, CompileNgModuleMetadata, CompileProviderMetadata, CompileQueryMetadata, CompileTokenMetadata, CompileTypeMetadata, tokenName, tokenReference} from './compile_metadata';\n-import {CompileReflector} from './compile_reflector';\n-import {createTokenForExternalReference, Identifiers} from './identifiers';\n-import {ParseError, ParseSourceSpan} from './parse_util';\n-import {AttrAst, DirectiveAst, ProviderAst, ProviderAstType, QueryMatch, ReferenceAst} from './template_parser/template_ast';\n-\n-export class ProviderError extends ParseError {\n-  constructor(message: string, span: ParseSourceSpan) {\n-    super(span, message);\n-  }\n-}\n-\n-export interface QueryWithId {\n-  meta: CompileQueryMetadata;\n-  queryId: number;\n-}\n-\n-export class ProviderViewContext {\n-  /**\n-   * @internal\n-   */\n-  viewQueries: Map<any, QueryWithId[]>;\n-  /**\n-   * @internal\n-   */\n-  viewProviders: Map<any, boolean>;\n-  errors: ProviderError[] = [];\n-\n-  constructor(public reflector: CompileReflector, public component: CompileDirectiveMetadata) {\n-    this.viewQueries = _getViewQueries(component);\n-    this.viewProviders = new Map<any, boolean>();\n-    component.viewProviders.forEach((provider) => {\n-      if (this.viewProviders.get(tokenReference(provider.token)) == null) {\n-        this.viewProviders.set(tokenReference(provider.token), true);\n-      }\n-    });\n-  }\n-}\n-\n-export class ProviderElementContext {\n-  private _contentQueries: Map<any, QueryWithId[]>;\n-\n-  private _transformedProviders = new Map<any, ProviderAst>();\n-  private _seenProviders = new Map<any, boolean>();\n-  private _allProviders: Map<any, ProviderAst>;\n-  private _attrs: {[key: string]: string};\n-  private _queriedTokens = new Map<any, QueryMatch[]>();\n-\n-  public readonly transformedHasViewContainer: boolean = false;\n-\n-  constructor(\n-      public viewContext: ProviderViewContext, private _parent: ProviderElementContext,\n-      private _isViewRoot: boolean, private _directiveAsts: DirectiveAst[], attrs: AttrAst[],\n-      refs: ReferenceAst[], isTemplate: boolean, contentQueryStartId: number,\n-      private _sourceSpan: ParseSourceSpan) {\n-    this._attrs = {};\n-    attrs.forEach((attrAst) => this._attrs[attrAst.name] = attrAst.value);\n-    const directivesMeta = _directiveAsts.map(directiveAst => directiveAst.directive);\n-    this._allProviders =\n-        _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);\n-    this._contentQueries = _getContentQueries(contentQueryStartId, directivesMeta);\n-    Array.from(this._allProviders.values()).forEach((provider) => {\n-      this._addQueryReadsTo(provider.token, provider.token, this._queriedTokens);\n-    });\n-    if (isTemplate) {\n-      const templateRefId =\n-          createTokenForExternalReference(this.viewContext.reflector, Identifiers.TemplateRef);\n-      this._addQueryReadsTo(templateRefId, templateRefId, this._queriedTokens);\n-    }\n-    refs.forEach((refAst) => {\n-      let defaultQueryValue = refAst.value ||\n-          createTokenForExternalReference(this.viewContext.reflector, Identifiers.ElementRef);\n-      this._addQueryReadsTo({value: refAst.name}, defaultQueryValue, this._queriedTokens);\n-    });\n-    if (this._queriedTokens.get(\n-            this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef))) {\n-      this.transformedHasViewContainer = true;\n-    }\n-\n-    // create the providers that we know are eager first\n-    Array.from(this._allProviders.values()).forEach((provider) => {\n-      const eager = provider.eager || this._queriedTokens.get(tokenReference(provider.token));\n-      if (eager) {\n-        this._getOrCreateLocalProvider(provider.providerType, provider.token, true);\n-      }\n-    });\n-  }\n-\n-  afterElement() {\n-    // collect lazy providers\n-    Array.from(this._allProviders.values()).forEach((provider) => {\n-      this._getOrCreateLocalProvider(provider.providerType, provider.token, false);\n-    });\n-  }\n-\n-  get transformProviders(): ProviderAst[] {\n-    // Note: Maps keep their insertion order.\n-    const lazyProviders: ProviderAst[] = [];\n-    const eagerProviders: ProviderAst[] = [];\n-    this._transformedProviders.forEach(provider => {\n-      if (provider.eager) {\n-        eagerProviders.push(provider);\n-      } else {\n-        lazyProviders.push(provider);\n-      }\n-    });\n-    return lazyProviders.concat(eagerProviders);\n-  }\n-\n-  get transformedDirectiveAsts(): DirectiveAst[] {\n-    const sortedProviderTypes = this.transformProviders.map(provider => provider.token.identifier);\n-    const sortedDirectives = this._directiveAsts.slice();\n-    sortedDirectives.sort(\n-        (dir1, dir2) => sortedProviderTypes.indexOf(dir1.directive.type) -\n-            sortedProviderTypes.indexOf(dir2.directive.type));\n-    return sortedDirectives;\n-  }\n-\n-  get queryMatches(): QueryMatch[] {\n-    const allMatches: QueryMatch[] = [];\n-    this._queriedTokens.forEach((matches: QueryMatch[]) => {\n-      allMatches.push(...matches);\n-    });\n-    return allMatches;\n-  }\n-\n-  private _addQueryReadsTo(\n-      token: CompileTokenMetadata, defaultValue: CompileTokenMetadata,\n-      queryReadTokens: Map<any, QueryMatch[]>) {\n-    this._getQueriesFor(token).forEach((query) => {\n-      const queryValue = query.meta.read || defaultValue;\n-      const tokenRef = tokenReference(queryValue);\n-      let queryMatches = queryReadTokens.get(tokenRef);\n-      if (!queryMatches) {\n-        queryMatches = [];\n-        queryReadTokens.set(tokenRef, queryMatches);\n-      }\n-      queryMatches.push({queryId: query.queryId, value: queryValue});\n-    });\n-  }\n-\n-  private _getQueriesFor(token: CompileTokenMetadata): QueryWithId[] {\n-    const result: QueryWithId[] = [];\n-    let currentEl: ProviderElementContext = this;\n-    let distance = 0;\n-    let queries: QueryWithId[]|undefined;\n-    while (currentEl !== null) {\n-      queries = currentEl._contentQueries.get(tokenReference(token));\n-      if (queries) {\n-        result.push(...queries.filter((query) => query.meta.descendants || distance <= 1));\n-      }\n-      if (currentEl._directiveAsts.length > 0) {\n-        distance++;\n-      }\n-      currentEl = currentEl._parent;\n-    }\n-    queries = this.viewContext.viewQueries.get(tokenReference(token));\n-    if (queries) {\n-      result.push(...queries);\n-    }\n-    return result;\n-  }\n-\n-\n-  private _getOrCreateLocalProvider(\n-      requestingProviderType: ProviderAstType, token: CompileTokenMetadata,\n-      eager: boolean): ProviderAst|null {\n-    const resolvedProvider = this._allProviders.get(tokenReference(token));\n-    if (!resolvedProvider ||\n-        ((requestingProviderType === ProviderAstType.Directive ||\n-          requestingProviderType === ProviderAstType.PublicService) &&\n-         resolvedProvider.providerType === ProviderAstType.PrivateService) ||\n-        ((requestingProviderType === ProviderAstType.PrivateService ||\n-          requestingProviderType === ProviderAstType.PublicService) &&\n-         resolvedProvider.providerType === ProviderAstType.Builtin)) {\n-      return null;\n-    }\n-    let transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n-    if (transformedProviderAst) {\n-      return transformedProviderAst;\n-    }\n-    if (this._seenProviders.get(tokenReference(token)) != null) {\n-      this.viewContext.errors.push(new ProviderError(\n-          `Cannot instantiate cyclic dependency! ${tokenName(token)}`, this._sourceSpan));\n-      return null;\n-    }\n-    this._seenProviders.set(tokenReference(token), true);\n-    const transformedProviders = resolvedProvider.providers.map((provider) => {\n-      let transformedUseValue = provider.useValue;\n-      let transformedUseExisting = provider.useExisting!;\n-      let transformedDeps: CompileDiDependencyMetadata[] = undefined!;\n-      if (provider.useExisting != null) {\n-        const existingDiDep = this._getDependency(\n-            resolvedProvider.providerType, {token: provider.useExisting}, eager)!;\n-        if (existingDiDep.token != null) {\n-          transformedUseExisting = existingDiDep.token;\n-        } else {\n-          transformedUseExisting = null!;\n-          transformedUseValue = existingDiDep.value;\n-        }\n-      } else if (provider.useFactory) {\n-        const deps = provider.deps || provider.useFactory.diDeps;\n-        transformedDeps =\n-            deps.map((dep) => this._getDependency(resolvedProvider.providerType, dep, eager)!);\n-      } else if (provider.useClass) {\n-        const deps = provider.deps || provider.useClass.diDeps;\n-        transformedDeps =\n-            deps.map((dep) => this._getDependency(resolvedProvider.providerType, dep, eager)!);\n-      }\n-      return _transformProvider(provider, {\n-        useExisting: transformedUseExisting,\n-        useValue: transformedUseValue,\n-        deps: transformedDeps\n-      });\n-    });\n-    transformedProviderAst =\n-        _transformProviderAst(resolvedProvider, {eager: eager, providers: transformedProviders});\n-    this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n-    return transformedProviderAst;\n-  }\n-\n-  private _getLocalDependency(\n-      requestingProviderType: ProviderAstType, dep: CompileDiDependencyMetadata,\n-      eager: boolean = false): CompileDiDependencyMetadata|null {\n-    if (dep.isAttribute) {\n-      const attrValue = this._attrs[dep.token!.value];\n-      return {isValue: true, value: attrValue == null ? null : attrValue};\n-    }\n-\n-    if (dep.token != null) {\n-      // access builtints\n-      if ((requestingProviderType === ProviderAstType.Directive ||\n-           requestingProviderType === ProviderAstType.Component)) {\n-        if (tokenReference(dep.token) ===\n-                this.viewContext.reflector.resolveExternalReference(Identifiers.Renderer) ||\n-            tokenReference(dep.token) ===\n-                this.viewContext.reflector.resolveExternalReference(Identifiers.ElementRef) ||\n-            tokenReference(dep.token) ===\n-                this.viewContext.reflector.resolveExternalReference(\n-                    Identifiers.ChangeDetectorRef) ||\n-            tokenReference(dep.token) ===\n-                this.viewContext.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n-          return dep;\n-        }\n-        if (tokenReference(dep.token) ===\n-            this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {\n-          (this as {transformedHasViewContainer: boolean}).transformedHasViewContainer = true;\n-        }\n-      }\n-      // access the injector\n-      if (tokenReference(dep.token) ===\n-          this.viewContext.reflector.resolveExternalReference(Identifiers.Injector)) {\n-        return dep;\n-      }\n-      // access providers\n-      if (this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager) != null) {\n-        return dep;\n-      }\n-    }\n-    return null;\n-  }\n-\n-  private _getDependency(\n-      requestingProviderType: ProviderAstType, dep: CompileDiDependencyMetadata,\n-      eager: boolean = false): CompileDiDependencyMetadata|null {\n-    let currElement: ProviderElementContext = this;\n-    let currEager: boolean = eager;\n-    let result: CompileDiDependencyMetadata|null = null;\n-    if (!dep.isSkipSelf) {\n-      result = this._getLocalDependency(requestingProviderType, dep, eager);\n-    }\n-    if (dep.isSelf) {\n-      if (!result && dep.isOptional) {\n-        result = {isValue: true, value: null};\n-      }\n-    } else {\n-      // check parent elements\n-      while (!result && currElement._parent) {\n-        const prevElement = currElement;\n-        currElement = currElement._parent;\n-        if (prevElement._isViewRoot) {\n-          currEager = false;\n-        }\n-        result = currElement._getLocalDependency(ProviderAstType.PublicService, dep, currEager);\n-      }\n-      // check @Host restriction\n-      if (!result) {\n-        if (!dep.isHost || this.viewContext.component.isHost ||\n-            this.viewContext.component.type.reference === tokenReference(dep.token!) ||\n-            this.viewContext.viewProviders.get(tokenReference(dep.token!)) != null) {\n-          result = dep;\n-        } else {\n-          result = dep.isOptional ? {isValue: true, value: null} : null;\n-        }\n-      }\n-    }\n-    if (!result) {\n-      this.viewContext.errors.push(\n-          new ProviderError(`No provider for ${tokenName(dep.token!)}`, this._sourceSpan));\n-    }\n-    return result;\n-  }\n-}\n-\n-\n-export class NgModuleProviderAnalyzer {\n-  private _transformedProviders = new Map<any, ProviderAst>();\n-  private _seenProviders = new Map<any, boolean>();\n-  private _allProviders: Map<any, ProviderAst>;\n-  private _errors: ProviderError[] = [];\n-\n-  constructor(\n-      private reflector: CompileReflector, ngModule: CompileNgModuleMetadata,\n-      extraProviders: CompileProviderMetadata[], sourceSpan: ParseSourceSpan) {\n-    this._allProviders = new Map<any, ProviderAst>();\n-    ngModule.transitiveModule.modules.forEach((ngModuleType: CompileTypeMetadata) => {\n-      const ngModuleProvider = {token: {identifier: ngModuleType}, useClass: ngModuleType};\n-      _resolveProviders(\n-          [ngModuleProvider], ProviderAstType.PublicService, true, sourceSpan, this._errors,\n-          this._allProviders, /* isModule */ true);\n-    });\n-    _resolveProviders(\n-        ngModule.transitiveModule.providers.map(entry => entry.provider).concat(extraProviders),\n-        ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders,\n-        /* isModule */ false);\n-  }\n-\n-  parse(): ProviderAst[] {\n-    Array.from(this._allProviders.values()).forEach((provider) => {\n-      this._getOrCreateLocalProvider(provider.token, provider.eager);\n-    });\n-    if (this._errors.length > 0) {\n-      const errorString = this._errors.join('\\n');\n-      throw new Error(`Provider parse errors:\\n${errorString}`);\n-    }\n-    // Note: Maps keep their insertion order.\n-    const lazyProviders: ProviderAst[] = [];\n-    const eagerProviders: ProviderAst[] = [];\n-    this._transformedProviders.forEach(provider => {\n-      if (provider.eager) {\n-        eagerProviders.push(provider);\n-      } else {\n-        lazyProviders.push(provider);\n-      }\n-    });\n-    return lazyProviders.concat(eagerProviders);\n-  }\n-\n-  private _getOrCreateLocalProvider(token: CompileTokenMetadata, eager: boolean): ProviderAst|null {\n-    const resolvedProvider = this._allProviders.get(tokenReference(token));\n-    if (!resolvedProvider) {\n-      return null;\n-    }\n-    let transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n-    if (transformedProviderAst) {\n-      return transformedProviderAst;\n-    }\n-    if (this._seenProviders.get(tokenReference(token)) != null) {\n-      this._errors.push(new ProviderError(\n-          `Cannot instantiate cyclic dependency! ${tokenName(token)}`,\n-          resolvedProvider.sourceSpan));\n-      return null;\n-    }\n-    this._seenProviders.set(tokenReference(token), true);\n-    const transformedProviders = resolvedProvider.providers.map((provider) => {\n-      let transformedUseValue = provider.useValue;\n-      let transformedUseExisting = provider.useExisting!;\n-      let transformedDeps: CompileDiDependencyMetadata[] = undefined!;\n-      if (provider.useExisting != null) {\n-        const existingDiDep =\n-            this._getDependency({token: provider.useExisting}, eager, resolvedProvider.sourceSpan);\n-        if (existingDiDep.token != null) {\n-          transformedUseExisting = existingDiDep.token;\n-        } else {\n-          transformedUseExisting = null!;\n-          transformedUseValue = existingDiDep.value;\n-        }\n-      } else if (provider.useFactory) {\n-        const deps = provider.deps || provider.useFactory.diDeps;\n-        transformedDeps =\n-            deps.map((dep) => this._getDependency(dep, eager, resolvedProvider.sourceSpan));\n-      } else if (provider.useClass) {\n-        const deps = provider.deps || provider.useClass.diDeps;\n-        transformedDeps =\n-            deps.map((dep) => this._getDependency(dep, eager, resolvedProvider.sourceSpan));\n-      }\n-      return _transformProvider(provider, {\n-        useExisting: transformedUseExisting,\n-        useValue: transformedUseValue,\n-        deps: transformedDeps\n-      });\n-    });\n-    transformedProviderAst =\n-        _transformProviderAst(resolvedProvider, {eager: eager, providers: transformedProviders});\n-    this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n-    return transformedProviderAst;\n-  }\n-\n-  private _getDependency(\n-      dep: CompileDiDependencyMetadata, eager: boolean = false,\n-      requestorSourceSpan: ParseSourceSpan): CompileDiDependencyMetadata {\n-    let foundLocal = false;\n-    if (!dep.isSkipSelf && dep.token != null) {\n-      // access the injector\n-      if (tokenReference(dep.token) ===\n-              this.reflector.resolveExternalReference(Identifiers.Injector) ||\n-          tokenReference(dep.token) ===\n-              this.reflector.resolveExternalReference(Identifiers.ComponentFactoryResolver)) {\n-        foundLocal = true;\n-        // access providers\n-      } else if (this._getOrCreateLocalProvider(dep.token, eager) != null) {\n-        foundLocal = true;\n-      }\n-    }\n-    return dep;\n-  }\n-}\n-\n-function _transformProvider(\n-    provider: CompileProviderMetadata,\n-    {useExisting, useValue, deps}:\n-        {useExisting: CompileTokenMetadata, useValue: any, deps: CompileDiDependencyMetadata[]}) {\n-  return {\n-    token: provider.token,\n-    useClass: provider.useClass,\n-    useExisting: useExisting,\n-    useFactory: provider.useFactory,\n-    useValue: useValue,\n-    deps: deps,\n-    multi: provider.multi\n-  };\n-}\n-\n-function _transformProviderAst(\n-    provider: ProviderAst,\n-    {eager, providers}: {eager: boolean, providers: CompileProviderMetadata[]}): ProviderAst {\n-  return new ProviderAst(\n-      provider.token, provider.multiProvider, provider.eager || eager, providers,\n-      provider.providerType, provider.lifecycleHooks, provider.sourceSpan, provider.isModule);\n-}\n-\n-function _resolveProvidersFromDirectives(\n-    directives: CompileDirectiveSummary[], sourceSpan: ParseSourceSpan,\n-    targetErrors: ParseError[]): Map<any, ProviderAst> {\n-  const providersByToken = new Map<any, ProviderAst>();\n-  directives.forEach((directive) => {\n-    const dirProvider:\n-        CompileProviderMetadata = {token: {identifier: directive.type}, useClass: directive.type};\n-    _resolveProviders(\n-        [dirProvider],\n-        directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true,\n-        sourceSpan, targetErrors, providersByToken, /* isModule */ false);\n-  });\n-\n-  // Note: directives need to be able to overwrite providers of a component!\n-  const directivesWithComponentFirst =\n-      directives.filter(dir => dir.isComponent).concat(directives.filter(dir => !dir.isComponent));\n-  directivesWithComponentFirst.forEach((directive) => {\n-    _resolveProviders(\n-        directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors,\n-        providersByToken, /* isModule */ false);\n-    _resolveProviders(\n-        directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors,\n-        providersByToken, /* isModule */ false);\n-  });\n-  return providersByToken;\n-}\n-\n-function _resolveProviders(\n-    providers: CompileProviderMetadata[], providerType: ProviderAstType, eager: boolean,\n-    sourceSpan: ParseSourceSpan, targetErrors: ParseError[],\n-    targetProvidersByToken: Map<any, ProviderAst>, isModule: boolean) {\n-  providers.forEach((provider) => {\n-    let resolvedProvider = targetProvidersByToken.get(tokenReference(provider.token));\n-    if (resolvedProvider != null && !!resolvedProvider.multiProvider !== !!provider.multi) {\n-      targetErrors.push(new ProviderError(\n-          `Mixing multi and non multi provider is not possible for token ${\n-              tokenName(resolvedProvider.token)}`,\n-          sourceSpan));\n-    }\n-    if (!resolvedProvider) {\n-      const lifecycleHooks = provider.token.identifier &&\n-              (<CompileTypeMetadata>provider.token.identifier).lifecycleHooks ?\n-          (<CompileTypeMetadata>provider.token.identifier).lifecycleHooks :\n-          [];\n-      const isUseValue = !(provider.useClass || provider.useExisting || provider.useFactory);\n-      resolvedProvider = new ProviderAst(\n-          provider.token, !!provider.multi, eager || isUseValue, [provider], providerType,\n-          lifecycleHooks, sourceSpan, isModule);\n-      targetProvidersByToken.set(tokenReference(provider.token), resolvedProvider);\n-    } else {\n-      if (!provider.multi) {\n-        resolvedProvider.providers.length = 0;\n-      }\n-      resolvedProvider.providers.push(provider);\n-    }\n-  });\n-}\n-\n-\n-function _getViewQueries(component: CompileDirectiveMetadata): Map<any, QueryWithId[]> {\n-  // Note: queries start with id 1 so we can use the number in a Bloom filter!\n-  let viewQueryId = 1;\n-  const viewQueries = new Map<any, QueryWithId[]>();\n-  if (component.viewQueries) {\n-    component.viewQueries.forEach(\n-        (query) => _addQueryToTokenMap(viewQueries, {meta: query, queryId: viewQueryId++}));\n-  }\n-  return viewQueries;\n-}\n-\n-function _getContentQueries(\n-    contentQueryStartId: number, directives: CompileDirectiveSummary[]): Map<any, QueryWithId[]> {\n-  let contentQueryId = contentQueryStartId;\n-  const contentQueries = new Map<any, QueryWithId[]>();\n-  directives.forEach((directive, directiveIndex) => {\n-    if (directive.queries) {\n-      directive.queries.forEach(\n-          (query) => _addQueryToTokenMap(contentQueries, {meta: query, queryId: contentQueryId++}));\n-    }\n-  });\n-  return contentQueries;\n-}\n-\n-function _addQueryToTokenMap(map: Map<any, QueryWithId[]>, query: QueryWithId) {\n-  query.meta.selectors.forEach((token: CompileTokenMetadata) => {\n-    let entry = map.get(tokenReference(token));\n-    if (!entry) {\n-      entry = [];\n-      map.set(tokenReference(token), entry);\n-    }\n-    entry.push(query);\n-  });\n-}"
        },
        {
            "sha": "731aa1eb3cead1677c8e5bd9c9f48c823c326882",
            "filename": "packages/compiler/src/render3/r3_jit.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 36,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_jit.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_jit.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_jit.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -6,19 +6,19 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {CompileReflector} from '../compile_reflector';\n import * as o from '../output/output_ast';\n+import {ExternalReferenceResolver} from '../output/output_jit';\n \n /**\n  * Implementation of `CompileReflector` which resolves references to @angular/core\n  * symbols at runtime, according to a consumer-provided mapping.\n  *\n  * Only supports `resolveExternalReference`, all other methods throw.\n  */\n-export class R3JitReflector implements CompileReflector {\n-  constructor(private context: {[key: string]: any}) {}\n+export class R3JitReflector implements ExternalReferenceResolver {\n+  constructor(private context: {[key: string]: unknown}) {}\n \n-  resolveExternalReference(ref: o.ExternalReference): any {\n+  resolveExternalReference(ref: o.ExternalReference): unknown {\n     // This reflector only handles @angular/core imports.\n     if (ref.moduleName !== '@angular/core') {\n       throw new Error(`Cannot resolve external reference to ${\n@@ -29,36 +29,4 @@ export class R3JitReflector implements CompileReflector {\n     }\n     return this.context[ref.name!];\n   }\n-\n-  parameters(typeOrFunc: any): any[][] {\n-    throw new Error('Not implemented.');\n-  }\n-\n-  annotations(typeOrFunc: any): any[] {\n-    throw new Error('Not implemented.');\n-  }\n-\n-  shallowAnnotations(typeOrFunc: any): any[] {\n-    throw new Error('Not implemented.');\n-  }\n-\n-  tryAnnotations(typeOrFunc: any): any[] {\n-    throw new Error('Not implemented.');\n-  }\n-\n-  propMetadata(typeOrFunc: any): {[key: string]: any[];} {\n-    throw new Error('Not implemented.');\n-  }\n-\n-  hasLifecycleHook(type: any, lcProperty: string): boolean {\n-    throw new Error('Not implemented.');\n-  }\n-\n-  guards(typeOrFunc: any): {[key: string]: any;} {\n-    throw new Error('Not implemented.');\n-  }\n-\n-  componentModuleUrl(type: any, cmpMetadata: any): string {\n-    throw new Error('Not implemented.');\n-  }\n }"
        },
        {
            "sha": "475ce119b74e5c114071f64817cb8d7f9c439386",
            "filename": "packages/compiler/src/render3/view/compiler.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 22,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fcompiler.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -6,7 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {CompileDirectiveSummary} from '../../compile_metadata';\n import {BindingForm, convertPropertyBinding} from '../../compiler_util/expression_converter';\n import {ConstantPool} from '../../constant_pool';\n import * as core from '../../core';\n@@ -15,7 +14,6 @@ import * as o from '../../output/output_ast';\n import {ParseError, ParseSourceSpan, sanitizeIdentifier} from '../../parse_util';\n import {CssSelector, SelectorMatcher} from '../../selector';\n import {ShadowCss} from '../../shadow_css';\n-import {CONTENT_ATTR, HOST_ATTR} from '../../style_compiler';\n import {BindingParser} from '../../template_parser/binding_parser';\n import {error} from '../../util';\n import {BoundEvent} from '../r3_ast';\n@@ -32,6 +30,11 @@ import {asLiteral, chainedInstruction, conditionallyCreateMapObjectLiteral, CONT\n // If there is a match, the first matching group will contain the attribute name to bind.\n const ATTR_REGEX = /attr\\.([^\\]]+)/;\n \n+\n+const COMPONENT_VARIABLE = '%COMP%';\n+const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\n+const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\n+\n function baseDirectiveFields(\n     meta: R3DirectiveMetadata, constantPool: ConstantPool,\n     bindingParser: BindingParser): DefinitionMap {\n@@ -483,18 +486,18 @@ function createHostBindingsFunction(\n   const updateStatements: o.Statement[] = [];\n \n   const hostBindingSourceSpan = typeSourceSpan;\n-  const directiveSummary = metadataAsSummary(hostBindingsMetadata);\n \n   // Calculate host event bindings\n-  const eventBindings =\n-      bindingParser.createDirectiveHostEventAsts(directiveSummary, hostBindingSourceSpan);\n+  const eventBindings = bindingParser.createDirectiveHostEventAsts(\n+      hostBindingsMetadata.listeners, hostBindingSourceSpan);\n   if (eventBindings && eventBindings.length) {\n     const listeners = createHostListeners(eventBindings, name);\n     createStatements.push(...listeners);\n   }\n \n   // Calculate the host property bindings\n-  const bindings = bindingParser.createBoundHostProperties(directiveSummary, hostBindingSourceSpan);\n+  const bindings = bindingParser.createBoundHostProperties(\n+      hostBindingsMetadata.properties, hostBindingSourceSpan);\n   const allOtherBindings: ParsedProperty[] = [];\n \n   // We need to calculate the total amount of binding slots required by\n@@ -707,19 +710,6 @@ function createHostListeners(eventBindings: ParsedEvent[], name?: string): o.Sta\n   return instructions;\n }\n \n-function metadataAsSummary(meta: R3HostMetadata): CompileDirectiveSummary {\n-  // clang-format off\n-  return {\n-    // This is used by the BindingParser, which only deals with listeners and properties. There's no\n-    // need to pass attributes to it.\n-    hostAttributes: {},\n-    hostListeners: meta.listeners,\n-    hostProperties: meta.properties,\n-  } as CompileDirectiveSummary;\n-  // clang-format on\n-}\n-\n-\n \n const HOST_REG_EXP = /^(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\))$/;\n // Represents the groups in the above regex.\n@@ -804,12 +794,11 @@ export function parseHostBindings(host: {[key: string]: string|o.Expression}): P\n  */\n export function verifyHostBindings(\n     bindings: ParsedHostBindings, sourceSpan: ParseSourceSpan): ParseError[] {\n-  const summary = metadataAsSummary(bindings);\n   // TODO: abstract out host bindings verification logic and use it instead of\n   // creating events and properties ASTs to detect errors (FW-996)\n   const bindingParser = makeBindingParser();\n-  bindingParser.createDirectiveHostEventAsts(summary, sourceSpan);\n-  bindingParser.createBoundHostProperties(summary, sourceSpan);\n+  bindingParser.createDirectiveHostEventAsts(bindings.listeners, sourceSpan);\n+  bindingParser.createBoundHostProperties(bindings.properties, sourceSpan);\n   return bindingParser.errors;\n }\n "
        },
        {
            "sha": "060668c2a2ea99871573dbdf3ea801b0aa4cb7d7",
            "filename": "packages/compiler/src/render3/view/styling_builder.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 2,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fstyling_builder.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fstyling_builder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fstyling_builder.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -6,10 +6,9 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n import {AttributeMarker} from '../../core';\n-import {AST, ASTWithSource, BindingPipe, BindingType, Interpolation} from '../../expression_parser/ast';\n+import {AST, ASTWithSource, BindingPipe, BindingType, EmptyExpr, Interpolation} from '../../expression_parser/ast';\n import * as o from '../../output/output_ast';\n import {ParseSourceSpan} from '../../parse_util';\n-import {isEmptyExpression} from '../../template_parser/template_parser';\n import * as t from '../r3_ast';\n import {Identifiers as R3} from '../r3_identifiers';\n \n@@ -618,3 +617,10 @@ function getStylePropInterpolationExpression(interpolation: Interpolation) {\n function isCssCustomProperty(name: string): boolean {\n   return name.startsWith('--');\n }\n+\n+function isEmptyExpression(ast: AST): boolean {\n+  if (ast instanceof ASTWithSource) {\n+    ast = ast.ast;\n+  }\n+  return ast instanceof EmptyExpr;\n+}"
        },
        {
            "sha": "82b01f58d5b8084dfdd338e9c8946abf6f587e16",
            "filename": "packages/compiler/src/render3/view/template.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 3,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -6,7 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {flatten} from '../../compile_metadata';\n import {BindingForm, BuiltinFunctionCall, convertActionBinding, convertPropertyBinding, convertUpdateArguments, LocalResolver} from '../../compiler_util/expression_converter';\n import {ConstantPool} from '../../constant_pool';\n import * as core from '../../core';\n@@ -2226,8 +2225,7 @@ const elementRegistry = new DomElementSchemaRegistry();\n  */\n export function makeBindingParser(\n     interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): BindingParser {\n-  return new BindingParser(\n-      new IvyParser(new Lexer()), interpolationConfig, elementRegistry, null, []);\n+  return new BindingParser(new IvyParser(new Lexer()), interpolationConfig, elementRegistry, []);\n }\n \n export function resolveSanitizationFn(context: core.SecurityContext, isAttribute?: boolean) {\n@@ -2406,3 +2404,10 @@ export interface ParsedTemplate {\n    */\n   commentNodes?: t.Comment[];\n }\n+\n+function flatten<T>(list: Array<T|T[]>): T[] {\n+  return list.reduce((flat: any[], item: T|T[]): T[] => {\n+    const flatItem = Array.isArray(item) ? flatten(item) : item;\n+    return (<T[]>flat).concat(flatItem);\n+  }, []);\n+}"
        },
        {
            "sha": "f766f9d4505efaab1bb58277b50e3620212fd386",
            "filename": "packages/compiler/src/style_compiler.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 99,
            "changes": 99,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fstyle_compiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fstyle_compiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fstyle_compiler.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,99 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompileDirectiveMetadata, CompileStylesheetMetadata} from './compile_metadata';\n-import {OutputContext} from './constant_pool';\n-import {ViewEncapsulation} from './core';\n-import * as o from './output/output_ast';\n-import {identifierModuleUrl, identifierName} from './parse_util';\n-import {ShadowCss} from './shadow_css';\n-import {UrlResolver} from './url_resolver';\n-\n-const COMPONENT_VARIABLE = '%COMP%';\n-export const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\n-export const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\n-\n-export class StylesCompileDependency {\n-  constructor(\n-      public name: string, public moduleUrl: string, public setValue: (value: any) => void) {}\n-}\n-\n-export class CompiledStylesheet {\n-  constructor(\n-      public outputCtx: OutputContext, public stylesVar: string,\n-      public dependencies: StylesCompileDependency[], public isShimmed: boolean,\n-      public meta: CompileStylesheetMetadata) {}\n-}\n-\n-export class StyleCompiler {\n-  private _shadowCss: ShadowCss = new ShadowCss();\n-\n-  constructor(private _urlResolver: UrlResolver) {}\n-\n-  compileComponent(outputCtx: OutputContext, comp: CompileDirectiveMetadata): CompiledStylesheet {\n-    const template = comp.template !;\n-    return this._compileStyles(\n-        outputCtx, comp, new CompileStylesheetMetadata({\n-          styles: template.styles,\n-          styleUrls: template.styleUrls,\n-          moduleUrl: identifierModuleUrl(comp.type)\n-        }),\n-        this.needsStyleShim(comp), true);\n-  }\n-\n-  compileStyles(\n-      outputCtx: OutputContext, comp: CompileDirectiveMetadata,\n-      stylesheet: CompileStylesheetMetadata,\n-      shim: boolean = this.needsStyleShim(comp)): CompiledStylesheet {\n-    return this._compileStyles(outputCtx, comp, stylesheet, shim, false);\n-  }\n-\n-  needsStyleShim(comp: CompileDirectiveMetadata): boolean {\n-    return comp.template !.encapsulation === ViewEncapsulation.Emulated;\n-  }\n-\n-  private _compileStyles(\n-      outputCtx: OutputContext, comp: CompileDirectiveMetadata,\n-      stylesheet: CompileStylesheetMetadata, shim: boolean,\n-      isComponentStylesheet: boolean): CompiledStylesheet {\n-    const styleExpressions: o.Expression[] =\n-        stylesheet.styles.map(plainStyle => o.literal(this._shimIfNeeded(plainStyle, shim)));\n-    const dependencies: StylesCompileDependency[] = [];\n-    stylesheet.styleUrls.forEach((styleUrl) => {\n-      const exprIndex = styleExpressions.length;\n-      // Note: This placeholder will be filled later.\n-      styleExpressions.push(null!);\n-      dependencies.push(new StylesCompileDependency(\n-          getStylesVarName(null), styleUrl,\n-          (value) => styleExpressions[exprIndex] = outputCtx.importExpr(value)));\n-    });\n-    // styles variable contains plain strings and arrays of other styles arrays (recursive),\n-    // so we set its type to dynamic.\n-    const stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);\n-    const stmt = o.variable(stylesVar)\n-                     .set(o.literalArr(\n-                         styleExpressions, new o.ArrayType(o.DYNAMIC_TYPE, [o.TypeModifier.Const])))\n-                     .toDeclStmt(null, isComponentStylesheet ? [o.StmtModifier.Final] : [\n-                       o.StmtModifier.Final, o.StmtModifier.Exported\n-                     ]);\n-    outputCtx.statements.push(stmt);\n-    return new CompiledStylesheet(outputCtx, stylesVar, dependencies, shim, stylesheet);\n-  }\n-\n-  private _shimIfNeeded(style: string, shim: boolean): string {\n-    return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;\n-  }\n-}\n-\n-function getStylesVarName(component: CompileDirectiveMetadata|null): string {\n-  let result = `styles`;\n-  if (component) {\n-    result += `_${identifierName(component.type)}`;\n-  }\n-  return result;\n-}"
        },
        {
            "sha": "d982b393fdc2fc7a82bc8957c7a8b9c7dc0209fe",
            "filename": "packages/compiler/src/style_url_resolver.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 30,
            "changes": 30,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Fstyle_url_resolver.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Fstyle_url_resolver.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fstyle_url_resolver.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -9,40 +9,10 @@\n // Some of the code comes from WebComponents.JS\n // https://github.com/webcomponents/webcomponentsjs/blob/master/src/HTMLImports/path.js\n \n-import {UrlResolver} from './url_resolver';\n-\n-export class StyleWithImports {\n-  constructor(public style: string, public styleUrls: string[]) {}\n-}\n-\n export function isStyleUrlResolvable(url: string): boolean {\n   if (url == null || url.length === 0 || url[0] == '/') return false;\n   const schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n   return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n }\n \n-/**\n- * Rewrites stylesheets by resolving and removing the @import urls that\n- * are either relative or don't have a `package:` scheme\n- */\n-export function extractStyleUrls(\n-    resolver: UrlResolver, baseUrl: string, cssText: string): StyleWithImports {\n-  const foundUrls: string[] = [];\n-\n-  const modifiedCssText = cssText.replace(CSS_STRIPPABLE_COMMENT_REGEXP, '')\n-                              .replace(CSS_IMPORT_REGEXP, (...m: string[]) => {\n-                                const url = m[1] || m[2];\n-                                if (!isStyleUrlResolvable(url)) {\n-                                  // Do not attempt to resolve non-package absolute URLs with URI\n-                                  // scheme\n-                                  return m[0];\n-                                }\n-                                foundUrls.push(resolver.resolve(baseUrl, url));\n-                                return '';\n-                              });\n-  return new StyleWithImports(modifiedCssText, foundUrls);\n-}\n-\n-const CSS_IMPORT_REGEXP = /@import\\s+(?:url\\()?\\s*(?:(?:['\"]([^'\"]*))|([^;\\)\\s]*))[^;]*;?/g;\n-const CSS_STRIPPABLE_COMMENT_REGEXP = /\\/\\*(?!#\\s*(?:sourceURL|sourceMappingURL)=)[\\s\\S]+?\\*\\//g;\n const URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;"
        },
        {
            "sha": "55e0ecd440c73af382f08c575085a51ea2bcf48b",
            "filename": "packages/compiler/src/summary_resolver.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 55,
            "changes": 55,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fsummary_resolver.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fsummary_resolver.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fsummary_resolver.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,55 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import {CompileTypeSummary} from './compile_metadata';\n-import {Type} from './core';\n-\n-export interface Summary<T> {\n-  symbol: T;\n-  metadata: any;\n-  type?: CompileTypeSummary;\n-}\n-\n-export abstract class SummaryResolver<T> {\n-  abstract isLibraryFile(fileName: string): boolean;\n-  abstract toSummaryFileName(fileName: string, referringSrcFileName: string): string;\n-  abstract fromSummaryFileName(fileName: string, referringLibFileName: string): string;\n-  abstract resolveSummary(reference: T): Summary<T>|null;\n-  abstract getSymbolsOf(filePath: string): T[]|null;\n-  abstract getImportAs(reference: T): T;\n-  abstract getKnownModuleName(fileName: string): string|null;\n-  abstract addSummary(summary: Summary<T>): void;\n-}\n-\n-export class JitSummaryResolver implements SummaryResolver<Type> {\n-  private _summaries = new Map<Type, Summary<Type>>();\n-\n-  isLibraryFile(): boolean {\n-    return false;\n-  }\n-  toSummaryFileName(fileName: string): string {\n-    return fileName;\n-  }\n-  fromSummaryFileName(fileName: string): string {\n-    return fileName;\n-  }\n-  resolveSummary(reference: Type): Summary<Type>|null {\n-    return this._summaries.get(reference) || null;\n-  }\n-  getSymbolsOf(): Type[] {\n-    return [];\n-  }\n-  getImportAs(reference: Type): Type {\n-    return reference;\n-  }\n-  getKnownModuleName(fileName: string) {\n-    return null;\n-  }\n-  addSummary(summary: Summary<Type>) {\n-    this._summaries.set(summary.symbol, summary);\n-  }\n-}"
        },
        {
            "sha": "64d1b762d37e70c5a772ee1f4008d554f5157cbf",
            "filename": "packages/compiler/src/template_parser/binding_parser.ts",
            "status": "modified",
            "additions": 53,
            "deletions": 98,
            "changes": 151,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Ftemplate_parser%2Fbinding_parser.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Fsrc%2Ftemplate_parser%2Fbinding_parser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Ftemplate_parser%2Fbinding_parser.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -6,7 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {CompileDirectiveSummary, CompilePipeSummary} from '../compile_metadata';\n import {SecurityContext} from '../core';\n import {AbsoluteSourceSpan, ASTWithSource, BindingPipe, BindingType, BoundElementProperty, EmptyExpr, ParsedEvent, ParsedEventType, ParsedProperty, ParsedPropertyType, ParsedVariable, ParserError, RecursiveAstVisitor, TemplateBinding, VariableBinding} from '../expression_parser/ast';\n import {Parser} from '../expression_parser/parser';\n@@ -24,98 +23,82 @@ const STYLE_PREFIX = 'style';\n const TEMPLATE_ATTR_PREFIX = '*';\n const ANIMATE_PROP_PREFIX = 'animate-';\n \n+export interface HostProperties {\n+  [key: string]: string;\n+}\n+\n+export interface HostListeners {\n+  [key: string]: string;\n+}\n+\n /**\n  * Parses bindings in templates and in the directive host area.\n  */\n export class BindingParser {\n-  pipesByName: Map<string, CompilePipeSummary>|null = null;\n-\n-  private _usedPipes: Map<string, CompilePipeSummary> = new Map();\n-\n   constructor(\n       private _exprParser: Parser, private _interpolationConfig: InterpolationConfig,\n-      private _schemaRegistry: ElementSchemaRegistry, pipes: CompilePipeSummary[]|null,\n-      public errors: ParseError[]) {\n-    // When the `pipes` parameter is `null`, do not check for used pipes\n-    // This is used in IVY when we might not know the available pipes at compile time\n-    if (pipes) {\n-      const pipesByName: Map<string, CompilePipeSummary> = new Map();\n-      pipes.forEach(pipe => pipesByName.set(pipe.name, pipe));\n-      this.pipesByName = pipesByName;\n-    }\n-  }\n+      private _schemaRegistry: ElementSchemaRegistry, public errors: ParseError[]) {}\n \n   get interpolationConfig(): InterpolationConfig {\n     return this._interpolationConfig;\n   }\n \n-  getUsedPipes(): CompilePipeSummary[] {\n-    return Array.from(this._usedPipes.values());\n-  }\n-\n-  createBoundHostProperties(dirMeta: CompileDirectiveSummary, sourceSpan: ParseSourceSpan):\n+  createBoundHostProperties(properties: HostProperties, sourceSpan: ParseSourceSpan):\n       ParsedProperty[]|null {\n-    if (dirMeta.hostProperties) {\n-      const boundProps: ParsedProperty[] = [];\n-      Object.keys(dirMeta.hostProperties).forEach(propName => {\n-        const expression = dirMeta.hostProperties[propName];\n-        if (typeof expression === 'string') {\n-          this.parsePropertyBinding(\n-              propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [],\n-              // Use the `sourceSpan` for  `keySpan`. This isn't really accurate, but neither is the\n-              // sourceSpan, as it represents the sourceSpan of the host itself rather than the\n-              // source of the host binding (which doesn't exist in the template). Regardless,\n-              // neither of these values are used in Ivy but are only here to satisfy the function\n-              // signature. This should likely be refactored in the future so that `sourceSpan`\n-              // isn't being used inaccurately.\n-              boundProps, sourceSpan);\n-        } else {\n-          this._reportError(\n-              `Value of the host property binding \"${\n-                  propName}\" needs to be a string representing an expression but got \"${\n-                  expression}\" (${typeof expression})`,\n-              sourceSpan);\n-        }\n-      });\n-      return boundProps;\n+    const boundProps: ParsedProperty[] = [];\n+    for (const propName of Object.keys(properties)) {\n+      const expression = properties[propName];\n+      if (typeof expression === 'string') {\n+        this.parsePropertyBinding(\n+            propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [],\n+            // Use the `sourceSpan` for  `keySpan`. This isn't really accurate, but neither is the\n+            // sourceSpan, as it represents the sourceSpan of the host itself rather than the\n+            // source of the host binding (which doesn't exist in the template). Regardless,\n+            // neither of these values are used in Ivy but are only here to satisfy the function\n+            // signature. This should likely be refactored in the future so that `sourceSpan`\n+            // isn't being used inaccurately.\n+            boundProps, sourceSpan);\n+      } else {\n+        this._reportError(\n+            `Value of the host property binding \"${\n+                propName}\" needs to be a string representing an expression but got \"${\n+                expression}\" (${typeof expression})`,\n+            sourceSpan);\n+      }\n     }\n-    return null;\n+    return boundProps;\n   }\n \n   createDirectiveHostPropertyAsts(\n-      dirMeta: CompileDirectiveSummary, elementSelector: string,\n+      hostProperties: HostProperties, elementSelector: string,\n       sourceSpan: ParseSourceSpan): BoundElementProperty[]|null {\n-    const boundProps = this.createBoundHostProperties(dirMeta, sourceSpan);\n+    const boundProps = this.createBoundHostProperties(hostProperties, sourceSpan);\n     return boundProps &&\n         boundProps.map((prop) => this.createBoundElementProperty(elementSelector, prop));\n   }\n \n-  createDirectiveHostEventAsts(dirMeta: CompileDirectiveSummary, sourceSpan: ParseSourceSpan):\n+  createDirectiveHostEventAsts(hostListeners: HostListeners, sourceSpan: ParseSourceSpan):\n       ParsedEvent[]|null {\n-    if (dirMeta.hostListeners) {\n-      const targetEvents: ParsedEvent[] = [];\n-      Object.keys(dirMeta.hostListeners).forEach(propName => {\n-        const expression = dirMeta.hostListeners[propName];\n-        if (typeof expression === 'string') {\n-          // Use the `sourceSpan` for  `keySpan` and `handlerSpan`. This isn't really accurate, but\n-          // neither is the `sourceSpan`, as it represents the `sourceSpan` of the host itself\n-          // rather than the source of the host binding (which doesn't exist in the template).\n-          // Regardless, neither of these values are used in Ivy but are only here to satisfy the\n-          // function signature. This should likely be refactored in the future so that `sourceSpan`\n-          // isn't being used inaccurately.\n-          this.parseEvent(\n-              propName, expression, sourceSpan, sourceSpan, [], targetEvents, sourceSpan);\n-        } else {\n-          this._reportError(\n-              `Value of the host listener \"${\n-                  propName}\" needs to be a string representing an expression but got \"${\n-                  expression}\" (${typeof expression})`,\n-              sourceSpan);\n-        }\n-      });\n-      return targetEvents;\n+    const targetEvents: ParsedEvent[] = [];\n+    for (const propName of Object.keys(hostListeners)) {\n+      const expression = hostListeners[propName];\n+      if (typeof expression === 'string') {\n+        // Use the `sourceSpan` for  `keySpan` and `handlerSpan`. This isn't really accurate, but\n+        // neither is the `sourceSpan`, as it represents the `sourceSpan` of the host itself\n+        // rather than the source of the host binding (which doesn't exist in the template).\n+        // Regardless, neither of these values are used in Ivy but are only here to satisfy the\n+        // function signature. This should likely be refactored in the future so that `sourceSpan`\n+        // isn't being used inaccurately.\n+        this.parseEvent(propName, expression, sourceSpan, sourceSpan, [], targetEvents, sourceSpan);\n+      } else {\n+        this._reportError(\n+            `Value of the host listener \"${\n+                propName}\" needs to be a string representing an expression but got \"${\n+                expression}\" (${typeof expression})`,\n+            sourceSpan);\n+      }\n     }\n-    return null;\n+    return targetEvents;\n   }\n \n   parseInterpolation(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n@@ -126,7 +109,6 @@ export class BindingParser {\n       const ast = this._exprParser.parseInterpolation(\n           value, sourceInfo, absoluteOffset, this._interpolationConfig)!;\n       if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n-      this._checkPipes(ast, sourceSpan);\n       return ast;\n     } catch (e) {\n       this._reportError(`${e}`, sourceSpan);\n@@ -147,7 +129,6 @@ export class BindingParser {\n       const ast =\n           this._exprParser.parseInterpolationExpression(expression, sourceInfo, absoluteOffset);\n       if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n-      this._checkPipes(ast, sourceSpan);\n       return ast;\n     } catch (e) {\n       this._reportError(`${e}`, sourceSpan);\n@@ -223,11 +204,6 @@ export class BindingParser {\n       const bindingsResult = this._exprParser.parseTemplateBindings(\n           tplKey, tplValue, sourceInfo, absoluteKeyOffset, absoluteValueOffset);\n       this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n-      bindingsResult.templateBindings.forEach((binding) => {\n-        if (binding.value instanceof ASTWithSource) {\n-          this._checkPipes(binding.value, sourceSpan);\n-        }\n-      });\n       bindingsResult.warnings.forEach((warning) => {\n         this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);\n       });\n@@ -360,7 +336,6 @@ export class BindingParser {\n           this._exprParser.parseBinding(\n               value, sourceInfo, absoluteOffset, this._interpolationConfig);\n       if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n-      this._checkPipes(ast, sourceSpan);\n       return ast;\n     } catch (e) {\n       this._reportError(`${e}`, sourceSpan);\n@@ -512,7 +487,6 @@ export class BindingParser {\n         this._reportError(`Empty expressions are not allowed`, sourceSpan);\n         return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n       }\n-      this._checkPipes(ast, sourceSpan);\n       return ast;\n     } catch (e) {\n       this._reportError(`${e}`, sourceSpan);\n@@ -532,25 +506,6 @@ export class BindingParser {\n     }\n   }\n \n-  // Make sure all the used pipes are known in `this.pipesByName`\n-  private _checkPipes(ast: ASTWithSource, sourceSpan: ParseSourceSpan): void {\n-    if (ast && this.pipesByName) {\n-      const collector = new PipeCollector();\n-      ast.visit(collector);\n-      collector.pipes.forEach((ast, pipeName) => {\n-        const pipeMeta = this.pipesByName!.get(pipeName);\n-        if (!pipeMeta) {\n-          this._reportError(\n-              `The pipe '${pipeName}' could not be found`,\n-              new ParseSourceSpan(\n-                  sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\n-        } else {\n-          this._usedPipes.set(pipeName, pipeMeta);\n-        }\n-      });\n-    }\n-  }\n-\n   /**\n    * @param propName the name of the property / attribute\n    * @param sourceSpan"
        },
        {
            "sha": "323a70afa39f6d6f9f0f01d54e70f51880a8abfd",
            "filename": "packages/compiler/src/template_parser/template_ast.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 393,
            "changes": 393,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Ftemplate_parser%2Ftemplate_ast.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Ftemplate_parser%2Ftemplate_ast.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Ftemplate_parser%2Ftemplate_ast.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,393 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {AstPath} from '../ast_path';\n-import {CompileDirectiveSummary, CompileProviderMetadata, CompileTokenMetadata} from '../compile_metadata';\n-import {SecurityContext} from '../core';\n-import {ASTWithSource, BindingType, BoundElementProperty, ParsedEvent, ParsedEventType, ParsedVariable} from '../expression_parser/ast';\n-import {LifecycleHooks} from '../lifecycle_reflector';\n-import {ParseSourceSpan} from '../parse_util';\n-\n-\n-\n-/**\n- * An Abstract Syntax Tree node representing part of a parsed Angular template.\n- */\n-export interface TemplateAst {\n-  /**\n-   * The source span from which this node was parsed.\n-   */\n-  sourceSpan: ParseSourceSpan;\n-\n-  /**\n-   * Visit this node and possibly transform it.\n-   */\n-  visit(visitor: TemplateAstVisitor, context: any): any;\n-}\n-\n-/**\n- * A segment of text within the template.\n- */\n-export class TextAst implements TemplateAst {\n-  constructor(\n-      public value: string, public ngContentIndex: number, public sourceSpan: ParseSourceSpan) {}\n-  visit(visitor: TemplateAstVisitor, context: any): any {\n-    return visitor.visitText(this, context);\n-  }\n-}\n-\n-/**\n- * A bound expression within the text of a template.\n- */\n-export class BoundTextAst implements TemplateAst {\n-  constructor(\n-      public value: ASTWithSource, public ngContentIndex: number,\n-      public sourceSpan: ParseSourceSpan) {}\n-  visit(visitor: TemplateAstVisitor, context: any): any {\n-    return visitor.visitBoundText(this, context);\n-  }\n-}\n-\n-/**\n- * A plain attribute on an element.\n- */\n-export class AttrAst implements TemplateAst {\n-  constructor(public name: string, public value: string, public sourceSpan: ParseSourceSpan) {}\n-  visit(visitor: TemplateAstVisitor, context: any): any {\n-    return visitor.visitAttr(this, context);\n-  }\n-}\n-\n-export const enum PropertyBindingType {\n-  // A normal binding to a property (e.g. `[property]=\"expression\"`).\n-  Property,\n-  // A binding to an element attribute (e.g. `[attr.name]=\"expression\"`).\n-  Attribute,\n-  // A binding to a CSS class (e.g. `[class.name]=\"condition\"`).\n-  Class,\n-  // A binding to a style rule (e.g. `[style.rule]=\"expression\"`).\n-  Style,\n-  // A binding to an animation reference (e.g. `[animate.key]=\"expression\"`).\n-  Animation,\n-}\n-\n-const BoundPropertyMapping = {\n-  [BindingType.Animation]: PropertyBindingType.Animation,\n-  [BindingType.Attribute]: PropertyBindingType.Attribute,\n-  [BindingType.Class]: PropertyBindingType.Class,\n-  [BindingType.Property]: PropertyBindingType.Property,\n-  [BindingType.Style]: PropertyBindingType.Style,\n-};\n-\n-/**\n- * A binding for an element property (e.g. `[property]=\"expression\"`) or an animation trigger (e.g.\n- * `[@trigger]=\"stateExp\"`)\n- */\n-export class BoundElementPropertyAst implements TemplateAst {\n-  readonly isAnimation: boolean;\n-\n-  constructor(\n-      public name: string, public type: PropertyBindingType,\n-      public securityContext: SecurityContext, public value: ASTWithSource,\n-      public unit: string|null, public sourceSpan: ParseSourceSpan) {\n-    this.isAnimation = this.type === PropertyBindingType.Animation;\n-  }\n-\n-  static fromBoundProperty(prop: BoundElementProperty) {\n-    const type = BoundPropertyMapping[prop.type];\n-    return new BoundElementPropertyAst(\n-        prop.name, type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan);\n-  }\n-\n-  visit(visitor: TemplateAstVisitor, context: any): any {\n-    return visitor.visitElementProperty(this, context);\n-  }\n-}\n-\n-/**\n- * A binding for an element event (e.g. `(event)=\"handler()\"`) or an animation trigger event (e.g.\n- * `(@trigger.phase)=\"callback($event)\"`).\n- */\n-export class BoundEventAst implements TemplateAst {\n-  readonly fullName: string;\n-  readonly isAnimation: boolean;\n-\n-  constructor(\n-      public name: string, public target: string|null, public phase: string|null,\n-      public handler: ASTWithSource, public sourceSpan: ParseSourceSpan,\n-      public handlerSpan: ParseSourceSpan) {\n-    this.fullName = BoundEventAst.calcFullName(this.name, this.target, this.phase);\n-    this.isAnimation = !!this.phase;\n-  }\n-\n-  static calcFullName(name: string, target: string|null, phase: string|null): string {\n-    if (target) {\n-      return `${target}:${name}`;\n-    }\n-    if (phase) {\n-      return `@${name}.${phase}`;\n-    }\n-\n-    return name;\n-  }\n-\n-  static fromParsedEvent(event: ParsedEvent) {\n-    const target: string|null = event.type === ParsedEventType.Regular ? event.targetOrPhase : null;\n-    const phase: string|null =\n-        event.type === ParsedEventType.Animation ? event.targetOrPhase : null;\n-    return new BoundEventAst(\n-        event.name, target, phase, event.handler, event.sourceSpan, event.handlerSpan);\n-  }\n-\n-  visit(visitor: TemplateAstVisitor, context: any): any {\n-    return visitor.visitEvent(this, context);\n-  }\n-}\n-\n-/**\n- * A reference declaration on an element (e.g. `let someName=\"expression\"`).\n- */\n-export class ReferenceAst implements TemplateAst {\n-  constructor(\n-      public name: string, public value: CompileTokenMetadata, public originalValue: string,\n-      public sourceSpan: ParseSourceSpan) {}\n-  visit(visitor: TemplateAstVisitor, context: any): any {\n-    return visitor.visitReference(this, context);\n-  }\n-}\n-\n-/**\n- * A variable declaration on a <ng-template> (e.g. `var-someName=\"someLocalName\"`).\n- */\n-export class VariableAst implements TemplateAst {\n-  constructor(\n-      public readonly name: string, public readonly value: string,\n-      public readonly sourceSpan: ParseSourceSpan, public readonly valueSpan?: ParseSourceSpan) {}\n-\n-  static fromParsedVariable(v: ParsedVariable) {\n-    return new VariableAst(v.name, v.value, v.sourceSpan, v.valueSpan);\n-  }\n-\n-  visit(visitor: TemplateAstVisitor, context: any): any {\n-    return visitor.visitVariable(this, context);\n-  }\n-}\n-\n-/**\n- * An element declaration in a template.\n- */\n-export class ElementAst implements TemplateAst {\n-  constructor(\n-      public name: string, public attrs: AttrAst[], public inputs: BoundElementPropertyAst[],\n-      public outputs: BoundEventAst[], public references: ReferenceAst[],\n-      public directives: DirectiveAst[], public providers: ProviderAst[],\n-      public hasViewContainer: boolean, public queryMatches: QueryMatch[],\n-      public children: TemplateAst[], public ngContentIndex: number|null,\n-      public sourceSpan: ParseSourceSpan, public endSourceSpan: ParseSourceSpan|null) {}\n-\n-  visit(visitor: TemplateAstVisitor, context: any): any {\n-    return visitor.visitElement(this, context);\n-  }\n-}\n-\n-/**\n- * A `<ng-template>` element included in an Angular template.\n- */\n-export class EmbeddedTemplateAst implements TemplateAst {\n-  constructor(\n-      public attrs: AttrAst[], public outputs: BoundEventAst[], public references: ReferenceAst[],\n-      public variables: VariableAst[], public directives: DirectiveAst[],\n-      public providers: ProviderAst[], public hasViewContainer: boolean,\n-      public queryMatches: QueryMatch[], public children: TemplateAst[],\n-      public ngContentIndex: number, public sourceSpan: ParseSourceSpan) {}\n-\n-  visit(visitor: TemplateAstVisitor, context: any): any {\n-    return visitor.visitEmbeddedTemplate(this, context);\n-  }\n-}\n-\n-/**\n- * A directive property with a bound value (e.g. `*ngIf=\"condition\").\n- */\n-export class BoundDirectivePropertyAst implements TemplateAst {\n-  constructor(\n-      public directiveName: string, public templateName: string, public value: ASTWithSource,\n-      public sourceSpan: ParseSourceSpan) {}\n-  visit(visitor: TemplateAstVisitor, context: any): any {\n-    return visitor.visitDirectiveProperty(this, context);\n-  }\n-}\n-\n-/**\n- * A directive declared on an element.\n- */\n-export class DirectiveAst implements TemplateAst {\n-  constructor(\n-      public directive: CompileDirectiveSummary, public inputs: BoundDirectivePropertyAst[],\n-      public hostProperties: BoundElementPropertyAst[], public hostEvents: BoundEventAst[],\n-      public contentQueryStartId: number, public sourceSpan: ParseSourceSpan) {}\n-  visit(visitor: TemplateAstVisitor, context: any): any {\n-    return visitor.visitDirective(this, context);\n-  }\n-}\n-\n-/**\n- * A provider declared on an element\n- */\n-export class ProviderAst implements TemplateAst {\n-  constructor(\n-      public token: CompileTokenMetadata, public multiProvider: boolean, public eager: boolean,\n-      public providers: CompileProviderMetadata[], public providerType: ProviderAstType,\n-      public lifecycleHooks: LifecycleHooks[], public sourceSpan: ParseSourceSpan,\n-      readonly isModule: boolean) {}\n-\n-  visit(visitor: TemplateAstVisitor, context: any): any {\n-    // No visit method in the visitor for now...\n-    return null;\n-  }\n-}\n-\n-export enum ProviderAstType {\n-  PublicService,\n-  PrivateService,\n-  Component,\n-  Directive,\n-  Builtin\n-}\n-\n-/**\n- * Position where content is to be projected (instance of `<ng-content>` in a template).\n- */\n-export class NgContentAst implements TemplateAst {\n-  constructor(\n-      public index: number, public ngContentIndex: number, public sourceSpan: ParseSourceSpan) {}\n-  visit(visitor: TemplateAstVisitor, context: any): any {\n-    return visitor.visitNgContent(this, context);\n-  }\n-}\n-\n-export interface QueryMatch {\n-  queryId: number;\n-  value: CompileTokenMetadata;\n-}\n-\n-/**\n- * A visitor for {@link TemplateAst} trees that will process each node.\n- */\n-export interface TemplateAstVisitor {\n-  // Returning a truthy value from `visit()` will prevent `templateVisitAll()` from the call to\n-  // the typed method and result returned will become the result included in `visitAll()`s\n-  // result array.\n-  visit?(ast: TemplateAst, context: any): any;\n-\n-  visitNgContent(ast: NgContentAst, context: any): any;\n-  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any;\n-  visitElement(ast: ElementAst, context: any): any;\n-  visitReference(ast: ReferenceAst, context: any): any;\n-  visitVariable(ast: VariableAst, context: any): any;\n-  visitEvent(ast: BoundEventAst, context: any): any;\n-  visitElementProperty(ast: BoundElementPropertyAst, context: any): any;\n-  visitAttr(ast: AttrAst, context: any): any;\n-  visitBoundText(ast: BoundTextAst, context: any): any;\n-  visitText(ast: TextAst, context: any): any;\n-  visitDirective(ast: DirectiveAst, context: any): any;\n-  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any;\n-}\n-\n-/**\n- * A visitor that accepts each node but doesn't do anything. It is intended to be used\n- * as the base class for a visitor that is only interested in a subset of the node types.\n- */\n-export class NullTemplateVisitor implements TemplateAstVisitor {\n-  visitNgContent(ast: NgContentAst, context: any): void {}\n-  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): void {}\n-  visitElement(ast: ElementAst, context: any): void {}\n-  visitReference(ast: ReferenceAst, context: any): void {}\n-  visitVariable(ast: VariableAst, context: any): void {}\n-  visitEvent(ast: BoundEventAst, context: any): void {}\n-  visitElementProperty(ast: BoundElementPropertyAst, context: any): void {}\n-  visitAttr(ast: AttrAst, context: any): void {}\n-  visitBoundText(ast: BoundTextAst, context: any): void {}\n-  visitText(ast: TextAst, context: any): void {}\n-  visitDirective(ast: DirectiveAst, context: any): void {}\n-  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): void {}\n-}\n-\n-/**\n- * Base class that can be used to build a visitor that visits each node\n- * in an template ast recursively.\n- */\n-export class RecursiveTemplateAstVisitor extends NullTemplateVisitor implements TemplateAstVisitor {\n-  constructor() {\n-    super();\n-  }\n-\n-  // Nodes with children\n-  override visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n-    return this.visitChildren(context, visit => {\n-      visit(ast.attrs);\n-      visit(ast.references);\n-      visit(ast.variables);\n-      visit(ast.directives);\n-      visit(ast.providers);\n-      visit(ast.children);\n-    });\n-  }\n-\n-  override visitElement(ast: ElementAst, context: any): any {\n-    return this.visitChildren(context, visit => {\n-      visit(ast.attrs);\n-      visit(ast.inputs);\n-      visit(ast.outputs);\n-      visit(ast.references);\n-      visit(ast.directives);\n-      visit(ast.providers);\n-      visit(ast.children);\n-    });\n-  }\n-\n-  override visitDirective(ast: DirectiveAst, context: any): any {\n-    return this.visitChildren(context, visit => {\n-      visit(ast.inputs);\n-      visit(ast.hostProperties);\n-      visit(ast.hostEvents);\n-    });\n-  }\n-\n-  protected visitChildren(\n-      context: any,\n-      cb: (visit: (<V extends TemplateAst>(children: V[]|undefined) => void)) => void) {\n-    let results: any[][] = [];\n-    let t = this;\n-    function visit<T extends TemplateAst>(children: T[]|undefined) {\n-      if (children && children.length) results.push(templateVisitAll(t, children, context));\n-    }\n-    cb(visit);\n-    return Array.prototype.concat.apply([], results);\n-  }\n-}\n-\n-/**\n- * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.\n- */\n-export function templateVisitAll(\n-    visitor: TemplateAstVisitor, asts: TemplateAst[], context: any = null): any[] {\n-  const result: any[] = [];\n-  const visit = visitor.visit ?\n-      (ast: TemplateAst) => visitor.visit!(ast, context) || ast.visit(visitor, context) :\n-      (ast: TemplateAst) => ast.visit(visitor, context);\n-  asts.forEach(ast => {\n-    const astResult = visit(ast);\n-    if (astResult) {\n-      result.push(astResult);\n-    }\n-  });\n-  return result;\n-}\n-\n-export type TemplateAstPath = AstPath<TemplateAst>;"
        },
        {
            "sha": "d680c90def5bb8df2ed02aec0d176d11c6bce111",
            "filename": "packages/compiler/src/template_parser/template_parser.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 939,
            "changes": 939,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Ftemplate_parser%2Ftemplate_parser.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Ftemplate_parser%2Ftemplate_parser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Ftemplate_parser%2Ftemplate_parser.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,939 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompileDirectiveMetadata, CompileDirectiveSummary, CompilePipeSummary, CompileTokenMetadata, CompileTypeMetadata} from '../compile_metadata';\n-import {CompileReflector} from '../compile_reflector';\n-import {CompilerConfig} from '../config';\n-import {SchemaMetadata} from '../core';\n-import {AST, ASTWithSource, EmptyExpr, ParsedEvent, ParsedProperty, ParsedVariable} from '../expression_parser/ast';\n-import {Parser} from '../expression_parser/parser';\n-import {createTokenForExternalReference, createTokenForReference, Identifiers} from '../identifiers';\n-import * as html from '../ml_parser/ast';\n-import {HtmlParser} from '../ml_parser/html_parser';\n-import {removeWhitespaces, replaceNgsp} from '../ml_parser/html_whitespaces';\n-import {expandNodes} from '../ml_parser/icu_ast_expander';\n-import {InterpolationConfig} from '../ml_parser/interpolation_config';\n-import {ParseTreeResult} from '../ml_parser/parser';\n-import {isNgTemplate, splitNsName} from '../ml_parser/tags';\n-import {identifierName, ParseError, ParseErrorLevel, ParseSourceSpan, syntaxError} from '../parse_util';\n-import {ProviderElementContext, ProviderViewContext} from '../provider_analyzer';\n-import {ElementSchemaRegistry} from '../schema/element_schema_registry';\n-import {CssSelector, SelectorMatcher} from '../selector';\n-import {isStyleUrlResolvable} from '../style_url_resolver';\n-import {Console, newArray} from '../util';\n-\n-import {BindingParser} from './binding_parser';\n-import * as t from './template_ast';\n-import {PreparsedElementType, preparseElement} from './template_preparser';\n-\n-const BIND_NAME_REGEXP =\n-    /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/;\n-\n-// Group 1 = \"bind-\"\n-const KW_BIND_IDX = 1;\n-// Group 2 = \"let-\"\n-const KW_LET_IDX = 2;\n-// Group 3 = \"ref-/#\"\n-const KW_REF_IDX = 3;\n-// Group 4 = \"on-\"\n-const KW_ON_IDX = 4;\n-// Group 5 = \"bindon-\"\n-const KW_BINDON_IDX = 5;\n-// Group 6 = \"@\"\n-const KW_AT_IDX = 6;\n-// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\n-const IDENT_KW_IDX = 7;\n-// Group 8 = identifier inside [()]\n-const IDENT_BANANA_BOX_IDX = 8;\n-// Group 9 = identifier inside []\n-const IDENT_PROPERTY_IDX = 9;\n-// Group 10 = identifier inside ()\n-const IDENT_EVENT_IDX = 10;\n-\n-const TEMPLATE_ATTR_PREFIX = '*';\n-const CLASS_ATTR = 'class';\n-\n-let _TEXT_CSS_SELECTOR!: CssSelector;\n-function TEXT_CSS_SELECTOR(): CssSelector {\n-  if (!_TEXT_CSS_SELECTOR) {\n-    _TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];\n-  }\n-  return _TEXT_CSS_SELECTOR;\n-}\n-\n-export class TemplateParseError extends ParseError {\n-  constructor(message: string, span: ParseSourceSpan, level: ParseErrorLevel) {\n-    super(span, message, level);\n-  }\n-}\n-\n-export class TemplateParseResult {\n-  constructor(\n-      public templateAst?: t.TemplateAst[], public usedPipes?: CompilePipeSummary[],\n-      public errors?: ParseError[]) {}\n-}\n-\n-export class TemplateParser {\n-  constructor(\n-      private _config: CompilerConfig, private _reflector: CompileReflector,\n-      private _exprParser: Parser, private _schemaRegistry: ElementSchemaRegistry,\n-      private _htmlParser: HtmlParser, private _console: Console|null,\n-      public transforms: t.TemplateAstVisitor[]) {}\n-\n-  public get expressionParser() {\n-    return this._exprParser;\n-  }\n-\n-  parse(\n-      component: CompileDirectiveMetadata, template: string|ParseTreeResult,\n-      directives: CompileDirectiveSummary[], pipes: CompilePipeSummary[], schemas: SchemaMetadata[],\n-      templateUrl: string,\n-      preserveWhitespaces: boolean): {template: t.TemplateAst[], pipes: CompilePipeSummary[]} {\n-    const result = this.tryParse(\n-        component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces);\n-    const warnings = result.errors!.filter(error => error.level === ParseErrorLevel.WARNING);\n-\n-    const errors = result.errors!.filter(error => error.level === ParseErrorLevel.ERROR);\n-\n-    if (warnings.length > 0) {\n-      this._console?.warn(`Template parse warnings:\\n${warnings.join('\\n')}`);\n-    }\n-\n-    if (errors.length > 0) {\n-      const errorString = errors.join('\\n');\n-      throw syntaxError(`Template parse errors:\\n${errorString}`, errors);\n-    }\n-\n-    return {template: result.templateAst!, pipes: result.usedPipes!};\n-  }\n-\n-  tryParse(\n-      component: CompileDirectiveMetadata, template: string|ParseTreeResult,\n-      directives: CompileDirectiveSummary[], pipes: CompilePipeSummary[], schemas: SchemaMetadata[],\n-      templateUrl: string, preserveWhitespaces: boolean): TemplateParseResult {\n-    let htmlParseResult = typeof template === 'string' ?\n-        this._htmlParser!.parse(template, templateUrl, {\n-          tokenizeExpansionForms: true,\n-          interpolationConfig: this.getInterpolationConfig(component)\n-        }) :\n-        template;\n-\n-    if (!preserveWhitespaces) {\n-      htmlParseResult = removeWhitespaces(htmlParseResult);\n-    }\n-\n-    return this.tryParseHtml(\n-        this.expandHtml(htmlParseResult), component, directives, pipes, schemas);\n-  }\n-\n-  tryParseHtml(\n-      htmlAstWithErrors: ParseTreeResult, component: CompileDirectiveMetadata,\n-      directives: CompileDirectiveSummary[], pipes: CompilePipeSummary[],\n-      schemas: SchemaMetadata[]): TemplateParseResult {\n-    let result: t.TemplateAst[];\n-    const errors = htmlAstWithErrors.errors;\n-    const usedPipes: CompilePipeSummary[] = [];\n-    if (htmlAstWithErrors.rootNodes.length > 0) {\n-      const uniqDirectives = removeSummaryDuplicates(directives);\n-      const uniqPipes = removeSummaryDuplicates(pipes);\n-      const providerViewContext = new ProviderViewContext(this._reflector, component);\n-      let interpolationConfig: InterpolationConfig = undefined!;\n-      if (component.template && component.template.interpolation) {\n-        interpolationConfig = {\n-          start: component.template.interpolation[0],\n-          end: component.template.interpolation[1]\n-        };\n-      }\n-      const bindingParser = new BindingParser(\n-          this._exprParser, interpolationConfig!, this._schemaRegistry, uniqPipes, errors);\n-      const parseVisitor = new TemplateParseVisitor(\n-          this._reflector, this._config, providerViewContext, uniqDirectives, bindingParser,\n-          this._schemaRegistry, schemas, errors);\n-      result = html.visitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);\n-      errors.push(...providerViewContext.errors);\n-      usedPipes.push(...bindingParser.getUsedPipes());\n-    } else {\n-      result = [];\n-    }\n-    this._assertNoReferenceDuplicationOnTemplate(result, errors);\n-\n-    if (errors.length > 0) {\n-      return new TemplateParseResult(result, usedPipes, errors);\n-    }\n-\n-    if (this.transforms) {\n-      this.transforms.forEach((transform: t.TemplateAstVisitor) => {\n-        result = t.templateVisitAll(transform, result);\n-      });\n-    }\n-\n-    return new TemplateParseResult(result, usedPipes, errors);\n-  }\n-\n-  expandHtml(htmlAstWithErrors: ParseTreeResult, forced: boolean = false): ParseTreeResult {\n-    const errors: ParseError[] = htmlAstWithErrors.errors;\n-\n-    if (errors.length == 0 || forced) {\n-      // Transform ICU messages to angular directives\n-      const expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);\n-      errors.push(...expandedHtmlAst.errors);\n-      htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);\n-    }\n-    return htmlAstWithErrors;\n-  }\n-\n-  getInterpolationConfig(component: CompileDirectiveMetadata): InterpolationConfig|undefined {\n-    if (component.template) {\n-      return InterpolationConfig.fromArray(component.template.interpolation);\n-    }\n-    return undefined;\n-  }\n-\n-  /** @internal */\n-  _assertNoReferenceDuplicationOnTemplate(result: t.TemplateAst[], errors: TemplateParseError[]):\n-      void {\n-    const existingReferences: string[] = [];\n-\n-    result.filter(element => !!(<any>element).references)\n-        .forEach(element => (<any>element).references.forEach((reference: t.ReferenceAst) => {\n-          const name = reference.name;\n-          if (existingReferences.indexOf(name) < 0) {\n-            existingReferences.push(name);\n-          } else {\n-            const error = new TemplateParseError(\n-                `Reference \"#${name}\" is defined several times`, reference.sourceSpan,\n-                ParseErrorLevel.ERROR);\n-            errors.push(error);\n-          }\n-        }));\n-  }\n-}\n-\n-class TemplateParseVisitor implements html.Visitor {\n-  selectorMatcher = new SelectorMatcher();\n-  directivesIndex = new Map<CompileDirectiveSummary, number>();\n-  ngContentCount = 0;\n-  contentQueryStartId: number;\n-\n-  constructor(\n-      private reflector: CompileReflector, private config: CompilerConfig,\n-      public providerViewContext: ProviderViewContext, directives: CompileDirectiveSummary[],\n-      private _bindingParser: BindingParser, private _schemaRegistry: ElementSchemaRegistry,\n-      private _schemas: SchemaMetadata[], private _targetErrors: TemplateParseError[]) {\n-    // Note: queries start with id 1 so we can use the number in a Bloom filter!\n-    this.contentQueryStartId = providerViewContext.component.viewQueries.length + 1;\n-    directives.forEach((directive, index) => {\n-      const selector = CssSelector.parse(directive.selector!);\n-      this.selectorMatcher.addSelectables(selector, directive);\n-      this.directivesIndex.set(directive, index);\n-    });\n-  }\n-\n-  visitExpansion(expansion: html.Expansion, context: any): any {\n-    return null;\n-  }\n-\n-  visitExpansionCase(expansionCase: html.ExpansionCase, context: any): any {\n-    return null;\n-  }\n-\n-  visitText(text: html.Text, parent: ElementContext): any {\n-    const ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR())!;\n-    const valueNoNgsp = replaceNgsp(text.value);\n-    const expr = this._bindingParser.parseInterpolation(valueNoNgsp, text.sourceSpan);\n-    return expr ? new t.BoundTextAst(expr, ngContentIndex, text.sourceSpan) :\n-                  new t.TextAst(valueNoNgsp, ngContentIndex, text.sourceSpan);\n-  }\n-\n-  visitAttribute(attribute: html.Attribute, context: any): any {\n-    return new t.AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n-  }\n-\n-  visitComment(comment: html.Comment, context: any): any {\n-    return null;\n-  }\n-\n-  visitElement(element: html.Element, parent: ElementContext): any {\n-    const queryStartIndex = this.contentQueryStartId;\n-    const elName = element.name;\n-    const preparsedElement = preparseElement(element);\n-    if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n-        preparsedElement.type === PreparsedElementType.STYLE) {\n-      // Skipping <script> for security reasons\n-      // Skipping <style> as we already processed them\n-      // in the StyleCompiler\n-      return null;\n-    }\n-    if (preparsedElement.type === PreparsedElementType.STYLESHEET &&\n-        isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n-      // Skipping stylesheets with either relative urls or package scheme as we already processed\n-      // them in the StyleCompiler\n-      return null;\n-    }\n-\n-    const matchableAttrs: [string, string][] = [];\n-    const elementOrDirectiveProps: ParsedProperty[] = [];\n-    const elementOrDirectiveRefs: ElementOrDirectiveRef[] = [];\n-    const elementVars: t.VariableAst[] = [];\n-    const events: t.BoundEventAst[] = [];\n-\n-    const templateElementOrDirectiveProps: ParsedProperty[] = [];\n-    const templateMatchableAttrs: [string, string][] = [];\n-    const templateElementVars: t.VariableAst[] = [];\n-\n-    let hasInlineTemplates = false;\n-    const attrs: t.AttrAst[] = [];\n-    const isTemplateElement = isNgTemplate(element.name);\n-\n-    element.attrs.forEach(attr => {\n-      const parsedVariables: ParsedVariable[] = [];\n-      const hasBinding = this._parseAttr(\n-          isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events,\n-          elementOrDirectiveRefs, elementVars);\n-      elementVars.push(...parsedVariables.map(v => t.VariableAst.fromParsedVariable(v)));\n-\n-      let templateValue: string|undefined;\n-      let templateKey: string|undefined;\n-      const normalizedName = this._normalizeAttributeName(attr.name);\n-\n-      if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n-        templateValue = attr.value;\n-        templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);\n-      }\n-\n-      const hasTemplateBinding = templateValue != null;\n-      if (hasTemplateBinding) {\n-        if (hasInlineTemplates) {\n-          this._reportError(\n-              `Can't have multiple template bindings on one element. Use only one attribute prefixed with *`,\n-              attr.sourceSpan);\n-        }\n-        hasInlineTemplates = true;\n-        const parsedVariables: ParsedVariable[] = [];\n-        const absoluteOffset = (attr.valueSpan || attr.sourceSpan).start.offset;\n-        this._bindingParser.parseInlineTemplateBinding(\n-            templateKey!, templateValue!, attr.sourceSpan, absoluteOffset, templateMatchableAttrs,\n-            templateElementOrDirectiveProps, parsedVariables, false /* isIvyAst */);\n-        templateElementVars.push(...parsedVariables.map(v => t.VariableAst.fromParsedVariable(v)));\n-      }\n-\n-      if (!hasBinding && !hasTemplateBinding) {\n-        // don't include the bindings as attributes as well in the AST\n-        attrs.push(this.visitAttribute(attr, null));\n-        matchableAttrs.push([attr.name, attr.value]);\n-      }\n-    });\n-\n-    const elementCssSelector = createElementCssSelector(elName, matchableAttrs);\n-    const {directives: directiveMetas, matchElement} =\n-        this._parseDirectives(this.selectorMatcher, elementCssSelector);\n-    const references: t.ReferenceAst[] = [];\n-    const boundDirectivePropNames = new Set<string>();\n-    const directiveAsts = this._createDirectiveAsts(\n-        isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps,\n-        elementOrDirectiveRefs, element.sourceSpan, references, boundDirectivePropNames);\n-    const elementProps: t.BoundElementPropertyAst[] = this._createElementPropertyAsts(\n-        element.name, elementOrDirectiveProps, boundDirectivePropNames);\n-    const isViewRoot = parent.isTemplateElement || hasInlineTemplates;\n-\n-    const providerContext = new ProviderElementContext(\n-        this.providerViewContext, parent.providerContext!, isViewRoot, directiveAsts, attrs,\n-        references, isTemplateElement, queryStartIndex, element.sourceSpan);\n-\n-    const children: t.TemplateAst[] = html.visitAll(\n-        preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children,\n-        ElementContext.create(\n-            isTemplateElement, directiveAsts,\n-            isTemplateElement ? parent.providerContext! : providerContext));\n-    providerContext.afterElement();\n-    // Override the actual selector when the `ngProjectAs` attribute is provided\n-    const projectionSelector = preparsedElement.projectAs != '' ?\n-        CssSelector.parse(preparsedElement.projectAs)[0] :\n-        elementCssSelector;\n-    const ngContentIndex = parent.findNgContentIndex(projectionSelector)!;\n-    let parsedElement: t.TemplateAst;\n-\n-    if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n-      // `<ng-content>` element\n-      if (element.children && !element.children.every(_isEmptyTextNode)) {\n-        this._reportError(`<ng-content> element cannot have content.`, element.sourceSpan);\n-      }\n-\n-      parsedElement = new t.NgContentAst(\n-          this.ngContentCount++, hasInlineTemplates ? null! : ngContentIndex, element.sourceSpan);\n-    } else if (isTemplateElement) {\n-      // `<ng-template>` element\n-      this._assertAllEventsPublishedByDirectives(directiveAsts, events);\n-      this._assertNoComponentsNorElementBindingsOnTemplate(\n-          directiveAsts, elementProps, element.sourceSpan);\n-\n-      parsedElement = new t.EmbeddedTemplateAst(\n-          attrs, events, references, elementVars, providerContext.transformedDirectiveAsts,\n-          providerContext.transformProviders, providerContext.transformedHasViewContainer,\n-          providerContext.queryMatches, children, hasInlineTemplates ? null! : ngContentIndex,\n-          element.sourceSpan);\n-    } else {\n-      // element other than `<ng-content>` and `<ng-template>`\n-      this._assertElementExists(matchElement, element);\n-      this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);\n-\n-      const ngContentIndex =\n-          hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);\n-      parsedElement = new t.ElementAst(\n-          elName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts,\n-          providerContext.transformProviders, providerContext.transformedHasViewContainer,\n-          providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex,\n-          element.sourceSpan, element.endSourceSpan || null);\n-    }\n-\n-    if (hasInlineTemplates) {\n-      // The element as a *-attribute\n-      const templateQueryStartIndex = this.contentQueryStartId;\n-      const templateSelector = createElementCssSelector('ng-template', templateMatchableAttrs);\n-      const {directives} = this._parseDirectives(this.selectorMatcher, templateSelector);\n-      const templateBoundDirectivePropNames = new Set<string>();\n-      const templateDirectiveAsts = this._createDirectiveAsts(\n-          true, elName, directives, templateElementOrDirectiveProps, [], element.sourceSpan, [],\n-          templateBoundDirectivePropNames);\n-      const templateElementProps: t.BoundElementPropertyAst[] = this._createElementPropertyAsts(\n-          elName, templateElementOrDirectiveProps, templateBoundDirectivePropNames);\n-      this._assertNoComponentsNorElementBindingsOnTemplate(\n-          templateDirectiveAsts, templateElementProps, element.sourceSpan);\n-      const templateProviderContext = new ProviderElementContext(\n-          this.providerViewContext, parent.providerContext!, parent.isTemplateElement,\n-          templateDirectiveAsts, [], [], true, templateQueryStartIndex, element.sourceSpan);\n-      templateProviderContext.afterElement();\n-\n-      parsedElement = new t.EmbeddedTemplateAst(\n-          [], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts,\n-          templateProviderContext.transformProviders,\n-          templateProviderContext.transformedHasViewContainer, templateProviderContext.queryMatches,\n-          [parsedElement], ngContentIndex, element.sourceSpan);\n-    }\n-\n-    return parsedElement;\n-  }\n-\n-  private _parseAttr(\n-      isTemplateElement: boolean, attr: html.Attribute, targetMatchableAttrs: string[][],\n-      targetProps: ParsedProperty[], targetEvents: t.BoundEventAst[],\n-      targetRefs: ElementOrDirectiveRef[], targetVars: t.VariableAst[]): boolean {\n-    const name = this._normalizeAttributeName(attr.name);\n-    const value = attr.value;\n-    const srcSpan = attr.sourceSpan;\n-    const absoluteOffset = attr.valueSpan ? attr.valueSpan.start.offset : srcSpan.start.offset;\n-\n-    const boundEvents: ParsedEvent[] = [];\n-    const bindParts = name.match(BIND_NAME_REGEXP);\n-    let hasBinding = false;\n-\n-    if (bindParts !== null) {\n-      hasBinding = true;\n-      if (bindParts[KW_BIND_IDX] != null) {\n-        this._bindingParser.parsePropertyBinding(\n-            bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan,\n-            targetMatchableAttrs, targetProps);\n-\n-      } else if (bindParts[KW_LET_IDX]) {\n-        if (isTemplateElement) {\n-          const identifier = bindParts[IDENT_KW_IDX];\n-          this._parseVariable(identifier, value, srcSpan, targetVars);\n-        } else {\n-          this._reportError(`\"let-\" is only supported on ng-template elements.`, srcSpan);\n-        }\n-\n-      } else if (bindParts[KW_REF_IDX]) {\n-        const identifier = bindParts[IDENT_KW_IDX];\n-        this._parseReference(identifier, value, srcSpan, targetRefs);\n-\n-      } else if (bindParts[KW_ON_IDX]) {\n-        this._bindingParser.parseEvent(\n-            bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan,\n-            targetMatchableAttrs, boundEvents);\n-\n-      } else if (bindParts[KW_BINDON_IDX]) {\n-        this._bindingParser.parsePropertyBinding(\n-            bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan,\n-            targetMatchableAttrs, targetProps);\n-        this._parseAssignmentEvent(\n-            bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan,\n-            targetMatchableAttrs, boundEvents);\n-\n-      } else if (bindParts[KW_AT_IDX]) {\n-        this._bindingParser.parseLiteralAttr(\n-            name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs,\n-            targetProps);\n-\n-      } else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n-        this._bindingParser.parsePropertyBinding(\n-            bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan,\n-            targetMatchableAttrs, targetProps);\n-        this._parseAssignmentEvent(\n-            bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, attr.valueSpan || srcSpan,\n-            targetMatchableAttrs, boundEvents);\n-\n-      } else if (bindParts[IDENT_PROPERTY_IDX]) {\n-        this._bindingParser.parsePropertyBinding(\n-            bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan,\n-            targetMatchableAttrs, targetProps);\n-\n-      } else if (bindParts[IDENT_EVENT_IDX]) {\n-        this._bindingParser.parseEvent(\n-            bindParts[IDENT_EVENT_IDX], value, srcSpan, attr.valueSpan || srcSpan,\n-            targetMatchableAttrs, boundEvents);\n-      }\n-    } else {\n-      hasBinding = this._bindingParser.parsePropertyInterpolation(\n-          name, value, srcSpan, attr.valueSpan, targetMatchableAttrs, targetProps);\n-    }\n-\n-    if (!hasBinding) {\n-      this._bindingParser.parseLiteralAttr(\n-          name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n-    }\n-\n-    targetEvents.push(...boundEvents.map(e => t.BoundEventAst.fromParsedEvent(e)));\n-\n-    return hasBinding;\n-  }\n-\n-  private _normalizeAttributeName(attrName: string): string {\n-    return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n-  }\n-\n-  private _parseVariable(\n-      identifier: string, value: string, sourceSpan: ParseSourceSpan, targetVars: t.VariableAst[]) {\n-    if (identifier.indexOf('-') > -1) {\n-      this._reportError(`\"-\" is not allowed in variable names`, sourceSpan);\n-    } else if (identifier.length === 0) {\n-      this._reportError(`Variable does not have a name`, sourceSpan);\n-    }\n-\n-    targetVars.push(new t.VariableAst(identifier, value, sourceSpan));\n-  }\n-\n-  private _parseReference(\n-      identifier: string, value: string, sourceSpan: ParseSourceSpan,\n-      targetRefs: ElementOrDirectiveRef[]) {\n-    if (identifier.indexOf('-') > -1) {\n-      this._reportError(`\"-\" is not allowed in reference names`, sourceSpan);\n-    } else if (identifier.length === 0) {\n-      this._reportError(`Reference does not have a name`, sourceSpan);\n-    }\n-\n-    targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));\n-  }\n-\n-  private _parseAssignmentEvent(\n-      name: string, expression: string, sourceSpan: ParseSourceSpan, valueSpan: ParseSourceSpan,\n-      targetMatchableAttrs: string[][], targetEvents: ParsedEvent[]) {\n-    this._bindingParser.parseEvent(\n-        `${name}Change`, `${expression}=$event`, sourceSpan, valueSpan, targetMatchableAttrs,\n-        targetEvents);\n-  }\n-\n-  private _parseDirectives(selectorMatcher: SelectorMatcher, elementCssSelector: CssSelector):\n-      {directives: CompileDirectiveSummary[], matchElement: boolean} {\n-    // Need to sort the directives so that we get consistent results throughout,\n-    // as selectorMatcher uses Maps inside.\n-    // Also deduplicate directives as they might match more than one time!\n-    const directives = newArray(this.directivesIndex.size);\n-    // Whether any directive selector matches on the element name\n-    let matchElement = false;\n-\n-    selectorMatcher.match(elementCssSelector, (selector, directive) => {\n-      directives[this.directivesIndex.get(directive)!] = directive;\n-      matchElement = matchElement || selector.hasElementSelector();\n-    });\n-\n-    return {\n-      directives: directives.filter(dir => !!dir),\n-      matchElement,\n-    };\n-  }\n-\n-  private _createDirectiveAsts(\n-      isTemplateElement: boolean, elementName: string, directives: CompileDirectiveSummary[],\n-      props: ParsedProperty[], elementOrDirectiveRefs: ElementOrDirectiveRef[],\n-      elementSourceSpan: ParseSourceSpan, targetReferences: t.ReferenceAst[],\n-      targetBoundDirectivePropNames: Set<string>): t.DirectiveAst[] {\n-    const matchedReferences = new Set<string>();\n-    let component: CompileDirectiveSummary = null!;\n-\n-    const directiveAsts = directives.map((directive) => {\n-      const sourceSpan = new ParseSourceSpan(\n-          elementSourceSpan.start, elementSourceSpan.end, elementSourceSpan.fullStart,\n-          `Directive ${identifierName(directive.type)}`);\n-\n-      if (directive.isComponent) {\n-        component = directive;\n-      }\n-      const directiveProperties: t.BoundDirectivePropertyAst[] = [];\n-      const boundProperties =\n-          this._bindingParser.createDirectiveHostPropertyAsts(directive, elementName, sourceSpan)!;\n-\n-      let hostProperties =\n-          boundProperties.map(prop => t.BoundElementPropertyAst.fromBoundProperty(prop));\n-      // Note: We need to check the host properties here as well,\n-      // as we don't know the element name in the DirectiveWrapperCompiler yet.\n-      hostProperties = this._checkPropertiesInSchema(elementName, hostProperties);\n-      const parsedEvents = this._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan)!;\n-      this._createDirectivePropertyAsts(\n-          directive.inputs, props, directiveProperties, targetBoundDirectivePropNames);\n-      elementOrDirectiveRefs.forEach((elOrDirRef) => {\n-        if ((elOrDirRef.value.length === 0 && directive.isComponent) ||\n-            (elOrDirRef.isReferenceToDirective(directive))) {\n-          targetReferences.push(new t.ReferenceAst(\n-              elOrDirRef.name, createTokenForReference(directive.type.reference), elOrDirRef.value,\n-              elOrDirRef.sourceSpan));\n-          matchedReferences.add(elOrDirRef.name);\n-        }\n-      });\n-      const hostEvents = parsedEvents.map(e => t.BoundEventAst.fromParsedEvent(e));\n-      const contentQueryStartId = this.contentQueryStartId;\n-      this.contentQueryStartId += directive.queries.length;\n-      return new t.DirectiveAst(\n-          directive, directiveProperties, hostProperties, hostEvents, contentQueryStartId,\n-          sourceSpan);\n-    });\n-\n-    elementOrDirectiveRefs.forEach((elOrDirRef) => {\n-      if (elOrDirRef.value.length > 0) {\n-        if (!matchedReferences.has(elOrDirRef.name)) {\n-          this._reportError(\n-              `There is no directive with \"exportAs\" set to \"${elOrDirRef.value}\"`,\n-              elOrDirRef.sourceSpan);\n-        }\n-      } else if (!component) {\n-        let refToken: CompileTokenMetadata = null!;\n-        if (isTemplateElement) {\n-          refToken = createTokenForExternalReference(this.reflector, Identifiers.TemplateRef);\n-        }\n-        targetReferences.push(\n-            new t.ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.value, elOrDirRef.sourceSpan));\n-      }\n-    });\n-    return directiveAsts;\n-  }\n-\n-  private _createDirectivePropertyAsts(\n-      directiveProperties: {[key: string]: string}, boundProps: ParsedProperty[],\n-      targetBoundDirectiveProps: t.BoundDirectivePropertyAst[],\n-      targetBoundDirectivePropNames: Set<string>) {\n-    if (directiveProperties) {\n-      const boundPropsByName = new Map<string, ParsedProperty>();\n-      boundProps.forEach(boundProp => {\n-        const prevValue = boundPropsByName.get(boundProp.name);\n-        if (!prevValue || prevValue.isLiteral) {\n-          // give [a]=\"b\" a higher precedence than a=\"b\" on the same element\n-          boundPropsByName.set(boundProp.name, boundProp);\n-        }\n-      });\n-\n-      Object.keys(directiveProperties).forEach(dirProp => {\n-        const elProp = directiveProperties[dirProp];\n-        const boundProp = boundPropsByName.get(elProp);\n-\n-        // Bindings are optional, so this binding only needs to be set up if an expression is given.\n-        if (boundProp) {\n-          targetBoundDirectivePropNames.add(boundProp.name);\n-          if (!isEmptyExpression(boundProp.expression)) {\n-            targetBoundDirectiveProps.push(new t.BoundDirectivePropertyAst(\n-                dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));\n-          }\n-        }\n-      });\n-    }\n-  }\n-\n-  private _createElementPropertyAsts(\n-      elementName: string, props: ParsedProperty[],\n-      boundDirectivePropNames: Set<string>): t.BoundElementPropertyAst[] {\n-    const boundElementProps: t.BoundElementPropertyAst[] = [];\n-\n-    props.forEach((prop: ParsedProperty) => {\n-      if (!prop.isLiteral && !boundDirectivePropNames.has(prop.name)) {\n-        const boundProp = this._bindingParser.createBoundElementProperty(elementName, prop);\n-        boundElementProps.push(t.BoundElementPropertyAst.fromBoundProperty(boundProp));\n-      }\n-    });\n-    return this._checkPropertiesInSchema(elementName, boundElementProps);\n-  }\n-\n-  private _findComponentDirectives(directives: t.DirectiveAst[]): t.DirectiveAst[] {\n-    return directives.filter(directive => directive.directive.isComponent);\n-  }\n-\n-  private _findComponentDirectiveNames(directives: t.DirectiveAst[]): string[] {\n-    return this._findComponentDirectives(directives)\n-        .map(directive => identifierName(directive.directive.type)!);\n-  }\n-\n-  private _assertOnlyOneComponent(directives: t.DirectiveAst[], sourceSpan: ParseSourceSpan) {\n-    const componentTypeNames = this._findComponentDirectiveNames(directives);\n-    if (componentTypeNames.length > 1) {\n-      this._reportError(\n-          `More than one component matched on this element.\\n` +\n-              `Make sure that only one component's selector can match a given element.\\n` +\n-              `Conflicting components: ${componentTypeNames.join(',')}`,\n-          sourceSpan);\n-    }\n-  }\n-\n-  /**\n-   * Make sure that non-angular tags conform to the schemas.\n-   *\n-   * Note: An element is considered an angular tag when at least one directive selector matches the\n-   * tag name.\n-   *\n-   * @param matchElement Whether any directive has matched on the tag name\n-   * @param element the html element\n-   */\n-  private _assertElementExists(matchElement: boolean, element: html.Element) {\n-    const elName = element.name.replace(/^:xhtml:/, '');\n-\n-    if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {\n-      let errorMsg = `'${elName}' is not a known element:\\n`;\n-      errorMsg += `1. If '${\n-          elName}' is an Angular component, then verify that it is part of this module.\\n`;\n-      if (elName.indexOf('-') > -1) {\n-        errorMsg += `2. If '${\n-            elName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.`;\n-      } else {\n-        errorMsg +=\n-            `2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\n-      }\n-      this._reportError(errorMsg, element.sourceSpan);\n-    }\n-  }\n-\n-  private _assertNoComponentsNorElementBindingsOnTemplate(\n-      directives: t.DirectiveAst[], elementProps: t.BoundElementPropertyAst[],\n-      sourceSpan: ParseSourceSpan) {\n-    const componentTypeNames: string[] = this._findComponentDirectiveNames(directives);\n-    if (componentTypeNames.length > 0) {\n-      this._reportError(\n-          `Components on an embedded template: ${componentTypeNames.join(',')}`, sourceSpan);\n-    }\n-    elementProps.forEach(prop => {\n-      this._reportError(\n-          `Property binding ${\n-              prop.name} not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \"@NgModule.declarations\".`,\n-          sourceSpan);\n-    });\n-  }\n-\n-  private _assertAllEventsPublishedByDirectives(\n-      directives: t.DirectiveAst[], events: t.BoundEventAst[]) {\n-    const allDirectiveEvents = new Set<string>();\n-\n-    directives.forEach(directive => {\n-      Object.keys(directive.directive.outputs).forEach(k => {\n-        const eventName = directive.directive.outputs[k];\n-        allDirectiveEvents.add(eventName);\n-      });\n-    });\n-\n-    events.forEach(event => {\n-      if (event.target != null || !allDirectiveEvents.has(event.name)) {\n-        this._reportError(\n-            `Event binding ${\n-                event\n-                    .fullName} not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \"@NgModule.declarations\".`,\n-            event.sourceSpan);\n-      }\n-    });\n-  }\n-\n-  private _checkPropertiesInSchema(elementName: string, boundProps: t.BoundElementPropertyAst[]):\n-      t.BoundElementPropertyAst[] {\n-    // Note: We can't filter out empty expressions before this method,\n-    // as we still want to validate them!\n-    return boundProps.filter((boundProp) => {\n-      if (boundProp.type === t.PropertyBindingType.Property &&\n-          !this._schemaRegistry.hasProperty(elementName, boundProp.name, this._schemas)) {\n-        let errorMsg = `Can't bind to '${boundProp.name}' since it isn't a known property of '${\n-            elementName}'.`;\n-        if (elementName.startsWith('ng-')) {\n-          errorMsg +=\n-              `\\n1. If '${\n-                  boundProp\n-                      .name}' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.` +\n-              `\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\n-        } else if (elementName.indexOf('-') > -1) {\n-          errorMsg +=\n-              `\\n1. If '${elementName}' is an Angular component and it has '${\n-                  boundProp.name}' input, then verify that it is part of this module.` +\n-              `\\n2. If '${\n-                  elementName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.` +\n-              `\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\n-        }\n-        this._reportError(errorMsg, boundProp.sourceSpan);\n-      }\n-      return !isEmptyExpression(boundProp.value);\n-    });\n-  }\n-\n-  private _reportError(\n-      message: string, sourceSpan: ParseSourceSpan,\n-      level: ParseErrorLevel = ParseErrorLevel.ERROR) {\n-    this._targetErrors.push(new ParseError(sourceSpan, message, level));\n-  }\n-}\n-\n-class NonBindableVisitor implements html.Visitor {\n-  visitElement(ast: html.Element, parent: ElementContext): t.ElementAst|null {\n-    const preparsedElement = preparseElement(ast);\n-    if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n-        preparsedElement.type === PreparsedElementType.STYLE ||\n-        preparsedElement.type === PreparsedElementType.STYLESHEET) {\n-      // Skipping <script> for security reasons\n-      // Skipping <style> and stylesheets as we already processed them\n-      // in the StyleCompiler\n-      return null;\n-    }\n-\n-    const attrNameAndValues = ast.attrs.map((attr): [string, string] => [attr.name, attr.value]);\n-    const selector = createElementCssSelector(ast.name, attrNameAndValues);\n-    const ngContentIndex = parent.findNgContentIndex(selector);\n-    const children: t.TemplateAst[] = html.visitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);\n-    return new t.ElementAst(\n-        ast.name, html.visitAll(this, ast.attrs), [], [], [], [], [], false, [], children,\n-        ngContentIndex, ast.sourceSpan, ast.endSourceSpan);\n-  }\n-  visitComment(comment: html.Comment, context: any): any {\n-    return null;\n-  }\n-\n-  visitAttribute(attribute: html.Attribute, context: any): t.AttrAst {\n-    return new t.AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n-  }\n-\n-  visitText(text: html.Text, parent: ElementContext): t.TextAst {\n-    const ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR())!;\n-    return new t.TextAst(text.value, ngContentIndex, text.sourceSpan);\n-  }\n-\n-  visitExpansion(expansion: html.Expansion, context: any): any {\n-    return expansion;\n-  }\n-\n-  visitExpansionCase(expansionCase: html.ExpansionCase, context: any): any {\n-    return expansionCase;\n-  }\n-}\n-\n-/**\n- * A reference to an element or directive in a template. E.g., the reference in this template:\n- *\n- * <div #myMenu=\"coolMenu\">\n- *\n- * would be {name: 'myMenu', value: 'coolMenu', sourceSpan: ...}\n- */\n-class ElementOrDirectiveRef {\n-  constructor(public name: string, public value: string, public sourceSpan: ParseSourceSpan) {}\n-\n-  /** Gets whether this is a reference to the given directive. */\n-  isReferenceToDirective(directive: CompileDirectiveSummary) {\n-    return splitExportAs(directive.exportAs).indexOf(this.value) !== -1;\n-  }\n-}\n-\n-/** Splits a raw, potentially comma-delimited `exportAs` value into an array of names. */\n-function splitExportAs(exportAs: string|null): string[] {\n-  return exportAs ? exportAs.split(',').map(e => e.trim()) : [];\n-}\n-\n-export function splitClasses(classAttrValue: string): string[] {\n-  return classAttrValue.trim().split(/\\s+/g);\n-}\n-\n-class ElementContext {\n-  static create(\n-      isTemplateElement: boolean, directives: t.DirectiveAst[],\n-      providerContext: ProviderElementContext): ElementContext {\n-    const matcher = new SelectorMatcher();\n-    let wildcardNgContentIndex: number = null!;\n-    const component = directives.find(directive => directive.directive.isComponent);\n-    if (component) {\n-      const ngContentSelectors = component.directive.template !.ngContentSelectors;\n-      for (let i = 0; i < ngContentSelectors.length; i++) {\n-        const selector = ngContentSelectors[i];\n-        if (selector === '*') {\n-          wildcardNgContentIndex = i;\n-        } else {\n-          matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);\n-        }\n-      }\n-    }\n-    return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);\n-  }\n-  constructor(\n-      public isTemplateElement: boolean, private _ngContentIndexMatcher: SelectorMatcher,\n-      private _wildcardNgContentIndex: number|null,\n-      public providerContext: ProviderElementContext|null) {}\n-\n-  findNgContentIndex(selector: CssSelector): number|null {\n-    const ngContentIndices: number[] = [];\n-    this._ngContentIndexMatcher.match(selector, (selector, ngContentIndex) => {\n-      ngContentIndices.push(ngContentIndex);\n-    });\n-    ngContentIndices.sort();\n-    if (this._wildcardNgContentIndex != null) {\n-      ngContentIndices.push(this._wildcardNgContentIndex);\n-    }\n-    return ngContentIndices.length > 0 ? ngContentIndices[0] : null;\n-  }\n-}\n-\n-export function createElementCssSelector(\n-    elementName: string, attributes: [string, string][]): CssSelector {\n-  const cssSelector = new CssSelector();\n-  const elNameNoNs = splitNsName(elementName)[1];\n-\n-  cssSelector.setElement(elNameNoNs);\n-\n-  for (let i = 0; i < attributes.length; i++) {\n-    const attrName = attributes[i][0];\n-    const attrNameNoNs = splitNsName(attrName)[1];\n-    const attrValue = attributes[i][1];\n-\n-    cssSelector.addAttribute(attrNameNoNs, attrValue);\n-    if (attrName.toLowerCase() == CLASS_ATTR) {\n-      const classes = splitClasses(attrValue);\n-      classes.forEach(className => cssSelector.addClassName(className));\n-    }\n-  }\n-  return cssSelector;\n-}\n-\n-const EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);\n-const NON_BINDABLE_VISITOR = new NonBindableVisitor();\n-\n-function _isEmptyTextNode(node: html.Node): boolean {\n-  return node instanceof html.Text && node.value.trim().length == 0;\n-}\n-\n-export function removeSummaryDuplicates<T extends {type: CompileTypeMetadata}>(items: T[]): T[] {\n-  const map = new Map<any, T>();\n-\n-  items.forEach((item) => {\n-    if (!map.get(item.type.reference)) {\n-      map.set(item.type.reference, item);\n-    }\n-  });\n-\n-  return Array.from(map.values());\n-}\n-\n-export function isEmptyExpression(ast: AST): boolean {\n-  if (ast instanceof ASTWithSource) {\n-    ast = ast.ast;\n-  }\n-  return ast instanceof EmptyExpr;\n-}"
        },
        {
            "sha": "6e11f16f7decaa13f27d444a0e63bdf0f393e3f3",
            "filename": "packages/compiler/src/url_resolver.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 343,
            "changes": 343,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Furl_resolver.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Furl_resolver.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Furl_resolver.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,343 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-/**\n- * Create a {@link UrlResolver} with no package prefix.\n- */\n-export function createUrlResolverWithoutPackagePrefix(): UrlResolver {\n-  return new UrlResolver();\n-}\n-\n-export function createOfflineCompileUrlResolver(): UrlResolver {\n-  return new UrlResolver('.');\n-}\n-\n-/**\n- * Used by the {@link Compiler} when resolving HTML and CSS template URLs.\n- *\n- * This class can be overridden by the application developer to create custom behavior.\n- *\n- * See {@link Compiler}\n- *\n- * ## Example\n- *\n- * <code-example path=\"compiler/ts/url_resolver/url_resolver.ts\"></code-example>\n- *\n- * @security  When compiling templates at runtime, you must\n- * ensure that the entire template comes from a trusted source.\n- * Attacker-controlled data introduced by a template could expose your\n- * application to XSS risks. For more detail, see the [Security Guide](https://g.co/ng/security).\n- */\n-export interface UrlResolver {\n-  resolve(baseUrl: string, url: string): string;\n-}\n-\n-export interface UrlResolverCtor {\n-  new(packagePrefix?: string|null): UrlResolver;\n-}\n-\n-export const UrlResolver: UrlResolverCtor = class UrlResolverImpl {\n-  constructor(private _packagePrefix: string|null = null) {}\n-\n-  /**\n-   * Resolves the `url` given the `baseUrl`:\n-   * - when the `url` is null, the `baseUrl` is returned,\n-   * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of\n-   * `baseUrl` and `url`,\n-   * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is\n-   * returned as is (ignoring the `baseUrl`)\n-   */\n-  resolve(baseUrl: string, url: string): string {\n-    let resolvedUrl = url;\n-    if (baseUrl != null && baseUrl.length > 0) {\n-      resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);\n-    }\n-    const resolvedParts = _split(resolvedUrl);\n-    let prefix = this._packagePrefix;\n-    if (prefix != null && resolvedParts != null &&\n-        resolvedParts[_ComponentIndex.Scheme] == 'package') {\n-      let path = resolvedParts[_ComponentIndex.Path];\n-      prefix = prefix.replace(/\\/+$/, '');\n-      path = path.replace(/^\\/+/, '');\n-      return `${prefix}/${path}`;\n-    }\n-    return resolvedUrl;\n-  }\n-};\n-\n-/**\n- * Extract the scheme of a URL.\n- */\n-export function getUrlScheme(url: string): string {\n-  const match = _split(url);\n-  return (match && match[_ComponentIndex.Scheme]) || '';\n-}\n-\n-// The code below is adapted from Traceur:\n-// https://github.com/google/traceur-compiler/blob/9511c1dafa972bf0de1202a8a863bad02f0f95a8/src/runtime/url.js\n-\n-/**\n- * Builds a URI string from already-encoded parts.\n- *\n- * No encoding is performed.  Any component may be omitted as either null or\n- * undefined.\n- *\n- * @param opt_scheme The scheme such as 'http'.\n- * @param opt_userInfo The user name before the '@'.\n- * @param opt_domain The domain such as 'www.google.com', already\n- *     URI-encoded.\n- * @param opt_port The port number.\n- * @param opt_path The path, already URI-encoded.  If it is not\n- *     empty, it must begin with a slash.\n- * @param opt_queryData The URI-encoded query data.\n- * @param opt_fragment The URI-encoded fragment identifier.\n- * @return The fully combined URI.\n- */\n-function _buildFromEncodedParts(\n-    opt_scheme?: string, opt_userInfo?: string, opt_domain?: string, opt_port?: string,\n-    opt_path?: string, opt_queryData?: string, opt_fragment?: string): string {\n-  const out: string[] = [];\n-\n-  if (opt_scheme != null) {\n-    out.push(opt_scheme + ':');\n-  }\n-\n-  if (opt_domain != null) {\n-    out.push('//');\n-\n-    if (opt_userInfo != null) {\n-      out.push(opt_userInfo + '@');\n-    }\n-\n-    out.push(opt_domain);\n-\n-    if (opt_port != null) {\n-      out.push(':' + opt_port);\n-    }\n-  }\n-\n-  if (opt_path != null) {\n-    out.push(opt_path);\n-  }\n-\n-  if (opt_queryData != null) {\n-    out.push('?' + opt_queryData);\n-  }\n-\n-  if (opt_fragment != null) {\n-    out.push('#' + opt_fragment);\n-  }\n-\n-  return out.join('');\n-}\n-\n-/**\n- * A regular expression for breaking a URI into its component parts.\n- *\n- * {@link https://tools.ietf.org/html/rfc3986#appendix-B} says\n- * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n- * disambiguation method used by POSIX regular expressions, it is natural and\n- * commonplace to use a regular expression for parsing the potential five\n- * components of a URI reference.\n- *\n- * The following line is the regular expression for breaking-down a\n- * well-formed URI reference into its components.\n- *\n- * <pre>\n- * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n- *  12            3  4          5       6  7        8 9\n- * </pre>\n- *\n- * The numbers in the second line above are only to assist readability; they\n- * indicate the reference points for each subexpression (i.e., each paired\n- * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n- * For example, matching the above expression to\n- * <pre>\n- *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n- * </pre>\n- * results in the following subexpression matches:\n- * <pre>\n- *    $1 = http:\n- *    $2 = http\n- *    $3 = //www.ics.uci.edu\n- *    $4 = www.ics.uci.edu\n- *    $5 = /pub/ietf/uri/\n- *    $6 = <undefined>\n- *    $7 = <undefined>\n- *    $8 = #Related\n- *    $9 = Related\n- * </pre>\n- * where <undefined> indicates that the component is not present, as is the\n- * case for the query component in the above example. Therefore, we can\n- * determine the value of the five components as\n- * <pre>\n- *    scheme    = $2\n- *    authority = $4\n- *    path      = $5\n- *    query     = $7\n- *    fragment  = $9\n- * </pre>\n- *\n- * The regular expression has been modified slightly to expose the\n- * userInfo, domain, and port separately from the authority.\n- * The modified version yields\n- * <pre>\n- *    $1 = http              scheme\n- *    $2 = <undefined>       userInfo -\\\n- *    $3 = www.ics.uci.edu   domain     | authority\n- *    $4 = <undefined>       port     -/\n- *    $5 = /pub/ietf/uri/    path\n- *    $6 = <undefined>       query without ?\n- *    $7 = Related           fragment without #\n- * </pre>\n- * @internal\n- */\n-const _splitRe = new RegExp(\n-    '^' +\n-    '(?:' +\n-    '([^:/?#.]+)' +  // scheme - ignore special characters\n-                     // used by other URL parts such as :,\n-                     // ?, /, #, and .\n-    ':)?' +\n-    '(?://' +\n-    '(?:([^/?#]*)@)?' +                  // userInfo\n-    '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)' +  // domain - restrict to letters,\n-                                         // digits, dashes, dots, percent\n-                                         // escapes, and unicode characters.\n-    '(?::([0-9]+))?' +                   // port\n-    ')?' +\n-    '([^?#]+)?' +        // path\n-    '(?:\\\\?([^#]*))?' +  // query\n-    '(?:#(.*))?' +       // fragment\n-    '$');\n-\n-/**\n- * The index of each URI component in the return value of goog.uri.utils.split.\n- * @enum {number}\n- */\n-enum _ComponentIndex {\n-  Scheme = 1,\n-  UserInfo,\n-  Domain,\n-  Port,\n-  Path,\n-  QueryData,\n-  Fragment\n-}\n-\n-/**\n- * Splits a URI into its component parts.\n- *\n- * Each component can be accessed via the component indices; for example:\n- * <pre>\n- * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];\n- * </pre>\n- *\n- * @param uri The URI string to examine.\n- * @return Each component still URI-encoded.\n- *     Each component that is present will contain the encoded value, whereas\n- *     components that are not present will be undefined or empty, depending\n- *     on the browser's regular expression implementation.  Never null, since\n- *     arbitrary strings may still look like path names.\n- */\n-function _split(uri: string): Array<string|any> {\n-  return uri.match(_splitRe)!;\n-}\n-\n-/**\n- * Removes dot segments in given path component, as described in\n- * RFC 3986, section 5.2.4.\n- *\n- * @param path A non-empty path component.\n- * @return Path component with removed dot segments.\n- */\n-function _removeDotSegments(path: string): string {\n-  if (path == '/') return '/';\n-\n-  const leadingSlash = path[0] == '/' ? '/' : '';\n-  const trailingSlash = path[path.length - 1] === '/' ? '/' : '';\n-  const segments = path.split('/');\n-\n-  const out: string[] = [];\n-  let up = 0;\n-  for (let pos = 0; pos < segments.length; pos++) {\n-    const segment = segments[pos];\n-    switch (segment) {\n-      case '':\n-      case '.':\n-        break;\n-      case '..':\n-        if (out.length > 0) {\n-          out.pop();\n-        } else {\n-          up++;\n-        }\n-        break;\n-      default:\n-        out.push(segment);\n-    }\n-  }\n-\n-  if (leadingSlash == '') {\n-    while (up-- > 0) {\n-      out.unshift('..');\n-    }\n-\n-    if (out.length === 0) out.push('.');\n-  }\n-\n-  return leadingSlash + out.join('/') + trailingSlash;\n-}\n-\n-/**\n- * Takes an array of the parts from split and canonicalizes the path part\n- * and then joins all the parts.\n- */\n-function _joinAndCanonicalizePath(parts: any[]): string {\n-  let path = parts[_ComponentIndex.Path];\n-  path = path == null ? '' : _removeDotSegments(path);\n-  parts[_ComponentIndex.Path] = path;\n-\n-  return _buildFromEncodedParts(\n-      parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain],\n-      parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData],\n-      parts[_ComponentIndex.Fragment]);\n-}\n-\n-/**\n- * Resolves a URL.\n- * @param base The URL acting as the base URL.\n- * @param to The URL to resolve.\n- */\n-function _resolveUrl(base: string, url: string): string {\n-  const parts = _split(encodeURI(url));\n-  const baseParts = _split(base);\n-\n-  if (parts[_ComponentIndex.Scheme] != null) {\n-    return _joinAndCanonicalizePath(parts);\n-  } else {\n-    parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];\n-  }\n-\n-  for (let i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {\n-    if (parts[i] == null) {\n-      parts[i] = baseParts[i];\n-    }\n-  }\n-\n-  if (parts[_ComponentIndex.Path][0] == '/') {\n-    return _joinAndCanonicalizePath(parts);\n-  }\n-\n-  let path = baseParts[_ComponentIndex.Path];\n-  if (path == null) path = '/';\n-  const index = path.lastIndexOf('/');\n-  path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];\n-  parts[_ComponentIndex.Path] = path;\n-  return _joinAndCanonicalizePath(parts);\n-}"
        },
        {
            "sha": "844a5432934184eef88cfd9eaa10a5803c49af99",
            "filename": "packages/compiler/src/view_compiler/provider_compiler.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 209,
            "changes": 209,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fview_compiler%2Fprovider_compiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fview_compiler%2Fprovider_compiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fview_compiler%2Fprovider_compiler.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,209 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompileDiDependencyMetadata, CompileEntryComponentMetadata, CompileProviderMetadata, CompileTokenMetadata} from '../compile_metadata';\n-import {CompileReflector} from '../compile_reflector';\n-import {OutputContext} from '../constant_pool';\n-import {DepFlags, NodeFlags} from '../core';\n-import {createTokenForExternalReference, Identifiers} from '../identifiers';\n-import {LifecycleHooks} from '../lifecycle_reflector';\n-import * as o from '../output/output_ast';\n-import {convertValueToOutputAst} from '../output/value_util';\n-import {ProviderAst, ProviderAstType} from '../template_parser/template_ast';\n-\n-export function providerDef(ctx: OutputContext, providerAst: ProviderAst): {\n-  providerExpr: o.Expression,\n-  flags: NodeFlags,\n-  depsExpr: o.Expression,\n-  tokenExpr: o.Expression\n-} {\n-  let flags = NodeFlags.None;\n-  if (!providerAst.eager) {\n-    flags |= NodeFlags.LazyProvider;\n-  }\n-  if (providerAst.providerType === ProviderAstType.PrivateService) {\n-    flags |= NodeFlags.PrivateProvider;\n-  }\n-  if (providerAst.isModule) {\n-    flags |= NodeFlags.TypeModuleProvider;\n-  }\n-  providerAst.lifecycleHooks.forEach((lifecycleHook) => {\n-    // for regular providers, we only support ngOnDestroy\n-    if (lifecycleHook === LifecycleHooks.OnDestroy ||\n-        providerAst.providerType === ProviderAstType.Directive ||\n-        providerAst.providerType === ProviderAstType.Component) {\n-      flags |= lifecycleHookToNodeFlag(lifecycleHook);\n-    }\n-  });\n-  const {providerExpr, flags: providerFlags, depsExpr} = providerAst.multiProvider ?\n-      multiProviderDef(ctx, flags, providerAst.providers) :\n-      singleProviderDef(ctx, flags, providerAst.providerType, providerAst.providers[0]);\n-  return {\n-    providerExpr,\n-    flags: providerFlags,\n-    depsExpr,\n-    tokenExpr: tokenExpr(ctx, providerAst.token),\n-  };\n-}\n-\n-function multiProviderDef(\n-    ctx: OutputContext, flags: NodeFlags, providers: CompileProviderMetadata[]):\n-    {providerExpr: o.Expression, flags: NodeFlags, depsExpr: o.Expression} {\n-  const allDepDefs: o.Expression[] = [];\n-  const allParams: o.FnParam[] = [];\n-  const exprs = providers.map((provider, providerIndex) => {\n-    let expr: o.Expression;\n-    if (provider.useClass) {\n-      const depExprs = convertDeps(providerIndex, provider.deps || provider.useClass.diDeps);\n-      expr = ctx.importExpr(provider.useClass.reference).instantiate(depExprs);\n-    } else if (provider.useFactory) {\n-      const depExprs = convertDeps(providerIndex, provider.deps || provider.useFactory.diDeps);\n-      expr = ctx.importExpr(provider.useFactory.reference).callFn(depExprs);\n-    } else if (provider.useExisting) {\n-      const depExprs = convertDeps(providerIndex, [{token: provider.useExisting}]);\n-      expr = depExprs[0];\n-    } else {\n-      expr = convertValueToOutputAst(ctx, provider.useValue);\n-    }\n-    return expr;\n-  });\n-  const providerExpr =\n-      o.fn(allParams, [new o.ReturnStatement(o.literalArr(exprs))], o.INFERRED_TYPE);\n-  return {\n-    providerExpr,\n-    flags: flags | NodeFlags.TypeFactoryProvider,\n-    depsExpr: o.literalArr(allDepDefs)\n-  };\n-\n-  function convertDeps(providerIndex: number, deps: CompileDiDependencyMetadata[]) {\n-    return deps.map((dep, depIndex) => {\n-      const paramName = `p${providerIndex}_${depIndex}`;\n-      allParams.push(new o.FnParam(paramName, o.DYNAMIC_TYPE));\n-      allDepDefs.push(depDef(ctx, dep));\n-      return o.variable(paramName);\n-    });\n-  }\n-}\n-\n-function singleProviderDef(\n-    ctx: OutputContext, flags: NodeFlags, providerType: ProviderAstType,\n-    providerMeta: CompileProviderMetadata):\n-    {providerExpr: o.Expression, flags: NodeFlags, depsExpr: o.Expression} {\n-  let providerExpr: o.Expression;\n-  let deps: CompileDiDependencyMetadata[];\n-  if (providerType === ProviderAstType.Directive || providerType === ProviderAstType.Component) {\n-    providerExpr = ctx.importExpr(providerMeta.useClass!.reference);\n-    flags |= NodeFlags.TypeDirective;\n-    deps = providerMeta.deps || providerMeta.useClass!.diDeps;\n-  } else {\n-    if (providerMeta.useClass) {\n-      providerExpr = ctx.importExpr(providerMeta.useClass.reference);\n-      flags |= NodeFlags.TypeClassProvider;\n-      deps = providerMeta.deps || providerMeta.useClass.diDeps;\n-    } else if (providerMeta.useFactory) {\n-      providerExpr = ctx.importExpr(providerMeta.useFactory.reference);\n-      flags |= NodeFlags.TypeFactoryProvider;\n-      deps = providerMeta.deps || providerMeta.useFactory.diDeps;\n-    } else if (providerMeta.useExisting) {\n-      providerExpr = o.NULL_EXPR;\n-      flags |= NodeFlags.TypeUseExistingProvider;\n-      deps = [{token: providerMeta.useExisting}];\n-    } else {\n-      providerExpr = convertValueToOutputAst(ctx, providerMeta.useValue);\n-      flags |= NodeFlags.TypeValueProvider;\n-      deps = [];\n-    }\n-  }\n-  const depsExpr = o.literalArr(deps.map(dep => depDef(ctx, dep)));\n-  return {providerExpr, flags, depsExpr};\n-}\n-\n-function tokenExpr(ctx: OutputContext, tokenMeta: CompileTokenMetadata): o.Expression {\n-  return tokenMeta.identifier ? ctx.importExpr(tokenMeta.identifier.reference) :\n-                                o.literal(tokenMeta.value);\n-}\n-\n-export function depDef(ctx: OutputContext, dep: CompileDiDependencyMetadata): o.Expression {\n-  // Note: the following fields have already been normalized out by provider_analyzer:\n-  // - isAttribute, isHost\n-  const expr = dep.isValue ? convertValueToOutputAst(ctx, dep.value) : tokenExpr(ctx, dep.token!);\n-  let flags = DepFlags.None;\n-  if (dep.isSkipSelf) {\n-    flags |= DepFlags.SkipSelf;\n-  }\n-  if (dep.isOptional) {\n-    flags |= DepFlags.Optional;\n-  }\n-  if (dep.isSelf) {\n-    flags |= DepFlags.Self;\n-  }\n-  if (dep.isValue) {\n-    flags |= DepFlags.Value;\n-  }\n-  return flags === DepFlags.None ? expr : o.literalArr([o.literal(flags), expr]);\n-}\n-\n-export function lifecycleHookToNodeFlag(lifecycleHook: LifecycleHooks): NodeFlags {\n-  let nodeFlag = NodeFlags.None;\n-  switch (lifecycleHook) {\n-    case LifecycleHooks.AfterContentChecked:\n-      nodeFlag = NodeFlags.AfterContentChecked;\n-      break;\n-    case LifecycleHooks.AfterContentInit:\n-      nodeFlag = NodeFlags.AfterContentInit;\n-      break;\n-    case LifecycleHooks.AfterViewChecked:\n-      nodeFlag = NodeFlags.AfterViewChecked;\n-      break;\n-    case LifecycleHooks.AfterViewInit:\n-      nodeFlag = NodeFlags.AfterViewInit;\n-      break;\n-    case LifecycleHooks.DoCheck:\n-      nodeFlag = NodeFlags.DoCheck;\n-      break;\n-    case LifecycleHooks.OnChanges:\n-      nodeFlag = NodeFlags.OnChanges;\n-      break;\n-    case LifecycleHooks.OnDestroy:\n-      nodeFlag = NodeFlags.OnDestroy;\n-      break;\n-    case LifecycleHooks.OnInit:\n-      nodeFlag = NodeFlags.OnInit;\n-      break;\n-  }\n-  return nodeFlag;\n-}\n-\n-export function componentFactoryResolverProviderDef(\n-    reflector: CompileReflector, ctx: OutputContext, flags: NodeFlags,\n-    entryComponents: CompileEntryComponentMetadata[]): {\n-  providerExpr: o.Expression,\n-  flags: NodeFlags,\n-  depsExpr: o.Expression,\n-  tokenExpr: o.Expression\n-} {\n-  const entryComponentFactories =\n-      entryComponents.map((entryComponent) => ctx.importExpr(entryComponent.componentFactory));\n-  const token = createTokenForExternalReference(reflector, Identifiers.ComponentFactoryResolver);\n-  const classMeta = {\n-    diDeps: [\n-      {isValue: true, value: o.literalArr(entryComponentFactories)},\n-      {token: token, isSkipSelf: true, isOptional: true},\n-      {token: createTokenForExternalReference(reflector, Identifiers.NgModuleRef)},\n-    ],\n-    lifecycleHooks: [],\n-    reference: reflector.resolveExternalReference(Identifiers.CodegenComponentFactoryResolver)\n-  };\n-  const {providerExpr, flags: providerFlags, depsExpr} =\n-      singleProviderDef(ctx, flags, ProviderAstType.PrivateService, {\n-        token,\n-        multi: false,\n-        useClass: classMeta,\n-      });\n-  return {providerExpr, flags: providerFlags, depsExpr, tokenExpr: tokenExpr(ctx, token)};\n-}"
        },
        {
            "sha": "216458afe2f0e57be10aa8a6fbb91609e6dea09c",
            "filename": "packages/compiler/src/view_compiler/type_check_compiler.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 372,
            "changes": 372,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fview_compiler%2Ftype_check_compiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fview_compiler%2Ftype_check_compiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fview_compiler%2Ftype_check_compiler.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,372 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {AotCompilerOptions} from '../aot/compiler_options';\n-import {StaticReflector} from '../aot/static_reflector';\n-import {StaticSymbol} from '../aot/static_symbol';\n-import {CompileDirectiveMetadata, CompilePipeSummary} from '../compile_metadata';\n-import {BindingForm, convertActionBinding, convertPropertyBinding, convertPropertyBindingBuiltins, EventHandlerVars, LocalResolver} from '../compiler_util/expression_converter';\n-import {OutputContext} from '../constant_pool';\n-import {AST, ASTWithSource, Interpolation} from '../expression_parser/ast';\n-import * as o from '../output/output_ast';\n-import {ParseSourceSpan} from '../parse_util';\n-import {AttrAst, BoundDirectivePropertyAst, BoundElementPropertyAst, BoundEventAst, BoundTextAst, DirectiveAst, ElementAst, EmbeddedTemplateAst, NgContentAst, ReferenceAst, TemplateAst, TemplateAstVisitor, templateVisitAll, TextAst, VariableAst} from '../template_parser/template_ast';\n-\n-\n-/**\n- * Generates code that is used to type check templates.\n- */\n-export class TypeCheckCompiler {\n-  constructor(private options: AotCompilerOptions, private reflector: StaticReflector) {}\n-\n-  /**\n-   * Important notes:\n-   * - This must not produce new `import` statements, but only refer to types outside\n-   *   of the file via the variables provided via externalReferenceVars.\n-   *   This allows Typescript to reuse the old program's structure as no imports have changed.\n-   * - This must not produce any exports, as this would pollute the .d.ts file\n-   *   and also violate the point above.\n-   */\n-  compileComponent(\n-      componentId: string, component: CompileDirectiveMetadata, template: TemplateAst[],\n-      usedPipes: CompilePipeSummary[], externalReferenceVars: Map<StaticSymbol, string>,\n-      ctx: OutputContext): o.Statement[] {\n-    const pipes = new Map<string, StaticSymbol>();\n-    usedPipes.forEach(p => pipes.set(p.name, p.type.reference));\n-    let embeddedViewCount = 0;\n-    const viewBuilderFactory =\n-        (parent: ViewBuilder|null, guards: GuardExpression[]): ViewBuilder => {\n-          const embeddedViewIndex = embeddedViewCount++;\n-          return new ViewBuilder(\n-              this.options, this.reflector, externalReferenceVars, parent, component.type.reference,\n-              component.isHost, embeddedViewIndex, pipes, guards, ctx, viewBuilderFactory);\n-        };\n-\n-    const visitor = viewBuilderFactory(null, []);\n-    visitor.visitAll([], template);\n-\n-    return visitor.build(componentId);\n-  }\n-}\n-\n-interface GuardExpression {\n-  guard: StaticSymbol;\n-  useIf: boolean;\n-  expression: Expression;\n-}\n-\n-interface ViewBuilderFactory {\n-  (parent: ViewBuilder, guards: GuardExpression[]): ViewBuilder;\n-}\n-\n-// Note: This is used as key in Map and should therefore be\n-// unique per value.\n-type OutputVarType = o.BuiltinTypeName|StaticSymbol;\n-\n-interface Expression {\n-  context: OutputVarType;\n-  sourceSpan: ParseSourceSpan;\n-  value: AST;\n-}\n-\n-const DYNAMIC_VAR_NAME = '_any';\n-\n-class TypeCheckLocalResolver implements LocalResolver {\n-  notifyImplicitReceiverUse(): void {}\n-  maybeRestoreView(): void {}\n-  getLocal(name: string): o.Expression|null {\n-    if (name === EventHandlerVars.event.name) {\n-      // References to the event should not be type-checked.\n-      // TODO(chuckj): determine a better type for the event.\n-      return o.variable(DYNAMIC_VAR_NAME);\n-    }\n-    return null;\n-  }\n-}\n-\n-const defaultResolver = new TypeCheckLocalResolver();\n-\n-class ViewBuilder implements TemplateAstVisitor, LocalResolver {\n-  private refOutputVars = new Map<string, OutputVarType>();\n-  private variables: VariableAst[] = [];\n-  private children: ViewBuilder[] = [];\n-  private updates: Expression[] = [];\n-  private actions: Expression[] = [];\n-\n-  constructor(\n-      private options: AotCompilerOptions, private reflector: StaticReflector,\n-      private externalReferenceVars: Map<StaticSymbol, string>, private parent: ViewBuilder|null,\n-      private component: StaticSymbol, private isHostComponent: boolean,\n-      private embeddedViewIndex: number, private pipes: Map<string, StaticSymbol>,\n-      private guards: GuardExpression[], private ctx: OutputContext,\n-      private viewBuilderFactory: ViewBuilderFactory) {}\n-\n-  private getOutputVar(type: o.BuiltinTypeName|StaticSymbol): string {\n-    let varName: string|undefined;\n-    if (type === this.component && this.isHostComponent) {\n-      varName = DYNAMIC_VAR_NAME;\n-    } else if (type instanceof StaticSymbol) {\n-      varName = this.externalReferenceVars.get(type);\n-    } else {\n-      varName = DYNAMIC_VAR_NAME;\n-    }\n-    if (!varName) {\n-      throw new Error(\n-          `Illegal State: referring to a type without a variable ${JSON.stringify(type)}`);\n-    }\n-    return varName;\n-  }\n-\n-  private getTypeGuardExpressions(ast: EmbeddedTemplateAst): GuardExpression[] {\n-    const result = [...this.guards];\n-    for (let directive of ast.directives) {\n-      for (let input of directive.inputs) {\n-        const guard = directive.directive.guards[input.directiveName];\n-        if (guard) {\n-          const useIf = guard === 'UseIf';\n-          result.push({\n-            guard,\n-            useIf,\n-            expression: {\n-              context: this.component,\n-              value: input.value,\n-              sourceSpan: input.sourceSpan,\n-            },\n-          });\n-        }\n-      }\n-    }\n-    return result;\n-  }\n-\n-  visitAll(variables: VariableAst[], astNodes: TemplateAst[]) {\n-    this.variables = variables;\n-    templateVisitAll(this, astNodes);\n-  }\n-\n-  build(componentId: string, targetStatements: o.Statement[] = []): o.Statement[] {\n-    this.children.forEach((child) => child.build(componentId, targetStatements));\n-    let viewStmts: o.Statement[] =\n-        [o.variable(DYNAMIC_VAR_NAME).set(o.NULL_EXPR).toDeclStmt(o.DYNAMIC_TYPE)];\n-    let bindingCount = 0;\n-    this.updates.forEach((expression) => {\n-      const {sourceSpan, context, value} = this.preprocessUpdateExpression(expression);\n-      const bindingId = `${bindingCount++}`;\n-      const nameResolver = context === this.component ? this : defaultResolver;\n-      const {stmts, currValExpr} = convertPropertyBinding(\n-          nameResolver, o.variable(this.getOutputVar(context)), value, bindingId,\n-          BindingForm.General);\n-      stmts.push(new o.ExpressionStatement(currValExpr));\n-      viewStmts.push(...stmts.map(\n-          (stmt: o.Statement) => o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\n-    });\n-\n-    this.actions.forEach(({sourceSpan, context, value}) => {\n-      const bindingId = `${bindingCount++}`;\n-      const nameResolver = context === this.component ? this : defaultResolver;\n-      const {stmts} = convertActionBinding(\n-          nameResolver, o.variable(this.getOutputVar(context)), value, bindingId);\n-      viewStmts.push(...stmts.map(\n-          (stmt: o.Statement) => o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\n-    });\n-\n-    if (this.guards.length) {\n-      let guardExpression: o.Expression|undefined = undefined;\n-      for (const guard of this.guards) {\n-        const {context, value} = this.preprocessUpdateExpression(guard.expression);\n-        const bindingId = `${bindingCount++}`;\n-        const nameResolver = context === this.component ? this : defaultResolver;\n-        // We only support support simple expressions and ignore others as they\n-        // are unlikely to affect type narrowing.\n-        const {stmts, currValExpr} = convertPropertyBinding(\n-            nameResolver, o.variable(this.getOutputVar(context)), value, bindingId,\n-            BindingForm.TrySimple);\n-        if (stmts.length == 0) {\n-          const guardClause =\n-              guard.useIf ? currValExpr : this.ctx.importExpr(guard.guard).callFn([currValExpr]);\n-          guardExpression = guardExpression ? guardExpression.and(guardClause) : guardClause;\n-        }\n-      }\n-      if (guardExpression) {\n-        viewStmts = [new o.IfStmt(guardExpression, viewStmts)];\n-      }\n-    }\n-\n-    const viewName = `_View_${componentId}_${this.embeddedViewIndex}`;\n-    const viewFactory = new o.DeclareFunctionStmt(viewName, [], viewStmts);\n-    targetStatements.push(viewFactory);\n-    return targetStatements;\n-  }\n-\n-  visitBoundText(ast: BoundTextAst, context: any): any {\n-    const astWithSource = <ASTWithSource>ast.value;\n-    const inter = <Interpolation>astWithSource.ast;\n-\n-    inter.expressions.forEach(\n-        (expr) =>\n-            this.updates.push({context: this.component, value: expr, sourceSpan: ast.sourceSpan}));\n-  }\n-\n-  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n-    this.visitElementOrTemplate(ast);\n-    // Note: The old view compiler used to use an `any` type\n-    // for the context in any embedded view.\n-    // We keep this behaivor behind a flag for now.\n-    if (this.options.fullTemplateTypeCheck) {\n-      // Find any applicable type guards. For example, NgIf has a type guard on ngIf\n-      // (see NgIf.ngIfTypeGuard) that can be used to indicate that a template is only\n-      // stamped out if ngIf is truthy so any bindings in the template can assume that,\n-      // if a nullable type is used for ngIf, that expression is not null or undefined.\n-      const guards = this.getTypeGuardExpressions(ast);\n-      const childVisitor = this.viewBuilderFactory(this, guards);\n-      this.children.push(childVisitor);\n-      childVisitor.visitAll(ast.variables, ast.children);\n-    }\n-  }\n-\n-  visitElement(ast: ElementAst, context: any): any {\n-    this.visitElementOrTemplate(ast);\n-\n-    let inputDefs: o.Expression[] = [];\n-    let updateRendererExpressions: Expression[] = [];\n-    let outputDefs: o.Expression[] = [];\n-    ast.inputs.forEach((inputAst) => {\n-      this.updates.push(\n-          {context: this.component, value: inputAst.value, sourceSpan: inputAst.sourceSpan});\n-    });\n-\n-    templateVisitAll(this, ast.children);\n-  }\n-\n-  private visitElementOrTemplate(ast: {\n-    outputs: BoundEventAst[],\n-    directives: DirectiveAst[],\n-    references: ReferenceAst[],\n-  }) {\n-    ast.directives.forEach((dirAst) => {\n-      this.visitDirective(dirAst);\n-    });\n-\n-    ast.references.forEach((ref) => {\n-      let outputVarType: OutputVarType = null!;\n-      // Note: The old view compiler used to use an `any` type\n-      // for directives exposed via `exportAs`.\n-      // We keep this behaivor behind a flag for now.\n-      if (ref.value && ref.value.identifier && this.options.fullTemplateTypeCheck) {\n-        outputVarType = ref.value.identifier.reference;\n-      } else {\n-        outputVarType = o.BuiltinTypeName.Dynamic;\n-      }\n-      this.refOutputVars.set(ref.name, outputVarType);\n-    });\n-    ast.outputs.forEach((outputAst) => {\n-      this.actions.push(\n-          {context: this.component, value: outputAst.handler, sourceSpan: outputAst.sourceSpan});\n-    });\n-  }\n-\n-  visitDirective(dirAst: DirectiveAst) {\n-    const dirType = dirAst.directive.type.reference;\n-    dirAst.inputs.forEach(\n-        (input) => this.updates.push(\n-            {context: this.component, value: input.value, sourceSpan: input.sourceSpan}));\n-    // Note: The old view compiler used to use an `any` type\n-    // for expressions in host properties / events.\n-    // We keep this behaivor behind a flag for now.\n-    if (this.options.fullTemplateTypeCheck) {\n-      dirAst.hostProperties.forEach(\n-          (inputAst) => this.updates.push(\n-              {context: dirType, value: inputAst.value, sourceSpan: inputAst.sourceSpan}));\n-      dirAst.hostEvents.forEach((hostEventAst) => this.actions.push({\n-        context: dirType,\n-        value: hostEventAst.handler,\n-        sourceSpan: hostEventAst.sourceSpan\n-      }));\n-    }\n-  }\n-\n-  notifyImplicitReceiverUse(): void {}\n-  maybeRestoreView(): void {}\n-\n-  getLocal(name: string): o.Expression|null {\n-    if (name == EventHandlerVars.event.name) {\n-      return o.variable(this.getOutputVar(o.BuiltinTypeName.Dynamic));\n-    }\n-    for (let currBuilder: ViewBuilder|null = this; currBuilder; currBuilder = currBuilder.parent) {\n-      let outputVarType: OutputVarType|undefined;\n-      // check references\n-      outputVarType = currBuilder.refOutputVars.get(name);\n-      if (outputVarType == null) {\n-        // check variables\n-        const varAst = currBuilder.variables.find((varAst) => varAst.name === name);\n-        if (varAst) {\n-          outputVarType = o.BuiltinTypeName.Dynamic;\n-        }\n-      }\n-      if (outputVarType != null) {\n-        return o.variable(this.getOutputVar(outputVarType));\n-      }\n-    }\n-    return null;\n-  }\n-\n-  private pipeOutputVar(name: string): string {\n-    const pipe = this.pipes.get(name);\n-    if (!pipe) {\n-      throw new Error(\n-          `Illegal State: Could not find pipe ${name} in template of ${this.component}`);\n-    }\n-    return this.getOutputVar(pipe);\n-  }\n-\n-  private preprocessUpdateExpression(expression: Expression): Expression {\n-    return {\n-      sourceSpan: expression.sourceSpan,\n-      context: expression.context,\n-      value: convertPropertyBindingBuiltins(\n-          {\n-            createLiteralArrayConverter: (argCount: number) => (args: o.Expression[]) => {\n-              const arr = o.literalArr(args);\n-              // Note: The old view compiler used to use an `any` type\n-              // for arrays.\n-              return this.options.fullTemplateTypeCheck ? arr : arr.cast(o.DYNAMIC_TYPE);\n-            },\n-            createLiteralMapConverter: (keys: {key: string, quoted: boolean}[]) =>\n-                (values: o.Expression[]) => {\n-                  const entries = keys.map((k, i) => ({\n-                                             key: k.key,\n-                                             value: values[i],\n-                                             quoted: k.quoted,\n-                                           }));\n-                  const map = o.literalMap(entries);\n-                  // Note: The old view compiler used to use an `any` type\n-                  // for maps.\n-                  return this.options.fullTemplateTypeCheck ? map : map.cast(o.DYNAMIC_TYPE);\n-                },\n-            createPipeConverter: (name: string, argCount: number) => (args: o.Expression[]) => {\n-              // Note: The old view compiler used to use an `any` type\n-              // for pipes.\n-              const pipeExpr = this.options.fullTemplateTypeCheck ?\n-                  o.variable(this.pipeOutputVar(name)) :\n-                  o.variable(this.getOutputVar(o.BuiltinTypeName.Dynamic));\n-              return pipeExpr.prop('transform').callFn(args);\n-            },\n-          },\n-          expression.value)\n-    };\n-  }\n-\n-  visitNgContent(ast: NgContentAst, context: any): any {}\n-  visitText(ast: TextAst, context: any): any {}\n-  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any {}\n-  visitReference(ast: ReferenceAst, context: any): any {}\n-  visitVariable(ast: VariableAst, context: any): any {}\n-  visitEvent(ast: BoundEventAst, context: any): any {}\n-  visitElementProperty(ast: BoundElementPropertyAst, context: any): any {}\n-  visitAttr(ast: AttrAst, context: any): any {}\n-}"
        },
        {
            "sha": "5fd77a8caaeb1a7d7ac5fa0134bff4105b92a581",
            "filename": "packages/compiler/src/view_compiler/view_compiler.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 1042,
            "changes": 1042,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fview_compiler%2Fview_compiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Fsrc%2Fview_compiler%2Fview_compiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fview_compiler%2Fview_compiler.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,1042 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {CompileDirectiveMetadata, CompilePipeSummary, CompileQueryMetadata, rendererTypeName, tokenReference, viewClassName} from '../compile_metadata';\n-import {CompileReflector} from '../compile_reflector';\n-import {BindingForm, BuiltinConverter, convertActionBinding, convertPropertyBinding, convertPropertyBindingBuiltins, EventHandlerVars, LocalResolver} from '../compiler_util/expression_converter';\n-import {OutputContext} from '../constant_pool';\n-import {ArgumentType, BindingFlags, ChangeDetectionStrategy, NodeFlags, QueryBindingType, QueryValueType, ViewFlags} from '../core';\n-import {AST, ASTWithSource, Interpolation} from '../expression_parser/ast';\n-import {Identifiers} from '../identifiers';\n-import {LifecycleHooks} from '../lifecycle_reflector';\n-import {isNgContainer} from '../ml_parser/tags';\n-import * as o from '../output/output_ast';\n-import {convertValueToOutputAst} from '../output/value_util';\n-import {ParseSourceSpan} from '../parse_util';\n-import {AttrAst, BoundDirectivePropertyAst, BoundElementPropertyAst, BoundEventAst, BoundTextAst, DirectiveAst, ElementAst, EmbeddedTemplateAst, NgContentAst, PropertyBindingType, ProviderAst, QueryMatch, ReferenceAst, TemplateAst, TemplateAstVisitor, templateVisitAll, TextAst, VariableAst} from '../template_parser/template_ast';\n-\n-import {componentFactoryResolverProviderDef, depDef, lifecycleHookToNodeFlag, providerDef} from './provider_compiler';\n-\n-const CLASS_ATTR = 'class';\n-const STYLE_ATTR = 'style';\n-const IMPLICIT_TEMPLATE_VAR = '$implicit';\n-\n-export class ViewCompileResult {\n-  constructor(public viewClassVar: string, public rendererTypeVar: string) {}\n-}\n-\n-export class ViewCompiler {\n-  constructor(private _reflector: CompileReflector) {}\n-\n-  compileComponent(\n-      outputCtx: OutputContext, component: CompileDirectiveMetadata, template: TemplateAst[],\n-      styles: o.Expression, usedPipes: CompilePipeSummary[]): ViewCompileResult {\n-    let embeddedViewCount = 0;\n-\n-    let renderComponentVarName: string = undefined!;\n-    if (!component.isHost) {\n-      const template = component.template !;\n-      const customRenderData: o.LiteralMapEntry[] = [];\n-      if (template.animations && template.animations.length) {\n-        customRenderData.push(new o.LiteralMapEntry(\n-            'animation', convertValueToOutputAst(outputCtx, template.animations), true));\n-      }\n-\n-      const renderComponentVar = o.variable(rendererTypeName(component.type.reference));\n-      renderComponentVarName = renderComponentVar.name!;\n-      outputCtx.statements.push(\n-          renderComponentVar\n-              .set(o.importExpr(Identifiers.createRendererType2).callFn([new o.LiteralMapExpr([\n-                new o.LiteralMapEntry('encapsulation', o.literal(template.encapsulation), false),\n-                new o.LiteralMapEntry('styles', styles, false),\n-                new o.LiteralMapEntry('data', new o.LiteralMapExpr(customRenderData), false)\n-              ])]))\n-              .toDeclStmt(\n-                  o.importType(Identifiers.RendererType2),\n-                  [o.StmtModifier.Final, o.StmtModifier.Exported]));\n-    }\n-\n-    const viewBuilderFactory = (parent: ViewBuilder|null): ViewBuilder => {\n-      const embeddedViewIndex = embeddedViewCount++;\n-      return new ViewBuilder(\n-          this._reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes,\n-          viewBuilderFactory);\n-    };\n-\n-    const visitor = viewBuilderFactory(null);\n-    visitor.visitAll([], template);\n-\n-    outputCtx.statements.push(...visitor.build());\n-\n-    return new ViewCompileResult(visitor.viewName, renderComponentVarName);\n-  }\n-}\n-\n-interface ViewBuilderFactory {\n-  (parent: ViewBuilder): ViewBuilder;\n-}\n-\n-interface UpdateExpression {\n-  context: o.Expression;\n-  nodeIndex: number;\n-  bindingIndex: number;\n-  sourceSpan: ParseSourceSpan;\n-  value: AST;\n-}\n-\n-const LOG_VAR = o.variable('_l');\n-const VIEW_VAR = o.variable('_v');\n-const CHECK_VAR = o.variable('_ck');\n-const COMP_VAR = o.variable('_co');\n-const EVENT_NAME_VAR = o.variable('en');\n-const ALLOW_DEFAULT_VAR = o.variable(`ad`);\n-\n-class ViewBuilder implements TemplateAstVisitor, LocalResolver {\n-  private compType: o.Type;\n-  private nodes: (() => {\n-    sourceSpan: ParseSourceSpan | null,\n-    nodeDef: o.Expression,\n-    nodeFlags: NodeFlags,\n-    updateDirectives?: UpdateExpression[],\n-    updateRenderer?: UpdateExpression[]\n-  })[] = [];\n-  private purePipeNodeIndices: {[pipeName: string]: number} = Object.create(null);\n-  // Need Object.create so that we don't have builtin values...\n-  private refNodeIndices: {[refName: string]: number} = Object.create(null);\n-  private variables: VariableAst[] = [];\n-  private children: ViewBuilder[] = [];\n-\n-  public readonly viewName: string;\n-\n-  constructor(\n-      private reflector: CompileReflector, private outputCtx: OutputContext,\n-      private parent: ViewBuilder|null, private component: CompileDirectiveMetadata,\n-      private embeddedViewIndex: number, private usedPipes: CompilePipeSummary[],\n-      private viewBuilderFactory: ViewBuilderFactory) {\n-    // TODO(tbosch): The old view compiler used to use an `any` type\n-    // for the context in any embedded view. We keep this behaivor for now\n-    // to be able to introduce the new view compiler without too many errors.\n-    this.compType = this.embeddedViewIndex > 0 ?\n-        o.DYNAMIC_TYPE :\n-        o.expressionType(outputCtx.importExpr(this.component.type.reference))!;\n-    this.viewName = viewClassName(this.component.type.reference, this.embeddedViewIndex);\n-  }\n-\n-  visitAll(variables: VariableAst[], astNodes: TemplateAst[]) {\n-    this.variables = variables;\n-    // create the pipes for the pure pipes immediately, so that we know their indices.\n-    if (!this.parent) {\n-      this.usedPipes.forEach((pipe) => {\n-        if (pipe.pure) {\n-          this.purePipeNodeIndices[pipe.name] = this._createPipe(null, pipe);\n-        }\n-      });\n-    }\n-\n-    if (!this.parent) {\n-      this.component.viewQueries.forEach((query, queryIndex) => {\n-        // Note: queries start with id 1 so we can use the number in a Bloom filter!\n-        const queryId = queryIndex + 1;\n-        const bindingType = query.first ? QueryBindingType.First : QueryBindingType.All;\n-        const flags = NodeFlags.TypeViewQuery | calcQueryFlags(query);\n-        this.nodes.push(() => ({\n-                          sourceSpan: null,\n-                          nodeFlags: flags,\n-                          nodeDef: o.importExpr(Identifiers.queryDef).callFn([\n-                            o.literal(flags), o.literal(queryId),\n-                            new o.LiteralMapExpr([new o.LiteralMapEntry(\n-                                query.propertyName, o.literal(bindingType), false)])\n-                          ])\n-                        }));\n-      });\n-    }\n-    templateVisitAll(this, astNodes);\n-    if (this.parent && (astNodes.length === 0 || needsAdditionalRootNode(astNodes))) {\n-      // if the view is an embedded view, then we need to add an additional root node in some cases\n-      this.nodes.push(() => ({\n-                        sourceSpan: null,\n-                        nodeFlags: NodeFlags.TypeElement,\n-                        nodeDef: o.importExpr(Identifiers.anchorDef).callFn([\n-                          o.literal(NodeFlags.None), o.NULL_EXPR, o.NULL_EXPR, o.literal(0)\n-                        ])\n-                      }));\n-    }\n-  }\n-\n-  build(targetStatements: o.Statement[] = []): o.Statement[] {\n-    this.children.forEach((child) => child.build(targetStatements));\n-\n-    const {updateRendererStmts, updateDirectivesStmts, nodeDefExprs} =\n-        this._createNodeExpressions();\n-\n-    const updateRendererFn = this._createUpdateFn(updateRendererStmts);\n-    const updateDirectivesFn = this._createUpdateFn(updateDirectivesStmts);\n-\n-\n-    let viewFlags = ViewFlags.None;\n-    if (!this.parent && this.component.changeDetection === ChangeDetectionStrategy.OnPush) {\n-      viewFlags |= ViewFlags.OnPush;\n-    }\n-    const viewFactory = new o.DeclareFunctionStmt(\n-        this.viewName, [new o.FnParam(LOG_VAR.name!)],\n-        [new o.ReturnStatement(o.importExpr(Identifiers.viewDef).callFn([\n-          o.literal(viewFlags),\n-          o.literalArr(nodeDefExprs),\n-          updateDirectivesFn,\n-          updateRendererFn,\n-        ]))],\n-        o.importType(Identifiers.ViewDefinition),\n-        this.embeddedViewIndex === 0 ? [o.StmtModifier.Exported] : []);\n-\n-    targetStatements.push(viewFactory);\n-    return targetStatements;\n-  }\n-\n-  private _createUpdateFn(updateStmts: o.Statement[]): o.Expression {\n-    let updateFn: o.Expression;\n-    if (updateStmts.length > 0) {\n-      const preStmts: o.Statement[] = [];\n-      if (!this.component.isHost && o.findReadVarNames(updateStmts).has(COMP_VAR.name!)) {\n-        preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n-      }\n-      updateFn = o.fn(\n-          [\n-            new o.FnParam(CHECK_VAR.name!, o.INFERRED_TYPE),\n-            new o.FnParam(VIEW_VAR.name!, o.INFERRED_TYPE)\n-          ],\n-          [...preStmts, ...updateStmts], o.INFERRED_TYPE);\n-    } else {\n-      updateFn = o.NULL_EXPR;\n-    }\n-    return updateFn;\n-  }\n-\n-  visitNgContent(ast: NgContentAst, context: any): any {\n-    // ngContentDef(ngContentIndex: number, index: number): NodeDef;\n-    this.nodes.push(() => ({\n-                      sourceSpan: ast.sourceSpan,\n-                      nodeFlags: NodeFlags.TypeNgContent,\n-                      nodeDef: o.importExpr(Identifiers.ngContentDef)\n-                                   .callFn([o.literal(ast.ngContentIndex), o.literal(ast.index)])\n-                    }));\n-  }\n-\n-  visitText(ast: TextAst, context: any): any {\n-    // Static text nodes have no check function\n-    const checkIndex = -1;\n-    this.nodes.push(() => ({\n-                      sourceSpan: ast.sourceSpan,\n-                      nodeFlags: NodeFlags.TypeText,\n-                      nodeDef: o.importExpr(Identifiers.textDef).callFn([\n-                        o.literal(checkIndex),\n-                        o.literal(ast.ngContentIndex),\n-                        o.literalArr([o.literal(ast.value)]),\n-                      ])\n-                    }));\n-  }\n-\n-  visitBoundText(ast: BoundTextAst, context: any): any {\n-    const nodeIndex = this.nodes.length;\n-    // reserve the space in the nodeDefs array\n-    this.nodes.push(null!);\n-\n-    const astWithSource = <ASTWithSource>ast.value;\n-    const inter = <Interpolation>astWithSource.ast;\n-\n-    const updateRendererExpressions = inter.expressions.map(\n-        (expr, bindingIndex) => this._preprocessUpdateExpression(\n-            {nodeIndex, bindingIndex, sourceSpan: ast.sourceSpan, context: COMP_VAR, value: expr}));\n-\n-    // Check index is the same as the node index during compilation\n-    // They might only differ at runtime\n-    const checkIndex = nodeIndex;\n-\n-    this.nodes[nodeIndex] = () => ({\n-      sourceSpan: ast.sourceSpan,\n-      nodeFlags: NodeFlags.TypeText,\n-      nodeDef: o.importExpr(Identifiers.textDef).callFn([\n-        o.literal(checkIndex),\n-        o.literal(ast.ngContentIndex),\n-        o.literalArr(inter.strings.map(s => o.literal(s))),\n-      ]),\n-      updateRenderer: updateRendererExpressions\n-    });\n-  }\n-\n-  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n-    const nodeIndex = this.nodes.length;\n-    // reserve the space in the nodeDefs array\n-    this.nodes.push(null!);\n-\n-    const {flags, queryMatchesExpr, hostEvents} = this._visitElementOrTemplate(nodeIndex, ast);\n-\n-    const childVisitor = this.viewBuilderFactory(this);\n-    this.children.push(childVisitor);\n-    childVisitor.visitAll(ast.variables, ast.children);\n-\n-    const childCount = this.nodes.length - nodeIndex - 1;\n-\n-    // anchorDef(\n-    //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], ngContentIndex: number,\n-    //   childCount: number, handleEventFn?: ElementHandleEventFn, templateFactory?:\n-    //   ViewDefinitionFactory): NodeDef;\n-    this.nodes[nodeIndex] = () => ({\n-      sourceSpan: ast.sourceSpan,\n-      nodeFlags: NodeFlags.TypeElement | flags,\n-      nodeDef: o.importExpr(Identifiers.anchorDef).callFn([\n-        o.literal(flags),\n-        queryMatchesExpr,\n-        o.literal(ast.ngContentIndex),\n-        o.literal(childCount),\n-        this._createElementHandleEventFn(nodeIndex, hostEvents),\n-        o.variable(childVisitor.viewName),\n-      ])\n-    });\n-  }\n-\n-  visitElement(ast: ElementAst, context: any): any {\n-    const nodeIndex = this.nodes.length;\n-    // reserve the space in the nodeDefs array so we can add children\n-    this.nodes.push(null!);\n-\n-    // Using a null element name creates an anchor.\n-    const elName: string|null = isNgContainer(ast.name) ? null : ast.name;\n-\n-    const {flags, usedEvents, queryMatchesExpr, hostBindings: dirHostBindings, hostEvents} =\n-        this._visitElementOrTemplate(nodeIndex, ast);\n-\n-    let inputDefs: o.Expression[] = [];\n-    let updateRendererExpressions: UpdateExpression[] = [];\n-    let outputDefs: o.Expression[] = [];\n-    if (elName) {\n-      const hostBindings: any[] = ast.inputs\n-                                      .map((inputAst) => ({\n-                                             context: COMP_VAR as o.Expression,\n-                                             inputAst,\n-                                             dirAst: null as any,\n-                                           }))\n-                                      .concat(dirHostBindings);\n-      if (hostBindings.length) {\n-        updateRendererExpressions =\n-            hostBindings.map((hostBinding, bindingIndex) => this._preprocessUpdateExpression({\n-              context: hostBinding.context,\n-              nodeIndex,\n-              bindingIndex,\n-              sourceSpan: hostBinding.inputAst.sourceSpan,\n-              value: hostBinding.inputAst.value\n-            }));\n-        inputDefs = hostBindings.map(\n-            hostBinding => elementBindingDef(hostBinding.inputAst, hostBinding.dirAst));\n-      }\n-      outputDefs = usedEvents.map(\n-          ([target, eventName]) => o.literalArr([o.literal(target), o.literal(eventName)]));\n-    }\n-\n-    templateVisitAll(this, ast.children);\n-\n-    const childCount = this.nodes.length - nodeIndex - 1;\n-\n-    const compAst = ast.directives.find(dirAst => dirAst.directive.isComponent);\n-    let compRendererType = o.NULL_EXPR as o.Expression;\n-    let compView = o.NULL_EXPR as o.Expression;\n-    if (compAst) {\n-      compView = this.outputCtx.importExpr(compAst.directive.componentViewType);\n-      compRendererType = this.outputCtx.importExpr(compAst.directive.rendererType);\n-    }\n-\n-    // Check index is the same as the node index during compilation\n-    // They might only differ at runtime\n-    const checkIndex = nodeIndex;\n-\n-    this.nodes[nodeIndex] = () => ({\n-      sourceSpan: ast.sourceSpan,\n-      nodeFlags: NodeFlags.TypeElement | flags,\n-      nodeDef: o.importExpr(Identifiers.elementDef).callFn([\n-        o.literal(checkIndex),\n-        o.literal(flags),\n-        queryMatchesExpr,\n-        o.literal(ast.ngContentIndex),\n-        o.literal(childCount),\n-        o.literal(elName),\n-        elName ? fixedAttrsDef(ast) : o.NULL_EXPR,\n-        inputDefs.length ? o.literalArr(inputDefs) : o.NULL_EXPR,\n-        outputDefs.length ? o.literalArr(outputDefs) : o.NULL_EXPR,\n-        this._createElementHandleEventFn(nodeIndex, hostEvents),\n-        compView,\n-        compRendererType,\n-      ]),\n-      updateRenderer: updateRendererExpressions\n-    });\n-  }\n-\n-  private _visitElementOrTemplate(nodeIndex: number, ast: {\n-    hasViewContainer: boolean,\n-    outputs: BoundEventAst[],\n-    directives: DirectiveAst[],\n-    providers: ProviderAst[],\n-    references: ReferenceAst[],\n-    queryMatches: QueryMatch[]\n-  }): {\n-    flags: NodeFlags,\n-    usedEvents: [string|null, string][],\n-    queryMatchesExpr: o.Expression,\n-    hostBindings:\n-        {context: o.Expression, inputAst: BoundElementPropertyAst, dirAst: DirectiveAst}[],\n-    hostEvents: {context: o.Expression, eventAst: BoundEventAst, dirAst: DirectiveAst}[],\n-  } {\n-    let flags = NodeFlags.None;\n-    if (ast.hasViewContainer) {\n-      flags |= NodeFlags.EmbeddedViews;\n-    }\n-    const usedEvents = new Map<string, [string | null, string]>();\n-    ast.outputs.forEach((event) => {\n-      const {name, target} = elementEventNameAndTarget(event, null);\n-      usedEvents.set(elementEventFullName(target, name), [target, name]);\n-    });\n-    ast.directives.forEach((dirAst) => {\n-      dirAst.hostEvents.forEach((event) => {\n-        const {name, target} = elementEventNameAndTarget(event, dirAst);\n-        usedEvents.set(elementEventFullName(target, name), [target, name]);\n-      });\n-    });\n-    const hostBindings:\n-        {context: o.Expression, inputAst: BoundElementPropertyAst, dirAst: DirectiveAst}[] = [];\n-    const hostEvents: {context: o.Expression, eventAst: BoundEventAst, dirAst: DirectiveAst}[] = [];\n-    this._visitComponentFactoryResolverProvider(ast.directives);\n-\n-    ast.providers.forEach(providerAst => {\n-      let dirAst: DirectiveAst = undefined!;\n-      ast.directives.forEach(localDirAst => {\n-        if (localDirAst.directive.type.reference === tokenReference(providerAst.token)) {\n-          dirAst = localDirAst;\n-        }\n-      });\n-      if (dirAst) {\n-        const {hostBindings: dirHostBindings, hostEvents: dirHostEvents} =\n-            this._visitDirective(providerAst, dirAst, ast.references, ast.queryMatches, usedEvents);\n-        hostBindings.push(...dirHostBindings);\n-        hostEvents.push(...dirHostEvents);\n-      } else {\n-        this._visitProvider(providerAst, ast.queryMatches);\n-      }\n-    });\n-\n-    let queryMatchExprs: o.Expression[] = [];\n-    ast.queryMatches.forEach((match) => {\n-      let valueType: QueryValueType = undefined!;\n-      if (tokenReference(match.value) ===\n-          this.reflector.resolveExternalReference(Identifiers.ElementRef)) {\n-        valueType = QueryValueType.ElementRef;\n-      } else if (\n-          tokenReference(match.value) ===\n-          this.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {\n-        valueType = QueryValueType.ViewContainerRef;\n-      } else if (\n-          tokenReference(match.value) ===\n-          this.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n-        valueType = QueryValueType.TemplateRef;\n-      }\n-      if (valueType != null) {\n-        queryMatchExprs.push(o.literalArr([o.literal(match.queryId), o.literal(valueType)]));\n-      }\n-    });\n-    ast.references.forEach((ref) => {\n-      let valueType: QueryValueType = undefined!;\n-      if (!ref.value) {\n-        valueType = QueryValueType.RenderElement;\n-      } else if (\n-          tokenReference(ref.value) ===\n-          this.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n-        valueType = QueryValueType.TemplateRef;\n-      }\n-      if (valueType != null) {\n-        this.refNodeIndices[ref.name] = nodeIndex;\n-        queryMatchExprs.push(o.literalArr([o.literal(ref.name), o.literal(valueType)]));\n-      }\n-    });\n-    ast.outputs.forEach((outputAst) => {\n-      hostEvents.push({context: COMP_VAR, eventAst: outputAst, dirAst: null!});\n-    });\n-\n-    return {\n-      flags,\n-      usedEvents: Array.from(usedEvents.values()),\n-      queryMatchesExpr: queryMatchExprs.length ? o.literalArr(queryMatchExprs) : o.NULL_EXPR,\n-      hostBindings,\n-      hostEvents: hostEvents\n-    };\n-  }\n-\n-  private _visitDirective(\n-      providerAst: ProviderAst, dirAst: DirectiveAst, refs: ReferenceAst[],\n-      queryMatches: QueryMatch[], usedEvents: Map<string, any>): {\n-    hostBindings:\n-        {context: o.Expression, inputAst: BoundElementPropertyAst, dirAst: DirectiveAst}[],\n-    hostEvents: {context: o.Expression, eventAst: BoundEventAst, dirAst: DirectiveAst}[]\n-  } {\n-    const nodeIndex = this.nodes.length;\n-    // reserve the space in the nodeDefs array so we can add children\n-    this.nodes.push(null!);\n-\n-    dirAst.directive.queries.forEach((query, queryIndex) => {\n-      const queryId = dirAst.contentQueryStartId + queryIndex;\n-      const flags = NodeFlags.TypeContentQuery | calcQueryFlags(query);\n-      const bindingType = query.first ? QueryBindingType.First : QueryBindingType.All;\n-      this.nodes.push(() => ({\n-                        sourceSpan: dirAst.sourceSpan,\n-                        nodeFlags: flags,\n-                        nodeDef: o.importExpr(Identifiers.queryDef).callFn([\n-                          o.literal(flags), o.literal(queryId),\n-                          new o.LiteralMapExpr([new o.LiteralMapEntry(\n-                              query.propertyName, o.literal(bindingType), false)])\n-                        ]),\n-                      }));\n-    });\n-\n-    // Note: the operation below might also create new nodeDefs,\n-    // but we don't want them to be a child of a directive,\n-    // as they might be a provider/pipe on their own.\n-    // I.e. we only allow queries as children of directives nodes.\n-    const childCount = this.nodes.length - nodeIndex - 1;\n-\n-    let {flags, queryMatchExprs, providerExpr, depsExpr} =\n-        this._visitProviderOrDirective(providerAst, queryMatches);\n-\n-    refs.forEach((ref) => {\n-      if (ref.value && tokenReference(ref.value) === tokenReference(providerAst.token)) {\n-        this.refNodeIndices[ref.name] = nodeIndex;\n-        queryMatchExprs.push(\n-            o.literalArr([o.literal(ref.name), o.literal(QueryValueType.Provider)]));\n-      }\n-    });\n-\n-    if (dirAst.directive.isComponent) {\n-      flags |= NodeFlags.Component;\n-    }\n-\n-    const inputDefs = dirAst.inputs.map((inputAst, inputIndex) => {\n-      const mapValue = o.literalArr([o.literal(inputIndex), o.literal(inputAst.directiveName)]);\n-      // Note: it's important to not quote the key so that we can capture renames by minifiers!\n-      return new o.LiteralMapEntry(inputAst.directiveName, mapValue, false);\n-    });\n-\n-    const outputDefs: o.LiteralMapEntry[] = [];\n-    const dirMeta = dirAst.directive;\n-    Object.keys(dirMeta.outputs).forEach((propName) => {\n-      const eventName = dirMeta.outputs[propName];\n-      if (usedEvents.has(eventName)) {\n-        // Note: it's important to not quote the key so that we can capture renames by minifiers!\n-        outputDefs.push(new o.LiteralMapEntry(propName, o.literal(eventName), false));\n-      }\n-    });\n-    let updateDirectiveExpressions: UpdateExpression[] = [];\n-    if (dirAst.inputs.length || (flags & (NodeFlags.DoCheck | NodeFlags.OnInit)) > 0) {\n-      updateDirectiveExpressions =\n-          dirAst.inputs.map((input, bindingIndex) => this._preprocessUpdateExpression({\n-            nodeIndex,\n-            bindingIndex,\n-            sourceSpan: input.sourceSpan,\n-            context: COMP_VAR,\n-            value: input.value\n-          }));\n-    }\n-\n-    const dirContextExpr =\n-        o.importExpr(Identifiers.nodeValue).callFn([VIEW_VAR, o.literal(nodeIndex)]);\n-    const hostBindings = dirAst.hostProperties.map((inputAst) => ({\n-                                                     context: dirContextExpr,\n-                                                     dirAst,\n-                                                     inputAst,\n-                                                   }));\n-    const hostEvents = dirAst.hostEvents.map((hostEventAst) => ({\n-                                               context: dirContextExpr,\n-                                               eventAst: hostEventAst,\n-                                               dirAst,\n-                                             }));\n-\n-    // Check index is the same as the node index during compilation\n-    // They might only differ at runtime\n-    const checkIndex = nodeIndex;\n-\n-    this.nodes[nodeIndex] = () => ({\n-      sourceSpan: dirAst.sourceSpan,\n-      nodeFlags: NodeFlags.TypeDirective | flags,\n-      nodeDef: o.importExpr(Identifiers.directiveDef).callFn([\n-        o.literal(checkIndex),\n-        o.literal(flags),\n-        queryMatchExprs.length ? o.literalArr(queryMatchExprs) : o.NULL_EXPR,\n-        o.literal(childCount),\n-        providerExpr,\n-        depsExpr,\n-        inputDefs.length ? new o.LiteralMapExpr(inputDefs) : o.NULL_EXPR,\n-        outputDefs.length ? new o.LiteralMapExpr(outputDefs) : o.NULL_EXPR,\n-      ]),\n-      updateDirectives: updateDirectiveExpressions,\n-      directive: dirAst.directive.type,\n-    });\n-\n-    return {hostBindings, hostEvents};\n-  }\n-\n-  private _visitProvider(providerAst: ProviderAst, queryMatches: QueryMatch[]): void {\n-    this._addProviderNode(this._visitProviderOrDirective(providerAst, queryMatches));\n-  }\n-\n-  private _visitComponentFactoryResolverProvider(directives: DirectiveAst[]) {\n-    const componentDirMeta = directives.find(dirAst => dirAst.directive.isComponent);\n-    if (componentDirMeta && componentDirMeta.directive.entryComponents.length) {\n-      const {providerExpr, depsExpr, flags, tokenExpr} = componentFactoryResolverProviderDef(\n-          this.reflector, this.outputCtx, NodeFlags.PrivateProvider,\n-          componentDirMeta.directive.entryComponents);\n-      this._addProviderNode({\n-        providerExpr,\n-        depsExpr,\n-        flags,\n-        tokenExpr,\n-        queryMatchExprs: [],\n-        sourceSpan: componentDirMeta.sourceSpan\n-      });\n-    }\n-  }\n-\n-  private _addProviderNode(data: {\n-    flags: NodeFlags,\n-    queryMatchExprs: o.Expression[],\n-    providerExpr: o.Expression,\n-    depsExpr: o.Expression,\n-    tokenExpr: o.Expression,\n-    sourceSpan: ParseSourceSpan\n-  }) {\n-    // providerDef(\n-    //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], token:any,\n-    //   value: any, deps: ([DepFlags, any] | any)[]): NodeDef;\n-    this.nodes.push(\n-        () => ({\n-          sourceSpan: data.sourceSpan,\n-          nodeFlags: data.flags,\n-          nodeDef: o.importExpr(Identifiers.providerDef).callFn([\n-            o.literal(data.flags),\n-            data.queryMatchExprs.length ? o.literalArr(data.queryMatchExprs) : o.NULL_EXPR,\n-            data.tokenExpr, data.providerExpr, data.depsExpr\n-          ])\n-        }));\n-  }\n-\n-  private _visitProviderOrDirective(providerAst: ProviderAst, queryMatches: QueryMatch[]): {\n-    flags: NodeFlags,\n-    tokenExpr: o.Expression,\n-    sourceSpan: ParseSourceSpan,\n-    queryMatchExprs: o.Expression[],\n-    providerExpr: o.Expression,\n-    depsExpr: o.Expression\n-  } {\n-    let flags = NodeFlags.None;\n-    let queryMatchExprs: o.Expression[] = [];\n-\n-    queryMatches.forEach((match) => {\n-      if (tokenReference(match.value) === tokenReference(providerAst.token)) {\n-        queryMatchExprs.push(\n-            o.literalArr([o.literal(match.queryId), o.literal(QueryValueType.Provider)]));\n-      }\n-    });\n-    const {providerExpr, depsExpr, flags: providerFlags, tokenExpr} =\n-        providerDef(this.outputCtx, providerAst);\n-    return {\n-      flags: flags | providerFlags,\n-      queryMatchExprs,\n-      providerExpr,\n-      depsExpr,\n-      tokenExpr,\n-      sourceSpan: providerAst.sourceSpan\n-    };\n-  }\n-\n-  getLocal(name: string): o.Expression|null {\n-    if (name == EventHandlerVars.event.name) {\n-      return EventHandlerVars.event;\n-    }\n-    let currViewExpr: o.Expression = VIEW_VAR;\n-    for (let currBuilder: ViewBuilder|null = this; currBuilder; currBuilder = currBuilder.parent,\n-                          currViewExpr = currViewExpr.prop('parent').cast(o.DYNAMIC_TYPE)) {\n-      // check references\n-      const refNodeIndex = currBuilder.refNodeIndices[name];\n-      if (refNodeIndex != null) {\n-        return o.importExpr(Identifiers.nodeValue).callFn([currViewExpr, o.literal(refNodeIndex)]);\n-      }\n-\n-      // check variables\n-      const varAst = currBuilder.variables.find((varAst) => varAst.name === name);\n-      if (varAst) {\n-        const varValue = varAst.value || IMPLICIT_TEMPLATE_VAR;\n-        return currViewExpr.prop('context').prop(varValue);\n-      }\n-    }\n-    return null;\n-  }\n-\n-  notifyImplicitReceiverUse(): void {\n-    // Not needed in ViewEngine as ViewEngine walks through the generated\n-    // expressions to figure out if the implicit receiver is used and needs\n-    // to be generated as part of the pre-update statements.\n-  }\n-\n-  maybeRestoreView(): void {\n-    // Not necessary in ViewEngine, because view restoration is an Ivy concept.\n-  }\n-\n-  private _createLiteralArrayConverter(sourceSpan: ParseSourceSpan, argCount: number):\n-      BuiltinConverter {\n-    if (argCount === 0) {\n-      const valueExpr = o.importExpr(Identifiers.EMPTY_ARRAY);\n-      return () => valueExpr;\n-    }\n-\n-    const checkIndex = this.nodes.length;\n-\n-    this.nodes.push(() => ({\n-                      sourceSpan,\n-                      nodeFlags: NodeFlags.TypePureArray,\n-                      nodeDef: o.importExpr(Identifiers.pureArrayDef).callFn([\n-                        o.literal(checkIndex),\n-                        o.literal(argCount),\n-                      ])\n-                    }));\n-\n-    return (args: o.Expression[]) => callCheckStmt(checkIndex, args);\n-  }\n-\n-  private _createLiteralMapConverter(\n-      sourceSpan: ParseSourceSpan, keys: {key: string, quoted: boolean}[]): BuiltinConverter {\n-    if (keys.length === 0) {\n-      const valueExpr = o.importExpr(Identifiers.EMPTY_MAP);\n-      return () => valueExpr;\n-    }\n-\n-    const map = o.literalMap(keys.map((e, i) => ({...e, value: o.literal(i)})));\n-    const checkIndex = this.nodes.length;\n-    this.nodes.push(() => ({\n-                      sourceSpan,\n-                      nodeFlags: NodeFlags.TypePureObject,\n-                      nodeDef: o.importExpr(Identifiers.pureObjectDef).callFn([\n-                        o.literal(checkIndex),\n-                        map,\n-                      ])\n-                    }));\n-\n-    return (args: o.Expression[]) => callCheckStmt(checkIndex, args);\n-  }\n-\n-  private _createPipeConverter(expression: UpdateExpression, name: string, argCount: number):\n-      BuiltinConverter {\n-    const pipe = this.usedPipes.find((pipeSummary) => pipeSummary.name === name)!;\n-    if (pipe.pure) {\n-      const checkIndex = this.nodes.length;\n-      this.nodes.push(() => ({\n-                        sourceSpan: expression.sourceSpan,\n-                        nodeFlags: NodeFlags.TypePurePipe,\n-                        nodeDef: o.importExpr(Identifiers.purePipeDef).callFn([\n-                          o.literal(checkIndex),\n-                          o.literal(argCount),\n-                        ])\n-                      }));\n-\n-      // find underlying pipe in the component view\n-      let compViewExpr: o.Expression = VIEW_VAR;\n-      let compBuilder: ViewBuilder = this;\n-      while (compBuilder.parent) {\n-        compBuilder = compBuilder.parent;\n-        compViewExpr = compViewExpr.prop('parent').cast(o.DYNAMIC_TYPE);\n-      }\n-      const pipeNodeIndex = compBuilder.purePipeNodeIndices[name];\n-      const pipeValueExpr: o.Expression =\n-          o.importExpr(Identifiers.nodeValue).callFn([compViewExpr, o.literal(pipeNodeIndex)]);\n-\n-      return (args: o.Expression[]) => callCheckStmt(checkIndex, [pipeValueExpr].concat(args));\n-    } else {\n-      const nodeIndex = this._createPipe(expression.sourceSpan, pipe);\n-      const nodeValueExpr =\n-          o.importExpr(Identifiers.nodeValue).callFn([VIEW_VAR, o.literal(nodeIndex)]);\n-\n-      return (args: o.Expression[]) => nodeValueExpr.prop('transform').callFn(args);\n-    }\n-  }\n-\n-  private _createPipe(sourceSpan: ParseSourceSpan|null, pipe: CompilePipeSummary): number {\n-    const nodeIndex = this.nodes.length;\n-    let flags = NodeFlags.None;\n-    pipe.type.lifecycleHooks.forEach((lifecycleHook) => {\n-      // for pipes, we only support ngOnDestroy\n-      if (lifecycleHook === LifecycleHooks.OnDestroy) {\n-        flags |= lifecycleHookToNodeFlag(lifecycleHook);\n-      }\n-    });\n-\n-    const depExprs = pipe.type.diDeps.map((diDep) => depDef(this.outputCtx, diDep));\n-    // function pipeDef(\n-    //   flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef\n-    this.nodes.push(\n-        () => ({\n-          sourceSpan,\n-          nodeFlags: NodeFlags.TypePipe,\n-          nodeDef: o.importExpr(Identifiers.pipeDef).callFn([\n-            o.literal(flags), this.outputCtx.importExpr(pipe.type.reference), o.literalArr(depExprs)\n-          ])\n-        }));\n-    return nodeIndex;\n-  }\n-\n-  /**\n-   * For the AST in `UpdateExpression.value`:\n-   * - create nodes for pipes, literal arrays and, literal maps,\n-   * - update the AST to replace pipes, literal arrays and, literal maps with calls to check fn.\n-   *\n-   * WARNING: This might create new nodeDefs (for pipes and literal arrays and literal maps)!\n-   */\n-  private _preprocessUpdateExpression(expression: UpdateExpression): UpdateExpression {\n-    return {\n-      nodeIndex: expression.nodeIndex,\n-      bindingIndex: expression.bindingIndex,\n-      sourceSpan: expression.sourceSpan,\n-      context: expression.context,\n-      value: convertPropertyBindingBuiltins(\n-          {\n-            createLiteralArrayConverter: (argCount: number) =>\n-                this._createLiteralArrayConverter(expression.sourceSpan, argCount),\n-            createLiteralMapConverter: (keys: {key: string, quoted: boolean}[]) =>\n-                this._createLiteralMapConverter(expression.sourceSpan, keys),\n-            createPipeConverter: (name: string, argCount: number) =>\n-                this._createPipeConverter(expression, name, argCount)\n-          },\n-          expression.value)\n-    };\n-  }\n-\n-  private _createNodeExpressions(): {\n-    updateRendererStmts: o.Statement[],\n-    updateDirectivesStmts: o.Statement[],\n-    nodeDefExprs: o.Expression[]\n-  } {\n-    const self = this;\n-    let updateBindingCount = 0;\n-    const updateRendererStmts: o.Statement[] = [];\n-    const updateDirectivesStmts: o.Statement[] = [];\n-    const nodeDefExprs = this.nodes.map((factory, nodeIndex) => {\n-      const {nodeDef, nodeFlags, updateDirectives, updateRenderer, sourceSpan} = factory();\n-      if (updateRenderer) {\n-        updateRendererStmts.push(\n-            ...createUpdateStatements(nodeIndex, sourceSpan, updateRenderer, false));\n-      }\n-      if (updateDirectives) {\n-        updateDirectivesStmts.push(...createUpdateStatements(\n-            nodeIndex, sourceSpan, updateDirectives,\n-            (nodeFlags & (NodeFlags.DoCheck | NodeFlags.OnInit)) > 0));\n-      }\n-      // We use a comma expression to call the log function before\n-      // the nodeDef function, but still use the result of the nodeDef function\n-      // as the value.\n-      // Note: We only add the logger to elements / text nodes,\n-      // so we don't generate too much code.\n-      const logWithNodeDef = nodeFlags & NodeFlags.CatRenderNode ?\n-          new o.CommaExpr([LOG_VAR.callFn([]).callFn([]), nodeDef]) :\n-          nodeDef;\n-      return o.applySourceSpanToExpressionIfNeeded(logWithNodeDef, sourceSpan);\n-    });\n-    return {updateRendererStmts, updateDirectivesStmts, nodeDefExprs};\n-\n-    function createUpdateStatements(\n-        nodeIndex: number, sourceSpan: ParseSourceSpan|null, expressions: UpdateExpression[],\n-        allowEmptyExprs: boolean): o.Statement[] {\n-      const updateStmts: o.Statement[] = [];\n-      const exprs = expressions.map(({sourceSpan, context, value}) => {\n-        const bindingId = `${updateBindingCount++}`;\n-        const nameResolver = context === COMP_VAR ? self : null;\n-        const {stmts, currValExpr} =\n-            convertPropertyBinding(nameResolver, context, value, bindingId, BindingForm.General);\n-        updateStmts.push(...stmts.map(\n-            (stmt: o.Statement) => o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\n-        return o.applySourceSpanToExpressionIfNeeded(currValExpr, sourceSpan);\n-      });\n-      if (expressions.length || allowEmptyExprs) {\n-        updateStmts.push(o.applySourceSpanToStatementIfNeeded(\n-            callCheckStmt(nodeIndex, exprs).toStmt(), sourceSpan));\n-      }\n-      return updateStmts;\n-    }\n-  }\n-\n-  private _createElementHandleEventFn(\n-      nodeIndex: number,\n-      handlers: {context: o.Expression, eventAst: BoundEventAst, dirAst: DirectiveAst}[]) {\n-    const handleEventStmts: o.Statement[] = [];\n-    let handleEventBindingCount = 0;\n-    handlers.forEach(({context, eventAst, dirAst}) => {\n-      const bindingId = `${handleEventBindingCount++}`;\n-      const nameResolver = context === COMP_VAR ? this : null;\n-      const {stmts, allowDefault} =\n-          convertActionBinding(nameResolver, context, eventAst.handler, bindingId);\n-      const trueStmts = stmts;\n-      if (allowDefault) {\n-        trueStmts.push(ALLOW_DEFAULT_VAR.set(allowDefault.and(ALLOW_DEFAULT_VAR)).toStmt());\n-      }\n-      const {target: eventTarget, name: eventName} = elementEventNameAndTarget(eventAst, dirAst);\n-      const fullEventName = elementEventFullName(eventTarget, eventName);\n-      handleEventStmts.push(o.applySourceSpanToStatementIfNeeded(\n-          new o.IfStmt(o.literal(fullEventName).identical(EVENT_NAME_VAR), trueStmts),\n-          eventAst.sourceSpan));\n-    });\n-    let handleEventFn: o.Expression;\n-    if (handleEventStmts.length > 0) {\n-      const preStmts: o.Statement[] =\n-          [ALLOW_DEFAULT_VAR.set(o.literal(true)).toDeclStmt(o.BOOL_TYPE)];\n-      if (!this.component.isHost && o.findReadVarNames(handleEventStmts).has(COMP_VAR.name!)) {\n-        preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n-      }\n-      handleEventFn = o.fn(\n-          [\n-            new o.FnParam(VIEW_VAR.name!, o.INFERRED_TYPE),\n-            new o.FnParam(EVENT_NAME_VAR.name!, o.INFERRED_TYPE),\n-            new o.FnParam(EventHandlerVars.event.name!, o.INFERRED_TYPE)\n-          ],\n-          [...preStmts, ...handleEventStmts, new o.ReturnStatement(ALLOW_DEFAULT_VAR)],\n-          o.INFERRED_TYPE);\n-    } else {\n-      handleEventFn = o.NULL_EXPR;\n-    }\n-    return handleEventFn;\n-  }\n-\n-  visitDirective(ast: DirectiveAst, context: {usedEvents: Set<string>}): any {}\n-  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any {}\n-  visitReference(ast: ReferenceAst, context: any): any {}\n-  visitVariable(ast: VariableAst, context: any): any {}\n-  visitEvent(ast: BoundEventAst, context: any): any {}\n-  visitElementProperty(ast: BoundElementPropertyAst, context: any): any {}\n-  visitAttr(ast: AttrAst, context: any): any {}\n-}\n-\n-function needsAdditionalRootNode(astNodes: TemplateAst[]): boolean {\n-  const lastAstNode = astNodes[astNodes.length - 1];\n-  if (lastAstNode instanceof EmbeddedTemplateAst) {\n-    return lastAstNode.hasViewContainer;\n-  }\n-\n-  if (lastAstNode instanceof ElementAst) {\n-    if (isNgContainer(lastAstNode.name) && lastAstNode.children.length) {\n-      return needsAdditionalRootNode(lastAstNode.children);\n-    }\n-    return lastAstNode.hasViewContainer;\n-  }\n-\n-  return lastAstNode instanceof NgContentAst;\n-}\n-\n-\n-function elementBindingDef(inputAst: BoundElementPropertyAst, dirAst: DirectiveAst): o.Expression {\n-  const inputType = inputAst.type;\n-  switch (inputType) {\n-    case PropertyBindingType.Attribute:\n-      return o.literalArr([\n-        o.literal(BindingFlags.TypeElementAttribute), o.literal(inputAst.name),\n-        o.literal(inputAst.securityContext)\n-      ]);\n-    case PropertyBindingType.Property:\n-      return o.literalArr([\n-        o.literal(BindingFlags.TypeProperty), o.literal(inputAst.name),\n-        o.literal(inputAst.securityContext)\n-      ]);\n-    case PropertyBindingType.Animation:\n-      const bindingType = BindingFlags.TypeProperty |\n-          (dirAst && dirAst.directive.isComponent ? BindingFlags.SyntheticHostProperty :\n-                                                    BindingFlags.SyntheticProperty);\n-      return o.literalArr([\n-        o.literal(bindingType), o.literal('@' + inputAst.name), o.literal(inputAst.securityContext)\n-      ]);\n-    case PropertyBindingType.Class:\n-      return o.literalArr(\n-          [o.literal(BindingFlags.TypeElementClass), o.literal(inputAst.name), o.NULL_EXPR]);\n-    case PropertyBindingType.Style:\n-      return o.literalArr([\n-        o.literal(BindingFlags.TypeElementStyle), o.literal(inputAst.name), o.literal(inputAst.unit)\n-      ]);\n-    default:\n-      // This default case is not needed by TypeScript compiler, as the switch is exhaustive.\n-      // However Closure Compiler does not understand that and reports an error in typed mode.\n-      // The `throw new Error` below works around the problem, and the unexpected: never variable\n-      // makes sure tsc still checks this code is unreachable.\n-      const unexpected: never = inputType;\n-      throw new Error(`unexpected ${unexpected}`);\n-  }\n-}\n-\n-\n-function fixedAttrsDef(elementAst: ElementAst): o.Expression {\n-  const mapResult: {[key: string]: string} = Object.create(null);\n-  elementAst.attrs.forEach(attrAst => {\n-    mapResult[attrAst.name] = attrAst.value;\n-  });\n-  elementAst.directives.forEach(dirAst => {\n-    Object.keys(dirAst.directive.hostAttributes).forEach(name => {\n-      const value = dirAst.directive.hostAttributes[name];\n-      const prevValue = mapResult[name];\n-      mapResult[name] = prevValue != null ? mergeAttributeValue(name, prevValue, value) : value;\n-    });\n-  });\n-  // Note: We need to sort to get a defined output order\n-  // for tests and for caching generated artifacts...\n-  return o.literalArr(Object.keys(mapResult).sort().map(\n-      (attrName) => o.literalArr([o.literal(attrName), o.literal(mapResult[attrName])])));\n-}\n-\n-function mergeAttributeValue(attrName: string, attrValue1: string, attrValue2: string): string {\n-  if (attrName == CLASS_ATTR || attrName == STYLE_ATTR) {\n-    return `${attrValue1} ${attrValue2}`;\n-  } else {\n-    return attrValue2;\n-  }\n-}\n-\n-function callCheckStmt(nodeIndex: number, exprs: o.Expression[]): o.Expression {\n-  if (exprs.length > 10) {\n-    return CHECK_VAR.callFn(\n-        [VIEW_VAR, o.literal(nodeIndex), o.literal(ArgumentType.Dynamic), o.literalArr(exprs)]);\n-  } else {\n-    return CHECK_VAR.callFn(\n-        [VIEW_VAR, o.literal(nodeIndex), o.literal(ArgumentType.Inline), ...exprs]);\n-  }\n-}\n-\n-function elementEventNameAndTarget(\n-    eventAst: BoundEventAst, dirAst: DirectiveAst|null): {name: string, target: string|null} {\n-  if (eventAst.isAnimation) {\n-    return {\n-      name: `@${eventAst.name}.${eventAst.phase}`,\n-      target: dirAst && dirAst.directive.isComponent ? 'component' : null\n-    };\n-  } else {\n-    return eventAst;\n-  }\n-}\n-\n-function calcQueryFlags(query: CompileQueryMetadata) {\n-  let flags = NodeFlags.None;\n-  // Note: We only make queries static that query for a single item and the user specifically\n-  // set the to be static. This is because of backwards compatibility with the old view compiler...\n-  if (query.first && query.static) {\n-    flags |= NodeFlags.StaticQuery;\n-  } else {\n-    flags |= NodeFlags.DynamicQuery;\n-  }\n-  if (query.emitDistinctChangesOnly) {\n-    flags |= NodeFlags.EmitDistinctChangesOnly;\n-  }\n-  return flags;\n-}\n-\n-export function elementEventFullName(target: string|null, name: string): string {\n-  return target ? `${target}:${name}` : name;\n-}"
        },
        {
            "sha": "96cfc00b5384e1f89d68c3ffadac7c4a15e1b6ae",
            "filename": "packages/compiler/test/output/js_emitter_node_only_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 49,
            "changes": 49,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Ftest%2Foutput%2Fjs_emitter_node_only_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Ftest%2Foutput%2Fjs_emitter_node_only_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Foutput%2Fjs_emitter_node_only_spec.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,49 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {JavaScriptEmitter} from '@angular/compiler/src/output/js_emitter';\n-import * as o from '@angular/compiler/src/output/output_ast';\n-import {SourceMap} from '@angular/compiler/src/output/source_map';\n-import {ParseLocation, ParseSourceFile, ParseSourceSpan} from '@angular/compiler/src/parse_util';\n-\n-import {extractSourceMap, originalPositionFor} from './source_map_util';\n-\n-const someGenFilePath = 'somePackage/someGenFile';\n-\n-{\n-  describe('JavaScriptEmitter', () => {\n-    let emitter: JavaScriptEmitter;\n-    let someVar: o.ReadVarExpr;\n-\n-    beforeEach(() => {\n-      emitter = new JavaScriptEmitter();\n-    });\n-\n-    function emitSourceMap(stmt: o.Statement|o.Statement[], preamble?: string): SourceMap {\n-      const stmts = Array.isArray(stmt) ? stmt : [stmt];\n-      const source = emitter.emitStatements(someGenFilePath, stmts, preamble);\n-      return extractSourceMap(source)!;\n-    }\n-\n-    describe('source maps', () => {\n-      it('should emit an inline source map', () => {\n-        const source = new ParseSourceFile(';;;var', 'in.js');\n-        const startLocation = new ParseLocation(source, 0, 0, 3);\n-        const endLocation = new ParseLocation(source, 7, 0, 6);\n-        const sourceSpan = new ParseSourceSpan(startLocation, endLocation);\n-        const someVar = o.variable('someVar', null, sourceSpan);\n-        const sm = emitSourceMap(someVar.toStmt(), '/* MyPreamble \\n */');\n-\n-        expect(sm.sources).toEqual([someGenFilePath, 'in.js']);\n-        expect(sm.sourcesContent).toEqual([' ', ';;;var']);\n-        expect(originalPositionFor(sm, {line: 3, column: 0}))\n-            .toEqual({line: 1, column: 3, source: 'in.js'});\n-      });\n-    });\n-  });\n-}"
        },
        {
            "sha": "93deba58b74f8d6852f8ce1750366e8dc0ad0c77",
            "filename": "packages/compiler/test/output/js_emitter_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 352,
            "changes": 352,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Ftest%2Foutput%2Fjs_emitter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Ftest%2Foutput%2Fjs_emitter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Foutput%2Fjs_emitter_spec.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,352 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {StaticSymbol} from '@angular/compiler/src/aot/static_symbol';\n-import {JavaScriptEmitter} from '@angular/compiler/src/output/js_emitter';\n-import * as o from '@angular/compiler/src/output/output_ast';\n-import {newArray} from '@angular/compiler/src/util';\n-\n-import {stripSourceMapAndNewLine} from './abstract_emitter_spec';\n-\n-const someGenFilePath = 'somePackage/someGenFile';\n-const anotherModuleUrl = 'somePackage/someOtherPath';\n-\n-const sameModuleIdentifier = new o.ExternalReference(null, 'someLocalId', null);\n-\n-const externalModuleIdentifier = new o.ExternalReference(anotherModuleUrl, 'someExternalId', null);\n-\n-{\n-  // Note supported features of our OutputAstin JavaScript / ES5:\n-  // - types\n-  // - declaring fields\n-\n-  describe('JavaScriptEmitter', () => {\n-    let emitter: JavaScriptEmitter;\n-    let someVar: o.ReadVarExpr;\n-\n-    beforeEach(() => {\n-      emitter = new JavaScriptEmitter();\n-      someVar = o.variable('someVar');\n-    });\n-\n-    function emitStmt(stmt: o.Statement, preamble?: string): string {\n-      const source = emitter.emitStatements(someGenFilePath, [stmt], preamble);\n-      return stripSourceMapAndNewLine(source);\n-    }\n-\n-    it('should declare variables', () => {\n-      expect(emitStmt(someVar.set(o.literal(1)).toDeclStmt())).toEqual(`var someVar = 1;`);\n-      expect(emitStmt(someVar.set(o.literal(1)).toDeclStmt(null, [o.StmtModifier.Exported])))\n-          .toEqual([\n-            'var someVar = 1;',\n-            `Object.defineProperty(exports, 'someVar', { get: function() { return someVar; }});`\n-          ].join('\\n'));\n-    });\n-\n-    it('should read and write variables', () => {\n-      expect(emitStmt(someVar.toStmt())).toEqual(`someVar;`);\n-      expect(emitStmt(someVar.set(o.literal(1)).toStmt())).toEqual(`someVar = 1;`);\n-      expect(emitStmt(someVar.set(o.variable('someOtherVar').set(o.literal(1))).toStmt()))\n-          .toEqual(`someVar = (someOtherVar = 1);`);\n-    });\n-\n-    it('should read and write keys', () => {\n-      expect(emitStmt(o.variable('someMap').key(o.variable('someKey')).toStmt()))\n-          .toEqual(`someMap[someKey];`);\n-      expect(emitStmt(o.variable('someMap').key(o.variable('someKey')).set(o.literal(1)).toStmt()))\n-          .toEqual(`someMap[someKey] = 1;`);\n-    });\n-\n-    it('should read and write properties', () => {\n-      expect(emitStmt(o.variable('someObj').prop('someProp').toStmt()))\n-          .toEqual(`someObj.someProp;`);\n-      expect(emitStmt(o.variable('someObj').prop('someProp').set(o.literal(1)).toStmt()))\n-          .toEqual(`someObj.someProp = 1;`);\n-    });\n-\n-    it('should invoke functions and methods and constructors', () => {\n-      expect(emitStmt(o.variable('someFn').callFn([o.literal(1)]).toStmt())).toEqual('someFn(1);');\n-      expect(emitStmt(o.variable('someObj').prop('someMethod').callFn([o.literal(1)]).toStmt()))\n-          .toEqual('someObj.someMethod(1);');\n-      expect(emitStmt(o.variable('SomeClass').instantiate([o.literal(1)]).toStmt()))\n-          .toEqual('new SomeClass(1);');\n-    });\n-\n-    it('should support literals', () => {\n-      expect(emitStmt(o.literal(0).toStmt())).toEqual('0;');\n-      expect(emitStmt(o.literal(true).toStmt())).toEqual('true;');\n-      expect(emitStmt(o.literal('someStr').toStmt())).toEqual(`'someStr';`);\n-      expect(emitStmt(o.literalArr([o.literal(1)]).toStmt())).toEqual(`[1];`);\n-      expect(emitStmt(o.literalMap([\n-                         {key: 'someKey', value: o.literal(1), quoted: false},\n-                         {key: 'a', value: o.literal('a'), quoted: false},\n-                         {key: '*', value: o.literal('star'), quoted: true},\n-                       ]).toStmt())\n-                 .replace(/\\s+/gm, ''))\n-          .toEqual(`{someKey:1,a:'a','*':'star'};`);\n-    });\n-\n-    it('should break expressions into multiple lines if they are too long', () => {\n-      const values: o.Expression[] = newArray(100);\n-      values.fill(o.literal(1));\n-      values.splice(50, 0, o.fn([], [new o.ReturnStatement(o.literal(1))]));\n-      expect(emitStmt(o.variable('fn').callFn(values).toStmt())).toEqual([\n-        'fn(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,',\n-        '    1,1,1,1,1,1,1,1,1,1,function() {', '      return 1;',\n-        '    },1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,',\n-        '    1,1,1,1,1,1,1,1,1,1,1,1);'\n-      ].join('\\n'));\n-    });\n-\n-    it('should support blank literals', () => {\n-      expect(emitStmt(o.literal(null).toStmt())).toEqual('null;');\n-      expect(emitStmt(o.literal(undefined).toStmt())).toEqual('undefined;');\n-    });\n-\n-    it('should support external identifiers', () => {\n-      expect(emitStmt(o.importExpr(sameModuleIdentifier).toStmt())).toEqual('someLocalId;');\n-      expect(emitStmt(o.importExpr(externalModuleIdentifier).toStmt())).toEqual([\n-        `var i0 = re` +\n-            `quire('somePackage/someOtherPath');`,\n-        `i0.someExternalId;`\n-      ].join('\\n'));\n-    });\n-\n-    it('should support operators', () => {\n-      const lhs = o.variable('lhs');\n-      const rhs = o.variable('rhs');\n-      expect(emitStmt(o.not(someVar).toStmt())).toEqual('!someVar;');\n-      expect(emitStmt(o.unary(o.UnaryOperator.Minus, someVar).toStmt())).toEqual('(-someVar);');\n-      expect(emitStmt(o.unary(o.UnaryOperator.Plus, someVar).toStmt())).toEqual('(+someVar);');\n-      expect(emitStmt(o.assertNotNull(someVar).toStmt())).toEqual('someVar;');\n-      expect(\n-          emitStmt(someVar.conditional(o.variable('trueCase'), o.variable('falseCase')).toStmt()))\n-          .toEqual('(someVar? trueCase: falseCase);');\n-\n-      expect(emitStmt(lhs.equals(rhs).toStmt())).toEqual('(lhs == rhs);');\n-      expect(emitStmt(lhs.notEquals(rhs).toStmt())).toEqual('(lhs != rhs);');\n-      expect(emitStmt(lhs.identical(rhs).toStmt())).toEqual('(lhs === rhs);');\n-      expect(emitStmt(lhs.notIdentical(rhs).toStmt())).toEqual('(lhs !== rhs);');\n-      expect(emitStmt(lhs.minus(rhs).toStmt())).toEqual('(lhs - rhs);');\n-      expect(emitStmt(lhs.plus(rhs).toStmt())).toEqual('(lhs + rhs);');\n-      expect(emitStmt(lhs.divide(rhs).toStmt())).toEqual('(lhs / rhs);');\n-      expect(emitStmt(lhs.multiply(rhs).toStmt())).toEqual('(lhs * rhs);');\n-      expect(emitStmt(lhs.modulo(rhs).toStmt())).toEqual('(lhs % rhs);');\n-      expect(emitStmt(lhs.and(rhs).toStmt())).toEqual('(lhs && rhs);');\n-      expect(emitStmt(lhs.or(rhs).toStmt())).toEqual('(lhs || rhs);');\n-      expect(emitStmt(lhs.lower(rhs).toStmt())).toEqual('(lhs < rhs);');\n-      expect(emitStmt(lhs.lowerEquals(rhs).toStmt())).toEqual('(lhs <= rhs);');\n-      expect(emitStmt(lhs.bigger(rhs).toStmt())).toEqual('(lhs > rhs);');\n-      expect(emitStmt(lhs.biggerEquals(rhs).toStmt())).toEqual('(lhs >= rhs);');\n-    });\n-\n-    it('should support function expressions', () => {\n-      expect(emitStmt(o.fn([], []).toStmt())).toEqual(['function() {', '};'].join('\\n'));\n-      expect(emitStmt(o.fn([], [new o.ReturnStatement(o.literal(1))]).toStmt())).toEqual([\n-        'function() {', '  return 1;\\n};'\n-      ].join('\\n'));\n-      expect(emitStmt(o.fn([new o.FnParam('param1')], []).toStmt())).toEqual([\n-        'function(param1) {', '};'\n-      ].join('\\n'));\n-    });\n-\n-    it('should support function statements', () => {\n-      expect(emitStmt(new o.DeclareFunctionStmt('someFn', [], []))).toEqual([\n-        'function someFn() {', '}'\n-      ].join('\\n'));\n-      expect(emitStmt(new o.DeclareFunctionStmt('someFn', [], [], null, [o.StmtModifier.Exported])))\n-          .toEqual([\n-            'function someFn() {', '}',\n-            `Object.defineProperty(exports, 'someFn', { get: function() { return someFn; }});`\n-          ].join('\\n'));\n-      expect(emitStmt(new o.DeclareFunctionStmt('someFn', [], [\n-        new o.ReturnStatement(o.literal(1))\n-      ]))).toEqual(['function someFn() {', '  return 1;', '}'].join('\\n'));\n-      expect(emitStmt(new o.DeclareFunctionStmt('someFn', [new o.FnParam('param1')], []))).toEqual([\n-        'function someFn(param1) {', '}'\n-      ].join('\\n'));\n-    });\n-\n-    describe('comments', () => {\n-      it('should support a preamble', () => {\n-        expect(emitStmt(o.variable('a').toStmt(), '/* SomePreamble */')).toBe([\n-          '/* SomePreamble */', 'a;'\n-        ].join('\\n'));\n-      });\n-\n-      it('should support singleline comments', () => {\n-        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [o.leadingComment('a\\nb')])))\n-            .toBe('// a\\n// b\\nreturn 1;');\n-      });\n-\n-      it('should support multiline comments', () => {\n-        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n-          o.leadingComment('Multiline comment', true)\n-        ]))).toBe('/* Multiline comment */\\nreturn 1;');\n-        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n-          o.leadingComment(`Multiline\\ncomment`, true)\n-        ]))).toBe(`/* Multiline\\ncomment */\\nreturn 1;`);\n-      });\n-\n-      it('should support inline multiline comments', () => {\n-        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n-          o.leadingComment('inline comment', true, false)\n-        ]))).toBe('/* inline comment */return 1;');\n-      });\n-\n-      it('should support JSDoc comments', () => {\n-        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n-          o.jsDocComment([{text: 'Intro comment'}])\n-        ]))).toBe(`/**\\n * Intro comment\\n */\\nreturn 1;`);\n-        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n-          o.jsDocComment([{tagName: o.JSDocTagName.Desc, text: 'description'}])\n-        ]))).toBe(`/**\\n * @desc description\\n */\\nreturn 1;`);\n-        expect(emitStmt(new o.ReturnStatement(\n-                   o.literal(1), null, [o.jsDocComment([\n-                     {text: 'Intro comment'},\n-                     {tagName: o.JSDocTagName.Desc, text: 'description'},\n-                     {tagName: o.JSDocTagName.Id, text: '{number} identifier 123'},\n-                   ])])))\n-            .toBe(\n-                `/**\\n * Intro comment\\n * @desc description\\n * @id {number} identifier 123\\n */\\nreturn 1;`);\n-      });\n-    });\n-\n-    it('should support if stmt', () => {\n-      const trueCase = o.variable('trueCase').callFn([]).toStmt();\n-      const falseCase = o.variable('falseCase').callFn([]).toStmt();\n-      expect(emitStmt(new o.IfStmt(o.variable('cond'), [trueCase]))).toEqual([\n-        'if (cond) { trueCase(); }'\n-      ].join('\\n'));\n-      expect(emitStmt(new o.IfStmt(o.variable('cond'), [trueCase], [falseCase]))).toEqual([\n-        'if (cond) {', '  trueCase();', '} else {', '  falseCase();', '}'\n-      ].join('\\n'));\n-    });\n-\n-    it('should support ES5 localized strings', () => {\n-      const messageParts =\n-          [new o.LiteralPiece('ab\\\\:c', {} as any), new o.LiteralPiece('d\"e\\'f', {} as any)];\n-      const placeholders = [new o.PlaceholderPiece('ph1', {} as any)];\n-      const expressions = [o.literal(7, o.NUMBER_TYPE).plus(o.literal(8, o.NUMBER_TYPE))];\n-      const localizedString = o.localizedString({}, messageParts, placeholders, expressions);\n-      expect(emitStmt(new o.ExpressionStatement(localizedString)))\n-          .toEqual(\n-              String.raw\n-              `$localize((this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,\"raw\",{value:t}):e.raw=t,e})(['ab\\\\:c', ':ph1:d\"e\\'f'], ['ab\\\\\\\\:c', ':ph1:d\"e\\'f']), (7 + 8));`);\n-    });\n-\n-    it('should support try/catch', () => {\n-      const bodyStmt = o.variable('body').callFn([]).toStmt();\n-      const catchStmt =\n-          o.variable('catchFn').callFn([o.CATCH_ERROR_VAR, o.CATCH_STACK_VAR]).toStmt();\n-      expect(emitStmt(new o.TryCatchStmt([bodyStmt], [catchStmt]))).toEqual([\n-        'try {', '  body();', '} catch (error) {', '  var stack = error.stack;',\n-        '  catchFn(error,stack);', '}'\n-      ].join('\\n'));\n-    });\n-\n-    it('should support support throwing', () => {\n-      expect(emitStmt(new o.ThrowStmt(someVar))).toEqual('throw someVar;');\n-    });\n-\n-    describe('classes', () => {\n-      let callSomeMethod: o.Statement;\n-\n-      beforeEach(() => {\n-        callSomeMethod = o.THIS_EXPR.prop('someMethod').callFn([]).toStmt();\n-      });\n-\n-      it('should support declaring classes', () => {\n-        expect(emitStmt(new o.ClassStmt('SomeClass', null!, [], [], null!, []))).toEqual([\n-          'function SomeClass() {', '}'\n-        ].join('\\n'));\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!, [], [], null!, [], [o.StmtModifier.Exported])))\n-            .toEqual([\n-              'function SomeClass() {', '}',\n-              `Object.defineProperty(exports, 'SomeClass', { get: function() { return SomeClass; }});`\n-            ].join('\\n'));\n-        expect(\n-            emitStmt(new o.ClassStmt('SomeClass', o.variable('SomeSuperClass'), [], [], null!, [])))\n-            .toEqual([\n-              'function SomeClass() {', '}',\n-              'SomeClass.prototype = Object.create(SomeSuperClass.prototype);'\n-            ].join('\\n'));\n-      });\n-\n-      it('should support declaring constructors', () => {\n-        const superCall = o.SUPER_EXPR.callFn([o.variable('someParam')]).toStmt();\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!, [], [], new o.ClassMethod(null!, [], []), [])))\n-            .toEqual(['function SomeClass() {', '}'].join('\\n'));\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!, [], [],\n-                   new o.ClassMethod(null!, [new o.FnParam('someParam')], []), [])))\n-            .toEqual(['function SomeClass(someParam) {', '}'].join('\\n'));\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', o.variable('SomeSuperClass'), [], [],\n-                   new o.ClassMethod(null!, [], [superCall]), [])))\n-            .toEqual([\n-              'function SomeClass() {', '  var self = this;',\n-              '  SomeSuperClass.call(this, someParam);', '}',\n-              'SomeClass.prototype = Object.create(SomeSuperClass.prototype);'\n-            ].join('\\n'));\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!, [], [], new o.ClassMethod(null!, [], [callSomeMethod]), [])))\n-            .toEqual([\n-              'function SomeClass() {', '  var self = this;', '  self.someMethod();', '}'\n-            ].join('\\n'));\n-      });\n-\n-      it('should support declaring getters', () => {\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!, [], [new o.ClassGetter('someGetter', [])], null!, [])))\n-            .toEqual([\n-              'function SomeClass() {', '}',\n-              `Object.defineProperty(SomeClass.prototype, 'someGetter', { get: function() {`, `}});`\n-            ].join('\\n'));\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!, [], [new o.ClassGetter('someGetter', [callSomeMethod])],\n-                   null!, [])))\n-            .toEqual([\n-              'function SomeClass() {', '}',\n-              `Object.defineProperty(SomeClass.prototype, 'someGetter', { get: function() {`,\n-              `  var self = this;`, `  self.someMethod();`, `}});`\n-            ].join('\\n'));\n-      });\n-\n-      it('should support methods', () => {\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!, [], [], null!, [new o.ClassMethod('someMethod', [], [])])))\n-            .toEqual([\n-              'function SomeClass() {', '}', 'SomeClass.prototype.someMethod = function() {', '};'\n-            ].join('\\n'));\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!, [], [], null!,\n-                   [new o.ClassMethod('someMethod', [new o.FnParam('someParam')], [])])))\n-            .toEqual([\n-              'function SomeClass() {', '}',\n-              'SomeClass.prototype.someMethod = function(someParam) {', '};'\n-            ].join('\\n'));\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!, [], [], null!,\n-                   [new o.ClassMethod('someMethod', [], [callSomeMethod])])))\n-            .toEqual([\n-              'function SomeClass() {', '}', 'SomeClass.prototype.someMethod = function() {',\n-              '  var self = this;', '  self.someMethod();', '};'\n-            ].join('\\n'));\n-      });\n-    });\n-\n-    it('should support a preamble', () => {\n-      expect(emitStmt(o.variable('a').toStmt(), '/* SomePreamble */')).toBe([\n-        '/* SomePreamble */', 'a;'\n-      ].join('\\n'));\n-    });\n-  });\n-}"
        },
        {
            "sha": "4293f3c8f3883660d6181e2e27566d7320e7275f",
            "filename": "packages/compiler/test/output/ts_emitter_node_only_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 56,
            "changes": 56,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Ftest%2Foutput%2Fts_emitter_node_only_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Ftest%2Foutput%2Fts_emitter_node_only_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Foutput%2Fts_emitter_node_only_spec.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,56 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {ParseLocation, ParseSourceFile} from '@angular/compiler';\n-import {StaticSymbol} from '@angular/compiler/src/aot/static_symbol';\n-import * as o from '@angular/compiler/src/output/output_ast';\n-import {SourceMap} from '@angular/compiler/src/output/source_map';\n-import {TypeScriptEmitter} from '@angular/compiler/src/output/ts_emitter';\n-import {ParseSourceSpan} from '@angular/compiler/src/parse_util';\n-\n-import {extractSourceMap, originalPositionFor} from './source_map_util';\n-\n-const someGenFilePath = 'somePackage/someGenFile';\n-\n-{\n-  // Not supported features of our OutputAst in TS:\n-  // - real `const` like in Dart\n-  // - final fields\n-\n-  describe('TypeScriptEmitter', () => {\n-    let emitter: TypeScriptEmitter;\n-    let someVar: o.ReadVarExpr;\n-\n-    beforeEach(() => {\n-      emitter = new TypeScriptEmitter();\n-      someVar = o.variable('someVar');\n-    });\n-\n-    function emitSourceMap(stmt: o.Statement|o.Statement[], preamble?: string): SourceMap {\n-      const stmts = Array.isArray(stmt) ? stmt : [stmt];\n-      const source = emitter.emitStatements(someGenFilePath, stmts, preamble);\n-      return extractSourceMap(source)!;\n-    }\n-\n-    describe('source maps', () => {\n-      it('should emit an inline source map', () => {\n-        const source = new ParseSourceFile(';;;var', 'in.js');\n-        const startLocation = new ParseLocation(source, 0, 0, 3);\n-        const endLocation = new ParseLocation(source, 7, 0, 6);\n-        const sourceSpan = new ParseSourceSpan(startLocation, endLocation);\n-        const someVar = o.variable('someVar', null, sourceSpan);\n-        const sm = emitSourceMap(someVar.toStmt(), '/* MyPreamble \\n */');\n-\n-        expect(sm.sources).toEqual([someGenFilePath, 'in.js']);\n-        expect(sm.sourcesContent).toEqual([' ', ';;;var']);\n-        expect(originalPositionFor(sm, {line: 3, column: 0}))\n-            .toEqual({line: 1, column: 3, source: 'in.js'});\n-      });\n-    });\n-  });\n-}"
        },
        {
            "sha": "30c716eb7529e308044d30d6fbe87e85d7f38ba3",
            "filename": "packages/compiler/test/output/ts_emitter_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 506,
            "changes": 506,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Ftest%2Foutput%2Fts_emitter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Ftest%2Foutput%2Fts_emitter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Foutput%2Fts_emitter_spec.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,506 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {StaticSymbol} from '@angular/compiler/src/aot/static_symbol';\n-import * as o from '@angular/compiler/src/output/output_ast';\n-import {TypeScriptEmitter} from '@angular/compiler/src/output/ts_emitter';\n-import {ParseLocation, ParseSourceFile, ParseSourceSpan} from '@angular/compiler/src/parse_util';\n-import {newArray} from '@angular/compiler/src/util';\n-\n-import {stripSourceMapAndNewLine} from './abstract_emitter_spec';\n-\n-const someGenFilePath = 'somePackage/someGenFile';\n-const anotherModuleUrl = 'somePackage/someOtherPath';\n-\n-const sameModuleIdentifier = new o.ExternalReference(null, 'someLocalId', null);\n-\n-const externalModuleIdentifier = new o.ExternalReference(anotherModuleUrl, 'someExternalId', null);\n-\n-{\n-  // Not supported features of our OutputAst in TS:\n-  // - real `const` like in Dart\n-  // - final fields\n-\n-  describe('TypeScriptEmitter', () => {\n-    let emitter: TypeScriptEmitter;\n-    let someVar: o.ReadVarExpr;\n-\n-    beforeEach(() => {\n-      emitter = new TypeScriptEmitter();\n-      someVar = o.variable('someVar', null, null);\n-    });\n-\n-    function emitStmt(stmt: o.Statement|o.Statement[], preamble?: string): string {\n-      const stmts = Array.isArray(stmt) ? stmt : [stmt];\n-      const source = emitter.emitStatements(someGenFilePath, stmts, preamble);\n-      return stripSourceMapAndNewLine(source);\n-    }\n-\n-    it('should declare variables', () => {\n-      expect(emitStmt(someVar.set(o.literal(1)).toDeclStmt())).toEqual(`var someVar:any = 1;`);\n-      expect(emitStmt(someVar.set(o.literal(1)).toDeclStmt(null, [o.StmtModifier.Final])))\n-          .toEqual(`const someVar:any = 1;`);\n-      expect(emitStmt(someVar.set(o.literal(1)).toDeclStmt(null, [o.StmtModifier.Exported])))\n-          .toEqual(`export var someVar:any = 1;`);\n-      expect(emitStmt(someVar.set(o.literal(1)).toDeclStmt(o.INT_TYPE)))\n-          .toEqual(`var someVar:number = 1;`);\n-      expect(emitStmt(someVar.set(o.literal(1)).toDeclStmt(o.INFERRED_TYPE)))\n-          .toEqual(`var someVar = 1;`);\n-    });\n-\n-    describe('declare variables with ExternExpressions as values', () => {\n-      it('should create no reexport if the identifier is in the same module', () => {\n-        // identifier is in the same module -> no reexport\n-        expect(emitStmt(someVar.set(o.importExpr(sameModuleIdentifier)).toDeclStmt(null, [\n-          o.StmtModifier.Exported\n-        ]))).toEqual('export var someVar:any = someLocalId;');\n-      });\n-\n-      it('should create no reexport if the variable is not exported', () => {\n-        expect(emitStmt(someVar.set(o.importExpr(externalModuleIdentifier)).toDeclStmt())).toEqual([\n-          `import * as i0 from 'somePackage/someOtherPath';`, `var someVar:any = i0.someExternalId;`\n-        ].join('\\n'));\n-      });\n-\n-      it('should create no reexport if the variable is typed', () => {\n-        expect(emitStmt(someVar.set(o.importExpr(externalModuleIdentifier))\n-                            .toDeclStmt(o.DYNAMIC_TYPE, [o.StmtModifier.Exported])))\n-            .toEqual([\n-              `import * as i0 from 'somePackage/someOtherPath';`,\n-              `export var someVar:any = i0.someExternalId;`\n-            ].join('\\n'));\n-      });\n-\n-      it('should create a reexport', () => {\n-        expect(emitStmt(someVar.set(o.importExpr(externalModuleIdentifier))\n-                            .toDeclStmt(null, [o.StmtModifier.Exported])))\n-            .toEqual([\n-              `export {someExternalId as someVar} from 'somePackage/someOtherPath';`, ``\n-            ].join('\\n'));\n-      });\n-\n-      it('should create multiple reexports from the same file', () => {\n-        const someVar2 = o.variable('someVar2');\n-        const externalModuleIdentifier2 =\n-            new o.ExternalReference(anotherModuleUrl, 'someExternalId2', null);\n-        expect(emitStmt([\n-          someVar.set(o.importExpr(externalModuleIdentifier))\n-              .toDeclStmt(null, [o.StmtModifier.Exported]),\n-          someVar2.set(o.importExpr(externalModuleIdentifier2))\n-              .toDeclStmt(null, [o.StmtModifier.Exported])\n-        ]))\n-            .toEqual([\n-              `export {someExternalId as someVar,someExternalId2 as someVar2} from 'somePackage/someOtherPath';`,\n-              ``\n-            ].join('\\n'));\n-      });\n-    });\n-\n-    it('should read and write variables', () => {\n-      expect(emitStmt(someVar.toStmt())).toEqual(`someVar;`);\n-      expect(emitStmt(someVar.set(o.literal(1)).toStmt())).toEqual(`someVar = 1;`);\n-      expect(emitStmt(someVar.set(o.variable('someOtherVar').set(o.literal(1))).toStmt()))\n-          .toEqual(`someVar = (someOtherVar = 1);`);\n-    });\n-\n-    it('should read and write keys', () => {\n-      expect(emitStmt(o.variable('someMap').key(o.variable('someKey')).toStmt()))\n-          .toEqual(`someMap[someKey];`);\n-      expect(emitStmt(o.variable('someMap').key(o.variable('someKey')).set(o.literal(1)).toStmt()))\n-          .toEqual(`someMap[someKey] = 1;`);\n-    });\n-\n-    it('should read and write properties', () => {\n-      expect(emitStmt(o.variable('someObj').prop('someProp').toStmt()))\n-          .toEqual(`someObj.someProp;`);\n-      expect(emitStmt(o.variable('someObj').prop('someProp').set(o.literal(1)).toStmt()))\n-          .toEqual(`someObj.someProp = 1;`);\n-    });\n-\n-    it('should invoke functions and methods and constructors', () => {\n-      expect(emitStmt(o.variable('someFn').callFn([o.literal(1)]).toStmt())).toEqual('someFn(1);');\n-      expect(emitStmt(o.variable('someObj').prop('someMethod').callFn([o.literal(1)]).toStmt()))\n-          .toEqual('someObj.someMethod(1);');\n-      expect(emitStmt(o.variable('SomeClass').instantiate([o.literal(1)]).toStmt()))\n-          .toEqual('new SomeClass(1);');\n-    });\n-\n-    it('should support literals', () => {\n-      expect(emitStmt(o.literal(0).toStmt())).toEqual('0;');\n-      expect(emitStmt(o.literal(true).toStmt())).toEqual('true;');\n-      expect(emitStmt(o.literal('someStr').toStmt())).toEqual(`'someStr';`);\n-      expect(emitStmt(o.literalArr([o.literal(1)]).toStmt())).toEqual(`[1];`);\n-      expect(emitStmt(o.literalMap([\n-                         {key: 'someKey', value: o.literal(1), quoted: false},\n-                         {key: 'a', value: o.literal('a'), quoted: false},\n-                         {key: '*', value: o.literal('star'), quoted: true},\n-                       ]).toStmt())\n-                 .replace(/\\s+/gm, ''))\n-          .toEqual(`{someKey:1,a:'a','*':'star'};`);\n-    });\n-\n-    it('should break expressions into multiple lines if they are too long', () => {\n-      const values: o.Expression[] = newArray(100);\n-      values.fill(o.literal(1));\n-      values.splice(50, 0, o.fn([], [new o.ReturnStatement(o.literal(1))]));\n-      expect(emitStmt(o.variable('fn').callFn(values).toStmt())).toEqual([\n-        'fn(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,',\n-        '    1,1,1,1,1,1,1,1,1,1,():void => {', '      return 1;',\n-        '    },1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,',\n-        '    1,1,1,1,1,1,1,1,1,1,1,1);'\n-      ].join('\\n'));\n-    });\n-\n-    it('should support blank literals', () => {\n-      expect(emitStmt(o.literal(null).toStmt())).toEqual('(null as any);');\n-      expect(emitStmt(o.literal(undefined).toStmt())).toEqual('(undefined as any);');\n-      expect(emitStmt(o.variable('a', null).isBlank().toStmt())).toEqual('(a == null);');\n-    });\n-\n-    it('should support external identifiers', () => {\n-      expect(emitStmt(o.importExpr(sameModuleIdentifier).toStmt())).toEqual('someLocalId;');\n-      expect(emitStmt(o.importExpr(externalModuleIdentifier).toStmt())).toEqual([\n-        `import * as i0 from 'somePackage/someOtherPath';`, `i0.someExternalId;`\n-      ].join('\\n'));\n-    });\n-\n-    it('should support operators', () => {\n-      const lhs = o.variable('lhs');\n-      const rhs = o.variable('rhs');\n-      expect(emitStmt(someVar.cast(o.INT_TYPE).toStmt())).toEqual('(<number>someVar);');\n-      expect(emitStmt(o.not(someVar).toStmt())).toEqual('!someVar;');\n-      expect(emitStmt(o.unary(o.UnaryOperator.Minus, someVar).toStmt())).toEqual('(-someVar);');\n-      expect(emitStmt(o.unary(o.UnaryOperator.Plus, someVar).toStmt())).toEqual('(+someVar);');\n-      expect(emitStmt(o.assertNotNull(someVar).toStmt())).toEqual('someVar!;');\n-      expect(\n-          emitStmt(someVar.conditional(o.variable('trueCase'), o.variable('falseCase')).toStmt()))\n-          .toEqual('(someVar? trueCase: falseCase);');\n-\n-      expect(emitStmt(lhs.equals(rhs).toStmt())).toEqual('(lhs == rhs);');\n-      expect(emitStmt(lhs.notEquals(rhs).toStmt())).toEqual('(lhs != rhs);');\n-      expect(emitStmt(lhs.identical(rhs).toStmt())).toEqual('(lhs === rhs);');\n-      expect(emitStmt(lhs.notIdentical(rhs).toStmt())).toEqual('(lhs !== rhs);');\n-      expect(emitStmt(lhs.minus(rhs).toStmt())).toEqual('(lhs - rhs);');\n-      expect(emitStmt(lhs.plus(rhs).toStmt())).toEqual('(lhs + rhs);');\n-      expect(emitStmt(lhs.divide(rhs).toStmt())).toEqual('(lhs / rhs);');\n-      expect(emitStmt(lhs.multiply(rhs).toStmt())).toEqual('(lhs * rhs);');\n-      expect(emitStmt(lhs.modulo(rhs).toStmt())).toEqual('(lhs % rhs);');\n-      expect(emitStmt(lhs.and(rhs).toStmt())).toEqual('(lhs && rhs);');\n-      expect(emitStmt(lhs.or(rhs).toStmt())).toEqual('(lhs || rhs);');\n-      expect(emitStmt(lhs.lower(rhs).toStmt())).toEqual('(lhs < rhs);');\n-      expect(emitStmt(lhs.lowerEquals(rhs).toStmt())).toEqual('(lhs <= rhs);');\n-      expect(emitStmt(lhs.bigger(rhs).toStmt())).toEqual('(lhs > rhs);');\n-      expect(emitStmt(lhs.biggerEquals(rhs).toStmt())).toEqual('(lhs >= rhs);');\n-    });\n-\n-    it('should support function expressions', () => {\n-      expect(emitStmt(o.fn([], []).toStmt())).toEqual(['():void => {', '};'].join('\\n'));\n-      expect(emitStmt(o.fn([], [new o.ReturnStatement(o.literal(1))], o.INT_TYPE).toStmt()))\n-          .toEqual(['():number => {', '  return 1;\\n};'].join('\\n'));\n-      expect(emitStmt(o.fn([new o.FnParam('param1', o.INT_TYPE)], []).toStmt())).toEqual([\n-        '(param1:number):void => {', '};'\n-      ].join('\\n'));\n-    });\n-\n-    it('should support function statements', () => {\n-      expect(emitStmt(new o.DeclareFunctionStmt('someFn', [], []))).toEqual([\n-        'function someFn():void {', '}'\n-      ].join('\\n'));\n-      expect(emitStmt(new o.DeclareFunctionStmt('someFn', [], [], null, [o.StmtModifier.Exported])))\n-          .toEqual(['export function someFn():void {', '}'].join('\\n'));\n-      expect(emitStmt(new o.DeclareFunctionStmt(\n-                 'someFn', [], [new o.ReturnStatement(o.literal(1))], o.INT_TYPE)))\n-          .toEqual(['function someFn():number {', '  return 1;', '}'].join('\\n'));\n-      expect(\n-          emitStmt(new o.DeclareFunctionStmt('someFn', [new o.FnParam('param1', o.INT_TYPE)], [])))\n-          .toEqual(['function someFn(param1:number):void {', '}'].join('\\n'));\n-    });\n-\n-    it('should support comments', () => {\n-      expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [o.leadingComment('a\\nb')])))\n-          .toEqual('// a\\n// b\\nreturn 1;');\n-    });\n-\n-    it('should support if stmt', () => {\n-      const trueCase = o.variable('trueCase').callFn([]).toStmt();\n-      const falseCase = o.variable('falseCase').callFn([]).toStmt();\n-      expect(emitStmt(new o.IfStmt(o.variable('cond'), [trueCase]))).toEqual([\n-        'if (cond) { trueCase(); }'\n-      ].join('\\n'));\n-      expect(emitStmt(new o.IfStmt(o.variable('cond'), [trueCase], [falseCase]))).toEqual([\n-        'if (cond) {', '  trueCase();', '} else {', '  falseCase();', '}'\n-      ].join('\\n'));\n-    });\n-\n-    it('should support localized strings', () => {\n-      const messageParts =\n-          [new o.LiteralPiece('ab\\\\:c', {} as any), new o.LiteralPiece('d\"e\\'f', {} as any)];\n-      const placeholders = [new o.PlaceholderPiece('ph1', {} as any)];\n-      const expressions = [o.literal(7, o.NUMBER_TYPE).plus(o.literal(8, o.NUMBER_TYPE))];\n-      const localizedString = o.localizedString({}, messageParts, placeholders, expressions);\n-      expect(emitStmt(new o.ExpressionStatement(localizedString)))\n-          .toEqual('$localize `ab\\\\\\\\:c${(7 + 8)}:ph1:d\"e\\'f`;');\n-    });\n-\n-    it('should support try/catch', () => {\n-      const bodyStmt = o.variable('body').callFn([]).toStmt();\n-      const catchStmt =\n-          o.variable('catchFn').callFn([o.CATCH_ERROR_VAR, o.CATCH_STACK_VAR]).toStmt();\n-      expect(emitStmt(new o.TryCatchStmt([bodyStmt], [catchStmt]))).toEqual([\n-        'try {', '  body();', '} catch (error) {', '  const stack:any = error.stack;',\n-        '  catchFn(error,stack);', '}'\n-      ].join('\\n'));\n-    });\n-\n-    it('should support support throwing', () => {\n-      expect(emitStmt(new o.ThrowStmt(someVar))).toEqual('throw someVar;');\n-    });\n-\n-    describe('classes', () => {\n-      let callSomeMethod: o.Statement;\n-\n-      beforeEach(() => {\n-        callSomeMethod = o.THIS_EXPR.prop('someMethod').callFn([]).toStmt();\n-      });\n-\n-\n-      it('should support declaring classes', () => {\n-        expect(emitStmt(new o.ClassStmt('SomeClass', null!, [], [], null!, []))).toEqual([\n-          'class SomeClass {', '}'\n-        ].join('\\n'));\n-        expect(emitStmt(new o.ClassStmt('SomeClass', null!, [], [], null!, [], [\n-          o.StmtModifier.Exported\n-        ]))).toEqual(['export class SomeClass {', '}'].join('\\n'));\n-        expect(\n-            emitStmt(new o.ClassStmt('SomeClass', o.variable('SomeSuperClass'), [], [], null!, [])))\n-            .toEqual(['class SomeClass extends SomeSuperClass {', '}'].join('\\n'));\n-      });\n-\n-      it('should support declaring constructors', () => {\n-        const superCall = o.SUPER_EXPR.callFn([o.variable('someParam')]).toStmt();\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!, [], [], new o.ClassMethod(null!, [], []), [])))\n-            .toEqual(['class SomeClass {', '  constructor() {', '  }', '}'].join('\\n'));\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!, [], [],\n-                   new o.ClassMethod(null!, [new o.FnParam('someParam', o.INT_TYPE)], []), [])))\n-            .toEqual(\n-                ['class SomeClass {', '  constructor(someParam:number) {', '  }', '}'].join('\\n'));\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!, [], [], new o.ClassMethod(null!, [], [superCall]), [])))\n-            .toEqual([\n-              'class SomeClass {', '  constructor() {', '    super(someParam);', '  }', '}'\n-            ].join('\\n'));\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!, [], [], new o.ClassMethod(null!, [], [callSomeMethod]), [])))\n-            .toEqual([\n-              'class SomeClass {', '  constructor() {', '    this.someMethod();', '  }', '}'\n-            ].join('\\n'));\n-      });\n-\n-      it('should support declaring fields', () => {\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!, [new o.ClassField('someField')], [], null!, [])))\n-            .toEqual(['class SomeClass {', '  someField:any;', '}'].join('\\n'));\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!, [new o.ClassField('someField', o.INT_TYPE)], [], null!, [])))\n-            .toEqual(['class SomeClass {', '  someField:number;', '}'].join('\\n'));\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!,\n-                   [new o.ClassField('someField', o.INT_TYPE, [o.StmtModifier.Private])], [], null!,\n-                   [])))\n-            .toEqual(['class SomeClass {', '  /*private*/ someField:number;', '}'].join('\\n'));\n-      });\n-\n-      it('should support declaring getters', () => {\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!, [], [new o.ClassGetter('someGetter', [])], null!, [])))\n-            .toEqual(['class SomeClass {', '  get someGetter():any {', '  }', '}'].join('\\n'));\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!, [], [new o.ClassGetter('someGetter', [], o.INT_TYPE)], null!,\n-                   [])))\n-            .toEqual(['class SomeClass {', '  get someGetter():number {', '  }', '}'].join('\\n'));\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!, [], [new o.ClassGetter('someGetter', [callSomeMethod])],\n-                   null!, [])))\n-            .toEqual([\n-              'class SomeClass {', '  get someGetter():any {', '    this.someMethod();', '  }', '}'\n-            ].join('\\n'));\n-        expect(\n-            emitStmt(new o.ClassStmt(\n-                'SomeClass', null!, [],\n-                [new o.ClassGetter('someGetter', [], null!, [o.StmtModifier.Private])], null!, [])))\n-            .toEqual(\n-                ['class SomeClass {', '  private get someGetter():any {', '  }', '}'].join('\\n'));\n-      });\n-\n-      it('should support methods', () => {\n-        expect(emitStmt(new o.ClassStmt('SomeClass', null!, [], [], null!, [\n-          new o.ClassMethod('someMethod', [], [])\n-        ]))).toEqual(['class SomeClass {', '  someMethod():void {', '  }', '}'].join('\\n'));\n-        expect(emitStmt(new o.ClassStmt('SomeClass', null!, [], [], null!, [\n-          new o.ClassMethod('someMethod', [], [], o.INT_TYPE)\n-        ]))).toEqual(['class SomeClass {', '  someMethod():number {', '  }', '}'].join('\\n'));\n-        expect(\n-            emitStmt(new o.ClassStmt(\n-                'SomeClass', null!, [], [], null!,\n-                [new o.ClassMethod('someMethod', [new o.FnParam('someParam', o.INT_TYPE)], [])])))\n-            .toEqual([\n-              'class SomeClass {', '  someMethod(someParam:number):void {', '  }', '}'\n-            ].join('\\n'));\n-        expect(emitStmt(new o.ClassStmt(\n-                   'SomeClass', null!, [], [], null!,\n-                   [new o.ClassMethod('someMethod', [], [callSomeMethod])])))\n-            .toEqual([\n-              'class SomeClass {', '  someMethod():void {', '    this.someMethod();', '  }', '}'\n-            ].join('\\n'));\n-      });\n-    });\n-\n-    it('should support builtin types', () => {\n-      const writeVarExpr = o.variable('a').set(o.NULL_EXPR);\n-      expect(emitStmt(writeVarExpr.toDeclStmt(o.DYNAMIC_TYPE)))\n-          .toEqual('var a:any = (null as any);');\n-      expect(emitStmt(writeVarExpr.toDeclStmt(o.BOOL_TYPE)))\n-          .toEqual('var a:boolean = (null as any);');\n-      expect(emitStmt(writeVarExpr.toDeclStmt(o.INT_TYPE)))\n-          .toEqual('var a:number = (null as any);');\n-      expect(emitStmt(writeVarExpr.toDeclStmt(o.NUMBER_TYPE)))\n-          .toEqual('var a:number = (null as any);');\n-      expect(emitStmt(writeVarExpr.toDeclStmt(o.STRING_TYPE)))\n-          .toEqual('var a:string = (null as any);');\n-      expect(emitStmt(writeVarExpr.toDeclStmt(o.FUNCTION_TYPE)))\n-          .toEqual('var a:Function = (null as any);');\n-    });\n-\n-    it('should support external types', () => {\n-      const writeVarExpr = o.variable('a').set(o.NULL_EXPR);\n-      expect(emitStmt(writeVarExpr.toDeclStmt(o.importType(sameModuleIdentifier))))\n-          .toEqual('var a:someLocalId = (null as any);');\n-      expect(emitStmt(writeVarExpr.toDeclStmt(o.importType(externalModuleIdentifier)))).toEqual([\n-        `import * as i0 from 'somePackage/someOtherPath';`,\n-        `var a:i0.someExternalId = (null as any);`\n-      ].join('\\n'));\n-    });\n-\n-    it('should support expression types', () => {\n-      expect(\n-          emitStmt(o.variable('a').set(o.NULL_EXPR).toDeclStmt(o.expressionType(o.variable('b')))))\n-          .toEqual('var a:b = (null as any);');\n-    });\n-\n-    it('should support expressions with type parameters', () => {\n-      expect(emitStmt(o.variable('a')\n-                          .set(o.NULL_EXPR)\n-                          .toDeclStmt(o.importType(externalModuleIdentifier, [o.STRING_TYPE]))))\n-          .toEqual([\n-            `import * as i0 from 'somePackage/someOtherPath';`,\n-            `var a:i0.someExternalId<string> = (null as any);`\n-          ].join('\\n'));\n-    });\n-\n-    it('should support combined types', () => {\n-      const writeVarExpr = o.variable('a').set(o.NULL_EXPR);\n-      expect(emitStmt(writeVarExpr.toDeclStmt(new o.ArrayType(null!))))\n-          .toEqual('var a:any[] = (null as any);');\n-      expect(emitStmt(writeVarExpr.toDeclStmt(new o.ArrayType(o.INT_TYPE))))\n-          .toEqual('var a:number[] = (null as any);');\n-\n-      expect(emitStmt(writeVarExpr.toDeclStmt(new o.MapType(null))))\n-          .toEqual('var a:{[key: string]:any} = (null as any);');\n-      expect(emitStmt(writeVarExpr.toDeclStmt(new o.MapType(o.INT_TYPE))))\n-          .toEqual('var a:{[key: string]:number} = (null as any);');\n-    });\n-\n-    describe('comments', () => {\n-      it('should support a preamble', () => {\n-        expect(emitStmt(o.variable('a').toStmt(), '/* SomePreamble */')).toBe([\n-          '/* SomePreamble */', 'a;'\n-        ].join('\\n'));\n-      });\n-\n-      it('should support singleline comments', () => {\n-        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [o.leadingComment('a\\nb')])))\n-            .toBe('// a\\n// b\\nreturn 1;');\n-      });\n-\n-      it('should support multiline comments', () => {\n-        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n-          o.leadingComment('Multiline comment', true)\n-        ]))).toBe('/* Multiline comment */\\nreturn 1;');\n-        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n-          o.leadingComment(`Multiline\\ncomment`, true)\n-        ]))).toBe(`/* Multiline\\ncomment */\\nreturn 1;`);\n-      });\n-\n-      it('should support inline multiline comments', () => {\n-        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n-          o.leadingComment('inline comment', true, false)\n-        ]))).toBe('/* inline comment */return 1;');\n-      });\n-\n-      it('should support JSDoc comments', () => {\n-        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n-          o.jsDocComment([{text: 'Intro comment'}])\n-        ]))).toBe(`/**\\n * Intro comment\\n */\\nreturn 1;`);\n-        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n-          o.jsDocComment([{tagName: o.JSDocTagName.Desc, text: 'description'}])\n-        ]))).toBe(`/**\\n * @desc description\\n */\\nreturn 1;`);\n-        expect(emitStmt(new o.ReturnStatement(\n-                   o.literal(1), null, [o.jsDocComment([\n-                     {text: 'Intro comment'},\n-                     {tagName: o.JSDocTagName.Desc, text: 'description'},\n-                     {tagName: o.JSDocTagName.Id, text: '{number} identifier 123'},\n-                   ])])))\n-            .toBe(\n-                `/**\\n * Intro comment\\n * @desc description\\n * @id {number} identifier 123\\n */\\nreturn 1;`);\n-      });\n-    });\n-\n-    describe('emitter context', () => {\n-      it('should be able to back to the generating span', () => {\n-        const file = new ParseSourceFile('some content', 'a.ts');\n-        const returnSpan = new ParseSourceSpan(\n-            new ParseLocation(file, 100, 10, 10), new ParseLocation(file, 200, 20, 10));\n-        const referenceSpan = new ParseSourceSpan(\n-            new ParseLocation(file, 150, 15, 10), new ParseLocation(file, 175, 17, 10));\n-        const statements = [new o.ClassStmt(\n-            'SomeClass', null, [], [], new o.ClassMethod(null, [], []),\n-            [new o.ClassMethod('someMethod', [new o.FnParam('a', o.INT_TYPE)], [\n-              o.variable('someVar', o.INT_TYPE).set(o.literal(0)).toDeclStmt(),\n-              new o.ReturnStatement(o.variable('someVar', null, referenceSpan), returnSpan)\n-            ])])];\n-        const {sourceText, context} =\n-            emitter.emitStatementsAndContext('a.ts', statements, '/* some preamble /*\\n\\n');\n-        const spanOf = (text: string, after: number = 0) => {\n-          const location = sourceText.indexOf(text, after);\n-          const {line, col} = calculateLineCol(sourceText, location);\n-          return context.spanOf(line, col);\n-        };\n-        const returnLoc = sourceText.indexOf('return');\n-        expect(spanOf('return someVar')).toEqual(returnSpan, 'return span calculated incorrectly');\n-        expect(spanOf(';', returnLoc)).toEqual(returnSpan, 'reference span calculated incorrectly');\n-        expect(spanOf('someVar', returnLoc))\n-            .toEqual(referenceSpan, 'return span calculated incorrectly');\n-      });\n-    });\n-  });\n-}\n-\n-function calculateLineCol(text: string, offset: number): {line: number, col: number} {\n-  const lines = text.split('\\n');\n-  let line = 0;\n-  for (let cur = 0; cur < text.length; line++) {\n-    const next = cur + lines[line].length + 1;\n-    if (next > offset) {\n-      return {line, col: offset - cur};\n-    }\n-    cur = next;\n-  }\n-  return {line, col: 0};\n-}"
        },
        {
            "sha": "b3f39dbd16b412a2b484e5303bb61c5922c86cca",
            "filename": "packages/compiler/test/output/value_util_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 23,
            "changes": 23,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Ftest%2Foutput%2Fvalue_util_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Ftest%2Foutput%2Fvalue_util_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Foutput%2Fvalue_util_spec.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,23 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as o from '../../src/output/output_ast';\n-import {convertValueToOutputAst} from '../../src/output/value_util';\n-\n-describe('convertValueToOutputAst', () => {\n-  it('should convert all array elements, including undefined', () => {\n-    const ctx = null;\n-    const value = new Array(3).concat('foo');\n-    const expr = convertValueToOutputAst(ctx!, value) as o.LiteralArrayExpr;\n-    expect(expr instanceof o.LiteralArrayExpr).toBe(true);\n-    expect(expr.entries.length).toBe(4);\n-    for (let i = 0; i < 4; ++i) {\n-      expect(expr.entries[i] instanceof o.Expression).toBe(true);\n-    }\n-  });\n-});"
        },
        {
            "sha": "a4f471442fad125041b5d59c2ea6f6b737b5e164",
            "filename": "packages/compiler/test/render3/view/util.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Ftest%2Frender3%2Fview%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Ftest%2Frender3%2Fview%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Frender3%2Fview%2Futil.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -169,7 +169,7 @@ export function parseR3(\n       {'invalidProp': false}, {'mappedAttr': 'mappedProp'}, {'unknown': false, 'un-known': false},\n       ['onEvent'], ['onEvent']);\n   const bindingParser =\n-      new BindingParser(expressionParser, DEFAULT_INTERPOLATION_CONFIG, schemaRegistry, null, []);\n+      new BindingParser(expressionParser, DEFAULT_INTERPOLATION_CONFIG, schemaRegistry, []);\n   const r3Result = htmlAstToRender3Ast(htmlNodes, bindingParser, {collectCommentNodes: false});\n \n   if (r3Result.errors.length > 0 && !options.ignoreError) {"
        },
        {
            "sha": "e788dd279fd051cffcd6cad664b860a7bbe13363",
            "filename": "packages/compiler/test/style_url_resolver_spec.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 129,
            "changes": 147,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Ftest%2Fstyle_url_resolver_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcompiler%2Ftest%2Fstyle_url_resolver_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fstyle_url_resolver_spec.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -6,139 +6,28 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {extractStyleUrls, isStyleUrlResolvable} from '@angular/compiler/src/style_url_resolver';\n-import {UrlResolver} from '@angular/compiler/src/url_resolver';\n+import {isStyleUrlResolvable} from '@angular/compiler/src/style_url_resolver';\n \n-{\n-  describe('extractStyleUrls', () => {\n-    let urlResolver: UrlResolver;\n-\n-    beforeEach(() => {\n-      urlResolver = new UrlResolver();\n-    });\n-\n-    it('should not resolve \"url()\" urls', () => {\n-      const css = `\n-      .foo {\n-        background-image: url(\"double.jpg\");\n-        background-image: url('simple.jpg');\n-        background-image: url(noquote.jpg);\n-      }`;\n-      const resolvedCss = extractStyleUrls(urlResolver, 'http://ng.io', css).style;\n-      expect(resolvedCss).toEqual(css);\n-    });\n-\n-    it('should extract \"@import\" urls', () => {\n-      const css = `\n-      @import '1.css';\n-      @import \"2.css\";\n-      `;\n-      const styleWithImports = extractStyleUrls(urlResolver, 'http://ng.io', css);\n-      expect(styleWithImports.style.trim()).toEqual('');\n-      expect(styleWithImports.styleUrls).toEqual(['http://ng.io/1.css', 'http://ng.io/2.css']);\n-    });\n-\n-    it('should ignore \"@import\" in comments', () => {\n-      const css = `\n-      @import '1.css';\n-      /*@import '2.css';*/\n-      /*\n-      @import '3.css';\n-      */\n-      `;\n-      const styleWithImports = extractStyleUrls(urlResolver, 'http://ng.io', css);\n-      expect(styleWithImports.style.trim()).toEqual('');\n-      expect(styleWithImports.styleUrls).toContain('http://ng.io/1.css');\n-      expect(styleWithImports.styleUrls).not.toContain('http://ng.io/2.css');\n-      expect(styleWithImports.styleUrls).not.toContain('http://ng.io/3.css');\n-    });\n-\n-    it('should keep /*# sourceURL... */ and /*# sourceMappingURL... */ comments', () => {\n-      const css =\n-          `/*regular comment*/\\n/*# sourceURL=.... */\\n/*# sourceMappingURL=... *//*#sourceMappingURL=... */`;\n-      const styleWithSourceMaps = extractStyleUrls(urlResolver, 'http://ng.io', css);\n-      expect(styleWithSourceMaps.style.trim())\n-          .toEqual('/*# sourceURL=.... */\\n/*# sourceMappingURL=... *//*#sourceMappingURL=... */');\n-    });\n-\n-    it('should extract \"@import url()\" urls', () => {\n-      const css = `\n-      @import url('3.css');\n-      @import url(\"4.css\");\n-      @import url(5.css);\n-      `;\n-      const styleWithImports = extractStyleUrls(urlResolver, 'http://ng.io', css);\n-      expect(styleWithImports.style.trim()).toEqual('');\n-      expect(styleWithImports.styleUrls).toEqual([\n-        'http://ng.io/3.css', 'http://ng.io/4.css', 'http://ng.io/5.css'\n-      ]);\n-    });\n-\n-    it('should extract \"@import urls and keep rules in the same line', () => {\n-      const css = `@import url('some.css');div {color: red};`;\n-      const styleWithImports = extractStyleUrls(urlResolver, 'http://ng.io', css);\n-      expect(styleWithImports.style.trim()).toEqual('div {color: red};');\n-      expect(styleWithImports.styleUrls).toEqual(['http://ng.io/some.css']);\n-    });\n-\n-    it('should extract media query in \"@import\"', () => {\n-      const css = `\n-      @import 'print1.css' print;\n-      @import url(print2.css) print;\n-      `;\n-      const styleWithImports = extractStyleUrls(urlResolver, 'http://ng.io', css);\n-      expect(styleWithImports.style.trim()).toEqual('');\n-      expect(styleWithImports.styleUrls).toEqual([\n-        'http://ng.io/print1.css', 'http://ng.io/print2.css'\n-      ]);\n-    });\n-\n-    it('should leave absolute non-package @import urls intact', () => {\n-      const css = `@import url('http://server.com/some.css');`;\n-      const styleWithImports = extractStyleUrls(urlResolver, 'http://ng.io', css);\n-      expect(styleWithImports.style.trim()).toEqual(`@import url('http://server.com/some.css');`);\n-      expect(styleWithImports.styleUrls).toEqual([]);\n-    });\n-\n-    it('should resolve package @import urls', () => {\n-      const css = `@import url('package:a/b/some.css');`;\n-      const styleWithImports = extractStyleUrls(new FakeUrlResolver(), 'http://ng.io', css);\n-      expect(styleWithImports.style.trim()).toEqual(``);\n-      expect(styleWithImports.styleUrls).toEqual(['fake_resolved_url']);\n-    });\n+describe('isStyleUrlResolvable', () => {\n+  it('should resolve relative urls', () => {\n+    expect(isStyleUrlResolvable('someUrl.css')).toBe(true);\n   });\n \n-  describe('isStyleUrlResolvable', () => {\n-    it('should resolve relative urls', () => {\n-      expect(isStyleUrlResolvable('someUrl.css')).toBe(true);\n-    });\n-\n-    it('should resolve package: urls', () => {\n-      expect(isStyleUrlResolvable('package:someUrl.css')).toBe(true);\n-    });\n-\n-    it('should not resolve empty urls', () => {\n-      expect(isStyleUrlResolvable(null!)).toBe(false);\n-      expect(isStyleUrlResolvable('')).toBe(false);\n-    });\n-\n-    it('should not resolve urls with other schema', () => {\n-      expect(isStyleUrlResolvable('http://otherurl')).toBe(false);\n-    });\n+  it('should resolve package: urls', () => {\n+    expect(isStyleUrlResolvable('package:someUrl.css')).toBe(true);\n+  });\n \n-    it('should not resolve urls with absolute paths', () => {\n-      expect(isStyleUrlResolvable('/otherurl')).toBe(false);\n-      expect(isStyleUrlResolvable('//otherurl')).toBe(false);\n-    });\n+  it('should not resolve empty urls', () => {\n+    expect(isStyleUrlResolvable(null!)).toBe(false);\n+    expect(isStyleUrlResolvable('')).toBe(false);\n   });\n-}\n \n-class FakeUrlResolver extends UrlResolver {\n-  constructor() {\n-    super();\n-  }\n+  it('should not resolve urls with other schema', () => {\n+    expect(isStyleUrlResolvable('http://otherurl')).toBe(false);\n+  });\n \n-  override resolve(baseUrl: string, url: string): string {\n-    return 'fake_resolved_url';\n-  }\n-}\n+  it('should not resolve urls with absolute paths', () => {\n+    expect(isStyleUrlResolvable('/otherurl')).toBe(false);\n+    expect(isStyleUrlResolvable('//otherurl')).toBe(false);\n+  });\n+});"
        },
        {
            "sha": "66226517b9f284aefea0988a372f191ee12c0155",
            "filename": "packages/compiler/test/url_resolver_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 118,
            "changes": 118,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Ftest%2Furl_resolver_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fcompiler%2Ftest%2Furl_resolver_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Furl_resolver_spec.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,118 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {UrlResolver} from '@angular/compiler/src/url_resolver';\n-import {inject} from '@angular/core/testing';\n-\n-{\n-  describe('UrlResolver', () => {\n-    let resolver = new UrlResolver();\n-\n-    describe('absolute base url', () => {\n-      it('should add a relative path to the base url', () => {\n-        expect(resolver.resolve('http://www.foo.com', 'bar')).toEqual('http://www.foo.com/bar');\n-        expect(resolver.resolve('http://www.foo.com/', 'bar')).toEqual('http://www.foo.com/bar');\n-        expect(resolver.resolve('http://www.foo.com', './bar')).toEqual('http://www.foo.com/bar');\n-        expect(resolver.resolve('http://www.foo.com/', './bar')).toEqual('http://www.foo.com/bar');\n-      });\n-\n-      it('should replace the base path', () => {\n-        expect(resolver.resolve('http://www.foo.com/baz', 'bar')).toEqual('http://www.foo.com/bar');\n-        expect(resolver.resolve('http://www.foo.com/baz', './bar'))\n-            .toEqual('http://www.foo.com/bar');\n-      });\n-\n-      it('should append to the base path', () => {\n-        expect(resolver.resolve('http://www.foo.com/baz/', 'bar'))\n-            .toEqual('http://www.foo.com/baz/bar');\n-        expect(resolver.resolve('http://www.foo.com/baz/', './bar'))\n-            .toEqual('http://www.foo.com/baz/bar');\n-      });\n-\n-      it('should support \"..\" in the path', () => {\n-        expect(resolver.resolve('http://www.foo.com/baz/', '../bar'))\n-            .toEqual('http://www.foo.com/bar');\n-        expect(resolver.resolve('http://www.foo.com/1/2/3/', '../../bar'))\n-            .toEqual('http://www.foo.com/1/bar');\n-        expect(resolver.resolve('http://www.foo.com/1/2/3/', '../biz/bar'))\n-            .toEqual('http://www.foo.com/1/2/biz/bar');\n-        expect(resolver.resolve('http://www.foo.com/1/2/baz', '../../bar'))\n-            .toEqual('http://www.foo.com/bar');\n-      });\n-\n-      it('should ignore the base path when the url has a scheme', () => {\n-        expect(resolver.resolve('http://www.foo.com', 'http://www.bar.com'))\n-            .toEqual('http://www.bar.com');\n-      });\n-\n-      it('should support absolute urls', () => {\n-        expect(resolver.resolve('http://www.foo.com', '/bar')).toEqual('http://www.foo.com/bar');\n-        expect(resolver.resolve('http://www.foo.com/', '/bar')).toEqual('http://www.foo.com/bar');\n-        expect(resolver.resolve('http://www.foo.com/baz', '/bar'))\n-            .toEqual('http://www.foo.com/bar');\n-        expect(resolver.resolve('http://www.foo.com/baz/', '/bar'))\n-            .toEqual('http://www.foo.com/bar');\n-      });\n-    });\n-\n-    describe('relative base url', () => {\n-      it('should add a relative path to the base url', () => {\n-        expect(resolver.resolve('foo/', './bar')).toEqual('foo/bar');\n-        expect(resolver.resolve('foo/baz', './bar')).toEqual('foo/bar');\n-        expect(resolver.resolve('foo/baz', 'bar')).toEqual('foo/bar');\n-      });\n-\n-      it('should support \"..\" in the path', () => {\n-        expect(resolver.resolve('foo/baz', '../bar')).toEqual('bar');\n-        expect(resolver.resolve('foo/baz', '../biz/bar')).toEqual('biz/bar');\n-      });\n-\n-      it('should support absolute urls', () => {\n-        expect(resolver.resolve('foo/baz', '/bar')).toEqual('/bar');\n-        expect(resolver.resolve('foo/baz/', '/bar')).toEqual('/bar');\n-      });\n-\n-      it('should not resolve urls against the baseUrl when the url contains a scheme', () => {\n-        resolver = new UrlResolver('my_packages_dir');\n-        expect(resolver.resolve('base/', 'package:file')).toEqual('my_packages_dir/file');\n-        expect(resolver.resolve('base/', 'http:super_file')).toEqual('http:super_file');\n-        expect(resolver.resolve('base/', './mega_file')).toEqual('base/mega_file');\n-      });\n-    });\n-\n-    describe('packages', () => {\n-      it('should resolve a url based on the application package', () => {\n-        resolver = new UrlResolver('my_packages_dir');\n-        expect(resolver.resolve(null!, 'package:some/dir/file.txt'))\n-            .toEqual('my_packages_dir/some/dir/file.txt');\n-        expect(resolver.resolve(null!, 'some/dir/file.txt')).toEqual('some/dir/file.txt');\n-      });\n-\n-      // TODO(alxhub): figure out if this test is still relevant, as it fails in Ivy\n-      // since UrlResolver is not part of TestBed.\n-      xit('should contain a default value of \"/\" when nothing is provided',\n-          inject([UrlResolver], (resolver: UrlResolver) => {\n-            expect(resolver.resolve(null!, 'package:file')).toEqual('/file');\n-          }));\n-\n-      it('should resolve a package value when present within the baseurl', () => {\n-        resolver = new UrlResolver('/my_special_dir');\n-        expect(resolver.resolve('package:some_dir/', 'matias.html'))\n-            .toEqual('/my_special_dir/some_dir/matias.html');\n-      });\n-    });\n-\n-    describe('corner and error cases', () => {\n-      it('should encode URLs before resolving',\n-         () => {\n-           expect(resolver.resolve('foo/baz', `<p #p>Hello\n-        </p>`)).toEqual('foo/%3Cp%20#p%3EHello%0A%20%20%20%20%20%20%20%20%3C/p%3E');\n-         });\n-    });\n-  });\n-}"
        },
        {
            "sha": "990e9a9e879d0265ba130f396c1fa8b46d82d72c",
            "filename": "packages/core/test/linker/change_detection_integration_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 5,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcore%2Ftest%2Flinker%2Fchange_detection_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fcore%2Ftest%2Flinker%2Fchange_detection_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Flinker%2Fchange_detection_integration_spec.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {ResourceLoader, UrlResolver} from '@angular/compiler';\n+import {ResourceLoader} from '@angular/compiler';\n import {AfterContentChecked, AfterContentInit, AfterViewChecked, AfterViewInit, ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, DebugElement, Directive, DoCheck, EventEmitter, HostBinding, Injectable, Input, OnChanges, OnDestroy, OnInit, Output, Pipe, PipeTransform, Provider, RendererFactory2, RendererType2, SimpleChange, SimpleChanges, TemplateRef, Type, ViewChild, ViewContainerRef} from '@angular/core';\n import {ComponentFixture, fakeAsync, TestBed} from '@angular/core/testing';\n import {By} from '@angular/platform-browser/src/dom/debug/by';\n@@ -15,13 +15,9 @@ import {expect} from '@angular/platform-browser/testing/src/matchers';\n \n import {MockResourceLoader} from './resource_loader_mock';\n \n-export function createUrlResolverWithoutPackagePrefix(): UrlResolver {\n-  return new UrlResolver();\n-}\n \n const TEST_COMPILER_PROVIDERS: Provider[] = [\n   {provide: ResourceLoader, useClass: MockResourceLoader, deps: []},\n-  {provide: UrlResolver, useFactory: createUrlResolverWithoutPackagePrefix, deps: []}\n ];\n \n "
        },
        {
            "sha": "0ca85ef1555f9ed0c2efce91627a853a155f17a2",
            "filename": "packages/examples/compiler/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 13,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fexamples%2Fcompiler%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fexamples%2Fcompiler%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fexamples%2Fcompiler%2FBUILD.bazel?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,13 +0,0 @@\n-package(default_visibility = [\"//visibility:public\"])\n-\n-load(\"//tools:defaults.bzl\", \"ng_module\")\n-\n-ng_module(\n-    name = \"compiler_examples\",\n-    srcs = glob([\"**/*.ts\"]),\n-    deps = [\n-        \"//packages/core\",\n-        \"//packages/platform-browser\",\n-        \"//packages/platform-browser-dynamic\",\n-    ],\n-)"
        },
        {
            "sha": "b4ea8a30affd9752933986cd62dad66caa98a2be",
            "filename": "packages/examples/compiler/ts/url_resolver/url_resolver.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 38,
            "changes": 38,
            "blob_url": "https://github.com/angular/angular/blob/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fexamples%2Fcompiler%2Fts%2Furl_resolver%2Furl_resolver.ts",
            "raw_url": "https://github.com/angular/angular/raw/433a9569b9e5109ffdfa3cee1d999714ada8174c/packages%2Fexamples%2Fcompiler%2Fts%2Furl_resolver%2Furl_resolver.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fexamples%2Fcompiler%2Fts%2Furl_resolver%2Furl_resolver.ts?ref=433a9569b9e5109ffdfa3cee1d999714ada8174c",
            "patch": "@@ -1,38 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {UrlResolver} from '@angular/compiler';\n-import {Component, NgModule} from '@angular/core';\n-import {BrowserModule} from '@angular/platform-browser';\n-import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';\n-\n-@Component({selector: 'app-root', template: 'empty'})\n-class MyApp {\n-}\n-\n-class MyUrlResolver extends UrlResolver {\n-  override resolve(baseUrl: string, url: string): string {\n-    // Serve CSS files from a special CDN.\n-    if (url.substr(-4) === '.css') {\n-      return super.resolve('http://cdn.myapp.com/css/', url);\n-    }\n-    return super.resolve(baseUrl, url);\n-  }\n-}\n-\n-@NgModule({\n-  imports: [BrowserModule],\n-  providers: [{provide: UrlResolver, useClass: MyUrlResolver}],\n-  bootstrap: [MyApp]\n-})\n-class AppModule {\n-}\n-\n-export function main() {\n-  platformBrowserDynamic().bootstrapModule(AppModule);\n-}"
        },
        {
            "sha": "ef681353b7e6dc3a9def68126ae0884f645680b3",
            "filename": "packages/platform-browser-dynamic/test/resource_loader/resource_loader_cache_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 9,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fplatform-browser-dynamic%2Ftest%2Fresource_loader%2Fresource_loader_cache_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/43db24302c69dedd24e4ee49e00273f33840b530/packages%2Fplatform-browser-dynamic%2Ftest%2Fresource_loader%2Fresource_loader_cache_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fplatform-browser-dynamic%2Ftest%2Fresource_loader%2Fresource_loader_cache_spec.ts?ref=43db24302c69dedd24e4ee49e00273f33840b530",
            "patch": "@@ -6,7 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {UrlResolver} from '@angular/compiler';\n import {Component} from '@angular/core';\n import {fakeAsync, TestBed, tick, waitForAsync} from '@angular/core/testing';\n import {CachedResourceLoader} from '@angular/platform-browser-dynamic/src/resource_loader/resource_loader_cache';\n@@ -67,11 +66,3 @@ if (isBrowser) {\n        }));\n   });\n }\n-\n-class TestUrlResolver extends UrlResolver {\n-  override resolve(baseUrl: string, url: string): string {\n-    // Don't use baseUrl to get the same URL as templateUrl.\n-    // This is to remove any difference between Dart and TS tests.\n-    return url;\n-  }\n-}"
        }
    ],
    "stats": {
        "total": 16365,
        "additions": 188,
        "deletions": 16177
    }
}