{
    "author": "gkalpak",
    "message": "test(service-worker): make mock implementations more similar to actual ones (#37922)\n\nThis commit makes the mock implementations used is ServiceWorker tests\nbehave more similar to the actual ones.\n\nPR Close #37922",
    "sha": "667aba7508c2772356ed252dff99018a7c07d861",
    "files": [
        {
            "sha": "9be5bf14c6479b1bda9cfe25318596f2e01291ad",
            "filename": "packages/service-worker/worker/test/happy_spec.ts",
            "status": "modified",
            "additions": 150,
            "deletions": 88,
            "changes": 238,
            "blob_url": "https://github.com/angular/angular/blob/667aba7508c2772356ed252dff99018a7c07d861/packages%2Fservice-worker%2Fworker%2Ftest%2Fhappy_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/667aba7508c2772356ed252dff99018a7c07d861/packages%2Fservice-worker%2Fworker%2Ftest%2Fhappy_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Ftest%2Fhappy_spec.ts?ref=667aba7508c2772356ed252dff99018a7c07d861",
            "patch": "@@ -13,7 +13,7 @@ import {AssetGroupConfig, DataGroupConfig, Manifest} from '../src/manifest';\n import {sha1} from '../src/sha1';\n import {clearAllCaches, MockCache} from '../testing/cache';\n import {MockRequest, MockResponse} from '../testing/fetch';\n-import {MockFileSystemBuilder, MockServerStateBuilder, tmpHashTableForFs} from '../testing/mock';\n+import {MockFileSystem, MockFileSystemBuilder, MockServerStateBuilder, tmpHashTableForFs} from '../testing/mock';\n import {SwTestHarness, SwTestHarnessBuilder} from '../testing/scope';\n \n (function() {\n@@ -352,7 +352,7 @@ describe('Driver', () => {\n     await scope.resolveSelfMessages();\n     scope.autoAdvanceTime = false;\n \n-    server.assertSawRequestFor('ngsw.json');\n+    server.assertSawRequestFor('/ngsw.json');\n     server.assertSawRequestFor('/foo.txt');\n     server.assertSawRequestFor('/bar.txt');\n     server.assertSawRequestFor('/redirected.txt');\n@@ -364,7 +364,7 @@ describe('Driver', () => {\n   it('initializes prefetched content correctly, after a request kicks it off', async () => {\n     expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');\n     await driver.initialized;\n-    server.assertSawRequestFor('ngsw.json');\n+    server.assertSawRequestFor('/ngsw.json');\n     server.assertSawRequestFor('/foo.txt');\n     server.assertSawRequestFor('/bar.txt');\n     server.assertSawRequestFor('/redirected.txt');\n@@ -381,7 +381,7 @@ describe('Driver', () => {\n     // Making a request initializes the driver (fetches assets).\n     expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');\n     expect(driver['latestHash']).toEqual(jasmine.any(String));\n-    server.assertSawRequestFor('ngsw.json');\n+    server.assertSawRequestFor('/ngsw.json');\n     server.assertSawRequestFor('/foo.txt');\n     server.assertSawRequestFor('/bar.txt');\n     server.assertSawRequestFor('/redirected.txt');\n@@ -400,7 +400,7 @@ describe('Driver', () => {\n     // Pushing a message initializes the driver (fetches assets).\n     await scope.handleMessage({action: 'foo'}, 'someClient');\n     expect(driver['latestHash']).toEqual(jasmine.any(String));\n-    server.assertSawRequestFor('ngsw.json');\n+    server.assertSawRequestFor('/ngsw.json');\n     server.assertSawRequestFor('/foo.txt');\n     server.assertSawRequestFor('/bar.txt');\n     server.assertSawRequestFor('/redirected.txt');\n@@ -466,7 +466,7 @@ describe('Driver', () => {\n \n     scope.updateServerState(serverUpdate);\n     expect(await driver.checkForUpdate()).toEqual(true);\n-    serverUpdate.assertSawRequestFor('ngsw.json');\n+    serverUpdate.assertSawRequestFor('/ngsw.json');\n     serverUpdate.assertSawRequestFor('/foo.txt');\n     serverUpdate.assertSawRequestFor('/redirected.txt');\n     serverUpdate.assertNoOtherRequests();\n@@ -562,7 +562,7 @@ describe('Driver', () => {\n     scope.advance(12000);\n     await driver.idle.empty;\n \n-    serverUpdate.assertSawRequestFor('ngsw.json');\n+    serverUpdate.assertSawRequestFor('/ngsw.json');\n     serverUpdate.assertSawRequestFor('/foo.txt');\n     serverUpdate.assertSawRequestFor('/redirected.txt');\n     serverUpdate.assertNoOtherRequests();\n@@ -578,7 +578,7 @@ describe('Driver', () => {\n     scope.advance(12000);\n     await driver.idle.empty;\n \n-    server.assertSawRequestFor('ngsw.json');\n+    server.assertSawRequestFor('/ngsw.json');\n   });\n \n   it('does not make concurrent checks for updates on navigation', async () => {\n@@ -593,7 +593,7 @@ describe('Driver', () => {\n     scope.advance(12000);\n     await driver.idle.empty;\n \n-    server.assertSawRequestFor('ngsw.json');\n+    server.assertSawRequestFor('/ngsw.json');\n     server.assertNoOtherRequests();\n   });\n \n@@ -791,70 +791,75 @@ describe('Driver', () => {\n   });\n \n   it('should bypass serviceworker on ngsw-bypass parameter', async () => {\n-    await makeRequest(scope, '/foo.txt', undefined, {headers: {'ngsw-bypass': 'true'}});\n-    server.assertNoRequestFor('/foo.txt');\n+    // NOTE:\n+    // Requests that bypass the SW are not handled at all in the mock implementation of `scope`,\n+    // therefore no requests reach the server.\n \n-    await makeRequest(scope, '/foo.txt', undefined, {headers: {'ngsw-bypass': 'anything'}});\n-    server.assertNoRequestFor('/foo.txt');\n+    await makeRequest(scope, '/some/url', undefined, {headers: {'ngsw-bypass': 'true'}});\n+    server.assertNoRequestFor('/some/url');\n \n-    await makeRequest(scope, '/foo.txt', undefined, {headers: {'ngsw-bypass': null!}});\n-    server.assertNoRequestFor('/foo.txt');\n+    await makeRequest(scope, '/some/url', undefined, {headers: {'ngsw-bypass': 'anything'}});\n+    server.assertNoRequestFor('/some/url');\n \n-    await makeRequest(scope, '/foo.txt', undefined, {headers: {'NGSW-bypass': 'upperCASE'}});\n-    server.assertNoRequestFor('/foo.txt');\n+    await makeRequest(scope, '/some/url', undefined, {headers: {'ngsw-bypass': null!}});\n+    server.assertNoRequestFor('/some/url');\n \n-    await makeRequest(scope, '/foo.txt', undefined, {headers: {'ngsw-bypasss': 'anything'}});\n-    server.assertSawRequestFor('/foo.txt');\n+    await makeRequest(scope, '/some/url', undefined, {headers: {'NGSW-bypass': 'upperCASE'}});\n+    server.assertNoRequestFor('/some/url');\n+\n+    await makeRequest(scope, '/some/url', undefined, {headers: {'ngsw-bypasss': 'anything'}});\n+    server.assertSawRequestFor('/some/url');\n \n     server.clearRequests();\n \n-    await makeRequest(scope, '/bar.txt?ngsw-bypass=true');\n-    server.assertNoRequestFor('/bar.txt');\n+    await makeRequest(scope, '/some/url?ngsw-bypass=true');\n+    server.assertNoRequestFor('/some/url');\n \n-    await makeRequest(scope, '/bar.txt?ngsw-bypasss=true');\n-    server.assertSawRequestFor('/bar.txt');\n+    await makeRequest(scope, '/some/url?ngsw-bypasss=true');\n+    server.assertSawRequestFor('/some/url');\n \n     server.clearRequests();\n \n-    await makeRequest(scope, '/bar.txt?ngsw-bypaSS=something');\n-    server.assertNoRequestFor('/bar.txt');\n+    await makeRequest(scope, '/some/url?ngsw-bypaSS=something');\n+    server.assertNoRequestFor('/some/url');\n \n-    await makeRequest(scope, '/bar.txt?testparam=test&ngsw-byPASS=anything');\n-    server.assertNoRequestFor('/bar.txt');\n+    await makeRequest(scope, '/some/url?testparam=test&ngsw-byPASS=anything');\n+    server.assertNoRequestFor('/some/url');\n \n-    await makeRequest(scope, '/bar.txt?testparam=test&angsw-byPASS=anything');\n-    server.assertSawRequestFor('/bar.txt');\n+    await makeRequest(scope, '/some/url?testparam=test&angsw-byPASS=anything');\n+    server.assertSawRequestFor('/some/url');\n \n     server.clearRequests();\n \n-    await makeRequest(scope, '/bar&ngsw-bypass=true.txt?testparam=test&angsw-byPASS=anything');\n-    server.assertSawRequestFor('/bar&ngsw-bypass=true.txt');\n+    await makeRequest(scope, '/some/url&ngsw-bypass=true.txt?testparam=test&angsw-byPASS=anything');\n+    server.assertSawRequestFor('/some/url&ngsw-bypass=true.txt');\n \n     server.clearRequests();\n \n-    await makeRequest(scope, '/bar&ngsw-bypass=true.txt');\n-    server.assertSawRequestFor('/bar&ngsw-bypass=true.txt');\n+    await makeRequest(scope, '/some/url&ngsw-bypass=true.txt');\n+    server.assertSawRequestFor('/some/url&ngsw-bypass=true.txt');\n \n     server.clearRequests();\n \n     await makeRequest(\n-        scope, '/bar&ngsw-bypass=true.txt?testparam=test&ngSW-BYPASS=SOMETHING&testparam2=test');\n-    server.assertNoRequestFor('/bar&ngsw-bypass=true.txt');\n+        scope,\n+        '/some/url&ngsw-bypass=true.txt?testparam=test&ngSW-BYPASS=SOMETHING&testparam2=test');\n+    server.assertNoRequestFor('/some/url&ngsw-bypass=true.txt');\n \n-    await makeRequest(scope, '/bar?testparam=test&ngsw-bypass');\n-    server.assertNoRequestFor('/bar');\n+    await makeRequest(scope, '/some/url?testparam=test&ngsw-bypass');\n+    server.assertNoRequestFor('/some/url');\n \n-    await makeRequest(scope, '/bar?testparam=test&ngsw-bypass&testparam2');\n-    server.assertNoRequestFor('/bar');\n+    await makeRequest(scope, '/some/url?testparam=test&ngsw-bypass&testparam2');\n+    server.assertNoRequestFor('/some/url');\n \n-    await makeRequest(scope, '/bar?ngsw-bypass&testparam2');\n-    server.assertNoRequestFor('/bar');\n+    await makeRequest(scope, '/some/url?ngsw-bypass&testparam2');\n+    server.assertNoRequestFor('/some/url');\n \n-    await makeRequest(scope, '/bar?ngsw-bypass=&foo=ngsw-bypass');\n-    server.assertNoRequestFor('/bar');\n+    await makeRequest(scope, '/some/url?ngsw-bypass=&foo=ngsw-bypass');\n+    server.assertNoRequestFor('/some/url');\n \n-    await makeRequest(scope, '/bar?ngsw-byapass&testparam2');\n-    server.assertSawRequestFor('/bar');\n+    await makeRequest(scope, '/some/url?ngsw-byapass&testparam2');\n+    server.assertSawRequestFor('/some/url');\n   });\n \n   it('unregisters when manifest 404s', async () => {\n@@ -922,115 +927,172 @@ describe('Driver', () => {\n   });\n \n   describe('cache naming', () => {\n+    let uid: number;\n+\n     // Helpers\n-    const cacheKeysFor = (baseHref: string) =>\n+    const cacheKeysFor = (baseHref: string, manifestHash: string) =>\n         [`ngsw:${baseHref}:db:control`,\n-         `ngsw:${baseHref}:${manifestHash}:assets:assets:cache`,\n-         `ngsw:${baseHref}:db:ngsw:${baseHref}:${manifestHash}:assets:assets:meta`,\n-         `ngsw:${baseHref}:${manifestHash}:assets:other:cache`,\n-         `ngsw:${baseHref}:db:ngsw:${baseHref}:${manifestHash}:assets:other:meta`,\n-         `ngsw:${baseHref}:${manifestHash}:assets:lazy_prefetch:cache`,\n-         `ngsw:${baseHref}:db:ngsw:${baseHref}:${manifestHash}:assets:lazy_prefetch:meta`,\n+         `ngsw:${baseHref}:${manifestHash}:assets:eager:cache`,\n+         `ngsw:${baseHref}:db:ngsw:${baseHref}:${manifestHash}:assets:eager:meta`,\n+         `ngsw:${baseHref}:${manifestHash}:assets:lazy:cache`,\n+         `ngsw:${baseHref}:db:ngsw:${baseHref}:${manifestHash}:assets:lazy:meta`,\n          `ngsw:${baseHref}:42:data:dynamic:api:cache`,\n          `ngsw:${baseHref}:db:ngsw:${baseHref}:42:data:dynamic:api:lru`,\n          `ngsw:${baseHref}:db:ngsw:${baseHref}:42:data:dynamic:api:age`,\n-         `ngsw:${baseHref}:43:data:dynamic:api-static:cache`,\n-         `ngsw:${baseHref}:db:ngsw:${baseHref}:43:data:dynamic:api-static:lru`,\n-         `ngsw:${baseHref}:db:ngsw:${baseHref}:43:data:dynamic:api-static:age`,\n     ];\n \n+    const createManifestWithBaseHref = (baseHref: string, distDir: MockFileSystem): Manifest => ({\n+      configVersion: 1,\n+      timestamp: 1234567890123,\n+      index: `${baseHref}foo.txt`,\n+      assetGroups: [\n+        {\n+          name: 'eager',\n+          installMode: 'prefetch',\n+          updateMode: 'prefetch',\n+          urls: [\n+            `${baseHref}foo.txt`,\n+            `${baseHref}bar.txt`,\n+          ],\n+          patterns: [],\n+          cacheQueryOptions: {ignoreVary: true},\n+        },\n+        {\n+          name: 'lazy',\n+          installMode: 'lazy',\n+          updateMode: 'lazy',\n+          urls: [\n+            `${baseHref}baz.txt`,\n+            `${baseHref}qux.txt`,\n+          ],\n+          patterns: [],\n+          cacheQueryOptions: {ignoreVary: true},\n+        },\n+      ],\n+      dataGroups: [\n+        {\n+          name: 'api',\n+          version: 42,\n+          maxAge: 3600000,\n+          maxSize: 100,\n+          strategy: 'freshness',\n+          patterns: [\n+            '/api/.*',\n+          ],\n+          cacheQueryOptions: {ignoreVary: true},\n+        },\n+      ],\n+      navigationUrls: processNavigationUrls(baseHref),\n+      hashTable: tmpHashTableForFs(distDir, {}, baseHref),\n+    });\n+\n     const getClientAssignments = async (sw: SwTestHarness, baseHref: string) => {\n       const cache = await sw.caches.open(`ngsw:${baseHref}:db:control`) as unknown as MockCache;\n       const dehydrated = cache.dehydrate();\n       return JSON.parse(dehydrated['/assignments'].body!);\n     };\n \n-    const initializeSwFor =\n-        async (baseHref: string, initialCacheState = '{}', serverState = server) => {\n+    const initializeSwFor = async (baseHref: string, initialCacheState = '{}') => {\n+      const newDistDir = dist.extend().addFile('/foo.txt', `this is foo v${++uid}`).build();\n+      const newManifest = createManifestWithBaseHref(baseHref, newDistDir);\n+      const newManifestHash = sha1(JSON.stringify(newManifest));\n+\n+      const serverState = new MockServerStateBuilder()\n+                              .withRootDirectory(baseHref)\n+                              .withStaticFiles(newDistDir)\n+                              .withManifest(newManifest)\n+                              .build();\n+\n       const newScope = new SwTestHarnessBuilder(`http://localhost${baseHref}`)\n                            .withCacheState(initialCacheState)\n                            .withServerState(serverState)\n                            .build();\n       const newDriver = new Driver(newScope, newScope, new CacheDatabase(newScope, newScope));\n \n-      await makeRequest(newScope, '/foo.txt', baseHref.replace(/\\//g, '_'));\n+      await makeRequest(newScope, newManifest.index, baseHref.replace(/\\//g, '_'));\n       await newDriver.initialized;\n \n-      return newScope;\n+      return [newScope, newManifestHash] as [SwTestHarness, string];\n     };\n \n+    beforeEach(() => {\n+      uid = 0;\n+    });\n+\n     it('includes the SW scope in all cache names', async () => {\n-      // Default SW with scope `/`.\n-      await makeRequest(scope, '/foo.txt');\n-      await driver.initialized;\n-      const cacheNames = await scope.caches.keys();\n+      // SW with scope `/`.\n+      const [rootScope, rootManifestHash] = await initializeSwFor('/');\n+      const cacheNames = await rootScope.caches.keys();\n \n-      expect(cacheNames).toEqual(cacheKeysFor('/'));\n+      expect(cacheNames).toEqual(cacheKeysFor('/', rootManifestHash));\n       expect(cacheNames.every(name => name.includes('/'))).toBe(true);\n \n       // SW with scope `/foo/`.\n-      const fooScope = await initializeSwFor('/foo/');\n+      const [fooScope, fooManifestHash] = await initializeSwFor('/foo/');\n       const fooCacheNames = await fooScope.caches.keys();\n \n-      expect(fooCacheNames).toEqual(cacheKeysFor('/foo/'));\n+      expect(fooCacheNames).toEqual(cacheKeysFor('/foo/', fooManifestHash));\n       expect(fooCacheNames.every(name => name.includes('/foo/'))).toBe(true);\n     });\n \n     it('does not affect caches from other scopes', async () => {\n       // Create SW with scope `/foo/`.\n-      const fooScope = await initializeSwFor('/foo/');\n+      const [fooScope, fooManifestHash] = await initializeSwFor('/foo/');\n       const fooAssignments = await getClientAssignments(fooScope, '/foo/');\n \n-      expect(fooAssignments).toEqual({_foo_: manifestHash});\n+      expect(fooAssignments).toEqual({_foo_: fooManifestHash});\n \n       // Add new SW with different scope.\n-      const barScope = await initializeSwFor('/bar/', await fooScope.caches.dehydrate());\n+      const [barScope, barManifestHash] =\n+          await initializeSwFor('/bar/', await fooScope.caches.dehydrate());\n       const barCacheNames = await barScope.caches.keys();\n       const barAssignments = await getClientAssignments(barScope, '/bar/');\n \n-      expect(barAssignments).toEqual({_bar_: manifestHash});\n+      expect(barAssignments).toEqual({_bar_: barManifestHash});\n       expect(barCacheNames).toEqual([\n-        ...cacheKeysFor('/foo/'),\n-        ...cacheKeysFor('/bar/'),\n+        ...cacheKeysFor('/foo/', fooManifestHash),\n+        ...cacheKeysFor('/bar/', barManifestHash),\n       ]);\n \n       // The caches for `/foo/` should be intact.\n       const fooAssignments2 = await getClientAssignments(barScope, '/foo/');\n-      expect(fooAssignments2).toEqual({_foo_: manifestHash});\n+      expect(fooAssignments2).toEqual({_foo_: fooManifestHash});\n     });\n \n     it('updates existing caches for same scope', async () => {\n       // Create SW with scope `/foo/`.\n-      const fooScope = await initializeSwFor('/foo/');\n-      await makeRequest(fooScope, '/foo.txt', '_bar_');\n+      const [fooScope, fooManifestHash] = await initializeSwFor('/foo/');\n+      await makeRequest(fooScope, '/foo/foo.txt', '_bar_');\n       const fooAssignments = await getClientAssignments(fooScope, '/foo/');\n \n       expect(fooAssignments).toEqual({\n-        _foo_: manifestHash,\n-        _bar_: manifestHash,\n+        _foo_: fooManifestHash,\n+        _bar_: fooManifestHash,\n       });\n \n-      expect(await makeRequest(fooScope, '/baz.txt', '_foo_')).toBe('this is baz');\n-      expect(await makeRequest(fooScope, '/baz.txt', '_bar_')).toBe('this is baz');\n+      expect(await makeRequest(fooScope, '/foo/baz.txt', '_foo_')).toBe('this is baz');\n+      expect(await makeRequest(fooScope, '/foo/baz.txt', '_bar_')).toBe('this is baz');\n \n       // Add new SW with same scope.\n-      const fooScope2 =\n-          await initializeSwFor('/foo/', await fooScope.caches.dehydrate(), serverUpdate);\n+      const [fooScope2, fooManifestHash2] =\n+          await initializeSwFor('/foo/', await fooScope.caches.dehydrate());\n+\n+      // Update client `_foo_` but not client `_bar_`.\n       await fooScope2.handleMessage({action: 'CHECK_FOR_UPDATES'}, '_foo_');\n       await fooScope2.handleMessage({action: 'ACTIVATE_UPDATE'}, '_foo_');\n       const fooAssignments2 = await getClientAssignments(fooScope2, '/foo/');\n \n       expect(fooAssignments2).toEqual({\n-        _foo_: manifestUpdateHash,\n-        _bar_: manifestHash,\n+        _foo_: fooManifestHash2,\n+        _bar_: fooManifestHash,\n       });\n \n       // Everything should still work as expected.\n-      expect(await makeRequest(fooScope2, '/foo.txt', '_foo_')).toBe('this is foo v2');\n-      expect(await makeRequest(fooScope2, '/foo.txt', '_bar_')).toBe('this is foo');\n+      expect(await makeRequest(fooScope2, '/foo/foo.txt', '_foo_')).toBe('this is foo v2');\n+      expect(await makeRequest(fooScope2, '/foo/foo.txt', '_bar_')).toBe('this is foo v1');\n \n-      expect(await makeRequest(fooScope2, '/baz.txt', '_foo_')).toBe('this is baz v2');\n-      expect(await makeRequest(fooScope2, '/baz.txt', '_bar_')).toBe('this is baz');\n+      expect(await makeRequest(fooScope2, '/foo/baz.txt', '_foo_')).toBe('this is baz');\n+      expect(await makeRequest(fooScope2, '/foo/baz.txt', '_bar_')).toBe('this is baz');\n     });\n   });\n \n@@ -1154,7 +1216,7 @@ describe('Driver', () => {\n       server.assertNoOtherRequests();\n     });\n \n-    it('redirects to index on a request to the origin URL request', async () => {\n+    it('redirects to index on a request to the scope URL', async () => {\n       expect(await navRequest('http://localhost/')).toEqual('this is foo');\n       server.assertNoOtherRequests();\n     });"
        },
        {
            "sha": "9f2d9824d7f36084fe04c7e03f815fd6d7a90f6d",
            "filename": "packages/service-worker/worker/testing/cache.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 9,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/667aba7508c2772356ed252dff99018a7c07d861/packages%2Fservice-worker%2Fworker%2Ftesting%2Fcache.ts",
            "raw_url": "https://github.com/angular/angular/raw/667aba7508c2772356ed252dff99018a7c07d861/packages%2Fservice-worker%2Fworker%2Ftesting%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Ftesting%2Fcache.ts?ref=667aba7508c2772356ed252dff99018a7c07d861",
            "patch": "@@ -6,7 +6,8 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {MockRequest, MockResponse} from './fetch';\n+import {MockResponse} from './fetch';\n+import {normalizeUrl} from './utils';\n \n export interface DehydratedResponse {\n   body: string|null;\n@@ -104,7 +105,7 @@ export class MockCache {\n   }\n \n   async 'delete'(request: RequestInfo, options?: CacheQueryOptions): Promise<boolean> {\n-    let url = (typeof request === 'string' ? request : request.url);\n+    let url = this.getRequestUrl(request);\n     if (this.cache.has(url)) {\n       this.cache.delete(url);\n       return true;\n@@ -127,10 +128,7 @@ export class MockCache {\n   }\n \n   async match(request: RequestInfo, options?: CacheQueryOptions): Promise<Response> {\n-    let url = (typeof request === 'string' ? request : request.url);\n-    if (url.startsWith(this.origin)) {\n-      url = '/' + url.substr(this.origin.length);\n-    }\n+    let url = this.getRequestUrl(request);\n     // TODO: cleanup typings. Typescript doesn't know this can resolve to undefined.\n     let res = this.cache.get(url);\n     if (!res && options?.ignoreSearch) {\n@@ -150,8 +148,7 @@ export class MockCache {\n     if (request === undefined) {\n       return Array.from(this.cache.values());\n     }\n-    const url = (typeof request === 'string' ? request : request.url);\n-    const res = await this.match(url, options);\n+    const res = await this.match(request, options);\n     if (res) {\n       return [res];\n     } else {\n@@ -160,7 +157,7 @@ export class MockCache {\n   }\n \n   async put(request: RequestInfo, response: Response): Promise<void> {\n-    const url = (typeof request === 'string' ? request : request.url);\n+    const url = this.getRequestUrl(request);\n     this.cache.set(url, response.clone());\n \n     // Even though the body above is cloned, consume it here because the\n@@ -190,6 +187,12 @@ export class MockCache {\n     return dehydrated;\n   }\n \n+  /** Get the normalized URL from a `RequestInfo` value. */\n+  private getRequestUrl(request: RequestInfo): string {\n+    const url = typeof request === 'string' ? request : request.url;\n+    return normalizeUrl(url, this.origin);\n+  }\n+\n   /** remove the query/hash part from a url*/\n   private stripQueryAndHash(url: string): string {\n     return url.replace(/[?#].*/, '');"
        },
        {
            "sha": "8b51e38ad4ae5dc8537db4fd95d0665dd1667e0c",
            "filename": "packages/service-worker/worker/testing/mock.ts",
            "status": "modified",
            "additions": 41,
            "deletions": 12,
            "changes": 53,
            "blob_url": "https://github.com/angular/angular/blob/667aba7508c2772356ed252dff99018a7c07d861/packages%2Fservice-worker%2Fworker%2Ftesting%2Fmock.ts",
            "raw_url": "https://github.com/angular/angular/raw/667aba7508c2772356ed252dff99018a7c07d861/packages%2Fservice-worker%2Fworker%2Ftesting%2Fmock.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Ftesting%2Fmock.ts?ref=667aba7508c2772356ed252dff99018a7c07d861",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AssetGroupConfig, Manifest} from '../src/manifest';\n+import {Manifest} from '../src/manifest';\n import {sha1} from '../src/sha1';\n \n import {MockResponse} from './fetch';\n@@ -69,19 +69,38 @@ export class MockFileSystem {\n }\n \n export class MockServerStateBuilder {\n+  private rootDir = '/';\n   private resources = new Map<string, Response>();\n   private errors = new Set<string>();\n \n-  withStaticFiles(fs: MockFileSystem): MockServerStateBuilder {\n-    fs.list().forEach(path => {\n-      const file = fs.lookup(path)!;\n-      this.resources.set(path, new MockResponse(file.contents, {headers: file.headers}));\n+  withRootDirectory(newRootDir: string): MockServerStateBuilder {\n+    // Update existing resources/errors.\n+    const oldRootDir = this.rootDir;\n+    const updateRootDir = (path: string) =>\n+        path.startsWith(oldRootDir) ? joinPaths(newRootDir, path.slice(oldRootDir.length)) : path;\n+\n+    this.resources = new Map(\n+        [...this.resources].map(([path, contents]) => [updateRootDir(path), contents.clone()]));\n+    this.errors = new Set([...this.errors].map(url => updateRootDir(url)));\n+\n+    // Set `rootDir` for future resource/error additions.\n+    this.rootDir = newRootDir;\n+\n+    return this;\n+  }\n+\n+  withStaticFiles(dir: MockFileSystem): MockServerStateBuilder {\n+    dir.list().forEach(path => {\n+      const file = dir.lookup(path)!;\n+      this.resources.set(\n+          joinPaths(this.rootDir, path), new MockResponse(file.contents, {headers: file.headers}));\n     });\n     return this;\n   }\n \n   withManifest(manifest: Manifest): MockServerStateBuilder {\n-    this.resources.set('ngsw.json', new MockResponse(JSON.stringify(manifest)));\n+    const manifestPath = joinPaths(this.rootDir, 'ngsw.json');\n+    this.resources.set(manifestPath, new MockResponse(JSON.stringify(manifest)));\n     return this;\n   }\n \n@@ -234,14 +253,16 @@ export function tmpManifestSingleAssetGroup(fs: MockFileSystem): Manifest {\n }\n \n export function tmpHashTableForFs(\n-    fs: MockFileSystem, breakHashes: {[url: string]: boolean} = {}): {[url: string]: string} {\n+    fs: MockFileSystem, breakHashes: {[url: string]: boolean} = {},\n+    baseHref = '/'): {[url: string]: string} {\n   const table: {[url: string]: string} = {};\n-  fs.list().forEach(path => {\n-    const file = fs.lookup(path)!;\n+  fs.list().forEach(filePath => {\n+    const urlPath = joinPaths(baseHref, filePath);\n+    const file = fs.lookup(filePath)!;\n     if (file.hashThisFile) {\n-      table[path] = file.hash;\n-      if (breakHashes[path]) {\n-        table[path] = table[path].split('').reverse().join('');\n+      table[urlPath] = file.hash;\n+      if (breakHashes[filePath]) {\n+        table[urlPath] = table[urlPath].split('').reverse().join('');\n       }\n     }\n   });\n@@ -256,3 +277,11 @@ export function tmpHashTable(manifest: Manifest): Map<string, string> {\n   });\n   return map;\n }\n+\n+// Helpers\n+/**\n+ * Join two path segments, ensuring that there is exactly one slash (`/`) between them.\n+ */\n+function joinPaths(path1: string, path2: string): string {\n+  return `${path1.replace(/\\/$/, '')}/${path2.replace(/^\\//, '')}`;\n+}"
        },
        {
            "sha": "44df03a2edbe00da700a0a440a4559121d39d2a7",
            "filename": "packages/service-worker/worker/testing/scope.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 24,
            "changes": 35,
            "blob_url": "https://github.com/angular/angular/blob/667aba7508c2772356ed252dff99018a7c07d861/packages%2Fservice-worker%2Fworker%2Ftesting%2Fscope.ts",
            "raw_url": "https://github.com/angular/angular/raw/667aba7508c2772356ed252dff99018a7c07d861/packages%2Fservice-worker%2Fworker%2Ftesting%2Fscope.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Ftesting%2Fscope.ts?ref=667aba7508c2772356ed252dff99018a7c07d861",
            "patch": "@@ -15,6 +15,7 @@ import {sha1} from '../src/sha1';\n import {MockCacheStorage} from './cache';\n import {MockHeaders, MockRequest, MockResponse} from './fetch';\n import {MockServerState, MockServerStateBuilder} from './mock';\n+import {normalizeUrl, parseUrl} from './utils';\n \n const EMPTY_SERVER_STATE = new MockServerStateBuilder().build();\n \n@@ -32,10 +33,11 @@ export class MockClient {\n }\n \n export class SwTestHarnessBuilder {\n+  private origin = parseUrl(this.scopeUrl).origin;\n   private server = EMPTY_SERVER_STATE;\n   private caches = new MockCacheStorage(this.origin);\n \n-  constructor(private origin = 'http://localhost/') {}\n+  constructor(private scopeUrl = 'http://localhost/') {}\n \n   withCacheState(cache: string): SwTestHarnessBuilder {\n     this.caches = new MockCacheStorage(this.origin, cache);\n@@ -48,7 +50,7 @@ export class SwTestHarnessBuilder {\n   }\n \n   build(): SwTestHarness {\n-    return new SwTestHarness(this.server, this.caches, this.origin);\n+    return new SwTestHarness(this.server, this.caches, this.scopeUrl);\n   }\n }\n \n@@ -137,6 +139,8 @@ export class SwTestHarness extends Adapter implements ServiceWorkerGlobalScope,\n     fired: boolean,\n   }[] = [];\n \n+  parseUrl = parseUrl;\n+\n   constructor(\n       private server: MockServerState, readonly caches: MockCacheStorage, scopeUrl: string) {\n     super(scopeUrl);\n@@ -176,17 +180,12 @@ export class SwTestHarness extends Adapter implements ServiceWorkerGlobalScope,\n     this.server = server || EMPTY_SERVER_STATE;\n   }\n \n-  fetch(req: string|Request): Promise<Response> {\n+  fetch(req: RequestInfo): Promise<Response> {\n     if (typeof req === 'string') {\n-      if (req.startsWith(this.origin)) {\n-        req = '/' + req.substr(this.origin.length);\n-      }\n-      return this.server.fetch(new MockRequest(req));\n+      return this.server.fetch(new MockRequest(normalizeUrl(req, this.scopeUrl)));\n     } else {\n       const mockReq = req.clone() as MockRequest;\n-      if (mockReq.url.startsWith(this.origin)) {\n-        mockReq.url = '/' + mockReq.url.substr(this.origin.length);\n-      }\n+      mockReq.url = normalizeUrl(mockReq.url, this.scopeUrl);\n       return this.server.fetch(mockReq);\n     }\n   }\n@@ -200,7 +199,7 @@ export class SwTestHarness extends Adapter implements ServiceWorkerGlobalScope,\n   }\n \n   newRequest(url: string, init: Object = {}): Request {\n-    return new MockRequest(url, init);\n+    return new MockRequest(normalizeUrl(url, this.scopeUrl), init);\n   }\n \n   newResponse(body: string, init: Object = {}): Response {\n@@ -214,18 +213,6 @@ export class SwTestHarness extends Adapter implements ServiceWorkerGlobalScope,\n     }, new MockHeaders());\n   }\n \n-  parseUrl(url: string, relativeTo?: string): {origin: string, path: string, search: string} {\n-    const parsedUrl: URL = (typeof URL === 'function') ?\n-        (!relativeTo ? new URL(url) : new URL(url, relativeTo)) :\n-        require('url').parse(require('url').resolve(relativeTo || '', url));\n-\n-    return {\n-      origin: parsedUrl.origin || `${parsedUrl.protocol}//${parsedUrl.host}`,\n-      path: parsedUrl.pathname,\n-      search: parsedUrl.search || '',\n-    };\n-  }\n-\n   async skipWaiting(): Promise<void> {\n     this.skippedWaiting = true;\n   }\n@@ -409,6 +396,7 @@ class MockPushEvent extends MockExtendableEvent {\n     json: () => this._data,\n   };\n }\n+\n class MockNotificationEvent extends MockExtendableEvent {\n   constructor(private _notification: any, readonly action?: string) {\n     super();\n@@ -418,5 +406,4 @@ class MockNotificationEvent extends MockExtendableEvent {\n \n class MockInstallEvent extends MockExtendableEvent {}\n \n-\n class MockActivateEvent extends MockExtendableEvent {}"
        },
        {
            "sha": "51be5b4a0d20f328472ae00a737db500cd34cd4a",
            "filename": "packages/service-worker/worker/testing/utils.ts",
            "status": "added",
            "additions": 43,
            "deletions": 0,
            "changes": 43,
            "blob_url": "https://github.com/angular/angular/blob/667aba7508c2772356ed252dff99018a7c07d861/packages%2Fservice-worker%2Fworker%2Ftesting%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/667aba7508c2772356ed252dff99018a7c07d861/packages%2Fservice-worker%2Fworker%2Ftesting%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Ftesting%2Futils.ts?ref=667aba7508c2772356ed252dff99018a7c07d861",
            "patch": "@@ -0,0 +1,43 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+/**\n+ * Get a normalized representation of a URL relative to a provided base URL.\n+ *\n+ * More specifically:\n+ * 1. Resolve the URL relative to the provided base URL.\n+ * 2. If the URL is relative to the base URL, then strip the origin (and only return the path and\n+ *    search parts). Otherwise, return the full URL.\n+ *\n+ * @param url The raw URL.\n+ * @param relativeTo The base URL to resolve `url` relative to.\n+ *     (This is usually the ServiceWorker's origin or registration scope).\n+ * @return A normalized representation of the URL.\n+ */\n+export function normalizeUrl(url: string, relativeTo: string): string {\n+  const {origin, path, search} = parseUrl(url, relativeTo);\n+  const {origin: relativeToOrigin} = parseUrl(relativeTo);\n+\n+  return (origin === relativeToOrigin) ? path + search : url;\n+}\n+\n+/**\n+ * Parse a URL into its different parts, such as `origin`, `path` and `search`.\n+ */\n+export function parseUrl(\n+    url: string, relativeTo?: string): {origin: string, path: string, search: string} {\n+  const parsedUrl: URL = (typeof URL === 'function') ?\n+      (!relativeTo ? new URL(url) : new URL(url, relativeTo)) :\n+      require('url').parse(require('url').resolve(relativeTo || '', url));\n+\n+  return {\n+    origin: parsedUrl.origin || `${parsedUrl.protocol}//${parsedUrl.host}`,\n+    path: parsedUrl.pathname,\n+    search: parsedUrl.search || '',\n+  };\n+}"
        }
    ],
    "stats": {
        "total": 390,
        "additions": 257,
        "deletions": 133
    }
}