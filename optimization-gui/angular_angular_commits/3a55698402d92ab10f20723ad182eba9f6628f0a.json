{
    "author": "AndrewKushnir",
    "message": "fix(core): remove obsolete check for [class] and [className] presence (#41254)\n\nPreviously presence of both [class] and [className] bindings on an element was treated as compiler error (implemented in https://github.com/angular/angular/commit/6f203c9575fe9a2da04529fbdf1e5f7b51e85e09). Later, the situation was improved to actually allow both bindings to co-exist (see https://github.com/angular/angular/commit/a153b610983389de6408f7a723fd5714a11c168e), however the compiler check was not removed completely. The only situation where the error is thrown at this moment is when static (but with interpolation) and bound `class` attributes are present on an element, for ex.:\n\n```\n<div class=\"{{ one }}\" [class]=\"'two'\"></div>\n```\n\nIn the current situation the error is acually misleading (as it refers to `[className]`).\n\nThis commit removes the mentioned compiler check as obsolete and makes the `class` and `style` attribute processing logically the same (the last occurrence is used to compute the value).\n\nPR Close #41254",
    "sha": "3a55698402d92ab10f20723ad182eba9f6628f0a",
    "files": [
        {
            "sha": "c14812e4836cb6d440cf306fb8b1a37f31ebd040",
            "filename": "packages/compiler/src/render3/view/styling_builder.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/3a55698402d92ab10f20723ad182eba9f6628f0a/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fstyling_builder.ts",
            "raw_url": "https://github.com/angular/angular/raw/3a55698402d92ab10f20723ad182eba9f6628f0a/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fstyling_builder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fstyling_builder.ts?ref=3a55698402d92ab10f20723ad182eba9f6628f0a",
            "patch": "@@ -246,10 +246,6 @@ export class StylingBuilder {\n     const entry:\n         BoundStylingEntry = {name: property, value, sourceSpan, hasOverrideFlag, suffix: null};\n     if (isMapBased) {\n-      if (this._classMapInput) {\n-        throw new Error(\n-            '[class] and [className] bindings cannot be used on the same element simultaneously');\n-      }\n       this._classMapInput = entry;\n     } else {\n       (this._singleClassInputs = this._singleClassInputs || []).push(entry);"
        },
        {
            "sha": "a300052077b8ed13c49daf7e79fa5da1ea08b219",
            "filename": "packages/core/test/acceptance/styling_spec.ts",
            "status": "modified",
            "additions": 92,
            "deletions": 29,
            "changes": 121,
            "blob_url": "https://github.com/angular/angular/blob/3a55698402d92ab10f20723ad182eba9f6628f0a/packages%2Fcore%2Ftest%2Facceptance%2Fstyling_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/3a55698402d92ab10f20723ad182eba9f6628f0a/packages%2Fcore%2Ftest%2Facceptance%2Fstyling_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fstyling_spec.ts?ref=3a55698402d92ab10f20723ad182eba9f6628f0a",
            "patch": "@@ -17,6 +17,40 @@ import {expect} from '@angular/platform-browser/testing/src/matchers';\n import {ivyEnabled, modifiedInIvy, onlyInIvy} from '@angular/private/testing';\n \n describe('styling', () => {\n+  /**\n+   * This helper function tests to see if the current browser supports non standard way of writing\n+   * into styles.\n+   *\n+   * This is not the correct way to write to style and is not supported in IE11.\n+   * ```\n+   * div.style = 'color: white';\n+   * ```\n+   *\n+   * This is the correct way to write to styles:\n+   * ```\n+   * div.style.cssText = 'color: white';\n+   * ```\n+   *\n+   * Even though writing to `div.style` is not officially supported, it works in all\n+   * browsers except IE11.\n+   *\n+   * This function detects this condition and allows us to skip affected tests.\n+   */\n+  let _supportsWritingStringsToStyleProperty: boolean|null = null;\n+  function supportsWritingStringsToStyleProperty() {\n+    if (_supportsWritingStringsToStyleProperty === null) {\n+      const div = document.createElement('div');\n+      const CSS = 'color: white;';\n+      try {\n+        (div as any).style = CSS;\n+      } catch (e) {\n+        _supportsWritingStringsToStyleProperty = false;\n+      }\n+      _supportsWritingStringsToStyleProperty = (div.style.cssText === CSS);\n+    }\n+    return _supportsWritingStringsToStyleProperty;\n+  }\n+\n   beforeEach(ngDevModeResetPerfCounters);\n \n   describe('apply in prioritization order', () => {\n@@ -3069,6 +3103,64 @@ describe('styling', () => {\n     expect(fixture.debugElement.nativeElement.innerHTML).toContain('three');\n   });\n \n+  it('should allow static and bound `class` attribute, but use last occurrence', () => {\n+    @Component({\n+      template: `\n+        <div id=\"first\" class=\"zero {{one}}\" [class]=\"'two'\"></div>\n+        <div id=\"second\" [class]=\"'two'\" class=\"zero {{one}}\"></div>\n+      `,\n+    })\n+    class MyComp {\n+      one = 'one';\n+    }\n+\n+    TestBed.configureTestingModule({declarations: [MyComp]});\n+    const fixture = TestBed.createComponent(MyComp);\n+    fixture.detectChanges();\n+\n+    const first = fixture.nativeElement.querySelector('#first').outerHTML;\n+    expect(first).not.toContain('zero');\n+    expect(first).not.toContain('one');\n+    expect(first).toContain('two');\n+\n+    const second = fixture.nativeElement.querySelector('#second').outerHTML;\n+    expect(second).toContain('zero');\n+    expect(second).toContain('one');\n+    expect(second).not.toContain('two');\n+  });\n+\n+  it('should allow static and bound `style` attribute, but use last occurrence', () => {\n+    if (!ivyEnabled && !supportsWritingStringsToStyleProperty()) {\n+      // VE does not treat `[style]` as anything special, instead it simply writes to the\n+      // `style` property on the element like so `element.style=value`. This seems to work fine\n+      // every where except IE11, where it throws an error and as a consequence this test fails in\n+      // VE on IE11.\n+      return;\n+    }\n+\n+    @Component({\n+      template: `\n+        <div id=\"first\" style=\"margin: {{margin}}\" [style]=\"'padding: 20px;'\"></div>\n+        <div id=\"second\" [style]=\"'padding: 20px;'\" style=\"margin: {{margin}}\"></div>\n+      `,\n+    })\n+    class MyComp {\n+      margin = '10px';\n+    }\n+\n+    TestBed.configureTestingModule({declarations: [MyComp]});\n+    const fixture = TestBed.createComponent(MyComp);\n+    fixture.detectChanges();\n+\n+    const first = fixture.nativeElement.querySelector('#first').outerHTML;\n+    expect(first).not.toContain('margin');\n+    expect(first).toContain('padding');\n+\n+    const second = fixture.nativeElement.querySelector('#second').outerHTML;\n+    expect(second).toContain('margin');\n+    expect(second).not.toContain('padding');\n+  });\n+\n   it('should allow to reset style property value defined using [style.prop.px] binding', () => {\n     @Component({\n       template: '<div [style.left.px]=\"left\"></div>',\n@@ -3625,35 +3717,6 @@ describe('styling', () => {\n       expectStyle(div).toEqual({color: 'white', display: 'block'});\n     });\n \n-    /**\n-     * Tests to see if the current browser supports non standard way of writing into styles.\n-     *\n-     * This is not the correct way to write to style and is not supported in IE11.\n-     * ```\n-     * div.style = 'color: white';\n-     * ```\n-     *\n-     * This is the correct way to write to styles:\n-     * ```\n-     * div.style.cssText = 'color: white';\n-     * ```\n-     *\n-     * Even though writing to `div.style` is not officially supported, it works in all\n-     * browsers except IE11.\n-     *\n-     * This function detects this condition and allows us to skip the test.\n-     */\n-    function supportsWritingStringsToStyleProperty() {\n-      const div = document.createElement('div');\n-      const CSS = 'color: white;';\n-      try {\n-        (div as any).style = CSS;\n-      } catch (e) {\n-        return false;\n-      }\n-      return div.style.cssText === CSS;\n-    }\n-\n     onlyInIvy('styling priority resolution is Ivy only feature.')\n         .it('should allow lookahead binding on second pass #35118', () => {\n           @Component({"
        }
    ],
    "stats": {
        "total": 125,
        "additions": 92,
        "deletions": 33
    }
}