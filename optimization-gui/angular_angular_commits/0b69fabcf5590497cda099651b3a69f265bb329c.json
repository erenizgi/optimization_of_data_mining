{
    "author": "petebacondarwin",
    "message": "fix(compiler-cli): ensure ngcc can handle wildcard base-paths (#41033)\n\nNgcc uses the `paths` property to compute the potential base-paths\nfor packages that are being processed. If the `paths` contain a wildcard\n`*` within a path segment, ngcc was not finding the base-path correctly.\n\nNow when a wildcard is found, there is an additional search to look for\npaths that might match the wildcard.\n\nFixes #41014\n\nPR Close #41033",
    "sha": "0b69fabcf5590497cda099651b3a69f265bb329c",
    "files": [
        {
            "sha": "c74f5ce1defdddb968ddc2819c35463223728c3e",
            "filename": "packages/compiler-cli/ngcc/src/entry_point_finder/utils.ts",
            "status": "modified",
            "additions": 54,
            "deletions": 18,
            "changes": 72,
            "blob_url": "https://github.com/angular/angular/blob/0b69fabcf5590497cda099651b3a69f265bb329c/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/0b69fabcf5590497cda099651b3a69f265bb329c/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fentry_point_finder%2Futils.ts?ref=0b69fabcf5590497cda099651b3a69f265bb329c",
            "patch": "@@ -5,7 +5,7 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {AbsoluteFsPath, getFileSystem, PathManipulation} from '../../../src/ngtsc/file_system';\n+import {AbsoluteFsPath, getFileSystem, PathManipulation, ReadonlyFileSystem} from '../../../src/ngtsc/file_system';\n import {Logger} from '../../../src/ngtsc/logging';\n import {PathMappings} from '../path_mappings';\n \n@@ -41,21 +41,52 @@ export function getBasePaths(\n           `This is likely to mess up how ngcc finds entry-points and is probably not correct.\\n` +\n           `Please check your path mappings configuration such as in the tsconfig.json file.`);\n     }\n-    Object.values(pathMappings.paths).forEach(paths => paths.forEach(path => {\n-      // We only want base paths that exist and are not files\n-      let basePath = fs.resolve(baseUrl, extractPathPrefix(path));\n-      if (fs.exists(basePath) && fs.stat(basePath).isFile()) {\n-        basePath = fs.dirname(basePath);\n-      }\n-      if (fs.exists(basePath)) {\n-        basePaths.push(basePath);\n-      } else {\n-        logger.debug(\n-            `The basePath \"${basePath}\" computed from baseUrl \"${baseUrl}\" and path mapping \"${\n-                path}\" does not exist in the file-system.\\n` +\n-            `It will not be scanned for entry-points.`);\n+    for (const paths of Object.values(pathMappings.paths)) {\n+      for (const path of paths) {\n+        let foundMatch = false;\n+\n+        // We only want base paths that exist and are not files\n+        const {prefix, hasWildcard} = extractPathPrefix(path);\n+        let basePath = fs.resolve(baseUrl, prefix);\n+        if (fs.exists(basePath) && fs.stat(basePath).isFile()) {\n+          basePath = fs.dirname(basePath);\n+        }\n+\n+        if (fs.exists(basePath)) {\n+          // The `basePath` is itself a directory\n+          basePaths.push(basePath);\n+          foundMatch = true;\n+        }\n+\n+        if (hasWildcard) {\n+          // The path contains a wildcard (`*`) so also try searching for directories that start\n+          // with the wildcard prefix path segment.\n+          const wildcardContainer = fs.dirname(basePath);\n+          const wildcardPrefix = fs.basename(basePath);\n+          if (isExistingDirectory(fs, wildcardContainer)) {\n+            const candidates = fs.readdir(wildcardContainer);\n+            for (const candidate of candidates) {\n+              if (candidate.startsWith(wildcardPrefix)) {\n+                const candidatePath = fs.resolve(wildcardContainer, candidate);\n+                if (isExistingDirectory(fs, candidatePath)) {\n+                  foundMatch = true;\n+                  basePaths.push(candidatePath);\n+                }\n+              }\n+            }\n+          }\n+        }\n+\n+        if (!foundMatch) {\n+          // We neither found a direct match (i.e. `basePath` is an existing directory) nor a\n+          // directory that starts with a wildcard prefix.\n+          logger.debug(\n+              `The basePath \"${basePath}\" computed from baseUrl \"${baseUrl}\" and path mapping \"${\n+                  path}\" does not exist in the file-system.\\n` +\n+              `It will not be scanned for entry-points.`);\n+        }\n       }\n-    }));\n+    }\n   }\n \n   const dedupedBasePaths = dedupePaths(fs, basePaths);\n@@ -70,13 +101,18 @@ export function getBasePaths(\n   return dedupedBasePaths;\n }\n \n+function isExistingDirectory(fs: ReadonlyFileSystem, path: AbsoluteFsPath): boolean {\n+  return fs.exists(path) && fs.stat(path).isDirectory();\n+}\n+\n /**\n  * Extract everything in the `path` up to the first `*`.\n  * @param path The path to parse.\n- * @returns The extracted prefix.\n+ * @returns The extracted prefix and a flag to indicate whether there was a wildcard `*`.\n  */\n-function extractPathPrefix(path: string) {\n-  return path.split('*', 1)[0];\n+function extractPathPrefix(path: string): {prefix: string, hasWildcard: boolean} {\n+  const [prefix, rest] = path.split('*', 2);\n+  return {prefix, hasWildcard: rest !== undefined};\n }\n \n /**"
        },
        {
            "sha": "8d365844c5e66198968fea708d2342a5420983a7",
            "filename": "packages/compiler-cli/ngcc/test/entry_point_finder/utils_spec.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/0b69fabcf5590497cda099651b3a69f265bb329c/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fentry_point_finder%2Futils_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/0b69fabcf5590497cda099651b3a69f265bb329c/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fentry_point_finder%2Futils_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fentry_point_finder%2Futils_spec.ts?ref=0b69fabcf5590497cda099651b3a69f265bb329c",
            "patch": "@@ -48,6 +48,24 @@ runInEachFileSystem(() => {\n       ]);\n     });\n \n+    it('should find base-paths that start with a wildcard prefix', () => {\n+      const projectDirectory = _('/path/to/project');\n+      const fs = getFileSystem();\n+      fs.ensureDir(fs.resolve(projectDirectory, 'dist'));\n+      fs.ensureDir(fs.resolve(projectDirectory, 'dist-a'));\n+      fs.ensureDir(fs.resolve(projectDirectory, 'dist-b'));\n+\n+      const sourceDirectory = _('/path/to/project/node_modules');\n+      const pathMappings = {baseUrl: projectDirectory, paths: {'@dist*': ['dist*']}};\n+      const basePaths = getBasePaths(logger, sourceDirectory, pathMappings);\n+      expect(basePaths).toEqual([\n+        sourceDirectory,\n+        fs.resolve(projectDirectory, 'dist'),\n+        fs.resolve(projectDirectory, 'dist-a'),\n+        fs.resolve(projectDirectory, 'dist-b'),\n+      ]);\n+    });\n+\n     it('should not be confused by folders that have the same starting string', () => {\n       const projectDirectory = _('/path/to/project');\n       const fs = getFileSystem();"
        }
    ],
    "stats": {
        "total": 90,
        "additions": 72,
        "deletions": 18
    }
}