{
    "author": "AndrewKushnir",
    "message": "fix(forms): remove validators while cleaning up a control (#39234)\n\nPrior to this commit, the `cleanUpControl` function (responsible for cleaning up control instance)\nwas not taking validators into account. As a result, these validators remain registered on a detached\nform control instance, thus causing memory leaks. This commit updates the `cleanUpControl` function\nlogic to also run validators cleanup.\n\nAs a part of this change, the logic to setup and cleanup validators was refactored and moved to\nseparate functions (with completely opposite behavior), so that they can be reused in the future.\n\nThis commit doesn't add the `cleanUpControl` calls to all possible places, it just fixes the cases\nwhere this function is being called, but doesn't fully perform a cleanup. The `cleanUpControl`\nfunction calls will be added to other parts of code (to avoid more memory leaks) in a followup PR.\n\nPR Close #39234",
    "sha": "e96b3793852ebfd79a54a708363691b11818b4a0",
    "files": [
        {
            "sha": "0e06d058e63f749b885ae27baf90d2424685e03f",
            "filename": "packages/core/test/bundling/forms/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/e96b3793852ebfd79a54a708363691b11818b4a0/packages%2Fcore%2Ftest%2Fbundling%2Fforms%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/e96b3793852ebfd79a54a708363691b11818b4a0/packages%2Fcore%2Ftest%2Fbundling%2Fforms%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Fforms%2Fbundle.golden_symbols.json?ref=e96b3793852ebfd79a54a708363691b11818b4a0",
            "patch": "@@ -755,6 +755,9 @@\n   {\n     \"name\": \"classIndexOf\"\n   },\n+  {\n+    \"name\": \"cleanUpValidators\"\n+  },\n   {\n     \"name\": \"cleanUpView\"\n   },\n@@ -962,6 +965,12 @@\n   {\n     \"name\": \"getConstant\"\n   },\n+  {\n+    \"name\": \"getControlAsyncValidators\"\n+  },\n+  {\n+    \"name\": \"getControlValidators\"\n+  },\n   {\n     \"name\": \"getCurrentTNode\"\n   },\n@@ -1316,6 +1325,9 @@\n   {\n     \"name\": \"mergeHostAttrs\"\n   },\n+  {\n+    \"name\": \"mergeValidators\"\n+  },\n   {\n     \"name\": \"modelGroupProvider\"\n   },\n@@ -1421,6 +1433,9 @@\n   {\n     \"name\": \"registerHostBindingOpCodes\"\n   },\n+  {\n+    \"name\": \"registerOnValidatorChange\"\n+  },\n   {\n     \"name\": \"registerPostOrderHooks\"\n   },\n@@ -1547,6 +1562,9 @@\n   {\n     \"name\": \"setUpFormContainer\"\n   },\n+  {\n+    \"name\": \"setUpValidators\"\n+  },\n   {\n     \"name\": \"shareSubjectFactory\"\n   },"
        },
        {
            "sha": "050f244a762abaace3564c21a416619a371eb487",
            "filename": "packages/forms/src/directives/reactive_directives/form_group_directive.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 10,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/e96b3793852ebfd79a54a708363691b11818b4a0/packages%2Fforms%2Fsrc%2Fdirectives%2Freactive_directives%2Fform_group_directive.ts",
            "raw_url": "https://github.com/angular/angular/raw/e96b3793852ebfd79a54a708363691b11818b4a0/packages%2Fforms%2Fsrc%2Fdirectives%2Freactive_directives%2Fform_group_directive.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Fsrc%2Fdirectives%2Freactive_directives%2Fform_group_directive.ts?ref=e96b3793852ebfd79a54a708363691b11818b4a0",
            "patch": "@@ -9,11 +9,11 @@\n import {Directive, EventEmitter, forwardRef, Inject, Input, OnChanges, Optional, Output, Self, SimpleChanges} from '@angular/core';\n \n import {FormArray, FormControl, FormGroup} from '../../model';\n-import {NG_ASYNC_VALIDATORS, NG_VALIDATORS, Validators} from '../../validators';\n+import {NG_ASYNC_VALIDATORS, NG_VALIDATORS} from '../../validators';\n import {ControlContainer} from '../control_container';\n import {Form} from '../form_interface';\n import {ReactiveErrors} from '../reactive_errors';\n-import {cleanUpControl, removeDir, setUpControl, setUpFormContainer, syncPendingControls} from '../shared';\n+import {cleanUpControl, cleanUpValidators, removeDir, setUpControl, setUpFormContainer, setUpValidators, syncPendingControls} from '../shared';\n import {AsyncValidator, AsyncValidatorFn, Validator, ValidatorFn} from '../validators';\n \n import {FormControlName} from './form_control_name';\n@@ -60,8 +60,11 @@ export class FormGroupDirective extends ControlContainer implements Form, OnChan\n    */\n   public readonly submitted: boolean = false;\n \n-  // TODO(issue/24571): remove '!'.\n-  private _oldForm!: FormGroup;\n+  /**\n+   * Reference to an old form group input value, which is needed to cleanup old instance in case it\n+   * was replaced with a new one.\n+   */\n+  private _oldForm: FormGroup|undefined;\n \n   /**\n    * @description\n@@ -97,6 +100,7 @@ export class FormGroupDirective extends ControlContainer implements Form, OnChan\n       this._updateValidators();\n       this._updateDomValue();\n       this._updateRegistrations();\n+      this._oldForm = this.form;\n     }\n   }\n \n@@ -266,7 +270,9 @@ export class FormGroupDirective extends ControlContainer implements Form, OnChan\n     this.directives.forEach(dir => {\n       const newCtrl: any = this.form.get(dir.path);\n       if (dir.control !== newCtrl) {\n-        cleanUpControl(dir.control, dir);\n+        // Note: the value of the `dir.control` may not be defined, for example when it's a first\n+        // `FormControl` that is added to a `FormGroup` instance (via `addControl` call).\n+        cleanUpControl(dir.control || null, dir);\n         if (newCtrl) setUpControl(newCtrl, dir);\n         (dir as {control: FormControl}).control = newCtrl;\n       }\n@@ -277,14 +283,16 @@ export class FormGroupDirective extends ControlContainer implements Form, OnChan\n \n   private _updateRegistrations() {\n     this.form._registerOnCollectionChange(() => this._updateDomValue());\n-    if (this._oldForm) this._oldForm._registerOnCollectionChange(() => {});\n-    this._oldForm = this.form;\n+    if (this._oldForm) {\n+      this._oldForm._registerOnCollectionChange(() => {});\n+    }\n   }\n \n   private _updateValidators() {\n-    this.form.validator = Validators.compose([this.form.validator, this.validator]);\n-    this.form.asyncValidator =\n-        Validators.composeAsync([this.form.asyncValidator, this.asyncValidator]);\n+    setUpValidators(this.form, this, /* handleOnValidatorChange */ false);\n+    if (this._oldForm) {\n+      cleanUpValidators(this._oldForm, this, /* handleOnValidatorChange */ false);\n+    }\n   }\n \n   private _checkFormPresent() {"
        },
        {
            "sha": "9b7ccf545e9d6391092299e6b9f4138d9a73cd18",
            "filename": "packages/forms/src/directives/shared.ts",
            "status": "modified",
            "additions": 95,
            "deletions": 28,
            "changes": 123,
            "blob_url": "https://github.com/angular/angular/blob/e96b3793852ebfd79a54a708363691b11818b4a0/packages%2Fforms%2Fsrc%2Fdirectives%2Fshared.ts",
            "raw_url": "https://github.com/angular/angular/raw/e96b3793852ebfd79a54a708363691b11818b4a0/packages%2Fforms%2Fsrc%2Fdirectives%2Fshared.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Fsrc%2Fdirectives%2Fshared.ts?ref=e96b3793852ebfd79a54a708363691b11818b4a0",
            "patch": "@@ -8,8 +8,8 @@\n \n import {isDevMode} from '@angular/core';\n \n-import {FormArray, FormControl, FormGroup} from '../model';\n-import {Validators} from '../validators';\n+import {AbstractControl, FormArray, FormControl, FormGroup} from '../model';\n+import {getControlAsyncValidators, getControlValidators, mergeValidators} from '../validators';\n \n import {AbstractControlDirective} from './abstract_control_directive';\n import {AbstractFormGroupDirective} from './abstract_form_group_directive';\n@@ -25,7 +25,7 @@ import {FormArrayName} from './reactive_directives/form_group_name';\n import {ReactiveErrors} from './reactive_errors';\n import {SelectControlValueAccessor} from './select_control_value_accessor';\n import {SelectMultipleControlValueAccessor} from './select_multiple_control_value_accessor';\n-import {AsyncValidator, AsyncValidatorFn, Validator, ValidatorFn} from './validators';\n+import {AsyncValidatorFn, Validator, ValidatorFn} from './validators';\n \n \n export function controlPath(name: string|null, parent: ControlContainer): string[] {\n@@ -38,8 +38,8 @@ export function setUpControl(control: FormControl, dir: NgControl): void {\n     if (!dir.valueAccessor) _throwError(dir, 'No value accessor for form control with');\n   }\n \n-  control.validator = Validators.compose([control.validator!, dir.validator]);\n-  control.asyncValidator = Validators.composeAsync([control.asyncValidator!, dir.asyncValidator]);\n+  setUpValidators(control, dir, /* handleOnValidatorChange */ true);\n+\n   dir.valueAccessor!.writeValue(control.value);\n \n   setUpViewChangePipeline(control, dir);\n@@ -52,20 +52,9 @@ export function setUpControl(control: FormControl, dir: NgControl): void {\n       dir.valueAccessor!.setDisabledState!(isDisabled);\n     });\n   }\n-\n-  // re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4\n-  dir._rawValidators.forEach((validator: Validator|ValidatorFn) => {\n-    if ((<Validator>validator).registerOnValidatorChange)\n-      (<Validator>validator).registerOnValidatorChange!(() => control.updateValueAndValidity());\n-  });\n-\n-  dir._rawAsyncValidators.forEach((validator: AsyncValidator|AsyncValidatorFn) => {\n-    if ((<Validator>validator).registerOnValidatorChange)\n-      (<Validator>validator).registerOnValidatorChange!(() => control.updateValueAndValidity());\n-  });\n }\n \n-export function cleanUpControl(control: FormControl, dir: NgControl) {\n+export function cleanUpControl(control: FormControl|null, dir: NgControl) {\n   const noop = () => {\n     if (typeof ngDevMode === 'undefined' || ngDevMode) {\n       _noControlError(dir);\n@@ -75,19 +64,98 @@ export function cleanUpControl(control: FormControl, dir: NgControl) {\n   dir.valueAccessor!.registerOnChange(noop);\n   dir.valueAccessor!.registerOnTouched(noop);\n \n-  dir._rawValidators.forEach((validator: any) => {\n-    if (validator.registerOnValidatorChange) {\n-      validator.registerOnValidatorChange(null);\n-    }\n+  cleanUpValidators(control, dir, /* handleOnValidatorChange */ true);\n+\n+  if (control) control._clearChangeFns();\n+}\n+\n+function registerOnValidatorChange<V>(validators: (V|Validator)[], onChange: () => void): void {\n+  validators.forEach((validator: (V|Validator)) => {\n+    if ((<Validator>validator).registerOnValidatorChange)\n+      (<Validator>validator).registerOnValidatorChange!(onChange);\n   });\n+}\n \n-  dir._rawAsyncValidators.forEach((validator: any) => {\n-    if (validator.registerOnValidatorChange) {\n-      validator.registerOnValidatorChange(null);\n+/**\n+ * Sets up sync and async directive validators on provided form control.\n+ * This function merges validators from the directive into the validators of the control.\n+ *\n+ * @param control Form control where directive validators should be setup.\n+ * @param dir Directive instance that contains validators to be setup.\n+ * @param handleOnValidatorChange Flag that determines whether directive validators should be setup\n+ *     to handle validator input change.\n+ */\n+export function setUpValidators(\n+    control: AbstractControl, dir: AbstractControlDirective,\n+    handleOnValidatorChange: boolean): void {\n+  const validators = getControlValidators(control);\n+  if (dir.validator !== null) {\n+    control.setValidators(mergeValidators<ValidatorFn>(validators, dir.validator));\n+  } else if (typeof validators === 'function') {\n+    // If sync validators are represented by a single validator function, we force the\n+    // `Validators.compose` call to happen by executing the `setValidators` function with\n+    // an array that contains that function. We need this to avoid possible discrepancies in\n+    // validators behavior, so sync validators are always processed by the `Validators.compose`.\n+    // Note: we should consider moving this logic inside the `setValidators` function itself, so we\n+    // have consistent behavior on AbstractControl API level. The same applies to the async\n+    // validators logic below.\n+    control.setValidators([validators]);\n+  }\n+\n+  const asyncValidators = getControlAsyncValidators(control);\n+  if (dir.asyncValidator !== null) {\n+    control.setAsyncValidators(\n+        mergeValidators<AsyncValidatorFn>(asyncValidators, dir.asyncValidator));\n+  } else if (typeof asyncValidators === 'function') {\n+    control.setAsyncValidators([asyncValidators]);\n+  }\n+\n+  // Re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4\n+  if (handleOnValidatorChange) {\n+    const onValidatorChange = () => control.updateValueAndValidity();\n+    registerOnValidatorChange<ValidatorFn>(dir._rawValidators, onValidatorChange);\n+    registerOnValidatorChange<AsyncValidatorFn>(dir._rawAsyncValidators, onValidatorChange);\n+  }\n+}\n+\n+/**\n+ * Cleans up sync and async directive validators on provided form control.\n+ * This function reverts the setup performed by the `setUpValidators` function, i.e.\n+ * removes directive-specific validators from a given control instance.\n+ *\n+ * @param control Form control from where directive validators should be removed.\n+ * @param dir Directive instance that contains validators to be removed.\n+ * @param handleOnValidatorChange Flag that determines whether directive validators should also be\n+ *     cleaned up to stop handling validator input change (if previously configured to do so).\n+ */\n+export function cleanUpValidators(\n+    control: AbstractControl|null, dir: AbstractControlDirective,\n+    handleOnValidatorChange: boolean): void {\n+  if (control !== null) {\n+    if (dir.validator !== null) {\n+      const validators = getControlValidators(control);\n+      if (Array.isArray(validators) && validators.length > 0) {\n+        // Filter out directive validator function.\n+        control.setValidators(validators.filter(validator => validator !== dir.validator));\n+      }\n     }\n-  });\n \n-  if (control) control._clearChangeFns();\n+    if (dir.asyncValidator !== null) {\n+      const asyncValidators = getControlAsyncValidators(control);\n+      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {\n+        // Filter out directive async validator function.\n+        control.setAsyncValidators(\n+            asyncValidators.filter(asyncValidator => asyncValidator !== dir.asyncValidator));\n+      }\n+    }\n+  }\n+\n+  if (handleOnValidatorChange) {\n+    // Clear onValidatorChange callbacks by providing a noop function.\n+    const noop = () => {};\n+    registerOnValidatorChange<ValidatorFn>(dir._rawValidators, noop);\n+    registerOnValidatorChange<AsyncValidatorFn>(dir._rawAsyncValidators, noop);\n+  }\n }\n \n function setUpViewChangePipeline(control: FormControl, dir: NgControl): void {\n@@ -130,8 +198,7 @@ export function setUpFormContainer(\n     control: FormGroup|FormArray, dir: AbstractFormGroupDirective|FormArrayName) {\n   if (control == null && (typeof ngDevMode === 'undefined' || ngDevMode))\n     _throwError(dir, 'Cannot find control with');\n-  control.validator = Validators.compose([control.validator, dir.validator]);\n-  control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);\n+  setUpValidators(control, dir, /* handleOnValidatorChange */ false);\n }\n \n function _noControlError(dir: NgControl) {"
        },
        {
            "sha": "5e32394edfc507a9a8183c15b6f0f596310b56cd",
            "filename": "packages/forms/src/validators.ts",
            "status": "modified",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/e96b3793852ebfd79a54a708363691b11818b4a0/packages%2Fforms%2Fsrc%2Fvalidators.ts",
            "raw_url": "https://github.com/angular/angular/raw/e96b3793852ebfd79a54a708363691b11818b4a0/packages%2Fforms%2Fsrc%2Fvalidators.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Fsrc%2Fvalidators.ts?ref=e96b3793852ebfd79a54a708363691b11818b4a0",
            "patch": "@@ -551,4 +551,29 @@ export function composeAsyncValidators(validators: Array<AsyncValidator|AsyncVal\n   return validators != null ?\n       Validators.composeAsync(normalizeValidators<AsyncValidatorFn>(validators)) :\n       null;\n+}\n+\n+/**\n+ * Merges raw control validators with a given directive validator and returns the combined list of\n+ * validators as an array.\n+ */\n+export function mergeValidators<V>(controlValidators: V|V[]|null, dirValidator: V): V[] {\n+  if (controlValidators === null) return [dirValidator];\n+  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] :\n+                                            [controlValidators, dirValidator];\n+}\n+\n+/**\n+ * Retrieves the list of raw synchronous validators attached to a given control.\n+ */\n+export function getControlValidators(control: AbstractControl): ValidatorFn|ValidatorFn[]|null {\n+  return (control as any)._rawValidators as ValidatorFn | ValidatorFn[] | null;\n+}\n+\n+/**\n+ * Retrieves the list of raw asynchronous validators attached to a given control.\n+ */\n+export function getControlAsyncValidators(control: AbstractControl): AsyncValidatorFn|\n+    AsyncValidatorFn[]|null {\n+  return (control as any)._rawAsyncValidators as AsyncValidatorFn | AsyncValidatorFn[] | null;\n }\n\\ No newline at end of file"
        },
        {
            "sha": "170ed7bb6c620eea07514211f3f66d936779511a",
            "filename": "packages/forms/test/reactive_integration_spec.ts",
            "status": "modified",
            "additions": 287,
            "deletions": 3,
            "changes": 290,
            "blob_url": "https://github.com/angular/angular/blob/e96b3793852ebfd79a54a708363691b11818b4a0/packages%2Fforms%2Ftest%2Freactive_integration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e96b3793852ebfd79a54a708363691b11818b4a0/packages%2Fforms%2Ftest%2Freactive_integration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fforms%2Ftest%2Freactive_integration_spec.ts?ref=e96b3793852ebfd79a54a708363691b11818b4a0",
            "patch": "@@ -9,11 +9,12 @@\n import {ÉµgetDOM as getDOM} from '@angular/common';\n import {Component, Directive, forwardRef, Input, Type} from '@angular/core';\n import {ComponentFixture, fakeAsync, TestBed, tick} from '@angular/core/testing';\n-import {AbstractControl, AsyncValidator, AsyncValidatorFn, COMPOSITION_BUFFER_MODE, FormArray, FormControl, FormControlDirective, FormControlName, FormGroup, FormGroupDirective, FormsModule, NG_ASYNC_VALIDATORS, NG_VALIDATORS, ReactiveFormsModule, Validators} from '@angular/forms';\n+import {expect} from '@angular/core/testing/src/testing_internal';\n+import {AbstractControl, AsyncValidator, AsyncValidatorFn, COMPOSITION_BUFFER_MODE, FormArray, FormControl, FormControlDirective, FormControlName, FormGroup, FormGroupDirective, FormsModule, NG_ASYNC_VALIDATORS, NG_VALIDATORS, ReactiveFormsModule, Validator, Validators} from '@angular/forms';\n import {By} from '@angular/platform-browser/src/dom/debug/by';\n import {dispatchEvent, sortedClassList} from '@angular/platform-browser/testing/src/browser_util';\n-import {merge, timer} from 'rxjs';\n-import {tap} from 'rxjs/operators';\n+import {merge, NEVER, of, timer} from 'rxjs';\n+import {map, tap} from 'rxjs/operators';\n \n import {MyInput, MyInputForm} from './value_accessor_integration_spec';\n \n@@ -25,6 +26,11 @@ import {MyInput, MyInputForm} from './value_accessor_integration_spec';\n       return TestBed.createComponent(component);\n     }\n \n+    // Helper method that attaches a spy to a `validate` function on a Validator class.\n+    function validatorSpyOn(validatorClass: any) {\n+      return spyOn(validatorClass.prototype, 'validate').and.callThrough();\n+    }\n+\n     describe('basic functionality', () => {\n       it('should work with single controls', () => {\n         const fixture = initTest(FormControlComp);\n@@ -1785,6 +1791,23 @@ import {MyInput, MyInputForm} from './value_accessor_integration_spec';\n         expect(control.hasError('required')).toEqual(false);\n       });\n \n+      // Note: this scenario goes against validator function rules were `null` is the only\n+      // representation of a successful check. However the `Validators.combine` has a side-effect\n+      // where falsy values are treated as success and `null` is returned from the wrapper function.\n+      // The goal of this test is to prevent regressions for validators that return falsy values by\n+      // mistake and rely on the `Validators.compose` side-effects to normalize the value to `null`\n+      // instead.\n+      it('should treat validators that return `undefined` as successful', () => {\n+        const fixture = initTest(FormControlComp);\n+        const validatorFn = (control: AbstractControl) => control.value ?? undefined;\n+        const control = new FormControl(undefined, validatorFn);\n+        fixture.componentInstance.control = control;\n+        fixture.detectChanges();\n+\n+        expect(control.status).toBe('VALID');\n+        expect(control.errors).toBe(null);\n+      });\n+\n       it('should use sync validators defined in html', () => {\n         const fixture = initTest(LoginIsEmptyWrapper, LoginIsEmptyValidator);\n         const form = new FormGroup({\n@@ -2446,6 +2469,181 @@ import {MyInput, MyInputForm} from './value_accessor_integration_spec';\n         expect(fixture.componentInstance.control.value).toEqual('updatedValue');\n       });\n     });\n+\n+    describe('cleanup', () => {\n+      function expectValidatorsToBeCalled(\n+          syncValidatorSpy: jasmine.Spy, asyncValidatorSpy: jasmine.Spy,\n+          expected: {ctx: any, count: number}) {\n+        [syncValidatorSpy, asyncValidatorSpy].forEach((spy: jasmine.Spy<jasmine.Func>) => {\n+          spy.calls.all().forEach((call: jasmine.CallInfo<jasmine.Func>) => {\n+            expect(call.args[0]).toBe(expected.ctx);\n+          });\n+          expect(spy).toHaveBeenCalledTimes(expected.count);\n+        });\n+      }\n+\n+      it('should clean up validators when FormGroup is replaced', () => {\n+        const fixture =\n+            initTest(FormGroupWithValidators, MyCustomValidator, MyCustomAsyncValidator);\n+        fixture.detectChanges();\n+\n+        const newForm = new FormGroup({login: new FormControl('NEW')});\n+        const oldForm = fixture.componentInstance.form;\n+\n+        // Update `form` input with a new value.\n+        fixture.componentInstance.form = newForm;\n+        fixture.detectChanges();\n+\n+        const validatorSpy = validatorSpyOn(MyCustomValidator);\n+        const asyncValidatorSpy = validatorSpyOn(MyCustomAsyncValidator);\n+\n+        // Calling `setValue` for the OLD form should NOT trigger validator calls.\n+        oldForm.setValue({login: 'SOME-OLD-VALUE'});\n+        expect(validatorSpy).not.toHaveBeenCalled();\n+        expect(asyncValidatorSpy).not.toHaveBeenCalled();\n+\n+        // Calling `setValue` for the NEW (active) form should trigger validator calls.\n+        newForm.setValue({login: 'SOME-NEW-VALUE'});\n+        expectValidatorsToBeCalled(validatorSpy, asyncValidatorSpy, {ctx: newForm, count: 1});\n+      });\n+\n+      it('should clean up validators when FormControl inside FormGroup is replaced', () => {\n+        const fixture =\n+            initTest(FormControlWithValidators, MyCustomValidator, MyCustomAsyncValidator);\n+        fixture.detectChanges();\n+\n+        const newControl = new FormControl('NEW')!;\n+        const oldControl = fixture.componentInstance.form.get('login')!;\n+\n+        const validatorSpy = validatorSpyOn(MyCustomValidator);\n+        const asyncValidatorSpy = validatorSpyOn(MyCustomAsyncValidator);\n+\n+        // Update `login` form control with a new `FormControl` instance.\n+        fixture.componentInstance.form.removeControl('login');\n+        fixture.componentInstance.form.addControl('login', newControl);\n+        fixture.detectChanges();\n+\n+        validatorSpy.calls.reset();\n+        asyncValidatorSpy.calls.reset();\n+\n+        // Calling `setValue` for the OLD control should NOT trigger validator calls.\n+        oldControl.setValue('SOME-OLD-VALUE');\n+        expect(validatorSpy).not.toHaveBeenCalled();\n+        expect(asyncValidatorSpy).not.toHaveBeenCalled();\n+\n+        // Calling `setValue` for the NEW (active) control should trigger validator calls.\n+        newControl.setValue('SOME-NEW-VALUE');\n+        expectValidatorsToBeCalled(validatorSpy, asyncValidatorSpy, {ctx: newControl, count: 1});\n+      });\n+\n+      it('should keep control in pending state if async validator never emits', fakeAsync(() => {\n+           const fixture = initTest(FormControlWithAsyncValidatorFn);\n+           fixture.detectChanges();\n+\n+           const control = fixture.componentInstance.form.get('login')!;\n+           expect(control.status).toBe('PENDING');\n+\n+           control.setValue('SOME-NEW-VALUE');\n+           tick();\n+\n+           // Since validator never emits, we expect a control to be retained in a pending state.\n+           expect(control.status).toBe('PENDING');\n+           expect(control.errors).toBe(null);\n+         }));\n+\n+      it('should call validators defined via `set[Async]Validators` after view init', () => {\n+        const fixture =\n+            initTest(FormControlWithValidators, MyCustomValidator, MyCustomAsyncValidator);\n+        fixture.detectChanges();\n+\n+        const control = fixture.componentInstance.form.get('login')!;\n+\n+        const initialValidatorSpy = validatorSpyOn(MyCustomValidator);\n+        const initialAsyncValidatorSpy = validatorSpyOn(MyCustomAsyncValidator);\n+\n+        initialValidatorSpy.calls.reset();\n+        initialAsyncValidatorSpy.calls.reset();\n+\n+        control.setValue('VALUE-A');\n+\n+        // Expect initial validators (setup during view creation) to be called.\n+        expectValidatorsToBeCalled(\n+            initialValidatorSpy, initialAsyncValidatorSpy, {ctx: control, count: 1});\n+\n+        initialValidatorSpy.calls.reset();\n+        initialAsyncValidatorSpy.calls.reset();\n+\n+        // Create new validators and corresponding spies.\n+        const newValidatorSpy = jasmine.createSpy('newValidator').and.returnValue(null);\n+        const newAsyncValidatorSpy =\n+            jasmine.createSpy('newAsyncValidator').and.returnValue(of(null));\n+\n+        // Set new validators to a control that is already used in a view.\n+        // Expect that new validators are applied and old validators are removed.\n+        control.setValidators(newValidatorSpy);\n+        control.setAsyncValidators(newAsyncValidatorSpy);\n+\n+        // Update control value to trigger validation.\n+        control.setValue('VALUE-B');\n+\n+        // Verify that initial (inactive) validators were not called.\n+        expect(initialValidatorSpy).not.toHaveBeenCalled();\n+        expect(initialAsyncValidatorSpy).not.toHaveBeenCalled();\n+\n+        // Verify that newly applied validators were executed.\n+        expectValidatorsToBeCalled(newValidatorSpy, newAsyncValidatorSpy, {ctx: control, count: 1});\n+      });\n+\n+      it('should cleanup validators on a control used for multiple `formControlName` directive',\n+         () => {\n+           const fixture =\n+               initTest(NgForFormControlWithValidators, MyCustomValidator, MyCustomAsyncValidator);\n+           fixture.detectChanges();\n+\n+           const newControl = new FormControl('b')!;\n+           const oldControl = fixture.componentInstance.form.get('login')!;\n+\n+           const validatorSpy = validatorSpyOn(MyCustomValidator);\n+           const asyncValidatorSpy = validatorSpyOn(MyCustomAsyncValidator);\n+\n+           // Case 1: replace `login` form control with a new `FormControl` instance.\n+           fixture.componentInstance.form.removeControl('login');\n+           fixture.componentInstance.form.addControl('login', newControl);\n+           fixture.detectChanges();\n+\n+           // Check that validators were called with a new control as a context\n+           // and each validator function was called for each control (so 3 times each).\n+           expectValidatorsToBeCalled(validatorSpy, asyncValidatorSpy, {ctx: newControl, count: 3});\n+\n+           validatorSpy.calls.reset();\n+           asyncValidatorSpy.calls.reset();\n+\n+           // Calling `setValue` for the OLD control should NOT trigger validator calls.\n+           oldControl.setValue('SOME-OLD-VALUE');\n+           expect(validatorSpy).not.toHaveBeenCalled();\n+           expect(asyncValidatorSpy).not.toHaveBeenCalled();\n+\n+           // Calling `setValue` for the NEW (active) control should trigger validator calls.\n+           newControl.setValue('SOME-NEW-VALUE');\n+\n+           // Check that setting a value on a new control triggers validator calls.\n+           expectValidatorsToBeCalled(validatorSpy, asyncValidatorSpy, {ctx: newControl, count: 3});\n+\n+           // Case 2: update `logins` to render a new list of elements.\n+           fixture.componentInstance.logins = ['a', 'b', 'c', 'd', 'e', 'f'];\n+           fixture.detectChanges();\n+\n+           validatorSpy.calls.reset();\n+           asyncValidatorSpy.calls.reset();\n+\n+           // Calling `setValue` for the NEW (active) control should trigger validator calls.\n+           newControl.setValue('SOME-NEW-VALUE-2');\n+\n+           // Check that setting a value on a new control triggers validator calls for updated set\n+           // of controls (one for each element in the `logins` array).\n+           expectValidatorsToBeCalled(validatorSpy, asyncValidatorSpy, {ctx: newControl, count: 6});\n+         });\n+    });\n   });\n }\n \n@@ -2678,3 +2876,89 @@ class UniqLoginWrapper {\n   // TODO(issue/24571): remove '!'.\n   form!: FormGroup;\n }\n+\n+@Component({\n+  selector: 'form-group-with-validators',\n+  template: `\n+    <div [formGroup]=\"form\" my-custom-validator my-custom-async-validator>\n+      <input type=\"text\" formControlName=\"login\">\n+    </div>\n+  `\n+})\n+class FormGroupWithValidators {\n+  form = new FormGroup({login: new FormControl('INITIAL')});\n+}\n+\n+@Component({\n+  selector: 'form-control-with-validators',\n+  template: `\n+    <div [formGroup]=\"form\">\n+      <input type=\"text\" formControlName=\"login\">\n+    </div>\n+  `\n+})\n+class FormControlWithAsyncValidatorFn {\n+  control = new FormControl('INITIAL');\n+  form = new FormGroup({login: this.control});\n+\n+  constructor() {\n+    this.control.setAsyncValidators(() => {\n+      return NEVER.pipe(map((_: any) => ({timeoutError: true})));\n+    });\n+  }\n+}\n+\n+@Component({\n+  selector: 'form-control-with-validators',\n+  template: `\n+    <div [formGroup]=\"form\">\n+      <input type=\"text\" formControlName=\"login\" my-custom-validator my-custom-async-validator>\n+    </div>\n+  `\n+})\n+class FormControlWithValidators {\n+  form = new FormGroup({login: new FormControl('INITIAL')});\n+}\n+\n+@Component({\n+  selector: 'ngfor-form-controls-with-validators',\n+  template: `\n+    <div [formGroup]=\"form\">\n+      <ng-container *ngFor=\"let login of logins\">\n+        <input type=\"radio\" formControlName=\"login\" [value]=\"login\" my-custom-validator my-custom-async-validator>\n+      </ng-container>\n+    </div>\n+  `\n+})\n+class NgForFormControlWithValidators {\n+  form = new FormGroup({login: new FormControl('a')});\n+  logins = ['a', 'b', 'c'];\n+}\n+\n+@Directive({\n+  selector: '[my-custom-validator]',\n+  providers: [{\n+    provide: NG_VALIDATORS,\n+    useClass: forwardRef(() => MyCustomValidator),\n+    multi: true,\n+  }]\n+})\n+class MyCustomValidator implements Validator {\n+  validate(control: AbstractControl) {\n+    return null;\n+  }\n+}\n+\n+@Directive({\n+  selector: '[my-custom-async-validator]',\n+  providers: [{\n+    provide: NG_ASYNC_VALIDATORS,\n+    useClass: forwardRef(() => MyCustomAsyncValidator),\n+    multi: true,\n+  }]\n+})\n+class MyCustomAsyncValidator implements AsyncValidator {\n+  validate(control: AbstractControl) {\n+    return Promise.resolve(null);\n+  }\n+}\n\\ No newline at end of file"
        }
    ],
    "stats": {
        "total": 484,
        "additions": 443,
        "deletions": 41
    }
}