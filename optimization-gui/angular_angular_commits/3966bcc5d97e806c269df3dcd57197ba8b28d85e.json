{
    "author": "atscott",
    "message": "fix(router): Ensure named outlets with empty path parents are recognized (#40029)\n\nThis commit updates the `recognize` algorithm to work with named outlets\nwhich have empty path parents. For example, given the following config\n\n```\n  const routes = [\n    {\n      path: '',\n      children: [\n        {path: 'a', outlet: 'aux', component: AuxComponent}\n    ]}\n  ];\n```\n\nThe url `/(aux:a)` should match this config. In order to do so, we need\nto allow the children of `UrlSegmentGroup`s to match a `Route` config\nfor a different outlet (in this example, the `primary`) when it's an\nempty path. This should also *only* happen if we were unable to find a\nmatch for the outlet in the level above. That is, the matching strategy\nis to find the first `Route` in the list which _matches the given\noutlet_. If we are unable to do that, then we allow empty paths from\nother outlets to match and try to find some child there whose outlet\nmatches our segment.\n\nPR Close #40029",
    "sha": "3966bcc5d97e806c269df3dcd57197ba8b28d85e",
    "files": [
        {
            "sha": "8cbbe39136732138e0855cdb2ee20d0151f38724",
            "filename": "packages/router/src/recognize.ts",
            "status": "modified",
            "additions": 105,
            "deletions": 11,
            "changes": 116,
            "blob_url": "https://github.com/angular/angular/blob/3966bcc5d97e806c269df3dcd57197ba8b28d85e/packages%2Frouter%2Fsrc%2Frecognize.ts",
            "raw_url": "https://github.com/angular/angular/raw/3966bcc5d97e806c269df3dcd57197ba8b28d85e/packages%2Frouter%2Fsrc%2Frecognize.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frecognize.ts?ref=3966bcc5d97e806c269df3dcd57197ba8b28d85e",
            "patch": "@@ -89,20 +89,42 @@ export class Recognizer {\n     return this.processSegment(config, segmentGroup, segmentGroup.segments, outlet);\n   }\n \n+  /**\n+   * Matches every child outlet in the `segmentGroup` to a `Route` in the config. Returns `null` if\n+   * we cannot find a match for _any_ of the children.\n+   *\n+   * @param config - The `Routes` to match against\n+   * @param segmentGroup - The `UrlSegmentGroup` whose children need to be matched against the\n+   *     config.\n+   */\n   processChildren(config: Route[], segmentGroup: UrlSegmentGroup):\n       TreeNode<ActivatedRouteSnapshot>[]|null {\n     const children: Array<TreeNode<ActivatedRouteSnapshot>> = [];\n     for (const childOutlet of Object.keys(segmentGroup.children)) {\n       const child = segmentGroup.children[childOutlet];\n-      const outletChildren = this.processSegmentGroup(config, child, childOutlet);\n+      // Sort the config so that routes with outlets that match the one being activated appear\n+      // first, followed by routes for other outlets, which might match if they have an empty path.\n+      const sortedConfig = config.filter(r => getOutlet(r) === childOutlet);\n+      sortedConfig.push(...config.filter(r => getOutlet(r) !== childOutlet));\n+      const outletChildren = this.processSegmentGroup(sortedConfig, child, childOutlet);\n       if (outletChildren === null) {\n+        // Configs must match all segment children so because we did not find a match for this\n+        // outlet, return `null`.\n         return null;\n       }\n       children.push(...outletChildren);\n     }\n-    checkOutletNameUniqueness(children);\n-    sortActivatedRouteSnapshots(children);\n-    return children;\n+    // Because we may have matched two outlets to the same empty path segment, we can have multiple\n+    // activated results for the same outlet. We should merge the children of these results so the\n+    // final return value is only one `TreeNode` per outlet.\n+    const mergedChildren = mergeEmptyPathMatches(children);\n+    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n+      // This should really never happen - we are only taking the first match for each outlet and\n+      // merge the empty path matches.\n+      checkOutletNameUniqueness(mergedChildren);\n+    }\n+    sortActivatedRouteSnapshots(mergedChildren);\n+    return mergedChildren;\n   }\n \n   processSegment(\n@@ -129,9 +151,7 @@ export class Recognizer {\n   processSegmentAgainstRoute(\n       route: Route, rawSegment: UrlSegmentGroup, segments: UrlSegment[],\n       outlet: string): TreeNode<ActivatedRouteSnapshot>[]|null {\n-    if (route.redirectTo) return null;\n-\n-    if ((route.outlet || PRIMARY_OUTLET) !== outlet) return null;\n+    if (!isImmediateMatch(route, rawSegment, segments, outlet)) return null;\n \n     let snapshot: ActivatedRouteSnapshot;\n     let consumedSegments: UrlSegment[] = [];\n@@ -141,8 +161,9 @@ export class Recognizer {\n       const params = segments.length > 0 ? last(segments)!.parameters : {};\n       snapshot = new ActivatedRouteSnapshot(\n           segments, params, Object.freeze({...this.urlTree.queryParams}), this.urlTree.fragment!,\n-          getData(route), outlet, route.component!, route, getSourceSegmentGroup(rawSegment),\n-          getPathIndexShift(rawSegment) + segments.length, getResolve(route));\n+          getData(route), getOutlet(route), route.component!, route,\n+          getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length,\n+          getResolve(route));\n     } else {\n       const result: MatchResult|null = match(rawSegment, route, segments);\n       if (result === null) {\n@@ -153,7 +174,7 @@ export class Recognizer {\n \n       snapshot = new ActivatedRouteSnapshot(\n           consumedSegments, result.parameters, Object.freeze({...this.urlTree.queryParams}),\n-          this.urlTree.fragment!, getData(route), outlet, route.component!, route,\n+          this.urlTree.fragment!, getData(route), getOutlet(route), route.component!, route,\n           getSourceSegmentGroup(rawSegment),\n           getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));\n     }\n@@ -175,7 +196,17 @@ export class Recognizer {\n       return [new TreeNode<ActivatedRouteSnapshot>(snapshot, [])];\n     }\n \n-    const children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);\n+    const matchedOnOutlet = getOutlet(route) === outlet;\n+    // If we matched a config due to empty path match on a different outlet, we need to continue\n+    // passing the current outlet for the segment rather than switch to PRIMARY.\n+    // Note that we switch to primary when we have a match because outlet configs look like this:\n+    // {path: 'a', outlet: 'a', children: [\n+    //  {path: 'b', component: B},\n+    //  {path: 'c', component: C},\n+    // ]}\n+    // Notice that the children of the named outlet are configured with the primary outlet\n+    const children = this.processSegment(\n+        childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet);\n     if (children === null) {\n       return null;\n     }\n@@ -234,6 +265,37 @@ function match(segmentGroup: UrlSegmentGroup, route: Route, segments: UrlSegment\n   return {consumedSegments: res.consumed, lastChild: res.consumed.length, parameters};\n }\n \n+/**\n+ * Finds `TreeNode`s with matching empty path route configs and merges them into `TreeNode` with the\n+ * children from each duplicate. This is necessary because different outlets can match a single\n+ * empty path route config and the results need to then be merged.\n+ */\n+function mergeEmptyPathMatches(nodes: Array<TreeNode<ActivatedRouteSnapshot>>):\n+    Array<TreeNode<ActivatedRouteSnapshot>> {\n+  const result: Array<TreeNode<ActivatedRouteSnapshot>> = [];\n+\n+  function hasEmptyConfig(node: TreeNode<ActivatedRouteSnapshot>) {\n+    const config = node.value.routeConfig;\n+    return config && config.path === '' && config.redirectTo === undefined;\n+  }\n+\n+  for (const node of nodes) {\n+    if (!hasEmptyConfig(node)) {\n+      result.push(node);\n+      continue;\n+    }\n+\n+    const duplicateEmptyPathNode =\n+        result.find(resultNode => node.value.routeConfig === resultNode.value.routeConfig);\n+    if (duplicateEmptyPathNode !== undefined) {\n+      duplicateEmptyPathNode.children.push(...node.children);\n+    } else {\n+      result.push(node);\n+    }\n+  }\n+  return result;\n+}\n+\n function checkOutletNameUniqueness(nodes: TreeNode<ActivatedRouteSnapshot>[]): void {\n   const names: {[k: string]: ActivatedRouteSnapshot} = {};\n   nodes.forEach(n => {\n@@ -364,3 +426,35 @@ function getData(route: Route): Data {\n function getResolve(route: Route): ResolveData {\n   return route.resolve || {};\n }\n+\n+/**\n+ * Determines if `route` is a path match for the `rawSegment`, `segments`, and `outlet` without\n+ * verifying that its children are a full match for the remainder of the `rawSegment` children as\n+ * well.\n+ */\n+function isImmediateMatch(\n+    route: Route, rawSegment: UrlSegmentGroup, segments: UrlSegment[], outlet: string): boolean {\n+  if (route.redirectTo) {\n+    return false;\n+  }\n+  // We allow matches to empty paths when the outlets differ so we can match a url like `/(b:b)` to\n+  // a config like\n+  // * `{path: '', children: [{path: 'b', outlet: 'b'}]}`\n+  // or even\n+  // * `{path: '', outlet: 'a', children: [{path: 'b', outlet: 'b'}]`\n+  //\n+  // The exception here is when the segment outlet is for the primary outlet. This would\n+  // result in a match inside the named outlet because all children there are written as primary\n+  // outlets. So we need to prevent child named outlet matches in a url like `/b` in a config like\n+  // * `{path: '', outlet: 'x' children: [{path: 'b'}]}`\n+  // This should only match if the url is `/(x:b)`.\n+  if (getOutlet(route) !== outlet &&\n+      (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {\n+    return false;\n+  }\n+  if (route.path === '**') {\n+    return true;\n+  } else {\n+    return match(rawSegment, route, segments) !== null;\n+  }\n+}"
        },
        {
            "sha": "e692097332def0f6c088cbfa3298bdc1f94df724",
            "filename": "packages/router/test/recognize.spec.ts",
            "status": "modified",
            "additions": 80,
            "deletions": 0,
            "changes": 80,
            "blob_url": "https://github.com/angular/angular/blob/3966bcc5d97e806c269df3dcd57197ba8b28d85e/packages%2Frouter%2Ftest%2Frecognize.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/3966bcc5d97e806c269df3dcd57197ba8b28d85e/packages%2Frouter%2Ftest%2Frecognize.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Frecognize.spec.ts?ref=3966bcc5d97e806c269df3dcd57197ba8b28d85e",
            "patch": "@@ -567,6 +567,86 @@ describe('recognize', () => {\n         checkActivatedRoute(c[1].firstChild!, 'e', {}, ComponentE);\n       });\n     });\n+\n+    describe('with outlets', () => {\n+      it('should work when outlet is a child of empty path parent', () => {\n+        const s = recognize(\n+            [{\n+              path: '',\n+              component: ComponentA,\n+              children: [{path: 'b', outlet: 'b', component: ComponentB}]\n+            }],\n+            '(b:b)');\n+        checkActivatedRoute(s.root.children[0], '', {}, ComponentA);\n+        checkActivatedRoute(s.root.children[0].children[0], 'b', {}, ComponentB, 'b');\n+      });\n+\n+      it('should work for outlets adjacent to empty path', () => {\n+        const s = recognize(\n+            [\n+              {\n+                path: '',\n+                component: ComponentA,\n+                children: [{path: '', component: ComponentC}],\n+              },\n+              {path: 'b', outlet: 'b', component: ComponentB}\n+            ],\n+            '(b:b)');\n+        const [primaryChild, outletChild] = s.root.children;\n+        checkActivatedRoute(primaryChild, '', {}, ComponentA);\n+        checkActivatedRoute(outletChild, 'b', {}, ComponentB, 'b');\n+        checkActivatedRoute(primaryChild.children[0], '', {}, ComponentC);\n+      });\n+\n+      it('should work with named outlets both adjecent to and as a child of empty path', () => {\n+        const s = recognize(\n+            [\n+              {\n+                path: '',\n+                component: ComponentA,\n+                children: [{path: 'b', outlet: 'b', component: ComponentB}]\n+              },\n+              {path: 'c', outlet: 'c', component: ComponentC}\n+            ],\n+            '(b:b//c:c)');\n+        checkActivatedRoute(s.root.children[0], '', {}, ComponentA);\n+        checkActivatedRoute(s.root.children[1], 'c', {}, ComponentC, 'c');\n+        checkActivatedRoute(s.root.children[0].children[0], 'b', {}, ComponentB, 'b');\n+      });\n+\n+      it('should work with children outlets within two levels of empty parents', () => {\n+        const s = recognize(\n+            [{\n+              path: '',\n+              component: ComponentA,\n+              children: [{\n+                path: '',\n+                component: ComponentB,\n+                children: [{path: 'c', outlet: 'c', component: ComponentC}],\n+              }]\n+            }],\n+            '(c:c)');\n+        checkActivatedRoute(s.root.children[0], '', {}, ComponentA);\n+        checkActivatedRoute(s.root.children[0].children[0], '', {}, ComponentB);\n+        checkActivatedRoute(s.root.children[0].children[0].children[0], 'c', {}, ComponentC, 'c');\n+      });\n+\n+      it('should not persist a primary segment beyond the boundary of a named outlet match', () => {\n+        const s = new Recognizer(\n+                      RootComponent,\n+                      [\n+                        {\n+                          path: '',\n+                          component: ComponentA,\n+                          outlet: 'a',\n+                          children: [{path: 'b', component: ComponentB}],\n+                        },\n+                      ],\n+                      tree('/b'), '/b', 'emptyOnly', 'corrected')\n+                      .recognize();\n+        expect(s).toBeNull();\n+      });\n+    });\n   });\n \n   describe('wildcards', () => {"
        }
    ],
    "stats": {
        "total": 196,
        "additions": 185,
        "deletions": 11
    }
}