{
    "author": "petebacondarwin",
    "message": "refactor(compiler): replace Comment nodes with leadingComments property (#38811)\n\nCommon AST formats such as TS and Babel do not use a separate\nnode for comments, but instead attach comments to other AST nodes.\nPreviously this was worked around in TS by creating a `NotEmittedStatement`\nAST node to attach the comment to. But Babel does not have this facility,\nso it will not be a viable approach for the linker.\n\nThis commit refactors the output AST, to remove the `CommentStmt` and\n`JSDocCommentStmt` nodes. Instead statements have a collection of\n`leadingComments` that are rendered/attached to the final AST nodes\nwhen being translated or printed.\n\nPR Close #38811",
    "sha": "d795a001375a7d06592450d6f57a4f05d4d3e8e9",
    "files": [
        {
            "sha": "62f6ce86ec2b56b8b24f0bcc14b99c90389c376f",
            "filename": "packages/compiler-cli/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2FBUILD.bazel?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -32,6 +32,7 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/perf\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\",\n         \"//packages/compiler-cli/src/ngtsc/shims\",\n+        \"//packages/compiler-cli/src/ngtsc/translator\",\n         \"//packages/compiler-cli/src/ngtsc/typecheck\",\n         \"@npm//@bazel/typescript\",\n         \"@npm//@types/node\","
        },
        {
            "sha": "8e02accfda01c461624341330365a1e49875c5bf",
            "filename": "packages/compiler-cli/ngcc/src/rendering/renderer.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 14,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Frenderer.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Frenderer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Frenderer.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -5,7 +5,7 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {CommentStmt, ConstantPool, Expression, Statement, WrappedNodeExpr, WritePropExpr} from '@angular/compiler';\n+import {ConstantPool, Expression, jsDocComment, LeadingComment, Statement, WrappedNodeExpr, WritePropExpr} from '@angular/compiler';\n import MagicString from 'magic-string';\n import * as ts from 'typescript';\n \n@@ -166,11 +166,11 @@ export class Renderer {\n       sourceFile: ts.SourceFile, compiledClass: CompiledClass, imports: ImportManager,\n       annotateForClosureCompiler: boolean): string {\n     const name = this.host.getInternalNameOfClass(compiledClass.declaration);\n-    const statements: Statement[][] = compiledClass.compilation.map(c => {\n-      return createAssignmentStatements(\n-          name, c.name, c.initializer, annotateForClosureCompiler ? '* @nocollapse ' : undefined);\n-    });\n-    return this.renderStatements(sourceFile, Array.prototype.concat.apply([], statements), imports);\n+    const leadingComment =\n+        annotateForClosureCompiler ? jsDocComment([{tagName: 'nocollapse'}]) : undefined;\n+    const statements: Statement[] = compiledClass.compilation.map(\n+        c => createAssignmentStatement(name, c.name, c.initializer, leadingComment));\n+    return this.renderStatements(sourceFile, statements, imports);\n   }\n \n   /**\n@@ -213,16 +213,16 @@ export function renderConstantPool(\n  * compiled decorator to be applied to the class.\n  * @param analyzedClass The info about the class whose statement we want to create.\n  */\n-function createAssignmentStatements(\n+function createAssignmentStatement(\n     receiverName: ts.DeclarationName, propName: string, initializer: Expression,\n-    leadingComment?: string): Statement[] {\n+    leadingComment?: LeadingComment): Statement {\n   const receiver = new WrappedNodeExpr(receiverName);\n-  const statements =\n-      [new WritePropExpr(\n-           receiver, propName, initializer, /* type */ undefined, /* sourceSpan */ undefined)\n-           .toStmt()];\n+  const statement =\n+      new WritePropExpr(\n+          receiver, propName, initializer, /* type */ undefined, /* sourceSpan */ undefined)\n+          .toStmt();\n   if (leadingComment !== undefined) {\n-    statements.unshift(new CommentStmt(leadingComment, true));\n+    statement.addLeadingComment(leadingComment);\n   }\n-  return statements;\n+  return statement;\n }"
        },
        {
            "sha": "16c7dc89351ab53dd775c63907e291791bf5cfcf",
            "filename": "packages/compiler-cli/ngcc/test/integration/ngcc_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fintegration%2Fngcc_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fintegration%2Fngcc_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fintegration%2Fngcc_spec.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -1663,12 +1663,12 @@ runInEachFileSystem(() => {\n             JSON.stringify({angularCompilerOptions: {annotateForClosureCompiler: true}}));\n         mainNgcc({basePath: '/dist', propertiesToConsider: ['es2015']});\n         const jsContents = fs.readFile(_(`/dist/local-package/index.js`));\n-        expect(jsContents).toContain('/** @nocollapse */ \\nAppComponent.ɵcmp =');\n+        expect(jsContents).toContain('/** @nocollapse */\\nAppComponent.ɵcmp =');\n       });\n       it('should default to not give closure annotated output', () => {\n         mainNgcc({basePath: '/dist', propertiesToConsider: ['es2015']});\n         const jsContents = fs.readFile(_(`/dist/local-package/index.js`));\n-        expect(jsContents).not.toContain('/** @nocollapse */');\n+        expect(jsContents).not.toContain('@nocollapse');\n       });\n     });\n "
        },
        {
            "sha": "f5635550e328c2ab531d099a323e4da9916d4a37",
            "filename": "packages/compiler-cli/src/ngtsc/modulewithproviders/src/scanner.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmodulewithproviders%2Fsrc%2Fscanner.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmodulewithproviders%2Fsrc%2Fscanner.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmodulewithproviders%2Fsrc%2Fscanner.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -103,7 +103,7 @@ export class ModuleWithProvidersScanner {\n         this.emitter.emit(ngModule, decl.getSourceFile(), ImportFlags.ForceNewImport);\n     const ngModuleType = new ExpressionType(ngModuleExpr);\n     const mwpNgType = new ExpressionType(\n-        new ExternalExpr(Identifiers.ModuleWithProviders), /* modifiers */ null, [ngModuleType]);\n+        new ExternalExpr(Identifiers.ModuleWithProviders), [/* modifiers */], [ngModuleType]);\n \n     dts.addTypeReplacement(decl, mwpNgType);\n   }"
        },
        {
            "sha": "64338c54885dc85efb72bb313a708f65c52079ed",
            "filename": "packages/compiler-cli/src/ngtsc/translator/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Findex.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -6,4 +6,4 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-export {Import, ImportManager, NamedImport, translateExpression, translateStatement, translateType} from './src/translator';\n+export {attachComments, Import, ImportManager, NamedImport, translateExpression, translateStatement, translateType} from './src/translator';"
        },
        {
            "sha": "84c1d926f1be908205274efc88069fd9a9273433",
            "filename": "packages/compiler-cli/src/ngtsc/translator/src/translator.ts",
            "status": "modified",
            "additions": 67,
            "deletions": 44,
            "changes": 111,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftranslator.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftranslator.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftranslator.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {ArrayType, AssertNotNull, BinaryOperator, BinaryOperatorExpr, BuiltinType, BuiltinTypeName, CastExpr, ClassStmt, CommaExpr, CommentStmt, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionType, ExpressionVisitor, ExternalExpr, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, JSDocCommentStmt, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, ParseSourceSpan, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, Statement, StatementVisitor, StmtModifier, ThrowStmt, TryCatchStmt, Type, TypeofExpr, TypeVisitor, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr} from '@angular/compiler';\n+import {ArrayType, AssertNotNull, BinaryOperator, BinaryOperatorExpr, BuiltinType, BuiltinTypeName, CastExpr, ClassStmt, CommaExpr, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionType, ExpressionVisitor, ExternalExpr, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, LeadingComment, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, ParseSourceSpan, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, Statement, StatementVisitor, StmtModifier, ThrowStmt, TryCatchStmt, Type, TypeofExpr, TypeVisitor, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr} from '@angular/compiler';\n import {LocalizedString, UnaryOperator, UnaryOperatorExpr} from '@angular/compiler/src/output/output_ast';\n import * as ts from 'typescript';\n \n@@ -134,34 +134,45 @@ class ExpressionTranslatorVisitor implements ExpressionVisitor, StatementVisitor\n       private scriptTarget: Exclude<ts.ScriptTarget, ts.ScriptTarget.JSON>) {}\n \n   visitDeclareVarStmt(stmt: DeclareVarStmt, context: Context): ts.VariableStatement {\n-    const nodeFlags =\n-        ((this.scriptTarget >= ts.ScriptTarget.ES2015) && stmt.hasModifier(StmtModifier.Final)) ?\n-        ts.NodeFlags.Const :\n-        ts.NodeFlags.None;\n-    return ts.createVariableStatement(\n-        undefined,\n-        ts.createVariableDeclarationList(\n-            [ts.createVariableDeclaration(\n-                stmt.name, undefined,\n-                stmt.value && stmt.value.visitExpression(this, context.withExpressionMode))],\n-            nodeFlags));\n+    const isConst =\n+        this.scriptTarget >= ts.ScriptTarget.ES2015 && stmt.hasModifier(StmtModifier.Final);\n+    const varDeclaration = ts.createVariableDeclaration(\n+        /* name */ stmt.name,\n+        /* type */ undefined,\n+        /* initializer */ stmt.value?.visitExpression(this, context.withExpressionMode));\n+    const declarationList = ts.createVariableDeclarationList(\n+        /* declarations */[varDeclaration],\n+        /* flags */ isConst ? ts.NodeFlags.Const : ts.NodeFlags.None);\n+    const varStatement = ts.createVariableStatement(undefined, declarationList);\n+    return attachComments(varStatement, stmt.leadingComments);\n   }\n \n   visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: Context): ts.FunctionDeclaration {\n-    return ts.createFunctionDeclaration(\n-        undefined, undefined, undefined, stmt.name, undefined,\n+    const fnDeclaration = ts.createFunctionDeclaration(\n+        /* decorators */ undefined,\n+        /* modifiers */ undefined,\n+        /* asterisk */ undefined,\n+        /* name */ stmt.name,\n+        /* typeParameters */ undefined,\n+        /* parameters */\n         stmt.params.map(param => ts.createParameter(undefined, undefined, undefined, param.name)),\n-        undefined,\n+        /* type */ undefined,\n+        /* body */\n         ts.createBlock(\n             stmt.statements.map(child => child.visitStatement(this, context.withStatementMode))));\n+    return attachComments(fnDeclaration, stmt.leadingComments);\n   }\n \n   visitExpressionStmt(stmt: ExpressionStatement, context: Context): ts.ExpressionStatement {\n-    return ts.createStatement(stmt.expr.visitExpression(this, context.withStatementMode));\n+    return attachComments(\n+        ts.createStatement(stmt.expr.visitExpression(this, context.withStatementMode)),\n+        stmt.leadingComments);\n   }\n \n   visitReturnStmt(stmt: ReturnStatement, context: Context): ts.ReturnStatement {\n-    return ts.createReturn(stmt.value.visitExpression(this, context.withExpressionMode));\n+    return attachComments(\n+        ts.createReturn(stmt.value.visitExpression(this, context.withExpressionMode)),\n+        stmt.leadingComments);\n   }\n \n   visitDeclareClassStmt(stmt: ClassStmt, context: Context) {\n@@ -174,40 +185,25 @@ class ExpressionTranslatorVisitor implements ExpressionVisitor, StatementVisitor\n   }\n \n   visitIfStmt(stmt: IfStmt, context: Context): ts.IfStatement {\n-    return ts.createIf(\n-        stmt.condition.visitExpression(this, context),\n+    const thenBlock = ts.createBlock(\n+        stmt.trueCase.map(child => child.visitStatement(this, context.withStatementMode)));\n+    const elseBlock = stmt.falseCase.length > 0 ?\n         ts.createBlock(\n-            stmt.trueCase.map(child => child.visitStatement(this, context.withStatementMode))),\n-        stmt.falseCase.length > 0 ?\n-            ts.createBlock(stmt.falseCase.map(\n-                child => child.visitStatement(this, context.withStatementMode))) :\n-            undefined);\n+            stmt.falseCase.map(child => child.visitStatement(this, context.withStatementMode))) :\n+        undefined;\n+    const ifStatement =\n+        ts.createIf(stmt.condition.visitExpression(this, context), thenBlock, elseBlock);\n+    return attachComments(ifStatement, stmt.leadingComments);\n   }\n \n   visitTryCatchStmt(stmt: TryCatchStmt, context: Context) {\n     throw new Error('Method not implemented.');\n   }\n \n   visitThrowStmt(stmt: ThrowStmt, context: Context): ts.ThrowStatement {\n-    return ts.createThrow(stmt.error.visitExpression(this, context.withExpressionMode));\n-  }\n-\n-  visitCommentStmt(stmt: CommentStmt, context: Context): ts.NotEmittedStatement {\n-    const commentStmt = ts.createNotEmittedStatement(ts.createLiteral(''));\n-    ts.addSyntheticLeadingComment(\n-        commentStmt,\n-        stmt.multiline ? ts.SyntaxKind.MultiLineCommentTrivia :\n-                         ts.SyntaxKind.SingleLineCommentTrivia,\n-        stmt.comment, /** hasTrailingNewLine */ false);\n-    return commentStmt;\n-  }\n-\n-  visitJSDocCommentStmt(stmt: JSDocCommentStmt, context: Context): ts.NotEmittedStatement {\n-    const commentStmt = ts.createNotEmittedStatement(ts.createLiteral(''));\n-    const text = stmt.toString();\n-    const kind = ts.SyntaxKind.MultiLineCommentTrivia;\n-    ts.setSyntheticLeadingComments(commentStmt, [{kind, text, pos: -1, end: -1}]);\n-    return commentStmt;\n+    return attachComments(\n+        ts.createThrow(stmt.error.visitExpression(this, context.withExpressionMode)),\n+        stmt.leadingComments);\n   }\n \n   visitReadVarExpr(ast: ReadVarExpr, context: Context): ts.Identifier {\n@@ -784,4 +780,31 @@ function createTemplateTail(cooked: string, raw: string): ts.TemplateTail {\n   const node: ts.TemplateLiteralLikeNode = ts.createTemplateHead(cooked, raw);\n   (node.kind as ts.SyntaxKind) = ts.SyntaxKind.TemplateTail;\n   return node as ts.TemplateTail;\n-}\n\\ No newline at end of file\n+}\n+\n+/**\n+ * Attach the given `leadingComments` to the `statement` node.\n+ *\n+ * @param statement The statement that will have comments attached.\n+ * @param leadingComments The comments to attach to the statement.\n+ */\n+export function attachComments<T extends ts.Statement>(\n+    statement: T, leadingComments?: LeadingComment[]): T {\n+  if (leadingComments === undefined) {\n+    return statement;\n+  }\n+\n+  for (const comment of leadingComments) {\n+    const commentKind = comment.multiline ? ts.SyntaxKind.MultiLineCommentTrivia :\n+                                            ts.SyntaxKind.SingleLineCommentTrivia;\n+    if (comment.multiline) {\n+      ts.addSyntheticLeadingComment(\n+          statement, commentKind, comment.toString(), comment.trailingNewline);\n+    } else {\n+      for (const line of comment.text.split('\\n')) {\n+        ts.addSyntheticLeadingComment(statement, commentKind, line, comment.trailingNewline);\n+      }\n+    }\n+  }\n+  return statement;\n+}"
        },
        {
            "sha": "48b1bca849b6b6a320daf8dc1be5d7b0a190001f",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/environment.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -245,7 +245,8 @@ export class Environment {\n    */\n   referenceExternalType(moduleName: string, name: string, typeParams?: Type[]): ts.TypeNode {\n     const external = new ExternalExpr({moduleName, name});\n-    return translateType(new ExpressionType(external, null, typeParams), this.importManager);\n+    return translateType(\n+        new ExpressionType(external, [/* modifiers */], typeParams), this.importManager);\n   }\n \n   getPreludeStatements(): ts.Statement[] {"
        },
        {
            "sha": "333c324d50ad7684f069b750c558081e49e6dc02",
            "filename": "packages/compiler-cli/src/transformers/node_emitter.ts",
            "status": "modified",
            "additions": 54,
            "deletions": 75,
            "changes": 129,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fnode_emitter.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fnode_emitter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fnode_emitter.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -6,10 +6,10 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AssertNotNull, BinaryOperator, BinaryOperatorExpr, BuiltinMethod, BuiltinVar, CastExpr, ClassStmt, CommaExpr, CommentStmt, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, ExpressionStatement, ExpressionVisitor, ExternalExpr, ExternalReference, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, JSDocCommentStmt, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, NotExpr, ParseSourceFile, ParseSourceSpan, PartialModule, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, Statement, StatementVisitor, StmtModifier, ThrowStmt, TryCatchStmt, TypeofExpr, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr} from '@angular/compiler';\n-import {LocalizedString, UnaryOperator, UnaryOperatorExpr} from '@angular/compiler/src/output/output_ast';\n+import {AssertNotNull, BinaryOperator, BinaryOperatorExpr, BuiltinMethod, BuiltinVar, CastExpr, ClassStmt, CommaExpr, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, ExpressionStatement, ExpressionVisitor, ExternalExpr, ExternalReference, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, LeadingComment, leadingComment, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, LocalizedString, NotExpr, ParseSourceFile, ParseSourceSpan, PartialModule, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, Statement, StatementVisitor, StmtModifier, ThrowStmt, TryCatchStmt, TypeofExpr, UnaryOperator, UnaryOperatorExpr, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr} from '@angular/compiler';\n import * as ts from 'typescript';\n \n+import {attachComments} from '../ngtsc/translator';\n import {error} from './util';\n \n export interface Node {\n@@ -31,30 +31,25 @@ export class TypeScriptNodeEmitter {\n     // stmts.\n     const statements: any[] = [].concat(\n         ...stmts.map(stmt => stmt.visitStatement(converter, null)).filter(stmt => stmt != null));\n-    const preambleStmts: ts.Statement[] = [];\n+    const sourceStatements =\n+        [...converter.getReexports(), ...converter.getImports(), ...statements];\n     if (preamble) {\n-      const commentStmt = this.createCommentStatement(sourceFile, preamble);\n-      preambleStmts.push(commentStmt);\n+      // We always attach the preamble comment to a `NotEmittedStatement` node, because tsickle uses\n+      // this node type as a marker of the preamble to ensure that it adds its own new nodes after\n+      // the preamble.\n+      const preambleCommentHolder = ts.createNotEmittedStatement(sourceFile);\n+      // Preamble comments are passed through as-is, which means that they must already contain a\n+      // leading `*` if they should be a JSDOC comment.\n+      ts.addSyntheticLeadingComment(\n+          preambleCommentHolder, ts.SyntaxKind.MultiLineCommentTrivia, preamble,\n+          /* hasTrailingNewline */ true);\n+      sourceStatements.unshift(preambleCommentHolder);\n     }\n-    const sourceStatements =\n-        [...preambleStmts, ...converter.getReexports(), ...converter.getImports(), ...statements];\n+\n     converter.updateSourceMap(sourceStatements);\n     const newSourceFile = ts.updateSourceFileNode(sourceFile, sourceStatements);\n     return [newSourceFile, converter.getNodeMap()];\n   }\n-\n-  /** Creates a not emitted statement containing the given comment. */\n-  createCommentStatement(sourceFile: ts.SourceFile, comment: string): ts.Statement {\n-    if (comment.startsWith('/*') && comment.endsWith('*/')) {\n-      comment = comment.substr(2, comment.length - 4);\n-    }\n-    const commentStmt = ts.createNotEmittedStatement(sourceFile);\n-    ts.setSyntheticLeadingComments(\n-        commentStmt,\n-        [{kind: ts.SyntaxKind.MultiLineCommentTrivia, text: comment, pos: -1, end: -1}]);\n-    ts.setEmitFlags(commentStmt, ts.EmitFlags.CustomPrologue);\n-    return commentStmt;\n-  }\n }\n \n /**\n@@ -288,10 +283,13 @@ export class NodeEmitterVisitor implements StatementVisitor, ExpressionVisitor {\n     recordLastSourceRange();\n   }\n \n-  private record<T extends ts.Node>(ngNode: Node, tsNode: T|null): RecordedNode<T> {\n+  private postProcess<T extends ts.Node>(ngNode: Node, tsNode: T|null): RecordedNode<T> {\n     if (tsNode && !this._nodeMap.has(tsNode)) {\n       this._nodeMap.set(tsNode, ngNode);\n     }\n+    if (tsNode !== null && ngNode instanceof Statement) {\n+      attachComments(tsNode as unknown as ts.Statement, ngNode.leadingComments);\n+    }\n     return tsNode as RecordedNode<T>;\n   }\n \n@@ -347,19 +345,19 @@ export class NodeEmitterVisitor implements StatementVisitor, ExpressionVisitor {\n       // Note: We need to add an explicit variable and export declaration so that\n       // the variable can be referred in the same file as well.\n       const tsVarStmt =\n-          this.record(stmt, ts.createVariableStatement(/* modifiers */[], varDeclList));\n-      const exportStmt = this.record(\n+          this.postProcess(stmt, ts.createVariableStatement(/* modifiers */[], varDeclList));\n+      const exportStmt = this.postProcess(\n           stmt,\n           ts.createExportDeclaration(\n               /*decorators*/ undefined, /*modifiers*/ undefined,\n               ts.createNamedExports([ts.createExportSpecifier(stmt.name, stmt.name)])));\n       return [tsVarStmt, exportStmt];\n     }\n-    return this.record(stmt, ts.createVariableStatement(this.getModifiers(stmt), varDeclList));\n+    return this.postProcess(stmt, ts.createVariableStatement(this.getModifiers(stmt), varDeclList));\n   }\n \n   visitDeclareFunctionStmt(stmt: DeclareFunctionStmt) {\n-    return this.record(\n+    return this.postProcess(\n         stmt,\n         ts.createFunctionDeclaration(\n             /* decorators */ undefined, this.getModifiers(stmt),\n@@ -372,11 +370,11 @@ export class NodeEmitterVisitor implements StatementVisitor, ExpressionVisitor {\n   }\n \n   visitExpressionStmt(stmt: ExpressionStatement) {\n-    return this.record(stmt, ts.createStatement(stmt.expr.visitExpression(this, null)));\n+    return this.postProcess(stmt, ts.createStatement(stmt.expr.visitExpression(this, null)));\n   }\n \n   visitReturnStmt(stmt: ReturnStatement) {\n-    return this.record(\n+    return this.postProcess(\n         stmt, ts.createReturn(stmt.value ? stmt.value.visitExpression(this, null) : undefined));\n   }\n \n@@ -434,7 +432,7 @@ export class NodeEmitterVisitor implements StatementVisitor, ExpressionVisitor {\n                                         /* decorators */ undefined, /* modifiers */ undefined,\n                                         /* dotDotDotToken */ undefined, p.name)),\n                                 /* type */ undefined, this._visitStatements(method.body)));\n-    return this.record(\n+    return this.postProcess(\n         stmt,\n         ts.createClassDeclaration(\n             /* decorators */ undefined, modifiers, stmt.name, /* typeParameters*/ undefined,\n@@ -446,7 +444,7 @@ export class NodeEmitterVisitor implements StatementVisitor, ExpressionVisitor {\n   }\n \n   visitIfStmt(stmt: IfStmt) {\n-    return this.record(\n+    return this.postProcess(\n         stmt,\n         ts.createIf(\n             stmt.condition.visitExpression(this, null), this._visitStatements(stmt.trueCase),\n@@ -455,7 +453,7 @@ export class NodeEmitterVisitor implements StatementVisitor, ExpressionVisitor {\n   }\n \n   visitTryCatchStmt(stmt: TryCatchStmt): RecordedNode<ts.TryStatement> {\n-    return this.record(\n+    return this.postProcess(\n         stmt,\n         ts.createTry(\n             this._visitStatements(stmt.bodyStmts),\n@@ -474,64 +472,46 @@ export class NodeEmitterVisitor implements StatementVisitor, ExpressionVisitor {\n   }\n \n   visitThrowStmt(stmt: ThrowStmt) {\n-    return this.record(stmt, ts.createThrow(stmt.error.visitExpression(this, null)));\n-  }\n-\n-  visitCommentStmt(stmt: CommentStmt, sourceFile: ts.SourceFile) {\n-    const text = stmt.multiline ? ` ${stmt.comment} ` : ` ${stmt.comment}`;\n-    return this.createCommentStmt(text, stmt.multiline, sourceFile);\n-  }\n-\n-  visitJSDocCommentStmt(stmt: JSDocCommentStmt, sourceFile: ts.SourceFile) {\n-    return this.createCommentStmt(stmt.toString(), true, sourceFile);\n-  }\n-\n-  private createCommentStmt(text: string, multiline: boolean, sourceFile: ts.SourceFile):\n-      ts.NotEmittedStatement {\n-    const commentStmt = ts.createNotEmittedStatement(sourceFile);\n-    const kind =\n-        multiline ? ts.SyntaxKind.MultiLineCommentTrivia : ts.SyntaxKind.SingleLineCommentTrivia;\n-    ts.setSyntheticLeadingComments(commentStmt, [{kind, text, pos: -1, end: -1}]);\n-    return commentStmt;\n+    return this.postProcess(stmt, ts.createThrow(stmt.error.visitExpression(this, null)));\n   }\n \n   // ExpressionVisitor\n   visitWrappedNodeExpr(expr: WrappedNodeExpr<any>) {\n-    return this.record(expr, expr.node);\n+    return this.postProcess(expr, expr.node);\n   }\n \n   visitTypeofExpr(expr: TypeofExpr) {\n     const typeOf = ts.createTypeOf(expr.expr.visitExpression(this, null));\n-    return this.record(expr, typeOf);\n+    return this.postProcess(expr, typeOf);\n   }\n \n   // ExpressionVisitor\n   visitReadVarExpr(expr: ReadVarExpr) {\n     switch (expr.builtin) {\n       case BuiltinVar.This:\n-        return this.record(expr, ts.createIdentifier(METHOD_THIS_NAME));\n+        return this.postProcess(expr, ts.createIdentifier(METHOD_THIS_NAME));\n       case BuiltinVar.CatchError:\n-        return this.record(expr, ts.createIdentifier(CATCH_ERROR_NAME));\n+        return this.postProcess(expr, ts.createIdentifier(CATCH_ERROR_NAME));\n       case BuiltinVar.CatchStack:\n-        return this.record(expr, ts.createIdentifier(CATCH_STACK_NAME));\n+        return this.postProcess(expr, ts.createIdentifier(CATCH_STACK_NAME));\n       case BuiltinVar.Super:\n-        return this.record(expr, ts.createSuper());\n+        return this.postProcess(expr, ts.createSuper());\n     }\n     if (expr.name) {\n-      return this.record(expr, ts.createIdentifier(expr.name));\n+      return this.postProcess(expr, ts.createIdentifier(expr.name));\n     }\n     throw Error(`Unexpected ReadVarExpr form`);\n   }\n \n   visitWriteVarExpr(expr: WriteVarExpr): RecordedNode<ts.BinaryExpression> {\n-    return this.record(\n+    return this.postProcess(\n         expr,\n         ts.createAssignment(\n             ts.createIdentifier(expr.name), expr.value.visitExpression(this, null)));\n   }\n \n   visitWriteKeyExpr(expr: WriteKeyExpr): RecordedNode<ts.BinaryExpression> {\n-    return this.record(\n+    return this.postProcess(\n         expr,\n         ts.createAssignment(\n             ts.createElementAccess(\n@@ -540,7 +520,7 @@ export class NodeEmitterVisitor implements StatementVisitor, ExpressionVisitor {\n   }\n \n   visitWritePropExpr(expr: WritePropExpr): RecordedNode<ts.BinaryExpression> {\n-    return this.record(\n+    return this.postProcess(\n         expr,\n         ts.createAssignment(\n             ts.createPropertyAccess(expr.receiver.visitExpression(this, null), expr.name),\n@@ -549,52 +529,52 @@ export class NodeEmitterVisitor implements StatementVisitor, ExpressionVisitor {\n \n   visitInvokeMethodExpr(expr: InvokeMethodExpr): RecordedNode<ts.CallExpression> {\n     const methodName = getMethodName(expr);\n-    return this.record(\n+    return this.postProcess(\n         expr,\n         ts.createCall(\n             ts.createPropertyAccess(expr.receiver.visitExpression(this, null), methodName),\n             /* typeArguments */ undefined, expr.args.map(arg => arg.visitExpression(this, null))));\n   }\n \n   visitInvokeFunctionExpr(expr: InvokeFunctionExpr): RecordedNode<ts.CallExpression> {\n-    return this.record(\n+    return this.postProcess(\n         expr,\n         ts.createCall(\n             expr.fn.visitExpression(this, null), /* typeArguments */ undefined,\n             expr.args.map(arg => arg.visitExpression(this, null))));\n   }\n \n   visitInstantiateExpr(expr: InstantiateExpr): RecordedNode<ts.NewExpression> {\n-    return this.record(\n+    return this.postProcess(\n         expr,\n         ts.createNew(\n             expr.classExpr.visitExpression(this, null), /* typeArguments */ undefined,\n             expr.args.map(arg => arg.visitExpression(this, null))));\n   }\n \n   visitLiteralExpr(expr: LiteralExpr) {\n-    return this.record(expr, createLiteral(expr.value));\n+    return this.postProcess(expr, createLiteral(expr.value));\n   }\n \n   visitLocalizedString(expr: LocalizedString, context: any) {\n     throw new Error('localized strings are not supported in pre-ivy mode.');\n   }\n \n   visitExternalExpr(expr: ExternalExpr) {\n-    return this.record(expr, this._visitIdentifier(expr.value));\n+    return this.postProcess(expr, this._visitIdentifier(expr.value));\n   }\n \n   visitConditionalExpr(expr: ConditionalExpr): RecordedNode<ts.ParenthesizedExpression> {\n     // TODO {chuckj}: Review use of ! on falseCase. Should it be non-nullable?\n-    return this.record(\n+    return this.postProcess(\n         expr,\n         ts.createParen(ts.createConditional(\n             expr.condition.visitExpression(this, null), expr.trueCase.visitExpression(this, null),\n             expr.falseCase!.visitExpression(this, null))));\n   }\n \n   visitNotExpr(expr: NotExpr): RecordedNode<ts.PrefixUnaryExpression> {\n-    return this.record(\n+    return this.postProcess(\n         expr,\n         ts.createPrefix(\n             ts.SyntaxKind.ExclamationToken, expr.condition.visitExpression(this, null)));\n@@ -609,7 +589,7 @@ export class NodeEmitterVisitor implements StatementVisitor, ExpressionVisitor {\n   }\n \n   visitFunctionExpr(expr: FunctionExpr) {\n-    return this.record(\n+    return this.postProcess(\n         expr,\n         ts.createFunctionExpression(\n             /* modifiers */ undefined, /* astriskToken */ undefined,\n@@ -636,7 +616,7 @@ export class NodeEmitterVisitor implements StatementVisitor, ExpressionVisitor {\n         throw new Error(`Unknown operator: ${expr.operator}`);\n     }\n     const binary = ts.createPrefix(unaryOperator, expr.expr.visitExpression(this, null));\n-    return this.record(expr, expr.parens ? ts.createParen(binary) : binary);\n+    return this.postProcess(expr, expr.parens ? ts.createParen(binary) : binary);\n   }\n \n   visitBinaryOperatorExpr(expr: BinaryOperatorExpr):\n@@ -696,28 +676,28 @@ export class NodeEmitterVisitor implements StatementVisitor, ExpressionVisitor {\n     }\n     const binary = ts.createBinary(\n         expr.lhs.visitExpression(this, null), binaryOperator, expr.rhs.visitExpression(this, null));\n-    return this.record(expr, expr.parens ? ts.createParen(binary) : binary);\n+    return this.postProcess(expr, expr.parens ? ts.createParen(binary) : binary);\n   }\n \n   visitReadPropExpr(expr: ReadPropExpr): RecordedNode<ts.PropertyAccessExpression> {\n-    return this.record(\n+    return this.postProcess(\n         expr, ts.createPropertyAccess(expr.receiver.visitExpression(this, null), expr.name));\n   }\n \n   visitReadKeyExpr(expr: ReadKeyExpr): RecordedNode<ts.ElementAccessExpression> {\n-    return this.record(\n+    return this.postProcess(\n         expr,\n         ts.createElementAccess(\n             expr.receiver.visitExpression(this, null), expr.index.visitExpression(this, null)));\n   }\n \n   visitLiteralArrayExpr(expr: LiteralArrayExpr): RecordedNode<ts.ArrayLiteralExpression> {\n-    return this.record(\n+    return this.postProcess(\n         expr, ts.createArrayLiteral(expr.entries.map(entry => entry.visitExpression(this, null))));\n   }\n \n   visitLiteralMapExpr(expr: LiteralMapExpr): RecordedNode<ts.ObjectLiteralExpression> {\n-    return this.record(\n+    return this.postProcess(\n         expr,\n         ts.createObjectLiteral(expr.entries.map(\n             entry => ts.createPropertyAssignment(\n@@ -728,7 +708,7 @@ export class NodeEmitterVisitor implements StatementVisitor, ExpressionVisitor {\n   }\n \n   visitCommaExpr(expr: CommaExpr): RecordedNode<ts.Expression> {\n-    return this.record(\n+    return this.postProcess(\n         expr,\n         expr.parts.map(e => e.visitExpression(this, null))\n             .reduce<ts.Expression|null>(\n@@ -773,7 +753,6 @@ export class NodeEmitterVisitor implements StatementVisitor, ExpressionVisitor {\n   }\n }\n \n-\n function getMethodName(methodRef: {name: string|null; builtin: BuiltinMethod | null}): string {\n   if (methodRef.name) {\n     return methodRef.name;"
        },
        {
            "sha": "043b6bcbecb8b070fdca5ecaeeced2c66fc25e41",
            "filename": "packages/compiler-cli/src/transformers/node_emitter_transform.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 9,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fnode_emitter_transform.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fnode_emitter_transform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fnode_emitter_transform.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -10,15 +10,15 @@ import {GeneratedFile} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {TypeScriptNodeEmitter} from './node_emitter';\n-import {GENERATED_FILES} from './util';\n+import {GENERATED_FILES, stripComment} from './util';\n \n function getPreamble(original: string) {\n-  return `/**\n+  return `*\n  * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n  * ${original}\n  * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes,extraRequire}\n  * tslint:disable\n- */`;\n+ `;\n }\n \n /**\n@@ -41,18 +41,18 @@ export function getAngularEmitterTransformFactory(\n       if (orig) originalComment = getFileoverviewComment(orig);\n       const preamble = getPreamble(originalComment);\n       if (g && g.stmts) {\n-        const orig = program.getSourceFile(g.srcFileUrl);\n-        let originalComment = '';\n-        if (orig) originalComment = getFileoverviewComment(orig);\n         const [newSourceFile] = emitter.updateSourceFile(sourceFile, g.stmts, preamble);\n         return newSourceFile;\n       } else if (GENERATED_FILES.test(sourceFile.fileName)) {\n         // The file should be empty, but emitter.updateSourceFile would still add imports\n         // and various minutiae.\n         // Clear out the source file entirely, only including the preamble comment, so that\n         // ngc produces an empty .js file.\n-        return ts.updateSourceFileNode(\n-            sourceFile, [emitter.createCommentStatement(sourceFile, preamble)]);\n+        const commentStmt = ts.createNotEmittedStatement(sourceFile);\n+        ts.addSyntheticLeadingComment(\n+            commentStmt, ts.SyntaxKind.MultiLineCommentTrivia, preamble,\n+            /* hasTrailingNewline */ true);\n+        return ts.updateSourceFileNode(sourceFile, [commentStmt]);\n       }\n       return sourceFile;\n     };\n@@ -75,5 +75,6 @@ function getFileoverviewComment(sourceFile: ts.SourceFile): string {\n   const commentText = sourceFile.getFullText().substring(comment.pos, comment.end);\n   // Closure Compiler ignores @suppress and similar if the comment contains @license.\n   if (commentText.indexOf('@license') !== -1) return '';\n-  return commentText.replace(/^\\/\\*\\*/, '').replace(/ ?\\*\\/$/, '');\n+  // Also remove any leading `* ` from the first line in case it was a JSDOC comment\n+  return stripComment(commentText).replace(/^\\*\\s+/, '');\n }"
        },
        {
            "sha": "47fdb141457b5c635397bef1dac56f5e67e0d960",
            "filename": "packages/compiler-cli/src/transformers/util.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Futil.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -94,3 +94,12 @@ export function ngToTsDiagnostic(ng: Diagnostic): ts.Diagnostic {\n     length,\n   };\n }\n+\n+/**\n+ * Strip multiline comment start and end markers from the `commentText` string.\n+ *\n+ * This will also strip the JSDOC comment start marker (`/**`).\n+ */\n+export function stripComment(commentText: string): string {\n+  return commentText.replace(/^\\/\\*\\*?/, '').replace(/\\*\\/$/, '').trim();\n+}"
        },
        {
            "sha": "0e35c3ee8ca99921ec136ad17560a63711395d81",
            "filename": "packages/compiler-cli/test/ngc_spec.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Ftest%2Fngc_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Ftest%2Fngc_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngc_spec.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -141,7 +141,7 @@ describe('ngc transformer command-line', () => {\n       write('mymodule.ts', `\n         import {NgModule} from '@angular/core';\n         import {AClass} from './aclass';\n-  \n+\n         @NgModule({declarations: []})\n         export class MyModule {\n           constructor(importedClass: AClass) {}\n@@ -382,13 +382,13 @@ describe('ngc transformer command-line', () => {\n         })\n         export class MyModule {}\n       `);\n-        expect(contents).toContain('@fileoverview');\n-        expect(contents).toContain('generated by the Angular template compiler');\n-        expect(contents).toContain('@suppress {suspiciousCode');\n+        expect(contents).toContain(\n+            '/**\\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.');\n+        expect(contents).toContain('\\n * @suppress {suspiciousCode');\n       });\n \n       it('should be merged with existing fileoverview comments', () => {\n-        const contents = compileAndRead(`/** Hello world. */\n+        const contents = compileAndRead(`/**\\n * @fileoverview Hello world.\\n */\n \n         import {CommonModule} from '@angular/common';\n         import {NgModule} from '@angular/core';\n@@ -398,7 +398,7 @@ describe('ngc transformer command-line', () => {\n         })\n         export class MyModule {}\n       `);\n-        expect(contents).toContain('Hello world.');\n+        expect(contents).toContain('\\n * @fileoverview Hello world.\\n');\n       });\n \n       it('should only pick file comments', () => {"
        },
        {
            "sha": "f4915d77043ddbae913c1811170d23944ec08905",
            "filename": "packages/compiler-cli/test/transformers/node_emitter_spec.ts",
            "status": "modified",
            "additions": 43,
            "deletions": 22,
            "changes": 65,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fnode_emitter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fnode_emitter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fnode_emitter_spec.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -267,48 +267,69 @@ describe('TypeScriptNodeEmitter', () => {\n   });\n \n   describe('comments', () => {\n-    it('should support a preamble', () => {\n-      expect(emitStmt(o.variable('a').toStmt(), Format.Flat, '/* SomePreamble */'))\n-          .toBe('/* SomePreamble */ a;');\n-    });\n+    it('should support a preamble, which is wrapped as a multi-line comment with no trimming or padding',\n+       () => {\n+         expect(emitStmt(o.variable('a').toStmt(), Format.Raw, '*\\n * SomePreamble\\n '))\n+             .toBe('/**\\n * SomePreamble\\n */\\na;');\n+       });\n \n     it('should support singleline comments', () => {\n-      expect(emitStmt(new o.CommentStmt('Simple comment'))).toBe('// Simple comment');\n+      expect(emitStmt(\n+                 new o.ReturnStatement(o.literal(1), null, [o.leadingComment(' a\\n b', false)]),\n+                 Format.Raw))\n+          .toBe('// a\\n// b\\nreturn 1;');\n     });\n \n     it('should support multiline comments', () => {\n-      expect(emitStmt(new o.CommentStmt('Multiline comment', true)))\n-          .toBe('/* Multiline comment */');\n-      expect(emitStmt(new o.CommentStmt(`Multiline\\ncomment`, true), Format.Raw))\n-          .toBe(`/* Multiline\\ncomment */`);\n+      expect(emitStmt(\n+                 new o.ReturnStatement(\n+                     o.literal(1), null, [o.leadingComment('Multiline comment', true)]),\n+                 Format.Raw))\n+          .toBe('/* Multiline comment */\\nreturn 1;');\n+      expect(emitStmt(\n+                 new o.ReturnStatement(\n+                     o.literal(1), null, [o.leadingComment(`Multiline\\ncomment`, true)]),\n+                 Format.Raw))\n+          .toBe(`/* Multiline\\ncomment */\\nreturn 1;`);\n     });\n \n     describe('JSDoc comments', () => {\n       it('should be supported', () => {\n-        expect(emitStmt(new o.JSDocCommentStmt([{text: 'Intro comment'}]), Format.Raw))\n-            .toBe(`/**\\n * Intro comment\\n */`);\n         expect(emitStmt(\n-                   new o.JSDocCommentStmt([{tagName: o.JSDocTagName.Desc, text: 'description'}]),\n+                   new o.ReturnStatement(\n+                       o.literal(1), null, [o.jsDocComment([{text: 'Intro comment'}])]),\n                    Format.Raw))\n-            .toBe(`/**\\n * @desc description\\n */`);\n+            .toBe(`/**\\n * Intro comment\\n */\\nreturn 1;`);\n         expect(emitStmt(\n-                   new o.JSDocCommentStmt([\n-                     {text: 'Intro comment'},\n-                     {tagName: o.JSDocTagName.Desc, text: 'description'},\n-                     {tagName: o.JSDocTagName.Id, text: '{number} identifier 123'},\n-                   ]),\n+                   new o.ReturnStatement(\n+                       o.literal(1), null,\n+                       [o.jsDocComment([{tagName: o.JSDocTagName.Desc, text: 'description'}])]),\n+                   Format.Raw))\n+            .toBe(`/**\\n * @desc description\\n */\\nreturn 1;`);\n+        expect(emitStmt(\n+                   new o.ReturnStatement(\n+                       o.literal(1), null, [o.jsDocComment([\n+                         {text: 'Intro comment'},\n+                         {tagName: o.JSDocTagName.Desc, text: 'description'},\n+                         {tagName: o.JSDocTagName.Id, text: '{number} identifier 123'},\n+                       ])]),\n                    Format.Raw))\n             .toBe(\n-                `/**\\n * Intro comment\\n * @desc description\\n * @id {number} identifier 123\\n */`);\n+                `/**\\n * Intro comment\\n * @desc description\\n * @id {number} identifier 123\\n */\\nreturn 1;`);\n       });\n \n       it('should escape @ in the text', () => {\n-        expect(emitStmt(new o.JSDocCommentStmt([{text: 'email@google.com'}]), Format.Raw))\n-            .toBe(`/**\\n * email\\\\@google.com\\n */`);\n+        expect(emitStmt(\n+                   new o.ReturnStatement(\n+                       o.literal(1), null, [o.jsDocComment([{text: 'email@google.com'}])]),\n+                   Format.Raw))\n+            .toBe(`/**\\n * email\\\\@google.com\\n */\\nreturn 1;`);\n       });\n \n       it('should not allow /* and */ in the text', () => {\n-        expect(() => emitStmt(new o.JSDocCommentStmt([{text: 'some text /* */'}]), Format.Raw))\n+        expect(\n+            () => emitStmt(new o.ReturnStatement(\n+                o.literal(1), null, [o.jsDocComment([{text: 'some text /* */'}])])))\n             .toThrowError(`JSDoc text cannot contain \"/*\" and \"*/\"`);\n       });\n     });"
        },
        {
            "sha": "c734932b8856d9f1527c63d434ba1dda6437f902",
            "filename": "packages/compiler/src/compiler.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Fsrc%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Fsrc%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fcompiler.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -78,7 +78,7 @@ export * from './ml_parser/tags';\n export {LexerRange} from './ml_parser/lexer';\n export * from './ml_parser/xml_parser';\n export {NgModuleCompiler} from './ng_module_compiler';\n-export {ArrayType, AssertNotNull, DYNAMIC_TYPE, BinaryOperator, BinaryOperatorExpr, BuiltinMethod, BuiltinType, BuiltinTypeName, BuiltinVar, CastExpr, ClassField, ClassMethod, ClassStmt, CommaExpr, CommentStmt, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionType, ExpressionVisitor, ExternalExpr, ExternalReference, literalMap, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, JSDocCommentStmt, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, NONE_TYPE, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, StatementVisitor, ThrowStmt, TryCatchStmt, Type, TypeVisitor, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr, StmtModifier, Statement, STRING_TYPE, TypeofExpr, collectExternalReferences} from './output/output_ast';\n+export {ArrayType, AssertNotNull, DYNAMIC_TYPE, BinaryOperator, BinaryOperatorExpr, BuiltinMethod, BuiltinType, BuiltinTypeName, BuiltinVar, CastExpr, ClassField, ClassMethod, ClassStmt, CommaExpr, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionType, ExpressionVisitor, ExternalExpr, ExternalReference, literalMap, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, MapType, NotExpr, NONE_TYPE, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, StatementVisitor, ThrowStmt, TryCatchStmt, Type, TypeVisitor, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr, StmtModifier, Statement, STRING_TYPE, TypeofExpr, collectExternalReferences, jsDocComment, leadingComment, LeadingComment, JSDocComment, UnaryOperator, UnaryOperatorExpr, LocalizedString} from './output/output_ast';\n export {EmitterVisitorContext} from './output/abstract_emitter';\n export {JitEvaluator} from './output/output_jit';\n export * from './output/ts_emitter';"
        },
        {
            "sha": "bbb561bacc8a2e5869e5dd413ee7e364fdcd1c94",
            "filename": "packages/compiler/src/output/abstract_emitter.ts",
            "status": "modified",
            "additions": 23,
            "deletions": 14,
            "changes": 37,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Fsrc%2Foutput%2Fabstract_emitter.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Fsrc%2Foutput%2Fabstract_emitter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Foutput%2Fabstract_emitter.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -202,13 +202,34 @@ export class EmitterVisitorContext {\n export abstract class AbstractEmitterVisitor implements o.StatementVisitor, o.ExpressionVisitor {\n   constructor(private _escapeDollarInStrings: boolean) {}\n \n+  protected printLeadingComments(stmt: o.Statement, ctx: EmitterVisitorContext): void {\n+    if (stmt.leadingComments === undefined) {\n+      return;\n+    }\n+    for (const comment of stmt.leadingComments) {\n+      if (comment instanceof o.JSDocComment) {\n+        ctx.print(stmt, `/*${comment.toString()}*/`, comment.trailingNewline);\n+      } else {\n+        if (comment.multiline) {\n+          ctx.print(stmt, `/* ${comment.text} */`, comment.trailingNewline);\n+        } else {\n+          comment.text.split('\\n').forEach((line) => {\n+            ctx.println(stmt, `// ${line}`);\n+          });\n+        }\n+      }\n+    }\n+  }\n+\n   visitExpressionStmt(stmt: o.ExpressionStatement, ctx: EmitterVisitorContext): any {\n+    this.printLeadingComments(stmt, ctx);\n     stmt.expr.visitExpression(this, ctx);\n     ctx.println(stmt, ';');\n     return null;\n   }\n \n   visitReturnStmt(stmt: o.ReturnStatement, ctx: EmitterVisitorContext): any {\n+    this.printLeadingComments(stmt, ctx);\n     ctx.print(stmt, `return `);\n     stmt.value.visitExpression(this, ctx);\n     ctx.println(stmt, ';');\n@@ -220,6 +241,7 @@ export abstract class AbstractEmitterVisitor implements o.StatementVisitor, o.Ex\n   abstract visitDeclareClassStmt(stmt: o.ClassStmt, ctx: EmitterVisitorContext): any;\n \n   visitIfStmt(stmt: o.IfStmt, ctx: EmitterVisitorContext): any {\n+    this.printLeadingComments(stmt, ctx);\n     ctx.print(stmt, `if (`);\n     stmt.condition.visitExpression(this, ctx);\n     ctx.print(stmt, `) {`);\n@@ -248,25 +270,12 @@ export abstract class AbstractEmitterVisitor implements o.StatementVisitor, o.Ex\n   abstract visitTryCatchStmt(stmt: o.TryCatchStmt, ctx: EmitterVisitorContext): any;\n \n   visitThrowStmt(stmt: o.ThrowStmt, ctx: EmitterVisitorContext): any {\n+    this.printLeadingComments(stmt, ctx);\n     ctx.print(stmt, `throw `);\n     stmt.error.visitExpression(this, ctx);\n     ctx.println(stmt, `;`);\n     return null;\n   }\n-  visitCommentStmt(stmt: o.CommentStmt, ctx: EmitterVisitorContext): any {\n-    if (stmt.multiline) {\n-      ctx.println(stmt, `/* ${stmt.comment} */`);\n-    } else {\n-      stmt.comment.split('\\n').forEach((line) => {\n-        ctx.println(stmt, `// ${line}`);\n-      });\n-    }\n-    return null;\n-  }\n-  visitJSDocCommentStmt(stmt: o.JSDocCommentStmt, ctx: EmitterVisitorContext) {\n-    ctx.println(stmt, `/*${stmt.toString()}*/`);\n-    return null;\n-  }\n \n   abstract visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any;\n "
        },
        {
            "sha": "c7332111c22c3124101075b1f92dafed5e0c6e2b",
            "filename": "packages/compiler/src/output/output_ast.ts",
            "status": "modified",
            "additions": 102,
            "deletions": 110,
            "changes": 212,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_ast.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_ast.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_ast.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -16,15 +16,11 @@ export enum TypeModifier {\n }\n \n export abstract class Type {\n-  constructor(public modifiers: TypeModifier[]|null = null) {\n-    if (!modifiers) {\n-      this.modifiers = [];\n-    }\n-  }\n+  constructor(public modifiers: TypeModifier[] = []) {}\n   abstract visitType(visitor: TypeVisitor, context: any): any;\n \n   hasModifier(modifier: TypeModifier): boolean {\n-    return this.modifiers!.indexOf(modifier) !== -1;\n+    return this.modifiers.indexOf(modifier) !== -1;\n   }\n }\n \n@@ -40,7 +36,7 @@ export enum BuiltinTypeName {\n }\n \n export class BuiltinType extends Type {\n-  constructor(public name: BuiltinTypeName, modifiers: TypeModifier[]|null = null) {\n+  constructor(public name: BuiltinTypeName, modifiers?: TypeModifier[]) {\n     super(modifiers);\n   }\n   visitType(visitor: TypeVisitor, context: any): any {\n@@ -50,8 +46,7 @@ export class BuiltinType extends Type {\n \n export class ExpressionType extends Type {\n   constructor(\n-      public value: Expression, modifiers: TypeModifier[]|null = null,\n-      public typeParams: Type[]|null = null) {\n+      public value: Expression, modifiers?: TypeModifier[], public typeParams: Type[]|null = null) {\n     super(modifiers);\n   }\n   visitType(visitor: TypeVisitor, context: any): any {\n@@ -61,7 +56,7 @@ export class ExpressionType extends Type {\n \n \n export class ArrayType extends Type {\n-  constructor(public of: Type, modifiers: TypeModifier[]|null = null) {\n+  constructor(public of: Type, modifiers?: TypeModifier[]) {\n     super(modifiers);\n   }\n   visitType(visitor: TypeVisitor, context: any): any {\n@@ -72,7 +67,7 @@ export class ArrayType extends Type {\n \n export class MapType extends Type {\n   public valueType: Type|null;\n-  constructor(valueType: Type|null|undefined, modifiers: TypeModifier[]|null = null) {\n+  constructor(valueType: Type|null|undefined, modifiers?: TypeModifier[]) {\n     super(modifiers);\n     this.valueType = valueType || null;\n   }\n@@ -357,7 +352,7 @@ export class WriteVarExpr extends Expression {\n     return visitor.visitWriteVarExpr(this, context);\n   }\n \n-  toDeclStmt(type?: Type|null, modifiers?: StmtModifier[]|null): DeclareVarStmt {\n+  toDeclStmt(type?: Type|null, modifiers?: StmtModifier[]): DeclareVarStmt {\n     return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n   }\n \n@@ -764,7 +759,7 @@ export class FunctionExpr extends Expression {\n     return visitor.visitFunctionExpr(this, context);\n   }\n \n-  toDeclStmt(name: string, modifiers: StmtModifier[]|null = null): DeclareFunctionStmt {\n+  toDeclStmt(name: string, modifiers?: StmtModifier[]): DeclareFunctionStmt {\n     return new DeclareFunctionStmt(\n         name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n   }\n@@ -978,13 +973,25 @@ export enum StmtModifier {\n   Static,\n }\n \n-export abstract class Statement {\n-  public modifiers: StmtModifier[];\n-  public sourceSpan: ParseSourceSpan|null;\n-  constructor(modifiers?: StmtModifier[]|null, sourceSpan?: ParseSourceSpan|null) {\n-    this.modifiers = modifiers || [];\n-    this.sourceSpan = sourceSpan || null;\n+export class LeadingComment {\n+  constructor(public text: string, public multiline: boolean, public trailingNewline: boolean) {}\n+  toString() {\n+    return this.multiline ? ` ${this.text} ` : this.text;\n+  }\n+}\n+export class JSDocComment extends LeadingComment {\n+  constructor(public tags: JSDocTag[]) {\n+    super('', /* multiline */ true, /* trailingNewline */ true);\n+  }\n+  toString(): string {\n+    return serializeTags(this.tags);\n   }\n+}\n+\n+export abstract class Statement {\n+  constructor(\n+      public modifiers: StmtModifier[] = [], public sourceSpan: ParseSourceSpan|null = null,\n+      public leadingComments?: LeadingComment[]) {}\n   /**\n    * Calculates whether this statement produces the same value as the given statement.\n    * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n@@ -994,17 +1001,22 @@ export abstract class Statement {\n   abstract visitStatement(visitor: StatementVisitor, context: any): any;\n \n   hasModifier(modifier: StmtModifier): boolean {\n-    return this.modifiers!.indexOf(modifier) !== -1;\n+    return this.modifiers.indexOf(modifier) !== -1;\n+  }\n+\n+  addLeadingComment(leadingComment: LeadingComment): void {\n+    this.leadingComments = this.leadingComments ?? [];\n+    this.leadingComments.push(leadingComment);\n   }\n }\n \n \n export class DeclareVarStmt extends Statement {\n   public type: Type|null;\n   constructor(\n-      public name: string, public value?: Expression, type?: Type|null,\n-      modifiers: StmtModifier[]|null = null, sourceSpan?: ParseSourceSpan|null) {\n-    super(modifiers, sourceSpan);\n+      public name: string, public value?: Expression, type?: Type|null, modifiers?: StmtModifier[],\n+      sourceSpan?: ParseSourceSpan|null, leadingComments?: LeadingComment[]) {\n+    super(modifiers, sourceSpan, leadingComments);\n     this.type = type || (value && value.type) || null;\n   }\n   isEquivalent(stmt: Statement): boolean {\n@@ -1020,37 +1032,40 @@ export class DeclareFunctionStmt extends Statement {\n   public type: Type|null;\n   constructor(\n       public name: string, public params: FnParam[], public statements: Statement[],\n-      type?: Type|null, modifiers: StmtModifier[]|null = null, sourceSpan?: ParseSourceSpan|null) {\n-    super(modifiers, sourceSpan);\n+      type?: Type|null, modifiers?: StmtModifier[], sourceSpan?: ParseSourceSpan|null,\n+      leadingComments?: LeadingComment[]) {\n+    super(modifiers, sourceSpan, leadingComments);\n     this.type = type || null;\n   }\n   isEquivalent(stmt: Statement): boolean {\n     return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) &&\n         areAllEquivalent(this.statements, stmt.statements);\n   }\n-\n   visitStatement(visitor: StatementVisitor, context: any): any {\n     return visitor.visitDeclareFunctionStmt(this, context);\n   }\n }\n \n export class ExpressionStatement extends Statement {\n-  constructor(public expr: Expression, sourceSpan?: ParseSourceSpan|null) {\n-    super(null, sourceSpan);\n+  constructor(\n+      public expr: Expression, sourceSpan?: ParseSourceSpan|null,\n+      leadingComments?: LeadingComment[]) {\n+    super([], sourceSpan, leadingComments);\n   }\n   isEquivalent(stmt: Statement): boolean {\n     return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n   }\n-\n   visitStatement(visitor: StatementVisitor, context: any): any {\n     return visitor.visitExpressionStmt(this, context);\n   }\n }\n \n \n export class ReturnStatement extends Statement {\n-  constructor(public value: Expression, sourceSpan?: ParseSourceSpan|null) {\n-    super(null, sourceSpan);\n+  constructor(\n+      public value: Expression, sourceSpan: ParseSourceSpan|null = null,\n+      leadingComments?: LeadingComment[]) {\n+    super([], sourceSpan, leadingComments);\n   }\n   isEquivalent(stmt: Statement): boolean {\n     return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n@@ -1061,21 +1076,15 @@ export class ReturnStatement extends Statement {\n }\n \n export class AbstractClassPart {\n-  public type: Type|null;\n-  constructor(type: Type|null|undefined, public modifiers: StmtModifier[]|null) {\n-    if (!modifiers) {\n-      this.modifiers = [];\n-    }\n-    this.type = type || null;\n-  }\n+  constructor(public type: Type|null = null, public modifiers: StmtModifier[] = []) {}\n   hasModifier(modifier: StmtModifier): boolean {\n-    return this.modifiers!.indexOf(modifier) !== -1;\n+    return this.modifiers.indexOf(modifier) !== -1;\n   }\n }\n \n export class ClassField extends AbstractClassPart {\n   constructor(\n-      public name: string, type?: Type|null, modifiers: StmtModifier[]|null = null,\n+      public name: string, type?: Type|null, modifiers?: StmtModifier[],\n       public initializer?: Expression) {\n     super(type, modifiers);\n   }\n@@ -1088,7 +1097,7 @@ export class ClassField extends AbstractClassPart {\n export class ClassMethod extends AbstractClassPart {\n   constructor(\n       public name: string|null, public params: FnParam[], public body: Statement[],\n-      type?: Type|null, modifiers: StmtModifier[]|null = null) {\n+      type?: Type|null, modifiers?: StmtModifier[]) {\n     super(type, modifiers);\n   }\n   isEquivalent(m: ClassMethod) {\n@@ -1099,8 +1108,7 @@ export class ClassMethod extends AbstractClassPart {\n \n export class ClassGetter extends AbstractClassPart {\n   constructor(\n-      public name: string, public body: Statement[], type?: Type|null,\n-      modifiers: StmtModifier[]|null = null) {\n+      public name: string, public body: Statement[], type?: Type|null, modifiers?: StmtModifier[]) {\n     super(type, modifiers);\n   }\n   isEquivalent(m: ClassGetter) {\n@@ -1113,9 +1121,9 @@ export class ClassStmt extends Statement {\n   constructor(\n       public name: string, public parent: Expression|null, public fields: ClassField[],\n       public getters: ClassGetter[], public constructorMethod: ClassMethod,\n-      public methods: ClassMethod[], modifiers: StmtModifier[]|null = null,\n-      sourceSpan?: ParseSourceSpan|null) {\n-    super(modifiers, sourceSpan);\n+      public methods: ClassMethod[], modifiers?: StmtModifier[], sourceSpan?: ParseSourceSpan|null,\n+      leadingComments?: LeadingComment[]) {\n+    super(modifiers, sourceSpan, leadingComments);\n   }\n   isEquivalent(stmt: Statement): boolean {\n     return stmt instanceof ClassStmt && this.name === stmt.name &&\n@@ -1134,8 +1142,9 @@ export class ClassStmt extends Statement {\n export class IfStmt extends Statement {\n   constructor(\n       public condition: Expression, public trueCase: Statement[],\n-      public falseCase: Statement[] = [], sourceSpan?: ParseSourceSpan|null) {\n-    super(null, sourceSpan);\n+      public falseCase: Statement[] = [], sourceSpan?: ParseSourceSpan|null,\n+      leadingComments?: LeadingComment[]) {\n+    super([], sourceSpan, leadingComments);\n   }\n   isEquivalent(stmt: Statement): boolean {\n     return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) &&\n@@ -1147,38 +1156,11 @@ export class IfStmt extends Statement {\n   }\n }\n \n-export class CommentStmt extends Statement {\n-  constructor(public comment: string, public multiline = false, sourceSpan?: ParseSourceSpan|null) {\n-    super(null, sourceSpan);\n-  }\n-  isEquivalent(stmt: Statement): boolean {\n-    return stmt instanceof CommentStmt;\n-  }\n-  visitStatement(visitor: StatementVisitor, context: any): any {\n-    return visitor.visitCommentStmt(this, context);\n-  }\n-}\n-\n-export class JSDocCommentStmt extends Statement {\n-  constructor(public tags: JSDocTag[] = [], sourceSpan?: ParseSourceSpan|null) {\n-    super(null, sourceSpan);\n-  }\n-  isEquivalent(stmt: Statement): boolean {\n-    return stmt instanceof JSDocCommentStmt && this.toString() === stmt.toString();\n-  }\n-  visitStatement(visitor: StatementVisitor, context: any): any {\n-    return visitor.visitJSDocCommentStmt(this, context);\n-  }\n-  toString(): string {\n-    return serializeTags(this.tags);\n-  }\n-}\n-\n export class TryCatchStmt extends Statement {\n   constructor(\n       public bodyStmts: Statement[], public catchStmts: Statement[],\n-      sourceSpan?: ParseSourceSpan|null) {\n-    super(null, sourceSpan);\n+      sourceSpan: ParseSourceSpan|null = null, leadingComments?: LeadingComment[]) {\n+    super([], sourceSpan, leadingComments);\n   }\n   isEquivalent(stmt: Statement): boolean {\n     return stmt instanceof TryCatchStmt && areAllEquivalent(this.bodyStmts, stmt.bodyStmts) &&\n@@ -1191,8 +1173,10 @@ export class TryCatchStmt extends Statement {\n \n \n export class ThrowStmt extends Statement {\n-  constructor(public error: Expression, sourceSpan?: ParseSourceSpan|null) {\n-    super(null, sourceSpan);\n+  constructor(\n+      public error: Expression, sourceSpan: ParseSourceSpan|null = null,\n+      leadingComments?: LeadingComment[]) {\n+    super([], sourceSpan, leadingComments);\n   }\n   isEquivalent(stmt: ThrowStmt): boolean {\n     return stmt instanceof TryCatchStmt && this.error.isEquivalent(stmt.error);\n@@ -1211,8 +1195,6 @@ export interface StatementVisitor {\n   visitIfStmt(stmt: IfStmt, context: any): any;\n   visitTryCatchStmt(stmt: TryCatchStmt, context: any): any;\n   visitThrowStmt(stmt: ThrowStmt, context: any): any;\n-  visitCommentStmt(stmt: CommentStmt, context: any): any;\n-  visitJSDocCommentStmt(stmt: JSDocCommentStmt, context: any): any;\n }\n \n export class AstTransformer implements StatementVisitor, ExpressionVisitor {\n@@ -1374,7 +1356,7 @@ export class AstTransformer implements StatementVisitor, ExpressionVisitor {\n     const entries = ast.entries.map(\n         (entry): LiteralMapEntry => new LiteralMapEntry(\n             entry.key, entry.value.visitExpression(this, context), entry.quoted));\n-    const mapType = new MapType(ast.valueType, null);\n+    const mapType = new MapType(ast.valueType);\n     return this.transformExpr(new LiteralMapExpr(entries, mapType, ast.sourceSpan), context);\n   }\n   visitCommaExpr(ast: CommaExpr, context: any): any {\n@@ -1388,25 +1370,30 @@ export class AstTransformer implements StatementVisitor, ExpressionVisitor {\n   visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any {\n     const value = stmt.value && stmt.value.visitExpression(this, context);\n     return this.transformStmt(\n-        new DeclareVarStmt(stmt.name, value, stmt.type, stmt.modifiers, stmt.sourceSpan), context);\n+        new DeclareVarStmt(\n+            stmt.name, value, stmt.type, stmt.modifiers, stmt.sourceSpan, stmt.leadingComments),\n+        context);\n   }\n   visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any {\n     return this.transformStmt(\n         new DeclareFunctionStmt(\n             stmt.name, stmt.params, this.visitAllStatements(stmt.statements, context), stmt.type,\n-            stmt.modifiers, stmt.sourceSpan),\n+            stmt.modifiers, stmt.sourceSpan, stmt.leadingComments),\n         context);\n   }\n \n   visitExpressionStmt(stmt: ExpressionStatement, context: any): any {\n     return this.transformStmt(\n-        new ExpressionStatement(stmt.expr.visitExpression(this, context), stmt.sourceSpan),\n+        new ExpressionStatement(\n+            stmt.expr.visitExpression(this, context), stmt.sourceSpan, stmt.leadingComments),\n         context);\n   }\n \n   visitReturnStmt(stmt: ReturnStatement, context: any): any {\n     return this.transformStmt(\n-        new ReturnStatement(stmt.value.visitExpression(this, context), stmt.sourceSpan), context);\n+        new ReturnStatement(\n+            stmt.value.visitExpression(this, context), stmt.sourceSpan, stmt.leadingComments),\n+        context);\n   }\n \n   visitDeclareClassStmt(stmt: ClassStmt, context: any): any {\n@@ -1435,29 +1422,25 @@ export class AstTransformer implements StatementVisitor, ExpressionVisitor {\n         new IfStmt(\n             stmt.condition.visitExpression(this, context),\n             this.visitAllStatements(stmt.trueCase, context),\n-            this.visitAllStatements(stmt.falseCase, context), stmt.sourceSpan),\n+            this.visitAllStatements(stmt.falseCase, context), stmt.sourceSpan,\n+            stmt.leadingComments),\n         context);\n   }\n \n   visitTryCatchStmt(stmt: TryCatchStmt, context: any): any {\n     return this.transformStmt(\n         new TryCatchStmt(\n             this.visitAllStatements(stmt.bodyStmts, context),\n-            this.visitAllStatements(stmt.catchStmts, context), stmt.sourceSpan),\n+            this.visitAllStatements(stmt.catchStmts, context), stmt.sourceSpan,\n+            stmt.leadingComments),\n         context);\n   }\n \n   visitThrowStmt(stmt: ThrowStmt, context: any): any {\n     return this.transformStmt(\n-        new ThrowStmt(stmt.error.visitExpression(this, context), stmt.sourceSpan), context);\n-  }\n-\n-  visitCommentStmt(stmt: CommentStmt, context: any): any {\n-    return this.transformStmt(stmt, context);\n-  }\n-\n-  visitJSDocCommentStmt(stmt: JSDocCommentStmt, context: any): any {\n-    return this.transformStmt(stmt, context);\n+        new ThrowStmt(\n+            stmt.error.visitExpression(this, context), stmt.sourceSpan, stmt.leadingComments),\n+        context);\n   }\n \n   visitAllStatements(stmts: Statement[], context: any): Statement[] {\n@@ -1647,12 +1630,6 @@ export class RecursiveAstVisitor implements StatementVisitor, ExpressionVisitor\n     stmt.error.visitExpression(this, context);\n     return stmt;\n   }\n-  visitCommentStmt(stmt: CommentStmt, context: any): any {\n-    return stmt;\n-  }\n-  visitJSDocCommentStmt(stmt: JSDocCommentStmt, context: any): any {\n-    return stmt;\n-  }\n   visitAllStatements(stmts: Statement[], context: any): void {\n     stmts.forEach(stmt => stmt.visitStatement(this, context));\n   }\n@@ -1743,6 +1720,15 @@ class _ApplySourceSpanTransformer extends AstTransformer {\n   }\n }\n \n+export function leadingComment(\n+    text: string, multiline: boolean = false, trailingNewline: boolean = true): LeadingComment {\n+  return new LeadingComment(text, multiline, trailingNewline);\n+}\n+\n+export function jsDocComment(tags: JSDocTag[] = []): JSDocComment {\n+  return new JSDocComment(tags);\n+}\n+\n export function variable(\n     name: string, type?: Type|null, sourceSpan?: ParseSourceSpan|null): ReadVarExpr {\n   return new ReadVarExpr(name, type, sourceSpan);\n@@ -1755,14 +1741,13 @@ export function importExpr(\n }\n \n export function importType(\n-    id: ExternalReference, typeParams: Type[]|null = null,\n-    typeModifiers: TypeModifier[]|null = null): ExpressionType|null {\n+    id: ExternalReference, typeParams?: Type[]|null,\n+    typeModifiers?: TypeModifier[]): ExpressionType|null {\n   return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n }\n \n export function expressionType(\n-    expr: Expression, typeModifiers: TypeModifier[]|null = null,\n-    typeParams: Type[]|null = null): ExpressionType {\n+    expr: Expression, typeModifiers?: TypeModifier[], typeParams?: Type[]|null): ExpressionType {\n   return new ExpressionType(expr, typeModifiers, typeParams);\n }\n \n@@ -1802,8 +1787,10 @@ export function fn(\n   return new FunctionExpr(params, body, type, sourceSpan, name);\n }\n \n-export function ifStmt(condition: Expression, thenClause: Statement[], elseClause?: Statement[]) {\n-  return new IfStmt(condition, thenClause, elseClause);\n+export function ifStmt(\n+    condition: Expression, thenClause: Statement[], elseClause?: Statement[],\n+    sourceSpan?: ParseSourceSpan, leadingComments?: LeadingComment[]) {\n+  return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);\n }\n \n export function literal(\n@@ -1865,10 +1852,15 @@ function tagToString(tag: JSDocTag): string {\n function serializeTags(tags: JSDocTag[]): string {\n   if (tags.length === 0) return '';\n \n+  if (tags.length === 1 && tags[0].tagName && !tags[0].text) {\n+    // The JSDOC comment is a single simple tag: e.g `/** @tagname */`.\n+    return `*${tagToString(tags[0])} `;\n+  }\n+\n   let out = '*\\n';\n   for (const tag of tags) {\n     out += ' *';\n-    // If the tagToString is multi-line, insert \" * \" prefixes on subsequent lines.\n+    // If the tagToString is multi-line, insert \" * \" prefixes on lines.\n     out += tagToString(tag).replace(/\\n/g, '\\n * ');\n     out += '\\n';\n   }"
        },
        {
            "sha": "72ae1871ca442ed5c093e15e158c169900bd9fb5",
            "filename": "packages/compiler/src/output/output_interpreter.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 6,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_interpreter.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_interpreter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Foutput%2Foutput_interpreter.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -233,12 +233,6 @@ class StatementInterpreter implements o.StatementVisitor, o.ExpressionVisitor {\n   visitThrowStmt(stmt: o.ThrowStmt, ctx: _ExecutionContext): any {\n     throw stmt.error.visitExpression(this, ctx);\n   }\n-  visitCommentStmt(stmt: o.CommentStmt, context?: any): any {\n-    return null;\n-  }\n-  visitJSDocCommentStmt(stmt: o.JSDocCommentStmt, context?: any): any {\n-    return null;\n-  }\n   visitInstantiateExpr(ast: o.InstantiateExpr, ctx: _ExecutionContext): any {\n     const args = this.visitAllExpressions(ast.args, ctx);\n     const clazz = ast.classExpr.visitExpression(this, ctx);"
        },
        {
            "sha": "5c1d7bb40a31dcc3cf792cf3362ef97b0530ab28",
            "filename": "packages/compiler/src/render3/util.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Fsrc%2Frender3%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Fsrc%2Frender3%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Futil.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -45,14 +45,14 @@ export function convertMetaToOutput(meta: any, ctx: OutputContext): o.Expression\n }\n \n export function typeWithParameters(type: o.Expression, numParams: number): o.ExpressionType {\n-  let params: o.Type[]|null = null;\n-  if (numParams > 0) {\n-    params = [];\n-    for (let i = 0; i < numParams; i++) {\n-      params.push(o.DYNAMIC_TYPE);\n-    }\n+  if (numParams === 0) {\n+    return o.expressionType(type);\n   }\n-  return o.expressionType(type, null, params);\n+  const params: o.Type[] = [];\n+  for (let i = 0; i < numParams; i++) {\n+    params.push(o.DYNAMIC_TYPE);\n+  }\n+  return o.expressionType(type, undefined, params);\n }\n \n export interface R3Reference {"
        },
        {
            "sha": "1ead29cb4e651220d6ac03ed0b60912a450d8aa9",
            "filename": "packages/compiler/src/render3/view/i18n/get_msg_utils.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 9,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fi18n%2Fget_msg_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fi18n%2Fget_msg_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fi18n%2Fget_msg_utils.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -10,7 +10,7 @@ import {mapLiteral} from '../../../output/map_util';\n import * as o from '../../../output/output_ast';\n \n import {serializeIcuNode} from './icu_serializer';\n-import {i18nMetaToDocStmt} from './meta';\n+import {i18nMetaToJSDoc} from './meta';\n import {formatI18nPlaceholderName} from './util';\n \n /** Closure uses `goog.getMsg(message)` to lookup translations */\n@@ -31,15 +31,13 @@ export function createGoogleGetMsgStatements(\n   //  */\n   // const MSG_... = goog.getMsg(..);\n   // I18N_X = MSG_...;\n-  const statements = [];\n-  const jsdocComment = i18nMetaToDocStmt(message);\n-  if (jsdocComment !== null) {\n-    statements.push(jsdocComment);\n+  const googGetMsgStmt = closureVar.set(o.variable(GOOG_GET_MSG).callFn(args)).toConstDecl();\n+  const metaComment = i18nMetaToJSDoc(message);\n+  if (metaComment !== null) {\n+    googGetMsgStmt.addLeadingComment(metaComment);\n   }\n-  statements.push(closureVar.set(o.variable(GOOG_GET_MSG).callFn(args)).toConstDecl());\n-  statements.push(new o.ExpressionStatement(variable.set(closureVar)));\n-\n-  return statements;\n+  const i18nAssignmentStmt = new o.ExpressionStatement(variable.set(closureVar));\n+  return [googGetMsgStmt, i18nAssignmentStmt];\n }\n \n /**"
        },
        {
            "sha": "31e9e2bc1b3b7be1e9c61f66a61856fb207fd278",
            "filename": "packages/compiler/src/render3/view/i18n/meta.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fi18n%2Fmeta.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fi18n%2Fmeta.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fi18n%2Fmeta.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -231,13 +231,13 @@ export function parseI18nMeta(meta: string = ''): I18nMeta {\n \n // Converts i18n meta information for a message (id, description, meaning)\n // to a JsDoc statement formatted as expected by the Closure compiler.\n-export function i18nMetaToDocStmt(meta: I18nMeta): o.JSDocCommentStmt|null {\n+export function i18nMetaToJSDoc(meta: I18nMeta): o.JSDocComment|null {\n   const tags: o.JSDocTag[] = [];\n   if (meta.description) {\n     tags.push({tagName: o.JSDocTagName.Desc, text: meta.description});\n   }\n   if (meta.meaning) {\n     tags.push({tagName: o.JSDocTagName.Meaning, text: meta.meaning});\n   }\n-  return tags.length == 0 ? null : new o.JSDocCommentStmt(tags);\n+  return tags.length == 0 ? null : o.jsDocComment(tags);\n }"
        },
        {
            "sha": "3c0360cffeb99641977ad16cfa2c45704797c34d",
            "filename": "packages/compiler/src/render3/view/i18n/util.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fi18n%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fi18n%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fi18n%2Futil.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -179,5 +179,5 @@ export function getTranslationConstPrefix(extra: string): string {\n  */\n export function declareI18nVariable(variable: o.ReadVarExpr): o.Statement {\n   return new o.DeclareVarStmt(\n-      variable.name!, undefined, o.INFERRED_TYPE, null, variable.sourceSpan);\n+      variable.name!, undefined, o.INFERRED_TYPE, undefined, variable.sourceSpan);\n }"
        },
        {
            "sha": "eb92a1590c4d9e29027ba86e79b198f6000c86df",
            "filename": "packages/compiler/src/render3/view/template.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -893,7 +893,7 @@ export class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver\n       const templateFunctionExpr = templateVisitor.buildTemplateFunction(\n           template.children, template.variables,\n           this._ngContentReservedSlots.length + this._ngContentSelectorsOffset, template.i18n);\n-      this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName, null));\n+      this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName));\n       if (templateVisitor._ngContentReservedSlots.length) {\n         this._ngContentReservedSlots.push(...templateVisitor._ngContentReservedSlots);\n       }"
        },
        {
            "sha": "e55c8e13398212477358ab86841f86c6d058e118",
            "filename": "packages/compiler/test/output/js_emitter_spec.ts",
            "status": "modified",
            "additions": 43,
            "deletions": 2,
            "changes": 45,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Ftest%2Foutput%2Fjs_emitter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Ftest%2Foutput%2Fjs_emitter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Foutput%2Fjs_emitter_spec.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -189,8 +189,49 @@ const externalModuleIdentifier = new o.ExternalReference(anotherModuleUrl, 'some\n       ].join('\\n'));\n     });\n \n-    it('should support comments', () => {\n-      expect(emitStmt(new o.CommentStmt('a\\nb'))).toEqual(['// a', '// b'].join('\\n'));\n+    describe('comments', () => {\n+      it('should support a preamble', () => {\n+        expect(emitStmt(o.variable('a').toStmt(), '/* SomePreamble */')).toBe([\n+          '/* SomePreamble */', 'a;'\n+        ].join('\\n'));\n+      });\n+\n+      it('should support singleline comments', () => {\n+        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [o.leadingComment('a\\nb')])))\n+            .toBe('// a\\n// b\\nreturn 1;');\n+      });\n+\n+      it('should support multiline comments', () => {\n+        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n+          o.leadingComment('Multiline comment', true)\n+        ]))).toBe('/* Multiline comment */\\nreturn 1;');\n+        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n+          o.leadingComment(`Multiline\\ncomment`, true)\n+        ]))).toBe(`/* Multiline\\ncomment */\\nreturn 1;`);\n+      });\n+\n+      it('should support inline multiline comments', () => {\n+        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n+          o.leadingComment('inline comment', true, false)\n+        ]))).toBe('/* inline comment */return 1;');\n+      });\n+\n+      it('should support JSDoc comments', () => {\n+        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n+          o.jsDocComment([{text: 'Intro comment'}])\n+        ]))).toBe(`/**\\n * Intro comment\\n */\\nreturn 1;`);\n+        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n+          o.jsDocComment([{tagName: o.JSDocTagName.Desc, text: 'description'}])\n+        ]))).toBe(`/**\\n * @desc description\\n */\\nreturn 1;`);\n+        expect(emitStmt(new o.ReturnStatement(\n+                   o.literal(1), null, [o.jsDocComment([\n+                     {text: 'Intro comment'},\n+                     {tagName: o.JSDocTagName.Desc, text: 'description'},\n+                     {tagName: o.JSDocTagName.Id, text: '{number} identifier 123'},\n+                   ])])))\n+            .toBe(\n+                `/**\\n * Intro comment\\n * @desc description\\n * @id {number} identifier 123\\n */\\nreturn 1;`);\n+      });\n     });\n \n     it('should support if stmt', () => {"
        },
        {
            "sha": "d0130d17191a914bb801b841021f0b58b12f2c51",
            "filename": "packages/compiler/test/output/output_ast_spec.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 17,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Ftest%2Foutput%2Foutput_ast_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Ftest%2Foutput%2Foutput_ast_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Foutput%2Foutput_ast_spec.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -21,22 +21,5 @@ import * as o from '../../src/output/output_ast';\n         expect(o.collectExternalReferences([stmt])).toEqual([ref1, ref2]);\n       });\n     });\n-\n-    describe('comments', () => {\n-      it('different JSDocCommentStmt should not be equivalent', () => {\n-        const comment1 = new o.JSDocCommentStmt([{text: 'text'}]);\n-        const comment2 = new o.JSDocCommentStmt([{text: 'text2'}]);\n-        const comment3 = new o.JSDocCommentStmt([{tagName: o.JSDocTagName.Desc, text: 'text2'}]);\n-        const comment4 = new o.JSDocCommentStmt([{text: 'text2'}, {text: 'text3'}]);\n-\n-        expect(comment1.isEquivalent(comment2)).toBeFalsy();\n-        expect(comment1.isEquivalent(comment3)).toBeFalsy();\n-        expect(comment1.isEquivalent(comment4)).toBeFalsy();\n-        expect(comment2.isEquivalent(comment3)).toBeFalsy();\n-        expect(comment2.isEquivalent(comment4)).toBeFalsy();\n-        expect(comment3.isEquivalent(comment4)).toBeFalsy();\n-        expect(comment1.isEquivalent(comment1)).toBeTruthy();\n-      });\n-    });\n   });\n }"
        },
        {
            "sha": "33f659dbec6e763c547d123bba72363783f11fc9",
            "filename": "packages/compiler/test/output/ts_emitter_spec.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 17,
            "changes": 46,
            "blob_url": "https://github.com/angular/angular/blob/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Ftest%2Foutput%2Fts_emitter_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/d795a001375a7d06592450d6f57a4f05d4d3e8e9/packages%2Fcompiler%2Ftest%2Foutput%2Fts_emitter_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Foutput%2Fts_emitter_spec.ts?ref=d795a001375a7d06592450d6f57a4f05d4d3e8e9",
            "patch": "@@ -239,7 +239,8 @@ const externalModuleIdentifier = new o.ExternalReference(anotherModuleUrl, 'some\n     });\n \n     it('should support comments', () => {\n-      expect(emitStmt(new o.CommentStmt('a\\nb'))).toEqual(['// a', '// b'].join('\\n'));\n+      expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [o.leadingComment('a\\nb')])))\n+          .toEqual('// a\\n// b\\nreturn 1;');\n     });\n \n     it('should support if stmt', () => {\n@@ -441,29 +442,40 @@ const externalModuleIdentifier = new o.ExternalReference(anotherModuleUrl, 'some\n       });\n \n       it('should support singleline comments', () => {\n-        expect(emitStmt(new o.CommentStmt('Simple comment'))).toBe('// Simple comment');\n+        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [o.leadingComment('a\\nb')])))\n+            .toBe('// a\\n// b\\nreturn 1;');\n       });\n \n       it('should support multiline comments', () => {\n-        expect(emitStmt(new o.CommentStmt('Multiline comment', true)))\n-            .toBe('/* Multiline comment */');\n-        expect(emitStmt(new o.CommentStmt(`Multiline\\ncomment`, true)))\n-            .toBe(`/* Multiline\\ncomment */`);\n+        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n+          o.leadingComment('Multiline comment', true)\n+        ]))).toBe('/* Multiline comment */\\nreturn 1;');\n+        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n+          o.leadingComment(`Multiline\\ncomment`, true)\n+        ]))).toBe(`/* Multiline\\ncomment */\\nreturn 1;`);\n+      });\n+\n+      it('should support inline multiline comments', () => {\n+        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n+          o.leadingComment('inline comment', true, false)\n+        ]))).toBe('/* inline comment */return 1;');\n       });\n \n       it('should support JSDoc comments', () => {\n-        expect(emitStmt(new o.JSDocCommentStmt([{text: 'Intro comment'}])))\n-            .toBe(`/**\\n * Intro comment\\n */`);\n-        expect(emitStmt(new o.JSDocCommentStmt([\n-          {tagName: o.JSDocTagName.Desc, text: 'description'}\n-        ]))).toBe(`/**\\n * @desc description\\n */`);\n-        expect(emitStmt(new o.JSDocCommentStmt([\n-          {text: 'Intro comment'},\n-          {tagName: o.JSDocTagName.Desc, text: 'description'},\n-          {tagName: o.JSDocTagName.Id, text: '{number} identifier 123'},\n-        ])))\n+        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n+          o.jsDocComment([{text: 'Intro comment'}])\n+        ]))).toBe(`/**\\n * Intro comment\\n */\\nreturn 1;`);\n+        expect(emitStmt(new o.ReturnStatement(o.literal(1), null, [\n+          o.jsDocComment([{tagName: o.JSDocTagName.Desc, text: 'description'}])\n+        ]))).toBe(`/**\\n * @desc description\\n */\\nreturn 1;`);\n+        expect(emitStmt(new o.ReturnStatement(\n+                   o.literal(1), null, [o.jsDocComment([\n+                     {text: 'Intro comment'},\n+                     {tagName: o.JSDocTagName.Desc, text: 'description'},\n+                     {tagName: o.JSDocTagName.Id, text: '{number} identifier 123'},\n+                   ])])))\n             .toBe(\n-                `/**\\n * Intro comment\\n * @desc description\\n * @id {number} identifier 123\\n */`);\n+                `/**\\n * Intro comment\\n * @desc description\\n * @id {number} identifier 123\\n */\\nreturn 1;`);\n       });\n     });\n "
        }
    ],
    "stats": {
        "total": 788,
        "additions": 426,
        "deletions": 362
    }
}