{
    "author": "atscott",
    "message": "refactor(compiler): refactor template symbol builder (#39047)\n\n* Add `templateNode` to `ElementSymbol` and `TemplateSymbol` so callers\ncan use the information about the attributes on the\n`TmplAstElement`/`TmplAstTemplate` for directive matching\n* Remove helper function `getSymbolOfVariableDeclaration` and favor\nmore specific handling for scenarios. The generic function did not\neasily handle different scenarios for all types of variable declarations\nin the TCB\n\nPR Close #39047",
    "sha": "ddc9e8e47a38ea63eeac3a1eff65f6b3c3f0032d",
    "files": [
        {
            "sha": "b74d6520d35b9081584497d96c7eb58a188e38b2",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/symbols.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/ddc9e8e47a38ea63eeac3a1eff65f6b3c3f0032d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fsymbols.ts",
            "raw_url": "https://github.com/angular/angular/raw/ddc9e8e47a38ea63eeac3a1eff65f6b3c3f0032d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fsymbols.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fsymbols.ts?ref=ddc9e8e47a38ea63eeac3a1eff65f6b3c3f0032d",
            "patch": "@@ -204,13 +204,17 @@ export interface ElementSymbol {\n \n   /** The location in the shim file for the variable that holds the type of the element. */\n   shimLocation: ShimLocation;\n+\n+  templateNode: TmplAstElement;\n }\n \n export interface TemplateSymbol {\n   kind: SymbolKind.Template;\n \n   /** A list of directives applied to the element. */\n   directives: DirectiveSymbol[];\n+\n+  templateNode: TmplAstTemplate;\n }\n \n /**"
        },
        {
            "sha": "d9bb5429d99ed2b5434f6e94764eab1d0f0982f0",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder.ts",
            "status": "modified",
            "additions": 20,
            "deletions": 32,
            "changes": 52,
            "blob_url": "https://github.com/angular/angular/blob/ddc9e8e47a38ea63eeac3a1eff65f6b3c3f0032d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "raw_url": "https://github.com/angular/angular/raw/ddc9e8e47a38ea63eeac3a1eff65f6b3c3f0032d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts?ref=ddc9e8e47a38ea63eeac3a1eff65f6b3c3f0032d",
            "patch": "@@ -54,7 +54,7 @@ export class SymbolBuilder {\n \n   private getSymbolOfAstTemplate(template: TmplAstTemplate): TemplateSymbol|null {\n     const directives = this.getDirectivesOfNode(template);\n-    return {kind: SymbolKind.Template, directives};\n+    return {kind: SymbolKind.Template, directives, templateNode: template};\n   }\n \n   private getSymbolOfElement(element: TmplAstElement): ElementSymbol|null {\n@@ -66,7 +66,7 @@ export class SymbolBuilder {\n       return null;\n     }\n \n-    const symbolFromDeclaration = this.getSymbolOfVariableDeclaration(node);\n+    const symbolFromDeclaration = this.getSymbolOfTsNode(node);\n     if (symbolFromDeclaration === null || symbolFromDeclaration.tsSymbol === null) {\n       return null;\n     }\n@@ -79,6 +79,7 @@ export class SymbolBuilder {\n       ...symbolFromDeclaration,\n       kind: SymbolKind.Element,\n       directives,\n+      templateNode: element,\n     };\n   }\n \n@@ -89,21 +90,18 @@ export class SymbolBuilder {\n     // - var _t1: TestDir /*T:D*/ = (null!);\n     // - var _t1 /*T:D*/ = _ctor1({});\n     const isDirectiveDeclaration = (node: ts.Node): node is ts.TypeNode|ts.Identifier =>\n-        (ts.isTypeNode(node) || ts.isIdentifier(node)) &&\n+        (ts.isTypeNode(node) || ts.isIdentifier(node)) && ts.isVariableDeclaration(node.parent) &&\n         hasExpressionIdentifier(tcbSourceFile, node, ExpressionIdentifier.DIRECTIVE);\n \n     const nodes = findAllMatchingNodes(\n         this.typeCheckBlock, {withSpan: elementSourceSpan, filter: isDirectiveDeclaration});\n     return nodes\n         .map(node => {\n-          const symbol = (ts.isIdentifier(node) && ts.isVariableDeclaration(node.parent)) ?\n-              this.getSymbolOfVariableDeclaration(node.parent) :\n-              this.getSymbolOfTsNode(node);\n+          const symbol = this.getSymbolOfTsNode(node.parent);\n           if (symbol === null || symbol.tsSymbol === null ||\n               symbol.tsSymbol.declarations.length === 0) {\n             return null;\n           }\n-\n           const meta = this.getDirectiveMeta(element, symbol.tsSymbol.declarations[0]);\n           if (meta === null) {\n             return null;\n@@ -240,7 +238,7 @@ export class SymbolBuilder {\n       return null;\n     }\n \n-    const symbol = this.getSymbolOfVariableDeclaration(declaration);\n+    const symbol = this.getSymbolOfTsNode(declaration);\n     if (symbol === null || symbol.tsSymbol === null) {\n       return null;\n     }\n@@ -258,11 +256,11 @@ export class SymbolBuilder {\n   private getSymbolOfVariable(variable: TmplAstVariable): VariableSymbol|null {\n     const node = findFirstMatchingNode(\n         this.typeCheckBlock, {withSpan: variable.sourceSpan, filter: ts.isVariableDeclaration});\n-    if (node === null) {\n+    if (node === null || node.initializer === undefined) {\n       return null;\n     }\n \n-    const expressionSymbol = this.getSymbolOfVariableDeclaration(node);\n+    const expressionSymbol = this.getSymbolOfTsNode(node.initializer);\n     if (expressionSymbol === null) {\n       return null;\n     }\n@@ -279,8 +277,18 @@ export class SymbolBuilder {\n       return null;\n     }\n \n-    // TODO(atscott): Shim location will need to be adjusted\n-    const symbol = this.getSymbolOfTsNode(node.name);\n+    // Get the original declaration for the references variable, with the exception of template refs\n+    // which are of the form var _t3 = (_t2 as any as i2.TemplateRef<any>)\n+    // TODO(atscott): Consider adding an `ExpressionIdentifier` to tag variable declaration\n+    // initializers as invalid for symbol retrieval.\n+    const originalDeclaration = ts.isParenthesizedExpression(node.initializer) &&\n+            ts.isAsExpression(node.initializer.expression) ?\n+        this.typeChecker.getSymbolAtLocation(node.name) :\n+        this.typeChecker.getSymbolAtLocation(node.initializer);\n+    if (originalDeclaration === undefined || originalDeclaration.valueDeclaration === undefined) {\n+      return null;\n+    }\n+    const symbol = this.getSymbolOfTsNode(originalDeclaration.valueDeclaration);\n     if (symbol === null || symbol.tsSymbol === null) {\n       return null;\n     }\n@@ -393,26 +401,6 @@ export class SymbolBuilder {\n     };\n   }\n \n-  private getSymbolOfVariableDeclaration(declaration: ts.VariableDeclaration): TsNodeSymbolInfo\n-      |null {\n-    // Instead of returning the Symbol for the temporary variable, we want to get the `ts.Symbol`\n-    // for:\n-    // - The type reference for `var _t2: MyDir = xyz` (prioritize/trust the declared type)\n-    // - The initializer for `var _t2 = _t1.index`.\n-    if (declaration.type && ts.isTypeReferenceNode(declaration.type)) {\n-      return this.getSymbolOfTsNode(declaration.type.typeName);\n-    }\n-    if (declaration.initializer === undefined) {\n-      return null;\n-    }\n-\n-    const symbol = this.getSymbolOfTsNode(declaration.initializer);\n-    if (symbol === null) {\n-      return null;\n-    }\n-    return symbol;\n-  }\n-\n   private getShimPositionForNode(node: ts.Node): number {\n     if (ts.isTypeReferenceNode(node)) {\n       return this.getShimPositionForNode(node.typeName);"
        },
        {
            "sha": "5c7eb20e4fb41291da535f91e8551322cdf0ce8a",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker__get_symbol_of_template_node_spec.ts",
            "status": "modified",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/angular/angular/blob/ddc9e8e47a38ea63eeac3a1eff65f6b3c3f0032d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/ddc9e8e47a38ea63eeac3a1eff65f6b3c3f0032d/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts?ref=ddc9e8e47a38ea63eeac3a1eff65f6b3c3f0032d",
            "patch": "@@ -133,13 +133,15 @@ runInEachFileSystem(() => {\n         it('should get a symbol for local ref which refers to a directive', () => {\n           const symbol = templateTypeChecker.getSymbolOfNode(templateNode.references[1], cmp)!;\n           assertReferenceSymbol(symbol);\n+          expect(program.getTypeChecker().symbolToString(symbol.tsSymbol)).toEqual('TestDir');\n           assertDirectiveReference(symbol);\n         });\n \n         it('should get a symbol for usage local ref which refers to a directive', () => {\n           const symbol = templateTypeChecker.getSymbolOfNode(\n               (templateNode.children[0] as TmplAstTemplate).inputs[2].value, cmp)!;\n           assertReferenceSymbol(symbol);\n+          expect(program.getTypeChecker().symbolToString(symbol.tsSymbol)).toEqual('TestDir');\n           assertDirectiveReference(symbol);\n         });\n \n@@ -737,6 +739,40 @@ runInEachFileSystem(() => {\n     });\n \n     describe('input bindings', () => {\n+      it('can get a symbol for empty binding', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const dirFile = absoluteFrom('/dir.ts');\n+        const {program, templateTypeChecker} = setup([\n+          {\n+            fileName,\n+            templates: {'Cmp': `<div dir [inputA]=\"\"></div>`},\n+            declarations: [{\n+              name: 'TestDir',\n+              selector: '[dir]',\n+              file: dirFile,\n+              type: 'directive',\n+              inputs: {inputA: 'inputA'},\n+            }]\n+          },\n+          {\n+            fileName: dirFile,\n+            source: `export class TestDir {inputA?: string; }`,\n+            templates: {},\n+          }\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+\n+        const nodes = templateTypeChecker.getTemplate(cmp)!;\n+\n+        const inputAbinding = (nodes[0] as TmplAstElement).inputs[0];\n+        const aSymbol = templateTypeChecker.getSymbolOfNode(inputAbinding, cmp)!;\n+        assertInputBindingSymbol(aSymbol);\n+        expect((aSymbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration)\n+                   .name.getText())\n+            .toEqual('inputA');\n+      });\n+\n       it('can retrieve a symbol for an input binding', () => {\n         const fileName = absoluteFrom('/main.ts');\n         const dirFile = absoluteFrom('/dir.ts');"
        }
    ],
    "stats": {
        "total": 92,
        "additions": 60,
        "deletions": 32
    }
}