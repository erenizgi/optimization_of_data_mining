{
    "author": "AndrewKushnir",
    "message": "test(core): refactor ApplicationInitStatus tests to avoid TestBed side-effects (#33222)\n\nCurrently TestBed (both ViewEngine and Ivy) invoke `ApplicationInitStatus.runInitializers` as a part of the\nbootstrap process to mimic real bootstrap steps. This is problematic for the `ApplicationInitStatus` class\ntests since the `runInitializers` call performed by TestBed interfere with actual tests.\n\nThis commit updates ApplicationInitStatus tests to interact with the class directly instead of relying on TestBed\nAPIs to retrieve the class though DI.\n\nPR Close #33222",
    "sha": "995adb2297b552fba8b1aeb5f229004cc0a98b8f",
    "files": [
        {
            "sha": "d36e6df8fb70346de1d6a12c385ee7f22186a758",
            "filename": "packages/core/test/application_init_spec.ts",
            "status": "modified",
            "additions": 140,
            "deletions": 161,
            "changes": 301,
            "blob_url": "https://github.com/angular/angular/blob/995adb2297b552fba8b1aeb5f229004cc0a98b8f/packages%2Fcore%2Ftest%2Fapplication_init_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/995adb2297b552fba8b1aeb5f229004cc0a98b8f/packages%2Fcore%2Ftest%2Fapplication_init_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fapplication_init_spec.ts?ref=995adb2297b552fba8b1aeb5f229004cc0a98b8f",
            "patch": "@@ -5,175 +5,154 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {APP_INITIALIZER, ApplicationInitStatus} from '@angular/core/src/application_init';\n-import {Observable, Subscriber} from 'rxjs';\n-\n-import {inject, TestBed, waitForAsync} from '../testing';\n-\n-{\n-  describe('ApplicationInitStatus', () => {\n-    describe('no initializers', () => {\n-      it('should return true for `done`',\n-         waitForAsync(inject([ApplicationInitStatus], (status: ApplicationInitStatus) => {\n-           (status as any).runInitializers();\n-           expect(status.done).toBe(true);\n-         })));\n-\n-      it('should return a promise that resolves immediately for `donePromise`',\n-         waitForAsync(inject([ApplicationInitStatus], (status: ApplicationInitStatus) => {\n-           (status as any).runInitializers();\n-           status.donePromise.then(() => {\n-             expect(status.done).toBe(true);\n-           });\n-         })));\n+import {ApplicationInitStatus} from '@angular/core/src/application_init';\n+import {EMPTY, Observable, Subscriber} from 'rxjs';\n+\n+describe('ApplicationInitStatus', () => {\n+  let status: ApplicationInitStatus;\n+  const runInitializers = () =>\n+      // Cast to `any` to access an internal function for testing purposes.\n+      (status as any).runInitializers();\n+\n+  describe('no initializers', () => {\n+    beforeEach(() => {\n+      status = new ApplicationInitStatus([]);\n     });\n \n-    describe('with async promise initializers', () => {\n-      let resolve: (result: any) => void;\n-      let reject: (reason?: any) => void;\n-      let promise: Promise<any>;\n-      let initFnInvoked = false;\n-      beforeEach(() => {\n-        promise = new Promise((res, rej) => {\n-          resolve = res;\n-          reject = rej;\n-        });\n-        TestBed.configureTestingModule({\n-          providers: [\n-            {provide: APP_INITIALIZER, multi: true, useValue: () => promise},\n-          ]\n-        });\n+    it('should return true for `done`', () => {\n+      runInitializers();\n+      expect(status.done).toBe(true);\n+    });\n+\n+    it('should return a promise that resolves immediately for `donePromise`', async () => {\n+      runInitializers();\n+      await status.donePromise;\n+      expect(status.done).toBe(true);\n+    });\n+  });\n+\n+  describe('with async promise initializers', () => {\n+    let resolve: (result: any) => void;\n+    let reject: (reason?: any) => void;\n+    let promise: Promise<any>;\n+    let initFnInvoked = false;\n+\n+    beforeEach(() => {\n+      promise = new Promise((res, rej) => {\n+        resolve = res;\n+        reject = rej;\n+      });\n+      status = new ApplicationInitStatus([() => promise]);\n+    });\n+\n+    it('should update the status once all async promise initializers are done', async () => {\n+      runInitializers();\n+\n+      setTimeout(() => {\n+        initFnInvoked = true;\n+        resolve(null);\n+      });\n+\n+      expect(status.done).toBe(false);\n+      await status.donePromise;\n+      expect(status.done).toBe(true);\n+      expect(initFnInvoked).toBe(true);\n+    });\n+\n+    it('should handle a case when promise is rejected', async () => {\n+      runInitializers();\n+\n+      setTimeout(() => {\n+        initFnInvoked = true;\n+        reject();\n       });\n \n-      it('should update the status once all async promise initializers are done',\n-         waitForAsync(inject([ApplicationInitStatus], (status: ApplicationInitStatus) => {\n-           // Accessing internal `runInitializers` function of the `ApplicationInitStatus` class\n-           // instance for testing purposes to invoke initializer functions.\n-           (status as any).runInitializers();\n-\n-           setTimeout(() => {\n-             initFnInvoked = true;\n-             resolve(null);\n-           });\n-\n-           expect(status.done).toBe(false);\n-           status.donePromise.then(() => {\n-             expect(status.done).toBe(true);\n-             expect(initFnInvoked).toBe(true);\n-           });\n-         })));\n-\n-      it('should handle a case when promise is rejected',\n-         waitForAsync(inject([ApplicationInitStatus], (status: ApplicationInitStatus) => {\n-           // Accessing internal `runInitializers` function of the `ApplicationInitStatus` class\n-           // instance for testing purposes to invoke initializer functions.\n-           (status as any).runInitializers();\n-\n-           setTimeout(() => {\n-             initFnInvoked = true;\n-             reject();\n-           });\n-\n-           expect(status.done).toBe(false);\n-           status.donePromise\n-               .then(\n-                   () => fail('`donePromise.then` should not be invoked when promise is rejected'))\n-               .catch(() => {\n-                 expect(status.done).toBe(false);\n-                 expect(initFnInvoked).toBe(true);\n-               });\n-         })));\n+      expect(status.done).toBe(false);\n+      try {\n+        await status.donePromise;\n+        fail('donePromise should have been rejected when promise is rejected');\n+      } catch {\n+        expect(status.done).toBe(false);\n+        expect(initFnInvoked).toBe(true);\n+      }\n     });\n+  });\n \n-    describe('with app initializers represented using observables', () => {\n-      let subscriber: Subscriber<any>;\n-      let observable: Observable<any>;\n-      let initFnInvoked = false;\n-      beforeEach(() => {\n-        observable = new Observable((res) => {\n-          subscriber = res;\n-        });\n-        TestBed.configureTestingModule({\n-          providers: [\n-            {provide: APP_INITIALIZER, multi: true, useValue: () => observable},\n-          ]\n-        });\n+  describe('with app initializers represented using observables', () => {\n+    let subscriber: Subscriber<any>;\n+    let initFnInvoked = false;\n+    beforeEach(() => {\n+      const observable = new Observable((res) => {\n+        subscriber = res;\n       });\n+      status = new ApplicationInitStatus([() => observable]);\n+    });\n+\n+    it('should update the status once all async observable initializers are completed',\n+       async () => {\n+         runInitializers();\n+\n+         setTimeout(() => {\n+           initFnInvoked = true;\n+           subscriber.complete();\n+         });\n \n-      it('should update the status once all async observable initializers are completed',\n-         waitForAsync(inject([ApplicationInitStatus], (status: ApplicationInitStatus) => {\n-           // Accessing internal `runInitializers` function of the `ApplicationInitStatus` class\n-           // instance for testing purposes to invoke initializer functions.\n-           (status as any).runInitializers();\n-\n-           setTimeout(() => {\n-             initFnInvoked = true;\n-             subscriber.complete();\n-           });\n-\n-           expect(status.done).toBe(false);\n-           status.donePromise.then(() => {\n-             expect(status.done).toBe(true);\n-             expect(initFnInvoked).toBe(true);\n-           });\n-         })));\n-\n-      it('should update the status once all async observable initializers nexted and completed',\n-         waitForAsync(inject([ApplicationInitStatus], (status: ApplicationInitStatus) => {\n-           // Accessing internal `runInitializers` function of the `ApplicationInitStatus` class\n-           // instance for testing purposes to invoke initializer functions.\n-           (status as any).runInitializers();\n-\n-           subscriber.next('one');\n-           subscriber.next('two');\n-\n-           setTimeout(() => {\n-             initFnInvoked = true;\n-             subscriber.complete();\n-           });\n-\n-           expect(status.done).toBe(false);\n-           status.donePromise.then(() => {\n-             expect(status.done).toBe(true);\n-             expect(initFnInvoked).toBe(true);\n-           });\n-         })));\n-\n-      it('should update the status if all async observable initializers are completed before runInitializers',\n-         waitForAsync(inject([ApplicationInitStatus], (status: ApplicationInitStatus) => {\n+         expect(status.done).toBe(false);\n+         await status.donePromise;\n+         expect(status.done).toBe(true);\n+         expect(initFnInvoked).toBe(true);\n+       });\n+\n+    it('should update the status once all async observable initializers emitted and completed',\n+       async () => {\n+         runInitializers();\n+\n+         subscriber.next('one');\n+         subscriber.next('two');\n+\n+         setTimeout(() => {\n+           initFnInvoked = true;\n            subscriber.complete();\n-           // Accessing internal `runInitializers` function of the `ApplicationInitStatus` class\n-           // instance for testing purposes to invoke initializer functions.\n-           (status as any).runInitializers();\n-\n-           expect(status.done).toBe(false);\n-\n-           status.donePromise.then(() => {\n-             expect(status.done).toBe(true);\n-           });\n-         })));\n-\n-      it('should handle a case when observable emits an error',\n-         waitForAsync(inject([ApplicationInitStatus], (status: ApplicationInitStatus) => {\n-           // Accessing internal `runInitializers` function of the `ApplicationInitStatus` class\n-           // instance for testing purposes to invoke initializer functions.\n-           (status as any).runInitializers();\n-\n-           setTimeout(() => {\n-             initFnInvoked = true;\n-             subscriber.error();\n-           });\n-\n-           expect(status.done).toBe(false);\n-           status.donePromise\n-               .then(\n-                   () => fail(\n-                       '`donePromise.then` should not be invoked when observable emits an error'))\n-               .catch(() => {\n-                 expect(status.done).toBe(false);\n-                 expect(initFnInvoked).toBe(true);\n-               });\n-         })));\n+         });\n+\n+         await status.donePromise;\n+         expect(status.done).toBe(true);\n+         expect(initFnInvoked).toBe(true);\n+       });\n+\n+    it('should update the status if all async observable initializers are completed synchronously',\n+       async () => {\n+         // Create a status instance using an initializer that returns the `EMPTY` Observable\n+         // which completes synchronously upon subscription.\n+         status = new ApplicationInitStatus([() => EMPTY]);\n+\n+         runInitializers();\n+\n+         // Although the Observable completes synchronously, we still queue a promise for\n+         // simplicity. This means that the `done` flag will not be `true` immediately, even\n+         // though there was not actually any asynchronous activity.\n+         expect(status.done).toBe(false);\n+\n+         await status.donePromise;\n+         expect(status.done).toBe(true);\n+       });\n+\n+    it('should handle a case when observable emits an error', async () => {\n+      runInitializers();\n+\n+      setTimeout(() => {\n+        initFnInvoked = true;\n+        subscriber.error();\n+      });\n+\n+      expect(status.done).toBe(false);\n+      try {\n+        await status.donePromise;\n+        fail('donePromise should have been rejected when observable emits an error');\n+      } catch {\n+        expect(status.done).toBe(false);\n+        expect(initFnInvoked).toBe(true);\n+      }\n     });\n   });\n-}\n+});"
        }
    ],
    "stats": {
        "total": 301,
        "additions": 140,
        "deletions": 161
    }
}