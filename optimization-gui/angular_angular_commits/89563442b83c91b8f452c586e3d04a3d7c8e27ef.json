{
    "author": "petebacondarwin",
    "message": "refactor(compiler): remove unused `emitAllPartialModules()` and associated code (#41040)\n\nThis method does not appear to be used in the project.\nThis commit removes it and code that it exclusively\ndepended upon, or depended upon it.\n\nPR Close #41040",
    "sha": "89563442b83c91b8f452c586e3d04a3d7c8e27ef",
    "files": [
        {
            "sha": "47db67073a0561de8a31f1492b57f005ef34de08",
            "filename": "packages/compiler/src/aot/compiler.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 110,
            "changes": 112,
            "blob_url": "https://github.com/angular/angular/blob/89563442b83c91b8f452c586e3d04a3d7c8e27ef/packages%2Fcompiler%2Fsrc%2Faot%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/89563442b83c91b8f452c586e3d04a3d7c8e27ef/packages%2Fcompiler%2Fsrc%2Faot%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Faot%2Fcompiler.ts?ref=89563442b83c91b8f452c586e3d04a3d7c8e27ef",
            "patch": "@@ -15,23 +15,16 @@ import {createTokenForExternalReference, Identifiers} from '../identifiers';\n import {InjectableCompiler} from '../injectable_compiler';\n import {CompileMetadataResolver} from '../metadata_resolver';\n import {HtmlParser} from '../ml_parser/html_parser';\n-import {removeWhitespaces} from '../ml_parser/html_whitespaces';\n-import {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../ml_parser/interpolation_config';\n+import {InterpolationConfig} from '../ml_parser/interpolation_config';\n import {NgModuleCompiler} from '../ng_module_compiler';\n import {OutputEmitter} from '../output/abstract_emitter';\n import * as o from '../output/output_ast';\n import {ParseError} from '../parse_util';\n-import {compileNgModuleFromRender2 as compileR3Module} from '../render3/r3_module_compiler';\n-import {compilePipeFromRender2 as compileR3Pipe} from '../render3/r3_pipe_compiler';\n-import {htmlAstToRender3Ast} from '../render3/r3_template_transform';\n-import {compileComponentFromRender2 as compileR3Component, compileDirectiveFromRender2 as compileR3Directive} from '../render3/view/compiler';\n-import {DomElementSchemaRegistry} from '../schema/dom_element_schema_registry';\n import {CompiledStylesheet, StyleCompiler} from '../style_compiler';\n import {SummaryResolver} from '../summary_resolver';\n-import {BindingParser} from '../template_parser/binding_parser';\n import {TemplateAst} from '../template_parser/template_ast';\n import {TemplateParser} from '../template_parser/template_parser';\n-import {error, newArray, OutputContext, syntaxError, ValueVisitor, visitValue} from '../util';\n+import {newArray, OutputContext, syntaxError, ValueVisitor, visitValue} from '../util';\n import {TypeCheckCompiler} from '../view_compiler/type_check_compiler';\n import {ViewCompiler, ViewCompileResult} from '../view_compiler/view_compiler';\n \n@@ -341,107 +334,6 @@ export class AotCompiler {\n     return messageBundle;\n   }\n \n-  emitAllPartialModules(\n-      {ngModuleByPipeOrDirective, files}: NgAnalyzedModules,\n-      r3Files: NgAnalyzedFileWithInjectables[]): PartialModule[] {\n-    const contextMap = new Map<string, OutputContext>();\n-\n-    const getContext = (fileName: string): OutputContext => {\n-      if (!contextMap.has(fileName)) {\n-        contextMap.set(fileName, this._createOutputContext(fileName));\n-      }\n-      return contextMap.get(fileName)!;\n-    };\n-\n-    files.forEach(\n-        file => this._compilePartialModule(\n-            file.fileName, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules,\n-            file.injectables, getContext(file.fileName)));\n-    r3Files.forEach(\n-        file => this._compileShallowModules(\n-            file.fileName, file.shallowModules, getContext(file.fileName)));\n-\n-    return Array.from(contextMap.values())\n-        .map(context => ({\n-               fileName: context.genFilePath,\n-               statements: [...context.constantPool.statements, ...context.statements],\n-             }));\n-  }\n-\n-  private _compileShallowModules(\n-      fileName: string, shallowModules: CompileShallowModuleMetadata[],\n-      context: OutputContext): void {\n-    shallowModules.forEach(module => compileR3Module(context, module, this._injectableCompiler));\n-  }\n-\n-  private _compilePartialModule(\n-      fileName: string, ngModuleByPipeOrDirective: Map<StaticSymbol, CompileNgModuleMetadata>,\n-      directives: StaticSymbol[], pipes: StaticSymbol[], ngModules: CompileNgModuleMetadata[],\n-      injectables: CompileInjectableMetadata[], context: OutputContext): void {\n-    const errors: ParseError[] = [];\n-\n-    const schemaRegistry = new DomElementSchemaRegistry();\n-    const hostBindingParser = new BindingParser(\n-        this._templateParser.expressionParser, DEFAULT_INTERPOLATION_CONFIG, schemaRegistry, [],\n-        errors);\n-\n-    // Process all components and directives\n-    directives.forEach(directiveType => {\n-      const directiveMetadata = this._metadataResolver.getDirectiveMetadata(directiveType);\n-      if (directiveMetadata.isComponent) {\n-        const module = ngModuleByPipeOrDirective.get(directiveType)!;\n-        module ||\n-            error(`Cannot determine the module for component '${\n-                identifierName(directiveMetadata.type)}'`);\n-\n-        let htmlAst = directiveMetadata.template !.htmlAst!;\n-        const preserveWhitespaces = directiveMetadata!.template !.preserveWhitespaces;\n-\n-        if (!preserveWhitespaces) {\n-          htmlAst = removeWhitespaces(htmlAst);\n-        }\n-        const render3Ast = htmlAstToRender3Ast(htmlAst.rootNodes, hostBindingParser);\n-\n-        // Map of StaticType by directive selectors\n-        const directiveTypeBySel = new Map<string, any>();\n-\n-        const directives = module.transitiveModule.directives.map(\n-            dir => this._metadataResolver.getDirectiveSummary(dir.reference));\n-\n-        directives.forEach(directive => {\n-          if (directive.selector) {\n-            directiveTypeBySel.set(directive.selector, directive.type.reference);\n-          }\n-        });\n-\n-        // Map of StaticType by pipe names\n-        const pipeTypeByName = new Map<string, any>();\n-\n-        const pipes = module.transitiveModule.pipes.map(\n-            pipe => this._metadataResolver.getPipeSummary(pipe.reference));\n-\n-        pipes.forEach(pipe => {\n-          pipeTypeByName.set(pipe.name, pipe.type.reference);\n-        });\n-\n-        compileR3Component(\n-            context, directiveMetadata, render3Ast, this.reflector, hostBindingParser,\n-            directiveTypeBySel, pipeTypeByName);\n-      } else {\n-        compileR3Directive(context, directiveMetadata, this.reflector, hostBindingParser);\n-      }\n-    });\n-\n-    pipes.forEach(pipeType => {\n-      const pipeMetadata = this._metadataResolver.getPipeMetadata(pipeType);\n-      if (pipeMetadata) {\n-        compileR3Pipe(context, pipeMetadata, this.reflector);\n-      }\n-    });\n-\n-    injectables.forEach(injectable => this._injectableCompiler.compile(injectable, context));\n-  }\n-\n   emitAllPartialModules2(files: NgAnalyzedFileWithInjectables[]): PartialModule[] {\n     // Using reduce like this is a select many pattern (where map is a select pattern)\n     return files.reduce<PartialModule[]>((r, file) => {"
        },
        {
            "sha": "7bf066338a3856f9944f241018aadb93a138196a",
            "filename": "packages/compiler/src/render3/r3_module_compiler.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 37,
            "changes": 38,
            "blob_url": "https://github.com/angular/angular/blob/89563442b83c91b8f452c586e3d04a3d7c8e27ef/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_module_compiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/89563442b83c91b8f452c586e3d04a3d7c8e27ef/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_module_compiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_module_compiler.ts?ref=89563442b83c91b8f452c586e3d04a3d7c8e27ef",
            "patch": "@@ -6,15 +6,11 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {CompileShallowModuleMetadata, identifierName} from '../compile_metadata';\n-import {InjectableCompiler} from '../injectable_compiler';\n-import {mapLiteral} from '../output/map_util';\n import * as o from '../output/output_ast';\n-import {OutputContext} from '../util';\n \n import {compileFactoryFunction, R3DependencyMetadata, R3FactoryTarget} from './r3_factory';\n import {Identifiers as R3} from './r3_identifiers';\n-import {convertMetaToOutput, jitOnlyGuardedExpression, mapToMapExpression, R3Reference} from './util';\n+import {jitOnlyGuardedExpression, mapToMapExpression, R3Reference} from './util';\n \n export interface R3NgModuleDef {\n   expression: o.Expression;\n@@ -261,38 +257,6 @@ export function compileInjector(meta: R3InjectorMetadata): R3InjectorDef {\n   return {expression, type, statements: result.statements};\n }\n \n-// TODO(alxhub): integrate this with `compileNgModule`. Currently the two are separate operations.\n-export function compileNgModuleFromRender2(\n-    ctx: OutputContext, ngModule: CompileShallowModuleMetadata,\n-    injectableCompiler: InjectableCompiler): void {\n-  const className = identifierName(ngModule.type)!;\n-\n-  const rawImports = ngModule.rawImports ? [ngModule.rawImports] : [];\n-  const rawExports = ngModule.rawExports ? [ngModule.rawExports] : [];\n-\n-  const injectorDefArg = mapLiteral({\n-    'factory':\n-        injectableCompiler.factoryFor({type: ngModule.type, symbol: ngModule.type.reference}, ctx),\n-    'providers': convertMetaToOutput(ngModule.rawProviders, ctx),\n-    'imports': convertMetaToOutput([...rawImports, ...rawExports], ctx),\n-  });\n-\n-  const injectorDef = o.importExpr(R3.defineInjector).callFn([injectorDefArg]);\n-\n-  ctx.statements.push(new o.ClassStmt(\n-      /* name */ className,\n-      /* parent */ null,\n-      /* fields */[new o.ClassField(\n-          /* name */ 'ɵinj',\n-          /* type */ o.INFERRED_TYPE,\n-          /* modifiers */[o.StmtModifier.Static],\n-          /* initializer */ injectorDef,\n-          )],\n-      /* getters */[],\n-      /* constructorMethod */ new o.ClassMethod(null, [], []),\n-      /* methods */[]));\n-}\n-\n function tupleTypeOf(exp: R3Reference[]): o.Type {\n   const types = exp.map(ref => o.typeofExpr(ref.type));\n   return exp.length > 0 ? o.expressionType(o.literalArr(types)) : o.NONE_TYPE;"
        },
        {
            "sha": "6a9e25ef1ca2b110cd52ab9e0d9de4efb463c1eb",
            "filename": "packages/compiler/src/render3/r3_pipe_compiler.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 59,
            "changes": 61,
            "blob_url": "https://github.com/angular/angular/blob/89563442b83c91b8f452c586e3d04a3d7c8e27ef/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_pipe_compiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/89563442b83c91b8f452c586e3d04a3d7c8e27ef/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_pipe_compiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fr3_pipe_compiler.ts?ref=89563442b83c91b8f452c586e3d04a3d7c8e27ef",
            "patch": "@@ -5,16 +5,11 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-\n-import {CompilePipeMetadata, identifierName} from '../compile_metadata';\n-import {CompileReflector} from '../compile_reflector';\n-import {DefinitionKind} from '../constant_pool';\n import * as o from '../output/output_ast';\n-import {error, OutputContext} from '../util';\n \n-import {compileFactoryFunction, dependenciesFromGlobalMetadata, R3DependencyMetadata, R3FactoryTarget} from './r3_factory';\n+import {R3DependencyMetadata} from './r3_factory';\n import {Identifiers as R3} from './r3_identifiers';\n-import {R3Reference, typeWithParameters, wrapReference} from './util';\n+import {R3Reference, typeWithParameters} from './util';\n import {R3PipeDef} from './view/api';\n \n export interface R3PipeMetadata {\n@@ -82,55 +77,3 @@ export function createPipeType(metadata: R3PipeMetadata): o.Type {\n     new o.ExpressionType(new o.LiteralExpr(metadata.pipeName)),\n   ]));\n }\n-\n-/**\n- * Write a pipe definition to the output context.\n- */\n-export function compilePipeFromRender2(\n-    outputCtx: OutputContext, pipe: CompilePipeMetadata, reflector: CompileReflector) {\n-  const name = identifierName(pipe.type);\n-\n-  if (!name) {\n-    return error(`Cannot resolve the name of ${pipe.type}`);\n-  }\n-\n-  const type = outputCtx.importExpr(pipe.type.reference);\n-  const metadata: R3PipeMetadata = {\n-    name,\n-    type: wrapReference(type),\n-    internalType: type,\n-    pipeName: pipe.name,\n-    typeArgumentCount: 0,\n-    deps: dependenciesFromGlobalMetadata(pipe.type, outputCtx, reflector),\n-    pure: pipe.pure,\n-  };\n-  const res = compilePipeFromMetadata(metadata);\n-  const factoryRes = compileFactoryFunction(\n-      {...metadata, injectFn: R3.directiveInject, target: R3FactoryTarget.Pipe});\n-  const definitionField = outputCtx.constantPool.propertyNameOf(DefinitionKind.Pipe);\n-  const ngFactoryDefStatement = new o.ClassStmt(\n-      /* name */ name,\n-      /* parent */ null,\n-      /* fields */\n-      [new o.ClassField(\n-          /* name */ 'ɵfac',\n-          /* type */ o.INFERRED_TYPE,\n-          /* modifiers */[o.StmtModifier.Static],\n-          /* initializer */ factoryRes.factory)],\n-      /* getters */[],\n-      /* constructorMethod */ new o.ClassMethod(null, [], []),\n-      /* methods */[]);\n-  const pipeDefStatement = new o.ClassStmt(\n-      /* name */ name,\n-      /* parent */ null,\n-      /* fields */[new o.ClassField(\n-          /* name */ definitionField,\n-          /* type */ o.INFERRED_TYPE,\n-          /* modifiers */[o.StmtModifier.Static],\n-          /* initializer */ res.expression)],\n-      /* getters */[],\n-      /* constructorMethod */ new o.ClassMethod(null, [], []),\n-      /* methods */[]);\n-\n-  outputCtx.statements.push(ngFactoryDefStatement, pipeDefStatement);\n-}"
        },
        {
            "sha": "6bc916d5720c3657df1bb14fbff9acd1c599faa6",
            "filename": "packages/compiler/src/render3/view/compiler.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 157,
            "changes": 160,
            "blob_url": "https://github.com/angular/angular/blob/89563442b83c91b8f452c586e3d04a3d7c8e27ef/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/89563442b83c91b8f452c586e3d04a3d7c8e27ef/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fcompiler.ts?ref=89563442b83c91b8f452c586e3d04a3d7c8e27ef",
            "patch": "@@ -6,33 +6,27 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {StaticSymbol} from '../../aot/static_symbol';\n-import {CompileDirectiveMetadata, CompileDirectiveSummary, CompileQueryMetadata, CompileTokenMetadata, identifierName, sanitizeIdentifier} from '../../compile_metadata';\n-import {CompileReflector} from '../../compile_reflector';\n+import {CompileDirectiveSummary, sanitizeIdentifier} from '../../compile_metadata';\n import {BindingForm, convertPropertyBinding} from '../../compiler_util/expression_converter';\n-import {ConstantPool, DefinitionKind} from '../../constant_pool';\n+import {ConstantPool} from '../../constant_pool';\n import * as core from '../../core';\n import {AST, ParsedEvent, ParsedEventType, ParsedProperty} from '../../expression_parser/ast';\n-import {DEFAULT_INTERPOLATION_CONFIG} from '../../ml_parser/interpolation_config';\n import * as o from '../../output/output_ast';\n import {ParseError, ParseSourceSpan} from '../../parse_util';\n import {CssSelector, SelectorMatcher} from '../../selector';\n import {ShadowCss} from '../../shadow_css';\n import {CONTENT_ATTR, HOST_ATTR} from '../../style_compiler';\n import {BindingParser} from '../../template_parser/binding_parser';\n-import {error, OutputContext} from '../../util';\n+import {error} from '../../util';\n import {BoundEvent} from '../r3_ast';\n-import {compileFactoryFunction, R3FactoryTarget} from '../r3_factory';\n import {Identifiers as R3} from '../r3_identifiers';\n-import {Render3ParseResult} from '../r3_template_transform';\n import {prepareSyntheticListenerFunctionName, prepareSyntheticPropertyName, typeWithParameters} from '../util';\n \n import {DeclarationListEmitMode, R3ComponentDef, R3ComponentMetadata, R3DirectiveDef, R3DirectiveMetadata, R3HostMetadata, R3QueryMetadata} from './api';\n import {MIN_STYLING_BINDING_SLOTS_REQUIRED, StylingBuilder, StylingInstructionCall} from './styling_builder';\n import {BindingScope, makeBindingParser, prepareEventListenerParameters, renderFlagCheckIfStmt, resolveSanitizationFn, TemplateDefinitionBuilder, ValueConverter} from './template';\n import {asLiteral, chainedInstruction, conditionallyCreateMapObjectLiteral, CONTEXT_NAME, DefinitionMap, getQueryPredicate, RENDER_FLAGS, TEMPORARY_NAME, temporaryAllocator} from './util';\n \n-const EMPTY_ARRAY: any[] = [];\n \n // This regex matches any binding names that contain the \"attr.\" prefix, e.g. \"attr.required\"\n // If there is a match, the first matching group will contain the attribute name to bind.\n@@ -293,147 +287,6 @@ function compileDeclarationList(\n   }\n }\n \n-/**\n- * A wrapper around `compileDirective` which depends on render2 global analysis data as its input\n- * instead of the `R3DirectiveMetadata`.\n- *\n- * `R3DirectiveMetadata` is computed from `CompileDirectiveMetadata` and other statically reflected\n- * information.\n- */\n-export function compileDirectiveFromRender2(\n-    outputCtx: OutputContext, directive: CompileDirectiveMetadata, reflector: CompileReflector,\n-    bindingParser: BindingParser) {\n-  const name = identifierName(directive.type)!;\n-  name || error(`Cannot resolver the name of ${directive.type}`);\n-\n-  const definitionField = outputCtx.constantPool.propertyNameOf(DefinitionKind.Directive);\n-\n-  const meta = directiveMetadataFromGlobalMetadata(directive, outputCtx, reflector);\n-  const res = compileDirectiveFromMetadata(meta, outputCtx.constantPool, bindingParser);\n-  const factoryRes = compileFactoryFunction(\n-      {...meta, injectFn: R3.directiveInject, target: R3FactoryTarget.Directive});\n-  const ngFactoryDefStatement = new o.ClassStmt(\n-      name, null,\n-      [new o.ClassField('ɵfac', o.INFERRED_TYPE, [o.StmtModifier.Static], factoryRes.factory)], [],\n-      new o.ClassMethod(null, [], []), []);\n-  const directiveDefStatement = new o.ClassStmt(\n-      name, null,\n-      [new o.ClassField(definitionField, o.INFERRED_TYPE, [o.StmtModifier.Static], res.expression)],\n-      [], new o.ClassMethod(null, [], []), []);\n-\n-  // Create the partial class to be merged with the actual class.\n-  outputCtx.statements.push(ngFactoryDefStatement, directiveDefStatement);\n-}\n-\n-/**\n- * A wrapper around `compileComponent` which depends on render2 global analysis data as its input\n- * instead of the `R3DirectiveMetadata`.\n- *\n- * `R3ComponentMetadata` is computed from `CompileDirectiveMetadata` and other statically reflected\n- * information.\n- */\n-export function compileComponentFromRender2(\n-    outputCtx: OutputContext, component: CompileDirectiveMetadata, render3Ast: Render3ParseResult,\n-    reflector: CompileReflector, bindingParser: BindingParser, directiveTypeBySel: Map<string, any>,\n-    pipeTypeByName: Map<string, any>) {\n-  const name = identifierName(component.type)!;\n-  name || error(`Cannot resolver the name of ${component.type}`);\n-\n-  const definitionField = outputCtx.constantPool.propertyNameOf(DefinitionKind.Component);\n-\n-  const summary = component.toSummary();\n-\n-  // Compute the R3ComponentMetadata from the CompileDirectiveMetadata\n-  const meta: R3ComponentMetadata = {\n-    ...directiveMetadataFromGlobalMetadata(component, outputCtx, reflector),\n-    selector: component.selector,\n-    template: {nodes: render3Ast.nodes, ngContentSelectors: render3Ast.ngContentSelectors},\n-    directives: [],\n-    pipes: typeMapToExpressionMap(pipeTypeByName, outputCtx),\n-    viewQueries: queriesFromGlobalMetadata(component.viewQueries, outputCtx),\n-    declarationListEmitMode: DeclarationListEmitMode.Direct,\n-    styles: (summary.template && summary.template.styles) || EMPTY_ARRAY,\n-    encapsulation:\n-        (summary.template && summary.template.encapsulation) || core.ViewEncapsulation.Emulated,\n-    interpolation: DEFAULT_INTERPOLATION_CONFIG,\n-    animations: null,\n-    viewProviders:\n-        component.viewProviders.length > 0 ? new o.WrappedNodeExpr(component.viewProviders) : null,\n-    relativeContextFilePath: '',\n-    i18nUseExternalIds: true,\n-  };\n-  const res = compileComponentFromMetadata(meta, outputCtx.constantPool, bindingParser);\n-  const factoryRes = compileFactoryFunction(\n-      {...meta, injectFn: R3.directiveInject, target: R3FactoryTarget.Directive});\n-  const ngFactoryDefStatement = new o.ClassStmt(\n-      name, null,\n-      [new o.ClassField('ɵfac', o.INFERRED_TYPE, [o.StmtModifier.Static], factoryRes.factory)], [],\n-      new o.ClassMethod(null, [], []), []);\n-  const componentDefStatement = new o.ClassStmt(\n-      name, null,\n-      [new o.ClassField(definitionField, o.INFERRED_TYPE, [o.StmtModifier.Static], res.expression)],\n-      [], new o.ClassMethod(null, [], []), []);\n-\n-  // Create the partial class to be merged with the actual class.\n-  outputCtx.statements.push(ngFactoryDefStatement, componentDefStatement);\n-}\n-\n-/**\n- * Compute `R3DirectiveMetadata` given `CompileDirectiveMetadata` and a `CompileReflector`.\n- */\n-function directiveMetadataFromGlobalMetadata(\n-    directive: CompileDirectiveMetadata, outputCtx: OutputContext,\n-    reflector: CompileReflector): R3DirectiveMetadata {\n-  // The global-analysis based Ivy mode in ngc is no longer utilized/supported.\n-  throw new Error('unsupported');\n-}\n-\n-/**\n- * Convert `CompileQueryMetadata` into `R3QueryMetadata`.\n- */\n-function queriesFromGlobalMetadata(\n-    queries: CompileQueryMetadata[], outputCtx: OutputContext): R3QueryMetadata[] {\n-  return queries.map(query => {\n-    let read: o.Expression|null = null;\n-    if (query.read && query.read.identifier) {\n-      read = outputCtx.importExpr(query.read.identifier.reference);\n-    }\n-    return {\n-      propertyName: query.propertyName,\n-      first: query.first,\n-      predicate: selectorsFromGlobalMetadata(query.selectors, outputCtx),\n-      descendants: query.descendants,\n-      read,\n-      emitDistinctChangesOnly: !!query.emitDistinctChangesOnly,\n-      static: !!query.static\n-    };\n-  });\n-}\n-\n-/**\n- * Convert `CompileTokenMetadata` for query selectors into either an expression for a predicate\n- * type, or a list of string predicates.\n- */\n-function selectorsFromGlobalMetadata(\n-    selectors: CompileTokenMetadata[], outputCtx: OutputContext): o.Expression|string[] {\n-  if (selectors.length > 1 || (selectors.length == 1 && selectors[0].value)) {\n-    const selectorStrings = selectors.map(value => value.value as string);\n-    selectorStrings.some(value => !value) &&\n-        error('Found a type among the string selectors expected');\n-    return outputCtx.constantPool.getConstLiteral(\n-        o.literalArr(selectorStrings.map(value => o.literal(value))));\n-  }\n-\n-  if (selectors.length == 1) {\n-    const first = selectors[0];\n-    if (first.identifier) {\n-      return outputCtx.importExpr(first.identifier.reference);\n-    }\n-  }\n-\n-  error('Unexpected query form');\n-}\n-\n function prepareQueryParams(query: R3QueryMetadata, constantPool: ConstantPool): o.Expression[] {\n   const parameters = [getQueryPredicate(query, constantPool), o.literal(toQueryFlags(query))];\n   if (query.read) {\n@@ -865,13 +718,6 @@ function metadataAsSummary(meta: R3HostMetadata): CompileDirectiveSummary {\n }\n \n \n-function typeMapToExpressionMap(\n-    map: Map<string, StaticSymbol>, outputCtx: OutputContext): Map<string, o.Expression> {\n-  // Convert each map entry into another entry where the value is an expression importing the type.\n-  const entries = Array.from(map).map(\n-      ([key, type]): [string, o.Expression] => [key, outputCtx.importExpr(type)]);\n-  return new Map(entries);\n-}\n \n const HOST_REG_EXP = /^(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\))$/;\n // Represents the groups in the above regex."
        }
    ],
    "stats": {
        "total": 371,
        "additions": 8,
        "deletions": 363
    }
}