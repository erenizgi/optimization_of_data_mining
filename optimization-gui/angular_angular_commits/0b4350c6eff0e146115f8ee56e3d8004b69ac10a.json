{
    "author": "alan-agius4",
    "message": "refactor(migrations): remove no longer accessible migrations (#43942)\n\nWith this change we remove no longer needed migrations. These migrations are no longer accessible following a change https://github.com/angular/angular-cli/pull/21986 in the Angular CLI.  The CLI now shows an error message when users try to update `@angular/` and `@nguniversal/` packages across multiple major versions.\n\nExample to update from version 11 to version 13 the recommand approach is to run the following commands\n\n```\nng update @angular/core@12\nng update @angular/core@13 (which is the same as ng update @angular/core)\n```\n\nNB: It is recommand that when update from one major to another, users verify that their applications is working as expected.\n\nPR Close #43942",
    "sha": "0b4350c6eff0e146115f8ee56e3d8004b69ac10a",
    "files": [
        {
            "sha": "a60dbd252def92cce26d4c6d198d343cfd538f42",
            "filename": "packages/core/schematics/BUILD.bazel",
            "status": "modified",
            "additions": 0,
            "deletions": 20,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/0b4350c6eff0e146115f8ee56e3d8004b69ac10a/packages%2Fcore%2Fschematics%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/0b4350c6eff0e146115f8ee56e3d8004b69ac10a/packages%2Fcore%2Fschematics%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2FBUILD.bazel?ref=0b4350c6eff0e146115f8ee56e3d8004b69ac10a",
            "patch": "@@ -13,27 +13,7 @@ pkg_npm(\n     ],\n     visibility = [\"//packages/core:__pkg__\"],\n     deps = [\n-        \"//packages/core/schematics/migrations/abstract-control-parent\",\n-        \"//packages/core/schematics/migrations/activated-route-snapshot-fragment\",\n-        \"//packages/core/schematics/migrations/can-activate-with-redirect-to\",\n-        \"//packages/core/schematics/migrations/deep-shadow-piercing-selector\",\n-        \"//packages/core/schematics/migrations/dynamic-queries\",\n-        \"//packages/core/schematics/migrations/initial-navigation\",\n-        \"//packages/core/schematics/migrations/missing-injectable\",\n-        \"//packages/core/schematics/migrations/module-with-providers\",\n-        \"//packages/core/schematics/migrations/move-document\",\n-        \"//packages/core/schematics/migrations/native-view-encapsulation\",\n-        \"//packages/core/schematics/migrations/navigation-extras-omissions\",\n-        \"//packages/core/schematics/migrations/relative-link-resolution\",\n-        \"//packages/core/schematics/migrations/renderer-to-renderer2\",\n         \"//packages/core/schematics/migrations/router-link-empty-expression\",\n-        \"//packages/core/schematics/migrations/router-preserve-query-params\",\n-        \"//packages/core/schematics/migrations/static-queries\",\n-        \"//packages/core/schematics/migrations/template-var-assignment\",\n         \"//packages/core/schematics/migrations/testbed-teardown\",\n-        \"//packages/core/schematics/migrations/undecorated-classes-with-decorated-fields\",\n-        \"//packages/core/schematics/migrations/undecorated-classes-with-di\",\n-        \"//packages/core/schematics/migrations/wait-for-async\",\n-        \"//packages/core/schematics/migrations/xhr-factory\",\n     ],\n )"
        },
        {
            "sha": "05f02c3dec062da3001fad1fa767b7a0501b8a02",
            "filename": "packages/core/schematics/migrations.json",
            "status": "modified",
            "additions": 0,
            "deletions": 100,
            "changes": 100,
            "blob_url": "https://github.com/angular/angular/blob/0b4350c6eff0e146115f8ee56e3d8004b69ac10a/packages%2Fcore%2Fschematics%2Fmigrations.json",
            "raw_url": "https://github.com/angular/angular/raw/0b4350c6eff0e146115f8ee56e3d8004b69ac10a/packages%2Fcore%2Fschematics%2Fmigrations.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations.json?ref=0b4350c6eff0e146115f8ee56e3d8004b69ac10a",
            "patch": "@@ -1,105 +1,5 @@\n {\n   \"schematics\": {\n-    \"migration-v8-move-document\": {\n-      \"version\": \"8.0.0-beta\",\n-      \"description\": \"@DOCUMENT migration. Migrates DOCUMENT Injection token from platform-browser imports to common import.\",\n-      \"factory\": \"./migrations/move-document/index\"\n-    },\n-    \"migration-v8-static-queries\": {\n-      \"version\": \"8.0.0-beta\",\n-      \"description\": \"ViewChild and ContentChild to explicit query timing migration. In Angular version 8, developers need to explicitly specify the timing of ViewChild and ContentChild queries. Read more about this here: https://v8.angular.io/guide/static-query-migration\",\n-      \"factory\": \"./migrations/static-queries/index\"\n-    },\n-    \"migration-v8-template-local-variables\": {\n-      \"version\": \"8.0.0-beta\",\n-      \"description\": \"Template Variable Assignment migration. Warns developers if values are assigned to template variables.\",\n-      \"factory\": \"./migrations/template-var-assignment/index\"\n-    },\n-    \"migration-v9-renderer-to-renderer2\": {\n-      \"version\": \"9.0.0-beta\",\n-      \"description\": \"Renderer to Renderer2 migration. As of Angular 9, the Renderer class is no longer available. Renderer2 should be used instead. Read more about this here: https://v9.angular.io/guide/migration-renderer\",\n-      \"factory\": \"./migrations/renderer-to-renderer2/index\"\n-    },\n-    \"migration-v9-undecorated-classes-with-di\": {\n-      \"version\": \"9.0.0-beta\",\n-      \"description\": \"Undecorated classes with DI migration. As of Angular 9, it is no longer supported to use Angular DI on a class that does not have an Angular decorator. Read more about this here: https://v9.angular.io/guide/migration-undecorated-classes\",\n-      \"factory\": \"./migrations/undecorated-classes-with-di/index\"\n-    },\n-    \"migration-v9-dynamic-queries\": {\n-      \"version\": \"9-beta\",\n-      \"description\": \"Static flag migration. Removes the `static` flag from dynamic queries. As of Angular 9, the \\\"static\\\" flag defaults to false and is no longer required for your view and content queries. Read more about this here: https://v9.angular.io/guide/migration-dynamic-flag\",\n-      \"factory\": \"./migrations/dynamic-queries/index\"\n-    },\n-    \"migration-v10-missing-injectable\": {\n-      \"version\": \"10.0.0-beta\",\n-      \"description\": \"Missing @Injectable and incomplete provider definition migration. As of Angular 9, enforcement of @Injectable decorators for DI is a bit stricter and incomplete provider definitions behave differently. Read more about this here: https://v9.angular.io/guide/migration-injectable\",\n-      \"factory\": \"./migrations/missing-injectable/index\"\n-    },\n-    \"migration-v10-module-with-providers\": {\n-      \"version\": \"10.0.0-beta\",\n-      \"description\": \"ModuleWithProviders migration. As of Angular 10, the ModuleWithProviders type requires a generic. This migration adds the generic where it is missing. Read more about this here: https://v10.angular.io/guide/migration-module-with-providers\",\n-      \"factory\": \"./migrations/module-with-providers/index\"\n-    },\n-    \"migration-v10-undecorated-classes-with-decorated-fields\": {\n-      \"version\": \"10.0.0-beta\",\n-      \"description\": \"Undecorated classes with Angular features migration. In version 10, classes that use Angular features and do not have an Angular decorator are no longer supported. Read more about this here: https://v10.angular.io/guide/migration-undecorated-classes\",\n-      \"factory\": \"./migrations/undecorated-classes-with-decorated-fields/index\"\n-    },\n-    \"migration-v11-navigation-extras-omissions\": {\n-      \"version\": \"11.0.0-beta\",\n-      \"description\": \"NavigationExtras omissions migration. In version 11, some unsupported properties were omitted from the `extras` parameter of the `Router.navigateByUrl` and `Router.createUrlTree` methods.\",\n-      \"factory\": \"./migrations/navigation-extras-omissions/index\"\n-    },\n-    \"migration-v11-router-relative-link-resolution-default\": {\n-      \"version\": \"11.0.0-beta\",\n-      \"description\": \"The default value for `relativeLinkResolution` is changing from 'legacy' to 'corrected'.\\nThis migration updates `RouterModule` configurations that use the default value to \\nnow specifically use 'legacy' to prevent breakages when updating.\",\n-      \"factory\": \"./migrations/relative-link-resolution/index\"\n-    },\n-    \"migration-v11-abstract-control-parent\": {\n-      \"version\": \"11.0.0-beta\",\n-      \"description\": \"In Angular version 11, the type of `AbstractControl.parent` can be `null` to reflect the runtime value more accurately. This migration automatically adds non-null assertions to existing accesses of the `parent` property on types like `FormControl`, `FormArray` and `FormGroup`.\",\n-      \"factory\": \"./migrations/abstract-control-parent/index\"\n-    },\n-    \"migration-v11-native-view-encapsulation\": {\n-      \"version\": \"11.0.0-beta\",\n-      \"description\": \"ViewEncapsulation.Native has been removed as of Angular version 11. This migration replaces any usages with ViewEncapsulation.ShadowDom.\",\n-      \"factory\": \"./migrations/native-view-encapsulation/index\"\n-    },\n-    \"migration-v11-wait-for-async\": {\n-      \"version\": \"11.0.0-beta\",\n-      \"description\": \"`async` to `waitForAsync` migration. The `async` testing function has been renamed to `waitForAsync` to avoid confusion with the native `async` keyword.\",\n-      \"factory\": \"./migrations/wait-for-async/index\"\n-    },\n-    \"migration-v11-router-preserve-query-params\": {\n-      \"version\": \"11.0.0-beta\",\n-      \"description\": \"NavigationExtras.preserveQueryParams has been removed as of Angular version 11.  This migration replaces any usages with the appropriate assignment of the queryParamsHandling key.\",\n-      \"factory\": \"./migrations/router-preserve-query-params/index\"\n-    },\n-    \"migration-v11-router-initial-navigation-options\": {\n-      \"version\": \"11.0.0-beta\",\n-      \"description\": \"Updates the `initialNavigation` property for `RouterModule.forRoot`.\",\n-      \"factory\": \"./migrations/initial-navigation/index\"\n-    },\n-    \"migration-v11.1-can-activate-with-redirect-to\": {\n-      \"version\": \"11.1.0-beta\",\n-      \"description\": \"Removes `canActivate` from a `Route` config when `redirectTo` is also present\",\n-      \"factory\": \"./migrations/can-activate-with-redirect-to/index\"\n-    },\n-    \"migration-v12-activated-route-snapshot-fragment\": {\n-      \"version\": \"12.0.0-beta\",\n-      \"description\": \"In Angular version 12, the type of ActivatedRouteSnapshot.fragment is nullable. This migration automatically adds non-null assertions to it.\",\n-      \"factory\": \"./migrations/activated-route-snapshot-fragment/index\"\n-    },\n-    \"migration-v12-xhr-factory\": {\n-      \"version\": \"12.0.0-next.6\",\n-      \"description\": \"`XhrFactory` has been moved from `@angular/common/http` to `@angular/common`.\",\n-      \"factory\": \"./migrations/xhr-factory/index\"\n-    },\n-    \"migration-v12-deep-shadow-piercing-selector\": {\n-      \"version\": \"12.0.2\",\n-      \"description\": \"Automatically migrates shadow-piercing selector from `/deep/` to the recommended alternative `::ng-deep`.\",\n-      \"factory\": \"./migrations/deep-shadow-piercing-selector/index\"\n-    },\n     \"migration-v13-router-link-empty-expression\": {\n       \"version\": \"13.0.0-beta\",\n       \"description\": \"Migrates `[routerLink]=\\\"\\\"` in templates to `[routerLink]=\\\"[]\\\"` because these links are likely intended to route to the current page with updated fragment/query params.\","
        },
        {
            "sha": "c78e69f55f13e33bde6639a591cf8f54c742e432",
            "filename": "packages/core/schematics/migrations/abstract-control-parent/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,18 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"abstract-control-parent\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/migrations/google3:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"//packages/core/schematics/utils\",\n-        \"@npm//@angular-devkit/schematics\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "b40ca8deda773cd25352a8d9330a2463bcd840be",
            "filename": "packages/core/schematics/migrations/abstract-control-parent/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 34,
            "changes": 34,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2FREADME.md?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,34 +0,0 @@\n-## `AbstractControl.parent` migration\n-\n-As of Angular v11, the type of `AbstractControl.parent` can be null. This migration automatically\n-identifies usages and adds non-null assertions.\n-\n-#### Before\n-```ts\n-import { Component } from '@angular/core';\n-import { FormControl } from '@angular/forms';\n-\n-@Component()\n-export class MyComponent {\n-  private _control = new FormControl();\n-\n-  getParentValue() {\n-    return this._control.parent.value; // <- Compilation error in v11.\n-  }\n-}\n-```\n-\n-#### After\n-```ts\n-import { Component } from '@angular/core';\n-import { FormControl } from '@angular/forms';\n-\n-@Component()\n-export class MyComponent {\n-  private _control = new FormControl();\n-\n-  getParentValue() {\n-    return this._control.parent!.value; // <- Non-null assertion added during the migration.\n-  }\n-}\n-```"
        },
        {
            "sha": "3291b5b45b03eadb25c543a947b56c9840d456eb",
            "filename": "packages/core/schematics/migrations/abstract-control-parent/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 57,
            "changes": 57,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,57 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\n-import {relative} from 'path';\n-\n-import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n-import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n-import {findParentAccesses} from './util';\n-\n-\n-/** Migration that marks accesses of `AbstractControl.parent` as non-null. */\n-export default function(): Rule {\n-  return async (tree: Tree) => {\n-    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n-    const basePath = process.cwd();\n-    const allPaths = [...buildPaths, ...testPaths];\n-\n-    if (!allPaths.length) {\n-      throw new SchematicsException(\n-          'Could not find any tsconfig file. Cannot migrate AbstractControl.parent accesses.');\n-    }\n-\n-    for (const tsconfigPath of allPaths) {\n-      runNativeAbstractControlParentMigration(tree, tsconfigPath, basePath);\n-    }\n-  };\n-}\n-\n-function runNativeAbstractControlParentMigration(\n-    tree: Tree, tsconfigPath: string, basePath: string) {\n-  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n-  const typeChecker = program.getTypeChecker();\n-  const sourceFiles =\n-      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n-\n-  sourceFiles.forEach(sourceFile => {\n-    // We sort the nodes based on their position in the file and we offset the positions by one\n-    // for each non-null assertion that we've added. We have to do it this way, rather than\n-    // creating and printing a new AST node like in other migrations, because property access\n-    // expressions can be nested (e.g. `control.parent.parent.value`), but the node positions\n-    // aren't being updated as we're inserting new code. If we were to go through the AST,\n-    // we'd have to update the `SourceFile` and start over after each operation.\n-    findParentAccesses(typeChecker, sourceFile)\n-        .sort((a, b) => a.getStart() - b.getStart())\n-        .forEach((node, index) => {\n-          const update = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n-          update.insertRight(node.getStart() + node.getWidth() + index, '!');\n-          tree.commitUpdate(update);\n-        });\n-  });\n-}"
        },
        {
            "sha": "da6965e4e99f9b27d559390a7ea106fc3761439b",
            "filename": "packages/core/schematics/migrations/abstract-control-parent/util.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 57,
            "changes": 57,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fabstract-control-parent%2Futil.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,57 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {normalize} from 'path';\n-import ts from 'typescript';\n-import {isNullCheck, isSafeAccess} from '../../utils/typescript/nodes';\n-import {hasOneOfTypes, isNullableType} from '../../utils/typescript/symbol';\n-\n-/** Names of symbols from `@angular/forms` whose `parent` accesses have to be migrated. */\n-const abstractControlSymbols = ['AbstractControl', 'FormArray', 'FormControl', 'FormGroup'];\n-\n-/**\n- * Finds the `PropertyAccessExpression`-s that are accessing the `parent` property in\n- * such a way that may result in a compilation error after the v11 type changes.\n- */\n-export function findParentAccesses(\n-    typeChecker: ts.TypeChecker, sourceFile: ts.SourceFile): ts.PropertyAccessExpression[] {\n-  const results: ts.PropertyAccessExpression[] = [];\n-\n-  sourceFile.forEachChild(function walk(node: ts.Node) {\n-    if (ts.isPropertyAccessExpression(node) && node.name.text === 'parent' && !isNullCheck(node) &&\n-        !isSafeAccess(node) && results.indexOf(node) === -1 &&\n-        isAbstractControlReference(typeChecker, node) && isNullableType(typeChecker, node)) {\n-      results.unshift(node);\n-    }\n-\n-    node.forEachChild(walk);\n-  });\n-\n-  return results;\n-}\n-\n-/** Checks whether a property access is on an `AbstractControl` coming from `@angular/forms`. */\n-function isAbstractControlReference(\n-    typeChecker: ts.TypeChecker, node: ts.PropertyAccessExpression): boolean {\n-  let current: ts.Expression = node;\n-  const formsPattern = /node_modules\\/?.*\\/@angular\\/forms/;\n-  // Walks up the property access chain and tries to find a symbol tied to a `SourceFile`.\n-  // If such a node is found, we check whether the type is one of the `AbstractControl` symbols\n-  // and whether it comes from the `@angular/forms` directory in the `node_modules`.\n-  while (ts.isPropertyAccessExpression(current)) {\n-    const symbol = typeChecker.getTypeAtLocation(current.expression)?.getSymbol();\n-    if (symbol) {\n-      const sourceFile = symbol.valueDeclaration?.getSourceFile();\n-      return sourceFile != null &&\n-          formsPattern.test(normalize(sourceFile.fileName).replace(/\\\\/g, '/')) &&\n-          hasOneOfTypes(typeChecker, current.expression, abstractControlSymbols);\n-    }\n-    current = current.expression;\n-  }\n-  return false;\n-}"
        },
        {
            "sha": "ff42f9dc839ea1de1c42ec8219d942b5f922d7df",
            "filename": "packages/core/schematics/migrations/activated-route-snapshot-fragment/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,18 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"activated-route-snapshot-fragment\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/migrations/google3:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"//packages/core/schematics/utils\",\n-        \"@npm//@angular-devkit/schematics\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "b7bc129091b4449fbb24fbd2b895e64b9d9a910b",
            "filename": "packages/core/schematics/migrations/activated-route-snapshot-fragment/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 34,
            "changes": 34,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2FREADME.md?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,34 +0,0 @@\n-## `ActivatedRouteSnapshot.fragment` migration\n-\n-The value if `ActivatedRouteSnapshot.fragment` is becoming nullable. This migration adds non-null\n-assertions to it.\n-\n-#### Before\n-```ts\n-import { Component } from '@angular/core';\n-import { ActivatedRouteSnapshot } from '@angular/router';\n-\n-@Component({})\n-export class YourComponent {\n-  private _activatedRouteSnapshot: ActivatedRouteSnapshot;\n-\n-  getFragmentValue() {\n-    return this._activatedRouteSnapshot.fragment.value;\n-  }\n-}\n-```\n-\n-#### After\n-```ts\n-import { Component } from '@angular/core';\n-import { ActivatedRoute } from '@angular/router';\n-\n-@Component({})\n-export class YourComponent {\n-  private _activatedRouteSnapshot: ActivatedRouteSnapshot;\n-\n-  getFragmentValue() {\n-    return this._activatedRouteSnapshot.fragment!.value;\n-  }\n-}\n-```"
        },
        {
            "sha": "0338570dc199e0509da2d5d91b4540514ed9694c",
            "filename": "packages/core/schematics/migrations/activated-route-snapshot-fragment/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 62,
            "changes": 62,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,62 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\n-import {relative} from 'path';\n-import ts from 'typescript';\n-\n-import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n-import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n-import {findFragmentAccesses, migrateActivatedRouteSnapshotFragment} from './util';\n-\n-\n-/**\n- * Migration that marks accesses of `ActivatedRouteSnapshot.fragment` as non-null.\n- */\n-export default function(): Rule {\n-  return async (tree: Tree) => {\n-    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n-    const basePath = process.cwd();\n-    const allPaths = [...buildPaths, ...testPaths];\n-\n-    if (!allPaths.length) {\n-      throw new SchematicsException(\n-          'Could not find any tsconfig file. Cannot migrate ' +\n-          '`ActivatedRouteSnapshot.fragment` accesses.');\n-    }\n-\n-    for (const tsconfigPath of allPaths) {\n-      runActivatedRouteSnapshotFragmentMigration(tree, tsconfigPath, basePath);\n-    }\n-  };\n-}\n-\n-function runActivatedRouteSnapshotFragmentMigration(\n-    tree: Tree, tsconfigPath: string, basePath: string) {\n-  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n-  const typeChecker = program.getTypeChecker();\n-  const sourceFiles =\n-      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n-  const printer = ts.createPrinter();\n-\n-  sourceFiles.forEach(sourceFile => {\n-    const nodesToMigrate = findFragmentAccesses(typeChecker, sourceFile);\n-\n-    if (nodesToMigrate.size > 0) {\n-      const update = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n-      nodesToMigrate.forEach(node => {\n-        update.remove(node.getStart(), node.getWidth());\n-        update.insertRight(\n-            node.getStart(),\n-            printer.printNode(\n-                ts.EmitHint.Unspecified, migrateActivatedRouteSnapshotFragment(node), sourceFile));\n-      });\n-      tree.commitUpdate(update);\n-    }\n-  });\n-}"
        },
        {
            "sha": "aba86d849febc9afdb8eae4412da7f61231f2026",
            "filename": "packages/core/schematics/migrations/activated-route-snapshot-fragment/util.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 39,
            "changes": 39,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Factivated-route-snapshot-fragment%2Futil.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,39 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-import {isNullCheck, isSafeAccess} from '../../utils/typescript/nodes';\n-import {hasOneOfTypes, isNullableType} from '../../utils/typescript/symbol';\n-\n-/**\n- * Finds all the accesses of `ActivatedRouteSnapshot.fragment`\n- * that need to be migrated within a particular file.\n- */\n-export function findFragmentAccesses(\n-    typeChecker: ts.TypeChecker, sourceFile: ts.SourceFile): Set<ts.PropertyAccessExpression> {\n-  const results = new Set<ts.PropertyAccessExpression>();\n-\n-  sourceFile.forEachChild(function walk(node: ts.Node) {\n-    if (ts.isPropertyAccessExpression(node) && node.name.text === 'fragment' &&\n-        !results.has(node) && !isNullCheck(node) && !isSafeAccess(node) &&\n-        hasOneOfTypes(typeChecker, node.expression, ['ActivatedRouteSnapshot']) &&\n-        isNullableType(typeChecker, node)) {\n-      results.add(node);\n-    }\n-\n-    node.forEachChild(walk);\n-  });\n-\n-  return results;\n-}\n-\n-/** Migrates an `ActivatedRouteSnapshot.fragment` access. */\n-export function migrateActivatedRouteSnapshotFragment(node: ts.PropertyAccessExpression): ts.Node {\n-  // Turns `foo.fragment` into `foo.fragment!`.\n-  return ts.createNonNullExpression(node);\n-}"
        },
        {
            "sha": "38990660897a8ad462c729e7737be00b41640a24",
            "filename": "packages/core/schematics/migrations/can-activate-with-redirect-to/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fcan-activate-with-redirect-to%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fcan-activate-with-redirect-to%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fcan-activate-with-redirect-to%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,18 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"can-activate-with-redirect-to\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/migrations/google3:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"//packages/core/schematics/utils\",\n-        \"@npm//@angular-devkit/schematics\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "e640403ec8c0e69a1665aa00ced44a33151bbfb1",
            "filename": "packages/core/schematics/migrations/can-activate-with-redirect-to/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 23,
            "changes": 23,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fcan-activate-with-redirect-to%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fcan-activate-with-redirect-to%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fcan-activate-with-redirect-to%2FREADME.md?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,23 +0,0 @@\n-## Router migration to remove canActivate property from Routes that also have redirectTo\n-\n-The activation stage of the router happens after redirects so any `canActivate` guards\n-will not be executed. This invalid configuration is now an error. This migration \n-removes `canActivate` from the `Route` to fix pre-existing invalid configurations.\n-\n-#### Before\n-```ts\n-import { Routes } from '@angular/router';\n-\n-const routes: Routes = [\n-  {path: '', redirectTo: 'other', canActivate: [MyGuard]}\n-];\n-```\n-\n-#### After\n-```ts\n-import { Routes } from '@angular/router';\n-\n-const routes: Routes = [\n-  {path: '', redirectTo: 'other'}\n-];\n-```"
        },
        {
            "sha": "3b5a564d34dead09ca39f05744cc4c3960694934",
            "filename": "packages/core/schematics/migrations/can-activate-with-redirect-to/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 56,
            "changes": 56,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fcan-activate-with-redirect-to%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fcan-activate-with-redirect-to%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fcan-activate-with-redirect-to%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,56 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\n-import {relative} from 'path';\n-import ts from 'typescript';\n-\n-import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n-import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n-import {findLiteralsToMigrate, migrateLiteral} from './util';\n-\n-\n-/** Migration that removes `canActivate` property from routes that also have `redirectTo`. */\n-export default function(): Rule {\n-  return async (tree: Tree) => {\n-    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n-    const basePath = process.cwd();\n-    const allPaths = [...buildPaths, ...testPaths];\n-\n-    if (!allPaths.length) {\n-      throw new SchematicsException(\n-          'Could not find any tsconfig file. Cannot migrate ' +\n-          'Router.navigateByUrl and Router.createUrlTree calls.');\n-    }\n-\n-    for (const tsconfigPath of allPaths) {\n-      runCanActivateWithRedirectToMigration(tree, tsconfigPath, basePath);\n-    }\n-  };\n-}\n-\n-function runCanActivateWithRedirectToMigration(tree: Tree, tsconfigPath: string, basePath: string) {\n-  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n-  const printer = ts.createPrinter();\n-  const sourceFiles =\n-      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n-\n-  sourceFiles.forEach(sourceFile => {\n-    const literalsToMigrate = findLiteralsToMigrate(sourceFile);\n-    const update = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n-\n-    for (const literal of Array.from(literalsToMigrate)) {\n-      const migratedNode = migrateLiteral(literal);\n-      update.remove(literal.getStart(), literal.getWidth());\n-      update.insertRight(\n-          literal.getStart(), printer.printNode(ts.EmitHint.Unspecified, migratedNode, sourceFile));\n-    }\n-\n-    tree.commitUpdate(update);\n-  });\n-}"
        },
        {
            "sha": "f537f6a5906c1bdb2829e73d28b839c6aded79f8",
            "filename": "packages/core/schematics/migrations/can-activate-with-redirect-to/util.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 62,
            "changes": 62,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fcan-activate-with-redirect-to%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fcan-activate-with-redirect-to%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fcan-activate-with-redirect-to%2Futil.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,62 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-const CAN_ACTIVATE = 'canActivate';\n-const REDIRECT_TO = 'redirectTo';\n-\n-export function migrateLiteral(node: ts.ObjectLiteralExpression): ts.ObjectLiteralExpression {\n-  const propertiesToKeep: ts.ObjectLiteralElementLike[] = [];\n-  node.properties.forEach(property => {\n-    // Only look for regular and shorthand property assignments since resolving things\n-    // like spread operators becomes too complicated for this migration.\n-    if ((ts.isPropertyAssignment(property) || ts.isShorthandPropertyAssignment(property)) &&\n-        (ts.isStringLiteralLike(property.name) || ts.isNumericLiteral(property.name) ||\n-         ts.isIdentifier(property.name))) {\n-      if (property.name.text !== CAN_ACTIVATE) {\n-        propertiesToKeep.push(property);\n-      }\n-    } else {\n-      propertiesToKeep.push(property);\n-    }\n-  });\n-\n-  return ts.createObjectLiteral(propertiesToKeep);\n-}\n-\n-\n-export function findLiteralsToMigrate(sourceFile: ts.SourceFile) {\n-  const results = new Set<ts.ObjectLiteralExpression>();\n-\n-  sourceFile.forEachChild(function visitNode(node: ts.Node) {\n-    if (!ts.isObjectLiteralExpression(node)) {\n-      node.forEachChild(visitNode);\n-      return;\n-    }\n-    if (hasProperty(node, REDIRECT_TO) && hasProperty(node, CAN_ACTIVATE)) {\n-      results.add(node);\n-    }\n-  });\n-\n-  return results;\n-}\n-\n-function hasProperty(node: ts.ObjectLiteralExpression, propertyName: string): boolean {\n-  for (const property of node.properties) {\n-    // Only look for regular and shorthand property assignments since resolving things\n-    // like spread operators becomes too complicated for this migration.\n-    if ((ts.isPropertyAssignment(property) || ts.isShorthandPropertyAssignment(property)) &&\n-        (ts.isStringLiteralLike(property.name) || ts.isNumericLiteral(property.name) ||\n-         ts.isIdentifier(property.name)) &&\n-        property.name.text === propertyName) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}"
        },
        {
            "sha": "00f141fcd4a2aef46c6383cff6f2137ccf3f8940",
            "filename": "packages/core/schematics/migrations/deep-shadow-piercing-selector/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 16,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fdeep-shadow-piercing-selector%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fdeep-shadow-piercing-selector%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fdeep-shadow-piercing-selector%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,16 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"deep-shadow-piercing-selector\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/migrations/google3:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"@npm//@angular-devkit/core\",\n-        \"@npm//@angular-devkit/schematics\",\n-    ],\n-)"
        },
        {
            "sha": "4215e54ec533321da8661f60ae7c0dc75cb6a09b",
            "filename": "packages/core/schematics/migrations/deep-shadow-piercing-selector/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 17,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fdeep-shadow-piercing-selector%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fdeep-shadow-piercing-selector%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fdeep-shadow-piercing-selector%2FREADME.md?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,17 +0,0 @@\n-## shadow-piercing selector `/deep/` to `::ng-deep`\n-\n-Automatically migrates shadow-piercing selector from `/deep/` to `::ng-deep`.\n-\n-#### Before\n-```css\n-:host /deep/ * {\n-  cursor: pointer;\n-}\n-```\n-\n-#### After\n-```css\n-:host ::ng-deep * {\n-  cursor: pointer;\n-}\n-```"
        },
        {
            "sha": "0e84ebbfeffa14637c8477b809fc37219058243b",
            "filename": "packages/core/schematics/migrations/deep-shadow-piercing-selector/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 41,
            "changes": 41,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fdeep-shadow-piercing-selector%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fdeep-shadow-piercing-selector%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fdeep-shadow-piercing-selector%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,41 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {extname, join} from '@angular-devkit/core';\n-import {DirEntry, Rule} from '@angular-devkit/schematics';\n-\n-const VALID_EXTENSIONS = ['.scss', '.sass', '.css', '.styl', '.less', '.ts'];\n-\n-function* visitFiles(directory: DirEntry): IterableIterator<string> {\n-  for (const path of directory.subfiles) {\n-    const extension = extname(path);\n-    if (VALID_EXTENSIONS.includes(extension)) {\n-      yield join(directory.path, path);\n-    }\n-  }\n-\n-  for (const path of directory.subdirs) {\n-    if (path === 'node_modules' || path.startsWith('.') || path === 'dist') {\n-      continue;\n-    }\n-\n-    yield* visitFiles(directory.dir(path));\n-  }\n-}\n-\n-export default function(): Rule {\n-  return (tree) => {\n-    // Visit all files in an Angular workspace monorepo.\n-    for (const file of visitFiles(tree.root)) {\n-      const content = tree.read(file)?.toString();\n-      if (content?.includes('/deep/ ')) {\n-        tree.overwrite(file, content.replace(/\\/deep\\/ /g, '::ng-deep '));\n-      }\n-    }\n-  };\n-}"
        },
        {
            "sha": "686593cb04245c89695e949ce051eaf3e22cc097",
            "filename": "packages/core/schematics/migrations/dynamic-queries/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fdynamic-queries%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fdynamic-queries%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fdynamic-queries%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,18 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"dynamic-queries\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/migrations/google3:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"//packages/core/schematics/utils\",\n-        \"@npm//@angular-devkit/schematics\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "9a469d50932e10c3a03058adc29b479d1c991470",
            "filename": "packages/core/schematics/migrations/dynamic-queries/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 28,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fdynamic-queries%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fdynamic-queries%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fdynamic-queries%2FREADME.md?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,28 +0,0 @@\n-## Dynamic queries migration\n-\n-Automatically migrates dynamic queries to remove their `static` flag. This flag will no\n-longer be necessary in version 9 for dynamic queries, as `false` is the default value.\n-\n-#### Before\n-```ts\n-import { Directive, ViewChild, ContentChild, ElementRef } from '@angular/core';\n-\n-@Directive()\n-export class MyDirective {\n-  @ViewChild('child', { static: false }) child: any;\n-  @ViewChild('secondChild', { read: ElementRef, static: false }) secondChild: ElementRef;\n-  @ContentChild('thirdChild', { static: false }) thirdChild: any;\n-}\n-```\n-\n-#### After\n-```ts\n-import { Directive, ViewChild, ContentChild, ElementRef } from '@angular/core';\n-\n-@Directive()\n-export class MyDirective {\n-  @ViewChild('child') child: any;\n-  @ViewChild('secondChild', { read: ElementRef }) secondChild: ElementRef;\n-  @ContentChild('thirdChild') thirdChild: any;\n-}\n-```"
        },
        {
            "sha": "265e7e9371ec0024ccc1176773d6ff9fd6e12be0",
            "filename": "packages/core/schematics/migrations/dynamic-queries/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 69,
            "changes": 69,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fdynamic-queries%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fdynamic-queries%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fdynamic-queries%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,69 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\n-import {relative} from 'path';\n-import ts from 'typescript';\n-\n-import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n-import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n-\n-import {identifyDynamicQueryNodes, removeOptionsParameter, removeStaticFlag} from './util';\n-\n-\n-/**\n- * Runs the dynamic queries migration for all TypeScript projects in the current CLI workspace.\n- */\n-export default function(): Rule {\n-  return async (tree: Tree) => {\n-    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n-    const basePath = process.cwd();\n-    const allPaths = [...buildPaths, ...testPaths];\n-\n-    if (!allPaths.length) {\n-      throw new SchematicsException(\n-          'Could not find any tsconfig file. Cannot migrate dynamic queries.');\n-    }\n-\n-    for (const tsconfigPath of allPaths) {\n-      runDynamicQueryMigration(tree, tsconfigPath, basePath);\n-    }\n-  };\n-}\n-\n-function runDynamicQueryMigration(tree: Tree, tsconfigPath: string, basePath: string) {\n-  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n-  const typeChecker = program.getTypeChecker();\n-  const sourceFiles =\n-      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n-  const printer = ts.createPrinter();\n-\n-  sourceFiles.forEach(sourceFile => {\n-    const result = identifyDynamicQueryNodes(typeChecker, sourceFile);\n-\n-    if (result.removeProperty.length || result.removeParameter.length) {\n-      const update = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n-\n-      result.removeProperty.forEach(node => {\n-        update.remove(node.getStart(), node.getWidth());\n-        update.insertRight(\n-            node.getStart(),\n-            printer.printNode(ts.EmitHint.Unspecified, removeStaticFlag(node), sourceFile));\n-      });\n-\n-      result.removeParameter.forEach(node => {\n-        update.remove(node.getStart(), node.getWidth());\n-        update.insertRight(\n-            node.getStart(),\n-            printer.printNode(ts.EmitHint.Unspecified, removeOptionsParameter(node), sourceFile));\n-      });\n-\n-      tree.commitUpdate(update);\n-    }\n-  });\n-}"
        },
        {
            "sha": "f5cd7c861ac875b1b5f4ef130d77193957c6cd56",
            "filename": "packages/core/schematics/migrations/dynamic-queries/util.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 77,
            "changes": 77,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fdynamic-queries%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fdynamic-queries%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fdynamic-queries%2Futil.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,77 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-import {getAngularDecorators} from '../../utils/ng_decorators';\n-\n-/**\n- * Identifies the nodes that should be migrated by the dynamic\n- * queries schematic. Splits the nodes into the following categories:\n- * - `removeProperty` - queries from which we should only remove the `static` property of the\n- *  `options` parameter (e.g. `@ViewChild('child', {static: false, read: ElementRef})`).\n- * - `removeParameter` - queries from which we should drop the entire `options` parameter.\n- *  (e.g. `@ViewChild('child', {static: false})`).\n- */\n-export function identifyDynamicQueryNodes(typeChecker: ts.TypeChecker, sourceFile: ts.SourceFile) {\n-  const removeProperty: ts.ObjectLiteralExpression[] = [];\n-  const removeParameter: ts.CallExpression[] = [];\n-\n-  sourceFile.forEachChild(function walk(node: ts.Node) {\n-    if (ts.isClassDeclaration(node)) {\n-      node.members.forEach(member => {\n-        const angularDecorators =\n-            member.decorators && getAngularDecorators(typeChecker, member.decorators);\n-\n-        if (angularDecorators) {\n-          angularDecorators\n-              // Filter out the queries that can have the `static` flag.\n-              .filter(decorator => {\n-                return decorator.name === 'ViewChild' || decorator.name === 'ContentChild';\n-              })\n-              // Filter out the queries where the `static` flag is explicitly set to `false`.\n-              .filter(decorator => {\n-                const options = decorator.node.expression.arguments[1];\n-                return options && ts.isObjectLiteralExpression(options) &&\n-                    options.properties.some(\n-                        property => ts.isPropertyAssignment(property) &&\n-                            property.initializer.kind === ts.SyntaxKind.FalseKeyword);\n-              })\n-              .forEach(decorator => {\n-                const options =\n-                    decorator.node.expression.arguments[1] as ts.ObjectLiteralExpression;\n-\n-                // At this point we know that at least one property is the `static` flag. If this is\n-                // the only property we can drop the entire object literal, otherwise we have to\n-                // drop only the property.\n-                if (options.properties.length === 1) {\n-                  removeParameter.push(decorator.node.expression);\n-                } else {\n-                  removeProperty.push(options);\n-                }\n-              });\n-        }\n-      });\n-    }\n-\n-    node.forEachChild(walk);\n-  });\n-\n-  return {removeProperty, removeParameter};\n-}\n-\n-/** Removes the `options` parameter from the call expression of a query decorator. */\n-export function removeOptionsParameter(node: ts.CallExpression): ts.CallExpression {\n-  return ts.updateCall(node, node.expression, node.typeArguments, [node.arguments[0]]);\n-}\n-\n-/** Removes the `static` property from an object literal expression. */\n-export function removeStaticFlag(node: ts.ObjectLiteralExpression): ts.ObjectLiteralExpression {\n-  return ts.updateObjectLiteral(\n-      node,\n-      node.properties.filter(property => property.name && property.name.getText() !== 'static'));\n-}"
        },
        {
            "sha": "e7a14c4c7fc6b81d677e6c872c349c1fbe165716",
            "filename": "packages/core/schematics/migrations/google3/BUILD.bazel",
            "status": "modified",
            "additions": 0,
            "deletions": 21,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/0b4350c6eff0e146115f8ee56e3d8004b69ac10a/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/0b4350c6eff0e146115f8ee56e3d8004b69ac10a/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FBUILD.bazel?ref=0b4350c6eff0e146115f8ee56e3d8004b69ac10a",
            "patch": "@@ -6,28 +6,7 @@ ts_library(\n     tsconfig = \"//packages/core/schematics:tsconfig.json\",\n     visibility = [\"//packages/core/schematics/test/google3:__pkg__\"],\n     deps = [\n-        \"//packages/compiler\",\n-        \"//packages/compiler-cli/src/ngtsc/annotations\",\n-        \"//packages/compiler-cli/src/ngtsc/imports\",\n-        \"//packages/compiler-cli/src/ngtsc/partial_evaluator\",\n-        \"//packages/compiler-cli/src/ngtsc/reflection\",\n-        \"//packages/core/schematics/migrations/activated-route-snapshot-fragment\",\n-        \"//packages/core/schematics/migrations/can-activate-with-redirect-to\",\n-        \"//packages/core/schematics/migrations/dynamic-queries\",\n-        \"//packages/core/schematics/migrations/initial-navigation\",\n-        \"//packages/core/schematics/migrations/initial-navigation/google3\",\n-        \"//packages/core/schematics/migrations/missing-injectable\",\n-        \"//packages/core/schematics/migrations/missing-injectable/google3\",\n-        \"//packages/core/schematics/migrations/navigation-extras-omissions\",\n-        \"//packages/core/schematics/migrations/relative-link-resolution\",\n-        \"//packages/core/schematics/migrations/relative-link-resolution/google3\",\n-        \"//packages/core/schematics/migrations/renderer-to-renderer2\",\n-        \"//packages/core/schematics/migrations/static-queries\",\n-        \"//packages/core/schematics/migrations/template-var-assignment\",\n         \"//packages/core/schematics/migrations/testbed-teardown\",\n-        \"//packages/core/schematics/migrations/undecorated-classes-with-decorated-fields\",\n-        \"//packages/core/schematics/migrations/undecorated-classes-with-decorated-fields/google3\",\n-        \"//packages/core/schematics/migrations/wait-for-async\",\n         \"//packages/core/schematics/utils\",\n         \"//packages/core/schematics/utils/tslint\",\n         \"@npm//tslint\","
        },
        {
            "sha": "35d67753a9cb18a6106f5775188f76ddd9599510",
            "filename": "packages/core/schematics/migrations/google3/activatedRouteSnapshotFragmentRule.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 40,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FactivatedRouteSnapshotFragmentRule.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FactivatedRouteSnapshotFragmentRule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FactivatedRouteSnapshotFragmentRule.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,40 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Replacement, RuleFailure, Rules} from 'tslint';\n-import ts from 'typescript';\n-\n-import {findFragmentAccesses, migrateActivatedRouteSnapshotFragment} from '../activated-route-snapshot-fragment/util';\n-\n-export class Rule extends Rules.TypedRule {\n-  override applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): RuleFailure[] {\n-    if (sourceFile.isDeclarationFile || program.isSourceFileFromExternalLibrary(sourceFile)) {\n-      return [];\n-    }\n-\n-    const failures: RuleFailure[] = [];\n-    const typeChecker = program.getTypeChecker();\n-    const nodesToMigrate = findFragmentAccesses(typeChecker, sourceFile);\n-\n-    if (nodesToMigrate.size > 0) {\n-      const printer = ts.createPrinter();\n-      nodesToMigrate.forEach(node => {\n-        const sourceFile = node.getSourceFile();\n-        const migratedNode = migrateActivatedRouteSnapshotFragment(node);\n-        const replacement = new Replacement(\n-            node.getStart(), node.getWidth(),\n-            printer.printNode(ts.EmitHint.Unspecified, migratedNode, sourceFile));\n-        failures.push(new RuleFailure(\n-            sourceFile, node.getStart(), node.getEnd(),\n-            '`ActivatedRouteSnapshot.fragment` is nullable.', this.ruleName, replacement));\n-      });\n-    }\n-\n-    return failures;\n-  }\n-}"
        },
        {
            "sha": "b3ada7e001e2b2f7f4ec8da6139322a77def9d56",
            "filename": "packages/core/schematics/migrations/google3/canActivateWithRedirectToRule.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 33,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FcanActivateWithRedirectToRule.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FcanActivateWithRedirectToRule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FcanActivateWithRedirectToRule.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,33 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Replacement, RuleFailure, Rules} from 'tslint';\n-import ts from 'typescript';\n-import {findLiteralsToMigrate, migrateLiteral} from '../can-activate-with-redirect-to/util';\n-\n-\n-/** TSLint rule that removes canActivate from Route configs that also have redirectTo. */\n-export class Rule extends Rules.TypedRule {\n-  override applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): RuleFailure[] {\n-    const failures: RuleFailure[] = [];\n-    const printer = ts.createPrinter();\n-    const literalsToMigrate = findLiteralsToMigrate(sourceFile);\n-\n-    for (const literal of Array.from(literalsToMigrate)) {\n-      const migratedNode = migrateLiteral(literal);\n-      failures.push(new RuleFailure(\n-          sourceFile, literal.getStart(), literal.getEnd(),\n-          'canActivate cannot be used with redirectTo.', this.ruleName,\n-          new Replacement(\n-              literal.getStart(), literal.getWidth(),\n-              printer.printNode(ts.EmitHint.Unspecified, migratedNode, sourceFile))));\n-    }\n-\n-    return failures;\n-  }\n-}"
        },
        {
            "sha": "429697433699e4b3b78e0bb58b2590888484254a",
            "filename": "packages/core/schematics/migrations/google3/dynamicQueriesRule.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 46,
            "changes": 46,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FdynamicQueriesRule.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FdynamicQueriesRule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FdynamicQueriesRule.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,46 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Replacement, RuleFailure, Rules} from 'tslint';\n-import ts from 'typescript';\n-\n-import {identifyDynamicQueryNodes, removeOptionsParameter, removeStaticFlag} from '../dynamic-queries/util';\n-\n-const RULE_NAME = 'dynamic-queries';\n-const FAILURE_MESSAGE =\n-    'The static flag defaults to false, so setting it false manually is unnecessary.';\n-\n-/**\n- * TSLint rule that removes the `static` flag from dynamic queries.\n- */\n-export class Rule extends Rules.TypedRule {\n-  override applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): RuleFailure[] {\n-    const printer = ts.createPrinter();\n-    const failures: RuleFailure[] = [];\n-    const result = identifyDynamicQueryNodes(program.getTypeChecker(), sourceFile);\n-\n-    result.removeProperty.forEach(node => {\n-      failures.push(new RuleFailure(\n-          sourceFile, node.getStart(), node.getEnd(), FAILURE_MESSAGE, RULE_NAME,\n-          new Replacement(\n-              node.getStart(), node.getWidth(),\n-              printer.printNode(ts.EmitHint.Unspecified, removeStaticFlag(node), sourceFile))));\n-    });\n-\n-    result.removeParameter.forEach(node => {\n-      failures.push(new RuleFailure(\n-          sourceFile, node.getStart(), node.getEnd(), FAILURE_MESSAGE, RULE_NAME,\n-          new Replacement(\n-              node.getStart(), node.getWidth(),\n-              printer.printNode(\n-                  ts.EmitHint.Unspecified, removeOptionsParameter(node), sourceFile))));\n-    });\n-\n-    return failures;\n-  }\n-}"
        },
        {
            "sha": "667f929f4542913178bca14384297cb2f70808a2",
            "filename": "packages/core/schematics/migrations/google3/explicitQueryTimingRule.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 86,
            "changes": 86,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FexplicitQueryTimingRule.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FexplicitQueryTimingRule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FexplicitQueryTimingRule.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,86 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as compiler from '@angular/compiler';\n-import {Replacement, RuleFailure, Rules} from 'tslint';\n-import ts from 'typescript';\n-\n-import {NgComponentTemplateVisitor} from '../../utils/ng_component_template';\n-import {NgQueryResolveVisitor} from '../static-queries/angular/ng_query_visitor';\n-import {QueryTiming} from '../static-queries/angular/query-definition';\n-import {QueryUsageStrategy} from '../static-queries/strategies/usage_strategy/usage_strategy';\n-import {getTransformedQueryCallExpr} from '../static-queries/transform';\n-\n-const FAILURE_MESSAGE = 'Query does not explicitly specify its timing. Read more here: ' +\n-    'https://github.com/angular/angular/pull/28810';\n-\n-/**\n- * Rule that reports if an Angular \"ViewChild\" or \"ContentChild\" query is not explicitly\n- * specifying its timing. The rule also provides TSLint automatic replacements that can\n- * be applied in order to automatically migrate to the explicit query timing API.\n- */\n-export class Rule extends Rules.TypedRule {\n-  override applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): RuleFailure[] {\n-    const typeChecker = program.getTypeChecker();\n-    const queryVisitor = new NgQueryResolveVisitor(program.getTypeChecker());\n-    const templateVisitor = new NgComponentTemplateVisitor(typeChecker);\n-    const rootSourceFiles = program.getRootFileNames().map(f => program.getSourceFile(f)!);\n-    const printer = ts.createPrinter();\n-    const failures: RuleFailure[] = [];\n-\n-    // Analyze source files by detecting queries, class relations and component templates.\n-    rootSourceFiles.forEach(sourceFile => {\n-      queryVisitor.visitNode(sourceFile);\n-      templateVisitor.visitNode(sourceFile);\n-    });\n-\n-    const {resolvedQueries, classMetadata} = queryVisitor;\n-\n-    // Add all resolved templates to the class metadata so that we can also\n-    // check component templates for static query usage.\n-    templateVisitor.resolvedTemplates.forEach(template => {\n-      if (classMetadata.has(template.container)) {\n-        classMetadata.get(template.container)!.template = template;\n-      }\n-    });\n-\n-    const queries = resolvedQueries.get(sourceFile);\n-    const usageStrategy = new QueryUsageStrategy(classMetadata, typeChecker, compiler);\n-\n-    // No queries detected for the given source file.\n-    if (!queries) {\n-      return [];\n-    }\n-\n-    // Compute the query usage for all resolved queries and update the\n-    // query definitions to explicitly declare the query timing (static or dynamic)\n-    queries.forEach(q => {\n-      const queryExpr = q.decorator.node.expression;\n-      const {timing, message} = usageStrategy.detectTiming(q);\n-      const result = getTransformedQueryCallExpr(q, timing, !!message);\n-\n-      if (!result) {\n-        return;\n-      }\n-\n-      const newText = printer.printNode(ts.EmitHint.Unspecified, result.node, sourceFile);\n-\n-      // Replace the existing query decorator call expression with the\n-      // updated call expression node.\n-      const fix = new Replacement(queryExpr.getStart(), queryExpr.getWidth(), newText);\n-      const failureMessage = `${FAILURE_MESSAGE}. Based on analysis of the query it can be ` +\n-          `marked as \"{static: ${(timing === QueryTiming.STATIC).toString()}}\".`;\n-\n-      failures.push(new RuleFailure(\n-          sourceFile, queryExpr.getStart(), queryExpr.getEnd(), failureMessage, this.ruleName,\n-          fix));\n-    });\n-\n-    return failures;\n-  }\n-}"
        },
        {
            "sha": "c8186550ede034a625b0867ce3c35865b2d7ecc8",
            "filename": "packages/core/schematics/migrations/google3/initialNavigationRule.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 55,
            "changes": 55,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FinitialNavigationRule.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FinitialNavigationRule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FinitialNavigationRule.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,55 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {RuleFailure, Rules} from 'tslint';\n-import ts from 'typescript';\n-\n-import {InitialNavigationCollector} from '../initial-navigation/collector';\n-import {TslintUpdateRecorder} from '../initial-navigation/google3/tslint_update_recorder';\n-import {InitialNavigationTransform} from '../initial-navigation/transform';\n-\n-\n-\n-/**\n- * TSLint rule that updates RouterModule `forRoot` options to be in line with v10 updates.\n- */\n-export class Rule extends Rules.TypedRule {\n-  override applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): RuleFailure[] {\n-    const ruleName = this.ruleName;\n-    const typeChecker = program.getTypeChecker();\n-    const sourceFiles = program.getSourceFiles().filter(\n-        s => !s.isDeclarationFile && !program.isSourceFileFromExternalLibrary(s));\n-    const initialNavigationCollector = new InitialNavigationCollector(typeChecker);\n-    const failures: RuleFailure[] = [];\n-\n-    // Analyze source files by detecting all ExtraOptions#InitialNavigation assignments\n-    sourceFiles.forEach(sourceFile => initialNavigationCollector.visitNode(sourceFile));\n-\n-    const {assignments} = initialNavigationCollector;\n-    const transformer = new InitialNavigationTransform(getUpdateRecorder);\n-    const updateRecorders = new Map<ts.SourceFile, TslintUpdateRecorder>();\n-\n-    transformer.migrateInitialNavigationAssignments(Array.from(assignments));\n-\n-    if (updateRecorders.has(sourceFile)) {\n-      failures.push(...updateRecorders.get(sourceFile)!.failures);\n-    }\n-\n-    return failures;\n-\n-    /** Gets the update recorder for the specified source file. */\n-    function getUpdateRecorder(sourceFile: ts.SourceFile): TslintUpdateRecorder {\n-      if (updateRecorders.has(sourceFile)) {\n-        return updateRecorders.get(sourceFile)!;\n-      }\n-      const recorder = new TslintUpdateRecorder(ruleName, sourceFile);\n-      updateRecorders.set(sourceFile, recorder);\n-      return recorder;\n-    }\n-  }\n-}"
        },
        {
            "sha": "f95c80ebb0497735e910dbd2abce6b2508b6e4e7",
            "filename": "packages/core/schematics/migrations/google3/navigationExtrasOmissionsRule.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 38,
            "changes": 38,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FnavigationExtrasOmissionsRule.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FnavigationExtrasOmissionsRule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FnavigationExtrasOmissionsRule.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,38 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Replacement, RuleFailure, Rules} from 'tslint';\n-import ts from 'typescript';\n-import {findLiteralsToMigrate, migrateLiteral} from '../../migrations/navigation-extras-omissions/util';\n-\n-\n-/** TSLint rule that migrates `navigateByUrl` and `createUrlTree` calls to an updated signature. */\n-export class Rule extends Rules.TypedRule {\n-  override applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): RuleFailure[] {\n-    const failures: RuleFailure[] = [];\n-    const typeChecker = program.getTypeChecker();\n-    const printer = ts.createPrinter();\n-    const literalsToMigrate = findLiteralsToMigrate(sourceFile, typeChecker);\n-\n-    literalsToMigrate.forEach((instances, methodName) => instances.forEach(instance => {\n-      const migratedNode = migrateLiteral(methodName, instance);\n-\n-      if (migratedNode !== instance) {\n-        failures.push(new RuleFailure(\n-            sourceFile, instance.getStart(), instance.getEnd(),\n-            'Object used in navigateByUrl or createUrlTree call contains unsupported properties.',\n-            this.ruleName,\n-            new Replacement(\n-                instance.getStart(), instance.getWidth(),\n-                printer.printNode(ts.EmitHint.Unspecified, migratedNode, sourceFile))));\n-      }\n-    }));\n-\n-    return failures;\n-  }\n-}"
        },
        {
            "sha": "e1eabb0cac7762cb2808f259a9e73bbb1fc2996f",
            "filename": "packages/core/schematics/migrations/google3/noMissingInjectableRule.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 81,
            "changes": 81,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FnoMissingInjectableRule.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FnoMissingInjectableRule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FnoMissingInjectableRule.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,81 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {forwardRefResolver} from '@angular/compiler-cli/src/ngtsc/annotations';\n-import {Reference} from '@angular/compiler-cli/src/ngtsc/imports';\n-import {DynamicValue, PartialEvaluator} from '@angular/compiler-cli/src/ngtsc/partial_evaluator';\n-import {StaticInterpreter} from '@angular/compiler-cli/src/ngtsc/partial_evaluator/src/interpreter';\n-import {reflectObjectLiteral, TypeScriptReflectionHost} from '@angular/compiler-cli/src/ngtsc/reflection';\n-import {RuleFailure, Rules} from 'tslint';\n-import ts from 'typescript';\n-\n-import {NgDefinitionCollector} from '../missing-injectable/definition_collector';\n-import {TslintUpdateRecorder} from '../missing-injectable/google3/tslint_update_recorder';\n-import {MissingInjectableTransform} from '../missing-injectable/transform';\n-\n-\n-\n-/**\n- * TSLint rule that flags classes which are declared as providers in \"NgModule\",\n- * \"Directive\" or \"Component\" definitions while not being decorated with any\n- * Angular decorator (e.g. \"@Injectable\").\n- */\n-export class Rule extends Rules.TypedRule {\n-  override applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): RuleFailure[] {\n-    const ruleName = this.ruleName;\n-    const typeChecker = program.getTypeChecker();\n-    const sourceFiles = program.getSourceFiles().filter(\n-        s => !s.isDeclarationFile && !program.isSourceFileFromExternalLibrary(s));\n-    const definitionCollector = new NgDefinitionCollector(typeChecker);\n-    const failures: RuleFailure[] = [];\n-\n-    // Analyze source files by detecting all \"NgModule\", \"Directive\" or\n-    // \"Component\" definitions.\n-    sourceFiles.forEach(sourceFile => definitionCollector.visitNode(sourceFile));\n-\n-    const {resolvedModules, resolvedDirectives} = definitionCollector;\n-    const transformer = new MissingInjectableTransform(typeChecker, getUpdateRecorder, {\n-      Reference,\n-      DynamicValue,\n-      PartialEvaluator,\n-      StaticInterpreter,\n-      TypeScriptReflectionHost,\n-      forwardRefResolver,\n-      reflectObjectLiteral,\n-    });\n-    const updateRecorders = new Map<ts.SourceFile, TslintUpdateRecorder>();\n-\n-    [...transformer.migrateModules(resolvedModules),\n-     ...transformer.migrateDirectives(resolvedDirectives),\n-    ].forEach(({message, node}) => {\n-      // Only report failures for the current source file that is visited.\n-      if (node.getSourceFile() === sourceFile) {\n-        failures.push(new RuleFailure(node.getSourceFile(), node.getStart(), 0, message, ruleName));\n-      }\n-    });\n-\n-    // Record the changes collected in the import manager and NgModule manager.\n-    transformer.recordChanges();\n-\n-    if (updateRecorders.has(sourceFile)) {\n-      failures.push(...updateRecorders.get(sourceFile)!.failures);\n-    }\n-\n-    return failures;\n-\n-    /** Gets the update recorder for the specified source file. */\n-    function getUpdateRecorder(sourceFile: ts.SourceFile): TslintUpdateRecorder {\n-      if (updateRecorders.has(sourceFile)) {\n-        return updateRecorders.get(sourceFile)!;\n-      }\n-      const recorder = new TslintUpdateRecorder(ruleName, sourceFile);\n-      updateRecorders.set(sourceFile, recorder);\n-      return recorder;\n-    }\n-  }\n-}"
        },
        {
            "sha": "771bb5d47a27e404683c762bd96d4b219c5dc3a1",
            "filename": "packages/core/schematics/migrations/google3/noTemplateVariableAssignmentRule.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 55,
            "changes": 55,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FnoTemplateVariableAssignmentRule.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FnoTemplateVariableAssignmentRule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FnoTemplateVariableAssignmentRule.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,55 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import * as compiler from '@angular/compiler';\n-import {RuleFailure, Rules} from 'tslint';\n-import ts from 'typescript';\n-\n-import {NgComponentTemplateVisitor} from '../../utils/ng_component_template';\n-import {createHtmlSourceFile} from '../../utils/tslint/tslint_html_source_file';\n-import {analyzeResolvedTemplate} from '../template-var-assignment/analyze_template';\n-\n-const FAILURE_MESSAGE = 'Found assignment to template variable. This does not work with Ivy and ' +\n-    'needs to be updated.';\n-\n-/**\n- * Rule that reports if an Angular template contains property assignments to template variables.\n- */\n-export class Rule extends Rules.TypedRule {\n-  override applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): RuleFailure[] {\n-    const typeChecker = program.getTypeChecker();\n-    const templateVisitor = new NgComponentTemplateVisitor(typeChecker);\n-    const failures: RuleFailure[] = [];\n-\n-    // Analyze the current source files by detecting all referenced HTML templates.\n-    templateVisitor.visitNode(sourceFile);\n-\n-    const {resolvedTemplates} = templateVisitor;\n-\n-    // Analyze each resolved template and print a warning for property writes to\n-    // template variables.\n-    resolvedTemplates.forEach(template => {\n-      const filePath = template.filePath;\n-      const nodes = analyzeResolvedTemplate(template, compiler);\n-      const templateFile =\n-          template.inline ? sourceFile : createHtmlSourceFile(filePath, template.content);\n-\n-      if (!nodes) {\n-        return;\n-      }\n-\n-      nodes.forEach(n => {\n-        failures.push(new RuleFailure(\n-            templateFile, template.start + n.start, template.start + n.end, FAILURE_MESSAGE,\n-            this.ruleName));\n-      });\n-    });\n-\n-    return failures;\n-  }\n-}"
        },
        {
            "sha": "7b21c10dd2d3b24427e79c3bc691cac333460656",
            "filename": "packages/core/schematics/migrations/google3/relativeLinkResolutionDefaultRule.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 48,
            "changes": 48,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FrelativeLinkResolutionDefaultRule.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FrelativeLinkResolutionDefaultRule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FrelativeLinkResolutionDefaultRule.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,48 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {RuleFailure, Rules} from 'tslint';\n-import ts from 'typescript';\n-\n-import {RelativeLinkResolutionCollector} from '../relative-link-resolution/collector';\n-import {TslintUpdateRecorder} from '../relative-link-resolution/google3/tslint_update_recorder';\n-import {RelativeLinkResolutionTransform} from '../relative-link-resolution/transform';\n-\n-export class Rule extends Rules.TypedRule {\n-  override applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): RuleFailure[] {\n-    const typeChecker = program.getTypeChecker();\n-    const ruleName = this.ruleName;\n-    const sourceFiles = program.getSourceFiles().filter(\n-        s => !s.isDeclarationFile && !program.isSourceFileFromExternalLibrary(s));\n-    const updateRecorders = new Map<ts.SourceFile, TslintUpdateRecorder>();\n-    const relativeLinkResolutionCollector = new RelativeLinkResolutionCollector(typeChecker);\n-\n-    // Analyze source files by detecting all modules.\n-    sourceFiles.forEach(sourceFile => relativeLinkResolutionCollector.visitNode(sourceFile));\n-\n-    const {forRootCalls, extraOptionsLiterals} = relativeLinkResolutionCollector;\n-    const transformer = new RelativeLinkResolutionTransform(getUpdateRecorder);\n-    transformer.migrateRouterModuleForRootCalls(forRootCalls);\n-    transformer.migrateObjectLiterals(extraOptionsLiterals);\n-\n-    if (updateRecorders.has(sourceFile)) {\n-      return updateRecorders.get(sourceFile)!.failures;\n-    }\n-    return [];\n-\n-    /** Gets the update recorder for the specified source file. */\n-    function getUpdateRecorder(sourceFile: ts.SourceFile): TslintUpdateRecorder {\n-      if (updateRecorders.has(sourceFile)) {\n-        return updateRecorders.get(sourceFile)!;\n-      }\n-      const recorder = new TslintUpdateRecorder(ruleName, sourceFile);\n-      updateRecorders.set(sourceFile, recorder);\n-      return recorder;\n-    }\n-  }\n-}"
        },
        {
            "sha": "0182257933ac92a21ccece57b241306937ac62d5",
            "filename": "packages/core/schematics/migrations/google3/rendererToRenderer2Rule.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 144,
            "changes": 144,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FrendererToRenderer2Rule.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FrendererToRenderer2Rule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FrendererToRenderer2Rule.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,144 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Replacement, RuleFailure, Rules} from 'tslint';\n-import ts from 'typescript';\n-\n-import {getImportSpecifier, replaceImport} from '../../utils/typescript/imports';\n-import {closestNode} from '../../utils/typescript/nodes';\n-import {getHelper, HelperFunction} from '../renderer-to-renderer2/helpers';\n-import {migrateExpression} from '../renderer-to-renderer2/migration';\n-import {findRendererReferences} from '../renderer-to-renderer2/util';\n-\n-/**\n- * TSLint rule that migrates from `Renderer` to `Renderer2`. More information on how it works:\n- * https://hackmd.angular.io/UTzUZTnPRA-cSa_4mHyfYw\n- */\n-export class Rule extends Rules.TypedRule {\n-  override applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): RuleFailure[] {\n-    const typeChecker = program.getTypeChecker();\n-    const printer = ts.createPrinter();\n-    const failures: RuleFailure[] = [];\n-    const rendererImportSpecifier = getImportSpecifier(sourceFile, '@angular/core', 'Renderer');\n-    const rendererImport = rendererImportSpecifier ?\n-        closestNode<ts.NamedImports>(rendererImportSpecifier, ts.SyntaxKind.NamedImports) :\n-        null;\n-\n-    // If there are no imports for the `Renderer`, we can exit early.\n-    if (!rendererImportSpecifier || !rendererImport) {\n-      return failures;\n-    }\n-\n-    const {typedNodes, methodCalls, forwardRefs} =\n-        findRendererReferences(sourceFile, typeChecker, rendererImportSpecifier);\n-    const helpersToAdd = new Set<HelperFunction>();\n-\n-    failures.push(this._getNamedImportsFailure(rendererImport, sourceFile, printer));\n-    typedNodes.forEach(node => failures.push(this._getTypedNodeFailure(node, sourceFile)));\n-    forwardRefs.forEach(node => failures.push(this._getIdentifierNodeFailure(node, sourceFile)));\n-\n-    methodCalls.forEach(call => {\n-      const {failure, requiredHelpers} =\n-          this._getMethodCallFailure(call, sourceFile, typeChecker, printer);\n-\n-      failures.push(failure);\n-\n-      if (requiredHelpers) {\n-        requiredHelpers.forEach(helperName => helpersToAdd.add(helperName));\n-      }\n-    });\n-\n-    // Some of the methods can't be mapped directly to `Renderer2` and need extra logic around them.\n-    // The safest way to do so is to declare helper functions similar to the ones emitted by TS\n-    // which encapsulate the extra \"glue\" logic. We should only emit these functions once per\n-    // file and only if they're needed.\n-    if (helpersToAdd.size) {\n-      failures.push(this._getHelpersFailure(helpersToAdd, sourceFile, printer));\n-    }\n-\n-    return failures;\n-  }\n-\n-  /** Gets a failure for an import of the Renderer. */\n-  private _getNamedImportsFailure(\n-      node: ts.NamedImports, sourceFile: ts.SourceFile, printer: ts.Printer): RuleFailure {\n-    const replacementText = printer.printNode(\n-        ts.EmitHint.Unspecified, replaceImport(node, 'Renderer', 'Renderer2'), sourceFile);\n-\n-    return new RuleFailure(\n-        sourceFile, node.getStart(), node.getEnd(),\n-        'Imports of deprecated Renderer are not allowed. Please use Renderer2 instead.',\n-        this.ruleName, new Replacement(node.getStart(), node.getWidth(), replacementText));\n-  }\n-\n-  /** Gets a failure for a typed node (e.g. function parameter or property). */\n-  private _getTypedNodeFailure(\n-      node: ts.ParameterDeclaration|ts.PropertyDeclaration|ts.AsExpression,\n-      sourceFile: ts.SourceFile): RuleFailure {\n-    const type = node.type!;\n-\n-    return new RuleFailure(\n-        sourceFile, type.getStart(), type.getEnd(),\n-        'References to deprecated Renderer are not allowed. Please use Renderer2 instead.',\n-        this.ruleName, new Replacement(type.getStart(), type.getWidth(), 'Renderer2'));\n-  }\n-\n-  /** Gets a failure for an identifier node. */\n-  private _getIdentifierNodeFailure(node: ts.Identifier, sourceFile: ts.SourceFile): RuleFailure {\n-    return new RuleFailure(\n-        sourceFile, node.getStart(), node.getEnd(),\n-        'References to deprecated Renderer are not allowed. Please use Renderer2 instead.',\n-        this.ruleName, new Replacement(node.getStart(), node.getWidth(), 'Renderer2'));\n-  }\n-\n-  /** Gets a failure for a Renderer method call. */\n-  private _getMethodCallFailure(\n-      call: ts.CallExpression, sourceFile: ts.SourceFile, typeChecker: ts.TypeChecker,\n-      printer: ts.Printer): {failure: RuleFailure, requiredHelpers?: HelperFunction[]} {\n-    const {node, requiredHelpers} = migrateExpression(call, typeChecker);\n-    let fix: Replacement|undefined;\n-\n-    if (node) {\n-      // If we migrated the node to a new expression, replace only the call expression.\n-      fix = new Replacement(\n-          call.getStart(), call.getWidth(),\n-          printer.printNode(ts.EmitHint.Unspecified, node, sourceFile));\n-    } else if (call.parent && ts.isExpressionStatement(call.parent)) {\n-      // Otherwise if the call is inside an expression statement, drop the entire statement.\n-      // This takes care of any trailing semicolons. We only need to drop nodes for cases like\n-      // `setBindingDebugInfo` which have been noop for a while so they can be removed safely.\n-      fix = new Replacement(call.parent.getStart(), call.parent.getWidth(), '');\n-    }\n-\n-    return {\n-      failure: new RuleFailure(\n-          sourceFile, call.getStart(), call.getEnd(), 'Calls to Renderer methods are not allowed',\n-          this.ruleName, fix),\n-      requiredHelpers\n-    };\n-  }\n-\n-  /** Gets a failure that inserts the required helper functions at the bottom of the file. */\n-  private _getHelpersFailure(\n-      helpersToAdd: Set<HelperFunction>, sourceFile: ts.SourceFile,\n-      printer: ts.Printer): RuleFailure {\n-    const helpers: Replacement[] = [];\n-    const endOfFile = sourceFile.endOfFileToken;\n-\n-    helpersToAdd.forEach(helperName => {\n-      helpers.push(new Replacement(\n-          endOfFile.getStart(), endOfFile.getWidth(), getHelper(helperName, sourceFile, printer)));\n-    });\n-\n-    // Add a failure at the end of the file which we can use as an anchor to insert the helpers.\n-    return new RuleFailure(\n-        sourceFile, endOfFile.getStart(), endOfFile.getStart() + 1,\n-        'File should contain Renderer helper functions. Run tslint with --fix to generate them.',\n-        this.ruleName, helpers);\n-  }\n-}"
        },
        {
            "sha": "99492c0efb76c0e8efd460fd03ce884d4904f86d",
            "filename": "packages/core/schematics/migrations/google3/undecoratedClassesWithDecoratedFieldsRule.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 61,
            "changes": 61,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FundecoratedClassesWithDecoratedFieldsRule.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FundecoratedClassesWithDecoratedFieldsRule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FundecoratedClassesWithDecoratedFieldsRule.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,61 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import {forwardRefResolver} from '@angular/compiler-cli/src/ngtsc/annotations';\n-import {Reference} from '@angular/compiler-cli/src/ngtsc/imports';\n-import {DynamicValue, PartialEvaluator} from '@angular/compiler-cli/src/ngtsc/partial_evaluator';\n-import {StaticInterpreter} from '@angular/compiler-cli/src/ngtsc/partial_evaluator/src/interpreter';\n-import {reflectObjectLiteral, TypeScriptReflectionHost} from '@angular/compiler-cli/src/ngtsc/reflection';\n-import {RuleFailure, Rules} from 'tslint';\n-import ts from 'typescript';\n-import {TslintUpdateRecorder} from '../undecorated-classes-with-decorated-fields/google3/tslint_update_recorder';\n-import {UndecoratedClassesWithDecoratedFieldsTransform} from '../undecorated-classes-with-decorated-fields/transform';\n-\n-/**\n- * TSLint rule that adds an Angular decorator to classes that have Angular field decorators.\n- * https://hackmd.io/vuQfavzfRG6KUCtU7oK_EA\n- */\n-export class Rule extends Rules.TypedRule {\n-  override applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): RuleFailure[] {\n-    const typeChecker = program.getTypeChecker();\n-    const ruleName = this.ruleName;\n-    const sourceFiles = program.getSourceFiles().filter(\n-        s => !s.isDeclarationFile && !program.isSourceFileFromExternalLibrary(s));\n-    const updateRecorders = new Map<ts.SourceFile, TslintUpdateRecorder>();\n-    const transform =\n-        new UndecoratedClassesWithDecoratedFieldsTransform(typeChecker, getUpdateRecorder, {\n-          Reference,\n-          DynamicValue,\n-          PartialEvaluator,\n-          StaticInterpreter,\n-          TypeScriptReflectionHost,\n-          forwardRefResolver,\n-          reflectObjectLiteral,\n-        });\n-\n-    // Migrate all source files in the project.\n-    transform.migrate(sourceFiles);\n-\n-    // Record the changes collected in the import manager.\n-    transform.recordChanges();\n-\n-    if (updateRecorders.has(sourceFile)) {\n-      return updateRecorders.get(sourceFile)!.failures;\n-    }\n-    return [];\n-\n-    /** Gets the update recorder for the specified source file. */\n-    function getUpdateRecorder(sourceFile: ts.SourceFile): TslintUpdateRecorder {\n-      if (updateRecorders.has(sourceFile)) {\n-        return updateRecorders.get(sourceFile)!;\n-      }\n-      const recorder = new TslintUpdateRecorder(ruleName, sourceFile);\n-      updateRecorders.set(sourceFile, recorder);\n-      return recorder;\n-    }\n-  }\n-}"
        },
        {
            "sha": "9379380a0acff8480b6c7224040236febbd048a2",
            "filename": "packages/core/schematics/migrations/google3/waitForAsyncRule.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 65,
            "changes": 65,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FwaitForAsyncRule.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FwaitForAsyncRule.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fgoogle3%2FwaitForAsyncRule.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,65 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Replacement, RuleFailure, Rules} from 'tslint';\n-import ts from 'typescript';\n-\n-import {findAsyncReferences} from '../../migrations/wait-for-async/util';\n-import {getImportSpecifier, replaceImport} from '../../utils/typescript/imports';\n-import {closestNode} from '../../utils/typescript/nodes';\n-\n-/** Name of the deprecated function that we're removing. */\n-const deprecatedFunction = 'async';\n-\n-/** Name of the function that will replace the deprecated one. */\n-const newFunction = 'waitForAsync';\n-\n-/** TSLint rule that migrates from `async` to `waitForAsync`. */\n-export class Rule extends Rules.TypedRule {\n-  override applyWithProgram(sourceFile: ts.SourceFile, program: ts.Program): RuleFailure[] {\n-    const failures: RuleFailure[] = [];\n-    const asyncImportSpecifier =\n-        getImportSpecifier(sourceFile, '@angular/core/testing', deprecatedFunction);\n-    const asyncImport = asyncImportSpecifier ?\n-        closestNode<ts.NamedImports>(asyncImportSpecifier, ts.SyntaxKind.NamedImports) :\n-        null;\n-\n-    // If there are no imports of `async`, we can exit early.\n-    if (asyncImportSpecifier && asyncImport) {\n-      const typeChecker = program.getTypeChecker();\n-      const printer = ts.createPrinter();\n-      failures.push(this._getNamedImportsFailure(asyncImport, sourceFile, printer));\n-      findAsyncReferences(sourceFile, typeChecker, asyncImportSpecifier)\n-          .forEach(node => failures.push(this._getIdentifierNodeFailure(node, sourceFile)));\n-    }\n-\n-    return failures;\n-  }\n-\n-  /** Gets a failure for an import of the `async` function. */\n-  private _getNamedImportsFailure(\n-      node: ts.NamedImports, sourceFile: ts.SourceFile, printer: ts.Printer): RuleFailure {\n-    const replacementText = printer.printNode(\n-        ts.EmitHint.Unspecified, replaceImport(node, deprecatedFunction, newFunction), sourceFile);\n-\n-    return new RuleFailure(\n-        sourceFile, node.getStart(), node.getEnd(),\n-        `Imports of the deprecated ${deprecatedFunction} function are not allowed. Use ${\n-            newFunction} instead.`,\n-        this.ruleName, new Replacement(node.getStart(), node.getWidth(), replacementText));\n-  }\n-\n-  /** Gets a failure for an identifier node. */\n-  private _getIdentifierNodeFailure(node: ts.Identifier, sourceFile: ts.SourceFile): RuleFailure {\n-    return new RuleFailure(\n-        sourceFile, node.getStart(), node.getEnd(),\n-        `References to the deprecated ${deprecatedFunction} function are not allowed. Use ${\n-            newFunction} instead.`,\n-        this.ruleName, new Replacement(node.getStart(), node.getWidth(), newFunction));\n-  }\n-}"
        },
        {
            "sha": "43326967b01ac49e5315a258de812e9251505452",
            "filename": "packages/core/schematics/migrations/initial-navigation/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 19,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,19 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"initial-navigation\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/migrations/google3:__pkg__\",\n-        \"//packages/core/schematics/migrations/initial-navigation/google3:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"//packages/core/schematics/utils\",\n-        \"@npm//@angular-devkit/schematics\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "a279f273c7696fe85ab26425a681f59bdd6d8d17",
            "filename": "packages/core/schematics/migrations/initial-navigation/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 43,
            "changes": 43,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2FREADME.md?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,43 +0,0 @@\n-## initialNavigation migration\n-\n-Automatically migrates the `initialNavigation` property of the `RouterModule` to the newly\n-available options: `enabledNonBlocking` (default), `enabledBlocking`, and `disabled`.\n-\n-#### Before\n-```ts\n-import { NgModule } from '@angular/core';\n-import { RouterModule } from '@angular/router';\n-\n-@NgModule({\n-  imports: [\n-    RouterModule.forRoot(ROUTES, {initialNavigation: 'legacy_disabled'}),\n-  ]\n-})\n-export class AppModule {\n-}\n-```\n-\n-#### After\n-```ts\n-import { NgModule } from '@angular/core';\n-import { RouterModule } from '@angular/router';\n-\n-@NgModule({\n-  imports: [\n-    RouterModule.forRoot(ROUTES, {initialNavigation: 'disabled'}),\n-  ]\n-})\n-export class AppModule {\n-}\n-```\n-\n-### Disclaimer\n-\n-The migration only covers the most common patterns where developers set the `ExtraOptions#InitialNavigation` \n-option to an outdated value. Therefore, if a user declares the option using a number of other methods, \n-e.g. shorthand notation, variable declaration, or some other crafty method, they will have to migrate \n-those options by hand. Otherwise, the compiler will error if the types are sufficiently enforced.\n-\n-The basic migration strategy is as follows:\n-* `legacy_disabled` || `false` => `disabled`\n-* `legacy_enabled` || `true` => `enabledNonBlocking` (new default)\n\\ No newline at end of file"
        },
        {
            "sha": "a1c3d9d6bcb909b6a0000d6cf31afe11e4b94244",
            "filename": "packages/core/schematics/migrations/initial-navigation/collector.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 117,
            "changes": 117,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Fcollector.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Fcollector.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Fcollector.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,117 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import ts from 'typescript';\n-import {isExtraOptions, isRouterModuleForRoot} from './util';\n-\n-\n-/** The property name for the options that need to be migrated */\n-const INITIAL_NAVIGATION = 'initialNavigation';\n-\n-/**\n- * Visitor that walks through specified TypeScript nodes and collects all\n- * found ExtraOptions#InitialNavigation assignments.\n- */\n-export class InitialNavigationCollector {\n-  public assignments: Set<ts.PropertyAssignment> = new Set();\n-\n-  constructor(private readonly typeChecker: ts.TypeChecker) {}\n-\n-  visitNode(node: ts.Node) {\n-    let extraOptionsLiteral: ts.ObjectLiteralExpression|null = null;\n-    if (isRouterModuleForRoot(this.typeChecker, node) && node.arguments.length > 0) {\n-      if (node.arguments.length === 1) {\n-        return;\n-      }\n-\n-      if (ts.isObjectLiteralExpression(node.arguments[1])) {\n-        extraOptionsLiteral = node.arguments[1] as ts.ObjectLiteralExpression;\n-      } else if (ts.isIdentifier(node.arguments[1])) {\n-        extraOptionsLiteral =\n-            this.getLiteralNeedingMigrationFromIdentifier(node.arguments[1] as ts.Identifier);\n-      }\n-    } else if (ts.isVariableDeclaration(node)) {\n-      extraOptionsLiteral = this.getLiteralNeedingMigration(node);\n-    }\n-\n-    if (extraOptionsLiteral !== null) {\n-      this.visitExtraOptionsLiteral(extraOptionsLiteral);\n-    } else {\n-      // no match found, continue iteration\n-      ts.forEachChild(node, n => this.visitNode(n));\n-    }\n-  }\n-\n-  visitExtraOptionsLiteral(extraOptionsLiteral: ts.ObjectLiteralExpression) {\n-    for (const prop of extraOptionsLiteral.properties) {\n-      if (ts.isPropertyAssignment(prop) &&\n-          (ts.isIdentifier(prop.name) || ts.isStringLiteralLike(prop.name))) {\n-        if (prop.name.text === INITIAL_NAVIGATION && isValidInitialNavigationValue(prop)) {\n-          this.assignments.add(prop);\n-        }\n-      } else if (ts.isSpreadAssignment(prop) && ts.isIdentifier(prop.expression)) {\n-        const literalFromSpreadAssignment =\n-            this.getLiteralNeedingMigrationFromIdentifier(prop.expression);\n-        if (literalFromSpreadAssignment !== null) {\n-          this.visitExtraOptionsLiteral(literalFromSpreadAssignment);\n-        }\n-      }\n-    }\n-  }\n-\n-  private getLiteralNeedingMigrationFromIdentifier(id: ts.Identifier): ts.ObjectLiteralExpression\n-      |null {\n-    const symbolForIdentifier = this.typeChecker.getSymbolAtLocation(id);\n-    if (symbolForIdentifier === undefined) {\n-      return null;\n-    }\n-\n-    if (symbolForIdentifier.declarations === undefined ||\n-        symbolForIdentifier.declarations.length === 0) {\n-      return null;\n-    }\n-\n-    const declarationNode = symbolForIdentifier.declarations[0];\n-    if (!ts.isVariableDeclaration(declarationNode) || declarationNode.initializer === undefined ||\n-        !ts.isObjectLiteralExpression(declarationNode.initializer)) {\n-      return null;\n-    }\n-\n-    return declarationNode.initializer;\n-  }\n-\n-  private getLiteralNeedingMigration(node: ts.VariableDeclaration): ts.ObjectLiteralExpression\n-      |null {\n-    if (node.initializer === undefined) {\n-      return null;\n-    }\n-\n-    // declaration could be `x: ExtraOptions = {}` or `x = {} as ExtraOptions`\n-    if (ts.isAsExpression(node.initializer) &&\n-        ts.isObjectLiteralExpression(node.initializer.expression) &&\n-        isExtraOptions(this.typeChecker, node.initializer.type)) {\n-      return node.initializer.expression;\n-    } else if (\n-        node.type !== undefined && ts.isObjectLiteralExpression(node.initializer) &&\n-        isExtraOptions(this.typeChecker, node.type)) {\n-      return node.initializer;\n-    }\n-\n-    return null;\n-  }\n-}\n-\n-/**\n- * Check whether the value assigned to an `initialNavigation` assignment\n- * conforms to the expected types for ExtraOptions#InitialNavigation\n- * @param node the property assignment to check\n- */\n-function isValidInitialNavigationValue(node: ts.PropertyAssignment): boolean {\n-  return ts.isStringLiteralLike(node.initializer) ||\n-      node.initializer.kind === ts.SyntaxKind.FalseKeyword ||\n-      node.initializer.kind === ts.SyntaxKind.TrueKeyword;\n-}"
        },
        {
            "sha": "28baae084ab647b55deab5c55ca8517be2845bdf",
            "filename": "packages/core/schematics/migrations/initial-navigation/google3/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 13,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Fgoogle3%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Fgoogle3%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Fgoogle3%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,13 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"google3\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\"//packages/core/schematics/migrations/google3:__pkg__\"],\n-    deps = [\n-        \"//packages/core/schematics/migrations/initial-navigation\",\n-        \"@npm//tslint\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "c861ff4b39ce65a1e9a15e0f1b458e00c3d6e168",
            "filename": "packages/core/schematics/migrations/initial-navigation/google3/tslint_update_recorder.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 26,
            "changes": 26,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Fgoogle3%2Ftslint_update_recorder.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Fgoogle3%2Ftslint_update_recorder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Fgoogle3%2Ftslint_update_recorder.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,26 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Replacement, RuleFailure} from 'tslint';\n-import ts from 'typescript';\n-\n-import {UpdateRecorder} from '../update_recorder';\n-\n-export class TslintUpdateRecorder implements UpdateRecorder {\n-  failures: RuleFailure[] = [];\n-\n-  constructor(private ruleName: string, private sourceFile: ts.SourceFile) {}\n-\n-  updateNode(node: ts.Node, newText: string): void {\n-    this.failures.push(new RuleFailure(\n-        this.sourceFile, node.getStart(), node.getEnd(), `Node needs to be updated to: ${newText}`,\n-        this.ruleName, Replacement.replaceFromTo(node.getStart(), node.getEnd(), newText)));\n-  }\n-\n-  commitUpdate() {}\n-}"
        },
        {
            "sha": "c31824e3b276fcc1a321ee9a77f090607dbced10",
            "filename": "packages/core/schematics/migrations/initial-navigation/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 73,
            "changes": 73,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,73 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\n-import {relative} from 'path';\n-import ts from 'typescript';\n-import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n-import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n-import {InitialNavigationCollector} from './collector';\n-import {InitialNavigationTransform} from './transform';\n-import {UpdateRecorder} from './update_recorder';\n-\n-/** Entry point for the v10 \"initialNavigation RouterModule options\" schematic. */\n-export default function(): Rule {\n-  return async (tree: Tree) => {\n-    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n-    const basePath = process.cwd();\n-\n-    if (!buildPaths.length && !testPaths.length) {\n-      throw new SchematicsException(\n-          'Could not find any tsconfig file. Cannot update the \"initialNavigation\" option for RouterModule');\n-    }\n-\n-    for (const tsconfigPath of [...buildPaths, ...testPaths]) {\n-      runInitialNavigationMigration(tree, tsconfigPath, basePath);\n-    }\n-  };\n-}\n-\n-function runInitialNavigationMigration(tree: Tree, tsconfigPath: string, basePath: string) {\n-  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n-  const typeChecker = program.getTypeChecker();\n-  const initialNavigationCollector = new InitialNavigationCollector(typeChecker);\n-  const sourceFiles =\n-      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n-\n-  // Analyze source files by detecting all modules.\n-  sourceFiles.forEach(sourceFile => initialNavigationCollector.visitNode(sourceFile));\n-\n-  const {assignments} = initialNavigationCollector;\n-  const transformer = new InitialNavigationTransform(getUpdateRecorder);\n-  const updateRecorders = new Map<ts.SourceFile, UpdateRecorder>();\n-  transformer.migrateInitialNavigationAssignments(Array.from(assignments));\n-\n-  // Walk through each update recorder and commit the update. We need to commit the\n-  // updates in batches per source file as there can be only one recorder per source\n-  // file in order to avoid shift character offsets.\n-  updateRecorders.forEach(recorder => recorder.commitUpdate());\n-\n-  /** Gets the update recorder for the specified source file. */\n-  function getUpdateRecorder(sourceFile: ts.SourceFile): UpdateRecorder {\n-    if (updateRecorders.has(sourceFile)) {\n-      return updateRecorders.get(sourceFile)!;\n-    }\n-    const treeRecorder = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n-    const recorder: UpdateRecorder = {\n-      updateNode(node: ts.Node, newText: string) {\n-        treeRecorder.remove(node.getStart(), node.getWidth());\n-        treeRecorder.insertRight(node.getStart(), newText);\n-      },\n-      commitUpdate() {\n-        tree.commitUpdate(treeRecorder);\n-      }\n-    };\n-    updateRecorders.set(sourceFile, recorder);\n-    return recorder;\n-  }\n-}"
        },
        {
            "sha": "07677fb74ceee67c9153612db761e62d55f7c184",
            "filename": "packages/core/schematics/migrations/initial-navigation/transform.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 62,
            "changes": 62,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Ftransform.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Ftransform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Ftransform.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,62 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import ts from 'typescript';\n-\n-import {UpdateRecorder} from './update_recorder';\n-\n-\n-export class InitialNavigationTransform {\n-  private printer = ts.createPrinter();\n-\n-  constructor(private getUpdateRecorder: (sf: ts.SourceFile) => UpdateRecorder) {}\n-\n-  /** Migrate the ExtraOptions#InitialNavigation property assignments. */\n-  migrateInitialNavigationAssignments(literals: ts.PropertyAssignment[]) {\n-    literals.forEach(l => this.migrateAssignment(l));\n-  }\n-\n-  /** Migrate an ExtraOptions#InitialNavigation expression to use the new options format. */\n-  migrateAssignment(assignment: ts.PropertyAssignment) {\n-    const newInitializer = getUpdatedInitialNavigationValue(assignment.initializer);\n-    if (newInitializer) {\n-      const newAssignment =\n-          ts.updatePropertyAssignment(assignment, assignment.name, newInitializer);\n-      this._updateNode(assignment, newAssignment);\n-    }\n-  }\n-\n-  private _updateNode(node: ts.Node, newNode: ts.Node) {\n-    const newText = this.printer.printNode(ts.EmitHint.Unspecified, newNode, node.getSourceFile());\n-    const recorder = this.getUpdateRecorder(node.getSourceFile());\n-    recorder.updateNode(node, newText);\n-  }\n-}\n-\n-/**\n- * Updates the deprecated initialNavigation options to their v10 equivalents\n- * (or as close as we can get).\n- * @param initializer the old initializer to update\n- */\n-function getUpdatedInitialNavigationValue(initializer: ts.Expression): ts.Expression|null {\n-  const oldText: string|boolean = ts.isStringLiteralLike(initializer) ?\n-      initializer.text :\n-      initializer.kind === ts.SyntaxKind.TrueKeyword;\n-  let newText: string|undefined;\n-  switch (oldText) {\n-    case false:\n-    case 'legacy_disabled':\n-      newText = 'disabled';\n-      break;\n-    case true:\n-    case 'legacy_enabled':\n-      newText = 'enabledNonBlocking';\n-      break;\n-  }\n-\n-  return !!newText ? ts.createIdentifier(`'${newText}'`) : null;\n-}"
        },
        {
            "sha": "6156375460f7daa8f26b6cec554d1f5a02621b2f",
            "filename": "packages/core/schematics/migrations/initial-navigation/update_recorder.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 19,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Fupdate_recorder.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Fupdate_recorder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Fupdate_recorder.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,19 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-/**\n- * Update recorder interface that is used to transform source files in a non-colliding\n- * way. Also this indirection makes it possible to re-use logic for both TSLint rules\n- * and CLI devkit schematic updates.\n- */\n-export interface UpdateRecorder {\n-  updateNode(node: ts.Node, newText: string): void;\n-  commitUpdate(): void;\n-}"
        },
        {
            "sha": "6f8a5a36f02d378917b1173154dbf7c1685e0882",
            "filename": "packages/core/schematics/migrations/initial-navigation/util.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 33,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Finitial-navigation%2Futil.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,33 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-import {getImportOfIdentifier} from '../../utils/typescript/imports';\n-\n-/** Determine whether a node is a ModuleWithProviders type reference node without a generic type */\n-export function isRouterModuleForRoot(\n-    typeChecker: ts.TypeChecker, node: ts.Node): node is ts.CallExpression {\n-  if (!ts.isCallExpression(node) || !ts.isPropertyAccessExpression(node.expression) ||\n-      !ts.isIdentifier(node.expression.expression) || node.expression.name.text !== 'forRoot') {\n-    return false;\n-  }\n-  const imp = getImportOfIdentifier(typeChecker, node.expression.expression);\n-  return !!imp && imp.name === 'RouterModule' && imp.importModule === '@angular/router' &&\n-      !node.typeArguments;\n-}\n-\n-export function isExtraOptions(\n-    typeChecker: ts.TypeChecker, node: ts.Node): node is ts.TypeReferenceNode {\n-  if (!ts.isTypeReferenceNode(node) || !ts.isIdentifier(node.typeName)) {\n-    return false;\n-  }\n-\n-  const imp = getImportOfIdentifier(typeChecker, node.typeName);\n-  return imp !== null && imp.name === 'ExtraOptions' && imp.importModule === '@angular/router' &&\n-      !node.typeArguments;\n-}"
        },
        {
            "sha": "b32c50e92297f9dd387ab3be57358f8827efbdae",
            "filename": "packages/core/schematics/migrations/missing-injectable/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 20,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,20 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"missing-injectable\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/migrations/google3:__pkg__\",\n-        \"//packages/core/schematics/migrations/missing-injectable/google3:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"//packages/compiler-cli/private\",\n-        \"//packages/core/schematics/utils\",\n-        \"@npm//@angular-devkit/schematics\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "dff28076095cfe82e04d20c4422e1310bd44b143",
            "filename": "packages/core/schematics/migrations/missing-injectable/definition_collector.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 104,
            "changes": 104,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Fdefinition_collector.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Fdefinition_collector.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Fdefinition_collector.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,104 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {getAngularDecorators, NgDecorator} from '../../utils/ng_decorators';\n-import {getPropertyNameText} from '../../utils/typescript/property_name';\n-\n-export interface ResolvedNgModule {\n-  name: string;\n-  node: ts.ClassDeclaration;\n-  decorator: NgDecorator;\n-  providersExpr: ts.Expression|null;\n-}\n-\n-export interface ResolvedDirective {\n-  name: string;\n-  node: ts.ClassDeclaration;\n-  decorator: NgDecorator;\n-  providersExpr: ts.Expression|null;\n-  viewProvidersExpr: ts.Expression|null;\n-}\n-\n-/**\n- * Visitor that walks through specified TypeScript nodes and collects all\n- * found NgModule, Directive or Component definitions.\n- */\n-export class NgDefinitionCollector {\n-  resolvedModules: ResolvedNgModule[] = [];\n-  resolvedDirectives: ResolvedDirective[] = [];\n-\n-  constructor(public typeChecker: ts.TypeChecker) {}\n-\n-  visitNode(node: ts.Node) {\n-    if (ts.isClassDeclaration(node)) {\n-      this.visitClassDeclaration(node);\n-    }\n-\n-    ts.forEachChild(node, n => this.visitNode(n));\n-  }\n-\n-  private visitClassDeclaration(node: ts.ClassDeclaration) {\n-    if (!node.decorators || !node.decorators.length) {\n-      return;\n-    }\n-\n-    const ngDecorators = getAngularDecorators(this.typeChecker, node.decorators);\n-    const directiveDecorator =\n-        ngDecorators.find(({name}) => name === 'Component' || name == 'Directive');\n-    const ngModuleDecorator = ngDecorators.find(({name}) => name === 'NgModule');\n-\n-    if (ngModuleDecorator) {\n-      this._visitNgModuleClass(node, ngModuleDecorator);\n-    } else if (directiveDecorator) {\n-      this._visitDirectiveClass(node, directiveDecorator);\n-    }\n-  }\n-\n-  private _visitDirectiveClass(node: ts.ClassDeclaration, decorator: NgDecorator) {\n-    const decoratorCall = decorator.node.expression;\n-    const metadata = decoratorCall.arguments[0];\n-\n-    if (!metadata || !ts.isObjectLiteralExpression(metadata)) {\n-      return;\n-    }\n-\n-    const providersNode = metadata.properties.filter(ts.isPropertyAssignment)\n-                              .find(p => getPropertyNameText(p.name) === 'providers');\n-\n-    const viewProvidersNode = metadata.properties.filter(ts.isPropertyAssignment)\n-                                  .find(p => getPropertyNameText(p.name) === 'viewProviders');\n-\n-    this.resolvedDirectives.push({\n-      name: node.name ? node.name.text : 'default',\n-      node,\n-      decorator,\n-      providersExpr: providersNode !== undefined ? providersNode.initializer : null,\n-      viewProvidersExpr: viewProvidersNode !== undefined ? viewProvidersNode.initializer : null,\n-    });\n-  }\n-\n-  private _visitNgModuleClass(node: ts.ClassDeclaration, decorator: NgDecorator) {\n-    const decoratorCall = decorator.node.expression;\n-    const metadata = decoratorCall.arguments[0];\n-\n-    if (!metadata || !ts.isObjectLiteralExpression(metadata)) {\n-      return;\n-    }\n-\n-    const providersNode = metadata.properties.filter(ts.isPropertyAssignment)\n-                              .find(p => getPropertyNameText(p.name) === 'providers');\n-    this.resolvedModules.push({\n-      name: node.name ? node.name.text : 'default',\n-      node,\n-      decorator,\n-      providersExpr: providersNode !== undefined ? providersNode.initializer : null,\n-    });\n-  }\n-}"
        },
        {
            "sha": "e5e4217f554653239f9b8e5c7d5aa4d2eb49a1c3",
            "filename": "packages/core/schematics/migrations/missing-injectable/google3/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 13,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Fgoogle3%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Fgoogle3%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Fgoogle3%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,13 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"google3\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\"//packages/core/schematics/migrations/google3:__pkg__\"],\n-    deps = [\n-        \"//packages/core/schematics/migrations/missing-injectable\",\n-        \"@npm//tslint\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "4ecdc52023c8d76e171fab5496522cd5237e75dd",
            "filename": "packages/core/schematics/migrations/missing-injectable/google3/tslint_update_recorder.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 67,
            "changes": 67,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Fgoogle3%2Ftslint_update_recorder.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Fgoogle3%2Ftslint_update_recorder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Fgoogle3%2Ftslint_update_recorder.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,67 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Replacement, RuleFailure} from 'tslint';\n-import ts from 'typescript';\n-\n-import {UpdateRecorder} from '../update_recorder';\n-\n-export class TslintUpdateRecorder implements UpdateRecorder {\n-  failures: RuleFailure[] = [];\n-\n-  constructor(private ruleName: string, private sourceFile: ts.SourceFile) {}\n-\n-  addClassDecorator(node: ts.ClassDeclaration, decoratorText: string, className: string) {\n-    // Adding a decorator should be the last replacement. Replacements/rule failures\n-    // are handled in reverse and in case a decorator and import are inserted at\n-    // the start of the file, the class decorator should come after the import.\n-    this.failures.unshift(new RuleFailure(\n-        this.sourceFile, node.getStart(), 0,\n-        `Class needs to be decorated with ` +\n-            `\"${decoratorText}\" because it has been provided by \"${className}\".`,\n-        this.ruleName, Replacement.appendText(node.getStart(), `${decoratorText}\\n`)));\n-  }\n-\n-  addNewImport(start: number, importText: string) {\n-    this.failures.push(new RuleFailure(\n-        this.sourceFile, start, 0, `Source file needs to have import: \"${importText}\"`,\n-        this.ruleName, Replacement.appendText(start, importText)));\n-  }\n-\n-  updateExistingImport(namedBindings: ts.NamedImports, newNamedBindings: string): void {\n-    const fix = [\n-      Replacement.deleteText(namedBindings.getStart(), namedBindings.getWidth()),\n-      Replacement.appendText(namedBindings.getStart(), newNamedBindings),\n-    ];\n-    this.failures.push(new RuleFailure(\n-        this.sourceFile, namedBindings.getStart(), namedBindings.getEnd(),\n-        `Import needs to be updated to import symbols: \"${newNamedBindings}\"`, this.ruleName, fix));\n-  }\n-\n-  replaceDecorator(decorator: ts.Node, newText: string, className: string): void {\n-    const fix = [\n-      Replacement.deleteText(decorator.getStart(), decorator.getWidth()),\n-      Replacement.appendText(decorator.getStart(), newText),\n-    ];\n-    this.failures.push(new RuleFailure(\n-        this.sourceFile, decorator.getStart(), decorator.getEnd(),\n-        `Decorator needs to be replaced with \"${newText}\" because it has been provided ` +\n-            `by \"${className}\"`,\n-        this.ruleName, fix));\n-  }\n-\n-\n-  updateObjectLiteral(node: ts.ObjectLiteralExpression, newText: string): void {\n-    this.failures.push(new RuleFailure(\n-        this.sourceFile, node.getStart(), node.getEnd(),\n-        `Object literal needs to be updated to: ${newText}`, this.ruleName,\n-        Replacement.replaceFromTo(node.getStart(), node.getEnd(), newText)));\n-  }\n-\n-  commitUpdate() {}\n-}"
        },
        {
            "sha": "5052f5ff45473eedc615820f68460616ec60d562",
            "filename": "packages/core/schematics/migrations/missing-injectable/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 134,
            "changes": 134,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,134 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Rule, SchematicContext, SchematicsException, Tree} from '@angular-devkit/schematics';\n-import {relative} from 'path';\n-import ts from 'typescript';\n-\n-import {loadCompilerCliMigrationsModule, loadEsmModule} from '../../utils/load_esm';\n-import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n-import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n-import {NgDefinitionCollector} from './definition_collector';\n-import {MissingInjectableTransform} from './transform';\n-import {UpdateRecorder} from './update_recorder';\n-\n-/** Entry point for the V9 \"missing @Injectable\" schematic. */\n-export default function(): Rule {\n-  return async (tree: Tree, ctx: SchematicContext) => {\n-    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n-    const basePath = process.cwd();\n-    const failures: string[] = [];\n-\n-    if (!buildPaths.length && !testPaths.length) {\n-      throw new SchematicsException(\n-          'Could not find any tsconfig file. Cannot add the \"@Injectable\" decorator to providers ' +\n-          'which don\\'t have that decorator set.');\n-    }\n-\n-    let compilerCliMigrationsModule;\n-    try {\n-      // Load ESM `@angular/compiler/private/migrations` using the TypeScript dynamic import\n-      // workaround. Once TypeScript provides support for keeping the dynamic import this workaround\n-      // can be changed to a direct dynamic import.\n-      compilerCliMigrationsModule = await loadCompilerCliMigrationsModule();\n-    } catch (e) {\n-      throw new SchematicsException(\n-          `Unable to load the '@angular/compiler-cli' package. Details: ${e.message}`);\n-    }\n-\n-    for (const tsconfigPath of [...buildPaths, ...testPaths]) {\n-      failures.push(...runMissingInjectableMigration(\n-          tree, tsconfigPath, basePath, compilerCliMigrationsModule));\n-    }\n-\n-    if (failures.length) {\n-      ctx.logger.info('Could not migrate all providers automatically. Please');\n-      ctx.logger.info('manually migrate the following instances:');\n-      failures.forEach(message => ctx.logger.warn(`   ${message}`));\n-    }\n-  };\n-}\n-\n-function runMissingInjectableMigration(\n-    tree: Tree, tsconfigPath: string, basePath: string,\n-    compilerCliMigrationsModule: typeof import('@angular/compiler-cli/private/migrations')):\n-    string[] {\n-  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n-  const failures: string[] = [];\n-  const typeChecker = program.getTypeChecker();\n-  const definitionCollector = new NgDefinitionCollector(typeChecker);\n-  const sourceFiles =\n-      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n-\n-  // Analyze source files by detecting all modules, directives and components.\n-  sourceFiles.forEach(sourceFile => definitionCollector.visitNode(sourceFile));\n-\n-  const {resolvedModules, resolvedDirectives} = definitionCollector;\n-  const transformer =\n-      new MissingInjectableTransform(typeChecker, getUpdateRecorder, compilerCliMigrationsModule);\n-  const updateRecorders = new Map<ts.SourceFile, UpdateRecorder>();\n-\n-  [...transformer.migrateModules(resolvedModules),\n-   ...transformer.migrateDirectives(resolvedDirectives),\n-  ].forEach(({message, node}) => {\n-    const nodeSourceFile = node.getSourceFile();\n-    const relativeFilePath = relative(basePath, nodeSourceFile.fileName);\n-    const {line, character} =\n-        ts.getLineAndCharacterOfPosition(node.getSourceFile(), node.getStart());\n-    failures.push(`${relativeFilePath}@${line + 1}:${character + 1}: ${message}`);\n-  });\n-\n-  // Record the changes collected in the import manager and transformer.\n-  transformer.recordChanges();\n-\n-  // Walk through each update recorder and commit the update. We need to commit the\n-  // updates in batches per source file as there can be only one recorder per source\n-  // file in order to avoid shift character offsets.\n-  updateRecorders.forEach(recorder => recorder.commitUpdate());\n-\n-  return failures;\n-\n-  /** Gets the update recorder for the specified source file. */\n-  function getUpdateRecorder(sourceFile: ts.SourceFile): UpdateRecorder {\n-    if (updateRecorders.has(sourceFile)) {\n-      return updateRecorders.get(sourceFile)!;\n-    }\n-    const treeRecorder = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n-    const recorder: UpdateRecorder = {\n-      addClassDecorator(node: ts.ClassDeclaration, text: string) {\n-        // New imports should be inserted at the left while decorators should be inserted\n-        // at the right in order to ensure that imports are inserted before the decorator\n-        // if the start position of import and decorator is the source file start.\n-        treeRecorder.insertRight(node.getStart(), `${text}\\n`);\n-      },\n-      replaceDecorator(decorator: ts.Decorator, newText: string) {\n-        treeRecorder.remove(decorator.getStart(), decorator.getWidth());\n-        treeRecorder.insertRight(decorator.getStart(), newText);\n-      },\n-      addNewImport(start: number, importText: string) {\n-        // New imports should be inserted at the left while decorators should be inserted\n-        // at the right in order to ensure that imports are inserted before the decorator\n-        // if the start position of import and decorator is the source file start.\n-        treeRecorder.insertLeft(start, importText);\n-      },\n-      updateExistingImport(namedBindings: ts.NamedImports, newNamedBindings: string) {\n-        treeRecorder.remove(namedBindings.getStart(), namedBindings.getWidth());\n-        treeRecorder.insertRight(namedBindings.getStart(), newNamedBindings);\n-      },\n-      updateObjectLiteral(node: ts.ObjectLiteralExpression, newText: string) {\n-        treeRecorder.remove(node.getStart(), node.getWidth());\n-        treeRecorder.insertRight(node.getStart(), newText);\n-      },\n-      commitUpdate() {\n-        tree.commitUpdate(treeRecorder);\n-      }\n-    };\n-    updateRecorders.set(sourceFile, recorder);\n-    return recorder;\n-  }\n-}"
        },
        {
            "sha": "1d7928454c43ef96b26f47afff8f52577b42a9ec",
            "filename": "packages/core/schematics/migrations/missing-injectable/providers_evaluator.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 74,
            "changes": 74,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Fproviders_evaluator.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Fproviders_evaluator.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Fproviders_evaluator.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,74 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import type {ResolvedValue, TypeScriptReflectionHost} from '@angular/compiler-cli/private/migrations';\n-\n-export interface ProviderLiteral {\n-  node: ts.ObjectLiteralExpression;\n-  resolvedValue: ResolvedValue;\n-}\n-\n-/**\n- * A factory function to create an evaluator for providers. This is required to be a\n- * factory function because the underlying class extends a class that is only available\n- * from within a dynamically imported module (`@angular/compiler-cli/private/migrations`)\n- * and is therefore not available at module evaluation time.\n- */\n-export function createProvidersEvaluator(\n-    compilerCliMigrationsModule: typeof import('@angular/compiler-cli/private/migrations'),\n-    host: TypeScriptReflectionHost, checker: ts.TypeChecker): {\n-  evaluate:\n-      (expr: ts.Expression) => {\n-        resolvedValue: ResolvedValue, literals: ProviderLiteral[]\n-      }\n-} {\n-  /**\n-   * Providers evaluator that extends the ngtsc static interpreter. This is necessary because\n-   * the static interpreter by default only exposes the resolved value, but we are also interested\n-   * in the TypeScript nodes that declare providers. It would be possible to manually traverse the\n-   * AST to collect these nodes, but that would mean that we need to re-implement the static\n-   * interpreter in order to handle all possible scenarios. (e.g. spread operator, function calls,\n-   * callee scope). This can be avoided by simply extending the static interpreter and intercepting\n-   * the \"visitObjectLiteralExpression\" method.\n-   */\n-  class ProvidersEvaluator extends compilerCliMigrationsModule.StaticInterpreter {\n-    private _providerLiterals: ProviderLiteral[] = [];\n-\n-    override visitObjectLiteralExpression(node: ts.ObjectLiteralExpression, context: any) {\n-      const resolvedValue =\n-          super.visitObjectLiteralExpression(node, {...context, insideProviderDef: true});\n-      // do not collect nested object literals. e.g. a provider could use a\n-      // spread assignment (which resolves to another object literal). In that\n-      // case the referenced object literal is not a provider object literal.\n-      if (!context.insideProviderDef) {\n-        this._providerLiterals.push({node, resolvedValue});\n-      }\n-      return resolvedValue;\n-    }\n-\n-    /**\n-     * Evaluates the given expression and returns its statically resolved value\n-     * and a list of object literals which define Angular providers.\n-     */\n-    evaluate(expr: ts.Expression) {\n-      this._providerLiterals = [];\n-      const resolvedValue = this.visit(expr, {\n-        originatingFile: expr.getSourceFile(),\n-        absoluteModuleName: null,\n-        resolutionContext: expr.getSourceFile().fileName,\n-        scope: new Map(),\n-        foreignFunctionResolver: compilerCliMigrationsModule.forwardRefResolver\n-      });\n-      return {resolvedValue, literals: this._providerLiterals};\n-    }\n-  }\n-\n-  return new ProvidersEvaluator(host, checker, /* dependencyTracker */ null);\n-}"
        },
        {
            "sha": "0c996748e3e4c3ceac326645f52830c98951deb4",
            "filename": "packages/core/schematics/migrations/missing-injectable/transform.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 239,
            "changes": 239,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Ftransform.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Ftransform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Ftransform.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,239 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import type {ResolvedValue} from '@angular/compiler-cli/private/migrations';\n-import ts from 'typescript';\n-\n-import {ImportManager} from '../../utils/import_manager';\n-import {getAngularDecorators} from '../../utils/ng_decorators';\n-\n-import {ResolvedDirective, ResolvedNgModule} from './definition_collector';\n-import {createProvidersEvaluator, ProviderLiteral} from './providers_evaluator';\n-import {UpdateRecorder} from './update_recorder';\n-\n-/**\n- * Name of decorators which imply that a given class does not need to be migrated.\n- *    - `@Injectable`, `@Directive`, `@Component` and `@Pipe` instruct the compiler\n- *       to generate a factory definition.\n- *    - `@NgModule` instructs the compiler to generate a provider definition that holds\n- *       the factory function.\n- */\n-const NO_MIGRATE_DECORATORS = ['Injectable', 'Directive', 'Component', 'Pipe', 'NgModule'];\n-\n-export interface AnalysisFailure {\n-  node: ts.Node;\n-  message: string;\n-}\n-\n-export class MissingInjectableTransform {\n-  private printer = ts.createPrinter();\n-  private importManager = new ImportManager(this.getUpdateRecorder, this.printer);\n-  private providersEvaluator;\n-\n-  /** Set of provider class declarations which were already checked or migrated. */\n-  private visitedProviderClasses = new Set<ts.ClassDeclaration>();\n-\n-  /** Set of provider object literals which were already checked or migrated. */\n-  private visitedProviderLiterals = new Set<ts.ObjectLiteralExpression>();\n-\n-  constructor(\n-      private typeChecker: ts.TypeChecker,\n-      private getUpdateRecorder: (sf: ts.SourceFile) => UpdateRecorder,\n-      private compilerCliMigrationsModule:\n-          typeof import('@angular/compiler-cli/private/migrations')) {\n-    this.providersEvaluator = createProvidersEvaluator(\n-        compilerCliMigrationsModule,\n-        new compilerCliMigrationsModule.TypeScriptReflectionHost(typeChecker), typeChecker);\n-  }\n-\n-  recordChanges() {\n-    this.importManager.recordChanges();\n-  }\n-\n-  /**\n-   * Migrates all specified NgModule's by walking through referenced providers\n-   * and decorating them with \"@Injectable\" if needed.\n-   */\n-  migrateModules(modules: ResolvedNgModule[]): AnalysisFailure[] {\n-    return modules.reduce(\n-        (failures, node) => failures.concat(this.migrateModule(node)), [] as AnalysisFailure[]);\n-  }\n-\n-  /**\n-   * Migrates all specified directives by walking through referenced providers\n-   * and decorating them with \"@Injectable\" if needed.\n-   */\n-  migrateDirectives(directives: ResolvedDirective[]): AnalysisFailure[] {\n-    return directives.reduce(\n-        (failures, node) => failures.concat(this.migrateDirective(node)), [] as AnalysisFailure[]);\n-  }\n-\n-  /** Migrates a given NgModule by walking through the referenced providers. */\n-  migrateModule(module: ResolvedNgModule): AnalysisFailure[] {\n-    if (module.providersExpr === null) {\n-      return [];\n-    }\n-\n-    const {resolvedValue, literals} = this.providersEvaluator.evaluate(module.providersExpr);\n-    this._migrateLiteralProviders(literals);\n-\n-    if (!Array.isArray(resolvedValue)) {\n-      return [\n-        {node: module.providersExpr, message: 'Providers of module are not statically analyzable.'}\n-      ];\n-    }\n-\n-    return this._visitProviderResolvedValue(resolvedValue, module);\n-  }\n-\n-\n-  /**\n-   * Migrates a given directive by walking through defined providers. This method\n-   * also handles components with \"viewProviders\" defined.\n-   */\n-  migrateDirective(directive: ResolvedDirective): AnalysisFailure[] {\n-    const failures: AnalysisFailure[] = [];\n-\n-    // Migrate \"providers\" on directives and components if defined.\n-    if (directive.providersExpr) {\n-      const {resolvedValue, literals} = this.providersEvaluator.evaluate(directive.providersExpr);\n-      this._migrateLiteralProviders(literals);\n-      if (!Array.isArray(resolvedValue)) {\n-        return [\n-          {node: directive.providersExpr, message: `Providers are not statically analyzable.`}\n-        ];\n-      }\n-      failures.push(...this._visitProviderResolvedValue(resolvedValue, directive));\n-    }\n-\n-    // Migrate \"viewProviders\" on components if defined.\n-    if (directive.viewProvidersExpr) {\n-      const {resolvedValue, literals} =\n-          this.providersEvaluator.evaluate(directive.viewProvidersExpr);\n-      this._migrateLiteralProviders(literals);\n-      if (!Array.isArray(resolvedValue)) {\n-        return [\n-          {node: directive.viewProvidersExpr, message: `Providers are not statically analyzable.`}\n-        ];\n-      }\n-      failures.push(...this._visitProviderResolvedValue(resolvedValue, directive));\n-    }\n-    return failures;\n-  }\n-\n-  /**\n-   * Migrates a given provider class if it is not decorated with\n-   * any Angular decorator.\n-   */\n-  migrateProviderClass(node: ts.ClassDeclaration, context: ResolvedNgModule|ResolvedDirective) {\n-    if (this.visitedProviderClasses.has(node)) {\n-      return;\n-    }\n-    this.visitedProviderClasses.add(node);\n-\n-    const sourceFile = node.getSourceFile();\n-\n-    // We cannot migrate provider classes outside of source files. This is because the\n-    // migration for third-party library files should happen in \"ngcc\", and in general\n-    // would also involve metadata parsing.\n-    if (sourceFile.isDeclarationFile) {\n-      return;\n-    }\n-\n-    const ngDecorators =\n-        node.decorators ? getAngularDecorators(this.typeChecker, node.decorators) : null;\n-\n-    if (ngDecorators !== null &&\n-        ngDecorators.some(d => NO_MIGRATE_DECORATORS.indexOf(d.name) !== -1)) {\n-      return;\n-    }\n-\n-    const updateRecorder = this.getUpdateRecorder(sourceFile);\n-    const importExpr =\n-        this.importManager.addImportToSourceFile(sourceFile, 'Injectable', '@angular/core');\n-    const newDecoratorExpr = ts.createDecorator(ts.createCall(importExpr, undefined, undefined));\n-    const newDecoratorText =\n-        this.printer.printNode(ts.EmitHint.Unspecified, newDecoratorExpr, sourceFile);\n-\n-\n-    // In case the class is already decorated with \"@Inject(..)\", we replace the \"@Inject\"\n-    // decorator with \"@Injectable()\" since using \"@Inject(..)\" on a class is a noop and\n-    // most likely was meant to be \"@Injectable()\".\n-    const existingInjectDecorator =\n-        ngDecorators !== null ? ngDecorators.find(d => d.name === 'Inject') : null;\n-    if (existingInjectDecorator) {\n-      updateRecorder.replaceDecorator(existingInjectDecorator.node, newDecoratorText, context.name);\n-    } else {\n-      updateRecorder.addClassDecorator(node, newDecoratorText, context.name);\n-    }\n-  }\n-\n-  /**\n-   * Migrates object literal providers which do not use \"useValue\", \"useClass\",\n-   * \"useExisting\" or \"useFactory\". These providers behave differently in Ivy. e.g.\n-   *\n-   * ```ts\n-   *   {provide: X} -> {provide: X, useValue: undefined} // this is how it behaves in VE\n-   *   {provide: X} -> {provide: X, useClass: X} // this is how it behaves in Ivy\n-   * ```\n-   *\n-   * To ensure forward compatibility, we migrate these empty object literal providers\n-   * to explicitly use `useValue: undefined`.\n-   */\n-  private _migrateLiteralProviders(literals: ProviderLiteral[]) {\n-    for (let {node, resolvedValue} of literals) {\n-      if (this.visitedProviderLiterals.has(node)) {\n-        continue;\n-      }\n-      this.visitedProviderLiterals.add(node);\n-\n-      if (!resolvedValue || !(resolvedValue instanceof Map) || !resolvedValue.has('provide') ||\n-          resolvedValue.has('useClass') || resolvedValue.has('useValue') ||\n-          resolvedValue.has('useExisting') || resolvedValue.has('useFactory')) {\n-        continue;\n-      }\n-\n-      const sourceFile = node.getSourceFile();\n-      const newObjectLiteral = ts.updateObjectLiteral(\n-          node,\n-          node.properties.concat(\n-              ts.createPropertyAssignment('useValue', ts.createIdentifier('undefined'))));\n-\n-      this.getUpdateRecorder(sourceFile)\n-          .updateObjectLiteral(\n-              node, this.printer.printNode(ts.EmitHint.Unspecified, newObjectLiteral, sourceFile));\n-    }\n-  }\n-\n-  /**\n-   * Visits the given resolved value of a provider. Providers can be nested in\n-   * arrays and we need to recursively walk through the providers to be able to\n-   * migrate all referenced provider classes. e.g. \"providers: [[A, [B]]]\".\n-   */\n-  private _visitProviderResolvedValue(value: ResolvedValue, module: ResolvedNgModule):\n-      AnalysisFailure[] {\n-    if (value instanceof this.compilerCliMigrationsModule.Reference &&\n-        ts.isClassDeclaration(value.node)) {\n-      this.migrateProviderClass(value.node, module);\n-    } else if (value instanceof Map) {\n-      // If a \"ClassProvider\" has the \"deps\" property set, then we do not need to\n-      // decorate the class. This is because the class is instantiated through the\n-      // specified \"deps\" and the class does not need a factory definition.\n-      if (value.has('provide') && value.has('useClass') && value.get('deps') == null) {\n-        return this._visitProviderResolvedValue(value.get('useClass')!, module);\n-      }\n-    } else if (Array.isArray(value)) {\n-      return value.reduce(\n-          (res, v) => res.concat(this._visitProviderResolvedValue(v, module)),\n-          [] as AnalysisFailure[]);\n-    } else if (value instanceof this.compilerCliMigrationsModule.DynamicValue) {\n-      return [{node: value.node, message: `Provider is not statically analyzable.`}];\n-    }\n-    return [];\n-  }\n-}"
        },
        {
            "sha": "8dbb078902890979ffcbdc7d9a1ceb9a190b34dd",
            "filename": "packages/core/schematics/migrations/missing-injectable/update_recorder.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 22,
            "changes": 22,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Fupdate_recorder.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Fupdate_recorder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fmissing-injectable%2Fupdate_recorder.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,22 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-import {ImportManagerUpdateRecorder} from '../../utils/import_manager';\n-\n-/**\n- * Update recorder interface that is used to transform source files in a non-colliding\n- * way. Also this indirection makes it possible to re-use logic for both TSLint rules\n- * and CLI devkit schematic updates.\n- */\n-export interface UpdateRecorder extends ImportManagerUpdateRecorder {\n-  addClassDecorator(node: ts.ClassDeclaration, text: string, className: string): void;\n-  replaceDecorator(node: ts.Decorator, newText: string, className: string): void;\n-  updateObjectLiteral(node: ts.ObjectLiteralExpression, newText: string): void;\n-  commitUpdate(): void;\n-}"
        },
        {
            "sha": "076e9cb67ddcb82969ba53592994e042ba5c9e9b",
            "filename": "packages/core/schematics/migrations/module-with-providers/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmodule-with-providers%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmodule-with-providers%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fmodule-with-providers%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,18 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"module-with-providers\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"//packages/compiler-cli/private\",\n-        \"//packages/core/schematics/utils\",\n-        \"@npm//@angular-devkit/schematics\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "294700512011b0aad07828fa992ee963871f042e",
            "filename": "packages/core/schematics/migrations/module-with-providers/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 28,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmodule-with-providers%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmodule-with-providers%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fmodule-with-providers%2FREADME.md?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,28 +0,0 @@\n-## ModuleWithProviders migration\n-\n-`ModuleWithProviders` type will not default to the `any` type for its generic in a future version of Angular. \n-This migration adds a generic to any `ModuleWithProvider` types found.\n-\n-#### Before\n-```ts\n-import { NgModule, ModuleWithProviders } from '@angular/core';\n-\n-@NgModule({})\n-export class MyModule {\n-  static forRoot(): ModuleWithProviders {\n-    ngModule: MyModule\n-  }\n-}\n-```\n-\n-#### After\n-```ts\n-import { NgModule, ModuleWithProviders } from '@angular/core';\n-\n-@NgModule({})\n-export class MyModule {\n-  static forRoot(): ModuleWithProviders<MyModule> {\n-    ngModule: MyModule\n-  }\n-}\n-```"
        },
        {
            "sha": "39cc70e5476728cc844e0e96e6d04ac6177ed51d",
            "filename": "packages/core/schematics/migrations/module-with-providers/collector.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 80,
            "changes": 80,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmodule-with-providers%2Fcollector.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmodule-with-providers%2Fcollector.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fmodule-with-providers%2Fcollector.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,80 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {getAngularDecorators, NgDecorator} from '../../utils/ng_decorators';\n-\n-import {isModuleWithProvidersNotGeneric} from './util';\n-\n-export interface ResolvedNgModule {\n-  name: string;\n-  node: ts.ClassDeclaration;\n-  decorator: NgDecorator;\n-  /**\n-   * List of found static method declarations on the module which do not\n-   * declare an explicit return type.\n-   */\n-  staticMethodsWithoutType: ts.MethodDeclaration[];\n-}\n-\n-/**\n- * Visitor that walks through specified TypeScript nodes and collects all\n- * found NgModule static methods without types and all ModuleWithProviders\n- * usages without generic types attached.\n- */\n-export class Collector {\n-  resolvedModules: ResolvedNgModule[] = [];\n-  resolvedNonGenerics: ts.TypeReferenceNode[] = [];\n-\n-  constructor(public typeChecker: ts.TypeChecker) {}\n-\n-  visitNode(node: ts.Node) {\n-    if (ts.isClassDeclaration(node)) {\n-      this.visitClassDeclaration(node);\n-    } else if (isModuleWithProvidersNotGeneric(this.typeChecker, node)) {\n-      this.resolvedNonGenerics.push(node);\n-    }\n-\n-    ts.forEachChild(node, n => this.visitNode(n));\n-  }\n-\n-  private visitClassDeclaration(node: ts.ClassDeclaration) {\n-    if (!node.decorators || !node.decorators.length) {\n-      return;\n-    }\n-\n-    const ngDecorators = getAngularDecorators(this.typeChecker, node.decorators);\n-    const ngModuleDecorator = ngDecorators.find(({name}) => name === 'NgModule');\n-\n-    if (ngModuleDecorator) {\n-      this._visitNgModuleClass(node, ngModuleDecorator);\n-    }\n-  }\n-\n-  private _visitNgModuleClass(node: ts.ClassDeclaration, decorator: NgDecorator) {\n-    const decoratorCall = decorator.node.expression;\n-    const metadata = decoratorCall.arguments[0];\n-\n-    if (!metadata || !ts.isObjectLiteralExpression(metadata)) {\n-      return;\n-    }\n-\n-    this.resolvedModules.push({\n-      name: node.name ? node.name.text : 'default',\n-      node,\n-      decorator,\n-      staticMethodsWithoutType: node.members.filter(isStaticMethodNoType),\n-    });\n-  }\n-}\n-\n-function isStaticMethodNoType(node: ts.ClassElement): node is ts.MethodDeclaration {\n-  return ts.isMethodDeclaration(node) && !!node.modifiers &&\n-      node.modifiers.findIndex(m => m.kind === ts.SyntaxKind.StaticKeyword) > -1 && !node.type;\n-}"
        },
        {
            "sha": "b315211ac426edd4bc4a7edcf3b331761993f30a",
            "filename": "packages/core/schematics/migrations/module-with-providers/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 106,
            "changes": 106,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmodule-with-providers%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmodule-with-providers%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fmodule-with-providers%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,106 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Rule, SchematicContext, SchematicsException, Tree, UpdateRecorder} from '@angular-devkit/schematics';\n-import {relative} from 'path';\n-import ts from 'typescript';\n-\n-import {loadCompilerCliMigrationsModule, loadEsmModule} from '../../utils/load_esm';\n-import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n-import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n-\n-import {Collector} from './collector';\n-import {AnalysisFailure, ModuleWithProvidersTransform} from './transform';\n-\n-\n-/**\n- * Runs the ModuleWithProviders migration for all TypeScript projects in the current CLI workspace.\n- */\n-export default function(): Rule {\n-  return async (tree: Tree, ctx: SchematicContext) => {\n-    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n-    const basePath = process.cwd();\n-    const allPaths = [...buildPaths, ...testPaths];\n-    const failures: string[] = [];\n-\n-    if (!allPaths.length) {\n-      throw new SchematicsException(\n-          'Could not find any tsconfig file. Cannot migrate ModuleWithProviders.');\n-    }\n-\n-    let compilerCliMigrationsModule;\n-    try {\n-      // Load ESM `@angular/compiler/private/migrations` using the TypeScript dynamic import\n-      // workaround. Once TypeScript provides support for keeping the dynamic import this workaround\n-      // can be changed to a direct dynamic import.\n-      compilerCliMigrationsModule = await loadCompilerCliMigrationsModule();\n-    } catch (e) {\n-      throw new SchematicsException(\n-          `Unable to load the '@angular/compiler-cli' package. Details: ${e.message}`);\n-    }\n-\n-    for (const tsconfigPath of allPaths) {\n-      failures.push(...runModuleWithProvidersMigration(\n-          tree, tsconfigPath, basePath, compilerCliMigrationsModule));\n-    }\n-\n-    if (failures.length) {\n-      ctx.logger.info('Could not migrate all instances of ModuleWithProviders');\n-      ctx.logger.info('Please manually fix the following failures:');\n-      failures.forEach(message => ctx.logger.warn(`   ${message}`));\n-    }\n-  };\n-}\n-\n-function runModuleWithProvidersMigration(\n-    tree: Tree, tsconfigPath: string, basePath: string,\n-    compilerCliMigrationsModule: typeof import('@angular/compiler-cli/private/migrations')) {\n-  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n-  const failures: string[] = [];\n-  const typeChecker = program.getTypeChecker();\n-  const collector = new Collector(typeChecker);\n-  const sourceFiles =\n-      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n-\n-  // Analyze source files by detecting all modules.\n-  sourceFiles.forEach(sourceFile => collector.visitNode(sourceFile));\n-\n-  const {resolvedModules, resolvedNonGenerics} = collector;\n-  const transformer =\n-      new ModuleWithProvidersTransform(typeChecker, getUpdateRecorder, compilerCliMigrationsModule);\n-  const updateRecorders = new Map<ts.SourceFile, UpdateRecorder>();\n-\n-  [...resolvedModules.reduce(\n-       (failures, m) => failures.concat(transformer.migrateModule(m)), [] as AnalysisFailure[]),\n-   ...resolvedNonGenerics.reduce(\n-       (failures, t) => failures.concat(transformer.migrateType(t)), [] as AnalysisFailure[])]\n-      .forEach(({message, node}) => {\n-        const nodeSourceFile = node.getSourceFile();\n-        const relativeFilePath = relative(basePath, nodeSourceFile.fileName);\n-        const {line, character} =\n-            ts.getLineAndCharacterOfPosition(node.getSourceFile(), node.getStart());\n-        failures.push(`${relativeFilePath}@${line + 1}:${character + 1}: ${message}`);\n-      });\n-\n-  // Walk through each update recorder and commit the update. We need to commit the\n-  // updates in batches per source file as there can be only one recorder per source\n-  // file in order to avoid shift character offsets.\n-  updateRecorders.forEach(recorder => tree.commitUpdate(recorder));\n-\n-  return failures;\n-\n-  /** Gets the update recorder for the specified source file. */\n-  function getUpdateRecorder(sourceFile: ts.SourceFile): UpdateRecorder {\n-    if (updateRecorders.has(sourceFile)) {\n-      return updateRecorders.get(sourceFile)!;\n-    }\n-    const recorder = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n-    updateRecorders.set(sourceFile, recorder);\n-    return recorder;\n-  }\n-}"
        },
        {
            "sha": "9064cfb530ad086509a36fd566df6df53f8d10f2",
            "filename": "packages/core/schematics/migrations/module-with-providers/transform.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 171,
            "changes": 171,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmodule-with-providers%2Ftransform.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmodule-with-providers%2Ftransform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fmodule-with-providers%2Ftransform.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,171 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {UpdateRecorder} from '@angular-devkit/schematics';\n-import type {ResolvedValue, ResolvedValueMap} from '@angular/compiler-cli/private/migrations';\n-import ts from 'typescript';\n-\n-import {ResolvedNgModule} from './collector';\n-import {createModuleWithProvidersType} from './util';\n-\n-export interface AnalysisFailure {\n-  node: ts.Node;\n-  message: string;\n-}\n-\n-const TODO_COMMENT = 'TODO: The following node requires a generic type for `ModuleWithProviders`';\n-\n-export class ModuleWithProvidersTransform {\n-  private printer = ts.createPrinter();\n-  private partialEvaluator = new this.compilerCliMigrationsModule.PartialEvaluator(\n-      new this.compilerCliMigrationsModule.TypeScriptReflectionHost(this.typeChecker),\n-      this.typeChecker,\n-      /* dependencyTracker */ null);\n-\n-  constructor(\n-      private typeChecker: ts.TypeChecker,\n-      private getUpdateRecorder: (sf: ts.SourceFile) => UpdateRecorder,\n-      private compilerCliMigrationsModule:\n-          typeof import('@angular/compiler-cli/private/migrations')) {}\n-\n-  /** Migrates a given NgModule by walking through the referenced providers and static methods. */\n-  migrateModule(module: ResolvedNgModule): AnalysisFailure[] {\n-    return module.staticMethodsWithoutType.map(this._migrateStaticNgModuleMethod.bind(this))\n-               .filter(v => v) as AnalysisFailure[];\n-  }\n-\n-  /** Migrates a ModuleWithProviders type definition that has no explicit generic type */\n-  migrateType(type: ts.TypeReferenceNode): AnalysisFailure[] {\n-    const parent = type.parent;\n-    let moduleText: string|undefined;\n-    if ((ts.isFunctionDeclaration(parent) || ts.isMethodDeclaration(parent)) && parent.body) {\n-      const returnStatement = parent.body.statements.find(ts.isReturnStatement);\n-\n-      // No return type found, exit\n-      if (!returnStatement || !returnStatement.expression) {\n-        return [{node: parent, message: `Return type is not statically analyzable.`}];\n-      }\n-\n-      moduleText = this._getNgModuleTypeOfExpression(returnStatement.expression);\n-    } else if (ts.isPropertyDeclaration(parent) || ts.isVariableDeclaration(parent)) {\n-      if (!parent.initializer) {\n-        addTodoToNode(type, TODO_COMMENT);\n-        this._updateNode(type, type);\n-        return [{node: parent, message: `Unable to determine type for declaration.`}];\n-      }\n-\n-      moduleText = this._getNgModuleTypeOfExpression(parent.initializer);\n-    }\n-\n-    if (moduleText) {\n-      this._addGenericToTypeReference(type, moduleText);\n-      return [];\n-    }\n-\n-    return [{node: parent, message: `Type is not statically analyzable.`}];\n-  }\n-\n-  /** Add a given generic to a type reference node */\n-  private _addGenericToTypeReference(node: ts.TypeReferenceNode, typeName: string) {\n-    const newGenericExpr = createModuleWithProvidersType(typeName, node);\n-    this._updateNode(node, newGenericExpr);\n-  }\n-\n-  /**\n-   * Migrates a given static method if its ModuleWithProviders does not provide\n-   * a generic type.\n-   */\n-  private _updateStaticMethodType(method: ts.MethodDeclaration, typeName: string) {\n-    const newGenericExpr =\n-        createModuleWithProvidersType(typeName, method.type as ts.TypeReferenceNode);\n-    const newMethodDecl = ts.updateMethod(\n-        method, method.decorators, method.modifiers, method.asteriskToken, method.name,\n-        method.questionToken, method.typeParameters, method.parameters, newGenericExpr,\n-        method.body);\n-\n-    this._updateNode(method, newMethodDecl);\n-  }\n-\n-  /** Whether the resolved value map represents a ModuleWithProviders object */\n-  isModuleWithProvidersType(value: ResolvedValueMap): boolean {\n-    const ngModule = value.get('ngModule') !== undefined;\n-    const providers = value.get('providers') !== undefined;\n-\n-    return ngModule && (value.size === 1 || (providers && value.size === 2));\n-  }\n-\n-  /**\n-   * Determine the generic type of a suspected ModuleWithProviders return type and add it\n-   * explicitly\n-   */\n-  private _migrateStaticNgModuleMethod(node: ts.MethodDeclaration): AnalysisFailure|null {\n-    const returnStatement = node.body &&\n-        node.body.statements.find(n => ts.isReturnStatement(n)) as ts.ReturnStatement | undefined;\n-\n-    // No return type found, exit\n-    if (!returnStatement || !returnStatement.expression) {\n-      return {node: node, message: `Return type is not statically analyzable.`};\n-    }\n-\n-    const moduleText = this._getNgModuleTypeOfExpression(returnStatement.expression);\n-\n-    if (moduleText) {\n-      this._updateStaticMethodType(node, moduleText);\n-      return null;\n-    }\n-\n-    return {node: node, message: `Method type is not statically analyzable.`};\n-  }\n-\n-  /** Evaluate and return the ngModule type from an expression */\n-  private _getNgModuleTypeOfExpression(expr: ts.Expression): string|undefined {\n-    const evaluatedExpr = this.partialEvaluator.evaluate(expr);\n-    return this._getTypeOfResolvedValue(evaluatedExpr);\n-  }\n-\n-  /**\n-   * Visits a given object literal expression to determine the ngModule type. If the expression\n-   * cannot be resolved, add a TODO to alert the user.\n-   */\n-  private _getTypeOfResolvedValue(value: ResolvedValue): string|undefined {\n-    if (value instanceof Map && this.isModuleWithProvidersType(value)) {\n-      const mapValue = value.get('ngModule')!;\n-      if (mapValue instanceof this.compilerCliMigrationsModule.Reference &&\n-          ts.isClassDeclaration(mapValue.node) && mapValue.node.name) {\n-        return mapValue.node.name.text;\n-      } else if (mapValue instanceof this.compilerCliMigrationsModule.DynamicValue) {\n-        addTodoToNode(mapValue.node, TODO_COMMENT);\n-        this._updateNode(mapValue.node, mapValue.node);\n-      }\n-    }\n-\n-    return undefined;\n-  }\n-\n-  private _updateNode(node: ts.Node, newNode: ts.Node) {\n-    const newText = this.printer.printNode(ts.EmitHint.Unspecified, newNode, node.getSourceFile());\n-    const recorder = this.getUpdateRecorder(node.getSourceFile());\n-\n-    recorder.remove(node.getStart(), node.getWidth());\n-    recorder.insertRight(node.getStart(), newText);\n-  }\n-}\n-\n-/**\n- * Adds a to-do to the given TypeScript node which alerts developers to fix\n- * potential issues identified by the migration.\n- */\n-function addTodoToNode(node: ts.Node, text: string) {\n-  ts.setSyntheticLeadingComments(node, [{\n-                                   pos: -1,\n-                                   end: -1,\n-                                   hasTrailingNewLine: false,\n-                                   kind: ts.SyntaxKind.MultiLineCommentTrivia,\n-                                   text: ` ${text} `\n-                                 }]);\n-}"
        },
        {
            "sha": "a76c906bee8642eb29d76cf2880033f1abd3da4f",
            "filename": "packages/core/schematics/migrations/module-with-providers/util.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 31,
            "changes": 31,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmodule-with-providers%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmodule-with-providers%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fmodule-with-providers%2Futil.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,31 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-import {getImportOfIdentifier} from '../../utils/typescript/imports';\n-\n-/** Add a generic type to a type reference. */\n-export function createModuleWithProvidersType(\n-    type: string, node?: ts.TypeReferenceNode): ts.TypeReferenceNode {\n-  const typeNode = node || ts.createTypeReferenceNode('ModuleWithProviders', []);\n-  const typeReferenceNode = ts.createTypeReferenceNode(ts.createIdentifier(type), []);\n-  return ts.updateTypeReferenceNode(\n-      typeNode, typeNode.typeName, ts.createNodeArray([typeReferenceNode]));\n-}\n-\n-/** Determine whether a node is a ModuleWithProviders type reference node without a generic type */\n-export function isModuleWithProvidersNotGeneric(\n-    typeChecker: ts.TypeChecker, node: ts.Node): node is ts.TypeReferenceNode {\n-  if (!ts.isTypeReferenceNode(node) || !ts.isIdentifier(node.typeName)) {\n-    return false;\n-  }\n-\n-  const imp = getImportOfIdentifier(typeChecker, node.typeName);\n-  return !!imp && imp.name === 'ModuleWithProviders' && imp.importModule === '@angular/core' &&\n-      !node.typeArguments;\n-}"
        },
        {
            "sha": "4cf0ffcd360165de88bcce44f36d1347609799c9",
            "filename": "packages/core/schematics/migrations/move-document/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmove-document%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmove-document%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fmove-document%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,18 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"move-document\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/migrations/move-document/google3:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"//packages/core/schematics/utils\",\n-        \"@npm//@angular-devkit/schematics\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "f215bb776cbb55833b37b996a248a79b1e27b11a",
            "filename": "packages/core/schematics/migrations/move-document/document_import_visitor.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 72,
            "changes": 72,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmove-document%2Fdocument_import_visitor.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmove-document%2Fdocument_import_visitor.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fmove-document%2Fdocument_import_visitor.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,72 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-export const COMMON_IMPORT = '@angular/common';\n-export const PLATFORM_BROWSER_IMPORT = '@angular/platform-browser';\n-export const DOCUMENT_TOKEN_NAME = 'DOCUMENT';\n-\n-/** This contains the metadata necessary to move items from one import to another */\n-export interface ResolvedDocumentImport {\n-  platformBrowserImport: ts.NamedImports|null;\n-  commonImport: ts.NamedImports|null;\n-  documentElement: ts.ImportSpecifier|null;\n-}\n-\n-/** Visitor that can be used to find a set of imports in a TypeScript file. */\n-export class DocumentImportVisitor {\n-  importsMap: Map<ts.SourceFile, ResolvedDocumentImport> = new Map();\n-\n-  constructor(public typeChecker: ts.TypeChecker) {}\n-\n-  visitNode(node: ts.Node) {\n-    if (ts.isNamedImports(node)) {\n-      this.visitNamedImport(node);\n-    }\n-\n-    ts.forEachChild(node, node => this.visitNode(node));\n-  }\n-\n-  private visitNamedImport(node: ts.NamedImports) {\n-    if (!node.elements || !node.elements.length) {\n-      return;\n-    }\n-\n-    const importDeclaration = node.parent.parent;\n-    // If this is not a StringLiteral it will be a grammar error\n-    const moduleSpecifier = importDeclaration.moduleSpecifier as ts.StringLiteral;\n-    const sourceFile = node.getSourceFile();\n-    let imports = this.importsMap.get(sourceFile);\n-    if (!imports) {\n-      imports = {\n-        platformBrowserImport: null,\n-        commonImport: null,\n-        documentElement: null,\n-      };\n-    }\n-\n-    if (moduleSpecifier.text === PLATFORM_BROWSER_IMPORT) {\n-      const documentElement = this.getDocumentElement(node);\n-      if (documentElement) {\n-        imports.platformBrowserImport = node;\n-        imports.documentElement = documentElement;\n-      }\n-    } else if (moduleSpecifier.text === COMMON_IMPORT) {\n-      imports.commonImport = node;\n-    } else {\n-      return;\n-    }\n-    this.importsMap.set(sourceFile, imports);\n-  }\n-\n-  private getDocumentElement(node: ts.NamedImports): ts.ImportSpecifier|undefined {\n-    const elements = node.elements;\n-    return elements.find(el => (el.propertyName || el.name).escapedText === DOCUMENT_TOKEN_NAME);\n-  }\n-}"
        },
        {
            "sha": "387d0569a77654e425e8f10a43721e421e2457bd",
            "filename": "packages/core/schematics/migrations/move-document/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 87,
            "changes": 87,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmove-document%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmove-document%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fmove-document%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,87 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\n-import {relative} from 'path';\n-import ts from 'typescript';\n-\n-import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n-import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n-\n-import {COMMON_IMPORT, DOCUMENT_TOKEN_NAME, DocumentImportVisitor, ResolvedDocumentImport} from './document_import_visitor';\n-import {addToImport, createImport, removeFromImport} from './move-import';\n-\n-\n-/** Entry point for the V8 move-document migration. */\n-export default function(): Rule {\n-  return async (tree: Tree) => {\n-    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n-    const basePath = process.cwd();\n-\n-    if (!buildPaths.length && !testPaths.length) {\n-      throw new SchematicsException(`Could not find any tsconfig file. Cannot migrate DOCUMENT\n-          to new import source.`);\n-    }\n-\n-    for (const tsconfigPath of [...buildPaths, ...testPaths]) {\n-      runMoveDocumentMigration(tree, tsconfigPath, basePath);\n-    }\n-  };\n-}\n-\n-/**\n- * Runs the DOCUMENT InjectionToken import migration for the given TypeScript project. The\n- * schematic analyzes the imports within the project and moves the deprecated symbol to the\n- * new import source.\n- */\n-function runMoveDocumentMigration(tree: Tree, tsconfigPath: string, basePath: string) {\n-  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n-  const typeChecker = program.getTypeChecker();\n-  const visitor = new DocumentImportVisitor(typeChecker);\n-  const sourceFiles =\n-      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n-\n-  // Analyze source files by finding imports.\n-  sourceFiles.forEach(sourceFile => visitor.visitNode(sourceFile));\n-\n-  const {importsMap} = visitor;\n-\n-  // Walk through all source files that contain resolved queries and update\n-  // the source files if needed. Note that we need to update multiple queries\n-  // within a source file within the same recorder in order to not throw off\n-  // the TypeScript node offsets.\n-  importsMap.forEach((resolvedImport: ResolvedDocumentImport, sourceFile: ts.SourceFile) => {\n-    const {platformBrowserImport, commonImport, documentElement} = resolvedImport;\n-    if (!documentElement || !platformBrowserImport) {\n-      return;\n-    }\n-    const update = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n-\n-    const platformBrowserDeclaration = platformBrowserImport.parent.parent;\n-    const newPlatformBrowserText =\n-        removeFromImport(platformBrowserImport, sourceFile, DOCUMENT_TOKEN_NAME);\n-    const newCommonText = commonImport ?\n-        addToImport(commonImport, sourceFile, documentElement.name, documentElement.propertyName) :\n-        createImport(COMMON_IMPORT, sourceFile, documentElement.name, documentElement.propertyName);\n-\n-    // Replace the existing query decorator call expression with the updated\n-    // call expression node.\n-    update.remove(platformBrowserDeclaration.getStart(), platformBrowserDeclaration.getWidth());\n-    update.insertRight(platformBrowserDeclaration.getStart(), newPlatformBrowserText);\n-\n-    if (commonImport) {\n-      const commonDeclaration = commonImport.parent.parent;\n-      update.remove(commonDeclaration.getStart(), commonDeclaration.getWidth());\n-      update.insertRight(commonDeclaration.getStart(), newCommonText);\n-    } else {\n-      update.insertRight(platformBrowserDeclaration.getStart(), newCommonText);\n-    }\n-\n-    tree.commitUpdate(update);\n-  });\n-}"
        },
        {
            "sha": "c7ef2610419c59984ad371d024da52a8e0b1ca3b",
            "filename": "packages/core/schematics/migrations/move-document/move-import.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 64,
            "changes": 64,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmove-document%2Fmove-import.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fmove-document%2Fmove-import.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fmove-document%2Fmove-import.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,64 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import ts from 'typescript';\n-\n-export function removeFromImport(\n-    importNode: ts.NamedImports, sourceFile: ts.SourceFile, importName: string): string {\n-  const printer = ts.createPrinter();\n-  const elements = importNode.elements.filter(\n-      el => String((el.propertyName || el.name).escapedText) !== importName);\n-\n-  if (!elements.length) {\n-    return '';\n-  }\n-\n-  const oldDeclaration = importNode.parent.parent;\n-  const newImport = ts.createNamedImports(elements);\n-  const importClause = ts.createImportClause(undefined, newImport);\n-  const newDeclaration = ts.createImportDeclaration(\n-      undefined, undefined, importClause, oldDeclaration.moduleSpecifier);\n-\n-  return printer.printNode(ts.EmitHint.Unspecified, newDeclaration, sourceFile);\n-}\n-\n-export function addToImport(\n-    importNode: ts.NamedImports, sourceFile: ts.SourceFile, name: ts.Identifier,\n-    propertyName?: ts.Identifier): string {\n-  const printer = ts.createPrinter();\n-  const propertyNameIdentifier =\n-      propertyName ? ts.createIdentifier(String(propertyName.escapedText)) : undefined;\n-  const nameIdentifier = ts.createIdentifier(String(name.escapedText));\n-  const newSpecfier = ts.createImportSpecifier(propertyNameIdentifier, nameIdentifier);\n-  const elements = [...importNode.elements];\n-\n-  elements.push(newSpecfier);\n-\n-  const oldDeclaration = importNode.parent.parent;\n-  const newImport = ts.createNamedImports(elements);\n-  const importClause = ts.createImportClause(undefined, newImport);\n-  const newDeclaration = ts.createImportDeclaration(\n-      undefined, undefined, importClause, oldDeclaration.moduleSpecifier);\n-\n-  return printer.printNode(ts.EmitHint.Unspecified, newDeclaration, sourceFile);\n-}\n-\n-export function createImport(\n-    importSource: string, sourceFile: ts.SourceFile, name: ts.Identifier,\n-    propertyName?: ts.Identifier) {\n-  const printer = ts.createPrinter();\n-  const propertyNameIdentifier =\n-      propertyName ? ts.createIdentifier(String(propertyName.escapedText)) : undefined;\n-  const nameIdentifier = ts.createIdentifier(String(name.escapedText));\n-  const newSpecfier = ts.createImportSpecifier(propertyNameIdentifier, nameIdentifier);\n-  const newNamedImports = ts.createNamedImports([newSpecfier]);\n-  const importClause = ts.createImportClause(undefined, newNamedImports);\n-  const moduleSpecifier = ts.createStringLiteral(importSource);\n-  const newImport = ts.createImportDeclaration(undefined, undefined, importClause, moduleSpecifier);\n-\n-  return printer.printNode(ts.EmitHint.Unspecified, newImport, sourceFile);\n-}"
        },
        {
            "sha": "4c08ab63bf66a092936c385ac028bca1d4514d16",
            "filename": "packages/core/schematics/migrations/native-view-encapsulation/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fnative-view-encapsulation%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fnative-view-encapsulation%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fnative-view-encapsulation%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,18 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"native-view-encapsulation\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/migrations/google3:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"//packages/core/schematics/utils\",\n-        \"@npm//@angular-devkit/schematics\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "0a9ab191a05859cc5cff59fbf7bffd9aa42f18fc",
            "filename": "packages/core/schematics/migrations/native-view-encapsulation/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 34,
            "changes": 34,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fnative-view-encapsulation%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fnative-view-encapsulation%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fnative-view-encapsulation%2FREADME.md?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,34 +0,0 @@\n-## `ViewEncapsulation.Native` migration\n-\n-Automatically migrates usages of `ViewEncapsulation.Native` to `ViewEncapsulation.ShadowDom`.\n-For most practical purposes the `Native` mode is compatible with the `ShadowDom` mode.\n-\n-The migration covers any reference to the `Native` value that can be traced to `@angular/core`.\n-Some examples:\n-* Inside the `encapsulation` property of `Component` decorators.\n-* In property assignments for the `COMPILER_OPTIONS` provider.\n-* In variables.\n-\n-#### Before\n-```ts\n-import { Component, ViewEncapsulation } from '@angular/core';\n-\n-@Component({\n-  template: '...',\n-  encapsulation: ViewEncapsulation.Native\n-})\n-export class App {\n-}\n-```\n-\n-#### After\n-```ts\n-import { Component, ViewEncapsulation } from '@angular/core';\n-\n-@Component({\n-  template: '...',\n-  encapsulation: ViewEncapsulation.ShadowDom\n-})\n-export class App {\n-}\n-```"
        },
        {
            "sha": "c0895057986435db2538c2242d367d0bba1ef3ef",
            "filename": "packages/core/schematics/migrations/native-view-encapsulation/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 52,
            "changes": 52,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fnative-view-encapsulation%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fnative-view-encapsulation%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fnative-view-encapsulation%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,52 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\n-import {relative} from 'path';\n-\n-import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n-import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n-import {findNativeEncapsulationNodes} from './util';\n-\n-\n-/** Migration that switches from `ViewEncapsulation.Native` to `ViewEncapsulation.ShadowDom`. */\n-export default function(): Rule {\n-  return async (tree: Tree) => {\n-    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n-    const basePath = process.cwd();\n-    const allPaths = [...buildPaths, ...testPaths];\n-\n-    if (!allPaths.length) {\n-      throw new SchematicsException(\n-          'Could not find any tsconfig file. Cannot migrate away from Native view encapsulation.');\n-    }\n-\n-    for (const tsconfigPath of allPaths) {\n-      runNativeViewEncapsulationMigration(tree, tsconfigPath, basePath);\n-    }\n-  };\n-}\n-\n-function runNativeViewEncapsulationMigration(tree: Tree, tsconfigPath: string, basePath: string) {\n-  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n-  const typeChecker = program.getTypeChecker();\n-  const sourceFiles =\n-      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n-\n-  sourceFiles.forEach(sourceFile => {\n-    const update = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n-    const identifiers = findNativeEncapsulationNodes(typeChecker, sourceFile);\n-\n-    identifiers.forEach(node => {\n-      update.remove(node.getStart(), node.getWidth());\n-      update.insertRight(node.getStart(), 'ShadowDom');\n-    });\n-\n-    tree.commitUpdate(update);\n-  });\n-}"
        },
        {
            "sha": "4d56019d8eec3c016889aeb0d60b4dfb4eec428b",
            "filename": "packages/core/schematics/migrations/native-view-encapsulation/util.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 38,
            "changes": 38,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fnative-view-encapsulation%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fnative-view-encapsulation%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fnative-view-encapsulation%2Futil.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,38 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {getImportOfIdentifier} from '../../utils/typescript/imports';\n-\n-/** Finds all the Identifier nodes in a file that refer to `Native` view encapsulation. */\n-export function findNativeEncapsulationNodes(\n-    typeChecker: ts.TypeChecker, sourceFile: ts.SourceFile): Set<ts.Identifier> {\n-  const results = new Set<ts.Identifier>();\n-\n-  sourceFile.forEachChild(function walkNode(node: ts.Node) {\n-    // Note that we look directly for nodes in the form of `<something>.Native`, rather than going\n-    // for `Component` class decorators, because it's much simpler and it allows us to handle cases\n-    // where `ViewEncapsulation.Native` might be used in a different context (e.g. a variable).\n-    // Using the encapsulation outside of a decorator is an edge case, but we do have public APIs\n-    // where it can be passed in (see the `defaultViewEncapsulation` property on the\n-    // `COMPILER_OPTIONS` provider).\n-    if (ts.isPropertyAccessExpression(node) && ts.isIdentifier(node.name) &&\n-        node.name.text === 'Native' && ts.isIdentifier(node.expression)) {\n-      const expressionImport = getImportOfIdentifier(typeChecker, node.expression);\n-      if (expressionImport && expressionImport.name === 'ViewEncapsulation' &&\n-          expressionImport.importModule === '@angular/core') {\n-        results.add(node.name);\n-      }\n-    } else {\n-      node.forEachChild(walkNode);\n-    }\n-  });\n-\n-  return results;\n-}"
        },
        {
            "sha": "dc793c9702303ccdce9e99a33912fb6c9cb5c71d",
            "filename": "packages/core/schematics/migrations/navigation-extras-omissions/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,18 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"navigation-extras-omissions\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/migrations/google3:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"//packages/core/schematics/utils\",\n-        \"@npm//@angular-devkit/schematics\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "e8236f03adc1a0a3552c4e7a4b0c735f0cb4adb1",
            "filename": "packages/core/schematics/migrations/navigation-extras-omissions/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 35,
            "changes": 35,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2FREADME.md?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,35 +0,0 @@\n-## Router.navigateByUrl and Router.createUrlTree extras migration\n-\n-Previously the `extras` parameter of `Router.navigateByUrl` and `Router.createUrlTree` accepted the\n-full `NavigationExtras` object, even though only a subset of properties was supported. This\n-migration removes the unsupported properties from the relevant method call sites.\n-\n-#### Before\n-```ts\n-import { Component } from '@angular/core';\n-import { Router } from '@angular/router';\n-\n-@Component({})\n-export class MyComponent {\n-  constructor(private _router: Router) {}\n-\n-  goHome() {\n-    this._router.navigateByUrl('/', {skipLocationChange: false, fragment: 'foo'});\n-  }\n-}\n-```\n-\n-#### After\n-```ts\n-import { Component } from '@angular/core';\n-import { Router } from '@angular/router';\n-\n-@Component({})\n-export class MyComponent {\n-  constructor(private _router: Router) {}\n-\n-  goHome() {\n-    this._router.navigateByUrl('/', { /* Removed unsupported properties by Angular migration: fragment. */ skipLocationChange: false });\n-  }\n-}\n-```"
        },
        {
            "sha": "fe7eb998b7bae72a35f691b5feb7a06a57a57287",
            "filename": "packages/core/schematics/migrations/navigation-extras-omissions/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 61,
            "changes": 61,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,61 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\n-import {relative} from 'path';\n-import ts from 'typescript';\n-\n-import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n-import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n-import {findLiteralsToMigrate, migrateLiteral} from './util';\n-\n-\n-/** Migration that switches `Router.navigateByUrl` and `Router.createUrlTree` to a new signature. */\n-export default function(): Rule {\n-  return async (tree: Tree) => {\n-    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n-    const basePath = process.cwd();\n-    const allPaths = [...buildPaths, ...testPaths];\n-\n-    if (!allPaths.length) {\n-      throw new SchematicsException(\n-          'Could not find any tsconfig file. Cannot migrate ' +\n-          'Router.navigateByUrl and Router.createUrlTree calls.');\n-    }\n-\n-    for (const tsconfigPath of allPaths) {\n-      runNavigationExtrasOmissionsMigration(tree, tsconfigPath, basePath);\n-    }\n-  };\n-}\n-\n-function runNavigationExtrasOmissionsMigration(tree: Tree, tsconfigPath: string, basePath: string) {\n-  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n-  const typeChecker = program.getTypeChecker();\n-  const printer = ts.createPrinter();\n-  const sourceFiles =\n-      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n-\n-  sourceFiles.forEach(sourceFile => {\n-    const literalsToMigrate = findLiteralsToMigrate(sourceFile, typeChecker);\n-    const update = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n-\n-    literalsToMigrate.forEach((instances, methodName) => instances.forEach(instance => {\n-      const migratedNode = migrateLiteral(methodName, instance);\n-\n-      if (migratedNode !== instance) {\n-        update.remove(instance.getStart(), instance.getWidth());\n-        update.insertRight(\n-            instance.getStart(),\n-            printer.printNode(ts.EmitHint.Unspecified, migratedNode, sourceFile));\n-      }\n-    }));\n-\n-    tree.commitUpdate(update);\n-  });\n-}"
        },
        {
            "sha": "f6858a211637e8a28d6f8c2172af1093ed65369b",
            "filename": "packages/core/schematics/migrations/navigation-extras-omissions/util.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 125,
            "changes": 125,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fnavigation-extras-omissions%2Futil.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,125 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {getImportSpecifier} from '../../utils/typescript/imports';\n-import {isReferenceToImport} from '../../utils/typescript/symbol';\n-\n-/**\n- * Configures the methods that the migration should be looking for\n- * and the properties from `NavigationExtras` that should be preserved.\n- */\n-const methodConfig = new Map<string, Set<string>>([\n-  ['navigateByUrl', new Set<string>(['skipLocationChange', 'replaceUrl', 'state'])],\n-  [\n-    'createUrlTree', new Set<string>([\n-      'relativeTo', 'queryParams', 'fragment', 'preserveQueryParams', 'queryParamsHandling',\n-      'preserveFragment'\n-    ])\n-  ]\n-]);\n-\n-export function migrateLiteral(\n-    methodName: string, node: ts.ObjectLiteralExpression): ts.ObjectLiteralExpression {\n-  const allowedProperties = methodConfig.get(methodName);\n-\n-  if (!allowedProperties) {\n-    throw Error(`Attempting to migrate unconfigured method called ${methodName}.`);\n-  }\n-\n-  const propertiesToKeep: ts.ObjectLiteralElementLike[] = [];\n-  const removedPropertyNames: string[] = [];\n-\n-  node.properties.forEach(property => {\n-    // Only look for regular and shorthand property assignments since resolving things\n-    // like spread operators becomes too complicated for this migration.\n-    if ((ts.isPropertyAssignment(property) || ts.isShorthandPropertyAssignment(property)) &&\n-        (ts.isStringLiteralLike(property.name) || ts.isNumericLiteral(property.name) ||\n-         ts.isIdentifier(property.name))) {\n-      if (allowedProperties.has(property.name.text)) {\n-        propertiesToKeep.push(property);\n-      } else {\n-        removedPropertyNames.push(property.name.text);\n-      }\n-    } else {\n-      propertiesToKeep.push(property);\n-    }\n-  });\n-\n-  // Don't modify the node if there's nothing to remove.\n-  if (removedPropertyNames.length === 0) {\n-    return node;\n-  }\n-\n-  // Note that the trailing/leading spaces are necessary so the comment looks good.\n-  const removalComment =\n-      ` Removed unsupported properties by Angular migration: ${removedPropertyNames.join(', ')}. `;\n-\n-  if (propertiesToKeep.length > 0) {\n-    propertiesToKeep[0] = addUniqueLeadingComment(propertiesToKeep[0], removalComment);\n-    return ts.createObjectLiteral(propertiesToKeep);\n-  } else {\n-    return addUniqueLeadingComment(ts.createObjectLiteral(propertiesToKeep), removalComment);\n-  }\n-}\n-\n-export function findLiteralsToMigrate(sourceFile: ts.SourceFile, typeChecker: ts.TypeChecker) {\n-  const results = new Map<string, Set<ts.ObjectLiteralExpression>>(\n-      Array.from(methodConfig.keys(), key => [key, new Set()]));\n-  const routerImport = getImportSpecifier(sourceFile, '@angular/router', 'Router');\n-  const seenLiterals = new Map<ts.ObjectLiteralExpression, string>();\n-\n-  if (routerImport) {\n-    sourceFile.forEachChild(function visitNode(node: ts.Node) {\n-      // Look for calls that look like `foo.<method to migrate>` with more than one parameter.\n-      if (ts.isCallExpression(node) && node.arguments.length > 1 &&\n-          ts.isPropertyAccessExpression(node.expression) && ts.isIdentifier(node.expression.name) &&\n-          methodConfig.has(node.expression.name.text)) {\n-        // Check whether the type of the object on which the\n-        // function is called refers to the Router import.\n-        if (isReferenceToImport(typeChecker, node.expression.expression, routerImport)) {\n-          const methodName = node.expression.name.text;\n-          const parameterDeclaration =\n-              typeChecker.getTypeAtLocation(node.arguments[1]).getSymbol()?.valueDeclaration;\n-\n-          // Find the source of the object literal.\n-          if (parameterDeclaration && ts.isObjectLiteralExpression(parameterDeclaration)) {\n-            if (!seenLiterals.has(parameterDeclaration)) {\n-              results.get(methodName)!.add(parameterDeclaration);\n-              seenLiterals.set(parameterDeclaration, methodName);\n-              // If the same literal has been passed into multiple different methods, we can't\n-              // migrate it, because the supported properties are different. When we detect such\n-              // a case, we drop it from the results so that it gets ignored. If it's used multiple\n-              // times for the same method, it can still be migrated.\n-            } else if (seenLiterals.get(parameterDeclaration) !== methodName) {\n-              results.forEach(literals => literals.delete(parameterDeclaration));\n-            }\n-          }\n-        }\n-      } else {\n-        node.forEachChild(visitNode);\n-      }\n-    });\n-  }\n-\n-  return results;\n-}\n-\n-/** Adds a leading comment to a node, if the node doesn't have such a comment already. */\n-function addUniqueLeadingComment<T extends ts.Node>(node: T, comment: string): T {\n-  const existingComments = ts.getSyntheticLeadingComments(node);\n-\n-  // This logic is primarily to ensure that we don't add the same comment multiple\n-  // times when tslint runs over the same file again with outdated information.\n-  if (!existingComments || existingComments.every(c => c.text !== comment)) {\n-    return ts.addSyntheticLeadingComment(node, ts.SyntaxKind.MultiLineCommentTrivia, comment);\n-  }\n-\n-  return node;\n-}"
        },
        {
            "sha": "b233da5b30afa0f28a0aec2f108c5f0f1e07f3cc",
            "filename": "packages/core/schematics/migrations/relative-link-resolution/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 20,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,20 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"relative-link-resolution\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/migrations/google3:__pkg__\",\n-        \"//packages/core/schematics/migrations/relative-link-resolution/google3:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"//packages/compiler-cli\",\n-        \"//packages/core/schematics/utils\",\n-        \"@npm//@angular-devkit/schematics\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "3d99628992e7aad25c4e83a38ab6b31cb3862e7c",
            "filename": "packages/core/schematics/migrations/relative-link-resolution/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 33,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2FREADME.md?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,33 +0,0 @@\n-## relativeLinkResolution migration\n-\n-The default value for `relativeLinkResolution` is changing from 'legacy' to 'corrected'.\n-This migration updates `RouterModule` configurations that use the default value to \n-now specifically use 'legacy' to prevent breakages when updating.\n-\n-#### Before\n-```ts\n-import { NgModule } from '@angular/core';\n-import { RouterModule } from '@angular/router';\n-\n-@NgModule({\n-  imports: [\n-    RouterModule.forRoot(ROUTES),\n-  ]\n-})\n-export class AppModule {\n-}\n-```\n-\n-#### After\n-```ts\n-import { NgModule } from '@angular/core';\n-import { RouterModule } from '@angular/router';\n-\n-@NgModule({\n-  imports: [\n-    RouterModule.forRoot(ROUTES, {relativeLinkResolution: 'legacy'}),\n-  ]\n-})\n-export class AppModule {\n-}\n-```\n\\ No newline at end of file"
        },
        {
            "sha": "a47976ff67c9aa952d0719aa863c5fdc06b8954b",
            "filename": "packages/core/schematics/migrations/relative-link-resolution/collector.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 88,
            "changes": 88,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Fcollector.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Fcollector.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Fcollector.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,88 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import ts from 'typescript';\n-\n-import {isExtraOptions, isRouterModuleForRoot} from './util';\n-\n-\n-/**\n- * Visitor that walks through specified TypeScript nodes and collects all\n- * found ExtraOptions#RelativeLinkResolution assignments.\n- */\n-export class RelativeLinkResolutionCollector {\n-  readonly forRootCalls: ts.CallExpression[] = [];\n-  readonly extraOptionsLiterals: ts.ObjectLiteralExpression[] = [];\n-\n-  constructor(private readonly typeChecker: ts.TypeChecker) {}\n-\n-  visitNode(node: ts.Node) {\n-    let forRootCall: ts.CallExpression|null = null;\n-    let literal: ts.ObjectLiteralExpression|null = null;\n-    if (isRouterModuleForRoot(this.typeChecker, node) && node.arguments.length > 0) {\n-      if (node.arguments.length === 1) {\n-        forRootCall = node;\n-      } else if (ts.isObjectLiteralExpression(node.arguments[1])) {\n-        literal = node.arguments[1] as ts.ObjectLiteralExpression;\n-      } else if (ts.isIdentifier(node.arguments[1])) {\n-        literal = this.getLiteralNeedingMigrationFromIdentifier(node.arguments[1] as ts.Identifier);\n-      }\n-    } else if (ts.isVariableDeclaration(node)) {\n-      literal = this.getLiteralNeedingMigration(node);\n-    }\n-\n-    if (literal !== null) {\n-      this.extraOptionsLiterals.push(literal);\n-    } else if (forRootCall !== null) {\n-      this.forRootCalls.push(forRootCall);\n-    } else {\n-      // no match found, continue iteration\n-      ts.forEachChild(node, n => this.visitNode(n));\n-    }\n-  }\n-\n-  private getLiteralNeedingMigrationFromIdentifier(id: ts.Identifier): ts.ObjectLiteralExpression\n-      |null {\n-    const symbolForIdentifier = this.typeChecker.getSymbolAtLocation(id);\n-    if (symbolForIdentifier === undefined) {\n-      return null;\n-    }\n-\n-    if (symbolForIdentifier.declarations === undefined ||\n-        symbolForIdentifier.declarations.length === 0) {\n-      return null;\n-    }\n-\n-    const declarationNode = symbolForIdentifier.declarations[0];\n-    if (!ts.isVariableDeclaration(declarationNode) || declarationNode.initializer === undefined ||\n-        !ts.isObjectLiteralExpression(declarationNode.initializer)) {\n-      return null;\n-    }\n-\n-    return declarationNode.initializer;\n-  }\n-\n-  private getLiteralNeedingMigration(node: ts.VariableDeclaration): ts.ObjectLiteralExpression\n-      |null {\n-    if (node.initializer === undefined) {\n-      return null;\n-    }\n-\n-    // declaration could be `x: ExtraOptions = {}` or `x = {} as ExtraOptions`\n-    if (ts.isAsExpression(node.initializer) &&\n-        ts.isObjectLiteralExpression(node.initializer.expression) &&\n-        isExtraOptions(this.typeChecker, node.initializer.type)) {\n-      return node.initializer.expression;\n-    } else if (\n-        node.type !== undefined && ts.isObjectLiteralExpression(node.initializer) &&\n-        isExtraOptions(this.typeChecker, node.type)) {\n-      return node.initializer;\n-    }\n-\n-    return null;\n-  }\n-}"
        },
        {
            "sha": "1a2d4e6b789f3303ba8d5712e9c5c2ad415b2da4",
            "filename": "packages/core/schematics/migrations/relative-link-resolution/google3/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 13,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Fgoogle3%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Fgoogle3%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Fgoogle3%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,13 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"google3\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\"//packages/core/schematics/migrations/google3:__pkg__\"],\n-    deps = [\n-        \"//packages/core/schematics/migrations/relative-link-resolution\",\n-        \"@npm//tslint\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "cbf73d8a1f146b179984ad6c9acfee776ac2a441",
            "filename": "packages/core/schematics/migrations/relative-link-resolution/google3/tslint_update_recorder.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 28,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Fgoogle3%2Ftslint_update_recorder.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Fgoogle3%2Ftslint_update_recorder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Fgoogle3%2Ftslint_update_recorder.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,28 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Replacement, RuleFailure} from 'tslint';\n-import ts from 'typescript';\n-\n-import {UpdateRecorder} from '../update_recorder';\n-\n-export class TslintUpdateRecorder implements UpdateRecorder {\n-  failures: RuleFailure[] = [];\n-\n-  constructor(private ruleName: string, private sourceFile: ts.SourceFile) {}\n-\n-  updateNode(node: ts.Node, newText: string) {\n-    this.failures.unshift(new RuleFailure(\n-        this.sourceFile, node.getStart(), 0,\n-        'The relativeLinkResolution default is changing from `legacy` to `corrected`. To keep behavior consistent' +\n-            ' when the change is merged, specify `legacy` rather than using the default.',\n-        this.ruleName, Replacement.replaceFromTo(node.getStart(), node.getEnd(), `${newText}`)));\n-  }\n-\n-  commitUpdate() {}\n-}"
        },
        {
            "sha": "b0deb46b8c42e2a3b083dfc95dc951133c24e93e",
            "filename": "packages/core/schematics/migrations/relative-link-resolution/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 74,
            "changes": 74,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,74 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\n-import {relative} from 'path';\n-import ts from 'typescript';\n-import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n-import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n-import {RelativeLinkResolutionCollector} from './collector';\n-import {RelativeLinkResolutionTransform} from './transform';\n-import {UpdateRecorder} from './update_recorder';\n-\n-/** Entry point for the v11 \"relativeLinkResolution RouterModule options\" schematic. */\n-export default function(): Rule {\n-  return async (tree: Tree) => {\n-    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n-    const basePath = process.cwd();\n-\n-    if (!buildPaths.length && !testPaths.length) {\n-      throw new SchematicsException(\n-          'Could not find any tsconfig file. Cannot update the \"relativeLinkResolution\" option for RouterModule');\n-    }\n-\n-    for (const tsconfigPath of [...buildPaths, ...testPaths]) {\n-      runRelativeLinkResolutionMigration(tree, tsconfigPath, basePath);\n-    }\n-  };\n-}\n-\n-function runRelativeLinkResolutionMigration(tree: Tree, tsconfigPath: string, basePath: string) {\n-  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n-  const typeChecker = program.getTypeChecker();\n-  const relativeLinkResolutionCollector = new RelativeLinkResolutionCollector(typeChecker);\n-  const sourceFiles =\n-      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n-\n-  // Analyze source files by detecting all modules.\n-  sourceFiles.forEach(sourceFile => relativeLinkResolutionCollector.visitNode(sourceFile));\n-\n-  const {forRootCalls, extraOptionsLiterals} = relativeLinkResolutionCollector;\n-  const transformer = new RelativeLinkResolutionTransform(getUpdateRecorder);\n-  const updateRecorders = new Map<ts.SourceFile, UpdateRecorder>();\n-  transformer.migrateRouterModuleForRootCalls(forRootCalls);\n-  transformer.migrateObjectLiterals(extraOptionsLiterals);\n-\n-  // Walk through each update recorder and commit the update. We need to commit the\n-  // updates in batches per source file as there can be only one recorder per source\n-  // file in order to avoid shift character offsets.\n-  updateRecorders.forEach(recorder => recorder.commitUpdate());\n-\n-  /** Gets the update recorder for the specified source file. */\n-  function getUpdateRecorder(sourceFile: ts.SourceFile): UpdateRecorder {\n-    if (updateRecorders.has(sourceFile)) {\n-      return updateRecorders.get(sourceFile)!;\n-    }\n-    const treeRecorder = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n-    const recorder: UpdateRecorder = {\n-      updateNode(node: ts.Node, newText: string) {\n-        treeRecorder.remove(node.getStart(), node.getWidth());\n-        treeRecorder.insertRight(node.getStart(), newText);\n-      },\n-      commitUpdate() {\n-        tree.commitUpdate(treeRecorder);\n-      }\n-    };\n-    updateRecorders.set(sourceFile, recorder);\n-    return recorder;\n-  }\n-}"
        },
        {
            "sha": "844f012a695d22cfd81bd1b0eb431226dd4177c4",
            "filename": "packages/core/schematics/migrations/relative-link-resolution/transform.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 64,
            "changes": 64,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Ftransform.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Ftransform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Ftransform.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,64 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import ts from 'typescript';\n-\n-import {UpdateRecorder} from './update_recorder';\n-\n-\n-const RELATIVE_LINK_RESOLUTION = 'relativeLinkResolution';\n-\n-export class RelativeLinkResolutionTransform {\n-  private printer = ts.createPrinter();\n-\n-  constructor(private getUpdateRecorder: (sf: ts.SourceFile) => UpdateRecorder) {}\n-\n-  /** Migrate the ExtraOptions#RelativeLinkResolution property assignments. */\n-  migrateRouterModuleForRootCalls(calls: ts.CallExpression[]) {\n-    calls.forEach(c => {\n-      this._updateCallExpressionWithoutExtraOptions(c);\n-    });\n-  }\n-\n-  migrateObjectLiterals(vars: ts.ObjectLiteralExpression[]) {\n-    vars.forEach(v => this._maybeUpdateLiteral(v));\n-  }\n-\n-  private _updateCallExpressionWithoutExtraOptions(callExpression: ts.CallExpression) {\n-    const args = callExpression.arguments;\n-    const emptyLiteral = ts.createObjectLiteral();\n-    const newNode = ts.updateCall(\n-        callExpression, callExpression.expression, callExpression.typeArguments,\n-        [args[0], this._getMigratedLiteralExpression(emptyLiteral)]);\n-    this._updateNode(callExpression, newNode);\n-  }\n-\n-  private _getMigratedLiteralExpression(literal: ts.ObjectLiteralExpression) {\n-    if (literal.properties.some(\n-            prop => ts.isPropertyAssignment(prop) &&\n-                prop.name.getText() === RELATIVE_LINK_RESOLUTION)) {\n-      // literal already defines a value for relativeLinkResolution. Skip it\n-      return literal;\n-    }\n-    const legacyExpression =\n-        ts.createPropertyAssignment(RELATIVE_LINK_RESOLUTION, ts.createIdentifier(`'legacy'`));\n-    return ts.updateObjectLiteral(literal, [...literal.properties, legacyExpression]);\n-  }\n-\n-  private _maybeUpdateLiteral(literal: ts.ObjectLiteralExpression) {\n-    const updatedLiteral = this._getMigratedLiteralExpression(literal);\n-    if (updatedLiteral !== literal) {\n-      this._updateNode(literal, updatedLiteral);\n-    }\n-  }\n-\n-  private _updateNode(node: ts.Node, newNode: ts.Node) {\n-    const newText = this.printer.printNode(ts.EmitHint.Unspecified, newNode, node.getSourceFile());\n-    const recorder = this.getUpdateRecorder(node.getSourceFile());\n-    recorder.updateNode(node, newText);\n-  }\n-}"
        },
        {
            "sha": "6156375460f7daa8f26b6cec554d1f5a02621b2f",
            "filename": "packages/core/schematics/migrations/relative-link-resolution/update_recorder.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 19,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Fupdate_recorder.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Fupdate_recorder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Fupdate_recorder.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,19 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-/**\n- * Update recorder interface that is used to transform source files in a non-colliding\n- * way. Also this indirection makes it possible to re-use logic for both TSLint rules\n- * and CLI devkit schematic updates.\n- */\n-export interface UpdateRecorder {\n-  updateNode(node: ts.Node, newText: string): void;\n-  commitUpdate(): void;\n-}"
        },
        {
            "sha": "6f8a5a36f02d378917b1173154dbf7c1685e0882",
            "filename": "packages/core/schematics/migrations/relative-link-resolution/util.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 33,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frelative-link-resolution%2Futil.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,33 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-import {getImportOfIdentifier} from '../../utils/typescript/imports';\n-\n-/** Determine whether a node is a ModuleWithProviders type reference node without a generic type */\n-export function isRouterModuleForRoot(\n-    typeChecker: ts.TypeChecker, node: ts.Node): node is ts.CallExpression {\n-  if (!ts.isCallExpression(node) || !ts.isPropertyAccessExpression(node.expression) ||\n-      !ts.isIdentifier(node.expression.expression) || node.expression.name.text !== 'forRoot') {\n-    return false;\n-  }\n-  const imp = getImportOfIdentifier(typeChecker, node.expression.expression);\n-  return !!imp && imp.name === 'RouterModule' && imp.importModule === '@angular/router' &&\n-      !node.typeArguments;\n-}\n-\n-export function isExtraOptions(\n-    typeChecker: ts.TypeChecker, node: ts.Node): node is ts.TypeReferenceNode {\n-  if (!ts.isTypeReferenceNode(node) || !ts.isIdentifier(node.typeName)) {\n-    return false;\n-  }\n-\n-  const imp = getImportOfIdentifier(typeChecker, node.typeName);\n-  return imp !== null && imp.name === 'ExtraOptions' && imp.importModule === '@angular/router' &&\n-      !node.typeArguments;\n-}"
        },
        {
            "sha": "58b6c7c6952513902366119a81f5229c82ca8218",
            "filename": "packages/core/schematics/migrations/renderer-to-renderer2/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,18 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"renderer-to-renderer2\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/migrations/google3:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"//packages/core/schematics/utils\",\n-        \"@npm//@angular-devkit/schematics\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "b816cdd0911dd4e03464f6395769174761771811",
            "filename": "packages/core/schematics/migrations/renderer-to-renderer2/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 33,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2FREADME.md?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,33 +0,0 @@\n-## Renderer -> Renderer2 migration\n-\n-Automatically migrates from `Renderer` to `Renderer2` by changing method calls, renaming imports\n-and renaming types. Tries to either map method calls directly from one renderer to the other, or\n-if that's not possible, inserts custom helper functions at the bottom of the file.\n-\n-#### Before\n-```ts\n-import { Renderer, ElementRef } from '@angular/core';\n-\n-@Component({})\n-export class MyComponent {\n-  constructor(private _renderer: Renderer, private _elementRef: ElementRef) {}\n-\n-  changeColor() {\n-    this._renderer.setElementStyle(this._element.nativeElement, 'color', 'purple');\n-  }\n-}\n-```\n-\n-#### After\n-```ts\n-import { Renderer2, ElementRef } from '@angular/core';\n-\n-@Component({})\n-export class MyComponent {\n-  constructor(private _renderer: Renderer2, private _elementRef: ElementRef) {}\n-\n-  changeColor() {\n-    this._renderer.setStyle(this._element.nativeElement, 'color', 'purple');\n-  }\n-}\n-```"
        },
        {
            "sha": "13a770b66929d7d4a70c0d115f73483c8e4bdf4e",
            "filename": "packages/core/schematics/migrations/renderer-to-renderer2/helpers.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 403,
            "changes": 403,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Fhelpers.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Fhelpers.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Fhelpers.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,403 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-/** Names of the helper functions that are supported for this migration. */\n-export const enum HelperFunction {\n-  any = 'AnyDuringRendererMigration',\n-  createElement = '__ngRendererCreateElementHelper',\n-  createText = '__ngRendererCreateTextHelper',\n-  createTemplateAnchor = '__ngRendererCreateTemplateAnchorHelper',\n-  projectNodes = '__ngRendererProjectNodesHelper',\n-  animate = '__ngRendererAnimateHelper',\n-  destroyView = '__ngRendererDestroyViewHelper',\n-  detachView = '__ngRendererDetachViewHelper',\n-  attachViewAfter = '__ngRendererAttachViewAfterHelper',\n-  splitNamespace = '__ngRendererSplitNamespaceHelper',\n-  setElementAttribute = '__ngRendererSetElementAttributeHelper'\n-}\n-\n-/** Gets the string representation of a helper function. */\n-export function getHelper(\n-    name: HelperFunction, sourceFile: ts.SourceFile, printer: ts.Printer): string {\n-  const helperDeclaration = getHelperDeclaration(name);\n-  return '\\n' + printer.printNode(ts.EmitHint.Unspecified, helperDeclaration, sourceFile) + '\\n';\n-}\n-\n-/** Creates a function declaration for the specified helper name. */\n-function getHelperDeclaration(name: HelperFunction): ts.Node {\n-  switch (name) {\n-    case HelperFunction.any:\n-      return createAnyTypeHelper();\n-    case HelperFunction.createElement:\n-      return getCreateElementHelper();\n-    case HelperFunction.createText:\n-      return getCreateTextHelper();\n-    case HelperFunction.createTemplateAnchor:\n-      return getCreateTemplateAnchorHelper();\n-    case HelperFunction.projectNodes:\n-      return getProjectNodesHelper();\n-    case HelperFunction.animate:\n-      return getAnimateHelper();\n-    case HelperFunction.destroyView:\n-      return getDestroyViewHelper();\n-    case HelperFunction.detachView:\n-      return getDetachViewHelper();\n-    case HelperFunction.attachViewAfter:\n-      return getAttachViewAfterHelper();\n-    case HelperFunction.setElementAttribute:\n-      return getSetElementAttributeHelper();\n-    case HelperFunction.splitNamespace:\n-      return getSplitNamespaceHelper();\n-  }\n-}\n-\n-/** Creates a helper for a custom `any` type during the migration. */\n-function createAnyTypeHelper(): ts.TypeAliasDeclaration {\n-  // type AnyDuringRendererMigration = any;\n-  return ts.createTypeAliasDeclaration(\n-      [], [], HelperFunction.any, [], ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n-}\n-\n-/** Creates a function parameter that is typed as `any`. */\n-function getAnyTypedParameter(\n-    parameterName: string|ts.Identifier, isRequired = true): ts.ParameterDeclaration {\n-  // Declare the parameter as `any` so we don't have to add extra logic to ensure that the\n-  // generated code will pass type checking. Use our custom `any` type so people have an incentive\n-  // to clean it up afterwards and to avoid potentially introducing lint warnings in G3.\n-  const type = ts.createTypeReferenceNode(HelperFunction.any, []);\n-  return ts.createParameter(\n-      [], [], undefined, parameterName,\n-      isRequired ? undefined : ts.createToken(ts.SyntaxKind.QuestionToken), type);\n-}\n-\n-/** Creates a helper for `createElement`. */\n-function getCreateElementHelper(): ts.FunctionDeclaration {\n-  const renderer = ts.createIdentifier('renderer');\n-  const parent = ts.createIdentifier('parent');\n-  const namespaceAndName = ts.createIdentifier('namespaceAndName');\n-  const name = ts.createIdentifier('name');\n-  const namespace = ts.createIdentifier('namespace');\n-\n-  // [namespace, name] = splitNamespace(namespaceAndName);\n-  const namespaceAndNameVariable = ts.createVariableDeclaration(\n-      ts.createArrayBindingPattern(\n-          [namespace, name].map(id => ts.createBindingElement(undefined, undefined, id))),\n-      undefined,\n-      ts.createCall(ts.createIdentifier(HelperFunction.splitNamespace), [], [namespaceAndName]));\n-\n-  // `renderer.createElement(name, namespace)`.\n-  const creationCall =\n-      ts.createCall(ts.createPropertyAccess(renderer, 'createElement'), [], [name, namespace]);\n-\n-  return getCreationHelper(\n-      HelperFunction.createElement, creationCall, renderer, parent, [namespaceAndName],\n-      [ts.createVariableStatement(\n-          undefined,\n-          ts.createVariableDeclarationList([namespaceAndNameVariable], ts.NodeFlags.Const))]);\n-}\n-\n-/** Creates a helper for `createText`. */\n-function getCreateTextHelper(): ts.FunctionDeclaration {\n-  const renderer = ts.createIdentifier('renderer');\n-  const parent = ts.createIdentifier('parent');\n-  const value = ts.createIdentifier('value');\n-\n-  // `renderer.createText(value)`.\n-  const creationCall = ts.createCall(ts.createPropertyAccess(renderer, 'createText'), [], [value]);\n-\n-  return getCreationHelper(HelperFunction.createText, creationCall, renderer, parent, [value]);\n-}\n-\n-/** Creates a helper for `createTemplateAnchor`. */\n-function getCreateTemplateAnchorHelper(): ts.FunctionDeclaration {\n-  const renderer = ts.createIdentifier('renderer');\n-  const parent = ts.createIdentifier('parent');\n-\n-  // `renderer.createComment('')`.\n-  const creationCall = ts.createCall(\n-      ts.createPropertyAccess(renderer, 'createComment'), [], [ts.createStringLiteral('')]);\n-\n-  return getCreationHelper(HelperFunction.createTemplateAnchor, creationCall, renderer, parent);\n-}\n-\n-/**\n- * Gets the function declaration for a creation helper. This is reused between `createElement`,\n- * `createText` and `createTemplateAnchor` which follow a very similar pattern.\n- * @param functionName Function that the helper should have.\n- * @param creationCall Expression that is used to create a node inside the function.\n- * @param rendererParameter Parameter for the `renderer`.\n- * @param parentParameter Parameter for the `parent` inside the function.\n- * @param extraParameters Extra parameters to be added to the end.\n- * @param precedingVariables Extra variables to be added before the one that creates the `node`.\n- */\n-function getCreationHelper(\n-    functionName: HelperFunction, creationCall: ts.CallExpression, renderer: ts.Identifier,\n-    parent: ts.Identifier, extraParameters: ts.Identifier[] = [],\n-    precedingVariables: ts.VariableStatement[] = []): ts.FunctionDeclaration {\n-  const node = ts.createIdentifier('node');\n-\n-  // `const node = {{creationCall}}`.\n-  const nodeVariableStatement = ts.createVariableStatement(\n-      undefined,\n-      ts.createVariableDeclarationList(\n-          [ts.createVariableDeclaration(node, undefined, creationCall)], ts.NodeFlags.Const));\n-\n-  // `if (parent) { renderer.appendChild(parent, node) }`.\n-  const guardedAppendChildCall = ts.createIf(\n-      parent,\n-      ts.createBlock(\n-          [ts.createExpressionStatement(\n-              ts.createCall(ts.createPropertyAccess(renderer, 'appendChild'), [], [parent, node]))],\n-          true));\n-\n-  return ts.createFunctionDeclaration(\n-      [], [], undefined, functionName, [],\n-      [renderer, parent, ...extraParameters].map(name => getAnyTypedParameter(name)), undefined,\n-      ts.createBlock(\n-          [\n-            ...precedingVariables, nodeVariableStatement, guardedAppendChildCall,\n-            ts.createReturn(node)\n-          ],\n-          true));\n-}\n-\n-/** Creates a helper for `projectNodes`. */\n-function getProjectNodesHelper(): ts.FunctionDeclaration {\n-  const renderer = ts.createIdentifier('renderer');\n-  const parent = ts.createIdentifier('parent');\n-  const nodes = ts.createIdentifier('nodes');\n-  const incrementor = ts.createIdentifier('i');\n-\n-  // for (let i = 0; i < nodes.length; i++) {\n-  //   renderer.appendChild(parent, nodes[i]);\n-  // }\n-  const loopInitializer = ts.createVariableDeclarationList(\n-      [ts.createVariableDeclaration(incrementor, undefined, ts.createNumericLiteral('0'))],\n-      ts.NodeFlags.Let);\n-  const loopCondition = ts.createBinary(\n-      incrementor, ts.SyntaxKind.LessThanToken,\n-      ts.createPropertyAccess(nodes, ts.createIdentifier('length')));\n-  const appendStatement = ts.createExpressionStatement(ts.createCall(\n-      ts.createPropertyAccess(renderer, 'appendChild'), [],\n-      [parent, ts.createElementAccess(nodes, incrementor)]));\n-  const loop = ts.createFor(\n-      loopInitializer, loopCondition, ts.createPostfix(incrementor, ts.SyntaxKind.PlusPlusToken),\n-      ts.createBlock([appendStatement]));\n-\n-  return ts.createFunctionDeclaration(\n-      [], [], undefined, HelperFunction.projectNodes, [],\n-      [renderer, parent, nodes].map(name => getAnyTypedParameter(name)), undefined,\n-      ts.createBlock([loop], true));\n-}\n-\n-/** Creates a helper for `animate`. */\n-function getAnimateHelper(): ts.FunctionDeclaration {\n-  // throw new Error('...');\n-  const throwStatement = ts.createThrow(ts.createNew(\n-      ts.createIdentifier('Error'), [],\n-      [ts.createStringLiteral('Renderer.animate is no longer supported!')]));\n-\n-  return ts.createFunctionDeclaration(\n-      [], [], undefined, HelperFunction.animate, [], [], undefined,\n-      ts.createBlock([throwStatement], true));\n-}\n-\n-/** Creates a helper for `destroyView`. */\n-function getDestroyViewHelper(): ts.FunctionDeclaration {\n-  const renderer = ts.createIdentifier('renderer');\n-  const allNodes = ts.createIdentifier('allNodes');\n-  const incrementor = ts.createIdentifier('i');\n-\n-  // for (let i = 0; i < allNodes.length; i++) {\n-  //   renderer.destroyNode(allNodes[i]);\n-  // }\n-  const loopInitializer = ts.createVariableDeclarationList(\n-      [ts.createVariableDeclaration(incrementor, undefined, ts.createNumericLiteral('0'))],\n-      ts.NodeFlags.Let);\n-  const loopCondition = ts.createBinary(\n-      incrementor, ts.SyntaxKind.LessThanToken,\n-      ts.createPropertyAccess(allNodes, ts.createIdentifier('length')));\n-  const destroyStatement = ts.createExpressionStatement(ts.createCall(\n-      ts.createPropertyAccess(renderer, 'destroyNode'), [],\n-      [ts.createElementAccess(allNodes, incrementor)]));\n-  const loop = ts.createFor(\n-      loopInitializer, loopCondition, ts.createPostfix(incrementor, ts.SyntaxKind.PlusPlusToken),\n-      ts.createBlock([destroyStatement]));\n-\n-  return ts.createFunctionDeclaration(\n-      [], [], undefined, HelperFunction.destroyView, [],\n-      [renderer, allNodes].map(name => getAnyTypedParameter(name)), undefined,\n-      ts.createBlock([loop], true));\n-}\n-\n-/** Creates a helper for `detachView`. */\n-function getDetachViewHelper(): ts.FunctionDeclaration {\n-  const renderer = ts.createIdentifier('renderer');\n-  const rootNodes = ts.createIdentifier('rootNodes');\n-  const incrementor = ts.createIdentifier('i');\n-  const node = ts.createIdentifier('node');\n-\n-  // for (let i = 0; i < rootNodes.length; i++) {\n-  //   const node = rootNodes[i];\n-  //   renderer.removeChild(renderer.parentNode(node), node);\n-  // }\n-  const loopInitializer = ts.createVariableDeclarationList(\n-      [ts.createVariableDeclaration(incrementor, undefined, ts.createNumericLiteral('0'))],\n-      ts.NodeFlags.Let);\n-  const loopCondition = ts.createBinary(\n-      incrementor, ts.SyntaxKind.LessThanToken,\n-      ts.createPropertyAccess(rootNodes, ts.createIdentifier('length')));\n-\n-  // const node = rootNodes[i];\n-  const nodeVariableStatement = ts.createVariableStatement(\n-      undefined,\n-      ts.createVariableDeclarationList(\n-          [ts.createVariableDeclaration(\n-              node, undefined, ts.createElementAccess(rootNodes, incrementor))],\n-          ts.NodeFlags.Const));\n-  // renderer.removeChild(renderer.parentNode(node), node);\n-  const removeCall = ts.createCall(\n-      ts.createPropertyAccess(renderer, 'removeChild'), [],\n-      [ts.createCall(ts.createPropertyAccess(renderer, 'parentNode'), [], [node]), node]);\n-\n-  const loop = ts.createFor(\n-      loopInitializer, loopCondition, ts.createPostfix(incrementor, ts.SyntaxKind.PlusPlusToken),\n-      ts.createBlock([nodeVariableStatement, ts.createExpressionStatement(removeCall)]));\n-\n-  return ts.createFunctionDeclaration(\n-      [], [], undefined, HelperFunction.detachView, [],\n-      [renderer, rootNodes].map(name => getAnyTypedParameter(name)), undefined,\n-      ts.createBlock([loop], true));\n-}\n-\n-/** Creates a helper for `attachViewAfter` */\n-function getAttachViewAfterHelper(): ts.FunctionDeclaration {\n-  const renderer = ts.createIdentifier('renderer');\n-  const node = ts.createIdentifier('node');\n-  const rootNodes = ts.createIdentifier('rootNodes');\n-  const parent = ts.createIdentifier('parent');\n-  const nextSibling = ts.createIdentifier('nextSibling');\n-  const incrementor = ts.createIdentifier('i');\n-  const createConstWithMethodCallInitializer = (constName: ts.Identifier, methodToCall: string) => {\n-    return ts.createVariableStatement(\n-        undefined,\n-        ts.createVariableDeclarationList(\n-            [ts.createVariableDeclaration(\n-                constName, undefined,\n-                ts.createCall(ts.createPropertyAccess(renderer, methodToCall), [], [node]))],\n-            ts.NodeFlags.Const));\n-  };\n-\n-  // const parent = renderer.parentNode(node);\n-  const parentVariableStatement = createConstWithMethodCallInitializer(parent, 'parentNode');\n-\n-  // const nextSibling = renderer.nextSibling(node);\n-  const nextSiblingVariableStatement =\n-      createConstWithMethodCallInitializer(nextSibling, 'nextSibling');\n-\n-  // for (let i = 0; i < rootNodes.length; i++) {\n-  //   renderer.insertBefore(parentElement, rootNodes[i], nextSibling);\n-  // }\n-  const loopInitializer = ts.createVariableDeclarationList(\n-      [ts.createVariableDeclaration(incrementor, undefined, ts.createNumericLiteral('0'))],\n-      ts.NodeFlags.Let);\n-  const loopCondition = ts.createBinary(\n-      incrementor, ts.SyntaxKind.LessThanToken,\n-      ts.createPropertyAccess(rootNodes, ts.createIdentifier('length')));\n-  const insertBeforeCall = ts.createCall(\n-      ts.createPropertyAccess(renderer, 'insertBefore'), [],\n-      [parent, ts.createElementAccess(rootNodes, incrementor), nextSibling]);\n-  const loop = ts.createFor(\n-      loopInitializer, loopCondition, ts.createPostfix(incrementor, ts.SyntaxKind.PlusPlusToken),\n-      ts.createBlock([ts.createExpressionStatement(insertBeforeCall)]));\n-\n-  return ts.createFunctionDeclaration(\n-      [], [], undefined, HelperFunction.attachViewAfter, [],\n-      [renderer, node, rootNodes].map(name => getAnyTypedParameter(name)), undefined,\n-      ts.createBlock([parentVariableStatement, nextSiblingVariableStatement, loop], true));\n-}\n-\n-/** Creates a helper for `setElementAttribute` */\n-function getSetElementAttributeHelper(): ts.FunctionDeclaration {\n-  const renderer = ts.createIdentifier('renderer');\n-  const element = ts.createIdentifier('element');\n-  const namespaceAndName = ts.createIdentifier('namespaceAndName');\n-  const value = ts.createIdentifier('value');\n-  const name = ts.createIdentifier('name');\n-  const namespace = ts.createIdentifier('namespace');\n-\n-  // [namespace, name] = splitNamespace(namespaceAndName);\n-  const namespaceAndNameVariable = ts.createVariableDeclaration(\n-      ts.createArrayBindingPattern(\n-          [namespace, name].map(id => ts.createBindingElement(undefined, undefined, id))),\n-      undefined,\n-      ts.createCall(ts.createIdentifier(HelperFunction.splitNamespace), [], [namespaceAndName]));\n-\n-  // renderer.setAttribute(element, name, value, namespace);\n-  const setCall = ts.createCall(\n-      ts.createPropertyAccess(renderer, 'setAttribute'), [], [element, name, value, namespace]);\n-\n-  // renderer.removeAttribute(element, name, namespace);\n-  const removeCall = ts.createCall(\n-      ts.createPropertyAccess(renderer, 'removeAttribute'), [], [element, name, namespace]);\n-\n-  // if (value != null) { setCall() } else { removeCall }\n-  const ifStatement = ts.createIf(\n-      ts.createBinary(value, ts.SyntaxKind.ExclamationEqualsToken, ts.createNull()),\n-      ts.createBlock([ts.createExpressionStatement(setCall)], true),\n-      ts.createBlock([ts.createExpressionStatement(removeCall)], true));\n-\n-  const functionBody = ts.createBlock(\n-      [\n-        ts.createVariableStatement(\n-            undefined,\n-            ts.createVariableDeclarationList([namespaceAndNameVariable], ts.NodeFlags.Const)),\n-        ifStatement\n-      ],\n-      true);\n-\n-  return ts.createFunctionDeclaration(\n-      [], [], undefined, HelperFunction.setElementAttribute, [],\n-      [\n-        getAnyTypedParameter(renderer), getAnyTypedParameter(element),\n-        getAnyTypedParameter(namespaceAndName), getAnyTypedParameter(value, false)\n-      ],\n-      undefined, functionBody);\n-}\n-\n-/** Creates a helper for splitting a name that might contain a namespace. */\n-function getSplitNamespaceHelper(): ts.FunctionDeclaration {\n-  const name = ts.createIdentifier('name');\n-  const match = ts.createIdentifier('match');\n-  const regex = ts.createRegularExpressionLiteral('/^:([^:]+):(.+)$/');\n-  const matchCall = ts.createCall(ts.createPropertyAccess(name, 'match'), [], [regex]);\n-\n-  // const match = name.split(regex);\n-  const matchVariable = ts.createVariableDeclarationList(\n-      [ts.createVariableDeclaration(match, undefined, matchCall)], ts.NodeFlags.Const);\n-\n-  // return [match[1], match[2]];\n-  const matchReturn = ts.createReturn(\n-      ts.createArrayLiteral([ts.createElementAccess(match, 1), ts.createElementAccess(match, 2)]));\n-\n-  // if (name[0] === ':') { const match = ...; return ...; }\n-  const ifStatement = ts.createIf(\n-      ts.createBinary(\n-          ts.createElementAccess(name, 0), ts.SyntaxKind.EqualsEqualsEqualsToken,\n-          ts.createStringLiteral(':')),\n-      ts.createBlock([ts.createVariableStatement([], matchVariable), matchReturn], true));\n-\n-  // return ['', name];\n-  const elseReturn = ts.createReturn(ts.createArrayLiteral([ts.createStringLiteral(''), name]));\n-\n-  return ts.createFunctionDeclaration(\n-      [], [], undefined, HelperFunction.splitNamespace, [], [getAnyTypedParameter(name)], undefined,\n-      ts.createBlock([ifStatement, elseReturn], true));\n-}"
        },
        {
            "sha": "af563f68330f7ef8fe3fe702f9bb1b70ce5a9807",
            "filename": "packages/core/schematics/migrations/renderer-to-renderer2/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 140,
            "changes": 140,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,140 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\n-import {basename, join, relative} from 'path';\n-import ts from 'typescript';\n-\n-import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n-import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n-import {getImportSpecifier, replaceImport} from '../../utils/typescript/imports';\n-import {closestNode} from '../../utils/typescript/nodes';\n-\n-import {getHelper, HelperFunction} from './helpers';\n-import {migrateExpression} from './migration';\n-import {findRendererReferences} from './util';\n-\n-const MODULE_AUGMENTATION_FILENAME = 'RENDERER_MIGRATION_CORE_AUGMENTATION.d.ts';\n-\n-/**\n- * Migration that switches from `Renderer` to `Renderer2`. More information on how it works:\n- * https://hackmd.angular.io/UTzUZTnPRA-cSa_4mHyfYw\n- */\n-export default function(): Rule {\n-  return async (tree: Tree) => {\n-    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n-    const basePath = process.cwd();\n-    const allPaths = [...buildPaths, ...testPaths];\n-\n-    if (!allPaths.length) {\n-      throw new SchematicsException(\n-          'Could not find any tsconfig file. Cannot migrate Renderer usages to Renderer2.');\n-    }\n-\n-    for (const tsconfigPath of allPaths) {\n-      runRendererToRenderer2Migration(tree, tsconfigPath, basePath);\n-    }\n-  };\n-}\n-\n-function runRendererToRenderer2Migration(tree: Tree, tsconfigPath: string, basePath: string) {\n-  // Technically we can get away with using `MODULE_AUGMENTATION_FILENAME` as the path, but as of\n-  // TS 4.2, the module resolution caching seems to be more aggressive which causes the file to be\n-  // retained between test runs. We can avoid it by using the full path.\n-  const augmentedFilePath = join(basePath, MODULE_AUGMENTATION_FILENAME);\n-  const {program} = createMigrationProgram(tree, tsconfigPath, basePath, fileName => {\n-    // In case the module augmentation file has been requested, we return a source file that\n-    // augments \"@angular/core\" to include a named export called \"Renderer\". This ensures that\n-    // we can rely on the type checker for this migration in v9 where \"Renderer\" has been removed.\n-    if (basename(fileName) === MODULE_AUGMENTATION_FILENAME) {\n-      return `\n-        import '@angular/core';\n-        declare module \"@angular/core\" {\n-          class Renderer {}\n-        }\n-      `;\n-    }\n-    return undefined;\n-  }, [augmentedFilePath]);\n-  const typeChecker = program.getTypeChecker();\n-  const printer = ts.createPrinter();\n-  const sourceFiles =\n-      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n-\n-  sourceFiles.forEach(sourceFile => {\n-    const rendererImportSpecifier = getImportSpecifier(sourceFile, '@angular/core', 'Renderer');\n-    const rendererImport = rendererImportSpecifier ?\n-        closestNode<ts.NamedImports>(rendererImportSpecifier, ts.SyntaxKind.NamedImports) :\n-        null;\n-\n-    // If there are no imports for the `Renderer`, we can exit early.\n-    if (!rendererImportSpecifier || !rendererImport) {\n-      return;\n-    }\n-\n-    const {typedNodes, methodCalls, forwardRefs} =\n-        findRendererReferences(sourceFile, typeChecker, rendererImportSpecifier);\n-    const update = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n-    const helpersToAdd = new Set<HelperFunction>();\n-\n-    // Change the `Renderer` import to `Renderer2`.\n-    update.remove(rendererImport.getStart(), rendererImport.getWidth());\n-    update.insertRight(\n-        rendererImport.getStart(),\n-        printer.printNode(\n-            ts.EmitHint.Unspecified, replaceImport(rendererImport, 'Renderer', 'Renderer2'),\n-            sourceFile));\n-\n-    // Change the method parameter and property types to `Renderer2`.\n-    typedNodes.forEach(node => {\n-      const type = node.type;\n-\n-      if (type) {\n-        update.remove(type.getStart(), type.getWidth());\n-        update.insertRight(type.getStart(), 'Renderer2');\n-      }\n-    });\n-\n-    // Change all identifiers inside `forwardRef` referring to the `Renderer`.\n-    forwardRefs.forEach(identifier => {\n-      update.remove(identifier.getStart(), identifier.getWidth());\n-      update.insertRight(identifier.getStart(), 'Renderer2');\n-    });\n-\n-    // Migrate all of the method calls.\n-    methodCalls.forEach(call => {\n-      const {node, requiredHelpers} = migrateExpression(call, typeChecker);\n-\n-      if (node) {\n-        // If we migrated the node to a new expression, replace only the call expression.\n-        update.remove(call.getStart(), call.getWidth());\n-        update.insertRight(\n-            call.getStart(), printer.printNode(ts.EmitHint.Unspecified, node, sourceFile));\n-      } else if (call.parent && ts.isExpressionStatement(call.parent)) {\n-        // Otherwise if the call is inside an expression statement, drop the entire statement.\n-        // This takes care of any trailing semicolons. We only need to drop nodes for cases like\n-        // `setBindingDebugInfo` which have been noop for a while so they can be removed safely.\n-        update.remove(call.parent.getStart(), call.parent.getWidth());\n-      }\n-\n-      if (requiredHelpers) {\n-        requiredHelpers.forEach(helperName => helpersToAdd.add(helperName));\n-      }\n-    });\n-\n-    // Some of the methods can't be mapped directly to `Renderer2` and need extra logic around them.\n-    // The safest way to do so is to declare helper functions similar to the ones emitted by TS\n-    // which encapsulate the extra \"glue\" logic. We should only emit these functions once per file.\n-    helpersToAdd.forEach(helperName => {\n-      update.insertLeft(\n-          sourceFile.endOfFileToken.getStart(), getHelper(helperName, sourceFile, printer));\n-    });\n-\n-    tree.commitUpdate(update);\n-  });\n-}"
        },
        {
            "sha": "0922d6e1aaa80f873d61be0872f6b5c148ace785",
            "filename": "packages/core/schematics/migrations/renderer-to-renderer2/migration.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 244,
            "changes": 244,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Fmigration.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Fmigration.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Fmigration.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,244 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {HelperFunction} from './helpers';\n-\n-/** A call expression that is based on a property access. */\n-type PropertyAccessCallExpression = ts.CallExpression&{expression: ts.PropertyAccessExpression};\n-\n-/**\n- * Migrates a function call expression from `Renderer` to `Renderer2`.\n- * Returns null if the expression should be dropped.\n- */\n-export function migrateExpression(node: ts.CallExpression, typeChecker: ts.TypeChecker):\n-    {node: ts.Node|null, requiredHelpers?: HelperFunction[]} {\n-  if (isPropertyAccessCallExpression(node)) {\n-    switch (node.expression.name.getText()) {\n-      case 'setElementProperty':\n-        return {node: renameMethodCall(node, 'setProperty')};\n-      case 'setText':\n-        return {node: renameMethodCall(node, 'setValue')};\n-      case 'listenGlobal':\n-        return {node: renameMethodCall(node, 'listen')};\n-      case 'selectRootElement':\n-        return {node: migrateSelectRootElement(node)};\n-      case 'setElementClass':\n-        return {node: migrateSetElementClass(node)};\n-      case 'setElementStyle':\n-        return {node: migrateSetElementStyle(node, typeChecker)};\n-      case 'invokeElementMethod':\n-        return {node: migrateInvokeElementMethod(node)};\n-      case 'setBindingDebugInfo':\n-        return {node: null};\n-      case 'createViewRoot':\n-        return {node: migrateCreateViewRoot(node)};\n-      case 'setElementAttribute':\n-        return {\n-          node: switchToHelperCall(node, HelperFunction.setElementAttribute, node.arguments),\n-          requiredHelpers: [\n-            HelperFunction.any, HelperFunction.splitNamespace, HelperFunction.setElementAttribute\n-          ]\n-        };\n-      case 'createElement':\n-        return {\n-          node: switchToHelperCall(node, HelperFunction.createElement, node.arguments.slice(0, 2)),\n-          requiredHelpers:\n-              [HelperFunction.any, HelperFunction.splitNamespace, HelperFunction.createElement]\n-        };\n-      case 'createText':\n-        return {\n-          node: switchToHelperCall(node, HelperFunction.createText, node.arguments.slice(0, 2)),\n-          requiredHelpers: [HelperFunction.any, HelperFunction.createText]\n-        };\n-      case 'createTemplateAnchor':\n-        return {\n-          node: switchToHelperCall(\n-              node, HelperFunction.createTemplateAnchor, node.arguments.slice(0, 1)),\n-          requiredHelpers: [HelperFunction.any, HelperFunction.createTemplateAnchor]\n-        };\n-      case 'projectNodes':\n-        return {\n-          node: switchToHelperCall(node, HelperFunction.projectNodes, node.arguments),\n-          requiredHelpers: [HelperFunction.any, HelperFunction.projectNodes]\n-        };\n-      case 'animate':\n-        return {\n-          node: migrateAnimateCall(),\n-          requiredHelpers: [HelperFunction.any, HelperFunction.animate]\n-        };\n-      case 'destroyView':\n-        return {\n-          node: switchToHelperCall(node, HelperFunction.destroyView, [node.arguments[1]]),\n-          requiredHelpers: [HelperFunction.any, HelperFunction.destroyView]\n-        };\n-      case 'detachView':\n-        return {\n-          node: switchToHelperCall(node, HelperFunction.detachView, [node.arguments[0]]),\n-          requiredHelpers: [HelperFunction.any, HelperFunction.detachView]\n-        };\n-      case 'attachViewAfter':\n-        return {\n-          node: switchToHelperCall(node, HelperFunction.attachViewAfter, node.arguments),\n-          requiredHelpers: [HelperFunction.any, HelperFunction.attachViewAfter]\n-        };\n-    }\n-  }\n-\n-  return {node};\n-}\n-\n-/** Checks whether a node is a PropertyAccessExpression. */\n-function isPropertyAccessCallExpression(node: ts.Node): node is PropertyAccessCallExpression {\n-  return ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression);\n-}\n-\n-/** Renames a method call while keeping all of the parameters in place. */\n-function renameMethodCall(node: PropertyAccessCallExpression, newName: string): ts.CallExpression {\n-  const newExpression = ts.updatePropertyAccess(\n-      node.expression, node.expression.expression, ts.createIdentifier(newName));\n-\n-  return ts.updateCall(node, newExpression, node.typeArguments, node.arguments);\n-}\n-\n-/**\n- * Migrates a `selectRootElement` call by removing the last argument which is no longer supported.\n- */\n-function migrateSelectRootElement(node: ts.CallExpression): ts.Node {\n-  // The only thing we need to do is to drop the last argument\n-  // (`debugInfo`), if the consumer was passing it in.\n-  if (node.arguments.length > 1) {\n-    return ts.updateCall(node, node.expression, node.typeArguments, [node.arguments[0]]);\n-  }\n-\n-  return node;\n-}\n-\n-/**\n- * Migrates a call to `setElementClass` either to a call to `addClass` or `removeClass`, or\n- * to an expression like `isAdd ? addClass(el, className) : removeClass(el, className)`.\n- */\n-function migrateSetElementClass(node: PropertyAccessCallExpression): ts.Node {\n-  // Clone so we don't mutate by accident. Note that we assume that\n-  // the user's code is providing all three required arguments.\n-  const outputMethodArgs = node.arguments.slice();\n-  const isAddArgument = outputMethodArgs.pop()!;\n-  const createRendererCall = (isAdd: boolean) => {\n-    const innerExpression = node.expression.expression;\n-    const topExpression =\n-        ts.createPropertyAccess(innerExpression, isAdd ? 'addClass' : 'removeClass');\n-    return ts.createCall(topExpression, [], node.arguments.slice(0, 2));\n-  };\n-\n-  // If the call has the `isAdd` argument as a literal boolean, we can map it directly to\n-  // `addClass` or `removeClass`. Note that we can't use the type checker here, because it\n-  // won't tell us whether the value resolves to true or false.\n-  if (isAddArgument.kind === ts.SyntaxKind.TrueKeyword ||\n-      isAddArgument.kind === ts.SyntaxKind.FalseKeyword) {\n-    return createRendererCall(isAddArgument.kind === ts.SyntaxKind.TrueKeyword);\n-  }\n-\n-  // Otherwise create a ternary on the variable.\n-  return ts.createConditional(isAddArgument, createRendererCall(true), createRendererCall(false));\n-}\n-\n-/**\n- * Migrates a call to `setElementStyle` call either to a call to\n- * `setStyle` or `removeStyle`. or to an expression like\n- * `value == null ? removeStyle(el, key) : setStyle(el, key, value)`.\n- */\n-function migrateSetElementStyle(\n-    node: PropertyAccessCallExpression, typeChecker: ts.TypeChecker): ts.Node {\n-  const args = node.arguments;\n-  const addMethodName = 'setStyle';\n-  const removeMethodName = 'removeStyle';\n-  const lastArgType = args[2] ?\n-      typeChecker.typeToString(\n-          typeChecker.getTypeAtLocation(args[2]), node, ts.TypeFormatFlags.AddUndefined) :\n-      null;\n-\n-  // Note that for a literal null, TS considers it a `NullKeyword`,\n-  // whereas a literal `undefined` is just an Identifier.\n-  if (args.length === 2 || lastArgType === 'null' || lastArgType === 'undefined') {\n-    // If we've got a call with two arguments, or one with three arguments where the last one is\n-    // `undefined` or `null`, we can safely switch to a `removeStyle` call.\n-    const innerExpression = node.expression.expression;\n-    const topExpression = ts.createPropertyAccess(innerExpression, removeMethodName);\n-    return ts.createCall(topExpression, [], args.slice(0, 2));\n-  } else if (args.length === 3) {\n-    // We need the checks for string literals, because the type of something\n-    // like `\"blue\"` is the literal `blue`, not `string`.\n-    if (lastArgType === 'string' || lastArgType === 'number' || ts.isStringLiteral(args[2]) ||\n-        ts.isNoSubstitutionTemplateLiteral(args[2]) || ts.isNumericLiteral(args[2])) {\n-      // If we've got three arguments and the last one is a string literal or a number, we\n-      // can safely rename to `setStyle`.\n-      return renameMethodCall(node, addMethodName);\n-    } else {\n-      // Otherwise migrate to a ternary that looks like:\n-      // `value == null ? removeStyle(el, key) : setStyle(el, key, value)`\n-      const condition = ts.createBinary(args[2], ts.SyntaxKind.EqualsEqualsToken, ts.createNull());\n-      const whenNullCall = renameMethodCall(\n-          ts.createCall(node.expression, [], args.slice(0, 2)) as PropertyAccessCallExpression,\n-          removeMethodName);\n-      return ts.createConditional(condition, whenNullCall, renameMethodCall(node, addMethodName));\n-    }\n-  }\n-\n-  return node;\n-}\n-\n-/**\n- * Migrates a call to `invokeElementMethod(target, method, [arg1, arg2])` either to\n- * `target.method(arg1, arg2)` or `(target as any)[method].apply(target, [arg1, arg2])`.\n- */\n-function migrateInvokeElementMethod(node: ts.CallExpression): ts.Node {\n-  const [target, name, args] = node.arguments;\n-  const isNameStatic = ts.isStringLiteral(name) || ts.isNoSubstitutionTemplateLiteral(name);\n-  const isArgsStatic = !args || ts.isArrayLiteralExpression(args);\n-\n-  if (isNameStatic && isArgsStatic) {\n-    // If the name is a static string and the arguments are an array literal,\n-    // we can safely convert the node into a call expression.\n-    const expression = ts.createPropertyAccess(\n-        target, (name as ts.StringLiteral | ts.NoSubstitutionTemplateLiteral).text);\n-    const callArguments = args ? (args as ts.ArrayLiteralExpression).elements : [];\n-    return ts.createCall(expression, [], callArguments);\n-  } else {\n-    // Otherwise create an expression in the form of `(target as any)[name].apply(target, args)`.\n-    const asExpression = ts.createParen(\n-        ts.createAsExpression(target, ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)));\n-    const elementAccess = ts.createElementAccess(asExpression, name);\n-    const applyExpression = ts.createPropertyAccess(elementAccess, 'apply');\n-    return ts.createCall(applyExpression, [], args ? [target, args] : [target]);\n-  }\n-}\n-\n-/** Migrates a call to `createViewRoot` to whatever node was passed in as the first argument. */\n-function migrateCreateViewRoot(node: ts.CallExpression): ts.Node {\n-  return node.arguments[0];\n-}\n-\n-/** Migrates a call to `migrate` a direct call to the helper. */\n-function migrateAnimateCall() {\n-  return ts.createCall(ts.createIdentifier(HelperFunction.animate), [], []);\n-}\n-\n-/**\n- * Switches out a call to the `Renderer` to a call to one of our helper functions.\n- * Most of the helpers accept an instance of `Renderer2` as the first argument and all\n- * subsequent arguments differ.\n- * @param node Node of the original method call.\n- * @param helper Name of the helper with which to replace the original call.\n- * @param args Arguments that should be passed into the helper after the renderer argument.\n- */\n-function switchToHelperCall(\n-    node: PropertyAccessCallExpression, helper: HelperFunction,\n-    args: ts.Expression[]|ts.NodeArray<ts.Expression>): ts.Node {\n-  return ts.createCall(ts.createIdentifier(helper), [], [node.expression.expression, ...args]);\n-}"
        },
        {
            "sha": "269cb537a42e6f70b61f223d075bd000adfd0123",
            "filename": "packages/core/schematics/migrations/renderer-to-renderer2/util.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 80,
            "changes": 80,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frenderer-to-renderer2%2Futil.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,80 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {getImportSpecifier} from '../../utils/typescript/imports';\n-import {isReferenceToImport} from '../../utils/typescript/symbol';\n-\n-/**\n- * Finds typed nodes (e.g. function parameters or class properties) that are referencing the old\n- * `Renderer`, as well as calls to the `Renderer` methods.\n- */\n-export function findRendererReferences(\n-    sourceFile: ts.SourceFile, typeChecker: ts.TypeChecker,\n-    rendererImportSpecifier: ts.ImportSpecifier) {\n-  const typedNodes = new Set<ts.ParameterDeclaration|ts.PropertyDeclaration|ts.AsExpression>();\n-  const methodCalls = new Set<ts.CallExpression>();\n-  const forwardRefs = new Set<ts.Identifier>();\n-  const forwardRefSpecifier = getImportSpecifier(sourceFile, '@angular/core', 'forwardRef');\n-\n-  ts.forEachChild(sourceFile, function visitNode(node: ts.Node) {\n-    if ((ts.isParameter(node) || ts.isPropertyDeclaration(node)) &&\n-        isReferenceToImport(typeChecker, node.name, rendererImportSpecifier)) {\n-      typedNodes.add(node);\n-    } else if (\n-        ts.isAsExpression(node) &&\n-        isReferenceToImport(typeChecker, node.type, rendererImportSpecifier)) {\n-      typedNodes.add(node);\n-    } else if (ts.isCallExpression(node)) {\n-      if (ts.isPropertyAccessExpression(node.expression) &&\n-          isReferenceToImport(typeChecker, node.expression.expression, rendererImportSpecifier)) {\n-        methodCalls.add(node);\n-      } else if (\n-          // If we're dealing with a forwardRef that's returning a Renderer.\n-          forwardRefSpecifier && ts.isIdentifier(node.expression) &&\n-          isReferenceToImport(typeChecker, node.expression, forwardRefSpecifier) &&\n-          node.arguments.length) {\n-        const rendererIdentifier =\n-            findRendererIdentifierInForwardRef(typeChecker, node, rendererImportSpecifier);\n-        if (rendererIdentifier) {\n-          forwardRefs.add(rendererIdentifier);\n-        }\n-      }\n-    }\n-\n-    ts.forEachChild(node, visitNode);\n-  });\n-\n-  return {typedNodes, methodCalls, forwardRefs};\n-}\n-\n-/** Finds the identifier referring to the `Renderer` inside a `forwardRef` call expression. */\n-function findRendererIdentifierInForwardRef(\n-    typeChecker: ts.TypeChecker, node: ts.CallExpression,\n-    rendererImport: ts.ImportSpecifier|null): ts.Identifier|null {\n-  const firstArg = node.arguments[0];\n-\n-  if (ts.isArrowFunction(firstArg) && rendererImport) {\n-    // Check if the function is `forwardRef(() => Renderer)`.\n-    if (ts.isIdentifier(firstArg.body) &&\n-        isReferenceToImport(typeChecker, firstArg.body, rendererImport)) {\n-      return firstArg.body;\n-    } else if (ts.isBlock(firstArg.body) && ts.isReturnStatement(firstArg.body.statements[0])) {\n-      // Otherwise check if the expression is `forwardRef(() => { return Renderer })`.\n-      const returnStatement = firstArg.body.statements[0] as ts.ReturnStatement;\n-\n-      if (returnStatement.expression && ts.isIdentifier(returnStatement.expression) &&\n-          isReferenceToImport(typeChecker, returnStatement.expression, rendererImport)) {\n-        return returnStatement.expression;\n-      }\n-    }\n-  }\n-\n-  return null;\n-}"
        },
        {
            "sha": "58d793e1a6c52d6e7688f0dc6671ee75982d771a",
            "filename": "packages/core/schematics/migrations/router-preserve-query-params/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-preserve-query-params%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-preserve-query-params%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-preserve-query-params%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,18 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"router-preserve-query-params\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/migrations/google3:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"//packages/core/schematics/utils\",\n-        \"@npm//@angular-devkit/schematics\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "77edc68558d7dc23ac21caabc429d62a32ee79e3",
            "filename": "packages/core/schematics/migrations/router-preserve-query-params/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 35,
            "changes": 35,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-preserve-query-params%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-preserve-query-params%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-preserve-query-params%2FREADME.md?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,35 +0,0 @@\n-## Router's NavigationExtras.preserveQueryParams migration\n-\n-Previously the `NatigationExtras` property of `preserveQueryParams` defined what should be done with\n-query parameters on navigation.  This migration updates the usages of `preserveQueryParams` to\n-instead use the `queryParamsHandling` property.\n-\n-#### Before\n-```ts\n-import { Component } from '@angular/core';\n-import { Router } from '@angular/router';\n-\n-@Component({})\n-export class MyComponent {\n-  constructor(private _router: Router) {}\n-\n-  goHome() {\n-    this._router.navigate('/', {preserveQueryParams: true, skipLocationChange: 'foo'});\n-  }\n-}\n-```\n-\n-#### After\n-```ts\n-import { Component } from '@angular/core';\n-import { Router } from '@angular/router';\n-\n-@Component({})\n-export class MyComponent {\n-  constructor(private _router: Router) {}\n-\n-  goHome() {\n-    this._router.navigate('/', { queryParamsHandling: 'preserve', skipLocationChange: 'foo' });\n-  }\n-}\n-```"
        },
        {
            "sha": "3562ab1b4725c0b709945917894369a3ed48edf0",
            "filename": "packages/core/schematics/migrations/router-preserve-query-params/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 64,
            "changes": 64,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-preserve-query-params%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-preserve-query-params%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-preserve-query-params%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,64 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\n-import {relative} from 'path';\n-import ts from 'typescript';\n-\n-import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n-import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n-import {findLiteralsToMigrate, migrateLiteral} from './util';\n-\n-\n-/**\n- * Migration that switches `NavigationExtras.preserveQueryParams` to set the coresponding value via\n- * `NavigationExtras`'s `queryParamsHandling` attribute.\n- */\n-export default function(): Rule {\n-  return async (tree: Tree) => {\n-    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n-    const basePath = process.cwd();\n-    const allPaths = [...buildPaths, ...testPaths];\n-\n-    if (!allPaths.length) {\n-      throw new SchematicsException(\n-          'Could not find any tsconfig file. Cannot migrate ' +\n-          'NavigationExtras.preserveQueryParams usages.');\n-    }\n-\n-    for (const tsconfigPath of allPaths) {\n-      runPreserveQueryParamsMigration(tree, tsconfigPath, basePath);\n-    }\n-  };\n-}\n-\n-function runPreserveQueryParamsMigration(tree: Tree, tsconfigPath: string, basePath: string) {\n-  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n-  const typeChecker = program.getTypeChecker();\n-  const printer = ts.createPrinter();\n-  const sourceFiles =\n-      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n-\n-  sourceFiles.forEach(sourceFile => {\n-    const literalsToMigrate = findLiteralsToMigrate(sourceFile, typeChecker);\n-    const update = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n-\n-    literalsToMigrate.forEach((instances, methodName) => instances.forEach(instance => {\n-      const migratedNode = migrateLiteral(methodName, instance);\n-\n-      if (migratedNode !== instance) {\n-        update.remove(instance.getStart(), instance.getWidth());\n-        update.insertRight(\n-            instance.getStart(),\n-            printer.printNode(ts.EmitHint.Unspecified, migratedNode, sourceFile));\n-      }\n-    }));\n-\n-    tree.commitUpdate(update);\n-  });\n-}"
        },
        {
            "sha": "f8d92894bbba43c61a0a02a79f9a6448b60ee35a",
            "filename": "packages/core/schematics/migrations/router-preserve-query-params/util.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 105,
            "changes": 105,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-preserve-query-params%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-preserve-query-params%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Frouter-preserve-query-params%2Futil.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,105 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {getImportSpecifier} from '../../utils/typescript/imports';\n-import {isReferenceToImport} from '../../utils/typescript/symbol';\n-\n-/**\n- * Configures the methods that the migration should be looking for\n- * and the properties from `NavigationExtras` that should be preserved.\n- */\n-const methodConfig = new Set<string>(['navigate', 'createUrlTree']);\n-\n-const preserveQueryParamsKey = 'preserveQueryParams';\n-\n-export function migrateLiteral(\n-    methodName: string, node: ts.ObjectLiteralExpression): ts.ObjectLiteralExpression {\n-  const isMigratableMethod = methodConfig.has(methodName);\n-\n-  if (!isMigratableMethod) {\n-    throw Error(`Attempting to migrate unconfigured method called ${methodName}.`);\n-  }\n-\n-\n-  const propertiesToKeep: ts.ObjectLiteralElementLike[] = [];\n-  let propertyToMigrate: ts.PropertyAssignment|ts.ShorthandPropertyAssignment|undefined = undefined;\n-\n-  for (const property of node.properties) {\n-    // Only look for regular and shorthand property assignments since resolving things\n-    // like spread operators becomes too complicated for this migration.\n-    if ((ts.isPropertyAssignment(property) || ts.isShorthandPropertyAssignment(property)) &&\n-        (ts.isStringLiteralLike(property.name) || ts.isNumericLiteral(property.name) ||\n-         ts.isIdentifier(property.name)) &&\n-        (property.name.text === preserveQueryParamsKey)) {\n-      propertyToMigrate = property;\n-      continue;\n-    }\n-    propertiesToKeep.push(property);\n-  }\n-\n-  // Don't modify the node if there's nothing to migrate.\n-  if (propertyToMigrate === undefined) {\n-    return node;\n-  }\n-\n-  if ((ts.isShorthandPropertyAssignment(propertyToMigrate) &&\n-       propertyToMigrate.objectAssignmentInitializer?.kind === ts.SyntaxKind.TrueKeyword) ||\n-      (ts.isPropertyAssignment(propertyToMigrate) &&\n-       propertyToMigrate.initializer.kind === ts.SyntaxKind.TrueKeyword)) {\n-    return ts.updateObjectLiteral(\n-        node,\n-        propertiesToKeep.concat(\n-            ts.createPropertyAssignment('queryParamsHandling', ts.createIdentifier(`'preserve'`))));\n-  }\n-\n-  return ts.updateObjectLiteral(node, propertiesToKeep);\n-}\n-\n-export function findLiteralsToMigrate(sourceFile: ts.SourceFile, typeChecker: ts.TypeChecker) {\n-  const results = new Map<string, Set<ts.ObjectLiteralExpression>>(\n-      Array.from(methodConfig.keys(), key => [key, new Set()]));\n-  const routerImport = getImportSpecifier(sourceFile, '@angular/router', 'Router');\n-  const seenLiterals = new Map<ts.ObjectLiteralExpression, string>();\n-\n-  if (routerImport) {\n-    sourceFile.forEachChild(function visitNode(node: ts.Node) {\n-      // Look for calls that look like `foo.<method to migrate>` with more than one parameter.\n-      if (ts.isCallExpression(node) && node.arguments.length > 1 &&\n-          ts.isPropertyAccessExpression(node.expression) && ts.isIdentifier(node.expression.name) &&\n-          methodConfig.has(node.expression.name.text)) {\n-        // Check whether the type of the object on which the\n-        // function is called refers to the Router import.\n-        if (isReferenceToImport(typeChecker, node.expression.expression, routerImport)) {\n-          const methodName = node.expression.name.text;\n-          const parameterDeclaration =\n-              typeChecker.getTypeAtLocation(node.arguments[1]).getSymbol()?.valueDeclaration;\n-\n-          // Find the source of the object literal.\n-          if (parameterDeclaration && ts.isObjectLiteralExpression(parameterDeclaration)) {\n-            if (!seenLiterals.has(parameterDeclaration)) {\n-              results.get(methodName)!.add(parameterDeclaration);\n-              seenLiterals.set(parameterDeclaration, methodName);\n-              // If the same literal has been passed into multiple different methods, we can't\n-              // migrate it, because the supported properties are different. When we detect such\n-              // a case, we drop it from the results so that it gets ignored. If it's used multiple\n-              // times for the same method, it can still be migrated.\n-            } else if (seenLiterals.get(parameterDeclaration) !== methodName) {\n-              results.forEach(literals => literals.delete(parameterDeclaration));\n-            }\n-          }\n-        }\n-      } else {\n-        node.forEachChild(visitNode);\n-      }\n-    });\n-  }\n-\n-  return results;\n-}"
        },
        {
            "sha": "528d322366ec28e0f815793d5a38e19e2b5504cb",
            "filename": "packages/core/schematics/migrations/static-queries/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 22,
            "changes": 22,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,22 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"static-queries\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/migrations/google3:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"//packages/compiler\",\n-        \"//packages/compiler-cli\",\n-        \"//packages/core/schematics/utils\",\n-        \"@npm//@angular-devkit/core\",\n-        \"@npm//@angular-devkit/schematics\",\n-        \"@npm//@types/node\",\n-        \"@npm//rxjs\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "c5ef338f938721866cb0ee7bb51ae44167f833b4",
            "filename": "packages/core/schematics/migrations/static-queries/angular/directive_inputs.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 88,
            "changes": 88,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fangular%2Fdirective_inputs.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fangular%2Fdirective_inputs.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fangular%2Fdirective_inputs.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,88 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-import {getAngularDecorators} from '../../../utils/ng_decorators';\n-import {getPropertyNameText, hasPropertyNameText} from '../../../utils/typescript/property_name';\n-\n-/** Analyzes the given class and resolves the name of all inputs which are declared. */\n-export function getInputNamesOfClass(\n-    node: ts.ClassDeclaration, typeChecker: ts.TypeChecker): string[] {\n-  const resolvedInputSetters: string[] = [];\n-\n-  // Determines the names of all inputs defined in the current class declaration by\n-  // checking whether a given property/getter/setter has the \"@Input\" decorator applied.\n-  node.members.forEach(m => {\n-    if (!m.decorators || !m.decorators.length ||\n-        !ts.isPropertyDeclaration(m) && !ts.isSetAccessor(m) && !ts.isGetAccessor(m)) {\n-      return;\n-    }\n-\n-    const inputDecorator =\n-        getAngularDecorators(typeChecker, m.decorators!).find(d => d.name === 'Input');\n-\n-    if (inputDecorator && hasPropertyNameText(m.name)) {\n-      resolvedInputSetters.push(m.name.text);\n-    }\n-  });\n-\n-  // Besides looking for immediate setters in the current class declaration, developers\n-  // can also define inputs in the directive metadata using the \"inputs\" property. We\n-  // also need to determine these inputs which are declared in the directive metadata.\n-  const metadataInputs = getInputNamesFromMetadata(node, typeChecker);\n-\n-  if (metadataInputs) {\n-    resolvedInputSetters.push(...metadataInputs);\n-  }\n-\n-  return resolvedInputSetters;\n-}\n-\n-/**\n- * Determines the names of all inputs declared in the directive/component metadata\n- * of the given class.\n- */\n-function getInputNamesFromMetadata(\n-    node: ts.ClassDeclaration, typeChecker: ts.TypeChecker): string[]|null {\n-  if (!node.decorators || !node.decorators.length) {\n-    return null;\n-  }\n-\n-  const decorator = getAngularDecorators(typeChecker, node.decorators)\n-                        .find(d => d.name === 'Directive' || d.name === 'Component');\n-\n-  // In case no directive/component decorator could be found for this class, just\n-  // return null as there is no metadata where an input could be declared.\n-  if (!decorator) {\n-    return null;\n-  }\n-\n-  const decoratorCall = decorator.node.expression;\n-\n-  // In case the decorator does define any metadata, there is no metadata\n-  // where inputs could be declared. This is an edge case because there\n-  // always needs to be an object literal, but in case there isn't we just\n-  // want to skip the invalid decorator and return null.\n-  if (decoratorCall.arguments.length !== 1 ||\n-      !ts.isObjectLiteralExpression(decoratorCall.arguments[0])) {\n-    return null;\n-  }\n-\n-  const metadata = decoratorCall.arguments[0] as ts.ObjectLiteralExpression;\n-  const inputs = metadata.properties.filter(ts.isPropertyAssignment)\n-                     .find(p => getPropertyNameText(p.name) === 'inputs');\n-\n-  // In case there is no \"inputs\" property in the directive metadata,\n-  // just return \"null\" as no inputs can be declared for this class.\n-  if (!inputs || !ts.isArrayLiteralExpression(inputs.initializer)) {\n-    return null;\n-  }\n-\n-  return inputs.initializer.elements.filter(ts.isStringLiteralLike)\n-      .map(element => element.text.split(':')[0].trim());\n-}"
        },
        {
            "sha": "5328d438f54964c9f39209f1be1378bdc48adb93",
            "filename": "packages/core/schematics/migrations/static-queries/angular/ng_query_visitor.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 158,
            "changes": 158,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fangular%2Fng_query_visitor.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fangular%2Fng_query_visitor.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fangular%2Fng_query_visitor.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,158 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {ResolvedTemplate} from '../../../utils/ng_component_template';\n-import {getAngularDecorators} from '../../../utils/ng_decorators';\n-import {findParentClassDeclaration, getBaseTypeIdentifiers} from '../../../utils/typescript/class_declaration';\n-import {getPropertyNameText} from '../../../utils/typescript/property_name';\n-\n-import {getInputNamesOfClass} from './directive_inputs';\n-import {NgQueryDefinition, QueryType} from './query-definition';\n-\n-\n-/** Resolved metadata of a given class. */\n-export interface ClassMetadata {\n-  /** List of class declarations that derive from the given class. */\n-  derivedClasses: ts.ClassDeclaration[];\n-  /** Super class of the given class. */\n-  superClass: ts.ClassDeclaration|null;\n-  /** List of property names that declare an Angular input within the given class. */\n-  ngInputNames: string[];\n-  /** Component template that belongs to that class if present. */\n-  template?: ResolvedTemplate;\n-}\n-\n-/** Type that describes a map which can be used to get a class declaration's metadata. */\n-export type ClassMetadataMap = Map<ts.ClassDeclaration, ClassMetadata>;\n-\n-/**\n- * Visitor that can be used to determine Angular queries within given TypeScript nodes.\n- * Besides resolving queries, the visitor also records class relations and searches for\n- * Angular input setters which can be used to analyze the timing usage of a given query.\n- */\n-export class NgQueryResolveVisitor {\n-  /** Resolved Angular query definitions. */\n-  resolvedQueries = new Map<ts.SourceFile, NgQueryDefinition[]>();\n-\n-  /** Maps a class declaration to its class metadata. */\n-  classMetadata: ClassMetadataMap = new Map();\n-\n-  constructor(public typeChecker: ts.TypeChecker) {}\n-\n-  visitNode(node: ts.Node) {\n-    switch (node.kind) {\n-      case ts.SyntaxKind.PropertyDeclaration:\n-        this.visitPropertyDeclaration(node as ts.PropertyDeclaration);\n-        break;\n-      case ts.SyntaxKind.ClassDeclaration:\n-        this.visitClassDeclaration(node as ts.ClassDeclaration);\n-        break;\n-      case ts.SyntaxKind.GetAccessor:\n-      case ts.SyntaxKind.SetAccessor:\n-        this.visitAccessorDeclaration(node as ts.AccessorDeclaration);\n-        break;\n-    }\n-\n-    ts.forEachChild(node, n => this.visitNode(n));\n-  }\n-\n-  private visitPropertyDeclaration(node: ts.PropertyDeclaration) {\n-    this._recordQueryDeclaration(node, node, getPropertyNameText(node.name));\n-  }\n-\n-  private visitAccessorDeclaration(node: ts.AccessorDeclaration) {\n-    this._recordQueryDeclaration(node, null, getPropertyNameText(node.name));\n-  }\n-\n-  private visitClassDeclaration(node: ts.ClassDeclaration) {\n-    this._recordClassInputSetters(node);\n-    this._recordClassInheritances(node);\n-  }\n-\n-  private _recordQueryDeclaration(\n-      node: ts.Node, property: ts.PropertyDeclaration|null, queryName: string|null) {\n-    if (!node.decorators || !node.decorators.length) {\n-      return;\n-    }\n-\n-    const ngDecorators = getAngularDecorators(this.typeChecker, node.decorators);\n-    const queryDecorator =\n-        ngDecorators.find(({name}) => name === 'ViewChild' || name === 'ContentChild');\n-\n-    // Ensure that the current property declaration is defining a query.\n-    if (!queryDecorator) {\n-      return;\n-    }\n-\n-    const queryContainer = findParentClassDeclaration(node);\n-\n-    // If the query is not located within a class declaration, skip this node.\n-    if (!queryContainer) {\n-      return;\n-    }\n-\n-    const sourceFile = node.getSourceFile();\n-    const newQueries = this.resolvedQueries.get(sourceFile) || [];\n-\n-    this.resolvedQueries.set(sourceFile, newQueries.concat({\n-      name: queryName,\n-      type: queryDecorator.name === 'ViewChild' ? QueryType.ViewChild : QueryType.ContentChild,\n-      node,\n-      property,\n-      decorator: queryDecorator,\n-      container: queryContainer,\n-    }));\n-  }\n-\n-  private _recordClassInputSetters(node: ts.ClassDeclaration) {\n-    const resolvedInputNames = getInputNamesOfClass(node, this.typeChecker);\n-\n-    if (resolvedInputNames) {\n-      const classMetadata = this._getClassMetadata(node);\n-\n-      classMetadata.ngInputNames = resolvedInputNames;\n-      this.classMetadata.set(node, classMetadata);\n-    }\n-  }\n-\n-  private _recordClassInheritances(node: ts.ClassDeclaration) {\n-    const baseTypes = getBaseTypeIdentifiers(node);\n-\n-    if (!baseTypes || baseTypes.length !== 1) {\n-      return;\n-    }\n-\n-    const superClass = baseTypes[0];\n-    const baseClassMetadata = this._getClassMetadata(node);\n-\n-    // We need to resolve the value declaration through the resolved type as the base\n-    // class could be declared in different source files and the local symbol won't\n-    // contain a value declaration as the value is not declared locally.\n-    const symbol = this.typeChecker.getTypeAtLocation(superClass).getSymbol();\n-\n-    if (symbol && symbol.valueDeclaration && ts.isClassDeclaration(symbol.valueDeclaration)) {\n-      const extendedClass = symbol.valueDeclaration;\n-      const classMetadataExtended = this._getClassMetadata(extendedClass);\n-\n-      // Record all classes that derive from the given class. This makes it easy to\n-      // determine all classes that could potentially use inherited queries statically.\n-      classMetadataExtended.derivedClasses.push(node);\n-      this.classMetadata.set(extendedClass, classMetadataExtended);\n-\n-      // Record the super class of the current class.\n-      baseClassMetadata.superClass = extendedClass;\n-      this.classMetadata.set(node, baseClassMetadata);\n-    }\n-  }\n-\n-  private _getClassMetadata(node: ts.ClassDeclaration): ClassMetadata {\n-    return this.classMetadata.get(node) || {derivedClasses: [], superClass: null, ngInputNames: []};\n-  }\n-}"
        },
        {
            "sha": "ac867762b062956eff2d76ab780000485b9f5de2",
            "filename": "packages/core/schematics/migrations/static-queries/angular/query-definition.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 40,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fangular%2Fquery-definition.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fangular%2Fquery-definition.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fangular%2Fquery-definition.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,40 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-import {NgDecorator} from '../../../utils/ng_decorators';\n-\n-/** Timing of a given query. Either static or dynamic. */\n-export enum QueryTiming {\n-  STATIC,\n-  DYNAMIC,\n-}\n-\n-/** Type of a given query. */\n-export enum QueryType {\n-  ViewChild,\n-  ContentChild\n-}\n-\n-export interface NgQueryDefinition {\n-  /** Name of the query. Set to \"null\" in case the query name is not statically analyzable. */\n-  name: string|null;\n-  /** Type of the query definition. */\n-  type: QueryType;\n-  /** Node that declares this query. */\n-  node: ts.Node;\n-  /**\n-   * Property declaration that refers to the query value. For accessors there\n-   * is no property that is guaranteed to access the query value.\n-   */\n-  property: ts.PropertyDeclaration|null;\n-  /** Decorator that declares this as a query. */\n-  decorator: NgDecorator;\n-  /** Class declaration that holds this query. */\n-  container: ts.ClassDeclaration;\n-}"
        },
        {
            "sha": "cc50c6389a23215df359335514f3d5e7282265a4",
            "filename": "packages/core/schematics/migrations/static-queries/angular/super_class.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 27,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fangular%2Fsuper_class.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fangular%2Fsuper_class.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fangular%2Fsuper_class.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,27 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-import {ClassMetadataMap} from './ng_query_visitor';\n-\n-/**\n- * Gets all chained super-class TypeScript declarations for the given class\n- * by using the specified class metadata map.\n- */\n-export function getSuperClassDeclarations(\n-    classDecl: ts.ClassDeclaration, classMetadataMap: ClassMetadataMap) {\n-  const declarations: ts.ClassDeclaration[] = [];\n-\n-  let current = classMetadataMap.get(classDecl);\n-  while (current && current.superClass) {\n-    declarations.push(current.superClass);\n-    current = classMetadataMap.get(current.superClass);\n-  }\n-\n-  return declarations;\n-}"
        },
        {
            "sha": "bc058565b022d5a722070e72989e1599f20d3e9e",
            "filename": "packages/core/schematics/migrations/static-queries/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 274,
            "changes": 274,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,274 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {logging} from '@angular-devkit/core';\n-import {Rule, SchematicContext, SchematicsException, Tree} from '@angular-devkit/schematics';\n-import {relative} from 'path';\n-import ts from 'typescript';\n-\n-import {loadEsmModule} from '../../utils/load_esm';\n-import {NgComponentTemplateVisitor} from '../../utils/ng_component_template';\n-import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n-import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n-\n-import {NgQueryResolveVisitor} from './angular/ng_query_visitor';\n-import {QueryTemplateStrategy} from './strategies/template_strategy/template_strategy';\n-import {QueryTestStrategy} from './strategies/test_strategy/test_strategy';\n-import {TimingStrategy} from './strategies/timing-strategy';\n-import {QueryUsageStrategy} from './strategies/usage_strategy/usage_strategy';\n-import {getTransformedQueryCallExpr} from './transform';\n-\n-enum SELECTED_STRATEGY {\n-  TEMPLATE,\n-  USAGE,\n-  TESTS,\n-}\n-\n-interface AnalyzedProject {\n-  program: ts.Program;\n-  host: ts.CompilerHost;\n-  queryVisitor: NgQueryResolveVisitor;\n-  sourceFiles: ts.SourceFile[];\n-  basePath: string;\n-  typeChecker: ts.TypeChecker;\n-  tsconfigPath: string;\n-}\n-\n-/** Entry point for the V8 static-query migration. */\n-export default function(): Rule {\n-  return runMigration;\n-}\n-\n-/** Runs the V8 migration static-query migration for all determined TypeScript projects. */\n-async function runMigration(tree: Tree, context: SchematicContext) {\n-  const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n-  const basePath = process.cwd();\n-  const logger = context.logger;\n-\n-  if (!buildPaths.length && !testPaths.length) {\n-    throw new SchematicsException(\n-        'Could not find any tsconfig file. Cannot migrate queries ' +\n-        'to add static flag.');\n-  }\n-\n-  const analyzedFiles = new Set<string>();\n-  const buildProjects = new Set<AnalyzedProject>();\n-  const failures = [];\n-  const strategy = process.env['NG_STATIC_QUERY_USAGE_STRATEGY'] === 'true' ?\n-      SELECTED_STRATEGY.USAGE :\n-      SELECTED_STRATEGY.TEMPLATE;\n-\n-  for (const tsconfigPath of buildPaths) {\n-    const project = analyzeProject(tree, tsconfigPath, basePath, analyzedFiles, logger);\n-    if (project) {\n-      buildProjects.add(project);\n-    }\n-  }\n-\n-  let compilerModule;\n-  try {\n-    // Load ESM `@angular/compiler` using the TypeScript dynamic import workaround.\n-    // Once TypeScript provides support for keeping the dynamic import this workaround can be\n-    // changed to a direct dynamic import.\n-    compilerModule = await loadEsmModule<typeof import('@angular/compiler')>('@angular/compiler');\n-  } catch (e) {\n-    throw new SchematicsException(\n-        `Unable to load the '@angular/compiler' package. Details: ${e.message}`);\n-  }\n-\n-  let compilerCliModule;\n-  try {\n-    // Load ESM `@angular/compiler-cli` using the TypeScript dynamic import workaround.\n-    // Once TypeScript provides support for keeping the dynamic import this workaround can be\n-    // changed to a direct dynamic import.\n-    compilerCliModule =\n-        await loadEsmModule<typeof import('@angular/compiler-cli')>('@angular/compiler-cli');\n-  } catch (e) {\n-    throw new SchematicsException(\n-        `Unable to load the '@angular/compiler' package. Details: ${e.message}`);\n-  }\n-\n-  if (buildProjects.size) {\n-    for (let project of Array.from(buildProjects.values())) {\n-      failures.push(...await runStaticQueryMigration(\n-          tree, project, strategy, logger, compilerModule, compilerCliModule));\n-    }\n-  }\n-\n-  // For the \"test\" tsconfig projects we always want to use the test strategy as\n-  // we can't detect the proper timing within spec files.\n-  for (const tsconfigPath of testPaths) {\n-    const project = await analyzeProject(tree, tsconfigPath, basePath, analyzedFiles, logger);\n-    if (project) {\n-      failures.push(...await runStaticQueryMigration(\n-          tree, project, SELECTED_STRATEGY.TESTS, logger, compilerModule, compilerCliModule));\n-    }\n-  }\n-\n-  if (failures.length) {\n-    logger.info('');\n-    logger.info('Some queries could not be migrated automatically. Please go');\n-    logger.info('through these manually and apply the appropriate timing.');\n-    logger.info('For more info on how to choose a flag, please see: ');\n-    logger.info('https://v8.angular.io/guide/static-query-migration');\n-    failures.forEach(failure => logger.warn(`   ${failure}`));\n-  }\n-}\n-\n-/**\n- * Analyzes the given TypeScript project by looking for queries that need to be\n- * migrated. In case there are no queries that can be migrated, null is returned.\n- */\n-function analyzeProject(\n-    tree: Tree, tsconfigPath: string, basePath: string, analyzedFiles: Set<string>,\n-    logger: logging.LoggerApi): AnalyzedProject|null {\n-  const {program, host} = createMigrationProgram(tree, tsconfigPath, basePath);\n-  const syntacticDiagnostics = program.getSyntacticDiagnostics();\n-\n-  // Syntactic TypeScript errors can throw off the query analysis and therefore we want\n-  // to notify the developer that we couldn't analyze parts of the project. Developers\n-  // can just re-run the migration after fixing these failures.\n-  if (syntacticDiagnostics.length) {\n-    logger.warn(\n-        `\\nTypeScript project \"${tsconfigPath}\" has syntactical errors which could cause ` +\n-        `an incomplete migration. Please fix the following failures and rerun the migration:`);\n-    logger.error(ts.formatDiagnostics(syntacticDiagnostics, host));\n-    logger.info(\n-        'Migration can be rerun with: \"ng update @angular/core --from 7 --to 8 --migrate-only\"\\n');\n-  }\n-\n-  const typeChecker = program.getTypeChecker();\n-  const sourceFiles =\n-      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n-  const queryVisitor = new NgQueryResolveVisitor(typeChecker);\n-\n-  // Analyze all project source-files and collect all queries that\n-  // need to be migrated.\n-  sourceFiles.forEach(sourceFile => {\n-    const relativePath = relative(basePath, sourceFile.fileName);\n-\n-    // Only look for queries within the current source files if the\n-    // file has not been analyzed before.\n-    if (!analyzedFiles.has(relativePath)) {\n-      analyzedFiles.add(relativePath);\n-      queryVisitor.visitNode(sourceFile);\n-    }\n-  });\n-\n-  if (queryVisitor.resolvedQueries.size === 0) {\n-    return null;\n-  }\n-\n-  return {program, host, tsconfigPath, typeChecker, basePath, queryVisitor, sourceFiles};\n-}\n-\n-/**\n- * Runs the static query migration for the given project. The schematic analyzes all\n- * queries within the project and sets up the query timing based on the current usage\n- * of the query property. e.g. a view query that is not used in any lifecycle hook does\n- * not need to be static and can be set up with \"static: false\".\n- */\n-async function runStaticQueryMigration(\n-    tree: Tree, project: AnalyzedProject, selectedStrategy: SELECTED_STRATEGY,\n-    logger: logging.LoggerApi, compilerModule: typeof import('@angular/compiler'),\n-    compilerCliModule: typeof import('@angular/compiler-cli')): Promise<string[]> {\n-  const {sourceFiles, typeChecker, host, queryVisitor, tsconfigPath, basePath} = project;\n-  const printer = ts.createPrinter();\n-  const failureMessages: string[] = [];\n-  const templateVisitor = new NgComponentTemplateVisitor(typeChecker);\n-\n-  // If the \"usage\" strategy is selected, we also need to add the query visitor\n-  // to the analysis visitors so that query usage in templates can be also checked.\n-  if (selectedStrategy === SELECTED_STRATEGY.USAGE) {\n-    sourceFiles.forEach(s => templateVisitor.visitNode(s));\n-  }\n-\n-  const {resolvedQueries, classMetadata} = queryVisitor;\n-  const {resolvedTemplates} = templateVisitor;\n-\n-  if (selectedStrategy === SELECTED_STRATEGY.USAGE) {\n-    // Add all resolved templates to the class metadata if the usage strategy is used. This\n-    // is necessary in order to be able to check component templates for static query usage.\n-    resolvedTemplates.forEach(template => {\n-      if (classMetadata.has(template.container)) {\n-        classMetadata.get(template.container)!.template = template;\n-      }\n-    });\n-  }\n-\n-  let strategy: TimingStrategy;\n-  if (selectedStrategy === SELECTED_STRATEGY.USAGE) {\n-    strategy = new QueryUsageStrategy(classMetadata, typeChecker, compilerModule);\n-  } else if (selectedStrategy === SELECTED_STRATEGY.TESTS) {\n-    strategy = new QueryTestStrategy();\n-  } else {\n-    strategy = new QueryTemplateStrategy(\n-        tsconfigPath, classMetadata, host, compilerModule, compilerCliModule);\n-  }\n-\n-  try {\n-    strategy.setup();\n-  } catch (e) {\n-    if (selectedStrategy === SELECTED_STRATEGY.TEMPLATE) {\n-      logger.warn(\n-          `\\nThe template migration strategy uses the Angular compiler ` +\n-          `internally and therefore projects that no longer build successfully after ` +\n-          `the update cannot use the template migration strategy. Please ensure ` +\n-          `there are no AOT compilation errors.\\n`);\n-    }\n-    // In case the strategy could not be set up properly, we just exit the\n-    // migration. We don't want to throw an exception as this could mean\n-    // that other migrations are interrupted.\n-    logger.warn(\n-        `Could not setup migration strategy for \"${project.tsconfigPath}\". The ` +\n-        `following error has been reported:\\n`);\n-    logger.error(`${e.toString()}\\n`);\n-    logger.info(\n-        'Migration can be rerun with: \"ng update @angular/core --from 7 --to 8 --migrate-only\"\\n');\n-    return [];\n-  }\n-\n-  // Walk through all source files that contain resolved queries and update\n-  // the source files if needed. Note that we need to update multiple queries\n-  // within a source file within the same recorder in order to not throw off\n-  // the TypeScript node offsets.\n-  resolvedQueries.forEach((queries, sourceFile) => {\n-    const relativePath = relative(basePath, sourceFile.fileName);\n-    const update = tree.beginUpdate(relativePath);\n-\n-    // Compute the query timing for all resolved queries and update the\n-    // query definitions to explicitly set the determined query timing.\n-    queries.forEach(q => {\n-      const queryExpr = q.decorator.node.expression;\n-      const {timing, message} = strategy.detectTiming(q);\n-      const result = getTransformedQueryCallExpr(q, timing, !!message);\n-\n-      if (!result) {\n-        return;\n-      }\n-\n-      const newText = printer.printNode(ts.EmitHint.Unspecified, result.node, sourceFile);\n-\n-      // Replace the existing query decorator call expression with the updated\n-      // call expression node.\n-      update.remove(queryExpr.getStart(), queryExpr.getWidth());\n-      update.insertRight(queryExpr.getStart(), newText);\n-\n-      if (result.failureMessage || message) {\n-        const {line, character} =\n-            ts.getLineAndCharacterOfPosition(sourceFile, q.decorator.node.getStart());\n-        failureMessages.push(\n-            `${relativePath}@${line + 1}:${character + 1}: ${result.failureMessage || message}`);\n-      }\n-    });\n-\n-    tree.commitUpdate(update);\n-  });\n-\n-  return failureMessages;\n-}"
        },
        {
            "sha": "054c37fa26feb9a7a4c018996dcbe4a3bd7c3429",
            "filename": "packages/core/schematics/migrations/static-queries/strategies/template_strategy/template_strategy.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 238,
            "changes": 238,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Ftemplate_strategy%2Ftemplate_strategy.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Ftemplate_strategy%2Ftemplate_strategy.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Ftemplate_strategy%2Ftemplate_strategy.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,238 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import type {AotCompiler, CompileDirectiveMetadata, CompileMetadataResolver, CompileNgModuleMetadata, CompileStylesheetMetadata, NgAnalyzedModules, QueryMatch, StaticSymbol, TemplateAst} from '@angular/compiler';\n-import {resolve} from 'path';\n-import ts from 'typescript';\n-\n-import {ClassMetadataMap} from '../../angular/ng_query_visitor';\n-import {NgQueryDefinition, QueryTiming, QueryType} from '../../angular/query-definition';\n-import {TimingResult, TimingStrategy} from '../timing-strategy';\n-\n-const QUERY_NOT_DECLARED_IN_COMPONENT_MESSAGE = 'Timing could not be determined. This happens ' +\n-    'if the query is not declared in any component.';\n-\n-export class QueryTemplateStrategy implements TimingStrategy {\n-  private compiler: AotCompiler|null = null;\n-  private metadataResolver: CompileMetadataResolver|null = null;\n-  private analyzedQueries = new Map<string, QueryTiming>();\n-\n-  constructor(\n-      private projectPath: string, private classMetadata: ClassMetadataMap,\n-      private host: ts.CompilerHost, private compilerModule: typeof import('@angular/compiler'),\n-      private compilerCliModule: typeof import('@angular/compiler-cli')) {}\n-\n-  /**\n-   * Sets up the template strategy by creating the AngularCompilerProgram. Returns false if\n-   * the AOT compiler program could not be created due to failure diagnostics.\n-   */\n-  setup() {\n-    const {rootNames, options} = this.compilerCliModule.readConfiguration(this.projectPath);\n-\n-    // https://github.com/angular/angular/commit/ec4381dd401f03bded652665b047b6b90f2b425f made Ivy\n-    // the default. This breaks the assumption that \"createProgram\" from compiler-cli returns the\n-    // NGC program. In order to ensure that the migration runs properly, we set \"enableIvy\" to\n-    // false.\n-    options.enableIvy = false;\n-\n-    const aotProgram = this.compilerCliModule.createProgram({rootNames, options, host: this.host});\n-\n-    // The \"AngularCompilerProgram\" does not expose the \"AotCompiler\" instance, nor does it\n-    // expose the logic that is necessary to analyze the determined modules. We work around\n-    // this by just accessing the necessary private properties using the bracket notation.\n-    this.compiler = (aotProgram as any)['compiler'];\n-    this.metadataResolver = this.compiler!['_metadataResolver'];\n-\n-    // Modify the \"DirectiveNormalizer\" to not normalize any referenced external stylesheets.\n-    // This is necessary because in CLI projects preprocessor files are commonly referenced\n-    // and we don't want to parse them in order to extract relative style references. This\n-    // breaks the analysis of the project because we instantiate a standalone AOT compiler\n-    // program which does not contain the custom logic by the Angular CLI Webpack compiler plugin.\n-    const directiveNormalizer = this.metadataResolver!['_directiveNormalizer'];\n-    directiveNormalizer['_normalizeStylesheet'] = (metadata: CompileStylesheetMetadata) => {\n-      return new this.compilerModule.CompileStylesheetMetadata(\n-          {styles: metadata.styles, styleUrls: [], moduleUrl: metadata.moduleUrl!});\n-    };\n-\n-    // Retrieves the analyzed modules of the current program. This data can be\n-    // used to determine the timing for registered queries.\n-    const analyzedModules = (aotProgram as any)['analyzedModules'] as NgAnalyzedModules;\n-\n-    const ngStructuralDiagnostics = aotProgram.getNgStructuralDiagnostics();\n-    if (ngStructuralDiagnostics.length) {\n-      throw new Error(this.compilerCliModule.formatDiagnostics(ngStructuralDiagnostics, this.host));\n-    }\n-\n-    analyzedModules.files.forEach(file => {\n-      file.directives.forEach(directive => this._analyzeDirective(directive, analyzedModules));\n-    });\n-  }\n-\n-  /** Analyzes a given directive by determining the timing of all matched view queries. */\n-  private _analyzeDirective(symbol: StaticSymbol, analyzedModules: NgAnalyzedModules) {\n-    const metadata = this.metadataResolver!.getDirectiveMetadata(symbol);\n-    const ngModule = analyzedModules.ngModuleByPipeOrDirective.get(symbol);\n-\n-    if (!metadata.isComponent || !ngModule) {\n-      return;\n-    }\n-\n-    const parsedTemplate = this._parseTemplate(metadata, ngModule);\n-    const queryTimingMap = this.findStaticQueryIds(parsedTemplate);\n-    const {staticQueryIds} = staticViewQueryIds(queryTimingMap);\n-\n-    metadata.viewQueries.forEach((query, index) => {\n-      // Query ids are computed by adding \"one\" to the index. This is done within\n-      // the \"view_compiler.ts\" in order to support using a bloom filter for queries.\n-      const queryId = index + 1;\n-      const queryKey =\n-          this._getViewQueryUniqueKey(symbol.filePath, symbol.name, query.propertyName);\n-      this.analyzedQueries.set(\n-          queryKey, staticQueryIds.has(queryId) ? QueryTiming.STATIC : QueryTiming.DYNAMIC);\n-    });\n-  }\n-\n-  /** Detects the timing of the query definition. */\n-  detectTiming(query: NgQueryDefinition): TimingResult {\n-    if (query.type === QueryType.ContentChild) {\n-      return {timing: null, message: 'Content queries cannot be migrated automatically.'};\n-    } else if (!query.name) {\n-      // In case the query property name is not statically analyzable, we mark this\n-      // query as unresolved. NGC currently skips these view queries as well.\n-      return {timing: null, message: 'Query is not statically analyzable.'};\n-    }\n-\n-    const propertyName = query.name;\n-    const classMetadata = this.classMetadata.get(query.container);\n-\n-    // In case there is no class metadata or there are no derived classes that\n-    // could access the current query, we just look for the query analysis of\n-    // the class that declares the query. e.g. only the template of the class\n-    // that declares the view query affects the query timing.\n-    if (!classMetadata || !classMetadata.derivedClasses.length) {\n-      const timing = this._getQueryTimingFromClass(query.container, propertyName);\n-\n-      if (timing === null) {\n-        return {timing: null, message: QUERY_NOT_DECLARED_IN_COMPONENT_MESSAGE};\n-      }\n-\n-      return {timing};\n-    }\n-\n-    let resolvedTiming: QueryTiming|null = null;\n-    let timingMismatch = false;\n-\n-    // In case there are multiple components that use the same query (e.g. through inheritance),\n-    // we need to check if all components use the query with the same timing. If that is not\n-    // the case, the query timing is ambiguous and the developer needs to fix the query manually.\n-    [query.container, ...classMetadata.derivedClasses].forEach(classDecl => {\n-      const classTiming = this._getQueryTimingFromClass(classDecl, propertyName);\n-\n-      if (classTiming === null) {\n-        return;\n-      }\n-\n-      // In case there is no resolved timing yet, save the new timing. Timings from other\n-      // components that use the query with a different timing, cause the timing to be\n-      // mismatched. In that case we can't detect a working timing for all components.\n-      if (resolvedTiming === null) {\n-        resolvedTiming = classTiming;\n-      } else if (resolvedTiming !== classTiming) {\n-        timingMismatch = true;\n-      }\n-    });\n-\n-    if (resolvedTiming === null) {\n-      return {timing: QueryTiming.DYNAMIC, message: QUERY_NOT_DECLARED_IN_COMPONENT_MESSAGE};\n-    } else if (timingMismatch) {\n-      return {timing: null, message: 'Multiple components use the query with different timings.'};\n-    }\n-    return {timing: resolvedTiming};\n-  }\n-\n-  /**\n-   * Gets the timing that has been resolved for a given query when it's used within the\n-   * specified class declaration. e.g. queries from an inherited class can be used.\n-   */\n-  private _getQueryTimingFromClass(classDecl: ts.ClassDeclaration, queryName: string): QueryTiming\n-      |null {\n-    if (!classDecl.name) {\n-      return null;\n-    }\n-    const filePath = classDecl.getSourceFile().fileName;\n-    const queryKey = this._getViewQueryUniqueKey(filePath, classDecl.name.text, queryName);\n-\n-    if (this.analyzedQueries.has(queryKey)) {\n-      return this.analyzedQueries.get(queryKey)!;\n-    }\n-    return null;\n-  }\n-\n-  private _parseTemplate(component: CompileDirectiveMetadata, ngModule: CompileNgModuleMetadata):\n-      TemplateAst[] {\n-    return this\n-        .compiler!['_parseTemplate'](component, ngModule, ngModule.transitiveModule.directives)\n-        .template;\n-  }\n-\n-  private _getViewQueryUniqueKey(filePath: string, className: string, propName: string) {\n-    return `${resolve(filePath)}#${className}-${propName}`;\n-  }\n-\n-  /** Figures out which queries are static and which ones are dynamic. */\n-  private findStaticQueryIds(\n-      nodes: TemplateAst[], result = new Map<TemplateAst, StaticAndDynamicQueryIds>()):\n-      Map<TemplateAst, StaticAndDynamicQueryIds> {\n-    nodes.forEach((node) => {\n-      const staticQueryIds = new Set<number>();\n-      const dynamicQueryIds = new Set<number>();\n-      let queryMatches: QueryMatch[] = undefined!;\n-      if (node instanceof this.compilerModule.ElementAst) {\n-        this.findStaticQueryIds(node.children, result);\n-        node.children.forEach((child) => {\n-          const childData = result.get(child)!;\n-          childData.staticQueryIds.forEach(queryId => staticQueryIds.add(queryId));\n-          childData.dynamicQueryIds.forEach(queryId => dynamicQueryIds.add(queryId));\n-        });\n-        queryMatches = node.queryMatches;\n-      } else if (node instanceof this.compilerModule.EmbeddedTemplateAst) {\n-        this.findStaticQueryIds(node.children, result);\n-        node.children.forEach((child) => {\n-          const childData = result.get(child)!;\n-          childData.staticQueryIds.forEach(queryId => dynamicQueryIds.add(queryId));\n-          childData.dynamicQueryIds.forEach(queryId => dynamicQueryIds.add(queryId));\n-        });\n-        queryMatches = node.queryMatches;\n-      }\n-      if (queryMatches) {\n-        queryMatches.forEach((match) => staticQueryIds.add(match.queryId));\n-      }\n-      dynamicQueryIds.forEach(queryId => staticQueryIds.delete(queryId));\n-      result.set(node, {staticQueryIds, dynamicQueryIds});\n-    });\n-    return result;\n-  }\n-}\n-\n-interface StaticAndDynamicQueryIds {\n-  staticQueryIds: Set<number>;\n-  dynamicQueryIds: Set<number>;\n-}\n-\n-/** Splits queries into static and dynamic. */\n-function staticViewQueryIds(nodeStaticQueryIds: Map<TemplateAst, StaticAndDynamicQueryIds>):\n-    StaticAndDynamicQueryIds {\n-  const staticQueryIds = new Set<number>();\n-  const dynamicQueryIds = new Set<number>();\n-  Array.from(nodeStaticQueryIds.values()).forEach((entry) => {\n-    entry.staticQueryIds.forEach(queryId => staticQueryIds.add(queryId));\n-    entry.dynamicQueryIds.forEach(queryId => dynamicQueryIds.add(queryId));\n-  });\n-  dynamicQueryIds.forEach(queryId => staticQueryIds.delete(queryId));\n-  return {staticQueryIds, dynamicQueryIds};\n-}"
        },
        {
            "sha": "7f39f3bdee7cea8efd4cd875e9e6c1e0a969dcda",
            "filename": "packages/core/schematics/migrations/static-queries/strategies/test_strategy/test_strategy.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 28,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Ftest_strategy%2Ftest_strategy.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Ftest_strategy%2Ftest_strategy.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Ftest_strategy%2Ftest_strategy.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,28 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {NgQueryDefinition} from '../../angular/query-definition';\n-import {TimingResult, TimingStrategy} from '../timing-strategy';\n-\n-/**\n- * Query timing strategy that is used for queries used within test files. The query\n- * timing is not analyzed for test files as the template strategy cannot work within\n- * spec files (due to missing component modules) and the usage strategy is not capable\n- * of detecting the timing of queries based on how they are used in tests.\n- */\n-export class QueryTestStrategy implements TimingStrategy {\n-  setup() {}\n-\n-  /**\n-   * Detects the timing for a given query. For queries within tests, we always\n-   * add a TODO and print a message saying that the timing can't be detected for tests.\n-   */\n-  detectTiming(query: NgQueryDefinition): TimingResult {\n-    return {timing: null, message: 'Timing within tests cannot be detected.'};\n-  }\n-}"
        },
        {
            "sha": "5db65156dd92152267c9ef83ff81878676857c78",
            "filename": "packages/core/schematics/migrations/static-queries/strategies/timing-strategy.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 21,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Ftiming-strategy.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Ftiming-strategy.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Ftiming-strategy.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,21 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {NgQueryDefinition, QueryTiming} from '../angular/query-definition';\n-\n-export interface TimingStrategy {\n-  /** Sets up the given strategy. Throws if the strategy could not be set up. */\n-  setup(): void;\n-  /** Detects the timing result for a given query. */\n-  detectTiming(query: NgQueryDefinition): TimingResult;\n-}\n-\n-export type TimingResult = {\n-  timing: QueryTiming|null;\n-  message?: string;\n-};"
        },
        {
            "sha": "cda8ea8b3889e5c21cfa7a48b98956c878bbfbdf",
            "filename": "packages/core/schematics/migrations/static-queries/strategies/usage_strategy/declaration_usage_visitor.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 420,
            "changes": 420,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Fusage_strategy%2Fdeclaration_usage_visitor.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Fusage_strategy%2Fdeclaration_usage_visitor.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Fusage_strategy%2Fdeclaration_usage_visitor.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,420 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-import {isFunctionLikeDeclaration, unwrapExpression} from '../../../../utils/typescript/functions';\n-import {getPropertyNameText} from '../../../../utils/typescript/property_name';\n-\n-export type FunctionContext = Map<ts.Node, ts.Node>;\n-\n-export enum ResolvedUsage {\n-  SYNCHRONOUS,\n-  ASYNCHRONOUS,\n-  AMBIGUOUS,\n-}\n-\n-/**\n- * List of TypeScript syntax tokens that can be used within a binary expression as\n- * compound assignment. These imply a read and write of the left-side expression.\n- */\n-const BINARY_COMPOUND_TOKENS = [\n-  ts.SyntaxKind.CaretEqualsToken,\n-  ts.SyntaxKind.AsteriskEqualsToken,\n-  ts.SyntaxKind.AmpersandEqualsToken,\n-  ts.SyntaxKind.BarEqualsToken,\n-  ts.SyntaxKind.AsteriskAsteriskEqualsToken,\n-  ts.SyntaxKind.PlusEqualsToken,\n-  ts.SyntaxKind.MinusEqualsToken,\n-  ts.SyntaxKind.SlashEqualsToken,\n-];\n-\n-/**\n- * List of known asynchronous external call expressions which aren't analyzable\n- * but are guaranteed to not execute the passed argument synchronously.\n- */\n-const ASYNC_EXTERNAL_CALLS = [\n-  {parent: ['Promise'], name: 'then'},\n-  {parent: ['Promise'], name: 'catch'},\n-  {parent: [null, 'Window'], name: 'requestAnimationFrame'},\n-  {parent: [null, 'Window'], name: 'setTimeout'},\n-  {parent: [null, 'Window'], name: 'setInterval'},\n-  {parent: ['*'], name: 'addEventListener'},\n-];\n-\n-/**\n- * Class that can be used to determine if a given TypeScript node is used within\n- * other given TypeScript nodes. This is achieved by walking through all children\n- * of the given node and checking for usages of the given declaration. The visitor\n- * also handles potential control flow changes caused by call/new expressions.\n- */\n-export class DeclarationUsageVisitor {\n-  /** Set of visited symbols that caused a jump in control flow. */\n-  private visitedJumpExprNodes = new Set<ts.Node>();\n-\n-  /**\n-   * Queue of nodes that need to be checked for declaration usage and\n-   * are guaranteed to be executed synchronously.\n-   */\n-  private nodeQueue: ts.Node[] = [];\n-\n-  /**\n-   * Nodes which need to be checked for declaration usage but aren't\n-   * guaranteed to execute synchronously.\n-   */\n-  private ambiguousNodeQueue: ts.Node[] = [];\n-\n-  /**\n-   * Function context that holds the TypeScript node values for all parameters\n-   * of the currently analyzed function block.\n-   */\n-  private context: FunctionContext = new Map();\n-\n-  constructor(\n-      private declaration: ts.Node, private typeChecker: ts.TypeChecker,\n-      private baseContext: FunctionContext = new Map()) {}\n-\n-  private isReferringToSymbol(node: ts.Node): boolean {\n-    const symbol = this.typeChecker.getSymbolAtLocation(node);\n-    return !!symbol && symbol.valueDeclaration === this.declaration;\n-  }\n-\n-  private addJumpExpressionToQueue(callExpression: ts.CallExpression) {\n-    const node = unwrapExpression(callExpression.expression);\n-\n-    // In case the given expression is already referring to a function-like declaration,\n-    // we don't need to resolve the symbol of the expression as the jump expression is\n-    // defined inline and we can just add the given node to the queue.\n-    if (isFunctionLikeDeclaration(node) && node.body) {\n-      this.nodeQueue.push(node.body);\n-      return;\n-    }\n-\n-    const callExprSymbol = this._getDeclarationSymbolOfNode(node);\n-\n-    if (!callExprSymbol || !callExprSymbol.valueDeclaration) {\n-      this.peekIntoJumpExpression(callExpression);\n-      return;\n-    }\n-\n-    const expressionDecl = this._resolveNodeFromContext(callExprSymbol.valueDeclaration);\n-\n-    // Note that we should not add previously visited symbols to the queue as\n-    // this could cause cycles.\n-    if (!isFunctionLikeDeclaration(expressionDecl) ||\n-        this.visitedJumpExprNodes.has(expressionDecl) || !expressionDecl.body) {\n-      this.peekIntoJumpExpression(callExpression);\n-      return;\n-    }\n-\n-    // Update the context for the new jump expression and its specified arguments.\n-    this._updateContext(callExpression.arguments, expressionDecl.parameters);\n-\n-    this.visitedJumpExprNodes.add(expressionDecl);\n-    this.nodeQueue.push(expressionDecl.body);\n-  }\n-\n-  private addNewExpressionToQueue(node: ts.NewExpression) {\n-    const newExprSymbol = this._getDeclarationSymbolOfNode(unwrapExpression(node.expression));\n-\n-    // Only handle new expressions which resolve to classes. Technically \"new\" could\n-    // also call void functions or objects with a constructor signature. Also note that\n-    // we should not visit already visited symbols as this could cause cycles.\n-    if (!newExprSymbol || !newExprSymbol.valueDeclaration ||\n-        !ts.isClassDeclaration(newExprSymbol.valueDeclaration)) {\n-      this.peekIntoJumpExpression(node);\n-      return;\n-    }\n-\n-    const targetConstructor =\n-        newExprSymbol.valueDeclaration.members.find(ts.isConstructorDeclaration);\n-\n-    if (targetConstructor && targetConstructor.body &&\n-        !this.visitedJumpExprNodes.has(targetConstructor)) {\n-      // Update the context for the new expression and its specified constructor\n-      // parameters if arguments are passed to the class constructor.\n-      if (node.arguments) {\n-        this._updateContext(node.arguments, targetConstructor.parameters);\n-      }\n-\n-      this.visitedJumpExprNodes.add(targetConstructor);\n-      this.nodeQueue.push(targetConstructor.body);\n-    } else {\n-      this.peekIntoJumpExpression(node);\n-    }\n-  }\n-\n-  private visitPropertyAccessors(\n-      node: ts.PropertyAccessExpression, checkSetter: boolean, checkGetter: boolean) {\n-    const propertySymbol = this._getPropertyAccessSymbol(node);\n-\n-    if (propertySymbol?.declarations === undefined || propertySymbol.declarations.length === 0 ||\n-        (propertySymbol.getFlags() & ts.SymbolFlags.Accessor) === 0) {\n-      return;\n-    }\n-\n-    // Since we checked the symbol flags and the symbol is describing an accessor, the\n-    // declarations are guaranteed to only contain the getters and setters.\n-    const accessors = propertySymbol.declarations as ts.AccessorDeclaration[];\n-\n-    accessors\n-        .filter(\n-            d => (checkSetter && ts.isSetAccessor(d) || checkGetter && ts.isGetAccessor(d)) &&\n-                d.body && !this.visitedJumpExprNodes.has(d))\n-        .forEach(d => {\n-          this.visitedJumpExprNodes.add(d);\n-          this.nodeQueue.push(d.body!);\n-        });\n-  }\n-\n-  private visitBinaryExpression(node: ts.BinaryExpression): boolean {\n-    const leftExpr = unwrapExpression(node.left);\n-\n-    if (!ts.isPropertyAccessExpression(leftExpr)) {\n-      return false;\n-    }\n-\n-    if (BINARY_COMPOUND_TOKENS.indexOf(node.operatorToken.kind) !== -1) {\n-      // Compound assignments always cause the getter and setter to be called.\n-      // Therefore we need to check the setter and getter of the property access.\n-      this.visitPropertyAccessors(leftExpr, /* setter */ true, /* getter */ true);\n-    } else if (node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {\n-      // Value assignments using the equals token only cause the \"setter\" to be called.\n-      // Therefore we need to analyze the setter declaration of the property access.\n-      this.visitPropertyAccessors(leftExpr, /* setter */ true, /* getter */ false);\n-    } else {\n-      // If the binary expression is not an assignment, it's a simple property read and\n-      // we need to check the getter declaration if present.\n-      this.visitPropertyAccessors(leftExpr, /* setter */ false, /* getter */ true);\n-    }\n-    return true;\n-  }\n-\n-  getResolvedNodeUsage(searchNode: ts.Node): ResolvedUsage {\n-    this.nodeQueue = [searchNode];\n-    this.visitedJumpExprNodes.clear();\n-    this.context.clear();\n-\n-    // Copy base context values into the current function block context. The\n-    // base context is useful if nodes need to be mapped to other nodes. e.g.\n-    // abstract super class methods are mapped to their implementation node of\n-    // the derived class.\n-    this.baseContext.forEach((value, key) => this.context.set(key, value));\n-\n-    return this.isSynchronouslyUsedInNode(searchNode);\n-  }\n-\n-  private isSynchronouslyUsedInNode(searchNode: ts.Node): ResolvedUsage {\n-    this.ambiguousNodeQueue = [];\n-\n-    while (this.nodeQueue.length) {\n-      const node = this.nodeQueue.shift()!;\n-\n-      if (ts.isIdentifier(node) && this.isReferringToSymbol(node)) {\n-        return ResolvedUsage.SYNCHRONOUS;\n-      }\n-\n-      // Handle call expressions within TypeScript nodes that cause a jump in control\n-      // flow. We resolve the call expression value declaration and add it to the node queue.\n-      if (ts.isCallExpression(node)) {\n-        this.addJumpExpressionToQueue(node);\n-      }\n-\n-      // Handle new expressions that cause a jump in control flow. We resolve the\n-      // constructor declaration of the target class and add it to the node queue.\n-      if (ts.isNewExpression(node)) {\n-        this.addNewExpressionToQueue(node);\n-      }\n-\n-      // We also need to handle binary expressions where a value can be either assigned to\n-      // the property, or a value is read from a property expression. Depending on the\n-      // binary expression operator, setters or getters need to be analyzed.\n-      if (ts.isBinaryExpression(node)) {\n-        // In case the binary expression contained a property expression on the left side, we\n-        // don't want to continue visiting this property expression on its own. This is necessary\n-        // because visiting the expression on its own causes a loss of context. e.g. property\n-        // access expressions *do not* always cause a value read (e.g. property assignments)\n-        if (this.visitBinaryExpression(node)) {\n-          this.nodeQueue.push(node.right);\n-          continue;\n-        }\n-      }\n-\n-      // Handle property access expressions. Property expressions which are part of binary\n-      // expressions won't be added to the node queue, so these access expressions are\n-      // guaranteed to be \"read\" accesses and we need to check the \"getter\" declaration.\n-      if (ts.isPropertyAccessExpression(node)) {\n-        this.visitPropertyAccessors(node, /* setter */ false, /* getter */ true);\n-      }\n-\n-      // Do not visit nodes that declare a block of statements but are not executed\n-      // synchronously (e.g. function declarations). We only want to check TypeScript\n-      // nodes which are synchronously executed in the control flow.\n-      if (!isFunctionLikeDeclaration(node)) {\n-        this.nodeQueue.push(...node.getChildren());\n-      }\n-    }\n-\n-    if (this.ambiguousNodeQueue.length) {\n-      // Update the node queue to all stored ambiguous nodes. These nodes are not\n-      // guaranteed to be executed and therefore in case of a synchronous usage\n-      // within one of those nodes, the resolved usage is ambiguous.\n-      this.nodeQueue = this.ambiguousNodeQueue;\n-      const usage = this.isSynchronouslyUsedInNode(searchNode);\n-      return usage === ResolvedUsage.SYNCHRONOUS ? ResolvedUsage.AMBIGUOUS : usage;\n-    }\n-    return ResolvedUsage.ASYNCHRONOUS;\n-  }\n-\n-  /**\n-   * Peeks into the given jump expression by adding all function like declarations\n-   * which are referenced in the jump expression arguments to the ambiguous node\n-   * queue. These arguments could technically access the given declaration but it's\n-   * not guaranteed that the jump expression is executed. In that case the resolved\n-   * usage is ambiguous.\n-   */\n-  private peekIntoJumpExpression(jumpExp: ts.CallExpression|ts.NewExpression) {\n-    if (!jumpExp.arguments) {\n-      return;\n-    }\n-\n-    // For some call expressions we don't want to add the arguments to the\n-    // ambiguous node queue. e.g. \"setTimeout\" is not analyzable but is\n-    // guaranteed to execute its argument asynchronously. We handle a subset\n-    // of these call expressions by having a hardcoded list of some.\n-    if (ts.isCallExpression(jumpExp)) {\n-      const symbol = this._getDeclarationSymbolOfNode(jumpExp.expression);\n-      if (symbol && symbol.valueDeclaration) {\n-        const parentNode = symbol.valueDeclaration.parent;\n-        if (parentNode && (ts.isInterfaceDeclaration(parentNode) || ts.isSourceFile(parentNode)) &&\n-            (ts.isMethodSignature(symbol.valueDeclaration) ||\n-             ts.isFunctionDeclaration(symbol.valueDeclaration)) &&\n-            symbol.valueDeclaration.name) {\n-          const parentName = ts.isInterfaceDeclaration(parentNode) ? parentNode.name.text : null;\n-          const callName = getPropertyNameText(symbol.valueDeclaration.name);\n-          if (ASYNC_EXTERNAL_CALLS.some(\n-                  c =>\n-                      (c.name === callName &&\n-                       (c.parent.indexOf(parentName) !== -1 || c.parent.indexOf('*') !== -1)))) {\n-            return;\n-          }\n-        }\n-      }\n-    }\n-\n-    jumpExp.arguments!.forEach((node: ts.Node) => {\n-      node = this._resolveDeclarationOfNode(node);\n-\n-      if (ts.isVariableDeclaration(node) && node.initializer) {\n-        node = node.initializer;\n-      }\n-\n-      if (isFunctionLikeDeclaration(node) && !!node.body) {\n-        this.ambiguousNodeQueue.push(node.body);\n-      }\n-    });\n-  }\n-\n-  /**\n-   * Resolves a given node from the context. In case the node is not mapped in\n-   * the context, the original node is returned.\n-   */\n-  private _resolveNodeFromContext(node: ts.Node): ts.Node {\n-    if (this.context.has(node)) {\n-      return this.context.get(node)!;\n-    }\n-    return node;\n-  }\n-\n-  /**\n-   * Updates the context to reflect the newly set parameter values. This allows future\n-   * references to function parameters to be resolved to the actual node through the context.\n-   */\n-  private _updateContext(\n-      callArgs: ts.NodeArray<ts.Expression>, parameters: ts.NodeArray<ts.ParameterDeclaration>) {\n-    parameters.forEach((parameter, index) => {\n-      let argumentNode: ts.Node = callArgs[index];\n-\n-      if (!argumentNode) {\n-        if (!parameter.initializer) {\n-          return;\n-        }\n-\n-        // Argument can be undefined in case the function parameter has a default\n-        // value. In that case we want to store the parameter default value in the context.\n-        argumentNode = parameter.initializer;\n-      }\n-\n-      if (ts.isIdentifier(argumentNode)) {\n-        this.context.set(parameter, this._resolveDeclarationOfNode(argumentNode));\n-      } else {\n-        this.context.set(parameter, argumentNode);\n-      }\n-    });\n-  }\n-\n-  /**\n-   * Resolves the declaration of a given TypeScript node. For example an identifier can\n-   * refer to a function parameter. This parameter can then be resolved through the\n-   * function context.\n-   */\n-  private _resolveDeclarationOfNode(node: ts.Node): ts.Node {\n-    const symbol = this._getDeclarationSymbolOfNode(node);\n-\n-    if (!symbol || !symbol.valueDeclaration) {\n-      return node;\n-    }\n-\n-    return this._resolveNodeFromContext(symbol.valueDeclaration);\n-  }\n-\n-  /**\n-   * Gets the declaration symbol of a given TypeScript node. Resolves aliased\n-   * symbols to the symbol containing the value declaration.\n-   */\n-  private _getDeclarationSymbolOfNode(node: ts.Node): ts.Symbol|null {\n-    let symbol = this.typeChecker.getSymbolAtLocation(node);\n-\n-    if (!symbol) {\n-      return null;\n-    }\n-\n-    // Resolve the symbol to it's original declaration symbol.\n-    while (symbol.flags & ts.SymbolFlags.Alias) {\n-      symbol = this.typeChecker.getAliasedSymbol(symbol);\n-    }\n-\n-    return symbol;\n-  }\n-\n-  /** Gets the symbol of the given property access expression. */\n-  private _getPropertyAccessSymbol(node: ts.PropertyAccessExpression): ts.Symbol|null {\n-    let propertySymbol = this._getDeclarationSymbolOfNode(node.name);\n-\n-    if (!propertySymbol || !propertySymbol.valueDeclaration) {\n-      return null;\n-    }\n-\n-    if (!this.context.has(propertySymbol.valueDeclaration)) {\n-      return propertySymbol;\n-    }\n-\n-    // In case the context has the value declaration of the given property access\n-    // name identifier, we need to replace the \"propertySymbol\" with the symbol\n-    // referring to the resolved symbol based on the context. e.g. abstract properties\n-    // can ultimately resolve into an accessor declaration based on the implementation.\n-    const contextNode = this._resolveNodeFromContext(propertySymbol.valueDeclaration);\n-\n-    if (!ts.isAccessor(contextNode)) {\n-      return null;\n-    }\n-\n-    // Resolve the symbol referring to the \"accessor\" using the name identifier\n-    // of the accessor declaration.\n-    return this._getDeclarationSymbolOfNode(contextNode.name);\n-  }\n-}"
        },
        {
            "sha": "8e4e738ceec6c55f6604f315aacb76836c3419fc",
            "filename": "packages/core/schematics/migrations/static-queries/strategies/usage_strategy/super_class_context.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 49,
            "changes": 49,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Fusage_strategy%2Fsuper_class_context.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Fusage_strategy%2Fsuper_class_context.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Fusage_strategy%2Fsuper_class_context.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,49 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {isFunctionLikeDeclaration} from '../../../../utils/typescript/functions';\n-import {hasModifier} from '../../../../utils/typescript/nodes';\n-import {getPropertyNameText} from '../../../../utils/typescript/property_name';\n-import {ClassMetadataMap} from '../../angular/ng_query_visitor';\n-import {getSuperClassDeclarations} from '../../angular/super_class';\n-\n-import {FunctionContext} from './declaration_usage_visitor';\n-\n-\n-/**\n- * Updates the specified function context to map abstract super-class class members\n- * to their implementation TypeScript nodes. This allows us to run the declaration visitor\n- * for the super class with the context of the \"baseClass\" (e.g. with implemented abstract\n- * class members)\n- */\n-export function updateSuperClassAbstractMembersContext(\n-    baseClass: ts.ClassDeclaration, context: FunctionContext, classMetadataMap: ClassMetadataMap) {\n-  getSuperClassDeclarations(baseClass, classMetadataMap).forEach(superClassDecl => {\n-    superClassDecl.members.forEach(superClassMember => {\n-      if (!superClassMember.name || !hasModifier(superClassMember, ts.SyntaxKind.AbstractKeyword)) {\n-        return;\n-      }\n-\n-      // Find the matching implementation of the abstract declaration from the super class.\n-      const baseClassImpl = baseClass.members.find(\n-          baseClassMethod => !!baseClassMethod.name &&\n-              getPropertyNameText(baseClassMethod.name) ===\n-                  getPropertyNameText(superClassMember.name!));\n-\n-      if (!baseClassImpl || !isFunctionLikeDeclaration(baseClassImpl) || !baseClassImpl.body) {\n-        return;\n-      }\n-\n-      if (!context.has(superClassMember)) {\n-        context.set(superClassMember, baseClassImpl);\n-      }\n-    });\n-  });\n-}"
        },
        {
            "sha": "6035592ab7c70c3edd15323b0509805b114c336f",
            "filename": "packages/core/schematics/migrations/static-queries/strategies/usage_strategy/template_usage_visitor.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 94,
            "changes": 94,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Fusage_strategy%2Ftemplate_usage_visitor.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Fusage_strategy%2Ftemplate_usage_visitor.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Fusage_strategy%2Ftemplate_usage_visitor.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,94 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import type {ParseSourceSpan, PropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstBoundText, TmplAstElement, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n-import {TemplateAstVisitor} from '../../../../utils/template_ast_visitor';\n-\n-/**\n- * AST visitor that traverses the Render3 HTML AST in order to check if the given\n- * query property is accessed statically in the template.\n- */\n-export class TemplateUsageVisitor extends TemplateAstVisitor {\n-  private hasQueryTemplateReference = false;\n-  private expressionAstVisitor;\n-\n-  constructor(\n-      public queryPropertyName: string, compilerModule: typeof import('@angular/compiler')) {\n-    super(compilerModule);\n-\n-    // AST visitor that checks if the given expression contains property reads that\n-    // refer to the specified query property name.\n-    // This class must be defined within the template visitor due to the need to extend from a class\n-    // value found within `@angular/compiler` which is dynamically imported and provided to the\n-    // visitor.\n-    this.expressionAstVisitor = new (class extends compilerModule.RecursiveAstVisitor {\n-      hasQueryPropertyRead = false;\n-\n-\n-      override visitPropertyRead(node: PropertyRead, span: ParseSourceSpan): any {\n-        // The receiver of the property read needs to be \"implicit\" as queries are accessed\n-        // from the component instance and not from other objects.\n-        if (node.receiver instanceof compilerModule.ImplicitReceiver &&\n-            node.name === queryPropertyName) {\n-          this.hasQueryPropertyRead = true;\n-          return;\n-        }\n-\n-        super.visitPropertyRead(node, span);\n-      }\n-    })();\n-  }\n-\n-  /** Checks whether the given query is statically accessed within the specified HTML nodes. */\n-  isQueryUsedStatically(htmlNodes: TmplAstNode[]): boolean {\n-    this.hasQueryTemplateReference = false;\n-    this.expressionAstVisitor.hasQueryPropertyRead = false;\n-\n-    // Visit all AST nodes and check if the query property is used statically.\n-    this.visitAll(htmlNodes);\n-\n-    return !this.hasQueryTemplateReference && this.expressionAstVisitor.hasQueryPropertyRead;\n-  }\n-\n-  override visitElement(element: TmplAstElement): void {\n-    // In case there is a template references variable that matches the query property\n-    // name, we can finish this visitor as such a template variable can be used in the\n-    // entire template and the query therefore can't be accessed from the template.\n-    if (element.references.some(r => r.name === this.queryPropertyName)) {\n-      this.hasQueryTemplateReference = true;\n-      return;\n-    }\n-\n-    this.visitAll(element.attributes);\n-    this.visitAll(element.inputs);\n-    this.visitAll(element.outputs);\n-    this.visitAll(element.children);\n-  }\n-\n-  override visitTemplate(template: TmplAstTemplate): void {\n-    this.visitAll(template.attributes);\n-    this.visitAll(template.inputs);\n-    this.visitAll(template.outputs);\n-\n-    // We don't want to visit any children of the template as these never can't\n-    // access a query statically. The templates can be rendered in the ngAfterViewInit\"\n-    // lifecycle hook at the earliest.\n-  }\n-\n-  override visitBoundAttribute(attribute: TmplAstBoundAttribute) {\n-    attribute.value.visit(this.expressionAstVisitor, attribute.sourceSpan);\n-  }\n-\n-  override visitBoundText(text: TmplAstBoundText) {\n-    text.value.visit(this.expressionAstVisitor, text.sourceSpan);\n-  }\n-\n-  override visitBoundEvent(node: TmplAstBoundEvent) {\n-    node.handler.visit(this.expressionAstVisitor, node.handlerSpan);\n-  }\n-}"
        },
        {
            "sha": "91423dae0d099c91d2dc23cb1f2b8f3c7fb23518",
            "filename": "packages/core/schematics/migrations/static-queries/strategies/usage_strategy/usage_strategy.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 186,
            "changes": 186,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Fusage_strategy%2Fusage_strategy.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Fusage_strategy%2Fusage_strategy.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Fstrategies%2Fusage_strategy%2Fusage_strategy.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,186 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {parseHtmlGracefully} from '../../../../utils/parse_html';\n-import {hasPropertyNameText} from '../../../../utils/typescript/property_name';\n-import {ClassMetadataMap} from '../../angular/ng_query_visitor';\n-import {NgQueryDefinition, QueryTiming, QueryType} from '../../angular/query-definition';\n-import {TimingResult, TimingStrategy} from '../timing-strategy';\n-\n-import {DeclarationUsageVisitor, FunctionContext, ResolvedUsage} from './declaration_usage_visitor';\n-import {updateSuperClassAbstractMembersContext} from './super_class_context';\n-import {TemplateUsageVisitor} from './template_usage_visitor';\n-\n-\n-/**\n- * Object that maps a given type of query to a list of lifecycle hooks that\n- * could be used to access such a query statically.\n- */\n-const STATIC_QUERY_LIFECYCLE_HOOKS = {\n-  [QueryType.ViewChild]:\n-      ['ngOnChanges', 'ngOnInit', 'ngDoCheck', 'ngAfterContentInit', 'ngAfterContentChecked'],\n-  [QueryType.ContentChild]: ['ngOnChanges', 'ngOnInit', 'ngDoCheck'],\n-};\n-\n-/**\n- * Query timing strategy that determines the timing of a given query by inspecting how\n- * the query is accessed within the project's TypeScript source files. Read more about\n- * this strategy here: https://hackmd.io/s/Hymvc2OKE\n- */\n-export class QueryUsageStrategy implements TimingStrategy {\n-  constructor(\n-      private classMetadata: ClassMetadataMap, private typeChecker: ts.TypeChecker,\n-      private compilerModule: typeof import('@angular/compiler')) {}\n-\n-  setup() {}\n-\n-  /**\n-   * Analyzes the usage of the given query and determines the query timing based\n-   * on the current usage of the query.\n-   */\n-  detectTiming(query: NgQueryDefinition): TimingResult {\n-    if (query.property === null) {\n-      return {timing: null, message: 'Queries defined on accessors cannot be analyzed.'};\n-    }\n-\n-    const usage = this.analyzeQueryUsage(query.container, query, []);\n-\n-    if (usage === ResolvedUsage.AMBIGUOUS) {\n-      return {\n-        timing: QueryTiming.STATIC,\n-        message: 'Query timing is ambiguous. Please check if the query can be marked as dynamic.'\n-      };\n-    } else if (usage === ResolvedUsage.SYNCHRONOUS) {\n-      return {timing: QueryTiming.STATIC};\n-    } else {\n-      return {timing: QueryTiming.DYNAMIC};\n-    }\n-  }\n-\n-  /**\n-   * Checks whether a given query is used statically within the given class, its super\n-   * class or derived classes.\n-   */\n-  private analyzeQueryUsage(\n-      classDecl: ts.ClassDeclaration, query: NgQueryDefinition, knownInputNames: string[],\n-      functionCtx: FunctionContext = new Map(), visitInheritedClasses = true): ResolvedUsage {\n-    const usageVisitor =\n-        new DeclarationUsageVisitor(query.property!, this.typeChecker, functionCtx);\n-    const classMetadata = this.classMetadata.get(classDecl);\n-    let usage: ResolvedUsage = ResolvedUsage.ASYNCHRONOUS;\n-\n-    // In case there is metadata for the current class, we collect all resolved Angular input\n-    // names and add them to the list of known inputs that need to be checked for usages of\n-    // the current query. e.g. queries used in an @Input() *setter* are always static.\n-    if (classMetadata) {\n-      knownInputNames.push(...classMetadata.ngInputNames);\n-    }\n-\n-    // Array of TypeScript nodes which can contain usages of the given query in\n-    // order to access it statically.\n-    const possibleStaticQueryNodes = filterQueryClassMemberNodes(classDecl, query, knownInputNames);\n-\n-    // In case nodes that can possibly access a query statically have been found, check\n-    // if the query declaration is synchronously used within any of these nodes.\n-    if (possibleStaticQueryNodes.length) {\n-      possibleStaticQueryNodes.forEach(\n-          n => usage = combineResolvedUsage(usage, usageVisitor.getResolvedNodeUsage(n)));\n-    }\n-\n-    if (!classMetadata) {\n-      return usage;\n-    }\n-\n-    // In case there is a component template for the current class, we check if the\n-    // template statically accesses the current query. In case that's true, the query\n-    // can be marked as static.\n-    if (classMetadata.template && hasPropertyNameText(query.property!.name)) {\n-      const template = classMetadata.template;\n-      const parsedHtml =\n-          parseHtmlGracefully(template.content, template.filePath, this.compilerModule);\n-      const htmlVisitor = new TemplateUsageVisitor(query.property!.name.text, this.compilerModule);\n-\n-      if (parsedHtml && htmlVisitor.isQueryUsedStatically(parsedHtml)) {\n-        return ResolvedUsage.SYNCHRONOUS;\n-      }\n-    }\n-\n-    // In case derived classes should also be analyzed, we determine the classes that derive\n-    // from the current class and check if these have input setters or lifecycle hooks that\n-    // use the query statically.\n-    if (visitInheritedClasses) {\n-      classMetadata.derivedClasses.forEach(derivedClass => {\n-        usage = combineResolvedUsage(\n-            usage, this.analyzeQueryUsage(derivedClass, query, knownInputNames));\n-      });\n-    }\n-\n-    // In case the current class has a super class, we determine declared abstract function-like\n-    // declarations in the super-class that are implemented in the current class. The super class\n-    // will then be analyzed with the abstract declarations mapped to the implemented TypeScript\n-    // nodes. This allows us to handle queries which are used in super classes through derived\n-    // abstract method declarations.\n-    if (classMetadata.superClass) {\n-      const superClassDecl = classMetadata.superClass;\n-\n-      // Update the function context to map abstract declaration nodes to their implementation\n-      // node in the base class. This ensures that the declaration usage visitor can analyze\n-      // abstract class member declarations.\n-      updateSuperClassAbstractMembersContext(classDecl, functionCtx, this.classMetadata);\n-\n-      usage = combineResolvedUsage(\n-          usage, this.analyzeQueryUsage(superClassDecl, query, [], functionCtx, false));\n-    }\n-\n-    return usage;\n-  }\n-}\n-\n-/**\n- * Combines two resolved usages based on a fixed priority. \"Synchronous\" takes\n- * precedence over \"Ambiguous\" whereas ambiguous takes precedence over \"Asynchronous\".\n- */\n-function combineResolvedUsage(base: ResolvedUsage, target: ResolvedUsage): ResolvedUsage {\n-  if (base === ResolvedUsage.SYNCHRONOUS) {\n-    return base;\n-  } else if (target !== ResolvedUsage.ASYNCHRONOUS) {\n-    return target;\n-  } else {\n-    return ResolvedUsage.ASYNCHRONOUS;\n-  }\n-}\n-\n-/**\n- * Filters all class members from the class declaration that can access the\n- * given query statically (e.g. ngOnInit lifecycle hook or @Input setters)\n- */\n-function filterQueryClassMemberNodes(\n-    classDecl: ts.ClassDeclaration, query: NgQueryDefinition,\n-    knownInputNames: string[]): ts.Block[] {\n-  // Returns an array of TypeScript nodes which can contain usages of the given query\n-  // in order to access it statically. e.g.\n-  //  (1) queries used in the \"ngOnInit\" lifecycle hook are static.\n-  //  (2) inputs with setters can access queries statically.\n-  return classDecl.members\n-      .filter(\n-          (m):\n-              m is(ts.SetAccessorDeclaration | ts.MethodDeclaration) => {\n-                if (ts.isMethodDeclaration(m) && m.body && hasPropertyNameText(m.name) &&\n-                    STATIC_QUERY_LIFECYCLE_HOOKS[query.type].indexOf(m.name.text) !== -1) {\n-                  return true;\n-                } else if (\n-                    knownInputNames && ts.isSetAccessor(m) && m.body &&\n-                    hasPropertyNameText(m.name) && knownInputNames.indexOf(m.name.text) !== -1) {\n-                  return true;\n-                }\n-                return false;\n-              })\n-      .map(member => member.body!);\n-}"
        },
        {
            "sha": "69b179dd2af40d172176b6692c72149541ad9da3",
            "filename": "packages/core/schematics/migrations/static-queries/transform.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 114,
            "changes": 114,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Ftransform.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Ftransform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fstatic-queries%2Ftransform.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,114 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-import {getPropertyNameText} from '../../utils/typescript/property_name';\n-import {NgQueryDefinition, QueryTiming} from './angular/query-definition';\n-\n-export type TransformedQueryResult = null|{\n-  /** Transformed call expression. */\n-  node: ts.CallExpression;\n-  /** Failure message which is set when the query could not be transformed successfully. */\n-  failureMessage: string|null;\n-};\n-\n-const TODO_SPECIFY_COMMENT = 'TODO: add static flag';\n-const TODO_CHECK_COMMENT = 'TODO: check static flag';\n-\n-/**\n- * Transforms the given query decorator by explicitly specifying the timing based on the\n- * determined timing. The updated decorator call expression node will be returned.\n- */\n-export function getTransformedQueryCallExpr(\n-    query: NgQueryDefinition, timing: QueryTiming|null,\n-    createTodo: boolean): TransformedQueryResult {\n-  const queryExpr = query.decorator.node.expression;\n-  const queryArguments = queryExpr.arguments;\n-  const queryPropertyAssignments = timing === null ?\n-      [] :\n-      [ts.createPropertyAssignment(\n-          'static', timing === QueryTiming.STATIC ? ts.createTrue() : ts.createFalse())];\n-\n-  // If the query decorator is already called with two arguments, we need to\n-  // keep the existing options untouched and just add the new property if possible.\n-  if (queryArguments.length === 2) {\n-    const existingOptions = queryArguments[1];\n-    const existingOptionsText = existingOptions.getFullText();\n-    const hasTodoComment = existingOptionsText.includes(TODO_SPECIFY_COMMENT) ||\n-        existingOptionsText.includes(TODO_CHECK_COMMENT);\n-    let newOptionsNode: ts.Expression;\n-    let failureMessage: string|null = null;\n-\n-    if (ts.isObjectLiteralExpression(existingOptions)) {\n-      // In case the options already contains a property for the \"static\" flag,\n-      // we just skip this query and leave it untouched.\n-      if (existingOptions.properties.some(\n-              p => !!p.name && getPropertyNameText(p.name) === 'static')) {\n-        return null;\n-      }\n-\n-      newOptionsNode = ts.updateObjectLiteral(\n-          existingOptions, existingOptions.properties.concat(queryPropertyAssignments));\n-\n-      // In case we want to add a todo and the options do not have the todo\n-      // yet, we add the query timing todo as synthetic multi-line comment.\n-      if (createTodo && !hasTodoComment) {\n-        addQueryTimingTodoToNode(newOptionsNode, timing === null);\n-      }\n-    } else {\n-      // In case the options query parameter is not an object literal expression, and\n-      // we want to set the query timing, we just preserve the existing query parameter.\n-      newOptionsNode = existingOptions;\n-      // We always want to add a TODO in case the query options cannot be updated.\n-      if (!hasTodoComment) {\n-        addQueryTimingTodoToNode(existingOptions, true);\n-      }\n-      // If there is a new explicit timing that has been determined for the given query,\n-      // we create a transformation failure message that shows developers that they need\n-      // to set the query timing manually to the determined query timing.\n-      if (timing !== null) {\n-        failureMessage = 'Cannot update query to set explicit timing. Please manually ' +\n-            `set the query timing to: \"{static: ${(timing === QueryTiming.STATIC).toString()}}\"`;\n-      }\n-    }\n-\n-    return {\n-      failureMessage,\n-      node: ts.updateCall(\n-          queryExpr, queryExpr.expression, queryExpr.typeArguments,\n-          [queryArguments[0], newOptionsNode!])\n-    };\n-  }\n-\n-  const optionsNode = ts.createObjectLiteral(queryPropertyAssignments);\n-\n-  if (createTodo) {\n-    addQueryTimingTodoToNode(optionsNode, timing === null);\n-  }\n-\n-  return {\n-    failureMessage: null,\n-    node: ts.updateCall(\n-        queryExpr, queryExpr.expression, queryExpr.typeArguments, [queryArguments[0], optionsNode])\n-  };\n-}\n-\n-/**\n- * Adds a to-do to the given TypeScript node which reminds developers to specify\n- * an explicit query timing or to double-check the updated timing.\n- */\n-function addQueryTimingTodoToNode(node: ts.Node, addSpecifyTimingTodo: boolean) {\n-  ts.setSyntheticLeadingComments(\n-      node, [{\n-        pos: -1,\n-        end: -1,\n-        hasTrailingNewLine: false,\n-        kind: ts.SyntaxKind.MultiLineCommentTrivia,\n-        text: ` ${addSpecifyTimingTodo ? TODO_SPECIFY_COMMENT : TODO_CHECK_COMMENT} `\n-      }]);\n-}"
        },
        {
            "sha": "a08d0b45789e5225d2b4fb1b667454bfcf8a21e0",
            "filename": "packages/core/schematics/migrations/template-var-assignment/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 20,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Ftemplate-var-assignment%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Ftemplate-var-assignment%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Ftemplate-var-assignment%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,20 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"template-var-assignment\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/migrations/google3:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"//packages/compiler\",\n-        \"//packages/core/schematics/utils\",\n-        \"@npm//@angular-devkit/core\",\n-        \"@npm//@angular-devkit/schematics\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "2cf411fec7da0663bb798992301db72c1f591d88",
            "filename": "packages/core/schematics/migrations/template-var-assignment/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 27,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Ftemplate-var-assignment%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Ftemplate-var-assignment%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Ftemplate-var-assignment%2FREADME.md?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,27 +0,0 @@\n-## Assignments to template variables\n-\n-With Ivy, assignments to template variables are no longer supported\n-as template variables are effectively constants.\n-\n-This means that assignments to template variables will break your\n-application once Ivy is enabled by default. For example:\n-\n-```html\n-<button *ngFor=\"let option of options\"\n-       (click)=\"option = 'newButtonText'\">\n-  {{ option }}\n-</button>\n-```\n-\n-In the example from above, a value is assigned to the `option`\n-template variable on `click`. This will ultimately break your\n-application and therefore the logic needs to be adjusted to not\n-update the `option` variable, but rather the given element in\n-the `options` array:\n-\n-```html\n-<button *ngFor=\"let option of options; let idx = index\"\n-       (click)=\"options[idx] = 'newButtonText'\">\n-  {{ option }}\n-</button>\n-```\n\\ No newline at end of file"
        },
        {
            "sha": "a74aba88d2237f22b1b6f46275da23206607f236",
            "filename": "packages/core/schematics/migrations/template-var-assignment/analyze_template.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 40,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Ftemplate-var-assignment%2Fanalyze_template.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Ftemplate-var-assignment%2Fanalyze_template.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Ftemplate-var-assignment%2Fanalyze_template.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,40 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import type {PropertyWrite} from '@angular/compiler';\n-import {ResolvedTemplate} from '../../utils/ng_component_template';\n-import {parseHtmlGracefully} from '../../utils/parse_html';\n-import {HtmlVariableAssignmentVisitor} from './angular/html_variable_assignment_visitor';\n-\n-export interface TemplateVariableAssignment {\n-  node: PropertyWrite;\n-  start: number;\n-  end: number;\n-}\n-\n-/**\n- * Analyzes a given resolved template by looking for property assignments to local\n- * template variables within bound events.\n- */\n-export function analyzeResolvedTemplate(\n-    template: ResolvedTemplate,\n-    compilerModule: typeof import('@angular/compiler')): TemplateVariableAssignment[]|null {\n-  const templateNodes = parseHtmlGracefully(template.content, template.filePath, compilerModule);\n-\n-  if (!templateNodes) {\n-    return null;\n-  }\n-\n-  const visitor = new HtmlVariableAssignmentVisitor(compilerModule);\n-\n-  // Analyze the Angular Render3 HTML AST and collect all template variable assignments.\n-  visitor.visitAll(templateNodes);\n-\n-  return visitor.variableAssignments.map(\n-      ({node, start, end}) => ({node, start: start + node.span.start, end}));\n-}"
        },
        {
            "sha": "afc443e1544852af196a5cd52814966dfcb570b5",
            "filename": "packages/core/schematics/migrations/template-var-assignment/angular/html_variable_assignment_visitor.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 86,
            "changes": 86,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Ftemplate-var-assignment%2Fangular%2Fhtml_variable_assignment_visitor.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Ftemplate-var-assignment%2Fangular%2Fhtml_variable_assignment_visitor.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Ftemplate-var-assignment%2Fangular%2Fhtml_variable_assignment_visitor.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,86 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import type {ImplicitReceiver, ParseSourceSpan, PropertyWrite, RecursiveAstVisitor, TmplAstBoundEvent, TmplAstElement, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\n-import {TemplateAstVisitor} from '../../../utils/template_ast_visitor';\n-\n-\n-export interface TemplateVariableAssignment {\n-  start: number;\n-  end: number;\n-  node: PropertyWrite;\n-}\n-\n-/**\n- * HTML AST visitor that traverses the Render3 HTML AST in order to find all\n- * expressions that write to local template variables within bound events.\n- */\n-export class HtmlVariableAssignmentVisitor extends TemplateAstVisitor {\n-  variableAssignments: TemplateVariableAssignment[] = [];\n-\n-  private currentVariables: TmplAstVariable[] = [];\n-  private expressionAstVisitor;\n-\n-  constructor(compilerModule: typeof import('@angular/compiler')) {\n-    super(compilerModule);\n-\n-    // AST visitor that resolves all variable assignments within a given expression AST.\n-    // This class must be defined within the template visitor due to the need to extend from a class\n-    // value found within `@angular/compiler` which is dynamically imported and provided to the\n-    // visitor.\n-    this.expressionAstVisitor = new (class extends compilerModule.RecursiveAstVisitor {\n-      constructor(\n-          private variableAssignments: TemplateVariableAssignment[],\n-          private currentVariables: TmplAstVariable[]) {\n-        super();\n-      }\n-\n-      override visitPropertyWrite(node: PropertyWrite, span: ParseSourceSpan) {\n-        if (node.receiver instanceof compilerModule.ImplicitReceiver &&\n-            this.currentVariables.some(v => v.name === node.name)) {\n-          this.variableAssignments.push({\n-            node: node,\n-            start: span.start.offset,\n-            end: span.end.offset,\n-          });\n-        }\n-        super.visitPropertyWrite(node, span);\n-      }\n-    })(this.variableAssignments, this.currentVariables);\n-  }\n-\n-  override visitElement(element: TmplAstElement): void {\n-    this.visitAll(element.outputs);\n-    this.visitAll(element.children);\n-  }\n-\n-  override visitTemplate(template: TmplAstTemplate): void {\n-    // Keep track of the template variables which can be accessed by the template\n-    // child nodes through the implicit receiver.\n-    this.currentVariables.push(...template.variables);\n-\n-    // Visit all children of the template. The template proxies the outputs of the\n-    // immediate child elements, so we just ignore outputs on the \"Template\" in order\n-    // to not visit similar bound events twice.\n-    this.visitAll(template.children);\n-\n-    // Remove all previously added variables since all children that could access\n-    // these have been visited already.\n-    template.variables.forEach(v => {\n-      const variableIdx = this.currentVariables.indexOf(v);\n-\n-      if (variableIdx !== -1) {\n-        this.currentVariables.splice(variableIdx, 1);\n-      }\n-    });\n-  }\n-\n-  override visitBoundEvent(node: TmplAstBoundEvent) {\n-    node.handler.visit(this.expressionAstVisitor, node.handlerSpan);\n-  }\n-}"
        },
        {
            "sha": "4e5a228a3d1e20c75f1a4a8b7a3e105e1fd67b2c",
            "filename": "packages/core/schematics/migrations/template-var-assignment/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 101,
            "changes": 101,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Ftemplate-var-assignment%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Ftemplate-var-assignment%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Ftemplate-var-assignment%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,101 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {logging, normalize} from '@angular-devkit/core';\n-import {Rule, SchematicContext, SchematicsException, Tree} from '@angular-devkit/schematics';\n-import {relative} from 'path';\n-\n-import {loadEsmModule} from '../../utils/load_esm';\n-import {NgComponentTemplateVisitor} from '../../utils/ng_component_template';\n-import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n-import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n-\n-import {analyzeResolvedTemplate} from './analyze_template';\n-\n-type Logger = logging.LoggerApi;\n-\n-const README_URL = 'https://v8.angular.io/guide/deprecations#cannot-assign-to-template-variables';\n-const FAILURE_MESSAGE = `Found assignment to template variable.`;\n-\n-/** Entry point for the V8 template variable assignment schematic. */\n-export default function(): Rule {\n-  return async (tree: Tree, context: SchematicContext) => {\n-    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n-    const basePath = process.cwd();\n-\n-    if (!buildPaths.length && !testPaths.length) {\n-      throw new SchematicsException(\n-          'Could not find any tsconfig file. Cannot check templates for template variable ' +\n-          'assignments.');\n-    }\n-\n-    let compilerModule;\n-    try {\n-      // Load ESM `@angular/compiler` using the TypeScript dynamic import workaround.\n-      // Once TypeScript provides support for keeping the dynamic import this workaround can be\n-      // changed to a direct dynamic import.\n-      compilerModule = await loadEsmModule<typeof import('@angular/compiler')>('@angular/compiler');\n-    } catch (e) {\n-      throw new SchematicsException(\n-          `Unable to load the '@angular/compiler' package. Details: ${e.message}`);\n-    }\n-\n-    for (const tsconfigPath of [...buildPaths, ...testPaths]) {\n-      runTemplateVariableAssignmentCheck(\n-          tree, tsconfigPath, basePath, context.logger, compilerModule);\n-    }\n-  };\n-}\n-\n-/**\n- * Runs the template variable assignment check. Warns developers\n- * if values are assigned to template variables within output bindings.\n- */\n-function runTemplateVariableAssignmentCheck(\n-    tree: Tree, tsconfigPath: string, basePath: string, logger: Logger,\n-    compilerModule: typeof import('@angular/compiler')) {\n-  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n-  const typeChecker = program.getTypeChecker();\n-  const templateVisitor = new NgComponentTemplateVisitor(typeChecker);\n-  const sourceFiles =\n-      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n-\n-  // Analyze source files by detecting HTML templates.\n-  sourceFiles.forEach(sourceFile => templateVisitor.visitNode(sourceFile));\n-\n-  const {resolvedTemplates} = templateVisitor;\n-  const collectedFailures: string[] = [];\n-\n-  // Analyze each resolved template and print a warning for property writes to\n-  // template variables.\n-  resolvedTemplates.forEach(template => {\n-    const filePath = template.filePath;\n-    const nodes = analyzeResolvedTemplate(template, compilerModule);\n-\n-    if (!nodes) {\n-      return;\n-    }\n-\n-    const displayFilePath = normalize(relative(basePath, filePath));\n-\n-    nodes.forEach(n => {\n-      const {line, character} = template.getCharacterAndLineOfPosition(n.start);\n-      collectedFailures.push(`${displayFilePath}@${line + 1}:${character + 1}: ${FAILURE_MESSAGE}`);\n-    });\n-  });\n-\n-  if (collectedFailures.length) {\n-    logger.info('---- Template Variable Assignment schematic ----');\n-    logger.info('Assignments to template variables will no longer work with Ivy as');\n-    logger.info('template variables are effectively constants in Ivy. Read more about');\n-    logger.info(`this change here: ${README_URL}`);\n-    logger.info('');\n-    logger.info('The following template assignments were found:');\n-    collectedFailures.forEach(failure => logger.warn(`   ${failure}`));\n-  }\n-}"
        },
        {
            "sha": "e0eff880da2663f459e7c19af16749ff9c738002",
            "filename": "packages/core/schematics/migrations/undecorated-classes-with-decorated-fields/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 20,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,20 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"undecorated-classes-with-decorated-fields\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/migrations/google3:__pkg__\",\n-        \"//packages/core/schematics/migrations/undecorated-classes-with-decorated-fields/google3:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"//packages/compiler-cli/private\",\n-        \"//packages/core/schematics/utils\",\n-        \"@npm//@angular-devkit/schematics\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "2c89d7b2b8da7869a4c6f41a4144fcb8dff3e620",
            "filename": "packages/core/schematics/migrations/undecorated-classes-with-decorated-fields/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 27,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2FREADME.md?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,27 +0,0 @@\n-## Undecorated classes with decorated fields migration\n-\n-Automatically adds a `Directive` decorator to undecorated classes that use Angular features. A\n-class is considered using Angular features if a class member is decorated (e.g. `@Input()`), or\n-if the class defines any lifecycle hooks.\n-\n-This matches the undecorated classes compatibility logic in ngtsc that will be removed\n-as part of v10 so that the new mental model is enforced.    \n-\n-#### Before\n-```ts\n-import { Input } from '@angular/core';\n-\n-export class Base {\n-  @Input() isActive: boolean;\n-}\n-```\n-\n-#### After\n-```ts\n-import { Input, Directive } from '@angular/core';\n-\n-@Directive()\n-export class Base {\n-  @Input() isActive: boolean;\n-}\n-```"
        },
        {
            "sha": "8950f5665253ee35c9e16a167dea23bc7e0519e1",
            "filename": "packages/core/schematics/migrations/undecorated-classes-with-decorated-fields/google3/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 13,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2Fgoogle3%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2Fgoogle3%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2Fgoogle3%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,13 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"google3\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\"//packages/core/schematics/migrations/google3:__pkg__\"],\n-    deps = [\n-        \"//packages/core/schematics/migrations/undecorated-classes-with-decorated-fields\",\n-        \"@npm//tslint\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "4ca54b989e931464d9b603dd8dac6f02f066dfc4",
            "filename": "packages/core/schematics/migrations/undecorated-classes-with-decorated-fields/google3/tslint_update_recorder.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 56,
            "changes": 56,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2Fgoogle3%2Ftslint_update_recorder.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2Fgoogle3%2Ftslint_update_recorder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2Fgoogle3%2Ftslint_update_recorder.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,56 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Replacement, RuleFailure} from 'tslint';\n-import ts from 'typescript';\n-\n-import {UpdateRecorder} from '../update_recorder';\n-\n-export class TslintUpdateRecorder implements UpdateRecorder {\n-  failures: RuleFailure[] = [];\n-\n-  constructor(private ruleName: string, private sourceFile: ts.SourceFile) {}\n-\n-  addClassTodo(node: ts.ClassDeclaration, message: string) {\n-    this.failures.push(new RuleFailure(\n-        this.sourceFile, node.getStart(), 0, message, this.ruleName,\n-        Replacement.appendText(node.getStart(), `// TODO: ${message}`)));\n-  }\n-\n-  /** Adds the specified decorator to the given class declaration. */\n-  addClassDecorator(node: ts.ClassDeclaration, decoratorText: string) {\n-    // Adding a decorator should be the last replacement. Replacements/rule failures\n-    // are handled in reverse and in case a decorator and import are inserted at\n-    // the start of the file, the class decorator should come after the import.\n-    this.failures.unshift(new RuleFailure(\n-        this.sourceFile, node.getStart(), 0,\n-        `Class needs to be decorated with ` +\n-            `\"${decoratorText}\" because it uses Angular features.`,\n-        this.ruleName, Replacement.appendText(node.getStart(), `${decoratorText}\\n`)));\n-  }\n-\n-  /** Adds the specified import to the source file at the given position */\n-  addNewImport(start: number, importText: string) {\n-    this.failures.push(new RuleFailure(\n-        this.sourceFile, start, 0, `Source file needs to have import: \"${importText}\"`,\n-        this.ruleName, Replacement.appendText(start, importText)));\n-  }\n-\n-  /** Updates existing named imports to the given new named imports. */\n-  updateExistingImport(namedBindings: ts.NamedImports, newNamedBindings: string): void {\n-    const fix = [\n-      Replacement.deleteText(namedBindings.getStart(), namedBindings.getWidth()),\n-      Replacement.appendText(namedBindings.getStart(), newNamedBindings),\n-    ];\n-    this.failures.push(new RuleFailure(\n-        this.sourceFile, namedBindings.getStart(), namedBindings.getEnd(),\n-        `Import needs to be updated to import symbols: \"${newNamedBindings}\"`, this.ruleName, fix));\n-  }\n-\n-  commitUpdate() {}\n-}"
        },
        {
            "sha": "fea367105eb3a131acf2f4a4d08d7f8ee28568a6",
            "filename": "packages/core/schematics/migrations/undecorated-classes-with-decorated-fields/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 125,
            "changes": 125,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,125 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Rule, SchematicContext, SchematicsException, Tree,} from '@angular-devkit/schematics';\n-import {relative} from 'path';\n-import ts from 'typescript';\n-\n-import {loadCompilerCliMigrationsModule, loadEsmModule} from '../../utils/load_esm';\n-import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n-import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n-\n-import {UndecoratedClassesWithDecoratedFieldsTransform} from './transform';\n-import {UpdateRecorder} from './update_recorder';\n-\n-/**\n- * Migration that adds an Angular decorator to classes that have Angular field decorators.\n- * https://hackmd.io/vuQfavzfRG6KUCtU7oK_EA\n- */\n-export default function(): Rule {\n-  return async (tree: Tree, ctx: SchematicContext) => {\n-    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n-    const basePath = process.cwd();\n-    const allPaths = [...buildPaths, ...testPaths];\n-    const failures: string[] = [];\n-\n-    if (!allPaths.length) {\n-      throw new SchematicsException(\n-          'Could not find any tsconfig file. Cannot add an Angular decorator to undecorated classes.');\n-    }\n-\n-    let compilerCliMigrationsModule;\n-    try {\n-      // Load ESM `@angular/compiler/private/migrations` using the TypeScript dynamic import\n-      // workaround. Once TypeScript provides support for keeping the dynamic import this workaround\n-      // can be changed to a direct dynamic import.\n-      compilerCliMigrationsModule = await loadCompilerCliMigrationsModule();\n-    } catch (e) {\n-      throw new SchematicsException(\n-          `Unable to load the '@angular/compiler-cli' package. Details: ${e.message}`);\n-    }\n-\n-    for (const tsconfigPath of allPaths) {\n-      failures.push(...runUndecoratedClassesMigration(\n-          tree, tsconfigPath, basePath, compilerCliMigrationsModule));\n-    }\n-\n-    if (failures.length) {\n-      ctx.logger.info('Could not migrate all undecorated classes that use Angular features.');\n-      ctx.logger.info('Please manually fix the following failures:');\n-      failures.forEach(message => ctx.logger.warn(`   ${message}`));\n-    }\n-  };\n-}\n-\n-function runUndecoratedClassesMigration(\n-    tree: Tree, tsconfigPath: string, basePath: string,\n-    compilerCliMigrationsModule: typeof import('@angular/compiler-cli/private/migrations')):\n-    string[] {\n-  const failures: string[] = [];\n-  const {program} = createMigrationProgram(tree, tsconfigPath, basePath);\n-  const typeChecker = program.getTypeChecker();\n-  const sourceFiles =\n-      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n-  const updateRecorders = new Map<ts.SourceFile, UpdateRecorder>();\n-  const transform = new UndecoratedClassesWithDecoratedFieldsTransform(\n-      typeChecker, getUpdateRecorder, compilerCliMigrationsModule);\n-\n-  // Migrate all source files in the project.\n-  transform.migrate(sourceFiles).forEach(({node, message}) => {\n-    const nodeSourceFile = node.getSourceFile();\n-    const relativeFilePath = relative(basePath, nodeSourceFile.fileName);\n-    const {line, character} =\n-        ts.getLineAndCharacterOfPosition(node.getSourceFile(), node.getStart());\n-    failures.push(`${relativeFilePath}@${line + 1}:${character + 1}: ${message}`);\n-  });\n-\n-  // Record the changes collected in the import manager.\n-  transform.recordChanges();\n-\n-  // Walk through each update recorder and commit the update. We need to commit the\n-  // updates in batches per source file as there can be only one recorder per source\n-  // file in order to avoid shifted character offsets.\n-  updateRecorders.forEach(recorder => recorder.commitUpdate());\n-\n-  return failures;\n-\n-  /** Gets the update recorder for the specified source file. */\n-  function getUpdateRecorder(sourceFile: ts.SourceFile): UpdateRecorder {\n-    if (updateRecorders.has(sourceFile)) {\n-      return updateRecorders.get(sourceFile)!;\n-    }\n-    const treeRecorder = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n-    const recorder: UpdateRecorder = {\n-      addClassTodo(node: ts.ClassDeclaration, message: string) {\n-        treeRecorder.insertRight(node.getStart(), `// TODO: ${message}\\n`);\n-      },\n-      addClassDecorator(node: ts.ClassDeclaration, text: string) {\n-        // New imports should be inserted at the left while decorators should be inserted\n-        // at the right in order to ensure that imports are inserted before the decorator\n-        // if the start position of import and decorator is the source file start.\n-        treeRecorder.insertRight(node.getStart(), `${text}\\n`);\n-      },\n-      addNewImport(start: number, importText: string) {\n-        // New imports should be inserted at the left while decorators should be inserted\n-        // at the right in order to ensure that imports are inserted before the decorator\n-        // if the start position of import and decorator is the source file start.\n-        treeRecorder.insertLeft(start, importText);\n-      },\n-      updateExistingImport(namedBindings: ts.NamedImports, newNamedBindings: string) {\n-        treeRecorder.remove(namedBindings.getStart(), namedBindings.getWidth());\n-        treeRecorder.insertRight(namedBindings.getStart(), newNamedBindings);\n-      },\n-      commitUpdate() {\n-        tree.commitUpdate(treeRecorder);\n-      }\n-    };\n-    updateRecorders.set(sourceFile, recorder);\n-    return recorder;\n-  }\n-}"
        },
        {
            "sha": "6f5c2500787a691eb89e35e05b6e3a95a18ead75",
            "filename": "packages/core/schematics/migrations/undecorated-classes-with-decorated-fields/transform.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 333,
            "changes": 333,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2Ftransform.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2Ftransform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2Ftransform.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,333 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {ImportManager} from '../../utils/import_manager';\n-import {getAngularDecorators, NgDecorator} from '../../utils/ng_decorators';\n-import {findBaseClassDeclarations} from '../../utils/typescript/find_base_classes';\n-import {unwrapExpression} from '../../utils/typescript/functions';\n-import {getPropertyNameText} from '../../utils/typescript/property_name';\n-\n-import {UpdateRecorder} from './update_recorder';\n-\n-/**\n- * Set of known decorators that indicate that the current class needs a directive\n- * definition. These decorators are always specific to directives.\n- */\n-const DIRECTIVE_FIELD_DECORATORS = new Set([\n-  'Input', 'Output', 'ViewChild', 'ViewChildren', 'ContentChild', 'ContentChildren', 'HostBinding',\n-  'HostListener'\n-]);\n-\n-/**\n- * Set of known lifecycle hooks that indicate that the current class needs a directive\n- * definition. These lifecycle hooks are always specific to directives.\n- */\n-const DIRECTIVE_LIFECYCLE_HOOKS = new Set([\n-  'ngOnChanges', 'ngOnInit', 'ngDoCheck', 'ngAfterViewInit', 'ngAfterViewChecked',\n-  'ngAfterContentInit', 'ngAfterContentChecked'\n-]);\n-\n-/**\n- * Set of known lifecycle hooks that indicate that a given class uses Angular\n- * features, but it's ambiguous whether it is a directive or service.\n- */\n-const AMBIGUOUS_LIFECYCLE_HOOKS = new Set(['ngOnDestroy']);\n-\n-/** Describes how a given class is used in the context of Angular. */\n-enum InferredKind {\n-  DIRECTIVE,\n-  AMBIGUOUS,\n-  UNKNOWN,\n-}\n-\n-/** Describes possible types of Angular declarations. */\n-enum DeclarationType {\n-  DIRECTIVE,\n-  COMPONENT,\n-  ABSTRACT_DIRECTIVE,\n-  PIPE,\n-  INJECTABLE,\n-}\n-\n-/** Analyzed class declaration. */\n-interface AnalyzedClass {\n-  /** Type of declaration that is determined through an applied decorator. */\n-  decoratedType: DeclarationType|null;\n-  /** Inferred class kind in terms of Angular. */\n-  inferredKind: InferredKind;\n-}\n-\n-interface AnalysisFailure {\n-  node: ts.Node;\n-  message: string;\n-}\n-\n-/** TODO message that is added to ambiguous classes using Angular features. */\n-const AMBIGUOUS_CLASS_TODO = 'Add Angular decorator.';\n-\n-export class UndecoratedClassesWithDecoratedFieldsTransform {\n-  private printer = ts.createPrinter();\n-  private importManager = new ImportManager(this.getUpdateRecorder, this.printer);\n-  private reflectionHost =\n-      new this.compilerCliMigrationsModule.TypeScriptReflectionHost(this.typeChecker);\n-  private partialEvaluator = new this.compilerCliMigrationsModule.PartialEvaluator(\n-      this.reflectionHost, this.typeChecker, null);\n-\n-  constructor(\n-      private typeChecker: ts.TypeChecker,\n-      private getUpdateRecorder: (sf: ts.SourceFile) => UpdateRecorder,\n-      private compilerCliMigrationsModule:\n-          typeof import('@angular/compiler-cli/private/migrations')) {}\n-\n-  /**\n-   * Migrates the specified source files. The transform adds the abstract `@Directive`\n-   * decorator to undecorated classes that use Angular features. Class members which\n-   * are decorated with any Angular decorator, or class members for lifecycle hooks are\n-   * indicating that a given class uses Angular features. https://hackmd.io/vuQfavzfRG6KUCtU7oK_EA\n-   */\n-  migrate(sourceFiles: ts.SourceFile[]): AnalysisFailure[] {\n-    const {detectedAbstractDirectives, ambiguousClasses} =\n-        this._findUndecoratedAbstractDirectives(sourceFiles);\n-\n-    detectedAbstractDirectives.forEach(node => {\n-      const sourceFile = node.getSourceFile();\n-      const recorder = this.getUpdateRecorder(sourceFile);\n-      const directiveExpr =\n-          this.importManager.addImportToSourceFile(sourceFile, 'Directive', '@angular/core');\n-      const decoratorExpr = ts.createDecorator(ts.createCall(directiveExpr, undefined, undefined));\n-      recorder.addClassDecorator(\n-          node, this.printer.printNode(ts.EmitHint.Unspecified, decoratorExpr, sourceFile));\n-    });\n-\n-    // Ambiguous classes clearly use Angular features, but the migration is unable to\n-    // determine whether the class is used as directive, service or pipe. The migration\n-    // could potentially determine the type by checking NgModule definitions or inheritance\n-    // of other known declarations, but this is out of scope and a TODO/failure is sufficient.\n-    return Array.from(ambiguousClasses).reduce((failures, node) => {\n-      // If the class has been reported as ambiguous before, skip adding a TODO and\n-      // printing an error. A class could be visited multiple times when it's part\n-      // of multiple build targets in the CLI project.\n-      if (this._hasBeenReportedAsAmbiguous(node)) {\n-        return failures;\n-      }\n-\n-      const sourceFile = node.getSourceFile();\n-      const recorder = this.getUpdateRecorder(sourceFile);\n-\n-      // Add a TODO to the class that uses Angular features but is not decorated.\n-      recorder.addClassTodo(node, AMBIGUOUS_CLASS_TODO);\n-\n-      // Add an error for the class that will be printed in the `ng update` output.\n-      return failures.concat({\n-        node,\n-        message: 'Class uses Angular features but cannot be migrated automatically. Please ' +\n-            'add an appropriate Angular decorator.'\n-      });\n-    }, [] as AnalysisFailure[]);\n-  }\n-\n-  /** Records all changes that were made in the import manager. */\n-  recordChanges() {\n-    this.importManager.recordChanges();\n-  }\n-\n-  /**\n-   * Finds undecorated abstract directives in the specified source files. Also returns\n-   * a set of undecorated classes which could not be detected as guaranteed abstract\n-   * directives. Those are ambiguous and could be either Directive, Pipe or service.\n-   */\n-  private _findUndecoratedAbstractDirectives(sourceFiles: ts.SourceFile[]) {\n-    const ambiguousClasses = new Set<ts.ClassDeclaration>();\n-    const declarations = new WeakMap<ts.ClassDeclaration, DeclarationType>();\n-    const detectedAbstractDirectives = new Set<ts.ClassDeclaration>();\n-    const undecoratedClasses = new Set<ts.ClassDeclaration>();\n-\n-    const visitNode = (node: ts.Node) => {\n-      node.forEachChild(visitNode);\n-      if (!ts.isClassDeclaration(node)) {\n-        return;\n-      }\n-      const {inferredKind, decoratedType} = this._analyzeClassDeclaration(node);\n-\n-      if (decoratedType !== null) {\n-        declarations.set(node, decoratedType);\n-        return;\n-      }\n-\n-      if (inferredKind === InferredKind.DIRECTIVE) {\n-        detectedAbstractDirectives.add(node);\n-      } else if (inferredKind === InferredKind.AMBIGUOUS) {\n-        ambiguousClasses.add(node);\n-      } else {\n-        undecoratedClasses.add(node);\n-      }\n-    };\n-\n-    sourceFiles.forEach(sourceFile => sourceFile.forEachChild(visitNode));\n-\n-    /**\n-     * Checks the inheritance of the given set of classes. It removes classes from the\n-     * detected abstract directives set when they inherit from a non-abstract Angular\n-     * declaration. e.g. an abstract directive can never extend from a component.\n-     *\n-     * If a class inherits from an abstract directive though, we will migrate them too\n-     * as derived classes also need to be decorated. This has been done for a simpler mental\n-     * model and reduced complexity in the Angular compiler. See migration plan document.\n-     */\n-    const checkInheritanceOfClasses = (classes: Set<ts.ClassDeclaration>) => {\n-      classes.forEach(node => {\n-        for (const {node: baseClass} of findBaseClassDeclarations(node, this.typeChecker)) {\n-          if (!declarations.has(baseClass)) {\n-            continue;\n-          }\n-          // If the undecorated class inherits from an abstract directive, always migrate it.\n-          // Derived undecorated classes of abstract directives are always also considered\n-          // abstract directives and need to be decorated too. This is necessary as otherwise\n-          // the inheritance chain cannot be resolved by the Angular compiler. e.g. when it\n-          // flattens directive metadata for type checking. In the other case, we never want\n-          // to migrate a class if it extends from a non-abstract Angular declaration. That\n-          // is an unsupported pattern as of v9 and was previously handled with the\n-          // `undecorated-classes-with-di` migration (which copied the inherited decorator).\n-          if (declarations.get(baseClass) === DeclarationType.ABSTRACT_DIRECTIVE) {\n-            detectedAbstractDirectives.add(node);\n-          } else {\n-            detectedAbstractDirectives.delete(node);\n-          }\n-          ambiguousClasses.delete(node);\n-          break;\n-        }\n-      });\n-    };\n-\n-    // Check inheritance of any detected abstract directive. We want to remove\n-    // classes that are not eligible abstract directives due to inheritance. i.e.\n-    // if a class extends from a component, it cannot be a derived abstract directive.\n-    checkInheritanceOfClasses(detectedAbstractDirectives);\n-    // Update the class declarations to reflect the detected abstract directives. This is\n-    // then used later when we check for undecorated classes that inherit from an abstract\n-    // directive and need to be decorated.\n-    detectedAbstractDirectives.forEach(\n-        n => declarations.set(n, DeclarationType.ABSTRACT_DIRECTIVE));\n-    // Check ambiguous and undecorated classes if they inherit from an abstract directive.\n-    // If they do, we want to migrate them too. See function definition for more details.\n-    checkInheritanceOfClasses(ambiguousClasses);\n-    checkInheritanceOfClasses(undecoratedClasses);\n-\n-    return {detectedAbstractDirectives, ambiguousClasses};\n-  }\n-\n-  /**\n-   * Analyzes the given class declaration by determining whether the class\n-   * is a directive, is an abstract directive, or uses Angular features.\n-   */\n-  private _analyzeClassDeclaration(node: ts.ClassDeclaration): AnalyzedClass {\n-    const ngDecorators = node.decorators && getAngularDecorators(this.typeChecker, node.decorators);\n-    const inferredKind = this._determineClassKind(node);\n-    if (ngDecorators === undefined || ngDecorators.length === 0) {\n-      return {decoratedType: null, inferredKind};\n-    }\n-    const directiveDecorator = ngDecorators.find(({name}) => name === 'Directive');\n-    const componentDecorator = ngDecorators.find(({name}) => name === 'Component');\n-    const pipeDecorator = ngDecorators.find(({name}) => name === 'Pipe');\n-    const injectableDecorator = ngDecorators.find(({name}) => name === 'Injectable');\n-    const isAbstractDirective =\n-        directiveDecorator !== undefined && this._isAbstractDirective(directiveDecorator);\n-\n-    let decoratedType: DeclarationType|null = null;\n-    if (isAbstractDirective) {\n-      decoratedType = DeclarationType.ABSTRACT_DIRECTIVE;\n-    } else if (componentDecorator !== undefined) {\n-      decoratedType = DeclarationType.COMPONENT;\n-    } else if (directiveDecorator !== undefined) {\n-      decoratedType = DeclarationType.DIRECTIVE;\n-    } else if (pipeDecorator !== undefined) {\n-      decoratedType = DeclarationType.PIPE;\n-    } else if (injectableDecorator !== undefined) {\n-      decoratedType = DeclarationType.INJECTABLE;\n-    }\n-    return {decoratedType, inferredKind};\n-  }\n-\n-  /**\n-   * Checks whether the given decorator resolves to an abstract directive. An directive is\n-   * considered \"abstract\" if there is no selector specified.\n-   */\n-  private _isAbstractDirective({node}: NgDecorator): boolean {\n-    const metadataArgs = node.expression.arguments;\n-    if (metadataArgs.length === 0) {\n-      return true;\n-    }\n-    const metadataExpr = unwrapExpression(metadataArgs[0]);\n-    if (!ts.isObjectLiteralExpression(metadataExpr)) {\n-      return false;\n-    }\n-    const metadata = this.compilerCliMigrationsModule.reflectObjectLiteral(metadataExpr);\n-    if (!metadata.has('selector')) {\n-      return false;\n-    }\n-    const selector = this.partialEvaluator.evaluate(metadata.get('selector')!);\n-    return selector == null;\n-  }\n-\n-  /**\n-   * Determines the kind of a given class in terms of Angular. The method checks\n-   * whether the given class has members that indicate the use of Angular features.\n-   * e.g. lifecycle hooks or decorated members like `@Input` or `@Output` are\n-   * considered Angular features..\n-   */\n-  private _determineClassKind(node: ts.ClassDeclaration): InferredKind {\n-    let usage = InferredKind.UNKNOWN;\n-\n-    for (const member of node.members) {\n-      const propertyName = member.name !== undefined ? getPropertyNameText(member.name) : null;\n-\n-      // If the class declares any of the known directive lifecycle hooks, we can\n-      // immediately exit the loop as the class is guaranteed to be a directive.\n-      if (propertyName !== null && DIRECTIVE_LIFECYCLE_HOOKS.has(propertyName)) {\n-        return InferredKind.DIRECTIVE;\n-      }\n-\n-      const ngDecorators = member.decorators !== undefined ?\n-          getAngularDecorators(this.typeChecker, member.decorators) :\n-          [];\n-      for (const {name} of ngDecorators) {\n-        if (DIRECTIVE_FIELD_DECORATORS.has(name)) {\n-          return InferredKind.DIRECTIVE;\n-        }\n-      }\n-\n-      // If the class declares any of the lifecycle hooks that do not guarantee that\n-      // the given class is a directive, update the kind and continue looking for other\n-      // members that would unveil a more specific kind (i.e. being a directive).\n-      if (propertyName !== null && AMBIGUOUS_LIFECYCLE_HOOKS.has(propertyName)) {\n-        usage = InferredKind.AMBIGUOUS;\n-      }\n-    }\n-\n-    return usage;\n-  }\n-\n-  /**\n-   * Checks whether a given class has been reported as ambiguous in previous\n-   * migration run. e.g. when build targets are migrated first, and then test\n-   * targets that have an overlap with build source files, the same class\n-   * could be detected as ambiguous.\n-   */\n-  private _hasBeenReportedAsAmbiguous(node: ts.ClassDeclaration): boolean {\n-    const sourceFile = node.getSourceFile();\n-    const leadingComments = ts.getLeadingCommentRanges(sourceFile.text, node.pos);\n-    if (leadingComments === undefined) {\n-      return false;\n-    }\n-    return leadingComments.some(\n-        ({kind, pos, end}) => kind === ts.SyntaxKind.SingleLineCommentTrivia &&\n-            sourceFile.text.substring(pos, end).includes(`TODO: ${AMBIGUOUS_CLASS_TODO}`));\n-  }\n-}"
        },
        {
            "sha": "baee6f67f70f4a575f62fe7a78a03027531058f9",
            "filename": "packages/core/schematics/migrations/undecorated-classes-with-decorated-fields/update_recorder.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 20,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2Fupdate_recorder.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2Fupdate_recorder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-decorated-fields%2Fupdate_recorder.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,20 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-import {ImportManagerUpdateRecorder} from '../../utils/import_manager';\n-\n-/**\n- * Update recorder interface that is used to transform source files\n- * in a non-colliding way.\n- */\n-export interface UpdateRecorder extends ImportManagerUpdateRecorder {\n-  addClassDecorator(node: ts.ClassDeclaration, text: string): void;\n-  addClassTodo(node: ts.ClassDeclaration, message: string): void;\n-  commitUpdate(): void;\n-}"
        },
        {
            "sha": "138542abe748b040d648b51332b384ec1358c06d",
            "filename": "packages/core/schematics/migrations/undecorated-classes-with-di/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 22,
            "changes": 22,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,22 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"undecorated-classes-with-di\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/migrations/undecorated-classes/google3:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"//packages/compiler\",\n-        \"//packages/compiler-cli\",\n-        \"//packages/core\",\n-        \"//packages/core/schematics/utils\",\n-        \"@npm//@angular-devkit/core\",\n-        \"@npm//@angular-devkit/schematics\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "a97f4aa16d0f1c3c8b7b965439bb5ed93f45c0a9",
            "filename": "packages/core/schematics/migrations/undecorated-classes-with-di/create_ngc_program.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 55,
            "changes": 55,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fcreate_ngc_program.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fcreate_ngc_program.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fcreate_ngc_program.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,55 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import type {AotCompiler} from '@angular/compiler';\n-import type {CompilerHost} from '@angular/compiler-cli';\n-import ts from 'typescript';\n-\n-/** Creates an NGC program that can be used to read and parse metadata for files. */\n-export function createNgcProgram(\n-    compilerCliModule: typeof import('@angular/compiler-cli'),\n-    createHost: (options: ts.CompilerOptions) => CompilerHost, tsconfigPath: string) {\n-  const {rootNames, options} = compilerCliModule.readConfiguration(tsconfigPath);\n-\n-  // https://github.com/angular/angular/commit/ec4381dd401f03bded652665b047b6b90f2b425f made Ivy\n-  // the default. This breaks the assumption that \"createProgram\" from compiler-cli returns the\n-  // NGC program. In order to ensure that the migration runs properly, we set \"enableIvy\" to false.\n-  options.enableIvy = false;\n-\n-  // Libraries which have been generated with CLI versions past v6.2.0, explicitly set the\n-  // flat-module options in their tsconfig files. This is problematic because by default,\n-  // those tsconfig files do not specify explicit source files which can be considered as\n-  // entry point for the flat-module bundle. Therefore the `@angular/compiler-cli` is unable\n-  // to determine the flat module entry point and throws a compile error. This is not an issue\n-  // for the libraries built with `ng-packagr`, because the tsconfig files are modified in-memory\n-  // to specify an explicit flat module entry-point. Our migrations don't distinguish between\n-  // libraries and applications, and also don't run `ng-packagr`. To ensure that such libraries\n-  // can be successfully migrated, we remove the flat-module options to eliminate the flat module\n-  // entry-point requirement. More context: https://github.com/angular/angular/issues/34985.\n-  options.flatModuleId = undefined;\n-  options.flatModuleOutFile = undefined;\n-\n-  const host = createHost(options);\n-\n-  // For this migration, we never need to read resources and can just return\n-  // an empty string for requested resources. We need to handle requested resources\n-  // because our created NGC compiler program does not know about special resolutions\n-  // which are set up by the Angular CLI. i.e. resolving stylesheets through \"tilde\".\n-  host.readResource = () => '';\n-  host.resourceNameToFileName = () => '$fake-file$';\n-\n-  const ngcProgram = compilerCliModule.createProgram({rootNames, options, host});\n-\n-  // The \"AngularCompilerProgram\" does not expose the \"AotCompiler\" instance, nor does it\n-  // expose the logic that is necessary to analyze the determined modules. We work around\n-  // this by just accessing the necessary private properties using the bracket notation.\n-  const compiler: AotCompiler = (ngcProgram as any)['compiler'];\n-  const program = ngcProgram.getTsProgram();\n-\n-  return {host, ngcProgram, program, compiler};\n-}"
        },
        {
            "sha": "d70ec740b279156b70f94c2c9eb9df9de2250b03",
            "filename": "packages/core/schematics/migrations/undecorated-classes-with-di/decorator_rewrite/convert_directive_metadata.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 92,
            "changes": 92,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fdecorator_rewrite%2Fconvert_directive_metadata.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fdecorator_rewrite%2Fconvert_directive_metadata.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fdecorator_rewrite%2Fconvert_directive_metadata.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,92 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import type {StaticSymbol} from '@angular/compiler';\n-import ts from 'typescript';\n-\n-/** Error that will be thrown if an unexpected value needs to be converted. */\n-export class UnexpectedMetadataValueError extends Error {}\n-\n-/**\n- * Converts a directive metadata object into a TypeScript expression. Throws\n- * if metadata cannot be cleanly converted.\n- */\n-export function convertDirectiveMetadataToExpression(\n-    compilerModule: typeof import('@angular/compiler'), metadata: any,\n-    resolveSymbolImport: (symbol: StaticSymbol) => string | null,\n-    createImport: (moduleName: string, name: string) => ts.Expression,\n-    convertProperty?: (key: string, value: any) => ts.Expression | null): ts.Expression {\n-  if (typeof metadata === 'string') {\n-    return ts.createStringLiteral(metadata);\n-  } else if (Array.isArray(metadata)) {\n-    return ts.createArrayLiteral(metadata.map(\n-        el => convertDirectiveMetadataToExpression(\n-            compilerModule, el, resolveSymbolImport, createImport, convertProperty)));\n-  } else if (typeof metadata === 'number') {\n-    return ts.createNumericLiteral(metadata.toString());\n-  } else if (typeof metadata === 'boolean') {\n-    return metadata ? ts.createTrue() : ts.createFalse();\n-  } else if (typeof metadata === 'undefined') {\n-    return ts.createIdentifier('undefined');\n-  } else if (typeof metadata === 'bigint') {\n-    return ts.createBigIntLiteral(metadata.toString());\n-  } else if (typeof metadata === 'object') {\n-    // In case there is a static symbol object part of the metadata, try to resolve\n-    // the import expression of the symbol. If no import path could be resolved, an\n-    // error will be thrown as the symbol cannot be converted into TypeScript AST.\n-    if (metadata instanceof compilerModule.StaticSymbol) {\n-      const resolvedImport = resolveSymbolImport(metadata);\n-      if (resolvedImport === null) {\n-        throw new UnexpectedMetadataValueError();\n-      }\n-      return createImport(resolvedImport, metadata.name);\n-    }\n-\n-    const literalProperties: ts.PropertyAssignment[] = [];\n-\n-    for (const key of Object.keys(metadata)) {\n-      const metadataValue = metadata[key];\n-      let propertyValue: ts.Expression|null = null;\n-\n-      // Allows custom conversion of properties in an object. This is useful for special\n-      // cases where we don't want to store the enum values as integers, but rather use the\n-      // real enum symbol. e.g. instead of `2` we want to use `ViewEncapsulation.None`.\n-      if (convertProperty) {\n-        propertyValue = convertProperty(key, metadataValue);\n-      }\n-\n-      // In case the property value has not been assigned to an expression, we convert\n-      // the resolved metadata value into a TypeScript expression.\n-      if (propertyValue === null) {\n-        propertyValue = convertDirectiveMetadataToExpression(\n-            compilerModule, metadataValue, resolveSymbolImport, createImport, convertProperty);\n-      }\n-\n-      literalProperties.push(ts.createPropertyAssignment(getPropertyName(key), propertyValue));\n-    }\n-\n-    return ts.createObjectLiteral(literalProperties, true);\n-  }\n-\n-  throw new UnexpectedMetadataValueError();\n-}\n-\n-/**\n- * Gets a valid property name from the given text. If the text cannot be used\n- * as unquoted identifier, the name will be wrapped in a string literal.\n- */\n-function getPropertyName(name: string): string|ts.StringLiteral {\n-  // Matches the most common identifiers that do not need quotes. Constructing a\n-  // regular expression that matches the ECMAScript specification in order to determine\n-  // whether quotes are needed is out of scope for this migration. For those more complex\n-  // property names, we just always use quotes (when constructing AST from metadata).\n-  if (/^[a-zA-Z_$]+$/.test(name)) {\n-    return name;\n-  }\n-  return ts.createStringLiteral(name);\n-}"
        },
        {
            "sha": "12bb8f98a21cffbb2704f76da52b762f86ea979c",
            "filename": "packages/core/schematics/migrations/undecorated-classes-with-di/decorator_rewrite/decorator_rewriter.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 135,
            "changes": 135,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fdecorator_rewrite%2Fdecorator_rewriter.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fdecorator_rewrite%2Fdecorator_rewriter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fdecorator_rewrite%2Fdecorator_rewriter.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,135 +0,0 @@\n-\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import type {AotCompiler} from '@angular/compiler';\n-import ts from 'typescript';\n-\n-import {ImportManager} from '../../../utils/import_manager';\n-import {NgDecorator} from '../../../utils/ng_decorators';\n-import {unwrapExpression} from '../../../utils/typescript/functions';\n-\n-import {ImportRewriteTransformerFactory, UnresolvedIdentifierError} from './import_rewrite_visitor';\n-\n-\n-/**\n- * Class that can be used to copy decorators to a new location. The rewriter ensures that\n- * identifiers and imports are rewritten to work in the new file location. Fields in a\n- * decorator that cannot be cleanly copied will be copied with a comment explaining that\n- * imports and identifiers need to be adjusted manually.\n- */\n-export class DecoratorRewriter {\n-  previousSourceFile: ts.SourceFile|null = null;\n-  newSourceFile: ts.SourceFile|null = null;\n-\n-  newProperties: ts.ObjectLiteralElementLike[] = [];\n-  nonCopyableProperties: ts.ObjectLiteralElementLike[] = [];\n-\n-  private importRewriterFactory = new ImportRewriteTransformerFactory(\n-      this.importManager, this.typeChecker, this.compiler['_host']);\n-\n-  constructor(\n-      private importManager: ImportManager, private typeChecker: ts.TypeChecker,\n-      private compiler: AotCompiler) {}\n-\n-  rewrite(ngDecorator: NgDecorator, newSourceFile: ts.SourceFile): ts.Decorator {\n-    const decorator = ngDecorator.node;\n-\n-    // Reset the previous state of the decorator rewriter.\n-    this.newProperties = [];\n-    this.nonCopyableProperties = [];\n-    this.newSourceFile = newSourceFile;\n-    this.previousSourceFile = decorator.getSourceFile();\n-\n-    // If the decorator will be added to the same source file it currently\n-    // exists in, we don't need to rewrite any paths or add new imports.\n-    if (this.previousSourceFile === newSourceFile) {\n-      return this._createDecorator(decorator.expression);\n-    }\n-\n-    const oldCallExpr = decorator.expression;\n-\n-    if (!oldCallExpr.arguments.length) {\n-      // Re-use the original decorator if there are no arguments and nothing needs\n-      // to be sanitized or rewritten.\n-      return this._createDecorator(decorator.expression);\n-    }\n-\n-    const metadata = unwrapExpression(oldCallExpr.arguments[0]);\n-    if (!ts.isObjectLiteralExpression(metadata)) {\n-      // Re-use the original decorator as there is no metadata that can be sanitized.\n-      return this._createDecorator(decorator.expression);\n-    }\n-\n-    metadata.properties.forEach(prop => {\n-      // We don't handle spread assignments, accessors or method declarations automatically\n-      // as it involves more advanced static analysis and these type of properties are not\n-      // picked up by ngc either.\n-      if (ts.isSpreadAssignment(prop) || ts.isAccessor(prop) || ts.isMethodDeclaration(prop)) {\n-        this.nonCopyableProperties.push(prop);\n-        return;\n-      }\n-\n-      const sanitizedProp = this._sanitizeMetadataProperty(prop);\n-      if (sanitizedProp !== null) {\n-        this.newProperties.push(sanitizedProp);\n-      } else {\n-        this.nonCopyableProperties.push(prop);\n-      }\n-    });\n-\n-    // In case there is at least one non-copyable property, we add a leading comment to\n-    // the first property assignment in order to ask the developer to manually manage\n-    // imports and do path rewriting for these properties.\n-    if (this.nonCopyableProperties.length !== 0) {\n-      ['The following fields were copied from the base class,',\n-       'but could not be updated automatically to work in the',\n-       'new file location. Please add any required imports for', 'the properties below:']\n-          .forEach(\n-              text => ts.addSyntheticLeadingComment(\n-                  this.nonCopyableProperties[0], ts.SyntaxKind.SingleLineCommentTrivia, ` ${text}`,\n-                  true));\n-    }\n-\n-    // Note that we don't update the decorator as we don't want to copy potential leading\n-    // comments of the decorator. This is necessary because otherwise comments from the\n-    // copied decorator end up describing the new class (which is not always correct).\n-    return this._createDecorator(ts.createCall(\n-        this.importManager.addImportToSourceFile(\n-            newSourceFile, ngDecorator.name, ngDecorator.moduleName),\n-        undefined, [ts.updateObjectLiteral(\n-                       metadata, [...this.newProperties, ...this.nonCopyableProperties])]));\n-  }\n-\n-  /** Creates a new decorator with the given expression. */\n-  private _createDecorator(expr: ts.Expression): ts.Decorator {\n-    // Note that we don't update the decorator as we don't want to copy potential leading\n-    // comments of the decorator. This is necessary because otherwise comments from the\n-    // copied decorator end up describing the new class (which is not always correct).\n-    return ts.createDecorator(expr);\n-  }\n-\n-  /**\n-   * Sanitizes a metadata property by ensuring that all contained identifiers\n-   * are imported in the target source file.\n-   */\n-  private _sanitizeMetadataProperty(prop: ts.ObjectLiteralElementLike): ts.ObjectLiteralElementLike\n-      |null {\n-    try {\n-      return ts\n-          .transform(prop, [ctx => this.importRewriterFactory.create(ctx, this.newSourceFile!)])\n-          .transformed[0];\n-    } catch (e) {\n-      // If the error is for an unresolved identifier, we want to return \"null\" because\n-      // such object literal elements could be added to the non-copyable properties.\n-      if (e instanceof UnresolvedIdentifierError) {\n-        return null;\n-      }\n-      throw e;\n-    }\n-  }\n-}"
        },
        {
            "sha": "4f2f1698e4370efb02b47b00d1b46cf4c7215e2d",
            "filename": "packages/core/schematics/migrations/undecorated-classes-with-di/decorator_rewrite/import_rewrite_visitor.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 143,
            "changes": 143,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fdecorator_rewrite%2Fimport_rewrite_visitor.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fdecorator_rewrite%2Fimport_rewrite_visitor.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fdecorator_rewrite%2Fimport_rewrite_visitor.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,143 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import type {AotCompilerHost} from '@angular/compiler';\n-import {dirname, resolve} from 'path';\n-import ts from 'typescript';\n-\n-import {ImportManager} from '../../../utils/import_manager';\n-import {getImportOfIdentifier, Import} from '../../../utils/typescript/imports';\n-import {getValueSymbolOfDeclaration} from '../../../utils/typescript/symbol';\n-\n-import {getPosixPath} from './path_format';\n-import {getExportSymbolsOfFile, ResolvedExport} from './source_file_exports';\n-\n-\n-/**\n- * Factory that creates a TypeScript transformer which ensures that\n- * referenced identifiers are available at the target file location.\n- *\n- * Imports cannot be just added as sometimes identifiers collide in the\n- * target source file and the identifier needs to be aliased.\n- */\n-export class ImportRewriteTransformerFactory {\n-  private sourceFileExports = new Map<ts.SourceFile, ResolvedExport[]>();\n-\n-  constructor(\n-      private importManager: ImportManager, private typeChecker: ts.TypeChecker,\n-      private compilerHost: AotCompilerHost) {}\n-\n-  create<T extends ts.Node>(ctx: ts.TransformationContext, newSourceFile: ts.SourceFile):\n-      ts.Transformer<T> {\n-    const visitNode: ts.Visitor = (node: ts.Node) => {\n-      if (ts.isIdentifier(node)) {\n-        // Record the identifier reference and return the new identifier. The identifier\n-        // name can change if the generated import uses an namespaced import or aliased\n-        // import identifier (to avoid collisions).\n-        return this._recordIdentifierReference(node, newSourceFile);\n-      }\n-\n-      return ts.visitEachChild(node, visitNode, ctx);\n-    };\n-\n-    return (node: T) => ts.visitNode(node, visitNode);\n-  }\n-\n-  private _recordIdentifierReference(node: ts.Identifier, targetSourceFile: ts.SourceFile):\n-      ts.Node {\n-    // For object literal elements we don't want to check identifiers that describe the\n-    // property name. These identifiers do not refer to a value but rather to a property\n-    // name and therefore don't need to be imported. The exception is that for shorthand\n-    // property assignments the \"name\" identifier is both used as value and property name.\n-    if (ts.isObjectLiteralElementLike(node.parent) &&\n-        !ts.isShorthandPropertyAssignment(node.parent) && node.parent.name === node) {\n-      return node;\n-    }\n-\n-    const resolvedImport = getImportOfIdentifier(this.typeChecker, node);\n-    const sourceFile = node.getSourceFile();\n-\n-    if (resolvedImport) {\n-      const symbolName = resolvedImport.name;\n-      const moduleFileName =\n-          this.compilerHost.moduleNameToFileName(resolvedImport.importModule, sourceFile.fileName);\n-\n-      // In case the identifier refers to an export in the target source file, we need to use\n-      // the local identifier in the scope of the target source file. This is necessary because\n-      // the export could be aliased and the alias is not available to the target source file.\n-      if (moduleFileName && resolve(moduleFileName) === resolve(targetSourceFile.fileName)) {\n-        const resolvedExport =\n-            this._getSourceFileExports(targetSourceFile).find(e => e.exportName === symbolName);\n-        if (resolvedExport) {\n-          return resolvedExport.identifier;\n-        }\n-      }\n-\n-      return this.importManager.addImportToSourceFile(\n-          targetSourceFile, symbolName,\n-          this._rewriteModuleImport(resolvedImport, targetSourceFile));\n-    } else {\n-      let symbol = getValueSymbolOfDeclaration(node, this.typeChecker);\n-\n-      if (symbol) {\n-        // If the symbol refers to a shorthand property assignment, we want to resolve the\n-        // value symbol of the shorthand property assignment. This is necessary because the\n-        // value symbol is ambiguous for shorthand property assignment identifiers as the\n-        // identifier resolves to both property name and property value.\n-        if (symbol.valueDeclaration && ts.isShorthandPropertyAssignment(symbol.valueDeclaration)) {\n-          symbol = this.typeChecker.getShorthandAssignmentValueSymbol(symbol.valueDeclaration);\n-        }\n-\n-        const resolvedExport =\n-            this._getSourceFileExports(sourceFile).find(e => e.symbol === symbol);\n-\n-        if (resolvedExport) {\n-          return this.importManager.addImportToSourceFile(\n-              targetSourceFile, resolvedExport.exportName,\n-              getPosixPath(this.compilerHost.fileNameToModuleName(\n-                  sourceFile.fileName, targetSourceFile.fileName)));\n-        }\n-      }\n-\n-      // The referenced identifier cannot be imported. In that case we throw an exception\n-      // which can be handled outside of the transformer.\n-      throw new UnresolvedIdentifierError();\n-    }\n-  }\n-\n-  /**\n-   * Gets the resolved exports of a given source file. Exports are cached\n-   * for subsequent calls.\n-   */\n-  private _getSourceFileExports(sourceFile: ts.SourceFile): ResolvedExport[] {\n-    if (this.sourceFileExports.has(sourceFile)) {\n-      return this.sourceFileExports.get(sourceFile)!;\n-    }\n-\n-    const sourceFileExports = getExportSymbolsOfFile(sourceFile, this.typeChecker);\n-    this.sourceFileExports.set(sourceFile, sourceFileExports);\n-    return sourceFileExports;\n-  }\n-\n-  /** Rewrites a module import to be relative to the target file location. */\n-  private _rewriteModuleImport(resolvedImport: Import, newSourceFile: ts.SourceFile): string {\n-    if (!resolvedImport.importModule.startsWith('.')) {\n-      return resolvedImport.importModule;\n-    }\n-\n-    const importFilePath = resolvedImport.node.getSourceFile().fileName;\n-    const resolvedModulePath = resolve(dirname(importFilePath), resolvedImport.importModule);\n-    const relativeModuleName =\n-        this.compilerHost.fileNameToModuleName(resolvedModulePath, newSourceFile.fileName);\n-\n-    return getPosixPath(relativeModuleName);\n-  }\n-}\n-\n-/** Error that will be thrown if a given identifier cannot be resolved. */\n-export class UnresolvedIdentifierError extends Error {}"
        },
        {
            "sha": "1528bfc80085911fccdc2d10aaea02d36fad3afb",
            "filename": "packages/core/schematics/migrations/undecorated-classes-with-di/decorator_rewrite/path_format.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fdecorator_rewrite%2Fpath_format.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fdecorator_rewrite%2Fpath_format.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fdecorator_rewrite%2Fpath_format.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,18 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {normalize} from 'path';\n-\n-/** Normalizes the specified path to conform with the posix path format. */\n-export function getPosixPath(pathString: string) {\n-  const normalized = normalize(pathString).replace(/\\\\/g, '/');\n-  if (!normalized.startsWith('.')) {\n-    return `./${normalized}`;\n-  }\n-  return normalized;\n-}"
        },
        {
            "sha": "93ae905421ab79d3b970438370a9aaba69eb65c7",
            "filename": "packages/core/schematics/migrations/undecorated-classes-with-di/decorator_rewrite/source_file_exports.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 59,
            "changes": 59,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fdecorator_rewrite%2Fsource_file_exports.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fdecorator_rewrite%2Fsource_file_exports.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fdecorator_rewrite%2Fsource_file_exports.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,59 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-import {getValueSymbolOfDeclaration} from '../../../utils/typescript/symbol';\n-\n-export interface ResolvedExport {\n-  symbol: ts.Symbol;\n-  exportName: string;\n-  identifier: ts.Identifier;\n-}\n-\n-/** Computes the resolved exports of a given source file. */\n-export function getExportSymbolsOfFile(\n-    sf: ts.SourceFile, typeChecker: ts.TypeChecker): ResolvedExport[] {\n-  const exports: {exportName: string, identifier: ts.Identifier}[] = [];\n-  const resolvedExports: ResolvedExport[] = [];\n-\n-  ts.forEachChild(sf, function visitNode(node) {\n-    if (ts.isClassDeclaration(node) || ts.isFunctionDeclaration(node) ||\n-        ts.isInterfaceDeclaration(node) &&\n-            (ts.getCombinedModifierFlags(node as ts.Declaration) & ts.ModifierFlags.Export) !== 0) {\n-      if (node.name) {\n-        exports.push({exportName: node.name.text, identifier: node.name});\n-      }\n-    } else if (ts.isVariableStatement(node)) {\n-      for (const decl of node.declarationList.declarations) {\n-        visitNode(decl);\n-      }\n-    } else if (ts.isVariableDeclaration(node)) {\n-      if ((ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) != 0 &&\n-          ts.isIdentifier(node.name)) {\n-        exports.push({exportName: node.name.text, identifier: node.name});\n-      }\n-    } else if (ts.isExportDeclaration(node)) {\n-      const {moduleSpecifier, exportClause} = node;\n-      if (!moduleSpecifier && exportClause && ts.isNamedExports(exportClause)) {\n-        exportClause.elements.forEach(el => exports.push({\n-          exportName: el.name.text,\n-          identifier: el.propertyName ? el.propertyName : el.name\n-        }));\n-      }\n-    }\n-  });\n-\n-  exports.forEach(({identifier, exportName}) => {\n-    const symbol = getValueSymbolOfDeclaration(identifier, typeChecker);\n-    if (symbol) {\n-      resolvedExports.push({symbol, identifier, exportName});\n-    }\n-  });\n-\n-  return resolvedExports;\n-}"
        },
        {
            "sha": "95479905fed133cd8bc0b5c673bfd67910a6dd66",
            "filename": "packages/core/schematics/migrations/undecorated-classes-with-di/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 253,
            "changes": 253,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,253 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {logging} from '@angular-devkit/core';\n-import {Rule, SchematicContext, SchematicsException, Tree} from '@angular-devkit/schematics';\n-import type {AotCompiler} from '@angular/compiler';\n-import type {Diagnostic as NgDiagnostic} from '@angular/compiler-cli';\n-import {relative} from 'path';\n-import ts from 'typescript';\n-\n-import {loadCompilerCliMigrationsModule, loadEsmModule} from '../../utils/load_esm';\n-import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n-import {canMigrateFile, createMigrationCompilerHost} from '../../utils/typescript/compiler_host';\n-\n-import {createNgcProgram} from './create_ngc_program';\n-import {NgDeclarationCollector} from './ng_declaration_collector';\n-import {UndecoratedClassesTransform} from './transform';\n-import {UpdateRecorder} from './update_recorder';\n-\n-const MIGRATION_RERUN_MESSAGE = 'Migration can be rerun with: \"ng update @angular/core ' +\n-    '--migrate-only migration-v9-undecorated-classes-with-di\"';\n-\n-const MIGRATION_AOT_FAILURE = 'This migration uses the Angular compiler internally and ' +\n-    'therefore projects that no longer build successfully after the update cannot run ' +\n-    'the migration. Please ensure there are no AOT compilation errors and rerun the migration.';\n-\n-/** Entry point for the V9 \"undecorated-classes-with-di\" migration. */\n-export default function(): Rule {\n-  return async (tree: Tree, ctx: SchematicContext) => {\n-    const {buildPaths} = await getProjectTsConfigPaths(tree);\n-    const basePath = process.cwd();\n-    const failures: string[] = [];\n-    let programError = false;\n-\n-    if (!buildPaths.length) {\n-      throw new SchematicsException(\n-          'Could not find any tsconfig file. Cannot migrate undecorated derived classes and ' +\n-          'undecorated base classes which use DI.');\n-    }\n-\n-    let compilerModule;\n-    try {\n-      // Load ESM `@angular/compiler` using the TypeScript dynamic import workaround.\n-      // Once TypeScript provides support for keeping the dynamic import this workaround can be\n-      // changed to a direct dynamic import.\n-      compilerModule = await loadEsmModule<typeof import('@angular/compiler')>('@angular/compiler');\n-    } catch (e) {\n-      throw new SchematicsException(\n-          `Unable to load the '@angular/compiler' package. Details: ${e.message}`);\n-    }\n-\n-    let compilerCliModule;\n-    try {\n-      // Load ESM `@angular/compiler-cli` using the TypeScript dynamic import workaround.\n-      // Once TypeScript provides support for keeping the dynamic import this workaround can be\n-      // changed to a direct dynamic import.\n-      compilerCliModule =\n-          await loadEsmModule<typeof import('@angular/compiler-cli')>('@angular/compiler-cli');\n-    } catch (e) {\n-      throw new SchematicsException(\n-          `Unable to load the '@angular/compiler-cli' package. Details: ${e.message}`);\n-    }\n-\n-    let coreModule;\n-    try {\n-      // Load ESM `@angular/compiler-cli` using the TypeScript dynamic import workaround.\n-      // Once TypeScript provides support for keeping the dynamic import this workaround can be\n-      // changed to a direct dynamic import.\n-      coreModule = await loadEsmModule<typeof import('@angular/core')>('@angular/core');\n-    } catch (e) {\n-      throw new SchematicsException(\n-          `Unable to load the '@angular/core' package. Details: ${e.message}`);\n-    }\n-\n-    let compilerCliMigrationsModule;\n-    try {\n-      // Load ESM `@angular/compiler/private/migrations` using the TypeScript dynamic import\n-      // workaround. Once TypeScript provides support for keeping the dynamic import this workaround\n-      // can be changed to a direct dynamic import.\n-      compilerCliMigrationsModule = await loadCompilerCliMigrationsModule();\n-    } catch (e) {\n-      throw new SchematicsException(\n-          `Unable to load the '@angular/compiler-cli' package. Details: ${e.message}`);\n-    }\n-\n-    for (const tsconfigPath of buildPaths) {\n-      const result = runUndecoratedClassesMigration(\n-          tree, tsconfigPath, basePath, ctx.logger, compilerModule, compilerCliModule,\n-          compilerCliMigrationsModule, coreModule);\n-      failures.push(...result.failures);\n-      programError = programError || !!result.programError;\n-    }\n-\n-    if (programError) {\n-      ctx.logger.info('Could not migrate all undecorated classes that use dependency');\n-      ctx.logger.info('injection. Some project targets could not be analyzed due to');\n-      ctx.logger.info('TypeScript program failures.\\n');\n-      ctx.logger.info(`${MIGRATION_RERUN_MESSAGE}\\n`);\n-\n-      if (failures.length) {\n-        ctx.logger.info('Please manually fix the following failures and re-run the');\n-        ctx.logger.info('migration once the TypeScript program failures are resolved.');\n-        failures.forEach(message => ctx.logger.warn(`   ${message}`));\n-      }\n-    } else if (failures.length) {\n-      ctx.logger.info('Could not migrate all undecorated classes that use dependency');\n-      ctx.logger.info('injection. Please manually fix the following failures:');\n-      failures.forEach(message => ctx.logger.warn(`   ${message}`));\n-    }\n-  };\n-}\n-\n-function runUndecoratedClassesMigration(\n-    tree: Tree, tsconfigPath: string, basePath: string, logger: logging.LoggerApi,\n-    compilerModule: typeof import('@angular/compiler'),\n-    compilerCliModule: typeof import('@angular/compiler-cli'),\n-    compilerCliMigrationsModule: typeof import('@angular/compiler-cli/private/migrations'),\n-    coreModule: typeof import('@angular/core')): {failures: string[], programError?: boolean} {\n-  const failures: string[] = [];\n-  const programData =\n-      gracefullyCreateProgram(tree, basePath, tsconfigPath, logger, compilerCliModule);\n-\n-  // Gracefully exit if the program could not be created.\n-  if (programData === null) {\n-    return {failures: [], programError: true};\n-  }\n-\n-  const {program, compiler} = programData;\n-  const typeChecker = program.getTypeChecker();\n-\n-  const declarationCollector = new NgDeclarationCollector(typeChecker, compilerCliMigrationsModule);\n-  const sourceFiles =\n-      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n-\n-  // Analyze source files by detecting all directives, components and providers.\n-  sourceFiles.forEach(sourceFile => declarationCollector.visitNode(sourceFile));\n-\n-  const {decoratedDirectives, decoratedProviders, undecoratedDeclarations} = declarationCollector;\n-  const transform = new UndecoratedClassesTransform(\n-      typeChecker, compiler, getUpdateRecorder, compilerModule, coreModule);\n-  const updateRecorders = new Map<ts.SourceFile, UpdateRecorder>();\n-\n-  // Run the migrations for decorated providers and both decorated and undecorated\n-  // directives. The transform failures are collected and converted into human-readable\n-  // failures which can be printed to the console.\n-  [...transform.migrateDecoratedDirectives(decoratedDirectives),\n-   ...transform.migrateDecoratedProviders(decoratedProviders),\n-   ...transform.migrateUndecoratedDeclarations(Array.from(undecoratedDeclarations))]\n-      .forEach(({node, message}) => {\n-        const nodeSourceFile = node.getSourceFile();\n-        const relativeFilePath = relative(basePath, nodeSourceFile.fileName);\n-        const {line, character} =\n-            ts.getLineAndCharacterOfPosition(node.getSourceFile(), node.getStart());\n-        failures.push(`${relativeFilePath}@${line + 1}:${character + 1}: ${message}`);\n-      });\n-\n-  // Record the changes collected in the import manager and transformer.\n-  transform.recordChanges();\n-\n-  // Walk through each update recorder and commit the update. We need to commit the\n-  // updates in batches per source file as there can be only one recorder per source\n-  // file in order to avoid shifted character offsets.\n-  updateRecorders.forEach(recorder => recorder.commitUpdate());\n-\n-  return {failures};\n-\n-  /** Gets the update recorder for the specified source file. */\n-  function getUpdateRecorder(sourceFile: ts.SourceFile): UpdateRecorder {\n-    if (updateRecorders.has(sourceFile)) {\n-      return updateRecorders.get(sourceFile)!;\n-    }\n-    const treeRecorder = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n-    const recorder: UpdateRecorder = {\n-      addClassComment(node: ts.ClassDeclaration, text: string) {\n-        treeRecorder.insertLeft(node.members.pos, `\\n  // ${text}\\n`);\n-      },\n-      addClassDecorator(node: ts.ClassDeclaration, text: string) {\n-        // New imports should be inserted at the left while decorators should be inserted\n-        // at the right in order to ensure that imports are inserted before the decorator\n-        // if the start position of import and decorator is the source file start.\n-        treeRecorder.insertRight(node.getStart(), `${text}\\n`);\n-      },\n-      addNewImport(start: number, importText: string) {\n-        // New imports should be inserted at the left while decorators should be inserted\n-        // at the right in order to ensure that imports are inserted before the decorator\n-        // if the start position of import and decorator is the source file start.\n-        treeRecorder.insertLeft(start, importText);\n-      },\n-      updateExistingImport(namedBindings: ts.NamedImports, newNamedBindings: string) {\n-        treeRecorder.remove(namedBindings.getStart(), namedBindings.getWidth());\n-        treeRecorder.insertRight(namedBindings.getStart(), newNamedBindings);\n-      },\n-      commitUpdate() {\n-        tree.commitUpdate(treeRecorder);\n-      }\n-    };\n-    updateRecorders.set(sourceFile, recorder);\n-    return recorder;\n-  }\n-}\n-\n-function getErrorDiagnostics(diagnostics: ReadonlyArray<ts.Diagnostic|NgDiagnostic>) {\n-  return <ts.Diagnostic[]>diagnostics.filter(d => d.category === ts.DiagnosticCategory.Error);\n-}\n-\n-function gracefullyCreateProgram(\n-    tree: Tree, basePath: string, tsconfigPath: string, logger: logging.LoggerApi,\n-    compilerCliModule: typeof import('@angular/compiler-cli')):\n-    {compiler: AotCompiler, program: ts.Program}|null {\n-  try {\n-    const {ngcProgram, host, program, compiler} = createNgcProgram(\n-        compilerCliModule, (options) => createMigrationCompilerHost(tree, options, basePath),\n-        tsconfigPath);\n-    const syntacticDiagnostics = getErrorDiagnostics(ngcProgram.getTsSyntacticDiagnostics());\n-    const structuralDiagnostics = getErrorDiagnostics(ngcProgram.getNgStructuralDiagnostics());\n-    const configDiagnostics = getErrorDiagnostics(\n-        [...program.getOptionsDiagnostics(), ...ngcProgram.getNgOptionDiagnostics()]);\n-\n-    if (configDiagnostics.length) {\n-      logger.warn(\n-          `\\nTypeScript project \"${tsconfigPath}\" has configuration errors. This could cause ` +\n-          `an incomplete migration. Please fix the following failures and rerun the migration:`);\n-      logger.error(ts.formatDiagnostics(configDiagnostics, host));\n-      return null;\n-    }\n-\n-    // Syntactic TypeScript errors can throw off the query analysis and therefore we want\n-    // to notify the developer that we couldn't analyze parts of the project. Developers\n-    // can just re-run the migration after fixing these failures.\n-    if (syntacticDiagnostics.length) {\n-      logger.warn(\n-          `\\nTypeScript project \"${tsconfigPath}\" has syntactical errors which could cause ` +\n-          `an incomplete migration. Please fix the following failures and rerun the migration:`);\n-      logger.error(ts.formatDiagnostics(syntacticDiagnostics, host));\n-      return null;\n-    }\n-\n-    if (structuralDiagnostics.length) {\n-      throw new Error(ts.formatDiagnostics(<ts.Diagnostic[]>structuralDiagnostics, host));\n-    }\n-\n-    return {program, compiler};\n-  } catch (e) {\n-    logger.warn(`\\n${MIGRATION_AOT_FAILURE} The following project failed: ${tsconfigPath}\\n`);\n-    logger.error(`${e.toString()}\\n`);\n-    return null;\n-  }\n-}"
        },
        {
            "sha": "99218da5228b04aeb3e12ce09b265b0203cb6fea",
            "filename": "packages/core/schematics/migrations/undecorated-classes-with-di/ng_declaration_collector.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 144,
            "changes": 144,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fng_declaration_collector.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fng_declaration_collector.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fng_declaration_collector.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,144 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {getAngularDecorators, NgDecorator} from '../../utils/ng_decorators';\n-import {getPropertyNameText} from '../../utils/typescript/property_name';\n-\n-\n-/**\n- * Visitor that walks through specified TypeScript nodes and collects all defined\n- * directives and provider classes. Directives are separated by decorated and\n- * undecorated directives.\n- */\n-export class NgDeclarationCollector {\n-  /** List of resolved directives which are decorated. */\n-  decoratedDirectives: ts.ClassDeclaration[] = [];\n-\n-  /** List of resolved providers which are decorated. */\n-  decoratedProviders: ts.ClassDeclaration[] = [];\n-\n-  /** Set of resolved Angular declarations which are not decorated. */\n-  undecoratedDeclarations = new Set<ts.ClassDeclaration>();\n-\n-  private evaluator;\n-\n-  constructor(\n-      public typeChecker: ts.TypeChecker,\n-      private compilerCliMigrationsModule:\n-          typeof import('@angular/compiler-cli/private/migrations')) {\n-    this.evaluator = new compilerCliMigrationsModule.PartialEvaluator(\n-        new compilerCliMigrationsModule.TypeScriptReflectionHost(typeChecker), typeChecker,\n-        /* dependencyTracker */ null);\n-  }\n-\n-  visitNode(node: ts.Node) {\n-    if (ts.isClassDeclaration(node)) {\n-      this._visitClassDeclaration(node);\n-    }\n-\n-    ts.forEachChild(node, n => this.visitNode(n));\n-  }\n-\n-  private _visitClassDeclaration(node: ts.ClassDeclaration) {\n-    if (!node.decorators || !node.decorators.length) {\n-      return;\n-    }\n-\n-    const ngDecorators = getAngularDecorators(this.typeChecker, node.decorators);\n-    const ngModuleDecorator = ngDecorators.find(({name}) => name === 'NgModule');\n-\n-    if (hasDirectiveDecorator(node, this.typeChecker, ngDecorators)) {\n-      this.decoratedDirectives.push(node);\n-    } else if (hasInjectableDecorator(node, this.typeChecker, ngDecorators)) {\n-      this.decoratedProviders.push(node);\n-    } else if (ngModuleDecorator) {\n-      this._visitNgModuleDecorator(ngModuleDecorator);\n-    }\n-  }\n-\n-  private _visitNgModuleDecorator(decorator: NgDecorator) {\n-    const decoratorCall = decorator.node.expression;\n-    const metadata = decoratorCall.arguments[0];\n-\n-    if (!metadata || !ts.isObjectLiteralExpression(metadata)) {\n-      return;\n-    }\n-\n-    let entryComponentsNode: ts.Expression|null = null;\n-    let declarationsNode: ts.Expression|null = null;\n-\n-    metadata.properties.forEach(p => {\n-      if (!ts.isPropertyAssignment(p)) {\n-        return;\n-      }\n-\n-      const name = getPropertyNameText(p.name);\n-\n-      if (name === 'entryComponents') {\n-        entryComponentsNode = p.initializer;\n-      } else if (name === 'declarations') {\n-        declarationsNode = p.initializer;\n-      }\n-    });\n-\n-    const values = [];\n-\n-    // In case the module specifies the \"entryComponents\" field, walk through all\n-    // resolved entry components and collect the referenced directives.\n-    if (entryComponentsNode) {\n-      values.push(this.evaluator.evaluate(entryComponentsNode));\n-    }\n-\n-    // In case the module specifies the \"declarations\" field, walk through all\n-    // resolved declarations and collect the referenced directives.\n-    if (declarationsNode) {\n-      values.push(this.evaluator.evaluate(declarationsNode));\n-    }\n-\n-    // Flatten values and analyze references\n-    for (const value of values.flat(Infinity)) {\n-      if (value instanceof this.compilerCliMigrationsModule.Reference &&\n-          ts.isClassDeclaration(value.node) &&\n-          !hasNgDeclarationDecorator(value.node, this.typeChecker)) {\n-        this.undecoratedDeclarations.add(value.node);\n-      }\n-    }\n-  }\n-}\n-\n-/** Checks whether the given node has the \"@Directive\" or \"@Component\" decorator set. */\n-export function hasDirectiveDecorator(\n-    node: ts.ClassDeclaration, typeChecker: ts.TypeChecker, ngDecorators?: NgDecorator[]): boolean {\n-  return (ngDecorators || getNgClassDecorators(node, typeChecker))\n-      .some(({name}) => name === 'Directive' || name === 'Component');\n-}\n-\n-\n-\n-/** Checks whether the given node has the \"@Injectable\" decorator set. */\n-export function hasInjectableDecorator(\n-    node: ts.ClassDeclaration, typeChecker: ts.TypeChecker, ngDecorators?: NgDecorator[]): boolean {\n-  return (ngDecorators || getNgClassDecorators(node, typeChecker))\n-      .some(({name}) => name === 'Injectable');\n-}\n-/** Whether the given node has an explicit decorator that describes an Angular declaration. */\n-export function hasNgDeclarationDecorator(node: ts.ClassDeclaration, typeChecker: ts.TypeChecker) {\n-  return getNgClassDecorators(node, typeChecker)\n-      .some(({name}) => name === 'Component' || name === 'Directive' || name === 'Pipe');\n-}\n-\n-/** Gets all Angular decorators of a given class declaration. */\n-export function getNgClassDecorators(\n-    node: ts.ClassDeclaration, typeChecker: ts.TypeChecker): NgDecorator[] {\n-  if (!node.decorators) {\n-    return [];\n-  }\n-  return getAngularDecorators(typeChecker, node.decorators);\n-}"
        },
        {
            "sha": "2d0e81277864a0b3cc0a83c79e07b5441c30f3d7",
            "filename": "packages/core/schematics/migrations/undecorated-classes-with-di/transform.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 459,
            "changes": 459,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Ftransform.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Ftransform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Ftransform.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,459 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import type {AotCompiler, AotCompilerHost, CompileMetadataResolver, StaticSymbol, StaticSymbolResolver, SummaryResolver} from '@angular/compiler';\n-import ts from 'typescript';\n-\n-import {ImportManager} from '../../utils/import_manager';\n-import {getAngularDecorators} from '../../utils/ng_decorators';\n-import {hasExplicitConstructor} from '../../utils/typescript/class_declaration';\n-import {findBaseClassDeclarations} from '../../utils/typescript/find_base_classes';\n-import {getImportOfIdentifier} from '../../utils/typescript/imports';\n-\n-import {convertDirectiveMetadataToExpression, UnexpectedMetadataValueError} from './decorator_rewrite/convert_directive_metadata';\n-import {DecoratorRewriter} from './decorator_rewrite/decorator_rewriter';\n-import {hasDirectiveDecorator, hasInjectableDecorator} from './ng_declaration_collector';\n-import {UpdateRecorder} from './update_recorder';\n-\n-\n-\n-/** Resolved metadata of a declaration. */\n-interface DeclarationMetadata {\n-  metadata: any;\n-  type: 'Component'|'Directive'|'Pipe';\n-}\n-\n-export interface TransformFailure {\n-  node: ts.Node;\n-  message: string;\n-}\n-\n-export class UndecoratedClassesTransform {\n-  private printer = ts.createPrinter({newLine: ts.NewLineKind.LineFeed});\n-  private importManager = new ImportManager(this.getUpdateRecorder, this.printer);\n-  private decoratorRewriter =\n-      new DecoratorRewriter(this.importManager, this.typeChecker, this.compiler);\n-\n-  private compilerHost: AotCompilerHost;\n-  private symbolResolver: StaticSymbolResolver;\n-  private metadataResolver: CompileMetadataResolver;\n-\n-  /** Set of class declarations which have been decorated with \"@Directive\". */\n-  private decoratedDirectives = new Set<ts.ClassDeclaration>();\n-  /** Set of class declarations which have been decorated with \"@Injectable\" */\n-  private decoratedProviders = new Set<ts.ClassDeclaration>();\n-  /**\n-   * Set of class declarations which have been analyzed and need to specify\n-   * an explicit constructor.\n-   */\n-  private missingExplicitConstructorClasses = new Set<ts.ClassDeclaration>();\n-\n-  constructor(\n-      private typeChecker: ts.TypeChecker, private compiler: AotCompiler,\n-      private getUpdateRecorder: (sf: ts.SourceFile) => UpdateRecorder,\n-      private compilerModule: typeof import('@angular/compiler'),\n-      private coreModule: typeof import('@angular/core')) {\n-    this.symbolResolver = compiler['_symbolResolver'];\n-    this.compilerHost = compiler['_host'];\n-    this.metadataResolver = compiler['_metadataResolver'];\n-\n-    // Unset the default error recorder so that the reflector will throw an exception\n-    // if metadata cannot be resolved.\n-    this.compiler.reflector['errorRecorder'] = undefined;\n-\n-    // Disables that static symbols are resolved through summaries from within the static\n-    // reflector. Summaries cannot be used for decorator serialization as decorators are\n-    // omitted in summaries and the decorator can't be reconstructed from the directive summary.\n-    this._disableSummaryResolution();\n-  }\n-\n-  /**\n-   * Migrates decorated directives which can potentially inherit a constructor\n-   * from an undecorated base class. All base classes until the first one\n-   * with an explicit constructor will be decorated with the abstract \"@Directive()\"\n-   * decorator. See case 1 in the migration plan: https://hackmd.io/@alx/S1XKqMZeS\n-   */\n-  migrateDecoratedDirectives(directives: ts.ClassDeclaration[]): TransformFailure[] {\n-    return directives.reduce(\n-        (failures, node) => failures.concat(this._migrateDirectiveBaseClass(node)),\n-        [] as TransformFailure[]);\n-  }\n-\n-  /**\n-   * Migrates decorated providers which can potentially inherit a constructor\n-   * from an undecorated base class. All base classes until the first one\n-   * with an explicit constructor will be decorated with the \"@Injectable()\".\n-   */\n-  migrateDecoratedProviders(providers: ts.ClassDeclaration[]): TransformFailure[] {\n-    return providers.reduce(\n-        (failures, node) => failures.concat(this._migrateProviderBaseClass(node)),\n-        [] as TransformFailure[]);\n-  }\n-\n-  private _migrateProviderBaseClass(node: ts.ClassDeclaration): TransformFailure[] {\n-    return this._migrateDecoratedClassWithInheritedCtor(\n-        node, symbol => this.metadataResolver.isInjectable(symbol),\n-        node => this._addInjectableDecorator(node));\n-  }\n-\n-  private _migrateDirectiveBaseClass(node: ts.ClassDeclaration): TransformFailure[] {\n-    return this._migrateDecoratedClassWithInheritedCtor(\n-        node, symbol => this.metadataResolver.isDirective(symbol),\n-        node => this._addAbstractDirectiveDecorator(node));\n-  }\n-\n-\n-  private _migrateDecoratedClassWithInheritedCtor(\n-      node: ts.ClassDeclaration, isClassDecorated: (symbol: StaticSymbol) => boolean,\n-      addClassDecorator: (node: ts.ClassDeclaration) => void): TransformFailure[] {\n-    // In case the provider has an explicit constructor, we don't need to do anything\n-    // because the class is already decorated and does not inherit a constructor.\n-    if (hasExplicitConstructor(node)) {\n-      return [];\n-    }\n-\n-    const orderedBaseClasses = findBaseClassDeclarations(node, this.typeChecker);\n-    const undecoratedBaseClasses: ts.ClassDeclaration[] = [];\n-\n-    for (let {node: baseClass, identifier} of orderedBaseClasses) {\n-      const baseClassFile = baseClass.getSourceFile();\n-\n-      if (hasExplicitConstructor(baseClass)) {\n-        // All classes in between the decorated class and the undecorated class\n-        // that defines the constructor need to be decorated as well.\n-        undecoratedBaseClasses.forEach(b => addClassDecorator(b));\n-\n-        if (baseClassFile.isDeclarationFile) {\n-          const staticSymbol = this._getStaticSymbolOfIdentifier(identifier);\n-\n-          // If the base class is decorated through metadata files, we don't\n-          // need to add a comment to the derived class for the external base class.\n-          if (staticSymbol && isClassDecorated(staticSymbol)) {\n-            break;\n-          }\n-\n-          // Find the last class in the inheritance chain that is decorated and will be\n-          // used as anchor for a comment explaining that the class that defines the\n-          // constructor cannot be decorated automatically.\n-          const lastDecoratedClass =\n-              undecoratedBaseClasses[undecoratedBaseClasses.length - 1] || node;\n-          return this._addMissingExplicitConstructorTodo(lastDecoratedClass);\n-        }\n-\n-        // Decorate the class that defines the constructor that is inherited.\n-        addClassDecorator(baseClass);\n-        break;\n-      }\n-\n-      // Add the class decorator for all base classes in the inheritance chain until\n-      // the base class with the explicit constructor. The decorator will be only\n-      // added for base classes which can be modified.\n-      if (!baseClassFile.isDeclarationFile) {\n-        undecoratedBaseClasses.push(baseClass);\n-      }\n-    }\n-    return [];\n-  }\n-\n-  /**\n-   * Adds the abstract \"@Directive()\" decorator to the given class in case there\n-   * is no existing directive decorator.\n-   */\n-  private _addAbstractDirectiveDecorator(baseClass: ts.ClassDeclaration) {\n-    if (hasDirectiveDecorator(baseClass, this.typeChecker) ||\n-        this.decoratedDirectives.has(baseClass)) {\n-      return;\n-    }\n-\n-    const baseClassFile = baseClass.getSourceFile();\n-    const recorder = this.getUpdateRecorder(baseClassFile);\n-    const directiveExpr =\n-        this.importManager.addImportToSourceFile(baseClassFile, 'Directive', '@angular/core');\n-\n-    const newDecorator = ts.createDecorator(ts.createCall(directiveExpr, undefined, []));\n-    const newDecoratorText =\n-        this.printer.printNode(ts.EmitHint.Unspecified, newDecorator, baseClassFile);\n-\n-    recorder.addClassDecorator(baseClass, newDecoratorText);\n-    this.decoratedDirectives.add(baseClass);\n-  }\n-\n-  /**\n-   * Adds the abstract \"@Injectable()\" decorator to the given class in case there\n-   * is no existing directive decorator.\n-   */\n-  private _addInjectableDecorator(baseClass: ts.ClassDeclaration) {\n-    if (hasInjectableDecorator(baseClass, this.typeChecker) ||\n-        this.decoratedProviders.has(baseClass)) {\n-      return;\n-    }\n-\n-    const baseClassFile = baseClass.getSourceFile();\n-    const recorder = this.getUpdateRecorder(baseClassFile);\n-    const injectableExpr =\n-        this.importManager.addImportToSourceFile(baseClassFile, 'Injectable', '@angular/core');\n-\n-    const newDecorator = ts.createDecorator(ts.createCall(injectableExpr, undefined, []));\n-    const newDecoratorText =\n-        this.printer.printNode(ts.EmitHint.Unspecified, newDecorator, baseClassFile);\n-\n-    recorder.addClassDecorator(baseClass, newDecoratorText);\n-    this.decoratedProviders.add(baseClass);\n-  }\n-\n-  /** Adds a comment for adding an explicit constructor to the given class declaration. */\n-  private _addMissingExplicitConstructorTodo(node: ts.ClassDeclaration): TransformFailure[] {\n-    // In case a todo comment has been already inserted to the given class, we don't\n-    // want to add a comment or transform failure multiple times.\n-    if (this.missingExplicitConstructorClasses.has(node)) {\n-      return [];\n-    }\n-    this.missingExplicitConstructorClasses.add(node);\n-    const recorder = this.getUpdateRecorder(node.getSourceFile());\n-    recorder.addClassComment(node, 'TODO: add explicit constructor');\n-    return [{node: node, message: 'Class needs to declare an explicit constructor.'}];\n-  }\n-\n-  /**\n-   * Migrates undecorated directives which were referenced in NgModule declarations.\n-   * These directives inherit the metadata from a parent base class, but with Ivy\n-   * these classes need to explicitly have a decorator for locality. The migration\n-   * determines the inherited decorator and copies it to the undecorated declaration.\n-   *\n-   * Note that the migration serializes the metadata for external declarations\n-   * where the decorator is not part of the source file AST.\n-   *\n-   * See case 2 in the migration plan: https://hackmd.io/@alx/S1XKqMZeS\n-   */\n-  migrateUndecoratedDeclarations(directives: ts.ClassDeclaration[]): TransformFailure[] {\n-    return directives.reduce(\n-        (failures, node) => failures.concat(this._migrateDerivedDeclaration(node)),\n-        [] as TransformFailure[]);\n-  }\n-\n-  private _migrateDerivedDeclaration(node: ts.ClassDeclaration): TransformFailure[] {\n-    const targetSourceFile = node.getSourceFile();\n-    const orderedBaseClasses = findBaseClassDeclarations(node, this.typeChecker);\n-    let newDecoratorText: string|null = null;\n-\n-    for (let {node: baseClass, identifier} of orderedBaseClasses) {\n-      // Before looking for decorators within the metadata or summary files, we\n-      // try to determine the directive decorator through the source file AST.\n-      if (baseClass.decorators) {\n-        const ngDecorator =\n-            getAngularDecorators(this.typeChecker, baseClass.decorators)\n-                .find(({name}) => name === 'Component' || name === 'Directive' || name === 'Pipe');\n-\n-        if (ngDecorator) {\n-          const newDecorator = this.decoratorRewriter.rewrite(ngDecorator, node.getSourceFile());\n-          newDecoratorText = this.printer.printNode(\n-              ts.EmitHint.Unspecified, newDecorator, ngDecorator.node.getSourceFile());\n-          break;\n-        }\n-      }\n-\n-      // If no metadata could be found within the source-file AST, try to find\n-      // decorator data through Angular metadata and summary files.\n-      const staticSymbol = this._getStaticSymbolOfIdentifier(identifier);\n-\n-      // Check if the static symbol resolves to a class declaration with\n-      // pipe or directive metadata.\n-      if (!staticSymbol ||\n-          !(this.metadataResolver.isPipe(staticSymbol) ||\n-            this.metadataResolver.isDirective(staticSymbol))) {\n-        continue;\n-      }\n-\n-      const metadata = this._resolveDeclarationMetadata(staticSymbol);\n-\n-      // If no metadata could be resolved for the static symbol, print a failure message\n-      // and ask the developer to manually migrate the class. This case is rare because\n-      // usually decorator metadata is always present but just can't be read if a program\n-      // only has access to summaries (this is a special case in google3).\n-      if (!metadata) {\n-        return [{\n-          node,\n-          message: `Class cannot be migrated as the inherited metadata from ` +\n-              `${identifier.getText()} cannot be converted into a decorator. Please manually\n-            decorate the class.`,\n-        }];\n-      }\n-\n-      const newDecorator = this._constructDecoratorFromMetadata(metadata, targetSourceFile);\n-      if (!newDecorator) {\n-        const annotationType = metadata.type;\n-        return [{\n-          node,\n-          message: `Class cannot be migrated as the inherited @${annotationType} decorator ` +\n-              `cannot be copied. Please manually add a @${annotationType} decorator.`,\n-        }];\n-      }\n-\n-      // In case the decorator could be constructed from the resolved metadata, use\n-      // that decorator for the derived undecorated classes.\n-      newDecoratorText =\n-          this.printer.printNode(ts.EmitHint.Unspecified, newDecorator, targetSourceFile);\n-      break;\n-    }\n-\n-    if (!newDecoratorText) {\n-      return [{\n-        node,\n-        message:\n-            'Class cannot be migrated as no directive/component/pipe metadata could be found. ' +\n-            'Please manually add a @Directive, @Component or @Pipe decorator.'\n-      }];\n-    }\n-\n-    this.getUpdateRecorder(targetSourceFile).addClassDecorator(node, newDecoratorText);\n-    return [];\n-  }\n-\n-  /** Records all changes that were made in the import manager. */\n-  recordChanges() {\n-    this.importManager.recordChanges();\n-  }\n-\n-  /**\n-   * Constructs a TypeScript decorator node from the specified declaration metadata. Returns\n-   * null if the metadata could not be simplified/resolved.\n-   */\n-  private _constructDecoratorFromMetadata(\n-      directiveMetadata: DeclarationMetadata, targetSourceFile: ts.SourceFile): ts.Decorator|null {\n-    try {\n-      const decoratorExpr = convertDirectiveMetadataToExpression(\n-          this.compilerModule, directiveMetadata.metadata,\n-          staticSymbol =>\n-              this.compilerHost\n-                  .fileNameToModuleName(staticSymbol.filePath, targetSourceFile.fileName)\n-                  .replace(/\\/index$/, ''),\n-          (moduleName: string, name: string) =>\n-              this.importManager.addImportToSourceFile(targetSourceFile, name, moduleName),\n-          (propertyName, value) => {\n-            // Only normalize properties called \"changeDetection\" and \"encapsulation\"\n-            // for \"@Directive\" and \"@Component\" annotations.\n-            if (directiveMetadata.type === 'Pipe') {\n-              return null;\n-            }\n-\n-            // Instead of using the number as value for the \"changeDetection\" and\n-            // \"encapsulation\" properties, we want to use the actual enum symbols.\n-            if (propertyName === 'changeDetection' && typeof value === 'number') {\n-              return ts.createPropertyAccess(\n-                  this.importManager.addImportToSourceFile(\n-                      targetSourceFile, 'ChangeDetectionStrategy', '@angular/core'),\n-                  this.coreModule.ChangeDetectionStrategy[value]);\n-            } else if (propertyName === 'encapsulation' && typeof value === 'number') {\n-              return ts.createPropertyAccess(\n-                  this.importManager.addImportToSourceFile(\n-                      targetSourceFile, 'ViewEncapsulation', '@angular/core'),\n-                  this.coreModule.ViewEncapsulation[value]);\n-            }\n-            return null;\n-          });\n-\n-      return ts.createDecorator(ts.createCall(\n-          this.importManager.addImportToSourceFile(\n-              targetSourceFile, directiveMetadata.type, '@angular/core'),\n-          undefined, [decoratorExpr]));\n-    } catch (e) {\n-      if (e instanceof UnexpectedMetadataValueError) {\n-        return null;\n-      }\n-      throw e;\n-    }\n-  }\n-\n-  /**\n-   * Resolves the declaration metadata of a given static symbol. The metadata\n-   * is determined by resolving metadata for the static symbol.\n-   */\n-  private _resolveDeclarationMetadata(symbol: StaticSymbol): null|DeclarationMetadata {\n-    try {\n-      // Note that this call can throw if the metadata is not computable. In that\n-      // case we are not able to serialize the metadata into a decorator and we return\n-      // null.\n-      const annotations = this.compiler.reflector.annotations(symbol).find(\n-          s => s.ngMetadataName === 'Component' || s.ngMetadataName === 'Directive' ||\n-              s.ngMetadataName === 'Pipe');\n-\n-      if (!annotations) {\n-        return null;\n-      }\n-\n-      const {ngMetadataName, ...metadata} = annotations;\n-\n-      // Delete the \"ngMetadataName\" property as we don't want to generate\n-      // a property assignment in the new decorator for that internal property.\n-      delete metadata['ngMetadataName'];\n-\n-      return {type: ngMetadataName, metadata};\n-    } catch (e) {\n-      return null;\n-    }\n-  }\n-\n-  private _getStaticSymbolOfIdentifier(node: ts.Identifier): StaticSymbol|null {\n-    const sourceFile = node.getSourceFile();\n-    const resolvedImport = getImportOfIdentifier(this.typeChecker, node);\n-\n-    if (!resolvedImport) {\n-      return null;\n-    }\n-\n-    const moduleName =\n-        this.compilerHost.moduleNameToFileName(resolvedImport.importModule, sourceFile.fileName);\n-\n-    if (!moduleName) {\n-      return null;\n-    }\n-\n-    // Find the declaration symbol as symbols could be aliased due to\n-    // metadata re-exports.\n-    return this.compiler.reflector.findSymbolDeclaration(\n-        this.symbolResolver.getStaticSymbol(moduleName, resolvedImport.name));\n-  }\n-\n-  /**\n-   * Disables that static symbols are resolved through summaries. Summaries\n-   * cannot be used for decorator analysis as decorators are omitted in summaries.\n-   */\n-  private _disableSummaryResolution() {\n-    // We never want to resolve symbols through summaries. Summaries never contain\n-    // decorators for class symbols and therefore summaries will cause every class\n-    // to be considered as undecorated. See reason for this in: \"ToJsonSerializer\".\n-    // In order to ensure that metadata is not retrieved through summaries, we\n-    // need to disable summary resolution, clear previous symbol caches. This way\n-    // future calls to \"StaticReflector#annotations\" are based on metadata files.\n-    this.symbolResolver['_resolveSymbolFromSummary'] = () => null;\n-    this.symbolResolver['resolvedSymbols'].clear();\n-    this.symbolResolver['symbolFromFile'].clear();\n-    this.compiler.reflector['annotationCache'].clear();\n-\n-    // Original summary resolver used by the AOT compiler.\n-    const summaryResolver = this.symbolResolver['summaryResolver'];\n-\n-    // Additionally we need to ensure that no files are treated as \"library\" files when\n-    // resolving metadata. This is necessary because by default the symbol resolver discards\n-    // class metadata for library files. See \"StaticSymbolResolver#createResolvedSymbol\".\n-    // Patching this function **only** for the static symbol resolver ensures that metadata\n-    // is not incorrectly omitted. Note that we only want to do this for the symbol resolver\n-    // because otherwise we could break the summary loading logic which is used to detect\n-    // if a static symbol is either a directive, component or pipe (see MetadataResolver).\n-    this.symbolResolver['summaryResolver'] = <SummaryResolver<StaticSymbol>>{\n-      fromSummaryFileName: summaryResolver.fromSummaryFileName.bind(summaryResolver),\n-      addSummary: summaryResolver.addSummary.bind(summaryResolver),\n-      getImportAs: summaryResolver.getImportAs.bind(summaryResolver),\n-      getKnownModuleName: summaryResolver.getKnownModuleName.bind(summaryResolver),\n-      resolveSummary: summaryResolver.resolveSummary.bind(summaryResolver),\n-      toSummaryFileName: summaryResolver.toSummaryFileName.bind(summaryResolver),\n-      getSymbolsOf: summaryResolver.getSymbolsOf.bind(summaryResolver),\n-      isLibraryFile: () => false,\n-    };\n-  }\n-}"
        },
        {
            "sha": "b696373d6b88557bea198419b4f935bf7d5de052",
            "filename": "packages/core/schematics/migrations/undecorated-classes-with-di/update_recorder.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 22,
            "changes": 22,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fupdate_recorder.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fupdate_recorder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fundecorated-classes-with-di%2Fupdate_recorder.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,22 +0,0 @@\n-\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-import {ImportManagerUpdateRecorder} from '../../utils/import_manager';\n-\n-/**\n- * Update recorder interface that is used to transform source files in a non-colliding\n- * way. Also this indirection makes it possible to re-use transformation logic with\n- * different replacement tools (e.g. TSLint or CLI devkit).\n- */\n-export interface UpdateRecorder extends ImportManagerUpdateRecorder {\n-  addClassDecorator(node: ts.ClassDeclaration, text: string): void;\n-  addClassComment(node: ts.ClassDeclaration, text: string): void;\n-  commitUpdate(): void;\n-}"
        },
        {
            "sha": "18cf7800c80ef9c6d107d428b2898e0671792e16",
            "filename": "packages/core/schematics/migrations/wait-for-async/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 18,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,18 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"wait-for-async\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/migrations/google3:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"//packages/core/schematics/utils\",\n-        \"@npm//@angular-devkit/schematics\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "468fb934966a6503483a4b2cf2c7272700210606",
            "filename": "packages/core/schematics/migrations/wait-for-async/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 21,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2FREADME.md?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,21 +0,0 @@\n-## async -> waitForAsync migration\n-\n-Automatically migrates from `async` to `waitForAsync` by changing function calls and renaming imports.\n-\n-#### Before\n-```ts\n-import { async } from '@angular/core/testing';\n-\n-it('should work', async(() => {\n-  // async testing logic\n-}));\n-```\n-\n-#### After\n-```ts\n-import { waitForAsync } from '@angular/core/testing';\n-\n-it('should work', waitForAsync(() => {\n-  // async testing logic\n-}));\n-```"
        },
        {
            "sha": "a9d3a3266433e3f1962abb12cb5af121ac29144f",
            "filename": "packages/core/schematics/migrations/wait-for-async/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 96,
            "changes": 96,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,96 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {Rule, SchematicsException, Tree} from '@angular-devkit/schematics';\n-import {basename, join, relative} from 'path';\n-import ts from 'typescript';\n-\n-import {getProjectTsConfigPaths} from '../../utils/project_tsconfig_paths';\n-import {canMigrateFile, createMigrationProgram} from '../../utils/typescript/compiler_host';\n-import {getImportSpecifier, replaceImport} from '../../utils/typescript/imports';\n-import {closestNode} from '../../utils/typescript/nodes';\n-\n-import {findAsyncReferences} from './util';\n-\n-const MODULE_AUGMENTATION_FILENAME = 'ASYNC_MIGRATION_CORE_AUGMENTATION.d.ts';\n-\n-/** Migration that switches from `async` to `waitForAsync`. */\n-export default function(): Rule {\n-  return async (tree: Tree) => {\n-    const {buildPaths, testPaths} = await getProjectTsConfigPaths(tree);\n-    const basePath = process.cwd();\n-    const allPaths = [...buildPaths, ...testPaths];\n-\n-    if (!allPaths.length) {\n-      throw new SchematicsException(\n-          'Could not find any tsconfig file. Cannot migrate async usages to waitForAsync.');\n-    }\n-\n-    for (const tsconfigPath of allPaths) {\n-      runWaitForAsyncMigration(tree, tsconfigPath, basePath);\n-    }\n-  };\n-}\n-\n-function runWaitForAsyncMigration(tree: Tree, tsconfigPath: string, basePath: string) {\n-  // Technically we can get away with using `MODULE_AUGMENTATION_FILENAME` as the path, but as of\n-  // TS 4.2, the module resolution caching seems to be more aggressive which causes the file to be\n-  // retained between test runs. We can avoid it by using the full path.\n-  const augmentedFilePath = join(basePath, MODULE_AUGMENTATION_FILENAME);\n-  const {program} = createMigrationProgram(tree, tsconfigPath, basePath, fileName => {\n-    // In case the module augmentation file has been requested, we return a source file that\n-    // augments \"@angular/core/testing\" to include a named export called \"async\". This ensures that\n-    // we can rely on the type checker for this migration after `async` has been removed.\n-    if (basename(fileName) === MODULE_AUGMENTATION_FILENAME) {\n-      return `\n-        import '@angular/core/testing';\n-        declare module \"@angular/core/testing\" {\n-          function async(fn: Function): any;\n-        }\n-      `;\n-    }\n-    return undefined;\n-  }, [augmentedFilePath]);\n-  const typeChecker = program.getTypeChecker();\n-  const printer = ts.createPrinter();\n-  const sourceFiles =\n-      program.getSourceFiles().filter(sourceFile => canMigrateFile(basePath, sourceFile, program));\n-  const deprecatedFunction = 'async';\n-  const newFunction = 'waitForAsync';\n-\n-  sourceFiles.forEach(sourceFile => {\n-    const asyncImportSpecifier =\n-        getImportSpecifier(sourceFile, '@angular/core/testing', deprecatedFunction);\n-    const asyncImport = asyncImportSpecifier ?\n-        closestNode<ts.NamedImports>(asyncImportSpecifier, ts.SyntaxKind.NamedImports) :\n-        null;\n-\n-    // If there are no imports for `async`, we can exit early.\n-    if (!asyncImportSpecifier || !asyncImport) {\n-      return;\n-    }\n-\n-    const update = tree.beginUpdate(relative(basePath, sourceFile.fileName));\n-\n-    // Change the `async` import to `waitForAsync`.\n-    update.remove(asyncImport.getStart(), asyncImport.getWidth());\n-    update.insertRight(\n-        asyncImport.getStart(),\n-        printer.printNode(\n-            ts.EmitHint.Unspecified, replaceImport(asyncImport, deprecatedFunction, newFunction),\n-            sourceFile));\n-\n-    // Change `async` calls to `waitForAsync`.\n-    findAsyncReferences(sourceFile, typeChecker, asyncImportSpecifier).forEach(node => {\n-      update.remove(node.getStart(), node.getWidth());\n-      update.insertRight(node.getStart(), newFunction);\n-    });\n-\n-    tree.commitUpdate(update);\n-  });\n-}"
        },
        {
            "sha": "5e879dc5e4b86f205883880a266d926abc925b00",
            "filename": "packages/core/schematics/migrations/wait-for-async/util.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 30,
            "changes": 30,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fwait-for-async%2Futil.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,30 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import ts from 'typescript';\n-\n-import {isReferenceToImport} from '../../utils/typescript/symbol';\n-\n-/** Finds calls to the `async` function. */\n-export function findAsyncReferences(\n-    sourceFile: ts.SourceFile, typeChecker: ts.TypeChecker,\n-    asyncImportSpecifier: ts.ImportSpecifier) {\n-  const results = new Set<ts.Identifier>();\n-\n-  ts.forEachChild(sourceFile, function visitNode(node: ts.Node) {\n-    if (ts.isCallExpression(node) && ts.isIdentifier(node.expression) &&\n-        node.expression.text === 'async' &&\n-        isReferenceToImport(typeChecker, node.expression, asyncImportSpecifier)) {\n-      results.add(node.expression);\n-    }\n-\n-    ts.forEachChild(node, visitNode);\n-  });\n-\n-  return results;\n-}"
        },
        {
            "sha": "570ee390560ed9cd6bfba001464b7ab01f802048",
            "filename": "packages/core/schematics/migrations/xhr-factory/BUILD.bazel",
            "status": "removed",
            "additions": 0,
            "deletions": 17,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fxhr-factory%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fxhr-factory%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fxhr-factory%2FBUILD.bazel?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,17 +0,0 @@\n-load(\"//tools:defaults.bzl\", \"ts_library\")\n-\n-ts_library(\n-    name = \"xhr-factory\",\n-    srcs = glob([\"**/*.ts\"]),\n-    tsconfig = \"//packages/core/schematics:tsconfig.json\",\n-    visibility = [\n-        \"//packages/core/schematics:__pkg__\",\n-        \"//packages/core/schematics/test:__pkg__\",\n-    ],\n-    deps = [\n-        \"//packages/core/schematics/utils\",\n-        \"@npm//@angular-devkit/schematics\",\n-        \"@npm//@types/node\",\n-        \"@npm//typescript\",\n-    ],\n-)"
        },
        {
            "sha": "968e76e94d358207c3d0eba258558ffd070dde7a",
            "filename": "packages/core/schematics/migrations/xhr-factory/README.md",
            "status": "removed",
            "additions": 0,
            "deletions": 13,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fxhr-factory%2FREADME.md",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fxhr-factory%2FREADME.md",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fxhr-factory%2FREADME.md?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,13 +0,0 @@\n-## XhrFactory migration\n-\n-Automatically migrates `XhrFactory` from `@angular/common/http` to `@angular/common`.\n-\n-#### Before\n-```ts\n-import { XhrFactory } from '@angular/common/http';\n-```\n-\n-#### After\n-```ts\n-import { XhrFactory } from '@angular/common';\n-```"
        },
        {
            "sha": "58d28a5160c956eb6a2b0c2dc1f0efc19833b57d",
            "filename": "packages/core/schematics/migrations/xhr-factory/index.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 132,
            "changes": 132,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fxhr-factory%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Fmigrations%2Fxhr-factory%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Fmigrations%2Fxhr-factory%2Findex.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,132 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-import {DirEntry, Rule, UpdateRecorder} from '@angular-devkit/schematics';\n-import ts from 'typescript';\n-import {findImportSpecifier} from '../../utils/typescript/imports';\n-\n-function* visit(directory: DirEntry): IterableIterator<ts.SourceFile> {\n-  for (const path of directory.subfiles) {\n-    if (path.endsWith('.ts') && !path.endsWith('.d.ts')) {\n-      const entry = directory.file(path);\n-      if (entry) {\n-        const content = entry.content;\n-        if (content.includes('XhrFactory')) {\n-          const source = ts.createSourceFile(\n-              entry.path,\n-              content.toString().replace(/^\\uFEFF/, ''),\n-              ts.ScriptTarget.Latest,\n-              true,\n-          );\n-\n-          yield source;\n-        }\n-      }\n-    }\n-  }\n-\n-  for (const path of directory.subdirs) {\n-    if (path === 'node_modules' || path.startsWith('.')) {\n-      continue;\n-    }\n-\n-    yield* visit(directory.dir(path));\n-  }\n-}\n-\n-export default function(): Rule {\n-  return tree => {\n-    const printer = ts.createPrinter({newLine: ts.NewLineKind.LineFeed});\n-\n-    for (const sourceFile of visit(tree.root)) {\n-      let recorder: UpdateRecorder|undefined;\n-\n-      const allImportDeclarations =\n-          sourceFile.statements.filter(n => ts.isImportDeclaration(n)) as ts.ImportDeclaration[];\n-      if (allImportDeclarations.length === 0) {\n-        continue;\n-      }\n-\n-      const httpCommonImport = findImportDeclaration('@angular/common/http', allImportDeclarations);\n-      if (!httpCommonImport) {\n-        continue;\n-      }\n-\n-      const commonHttpNamedBinding = getNamedImports(httpCommonImport);\n-      if (commonHttpNamedBinding) {\n-        const commonHttpNamedImports = commonHttpNamedBinding.elements;\n-        const xhrFactorySpecifier = findImportSpecifier(commonHttpNamedImports, 'XhrFactory');\n-\n-        if (!xhrFactorySpecifier) {\n-          continue;\n-        }\n-\n-        recorder = tree.beginUpdate(sourceFile.fileName);\n-\n-        // Remove 'XhrFactory' from '@angular/common/http'\n-        if (commonHttpNamedImports.length > 1) {\n-          // Remove 'XhrFactory' named import\n-          const index = commonHttpNamedBinding.getStart();\n-          const length = commonHttpNamedBinding.getWidth();\n-\n-          const newImports = printer.printNode(\n-              ts.EmitHint.Unspecified,\n-              ts.factory.updateNamedImports(\n-                  commonHttpNamedBinding,\n-                  commonHttpNamedBinding.elements.filter(e => e !== xhrFactorySpecifier)),\n-              sourceFile);\n-          recorder.remove(index, length).insertLeft(index, newImports);\n-        } else {\n-          // Remove '@angular/common/http' import\n-          const index = httpCommonImport.getFullStart();\n-          const length = httpCommonImport.getFullWidth();\n-          recorder.remove(index, length);\n-        }\n-\n-        // Import XhrFactory from @angular/common\n-        const commonImport = findImportDeclaration('@angular/common', allImportDeclarations);\n-        const commonNamedBinding = getNamedImports(commonImport);\n-        if (commonNamedBinding) {\n-          // Already has an import for '@angular/common', just add the named import.\n-          const index = commonNamedBinding.getStart();\n-          const length = commonNamedBinding.getWidth();\n-          const newImports = printer.printNode(\n-              ts.EmitHint.Unspecified,\n-              ts.factory.updateNamedImports(\n-                  commonNamedBinding, [...commonNamedBinding.elements, xhrFactorySpecifier]),\n-              sourceFile);\n-\n-          recorder.remove(index, length).insertLeft(index, newImports);\n-        } else {\n-          // Add import to '@angular/common'\n-          const index = httpCommonImport.getFullStart();\n-          recorder.insertLeft(index, `\\nimport { XhrFactory } from '@angular/common';`);\n-        }\n-      }\n-\n-      if (recorder) {\n-        tree.commitUpdate(recorder);\n-      }\n-    }\n-  };\n-}\n-\n-function findImportDeclaration(moduleSpecifier: string, importDeclarations: ts.ImportDeclaration[]):\n-    ts.ImportDeclaration|undefined {\n-  return importDeclarations.find(\n-      n => ts.isStringLiteral(n.moduleSpecifier) && n.moduleSpecifier.text === moduleSpecifier);\n-}\n-\n-function getNamedImports(importDeclaration: ts.ImportDeclaration|undefined): ts.NamedImports|\n-    undefined {\n-  const namedBindings = importDeclaration?.importClause?.namedBindings;\n-  if (namedBindings && ts.isNamedImports(namedBindings)) {\n-    return namedBindings;\n-  }\n-\n-  return undefined;\n-}"
        },
        {
            "sha": "225cc068b6418c88da34160baf8f00978855ec19",
            "filename": "packages/core/schematics/test/BUILD.bazel",
            "status": "modified",
            "additions": 0,
            "deletions": 20,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/0b4350c6eff0e146115f8ee56e3d8004b69ac10a/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/0b4350c6eff0e146115f8ee56e3d8004b69ac10a/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2FBUILD.bazel?ref=0b4350c6eff0e146115f8ee56e3d8004b69ac10a",
            "patch": "@@ -8,28 +8,8 @@ ts_library(\n         \"//packages/core/schematics:migrations.json\",\n     ],\n     deps = [\n-        \"//packages/core/schematics/migrations/abstract-control-parent\",\n-        \"//packages/core/schematics/migrations/activated-route-snapshot-fragment\",\n-        \"//packages/core/schematics/migrations/can-activate-with-redirect-to\",\n-        \"//packages/core/schematics/migrations/deep-shadow-piercing-selector\",\n-        \"//packages/core/schematics/migrations/dynamic-queries\",\n-        \"//packages/core/schematics/migrations/initial-navigation\",\n-        \"//packages/core/schematics/migrations/missing-injectable\",\n-        \"//packages/core/schematics/migrations/module-with-providers\",\n-        \"//packages/core/schematics/migrations/move-document\",\n-        \"//packages/core/schematics/migrations/native-view-encapsulation\",\n-        \"//packages/core/schematics/migrations/navigation-extras-omissions\",\n-        \"//packages/core/schematics/migrations/relative-link-resolution\",\n-        \"//packages/core/schematics/migrations/renderer-to-renderer2\",\n         \"//packages/core/schematics/migrations/router-link-empty-expression\",\n-        \"//packages/core/schematics/migrations/router-preserve-query-params\",\n-        \"//packages/core/schematics/migrations/static-queries\",\n-        \"//packages/core/schematics/migrations/template-var-assignment\",\n         \"//packages/core/schematics/migrations/testbed-teardown\",\n-        \"//packages/core/schematics/migrations/undecorated-classes-with-decorated-fields\",\n-        \"//packages/core/schematics/migrations/undecorated-classes-with-di\",\n-        \"//packages/core/schematics/migrations/wait-for-async\",\n-        \"//packages/core/schematics/migrations/xhr-factory\",\n         \"//packages/core/schematics/utils\",\n         \"@npm//@angular-devkit/core\",\n         \"@npm//@angular-devkit/schematics\","
        },
        {
            "sha": "ad38b34117f341fc620fdf2ddd5c8c6b5d090053",
            "filename": "packages/core/schematics/test/abstract_control_parent_migration_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 290,
            "changes": 290,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fabstract_control_parent_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fabstract_control_parent_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fabstract_control_parent_migration_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,290 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n-import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n-import {HostTree} from '@angular-devkit/schematics';\n-import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n-import * as shx from 'shelljs';\n-\n-describe('AbstractControl.parent migration', () => {\n-  let runner: SchematicTestRunner;\n-  let host: TempScopedNodeJsSyncHost;\n-  let tree: UnitTestTree;\n-  let tmpDirPath: string;\n-  let previousWorkingDir: string;\n-\n-  beforeEach(() => {\n-    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n-    host = new TempScopedNodeJsSyncHost();\n-    tree = new UnitTestTree(new HostTree(host));\n-\n-    writeFile('/tsconfig.json', JSON.stringify({\n-      compilerOptions: {lib: ['es2015'], strictNullChecks: true},\n-    }));\n-    writeFile('/angular.json', JSON.stringify({\n-      version: 1,\n-      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n-    }));\n-    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n-    writeFile('/node_modules/@angular/forms/index.d.ts', `\n-      export declare abstract class AbstractControl {\n-        get dirty(): boolean;\n-        get disabled(): boolean;\n-        get parent(): FormGroup | FormArray | null;\n-      }\n-\n-      export declare class FormArray extends AbstractControl {\n-        getRawValue(): any[];\n-      }\n-\n-      export declare class FormControl extends AbstractControl {\n-        setValue(value: any): void;\n-      }\n-\n-      export declare class FormGroup extends AbstractControl {\n-        getRawValue(): any;\n-      }\n-    `);\n-\n-    // Fake non-Angular package to make sure that we don't migrate packages we don't own.\n-    writeFile('/node_modules/@not-angular/forms/index.d.ts', `\n-      export declare abstract class AbstractControl {\n-        get dirty(): boolean;\n-        get disabled(): boolean;\n-        get parent(): FormGroup | FormArray | null;\n-      }\n-\n-      export declare class FormControl extends AbstractControl {\n-        setValue(value: any): void;\n-      }\n-    `);\n-\n-    previousWorkingDir = shx.pwd();\n-    tmpDirPath = getSystemPath(host.root);\n-\n-    // Switch into the temporary directory path. This allows us to run\n-    // the schematic against our custom unit test tree.\n-    shx.cd(tmpDirPath);\n-  });\n-\n-  afterEach(() => {\n-    shx.cd(previousWorkingDir);\n-    shx.rm('-r', tmpDirPath);\n-  });\n-\n-  it('should add non-null assertions to accesses of AbstractControl.parent', async () => {\n-    writeFile('/index.ts', `\n-      import {AbstractControl} from '@angular/forms';\n-\n-      class App {\n-        private _control: AbstractControl;\n-\n-        getParentValue() {\n-          return this._control.parent.value;\n-        }\n-      }\n-    `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts')).toContain(`return this._control.parent!.value;`);\n-  });\n-\n-  it('should add non-null assertions to accesses of FormArray.parent', async () => {\n-    writeFile('/index.ts', `\n-      import {FormArray} from '@angular/forms';\n-\n-      class App {\n-        getParentValueOf(control: FormArray) {\n-          return control.parent.value;\n-        }\n-      }\n-    `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts')).toContain(`return control.parent!.value;`);\n-  });\n-\n-  it('should add non-null assertions to accesses of FormControl.parent', async () => {\n-    writeFile('/index.ts', `\n-      import {FormControl} from '@angular/forms';\n-\n-      class App {\n-        getBlankControlParentValue() {\n-          return this._getControl().parent.value;\n-        }\n-\n-        private _getControl() {\n-          return new FormControl();\n-        }\n-      }\n-    `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts')).toContain(`return this._getControl().parent!.value;`);\n-  });\n-\n-  it('should add non-null assertions to accesses of FormGroup.parent', async () => {\n-    writeFile('/index.ts', `\n-      import {FormGroup} from '@angular/forms';\n-\n-      class App {\n-        getGlobalGroupParentValue() {\n-          const parent = (window.foo as FormGroup).parent;\n-          return parent.value;\n-        }\n-      }\n-    `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts'))\n-        .toContain(`const parent = (window.foo as FormGroup).parent!;`);\n-  });\n-\n-  it('should add non-null assertions to nested accesses of `AbstractControl.parent`', async () => {\n-    writeFile('/index.ts', `\n-      import {FormControl} from '@angular/forms';\n-\n-      class App {\n-        private _control = new FormControl();\n-\n-        getGreatGrandParentValue() {\n-          return this._control.parent.parent.parent.value;\n-        }\n-      }\n-    `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts'))\n-        .toContain(`return this._control.parent!.parent!.parent!.value;`);\n-  });\n-\n-  it('should not add non-null assertions if the `parent` has been null checked in an if statement',\n-     async () => {\n-       writeFile('/index.ts', `\n-        import {FormControl} from '@angular/forms';\n-\n-        function getParentValue(control: FormControl) {\n-          if (control.parent) {\n-            return control.parent.value;\n-          }\n-\n-          return null;\n-        }\n-      `);\n-\n-       await runMigration();\n-\n-       const content = tree.readContent('/index.ts');\n-       expect(content).toContain(`if (control.parent) {`);\n-       expect(content).toContain(`return control.parent.value;`);\n-     });\n-\n-  it('should not add non-null assertions if the `parent` has been null checked in an else if statement',\n-     async () => {\n-       writeFile('/index.ts', `\n-        import {FormControl} from '@angular/forms';\n-\n-        function getParentValue(foo: boolean, control: FormControl) {\n-          if (foo) {\n-            return foo;\n-          } else if (control.parent) {\n-            return control.parent.value;\n-          }\n-\n-          return null;\n-        }\n-      `);\n-\n-       await runMigration();\n-\n-       const content = tree.readContent('/index.ts');\n-       expect(content).toContain(`} else if (control.parent) {`);\n-       expect(content).toContain(`return control.parent.value;`);\n-     });\n-\n-  it('should not add non-null assertions if the `parent` has been null checked in a ternary expression',\n-     async () => {\n-       writeFile('/index.ts', `\n-        import {FormControl} from '@angular/forms';\n-\n-        function getParentValue(control: FormControl) {\n-          return control.parent ? control.parent.value : null;\n-        }\n-      `);\n-\n-       await runMigration();\n-\n-       expect(tree.readContent('/index.ts'))\n-           .toContain(`return control.parent ? control.parent.value : null;`);\n-     });\n-\n-  it('should not add non-null assertions if a nested `parent` has been null checked', async () => {\n-    writeFile('/index.ts', `\n-      import {FormControl} from '@angular/forms';\n-\n-      function getGreatGrandParentValue(control: FormControl) {\n-        return control.parent && control.parent.parent && control.parent.parent.parent && control.parent.parent.parent.value;\n-      }\n-    `);\n-\n-    await runMigration();\n-\n-    expect(tree.readContent('/index.ts'))\n-        .toContain(\n-            `return control.parent && control.parent.parent && control.parent.parent.parent && control.parent.parent.parent.value;`);\n-  });\n-\n-  it('should not add non-null assertions if there is one already', async () => {\n-    writeFile('/index.ts', `\n-      import {FormControl} from '@angular/forms';\n-\n-      function getParentValue(control: FormControl) {\n-        return control.parent!.value;\n-      }\n-    `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts')).toContain(`return control.parent!.value;`);\n-  });\n-\n-  it('should not add non-null assertions if there is a safe access', async () => {\n-    writeFile('/index.ts', `\n-      import {FormControl} from '@angular/forms';\n-\n-      function getParentValue(control: FormControl) {\n-        return control.parent?.value;\n-      }\n-    `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts')).toContain(`return control.parent?.value;`);\n-  });\n-\n-  it('should not add non-null assertions if the symbol does not come from @angular/forms',\n-     async () => {\n-       writeFile('/index.ts', `\n-        import {FormControl} from '@not-angular/forms';\n-\n-        function getParentValue(control: FormControl) {\n-          return control.parent.value;\n-        }\n-      `);\n-\n-       await runMigration();\n-       expect(tree.readContent('/index.ts')).toContain(`return control.parent.value;`);\n-     });\n-\n-  function writeFile(filePath: string, contents: string) {\n-    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n-  }\n-\n-  function runMigration() {\n-    return runner.runSchematicAsync('migration-v11-abstract-control-parent', {}, tree).toPromise();\n-  }\n-});"
        },
        {
            "sha": "4d95fd29aa890239d0da5b167963b59061e9a7eb",
            "filename": "packages/core/schematics/test/activated_route_snapshot_fragment_migration_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 187,
            "changes": 187,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Factivated_route_snapshot_fragment_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Factivated_route_snapshot_fragment_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Factivated_route_snapshot_fragment_migration_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,187 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n-import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n-import {HostTree} from '@angular-devkit/schematics';\n-import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n-import * as shx from 'shelljs';\n-\n-describe('ActivatedRouteSnapshot.fragment migration', () => {\n-  let runner: SchematicTestRunner;\n-  let host: TempScopedNodeJsSyncHost;\n-  let tree: UnitTestTree;\n-  let tmpDirPath: string;\n-  let previousWorkingDir: string;\n-\n-  beforeEach(() => {\n-    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n-    host = new TempScopedNodeJsSyncHost();\n-    tree = new UnitTestTree(new HostTree(host));\n-\n-    writeFile('/tsconfig.json', JSON.stringify({\n-      compilerOptions: {lib: ['es2015'], strictNullChecks: true},\n-    }));\n-    writeFile('/angular.json', JSON.stringify({\n-      version: 1,\n-      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n-    }));\n-    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n-    writeFile('/node_modules/@angular/router.d.ts', `\n-      export declare class ActivatedRoute {\n-        get children(): ActivatedRoute[];\n-        fragment: Observable<string | null>;\n-        snapshot: ActivatedRouteSnapshot;\n-        url: Observable<unknown[]>;\n-      }\n-\n-      export declare class ActivatedRouteSnapshot {\n-        fragment: string | null;\n-        url: unknown[];\n-      }\n-    `);\n-\n-    previousWorkingDir = shx.pwd();\n-    tmpDirPath = getSystemPath(host.root);\n-\n-    // Switch into the temporary directory path. This allows us to run\n-    // the schematic against our custom unit test tree.\n-    shx.cd(tmpDirPath);\n-  });\n-\n-  afterEach(() => {\n-    shx.cd(previousWorkingDir);\n-    shx.rm('-r', tmpDirPath);\n-  });\n-\n-  it('should add non-null assertions to accesses of `ActivatedRouteSnapshot.fragment`',\n-     async () => {\n-       writeFile('/index.ts', `\n-          import {ActivatedRoute} from '@angular/router';\n-\n-          class App {\n-            private _route: ActivatedRoute;\n-\n-            getFragment() {\n-              return this._getSnapshot().fragment.foo;\n-            }\n-\n-            private _getSnapshot() {\n-              return this._route.snapshot;\n-            }\n-          }\n-        `);\n-\n-       await runMigration();\n-\n-       expect(tree.readContent('/index.ts')).toContain('return this._getSnapshot().fragment!.foo');\n-     });\n-\n-  it('should not add non-null assertions to accesses of `ActivatedRouteSnapshot.fragment` if there is one already',\n-     async () => {\n-       writeFile('/index.ts', `\n-        import {ActivatedRoute} from '@angular/router';\n-\n-        class App {\n-          private _route: ActivatedRoute;\n-\n-          getFragment() {\n-            return this._route.snapshot.fragment!.foo;\n-          }\n-        }\n-      `);\n-\n-       await runMigration();\n-\n-       expect(tree.readContent('/index.ts'))\n-           .toContain('return this._route.snapshot.fragment!.foo;');\n-     });\n-\n-  it('should not add non-null assertions if the `ActivatedRouteSnapshot.fragment` has been null checked in an if statement',\n-     async () => {\n-       writeFile('/index.ts', `\n-        import {ActivatedRouteSnapshot} from '@angular/router';\n-\n-        function getFragmentValue(snapshot: ActivatedRouteSnapshot) {\n-          if (snapshot.fragment) {\n-            return snapshot.fragment.value;\n-          }\n-\n-          return null;\n-        }\n-      `);\n-\n-       await runMigration();\n-\n-       const content = tree.readContent('/index.ts');\n-       expect(content).toContain(`if (snapshot.fragment) {`);\n-       expect(content).toContain(`return snapshot.fragment.value;`);\n-     });\n-\n-  it('should not add non-null assertions if the `ActivatedRouteSnapshot.fragment` has been null checked in an else if statement',\n-     async () => {\n-       writeFile('/index.ts', `\n-        import {ActivatedRouteSnapshot} from '@angular/router';\n-\n-        function getSnapshotValue(foo: boolean, snapshot: ActivatedRouteSnapshot) {\n-          if (foo) {\n-            return foo;\n-          } else if (snapshot.fragment) {\n-            return snapshot.fragment.value;\n-          }\n-\n-          return null;\n-        }\n-      `);\n-\n-       await runMigration();\n-\n-       const content = tree.readContent('/index.ts');\n-       expect(content).toContain(`} else if (snapshot.fragment) {`);\n-       expect(content).toContain(`return snapshot.fragment.value;`);\n-     });\n-\n-  it('should not add non-null assertions if the `ActivatedRouteSnapshot.fragment` has been null checked in a ternary expression',\n-     async () => {\n-       writeFile('/index.ts', `\n-        import {ActivatedRouteSnapshot} from '@angular/router';\n-\n-        function getSnapshotValue(snapshot: ActivatedRouteSnapshot) {\n-          return snapshot.fragment ? snapshot.fragment.value : null;\n-        }\n-      `);\n-\n-       await runMigration();\n-\n-       expect(tree.readContent('/index.ts'))\n-           .toContain(`return snapshot.fragment ? snapshot.fragment.value : null;`);\n-     });\n-\n-  it('should not add non-null assertion to `ActivatedRouteSnapshot.fragment` if there is a safe access',\n-     async () => {\n-       writeFile('/index.ts', `\n-        import {ActivatedRouteSnapshot} from '@angular/router';\n-\n-        function getSnapshotValue(snapshot: ActivatedRouteSnapshot) {\n-          return snapshot.fragment?.value;\n-        }\n-      `);\n-\n-       await runMigration();\n-       expect(tree.readContent('/index.ts')).toContain(`return snapshot.fragment?.value;`);\n-     });\n-\n-  function writeFile(filePath: string, contents: string) {\n-    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n-  }\n-\n-  function runMigration() {\n-    return runner.runSchematicAsync('migration-v12-activated-route-snapshot-fragment', {}, tree)\n-        .toPromise();\n-  }\n-});"
        },
        {
            "sha": "f8ba5581214adc66f86f34d522d94ef8f74c2f2a",
            "filename": "packages/core/schematics/test/can_activate_with_redirect_migration_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 79,
            "changes": 79,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fcan_activate_with_redirect_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fcan_activate_with_redirect_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fcan_activate_with_redirect_migration_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,79 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n-import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n-import {HostTree} from '@angular-devkit/schematics';\n-import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n-import * as shx from 'shelljs';\n-\n-describe('canActivate removal with redirectTo', () => {\n-  let runner: SchematicTestRunner;\n-  let host: TempScopedNodeJsSyncHost;\n-  let tree: UnitTestTree;\n-  let tmpDirPath: string;\n-  let previousWorkingDir: string;\n-\n-  beforeEach(() => {\n-    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n-    host = new TempScopedNodeJsSyncHost();\n-    tree = new UnitTestTree(new HostTree(host));\n-\n-    writeFile('/tsconfig.json', JSON.stringify({\n-      compilerOptions: {\n-        lib: ['es2015'],\n-        strictNullChecks: true,\n-      },\n-    }));\n-    writeFile('/angular.json', JSON.stringify({\n-      version: 1,\n-      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n-    }));\n-\n-    previousWorkingDir = shx.pwd();\n-    tmpDirPath = getSystemPath(host.root);\n-\n-    // Switch into the temporary directory path. This allows us to run\n-    // the schematic against our custom unit test tree.\n-    shx.cd(tmpDirPath);\n-  });\n-\n-  afterEach(() => {\n-    shx.cd(previousWorkingDir);\n-    shx.rm('-r', tmpDirPath);\n-  });\n-\n-  it('should not remove canActivate when redirectTo is not present', async () => {\n-    writeFile('/index.ts', `const route = {path: '', canActivate: ['my_guard_token']}`);\n-\n-    await runMigration();\n-\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toEqual(`const route = {path: '', canActivate: ['my_guard_token']}`);\n-  });\n-\n-  it('removes canActivate when redirectTo is present', async () => {\n-    writeFile(\n-        '/index.ts',\n-        `const route = {path: '', redirectTo: 'other', canActivate: ['my_guard_token']}`);\n-\n-    await runMigration();\n-\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toEqual(`const route = { path: '', redirectTo: 'other' }`);\n-  });\n-\n-  function writeFile(filePath: string, contents: string) {\n-    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n-  }\n-\n-  function runMigration() {\n-    return runner.runSchematicAsync('migration-v11.1-can-activate-with-redirect-to', {}, tree)\n-        .toPromise();\n-  }\n-});"
        },
        {
            "sha": "912642c5a4fa0966b04059a4afbb4c1bfe2d399d",
            "filename": "packages/core/schematics/test/deep-shadow-piercing-selector_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 69,
            "changes": 69,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fdeep-shadow-piercing-selector_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fdeep-shadow-piercing-selector_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fdeep-shadow-piercing-selector_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,69 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {tags} from '@angular-devkit/core';\n-import {EmptyTree} from '@angular-devkit/schematics';\n-import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n-\n-describe('`/deep/` to `::ng-deep` migration', () => {\n-  let tree: UnitTestTree;\n-  const runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n-\n-  beforeEach(() => {\n-    tree = new UnitTestTree(new EmptyTree());\n-  });\n-\n-  it(`should replace '/deep/' with '::ng-deep' in inline component styles`, async () => {\n-    const fileName = '/index.ts';\n-    const getFileContent = (contentToReplace: string) => tags.stripIndents`\n-      import { Component } from '@angular/core';\n-\n-      @Component({\n-        selector: 'app-root',\n-        template: '<router-outlet></router-outlet>',\n-        styles: ['` +\n-        contentToReplace + `'],\n-      })\n-      export class AppComponent { }\n-   `;\n-\n-    tree.create(fileName, getFileContent(':host /deep/ * { cursor: pointer; }'));\n-    await runMigration();\n-    expect(tree.readContent(fileName))\n-        .toBe(getFileContent(':host ::ng-deep * { cursor: pointer; }'));\n-  });\n-\n-  for (const styleExtension of ['scss', 'sass', 'css', 'styl', 'less']) {\n-    it(`should replace '/deep/' with '::ng-deep' in ${styleExtension} file`, async () => {\n-      const fileName = `/index.${styleExtension}`;\n-      tree.create(fileName, ':host /deep/ * { cursor: pointer; }');\n-      await runMigration();\n-      expect(tree.readContent(fileName)).toBe(':host ::ng-deep * { cursor: pointer; }');\n-    });\n-  }\n-\n-  it(`should replace '/deep/' with '::ng-deep' when used as root selector`, async () => {\n-    const fileName = '/index.css';\n-    tree.create(fileName, '/deep/ * { cursor: pointer; }');\n-    await runMigration();\n-    expect(tree.readContent(fileName)).toBe('::ng-deep * { cursor: pointer; }');\n-  });\n-\n-  it(`should not replace '/deep/' with '::ng-deep' in unknown file extension`, async () => {\n-    const fileName = '/index.foo';\n-    const content = 'this is a not /deep/ selector';\n-    tree.create(fileName, content);\n-    await runMigration();\n-    expect(tree.readContent(fileName)).toBe(content);\n-  });\n-\n-  async function runMigration(): Promise<void> {\n-    await runner.runSchematicAsync('migration-v12-deep-shadow-piercing-selector', {}, tree)\n-        .toPromise();\n-  }\n-});"
        },
        {
            "sha": "6950c35b96888dd5624211fc3dd4d821d43b4ad6",
            "filename": "packages/core/schematics/test/dynamic_queries_migration_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 166,
            "changes": 166,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fdynamic_queries_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fdynamic_queries_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fdynamic_queries_migration_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,166 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n-import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n-import {HostTree} from '@angular-devkit/schematics';\n-import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n-import * as shx from 'shelljs';\n-\n-describe('dynamic queries migration', () => {\n-  let runner: SchematicTestRunner;\n-  let host: TempScopedNodeJsSyncHost;\n-  let tree: UnitTestTree;\n-  let tmpDirPath: string;\n-  let previousWorkingDir: string;\n-\n-  beforeEach(() => {\n-    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n-    host = new TempScopedNodeJsSyncHost();\n-    tree = new UnitTestTree(new HostTree(host));\n-\n-    writeFile('/tsconfig.json', JSON.stringify({\n-      compilerOptions: {\n-        lib: ['es2015'],\n-      }\n-    }));\n-    writeFile('/angular.json', JSON.stringify({\n-      version: 1,\n-      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n-    }));\n-\n-    previousWorkingDir = shx.pwd();\n-    tmpDirPath = getSystemPath(host.root);\n-\n-    // Switch into the temporary directory path. This allows us to run\n-    // the schematic against our custom unit test tree.\n-    shx.cd(tmpDirPath);\n-  });\n-\n-  afterEach(() => {\n-    shx.cd(previousWorkingDir);\n-    shx.rm('-r', tmpDirPath);\n-  });\n-\n-  it('should remove the options object from a dynamic ViewChild query that only has one property',\n-     async () => {\n-       writeFile('/index.ts', `\n-        import { Directive, ViewChild } from '@angular/core';\n-\n-        @Directive()\n-        export class MyDirective {\n-          @ViewChild('child', { static: false }) child: any;\n-        }\n-      `);\n-\n-       await runMigration();\n-       expect(tree.readContent('/index.ts')).toContain(`@ViewChild('child') child: any;`);\n-     });\n-\n-  it('should remove the options object from a dynamic ContentChild query that only has one property',\n-     async () => {\n-       writeFile('/index.ts', `\n-        import { Directive, ContentChild } from '@angular/core';\n-\n-        @Directive()\n-        export class MyComponent {\n-          @ContentChild('child', { static: false }) child: any;\n-        }\n-      `);\n-\n-       await runMigration();\n-       expect(tree.readContent('/index.ts')).toContain(`@ContentChild('child') child: any;`);\n-     });\n-\n-  it('should only remove the `static` flag from a ViewChild query if it has more than one property',\n-     async () => {\n-       writeFile('/index.ts', `\n-        import { Directive, ViewChild, ElementRef } from '@angular/core';\n-\n-        @Directive()\n-        export class MyDirective {\n-          @ViewChild('child', { read: ElementRef, static: false }) child: ElementRef;\n-        }\n-      `);\n-\n-       await runMigration();\n-       expect(tree.readContent('/index.ts'))\n-           .toContain(`@ViewChild('child', { read: ElementRef }) child: ElementRef;`);\n-     });\n-\n-  it('should only remove the `static` flag from a ContentChild query if it has more than one property',\n-     async () => {\n-       writeFile('/index.ts', `\n-        import { Directive, ContentChild, ElementRef } from '@angular/core';\n-\n-        @Directive()\n-        export class MyDirective {\n-          @ContentChild('child', { static: false, read: ElementRef }) child: ElementRef;\n-        }\n-      `);\n-\n-       await runMigration();\n-       expect(tree.readContent('/index.ts'))\n-           .toContain(`@ContentChild('child', { read: ElementRef }) child: ElementRef;`);\n-     });\n-\n-  it('should not change static ViewChild queries', async () => {\n-    writeFile('/index.ts', `\n-      import { Directive, ViewChild, ElementRef } from '@angular/core';\n-\n-      @Directive()\n-      export class MyDirective {\n-        @ViewChild('child', { read: ElementRef, static: true }) child: ElementRef;\n-      }\n-    `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts'))\n-        .toContain(`@ViewChild('child', { read: ElementRef, static: true }) child: ElementRef;`);\n-  });\n-\n-  it('should not change static ContentChild queries', async () => {\n-    writeFile('/index.ts', `\n-      import { Directive, ContentChild, ElementRef } from '@angular/core';\n-\n-      @Directive()\n-      export class MyDirective {\n-        @ContentChild('child', { static: true, read: ElementRef }) child: ElementRef;\n-      }\n-    `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts'))\n-        .toContain(`@ContentChild('child', { static: true, read: ElementRef }) child: ElementRef;`);\n-  });\n-\n-  it('should migrate dynamic queries on a setter', async () => {\n-    writeFile('/index.ts', `\n-     import { Directive, ContentChild, ViewChild } from '@angular/core';\n-\n-     @Directive()\n-     export class MyDirective {\n-       @ContentChild('child', { static: false }) set child(c: any) {}\n-       @ViewChild('otherChild', { static: false }) set otherChild(c: any) {}\n-     }\n-   `);\n-\n-    await runMigration();\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toContain(`@ContentChild('child') set child(c: any) {}`);\n-    expect(content).toContain(`@ViewChild('otherChild') set otherChild(c: any) {}`);\n-  });\n-\n-  function writeFile(filePath: string, contents: string) {\n-    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n-  }\n-\n-  function runMigration() {\n-    return runner.runSchematicAsync('migration-v9-dynamic-queries', {}, tree).toPromise();\n-  }\n-});"
        },
        {
            "sha": "19232cf1a90049f20d698e69ce09b4b0b707d2ca",
            "filename": "packages/core/schematics/test/google3/activated_route_snapshot_fragment_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 210,
            "changes": 210,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Factivated_route_snapshot_fragment_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Factivated_route_snapshot_fragment_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Factivated_route_snapshot_fragment_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,210 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {readFileSync, writeFileSync} from 'fs';\n-import {dirname, join} from 'path';\n-import * as shx from 'shelljs';\n-import {Configuration, Linter} from 'tslint';\n-\n-describe('Google3 ActivatedRouteSnapshot.fragment TSLint rule', () => {\n-  const rulesDirectory =\n-      dirname(require.resolve('../../migrations/google3/activatedRouteSnapshotFragmentRule'));\n-\n-  let tmpDir: string;\n-\n-  beforeEach(() => {\n-    tmpDir = join(process.env['TEST_TMPDIR']!, 'google3-test');\n-    shx.mkdir('-p', tmpDir);\n-\n-    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n-    writeFile('router.d.ts', `\n-      export declare class ActivatedRoute {\n-        get children(): ActivatedRoute[];\n-        fragment: Observable<string | null>;\n-        snapshot: ActivatedRouteSnapshot;\n-        url: Observable<UrlSegment[]>;\n-      }\n-\n-      export declare class ActivatedRouteSnapshot {\n-        fragment: string | null;\n-        url: UrlSegment[];\n-      }\n-    `);\n-\n-    writeFile('tsconfig.json', JSON.stringify({\n-      compilerOptions: {\n-        module: 'es2015',\n-        baseUrl: './',\n-        strictNullChecks: true,\n-        paths: {\n-          '@angular/router': ['router.d.ts'],\n-        }\n-      },\n-    }));\n-  });\n-\n-  afterEach(() => shx.rm('-r', tmpDir));\n-\n-  function runTSLint(fix: boolean) {\n-    const program = Linter.createProgram(join(tmpDir, 'tsconfig.json'));\n-    const linter = new Linter({fix, rulesDirectory: [rulesDirectory]}, program);\n-    const config =\n-        Configuration.parseConfigFile({rules: {'activated-route-snapshot-fragment': true}});\n-\n-    program.getRootFileNames().forEach(fileName => {\n-      linter.lint(fileName, program.getSourceFile(fileName)!.getFullText(), config);\n-    });\n-\n-    return linter;\n-  }\n-\n-  function writeFile(fileName: string, content: string) {\n-    writeFileSync(join(tmpDir, fileName), content);\n-  }\n-\n-  function getFile(fileName: string) {\n-    return readFileSync(join(tmpDir, fileName), 'utf8');\n-  }\n-\n-  it('should flag accesses to `ActivatedRouteSnapshot.fragment`', () => {\n-    writeFile('/index.ts', `\n-      import {ActivatedRoute} from '@angular/router';\n-\n-      class App {\n-        private _route: ActivatedRoute;\n-\n-        ngOnInit() {\n-          this._route.fragment.subscribe();\n-        }\n-\n-        getFragment() {\n-          return this._route.snapshot.fragment.foo;\n-        }\n-      }\n-  `);\n-\n-    const linter = runTSLint(false);\n-    const failures = linter.getResult().failures.map(failure => failure.getFailure());\n-    expect(failures).toEqual(['`ActivatedRouteSnapshot.fragment` is nullable.']);\n-  });\n-\n-  it('should add non-null assertions to accesses of `ActivatedRouteSnapshot.fragment`', () => {\n-    writeFile('/index.ts', `\n-      import {ActivatedRoute} from '@angular/router';\n-\n-      class App {\n-        private _route: ActivatedRoute;\n-\n-        getFragment() {\n-          return this._getSnapshot().fragment.foo;\n-        }\n-\n-        private _getSnapshot() {\n-          return this._route.snapshot;\n-        }\n-      }\n-    `);\n-\n-    runTSLint(true);\n-\n-    expect(getFile('/index.ts')).toContain('return this._getSnapshot().fragment!.foo');\n-  });\n-\n-  it('should not add non-null assertions to accesses of `ActivatedRouteSnapshot.fragment` if there is one already',\n-     () => {\n-       writeFile('/index.ts', `\n-        import {ActivatedRoute} from '@angular/router';\n-\n-        class App {\n-          private _route: ActivatedRoute;\n-\n-          getFragment() {\n-            return this._route.snapshot.fragment!.foo;\n-          }\n-        }\n-      `);\n-\n-       runTSLint(true);\n-\n-       expect(getFile('/index.ts')).toContain('return this._route.snapshot.fragment!.foo;');\n-     });\n-\n-  it('should not add non-null assertions if the `ActivatedRouteSnapshot.fragment` has been null checked in an if statement',\n-     () => {\n-       writeFile('/index.ts', `\n-        import {ActivatedRouteSnapshot} from '@angular/router';\n-\n-        function getFragmentValue(snapshot: ActivatedRouteSnapshot) {\n-          if (snapshot.fragment) {\n-            return snapshot.fragment.value;\n-          }\n-\n-          return null;\n-        }\n-      `);\n-\n-       runTSLint(true);\n-\n-       const content = getFile('/index.ts');\n-       expect(content).toContain(`if (snapshot.fragment) {`);\n-       expect(content).toContain(`return snapshot.fragment.value;`);\n-     });\n-\n-  it('should not add non-null assertions if the `ActivatedRouteSnapshot.fragment` has been null checked in an else if statement',\n-     () => {\n-       writeFile('/index.ts', `\n-        import {ActivatedRouteSnapshot} from '@angular/router';\n-\n-        function getSnapshotValue(foo: boolean, snapshot: ActivatedRouteSnapshot) {\n-          if (foo) {\n-            return foo;\n-          } else if (snapshot.fragment) {\n-            return snapshot.fragment.value;\n-          }\n-\n-          return null;\n-        }\n-      `);\n-\n-       runTSLint(true);\n-\n-       const content = getFile('/index.ts');\n-       expect(content).toContain(`} else if (snapshot.fragment) {`);\n-       expect(content).toContain(`return snapshot.fragment.value;`);\n-     });\n-\n-  it('should not add non-null assertions if the `ActivatedRouteSnapshot.fragment` has been null checked in a ternary expression',\n-     () => {\n-       writeFile('/index.ts', `\n-        import {ActivatedRouteSnapshot} from '@angular/router';\n-\n-        function getSnapshotValue(snapshot: ActivatedRouteSnapshot) {\n-          return snapshot.fragment ? snapshot.fragment.value : null;\n-        }\n-      `);\n-\n-       runTSLint(true);\n-\n-       expect(getFile('/index.ts'))\n-           .toContain(`return snapshot.fragment ? snapshot.fragment.value : null;`);\n-     });\n-\n-  it('should not add non-null assertion to `ActivatedRouteSnapshot.fragment` if there is a safe access',\n-     () => {\n-       writeFile('/index.ts', `\n-        import {ActivatedRouteSnapshot} from '@angular/router';\n-\n-        function getSnapshotValue(snapshot: ActivatedRouteSnapshot) {\n-          return snapshot.fragment?.value;\n-        }\n-      `);\n-\n-       runTSLint(true);\n-       expect(getFile('/index.ts')).toContain(`return snapshot.fragment?.value;`);\n-     });\n-});"
        },
        {
            "sha": "0f3a479c5cf6edb5f0eb63823a1bcfadd86c07cf",
            "filename": "packages/core/schematics/test/google3/can_activate_with_redirect_rule_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 83,
            "changes": 83,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fcan_activate_with_redirect_rule_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fcan_activate_with_redirect_rule_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fcan_activate_with_redirect_rule_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,83 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {readFileSync, writeFileSync} from 'fs';\n-import {dirname, join} from 'path';\n-import * as shx from 'shelljs';\n-import {Configuration, Linter} from 'tslint';\n-\n-describe('Google3 canActivate with redirectTo', () => {\n-  const rulesDirectory =\n-      dirname(require.resolve('../../migrations/google3/canActivateWithRedirectToRule'));\n-\n-  let tmpDir: string;\n-\n-  beforeEach(() => {\n-    tmpDir = join(process.env['TEST_TMPDIR']!, 'google3-test');\n-    shx.mkdir('-p', tmpDir);\n-\n-    writeFile('tsconfig.json', JSON.stringify({\n-      compilerOptions: {\n-        module: 'es2015',\n-        baseUrl: './',\n-      },\n-    }));\n-  });\n-\n-  afterEach(() => shx.rm('-r', tmpDir));\n-\n-  function runTSLint(fix: boolean) {\n-    const program = Linter.createProgram(join(tmpDir, 'tsconfig.json'));\n-    const linter = new Linter({fix, rulesDirectory: [rulesDirectory]}, program);\n-    const config = Configuration.parseConfigFile({rules: {'can-activate-with-redirect-to': true}});\n-\n-    program.getRootFileNames().forEach(fileName => {\n-      linter.lint(fileName, program.getSourceFile(fileName)!.getFullText(), config);\n-    });\n-\n-    return linter;\n-  }\n-\n-  function writeFile(fileName: string, content: string) {\n-    writeFileSync(join(tmpDir, fileName), content);\n-  }\n-\n-  function getFile(fileName: string) {\n-    return readFileSync(join(tmpDir, fileName), 'utf8');\n-  }\n-\n-  it('should not flag canActivate when redirectTo is not present', async () => {\n-    writeFile('/index.ts', `const route = {path: '', canActivate: ['my_guard_token']}`);\n-\n-    const linter = runTSLint(false);\n-    const failures = linter.getResult().failures.map(failure => failure.getFailure());\n-\n-    expect(failures.length).toBe(0);\n-  });\n-\n-  it('should flag when canActivate when redirectTo is present', async () => {\n-    writeFile(\n-        '/index.ts',\n-        `const route = {path: '', redirectTo: 'other', canActivate: ['my_guard_token']}`);\n-\n-    const linter = runTSLint(false);\n-    const failures = linter.getResult().failures.map(failure => failure.getFailure());\n-    expect(failures.length).toBe(1);\n-    expect(failures[0]).toMatch(/canActivate cannot be used with redirectTo./);\n-  });\n-\n-  it('should fix when canActivate when redirectTo is present', async () => {\n-    writeFile(\n-        '/index.ts',\n-        `const route = {path: '', redirectTo: 'other', canActivate: ['my_guard_token']}`);\n-\n-    runTSLint(true);\n-    const content = getFile('/index.ts');\n-    expect(content).toContain(`const route = { path: '', redirectTo: 'other' }`);\n-  });\n-});"
        },
        {
            "sha": "106b61e708866f243ff9cfbc9d76be0ef561804a",
            "filename": "packages/core/schematics/test/google3/dynamic_queries_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 177,
            "changes": 177,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fdynamic_queries_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fdynamic_queries_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fdynamic_queries_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,177 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {readFileSync, writeFileSync} from 'fs';\n-import {dirname, join} from 'path';\n-import * as shx from 'shelljs';\n-import {Configuration, Linter} from 'tslint';\n-\n-describe('Google3 dynamic queries TSLint rule', () => {\n-  const rulesDirectory = dirname(require.resolve('../../migrations/google3/dynamicQueriesRule'));\n-\n-  let tmpDir: string;\n-\n-  beforeEach(() => {\n-    tmpDir = join(process.env['TEST_TMPDIR']!, 'google3-test');\n-    shx.mkdir('-p', tmpDir);\n-\n-    writeFile('tsconfig.json', JSON.stringify({compilerOptions: {module: 'es2015'}}));\n-  });\n-\n-  afterEach(() => shx.rm('-r', tmpDir));\n-\n-  function runTSLint(fix = true) {\n-    const program = Linter.createProgram(join(tmpDir, 'tsconfig.json'));\n-    const linter = new Linter({fix, rulesDirectory: [rulesDirectory]}, program);\n-    const config = Configuration.parseConfigFile({rules: {'dynamic-queries': true}});\n-\n-    program.getRootFileNames().forEach(fileName => {\n-      linter.lint(fileName, program.getSourceFile(fileName)!.getFullText(), config);\n-    });\n-\n-    return linter;\n-  }\n-\n-  function writeFile(fileName: string, content: string) {\n-    writeFileSync(join(tmpDir, fileName), content);\n-  }\n-\n-  function getFile(fileName: string) {\n-    return readFileSync(join(tmpDir, fileName), 'utf8');\n-  }\n-\n-  it('should flag dynamic queries', () => {\n-    writeFile('/index.ts', `\n-      import { Directive, ViewChild, ContentChild } from '@angular/core';\n-\n-      @Directive()\n-      export class MyDirective {\n-        @ViewChild('child', { static: false }) child: any;\n-        @ContentChild('otherChild', { static: false }) otherChild: any;\n-      }\n-    `);\n-\n-    const linter = runTSLint(false);\n-    const failures = linter.getResult().failures;\n-\n-    expect(failures.length).toBe(2);\n-    expect(failures[0].getFailure())\n-        .toMatch('The static flag defaults to false, so setting it false manually is unnecessary.');\n-    expect(failures[1].getFailure())\n-        .toMatch('The static flag defaults to false, so setting it false manually is unnecessary.');\n-  });\n-\n-  it('should remove the options object from a dynamic ViewChild query that only has one property',\n-     () => {\n-       writeFile('/index.ts', `\n-        import { Directive, ViewChild } from '@angular/core';\n-\n-        @Directive()\n-        export class MyDirective {\n-          @ViewChild('child', { static: false }) child: any;\n-        }\n-      `);\n-\n-       runTSLint(true);\n-       expect(getFile('/index.ts')).toContain(`@ViewChild('child') child: any;`);\n-     });\n-\n-  it('should remove the options object from a dynamic ContentChild query that only has one property',\n-     () => {\n-       writeFile('/index.ts', `\n-        import { Directive, ContentChild } from '@angular/core';\n-\n-        @Directive()\n-        export class MyComponent {\n-          @ContentChild('child', { static: false }) child: any;\n-        }\n-      `);\n-\n-       runTSLint(true);\n-       expect(getFile('/index.ts')).toContain(`@ContentChild('child') child: any;`);\n-     });\n-\n-  it('should only remove the `static` flag from a ViewChild query if it has more than one property',\n-     () => {\n-       writeFile('/index.ts', `\n-        import { Directive, ViewChild, ElementRef } from '@angular/core';\n-\n-        @Directive()\n-        export class MyDirective {\n-          @ViewChild('child', { read: ElementRef, static: false }) child: ElementRef;\n-        }\n-      `);\n-\n-       runTSLint(true);\n-       expect(getFile('/index.ts'))\n-           .toContain(`@ViewChild('child', { read: ElementRef }) child: ElementRef;`);\n-     });\n-\n-  it('should only remove the `static` flag from a ContentChild query if it has more than one property',\n-     () => {\n-       writeFile('/index.ts', `\n-        import { Directive, ContentChild, ElementRef } from '@angular/core';\n-\n-        @Directive()\n-        export class MyDirective {\n-          @ContentChild('child', { static: false, read: ElementRef }) child: ElementRef;\n-        }\n-      `);\n-\n-       runTSLint(true);\n-       expect(getFile('/index.ts'))\n-           .toContain(`@ContentChild('child', { read: ElementRef }) child: ElementRef;`);\n-     });\n-\n-  it('should not change static ViewChild queries', () => {\n-    writeFile('/index.ts', `\n-      import { Directive, ViewChild, ElementRef } from '@angular/core';\n-\n-      @Directive()\n-      export class MyDirective {\n-        @ViewChild('child', { read: ElementRef, static: true }) child: ElementRef;\n-      }\n-    `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts'))\n-        .toContain(`@ViewChild('child', { read: ElementRef, static: true }) child: ElementRef;`);\n-  });\n-\n-  it('should not change static ContentChild queries', () => {\n-    writeFile('/index.ts', `\n-      import { Directive, ContentChild, ElementRef } from '@angular/core';\n-\n-      @Directive()\n-      export class MyDirective {\n-        @ContentChild('child', { static: true, read: ElementRef }) child: ElementRef;\n-      }\n-    `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts'))\n-        .toContain(`@ContentChild('child', { static: true, read: ElementRef }) child: ElementRef;`);\n-  });\n-\n-  it('should migrate dynamic queries on a setter', () => {\n-    writeFile('/index.ts', `\n-     import { Directive, ContentChild, ViewChild } from '@angular/core';\n-\n-     @Directive()\n-     export class MyDirective {\n-       @ContentChild('child', { static: false }) set child(c: any) {}\n-       @ViewChild('otherChild', { static: false }) set otherChild(c: any) {}\n-     }\n-   `);\n-\n-    runTSLint(true);\n-    const content = getFile('/index.ts');\n-    expect(content).toContain(`@ContentChild('child') set child(c: any) {}`);\n-    expect(content).toContain(`@ViewChild('otherChild') set otherChild(c: any) {}`);\n-  });\n-});"
        },
        {
            "sha": "f791863b5aee7a857e36700ecddd9ba5728d4ae3",
            "filename": "packages/core/schematics/test/google3/explicit_query_timing_rule_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 149,
            "changes": 149,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fexplicit_query_timing_rule_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fexplicit_query_timing_rule_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fexplicit_query_timing_rule_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,149 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {readFileSync, writeFileSync} from 'fs';\n-import {dirname, join} from 'path';\n-import * as shx from 'shelljs';\n-import {Configuration, Linter} from 'tslint';\n-\n-describe('Google3 explicitQueryTiming TSLint rule', () => {\n-  /**\n-   * Path to the static-query schematic rules directory. The path needs to be resolved through\n-   * the Bazel runfiles, because on Windows runfiles are not symlinked into the working directory.\n-   */\n-  const rulesDirectory =\n-      dirname(require.resolve('../../migrations/google3/explicitQueryTimingRule'));\n-\n-  let tmpDir: string;\n-\n-  beforeEach(() => {\n-    tmpDir = join(process.env['TEST_TMPDIR']!, 'google3-test');\n-    shx.mkdir('-p', tmpDir);\n-\n-    writeFile('tsconfig.json', JSON.stringify({compilerOptions: {module: 'es2015'}}));\n-  });\n-\n-  afterEach(() => shx.rm('-r', tmpDir));\n-\n-  /**\n-   * Runs TSLint with the static-query timing TSLint rule. By default the rule fixes\n-   * are automatically applied.\n-   */\n-  function runTSLint(fix = true) {\n-    const program = Linter.createProgram(join(tmpDir, 'tsconfig.json'));\n-    const linter = new Linter({fix, rulesDirectory: [rulesDirectory]}, program);\n-    const config = Configuration.parseConfigFile({rules: {'explicit-query-timing': true}});\n-\n-    program.getRootFileNames().forEach(fileName => {\n-      linter.lint(fileName, program.getSourceFile(fileName)!.getFullText(), config);\n-    });\n-\n-    return linter;\n-  }\n-\n-  /** Writes a file to the current temporary directory. */\n-  function writeFile(fileName: string, content: string) {\n-    writeFileSync(join(tmpDir, fileName), content);\n-  }\n-\n-  /** Expects a given file in the temporary directory to contain the specified string. */\n-  function expectFileToContain(fileName: string, match: string) {\n-    expect(readFileSync(join(tmpDir, fileName), 'utf8')).toContain(match);\n-  }\n-\n-  it('should properly apply query timing replacements', () => {\n-    writeFile('index.ts', `\n-      import {Component, ViewChild} from '@angular/core';\n-\n-      @Component({template: '<span #test></span>'})\n-      export class MyComp {\n-        @ViewChild('test') query: any;\n-        @ViewChild('test') query2: any;\n-        @ViewChild('test') query3: any;\n-\n-        ngAfterContentInit() {\n-          this.query.classList.add('test');\n-        }\n-      }\n-    `);\n-\n-    writeFile('external.ts', `\n-      import {MyComp} from './index';\n-\n-      export class Test extends MyComp {\n-        ngOnInit() {\n-          this.query3.doSomething();\n-        }\n-      }\n-    `);\n-\n-    runTSLint();\n-\n-    expectFileToContain('index.ts', `@ViewChild('test', { static: true }) query: any;`);\n-    expectFileToContain('index.ts', `@ViewChild('test', { static: false }) query2: any;`);\n-    expectFileToContain('index.ts', `@ViewChild('test', { static: true }) query3: any;`);\n-  });\n-\n-  it('should report non-explicit static query definitions', () => {\n-    writeFile('index.ts', `\n-      import {Component, ViewChild} from '@angular/core';\n-\n-      @Component({template: '<span #test></span>'})\n-      export class MyComp {\n-        @ViewChild('test') query: any;\n-\n-        ngAfterContentInit() {\n-          this.query.classList.add('test');\n-        }\n-      }\n-    `);\n-\n-    const linter = runTSLint(false);\n-    const failures = linter.getResult().failures;\n-\n-    expect(failures.length).toBe(1);\n-    expect(failures[0].getFailure()).toMatch(/analysis of the query.*\"{static: true}\"/);\n-  });\n-\n-  it('should report non-explicit dynamic query definitions', () => {\n-    writeFile('index.ts', `\n-      import {Component, ContentChild} from '@angular/core';\n-\n-      @Component({template: '<span #test></span>'})\n-      export class MyComp {\n-        @ContentChild('test') query: any;\n-      }\n-    `);\n-\n-    const linter = runTSLint(false);\n-    const failures = linter.getResult().failures;\n-\n-    expect(failures.length).toBe(1);\n-    expect(failures[0].getFailure()).toMatch(/analysis of the query.*\"{static: false}\"/);\n-  });\n-\n-  it('should detect query usage in component template', () => {\n-    writeFile('index.ts', `\n-      import {Component, ViewChild} from '@angular/core';\n-\n-      @Component({\n-        template: \\`\n-          <span #test></span>\n-          <my-comp [binding]=\"query\"></my-comp>\n-        \\`\n-      })\n-      export class MyComp {\n-        @ViewChild('test') query: any;\n-      }\n-    `);\n-\n-    runTSLint();\n-\n-    expectFileToContain('index.ts', `@ViewChild('test', { static: true }) query: any;`);\n-  });\n-});"
        },
        {
            "sha": "07cddb8fdb24034fea078880a9a6f7526e3c6de1",
            "filename": "packages/core/schematics/test/google3/initial_navigation_rule_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 211,
            "changes": 211,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Finitial_navigation_rule_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Finitial_navigation_rule_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Finitial_navigation_rule_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,211 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {readFileSync, writeFileSync} from 'fs';\n-import {dirname, join} from 'path';\n-import * as shx from 'shelljs';\n-import {Configuration, Linter} from 'tslint';\n-\n-describe('Google3 initial navigation tslint rule', () => {\n-  const rulesDirectory = dirname(require.resolve('../../migrations/google3/initialNavigationRule'));\n-\n-  let tmpDir: string;\n-\n-  beforeEach(() => {\n-    tmpDir = join(process.env['TEST_TMPDIR']!, 'google3-test');\n-    shx.mkdir('-p', tmpDir);\n-\n-    writeFile('tsconfig.json', JSON.stringify({compilerOptions: {module: 'es2015'}}));\n-  });\n-\n-  afterEach(() => shx.rm('-r', tmpDir));\n-\n-  function runTSLint(fix = true) {\n-    const program = Linter.createProgram(join(tmpDir, 'tsconfig.json'));\n-    const linter = new Linter({fix, rulesDirectory: [rulesDirectory]}, program);\n-    const config = Configuration.parseConfigFile({rules: {'initial-navigation': true}});\n-\n-    program.getRootFileNames().forEach(fileName => {\n-      linter.lint(fileName, program.getSourceFile(fileName)!.getFullText(), config);\n-    });\n-\n-    return linter;\n-  }\n-\n-  function writeFile(fileName: string, content: string) {\n-    writeFileSync(join(tmpDir, fileName), content);\n-  }\n-\n-  function getFile(fileName: string) {\n-    return readFileSync(join(tmpDir, fileName), 'utf8');\n-  }\n-\n-  it('should migrate legacy_disabled to disabled', () => {\n-    writeFile('/index.ts', `\n-      import { NgModule } from '@angular/core';\n-      import { RouterModule } from '@angular/router';\n-\n-      @NgModule({\n-        imports: [\n-          RouterModule.forRoot([], {initialNavigation: 'legacy_disabled'}),\n-        ]\n-      })\n-      export class AppModule {\n-      }\n-    `);\n-\n-\n-    runTSLint();\n-\n-    expect(getFile('/index.ts')).toContain(`{initialNavigation: 'disabled'}`);\n-  });\n-\n-  it(`should migrate false to disabled`, () => {\n-    writeFile('/index.ts', `\n-      import { NgModule } from '@angular/core';\n-      import { RouterModule } from '@angular/router';\n-\n-      @NgModule({\n-        imports: [\n-          RouterModule.forRoot([], {initialNavigation: false}),\n-        ]\n-      })\n-      export class AppModule {\n-      }\n-    `);\n-\n-    runTSLint();\n-\n-    expect(getFile('/index.ts')).toContain(`{initialNavigation: 'disabled'}`);\n-  });\n-\n-  it('should migrate legacy_enabled to enabledNonBlocking', () => {\n-    writeFile('/index.ts', `\n-      import { NgModule } from '@angular/core';\n-      import { RouterModule } from '@angular/router';\n-\n-      @NgModule({\n-        imports: [\n-          RouterModule.forRoot([], {initialNavigation: 'legacy_enabled'}),\n-        ]\n-      })\n-      export class AppModule {\n-      }\n-    `);\n-\n-    runTSLint(true);\n-\n-    expect(getFile('/index.ts')).toContain(`{initialNavigation: 'enabledNonBlocking'}`);\n-  });\n-\n-  it(`should migrate true to enabledNonBlocking`, () => {\n-    writeFile('/index.ts', `\n-      mport { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([], {initialNavigation: true}),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-    `);\n-\n-    runTSLint(true);\n-\n-    expect(getFile('/index.ts')).toContain(`{initialNavigation: 'enabledNonBlocking'}`);\n-  });\n-\n-  it('should migrate nested objects', () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-\n-        const options = {initialNavigation: 'legacy_enabled'};\n-\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([], {initialNavigation: 'legacy_disabled', ...options}),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts'))\n-        .toContain(`const options = {initialNavigation: 'enabledNonBlocking'};`);\n-    expect(getFile('/index.ts')).toContain(`{initialNavigation: 'disabled', ...options}`);\n-  });\n-\n-  it('should migrate nested objects mixed validity', () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-\n-        const options = {initialNavigation: 'legacy_enabled'};\n-\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([], {initialNavigation: 'disabled', ...options}),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts'))\n-        .toContain(`const options = {initialNavigation: 'enabledNonBlocking'};`);\n-  });\n-\n-  it('should migrate nested objects opposite order', () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-\n-        const options = {initialNavigation: 'legacy_enabled'};\n-\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([], {...options, initialNavigation: 'legacy_disabled'}),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts'))\n-        .toContain(`const options = {initialNavigation: 'enabledNonBlocking'};`);\n-    expect(getFile('/index.ts')).toContain(`{...options, initialNavigation: 'disabled'}`);\n-  });\n-\n-  it('should migrate nested objects mixed validity opposite order', () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-\n-        const options = {initialNavigation: 'legacy_enabled'};\n-\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([], {...options, initialNavigation: 'disabled'}),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts'))\n-        .toContain(`const options = {initialNavigation: 'enabledNonBlocking'};`);\n-    expect(getFile('/index.ts')).toContain(`{...options, initialNavigation: 'disabled'}`);\n-  });\n-});"
        },
        {
            "sha": "de6f4503790ed7e12e9f785e6c8d8bbf970a9106",
            "filename": "packages/core/schematics/test/google3/missing_injectable_rule_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 271,
            "changes": 271,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fmissing_injectable_rule_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fmissing_injectable_rule_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fmissing_injectable_rule_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,271 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {readFileSync, writeFileSync} from 'fs';\n-import {dirname, join} from 'path';\n-import * as shx from 'shelljs';\n-import {Configuration, Linter} from 'tslint';\n-\n-describe('Google3 missing injectable tslint rule', () => {\n-  const rulesDirectory =\n-      dirname(require.resolve('../../migrations/google3/noMissingInjectableRule'));\n-\n-  let tmpDir: string;\n-\n-  beforeEach(() => {\n-    tmpDir = join(process.env['TEST_TMPDIR']!, 'google3-test');\n-    shx.mkdir('-p', tmpDir);\n-\n-    writeFile('tsconfig.json', JSON.stringify({compilerOptions: {module: 'es2015'}}));\n-  });\n-\n-  afterEach(() => shx.rm('-r', tmpDir));\n-\n-  function runTSLint(fix = true) {\n-    const program = Linter.createProgram(join(tmpDir, 'tsconfig.json'));\n-    const linter = new Linter({fix, rulesDirectory: [rulesDirectory]}, program);\n-    const config = Configuration.parseConfigFile({rules: {'no-missing-injectable': true}});\n-\n-    program.getRootFileNames().forEach(fileName => {\n-      linter.lint(fileName, program.getSourceFile(fileName)!.getFullText(), config);\n-    });\n-\n-    return linter;\n-  }\n-\n-  function writeFile(fileName: string, content: string) {\n-    writeFileSync(join(tmpDir, fileName), content);\n-  }\n-\n-  function getFile(fileName: string) {\n-    return readFileSync(join(tmpDir, fileName), 'utf8');\n-  }\n-\n-  describe('NgModule', () => createTests('NgModule', 'providers'));\n-  describe('Directive', () => createTests('Directive', 'providers'));\n-\n-  describe('Component', () => {\n-    createTests('Component', 'providers');\n-    createTests('Component', 'viewProviders');\n-\n-    it('should migrate all providers defined in \"viewProviders\" and \"providers\" in the ' +\n-           'same component',\n-       () => {\n-         writeFile('/index.ts', `\n-          import {Component} from '@angular/core';\n-\n-          export class MyService {}\n-          export class MySecondService {}\n-\n-          @Component({\n-            providers: [MyService],\n-            viewProviders: [MySecondService],\n-          })\n-          export class TestClass {}\n-        `);\n-\n-         const result = runTSLint().getResult();\n-\n-         expect(result.errorCount).toBe(0);\n-         expect(getFile('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class MyService/);\n-         expect(getFile('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class MySecondService/);\n-         expect(getFile('/index.ts')).toContain(`{ Component, Injectable } from '@angular/core`);\n-       });\n-  });\n-\n-  function createTests(\n-      type: 'NgModule'|'Directive'|'Component', propName: 'providers'|'viewProviders') {\n-    it('should create proper failures for missing injectable providers', () => {\n-      writeFile('index.ts', `\n-        import { ${type} } from '@angular/core';\n-\n-        export class A {}\n-\n-        @${type}({${propName}: [A]})\n-        export class TestClass {}\n-      `);\n-\n-      const linter = runTSLint(false);\n-      const failures = linter.getResult().failures;\n-\n-      expect(failures.length).toBe(2);\n-      expect(failures[0].getFailure())\n-          .toMatch(/Class needs to be decorated with \"@Injectable\\(\\)\".*provided by \"TestClass\"/);\n-      expect(failures[0].getStartPosition().getLineAndCharacter()).toEqual({line: 3, character: 8});\n-      expect(failures[1].getFailure()).toMatch(/Import needs to be updated to import.*Injectable/);\n-      expect(failures[1].getStartPosition().getLineAndCharacter())\n-          .toEqual({line: 1, character: 15});\n-    });\n-\n-    it('should update provider classes which need to be migrated in Ivy', () => {\n-      writeFile('/index.ts', `\n-        import {Pipe, Directive, Component, NgModule} from '@angular/core';\n-\n-        @Pipe()\n-        export class WithPipe {}\n-\n-        @Directive()\n-        export class WithDirective {}\n-\n-        @Component()\n-        export class WithComponent {}\n-\n-        export class MyServiceA {}\n-        export class MyServiceB {}\n-        export class MyServiceC {}\n-        export class MyServiceD {}\n-        export class MyServiceE {}\n-        export class MyServiceF {}\n-        export class MyServiceG {}\n-        export class MyServiceH {}\n-\n-        @${type}({${propName}: [\n-          WithPipe,\n-          [\n-            WithDirective,\n-            WithComponent,\n-            MyServiceA,\n-          ]\n-          MyServiceB,\n-          {provide: MyServiceC},\n-          {provide: null, useClass: MyServiceD},\n-          {provide: null, useExisting: MyServiceE},\n-          {provide: MyServiceF, useFactory: () => null},\n-          {provide: MyServiceG, useValue: null},\n-          {provide: MyServiceH, deps: []},\n-        ]})\n-        export class TestClass {}\n-      `);\n-\n-\n-      runTSLint();\n-\n-      expect(getFile('/index.ts')).toMatch(/'@angular\\/core';\\s+@Pipe\\(\\)\\s+export class WithPipe/);\n-      expect(getFile('/index.ts'))\n-          .toMatch(/WithPipe {}\\s+@Directive\\(\\)\\s+export class WithDirective/);\n-      expect(getFile('/index.ts'))\n-          .toMatch(/WithDirective {}\\s+@Component\\(\\)\\s+export class WithComponent/);\n-      expect(getFile('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class MyServiceA/);\n-      expect(getFile('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class MyServiceB/);\n-      expect(getFile('/index.ts')).toMatch(/MyServiceB {}\\s+export class MyServiceC/);\n-      expect(getFile('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class MyServiceD/);\n-      expect(getFile('/index.ts')).toMatch(/MyServiceD {}\\s+export class MyServiceE/);\n-      expect(getFile('/index.ts')).toMatch(/MyServiceE {}\\s+export class MyServiceF/);\n-      expect(getFile('/index.ts')).toMatch(/MyServiceF {}\\s+export class MyServiceG/);\n-      expect(getFile('/index.ts')).toMatch(/MyServiceG {}\\s+export class MyServiceH/);\n-      expect(getFile('/index.ts')).toContain(`{ provide: MyServiceC, useValue: undefined },`);\n-    });\n-\n-    it(`should migrate provider once if referenced in multiple ${type} definitions`, () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        export class ServiceA {}\n-\n-        @${type}({${propName}: [ServiceA]})\n-        export class TestClass {}\n-      `);\n-\n-      writeFile('/second.ts', `\n-        import {${type}} from '@angular/core';\n-        import {ServiceA} from './index';\n-\n-        export class ServiceB {}\n-\n-        @${type}({${propName}: [ServiceA, ServiceB]})\n-        export class TestClass2 {}\n-      `);\n-\n-      runTSLint();\n-\n-      expect(getFile('/index.ts'))\n-          .toMatch(/@angular\\/core';\\s+@Injectable\\(\\)\\s+export class ServiceA/);\n-      expect(getFile('/index.ts')).toContain(`{ ${type}, Injectable } from '@angular/core`);\n-      expect(getFile('/second.ts')).toMatch(/@Injectable\\(\\)\\s+export class ServiceB/);\n-      expect(getFile('/second.ts')).toContain(`{ ${type}, Injectable } from '@angular/core`);\n-    });\n-\n-    it('should warn if a referenced provider could not be resolved', () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        @${type}({${propName}: [NotPresent]})\n-        export class TestClass {}\n-      `);\n-\n-      const linter = runTSLint();\n-      const failures = linter.getResult().failures;\n-\n-      expect(failures.length).toBe(1);\n-      expect(failures[0].getFailure()).toMatch(/Provider is not statically analyzable./);\n-      expect(failures[0].getStartPosition().getLineAndCharacter())\n-          .toEqual({line: 3, character: 14 + type.length + propName.length});\n-    });\n-\n-    it(`should warn if the \"${propName}\" value could not be resolved`, () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        @${type}({${propName}: NOT_ANALYZABLE)\n-        export class TestClass {}\n-      `);\n-\n-      const linter = runTSLint();\n-      const failures = linter.getResult().failures;\n-\n-      expect(failures.length).toBe(1);\n-      expect(failures[0].getFailure()).toMatch(/Providers.*not statically analyzable./);\n-      expect(failures[0].getStartPosition().getLineAndCharacter())\n-          .toEqual({line: 3, character: 13 + type.length + propName.length});\n-    });\n-\n-    it('should create new import for @Injectable when migrating provider', () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-        import {MyService, MySecondService} from './service';\n-\n-        @${type}({${propName}: [MyService, MySecondService]})\n-        export class TestClass {}\n-      `);\n-\n-      writeFile('/service.ts', `export class MyService {}\n-\n-        export class MySecondService {}\n-      `);\n-\n-      runTSLint();\n-\n-      expect(getFile('/service.ts')).toMatch(/@Injectable\\(\\)\\s+export class MyService/);\n-      expect(getFile('/service.ts')).toMatch(/@Injectable\\(\\)\\s+export class MySecondService/);\n-      expect(getFile('/service.ts')).toMatch(/import { Injectable } from \"@angular\\/core\";/);\n-    });\n-\n-    it('should remove @Inject decorator for providers which are migrated', () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-        import {MyService} from './service';\n-\n-        @${type}({${propName}: [MyService]})\n-        export class TestClass {}\n-      `);\n-\n-      writeFile('/service.ts', `\n-        import {Inject} from '@angular/core';\n-\n-        @Inject()\n-        export class MyService {}\n-      `);\n-\n-      runTSLint();\n-\n-      expect(getFile('/service.ts')).toMatch(/core';\\s+@Injectable\\(\\)\\s+export class MyService/);\n-      expect(getFile('/service.ts'))\n-          .toMatch(/import { Inject, Injectable } from '@angular\\/core';/);\n-    });\n-  }\n-});"
        },
        {
            "sha": "42325de7c02ecdcea73346216aaf534f0349af63",
            "filename": "packages/core/schematics/test/google3/navigation_extras_omissions_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 334,
            "changes": 334,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fnavigation_extras_omissions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fnavigation_extras_omissions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fnavigation_extras_omissions_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,334 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {readFileSync, writeFileSync} from 'fs';\n-import {dirname, join} from 'path';\n-import * as shx from 'shelljs';\n-import {Configuration, Linter} from 'tslint';\n-\n-describe('Google3 NavigationExtras omissions TSLint rule', () => {\n-  const rulesDirectory =\n-      dirname(require.resolve('../../migrations/google3/navigationExtrasOmissionsRule'));\n-\n-  let tmpDir: string;\n-\n-  beforeEach(() => {\n-    tmpDir = join(process.env['TEST_TMPDIR']!, 'google3-test');\n-    shx.mkdir('-p', tmpDir);\n-\n-    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n-    writeFile('router.d.ts', `\n-      export declare class Router {\n-        navigateByUrl(url: string, extras?: any);\n-        createUrlTree(commands: any[], extras?: any);\n-      }\n-    `);\n-\n-    writeFile('tsconfig.json', JSON.stringify({\n-      compilerOptions: {\n-        module: 'es2015',\n-        baseUrl: './',\n-        paths: {\n-          '@angular/router': ['router.d.ts'],\n-        }\n-      },\n-    }));\n-  });\n-\n-  afterEach(() => shx.rm('-r', tmpDir));\n-\n-  function runTSLint(fix: boolean) {\n-    const program = Linter.createProgram(join(tmpDir, 'tsconfig.json'));\n-    const linter = new Linter({fix, rulesDirectory: [rulesDirectory]}, program);\n-    const config = Configuration.parseConfigFile({rules: {'navigation-extras-omissions': true}});\n-\n-    program.getRootFileNames().forEach(fileName => {\n-      linter.lint(fileName, program.getSourceFile(fileName)!.getFullText(), config);\n-    });\n-\n-    return linter;\n-  }\n-\n-  function writeFile(fileName: string, content: string) {\n-    writeFileSync(join(tmpDir, fileName), content);\n-  }\n-\n-  function getFile(fileName: string) {\n-    return readFileSync(join(tmpDir, fileName), 'utf8');\n-  }\n-\n-  it('should flag objects with invalid properties used inside the relevant method calls', () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      class Navigator {\n-        constructor(private _router: Router) {}\n-\n-        goHome() {\n-          this._router.navigateByUrl('/', {fragment: 'foo'});\n-        }\n-\n-        createTree() {\n-          return this._router.createUrlTree(['/'], {state: {}});\n-        }\n-\n-        goAway() {\n-          this._router.navigateByUrl('/away');\n-        }\n-      }\n-    `);\n-\n-    const linter = runTSLint(false);\n-    const failures = linter.getResult().failures.map(failure => failure.getFailure());\n-\n-    expect(failures.length).toBe(2);\n-    expect(failures[0])\n-        .toMatch(\n-            /Object used in navigateByUrl or createUrlTree call contains unsupported properties/);\n-    expect(failures[1])\n-        .toMatch(\n-            /Object used in navigateByUrl or createUrlTree call contains unsupported properties/);\n-  });\n-\n-  it('should not change calls with a single argument', () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      class Navigator {\n-        constructor(private _router: Router) {}\n-\n-        goHome() {\n-          this._router.navigateByUrl('/');\n-        }\n-      }\n-\n-      function createTree(router: Router) {\n-        return router.createUrlTree(['/']);\n-      }\n-    `);\n-\n-    runTSLint(true);\n-\n-    const content = getFile('/index.ts');\n-    expect(content).toContain(`this._router.navigateByUrl('/');`);\n-    expect(content).toContain(`return router.createUrlTree(['/']);`);\n-  });\n-\n-  it('should not change calls with an empty object literal', () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      class Navigator {\n-        constructor(private _router: Router) {}\n-\n-        goHome() {\n-          this._router.navigateByUrl('/', {});\n-        }\n-      }\n-\n-      function createTree(router: Router) {\n-        return router.createUrlTree(['/'], {});\n-      }\n-    `);\n-\n-    runTSLint(true);\n-\n-    const content = getFile('/index.ts');\n-    expect(content).toContain(`this._router.navigateByUrl('/', {});`);\n-    expect(content).toContain(`return router.createUrlTree(['/'], {});`);\n-  });\n-\n-  it('should not change objects that are used in multiple different methods', () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      const config = {replaceUrl: true, fragment: 'foo', state: {}};\n-\n-      class Navigator {\n-        constructor(private _router: Router) {}\n-\n-        goHome() {\n-          this._router.navigateByUrl('/', config);\n-          return this._router.createUrlTree(['/'], config);\n-        }\n-      }\n-    `);\n-\n-    runTSLint(true);\n-\n-    const content = getFile('/index.ts');\n-    expect(content).toContain(`const config = {replaceUrl: true, fragment: 'foo', state: {}};`);\n-  });\n-\n-  it('should preserve calls if the router does not come from @angular/router', () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@custom/router';\n-\n-      function createTree(router: Router) {\n-        return router.createUrlTree(['/'], {foo: 1, bar: 2});\n-      }\n-    `);\n-\n-    runTSLint(true);\n-\n-    const content = getFile('/index.ts');\n-    expect(content).toContain(`return router.createUrlTree(['/'], {foo: 1, bar: 2});`);\n-  });\n-\n-  it('should change invalid navigateByUrl calls', () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      class Navigator {\n-        constructor(private _router: Router) {}\n-\n-        goHome() {\n-          this._router.navigateByUrl('/', {preserveFragment: false, skipLocationChange: false, fragment: 'foo'});\n-        }\n-      }\n-    `);\n-\n-    runTSLint(true);\n-\n-    const content = getFile('/index.ts');\n-    expect(content).toContain(\n-        `this._router.navigateByUrl('/', { /* Removed unsupported properties by Angular migration: preserveFragment, fragment. */ skipLocationChange: false });`);\n-  });\n-\n-  it('should change invalid navigateByUrl calls', () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      function createTree(router: Router) {\n-        return router.createUrlTree(['/'], {replaceUrl: true, preserveFragment: true, state: {}});\n-      }\n-    `);\n-\n-    runTSLint(true);\n-\n-    const content = getFile('/index.ts');\n-    expect(content).toContain(\n-        `return router.createUrlTree(['/'], { /* Removed unsupported properties by Angular migration: replaceUrl, state. */ preserveFragment: true });`);\n-  });\n-\n-  it('should set the comment outside the object if all properties were removed', () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      function navigate(router: Router) {\n-        router.navigateByUrl('/', {fragment: 'foo'});\n-      }\n-    `);\n-\n-    runTSLint(true);\n-\n-    const content = getFile('/index.ts');\n-    expect(content).toContain(\n-        `router.navigateByUrl('/', /* Removed unsupported properties by Angular migration: fragment. */ {});`);\n-  });\n-\n-  it('should migrate object literals defined as variables', () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      const config = {skipLocationChange: false, fragment: 'foo'};\n-      const proxy = config;\n-\n-      function navigate(router: Router) {\n-        router.navigateByUrl('/', proxy);\n-      }\n-    `);\n-\n-    runTSLint(true);\n-\n-    const content = getFile('/index.ts');\n-    expect(content).toContain(\n-        `const config = { /* Removed unsupported properties by Angular migration: fragment. */ skipLocationChange: false };`);\n-    expect(content).toContain(`const proxy = config;`);\n-    expect(content).toContain(`router.navigateByUrl('/', proxy);`);\n-  });\n-\n-  it('should pick up calls where the router is returned by a function', () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      function navigate(router: Router) {\n-        getRouter().navigateByUrl('/', {fragment: 'foo'});\n-      }\n-\n-      function getRouter() {\n-        return {} as Router;\n-      }\n-    `);\n-\n-    runTSLint(true);\n-\n-    const content = getFile('/index.ts');\n-    expect(content).toContain(\n-        `getRouter().navigateByUrl('/', /* Removed unsupported properties by Angular migration: fragment. */ {});`);\n-  });\n-\n-  it('should pick up calls where the router is aliased', () => {\n-    writeFile('/index.ts', `\n-      import {Router as AliasedRouter} from '@angular/router';\n-\n-      function navigate(router: AliasedRouter) {\n-        router.navigateByUrl('/', {fragment: 'foo'});\n-      }\n-    `);\n-\n-    runTSLint(true);\n-\n-    const content = getFile('/index.ts');\n-    expect(content).toContain(\n-        `router.navigateByUrl('/', /* Removed unsupported properties by Angular migration: fragment. */ {});`);\n-  });\n-\n-  it('should preserve object spread assignments', () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      function navigate(router: Router) {\n-        const overrides = {foo: 1};\n-        router.navigateByUrl('/', {replaceUrl: true, fragment: 'foo', ...overrides});\n-      }\n-    `);\n-\n-    runTSLint(true);\n-\n-    const content = getFile('/index.ts');\n-    expect(content).toContain(\n-        `router.navigateByUrl('/', { /* Removed unsupported properties by Angular migration: fragment. */ replaceUrl: true, ...overrides });`);\n-  });\n-\n-  it('should migrate objects that are used in multiple calls of the same method', () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      const config = {skipLocationChange: false, fragment: 'foo'};\n-\n-      class Navigator {\n-        constructor(private _router: Router) {}\n-\n-        goHome() {\n-          this._router.navigateByUrl('/', config);\n-        }\n-\n-        goFish() {\n-          this._router.navigateByUrl('/fish', config);\n-        }\n-      }\n-    `);\n-\n-    runTSLint(true);\n-\n-    const content = getFile('/index.ts');\n-    expect(content).toContain(\n-        `const config = { /* Removed unsupported properties by Angular migration: fragment. */ skipLocationChange: false };`);\n-  });\n-});"
        },
        {
            "sha": "44ee0095972cec5e073ec45e4534c40dedb0e699",
            "filename": "packages/core/schematics/test/google3/no_template_variable_assignment_rule_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 110,
            "changes": 110,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fno_template_variable_assignment_rule_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fno_template_variable_assignment_rule_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fno_template_variable_assignment_rule_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,110 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {writeFileSync} from 'fs';\n-import {dirname, join} from 'path';\n-import * as shx from 'shelljs';\n-import {Configuration, Linter} from 'tslint';\n-\n-describe('Google3 noTemplateVariableAssignment TSLint rule', () => {\n-  const rulesDirectory =\n-      dirname(require.resolve('../../migrations/google3/noTemplateVariableAssignmentRule'));\n-\n-  let tmpDir: string;\n-\n-  beforeEach(() => {\n-    tmpDir = join(process.env['TEST_TMPDIR']!, 'google3-test');\n-    shx.mkdir('-p', tmpDir);\n-\n-    writeFile('tsconfig.json', JSON.stringify({compilerOptions: {module: 'es2015'}}));\n-  });\n-\n-  afterEach(() => shx.rm('-r', tmpDir));\n-\n-  /** Runs TSLint with the no-template-variable TSLint rule.*/\n-  function runTSLint() {\n-    const program = Linter.createProgram(join(tmpDir, 'tsconfig.json'));\n-    const linter = new Linter({fix: false, rulesDirectory: [rulesDirectory]}, program);\n-    const config =\n-        Configuration.parseConfigFile({rules: {'no-template-variable-assignment': true}});\n-\n-    program.getRootFileNames().forEach(fileName => {\n-      linter.lint(fileName, program.getSourceFile(fileName)!.getFullText(), config);\n-    });\n-\n-    return linter;\n-  }\n-\n-  /** Writes a file to the current temporary directory. */\n-  function writeFile(fileName: string, content: string) {\n-    writeFileSync(join(tmpDir, fileName), content);\n-  }\n-\n-  it('should create failure for detected two-way data binding assignment', () => {\n-    writeFile('index.ts', `\n-      import {Component} from '@angular/core';\n-\n-      @Component({template: '<span *ngFor=\"let i of options\" [(a)]=\"i\"></span>'})\n-      export class MyComp {}\n-    `);\n-\n-    const linter = runTSLint();\n-    const failures = linter.getResult().failures;\n-\n-    expect(failures.length).toBe(1);\n-    expect(failures[0].getFileName()).toContain('index.ts');\n-    expect(failures[0].getStartPosition().getLineAndCharacter()).toEqual({line: 3, character: 68});\n-    expect(failures[0].getEndPosition().getLineAndCharacter()).toEqual({line: 3, character: 69});\n-    expect(failures[0].getFailure()).toMatch(/^Found assignment to template variable./);\n-  });\n-\n-  it('should create failure with correct offsets for external templates', () => {\n-    writeFile('index.ts', `\n-      import {Component} from '@angular/core';\n-\n-      @Component({templateUrl: './my-tmpl.html'})\n-      export class MyComp {}\n-    `);\n-\n-    writeFile(`my-tmpl.html`, `\n-      <span *ngFor=\"let option of options\" [(a)]=\"option\"></span>\n-    `);\n-\n-    const linter = runTSLint();\n-    const failures = linter.getResult().failures;\n-\n-    expect(failures.length).toBe(1);\n-    expect(failures[0].getFileName()).toContain('my-tmpl.html');\n-    expect(failures[0].getStartPosition().getLineAndCharacter()).toEqual({line: 1, character: 50});\n-    expect(failures[0].getEndPosition().getLineAndCharacter()).toEqual({line: 1, character: 56});\n-    expect(failures[0].getFailure()).toMatch(/^Found assignment to template variable./);\n-  });\n-\n-  it('should create failure for template variable assignment within output', () => {\n-    writeFile('index.ts', `\n-      import {Component} from '@angular/core';\n-\n-      @Component({templateUrl: './my-tmpl.html'})\n-      export class MyComp {}\n-    `);\n-\n-    writeFile(`my-tmpl.html`, `\n-      <!-- Comment -->\n-      <span *ngFor=\"let option of options\" (click)=\"option = true\"></span>\n-    `);\n-\n-    const linter = runTSLint();\n-    const failures = linter.getResult().failures;\n-\n-    expect(failures.length).toBe(1);\n-    expect(failures[0].getFileName()).toContain('my-tmpl.html');\n-    expect(failures[0].getStartPosition().getLineAndCharacter()).toEqual({line: 2, character: 52});\n-    expect(failures[0].getEndPosition().getLineAndCharacter()).toEqual({line: 2, character: 65});\n-    expect(failures[0].getFailure()).toMatch(/^Found assignment to template variable./);\n-  });\n-});"
        },
        {
            "sha": "700e291983a2ccb77b78aaa6abc50a9e7d365324",
            "filename": "packages/core/schematics/test/google3/relative_link_resolution_default_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 202,
            "changes": 202,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Frelative_link_resolution_default_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Frelative_link_resolution_default_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Frelative_link_resolution_default_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,202 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {readFileSync, writeFileSync} from 'fs';\n-import {dirname, join} from 'path';\n-import * as shx from 'shelljs';\n-import {Configuration, Linter} from 'tslint';\n-\n-describe('Google3 relativeLinkResolution TSLint rule', () => {\n-  const rulesDirectory =\n-      dirname(require.resolve('../../migrations/google3/relativeLinkResolutionDefaultRule'));\n-\n-  let tmpDir: string;\n-\n-  beforeEach(() => {\n-    tmpDir = join(process.env['TEST_TMPDIR']!, 'google3-test');\n-    shx.mkdir('-p', tmpDir);\n-    writeFile('tsconfig.json', JSON.stringify({compilerOptions: {module: 'es2015'}}));\n-  });\n-\n-  afterEach(() => shx.rm('-r', tmpDir));\n-\n-  function runTSLint(fix: boolean) {\n-    const program = Linter.createProgram(join(tmpDir, 'tsconfig.json'));\n-    const linter = new Linter({fix, rulesDirectory: [rulesDirectory]}, program);\n-    const config = Configuration.parseConfigFile({\n-      rules: {'relative-link-resolution-default': true},\n-    });\n-\n-    program.getRootFileNames().forEach(fileName => {\n-      linter.lint(fileName, program.getSourceFile(fileName)!.getFullText(), config);\n-    });\n-\n-    return linter;\n-  }\n-\n-  function writeFile(fileName: string, content: string) {\n-    writeFileSync(join(tmpDir, fileName), content);\n-  }\n-\n-  function getFile(fileName: string) {\n-    return readFileSync(join(tmpDir, fileName), 'utf8');\n-  }\n-\n-  it('should flag forRoot with no options', () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([]),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-    `);\n-\n-    const linter = runTSLint(false);\n-    const failures = linter.getResult().failures.map(failure => failure.getFailure());\n-\n-    expect(failures.length).toBe(1);\n-    expect(failures[0])\n-        .toBe(\n-            'The relativeLinkResolution default is changing from `legacy` to `corrected`. To keep' +\n-            ' behavior consistent when the change is merged, specify `legacy` rather than using the default.');\n-  });\n-\n-  it('should migrate forRoot with no options', () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([]),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts'))\n-        .toContain(`RouterModule.forRoot([], { relativeLinkResolution: 'legacy' })`);\n-  });\n-\n-  it('should migrate options without relativeLinkResolution', () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([], {useHash: true}),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts'))\n-        .toContain(`RouterModule.forRoot([], { useHash: true, relativeLinkResolution: 'legacy' })`);\n-  });\n-\n-  it('should not migrate options containing relativeLinkResolution', () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([], {relativeLinkResolution: 'corrected'}),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts'))\n-        .toContain(`RouterModule.forRoot([], {relativeLinkResolution: 'corrected'})`);\n-  });\n-\n-  it('should migrate when options is a variable with AsExpression', () => {\n-    writeFile('/index.ts', `\n-        import { ExtraOptions } from '@angular/router';\n-        const options = {useHash: true} as ExtraOptions;\n-      `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts'))\n-        .toContain(\n-            `const options = { useHash: true, relativeLinkResolution: 'legacy' } as ExtraOptions;`);\n-  });\n-\n-  it('should migrate when options is a variable', () => {\n-    writeFile('/index.ts', `\n-        import { ExtraOptions } from '@angular/router';\n-        const options: ExtraOptions = {useHash: true};\n-      `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts'))\n-        .toContain(\n-            `const options: ExtraOptions = { useHash: true, relativeLinkResolution: 'legacy' };`);\n-  });\n-\n-  it('should migrate when options is a variable with no type', () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { ExtraOptions, RouterModule } from '@angular/router';\n-\n-        const options = {useHash: true};\n-\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([], options),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts'))\n-        .toContain(`const options = { useHash: true, relativeLinkResolution: 'legacy' };`);\n-    expect(getFile('/index.ts')).toContain(`RouterModule.forRoot([], options)`);\n-  });\n-\n-  it('should migrate when aliased options is a variable', () => {\n-    writeFile('/index.ts', `\n-        import { ExtraOptions as RouterExtraOptions } from '@angular/router';\n-        const options: RouterExtraOptions = {useHash: true};\n-      `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts'))\n-        .toContain(\n-            `const options: RouterExtraOptions = { useHash: true, relativeLinkResolution: 'legacy' };`);\n-  });\n-\n-  it('should migrate aliased RouterModule.forRoot', () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule as AngularRouterModule} from '@angular/router';\n-        @NgModule({\n-          imports: [\n-            AngularRouterModule.forRoot([]),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts'))\n-        .toContain(`AngularRouterModule.forRoot([], { relativeLinkResolution: 'legacy' }),`);\n-  });\n-});"
        },
        {
            "sha": "c71620cf5f415cee2da35a86685e9c547dc596d9",
            "filename": "packages/core/schematics/test/google3/renderer_to_renderer2_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 435,
            "changes": 435,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Frenderer_to_renderer2_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Frenderer_to_renderer2_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Frenderer_to_renderer2_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,435 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {readFileSync, writeFileSync} from 'fs';\n-import {dirname, join} from 'path';\n-import * as shx from 'shelljs';\n-import {Configuration, Linter} from 'tslint';\n-\n-describe('Google3 Renderer to Renderer2 TSLint rule', () => {\n-  const rulesDirectory =\n-      dirname(require.resolve('../../migrations/google3/rendererToRenderer2Rule'));\n-\n-  let tmpDir: string;\n-\n-  beforeEach(() => {\n-    tmpDir = join(process.env['TEST_TMPDIR']!, 'google3-test');\n-    shx.mkdir('-p', tmpDir);\n-\n-    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n-    writeFile('angular.d.ts', `\n-      export declare abstract class Renderer {}\n-      export declare function forwardRef(fn: () => any): any {}\n-    `);\n-\n-    writeFile('tsconfig.json', JSON.stringify({\n-      compilerOptions: {\n-        module: 'es2015',\n-        baseUrl: './',\n-        paths: {\n-          '@angular/core': ['angular.d.ts'],\n-        }\n-      },\n-    }));\n-  });\n-\n-  afterEach(() => shx.rm('-r', tmpDir));\n-\n-  function runTSLint(fix: boolean) {\n-    const program = Linter.createProgram(join(tmpDir, 'tsconfig.json'));\n-    const linter = new Linter({fix, rulesDirectory: [rulesDirectory]}, program);\n-    const config = Configuration.parseConfigFile({rules: {'renderer-to-renderer2': true}});\n-\n-    program.getRootFileNames().forEach(fileName => {\n-      linter.lint(fileName, program.getSourceFile(fileName)!.getFullText(), config);\n-    });\n-\n-    return linter;\n-  }\n-\n-  function writeFile(fileName: string, content: string) {\n-    writeFileSync(join(tmpDir, fileName), content);\n-  }\n-\n-  function getFile(fileName: string) {\n-    return readFileSync(join(tmpDir, fileName), 'utf8');\n-  }\n-\n-  it('should flag Renderer imports and typed nodes', () => {\n-    writeFile('/index.ts', `\n-        import { Renderer, Component } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          public renderer: Renderer;\n-\n-          constructor(renderer: Renderer) {\n-            this.renderer = renderer;\n-          }\n-        }\n-      `);\n-\n-    const linter = runTSLint(false);\n-    const failures = linter.getResult().failures.map(failure => failure.getFailure());\n-\n-    expect(failures.length).toBe(3);\n-    expect(failures[0]).toMatch(/Imports of deprecated Renderer are not allowed/);\n-    expect(failures[1]).toMatch(/References to deprecated Renderer are not allowed/);\n-    expect(failures[2]).toMatch(/References to deprecated Renderer are not allowed/);\n-  });\n-\n-  it('should change Renderer imports and typed nodes to Renderer2', () => {\n-    writeFile('/index.ts', `\n-        import { Renderer, Component } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          public renderer: Renderer;\n-\n-          constructor(renderer: Renderer) {\n-            this.renderer = renderer;\n-          }\n-        }\n-      `);\n-\n-    runTSLint(true);\n-    const content = getFile('index.ts');\n-\n-    expect(content).toContain(`import { Component, Renderer2 } from '@angular/core';`);\n-    expect(content).toContain('public renderer: Renderer2;');\n-    expect(content).toContain('(renderer: Renderer2)');\n-  });\n-\n-  it('should not change Renderer imports if Renderer2 is already imported', () => {\n-    writeFile('/index.ts', `\n-        import { Renderer, Component, Renderer2 } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          public renderer: Renderer;\n-\n-          constructor(renderer: Renderer) {\n-            this.renderer = renderer;\n-          }\n-        }\n-      `);\n-\n-    runTSLint(true);\n-    const content = getFile('index.ts');\n-\n-    expect(content).toContain(`import { Renderer, Component, Renderer2 } from '@angular/core';`);\n-  });\n-\n-  it('should change Renderer inside single-line forwardRefs to Renderer2', () => {\n-    writeFile('/index.ts', `\n-      import { Renderer, Component, forwardRef, Inject } from '@angular/core';\n-\n-      @Component({template: ''})\n-      export class MyComp {\n-        constructor(@Inject(forwardRef(() => Renderer)) private _renderer: Renderer) {}\n-      }\n-    `);\n-\n-    runTSLint(true);\n-    const content = getFile('index.ts');\n-\n-    expect(content).toContain(\n-        `constructor(@Inject(forwardRef(() => Renderer2)) private _renderer: Renderer2) {}`);\n-  });\n-\n-  it('should change Renderer inside multi-line forwardRefs to Renderer2', () => {\n-    writeFile('/index.ts', `\n-      import { Renderer, Component, forwardRef, Inject } from '@angular/core';\n-\n-      @Component({template: ''})\n-      export class MyComp {\n-        constructor(@Inject(forwardRef(() => { return Renderer; })) private _renderer: Renderer) {}\n-      }\n-    `);\n-\n-    runTSLint(true);\n-    const content = getFile('index.ts');\n-\n-    expect(content).toContain(\n-        `constructor(@Inject(forwardRef(() => { return Renderer2; })) private _renderer: Renderer2) {}`);\n-  });\n-\n-  it('should flag something that was cast to Renderer', () => {\n-    writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          setColor(maybeRenderer: any, element: ElementRef) {\n-            const renderer = maybeRenderer as Renderer;\n-            renderer.setElementStyle(element.nativeElement, 'color', 'red');\n-          }\n-        }\n-      `);\n-\n-    const linter = runTSLint(false);\n-    const failures = linter.getResult().failures.map(failure => failure.getFailure());\n-\n-    expect(failures.length).toBe(3);\n-    expect(failures[0]).toMatch(/Imports of deprecated Renderer are not allowed/);\n-    expect(failures[1]).toMatch(/References to deprecated Renderer are not allowed/);\n-    expect(failures[2]).toMatch(/Calls to Renderer methods are not allowed/);\n-  });\n-\n-  it('should change the type of something that was cast to Renderer', () => {\n-    writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          setColor(maybeRenderer: any, element: ElementRef) {\n-            const renderer = maybeRenderer as Renderer;\n-            renderer.setElementStyle(element.nativeElement, 'color', 'red');\n-          }\n-        }\n-      `);\n-\n-    runTSLint(true);\n-    const content = getFile('index.ts');\n-\n-    expect(content).toContain(`const renderer = maybeRenderer as Renderer2;`);\n-    expect(content).toContain(`renderer.setStyle(element.nativeElement, 'color', 'red');`);\n-  });\n-\n-  it('should be able to insert helper functions', () => {\n-    writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(renderer: Renderer, element: ElementRef) {\n-            const el = renderer.createElement(element.nativeElement, 'div');\n-            renderer.setElementAttribute(el, 'title', 'hello');\n-            renderer.projectNodes(element.nativeElement, [el]);\n-          }\n-        }\n-      `);\n-\n-    runTSLint(true);\n-    const content = getFile('index.ts');\n-\n-    expect(content).toContain(`function __ngRendererCreateElementHelper(`);\n-    expect(content).toContain(`function __ngRendererSetElementAttributeHelper(`);\n-    expect(content).toContain(`function __ngRendererProjectNodesHelper(`);\n-  });\n-\n-  it('should only insert each helper only once per file', () => {\n-    writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(renderer: Renderer, element: ElementRef) {\n-            const el = renderer.createElement(element.nativeElement, 'div');\n-            renderer.setElementAttribute(el, 'title', 'hello');\n-\n-            const el1 = renderer.createElement(element.nativeElement, 'div');\n-            renderer.setElementAttribute(el2, 'title', 'hello');\n-\n-            const el2 = renderer.createElement(element.nativeElement, 'div');\n-            renderer.setElementAttribute(el2, 'title', 'hello');\n-          }\n-        }\n-      `);\n-\n-    runTSLint(true);\n-    const content = getFile('index.ts');\n-\n-    expect(content.match(/function __ngRendererCreateElementHelper\\(/g)!.length).toBe(1);\n-    expect(content.match(/function __ngRendererSetElementAttributeHelper\\(/g)!.length).toBe(1);\n-  });\n-\n-  it('should insert helpers after the user\\'s code', () => {\n-    writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(renderer: Renderer, element: ElementRef) {\n-            const el = renderer.createElement(element.nativeElement, 'div');\n-            renderer.setElementAttribute(el, 'title', 'hello');\n-          }\n-        }\n-\n-        //---\n-      `);\n-\n-    runTSLint(true);\n-    const content = getFile('index.ts');\n-    const [contentBeforeSeparator, contentAfterSeparator] = content.split('//---');\n-\n-    expect(contentBeforeSeparator).not.toContain('function __ngRendererCreateElementHelper(');\n-    expect(contentAfterSeparator).toContain('function __ngRendererCreateElementHelper(');\n-  });\n-\n-  // Note that this is intended primarily as a sanity test. All of the replacement logic is the\n-  // same between the lint rule and the CLI migration so there's not much value in repeating and\n-  // maintaining the same tests twice. The migration's tests are more exhaustive.\n-  it('should flag calls to Renderer methods', () => {\n-    writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _renderer: Renderer, private _element: ElementRef) {\n-            const span = _renderer.createElement(_element.nativeElement, 'span');\n-            const greeting = _renderer.createText(_element.nativeElement, 'hello');\n-            const color = 'red';\n-\n-            _renderer.setElementProperty(_element.nativeElement, 'disabled', true);\n-            _renderer.listenGlobal('window', 'resize', () => console.log('resized'));\n-            _renderer.setElementAttribute(_element.nativeElement, 'title', 'hello');\n-            _renderer.createViewRoot(_element.nativeElement);\n-            _renderer.animate(_element.nativeElement);\n-            _renderer.detachView([]);\n-            _renderer.destroyView(_element.nativeElement, []);\n-            _renderer.invokeElementMethod(_element.nativeElement, 'focus', []);\n-            _renderer.setElementStyle(_element.nativeElement, 'color', color);\n-            _renderer.setText(_element.nativeElement.querySelector('span'), 'Hello');\n-          }\n-\n-          getRootElement() {\n-            return this._renderer.selectRootElement(this._element.nativeElement, {});\n-          }\n-\n-          toggleClass(className: string, shouldAdd: boolean) {\n-            this._renderer.setElementClass(this._element.nativeElement, className, shouldAdd);\n-          }\n-\n-          setInfo() {\n-            this._renderer.setBindingDebugInfo(this._element.nativeElement, 'prop', 'value');\n-          }\n-\n-          createAndAppendAnchor() {\n-            return this._renderer.createTemplateAnchor(this._element.nativeElement);\n-          }\n-\n-          attachViewAfter(rootNodes) {\n-            this._renderer.attachViewAfter(this._element.nativeElement, rootNodes);\n-          }\n-\n-          projectNodes(nodesToProject: Node[]) {\n-            this._renderer.projectNodes(this._element.nativeElement, nodesToProject);\n-          }\n-        }\n-      `);\n-\n-    const linter = runTSLint(false);\n-    const failures = linter.getResult().failures.map(failure => failure.getFailure());\n-\n-    // One failure for the import, one for the constructor param, one at the end that is used as\n-    // an anchor for inserting helper functions and the rest are for method calls.\n-    expect(failures.length).toBe(21);\n-    expect(failures[0]).toMatch(/Imports of deprecated Renderer are not allowed/);\n-    expect(failures[1]).toMatch(/References to deprecated Renderer are not allowed/);\n-    expect(failures[failures.length - 1]).toMatch(/File should contain Renderer helper functions/);\n-    expect(failures.slice(2, -1).every(message => {\n-      return /Calls to Renderer methods are not allowed/.test(message);\n-    })).toBe(true);\n-  });\n-\n-  // Note that this is intended primarily as a sanity test. All of the replacement logic is the\n-  // same between the lint rule and the CLI migration so there's not much value in repeating and\n-  // maintaining the same tests twice. The migration's tests are more exhaustive.\n-  it('should fix calls to Renderer methods', () => {\n-    writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _renderer: Renderer, private _element: ElementRef) {\n-            const span = _renderer.createElement(_element.nativeElement, 'span');\n-            const greeting = _renderer.createText(_element.nativeElement, 'hello');\n-            const color = 'red';\n-\n-            _renderer.setElementProperty(_element.nativeElement, 'disabled', true);\n-            _renderer.listenGlobal('window', 'resize', () => console.log('resized'));\n-            _renderer.setElementAttribute(_element.nativeElement, 'title', 'hello');\n-            _renderer.animate(_element.nativeElement);\n-            _renderer.detachView([]);\n-            _renderer.destroyView(_element.nativeElement, []);\n-            _renderer.invokeElementMethod(_element.nativeElement, 'focus', []);\n-            _renderer.setElementStyle(_element.nativeElement, 'color', color);\n-            _renderer.setText(_element.nativeElement.querySelector('span'), 'Hello');\n-          }\n-\n-          createRoot() {\n-            return this._renderer.createViewRoot(this._element.nativeElement);\n-          }\n-\n-          getRootElement() {\n-            return this._renderer.selectRootElement(this._element.nativeElement, {});\n-          }\n-\n-          toggleClass(className: string, shouldAdd: boolean) {\n-            this._renderer.setElementClass(this._element.nativeElement, className, shouldAdd);\n-          }\n-\n-          setInfo() {\n-            this._renderer.setBindingDebugInfo(this._element.nativeElement, 'prop', 'value');\n-          }\n-\n-          createAndAppendAnchor() {\n-            return this._renderer.createTemplateAnchor(this._element.nativeElement);\n-          }\n-\n-          attachViewAfter(rootNodes: Node[]) {\n-            this._renderer.attachViewAfter(this._element.nativeElement, rootNodes);\n-          }\n-\n-          projectNodes(nodesToProject: Node[]) {\n-            this._renderer.projectNodes(this._element.nativeElement, nodesToProject);\n-          }\n-        }\n-      `);\n-\n-    runTSLint(true);\n-    const content = getFile('index.ts');\n-\n-    expect(content).toContain(\n-        `const span = __ngRendererCreateElementHelper(_renderer, _element.nativeElement, 'span');`);\n-    expect(content).toContain(\n-        `const greeting = __ngRendererCreateTextHelper(_renderer, _element.nativeElement, 'hello');`);\n-    expect(content).toContain(`_renderer.setProperty(_element.nativeElement, 'disabled', true);`);\n-    expect(content).toContain(\n-        `_renderer.listen('window', 'resize', () => console.log('resized'));`);\n-    expect(content).toContain(\n-        `__ngRendererSetElementAttributeHelper(_renderer, _element.nativeElement, 'title', 'hello');`);\n-    expect(content).toContain('__ngRendererAnimateHelper();');\n-    expect(content).toContain('__ngRendererDetachViewHelper(_renderer, []);');\n-    expect(content).toContain('__ngRendererDestroyViewHelper(_renderer, []);');\n-    expect(content).toContain(`_element.nativeElement.focus()`);\n-    expect(content).toContain(\n-        `color == null ? _renderer.removeStyle(_element.nativeElement, 'color') : ` +\n-        `_renderer.setStyle(_element.nativeElement, 'color', color);`);\n-    expect(content).toContain(\n-        `_renderer.setValue(_element.nativeElement.querySelector('span'), 'Hello')`);\n-    expect(content).toContain(\n-        `return this._renderer.selectRootElement(this._element.nativeElement);`);\n-    expect(content).toContain(\n-        `shouldAdd ? this._renderer.addClass(this._element.nativeElement, className) : ` +\n-        `this._renderer.removeClass(this._element.nativeElement, className);`);\n-    expect(content).toContain(\n-        `return __ngRendererCreateTemplateAnchorHelper(this._renderer, this._element.nativeElement);`);\n-    expect(content).toContain(\n-        `__ngRendererAttachViewAfterHelper(this._renderer, this._element.nativeElement, rootNodes);`);\n-    expect(content).toContain(\n-        `__ngRendererProjectNodesHelper(this._renderer, this._element.nativeElement, nodesToProject);`);\n-\n-    // Expect the `createRoot` only to return `this._element.nativeElement`.\n-    expect(content).toMatch(/createRoot\\(\\) \\{\\s+return this\\._element\\.nativeElement;\\s+\\}/);\n-\n-    // Expect the `setInfo` method to only contain whitespace.\n-    expect(content).toMatch(/setInfo\\(\\) \\{\\s+\\}/);\n-  });\n-});"
        },
        {
            "sha": "04afcf0f30731ecef18c9ad09d47a2d53cc0f4a8",
            "filename": "packages/core/schematics/test/google3/undecorated_classes_with_decorated_fields_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 299,
            "changes": 299,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fundecorated_classes_with_decorated_fields_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fundecorated_classes_with_decorated_fields_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fundecorated_classes_with_decorated_fields_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,299 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {readFileSync, writeFileSync} from 'fs';\n-import {dirname, join} from 'path';\n-import * as shx from 'shelljs';\n-import {Configuration, Linter} from 'tslint';\n-\n-describe('Google3 undecorated classes with decorated fields TSLint rule', () => {\n-  const rulesDirectory = dirname(\n-      require.resolve('../../migrations/google3/undecoratedClassesWithDecoratedFieldsRule'));\n-\n-  let tmpDir: string;\n-\n-  beforeEach(() => {\n-    tmpDir = join(process.env['TEST_TMPDIR']!, 'google3-test');\n-    shx.mkdir('-p', tmpDir);\n-    writeFile('tsconfig.json', JSON.stringify({compilerOptions: {module: 'es2015'}}));\n-  });\n-\n-  afterEach(() => shx.rm('-r', tmpDir));\n-\n-  function runTSLint(fix: boolean) {\n-    const program = Linter.createProgram(join(tmpDir, 'tsconfig.json'));\n-    const linter = new Linter({fix, rulesDirectory: [rulesDirectory]}, program);\n-    const config = Configuration.parseConfigFile({\n-      rules: {'undecorated-classes-with-decorated-fields': true},\n-    });\n-\n-    program.getRootFileNames().forEach(fileName => {\n-      linter.lint(fileName, program.getSourceFile(fileName)!.getFullText(), config);\n-    });\n-\n-    return linter;\n-  }\n-\n-  function writeFile(fileName: string, content: string) {\n-    writeFileSync(join(tmpDir, fileName), content);\n-  }\n-\n-  function getFile(fileName: string) {\n-    return readFileSync(join(tmpDir, fileName), 'utf8');\n-  }\n-\n-  it('should flag undecorated classes with decorated fields', () => {\n-    writeFile('/index.ts', `\n-      import { Input, Directive } from '@angular/core';\n-\n-      @Directive()\n-      export class ValidClass {\n-        @Input() isActive: boolean;\n-      }\n-\n-      export class InvalidClass {\n-        @Input() isActive: boolean;\n-      }\n-    `);\n-\n-    const linter = runTSLint(false);\n-    const failures = linter.getResult().failures.map(failure => failure.getFailure());\n-\n-    expect(failures.length).toBe(1);\n-    expect(failures[0])\n-        .toBe('Class needs to be decorated with \"@Directive()\" because it uses Angular features.');\n-  });\n-\n-  it(`should add an import for Directive if there isn't one already`, () => {\n-    writeFile('/index.ts', `\n-      import { Input } from '@angular/core';\n-\n-      export class Base {\n-        @Input() isActive: boolean;\n-      }\n-    `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts')).toContain(`import { Input, Directive } from '@angular/core';`);\n-  });\n-\n-  it('should not change the imports if there is an import for Directive already', () => {\n-    writeFile('/index.ts', `\n-      import { Directive, Input } from '@angular/core';\n-\n-      export class Base {\n-        @Input() isActive: boolean;\n-      }\n-\n-      @Directive()\n-      export class Child extends Base {\n-      }\n-    `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts')).toContain(`import { Directive, Input } from '@angular/core';`);\n-  });\n-\n-  it('should not generate conflicting imports there is a different `Directive` symbol',\n-     async () => {\n-       writeFile('/index.ts', `\n-      import { HostBinding } from '@angular/core';\n-\n-      export class Directive {\n-        // Simulates a scenario where a library defines a class named \"Directive\".\n-        // We don't want to generate a conflicting import.\n-      }\n-\n-      export class MyLibrarySharedBaseClass {\n-        @HostBinding('class.active') isActive: boolean;\n-      }\n-    `);\n-\n-       runTSLint(true);\n-       const fileContent = getFile('/index.ts');\n-       expect(fileContent)\n-           .toContain(`import { HostBinding, Directive as Directive_1 } from '@angular/core';`);\n-       expect(fileContent).toMatch(/@Directive_1\\(\\)\\s+export class MyLibrarySharedBaseClass/);\n-     });\n-\n-  it('should add @Directive to undecorated classes that have @Input', () => {\n-    writeFile('/index.ts', `\n-      import { Input } from '@angular/core';\n-\n-      export class Base {\n-        @Input() isActive: boolean;\n-      }\n-    `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts')).toContain(`@Directive()\\nexport class Base {`);\n-  });\n-\n-  it('should not change decorated classes', () => {\n-    writeFile('/index.ts', `\n-      import { Input, Component, Directive, Pipe, Injectable } from '@angular/core';\n-\n-      @Component({})\n-      export class MyComp {\n-        @Input() isActive: boolean;\n-      }\n-      \n-      @Directive({selector: 'dir'})\n-      export class MyDir {\n-        @Input() isActive: boolean;\n-      }\n-\n-      @Injectable()\n-      export class MyService {\n-        ngOnDestroy() {}\n-      }\n-      \n-      @Pipe({name: 'my-pipe'})\n-      export class MyPipe {\n-        ngOnDestroy() {}\n-      }\n-    `);\n-\n-    runTSLint(true);\n-    const content = getFile('/index.ts');\n-    expect(content).toMatch(/@Component\\({}\\)\\s+export class MyComp {/);\n-    expect(content).toMatch(/@Directive\\({selector: 'dir'}\\)\\s+export class MyDir {/);\n-    expect(content).toMatch(/@Injectable\\(\\)\\s+export class MyService {/);\n-    expect(content).toMatch(/@Pipe\\({name: 'my-pipe'}\\)\\s+export class MyPipe {/);\n-    expect(content).not.toContain('TODO');\n-  });\n-\n-  it('should add @Directive to undecorated classes that have @Output', () => {\n-    writeFile('/index.ts', `\n-      import { Output, EventEmitter } from '@angular/core';\n-\n-      export class Base {\n-        @Output() clicked = new EventEmitter<void>();\n-      }\n-    `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts')).toContain(`@Directive()\\nexport class Base {`);\n-  });\n-\n-  it('should add @Directive to undecorated classes that have a host binding', () => {\n-    writeFile('/index.ts', `\n-      import { HostBinding } from '@angular/core';\n-\n-      export class Base {\n-        @HostBinding('attr.id')\n-        get id() {\n-          return 'id-' + Date.now();\n-        }\n-      }\n-    `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts')).toContain(`@Directive()\\nexport class Base {`);\n-  });\n-\n-  it('should add @Directive to undecorated classes that have a host listener', () => {\n-    writeFile('/index.ts', `\n-      import { HostListener } from '@angular/core';\n-\n-      export class Base {\n-        @HostListener('keydown')\n-        handleKeydown() {\n-          console.log('Key has been pressed');\n-        }\n-      }\n-    `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts')).toContain(`@Directive()\\nexport class Base {`);\n-  });\n-\n-  it('should add @Directive to undecorated classes that have a ViewChild query', () => {\n-    writeFile('/index.ts', `\n-      import { ViewChild, ElementRef } from '@angular/core';\n-\n-      export class Base {\n-        @ViewChild('button') button: ElementRef<HTMLElement>;\n-      }\n-    `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts')).toContain(`@Directive()\\nexport class Base {`);\n-  });\n-\n-  it('should add @Directive to undecorated classes that have a ViewChildren query', () => {\n-    writeFile('/index.ts', `\n-      import { ViewChildren, ElementRef } from '@angular/core';\n-\n-      export class Base {\n-        @ViewChildren('button') button: ElementRef<HTMLElement>;\n-      }\n-    `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts')).toContain(`@Directive()\\nexport class Base {`);\n-  });\n-\n-  it('should add @Directive to undecorated classes that have a ContentChild query', () => {\n-    writeFile('/index.ts', `\n-      import { ContentChild, ElementRef } from '@angular/core';\n-\n-      export class Base {\n-        @ContentChild('button') button: ElementRef<HTMLElement>;\n-      }\n-    `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts')).toContain(`@Directive()\\nexport class Base {`);\n-  });\n-\n-  it('should add @Directive to undecorated classes that have a ContentChildren query', () => {\n-    writeFile('/index.ts', `\n-      import { ContentChildren, ElementRef } from '@angular/core';\n-\n-      export class Base {\n-        @ContentChildren('button') button: ElementRef<HTMLElement>;\n-      }\n-    `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts')).toContain(`@Directive()\\nexport class Base {`);\n-  });\n-\n-  it('should add @Directive to undecorated derived classes of a migrated class', async () => {\n-    writeFile('/index.ts', `\n-      import { Input, Directive, NgModule } from '@angular/core';\n-\n-      export class Base {\n-        @Input() isActive: boolean;\n-      }\n-\n-      export class DerivedA extends Base {}\n-      export class DerivedB extends DerivedA {}\n-      export class DerivedC extends DerivedB {}\n-\n-      @Directive({selector: 'my-comp'})\n-      export class MyComp extends DerivedC {}\n-\n-      export class MyCompWrapped extends MyComp {}\n-\n-      @NgModule({declarations: [MyComp, MyCompWrapped]})\n-      export class AppModule {}\n-    `);\n-\n-    runTSLint(true);\n-    const fileContent = getFile('/index.ts');\n-    expect(fileContent).toContain(`import { Input, Directive, NgModule } from '@angular/core';`);\n-    expect(fileContent).toMatch(/@Directive\\(\\)\\s+export class Base/);\n-    expect(fileContent).toMatch(/@Directive\\(\\)\\s+export class DerivedA/);\n-    expect(fileContent).toMatch(/@Directive\\(\\)\\s+export class DerivedB/);\n-    expect(fileContent).toMatch(/@Directive\\(\\)\\s+export class DerivedC/);\n-    expect(fileContent).toMatch(/}\\s+@Directive\\(\\{selector: 'my-comp'}\\)\\s+export class MyComp/);\n-    expect(fileContent).toMatch(/}\\s+export class MyCompWrapped/);\n-  });\n-});"
        },
        {
            "sha": "d68f202988402b3299c716975a28f07434a34223",
            "filename": "packages/core/schematics/test/google3/wait_for_async_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 181,
            "changes": 181,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fwait_for_async_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fwait_for_async_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fgoogle3%2Fwait_for_async_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,181 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {readFileSync, writeFileSync} from 'fs';\n-import {dirname, join} from 'path';\n-import * as shx from 'shelljs';\n-import {Configuration, Linter} from 'tslint';\n-\n-describe('Google3 waitForAsync TSLint rule', () => {\n-  const rulesDirectory = dirname(require.resolve('../../migrations/google3/waitForAsyncRule'));\n-\n-  let tmpDir: string;\n-\n-  beforeEach(() => {\n-    tmpDir = join(process.env['TEST_TMPDIR']!, 'google3-test');\n-    shx.mkdir('-p', tmpDir);\n-\n-    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n-    writeFile('testing.d.ts', `\n-      export declare function async(fn: Function): any;\n-    `);\n-\n-    writeFile('tsconfig.json', JSON.stringify({\n-      compilerOptions: {\n-        module: 'es2015',\n-        baseUrl: './',\n-        paths: {\n-          '@angular/core/testing': ['testing.d.ts'],\n-        }\n-      },\n-    }));\n-  });\n-\n-  afterEach(() => shx.rm('-r', tmpDir));\n-\n-  function runTSLint(fix: boolean) {\n-    const program = Linter.createProgram(join(tmpDir, 'tsconfig.json'));\n-    const linter = new Linter({fix, rulesDirectory: [rulesDirectory]}, program);\n-    const config = Configuration.parseConfigFile({rules: {'wait-for-async': true}});\n-\n-    program.getRootFileNames().forEach(fileName => {\n-      linter.lint(fileName, program.getSourceFile(fileName)!.getFullText(), config);\n-    });\n-\n-    return linter;\n-  }\n-\n-  function writeFile(fileName: string, content: string) {\n-    writeFileSync(join(tmpDir, fileName), content);\n-  }\n-\n-  function getFile(fileName: string) {\n-    return readFileSync(join(tmpDir, fileName), 'utf8');\n-  }\n-\n-  it('should flag async imports and usages', () => {\n-    writeFile('/index.ts', `\n-      import { async, inject } from '@angular/core/testing';\n-\n-      it('should work', async(() => {\n-        expect(inject('foo')).toBe('foo');\n-      }));\n-\n-      it('should also work', async(() => {\n-        expect(inject('bar')).toBe('bar');\n-      }));\n-    `);\n-\n-    const linter = runTSLint(false);\n-    const failures = linter.getResult().failures.map(failure => failure.getFailure());\n-    expect(failures.length).toBe(3);\n-    expect(failures[0]).toMatch(/Imports of the deprecated async function are not allowed/);\n-    expect(failures[1]).toMatch(/References to the deprecated async function are not allowed/);\n-    expect(failures[2]).toMatch(/References to the deprecated async function are not allowed/);\n-  });\n-\n-  it('should change async imports to waitForAsync', () => {\n-    writeFile('/index.ts', `\n-      import { async, inject } from '@angular/core/testing';\n-\n-      it('should work', async(() => {\n-        expect(inject('foo')).toBe('foo');\n-      }));\n-    `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts'))\n-        .toContain(`import { inject, waitForAsync } from '@angular/core/testing';`);\n-  });\n-\n-  it('should change aliased async imports to waitForAsync', () => {\n-    writeFile('/index.ts', `\n-      import { async as renamedAsync, inject } from '@angular/core/testing';\n-\n-      it('should work', renamedAsync(() => {\n-        expect(inject('foo')).toBe('foo');\n-      }));\n-    `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts'))\n-        .toContain(`import { inject, waitForAsync as renamedAsync } from '@angular/core/testing';`);\n-  });\n-\n-  it('should not change async imports if they are not from @angular/core/testing', () => {\n-    writeFile('/index.ts', `\n-      import { inject } from '@angular/core/testing';\n-      import { async } from './my-test-library';\n-\n-      it('should work', async(() => {\n-        expect(inject('foo')).toBe('foo');\n-      }));\n-    `);\n-\n-    runTSLint(true);\n-    const content = getFile('/index.ts');\n-    expect(content).toContain(`import { inject } from '@angular/core/testing';`);\n-    expect(content).toContain(`import { async } from './my-test-library';`);\n-  });\n-\n-  it('should not change imports if waitForAsync was already imported', () => {\n-    writeFile('/index.ts', `\n-      import { async, inject, waitForAsync } from '@angular/core/testing';\n-\n-      it('should work', async(() => {\n-        expect(inject('foo')).toBe('foo');\n-      }));\n-\n-      it('should also work', waitForAsync(() => {\n-        expect(inject('bar')).toBe('bar');\n-      }));\n-    `);\n-\n-    runTSLint(true);\n-    expect(getFile('/index.ts'))\n-        .toContain(`import { async, inject, waitForAsync } from '@angular/core/testing';`);\n-  });\n-\n-  it('should change calls from `async` to `waitForAsync`', () => {\n-    writeFile('/index.ts', `\n-      import { async, inject } from '@angular/core/testing';\n-\n-      it('should work', async(() => {\n-        expect(inject('foo')).toBe('foo');\n-      }));\n-\n-      it('should also work', async(() => {\n-        expect(inject('bar')).toBe('bar');\n-      }));\n-    `);\n-\n-    runTSLint(true);\n-\n-    const content = getFile('/index.ts');\n-    expect(content).toContain(`import { inject, waitForAsync } from '@angular/core/testing';`);\n-    expect(content).toContain(`it('should work', waitForAsync(() => {`);\n-    expect(content).toContain(`it('should also work', waitForAsync(() => {`);\n-  });\n-\n-  it('should not change aliased calls', () => {\n-    writeFile('/index.ts', `\n-      import { async as renamedAsync, inject } from '@angular/core/testing';\n-\n-      it('should work', renamedAsync(() => {\n-        expect(inject('foo')).toBe('foo');\n-      }));\n-    `);\n-\n-    runTSLint(true);\n-\n-    const content = getFile('/index.ts');\n-    expect(content).toContain(\n-        `import { inject, waitForAsync as renamedAsync } from '@angular/core/testing';`);\n-    expect(content).toContain(`it('should work', renamedAsync(() => {`);\n-  });\n-});"
        },
        {
            "sha": "77d5c930e33a6326435bbe0615585abdfe26c43e",
            "filename": "packages/core/schematics/test/initial_navigation_migration_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 240,
            "changes": 240,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Finitial_navigation_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Finitial_navigation_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Finitial_navigation_migration_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,240 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n-import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n-import {HostTree} from '@angular-devkit/schematics';\n-import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n-import * as shx from 'shelljs';\n-\n-describe('initial navigation migration', () => {\n-  let runner: SchematicTestRunner;\n-  let host: TempScopedNodeJsSyncHost;\n-  let tree: UnitTestTree;\n-  let tmpDirPath: string;\n-  let previousWorkingDir: string;\n-\n-  beforeEach(() => {\n-    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n-    host = new TempScopedNodeJsSyncHost();\n-    tree = new UnitTestTree(new HostTree(host));\n-\n-    writeFile('/tsconfig.json', JSON.stringify({\n-      compilerOptions: {\n-        lib: ['es2015'],\n-      }\n-    }));\n-    writeFile('/angular.json', JSON.stringify({\n-      version: 1,\n-      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n-    }));\n-\n-    previousWorkingDir = shx.pwd();\n-    tmpDirPath = getSystemPath(host.root);\n-\n-    // Switch into the temporary directory path. This allows us to run\n-    // the schematic against our custom unit test tree.\n-    shx.cd(tmpDirPath);\n-  });\n-\n-  afterEach(() => {\n-    shx.cd(previousWorkingDir);\n-    shx.rm('-r', tmpDirPath);\n-  });\n-\n-  it('should migrate legacy_disabled to disabled', async () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([], {initialNavigation: 'legacy_disabled'}),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts')).toContain(`{initialNavigation: 'disabled'}`);\n-  });\n-\n-  it('should migrate false to disabled', async () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([], {initialNavigation: false}),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts')).toContain(`{initialNavigation: 'disabled'}`);\n-  });\n-\n-  it('should migrate legacy_enabled to enabledNonBlocking', async () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([], {initialNavigation: 'legacy_enabled'}),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts')).toContain(`{initialNavigation: 'enabledNonBlocking'}`);\n-  });\n-\n-  it('should migrate true to enabledNonBlocking', async () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([], {initialNavigation: true}),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts')).toContain(`{initialNavigation: 'enabledNonBlocking'}`);\n-  });\n-\n-  it('should migrate nested objects', async () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-\n-        const options = {initialNavigation: 'legacy_enabled'};\n-\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([], {initialNavigation: 'legacy_disabled', ...options}),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts'))\n-        .toContain(`const options = {initialNavigation: 'enabledNonBlocking'};`);\n-    expect(tree.readContent('/index.ts')).toContain(`{initialNavigation: 'disabled', ...options}`);\n-  });\n-\n-  it('should migrate nested objects mixed validity', async () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-\n-        const options = {initialNavigation: 'legacy_enabled'};\n-\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([], {initialNavigation: 'disabled', ...options}),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts'))\n-        .toContain(`const options = {initialNavigation: 'enabledNonBlocking'};`);\n-  });\n-\n-\n-  it('should migrate nested objects opposite order', async () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-\n-        const options = {initialNavigation: 'legacy_enabled'};\n-\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([], {...options, initialNavigation: 'legacy_disabled'}),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts'))\n-        .toContain(`const options = {initialNavigation: 'enabledNonBlocking'};`);\n-    expect(tree.readContent('/index.ts')).toContain(`{...options, initialNavigation: 'disabled'}`);\n-  });\n-\n-  it('should migrate nested objects mixed validity opposite order', async () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-\n-        const options = {initialNavigation: 'legacy_enabled'};\n-\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([], {...options, initialNavigation: 'disabled'}),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts'))\n-        .toContain(`const options = {initialNavigation: 'enabledNonBlocking'};`);\n-    expect(tree.readContent('/index.ts')).toContain(`disabled`);\n-  });\n-\n-  it('should not migrate variable not used in forRoot', async () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-\n-        const options = {initialNavigation: 'legacy_enabled'};\n-\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([]),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts'))\n-        .toContain(`const options = {initialNavigation: 'legacy_enabled'};`);\n-    expect(tree.readContent('/index.ts')).toContain(`RouterModule.forRoot([])`);\n-  });\n-\n-  function writeFile(filePath: string, contents: string) {\n-    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n-  }\n-\n-  function runMigration() {\n-    return runner.runSchematicAsync('migration-v11-router-initial-navigation-options', {}, tree)\n-        .toPromise();\n-  }\n-});"
        },
        {
            "sha": "76719cc014964fffdff07e0f7631aac056b4d0f2",
            "filename": "packages/core/schematics/test/line_mappings_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 29,
            "changes": 29,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fline_mappings_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fline_mappings_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fline_mappings_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,29 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {computeLineStartsMap, getLineAndCharacterFromPosition} from '../utils/line_mappings';\n-\n-describe('line mappings', () => {\n-  it('should properly compute line starts',\n-     () => {\n-       expect(computeLineStartsMap(`\n-      1\n-      2`)).toEqual([0, 1, 9, 16]);\n-     });\n-\n-  it('should properly get line and character from line starts', () => {\n-    const lineStarts = computeLineStartsMap(`\n-      1\n-      2`);\n-\n-    expect(getLineAndCharacterFromPosition(lineStarts, 8)).toEqual({\n-      line: 1,\n-      character: 7,\n-    });\n-  });\n-});"
        },
        {
            "sha": "4624fca7ff34886755f4ca65b78f44546b8a72cc",
            "filename": "packages/core/schematics/test/missing_injectable_migration_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 807,
            "changes": 807,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fmissing_injectable_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fmissing_injectable_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fmissing_injectable_migration_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,807 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n-import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n-import {HostTree} from '@angular-devkit/schematics';\n-import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n-import * as shx from 'shelljs';\n-\n-describe('Missing injectable migration', () => {\n-  let runner: SchematicTestRunner;\n-  let host: TempScopedNodeJsSyncHost;\n-  let tree: UnitTestTree;\n-  let tmpDirPath: string;\n-  let previousWorkingDir: string;\n-  let warnOutput: string[];\n-\n-  beforeEach(() => {\n-    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n-    host = new TempScopedNodeJsSyncHost();\n-    tree = new UnitTestTree(new HostTree(host));\n-\n-    writeFile('/tsconfig.json', JSON.stringify({\n-      compilerOptions: {\n-        experimentalDecorators: true,\n-        lib: ['es2015'],\n-      },\n-    }));\n-    writeFile('/angular.json', JSON.stringify({\n-      version: 1,\n-      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n-    }));\n-\n-    warnOutput = [];\n-    runner.logger.subscribe(logEntry => {\n-      if (logEntry.level === 'warn') {\n-        warnOutput.push(logEntry.message);\n-      }\n-    });\n-\n-    previousWorkingDir = shx.pwd();\n-    tmpDirPath = getSystemPath(host.root);\n-\n-    // Switch into the temporary directory path. This allows us to run\n-    // the schematic against our custom unit test tree.\n-    shx.cd(tmpDirPath);\n-\n-    writeFile('/node_modules/@angular/core/index.d.ts', `\n-      export declare function forwardRef(fn: Function);\n-    `);\n-  });\n-\n-  afterEach(() => {\n-    shx.cd(previousWorkingDir);\n-    shx.rm('-r', tmpDirPath);\n-  });\n-\n-  function writeFile(filePath: string, contents: string) {\n-    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n-  }\n-\n-  function runMigration() {\n-    return runner.runSchematicAsync('migration-v10-missing-injectable', {}, tree).toPromise();\n-  }\n-\n-  describe('NgModule', () => createTests('NgModule', 'providers'));\n-  describe('Directive', () => createTests('Directive', 'providers'));\n-\n-  describe('Component', () => {\n-    createTests('Component', 'providers');\n-    createTests('Component', 'viewProviders');\n-\n-    it('should migrate all providers defined in \"viewProviders\" and \"providers\" in the ' +\n-           'same component',\n-       async () => {\n-         writeFile('/index.ts', `\n-          import {Component} from '@angular/core';\n-\n-          export class MyService {}\n-          export class MySecondService {}\n-\n-          @Component({\n-            providers: [MyService],\n-            viewProviders: [MySecondService],\n-          })\n-          export class TestClass {}\n-        `);\n-\n-         await runMigration();\n-\n-         expect(warnOutput.length).toBe(0);\n-         expect(tree.readContent('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class MyService/);\n-         expect(tree.readContent('/index.ts'))\n-             .toMatch(/@Injectable\\(\\)\\s+export class MySecondService/);\n-         expect(tree.readContent('/index.ts'))\n-             .toContain(`{ Component, Injectable } from '@angular/core`);\n-       });\n-  });\n-\n-  function createTests(\n-      type: 'NgModule'|'Directive'|'Component', propName: 'providers'|'viewProviders') {\n-    it(`should migrate type provider in ${type}`, async () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        export class MyService {}\n-\n-        @${type}({${propName}: [MyService]})\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class MyService/);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`{ ${type}, Injectable } from '@angular/core`);\n-    });\n-\n-    it(`should migrate object literal provider in ${type} to explicit value provider`, async () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        export class MyService {}\n-\n-        @${type}({${propName}: [{provide: MyService}]})\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts')).toMatch(/@angular\\/core';\\s+export class MyService/);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`${propName}: [{ provide: MyService, useValue: undefined }]`);\n-      expect(tree.readContent('/index.ts')).toContain(`{${type}} from '@angular/core`);\n-    });\n-\n-    it(`should migrate object literal provider with forwardRef in ${type}`, async () => {\n-      writeFile('/index.ts', `\n-        import {${type}, forwardRef} from '@angular/core';\n-\n-        @${type}({${propName}: [forwardRef(() => MyService)]})\n-        export class TestClass {}\n-\n-        export class MyService {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class MyService/);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`{ ${type}, forwardRef, Injectable } from '@angular/core`);\n-    });\n-\n-    it(`should not migrate object literal provider with \"useValue\" in ${type}`, async () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        export class MyService {}\n-\n-        @${type}({${propName}: [{provide: MyService, useValue: null }]})\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts')).not.toContain('@Injectable');\n-    });\n-\n-    it(`should not migrate provider with \"useClass\" and \"deps\" in ${type}`, async () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        export class MyService {}\n-\n-        @${type}({${propName}: [{provide: MyService, deps: []}]})\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts')).not.toContain('@Injectable');\n-    });\n-\n-    it(`should not migrate object literal provider with \"useFactory\" in ${type}`, async () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        export class MyService {}\n-\n-        @${type}({${propName}: [{provide: MyService, useFactory: () => null }]})\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts')).not.toContain('@Injectable');\n-    });\n-\n-    it(`should not migrate object literal provider with \"useExisting\" in ${type}`, async () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        export class MyService {}\n-        export class MyToken {}\n-\n-        @${type}({${propName}: [\n-          {provide: MyService: useValue: null},\n-          {provide: MyToken, useExisting: MyService},\n-        ]})\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts')).not.toContain('@Injectable');\n-    });\n-\n-    it(`should migrate object literal provider with \"useClass\" in ${type}`, async () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        export class MyService {}\n-        export class MyToken {}\n-\n-        @${type}({${propName}: [{provide: MyToken, useClass: MyService}]})\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class MyService/);\n-      expect(tree.readContent('/index.ts')).toMatch(/MyService {}\\s+export class MyToken/);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`{ ${type}, Injectable } from '@angular/core`);\n-    });\n-\n-    it(`should not migrate references for providers with \"useExisting\" in ${type}, but migrate ` +\n-           `existing token if declared in other ${type}`,\n-       async () => {\n-         writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        export class MyService {}\n-        export class MyToken {}\n-\n-        @${type}({\n-          ${propName}: [\n-            {provide: MyToken, useExisting: MyService},\n-          ],\n-        })\n-        export class TestClass {}\n-      `);\n-\n-         writeFile('/other.ts', `\n-        import {${type} from '@angular/core';\n-        import {MyService} from './index';\n-\n-        export @${type}({\n-          ${propName}: [{provide: MyService, useClass: MyService}],\n-        })\n-        export class OtherClass {}\n-      `);\n-\n-         await runMigration();\n-\n-         expect(warnOutput.length).toBe(0);\n-         expect(tree.readContent('/index.ts'))\n-             .toMatch(/@angular\\/core';\\s+@Injectable\\(\\)\\s+export class MyService/);\n-         expect(tree.readContent('/index.ts')).toMatch(/MyService {}\\s+export class MyToken/);\n-       });\n-\n-    it('should not migrate provider which is already decorated with @Injectable', async () => {\n-      writeFile('/index.ts', `\n-        import {Injectable, ${type}} from '@angular/core';\n-\n-        @Injectable()\n-        export class MyService {}\n-\n-        @${type}({${propName}: [MyService]})\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts'))\n-          .toMatch(/@angular\\/core';\\s+@Injectable\\(\\)\\s+export class MyService/);\n-    });\n-\n-    it('should not migrate provider which is already decorated with @Directive', async () => {\n-      writeFile('/index.ts', `\n-        import {Directive, ${type}} from '@angular/core';\n-\n-        @Directive()\n-        export class MyService {}\n-\n-        @${type}({${propName}: [MyService]})\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts')).not.toContain('@Injectable');\n-    });\n-\n-    it('should not migrate provider which is already decorated with @Component', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${type}} from '@angular/core';\n-\n-        @Component()\n-        export class MyService {}\n-\n-        @${type}({${propName}: [MyService]})\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts')).not.toContain('@Injectable');\n-    });\n-\n-    it('should not migrate provider which is already decorated with @Pipe', async () => {\n-      writeFile('/index.ts', `\n-        import {Pipe, ${type}} from '@angular/core';\n-\n-        @Pipe()\n-        export class MyService {}\n-\n-        @${type}({${propName}: [MyService]})\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts')).not.toContain('@Injectable');\n-    });\n-\n-    it('should not migrate provider which is already decorated with @NgModule', async () => {\n-      const importedSymbols = type !== 'NgModule' ? ['NgModule', type] : ['NgModule'];\n-      writeFile('/index.ts', `\n-        import {${importedSymbols.join(', ')}} from '@angular/core';\n-\n-        @NgModule()\n-        export class MyOtherModule {}\n-\n-        @${type}({${propName}: [MyOtherModule]})\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts')).not.toContain('@Injectable');\n-    });\n-\n-    it(`should migrate multiple providers in same ${type}`, async () => {\n-      writeFile('/index.ts', `\n-      import {${type}} from '@angular/core';\n-\n-      export class ServiceA {}\n-      export class ServiceB {}\n-\n-      @${type}({${propName}: [ServiceA, ServiceB]})\n-      export class TestClass {}\n-    `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class ServiceA/);\n-      expect(tree.readContent('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class ServiceB/);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`{ ${type}, Injectable } from '@angular/core`);\n-    });\n-\n-    it(`should migrate multiple mixed providers in same ${type}`, async () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        export class ServiceA {}\n-        export class ServiceB {}\n-        export class ServiceC {}\n-\n-        @${type}({\n-          ${propName}: [\n-            ServiceA,\n-            {provide: ServiceB},\n-            {provide: SomeToken, useClass: ServiceC},\n-          ]})\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class ServiceA/);\n-      expect(tree.readContent('/index.ts')).toMatch(/ServiceA {}\\s+export class ServiceB/);\n-      expect(tree.readContent('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class ServiceC/);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`{ ${type}, Injectable } from '@angular/core`);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`{ provide: ServiceB, useValue: undefined },`);\n-    });\n-\n-    it(`should migrate multiple nested providers in same ${type}`, async () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        export class ServiceA {}\n-        export class ServiceB {}\n-        export class ServiceC {}\n-        export class ServiceD {}\n-\n-        @${type}({\n-          ${propName}: [\n-            ServiceA,\n-            [\n-              {provide: ServiceB, useClass: ServiceB},\n-              ServiceC,\n-              {provide: ServiceD},\n-            ],\n-          ]})\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class ServiceA/);\n-      expect(tree.readContent('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class ServiceB/);\n-      expect(tree.readContent('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class ServiceC/);\n-      expect(tree.readContent('/index.ts')).toMatch(/ServiceC {}\\s+export class ServiceD/);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`{ ${type}, Injectable } from '@angular/core`);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`{ provide: ServiceD, useValue: undefined },`);\n-    });\n-\n-    it('should migrate providers referenced through identifier', async () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        export class ServiceA {}\n-        export class ServiceB {}\n-        export class ServiceC {}\n-\n-        const PROVIDERS = [\n-          ServiceA,\n-          ServiceB,\n-          // trailing comma is by intention to check if do not create\n-          // an invalid object literal.\n-          {provide: ServiceC, },\n-        ];\n-\n-        @${type}({\n-          ${propName}: PROVIDERS,\n-        })\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class ServiceA/);\n-      expect(tree.readContent('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class ServiceB/);\n-      expect(tree.readContent('/index.ts')).toMatch(/ServiceB {}\\s+export class ServiceC/);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`{ ${type}, Injectable } from '@angular/core`);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`{ provide: ServiceC, useValue: undefined },`);\n-    });\n-\n-    it('should migrate providers created through static analyzable function call', async () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        export class ServiceA {}\n-        export class ServiceB {}\n-        export class ServiceC {}\n-\n-        export function createProviders(x: any, b: any) {\n-          return [ServiceA, x, b]\n-        }\n-\n-        @${type}({\n-          ${propName}: createProviders(ServiceB, {provide: ServiceC}),\n-        })\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class ServiceA/);\n-      expect(tree.readContent('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class ServiceB/);\n-      expect(tree.readContent('/index.ts')).toMatch(/ServiceB {}\\s+export class ServiceC/);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`{ ${type}, Injectable } from '@angular/core`);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`ServiceB, { provide: ServiceC, useValue: undefined }),`);\n-    });\n-\n-    it('should migrate providers which are computed through spread operator', async () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        export class ServiceA {}\n-        export class ServiceB {}\n-        export class ServiceC {}\n-\n-        const otherServices = [ServiceB, {provide: ServiceC}];\n-\n-        @${type}({\n-          ${propName}: [ServiceA, ...otherServices],\n-        })\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class ServiceA/);\n-      expect(tree.readContent('/index.ts')).toMatch(/@Injectable\\(\\)\\s+export class ServiceB/);\n-      expect(tree.readContent('/index.ts')).toMatch(/ServiceB {}\\s+export class ServiceC/);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`{ ${type}, Injectable } from '@angular/core`);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`ServiceB, { provide: ServiceC, useValue: undefined }];`);\n-    });\n-\n-    it(`should migrate provider once if referenced in multiple ${type} definitions`, async () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        export class ServiceA {}\n-\n-        @${type}({${propName}: [ServiceA]})\n-        export class TestClassA {}\n-      `);\n-\n-      writeFile('/second.ts', `\n-        import {${type}} from '@angular/core';\n-        import {ServiceA} from './index';\n-\n-        export class ServiceB {}\n-\n-        @${type}({${propName}: [ServiceA, ServiceB]})\n-        export class TestClassB {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/index.ts'))\n-          .toMatch(/@angular\\/core';\\s+@Injectable\\(\\)\\s+export class ServiceA/);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`{ ${type}, Injectable } from '@angular/core`);\n-      expect(tree.readContent('/second.ts')).toMatch(/@Injectable\\(\\)\\s+export class ServiceB/);\n-      expect(tree.readContent('/second.ts'))\n-          .toContain(`{ ${type}, Injectable } from '@angular/core`);\n-    });\n-\n-    it(`should only migrate empty object provider literal once if referenced multiple times ` +\n-           `in ${type} definitions`,\n-       async () => {\n-         writeFile('/provider.ts', `\n-        export class MyService {}\n-\n-        export const PROVIDER = {provide: MyService};\n-      `);\n-\n-         writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-        import {PROVIDER} from './provider';\n-\n-        @${type}({${propName}: [PROVIDER]})\n-        export class TestClassA {}\n-      `);\n-\n-         writeFile('/second.ts', `\n-        import {${type}} from '@angular/core';\n-        import {PROVIDER} from './provider';\n-\n-        export class ServiceB {}\n-\n-        @${type}({${propName}: [PROVIDER, ServiceB]})\n-        export class TestClassB {}\n-      `);\n-\n-         await runMigration();\n-\n-         expect(warnOutput.length).toBe(0);\n-         expect(tree.readContent('/provider.ts')).toMatch(/^\\s+export class MyService {}/);\n-         expect(tree.readContent('/provider.ts'))\n-             .toContain(`const PROVIDER = { provide: MyService, useValue: undefined };`);\n-       });\n-\n-    it('should create new import for @Injectable when migrating provider', async () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-        import {MyService, MySecondService} from './service';\n-\n-        @${type}({${propName}: [MyService, MySecondService]})\n-        export class TestClass {}\n-      `);\n-\n-      writeFile('/service.ts', `export class MyService {}\n-\n-        export class MySecondService {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/service.ts')).toMatch(/@Injectable\\(\\)\\s+export class MyService/);\n-      expect(tree.readContent('/service.ts'))\n-          .toMatch(/@Injectable\\(\\)\\s+export class MySecondService/);\n-      expect(tree.readContent('/service.ts'))\n-          .toMatch(/import { Injectable } from \"@angular\\/core\";/);\n-    });\n-\n-    it('should re-use existing namespace import for importing @Injectable when migrating provider',\n-       async () => {\n-         writeFile('/index.ts', `\n-          import * as core from '@angular/core';\n-\n-          export class MyService {\n-            constructor() {\n-              console.log(core.isDevMode());\n-            }\n-          }\n-        `);\n-\n-         writeFile('/app.module.ts', `\n-          import {${type}} from '@angular/core';\n-          import {MyService} from './index';\n-\n-          @${type}({${propName}: [MyService]})\n-          export class TestClass {}\n-        `);\n-\n-         await runMigration();\n-\n-         expect(warnOutput.length).toBe(0);\n-         expect(tree.readContent('/index.ts'))\n-             .toMatch(/@core.Injectable\\(\\)\\s+export class MyService/);\n-       });\n-\n-    it('should warn if a referenced individual provider could not be resolved', async () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        @${type}({${propName}: [NotPresent]})\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      const providerSourceTextColumn = 15 + type.length + propName.length;\n-      expect(warnOutput.length).toBe(1);\n-      expect(warnOutput[0]).toMatch(/\\s+index\\.ts@4:.+Provider is not statically analyzable./);\n-      expect(warnOutput[0]).toContain(`4:${providerSourceTextColumn}:`);\n-    });\n-\n-    it(`should warn if ${propName} value could not be resolved`, async () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        @${type}({${propName}: NOT_ANALYZABLE)\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      const propValueSourceTextColumn = 14 + type.length + propName.length;\n-      expect(warnOutput.length).toBe(1);\n-      expect(warnOutput[0]).toMatch(/\\s+index\\.ts@4:.+Providers.*not statically analyzable./);\n-      expect(warnOutput[0]).toContain(`4:${propValueSourceTextColumn}:`);\n-    });\n-\n-    it(`should not throw if an empty @${type} is analyzed`, async () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-\n-        @${type}()\n-        export class MyModule {}\n-      `);\n-\n-      try {\n-        await runMigration();\n-      } catch (e) {\n-        fail(e);\n-      }\n-\n-      expect(warnOutput.length).toBe(0);\n-    });\n-\n-    it('should create new import for injectable after full end of last import statement',\n-       async () => {\n-         writeFile('/index.ts', `\n-          import {${type}} from '@angular/core';\n-          import {MyService} from './service';\n-\n-          @${type}({${propName}: [MyService]})\n-          export class TestClass {}\n-        `);\n-\n-         writeFile('/service.ts', `\n-          import * as a from 'a';\n-          import * as a from 'b'; // some comment\n-\n-          export class MyService {}\n-        `);\n-\n-         await runMigration();\n-\n-         expect(warnOutput.length).toBe(0);\n-         expect(tree.readContent('/service.ts'))\n-             .toMatch(/@Injectable\\(\\)\\s+export class MyService/);\n-         expect(tree.readContent('/service.ts'))\n-             .toMatch(/'b'; \\/\\/ some comment\\s+import { Injectable } from \"@angular\\/core\";/);\n-       });\n-\n-    it('should create new import at source file start with trailing new-line', async () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-        import {MyService} from './service';\n-\n-        @${type}({${propName}: [MyService]})\n-        export class TestClass {}\n-      `);\n-\n-      writeFile('/service.ts', `/* @license */\n-        export class MyService {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/service.ts'))\n-          .toMatch(\n-              /^import { Injectable } from \"@angular\\/core\";\\s+\\/\\* @license \\*\\/\\s+@Injectable\\(\\)\\s+export class MyService/);\n-    });\n-\n-    it('should remove @Inject decorator for providers which are migrated', async () => {\n-      writeFile('/index.ts', `\n-        import {${type}} from '@angular/core';\n-        import {MyService} from './service';\n-\n-        @${type}({${propName}: [MyService]})\n-        export class TestClass {}\n-      `);\n-\n-      writeFile('/service.ts', `\n-        import {Inject} from '@angular/core';\n-\n-        @Inject()\n-        export class MyService {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/service.ts'))\n-          .toMatch(/core';\\s+@Injectable\\(\\)\\s+export class MyService/);\n-      // \"inject\" import will be preserved. We don't want to bother with detecting\n-      // if the import is unused or not. We leave this up to the developers.\n-      expect(tree.readContent('/service.ts'))\n-          .toMatch(/import { Inject, Injectable } from '@angular\\/core';/);\n-    });\n-\n-    it('should not migrate provider classes in library type definitions', async () => {\n-      writeFile('/node_modules/my-lib/index.d.ts', `\n-        export declare class MyService {}\n-      `);\n-\n-      writeFile('/index.ts', `\n-        import {MyService} from 'my-lib';\n-        import {Pipe, ${type}} from '@angular/core';\n-\n-        @${type}({${propName}: [MyService]})\n-        export class TestClass {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(warnOutput.length).toBe(0);\n-      expect(tree.readContent('/node_modules/my-lib/index.d.ts')).not.toContain('@Injectable');\n-    });\n-  }\n-});"
        },
        {
            "sha": "1ebbb6897898f13eacdd21b4c1c7efa390c68a63",
            "filename": "packages/core/schematics/test/module_with_providers_migration_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 236,
            "changes": 236,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fmodule_with_providers_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fmodule_with_providers_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fmodule_with_providers_migration_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,236 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n-import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n-import {HostTree} from '@angular-devkit/schematics';\n-import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n-import * as shx from 'shelljs';\n-\n-describe('ModuleWithProviders migration', () => {\n-  let runner: SchematicTestRunner;\n-  let host: TempScopedNodeJsSyncHost;\n-  let tree: UnitTestTree;\n-  let tmpDirPath: string;\n-  let previousWorkingDir: string;\n-\n-  beforeEach(() => {\n-    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n-    host = new TempScopedNodeJsSyncHost();\n-    tree = new UnitTestTree(new HostTree(host));\n-\n-    writeFile('/tsconfig.json', JSON.stringify({\n-      compilerOptions: {\n-        lib: ['es2015'],\n-      }\n-    }));\n-    writeFile('/angular.json', JSON.stringify({\n-      version: 1,\n-      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n-    }));\n-\n-    previousWorkingDir = shx.pwd();\n-    tmpDirPath = getSystemPath(host.root);\n-\n-    // Switch into the temporary directory path. This allows us to run\n-    // the schematic against our custom unit test tree.\n-    shx.cd(tmpDirPath);\n-  });\n-\n-  afterEach(() => {\n-    shx.cd(previousWorkingDir);\n-    shx.rm('-r', tmpDirPath);\n-  });\n-\n-  it('should add generic type for function return', async () => {\n-    writeFile('/index.ts', `\n-        import {NgModule, ModuleWithProviders} from '@angular/core';\n-\n-        @NgModule({})\n-        export class BaseModule {}\n-\n-        export function getProvider() {\n-          return {ngModule: BaseModule}\n-        }\n-\n-        @NgModule({})\n-        export class TestModule {\n-          static forRoot(): ModuleWithProviders {\n-            return getProvider();\n-          }\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts')).toContain(`ModuleWithProviders<BaseModule>`);\n-  });\n-\n-  it('should add generic type for function return; external file', async () => {\n-    writeFile('/module.ts', `\n-        import {NgModule} from '@angular/core';\n-\n-        @NgModule({})\n-        export class BaseModule {}\n-      `);\n-    writeFile('/index.ts', `\n-        import {NgModule, ModuleWithProviders} from '@angular/core';\n-        import {BaseModule} from './module';\n-\n-        export function getProvider() {\n-          return {ngModule: BaseModule}\n-        }\n-\n-        @NgModule({})\n-        export class TestModule {\n-          static forRoot(): ModuleWithProviders {\n-            return getProvider();\n-          }\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts')).toContain(`ModuleWithProviders<BaseModule>`);\n-  });\n-\n-  it('should add generic type for function return without explicit type', async () => {\n-    writeFile('/index.ts', `\n-        import {NgModule} from '@angular/core';\n-\n-        @NgModule({})\n-        export class BaseModule {}\n-\n-        export function getProvider() {\n-          return {ngModule: BaseModule}\n-        }\n-\n-        @NgModule({})\n-        export class TestModule {\n-          static forRoot() {\n-            return getProvider();\n-          }\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts')).toContain(`ModuleWithProviders<BaseModule>`);\n-  });\n-\n-  it('should add generic type for const variable', async () => {\n-    writeFile('/index.ts', `\n-        import {ModuleWithProviders, NgModule} from '@angular/core';\n-\n-        @NgModule({})\n-        export class BaseModule {}\n-\n-        export const myModuleWithProviders = {ngModule: BaseModule};\n-\n-        @NgModule({})\n-        export class TestModule {\n-          static forRoot(): ModuleWithProviders {\n-            return myModuleWithProviders;\n-          }\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts')).toContain(`ModuleWithProviders<BaseModule>`);\n-  });\n-\n-  it('should add generic type for const variable without explicit type', async () => {\n-    writeFile('/index.ts', `\n-        import {NgModule} from '@angular/core';\n-\n-        @NgModule({})\n-        export class BaseModule {}\n-\n-        export const myModuleWithProviders = {ngModule: BaseModule};\n-\n-        @NgModule({})\n-        export class TestModule {\n-          static forRoot() {\n-            return myModuleWithProviders;\n-          }\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts')).toContain(`ModuleWithProviders<BaseModule>`);\n-  });\n-\n-  it('should not add generic type for const variable with invalid base object', async () => {\n-    writeFile('/index.ts', `\n-        import {NgModule} from '@angular/core';\n-\n-        @NgModule({})\n-        export class BaseModule {}\n-\n-        export const myModuleWithProviders = {ngModule: BaseModule, otherKey: 'a'};\n-\n-        @NgModule({})\n-        export class TestModule {\n-          static forRoot() {\n-            return myModuleWithProviders;\n-          }\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts')).not.toContain(`ModuleWithProviders<BaseModule>`);\n-  });\n-\n-  it('should add generic type for const variables and functions with incomplete type', async () => {\n-    writeFile('/index.ts', `\n-      import {ModuleWithProviders, NgModule} from '@angular/core';\n-\n-      @NgModule({})\n-      export class BaseModule {}\n-\n-      export const myModuleWithProviders: ModuleWithProviders = {ngModule: BaseModule};\n-\n-      export function mwpFunction(): ModuleWithProviders {\n-        return myModuleWithProviders;\n-      }\n-\n-      export class MwpClass {\n-        mwp: ModuleWithProviders = myModuleWithProviders;\n-        private _mwp: ModuleWithProviders = myModuleWithProviders;\n-\n-        getMwp(): ModuleWithProviders {\n-          return myModuleWithProviders;\n-        }\n-\n-        static initMwp(): ModuleWithProviders {\n-          return myModuleWithProviders;\n-        }\n-      }\n-    `);\n-\n-    await runMigration();\n-    // Note the explicit space at the end here\n-    expect(tree.readContent('/index.ts')).not.toContain(`ModuleWithProviders `);\n-  });\n-\n-  it('should not add generic type for const variables without initialization', async () => {\n-    writeFile('/index.ts', `\n-      import {ModuleWithProviders} from '@angular/core';\n-\n-      export const myModuleWithProviders: ModuleWithProviders;\n-    `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts')).toContain(`TODO`);\n-  });\n-\n-  function writeFile(filePath: string, contents: string) {\n-    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n-  }\n-\n-  function runMigration() {\n-    return runner.runSchematicAsync('migration-v10-module-with-providers', {}, tree).toPromise();\n-  }\n-});"
        },
        {
            "sha": "d07e5167a17e498a1c86c9e82ae6775436da0d99",
            "filename": "packages/core/schematics/test/move_document_migration_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 171,
            "changes": 171,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fmove_document_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fmove_document_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fmove_document_migration_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,171 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n-import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n-import {HostTree} from '@angular-devkit/schematics';\n-import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n-import * as shx from 'shelljs';\n-\n-describe('move-document migration', () => {\n-  let runner: SchematicTestRunner;\n-  let host: TempScopedNodeJsSyncHost;\n-  let tree: UnitTestTree;\n-  let tmpDirPath: string;\n-  let previousWorkingDir: string;\n-\n-  beforeEach(() => {\n-    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n-    host = new TempScopedNodeJsSyncHost();\n-    tree = new UnitTestTree(new HostTree(host));\n-\n-    writeFile('/tsconfig.json', JSON.stringify({\n-      compilerOptions: {\n-        lib: ['es2015'],\n-      },\n-    }));\n-    writeFile('/angular.json', JSON.stringify({\n-      version: 1,\n-      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n-    }));\n-\n-    previousWorkingDir = shx.pwd();\n-    tmpDirPath = getSystemPath(host.root);\n-\n-    // Switch into the temporary directory path. This allows us to run\n-    // the schematic against our custom unit test tree.\n-    shx.cd(tmpDirPath);\n-  });\n-\n-  afterEach(() => {\n-    shx.cd(previousWorkingDir);\n-    shx.rm('-r', tmpDirPath);\n-  });\n-\n-  describe('move-document', () => {\n-    it('should properly apply import replacement', async () => {\n-      writeFile('/index.ts', `\n-        import {DOCUMENT} from '@angular/platform-browser';\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-\n-      expect(content).toContain(`import { DOCUMENT } from \"@angular/common\";`);\n-      expect(content).not.toContain(`import {DOCUMENT} from '@angular/platform-browser';`);\n-    });\n-\n-    it('should properly apply import replacement (BOM)', async () => {\n-      writeFile('/index.ts', `\\uFEFF\n-        import {DOCUMENT} from '@angular/platform-browser';\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-\n-      expect(content).toContain(`import { DOCUMENT } from \"@angular/common\";`);\n-      expect(content).not.toContain(`import {DOCUMENT} from '@angular/platform-browser';`);\n-    });\n-\n-    it('should properly apply import replacement with existing import', async () => {\n-      writeFile('/index.ts', `\n-        import {DOCUMENT} from '@angular/platform-browser';\n-        import {someImport} from '@angular/common';\n-      `);\n-\n-      writeFile('/reverse.ts', `\n-        import {someImport} from '@angular/common';\n-        import {DOCUMENT} from '@angular/platform-browser';\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-      const contentReverse = tree.readContent('/reverse.ts');\n-\n-      expect(content).toContain(`import { someImport, DOCUMENT } from '@angular/common';`);\n-      expect(content).not.toContain(`import {DOCUMENT} from '@angular/platform-browser';`);\n-\n-      expect(contentReverse).toContain(`import { someImport, DOCUMENT } from '@angular/common';`);\n-      expect(contentReverse).not.toContain(`import {DOCUMENT} from '@angular/platform-browser';`);\n-    });\n-\n-    it('should properly apply import replacement with existing import w/ comments', async () => {\n-      writeFile('/index.ts', `\n-        /**\n-         * this is a comment\n-         */\n-        import {someImport} from '@angular/common';\n-        import {DOCUMENT} from '@angular/platform-browser';\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-\n-      expect(content).toContain(`import { someImport, DOCUMENT } from '@angular/common';`);\n-      expect(content).not.toContain(`import {DOCUMENT} from '@angular/platform-browser';`);\n-\n-      expect(content).toMatch(/.*this is a comment.*/);\n-    });\n-\n-    it('should properly apply import replacement with existing and redundant imports', async () => {\n-      writeFile('/index.ts', `\n-        import {DOCUMENT} from '@angular/platform-browser';\n-        import {anotherImport} from '@angular/platform-browser-dynamic';\n-        import {someImport} from '@angular/common';\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-\n-      expect(content).toContain(`import { someImport, DOCUMENT } from '@angular/common';`);\n-      expect(content).not.toContain(`import {DOCUMENT} from '@angular/platform-browser';`);\n-    });\n-\n-    it('should properly apply import replacement with existing import and leave original import',\n-       async () => {\n-         writeFile('/index.ts', `\n-        import {DOCUMENT, anotherImport} from '@angular/platform-browser';\n-        import {someImport} from '@angular/common';\n-      `);\n-\n-         await runMigration();\n-\n-         const content = tree.readContent('/index.ts');\n-\n-         expect(content).toContain(`import { someImport, DOCUMENT } from '@angular/common';`);\n-         expect(content).toContain(`import { anotherImport } from '@angular/platform-browser';`);\n-       });\n-\n-    it('should properly apply import replacement with existing import and alias', async () => {\n-      writeFile('/index.ts', `\n-        import {DOCUMENT as doc, anotherImport} from '@angular/platform-browser';\n-        import {someImport} from '@angular/common';\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-\n-      expect(content).toContain(`import { someImport, DOCUMENT as doc } from '@angular/common';`);\n-      expect(content).toContain(`import { anotherImport } from '@angular/platform-browser';`);\n-    });\n-  });\n-\n-  function writeFile(filePath: string, contents: string) {\n-    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n-  }\n-\n-  function runMigration() {\n-    return runner.runSchematicAsync('migration-v8-move-document', {}, tree).toPromise();\n-  }\n-});"
        },
        {
            "sha": "d2c94daff1010170426e8186146a4a108e11ebd9",
            "filename": "packages/core/schematics/test/native_view_encapsulation_migration_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 170,
            "changes": 170,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fnative_view_encapsulation_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fnative_view_encapsulation_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fnative_view_encapsulation_migration_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,170 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n-import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n-import {HostTree} from '@angular-devkit/schematics';\n-import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n-import * as shx from 'shelljs';\n-\n-describe('ViewEncapsulation.Native migration', () => {\n-  let runner: SchematicTestRunner;\n-  let host: TempScopedNodeJsSyncHost;\n-  let tree: UnitTestTree;\n-  let tmpDirPath: string;\n-  let previousWorkingDir: string;\n-\n-  beforeEach(() => {\n-    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n-    host = new TempScopedNodeJsSyncHost();\n-    tree = new UnitTestTree(new HostTree(host));\n-\n-    writeFile('/tsconfig.json', JSON.stringify({\n-      compilerOptions: {\n-        lib: ['es2015'],\n-        strictNullChecks: true,\n-      },\n-    }));\n-    writeFile('/angular.json', JSON.stringify({\n-      version: 1,\n-      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n-    }));\n-\n-    previousWorkingDir = shx.pwd();\n-    tmpDirPath = getSystemPath(host.root);\n-\n-    // Switch into the temporary directory path. This allows us to run\n-    // the schematic against our custom unit test tree.\n-    shx.cd(tmpDirPath);\n-  });\n-\n-  afterEach(() => {\n-    shx.cd(previousWorkingDir);\n-    shx.rm('-r', tmpDirPath);\n-  });\n-\n-  it('should change Native view encapsulation usages to ShadowDom', async () => {\n-    writeFile('/index.ts', `\n-      import {Component, ViewEncapsulation} from '@angular/core';\n-\n-      @Component({\n-        template: 'hello',\n-        encapsulation: ViewEncapsulation.Native\n-      })\n-      class App {}\n-    `);\n-\n-    await runMigration();\n-\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toContain('encapsulation: ViewEncapsulation.ShadowDom');\n-  });\n-\n-  it('should change Native view encapsulation usages if the enum is aliased', async () => {\n-    writeFile('/index.ts', `\n-      import {Component, ViewEncapsulation as Encapsulation} from '@angular/core';\n-\n-      @Component({\n-        template: 'hello',\n-        encapsulation: Encapsulation.Native\n-      })\n-      class App {}\n-    `);\n-\n-    await runMigration();\n-\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toContain('encapsulation: Encapsulation.ShadowDom');\n-  });\n-\n-  it('should change Native view encapsulation usages inside a variable', async () => {\n-    writeFile('/index.ts', `\n-      import {Component, ViewEncapsulation} from '@angular/core';\n-\n-      const encapsulation = ViewEncapsulation.Native;\n-\n-      @Component({template: 'hello', encapsulation})\n-      class App {}\n-\n-      @Component({template: 'click me', encapsulation})\n-      class Button {}\n-    `);\n-\n-    await runMigration();\n-\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toContain('const encapsulation = ViewEncapsulation.ShadowDom;');\n-  });\n-\n-  it('should not change components that do not set an encapsulation', async () => {\n-    const source = `\n-      import {Component} from '@angular/core';\n-\n-      @Component({\n-        template: 'hello'\n-      })\n-      class App {}\n-    `;\n-\n-    writeFile('/index.ts', source);\n-\n-    await runMigration();\n-\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toBe(source);\n-  });\n-\n-  it('should not change components that use an encapsulation different from Native', async () => {\n-    const source = `\n-      import {Component, ViewEncapsulation} from '@angular/core';\n-\n-      @Component({\n-        template: 'hello',\n-        encapsulation: ViewEncapsulation.None\n-      })\n-      class App {}\n-    `;\n-\n-    writeFile('/index.ts', source);\n-\n-    await runMigration();\n-\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toBe(source);\n-  });\n-\n-  it('should not change cases where ViewEncapsulation does not come from @angular/core',\n-     async () => {\n-       const source = `\n-        import {Component} from '@angular/core';\n-        import {ViewEncapsulation} from '@not-angular/core';\n-\n-        @Component({\n-          template: 'hello',\n-          encapsulation: ViewEncapsulation.Native\n-        })\n-        class App {}\n-      `;\n-\n-       writeFile('/index.ts', source);\n-\n-       await runMigration();\n-\n-       const content = tree.readContent('/index.ts');\n-       expect(content).toBe(source);\n-     });\n-\n-  function writeFile(filePath: string, contents: string) {\n-    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n-  }\n-\n-  function runMigration() {\n-    return runner.runSchematicAsync('migration-v11-native-view-encapsulation', {}, tree)\n-        .toPromise();\n-  }\n-});"
        },
        {
            "sha": "f30cf78e37322ddc0c89725873c5ffb2c05c03c8",
            "filename": "packages/core/schematics/test/navigation_extras_omissions_migration_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 303,
            "changes": 303,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fnavigation_extras_omissions_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fnavigation_extras_omissions_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fnavigation_extras_omissions_migration_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,303 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n-import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n-import {HostTree} from '@angular-devkit/schematics';\n-import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n-import * as shx from 'shelljs';\n-\n-describe('NavigationExtras omissions migration', () => {\n-  let runner: SchematicTestRunner;\n-  let host: TempScopedNodeJsSyncHost;\n-  let tree: UnitTestTree;\n-  let tmpDirPath: string;\n-  let previousWorkingDir: string;\n-\n-  beforeEach(() => {\n-    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n-    host = new TempScopedNodeJsSyncHost();\n-    tree = new UnitTestTree(new HostTree(host));\n-\n-    writeFile('/tsconfig.json', JSON.stringify({\n-      compilerOptions: {\n-        lib: ['es2015'],\n-        strictNullChecks: true,\n-      },\n-    }));\n-    writeFile('/angular.json', JSON.stringify({\n-      version: 1,\n-      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n-    }));\n-    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n-    writeFile('/node_modules/@angular/router/index.d.ts', `\n-      export declare class Router {\n-        navigateByUrl(url: string, extras?: any);\n-        createUrlTree(commands: any[], extras?: any);\n-      }\n-    `);\n-\n-    previousWorkingDir = shx.pwd();\n-    tmpDirPath = getSystemPath(host.root);\n-\n-    // Switch into the temporary directory path. This allows us to run\n-    // the schematic against our custom unit test tree.\n-    shx.cd(tmpDirPath);\n-  });\n-\n-  afterEach(() => {\n-    shx.cd(previousWorkingDir);\n-    shx.rm('-r', tmpDirPath);\n-  });\n-\n-  it('should not change calls with a single argument', async () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      class Navigator {\n-        constructor(private _router: Router) {}\n-\n-        goHome() {\n-          this._router.navigateByUrl('/');\n-        }\n-      }\n-\n-      function createTree(router: Router) {\n-        return router.createUrlTree(['/']);\n-      }\n-    `);\n-\n-    await runMigration();\n-\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toContain(`this._router.navigateByUrl('/');`);\n-    expect(content).toContain(`return router.createUrlTree(['/']);`);\n-  });\n-\n-  it('should not change calls with an empty object literal', async () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      class Navigator {\n-        constructor(private _router: Router) {}\n-\n-        goHome() {\n-          this._router.navigateByUrl('/', {});\n-        }\n-      }\n-\n-      function createTree(router: Router) {\n-        return router.createUrlTree(['/'], {});\n-      }\n-    `);\n-\n-    await runMigration();\n-\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toContain(`this._router.navigateByUrl('/', {});`);\n-    expect(content).toContain(`return router.createUrlTree(['/'], {});`);\n-  });\n-\n-  it('should not change objects that are used in multiple different methods', async () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      const config = {replaceUrl: true, fragment: 'foo', state: {}};\n-\n-      class Navigator {\n-        constructor(private _router: Router) {}\n-\n-        goHome() {\n-          this._router.navigateByUrl('/', config);\n-          return this._router.createUrlTree(['/'], config);\n-        }\n-      }\n-    `);\n-\n-    await runMigration();\n-\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toContain(`const config = {replaceUrl: true, fragment: 'foo', state: {}};`);\n-  });\n-\n-  it('should preserve calls if the router does not come from @angular/router', async () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@custom/router';\n-\n-      function createTree(router: Router) {\n-        return router.createUrlTree(['/'], {foo: 1, bar: 2});\n-      }\n-    `);\n-\n-    await runMigration();\n-\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toContain(`return router.createUrlTree(['/'], {foo: 1, bar: 2});`);\n-  });\n-\n-  it('should change invalid navigateByUrl calls', async () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      class Navigator {\n-        constructor(private _router: Router) {}\n-\n-        goHome() {\n-          this._router.navigateByUrl('/', {preserveFragment: false, skipLocationChange: false, fragment: 'foo'});\n-        }\n-      }\n-    `);\n-\n-    await runMigration();\n-\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toContain(\n-        `this._router.navigateByUrl('/', { /* Removed unsupported properties by Angular migration: preserveFragment, fragment. */ skipLocationChange: false });`);\n-  });\n-\n-  it('should change invalid navigateByUrl calls', async () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      function createTree(router: Router) {\n-        return router.createUrlTree(['/'], {replaceUrl: true, preserveFragment: true, state: {}});\n-      }\n-    `);\n-\n-    await runMigration();\n-\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toContain(\n-        `return router.createUrlTree(['/'], { /* Removed unsupported properties by Angular migration: replaceUrl, state. */ preserveFragment: true });`);\n-  });\n-\n-  it('should set the comment outside the object if all properties were removed', async () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      function navigate(router: Router) {\n-        router.navigateByUrl('/', {fragment: 'foo'});\n-      }\n-    `);\n-\n-    await runMigration();\n-\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toContain(\n-        `router.navigateByUrl('/', /* Removed unsupported properties by Angular migration: fragment. */ {});`);\n-  });\n-\n-  it('should migrate object literals defined as variables', async () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      const config = {skipLocationChange: false, fragment: 'foo'};\n-      const proxy = config;\n-\n-      function navigate(router: Router) {\n-        router.navigateByUrl('/', proxy);\n-      }\n-    `);\n-\n-    await runMigration();\n-\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toContain(\n-        `const config = { /* Removed unsupported properties by Angular migration: fragment. */ skipLocationChange: false };`);\n-    expect(content).toContain(`const proxy = config;`);\n-    expect(content).toContain(`router.navigateByUrl('/', proxy);`);\n-  });\n-\n-  it('should pick up calls where the router is returned by a function', async () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      function navigate(router: Router) {\n-        getRouter().navigateByUrl('/', {fragment: 'foo'});\n-      }\n-\n-      function getRouter() {\n-        return {} as Router;\n-      }\n-    `);\n-\n-    await runMigration();\n-\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toContain(\n-        `getRouter().navigateByUrl('/', /* Removed unsupported properties by Angular migration: fragment. */ {});`);\n-  });\n-\n-  it('should pick up calls where the router is aliased', async () => {\n-    writeFile('/index.ts', `\n-      import {Router as AliasedRouter} from '@angular/router';\n-\n-      function navigate(router: AliasedRouter) {\n-        router.navigateByUrl('/', {fragment: 'foo'});\n-      }\n-    `);\n-\n-    await runMigration();\n-\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toContain(\n-        `router.navigateByUrl('/', /* Removed unsupported properties by Angular migration: fragment. */ {});`);\n-  });\n-\n-  it('should preserve object spread assignments', async () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      function navigate(router: Router) {\n-        const overrides = {foo: 1};\n-        router.navigateByUrl('/', {replaceUrl: true, fragment: 'foo', ...overrides});\n-      }\n-    `);\n-\n-    await runMigration();\n-\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toContain(\n-        `router.navigateByUrl('/', { /* Removed unsupported properties by Angular migration: fragment. */ replaceUrl: true, ...overrides });`);\n-  });\n-\n-  it('should migrate objects that are used in multiple calls of the same method', async () => {\n-    writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      const config = {skipLocationChange: false, fragment: 'foo'};\n-\n-      class Navigator {\n-        constructor(private _router: Router) {}\n-\n-        goHome() {\n-          this._router.navigateByUrl('/', config);\n-        }\n-\n-        goFish() {\n-          this._router.navigateByUrl('/fish', config);\n-        }\n-      }\n-    `);\n-\n-    await runMigration();\n-\n-    const content = tree.readContent('/index.ts');\n-    expect(content).toContain(\n-        `const config = { /* Removed unsupported properties by Angular migration: fragment. */ skipLocationChange: false };`);\n-  });\n-\n-  function writeFile(filePath: string, contents: string) {\n-    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n-  }\n-\n-  function runMigration() {\n-    return runner.runSchematicAsync('migration-v11-navigation-extras-omissions', {}, tree)\n-        .toPromise();\n-  }\n-});"
        },
        {
            "sha": "e0f46e14a780a8fcb264938c08247c2fb92efc77",
            "filename": "packages/core/schematics/test/preserve_query_params_migration_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 233,
            "changes": 233,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fpreserve_query_params_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fpreserve_query_params_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fpreserve_query_params_migration_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,233 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n-import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n-import {HostTree} from '@angular-devkit/schematics';\n-import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n-import * as shx from 'shelljs';\n-\n-describe('NavigationExtras preserveQueryParams migration', () => {\n-  let runner: SchematicTestRunner;\n-  let host: TempScopedNodeJsSyncHost;\n-  let tree: UnitTestTree;\n-  let tmpDirPath: string;\n-  let previousWorkingDir: string;\n-\n-  beforeEach(() => {\n-    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n-    host = new TempScopedNodeJsSyncHost();\n-    tree = new UnitTestTree(new HostTree(host));\n-\n-    writeFile('/tsconfig.json', JSON.stringify({\n-      compilerOptions: {\n-        lib: ['es2015'],\n-        strictNullChecks: true,\n-      },\n-    }));\n-    writeFile('/angular.json', JSON.stringify({\n-      version: 1,\n-      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n-    }));\n-    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n-    writeFile('/node_modules/@angular/router/index.d.ts', `\n-      export declare class Router {\n-        navigate(url: string, extras?: any);\n-        createUrlTree(commands: any[], extras?: any);\n-      }\n-    `);\n-\n-    previousWorkingDir = shx.pwd();\n-    tmpDirPath = getSystemPath(host.root);\n-\n-    // Switch into the temporary directory path. This allows us to run\n-    // the schematic against our custom unit test tree.\n-    shx.cd(tmpDirPath);\n-  });\n-\n-  afterEach(() => {\n-    shx.cd(previousWorkingDir);\n-    shx.rm('-r', tmpDirPath);\n-  });\n-\n-  describe('updates the', () => {\n-    it('`navigate` function', async () => {\n-      writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      class Navigator {\n-        constructor(private _router: Router) {}\n-\n-        goHome() {\n-          this._router.navigate('/', {preserveQueryParams: true});\n-        }\n-      }\n-    `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-      expect(content).toContain(`this._router.navigate('/', { queryParamsHandling: 'preserve' });`);\n-    });\n-\n-    it('`createUrlTree` function', async () => {\n-      writeFile('/index.ts', `\n-      import {Router} from '@angular/router';\n-\n-      class Navigator {\n-        constructor(private _router: Router) {}\n-\n-        goHome() {\n-          this._router.createUrlTree('/', {preserveQueryParams: false});\n-        }\n-      }\n-    `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-      expect(content).toContain(`this._router.createUrlTree('/', {});`);\n-    });\n-  });\n-\n-  describe('updates an object which is used for the parameter', () => {\n-    it('should migrate when the value is `true`', async () => {\n-      writeFile('/index.ts', `\n-        import {Router} from '@angular/router';\n-\n-        const config = {preserveQueryParams: true, replaceUrl: true, fragment: 'foo', state: {}};\n-\n-        class Navigator {\n-          constructor(private _router: Router) {}\n-\n-          goHome() {\n-            this._router.createUrlTree(['/'], config);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-      expect(content).toContain(\n-          `const config = { replaceUrl: true, fragment: 'foo', state: {}, queryParamsHandling: 'preserve' };`);\n-    });\n-\n-    it('should remove when the value is `false`', async () => {\n-      writeFile('/index.ts', `\n-        import {Router} from '@angular/router';\n-\n-        const config = {preserveQueryParams: false, replaceUrl: true, fragment: 'foo', state: {}};\n-\n-        class Navigator {\n-          constructor(private _router: Router) {}\n-\n-          goHome() {\n-            this._router.createUrlTree(['/'], config);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-      expect(content).toContain(`const config = { replaceUrl: true, fragment: 'foo', state: {} };`);\n-    });\n-\n-    it('should not modify when the property is no present', async () => {\n-      writeFile('/index.ts', `\n-        import {Router} from '@angular/router';\n-\n-        const config = {replaceUrl: true, fragment: 'foo', state: {}};\n-\n-        class Navigator {\n-          constructor(private _router: Router) {}\n-\n-          goHome() {\n-            this._router.navigate('/', config);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-      expect(content).toContain(`const config = {replaceUrl: true, fragment: 'foo', state: {}};`);\n-    });\n-  });\n-\n-  describe('updates an the locally defined parameter in the method', () => {\n-    it('should migrate when the value is `true`', async () => {\n-      writeFile('/index.ts', `\n-        import {Router} from '@angular/router';\n-\n-        class Navigator {\n-          constructor(private _router: Router) {}\n-\n-          goHome() {\n-            this._router.navigate('/', {preserveQueryParams: true, replaceUrl: true, fragment: 'foo', state: {}});\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-      expect(content).toContain(\n-          `this._router.navigate('/', { replaceUrl: true, fragment: 'foo', state: {}, queryParamsHandling: 'preserve' });`);\n-    });\n-\n-    it('should remove when the value is `false`', async () => {\n-      writeFile('/index.ts', `\n-        import {Router} from '@angular/router';\n-\n-        class Navigator {\n-          constructor(private _router: Router) {}\n-\n-          goHome() {\n-            this._router.createUrlTree(['/'], {preserveQueryParams: false, replaceUrl: true, fragment: 'foo', state: {}};);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-      expect(content).toContain(\n-          `this._router.createUrlTree(['/'], { replaceUrl: true, fragment: 'foo', state: {} };`);\n-    });\n-\n-    it('should not modify when the property is not present', async () => {\n-      writeFile('/index.ts', `\n-        import {Router} from '@angular/router';\n-\n-        class Navigator {\n-          constructor(private _router: Router) {}\n-\n-          goHome() {\n-            this._router.navigate('/', {replaceUrl: true, fragment: 'foo', state: {}});\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-      expect(content).toContain(\n-          `this._router.navigate('/', {replaceUrl: true, fragment: 'foo', state: {}});`);\n-    });\n-  });\n-  function writeFile(filePath: string, contents: string) {\n-    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n-  }\n-\n-  function runMigration() {\n-    return runner.runSchematicAsync('migration-v11-router-preserve-query-params', {}, tree)\n-        .toPromise();\n-  }\n-});"
        },
        {
            "sha": "1a51ec3d301ed79e4986d7bd39c374f858b3fc7d",
            "filename": "packages/core/schematics/test/relative_link_resolution_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 189,
            "changes": 189,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Frelative_link_resolution_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Frelative_link_resolution_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Frelative_link_resolution_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,189 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n-import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n-import {HostTree} from '@angular-devkit/schematics';\n-import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n-import * as shx from 'shelljs';\n-\n-describe('initial navigation migration', () => {\n-  let runner: SchematicTestRunner;\n-  let host: TempScopedNodeJsSyncHost;\n-  let tree: UnitTestTree;\n-  let tmpDirPath: string;\n-  let previousWorkingDir: string;\n-\n-  beforeEach(() => {\n-    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n-    host = new TempScopedNodeJsSyncHost();\n-    tree = new UnitTestTree(new HostTree(host));\n-\n-    writeFile('/tsconfig.json', JSON.stringify({\n-      compilerOptions: {\n-        lib: ['es2015'],\n-      }\n-    }));\n-    writeFile('/angular.json', JSON.stringify({\n-      version: 1,\n-      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n-    }));\n-\n-    previousWorkingDir = shx.pwd();\n-    tmpDirPath = getSystemPath(host.root);\n-\n-    // Switch into the temporary directory path. This allows us to run\n-    // the schematic against our custom unit test tree.\n-    shx.cd(tmpDirPath);\n-  });\n-\n-  afterEach(() => {\n-    shx.cd(previousWorkingDir);\n-    shx.rm('-r', tmpDirPath);\n-  });\n-\n-  it('should migrate forRoot with no options', async () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([]),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts'))\n-        .toContain(`RouterModule.forRoot([], { relativeLinkResolution: 'legacy' })`);\n-  });\n-\n-  it('should migrate options without relativeLinkResolution', async () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([], {useHash: true}),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts'))\n-        .toContain(`RouterModule.forRoot([], { useHash: true, relativeLinkResolution: 'legacy' })`);\n-  });\n-\n-  it('should not migrate options containing relativeLinkResolution', async () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule } from '@angular/router';\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([], {relativeLinkResolution: 'corrected'}),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts'))\n-        .toContain(`RouterModule.forRoot([], {relativeLinkResolution: 'corrected'})`);\n-  });\n-\n-  it('should migrate when options is a variable with AsExpression', async () => {\n-    writeFile('/index.ts', `\n-        import { ExtraOptions } from '@angular/router';\n-        const options = {useHash: true} as ExtraOptions;\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts'))\n-        .toContain(\n-            `const options = { useHash: true, relativeLinkResolution: 'legacy' } as ExtraOptions;`);\n-  });\n-\n-  it('should migrate when options is a variable', async () => {\n-    writeFile('/index.ts', `\n-        import { ExtraOptions } from '@angular/router';\n-        const options: ExtraOptions = {useHash: true};\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts'))\n-        .toContain(\n-            `const options: ExtraOptions = { useHash: true, relativeLinkResolution: 'legacy' };`);\n-  });\n-\n-  it('should migrate when options is a variable with no type', async () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { ExtraOptions, RouterModule } from '@angular/router';\n-\n-        const options = {useHash: true};\n-\n-        @NgModule({\n-          imports: [\n-            RouterModule.forRoot([], options),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts'))\n-        .toContain(`const options = { useHash: true, relativeLinkResolution: 'legacy' };`);\n-    expect(tree.readContent('/index.ts')).toContain(`RouterModule.forRoot([], options)`);\n-  });\n-\n-  it('should migrate when aliased options is a variable', async () => {\n-    writeFile('/index.ts', `\n-        import { ExtraOptions as RouterExtraOptions } from '@angular/router';\n-        const options: RouterExtraOptions = {useHash: true};\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts'))\n-        .toContain(\n-            `const options: RouterExtraOptions = { useHash: true, relativeLinkResolution: 'legacy' };`);\n-  });\n-\n-  it('should migrate aliased RouterModule.forRoot', async () => {\n-    writeFile('/index.ts', `\n-        import { NgModule } from '@angular/core';\n-        import { RouterModule as AngularRouterModule} from '@angular/router';\n-        @NgModule({\n-          imports: [\n-            AngularRouterModule.forRoot([]),\n-          ]\n-        })\n-        export class AppModule {\n-        }\n-      `);\n-\n-    await runMigration();\n-    expect(tree.readContent('/index.ts'))\n-        .toContain(`AngularRouterModule.forRoot([], { relativeLinkResolution: 'legacy' }),`);\n-  });\n-\n-  function writeFile(filePath: string, contents: string) {\n-    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n-  }\n-\n-  function runMigration() {\n-    return runner\n-        .runSchematicAsync('migration-v11-router-relative-link-resolution-default', {}, tree)\n-        .toPromise();\n-  }\n-});"
        },
        {
            "sha": "3d3c2828c12c221caf92cc57a4e9e7e86f8c2c26",
            "filename": "packages/core/schematics/test/renderer_to_renderer2_migration_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 1239,
            "changes": 1239,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Frenderer_to_renderer2_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Frenderer_to_renderer2_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Frenderer_to_renderer2_migration_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,1239 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n-import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n-import {HostTree} from '@angular-devkit/schematics';\n-import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n-import * as shx from 'shelljs';\n-\n-describe('Renderer to Renderer2 migration', () => {\n-  let runner: SchematicTestRunner;\n-  let host: TempScopedNodeJsSyncHost;\n-  let tree: UnitTestTree;\n-  let tmpDirPath: string;\n-  let previousWorkingDir: string;\n-\n-  beforeEach(() => {\n-    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n-    host = new TempScopedNodeJsSyncHost();\n-    tree = new UnitTestTree(new HostTree(host));\n-\n-    writeFile('/tsconfig.json', JSON.stringify({\n-      compilerOptions: {\n-        lib: ['es2015'],\n-        strictNullChecks: true,\n-      },\n-    }));\n-    writeFile('/angular.json', JSON.stringify({\n-      version: 1,\n-      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n-    }));\n-    // We need to declare the Angular symbols we're testing for, otherwise type checking won't work.\n-    writeFile('/node_modules/@angular/core/index.d.ts', `\n-      export declare function forwardRef(fn: () => any): any {}\n-    `);\n-\n-    previousWorkingDir = shx.pwd();\n-    tmpDirPath = getSystemPath(host.root);\n-\n-    // Switch into the temporary directory path. This allows us to run\n-    // the schematic against our custom unit test tree.\n-    shx.cd(tmpDirPath);\n-  });\n-\n-  afterEach(() => {\n-    shx.cd(previousWorkingDir);\n-    shx.rm('-r', tmpDirPath);\n-  });\n-\n-  describe('import renaming', () => {\n-    it('should change Renderer imports to Renderer2', async () => {\n-      writeFile('/index.ts', `\n-          import { Renderer, Component } from '@angular/core';\n-\n-          @Component({template: ''})\n-          export class MyComp {\n-            constructor(renderer: Renderer) {}\n-          }\n-        `);\n-\n-      await runMigration();\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`import { Component, Renderer2 } from '@angular/core';`);\n-    });\n-\n-    it('should change aliased Renderer imports to Renderer2', async () => {\n-      writeFile('/index.ts', `\n-          import { Renderer as RenamedRenderer, Component } from '@angular/core';\n-\n-          @Component({template: ''})\n-          export class MyComp {\n-            constructor(renderer: RenamedRenderer) {}\n-          }\n-        `);\n-\n-      await runMigration();\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`import { Component, Renderer2 as RenamedRenderer } from '@angular/core';`);\n-    });\n-\n-    it('should not change Renderer imports if they are not from @angular/core', async () => {\n-      writeFile('/index.ts', `\n-          import { Component } from '@angular/core';\n-          import { Renderer } from './my-renderer';\n-\n-          @Component({template: ''})\n-          export class MyComp {\n-            constructor(renderer: Renderer) {}\n-          }\n-        `);\n-\n-      await runMigration();\n-      const content = tree.readContent('/index.ts');\n-\n-      expect(content).toContain(`import { Component } from '@angular/core';`);\n-      expect(content).toContain(`import { Renderer } from './my-renderer';`);\n-    });\n-\n-    it('should not change imports if Renderer2 was already imported', async () => {\n-      writeFile('/index.ts', `\n-          import { Renderer, Component, Renderer2 } from '@angular/core';\n-\n-          @Component({template: ''})\n-          export class MyComp {\n-            constructor(renderer: Renderer) {}\n-          }\n-        `);\n-\n-      await runMigration();\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`import { Renderer, Component, Renderer2 } from '@angular/core';`);\n-    });\n-  });\n-\n-  describe('type renaming', () => {\n-    it('should change type of constructor parameter from Renderer to Renderer2', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(element: ElementRef, renderer: Renderer) {}\n-        }\n-      `);\n-\n-      await runMigration();\n-      expect(tree.readContent('/index.ts'))\n-          .toContain('constructor(element: ElementRef, renderer: Renderer2)');\n-    });\n-\n-    it('should change type of method parameter from Renderer to Renderer2', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          disable(renderer: Renderer, element: HTMLElement, isDisabled: boolean) {\n-            renderer.setElementProperty(element, 'disabled', isDisabled);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-      expect(tree.readContent('/index.ts'))\n-          .toContain('disable(renderer: Renderer2, element: HTMLElement, isDisabled: boolean)');\n-    });\n-\n-    it('should change type of property declarations', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          public renderer: Renderer;\n-        }\n-      `);\n-\n-      await runMigration();\n-      expect(tree.readContent('/index.ts')).toContain('public renderer: Renderer2;');\n-    });\n-\n-    it('should change type of properties initialized via the constructor', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(element: ElementRef, private _renderer: Renderer) {}\n-        }\n-      `);\n-\n-      await runMigration();\n-      expect(tree.readContent('/index.ts'))\n-          .toContain('constructor(element: ElementRef, private _renderer: Renderer2)');\n-    });\n-\n-    it('should change the type of something that was cast to Renderer', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          setColor(maybeRenderer: any, element: ElementRef) {\n-            const renderer = maybeRenderer as Renderer;\n-            renderer.setElementStyle(element.nativeElement, 'color', 'red');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-\n-      expect(content).toContain(`const renderer = maybeRenderer as Renderer2;`);\n-      expect(content).toContain(`renderer.setStyle(element.nativeElement, 'color', 'red');`);\n-    });\n-\n-    it('should not rename types called Renderer that do not come from Angular', async () => {\n-      // Write a dummy renderer file so type checking picks it up.\n-      writeFile('/my-renderer.ts', `export abstract class Renderer {}`);\n-\n-      writeFile('/index.ts', `\n-        import { Renderer as ActualAngularRenderer, Component, ElementRef } from '@angular/core';\n-        import { Renderer } from './my-renderer';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(element: ElementRef, renderer: Renderer) {}\n-        }\n-      `);\n-\n-      await runMigration();\n-      expect(tree.readContent('/index.ts'))\n-          .toContain('constructor(element: ElementRef, renderer: Renderer)');\n-    });\n-\n-    it('should rename inside single-line forwardRef', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef, forwardRef, Inject } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(@Inject(forwardRef(() => Renderer)) private _renderer: Renderer) {}\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-\n-      expect(content).toContain(\n-          `constructor(@Inject(forwardRef(() => Renderer2)) private _renderer: Renderer2)`);\n-    });\n-\n-    it('should rename inside multi-line forwardRef', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef, forwardRef, Inject } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(@Inject(forwardRef(() => { return Renderer; })) private _renderer: Renderer) {}\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-\n-      expect(content).toContain(\n-          `constructor(@Inject(forwardRef(() => { return Renderer2; })) private _renderer: Renderer2) {}`);\n-    });\n-  });\n-\n-  describe('helper insertion', () => {\n-    it('should only declare each helper once per file', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {\n-            _renderer.createElement(_element.nativeElement, 'span');\n-            _renderer.createElement(_element.nativeElement, 'button');\n-            _renderer.createElement(_element.nativeElement, 'div');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-\n-      expect(content.match(/function __ngRendererCreateElementHelper\\(/g)!.length)\n-          .toBe(1, 'Expected exactly one helper for createElement.');\n-    });\n-\n-    it('should insert helpers after the user\\'s code', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {\n-            _renderer.createElement(_element.nativeElement, 'span');\n-          }\n-        }\n-\n-        //---\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-      const [contentBeforeSeparator, contentAfterSeparator] = content.split('//---');\n-\n-      expect(contentBeforeSeparator).not.toContain('function __ngRendererCreateElementHelper(');\n-      expect(contentAfterSeparator).toContain('function __ngRendererCreateElementHelper(');\n-    });\n-\n-    it('should be able to handle multiple helpers per file', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {\n-            _renderer.createText(_element.nativeElement, 'hello');\n-            _renderer.createText(_element.nativeElement, 'there');\n-            _renderer.createText(_element.nativeElement, '!');\n-          }\n-\n-          createElements(parent: HTMLElement) {\n-            this._renderer.createElement(parent, 'span');\n-            this._renderer.createElement(parent, 'button');\n-          }\n-\n-          createAnchor() {\n-            this._renderer.createTemplateAnchor(this._element.nativeElement);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-\n-      expect(content.match(/function __ngRendererCreateTextHelper\\(/g)!.length)\n-          .toBe(1, 'Expected exactly one helper for createElement.');\n-      expect(content.match(/function __ngRendererCreateElementHelper\\(/g)!.length)\n-          .toBe(1, 'Expected exactly one helper for createText.');\n-      expect(content.match(/function __ngRendererCreateTemplateAnchorHelper\\(/g)!.length)\n-          .toBe(1, 'Expected exactly one helper for createTemplateAnchor.');\n-    });\n-\n-    it('should create the __ngRendererSplitNamespaceHelper', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(element: ElementRef, renderer: Renderer) {\n-            renderer.createElement(element.nativeElement, 'span');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(stripWhitespace(tree.readContent('/index.ts'))).toContain(stripWhitespace(`\n-        function __ngRendererSplitNamespaceHelper(name: AnyDuringRendererMigration) {\n-          if (name[0] === \":\") {\n-            const match = name.match(/^:([^:]+):(.+)$/);\n-            return [match[1], match[2]];\n-          }\n-          return [\"\", name];\n-        }\n-      `));\n-    });\n-\n-    it('should declare our custom any type', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(element: ElementRef, renderer: Renderer) {\n-            renderer.createElement(element.nativeElement, 'span');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(stripWhitespace(tree.readContent('/index.ts'))).toContain(stripWhitespace(`\n-        type AnyDuringRendererMigration = any;\n-      `));\n-    });\n-  });\n-\n-  describe('setElementProperty migration', () => {\n-    it('should migrate setElementProperty calls', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {}\n-\n-          disable() {\n-            this._renderer.setElementProperty(this._element.nativeElement, 'disabled', true);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`this._renderer.setProperty(this._element.nativeElement, 'disabled', true);`);\n-    });\n-  });\n-\n-  describe('setText migration', () => {\n-    it('should migrate setText calls', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: '<span></span>'})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {}\n-\n-          sayHello() {\n-            this._renderer.setText(this._element.nativeElement.querySelector('span'), 'Hello');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(\n-              `this._renderer.setValue(this._element.nativeElement.querySelector('span'), 'Hello');`);\n-    });\n-  });\n-\n-  describe('listenGlobal migration', () => {\n-    it('should migrate listenGlobal calls', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component } from '@angular/core';\n-\n-        @Component({template: '<span></span>'})\n-        export class MyComp {\n-          constructor(private _renderer: Renderer) {}\n-\n-          listenToResize() {\n-            this._renderer.listenGlobal('window', 'resize', () => console.log('resized'));\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`this._renderer.listen('window', 'resize', () => console.log('resized'));`);\n-    });\n-  });\n-\n-  describe('selectRootElement migration', () => {\n-    it('should migrate selectRootElement calls', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {}\n-\n-          getRootElement() {\n-            return this._renderer.selectRootElement(this._element.nativeElement, {});\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`return this._renderer.selectRootElement(this._element.nativeElement);`);\n-    });\n-  });\n-\n-  describe('setElementClass migration', () => {\n-    it('should migrate calls with inline isAdd value', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {}\n-\n-          addClass(className: string) {\n-            this._renderer.setElementClass(this._element.nativeElement, className, true);\n-          }\n-\n-          removeClass(className: string) {\n-            this._renderer.setElementClass(this._element.nativeElement, className, false);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`this._renderer.addClass(this._element.nativeElement, className);`);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`this._renderer.removeClass(this._element.nativeElement, className);`);\n-    });\n-\n-    it('should migrate calls with variable isAdd value', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {}\n-\n-          toggleClass(className: string, shouldAdd: any) {\n-            this._renderer.setElementClass(this._element.nativeElement, className, shouldAdd);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(\n-              `shouldAdd ? this._renderer.addClass(this._element.nativeElement, className) : ` +\n-              `this._renderer.removeClass(this._element.nativeElement, className);`);\n-    });\n-  });\n-\n-  describe('setElementStyle migration', () => {\n-    it('should migrate calls with two arguments to a removeStyle call', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {}\n-\n-          removeColor() {\n-            this._renderer.setElementStyle(this._element.nativeElement, 'color');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`this._renderer.removeStyle(this._element.nativeElement, 'color');`);\n-    });\n-\n-    it('should migrate calls with static third arguments to a setStyle call', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {}\n-\n-          setStyles(height: number) {\n-            this._renderer.setElementStyle(this._element.nativeElement, 'color', 'red');\n-            this._renderer.setElementStyle(this._element.nativeElement, 'background-color', \\`blue\\`);\n-            this._renderer.setElementStyle(this._element.nativeElement, 'width', 3);\n-            this._renderer.setElementStyle(this._element.nativeElement, 'height', \\`\\${height\\}px\\`);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-      const content = tree.readContent('/index.ts');\n-      expect(content).toContain(\n-          `this._renderer.setStyle(this._element.nativeElement, 'color', 'red');`);\n-      expect(content).toContain(\n-          `this._renderer.setStyle(this._element.nativeElement, 'background-color', \\`blue\\`);`);\n-      expect(content).toContain(\n-          `this._renderer.setStyle(this._element.nativeElement, 'width', 3);`);\n-      expect(content).toContain(\n-          `this._renderer.setStyle(this._element.nativeElement, 'height', \\`\\${height\\}px\\`);`);\n-    });\n-\n-    it('should migrate calls with null or undefined value for last argument to a removeStyle call',\n-       async () => {\n-         writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {}\n-\n-          removeColors() {\n-            this._renderer.setElementStyle(this._element.nativeElement, 'color', null);\n-            this._renderer.setElementStyle(this._element.nativeElement, 'background-color', undefined);\n-          }\n-        }\n-      `);\n-\n-         await runMigration();\n-         expect(tree.readContent('/index.ts'))\n-             .toContain(`this._renderer.removeStyle(this._element.nativeElement, 'color');`);\n-         expect(tree.readContent('/index.ts'))\n-             .toContain(\n-                 `this._renderer.removeStyle(this._element.nativeElement, 'background-color');`);\n-       });\n-\n-    it('should migrate calls with a variable third argument', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {}\n-\n-          setColor(value: string | null) {\n-            this._renderer.setElementStyle(this._element.nativeElement, 'color', value);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(\n-              `value == null ? this._renderer.removeStyle(this._element.nativeElement, 'color') : ` +\n-              `this._renderer.setStyle(this._element.nativeElement, 'color', value);`);\n-    });\n-\n-    it('should migrate calls with a variable third argument whose value can be inferred',\n-       async () => {\n-         writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {}\n-\n-          setColor(color: string, backgroundColor: null, width: number) {\n-            this._renderer.setElementStyle(this._element.nativeElement, 'color', color);\n-            this._renderer.setElementStyle(this._element.nativeElement, 'background-color', backgroundColor);\n-            this._renderer.setElementStyle(this._element.nativeElement, 'width', width + 'px');\n-          }\n-        }\n-      `);\n-\n-         await runMigration();\n-         const content = tree.readContent('/index.ts');\n-         expect(content).toContain(\n-             `this._renderer.setStyle(this._element.nativeElement, 'color', color);`);\n-         expect(content).toContain(\n-             `this._renderer.removeStyle(this._element.nativeElement, 'background-color');`);\n-         expect(content).toContain(\n-             `this._renderer.setStyle(this._element.nativeElement, 'width', width + 'px');`);\n-       });\n-  });\n-\n-  describe('setElementAttribute migration', () => {\n-    it('should migrate to calls to the __ngRendererSetElementAttributeHelper', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {\n-            _renderer.setElementAttribute(_element.nativeElement, 'title', 'hello');\n-          }\n-\n-          removeAttribute(name: string) {\n-            this._renderer.setElementAttribute(this._element.nativeElement, name);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-\n-      expect(content).toContain(\n-          `__ngRendererSetElementAttributeHelper(_renderer, _element.nativeElement, 'title', 'hello');`);\n-      expect(content).toContain(\n-          '__ngRendererSetElementAttributeHelper(this._renderer, this._element.nativeElement, name);');\n-    });\n-\n-    it('should declare the __ngRendererSetElementAttributeHelper', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(element: ElementRef, renderer: Renderer) {\n-            renderer.setElementAttribute(element.nativeElement, 'foo', 'bar');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      const content = stripWhitespace(tree.readContent('/index.ts'));\n-\n-      expect(content).toContain(stripWhitespace(`\n-        function __ngRendererSetElementAttributeHelper(renderer: AnyDuringRendererMigration, element: AnyDuringRendererMigration, namespaceAndName: AnyDuringRendererMigration, value?: AnyDuringRendererMigration) {\n-          const [namespace, name] = __ngRendererSplitNamespaceHelper(namespaceAndName);\n-          if (value != null) {\n-            renderer.setAttribute(element, name, value, namespace);\n-          } else {\n-            renderer.removeAttribute(element, name, namespace);\n-          }\n-        }\n-      `));\n-\n-      expect(content).toContain(stripWhitespace('function __ngRendererSplitNamespaceHelper('));\n-    });\n-  });\n-\n-  describe('invokeElementMethod migration', () => {\n-    it('should migrate calls to a direct method call if the method name and arguments are static',\n-       async () => {\n-         writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {}\n-\n-          focus() {\n-            this._renderer.invokeElementMethod(this._element.nativeElement, 'focus', []);\n-            this._renderer.invokeElementMethod(this._element.nativeElement, 'focusEvenMore');\n-            this._renderer.invokeElementMethod(this._element.nativeElement, 'doSomething', [1, true, 'three']);\n-          }\n-        }\n-      `);\n-\n-         await runMigration();\n-         const content = tree.readContent('/index.ts');\n-         expect(content).not.toContain('this._renderer');\n-         expect(content).toContain(`this._element.nativeElement.focus()`);\n-         expect(content).toContain(`this._element.nativeElement.focusEvenMore()`);\n-         expect(content).toContain(`this._element.nativeElement.doSomething(1, true, 'three')`);\n-       });\n-\n-    it('should migrate calls to a property access if the method name or arguments are dynamic',\n-       async () => {\n-         writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {}\n-\n-          callMethod(name: string, args: any[]) {\n-            this._renderer.invokeElementMethod(this._element.nativeElement, name, [1, true]);\n-          }\n-\n-          callOtherMethod(args: any[]) {\n-            this._renderer.invokeElementMethod(this._element.nativeElement, 'otherMethod', args);\n-          }\n-        }\n-      `);\n-\n-         await runMigration();\n-         const content = tree.readContent('/index.ts');\n-         expect(content).not.toContain('this._renderer');\n-         expect(content).toContain(\n-             `(this._element.nativeElement as any)[name].apply(this._element.nativeElement, [1, true]);`);\n-\n-         expect(content).toContain(\n-             `(this._element.nativeElement as any)['otherMethod'].apply(this._element.nativeElement, args);`);\n-       });\n-\n-    it('should handle calls without an `args` array', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {}\n-\n-          callMethod(name: string) {\n-            this._renderer.invokeElementMethod(this._element.nativeElement, name);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-      const content = tree.readContent('/index.ts');\n-      expect(content).not.toContain('this._renderer');\n-      expect(content).toContain(\n-          `(this._element.nativeElement as any)[name].apply(this._element.nativeElement);`);\n-    });\n-  });\n-\n-  describe('setBindingDebugInfo migration', () => {\n-    it('should drop calls to setBindingDebugInfo', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {}\n-\n-          setInfo() {\n-            this._renderer.setBindingDebugInfo(this._element.nativeElement, 'prop', 'value');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      // Expect the `setInfo` method to only contain whitespace.\n-      expect(tree.readContent('/index.ts')).toMatch(/setInfo\\(\\) \\{\\s+\\}/);\n-    });\n-  });\n-\n-  describe('createViewRoot migration', () => {\n-    it('should replace createViewRoot calls with a reference to the first argument', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {}\n-\n-          createRoot() {\n-            return this._renderer.createViewRoot(this._element.nativeElement);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      // Expect the `createRoot` only to return `this._element.nativeElement`.\n-      expect(tree.readContent('/index.ts'))\n-          .toMatch(/createRoot\\(\\) \\{\\s+return this\\._element\\.nativeElement;\\s+\\}/);\n-    });\n-  });\n-\n-  describe('createElement migration', () => {\n-    it('should migrate to calls to the __ngRendererCreateElementHelper', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {\n-            const message = _renderer.createElement(_element.nativeElement, 'span', {});\n-            message.textContent = 'hello';\n-          }\n-\n-          createAndAppendElement(nodeName: string) {\n-            return this._renderer.createElement(this._element.nativeElement, nodeName);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-\n-      expect(content).toContain(\n-          `const message = __ngRendererCreateElementHelper(_renderer, _element.nativeElement, 'span');`);\n-      expect(content).toContain(\n-          'return __ngRendererCreateElementHelper(this._renderer, this._element.nativeElement, nodeName);');\n-    });\n-\n-    it('should declare the __ngRendererCreateElementHelper', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(element: ElementRef, renderer: Renderer) {\n-            renderer.createElement(element.nativeElement, 'span');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      const content = stripWhitespace(tree.readContent('/index.ts'));\n-\n-      expect(content).toContain(stripWhitespace(`\n-        function __ngRendererCreateElementHelper(renderer: AnyDuringRendererMigration, parent: AnyDuringRendererMigration, namespaceAndName: AnyDuringRendererMigration) {\n-          const [namespace, name] = __ngRendererSplitNamespaceHelper(namespaceAndName);\n-          const node = renderer.createElement(name, namespace);\n-          if (parent) {\n-            renderer.appendChild(parent, node);\n-          }\n-          return node;\n-        }\n-      `));\n-\n-      expect(content).toContain(stripWhitespace('function __ngRendererSplitNamespaceHelper('));\n-    });\n-  });\n-\n-  describe('createText migration', () => {\n-    it('should migrate to calls to the __ngRendererCreateTextHelper', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {\n-            const message = _renderer.createText(_element.nativeElement, 'hello', {});\n-            message.textContent += ' world';\n-          }\n-\n-          createAndAppendText(value: string) {\n-            return this._renderer.createText(this._element.nativeElement, value);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-\n-      expect(content).toContain(\n-          `const message = __ngRendererCreateTextHelper(_renderer, _element.nativeElement, 'hello');`);\n-      expect(content).toContain(\n-          'return __ngRendererCreateTextHelper(this._renderer, this._element.nativeElement, value);');\n-    });\n-\n-    it('should declare the __ngRendererCreateTextHelper', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(element: ElementRef, renderer: Renderer) {\n-            renderer.createText(element.nativeElement, 'hi');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(stripWhitespace(tree.readContent('/index.ts'))).toContain(stripWhitespace(`\n-        function __ngRendererCreateTextHelper(renderer: AnyDuringRendererMigration, parent: AnyDuringRendererMigration, value: AnyDuringRendererMigration) {\n-          const node = renderer.createText(value);\n-          if (parent) {\n-            renderer.appendChild(parent, node);\n-          }\n-          return node;\n-        }\n-      `));\n-    });\n-  });\n-\n-  describe('createTemplateAnchor migration', () => {\n-    it('should migrate to calls to the __ngRendererCreateTemplateAnchorHelper', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {\n-            console.log(_renderer.createTemplateAnchor(_element.nativeElement));\n-          }\n-\n-          createAndAppendAnchor() {\n-            return this._renderer.createTemplateAnchor(this._element.nativeElement);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      const content = tree.readContent('/index.ts');\n-\n-      expect(content).toContain(\n-          `console.log(__ngRendererCreateTemplateAnchorHelper(_renderer, _element.nativeElement));`);\n-      expect(content).toContain(\n-          'return __ngRendererCreateTemplateAnchorHelper(this._renderer, this._element.nativeElement);');\n-    });\n-\n-    it('should declare the __ngRendererCreateTemplateAnchorHelper', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(element: ElementRef, renderer: Renderer) {\n-            renderer.createTemplateAnchor(element.nativeElement);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(stripWhitespace(tree.readContent('/index.ts'))).toContain(stripWhitespace(`\n-        function __ngRendererCreateTemplateAnchorHelper(renderer: AnyDuringRendererMigration, parent: AnyDuringRendererMigration) {\n-          const node = renderer.createComment(\"\");\n-          if (parent) {\n-            renderer.appendChild(parent, node);\n-          }\n-          return node;\n-        }\n-      `));\n-    });\n-  });\n-\n-  describe('projectNodes migration', () => {\n-    it('should migrate to calls to the __ngRendererProjectNodesHelper', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {\n-          }\n-\n-          projectNodes(nodesToProject: Node[]) {\n-            this._renderer.projectNodes(this._element.nativeElement, nodesToProject);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(\n-              '__ngRendererProjectNodesHelper(this._renderer, this._element.nativeElement, nodesToProject);');\n-    });\n-\n-    it('should declare the __ngRendererProjectNodesHelper', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(element: ElementRef, renderer: Renderer) {\n-            renderer.projectNodes(element.nativeElement, []);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(stripWhitespace(tree.readContent('/index.ts'))).toContain(stripWhitespace(`\n-        function __ngRendererProjectNodesHelper(renderer: AnyDuringRendererMigration, parent: AnyDuringRendererMigration, nodes: AnyDuringRendererMigration) {\n-          for (let i = 0; i < nodes.length; i++) {\n-            renderer.appendChild(parent, nodes[i]);\n-          }\n-        }\n-      `));\n-    });\n-  });\n-\n-  describe('animate migration', () => {\n-    it('should migrate to calls to the __ngRendererAnimateHelper', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {\n-          }\n-\n-          animate() {\n-            this._renderer.animate(this._element.nativeElement);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts')).toContain('__ngRendererAnimateHelper();');\n-    });\n-\n-    it('should declare the __ngRendererAnimateHelper', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(element: ElementRef, renderer: Renderer) {\n-            renderer.animate(element.nativeElement);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(stripWhitespace(tree.readContent('/index.ts'))).toContain(stripWhitespace(`\n-        function __ngRendererAnimateHelper() {\n-          throw new Error(\"Renderer.animate is no longer supported!\");\n-        }\n-      `));\n-    });\n-  });\n-\n-  describe('destroyView migration', () => {\n-    it('should migrate to calls to the __ngRendererDestroyViewHelper', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {\n-          }\n-\n-          destroyView(allNodes: Node[]) {\n-            this._renderer.destroyView(this._element.nativeElement, allNodes);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain('__ngRendererDestroyViewHelper(this._renderer, allNodes);');\n-    });\n-\n-    it('should declare the __ngRendererDestroyViewHelper', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {\n-          }\n-\n-          destroyView(allNodes: Node[]) {\n-            this._renderer.destroyView(this._element.nativeElement, allNodes);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(stripWhitespace(tree.readContent('/index.ts'))).toContain(stripWhitespace(`\n-        function __ngRendererDestroyViewHelper(renderer: AnyDuringRendererMigration, allNodes: AnyDuringRendererMigration) {\n-          for (let i = 0; i < allNodes.length; i++) {\n-            renderer.destroyNode(allNodes[i]);\n-          }\n-        }\n-      `));\n-    });\n-  });\n-\n-  describe('detachView migration', () => {\n-    it('should migrate to calls to the __ngRendererDetachViewHelper', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _renderer: Renderer) {\n-          }\n-\n-          detachView(rootNodes: Node[]) {\n-            this._renderer.detachView(rootNodes);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain('__ngRendererDetachViewHelper(this._renderer, rootNodes);');\n-    });\n-\n-    it('should declare the __ngRendererDetachViewHelper', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _renderer: Renderer) {\n-          }\n-\n-          detachView(rootNodes: Node[]) {\n-            this._renderer.detachView(rootNodes);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(stripWhitespace(tree.readContent('/index.ts'))).toContain(stripWhitespace(`\n-        function __ngRendererDetachViewHelper(renderer: AnyDuringRendererMigration, rootNodes: AnyDuringRendererMigration) {\n-          for (let i = 0; i < rootNodes.length; i++) {\n-            const node = rootNodes[i];\n-            renderer.removeChild(renderer.parentNode(node), node);\n-          }\n-        }\n-      `));\n-    });\n-  });\n-\n-  describe('attachViewAfter migration', () => {\n-    it('should migrate to calls to the __ngRendererAttachViewAfterHelper', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component, ElementRef } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _element: ElementRef, private _renderer: Renderer) {\n-          }\n-\n-          attachViewAfter(rootNodes: Node[]) {\n-            this._renderer.attachViewAfter(this._element.nativeElement, rootNodes);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(\n-              '__ngRendererAttachViewAfterHelper(this._renderer, this._element.nativeElement, rootNodes);');\n-    });\n-\n-    it('should declare the __ngRendererAttachViewAfterHelper', async () => {\n-      writeFile('/index.ts', `\n-        import { Renderer, Component } from '@angular/core';\n-\n-        @Component({template: ''})\n-        export class MyComp {\n-          constructor(private _renderer: Renderer) {\n-          }\n-\n-          attachViewAfter(node: Node, rootNodes: Node[]) {\n-            this._renderer.attachViewAfter(node, rootNodes);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(stripWhitespace(tree.readContent('/index.ts'))).toContain(stripWhitespace(`\n-        function __ngRendererAttachViewAfterHelper(renderer: AnyDuringRendererMigration, node: AnyDuringRendererMigration, rootNodes: AnyDuringRendererMigration) {\n-          const parent = renderer.parentNode(node);\n-          const nextSibling = renderer.nextSibling(node);\n-          for (let i = 0; i < rootNodes.length; i++) {\n-            renderer.insertBefore(parent, rootNodes[i], nextSibling);\n-          }\n-        }\n-      `));\n-    });\n-  });\n-\n-  function writeFile(filePath: string, contents: string) {\n-    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n-  }\n-\n-  function runMigration() {\n-    return runner.runSchematicAsync('migration-v9-renderer-to-renderer2', {}, tree).toPromise();\n-  }\n-\n-  function stripWhitespace(contents: string) {\n-    return contents.replace(/\\s/g, '');\n-  }\n-});"
        },
        {
            "sha": "bdb4fbf8f9188a3b048a188859779c0462bccee6",
            "filename": "packages/core/schematics/test/static_queries_migration_template_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 855,
            "changes": 855,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fstatic_queries_migration_template_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fstatic_queries_migration_template_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fstatic_queries_migration_template_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,855 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n-import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n-import {HostTree} from '@angular-devkit/schematics';\n-import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n-import * as shx from 'shelljs';\n-\n-describe('static-queries migration with template strategy', () => {\n-  let runner: SchematicTestRunner;\n-  let host: TempScopedNodeJsSyncHost;\n-  let tree: UnitTestTree;\n-  let tmpDirPath: string;\n-  let previousWorkingDir: string;\n-  let warnOutput: string[];\n-  let errorOutput: string[];\n-\n-  beforeEach(() => {\n-    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n-    host = new TempScopedNodeJsSyncHost();\n-    tree = new UnitTestTree(new HostTree(host));\n-\n-    writeFile('/tsconfig.json', JSON.stringify({\n-      compilerOptions: {\n-        experimentalDecorators: true,\n-        lib: ['es2015'],\n-      },\n-    }));\n-    writeFile('/angular.json', JSON.stringify({\n-      version: 1,\n-      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n-    }));\n-\n-    warnOutput = [];\n-    errorOutput = [];\n-    runner.logger.subscribe(logEntry => {\n-      if (logEntry.level === 'warn') {\n-        warnOutput.push(logEntry.message);\n-      } else if (logEntry.level === 'error') {\n-        errorOutput.push(logEntry.message);\n-      }\n-    });\n-\n-    previousWorkingDir = shx.pwd();\n-    tmpDirPath = getSystemPath(host.root);\n-\n-    // Switch into the temporary directory path. This allows us to run\n-    // the schematic against our custom unit test tree.\n-    shx.cd(tmpDirPath);\n-\n-    writeFakeAngular();\n-  });\n-\n-  afterEach(() => {\n-    shx.cd(previousWorkingDir);\n-    shx.rm('-r', tmpDirPath);\n-  });\n-\n-  function writeFakeAngular() {\n-    writeFile('/node_modules/@angular/core/index.d.ts', ``);\n-  }\n-\n-  function writeFakeLibrary(selectorName = 'my-lib-selector') {\n-    writeFile('/node_modules/my-lib/index.d.ts', `export * from './public-api';`);\n-    writeFile('/node_modules/my-lib/public-api.d.ts', `export declare class MyLibComponent {}`);\n-    writeFile('/node_modules/my-lib/index.metadata.json', JSON.stringify({\n-      __symbolic: 'module',\n-      version: 4,\n-      metadata: {\n-        MyLibComponent: {\n-          __symbolic: 'class',\n-          decorators: [{\n-            __symbolic: 'call',\n-            expression: {\n-              __symbolic: 'reference',\n-              module: '@angular/core',\n-              name: 'Component',\n-              line: 0,\n-              character: 0\n-            },\n-            arguments: [{\n-              selector: selectorName,\n-              template: `<span>My Lib Component</span>`,\n-            }]\n-          }],\n-          members: {}\n-        },\n-      },\n-      origins: {\n-        MyLibComponent: './public-api',\n-      },\n-      importAs: 'my-lib',\n-    }));\n-  }\n-\n-  function writeFile(filePath: string, contents: string) {\n-    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n-  }\n-\n-  function runMigration() {\n-    return runner.runSchematicAsync('migration-v8-static-queries', {}, tree).toPromise();\n-  }\n-\n-  describe('ViewChild', () => {\n-    it('should detect queries selecting elements through template reference', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, NgModule, ViewChild} from '@angular/core';\n-\n-        @Component({template: \\`\n-          <ng-template>\n-            <button #myButton>My Button</button>\n-          </ng-template>\n-          <div>\n-            <button #myStaticButton>Button outside ng-template</button>\n-          </div>\n-        \\`})\n-        export class MyComp {\n-          private @ViewChild('myButton') query: any;\n-          private @ViewChild('myStaticButton') query2: any;\n-        }\n-\n-        @NgModule({declarations: [MyComp]})\n-        export class MyModule {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ViewChild('myButton', { static: false }) query: any;`);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ViewChild('myStaticButton', { static: true }) query2: any;`);\n-    });\n-\n-    it('should detect queries selecting ng-template as static', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, NgModule, ViewChild} from '@angular/core';\n-\n-        @Component({template: \\`\n-          <ng-template #myTmpl>\n-            My template\n-          </ng-template>\n-        \\`})\n-        export class MyComp {\n-          private @ViewChild('myTmpl') query: any;\n-        }\n-\n-        @NgModule({declarations: [MyComp]})\n-        export class MyModule {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ViewChild('myTmpl', { static: true }) query: any;`);\n-    });\n-\n-    it('should detect queries selecting ng-template as static (BOM)', async () => {\n-      writeFile('/index.ts', `\\uFEFF\n-        import {Component, NgModule, ViewChild} from '@angular/core';\n-\n-        @Component({template: \\`\n-          <ng-template #myTmpl>\n-            My template\n-          </ng-template>\n-        \\`})\n-        export class MyComp {\n-          private @ViewChild('myTmpl') query: any;\n-        }\n-\n-        @NgModule({declarations: [MyComp]})\n-        export class MyModule {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ViewChild('myTmpl', { static: true }) query: any;`);\n-    });\n-\n-    it('should detect queries selecting component view providers through string token',\n-       async () => {\n-         writeFile('/index.ts', `\n-        import {Component, Directive, NgModule, ViewChild} from '@angular/core';\n-\n-        @Directive({\n-          selector: '[myDirective]',\n-          providers: [\n-            {provide: 'my-token', useValue: 'test'}\n-          ]\n-        })\n-        export class MyDirective {}\n-\n-        @Directive({\n-          selector: '[myDirective2]',\n-          providers: [\n-            {provide: 'my-token-2', useValue: 'test'}\n-          ]\n-        })\n-        export class MyDirective2 {}\n-\n-        @Component({templateUrl: './my-tmpl.html'})\n-        export class MyComp {\n-          private @ViewChild('my-token') query: any;\n-          private @ViewChild('my-token-2') query2: any;\n-        }\n-\n-        @NgModule({declarations: [MyComp, MyDirective, MyDirective2]})\n-        export class MyModule {}\n-      `);\n-\n-         writeFile(`/my-tmpl.html`, `\n-        <span myDirective></span>\n-        <ng-template>\n-          <span myDirective2></span>\n-        </ng-template>\n-      `);\n-\n-         await runMigration();\n-\n-         expect(tree.readContent('/index.ts'))\n-             .toContain(`@ViewChild('my-token', { static: true }) query: any;`);\n-         expect(tree.readContent('/index.ts'))\n-             .toContain(`@ViewChild('my-token-2', { static: false }) query2: any;`);\n-       });\n-\n-    it('should detect queries selecting component view providers using class token', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, Directive, NgModule, ViewChild} from '@angular/core';\n-\n-        export class MyService {}\n-        export class MyService2 {}\n-\n-        @Directive({\n-          selector: '[myDirective]',\n-          providers: [MyService]\n-        })\n-        export class MyDirective {}\n-\n-        @Directive({\n-          selector: '[myDirective2]',\n-          providers: [MyService2]\n-        })\n-        export class MyDirective2 {}\n-\n-        @Component({templateUrl: './my-tmpl.html'})\n-        export class MyComp {\n-          private @ViewChild(MyService) query: any;\n-          private @ViewChild(MyService2) query2: any;\n-        }\n-\n-        @NgModule({declarations: [MyComp, MyDirective, MyDirective2]})\n-        export class MyModule {}\n-      `);\n-\n-      writeFile(`/my-tmpl.html`, `\n-        <span myDirective></span>\n-        <ng-template>\n-          <span myDirective2></span>\n-        </ng-template>\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ViewChild(MyService, { static: true }) query: any;`);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ViewChild(MyService2, { static: false }) query2: any;`);\n-    });\n-\n-    it('should detect queries selecting component', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, NgModule, ViewChild} from '@angular/core';\n-        import {HomeComponent, HomeComponent2} from './home-comp';\n-\n-        @Component({\n-          template: \\`\n-            <home-comp></home-comp>\n-            <ng-template>\n-              <home-comp2></home-comp2>\n-            </ng-template>\n-          \\`\n-        })\n-        export class MyComp {\n-          private @ViewChild(HomeComponent) query: any;\n-          private @ViewChild(HomeComponent2) query2: any;\n-        }\n-\n-        @NgModule({declarations: [MyComp, HomeComponent, HomeComponent2]})\n-        export class MyModule {}\n-      `);\n-\n-      writeFile(`/home-comp.ts`, `\n-        import {Component} from '@angular/core';\n-\n-        @Component({\n-          selector: 'home-comp',\n-          template: '<span>Home</span>'\n-        })\n-        export class HomeComponent {}\n-\n-        @Component({\n-          selector: 'home-comp2',\n-          template: '<span>Home 2</span>'\n-        })\n-        export class HomeComponent2 {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ViewChild(HomeComponent, { static: true }) query: any;`);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ViewChild(HomeComponent2, { static: false }) query2: any;`);\n-    });\n-\n-    it('should detect queries selecting third-party component', async () => {\n-      writeFakeLibrary();\n-      writeFile('/index.ts', `\n-        import {Component, NgModule, ViewChild} from '@angular/core';\n-        import {MyLibComponent} from 'my-lib';\n-\n-        @Component({templateUrl: './my-tmpl.html'})\n-        export class MyComp {\n-          private @ViewChild(MyLibComponent) query: any;\n-        }\n-\n-        @NgModule({declarations: [MyComp, MyLibComponent]})\n-        export class MyModule {}\n-      `);\n-\n-      writeFile('/my-tmpl.html', `\n-        <my-lib-selector>My projected content</my-lib-selector>\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ViewChild(MyLibComponent, { static: true }) query: any;`);\n-    });\n-\n-    it('should detect queries selecting third-party component with multiple selectors',\n-       async () => {\n-         writeFakeLibrary('a-selector, test-selector');\n-         writeFile('/index.ts', `\n-        import {Component, NgModule, ViewChild} from '@angular/core';\n-        import {MyLibComponent} from 'my-lib';\n-\n-        @Component({templateUrl: './my-tmpl.html'})\n-        export class MyComp {\n-          private @ViewChild(MyLibComponent) query: any;\n-        }\n-\n-        @NgModule({declarations: [MyComp, MyLibComponent]})\n-        export class MyModule {}\n-      `);\n-\n-         writeFile('/my-tmpl.html', `\n-        <a-selector>Match 1</a-selector>\n-        <ng-template>\n-          <test-selector>Match 2</test-selector>\n-        </ng-template>\n-      `);\n-\n-         await runMigration();\n-\n-         expect(tree.readContent('/index.ts'))\n-             .toContain(`@ViewChild(MyLibComponent, { static: false }) query: any;`);\n-       });\n-\n-    it('should detect queries within structural directive', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, Directive, NgModule, ViewChild} from '@angular/core';\n-\n-        @Directive({selector: '[ngIf]'})\n-        export class FakeNgIf {}\n-\n-        @Component({templateUrl: 'my-tmpl.html'})\n-        export class MyComp {\n-          private @ViewChild('myRef') query: any;\n-          private @ViewChild('myRef2') query2: any;\n-        }\n-\n-        @NgModule({declarations: [MyComp, FakeNgIf]})\n-        export class MyModule {}\n-      `);\n-\n-      writeFile(`/my-tmpl.html`, `\n-        <span ngIf #myRef>No asterisk</span>\n-        <span *ngIf #myRef2>With asterisk</span>\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ViewChild('myRef', { static: true }) query: any;`);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ViewChild('myRef2', { static: false }) query2: any;`);\n-    });\n-\n-    it('should detect inherited queries', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, NgModule, ViewChild} from '@angular/core';\n-\n-        export class BaseClass {\n-          @ViewChild('myRef') query: any;\n-        }\n-\n-        @Component({templateUrl: 'my-tmpl.html'})\n-        export class MyComp extends BaseClass {}\n-\n-        @NgModule({declarations: [MyComp]})\n-        export class MyModule {}\n-      `);\n-\n-      writeFile(`/my-tmpl.html`, `\n-          <span #myRef>My Ref</span>\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ViewChild('myRef', { static: true }) query: any;`);\n-    });\n-\n-    it('should detect queries declared on setter', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, NgModule, ViewChild} from '@angular/core';\n-\n-        @Component({templateUrl: 'my-tmpl.html'})\n-        export class MyComp {\n-          @ViewChild('myRef')\n-          set query(result: any) { /* noop */}\n-        }\n-\n-        @NgModule({declarations: [MyComp]})\n-        export class MyModule {}\n-      `);\n-\n-      writeFile(`/my-tmpl.html`, `\n-        <span #myRef>My Ref</span>\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toMatch(/@ViewChild\\('myRef', { static: true }\\)\\s+set query/);\n-    });\n-\n-    it('should detect queries declared on getter', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, NgModule, ViewChild} from '@angular/core';\n-\n-        @Component({templateUrl: 'my-tmpl.html'})\n-        export class MyComp {\n-          @ViewChild('myRef')\n-          get query() { return null; }\n-          set query(result: any) { /* noop */}\n-        }\n-\n-        @NgModule({declarations: [MyComp]})\n-        export class MyModule {}\n-      `);\n-\n-      writeFile(`/my-tmpl.html`, `\n-        <span #myRef>My Ref</span>\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toMatch(/@ViewChild\\('myRef', { static: true }\\)\\s+get query/);\n-    });\n-\n-    it('should add a todo if a query is not declared in any component', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, NgModule, ViewChild, SomeToken} from '@angular/core';\n-\n-        export class NotAComponent {\n-          @ViewChild('myRef', {read: SomeToken}) query: any;\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(\n-              `@ViewChild('myRef', /* TODO: add static flag */ { read: SomeToken }) query: any;`);\n-      expect(warnOutput.length).toBe(1);\n-      expect(warnOutput[0])\n-          .toMatch(\n-              /^ {3}index.ts@5:11:.+could not be determined.+not declared in any component/);\n-    });\n-\n-    it('should add a todo if a query is used multiple times with different timing', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, NgModule, ViewChild} from '@angular/core';\n-\n-        export class BaseClass {\n-          @ViewChild('myRef') query: any;\n-        }\n-\n-        @Component({template: '<ng-template><p #myRef></p></ng-template>'})\n-        export class FirstComp extends BaseClass {}\n-\n-        @Component({template: '<span #myRef></span>'})\n-        export class SecondComp extends BaseClass {}\n-\n-        @NgModule({declarations: [FirstComp, SecondComp]})\n-        export class MyModule {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ViewChild('myRef', /* TODO: add static flag */ {}) query: any;`);\n-      expect(warnOutput.length).toBe(1);\n-      expect(warnOutput[0])\n-          .toMatch(\n-              /^ {3}index.ts@5:11: Multiple components use the query with different timings./);\n-    });\n-\n-    it('should be able to migrate an application with type checking failure which ' +\n-           'does not affect analysis',\n-       async () => {\n-         // Fakes the `@angular/package` by creating a `ViewChild` decorator\n-         // function that requires developers to specify the \"static\" flag.\n-         writeFile('/node_modules/@angular/core/index.d.ts', `\n-           export interface ViewChildDecorator {\n-             (selector: Type<any> | Function | string, opts: {\n-               static: boolean;\n-               read?: any;\n-             }): any;\n-           }\n-\n-           export declare const ViewChild: ViewChildDecorator;\n-         `);\n-\n-         writeFile('/index.ts', `\n-           import {NgModule, Component, ViewChild} from '@angular/core';\n-\n-           @Component({\n-             template: '<ng-template><p #myRef></p></ng-template>'\n-           })\n-           export class MyComp {\n-             @ViewChild('myRef') query: any;\n-           }\n-         `);\n-\n-         writeFile('/my-module.ts', `\n-           import {NgModule} from '@angular/core';\n-           import {MyComp} from './index';\n-\n-           @NgModule({declarations: [MyComp]})\n-           export class MyModule {}\n-         `);\n-\n-         await runMigration();\n-\n-         expect(errorOutput.length).toBe(0);\n-         expect(tree.readContent('/index.ts'))\n-             .toContain(`@ViewChild('myRef', { static: false }) query: any;`);\n-       });\n-\n-    it('should be able to migrate applications with template type checking failure ' +\n-           'which does not affect analysis',\n-       async () => {\n-         writeFile('/index.ts', `\n-           import {NgModule, Component, ViewChild} from '@angular/core';\n-\n-           @Component({\n-             template: '<p #myRef>{{myVar.hello()}}</p>'\n-           })\n-           export class MyComp {\n-             // This causes a type checking exception as the template\n-             // tries to call a function called \"hello()\" on this variable.\n-             myVar: boolean = false;\n-\n-             @ViewChild('myRef') query: any;\n-           }\n-         `);\n-\n-         writeFile('/my-module.ts', `\n-           import {NgModule} from '@angular/core';\n-           import {MyComp} from './index';\n-\n-           @NgModule({declarations: [MyComp]})\n-           export class MyModule {}\n-         `);\n-\n-         await runMigration();\n-\n-         expect(errorOutput.length).toBe(0);\n-         expect(tree.readContent('/index.ts'))\n-             .toContain(`@ViewChild('myRef', { static: true }) query: any;`);\n-       });\n-\n-    it('should notify user if project has syntax errors which can affect analysis', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ViewChild} from '@angular/core';\n-\n-        @Component({\n-          template: '<p #myRef></p>'\n-        })\n-        export class MyComp {\n-          @ViewChild('myRef') query: any;\n-        }\n-      `);\n-\n-      writeFile('/file-with-syntax-error.ts', `\n-        export classX ClassWithSyntaxError {\n-          // ...\n-        }\n-      `);\n-\n-      writeFile('/my-module.ts', `\n-        import {NgModule} from '@angular/core';\n-        import {MyComp} from './index';\n-\n-        @NgModule({declarations: [MyComp]})\n-        export class MyModule {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(errorOutput.length).toBe(1);\n-      expect(errorOutput[0]).toMatch(/file-with-syntax-error\\.ts\\(2,9\\): error TS1128.*/);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ViewChild('myRef', { static: true }) query: any;`);\n-    });\n-\n-    it('should gracefully exit migration if queries could not be analyzed', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ViewChild} from '@angular/core';\n-\n-        @Component({template: '<ng-template><p #myRef></p></ng-template>'})\n-        export class MyComp {\n-          @ViewChild('myRef') query: any;\n-        }\n-\n-        // **NOTE**: Analysis will fail as there is no \"NgModule\" that declares the component.\n-      `);\n-\n-      // We don't expect an error to be thrown as this could interrupt other\n-      // migrations which are scheduled with \"ng update\" in the CLI.\n-      await runMigration();\n-\n-      expect(errorOutput.length).toBe(1);\n-      expect(errorOutput[0]).toMatch(/Cannot determine the module for class MyComp/);\n-    });\n-\n-    it('should gracefully exit migration if AOT compiler throws exception', async () => {\n-      writeFile('/my-component.ts', `\n-        import {Component, ViewChild} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @ViewChild('test') query: any;\n-        }\n-      `);\n-      writeFile('/app-module.ts', `\n-        import {NgModule} from '@angular/core';\n-        import {MyComp} from './components';\n-\n-        @NgModule({declarations: [MyComp]})\n-        export class MyModule {}\n-      `);\n-\n-      writeFile('/components.ts', `export * from './my-component';`);\n-      writeFile('/index.ts', `export * from './app-module';`);\n-\n-      // Enable flat-module bundling in order to simulate a common AOT compiler\n-      // failure that can happen in CLI projects that use flat-module bundling\n-      // e.g. with ng-packagr. https://github.com/angular/angular/issues/20931\n-      writeFile('/tsconfig.json', JSON.stringify({\n-        compilerOptions: {\n-          experimentalDecorators: true,\n-          lib: ['es2015'],\n-        },\n-        angularCompilerOptions: {\n-          flatModuleId: 'flat-module',\n-          flatModuleOutFile: 'flat-module-bundle.js',\n-        },\n-        files: ['index.ts']\n-      }));\n-\n-      await runMigration();\n-\n-      expect(errorOutput.length).toBe(1);\n-      expect(errorOutput[0]).toMatch(/^TypeError: Cannot read property 'module' of undefined/);\n-    });\n-\n-    it('should add a todo for content queries which are not detectable', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, NgModule, ContentChild} from '@angular/core';\n-\n-        @Component({template: '<p #myRef></p>'})\n-        export class MyComp {\n-          @ContentChild('myRef') query: any;\n-        }\n-\n-        @NgModule({declarations: [MyComp]})\n-        export class MyModule {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ContentChild('myRef', /* TODO: add static flag */ {}) query: any;`);\n-      expect(warnOutput.length).toBe(1);\n-      expect(warnOutput[0])\n-          .toMatch(/^ {3}index.ts@6:11: Content queries cannot be migrated automatically\\./);\n-    });\n-\n-    it('should add a todo if query options cannot be migrated inline', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, NgModule, ViewChild} from '@angular/core';\n-\n-        const myOptionsVar = {};\n-\n-        @Component({template: '<p #myRef></p>'})\n-        export class MyComp {\n-          @ViewChild('myRef', myOptionsVar) query: any;\n-        }\n-\n-        @NgModule({declarations: [MyComp]})\n-        export class MyModule {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ViewChild('myRef', /* TODO: add static flag */ myOptionsVar) query: any;`);\n-      expect(warnOutput.length).toBe(1);\n-      expect(warnOutput[0])\n-          .toMatch(/^ {3}index.ts@8:11: Cannot update query to set explicit timing./);\n-      expect(warnOutput[0]).toMatch(/Please manually set the query timing to.*static: true/);\n-    });\n-\n-    it('should not normalize stylesheets which are referenced in component', async () => {\n-      writeFile('sub_dir/index.ts', `\n-        import {Component, NgModule, ContentChild} from '@angular/core';\n-\n-        @Component({\n-          template: '<p #myRef></p>',\n-          styleUrls: ['./my-comp.scss']\n-        })\n-        export class MyComp {}\n-\n-        @NgModule({declarations: [MyComp]})\n-        export class MyModule {}\n-      `);\n-\n-      // In order to check that the stylesheet is not normalized, we add an \"@import\" statement\n-      // that would be extracted by the \"DirectiveNormalizer\" and fail because the URL resolver\n-      // is not able to resolve the \"../shared\" relative import to the SCSS file extension.\n-      writeFile('/sub_dir/my-comp.scss', `@import '../shared'`);\n-      writeFile('/shared.scss', `shared {}`);\n-\n-      spyOn(console, 'error').and.callThrough();\n-\n-      await runMigration();\n-\n-      expect(console.error).toHaveBeenCalledTimes(0);\n-    });\n-\n-    it('should always use the test migration strategy for test tsconfig files', async () => {\n-      writeFile('/src/tsconfig.spec.json', JSON.stringify({\n-        compilerOptions: {\n-          experimentalDecorators: true,\n-          lib: ['es2015'],\n-        },\n-        files: [\n-          'test.ts',\n-        ],\n-      }));\n-\n-      writeFile('/src/test.ts', `\n-        import {ViewChild} from '@angular/core';\n-        import {AppComponent} from './app.component';\n-\n-        @Component({template: '<span #test>Test</span>'})\n-        class MyTestComponent {\n-          @ViewChild('test') query: any;\n-        }\n-      `);\n-\n-      writeFile('/src/app.component.ts', `\n-        import {Component, ViewChild} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class AppComponent {\n-          @ViewChild('test') query: any;\n-        }\n-      `);\n-\n-      writeFile('/src/app.module.ts', `\n-        import {NgModule} from '@angular/core';\n-        import {AppComponent} from './app.component';\n-\n-        @NgModule({declarations: [AppComponent]})\n-        export class MyModule {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(errorOutput.length).toBe(0);\n-      expect(tree.readContent('/src/test.ts'))\n-          .toContain(`@ViewChild('test', /* TODO: add static flag */ {}) query: any;`);\n-      expect(tree.readContent('/src/app.component.ts'))\n-          .toContain(`@ViewChild('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should not fall back to test strategy if selected strategy fails', async () => {\n-      writeFile('/src/tsconfig.spec.json', JSON.stringify({\n-        compilerOptions: {\n-          experimentalDecorators: true,\n-          lib: ['es2015'],\n-        },\n-        files: [\n-          'test.ts',\n-        ],\n-      }));\n-\n-      writeFile('/src/test.ts', `import * as mod from './app.module';`);\n-      writeFile('/src/app.component.ts', `\n-        import {Component, ViewChild} from '@angular/core';\n-\n-        @Component({template: '<span #test>Test</span>'})\n-        export class AppComponent {\n-          @ViewChild('test') query: any;\n-        }\n-      `);\n-\n-      writeFile('/src/app.module.ts', `\n-        import {NgModule} from '@angular/core';\n-        import {AppComponent} from './app.component';\n-\n-        @NgModule({declarations: [AppComponent, ThisCausesAnError]})\n-        export class MyModule {}\n-      `);\n-\n-      await runMigration();\n-\n-      expect(errorOutput.length).toBe(1);\n-      expect(errorOutput[0]).toMatch(/Unexpected value 'undefined'/);\n-      expect(tree.readContent('/src/app.component.ts')).toContain(`@ViewChild('test') query: any;`);\n-    });\n-  });\n-});"
        },
        {
            "sha": "e11e602f58b54c7a14e742ee8613556f5c44172c",
            "filename": "packages/core/schematics/test/static_queries_migration_usage_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 1559,
            "changes": 1559,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fstatic_queries_migration_usage_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fstatic_queries_migration_usage_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fstatic_queries_migration_usage_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,1559 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n-import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n-import {HostTree} from '@angular-devkit/schematics';\n-import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n-import * as shx from 'shelljs';\n-\n-describe('static-queries migration with usage strategy', () => {\n-  let runner: SchematicTestRunner;\n-  let host: TempScopedNodeJsSyncHost;\n-  let tree: UnitTestTree;\n-  let tmpDirPath: string;\n-  let previousWorkingDir: string;\n-  let warnOutput: string[] = [];\n-\n-  // Enables the query usage strategy when running the `static-query` migration. By\n-  // default the schematic runs the template strategy and there is currently no easy\n-  // way to pass options to the migration without using environment variables.\n-  beforeAll(() => process.env['NG_STATIC_QUERY_USAGE_STRATEGY'] = 'true');\n-  afterAll(() => process.env['NG_STATIC_QUERY_USAGE_STRATEGY'] = '');\n-\n-  beforeEach(() => {\n-    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n-    host = new TempScopedNodeJsSyncHost();\n-    tree = new UnitTestTree(new HostTree(host));\n-\n-    writeFile('/tsconfig.json', JSON.stringify({\n-      compilerOptions: {\n-        lib: ['es2015'],\n-      },\n-    }));\n-    writeFile('/angular.json', JSON.stringify({\n-      version: 1,\n-      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n-    }));\n-\n-    warnOutput = [];\n-    runner.logger.subscribe(logEntry => {\n-      if (logEntry.level === 'warn') {\n-        warnOutput.push(logEntry.message);\n-      }\n-    });\n-\n-    previousWorkingDir = shx.pwd();\n-    tmpDirPath = getSystemPath(host.root);\n-\n-    // Switch into the temporary directory path. This allows us to run\n-    // the schematic against our custom unit test tree.\n-    shx.cd(tmpDirPath);\n-  });\n-\n-  afterEach(() => {\n-    shx.cd(previousWorkingDir);\n-    shx.rm('-r', tmpDirPath);\n-  });\n-\n-  describe('ViewChild', () => {\n-    createQueryTests('ViewChild');\n-\n-    it('should mark view queries used in \"ngAfterContentInit\" as static', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ViewChild} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @ViewChild('test') query: any;\n-\n-          ngAfterContentInit() {\n-            this.query.classList.add('test');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ViewChild('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should mark view queries used in \"ngAfterContentChecked\" as static', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ViewChild} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @ViewChild('test') query: any;\n-\n-          ngAfterContentChecked() {\n-            this.query.classList.add('test');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ViewChild('test', { static: true }) query: any;`);\n-    });\n-  });\n-\n-  describe('ContentChild', () => {\n-    createQueryTests('ContentChild');\n-\n-    it('should not mark content queries used in \"ngAfterContentInit\" as static', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ContentChild} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @ContentChild('test') query: any;\n-\n-          ngAfterContentInit() {\n-            this.query.classList.add('test');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ContentChild('test', { static: false }) query: any;`);\n-    });\n-\n-    it('should not mark content queries used in \"ngAfterContentInit\" as static (BOM)', async () => {\n-      writeFile('/index.ts', `\\uFEFF\n-        import {Component, ContentChild} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @ContentChild('test') query: any;\n-\n-          ngAfterContentInit() {\n-            this.query.classList.add('test');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ContentChild('test', { static: false }) query: any;`);\n-    });\n-\n-    it('should not mark content queries used in \"ngAfterContentChecked\" as static', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ContentChild} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @ContentChild('test') query: any;\n-\n-          ngAfterContentChecked() {\n-            this.query.classList.add('test');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@ContentChild('test', { static: false }) query: any;`);\n-    });\n-  });\n-\n-  function writeFile(filePath: string, contents: string) {\n-    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n-  }\n-\n-  function runMigration() {\n-    return runner.runSchematicAsync('migration-v8-static-queries', {}, tree).toPromise();\n-  }\n-\n-  function createQueryTests(queryType: 'ViewChild'|'ContentChild') {\n-    it('should mark queries as dynamic', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @${queryType}('test') unused: any;\n-          @${queryType}('dynamic') dynamic: any;\n-\n-          onClick() {\n-            this.dynamicQuery.classList.add('test');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: false }) unused: any;`);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('dynamic', { static: false }) dynamic: any`);\n-    });\n-\n-    it('should mark queries used in \"ngOnChanges\" as static', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @${queryType}('test') query: any;\n-\n-          ngOnChanges() {\n-            this.query.classList.add('test');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should mark queries used in \"ngOnInit\" as static', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @${queryType}('test') query: any;\n-\n-          ngOnInit() {\n-            this.query.classList.add('test');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should mark queries used in \"ngDoCheck\" as static', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @${queryType}('test') query: any;\n-\n-          ngDoCheck() {\n-            this.query.classList.add('test');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should keep existing query options when updating timing', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @${queryType}('test', { /* test */ read: null }) query: any;\n-\n-          ngOnInit() {\n-            this.query.classList.add('test');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { /* test */ read: null, static: true }) query: any;`);\n-    });\n-\n-    it('should add a todo for queries declared on setter', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @${queryType}('test')\n-          set query(result: any) {};\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', /* TODO: add static flag */ {})`);\n-      expect(warnOutput.length).toBe(1);\n-      expect(warnOutput[0])\n-          .toMatch(/index.ts@6:11: Queries defined on accessors cannot be analyzed.$/);\n-    });\n-\n-    it('should add a todo for queries declared on getter', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @${queryType}('test')\n-          get query() { return null; }\n-          set query(result: any) {}\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', /* TODO: add static flag */ {})`);\n-      expect(warnOutput.length).toBe(1);\n-      expect(warnOutput[0])\n-          .toMatch(/index.ts@6:11: Queries defined on accessors cannot be analyzed.$/);\n-    });\n-\n-    it('should not overwrite existing explicit query timing', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @${queryType}('test', {static: /* untouched */ someVal}) query: any;\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', {static: /* untouched */ someVal}) query: any;`);\n-    });\n-\n-    it('should detect queries used in deep method chain', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          // We intentionally add this comma for the second parameter in order\n-          // to ensure that the migration does not incorrectly create an invalid\n-          // decorator call with three parameters. e.g. \"ViewQuery('test', {...}, )\"\n-          @${queryType}('test', ) query: any;\n-\n-          ngOnInit() {\n-            this.a();\n-          }\n-\n-          a() {\n-            this.b();\n-          }\n-\n-          b() {\n-            this.c();\n-          }\n-\n-          c() {\n-            console.log(this.query);\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should properly exit if recursive function is analyzed', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @${queryType}('test') query: any;\n-\n-          ngOnInit() {\n-            this.recursive();\n-          }\n-\n-          recursive() {\n-            this.recursive();\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: false }) query: any;`);\n-    });\n-\n-    it('should detect queries used in newly instantiated classes', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @${queryType}('test') query: any;\n-          @${queryType}('test') query2: any;\n-\n-          ngOnInit() {\n-            new A(this);\n-\n-            new class Inline {\n-              constructor(private ctx: MyComp) {\n-                this.a();\n-              }\n-\n-              a() {\n-                this.ctx.query2.useStatically();\n-              }\n-            }(this);\n-          }\n-        }\n-\n-        export class A {\n-          constructor(ctx: MyComp) {\n-            ctx.query.test();\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query2: any;`);\n-    });\n-\n-    it('should detect queries used in parenthesized new expressions', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @${queryType}('test') query: any;\n-\n-          ngOnInit() {\n-            new ((A))(this);\n-          }\n-        }\n-\n-        export class A {\n-          constructor(ctx: MyComp) {\n-            ctx.query.test();\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should detect queries in lifecycle hook with string literal name', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @${queryType}('test') query: any;\n-\n-          'ngOnInit'() {\n-            this.query.test();\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should detect static queries within nested inheritance', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @${queryType}('test') query: any;\n-        }\n-\n-        export class A extends MyComp {}\n-        export class B extends A {\n-\n-          ngOnInit() {\n-            this.query.testFn();\n-          }\n-\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should detect static queries used within input setters', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, Input, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @${queryType}('test') query: any;\n-\n-          @Input()\n-          get myVal() { return null; }\n-          set myVal(newVal: any) {\n-            this.query.classList.add('setter');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should detect inputs defined in metadata', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({\n-          template: '<span #test></span>',\n-          inputs: [\"myVal\"],\n-        })\n-        export class MyComp {\n-          @${queryType}('test') query: any;\n-\n-          // We don't use the input decorator here as we want to verify\n-          // that it properly detects the input through the component metadata.\n-          get myVal() { return null; }\n-          set myVal(newVal: any) {\n-            this.query.classList.add('setter');\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should detect aliased inputs declared in metadata', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({\n-          template: '<span #test></span>',\n-          inputs: ['prop: publicName'],\n-        })\n-        export class MyComp {\n-          @${queryType}('test') query: any;\n-\n-          set prop(val: any) {\n-            this.query.test();\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should not mark query as static if query is used in non-input setter', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @${queryType}('test') query: any;\n-\n-          set myProperty(val: any) {\n-            this.query.test();\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: false }) query: any;`);\n-    });\n-\n-    it('should detect input decorator on setter', async () => {\n-      writeFile('/index.ts', `\n-        import {Input, Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @${queryType}('test') query: any;\n-\n-          get myProperty() { return null; }\n-\n-          // Usually the decorator is set on the get accessor, but it's also possible\n-          // to declare the input on the setter. This ensures that it is handled properly.\n-          @Input()\n-          set myProperty(val: any) {\n-            this.query.test();\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should detect setter inputs in derived classes', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({\n-          template: '<span #test></span>',\n-          inputs: ['childSetter'],\n-        })\n-        export class MyComp {\n-          protected @${queryType}('test') query: any;\n-        }\n-\n-        export class B extends MyComp {\n-          set childSetter(newVal: any) {\n-            this.query.test();\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should properly detect static query in external derived class', async () => {\n-      writeFile('/src/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @${queryType}('test') query: any;\n-        }\n-      `);\n-\n-      writeFile('/src/external.ts', `\n-        import {MyComp} from './index';\n-\n-        export class ExternalComp extends MyComp {\n-          ngOnInit() {\n-            this.query.test();\n-          }\n-        }\n-      `);\n-\n-      // Move the tsconfig into a subdirectory. This ensures that the update is properly\n-      // recorded for TypeScript projects not at the schematic tree root.\n-      host.sync.rename(normalize('/tsconfig.json'), normalize('/src/tsconfig.json'));\n-      writeFile('/angular.json', JSON.stringify({\n-        version: 1,\n-        projects: {t: {architect: {build: {options: {tsConfig: './src/tsconfig.json'}}}}}\n-      }));\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/src/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should not mark queries used in promises as static', async () => {\n-      writeFile('/es2015.dom.d.ts', `\n-        interface PromiseConstructor {\n-          resolve(): Promise<unknown>;\n-          reject(): Promise<unknown>;\n-        }\n-\n-        interface Promise {\n-          then(cb: Function): Promise<unknown>;\n-          catch(cb: Function): Promise<unknown>;\n-        }\n-\n-        declare var Promise: PromiseConstructor;\n-      `);\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          private @${queryType}('test') query: any;\n-          private @${queryType}('test') query2: any;\n-\n-          ngOnInit() {\n-            const a = Promise.resolve();\n-\n-            Promise.resolve().then(() => {\n-              this.query.doSomething();\n-            });\n-\n-            Promise.reject().catch(() => {\n-              this.query.doSomething();\n-            });\n-\n-            a.then(() => {}).then(() => {\n-              this.query.doSomething();\n-            });\n-\n-            Promise.resolve().then(this.createPromiseCb());\n-          }\n-\n-          createPromiseCb() {\n-            this.query2.doSomething();\n-            return () => { /* empty callback */}\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: false }) query: any;`);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query2: any;`);\n-    });\n-\n-    it('should handle function callbacks which statically access queries', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          private @${queryType}('test') query: any;\n-\n-          ngOnInit() {\n-            this.callSync(() => this.query.doSomething());\n-          }\n-\n-          callSync(cb: Function) {\n-            this.callSync2(cb);\n-          }\n-\n-          callSync2(cb: Function) {\n-            cb();\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should handle class instantiations with specified callbacks that access queries',\n-       async () => {\n-         writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-        import {External} from './external';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          private @${queryType}('test') query: any;\n-\n-          ngOnInit() {\n-            new External(() => this.query.doSomething());\n-          }\n-        }\n-      `);\n-\n-         writeFile('/external.ts', `\n-        export class External {\n-          constructor(cb: () => void) {\n-            // Add extra parentheses to ensure that expression is unwrapped.\n-            ((cb))();\n-          }\n-        }\n-      `);\n-\n-         await runMigration();\n-\n-         expect(tree.readContent('/index.ts'))\n-             .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-       });\n-\n-    it('should handle nested functions with arguments from parent closure', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          private @${queryType}('test') query: any;\n-\n-          ngOnInit() {\n-            this.callSync(() => this.query.doSomething());\n-          }\n-\n-          callSync(cb: Function) {\n-            function callSyncNested() {\n-              // The \"cb\" identifier comes from the \"callSync\" function.\n-              cb();\n-            }\n-\n-            callSyncNested();\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should not mark queries used in setTimeout as static', async () => {\n-      writeFile('/lib.dom.d.ts', `declare function setTimeout(cb: Function);`);\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          private @${queryType}('test') query: any;\n-          private @${queryType}('test') query2: any;\n-          private @${queryType}('test') query3: any;\n-\n-          ngOnInit() {\n-            setTimeout(function() {\n-              this.query.doSomething();\n-            });\n-\n-            setTimeout(createCallback(this));\n-          }\n-        }\n-\n-        function createCallback(instance: MyComp) {\n-          instance.query2.doSomething();\n-          return () => instance.query3.doSomething();\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: false }) query: any;`);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query2: any;`);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: false }) query3: any;`);\n-    });\n-\n-    it('should not mark queries used in \"addEventListener\" as static', async () => {\n-      writeFile('/lib.dom.d.ts', `\n-        interface HTMLElement {\n-          addEventListener(cb: Function);\n-        }\n-      `);\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          private @${queryType}('test') query: any;\n-\n-          constructor(private elementRef: HTMLElement) {}\n-\n-          ngOnInit() {\n-            this.elementRef.addEventListener(() => {\n-              this.query.classList.add('test');\n-            });\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: false }) query: any;`);\n-    });\n-\n-    it('should not mark queries used in \"requestAnimationFrame\" as static', async () => {\n-      writeFile('/lib.dom.d.ts', `declare function requestAnimationFrame(cb: Function);`);\n-      writeFile('/index.ts', `\n-        import {Component, ElementRef, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          private @${queryType}('test') query: any;\n-\n-          constructor(private elementRef: ElementRef) {}\n-\n-          ngOnInit() {\n-            requestAnimationFrame(() => {\n-              this.query.classList.add('test');\n-            });\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: false }) query: any;`);\n-    });\n-\n-    it('should mark queries used in immediately-invoked function expression as static',\n-       async () => {\n-         writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          private @${queryType}('test') query: any;\n-          private @${queryType}('test') query2: any;\n-\n-          ngOnInit() {\n-            (() => {\n-              this.query.usedStatically();\n-            })();\n-\n-            (function(ctx) {\n-              ctx.query2.useStatically();\n-            })(this);\n-          }\n-        }\n-      `);\n-\n-         await runMigration();\n-\n-         expect(tree.readContent('/index.ts'))\n-             .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-         expect(tree.readContent('/index.ts'))\n-             .toContain(`@${queryType}('test', { static: true }) query2: any;`);\n-       });\n-\n-    it('should detect static queries used in external function-like declaration', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-        import {externalFn} from './external';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          private @${queryType}('test') query: any;\n-\n-          ngOnInit() {\n-            externalFn(this);\n-          }\n-        }\n-      `);\n-\n-      writeFile('/external.ts', `\n-        import {MyComp} from './index';\n-\n-        export function externalFn(ctx: MyComp) {\n-          ctx.query.usedStatically();\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should detect static queries used through getter property access', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          private @${queryType}('test') query: any;\n-\n-          get myProp() {\n-            return this.query.myValue;\n-          }\n-\n-          ngOnInit() {\n-            this.myProp.test();\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should detect static queries used through external getter access', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-        import {External} from './external';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          @${queryType}('test') query: any;\n-\n-          private external = new External(this);\n-\n-          get myProp() {\n-            return this.query.myValue;\n-          }\n-\n-          ngOnInit() {\n-            console.log(this.external.query);\n-          }\n-        }\n-      `);\n-\n-      writeFile('/external.ts', `\n-        import {MyComp} from './index';\n-\n-        export class External {\n-          constructor(private comp: MyComp) {}\n-\n-          set query() { /** noop */ }\n-          get query() { return this.comp.query; }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should not mark queries as static if a value is assigned to accessor property',\n-       async () => {\n-         writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          private @${queryType}('test') query: any;\n-\n-          set myProp(value: any) { /* noop */}\n-          get myProp() {\n-            return this.query.myValue;\n-          }\n-\n-          ngOnInit() {\n-            this.myProp = true;\n-          }\n-        }\n-      `);\n-\n-         await runMigration();\n-\n-         expect(tree.readContent('/index.ts'))\n-             .toContain(`@${queryType}('test', { static: false }) query: any;`);\n-       });\n-\n-    it('should mark queries as static if non-input setter uses query', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          private @${queryType}('test') query: any;\n-\n-          get myProp() { return null; }\n-          set myProp(value: any) {\n-            this.query.doSomething();\n-          }\n-\n-          ngOnInit() {\n-            this.myProp = 'newValue';\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should check setter and getter when using compound assignment', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          private @${queryType}('test') query: any;\n-          private @${queryType}('test') query2: any;\n-\n-          get myProp() { return this.query2 }\n-          set myProp(value: any) {\n-            this.query.doSomething();\n-          }\n-\n-          ngOnInit() {\n-            this.myProp *= 5;\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query2: any;`);\n-    });\n-\n-    it('should check getters when using comparison operator in binary expression', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          private @${queryType}('test') query: any;\n-\n-          get myProp() { return this.query }\n-          set myProp(value: any) { /* noop */ }\n-\n-          ngOnInit() {\n-            if (this.myProp === 3) {\n-              // noop\n-            }\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should check derived abstract class methods', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        export abstract class RootBaseClass {\n-          abstract getQuery(): any;\n-\n-          ngOnInit() {\n-            this.getQuery().doSomething();\n-          }\n-        }\n-\n-        export abstract class BaseClass extends RootBaseClass {\n-          abstract getQuery2(): any;\n-\n-          getQuery() {\n-            this.getQuery2();\n-          }\n-        }\n-\n-        @Component({template: '<span #test></span>'})\n-        export class Subclass extends BaseClass {\n-          @${queryType}('test') query: any;\n-\n-          getQuery2(): any {\n-            return this.query;\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should detect queries accessed through deep abstract class method', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        export abstract class RootBaseClass {\n-          abstract getQuery(): any;\n-\n-          ngOnInit() {\n-            this.getQuery().doSomething();\n-          }\n-        }\n-\n-        export abstract class BaseClass extends RootBaseClass {\n-          /* additional layer of indirection */\n-        }\n-\n-        @Component({template: '<span #test></span>'})\n-        export class Subclass extends BaseClass {\n-          @${queryType}('test') query: any;\n-\n-          getQuery(): any {\n-            return this.query;\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should detect queries accessed through abstract property getter', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        export abstract class BaseClass {\n-          abstract myQuery: any;\n-\n-          ngOnInit() {\n-            this.myQuery.doSomething();\n-          }\n-        }\n-\n-        @Component({template: '<span #test></span>'})\n-        export class Subclass extends BaseClass {\n-          @${queryType}('test') query: any;\n-\n-          get myQuery() { return this.query; }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should detect queries accessed through abstract property setter', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        export abstract class BaseClass {\n-          abstract myQuery: any;\n-\n-          ngOnInit() {\n-            this.myQuery = \"trigger\";\n-          }\n-        }\n-\n-        @Component({template: '<span #test></span>'})\n-        export class Subclass extends BaseClass {\n-          @${queryType}('test') query: any;\n-\n-          set myQuery(val: any) { this.query.doSomething() }\n-          get myQuery() { /* noop */ }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should detect query usage in abstract class methods accessing inherited query',\n-       async () => {\n-         writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        export abstract class RootBaseClass {\n-          abstract getQuery(): any;\n-\n-          ngOnInit() {\n-            this.getQuery().doSomething();\n-          }\n-        }\n-\n-        export abstract class BaseClass extends RootBaseClass {\n-          @${queryType}('test') query: any;\n-          abstract getQuery2(): any;\n-\n-          getQuery() {\n-            this.getQuery2();\n-          }\n-        }\n-\n-        @Component({template: '<span #test></span>'})\n-        export class Subclass extends BaseClass {\n-\n-          getQuery2(): any {\n-            return this.query;\n-          }\n-        }\n-      `);\n-\n-         await runMigration();\n-\n-         expect(tree.readContent('/index.ts'))\n-             .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-       });\n-\n-    it('should detect query usage within component template', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({templateUrl: 'my-template.html'})\n-        export class MyComponent {\n-          @${queryType}('test') query: any;\n-        }\n-      `);\n-\n-      writeFile(`/my-template.html`, `\n-        <foo #test></foo>\n-        <comp [dir]=\"query\"></comp>\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should detect query usage with nested property read within component template',\n-       async () => {\n-         writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({templateUrl: 'my-template.html'})\n-        export class MyComponent {\n-          @${queryType}('test') query: any;\n-        }\n-      `);\n-\n-         writeFile(`/my-template.html`, `\n-        <foo #test></foo>\n-        <comp [dir]=\"query.someProperty\"></comp>\n-      `);\n-\n-         await runMigration();\n-\n-         expect(tree.readContent('/index.ts'))\n-             .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-       });\n-\n-    it('should not mark query as static if template has template reference with same name',\n-       async () => {\n-         writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({templateUrl: 'my-template.html'})\n-        export class MyComponent {\n-          @${queryType}('test') query: any;\n-        }\n-      `);\n-\n-         writeFile(`/my-template.html`, `\n-        <foo #test></foo>\n-        <same-name #query></same-name>\n-        <!-- In that case the \"query\" from the component cannot be referenced. -->\n-        <comp [dir]=\"query\"></comp>\n-      `);\n-\n-         await runMigration();\n-\n-         expect(tree.readContent('/index.ts'))\n-             .toContain(`@${queryType}('test', { static: false }) query: any;`);\n-       });\n-\n-    it('should not mark query as static if template has property read with query name but different receiver',\n-       async () => {\n-         writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({templateUrl: 'my-template.html'})\n-        export class MyComponent {\n-          myObject: {someProp: any};\n-          @${queryType}('test') someProp: any;\n-        }\n-      `);\n-\n-         // This test ensures that we don't accidentally treat template property reads\n-         // which do not refer to the query of the component instance, but have the same\n-         // \"render3Ast.PropertyRead\" name, as references to the query declaration.\n-         writeFile(`/my-template.html`, `\n-        <foo #test></foo>\n-        <comp [dir]=\"myObject.someProp\"></comp>\n-      `);\n-\n-         await runMigration();\n-\n-         expect(tree.readContent('/index.ts'))\n-             .toContain(`@${queryType}('test', { static: false }) someProp: any;`);\n-       });\n-\n-    it('should ignore queries accessed within <ng-template> element', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({templateUrl: 'my-template.html'})\n-        export class MyComponent {\n-          @${queryType}('test') query: any;\n-        }\n-      `);\n-\n-      writeFile(`/my-template.html`, `\n-        <foo #test></foo>\n-\n-        <ng-template>\n-          <my-comp [myInput]=\"query\"></my-comp>\n-        </ng-template>\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: false }) query: any;`);\n-    });\n-\n-    it('should detect inherited queries used in templates', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        export class ParentClass {\n-          @${queryType}('test') query: any;\n-        }\n-\n-        @Component({templateUrl: 'my-template.html'})\n-        export class MyComponent extends ParentClass {}\n-      `);\n-\n-      writeFile(`/my-template.html`, `\n-        <foo #test></foo>\n-        <my-comp [myInput]=\"query\"></my-comp>\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-\n-    it('should mark queries which could be accessed statically within third-party calls as ambiguous',\n-       async () => {\n-         writeFile('/index.ts', `\n-            import {Component, ${queryType}} from '@angular/core';\n-            import {thirdPartySync} from 'my-lib';\n-\n-            @Component({template: '<span>Template</span>'})\n-            export class MyComponent {\n-              @${queryType}('test') query: any;\n-              @${queryType}('test') query2: any;\n-\n-              ngOnInit() {\n-                const myVarFn = () => this.query2.doSomething();\n-\n-                thirdPartySync(() => this.query.doSomething());\n-                thirdPartySync(myVarFn);\n-              }\n-            }\n-          `);\n-\n-         writeFile(\n-             '/node_modules/my-lib/index.d.ts', `export function thirdPartySync(fn: Function);`);\n-\n-         await runMigration();\n-\n-         expect(tree.readContent('/index.ts'))\n-             .toContain(`@${\n-                 queryType}('test', /* TODO: check static flag */ { static: true }) query: any;`);\n-         expect(tree.readContent('/index.ts'))\n-             .toContain(`@${\n-                 queryType}('test', /* TODO: check static flag */ { static: true }) query2: any;`);\n-         expect(warnOutput.length).toBe(2);\n-         expect(warnOutput[0]).toContain('Query timing is ambiguous.');\n-         expect(warnOutput[1]).toContain('Query timing is ambiguous.');\n-       });\n-\n-    it('should mark queries which could be accessed statically within third-party new expressions as ambiguous',\n-       async () => {\n-         writeFile('/index.ts', `\n-            import {Component, ${queryType}} from '@angular/core';\n-            import {ThirdParty} from 'my-lib';\n-\n-            @Component({template: '<span>Template</span>'})\n-            export class MyComponent {\n-              @${queryType}('test') query: any;\n-\n-              ngOnInit() {\n-                new ThirdParty(() => this.query.doSomething());\n-              }\n-            }\n-          `);\n-\n-         writeFile('/node_modules/my-lib/index.d.ts', `\n-            export declare class ThirdParty {\n-              constructor(cb: Function);\n-            }\n-          `);\n-\n-         await runMigration();\n-\n-         expect(tree.readContent('/index.ts'))\n-             .toContain(`@${\n-                 queryType}('test', /* TODO: check static flag */ { static: true }) query: any;`);\n-         expect(warnOutput.length).toBe(1);\n-         expect(warnOutput[0])\n-             .toContain(\n-                 'Query timing is ambiguous. Please check if the query can be marked as dynamic');\n-       });\n-\n-    it('should properly handle multiple tsconfig files', async () => {\n-      writeFile('/src/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span #test></span>'})\n-        export class MyComp {\n-          private @${queryType}('test') query: any;\n-        }\n-      `);\n-\n-      writeFile('/src/tsconfig.json', JSON.stringify({\n-        compilerOptions: {\n-          lib: ['es2015'],\n-        }\n-      }));\n-\n-      // The migration runs for \"/tsconfig.json\" and \"/src/tsconfig.json\" which both\n-      // contain the \"src/index.ts\" file. This test ensures that we don't incorrectly\n-      // apply the code transformation multiple times with outdated offsets.\n-      await runMigration();\n-\n-      expect(tree.readContent('/src/index.ts'))\n-          .toContain(`@${queryType}('test', { static: false }) query: any;`);\n-    });\n-\n-    it('should support function call with default parameter value', async () => {\n-      writeFile('/index.ts', `\n-        import {Component, ${queryType}} from '@angular/core';\n-\n-        @Component({template: '<span>Test</span>'})\n-        export class MyComponent {\n-          @${queryType}('test') query: any;\n-\n-          ngOnInit() {\n-            this.myFunction();\n-          }\n-\n-          myFunction(unused?: string, cb = () => this.query.doSomething) {\n-            cb();\n-          }\n-        }\n-      `);\n-\n-      await runMigration();\n-\n-      expect(tree.readContent('/index.ts'))\n-          .toContain(`@${queryType}('test', { static: true }) query: any;`);\n-    });\n-  }\n-});"
        },
        {
            "sha": "3c5a5534d9447de5ebd2d39bf629337769ee7e05",
            "filename": "packages/core/schematics/test/template_var_assignment_migration_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 301,
            "changes": 301,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Ftemplate_var_assignment_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Ftemplate_var_assignment_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Ftemplate_var_assignment_migration_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14",
            "patch": "@@ -1,301 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-\n-import {getSystemPath, normalize, virtualFs} from '@angular-devkit/core';\n-import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n-import {HostTree} from '@angular-devkit/schematics';\n-import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing';\n-import * as shx from 'shelljs';\n-\n-describe('template variable assignment migration', () => {\n-  let runner: SchematicTestRunner;\n-  let host: TempScopedNodeJsSyncHost;\n-  let tree: UnitTestTree;\n-  let tmpDirPath: string;\n-  let previousWorkingDir: string;\n-  let warnOutput: string[];\n-\n-  beforeEach(() => {\n-    runner = new SchematicTestRunner('test', require.resolve('../migrations.json'));\n-    host = new TempScopedNodeJsSyncHost();\n-    tree = new UnitTestTree(new HostTree(host));\n-\n-    writeFile('/tsconfig.json', JSON.stringify({\n-      compilerOptions: {\n-        lib: ['es2015'],\n-      },\n-    }));\n-    writeFile('/angular.json', JSON.stringify({\n-      version: 1,\n-      projects: {t: {architect: {build: {options: {tsConfig: './tsconfig.json'}}}}}\n-    }));\n-\n-    warnOutput = [];\n-    runner.logger.subscribe(logEntry => {\n-      if (logEntry.level === 'warn') {\n-        warnOutput.push(logEntry.message);\n-      }\n-    });\n-\n-    previousWorkingDir = shx.pwd();\n-    tmpDirPath = getSystemPath(host.root);\n-\n-    // Switch into the temporary directory path. This allows us to run\n-    // the schematic against our custom unit test tree.\n-    shx.cd(tmpDirPath);\n-  });\n-\n-  afterEach(() => {\n-    shx.cd(previousWorkingDir);\n-    shx.rm('-r', tmpDirPath);\n-  });\n-\n-  function writeFile(filePath: string, contents: string) {\n-    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n-  }\n-\n-  function runMigration() {\n-    return runner.runSchematicAsync('migration-v8-template-local-variables', {}, tree).toPromise();\n-  }\n-\n-  it('should warn for two-way data binding variable assignment', async () => {\n-    writeFile('/index.ts', `\n-      import {Component} from '@angular/core';\n-\n-      @Component({\n-        template: '<cmp *ngFor=\"let optionName of options\" [(opt)]=\"optionName\"></cmp>',\n-      })\n-      export class MyComp {}\n-    `);\n-\n-    await runMigration();\n-\n-    expect(warnOutput.length).toBe(1);\n-    expect(warnOutput[0]).toMatch(/^ {3}index.ts@5:69: Found assignment/);\n-  });\n-\n-  it('should warn for two-way data binding assigning to \"as\" variable', async () => {\n-    writeFile('/index.ts', `\n-      import {Component} from '@angular/core';\n-\n-      @Component({\n-        templateUrl: './tmpl.html',\n-      })\n-      export class MyComp {}\n-    `);\n-\n-    writeFile('/tmpl.html', `\n-      <div *ngIf=\"somePartner() | async as partner\">\n-        <some-comp [(value)]=\"partner\"></some-comp>\n-      </div>\n-    `);\n-\n-    await runMigration();\n-\n-    expect(warnOutput.length).toBe(1);\n-    expect(warnOutput).toMatch(/^ {3}tmpl.html@3:31: Found assignment/);\n-  });\n-\n-  it('should warn for bound event assignments to \"as\" variable', async () => {\n-    writeFile('/index.ts', `\n-      import {Component} from '@angular/core';\n-\n-      @Component({\n-        templateUrl: './sub_dir/tmpl.html',\n-      })\n-      export class MyComp {}\n-    `);\n-\n-    writeFile('/sub_dir/tmpl.html', `\n-      <div *ngIf=\"true as visible\">\n-          <div (click)=\"visible=false\">Hide</div>\n-          <div (click)=\"visible=true\">Show</div>\n-      </div>\n-    `);\n-\n-    await runMigration();\n-\n-    expect(warnOutput.length).toBe(2);\n-    expect(warnOutput[0]).toMatch(/^ {3}sub_dir\\/tmpl.html@3:25: Found assignment/);\n-    expect(warnOutput[1]).toMatch(/^ {3}sub_dir\\/tmpl.html@4:25: Found assignment/);\n-  });\n-\n-  it('should warn for bound event assignments to template \"let\" variables', async () => {\n-    writeFile('/index.ts', `\n-      import {Component} from '@angular/core';\n-\n-      @Component({\n-        templateUrl: './sub_dir/tmpl.html',\n-      })\n-      export class MyComp {}\n-    `);\n-\n-    writeFile('/sub_dir/tmpl.html', `\n-      <ng-template let-visible=\"false\">\n-          <div (click)=\"visible=false\">Hide</div>\n-          <div (click)=\"visible=true\">Show</div>\n-      </ng-template>\n-    `);\n-\n-    await runMigration();\n-\n-    expect(warnOutput.length).toBe(2);\n-    expect(warnOutput[0]).toMatch(/^ {3}sub_dir\\/tmpl.html@3:25: Found assignment/);\n-    expect(warnOutput[1]).toMatch(/^ {3}sub_dir\\/tmpl.html@4:25: Found assignment/);\n-  });\n-\n-  it('should not warn for bound event assignments to component property', async () => {\n-    writeFile('/index.ts', `\n-      import {Component} from '@angular/core';\n-\n-      @Component({\n-        templateUrl: './sub_dir/tmpl.html',\n-      })\n-      export class MyComp {}\n-    `);\n-\n-    writeFile('/sub_dir/tmpl.html', `<button (click)=\"myProp = true\"></button>`);\n-\n-    await runMigration();\n-\n-    expect(warnOutput.length).toBe(0);\n-  });\n-\n-  it('should not warn for bound event assignments to template variable object property',\n-     async () => {\n-       writeFile('/index.ts', `\n-      import {Component} from '@angular/core';\n-\n-      @Component({\n-        templateUrl: './sub_dir/tmpl.html',\n-      })\n-      export class MyComp {}\n-    `);\n-\n-       writeFile('/sub_dir/tmpl.html', `\n-      <button *ngFor=\"let element of list\" (click)=\"element.value = null\">Reset</button>\n-    `);\n-\n-       await runMigration();\n-\n-       expect(warnOutput.length).toBe(0);\n-     });\n-\n-  it('should not warn for property writes with template variable name but different receiver',\n-     async () => {\n-       writeFile('/index.ts', `\n-      import {Component} from '@angular/core';\n-\n-      @Component({\n-        templateUrl: './sub_dir/tmpl.html',\n-      })\n-      export class MyComp {\n-        someProp = {\n-          element: 'someValue',\n-        };\n-      }\n-    `);\n-\n-       writeFile('/sub_dir/tmpl.html', `\n-      <button *ngFor=\"let element of list\" (click)=\"someProp.element = null\">\n-        Reset\n-      </button>\n-    `);\n-\n-       await runMigration();\n-\n-       expect(warnOutput.length).toBe(0);\n-     });\n-\n-  it('should warn for template variable assignments in expression conditional', async () => {\n-    writeFile('/index.ts', `\n-      import {Component} from '@angular/core';\n-\n-      @Component({\n-        templateUrl: './sub_dir/tmpl.html',\n-      })\n-      export class MyComp {\n-        otherVar = false;\n-      }\n-    `);\n-\n-    writeFile('/sub_dir/tmpl.html', `\n-      <ng-template let-tmplVar>\n-        <p (click)=\"enabled ? tmplVar = true : otherVar = true\"></p>\n-      </ng-template>\n-    `);\n-\n-    await runMigration();\n-\n-    expect(warnOutput.length).toBe(1);\n-    expect(warnOutput[0]).toMatch(/^ {3}sub_dir\\/tmpl.html@3:31: Found assignment/);\n-  });\n-\n-  it('should not warn for property writes with template variable name but different scope',\n-     async () => {\n-       writeFile('/index.ts', `\n-      import {Component} from '@angular/core';\n-\n-      @Component({\n-        templateUrl: './sub_dir/tmpl.html',\n-      })\n-      export class MyComp {\n-        element = 'someValue';\n-      }\n-    `);\n-\n-       writeFile('/sub_dir/tmpl.html', `\n-      <button *ngFor=\"let element of list\">{{element}}</button>\n-      <button (click)=\"element = null\"></button>\n-    `);\n-\n-       await runMigration();\n-\n-       expect(warnOutput.length).toBe(0);\n-     });\n-\n-\n-  it('should not throw an error if a detected template fails parsing', async () => {\n-    writeFile('/index.ts', `\n-      import {Component} from '@angular/core';\n-\n-      @Component({\n-        templateUrl: './sub_dir/tmpl.html',\n-      })\n-      export class MyComp {}\n-    `);\n-\n-    writeFile('/sub_dir/tmpl.html', `<x (click)=\"<invalid-syntax>\"></x>`);\n-\n-    await runMigration();\n-\n-    expect(warnOutput.length).toBe(0);\n-  });\n-\n-  it('should be able to report multiple templates within the same source file', async () => {\n-    writeFile('/index.ts', `\n-      import {Component} from '@angular/core';\n-\n-      @Component({\n-        template: '<ng-template let-one><a (sayHello)=\"one=true\"></a></ng-template>',\n-      })\n-      export class MyComp {}\n-\n-      @Component({\n-        template: '<ng-template let-two><b (greet)=\"two=true\"></b></ng-template>',\n-      })\n-      export class MyComp2 {}\n-    `);\n-\n-    await runMigration();\n-\n-    expect(warnOutput.length).toBe(2);\n-    expect(warnOutput[0]).toMatch(/^ {3}index.ts@5:56: Found assignment/);\n-    expect(warnOutput[1]).toMatch(/^ {3}index.ts@10:53: Found assignment/);\n-  });\n-});"
        },
        {
            "sha": "7d4d7dd66fd4bed63cae4bd30f6485118a86382e",
            "filename": "packages/core/schematics/test/undecorated_classes_with_decorated_fields_migration_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fundecorated_classes_with_decorated_fields_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fundecorated_classes_with_decorated_fields_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fundecorated_classes_with_decorated_fields_migration_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14"
        },
        {
            "sha": "82a9f9733514281a7a9f7ad5eea74b343634b83c",
            "filename": "packages/core/schematics/test/undecorated_classes_with_di_migration_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 1562,
            "changes": 1562,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fundecorated_classes_with_di_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fundecorated_classes_with_di_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fundecorated_classes_with_di_migration_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14"
        },
        {
            "sha": "58ea9ba8ba45c25ea10fb5879bcde796c52b22da",
            "filename": "packages/core/schematics/test/wait_for_async_migration_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 162,
            "changes": 162,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fwait_for_async_migration_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fwait_for_async_migration_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fwait_for_async_migration_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14"
        },
        {
            "sha": "ced959648a1e6f751e0763f1cd8520cc358e42f4",
            "filename": "packages/core/schematics/test/xhr_factory_spec.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 79,
            "changes": 79,
            "blob_url": "https://github.com/angular/angular/blob/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fxhr_factory_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14/packages%2Fcore%2Fschematics%2Ftest%2Fxhr_factory_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fschematics%2Ftest%2Fxhr_factory_spec.ts?ref=bf1a2fc2d5ea394a35577bcd1bb68b807e6e2c14"
        }
    ],
    "stats": {
        "total": 21869,
        "additions": 0,
        "deletions": 21869
    }
}