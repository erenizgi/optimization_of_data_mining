{
    "author": "edusperoni",
    "message": "fix(zone.js): patch child method that overrides an already patched method (#39850)\n\nFix a case where, if the parent class had already been patched, it would\nnot patch the child class. In addition to checking if the method is\ndefined in the prototype, and not inherited, it also does the same for\nthe unpatched method.\n\nPR Close #39850",
    "sha": "82e3f546dbedbab273bf66536a36f7add837b166",
    "files": [
        {
            "sha": "28a58f0ff1693d75580d7e740f0b0806b52249dc",
            "filename": "packages/zone.js/lib/common/utils.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/82e3f546dbedbab273bf66536a36f7add837b166/packages%2Fzone.js%2Flib%2Fcommon%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/82e3f546dbedbab273bf66536a36f7add837b166/packages%2Fzone.js%2Flib%2Fcommon%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fzone.js%2Flib%2Fcommon%2Futils.ts?ref=82e3f546dbedbab273bf66536a36f7add837b166",
            "patch": "@@ -402,7 +402,7 @@ export function patchMethod(\n \n   const delegateName = zoneSymbol(name);\n   let delegate: Function|null = null;\n-  if (proto && !(delegate = proto[delegateName])) {\n+  if (proto && (!(delegate = proto[delegateName]) || !proto.hasOwnProperty(delegateName))) {\n     delegate = proto[delegateName] = proto[name];\n     // check whether proto[name] is writable\n     // some property is readonly in safari, such as HtmlCanvasElement.prototype.toBlob"
        },
        {
            "sha": "c790f360efd811f7847d56fce27e67a14dae8f41",
            "filename": "packages/zone.js/test/common/util.spec.ts",
            "status": "modified",
            "additions": 120,
            "deletions": 0,
            "changes": 120,
            "blob_url": "https://github.com/angular/angular/blob/82e3f546dbedbab273bf66536a36f7add837b166/packages%2Fzone.js%2Ftest%2Fcommon%2Futil.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/82e3f546dbedbab273bf66536a36f7add837b166/packages%2Fzone.js%2Ftest%2Fcommon%2Futil.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fzone.js%2Ftest%2Fcommon%2Futil.spec.ts?ref=82e3f546dbedbab273bf66536a36f7add837b166",
            "patch": "@@ -77,6 +77,126 @@ describe('utils', function() {\n       expect(desc!.writable).toBeTruthy();\n       expect(!desc!.get).toBeTruthy();\n     });\n+\n+    it('should patch target if it overrides a patched method', () => {\n+      let args: any[]|undefined;\n+      let childArgs: any[]|undefined;\n+      let self: any;\n+      let childSelf: any;\n+      class Type {\n+        method(..._args: any[]) {\n+          args = _args;\n+          self = this;\n+          return 'OK';\n+        }\n+      }\n+      class ChildType extends Type {\n+        method(..._args: any[]) {\n+          childArgs = _args;\n+          childSelf = this;\n+          return 'ChildOK';\n+        }\n+      }\n+\n+      const method = Type.prototype.method;\n+      const childMethod = ChildType.prototype.method;\n+      let delegateMethod: Function;\n+      let delegateSymbol: string;\n+      let childDelegateMethod: Function;\n+      let childDelegateSymbol: string;\n+\n+      const typeInstance = new Type();\n+      const childTypeInstance = new ChildType();\n+      expect(patchMethod(\n+                 Type.prototype, 'method',\n+                 (delegate: Function, symbol: string, name: string) => {\n+                   expect(name).toEqual('method');\n+                   delegateMethod = delegate;\n+                   delegateSymbol = symbol;\n+                   return function(self, args) {\n+                     return delegate.apply(self, ['patch', args[0]]);\n+                   };\n+                 }))\n+          .toBe(delegateMethod!);\n+\n+      expect(patchMethod(\n+                 ChildType.prototype, 'method',\n+                 (delegate: Function, symbol: string, name: string) => {\n+                   expect(name).toEqual('method');\n+                   childDelegateMethod = delegate;\n+                   childDelegateSymbol = symbol;\n+                   return function(self, args) {\n+                     return delegate.apply(self, ['child patch', args[0]]);\n+                   };\n+                 }))\n+          .toBe(childDelegateMethod!);\n+\n+      expect(typeInstance.method('a0')).toEqual('OK');\n+      expect(childTypeInstance.method('a0')).toEqual('ChildOK');\n+      expect(args).toEqual(['patch', 'a0']);\n+      expect(childArgs).toEqual(['child patch', 'a0']);\n+      expect(self).toBe(typeInstance);\n+      expect(childSelf).toBe(childTypeInstance);\n+      expect(delegateMethod!).toBe(method);\n+      expect(childDelegateMethod!).toBe(childMethod);\n+      expect(delegateSymbol!).toEqual(zoneSymbol('method'));\n+      expect(childDelegateSymbol!).toEqual(zoneSymbol('method'));\n+      expect((Type.prototype as any)[delegateSymbol!]).toBe(method);\n+      expect((ChildType.prototype as any)[delegateSymbol!]).toBe(childMethod);\n+    });\n+\n+    it('should not patch target if does not override a patched method', () => {\n+      let args: any[]|undefined;\n+      let self: any;\n+      class Type {\n+        method(..._args: any[]) {\n+          args = _args;\n+          self = this;\n+          return 'OK';\n+        }\n+      }\n+      class ChildType extends Type {}\n+      const method = Type.prototype.method;\n+      let delegateMethod: Function;\n+      let delegateSymbol: string;\n+      let childPatched = false;\n+\n+      const typeInstance = new Type();\n+      const childTypeInstance = new ChildType();\n+      expect(patchMethod(\n+                 Type.prototype, 'method',\n+                 (delegate: Function, symbol: string, name: string) => {\n+                   expect(name).toEqual('method');\n+                   delegateMethod = delegate;\n+                   delegateSymbol = symbol;\n+                   return function(self, args) {\n+                     return delegate.apply(self, ['patch', args[0]]);\n+                   };\n+                 }))\n+          .toBe(delegateMethod!);\n+\n+      expect(patchMethod(\n+                 ChildType.prototype, 'method',\n+                 (delegate: Function, symbol: string, name: string) => {\n+                   childPatched = true;\n+                   return function(self, args) {\n+                     return delegate.apply(self, ['child patch', args[0]]);\n+                   };\n+                 }))\n+          .toBe(delegateMethod!);\n+\n+      expect(childPatched).toBe(false);\n+      expect(typeInstance.method('a0')).toEqual('OK');\n+      expect(args).toEqual(['patch', 'a0']);\n+      expect(self).toBe(typeInstance);\n+      expect(delegateMethod!).toBe(method);\n+      expect(delegateSymbol!).toEqual(zoneSymbol('method'));\n+      expect((Type.prototype as any)[delegateSymbol!]).toBe(method);\n+      expect(childTypeInstance.method('a0')).toEqual('OK');\n+      expect(args).toEqual(['patch', 'a0']);\n+      expect(self).toBe(childTypeInstance);\n+      expect((ChildType.prototype as any)[delegateSymbol!]).toBe(method);\n+    });\n   });\n \n   describe('patchPrototype', () => {"
        }
    ],
    "stats": {
        "total": 122,
        "additions": 121,
        "deletions": 1
    }
}