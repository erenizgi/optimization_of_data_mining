{
    "author": "atscott",
    "message": "refactor(language-service): Return directive defs when input name is part of selector (#39243)\n\nWhen an input name is part of the directive selector, it would be good to return the directive as well\nwhen performing 'go to definition' or 'go to type definition'. As an example, this would allow\n'go to type definition' for ngIf to take the user to the NgIf directive.\n'Go to type definition' would otherwise return no results because the\ninput is a generic type. This would also be the case for all primitive\ninput types.\n\nPR Close #39243",
    "sha": "5bda62c51d8f5590755c04acb50b49cd8cd84bbd",
    "files": [
        {
            "sha": "4ce1e15caacd3984f5631fb8641c888ad7eb0155",
            "filename": "packages/language-service/ivy/definitions.ts",
            "status": "modified",
            "additions": 47,
            "deletions": 12,
            "changes": 59,
            "blob_url": "https://github.com/angular/angular/blob/5bda62c51d8f5590755c04acb50b49cd8cd84bbd/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts",
            "raw_url": "https://github.com/angular/angular/raw/5bda62c51d8f5590755c04acb50b49cd8cd84bbd/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts?ref=5bda62c51d8f5590755c04acb50b49cd8cd84bbd",
            "patch": "@@ -6,16 +6,17 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, TmplAstNode, TmplAstTextAttribute} from '@angular/compiler';\n+import {AST, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstTemplate, TmplAstTextAttribute} from '@angular/compiler';\n import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n import {DirectiveSymbol, DomBindingSymbol, ElementSymbol, ShimLocation, Symbol, SymbolKind, TemplateSymbol} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import * as ts from 'typescript';\n \n-import {findNodeAtPosition} from './hybrid_visitor';\n+import {getPathToNodeAtPosition} from './hybrid_visitor';\n import {flatMap, getDirectiveMatchesForAttribute, getDirectiveMatchesForElementTag, getTemplateInfoAtPosition, getTextSpanOfNode, isDollarEvent, TemplateInfo, toTextSpan} from './utils';\n \n interface DefinitionMeta {\n   node: AST|TmplAstNode;\n+  path: Array<AST|TmplAstNode>;\n   symbol: Symbol;\n }\n \n@@ -41,12 +42,12 @@ export class DefinitionBuilder {\n       return undefined;\n     }\n \n-    const definitions = this.getDefinitionsForSymbol(definitionMeta.symbol, definitionMeta.node);\n+    const definitions = this.getDefinitionsForSymbol({...definitionMeta, ...templateInfo});\n     return {definitions, textSpan: getTextSpanOfNode(definitionMeta.node)};\n   }\n \n-  private getDefinitionsForSymbol(symbol: Symbol, node: TmplAstNode|AST):\n-      readonly ts.DefinitionInfo[]|undefined {\n+  private getDefinitionsForSymbol({symbol, node, path, component}: DefinitionMeta&\n+                                  TemplateInfo): readonly ts.DefinitionInfo[]|undefined {\n     switch (symbol.kind) {\n       case SymbolKind.Directive:\n       case SymbolKind.Element:\n@@ -58,9 +59,14 @@ export class DefinitionBuilder {\n         // LS users to \"go to definition\" on an item in the template that maps to a class and be\n         // taken to the directive or HTML class.\n         return this.getTypeDefinitionsForTemplateInstance(symbol, node);\n-      case SymbolKind.Input:\n       case SymbolKind.Output:\n-        return this.getDefinitionsForSymbols(...symbol.bindings);\n+      case SymbolKind.Input: {\n+        const bindingDefs = this.getDefinitionsForSymbols(...symbol.bindings);\n+        // Also attempt to get directive matches for the input name. If there is a directive that\n+        // has the input name as part of the selector, we want to return that as well.\n+        const directiveDefs = this.getDirectiveTypeDefsForBindingNode(node, path, component);\n+        return [...bindingDefs, ...directiveDefs];\n+      }\n       case SymbolKind.Variable:\n       case SymbolKind.Reference: {\n         const definitions: ts.DefinitionInfo[] = [];\n@@ -112,8 +118,14 @@ export class DefinitionBuilder {\n       case SymbolKind.Template:\n         return this.getTypeDefinitionsForTemplateInstance(symbol, node);\n       case SymbolKind.Output:\n-      case SymbolKind.Input:\n-        return this.getTypeDefinitionsForSymbols(...symbol.bindings);\n+      case SymbolKind.Input: {\n+        const bindingDefs = this.getTypeDefinitionsForSymbols(...symbol.bindings);\n+        // Also attempt to get directive matches for the input name. If there is a directive that\n+        // has the input name as part of the selector, we want to return that as well.\n+        const directiveDefs = this.getDirectiveTypeDefsForBindingNode(\n+            node, definitionMeta.path, templateInfo.component);\n+        return [...bindingDefs, ...directiveDefs];\n+      }\n       case SymbolKind.Reference:\n       case SymbolKind.Expression:\n       case SymbolKind.Variable:\n@@ -150,6 +162,28 @@ export class DefinitionBuilder {\n     }\n   }\n \n+  private getDirectiveTypeDefsForBindingNode(\n+      node: TmplAstNode|AST, pathToNode: Array<TmplAstNode|AST>, component: ts.ClassDeclaration) {\n+    if (!(node instanceof TmplAstBoundAttribute) && !(node instanceof TmplAstTextAttribute) &&\n+        !(node instanceof TmplAstBoundEvent)) {\n+      return [];\n+    }\n+    const parent = pathToNode[pathToNode.length - 2];\n+    if (!(parent instanceof TmplAstTemplate || parent instanceof TmplAstElement)) {\n+      return [];\n+    }\n+    const templateOrElementSymbol =\n+        this.compiler.getTemplateTypeChecker().getSymbolOfNode(parent, component);\n+    if (templateOrElementSymbol === null ||\n+        (templateOrElementSymbol.kind !== SymbolKind.Template &&\n+         templateOrElementSymbol.kind !== SymbolKind.Element)) {\n+      return [];\n+    }\n+    const dirs =\n+        getDirectiveMatchesForAttribute(node.name, parent, templateOrElementSymbol.directives);\n+    return this.getTypeDefinitionsForSymbols(...dirs);\n+  }\n+\n   private getTypeDefinitionsForSymbols(...symbols: HasShimLocation[]): ts.DefinitionInfo[] {\n     return flatMap(symbols, ({shimLocation}) => {\n       const {shimPath, positionInShimFile} = shimLocation;\n@@ -159,15 +193,16 @@ export class DefinitionBuilder {\n \n   private getDefinitionMetaAtPosition({template, component}: TemplateInfo, position: number):\n       DefinitionMeta|undefined {\n-    const node = findNodeAtPosition(template, position);\n-    if (node === undefined) {\n+    const path = getPathToNodeAtPosition(template, position);\n+    if (path === undefined) {\n       return;\n     }\n \n+    const node = path[path.length - 1];\n     const symbol = this.compiler.getTemplateTypeChecker().getSymbolOfNode(node, component);\n     if (symbol === null) {\n       return;\n     }\n-    return {node, symbol};\n+    return {node, path, symbol};\n   }\n }"
        },
        {
            "sha": "391809e38da412290e8974dce129f76638476e3f",
            "filename": "packages/language-service/ivy/hybrid_visitor.ts",
            "status": "modified",
            "additions": 20,
            "deletions": 3,
            "changes": 23,
            "blob_url": "https://github.com/angular/angular/blob/5bda62c51d8f5590755c04acb50b49cd8cd84bbd/packages%2Flanguage-service%2Fivy%2Fhybrid_visitor.ts",
            "raw_url": "https://github.com/angular/angular/raw/5bda62c51d8f5590755c04acb50b49cd8cd84bbd/packages%2Flanguage-service%2Fivy%2Fhybrid_visitor.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fhybrid_visitor.ts?ref=5bda62c51d8f5590755c04acb50b49cd8cd84bbd",
            "patch": "@@ -13,12 +13,14 @@ import * as t from '@angular/compiler/src/render3/r3_ast';         // t for temp\n import {isTemplateNode, isTemplateNodeWithKeyAndValue} from './utils';\n \n /**\n- * Return the template AST node or expression AST node that most accurately\n+ * Return the path to the template AST node or expression AST node that most accurately\n  * represents the node at the specified cursor `position`.\n+ *\n  * @param ast AST tree\n  * @param position cursor position\n  */\n-export function findNodeAtPosition(ast: t.Node[], position: number): t.Node|e.AST|undefined {\n+export function getPathToNodeAtPosition(ast: t.Node[], position: number): Array<t.Node|e.AST>|\n+    undefined {\n   const visitor = new R3Visitor(position);\n   visitor.visitAll(ast);\n   const candidate = visitor.path[visitor.path.length - 1];\n@@ -35,7 +37,22 @@ export function findNodeAtPosition(ast: t.Node[], position: number): t.Node|e.AS\n       return;\n     }\n   }\n-  return candidate;\n+  return visitor.path;\n+}\n+\n+/**\n+ * Return the template AST node or expression AST node that most accurately\n+ * represents the node at the specified cursor `position`.\n+ *\n+ * @param ast AST tree\n+ * @param position cursor position\n+ */\n+export function findNodeAtPosition(ast: t.Node[], position: number): t.Node|e.AST|undefined {\n+  const path = getPathToNodeAtPosition(ast, position);\n+  if (!path) {\n+    return;\n+  }\n+  return path[path.length - 1];\n }\n \n class R3Visitor implements t.Visitor {"
        },
        {
            "sha": "6e2e568bf1446774652f820cca7acbeb62a07122",
            "filename": "packages/language-service/ivy/test/definitions_spec.ts",
            "status": "modified",
            "additions": 41,
            "deletions": 8,
            "changes": 49,
            "blob_url": "https://github.com/angular/angular/blob/5bda62c51d8f5590755c04acb50b49cd8cd84bbd/packages%2Flanguage-service%2Fivy%2Ftest%2Fdefinitions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/5bda62c51d8f5590755c04acb50b49cd8cd84bbd/packages%2Flanguage-service%2Fivy%2Ftest%2Fdefinitions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fdefinitions_spec.ts?ref=5bda62c51d8f5590755c04acb50b49cd8cd84bbd",
            "patch": "@@ -88,11 +88,14 @@ describe('definitions', () => {\n         templateOverride: `<div *ng¦If=\"anyValue\"></div>`,\n         expectedSpanText: 'ngIf',\n       });\n-      expect(definitions!.length).toEqual(1);\n+      // Because the input is also part of the selector, the directive is also returned.\n+      expect(definitions!.length).toEqual(2);\n+      const [inputDef, directiveDef] = definitions;\n \n-      const [def] = definitions;\n-      expect(def.textSpan).toEqual('ngIf');\n-      expect(def.contextSpan).toEqual('set ngIf(condition: T);');\n+      expect(inputDef.textSpan).toEqual('ngIf');\n+      expect(inputDef.contextSpan).toEqual('set ngIf(condition: T);');\n+      expect(directiveDef.textSpan).toEqual('NgIf');\n+      expect(directiveDef.contextSpan).toContain('export declare class NgIf');\n     });\n \n     it('should work for directives with compound selectors', () => {\n@@ -125,6 +128,18 @@ describe('definitions', () => {\n         expect(def.contextSpan).toEqual(`@Input('tcName') name = 'test';`);\n       });\n \n+      it('should work for text inputs', () => {\n+        const definitions = getDefinitionsAndAssertBoundSpan({\n+          templateOverride: `<test-comp tcN¦ame=\"name\"></test-comp>`,\n+          expectedSpanText: 'tcName=\"name\"',\n+        });\n+        expect(definitions!.length).toEqual(1);\n+\n+        const [def] = definitions;\n+        expect(def.textSpan).toEqual('name');\n+        expect(def.contextSpan).toEqual(`@Input('tcName') name = 'test';`);\n+      });\n+\n       it('should work for structural directive inputs ngForTrackBy', () => {\n         const definitions = getDefinitionsAndAssertBoundSpan({\n           templateOverride: `<div *ngFor=\"let item of heroes; tr¦ackBy: test;\"></div>`,\n@@ -145,12 +160,16 @@ describe('definitions', () => {\n           templateOverride: `<div *ngFor=\"let item o¦f heroes\"></div>`,\n           expectedSpanText: 'of',\n         });\n-        expect(definitions!.length).toEqual(1);\n+        // Because the input is also part of the selector ([ngFor][ngForOf]), the directive is also\n+        // returned.\n+        expect(definitions!.length).toEqual(2);\n+        const [inputDef, directiveDef] = definitions;\n \n-        const [def] = definitions;\n-        expect(def.textSpan).toEqual('ngForOf');\n-        expect(def.contextSpan)\n+        expect(inputDef.textSpan).toEqual('ngForOf');\n+        expect(inputDef.contextSpan)\n             .toEqual('set ngForOf(ngForOf: U & NgIterable<T> | undefined | null);');\n+        expect(directiveDef.textSpan).toEqual('NgForOf');\n+        expect(directiveDef.contextSpan).toContain('export declare class NgForOf');\n       });\n \n       it('should work for two-way binding providers', () => {\n@@ -191,6 +210,20 @@ describe('definitions', () => {\n         const definitionAndBoundSpan = ngLS.getDefinitionAndBoundSpan(APP_COMPONENT, position);\n         expect(definitionAndBoundSpan).toBeUndefined();\n       });\n+\n+      it('should return the directive when the event is part of the selector', () => {\n+        const definitions = getDefinitionsAndAssertBoundSpan({\n+          templateOverride: `<div (eventSelect¦or)=\"title = ''\"></div>`,\n+          expectedSpanText: `(eventSelector)=\"title = ''\"`,\n+        });\n+        expect(definitions!.length).toEqual(2);\n+\n+        const [inputDef, directiveDef] = definitions;\n+        expect(inputDef.textSpan).toEqual('eventSelector');\n+        expect(inputDef.contextSpan).toEqual('@Output() eventSelector = new EventEmitter<void>();');\n+        expect(directiveDef.textSpan).toEqual('EventSelectorDirective');\n+        expect(directiveDef.contextSpan).toContain('export class EventSelectorDirective');\n+      });\n     });\n   });\n "
        },
        {
            "sha": "cffed6d2fc4819591c3e4afdc7b3cc2ae7cd7e8c",
            "filename": "packages/language-service/ivy/test/type_definitions_spec.ts",
            "status": "modified",
            "additions": 35,
            "deletions": 14,
            "changes": 49,
            "blob_url": "https://github.com/angular/angular/blob/5bda62c51d8f5590755c04acb50b49cd8cd84bbd/packages%2Flanguage-service%2Fivy%2Ftest%2Ftype_definitions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/5bda62c51d8f5590755c04acb50b49cd8cd84bbd/packages%2Flanguage-service%2Fivy%2Ftest%2Ftype_definitions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Ftype_definitions_spec.ts?ref=5bda62c51d8f5590755c04acb50b49cd8cd84bbd",
            "patch": "@@ -14,6 +14,10 @@ import {HumanizedDefinitionInfo, humanizeDefinitionInfo} from './test_utils';\n describe('type definitions', () => {\n   const {project, service, tsLS} = setup();\n   const ngLS = new LanguageService(project, tsLS);\n+  const possibleArrayDefFiles = new Set([\n+    'lib.es5.d.ts', 'lib.es2015.core.d.ts', 'lib.es2015.iterable.d.ts',\n+    'lib.es2015.symbol.wellknown.d.ts', 'lib.es2016.array.include.d.ts'\n+  ]);\n \n   beforeEach(() => {\n     service.reset();\n@@ -121,7 +125,11 @@ describe('type definitions', () => {\n         const definitions = getTypeDefinitionsAndAssertBoundSpan({\n           templateOverride: `<div *ngFor=\"let item o¦f heroes\"></div>`,\n         });\n-        expectAllArrayDefinitions(definitions);\n+        // In addition to all the array defs, this will also return the NgForOf def because the\n+        // input is part of the selector ([ngFor][ngForOf]).\n+        expectAllDefinitions(\n+            definitions, new Set(['Array', 'NgForOf']),\n+            new Set([...possibleArrayDefFiles, 'ng_for_of.d.ts']));\n       });\n \n       it('should return nothing for two-way binding providers', () => {\n@@ -141,10 +149,25 @@ describe('type definitions', () => {\n         });\n         expect(definitions!.length).toEqual(2);\n \n-        const [def, xyz] = definitions;\n-        expect(def.textSpan).toEqual('EventEmitter');\n-        expect(def.contextSpan).toContain('export interface EventEmitter<T> extends Subject<T>');\n-        expect(xyz.textSpan).toEqual('EventEmitter');\n+        const [emitterInterface, emitterConst] = definitions;\n+        expect(emitterInterface.textSpan).toEqual('EventEmitter');\n+        expect(emitterInterface.contextSpan)\n+            .toContain('export interface EventEmitter<T> extends Subject<T>');\n+        expect(emitterInterface.fileName).toContain('event_emitter.d.ts');\n+        expect(emitterConst.textSpan).toEqual('EventEmitter');\n+        expect(emitterConst.contextSpan).toContain('export declare const EventEmitter');\n+        expect(emitterConst.fileName).toContain('event_emitter.d.ts');\n+      });\n+\n+      it('should return the directive when the event is part of the selector', () => {\n+        const definitions = getTypeDefinitionsAndAssertBoundSpan({\n+          templateOverride: `<div (eventSelect¦or)=\"title = ''\"></div>`,\n+        });\n+        expect(definitions!.length).toEqual(3);\n+\n+        // EventEmitter tested in previous test\n+        const directiveDef = definitions[2];\n+        expect(directiveDef.contextSpan).toContain('export class EventSelectorDirective');\n       });\n     });\n   });\n@@ -264,21 +287,21 @@ describe('type definitions', () => {\n       const definitions = getTypeDefinitionsAndAssertBoundSpan({\n         templateOverride: `<div *ngFor=\"let item of heroes as her¦oes2; trackBy: test;\"></div>`,\n       });\n-      expectAllArrayDefinitions(definitions);\n+      expectAllDefinitions(definitions, new Set(['Array']), possibleArrayDefFiles);\n     });\n \n     it('should work for uses of members in structural directives', () => {\n       const definitions = getTypeDefinitionsAndAssertBoundSpan({\n         templateOverride: `<div *ngFor=\"let item of heroes as heroes2\">{{her¦oes2}}</div>`,\n       });\n-      expectAllArrayDefinitions(definitions);\n+      expectAllDefinitions(definitions, new Set(['Array']), possibleArrayDefFiles);\n     });\n \n     it('should work for members in structural directives', () => {\n       const definitions = getTypeDefinitionsAndAssertBoundSpan({\n         templateOverride: `<div *ngFor=\"let item of her¦oes; trackBy: test;\"></div>`,\n       });\n-      expectAllArrayDefinitions(definitions);\n+      expectAllDefinitions(definitions, new Set(['Array']), possibleArrayDefFiles);\n     });\n \n     it('should return nothing for the $any() cast function', () => {\n@@ -297,14 +320,12 @@ describe('type definitions', () => {\n     return defs!.map(d => humanizeDefinitionInfo(d, service));\n   }\n \n-  function expectAllArrayDefinitions(definitions: HumanizedDefinitionInfo[]) {\n+  function expectAllDefinitions(\n+      definitions: HumanizedDefinitionInfo[], textSpans: Set<string>,\n+      possibleFileNames: Set<string>) {\n     expect(definitions!.length).toBeGreaterThan(0);\n     const actualTextSpans = new Set(definitions.map(d => d.textSpan));\n-    expect(actualTextSpans).toEqual(new Set(['Array']));\n-    const possibleFileNames = [\n-      'lib.es5.d.ts', 'lib.es2015.core.d.ts', 'lib.es2015.iterable.d.ts',\n-      'lib.es2015.symbol.wellknown.d.ts', 'lib.es2016.array.include.d.ts'\n-    ];\n+    expect(actualTextSpans).toEqual(textSpans);\n     for (const def of definitions) {\n       const fileName = def.fileName.split('/').slice(-1)[0];\n       expect(possibleFileNames)"
        },
        {
            "sha": "8fb027c7c60d514723898f5b1087ddac22dc378a",
            "filename": "packages/language-service/ivy/utils.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 6,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/5bda62c51d8f5590755c04acb50b49cd8cd84bbd/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/5bda62c51d8f5590755c04acb50b49cd8cd84bbd/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Futils.ts?ref=5bda62c51d8f5590755c04acb50b49cd8cd84bbd",
            "patch": "@@ -143,8 +143,12 @@ function getInlineTemplateInfoAtPosition(\n /**\n  * Given an attribute node, converts it to string form.\n  */\n-function toAttributeString(attribute: t.TextAttribute|t.BoundAttribute): string {\n-  return `[${attribute.name}=${attribute.valueSpan?.toString() ?? ''}]`;\n+function toAttributeString(attribute: t.TextAttribute|t.BoundAttribute|t.BoundEvent): string {\n+  if (attribute instanceof t.BoundEvent) {\n+    return `[${attribute.name}]`;\n+  } else {\n+    return `[${attribute.name}=${attribute.valueSpan?.toString() ?? ''}]`;\n+  }\n }\n \n function getNodeName(node: t.Template|t.Element): string {\n@@ -154,8 +158,10 @@ function getNodeName(node: t.Template|t.Element): string {\n /**\n  * Given a template or element node, returns all attributes on the node.\n  */\n-function getAttributes(node: t.Template|t.Element): Array<t.TextAttribute|t.BoundAttribute> {\n-  const attributes: Array<t.TextAttribute|t.BoundAttribute> = [...node.attributes, ...node.inputs];\n+function getAttributes(node: t.Template|\n+                       t.Element): Array<t.TextAttribute|t.BoundAttribute|t.BoundEvent> {\n+  const attributes: Array<t.TextAttribute|t.BoundAttribute|t.BoundEvent> =\n+      [...node.attributes, ...node.inputs, ...node.outputs];\n   if (node instanceof t.Template) {\n     attributes.push(...node.templateAttrs);\n   }\n@@ -216,8 +222,8 @@ export function getDirectiveMatchesForAttribute(\n   const allDirectiveMatches =\n       getDirectiveMatchesForSelector(directives, getNodeName(hostNode) + allAttrs.join(''));\n   const attrsExcludingName = attributes.filter(a => a.name !== name).map(toAttributeString);\n-  const matchesWithoutAttr =\n-      getDirectiveMatchesForSelector(directives, attrsExcludingName.join(''));\n+  const matchesWithoutAttr = getDirectiveMatchesForSelector(\n+      directives, getNodeName(hostNode) + attrsExcludingName.join(''));\n   return difference(allDirectiveMatches, matchesWithoutAttr);\n }\n "
        },
        {
            "sha": "4860cc3930c91811c904e7a505a0d0e1b1b747d0",
            "filename": "packages/language-service/test/project/app/main.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/5bda62c51d8f5590755c04acb50b49cd8cd84bbd/packages%2Flanguage-service%2Ftest%2Fproject%2Fapp%2Fmain.ts",
            "raw_url": "https://github.com/angular/angular/raw/5bda62c51d8f5590755c04acb50b49cd8cd84bbd/packages%2Flanguage-service%2Ftest%2Fproject%2Fapp%2Fmain.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fproject%2Fapp%2Fmain.ts?ref=5bda62c51d8f5590755c04acb50b49cd8cd84bbd",
            "patch": "@@ -25,6 +25,7 @@ import * as ParsingCases from './parsing-cases';\n     ParsingCases.TestPipe,\n     ParsingCases.WithContextDirective,\n     ParsingCases.CompoundCustomButtonDirective,\n+    ParsingCases.EventSelectorDirective,\n   ]\n })\n export class AppModule {"
        },
        {
            "sha": "5f9bec3e7cd4dbe5f489bc0dbe9365a8e0e7e034",
            "filename": "packages/language-service/test/project/app/parsing-cases.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/5bda62c51d8f5590755c04acb50b49cd8cd84bbd/packages%2Flanguage-service%2Ftest%2Fproject%2Fapp%2Fparsing-cases.ts",
            "raw_url": "https://github.com/angular/angular/raw/5bda62c51d8f5590755c04acb50b49cd8cd84bbd/packages%2Flanguage-service%2Ftest%2Fproject%2Fapp%2Fparsing-cases.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Ftest%2Fproject%2Fapp%2Fparsing-cases.ts?ref=5bda62c51d8f5590755c04acb50b49cd8cd84bbd",
            "patch": "@@ -75,6 +75,11 @@ export class CompoundCustomButtonDirective {\n   @Input() config?: {color?: string};\n }\n \n+@Directive({selector: '[eventSelector]'})\n+export class EventSelectorDirective {\n+  @Output() eventSelector = new EventEmitter<void>();\n+}\n+\n @Pipe({\n   name: 'prefixPipe',\n })"
        }
    ],
    "stats": {
        "total": 204,
        "additions": 161,
        "deletions": 43
    }
}