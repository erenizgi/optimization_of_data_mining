{
    "author": "crisbeto",
    "message": "fix(core): error if detectChanges is called at the wrong time under specific circumstances (#40206)\n\nInternally we store lifecycle hooks in the format `[index, hook, index, hook]` and when\niterating over them, we check one place ahead to figure out whether we've hit found\na hook or an index. The problem is that the loop is set up to iterate up to `hooks.length`\nwhich means that we may go out of bounds on the last iteration, depending on where\nwe started. This appears to happen under a specific set of circumstances where a\ndirective calls `detectChanges` from an input setter while it has `ngOnChanges` and\n`ngAfterViewInit` hooks.\n\nThese changes resolve the issue by only iterating up to `length - 1` which guarantees that\nwe can always look one place ahead.\n\nThis appears to have regressed some time in version 10.\n\nFixes #38611.\n\nPR Close #40206",
    "sha": "e4fbab9ec8a575e0db97f5dee81e1e91ceb42c48",
    "files": [
        {
            "sha": "5199d2846e6d79a7cc7f2bfc56324fc6876dcf7d",
            "filename": "packages/core/src/render3/hooks.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/e4fbab9ec8a575e0db97f5dee81e1e91ceb42c48/packages%2Fcore%2Fsrc%2Frender3%2Fhooks.ts",
            "raw_url": "https://github.com/angular/angular/raw/e4fbab9ec8a575e0db97f5dee81e1e91ceb42c48/packages%2Fcore%2Fsrc%2Frender3%2Fhooks.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fhooks.ts?ref=e4fbab9ec8a575e0db97f5dee81e1e91ceb42c48",
            "patch": "@@ -212,9 +212,10 @@ function callHooks(\n       (currentView[PREORDER_HOOK_FLAGS] & PreOrderHookFlags.IndexOfTheNextPreOrderHookMaskMask) :\n       0;\n   const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;\n+  const max = arr.length - 1;  // Stop the loop at length - 1, because we look for the hook at i + 1\n   let lastNodeIndexFound = 0;\n-  for (let i = startIndex; i < arr.length; i++) {\n-    const hook = arr[i + 1] as () => void;\n+  for (let i = startIndex; i < max; i++) {\n+    const hook = arr[i + 1] as number | (() => void);\n     if (typeof hook === 'number') {\n       lastNodeIndexFound = arr[i] as number;\n       if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {\n@@ -250,8 +251,7 @@ function callHook(currentView: LView, initPhase: InitPhaseState, arr: HookData,\n   const directive = currentView[directiveIndex];\n   if (isInitHook) {\n     const indexWithintInitPhase = currentView[FLAGS] >> LViewFlags.IndexWithinInitPhaseShift;\n-    // The init phase state must be always checked here as it may have been recursively\n-    // updated\n+    // The init phase state must be always checked here as it may have been recursively updated.\n     if (indexWithintInitPhase <\n             (currentView[PREORDER_HOOK_FLAGS] >> PreOrderHookFlags.NumberOfInitHooksCalledShift) &&\n         (currentView[FLAGS] & LViewFlags.InitPhaseStateMask) === initPhase) {"
        },
        {
            "sha": "e322a78aeb8bbbdcd9ee5ebbc78272b532a31402",
            "filename": "packages/core/test/acceptance/lifecycle_spec.ts",
            "status": "modified",
            "additions": 69,
            "deletions": 2,
            "changes": 71,
            "blob_url": "https://github.com/angular/angular/blob/e4fbab9ec8a575e0db97f5dee81e1e91ceb42c48/packages%2Fcore%2Ftest%2Facceptance%2Flifecycle_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e4fbab9ec8a575e0db97f5dee81e1e91ceb42c48/packages%2Fcore%2Ftest%2Facceptance%2Flifecycle_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Flifecycle_spec.ts?ref=e4fbab9ec8a575e0db97f5dee81e1e91ceb42c48",
            "patch": "@@ -7,8 +7,7 @@\n  */\n \n import {CommonModule} from '@angular/common';\n-import {ChangeDetectorRef, Component, ComponentFactoryResolver, ContentChildren, Directive, Input, NgModule, OnChanges, QueryList, SimpleChanges, TemplateRef, ViewChild, ViewContainerRef} from '@angular/core';\n-import {SimpleChange} from '@angular/core/src/core';\n+import {AfterViewInit, ChangeDetectorRef, Component, ComponentFactoryResolver, ContentChildren, Directive, DoCheck, Input, NgModule, OnChanges, QueryList, SimpleChange, SimpleChanges, TemplateRef, ViewChild, ViewContainerRef} from '@angular/core';\n import {TestBed} from '@angular/core/testing';\n import {By} from '@angular/platform-browser';\n import {onlyInIvy} from '@angular/private/testing';\n@@ -4378,4 +4377,72 @@ describe('non-regression', () => {\n \n     expect(destroyed).toBeTruthy();\n   });\n+\n+  onlyInIvy('Use case is not supported in ViewEngine')\n+      .it('should not throw when calling detectChanges from a setter in the presence of a data binding, ngOnChanges and ngAfterViewInit',\n+          () => {\n+            const hooks: string[] = [];\n+\n+            @Directive({selector: '[testDir]'})\n+            class TestDirective implements OnChanges, AfterViewInit {\n+              constructor(private _changeDetectorRef: ChangeDetectorRef) {}\n+\n+              @Input('testDir')\n+              set value(_value: any) {\n+                this._changeDetectorRef.detectChanges();\n+              }\n+              ngOnChanges() {\n+                hooks.push('ngOnChanges');\n+              }\n+              ngAfterViewInit() {\n+                hooks.push('ngAfterViewInit');\n+              }\n+            }\n+\n+            @Component({template: `<div [testDir]=\"value\">{{value}}</div>`})\n+            class App {\n+              value = 1;\n+            }\n+\n+            TestBed.configureTestingModule({declarations: [App, TestDirective]});\n+            const fixture = TestBed.createComponent(App);\n+            expect(() => fixture.detectChanges()).not.toThrow();\n+            expect(hooks).toEqual(['ngOnChanges', 'ngAfterViewInit']);\n+            expect(fixture.nativeElement.textContent.trim()).toBe('1');\n+          });\n+\n+  onlyInIvy('Use case is not supported in ViewEngine')\n+      .it('should call hooks in the correct order when calling detectChanges in a setter', () => {\n+        const hooks: string[] = [];\n+\n+        @Directive({selector: '[testDir]'})\n+        class TestDirective implements OnChanges, DoCheck, AfterViewInit {\n+          constructor(private _changeDetectorRef: ChangeDetectorRef) {}\n+\n+          @Input('testDir')\n+          set value(_value: any) {\n+            this._changeDetectorRef.detectChanges();\n+          }\n+          ngOnChanges() {\n+            hooks.push('ngOnChanges');\n+          }\n+          ngDoCheck() {\n+            hooks.push('ngDoCheck');\n+          }\n+          ngAfterViewInit() {\n+            hooks.push('ngAfterViewInit');\n+          }\n+        }\n+\n+        @Component({template: `<div [testDir]=\"value\">{{value}}</div>`})\n+        class App {\n+          value = 1;\n+        }\n+\n+        TestBed.configureTestingModule({declarations: [App, TestDirective]});\n+        const fixture = TestBed.createComponent(App);\n+        expect(() => fixture.detectChanges()).not.toThrow();\n+        expect(hooks).toEqual(['ngOnChanges', 'ngDoCheck', 'ngAfterViewInit']);\n+        expect(fixture.nativeElement.textContent.trim()).toBe('1');\n+      });\n });"
        }
    ],
    "stats": {
        "total": 79,
        "additions": 73,
        "deletions": 6
    }
}