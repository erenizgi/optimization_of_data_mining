{
    "author": "alxhub",
    "message": "feat(language-service): autocompletion of element tags (#40032)\n\nThis commit expands the autocompletion capabilities of the language service\nto include element tag names. It presents both DOM elements from the Angular\nDOM schema as well as any components (or directives with element selectors)\nthat are in scope within the template as options for completion.\n\nPR Close #40032",
    "sha": "e42250f13950ef20a8acbb5871dc19c20800ddad",
    "files": [
        {
            "sha": "f87d6662cafedf0f48747ed25ab6ddb59e2d3c02",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/checker.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/e42250f13950ef20a8acbb5871dc19c20800ddad/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/e42250f13950ef20a8acbb5871dc19c20800ddad/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts?ref=e42250f13950ef20a8acbb5871dc19c20800ddad",
            "patch": "@@ -142,6 +142,13 @@ export interface TemplateTypeChecker {\n    * Get basic metadata on the pipes which are in scope for the given component.\n    */\n   getPipesInScope(component: ts.ClassDeclaration): PipeInScope[]|null;\n+\n+  /**\n+   * Retrieve a `Map` of potential template element tags, to either the `DirectiveInScope` that\n+   * declares them (if the tag is from a directive/component), or `null` if the tag originates from\n+   * the DOM schema.\n+   */\n+  getPotentialElementTags(component: ts.ClassDeclaration): Map<string, DirectiveInScope|null>;\n }\n \n /**"
        },
        {
            "sha": "54763b77a339ad251cfd4ab3124cec5f42d1f36b",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/scope.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/e42250f13950ef20a8acbb5871dc19c20800ddad/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fscope.ts",
            "raw_url": "https://github.com/angular/angular/raw/e42250f13950ef20a8acbb5871dc19c20800ddad/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fscope.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fscope.ts?ref=e42250f13950ef20a8acbb5871dc19c20800ddad",
            "patch": "@@ -7,6 +7,7 @@\n  */\n \n import * as ts from 'typescript';\n+import {ClassDeclaration} from '../../reflection';\n \n /**\n  * Metadata on a directive which is available in the scope of a template.\n@@ -17,6 +18,11 @@ export interface DirectiveInScope {\n    */\n   tsSymbol: ts.Symbol;\n \n+  /**\n+   * The module which declares the directive.\n+   */\n+  ngModule: ClassDeclaration|null;\n+\n   /**\n    * The selector for the directive or component.\n    */"
        },
        {
            "sha": "0640ac103b9e891bfce54903ec16230232b36891",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/symbols.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/e42250f13950ef20a8acbb5871dc19c20800ddad/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fsymbols.ts",
            "raw_url": "https://github.com/angular/angular/raw/e42250f13950ef20a8acbb5871dc19c20800ddad/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fsymbols.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fsymbols.ts?ref=e42250f13950ef20a8acbb5871dc19c20800ddad",
            "patch": "@@ -261,9 +261,6 @@ export interface DirectiveSymbol extends DirectiveInScope {\n \n   /** The location in the shim file for the variable that holds the type of the directive. */\n   shimLocation: ShimLocation;\n-\n-  /** The `NgModule` that this directive is declared in or `null` if it could not be determined. */\n-  ngModule: ClassDeclaration|null;\n }\n \n /**"
        },
        {
            "sha": "22acdfa999d9be6cdd16c202fdaed421319421df",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts",
            "status": "modified",
            "additions": 56,
            "deletions": 5,
            "changes": 61,
            "blob_url": "https://github.com/angular/angular/blob/e42250f13950ef20a8acbb5871dc19c20800ddad/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/e42250f13950ef20a8acbb5871dc19c20800ddad/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts?ref=e42250f13950ef20a8acbb5871dc19c20800ddad",
            "patch": "@@ -6,13 +6,13 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, MethodCall, ParseError, parseTemplate, PropertyRead, SafeMethodCall, SafePropertyRead, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n+import {AST, CssSelector, DomElementSchemaRegistry, MethodCall, ParseError, parseTemplate, PropertyRead, SafeMethodCall, SafePropertyRead, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {absoluteFrom, absoluteFromSourceFile, AbsoluteFsPath, getSourceFileOrError} from '../../file_system';\n import {ReferenceEmitter} from '../../imports';\n import {IncrementalBuild} from '../../incremental/api';\n-import {isNamedClassDeclaration, ReflectionHost} from '../../reflection';\n+import {ClassDeclaration, isNamedClassDeclaration, ReflectionHost} from '../../reflection';\n import {ComponentScopeReader} from '../../scope';\n import {isShim} from '../../shims';\n import {getSourceFileOrNull} from '../../util/src/typescript';\n@@ -26,6 +26,8 @@ import {TemplateSourceManager} from './source';\n import {findTypeCheckBlock, getTemplateMapping, TemplateSourceResolver} from './tcb_util';\n import {SymbolBuilder} from './template_symbol_builder';\n \n+\n+const REGISTRY = new DomElementSchemaRegistry();\n /**\n  * Primary template type-checking engine, which performs type-checking using a\n  * `TypeCheckingProgramStrategy` for type-checking program maintenance, and the\n@@ -54,13 +56,24 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n   /**\n    * Stores directives and pipes that are in scope for each component.\n    *\n-   * Unlike the other caches, the scope of a component is not affected by its template, so this\n+   * Unlike other caches, the scope of a component is not affected by its template, so this\n    * cache does not need to be invalidate if the template is overridden. It will be destroyed when\n    * the `ts.Program` changes and the `TemplateTypeCheckerImpl` as a whole is destroyed and\n    * replaced.\n    */\n   private scopeCache = new Map<ts.ClassDeclaration, ScopeData>();\n \n+  /**\n+   * Stores potential element tags for each component (a union of DOM tags as well as directive\n+   * tags).\n+   *\n+   * Unlike other caches, the scope of a component is not affected by its template, so this\n+   * cache does not need to be invalidate if the template is overridden. It will be destroyed when\n+   * the `ts.Program` changes and the `TemplateTypeCheckerImpl` as a whole is destroyed and\n+   * replaced.\n+   */\n+  private elementTagCache = new Map<ts.ClassDeclaration, Map<string, DirectiveInScope|null>>();\n+\n   private isComplete = false;\n \n   constructor(\n@@ -500,6 +513,36 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     return data.pipes;\n   }\n \n+  getPotentialElementTags(component: ts.ClassDeclaration): Map<string, DirectiveInScope|null> {\n+    if (this.elementTagCache.has(component)) {\n+      return this.elementTagCache.get(component)!;\n+    }\n+\n+    const tagMap = new Map<string, DirectiveInScope|null>();\n+\n+    for (const tag of REGISTRY.allKnownElementNames()) {\n+      tagMap.set(tag, null);\n+    }\n+\n+    const scope = this.getScopeData(component);\n+    if (scope !== null) {\n+      for (const directive of scope.directives) {\n+        for (const selector of CssSelector.parse(directive.selector)) {\n+          if (selector.element === null || tagMap.has(selector.element)) {\n+            // Skip this directive if it doesn't match an element tag, or if another directive has\n+            // already been included with the same element name.\n+            continue;\n+          }\n+\n+          tagMap.set(selector.element, directive);\n+        }\n+      }\n+    }\n+\n+    this.elementTagCache.set(component, tagMap);\n+    return tagMap;\n+  }\n+\n   private getScopeData(component: ts.ClassDeclaration): ScopeData|null {\n     if (this.scopeCache.has(component)) {\n       return this.scopeCache.get(component)!;\n@@ -521,7 +564,7 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     };\n \n     const typeChecker = this.typeCheckingStrategy.getProgram().getTypeChecker();\n-    for (const dir of scope.exported.directives) {\n+    for (const dir of scope.compilation.directives) {\n       if (dir.selector === null) {\n         // Skip this directive, it can't be added to a template anyway.\n         continue;\n@@ -530,14 +573,22 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n       if (tsSymbol === undefined) {\n         continue;\n       }\n+\n+      let ngModule: ClassDeclaration|null = null;\n+      const moduleScopeOfDir = this.componentScopeReader.getScopeForComponent(dir.ref.node);\n+      if (moduleScopeOfDir !== null) {\n+        ngModule = moduleScopeOfDir.ngModule;\n+      }\n+\n       data.directives.push({\n         isComponent: dir.isComponent,\n         selector: dir.selector,\n         tsSymbol,\n+        ngModule,\n       });\n     }\n \n-    for (const pipe of scope.exported.pipes) {\n+    for (const pipe of scope.compilation.pipes) {\n       const tsSymbol = typeChecker.getSymbolAtLocation(pipe.ref.node.name);\n       if (tsSymbol === undefined) {\n         continue;"
        },
        {
            "sha": "f8aaa3c3059a798f8434356ba122e33cc8d10bb8",
            "filename": "packages/language-service/ivy/completions.ts",
            "status": "modified",
            "additions": 111,
            "deletions": 7,
            "changes": 118,
            "blob_url": "https://github.com/angular/angular/blob/e42250f13950ef20a8acbb5871dc19c20800ddad/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "raw_url": "https://github.com/angular/angular/raw/e42250f13950ef20a8acbb5871dc19c20800ddad/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fcompletions.ts?ref=e42250f13950ef20a8acbb5871dc19c20800ddad",
            "patch": "@@ -6,19 +6,26 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, EmptyExpr, ImplicitReceiver, LiteralPrimitive, MethodCall, PropertyRead, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\n+import {AST, EmptyExpr, ImplicitReceiver, LiteralPrimitive, MethodCall, PropertyRead, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\n import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n-import {CompletionKind, TemplateDeclarationSymbol} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n-import {BoundEvent} from '@angular/compiler/src/render3/r3_ast';\n+import {CompletionKind, DirectiveInScope, TemplateDeclarationSymbol} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import * as ts from 'typescript';\n \n-import {DisplayInfoKind, getDisplayInfo, unsafeCastDisplayInfoKindToScriptElementKind} from './display_parts';\n+import {DisplayInfoKind, getDirectiveDisplayInfo, getSymbolDisplayInfo, unsafeCastDisplayInfoKindToScriptElementKind} from './display_parts';\n import {filterAliasImports} from './utils';\n \n type PropertyExpressionCompletionBuilder =\n     CompletionBuilder<PropertyRead|PropertyWrite|MethodCall|EmptyExpr|SafePropertyRead|\n                       SafeMethodCall>;\n \n+\n+export enum CompletionNodeContext {\n+  None,\n+  ElementTag,\n+  ElementAttributeKey,\n+  ElementAttributeValue,\n+}\n+\n /**\n  * Performs autocompletion operations on a given node in the template.\n  *\n@@ -37,6 +44,7 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n   constructor(\n       private readonly tsLS: ts.LanguageService, private readonly compiler: NgCompiler,\n       private readonly component: ts.ClassDeclaration, private readonly node: N,\n+      private readonly nodeContext: CompletionNodeContext,\n       private readonly nodeParent: TmplAstNode|AST|null,\n       private readonly template: TmplAstTemplate|null) {}\n \n@@ -47,6 +55,8 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n                            undefined): ts.WithMetadata<ts.CompletionInfo>|undefined {\n     if (this.isPropertyExpressionCompletion()) {\n       return this.getPropertyExpressionCompletion(options);\n+    } else if (this.isElementTagCompletion()) {\n+      return this.getElementTagCompletion();\n     } else {\n       return undefined;\n     }\n@@ -60,6 +70,8 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n       preferences: ts.UserPreferences|undefined): ts.CompletionEntryDetails|undefined {\n     if (this.isPropertyExpressionCompletion()) {\n       return this.getPropertyExpressionCompletionDetails(entryName, formatOptions, preferences);\n+    } else if (this.isElementTagCompletion()) {\n+      return this.getElementTagCompletionDetails(entryName);\n     } else {\n       return undefined;\n     }\n@@ -71,6 +83,8 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n   getCompletionEntrySymbol(name: string): ts.Symbol|undefined {\n     if (this.isPropertyExpressionCompletion()) {\n       return this.getPropertyExpressionCompletionSymbol(name);\n+    } else if (this.isElementTagCompletion()) {\n+      return this.getElementTagCompletionSymbol(name);\n     } else {\n       return undefined;\n     }\n@@ -268,7 +282,7 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n       }\n \n       const {kind, displayParts, documentation} =\n-          getDisplayInfo(this.tsLS, this.typeChecker, symbol);\n+          getSymbolDisplayInfo(this.tsLS, this.typeChecker, symbol);\n       return {\n         kind: unsafeCastDisplayInfoKindToScriptElementKind(kind),\n         name: entryName,\n@@ -311,6 +325,84 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n           /* source */ undefined);\n     }\n   }\n+\n+  private isElementTagCompletion(): this is CompletionBuilder<TmplAstElement> {\n+    return this.node instanceof TmplAstElement &&\n+        this.nodeContext === CompletionNodeContext.ElementTag;\n+  }\n+\n+  private getElementTagCompletion(this: CompletionBuilder<TmplAstElement>):\n+      ts.WithMetadata<ts.CompletionInfo>|undefined {\n+    const templateTypeChecker = this.compiler.getTemplateTypeChecker();\n+\n+    // The replacementSpan is the tag name.\n+    const replacementSpan: ts.TextSpan = {\n+      start: this.node.sourceSpan.start.offset + 1,  // account for leading '<'\n+      length: this.node.name.length,\n+    };\n+\n+    const entries: ts.CompletionEntry[] =\n+        Array.from(templateTypeChecker.getPotentialElementTags(this.component))\n+            .map(([tag, directive]) => ({\n+                   kind: tagCompletionKind(directive),\n+                   name: tag,\n+                   sortText: tag,\n+                   replacementSpan,\n+                 }));\n+\n+    return {\n+      entries,\n+      isGlobalCompletion: false,\n+      isMemberCompletion: false,\n+      isNewIdentifierLocation: false,\n+    };\n+  }\n+\n+  private getElementTagCompletionDetails(\n+      this: CompletionBuilder<TmplAstElement>, entryName: string): ts.CompletionEntryDetails\n+      |undefined {\n+    const templateTypeChecker = this.compiler.getTemplateTypeChecker();\n+\n+    const tagMap = templateTypeChecker.getPotentialElementTags(this.component);\n+    if (!tagMap.has(entryName)) {\n+      return undefined;\n+    }\n+\n+    const directive = tagMap.get(entryName)!;\n+    let displayParts: ts.SymbolDisplayPart[];\n+    let documentation: ts.SymbolDisplayPart[]|undefined = undefined;\n+    if (directive === null) {\n+      displayParts = [];\n+    } else {\n+      const displayInfo = getDirectiveDisplayInfo(this.tsLS, directive);\n+      displayParts = displayInfo.displayParts;\n+      documentation = displayInfo.documentation;\n+    }\n+\n+    return {\n+      kind: tagCompletionKind(directive),\n+      name: entryName,\n+      kindModifiers: ts.ScriptElementKindModifier.none,\n+      displayParts,\n+      documentation,\n+    };\n+  }\n+\n+  private getElementTagCompletionSymbol(this: CompletionBuilder<TmplAstElement>, entryName: string):\n+      ts.Symbol|undefined {\n+    const templateTypeChecker = this.compiler.getTemplateTypeChecker();\n+\n+    const tagMap = templateTypeChecker.getPotentialElementTags(this.component);\n+    if (!tagMap.has(entryName)) {\n+      return undefined;\n+    }\n+\n+    const directive = tagMap.get(entryName)!;\n+    return directive?.tsSymbol;\n+  }\n+\n+  // private getElementAttributeCompletions(this: CompletionBuilder<TmplAstElement>):\n+  //     ts.WithMetadata<ts.CompletionInfo> {}\n }\n \n /**\n@@ -323,8 +415,8 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n  */\n function isBrokenEmptyBoundEventExpression(\n     node: TmplAstNode|AST, parent: TmplAstNode|AST|null): node is LiteralPrimitive {\n-  return node instanceof LiteralPrimitive && parent !== null && parent instanceof BoundEvent &&\n-      node.value === 'ERROR';\n+  return node instanceof LiteralPrimitive && parent !== null &&\n+      parent instanceof TmplAstBoundEvent && node.value === 'ERROR';\n }\n \n function makeReplacementSpan(node: PropertyRead|PropertyWrite|MethodCall|SafePropertyRead|\n@@ -334,3 +426,15 @@ function makeReplacementSpan(node: PropertyRead|PropertyWrite|MethodCall|SafePro\n     length: node.nameSpan.end - node.nameSpan.start,\n   };\n }\n+\n+function tagCompletionKind(directive: DirectiveInScope|null): ts.ScriptElementKind {\n+  let kind: DisplayInfoKind;\n+  if (directive === null) {\n+    kind = DisplayInfoKind.ELEMENT;\n+  } else if (directive.isComponent) {\n+    kind = DisplayInfoKind.COMPONENT;\n+  } else {\n+    kind = DisplayInfoKind.DIRECTIVE;\n+  }\n+  return unsafeCastDisplayInfoKindToScriptElementKind(kind);\n+}"
        },
        {
            "sha": "528f17e07ab072054d8bff77f6fa755e407b00f1",
            "filename": "packages/language-service/ivy/display_parts.ts",
            "status": "modified",
            "additions": 25,
            "deletions": 2,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/e42250f13950ef20a8acbb5871dc19c20800ddad/packages%2Flanguage-service%2Fivy%2Fdisplay_parts.ts",
            "raw_url": "https://github.com/angular/angular/raw/e42250f13950ef20a8acbb5871dc19c20800ddad/packages%2Flanguage-service%2Fivy%2Fdisplay_parts.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fdisplay_parts.ts?ref=e42250f13950ef20a8acbb5871dc19c20800ddad",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {ReferenceSymbol, ShimLocation, Symbol, SymbolKind, VariableSymbol} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n+import {DirectiveInScope, ReferenceSymbol, ShimLocation, Symbol, SymbolKind, VariableSymbol} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import * as ts from 'typescript';\n \n \n@@ -40,7 +40,7 @@ export interface DisplayInfo {\n   documentation: ts.SymbolDisplayPart[]|undefined;\n }\n \n-export function getDisplayInfo(\n+export function getSymbolDisplayInfo(\n     tsLS: ts.LanguageService, typeChecker: ts.TypeChecker,\n     symbol: ReferenceSymbol|VariableSymbol): DisplayInfo {\n   let kind: DisplayInfoKind;\n@@ -126,3 +126,26 @@ function getDocumentationFromTypeDefAtLocation(\n   return tsLS.getQuickInfoAtPosition(typeDefs[0].fileName, typeDefs[0].textSpan.start)\n       ?.documentation;\n }\n+\n+export function getDirectiveDisplayInfo(\n+    tsLS: ts.LanguageService, dir: DirectiveInScope): DisplayInfo {\n+  const kind = dir.isComponent ? DisplayInfoKind.COMPONENT : DisplayInfoKind.DIRECTIVE;\n+  const decl = dir.tsSymbol.declarations.find(ts.isClassDeclaration);\n+  if (decl === undefined || decl.name === undefined) {\n+    return {kind, displayParts: [], documentation: []};\n+  }\n+\n+  const res = tsLS.getQuickInfoAtPosition(decl.getSourceFile().fileName, decl.name.getStart());\n+  if (res === undefined) {\n+    return {kind, displayParts: [], documentation: []};\n+  }\n+\n+  const displayParts =\n+      createDisplayParts(dir.tsSymbol.name, kind, dir.ngModule?.name?.text, undefined);\n+\n+  return {\n+    kind,\n+    displayParts,\n+    documentation: res.documentation,\n+  };\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "20a0c735a08fcf63f6065ee05f244916855c63e1",
            "filename": "packages/language-service/ivy/language_service.ts",
            "status": "modified",
            "additions": 20,
            "deletions": 5,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/e42250f13950ef20a8acbb5871dc19c20800ddad/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "raw_url": "https://github.com/angular/angular/raw/e42250f13950ef20a8acbb5871dc19c20800ddad/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts?ref=e42250f13950ef20a8acbb5871dc19c20800ddad",
            "patch": "@@ -15,11 +15,11 @@ import * as ts from 'typescript/lib/tsserverlibrary';\n \n import {LanguageServiceAdapter, LSParseConfigHost} from './adapters';\n import {CompilerFactory} from './compiler_factory';\n-import {CompletionBuilder} from './completions';\n+import {CompletionBuilder, CompletionNodeContext} from './completions';\n import {DefinitionBuilder} from './definitions';\n import {QuickInfoBuilder} from './quick_info';\n import {ReferenceBuilder} from './references';\n-import {getTargetAtPosition} from './template_target';\n+import {getTargetAtPosition, TargetNode, TargetNodeKind} from './template_target';\n import {getTemplateInfoAtPosition, isTypeScriptFile} from './utils';\n \n export class LanguageService {\n@@ -133,7 +133,8 @@ export class LanguageService {\n     }\n     return new CompletionBuilder(\n         this.tsLS, compiler, templateInfo.component, positionDetails.nodeInContext.node,\n-        positionDetails.parent, positionDetails.template);\n+        nodeContextFromTarget(positionDetails.nodeInContext), positionDetails.parent,\n+        positionDetails.template);\n   }\n \n   getCompletionsAtPosition(\n@@ -161,12 +162,13 @@ export class LanguageService {\n     return result;\n   }\n \n-  getCompletionEntrySymbol(fileName: string, position: number, name: string): ts.Symbol|undefined {\n+  getCompletionEntrySymbol(fileName: string, position: number, entryName: string): ts.Symbol\n+      |undefined {\n     const builder = this.getCompletionBuilder(fileName, position);\n     if (builder === null) {\n       return undefined;\n     }\n-    const result = builder.getCompletionEntrySymbol(name);\n+    const result = builder.getCompletionEntrySymbol(entryName);\n     this.compilerFactory.registerLastKnownProgram();\n     return result;\n   }\n@@ -255,3 +257,16 @@ function getOrCreateTypeCheckScriptInfo(\n   }\n   return scriptInfo;\n }\n+\n+function nodeContextFromTarget(target: TargetNode): CompletionNodeContext {\n+  switch (target.kind) {\n+    case TargetNodeKind.ElementInTagContext:\n+      return CompletionNodeContext.ElementTag;\n+    case TargetNodeKind.ElementInBodyContext:\n+      // Completions in element bodies are for new attributes.\n+      return CompletionNodeContext.ElementAttributeKey;\n+    default:\n+      // No special context is available.\n+      return CompletionNodeContext.None;\n+  }\n+}"
        },
        {
            "sha": "4edeed79b87ff0e9f15fb7221afdd39adecbcd7b",
            "filename": "packages/language-service/ivy/test/completions_spec.ts",
            "status": "modified",
            "additions": 68,
            "deletions": 4,
            "changes": 72,
            "blob_url": "https://github.com/angular/angular/blob/e42250f13950ef20a8acbb5871dc19c20800ddad/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e42250f13950ef20a8acbb5871dc19c20800ddad/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts?ref=e42250f13950ef20a8acbb5871dc19c20800ddad",
            "patch": "@@ -10,7 +10,7 @@ import {TmplAstNode} from '@angular/compiler';\n import {absoluteFrom, AbsoluteFsPath} from '@angular/compiler-cli/src/ngtsc/file_system';\n import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n import * as ts from 'typescript';\n-import {DisplayInfoKind} from '../display_parts';\n+import {DisplayInfoKind, unsafeCastDisplayInfoKindToScriptElementKind} from '../display_parts';\n import {LanguageService} from '../language_service';\n \n import {LanguageServiceTestEnvironment} from './env';\n@@ -198,6 +198,61 @@ describe('completions', () => {\n       });\n     });\n   });\n+\n+  describe('element tag scope', () => {\n+    it('should return DOM completions', () => {\n+      const {ngLS, fileName, cursor} = setup(`<div¦>`, '');\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectContain(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.ELEMENT),\n+          ['div', 'span']);\n+    });\n+\n+    it('should return directive completions', () => {\n+      const OTHER_DIR = {\n+        'OtherDir': `\n+            /** This is another directive. */\n+            @Directive({selector: 'other-dir'})\n+            export class OtherDir {}\n+          `,\n+      };\n+      const {ngLS, fileName, cursor} = setup(`<div¦>`, '', OTHER_DIR);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectContain(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.DIRECTIVE),\n+          ['other-dir']);\n+\n+      const details =\n+          ngLS.getCompletionEntryDetails(fileName, cursor, 'other-dir', undefined, undefined)!;\n+      expect(details).toBeDefined();\n+      expect(ts.displayPartsToString(details.displayParts))\n+          .toEqual('(directive) AppModule.OtherDir');\n+      expect(ts.displayPartsToString(details.documentation!)).toEqual('This is another directive.');\n+    });\n+\n+    it('should return component completions', () => {\n+      const OTHER_CMP = {\n+        'OtherCmp': `\n+            /** This is another component. */\n+            @Component({selector: 'other-cmp', template: 'unimportant'})\n+            export class OtherCmp {}\n+          `,\n+      };\n+      const {ngLS, fileName, cursor} = setup(`<div¦>`, '', OTHER_CMP);\n+      const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n+      expectContain(\n+          completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.COMPONENT),\n+          ['other-cmp']);\n+\n+\n+      const details =\n+          ngLS.getCompletionEntryDetails(fileName, cursor, 'other-cmp', undefined, undefined)!;\n+      expect(details).toBeDefined();\n+      expect(ts.displayPartsToString(details.displayParts))\n+          .toEqual('(component) AppModule.OtherCmp');\n+      expect(ts.displayPartsToString(details.documentation!)).toEqual('This is another component.');\n+    });\n+  });\n });\n \n function expectContain(\n@@ -223,7 +278,9 @@ function toText(displayParts?: ts.SymbolDisplayPart[]): string {\n   return (displayParts ?? []).map(p => p.text).join('');\n }\n \n-function setup(templateWithCursor: string, classContents: string): {\n+function setup(\n+    templateWithCursor: string, classContents: string,\n+    otherDirectives: {[name: string]: string} = {}): {\n   env: LanguageServiceTestEnvironment,\n   fileName: AbsoluteFsPath,\n   AppCmp: ts.ClassDeclaration,\n@@ -233,11 +290,16 @@ function setup(templateWithCursor: string, classContents: string): {\n } {\n   const codePath = absoluteFrom('/test.ts');\n   const templatePath = absoluteFrom('/test.html');\n+\n+  const decls = ['AppCmp', ...Object.keys(otherDirectives)];\n+\n+  const otherDirectiveClassDecls = Object.values(otherDirectives).join('\\n\\n');\n+\n   const env = LanguageServiceTestEnvironment.setup([\n     {\n       name: codePath,\n       contents: `\n-        import {Component, NgModule} from '@angular/core';\n+        import {Component, Directive, NgModule} from '@angular/core';\n \n         @Component({\n           templateUrl: './test.html',\n@@ -247,8 +309,10 @@ function setup(templateWithCursor: string, classContents: string): {\n           ${classContents}\n         }\n         \n+        ${otherDirectiveClassDecls}\n+\n         @NgModule({\n-          declarations: [AppCmp],\n+          declarations: [${decls.join(', ')}],\n         })\n         export class AppModule {}\n         `,"
        }
    ],
    "stats": {
        "total": 319,
        "additions": 293,
        "deletions": 26
    }
}