{
    "author": "josephperrott",
    "message": "fix(dev-infra): run caretaker checks asyncronously (#39086)\n\nRun each check in the caretaker check process asyncronously.\n\nPR Close #39086",
    "sha": "2d797803841610e5ef8dbecb6d34be500fa6066b",
    "files": [
        {
            "sha": "7de91c849fca644db71bfb3f6b738d83a03bc149",
            "filename": "dev-infra/caretaker/BUILD.bazel",
            "status": "modified",
            "additions": 29,
            "deletions": 3,
            "changes": 32,
            "blob_url": "https://github.com/angular/angular/blob/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fcaretaker%2FBUILD.bazel?ref=2d797803841610e5ef8dbecb6d34be500fa6066b",
            "patch": "@@ -1,10 +1,12 @@\n load(\"@npm//@bazel/typescript:index.bzl\", \"ts_library\")\n+load(\"//tools:defaults.bzl\", \"jasmine_node_test\")\n \n ts_library(\n     name = \"caretaker\",\n-    srcs = glob([\n-        \"**/*.ts\",\n-    ]),\n+    srcs = glob(\n+        [\"**/*.ts\"],\n+        exclude = [\"**/*.spec.ts\"],\n+    ),\n     module_name = \"@angular/dev-infra-private/caretaker\",\n     visibility = [\"//dev-infra:__subpackages__\"],\n     deps = [\n@@ -20,3 +22,27 @@ ts_library(\n         \"@npm//yargs\",\n     ],\n )\n+\n+ts_library(\n+    name = \"test_lib\",\n+    testonly = True,\n+    srcs = glob([\"**/*.spec.ts\"]),\n+    deps = [\n+        \":caretaker\",\n+        \"//dev-infra/release/versioning\",\n+        \"//dev-infra/utils\",\n+        \"//dev-infra/utils/testing\",\n+        \"@npm//@types/jasmine\",\n+        \"@npm//@types/node\",\n+        \"@npm//@types/semver\",\n+        \"@npm//semver\",\n+    ],\n+)\n+\n+jasmine_node_test(\n+    name = \"test\",\n+    bootstrap = [\"//tools/testing:node_no_angular_es5\"],\n+    deps = [\n+        \":test_lib\",\n+    ],\n+)"
        },
        {
            "sha": "32f2d9e8976db2740206591c8e0b2dc3cde20066",
            "filename": "dev-infra/caretaker/check/base.spec.ts",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fbase.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fbase.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fcaretaker%2Fcheck%2Fbase.spec.ts?ref=2d797803841610e5ef8dbecb6d34be500fa6066b",
            "patch": "@@ -0,0 +1,40 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {BaseModule} from './base';\n+\n+/** Data mocking as the \"retrieved data\". */\n+const exampleData = 'this is example data' as const;\n+\n+/** A simple usage of the BaseModule to illustrate the workings built into the abstract class. */\n+class ConcreteBaseModule extends BaseModule<typeof exampleData> {\n+  async retrieveData() {\n+    return exampleData;\n+  }\n+  async printToTerminal() {}\n+}\n+\n+describe('BaseModule', () => {\n+  let retrieveDataSpy: jasmine.Spy;\n+\n+  beforeEach(() => {\n+    retrieveDataSpy = spyOn(ConcreteBaseModule.prototype, 'retrieveData');\n+  });\n+\n+  it('begins retrieving data during construction', () => {\n+    new ConcreteBaseModule({} as any, {} as any);\n+\n+    expect(retrieveDataSpy).toHaveBeenCalled();\n+  });\n+\n+  it('makes the data available via the data attribute', async () => {\n+    retrieveDataSpy.and.callThrough();\n+    const module = new ConcreteBaseModule({} as any, {} as any);\n+\n+    expect(await module.data).toBe(exampleData);\n+  });\n+});"
        },
        {
            "sha": "338688a4c45c819893df7d9773f0623f8f085a11",
            "filename": "dev-infra/caretaker/check/base.ts",
            "status": "added",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fbase.ts",
            "raw_url": "https://github.com/angular/angular/raw/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fbase.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fcaretaker%2Fcheck%2Fbase.ts?ref=2d797803841610e5ef8dbecb6d34be500fa6066b",
            "patch": "@@ -0,0 +1,25 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {NgDevConfig} from '../../utils/config';\n+import {GitClient} from '../../utils/git/index';\n+import {CaretakerConfig} from '../config';\n+\n+/** The BaseModule to extend modules for caretaker checks from. */\n+export abstract class BaseModule<Data> {\n+  /** The data for the module. */\n+  readonly data = this.retrieveData();\n+\n+  constructor(\n+      protected git: GitClient, protected config: NgDevConfig<{caretaker: CaretakerConfig}>) {}\n+\n+  /** Asyncronously retrieve data for the module. */\n+  protected abstract async retrieveData(): Promise<Data>;\n+\n+  /** Print the information discovered for the module to the terminal. */\n+  abstract async printToTerminal(): Promise<void>;\n+}"
        },
        {
            "sha": "4202059b2f382168ad9e01da8073c83ecab009dd",
            "filename": "dev-infra/caretaker/check/check.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 9,
            "changes": 30,
            "blob_url": "https://github.com/angular/angular/blob/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fcheck.ts",
            "raw_url": "https://github.com/angular/angular/raw/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fcheck.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fcaretaker%2Fcheck%2Fcheck.ts?ref=2d797803841610e5ef8dbecb6d34be500fa6066b",
            "patch": "@@ -9,11 +9,18 @@\n import {GitClient} from '../../utils/git/index';\n import {getCaretakerConfig} from '../config';\n \n-import {printCiStatus} from './ci';\n-import {printG3Comparison} from './g3';\n-import {printGithubTasks} from './github';\n-import {printServiceStatuses} from './services';\n+import {CiModule} from './ci';\n+import {G3Module} from './g3';\n+import {GithubQueriesModule} from './github';\n+import {ServicesModule} from './services';\n \n+/** List of modules checked for the caretaker check command. */\n+const moduleList = [\n+  GithubQueriesModule,\n+  ServicesModule,\n+  CiModule,\n+  G3Module,\n+];\n \n /** Check the status of services which Angular caretakers need to monitor. */\n export async function checkServiceStatuses(githubToken: string) {\n@@ -23,10 +30,15 @@ export async function checkServiceStatuses(githubToken: string) {\n   const git = new GitClient(githubToken, config);\n   // Prevent logging of the git commands being executed during the check.\n   GitClient.LOG_COMMANDS = false;\n+  /** List of instances of Caretaker Check modules */\n+  const caretakerCheckModules = moduleList.map(module => new module(git, config));\n \n-  // TODO(josephperrott): Allow these checks to be loaded in parallel.\n-  await printServiceStatuses();\n-  await printGithubTasks(git, config.caretaker);\n-  await printG3Comparison(git);\n-  await printCiStatus(git);\n+  // Module's `data` is casted as Promise<unknown> because the data types of the `module`'s `data`\n+  // promises do not match typings, however our usage here is only to determine when the promise\n+  // resolves.\n+  await Promise.all(caretakerCheckModules.map(module => module.data as Promise<unknown>));\n+\n+  for (const module of caretakerCheckModules) {\n+    await module.printToTerminal();\n+  }\n }"
        },
        {
            "sha": "74c7ef30f24cf61a81e574fabe7061087eda0092",
            "filename": "dev-infra/caretaker/check/ci.spec.ts",
            "status": "added",
            "additions": 118,
            "deletions": 0,
            "changes": 118,
            "blob_url": "https://github.com/angular/angular/blob/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fci.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fci.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fcaretaker%2Fcheck%2Fci.spec.ts?ref=2d797803841610e5ef8dbecb6d34be500fa6066b",
            "patch": "@@ -0,0 +1,118 @@\n+\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {SemVer} from 'semver';\n+import {ReleaseTrain} from '../../release/versioning';\n+\n+import * as versioning from '../../release/versioning/active-release-trains';\n+import * as console from '../../utils/console';\n+import {buildVirtualGitClient, mockNgDevConfig, VirtualGitClient} from '../../utils/testing';\n+\n+import {CiModule} from './ci';\n+\n+describe('CiModule', () => {\n+  let fetchActiveReleaseTrainsSpy: jasmine.Spy;\n+  let getBranchStatusFromCiSpy: jasmine.Spy;\n+  let infoSpy: jasmine.Spy;\n+  let debugSpy: jasmine.Spy;\n+  let virtualGitClient: VirtualGitClient;\n+\n+  beforeEach(() => {\n+    virtualGitClient = buildVirtualGitClient();\n+    fetchActiveReleaseTrainsSpy = spyOn(versioning, 'fetchActiveReleaseTrains');\n+    getBranchStatusFromCiSpy = spyOn(CiModule.prototype, 'getBranchStatusFromCi' as any);\n+    infoSpy = spyOn(console, 'info');\n+    debugSpy = spyOn(console, 'debug');\n+  });\n+\n+  describe('getting data for active trains', () => {\n+    it('handles active rc train', async () => {\n+      const trains = buildMockActiveReleaseTrains(true);\n+      fetchActiveReleaseTrainsSpy.and.resolveTo(trains);\n+      const module = new CiModule(virtualGitClient, {caretaker: {}, ...mockNgDevConfig});\n+      await module.data;\n+\n+      expect(getBranchStatusFromCiSpy).toHaveBeenCalledWith(trains.releaseCandidate.branchName);\n+      expect(getBranchStatusFromCiSpy).toHaveBeenCalledWith(trains.latest.branchName);\n+      expect(getBranchStatusFromCiSpy).toHaveBeenCalledWith(trains.next.branchName);\n+      expect(getBranchStatusFromCiSpy).toHaveBeenCalledTimes(3);\n+    });\n+\n+    it('handles an inactive rc train', async () => {\n+      const trains = buildMockActiveReleaseTrains(false);\n+      fetchActiveReleaseTrainsSpy.and.resolveTo(trains);\n+      const module = new CiModule(virtualGitClient, {caretaker: {}, ...mockNgDevConfig});\n+      await module.data;\n+\n+      expect(getBranchStatusFromCiSpy).toHaveBeenCalledWith(trains.latest.branchName);\n+      expect(getBranchStatusFromCiSpy).toHaveBeenCalledWith(trains.next.branchName);\n+      expect(getBranchStatusFromCiSpy).toHaveBeenCalledTimes(2);\n+    });\n+\n+    it('aggregates information into a useful structure', async () => {\n+      const trains = buildMockActiveReleaseTrains(false);\n+      fetchActiveReleaseTrainsSpy.and.resolveTo(trains);\n+      getBranchStatusFromCiSpy.and.returnValue('success');\n+      const module = new CiModule(virtualGitClient, {caretaker: {}, ...mockNgDevConfig});\n+      const data = await module.data;\n+\n+      expect(data[0]).toEqual(\n+          {active: false, name: 'releaseCandidate', label: '', status: 'not found'});\n+      expect(data[1]).toEqual({\n+        active: true,\n+        name: 'latest-branch',\n+        label: 'latest (latest-branch)',\n+        status: 'success',\n+      });\n+    });\n+  });\n+\n+  it('prints the data retrieved', async () => {\n+    const fakeData = Promise.resolve([\n+      {\n+        active: true,\n+        name: 'name0',\n+        label: 'label0',\n+        status: 'success',\n+      },\n+      {\n+        active: false,\n+        name: 'name1',\n+        label: 'label1',\n+        status: 'failed',\n+      },\n+    ]);\n+    fetchActiveReleaseTrainsSpy.and.resolveTo([]);\n+\n+    const module = new CiModule(virtualGitClient, {caretaker: {}, ...mockNgDevConfig});\n+    Object.defineProperty(module, 'data', {value: fakeData});\n+\n+    await module.printToTerminal();\n+\n+    expect(debugSpy).toHaveBeenCalledWith('No active release train for name1');\n+    expect(infoSpy).toHaveBeenCalledWith('label0 ✅');\n+  });\n+});\n+\n+\n+/** Build a mock set of ActiveReleaseTrains. */\n+function buildMockActiveReleaseTrains(withRc: false): versioning.ActiveReleaseTrains&\n+    {releaseCandidate: null};\n+function buildMockActiveReleaseTrains(withRc: true): versioning.ActiveReleaseTrains&\n+    {releaseCandidate: ReleaseTrain};\n+function buildMockActiveReleaseTrains(withRc: boolean): versioning.ActiveReleaseTrains {\n+  const baseResult = {\n+    isMajor: false,\n+    version: new SemVer('0.0.0'),\n+  };\n+  return {\n+    releaseCandidate: withRc ? {branchName: 'rc-branch', ...baseResult} : null,\n+    latest: {branchName: 'latest-branch', ...baseResult},\n+    next: {branchName: 'next-branch', ...baseResult}\n+  };\n+}"
        },
        {
            "sha": "41985b9f0c31fe5eeafd52d6e20aabce0ca5d306",
            "filename": "dev-infra/caretaker/check/ci.ts",
            "status": "modified",
            "additions": 66,
            "deletions": 40,
            "changes": 106,
            "blob_url": "https://github.com/angular/angular/blob/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fci.ts",
            "raw_url": "https://github.com/angular/angular/raw/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fci.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fcaretaker%2Fcheck%2Fci.ts?ref=2d797803841610e5ef8dbecb6d34be500fa6066b",
            "patch": "@@ -7,56 +7,82 @@\n  */\n \n import fetch from 'node-fetch';\n-import {fetchActiveReleaseTrains} from '../../release/versioning/index';\n+import {fetchActiveReleaseTrains, ReleaseTrain} from '../../release/versioning/index';\n \n import {bold, debug, info} from '../../utils/console';\n-import {GitClient} from '../../utils/git/index';\n+import {BaseModule} from './base';\n \n \n-/** The results of checking the status of CI.  */\n-interface StatusCheckResult {\n-  status: 'success'|'failed';\n-}\n+/** The result of checking a branch on CI. */\n+type CiBranchStatus = 'success'|'failed'|'not found';\n \n-/** Retrieve and log status of CI for the project. */\n-export async function printCiStatus(git: GitClient) {\n-  const releaseTrains = await fetchActiveReleaseTrains({api: git.github, ...git.remoteConfig});\n+/** A list of results for checking CI branches. */\n+type CiData = {\n+  active: boolean,\n+  name: string,\n+  label: string,\n+  status: CiBranchStatus,\n+}[];\n \n-  info.group(bold(`CI`));\n-  for (const [trainName, train] of Object.entries(releaseTrains)) {\n-    if (train === null) {\n-      debug(`No active release train for ${trainName}`);\n-      continue;\n-    }\n-    const status = await getStatusOfBranch(git, train.branchName);\n-    await printStatus(`${trainName.padEnd(6)} (${train.branchName})`, status);\n+export class CiModule extends BaseModule<CiData> {\n+  async retrieveData() {\n+    const gitRepoWithApi = {api: this.git.github, ...this.git.remoteConfig};\n+    const releaseTrains = await fetchActiveReleaseTrains(gitRepoWithApi);\n+\n+    const ciResultPromises = Object.entries(releaseTrains).map(async ([trainName, train]: [\n+                                                                 string, ReleaseTrain|null\n+                                                               ]) => {\n+      if (train === null) {\n+        return {\n+          active: false,\n+          name: trainName,\n+          label: '',\n+          status: 'not found' as const,\n+        };\n+      }\n+\n+      return {\n+        active: true,\n+        name: train.branchName,\n+        label: `${trainName} (${train.branchName})`,\n+        status: await this.getBranchStatusFromCi(train.branchName),\n+      };\n+    });\n+\n+    return await Promise.all(ciResultPromises);\n   }\n-  info.groupEnd();\n-  info();\n-}\n \n-/** Log the status of CI for a given branch to the console. */\n-async function printStatus(label: string, status: StatusCheckResult|null) {\n-  const branchName = label.padEnd(16);\n-  if (status === null) {\n-    info(`${branchName} was not found on CircleCI`);\n-  } else if (status.status === 'success') {\n-    info(`${branchName} ✅`);\n-  } else {\n-    info(`${branchName} ❌`);\n+  async printToTerminal() {\n+    const data = await this.data;\n+    const minLabelLength = Math.max(...data.map(result => result.label.length));\n+    info.group(bold(`CI`));\n+    data.forEach(result => {\n+      if (result.active === false) {\n+        debug(`No active release train for ${result.name}`);\n+        return;\n+      }\n+      const label = result.label.padEnd(minLabelLength);\n+      if (result.status === 'not found') {\n+        info(`${result.name} was not found on CircleCI`);\n+      } else if (result.status === 'success') {\n+        info(`${label} ✅`);\n+      } else {\n+        info(`${label} ❌`);\n+      }\n+    });\n+    info.groupEnd();\n+    info();\n   }\n-}\n \n-/** Get the CI status of a given branch from CircleCI. */\n-async function getStatusOfBranch(git: GitClient, branch: string): Promise<StatusCheckResult|null> {\n-  const {owner, name} = git.remoteConfig;\n-  const url = `https://circleci.com/gh/${owner}/${name}/tree/${branch}.svg?style=shield`;\n-  const result = await fetch(url).then(result => result.text());\n+  /** Get the CI status of a given branch from CircleCI. */\n+  private async getBranchStatusFromCi(branch: string): Promise<CiBranchStatus> {\n+    const {owner, name} = this.git.remoteConfig;\n+    const url = `https://circleci.com/gh/${owner}/${name}/tree/${branch}.svg?style=shield`;\n+    const result = await fetch(url).then(result => result.text());\n \n-  if (result && !result.includes('no builds')) {\n-    return {\n-      status: result.includes('passing') ? 'success' : 'failed',\n-    };\n+    if (result && !result.includes('no builds')) {\n+      return result.includes('passing') ? 'success' : 'failed';\n+    }\n+    return 'not found';\n   }\n-  return null;\n }"
        },
        {
            "sha": "e3b7d737ff2696902ebce8893c42468c0d32b334",
            "filename": "dev-infra/caretaker/check/g3.spec.ts",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/angular/angular/blob/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fg3.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fg3.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fcaretaker%2Fcheck%2Fg3.spec.ts?ref=2d797803841610e5ef8dbecb6d34be500fa6066b",
            "patch": "@@ -0,0 +1,109 @@\n+\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {SpawnSyncReturns} from 'child_process';\n+\n+import * as console from '../../utils/console';\n+import {buildVirtualGitClient, mockNgDevConfig, VirtualGitClient} from '../../utils/testing';\n+\n+import {G3Module, G3StatsData} from './g3';\n+\n+describe('G3Module', () => {\n+  let getG3FileIncludeAndExcludeLists: jasmine.Spy;\n+  let getLatestShas: jasmine.Spy;\n+  let getDiffStats: jasmine.Spy;\n+  let infoSpy: jasmine.Spy;\n+  let virtualGitClient: VirtualGitClient;\n+\n+  beforeEach(() => {\n+    virtualGitClient = buildVirtualGitClient();\n+    getG3FileIncludeAndExcludeLists =\n+        spyOn(G3Module.prototype, 'getG3FileIncludeAndExcludeLists' as any).and.returnValue(null);\n+    getLatestShas = spyOn(G3Module.prototype, 'getLatestShas' as any).and.returnValue(null);\n+    getDiffStats = spyOn(G3Module.prototype, 'getDiffStats' as any).and.returnValue(null);\n+    infoSpy = spyOn(console, 'info');\n+  });\n+\n+  describe('gathering stats', () => {\n+    it('unless the g3 merge config is not defined in the angular robot file', async () => {\n+      getG3FileIncludeAndExcludeLists.and.returnValue(null);\n+      getLatestShas.and.returnValue({g3: 'abc123', master: 'zxy987'});\n+      const module = new G3Module(virtualGitClient, {caretaker: {}, ...mockNgDevConfig});\n+\n+      expect(getDiffStats).not.toHaveBeenCalled();\n+      expect(await module.data).toBe(undefined);\n+    });\n+\n+    it('unless the branch shas are not able to be retrieved', async () => {\n+      getLatestShas.and.returnValue(null);\n+      getG3FileIncludeAndExcludeLists.and.returnValue({include: ['file1'], exclude: []});\n+      const module = new G3Module(virtualGitClient, {caretaker: {}, ...mockNgDevConfig});\n+\n+      expect(getDiffStats).not.toHaveBeenCalled();\n+      expect(await module.data).toBe(undefined);\n+    });\n+\n+    it('for the files which are being synced to g3', async () => {\n+      getLatestShas.and.returnValue({g3: 'abc123', master: 'zxy987'});\n+      getG3FileIncludeAndExcludeLists.and.returnValue({include: ['project1/*'], exclude: []});\n+      getDiffStats.and.callThrough();\n+      spyOn(virtualGitClient, 'run').and.callFake((args: string[]): any => {\n+        const output: Partial<SpawnSyncReturns<string>> = {};\n+        if (args[0] === 'rev-list') {\n+          output.stdout = '3';\n+        }\n+        if (args[0] === 'diff') {\n+          output.stdout = '5\\t6\\tproject1/file1\\n2\\t3\\tproject2/file2\\n7\\t1\\tproject1/file3\\n';\n+        }\n+        return output;\n+      });\n+\n+      const module = new G3Module(virtualGitClient, {caretaker: {}, ...mockNgDevConfig});\n+      const {insertions, deletions, files, commits} = (await module.data) as G3StatsData;\n+\n+      expect(insertions).toBe(12);\n+      expect(deletions).toBe(7);\n+      expect(files).toBe(2);\n+      expect(commits).toBe(3);\n+    });\n+  });\n+\n+  describe('printing the data retrieved', () => {\n+    it('if files are discovered needing to sync', async () => {\n+      const fakeData = Promise.resolve({\n+        insertions: 25,\n+        deletions: 10,\n+        files: 2,\n+        commits: 2,\n+      });\n+\n+      const module = new G3Module(virtualGitClient, {caretaker: {}, ...mockNgDevConfig});\n+      Object.defineProperty(module, 'data', {value: fakeData});\n+      await module.printToTerminal();\n+\n+      expect(infoSpy).toHaveBeenCalledWith(\n+          '2 files changed, 25 insertions(+), 10 deletions(-) from 2 commits will be included in the next sync');\n+    });\n+\n+    it('if no files need to sync', async () => {\n+      const fakeData = Promise.resolve({\n+        insertions: 0,\n+        deletions: 0,\n+        files: 0,\n+        commits: 25,\n+      });\n+\n+      const module = new G3Module(virtualGitClient, {caretaker: {}, ...mockNgDevConfig});\n+      Object.defineProperty(module, 'data', {value: fakeData});\n+      await module.printToTerminal();\n+\n+      expect(infoSpy).toHaveBeenCalledWith('25 commits between g3 and master');\n+      expect(infoSpy).toHaveBeenCalledWith('✅  No sync is needed at this time');\n+    });\n+  });\n+});"
        },
        {
            "sha": "a66dbafcc4d653e95c8e53dee37cda01ad685e91",
            "filename": "dev-infra/caretaker/check/g3.ts",
            "status": "modified",
            "additions": 85,
            "deletions": 55,
            "changes": 140,
            "blob_url": "https://github.com/angular/angular/blob/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fg3.ts",
            "raw_url": "https://github.com/angular/angular/raw/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fg3.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fcaretaker%2Fcheck%2Fg3.ts?ref=2d797803841610e5ef8dbecb6d34be500fa6066b",
            "patch": "@@ -10,76 +10,71 @@ import {existsSync, readFileSync} from 'fs';\n import * as multimatch from 'multimatch';\n import {join} from 'path';\n import {parse as parseYaml} from 'yaml';\n-\n import {getRepoBaseDir} from '../../utils/config';\n-import {bold, debug, info} from '../../utils/console';\n-import {GitClient} from '../../utils/git/index';\n-\n-/** Compare the upstream master to the upstream g3 branch, if it exists. */\n-export async function printG3Comparison(git: GitClient) {\n-  const angularRobotFilePath = join(getRepoBaseDir(), '.github/angular-robot.yml');\n-  if (!existsSync(angularRobotFilePath)) {\n-    return debug('No angular robot configuration file exists, skipping.');\n-  }\n+import {bold, debug, error, info} from '../../utils/console';\n \n-  /** The configuration defined for the angular robot. */\n-  const robotConfig = parseYaml(readFileSync(angularRobotFilePath).toString());\n-  /** The files to be included in the g3 sync. */\n-  const includeFiles = robotConfig?.merge?.g3Status?.include || [];\n-  /** The files to be expected in the g3 sync. */\n-  const excludeFiles = robotConfig?.merge?.g3Status?.exclude || [];\n-\n-  if (includeFiles.length === 0 && excludeFiles.length === 0) {\n-    debug('No g3Status include or exclude lists are defined in the angular robot configuration,');\n-    debug('skipping.');\n-    return;\n-  }\n+import {BaseModule} from './base';\n \n-  /** The latest sha for the g3 branch. */\n-  const g3Ref = getShaForBranchLatest('g3');\n-  /** The latest sha for the master branch. */\n-  const masterRef = getShaForBranchLatest('master');\n+/** Information expressing the difference between the master and g3 branches */\n+export interface G3StatsData {\n+  insertions: number;\n+  deletions: number;\n+  files: number;\n+  commits: number;\n+}\n \n-  if (!g3Ref && !masterRef) {\n-    return debug('Exiting early as either the g3 or master was unable to be retrieved');\n-  }\n+export class G3Module extends BaseModule<G3StatsData|void> {\n+  async retrieveData() {\n+    const toCopyToG3 = this.getG3FileIncludeAndExcludeLists();\n+    const latestSha = this.getLatestShas();\n \n-  /** The statistical information about the git diff between master and g3. */\n-  const stats = getDiffStats();\n+    if (toCopyToG3 === null || latestSha === null) {\n+      return;\n+    }\n \n-  info.group(bold('g3 branch check'));\n-  info(`${stats.commits} commits between g3 and master`);\n-  if (stats.files === 0) {\n-    info('✅ No sync is needed at this time');\n-  } else {\n-    info(`${stats.files} files changed, ${stats.insertions} insertions(+), ${\n-        stats.deletions} deletions(-) will be included in the next sync`);\n+    return this.getDiffStats(\n+        latestSha.g3, latestSha.master, toCopyToG3.include, toCopyToG3.exclude);\n   }\n-  info.groupEnd();\n-  info();\n \n+  async printToTerminal() {\n+    const stats = await this.data;\n+    if (!stats) {\n+      return;\n+    }\n+    info.group(bold('g3 branch check'));\n+    if (stats.files === 0) {\n+      info(`${stats.commits} commits between g3 and master`);\n+      info('✅  No sync is needed at this time');\n+    } else {\n+      info(\n+          `${stats.files} files changed, ${stats.insertions} insertions(+), ${stats.deletions} ` +\n+          `deletions(-) from ${stats.commits} commits will be included in the next sync`);\n+    }\n+    info.groupEnd();\n+    info();\n+  }\n \n   /** Fetch and retrieve the latest sha for a specific branch. */\n-  function getShaForBranchLatest(branch: string) {\n+  private getShaForBranchLatest(branch: string) {\n+    const {owner, name} = this.git.remoteConfig;\n     /** The result fo the fetch command. */\n-    const fetchResult = git.runGraceful([\n-      'fetch', '-q', `https://github.com/${git.remoteConfig.owner}/${git.remoteConfig.name}.git`,\n-      branch\n-    ]);\n+    const fetchResult =\n+        this.git.runGraceful(['fetch', '-q', `https://github.com/${owner}/${name}.git`, branch]);\n \n     if (fetchResult.status !== 0 &&\n         fetchResult.stderr.includes(`couldn't find remote ref ${branch}`)) {\n       debug(`No '${branch}' branch exists on upstream, skipping.`);\n-      return false;\n+      return null;\n     }\n-    return git.runGraceful(['rev-parse', 'FETCH_HEAD']).stdout.trim();\n+    return this.git.runGraceful(['rev-parse', 'FETCH_HEAD']).stdout.trim();\n   }\n \n   /**\n    * Get git diff stats between master and g3, for all files and filtered to only g3 affecting\n    * files.\n    */\n-  function getDiffStats() {\n+  private getDiffStats(\n+      g3Ref: string, masterRef: string, includeFiles: string[], excludeFiles: string[]) {\n     /** The diff stats to be returned. */\n     const stats = {\n       insertions: 0,\n@@ -89,39 +84,74 @@ export async function printG3Comparison(git: GitClient) {\n     };\n \n     // Determine the number of commits between master and g3 refs. */\n-    stats.commits = parseInt(git.run(['rev-list', '--count', `${g3Ref}..${masterRef}`]).stdout, 10);\n+    stats.commits =\n+        parseInt(this.git.run(['rev-list', '--count', `${g3Ref}..${masterRef}`]).stdout, 10);\n \n     // Get the numstat information between master and g3\n-    git.run(['diff', `${g3Ref}...${masterRef}`, '--numstat'])\n+    this.git.run(['diff', `${g3Ref}...${masterRef}`, '--numstat'])\n         .stdout\n         // Remove the extra space after git's output.\n         .trim()\n         // Split each line of git output into array\n         .split('\\n')\n         // Split each line from the git output into components parts: insertions,\n         // deletions and file name respectively\n-        .map(line => line.split('\\t'))\n+        .map(line => line.trim().split('\\t'))\n         // Parse number value from the insertions and deletions values\n         // Example raw line input:\n         //   10\\t5\\tsrc/file/name.ts\n         .map(line => [Number(line[0]), Number(line[1]), line[2]] as [number, number, string])\n         // Add each line's value to the diff stats, and conditionally to the g3\n         // stats as well if the file name is included in the files synced to g3.\n         .forEach(([insertions, deletions, fileName]) => {\n-          if (checkMatchAgainstIncludeAndExclude(fileName, includeFiles, excludeFiles)) {\n+          if (this.checkMatchAgainstIncludeAndExclude(fileName, includeFiles, excludeFiles)) {\n             stats.insertions += insertions;\n             stats.deletions += deletions;\n             stats.files += 1;\n           }\n         });\n     return stats;\n   }\n-\n   /** Determine whether the file name passes both include and exclude checks. */\n-  function checkMatchAgainstIncludeAndExclude(\n-      file: string, includes: string[], excludes: string[]) {\n+  private checkMatchAgainstIncludeAndExclude(file: string, includes: string[], excludes: string[]) {\n     return (\n         multimatch.call(undefined, file, includes).length >= 1 &&\n         multimatch.call(undefined, file, excludes).length === 0);\n   }\n+\n+\n+  private getG3FileIncludeAndExcludeLists() {\n+    const angularRobotFilePath = join(getRepoBaseDir(), '.github/angular-robot.yml');\n+    if (!existsSync(angularRobotFilePath)) {\n+      debug('No angular robot configuration file exists, skipping.');\n+      return null;\n+    }\n+    /** The configuration defined for the angular robot. */\n+    const robotConfig = parseYaml(readFileSync(angularRobotFilePath).toString());\n+    /** The files to be included in the g3 sync. */\n+    const include: string[] = robotConfig?.merge?.g3Status?.include || [];\n+    /** The files to be expected in the g3 sync. */\n+    const exclude: string[] = robotConfig?.merge?.g3Status?.exclude || [];\n+\n+    if (include.length === 0 && exclude.length === 0) {\n+      debug('No g3Status include or exclude lists are defined in the angular robot configuration');\n+      return null;\n+    }\n+\n+    return {include, exclude};\n+  }\n+\n+  private getLatestShas() {\n+    /** The latest sha for the g3 branch. */\n+    const g3 = this.getShaForBranchLatest('g3');\n+    /** The latest sha for the master branch. */\n+    const master = this.getShaForBranchLatest('master');\n+\n+    if (g3 === null || master === null) {\n+      debug('Either the g3 or master was unable to be retrieved');\n+      return null;\n+    }\n+\n+    return {g3, master};\n+  }\n }"
        },
        {
            "sha": "452e5595bf38ae5808c271b1082a5b756861b580",
            "filename": "dev-infra/caretaker/check/github.spec.ts",
            "status": "added",
            "additions": 121,
            "deletions": 0,
            "changes": 121,
            "blob_url": "https://github.com/angular/angular/blob/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fgithub.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fgithub.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fcaretaker%2Fcheck%2Fgithub.spec.ts?ref=2d797803841610e5ef8dbecb6d34be500fa6066b",
            "patch": "@@ -0,0 +1,121 @@\n+\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import * as console from '../../utils/console';\n+import {GithubGraphqlClient} from '../../utils/git/github';\n+import {buildVirtualGitClient, mockNgDevConfig, VirtualGitClient} from '../../utils/testing';\n+\n+import {GithubQueriesModule} from './github';\n+\n+describe('GithubQueriesModule', () => {\n+  let githubApiSpy: jasmine.Spy;\n+  let infoSpy: jasmine.Spy;\n+  let infoGroupSpy: jasmine.Spy;\n+  let virtualGitClient: VirtualGitClient;\n+\n+  beforeEach(() => {\n+    githubApiSpy = spyOn(GithubGraphqlClient.prototype, 'query')\n+                       .and.throwError(\n+                           'The graphql query response must always be manually defined in a test.');\n+    virtualGitClient = buildVirtualGitClient();\n+    infoGroupSpy = spyOn(console.info, 'group');\n+    infoSpy = spyOn(console, 'info');\n+  });\n+\n+  describe('gathering stats', () => {\n+    it('unless githubQueries are `undefined`', async () => {\n+      const module = new GithubQueriesModule(\n+          virtualGitClient, {...mockNgDevConfig, caretaker: {githubQueries: undefined}});\n+\n+      expect(await module.data).toBe(undefined);\n+    });\n+\n+    it('unless githubQueries are an empty array', async () => {\n+      const module = new GithubQueriesModule(\n+          virtualGitClient, {...mockNgDevConfig, caretaker: {githubQueries: []}});\n+\n+      expect(await module.data).toBe(undefined);\n+    });\n+\n+    it('for the requestd Github queries', async () => {\n+      githubApiSpy.and.returnValue({\n+        'keynamewithspaces': {issueCount: 1, nodes: [{url: 'http://gituhb.com/owner/name/issue/1'}]}\n+      });\n+      const module = new GithubQueriesModule(virtualGitClient, {\n+        ...mockNgDevConfig,\n+        caretaker: {githubQueries: [{name: 'key name with spaces', query: 'issue: yes'}]}\n+      });\n+\n+      expect(await module.data).toEqual([{\n+        queryName: 'key name with spaces',\n+        count: 1,\n+        queryUrl: 'https://github.com/owner/name/issues?q=issue:%20yes',\n+        matchedUrls: ['http://gituhb.com/owner/name/issue/1'],\n+      }]);\n+    });\n+  });\n+\n+  describe('printing the data retrieved', () => {\n+    it('if there are no matches of the query', async () => {\n+      const fakeData = Promise.resolve([\n+        {\n+          queryName: 'query1',\n+          count: 0,\n+          queryUrl: 'https://github.com/owner/name/issues?q=issue:%20no',\n+          matchedUrls: [],\n+        },\n+        {\n+          queryName: 'query2',\n+          count: 0,\n+          queryUrl: 'https://github.com/owner/name/issues?q=something',\n+          matchedUrls: [],\n+        },\n+      ]);\n+\n+\n+      const module = new GithubQueriesModule(virtualGitClient, {caretaker: {}, ...mockNgDevConfig});\n+      Object.defineProperty(module, 'data', {value: fakeData});\n+\n+      await module.printToTerminal();\n+\n+\n+      expect(infoGroupSpy).toHaveBeenCalledWith('Github Tasks');\n+      expect(infoSpy).toHaveBeenCalledWith('query1  0');\n+      expect(infoSpy).toHaveBeenCalledWith('query2  0');\n+    });\n+\n+    it('if there are maches of the query', async () => {\n+      const fakeData = Promise.resolve([\n+        {\n+          queryName: 'query1',\n+          count: 1,\n+          queryUrl: 'https://github.com/owner/name/issues?q=issue:%20yes',\n+          matchedUrls: ['http://gituhb.com/owner/name/issue/1'],\n+        },\n+        {\n+          queryName: 'query2',\n+          count: 0,\n+          queryUrl: 'https://github.com/owner/name/issues?q=something',\n+          matchedUrls: [],\n+        },\n+      ]);\n+\n+      const module = new GithubQueriesModule(virtualGitClient, {caretaker: {}, ...mockNgDevConfig});\n+      Object.defineProperty(module, 'data', {value: fakeData});\n+\n+      await module.printToTerminal();\n+\n+      expect(infoGroupSpy).toHaveBeenCalledWith('Github Tasks');\n+      expect(infoSpy).toHaveBeenCalledWith('query1  1');\n+      expect(infoGroupSpy)\n+          .toHaveBeenCalledWith('https://github.com/owner/name/issues?q=issue:%20yes');\n+      expect(infoSpy).toHaveBeenCalledWith('- http://gituhb.com/owner/name/issue/1');\n+      expect(infoSpy).toHaveBeenCalledWith('query2  0');\n+    });\n+  });\n+});"
        },
        {
            "sha": "1b5be056e984fa3098ce1cb3a7c0ffe64b8ec264",
            "filename": "dev-infra/caretaker/check/github.ts",
            "status": "modified",
            "additions": 96,
            "deletions": 59,
            "changes": 155,
            "blob_url": "https://github.com/angular/angular/blob/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fgithub.ts",
            "raw_url": "https://github.com/angular/angular/raw/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fgithub.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fcaretaker%2Fcheck%2Fgithub.ts?ref=2d797803841610e5ef8dbecb6d34be500fa6066b",
            "patch": "@@ -9,75 +9,112 @@\n import {alias, onUnion, params, types} from 'typed-graphqlify';\n \n import {bold, debug, info} from '../../utils/console';\n-import {GitClient} from '../../utils/git/index';\n import {CaretakerConfig} from '../config';\n+import {BaseModule} from './base';\n+\n+/** A list of generated results for a github query. */\n+type GithubQueryResults = {\n+  queryName: string,\n+  count: number,\n+  queryUrl: string,\n+  matchedUrls: string[],\n+}[];\n+\n+/** The fragment for a result from Github's api for a Github query. */\n+const GithubQueryResultFragment = {\n+  issueCount: types.number,\n+  nodes: [{...onUnion({\n+    PullRequest: {\n+      url: types.string,\n+    },\n+    Issue: {\n+      url: types.string,\n+    },\n+  })}],\n+};\n+\n+/** An object containing results of multiple queries.  */\n+type GithubQueryResult = {\n+  [key: string]: typeof GithubQueryResultFragment;\n+};\n \n /**\n- * Cap the returned issues in the queries to an arbitrary 100. At that point, caretaker has a lot\n+ * Cap the returned issues in the queries to an arbitrary 20. At that point, caretaker has a lot\n  * of work to do and showing more than that isn't really useful.\n  */\n const MAX_RETURNED_ISSUES = 20;\n \n-/** Retrieve the number of matching issues for each github query. */\n-export async function printGithubTasks(git: GitClient, config?: CaretakerConfig) {\n-  if (!config?.githubQueries?.length) {\n-    debug('No github queries defined in the configuration, skipping.');\n-    return;\n+export class GithubQueriesModule extends BaseModule<GithubQueryResults|void> {\n+  async retrieveData() {\n+    // Non-null assertion is used here as the check for undefined immediately follows to confirm the\n+    // assertion.  Typescript's type filtering does not seem to work as needed to understand\n+    // whether githubQueries is undefined or not.\n+    let queries = this.config.caretaker?.githubQueries!;\n+    if (queries === undefined || queries.length === 0) {\n+      debug('No github queries defined in the configuration, skipping');\n+      return;\n+    }\n+\n+    /** The results of the generated github query. */\n+    const queryResult = await this.git.github.graphql.query(this.buildGraphqlQuery(queries));\n+    const results = Object.values(queryResult);\n+\n+    const {owner, name: repo} = this.git.remoteConfig;\n+\n+    return results.map((result, i) => {\n+      return {\n+        queryName: queries[i].name,\n+        count: result.issueCount,\n+        queryUrl: encodeURI(`https://github.com/${owner}/${repo}/issues?q=${queries[i].query}`),\n+        matchedUrls: result.nodes.map(node => node.url)\n+      };\n+    });\n   }\n-  info.group(bold(`Github Tasks`));\n-  await getGithubInfo(git, config);\n-  info.groupEnd();\n-  info();\n-}\n \n-/** Retrieve query match counts and log discovered counts to the console. */\n-async function getGithubInfo(git: GitClient, {githubQueries: queries = []}: CaretakerConfig) {\n-  /** The query object for graphql. */\n-  const graphQlQuery: {\n-    [key: string]: {\n-      issueCount: number,\n-      nodes: Array<{url: string}>,\n+  /** Build a Graphql query statement for the provided queries. */\n+  private buildGraphqlQuery(queries: NonNullable<CaretakerConfig['githubQueries']>) {\n+    /** The query object for graphql. */\n+    const graphQlQuery: GithubQueryResult = {};\n+    const {owner, name: repo} = this.git.remoteConfig;\n+    /** The Github search filter for the configured repository. */\n+    const repoFilter = `repo:${owner}/${repo}`;\n+\n+\n+    queries.forEach(({name, query}) => {\n+      /** The name of the query, with spaces removed to match GraphQL requirements. */\n+      const queryKey = alias(name.replace(/ /g, ''), 'search');\n+      graphQlQuery[queryKey] = params(\n+          {\n+            type: 'ISSUE',\n+            first: MAX_RETURNED_ISSUES,\n+            query: `\"${repoFilter} ${query.replace(/\"/g, '\\\\\"')}\"`,\n+          },\n+          {...GithubQueryResultFragment});\n+    });\n+\n+    return graphQlQuery;\n+  }\n+\n+  async printToTerminal() {\n+    const queryResults = await this.data;\n+    if (!queryResults) {\n+      return;\n     }\n-  } = {};\n-  /** The Github search filter for the configured repository. */\n-  const repoFilter = `repo:${git.remoteConfig.owner}/${git.remoteConfig.name}`;\n-  queries.forEach(({name, query}) => {\n-    /** The name of the query, with spaces removed to match GraphQL requirements. */\n-    const queryKey = alias(name.replace(/ /g, ''), 'search');\n-    graphQlQuery[queryKey] = params(\n-        {\n-          type: 'ISSUE',\n-          first: MAX_RETURNED_ISSUES,\n-          query: `\"${repoFilter} ${query.replace(/\"/g, '\\\\\"')}\"`,\n-        },\n-        {\n-          issueCount: types.number,\n-          nodes: [{...onUnion({\n-            PullRequest: {\n-              url: types.string,\n-            },\n-            Issue: {\n-              url: types.string,\n-            },\n-          })}],\n-        },\n-    );\n-  });\n-  /** The results of the generated github query. */\n-  const results = await git.github.graphql.query(graphQlQuery);\n-  Object.values(results).forEach((result, i) => {\n-    info(`${queries[i]?.name.padEnd(25)} ${result.issueCount}`);\n-    if (result.issueCount > 0) {\n-      const {owner, name: repo} = git.remoteConfig;\n-      const url = encodeURI(`https://github.com/${owner}/${repo}/issues?q=${queries[i]?.query}`);\n-      info.group(`${url}`);\n-      if (result.nodes.length === MAX_RETURNED_ISSUES && result.nodes.length < result.issueCount) {\n-        info(`(first ${MAX_RETURNED_ISSUES})`);\n-      }\n-      for (const node of result.nodes) {\n-        info(`- ${node.url}`);\n+    info.group(bold('Github Tasks'));\n+    const minQueryNameLength = Math.max(...queryResults.map(result => result.queryName.length));\n+    for (const queryResult of queryResults) {\n+      info(`${queryResult.queryName.padEnd(minQueryNameLength)}  ${queryResult.count}`);\n+\n+      if (queryResult.count > 0) {\n+        info.group(queryResult.queryUrl);\n+        queryResult.matchedUrls.forEach(url => info(`- ${url}`));\n+        if (queryResult.count > MAX_RETURNED_ISSUES) {\n+          info(`... ${queryResult.count - MAX_RETURNED_ISSUES} additional matches`);\n+        }\n+        info.groupEnd();\n       }\n-      info.groupEnd();\n     }\n-  });\n+    info.groupEnd();\n+    info();\n+  }\n }"
        },
        {
            "sha": "ec2b64f7be349e7d9c76fa282d780fae25d85729",
            "filename": "dev-infra/caretaker/check/services.spec.ts",
            "status": "added",
            "additions": 69,
            "deletions": 0,
            "changes": 69,
            "blob_url": "https://github.com/angular/angular/blob/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fservices.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fservices.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fcaretaker%2Fcheck%2Fservices.spec.ts?ref=2d797803841610e5ef8dbecb6d34be500fa6066b",
            "patch": "@@ -0,0 +1,69 @@\n+\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as console from '../../utils/console';\n+import {buildVirtualGitClient, mockNgDevConfig, VirtualGitClient} from '../../utils/testing';\n+\n+import {services, ServicesModule} from './services';\n+\n+describe('ServicesModule', () => {\n+  let getStatusFromStandardApiSpy: jasmine.Spy;\n+  let infoSpy: jasmine.Spy;\n+  let infoGroupSpy: jasmine.Spy;\n+  let virtualGitClient: VirtualGitClient;\n+\n+  services.splice(0, Infinity, {url: 'fakeStatus.com/api.json', name: 'Service Name'});\n+\n+  beforeEach(() => {\n+    getStatusFromStandardApiSpy = spyOn(ServicesModule.prototype, 'getStatusFromStandardApi');\n+    virtualGitClient = buildVirtualGitClient();\n+    infoGroupSpy = spyOn(console.info, 'group');\n+    infoSpy = spyOn(console, 'info');\n+  });\n+\n+  describe('gathering status', () => {\n+    it('for each of the services', async () => {\n+      new ServicesModule(virtualGitClient, {caretaker: {}, ...mockNgDevConfig});\n+\n+      expect(getStatusFromStandardApiSpy)\n+          .toHaveBeenCalledWith({url: 'fakeStatus.com/api.json', name: 'Service Name'});\n+    });\n+  });\n+\n+  describe('printing the data retrieved', () => {\n+    it('for each service ', async () => {\n+      const fakeData = Promise.resolve([\n+        {\n+          name: 'Service 1',\n+          status: 'passing',\n+          description: 'Everything is working great',\n+          lastUpdated: new Date(0),\n+        },\n+        {\n+          name: 'Service 2',\n+          status: 'failing',\n+          description: 'Literally everything is broken',\n+          lastUpdated: new Date(0),\n+        },\n+      ]);\n+\n+\n+      const module = new ServicesModule(virtualGitClient, {caretaker: {}, ...mockNgDevConfig});\n+      Object.defineProperty(module, 'data', {value: fakeData});\n+      await module.printToTerminal();\n+\n+\n+      expect(infoGroupSpy).toHaveBeenCalledWith('Service Statuses');\n+      expect(infoSpy).toHaveBeenCalledWith('Service 1 ✅');\n+      expect(infoGroupSpy)\n+          .toHaveBeenCalledWith(`Service 2 ❌ (Updated: ${new Date(0).toLocaleString()})`);\n+      expect(infoSpy).toHaveBeenCalledWith('  Details: Literally everything is broken');\n+    });\n+  });\n+});"
        },
        {
            "sha": "3e0a348ca79facafd3a98080eecddc7faffdcf0c",
            "filename": "dev-infra/caretaker/check/services.ts",
            "status": "modified",
            "additions": 56,
            "deletions": 54,
            "changes": 110,
            "blob_url": "https://github.com/angular/angular/blob/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fservices.ts",
            "raw_url": "https://github.com/angular/angular/raw/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcaretaker%2Fcheck%2Fservices.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fcaretaker%2Fcheck%2Fservices.ts?ref=2d797803841610e5ef8dbecb6d34be500fa6066b",
            "patch": "@@ -8,72 +8,74 @@\n \n import fetch from 'node-fetch';\n \n-import {bold, green, info, red} from '../../utils/console';\n+import {bold, info} from '../../utils/console';\n+import {BaseModule} from './base';\n \n-/** The status levels for services. */\n-enum ServiceStatus {\n-  GREEN,\n-  RED\n+interface ServiceConfig {\n+  name: string;\n+  url: string;\n }\n \n /** The results of checking the status of a service */\n interface StatusCheckResult {\n-  status: ServiceStatus;\n+  name: string;\n+  status: 'passing'|'failing';\n   description: string;\n   lastUpdated: Date;\n }\n \n-/** Retrieve and log stasuses for all of the services of concern. */\n-export async function printServiceStatuses() {\n-  info.group(bold(`Service Statuses (checked: ${new Date().toLocaleString()})`));\n-  logStatus('CircleCI', await getCircleCiStatus());\n-  logStatus('Github', await getGithubStatus());\n-  logStatus('NPM', await getNpmStatus());\n-  logStatus('Saucelabs', await getSaucelabsStatus());\n-  info.groupEnd();\n-  info();\n-}\n+/** List of services Angular relies on. */\n+export const services: ServiceConfig[] = [\n+  {\n+    url: 'https://status.us-west-1.saucelabs.com/api/v2/status.json',\n+    name: 'Saucelabs',\n+  },\n+  {\n+    url: 'https://status.npmjs.org/api/v2/status.json',\n+    name: 'Npm',\n+  },\n+  {\n+    url: 'https://status.circleci.com/api/v2/status.json',\n+    name: 'CircleCi',\n+  },\n+  {\n+    url: 'https://www.githubstatus.com/api/v2/status.json',\n+    name: 'Github',\n+  },\n+];\n \n+export class ServicesModule extends BaseModule<StatusCheckResult[]> {\n+  async retrieveData() {\n+    return Promise.all(services.map(service => this.getStatusFromStandardApi(service)));\n+  }\n \n-/** Log the status of the service to the console. */\n-function logStatus(serviceName: string, status: StatusCheckResult) {\n-  serviceName = serviceName.padEnd(15);\n-  if (status.status === ServiceStatus.GREEN) {\n-    info(`${serviceName} ${green('✅')}`);\n-  } else if (status.status === ServiceStatus.RED) {\n-    info.group(`${serviceName} ${red('❌')} (Updated: ${status.lastUpdated.toLocaleString()})`);\n-    info(`  Details: ${status.description}`);\n+  async printToTerminal() {\n+    const statuses = await this.data;\n+    const serviceNameMinLength = Math.max(...statuses.map(service => service.name.length));\n+    info.group(bold('Service Statuses'));\n+    for (const status of statuses) {\n+      const name = status.name.padEnd(serviceNameMinLength);\n+      if (status.status === 'passing') {\n+        info(`${name} ✅`);\n+      } else {\n+        info.group(`${name} ❌ (Updated: ${status.lastUpdated.toLocaleString()})`);\n+        info(`  Details: ${status.description}`);\n+        info.groupEnd();\n+      }\n+    }\n     info.groupEnd();\n+    info();\n   }\n-}\n-\n-/** Gets the service status information for Saucelabs. */\n-async function getSaucelabsStatus(): Promise<StatusCheckResult> {\n-  return getStatusFromStandardApi('https://status.us-west-1.saucelabs.com/api/v2/status.json');\n-}\n-\n-/** Gets the service status information for NPM. */\n-async function getNpmStatus(): Promise<StatusCheckResult> {\n-  return getStatusFromStandardApi('https://status.npmjs.org/api/v2/status.json');\n-}\n-\n-/** Gets the service status information for CircleCI. */\n-async function getCircleCiStatus(): Promise<StatusCheckResult> {\n-  return getStatusFromStandardApi('https://status.circleci.com/api/v2/status.json');\n-}\n \n-/** Gets the service status information for Github. */\n-async function getGithubStatus(): Promise<StatusCheckResult> {\n-  return getStatusFromStandardApi('https://www.githubstatus.com/api/v2/status.json');\n-}\n-\n-/** Retrieve the status information for a service which uses a standard API response. */\n-async function getStatusFromStandardApi(url: string) {\n-  const result = await fetch(url).then(result => result.json());\n-  const status = result.status.indicator === 'none' ? ServiceStatus.GREEN : ServiceStatus.RED;\n-  return {\n-    status,\n-    description: result.status.description,\n-    lastUpdated: new Date(result.page.updated_at)\n-  };\n+  /** Retrieve the status information for a service which uses a standard API response. */\n+  async getStatusFromStandardApi(service: ServiceConfig): Promise<StatusCheckResult> {\n+    const result = await fetch(service.url).then(result => result.json());\n+    const status = result.status.indicator === 'none' ? 'passing' : 'failing';\n+    return {\n+      name: service.name,\n+      status,\n+      description: result.status.description,\n+      lastUpdated: new Date(result.page.updated_at)\n+    };\n+  }\n }"
        },
        {
            "sha": "ed4abcc30a3b568a588c04d551a04dc69d83b9ef",
            "filename": "dev-infra/commit-message/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcommit-message%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fcommit-message%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fcommit-message%2FBUILD.bazel?ref=2d797803841610e5ef8dbecb6d34be500fa6066b",
            "patch": "@@ -39,6 +39,6 @@ jasmine_node_test(\n     name = \"test\",\n     bootstrap = [\"//tools/testing:node_no_angular_es5\"],\n     deps = [\n-        \"test_lib\",\n+        \":test_lib\",\n     ],\n )"
        },
        {
            "sha": "26cb04e3f4c2e8e4ade4b5e4210b6d892d944665",
            "filename": "dev-infra/ng-dev.js",
            "status": "modified",
            "additions": 314,
            "deletions": 244,
            "changes": 558,
            "blob_url": "https://github.com/angular/angular/blob/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fng-dev.js",
            "raw_url": "https://github.com/angular/angular/raw/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Fng-dev.js",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Fng-dev.js?ref=2d797803841610e5ef8dbecb6d34be500fa6066b",
            "patch": "@@ -1089,58 +1089,84 @@ function getLtsNpmDistTagOfMajor(major) {\n     return `v${major}-lts`;\n }\n \n+/** The BaseModule to extend modules for caretaker checks from. */\n+class BaseModule {\n+    constructor(git, config) {\n+        this.git = git;\n+        this.config = config;\n+        /** The data for the module. */\n+        this.data = this.retrieveData();\n+    }\n+}\n+\n /**\n  * @license\n  * Copyright Google LLC All Rights Reserved.\n  *\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-/** Retrieve and log status of CI for the project. */\n-function printCiStatus(git) {\n-    return tslib.__awaiter(this, void 0, void 0, function* () {\n-        const releaseTrains = yield fetchActiveReleaseTrains(Object.assign({ api: git.github }, git.remoteConfig));\n-        info.group(bold(`CI`));\n-        for (const [trainName, train] of Object.entries(releaseTrains)) {\n-            if (train === null) {\n-                debug(`No active release train for ${trainName}`);\n-                continue;\n+class CiModule extends BaseModule {\n+    retrieveData() {\n+        return tslib.__awaiter(this, void 0, void 0, function* () {\n+            const gitRepoWithApi = Object.assign({ api: this.git.github }, this.git.remoteConfig);\n+            const releaseTrains = yield fetchActiveReleaseTrains(gitRepoWithApi);\n+            const ciResultPromises = Object.entries(releaseTrains).map(([trainName, train]) => tslib.__awaiter(this, void 0, void 0, function* () {\n+                if (train === null) {\n+                    return {\n+                        active: false,\n+                        name: trainName,\n+                        label: '',\n+                        status: 'not found',\n+                    };\n+                }\n+                return {\n+                    active: true,\n+                    name: train.branchName,\n+                    label: `${trainName} (${train.branchName})`,\n+                    status: yield this.getBranchStatusFromCi(train.branchName),\n+                };\n+            }));\n+            return yield Promise.all(ciResultPromises);\n+        });\n+    }\n+    printToTerminal() {\n+        return tslib.__awaiter(this, void 0, void 0, function* () {\n+            const data = yield this.data;\n+            const minLabelLength = Math.max(...data.map(result => result.label.length));\n+            info.group(bold(`CI`));\n+            data.forEach(result => {\n+                if (result.active === false) {\n+                    debug(`No active release train for ${result.name}`);\n+                    return;\n+                }\n+                const label = result.label.padEnd(minLabelLength);\n+                if (result.status === 'not found') {\n+                    info(`${result.name} was not found on CircleCI`);\n+                }\n+                else if (result.status === 'success') {\n+                    info(`${label} ✅`);\n+                }\n+                else {\n+                    info(`${label} ❌`);\n+                }\n+            });\n+            info.groupEnd();\n+            info();\n+        });\n+    }\n+    /** Get the CI status of a given branch from CircleCI. */\n+    getBranchStatusFromCi(branch) {\n+        return tslib.__awaiter(this, void 0, void 0, function* () {\n+            const { owner, name } = this.git.remoteConfig;\n+            const url = `https://circleci.com/gh/${owner}/${name}/tree/${branch}.svg?style=shield`;\n+            const result = yield fetch(url).then(result => result.text());\n+            if (result && !result.includes('no builds')) {\n+                return result.includes('passing') ? 'success' : 'failed';\n             }\n-            const status = yield getStatusOfBranch(git, train.branchName);\n-            yield printStatus(`${trainName.padEnd(6)} (${train.branchName})`, status);\n-        }\n-        info.groupEnd();\n-        info();\n-    });\n-}\n-/** Log the status of CI for a given branch to the console. */\n-function printStatus(label, status) {\n-    return tslib.__awaiter(this, void 0, void 0, function* () {\n-        const branchName = label.padEnd(16);\n-        if (status === null) {\n-            info(`${branchName} was not found on CircleCI`);\n-        }\n-        else if (status.status === 'success') {\n-            info(`${branchName} ✅`);\n-        }\n-        else {\n-            info(`${branchName} ❌`);\n-        }\n-    });\n-}\n-/** Get the CI status of a given branch from CircleCI. */\n-function getStatusOfBranch(git, branch) {\n-    return tslib.__awaiter(this, void 0, void 0, function* () {\n-        const { owner, name } = git.remoteConfig;\n-        const url = `https://circleci.com/gh/${owner}/${name}/tree/${branch}.svg?style=shield`;\n-        const result = yield fetch(url).then(result => result.text());\n-        if (result && !result.includes('no builds')) {\n-            return {\n-                status: result.includes('passing') ? 'success' : 'failed',\n-            };\n-        }\n-        return null;\n-    });\n+            return 'not found';\n+        });\n+    }\n }\n \n /**\n@@ -1150,103 +1176,123 @@ function getStatusOfBranch(git, branch) {\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-/** Compare the upstream master to the upstream g3 branch, if it exists. */\n-function printG3Comparison(git) {\n-    var _a, _b, _c, _d;\n-    return tslib.__awaiter(this, void 0, void 0, function* () {\n+class G3Module extends BaseModule {\n+    retrieveData() {\n+        return tslib.__awaiter(this, void 0, void 0, function* () {\n+            const toCopyToG3 = this.getG3FileIncludeAndExcludeLists();\n+            const latestSha = this.getLatestShas();\n+            if (toCopyToG3 === null || latestSha === null) {\n+                return;\n+            }\n+            return this.getDiffStats(latestSha.g3, latestSha.master, toCopyToG3.include, toCopyToG3.exclude);\n+        });\n+    }\n+    printToTerminal() {\n+        return tslib.__awaiter(this, void 0, void 0, function* () {\n+            const stats = yield this.data;\n+            if (!stats) {\n+                return;\n+            }\n+            info.group(bold('g3 branch check'));\n+            if (stats.files === 0) {\n+                info(`${stats.commits} commits between g3 and master`);\n+                info('✅  No sync is needed at this time');\n+            }\n+            else {\n+                info(`${stats.files} files changed, ${stats.insertions} insertions(+), ${stats.deletions} ` +\n+                    `deletions(-) from ${stats.commits} commits will be included in the next sync`);\n+            }\n+            info.groupEnd();\n+            info();\n+        });\n+    }\n+    /** Fetch and retrieve the latest sha for a specific branch. */\n+    getShaForBranchLatest(branch) {\n+        const { owner, name } = this.git.remoteConfig;\n+        /** The result fo the fetch command. */\n+        const fetchResult = this.git.runGraceful(['fetch', '-q', `https://github.com/${owner}/${name}.git`, branch]);\n+        if (fetchResult.status !== 0 &&\n+            fetchResult.stderr.includes(`couldn't find remote ref ${branch}`)) {\n+            debug(`No '${branch}' branch exists on upstream, skipping.`);\n+            return null;\n+        }\n+        return this.git.runGraceful(['rev-parse', 'FETCH_HEAD']).stdout.trim();\n+    }\n+    /**\n+     * Get git diff stats between master and g3, for all files and filtered to only g3 affecting\n+     * files.\n+     */\n+    getDiffStats(g3Ref, masterRef, includeFiles, excludeFiles) {\n+        /** The diff stats to be returned. */\n+        const stats = {\n+            insertions: 0,\n+            deletions: 0,\n+            files: 0,\n+            commits: 0,\n+        };\n+        // Determine the number of commits between master and g3 refs. */\n+        stats.commits =\n+            parseInt(this.git.run(['rev-list', '--count', `${g3Ref}..${masterRef}`]).stdout, 10);\n+        // Get the numstat information between master and g3\n+        this.git.run(['diff', `${g3Ref}...${masterRef}`, '--numstat'])\n+            .stdout\n+            // Remove the extra space after git's output.\n+            .trim()\n+            // Split each line of git output into array\n+            .split('\\n')\n+            // Split each line from the git output into components parts: insertions,\n+            // deletions and file name respectively\n+            .map(line => line.trim().split('\\t'))\n+            // Parse number value from the insertions and deletions values\n+            // Example raw line input:\n+            //   10\\t5\\tsrc/file/name.ts\n+            .map(line => [Number(line[0]), Number(line[1]), line[2]])\n+            // Add each line's value to the diff stats, and conditionally to the g3\n+            // stats as well if the file name is included in the files synced to g3.\n+            .forEach(([insertions, deletions, fileName]) => {\n+            if (this.checkMatchAgainstIncludeAndExclude(fileName, includeFiles, excludeFiles)) {\n+                stats.insertions += insertions;\n+                stats.deletions += deletions;\n+                stats.files += 1;\n+            }\n+        });\n+        return stats;\n+    }\n+    /** Determine whether the file name passes both include and exclude checks. */\n+    checkMatchAgainstIncludeAndExclude(file, includes, excludes) {\n+        return (multimatch.call(undefined, file, includes).length >= 1 &&\n+            multimatch.call(undefined, file, excludes).length === 0);\n+    }\n+    getG3FileIncludeAndExcludeLists() {\n+        var _a, _b, _c, _d;\n         const angularRobotFilePath = path.join(getRepoBaseDir(), '.github/angular-robot.yml');\n         if (!fs.existsSync(angularRobotFilePath)) {\n-            return debug('No angular robot configuration file exists, skipping.');\n+            debug('No angular robot configuration file exists, skipping.');\n+            return null;\n         }\n         /** The configuration defined for the angular robot. */\n         const robotConfig = yaml.parse(fs.readFileSync(angularRobotFilePath).toString());\n         /** The files to be included in the g3 sync. */\n-        const includeFiles = ((_b = (_a = robotConfig === null || robotConfig === void 0 ? void 0 : robotConfig.merge) === null || _a === void 0 ? void 0 : _a.g3Status) === null || _b === void 0 ? void 0 : _b.include) || [];\n+        const include = ((_b = (_a = robotConfig === null || robotConfig === void 0 ? void 0 : robotConfig.merge) === null || _a === void 0 ? void 0 : _a.g3Status) === null || _b === void 0 ? void 0 : _b.include) || [];\n         /** The files to be expected in the g3 sync. */\n-        const excludeFiles = ((_d = (_c = robotConfig === null || robotConfig === void 0 ? void 0 : robotConfig.merge) === null || _c === void 0 ? void 0 : _c.g3Status) === null || _d === void 0 ? void 0 : _d.exclude) || [];\n-        if (includeFiles.length === 0 && excludeFiles.length === 0) {\n-            debug('No g3Status include or exclude lists are defined in the angular robot configuration,');\n-            debug('skipping.');\n-            return;\n+        const exclude = ((_d = (_c = robotConfig === null || robotConfig === void 0 ? void 0 : robotConfig.merge) === null || _c === void 0 ? void 0 : _c.g3Status) === null || _d === void 0 ? void 0 : _d.exclude) || [];\n+        if (include.length === 0 && exclude.length === 0) {\n+            debug('No g3Status include or exclude lists are defined in the angular robot configuration');\n+            return null;\n         }\n+        return { include, exclude };\n+    }\n+    getLatestShas() {\n         /** The latest sha for the g3 branch. */\n-        const g3Ref = getShaForBranchLatest('g3');\n+        const g3 = this.getShaForBranchLatest('g3');\n         /** The latest sha for the master branch. */\n-        const masterRef = getShaForBranchLatest('master');\n-        if (!g3Ref && !masterRef) {\n-            return debug('Exiting early as either the g3 or master was unable to be retrieved');\n-        }\n-        /** The statistical information about the git diff between master and g3. */\n-        const stats = getDiffStats();\n-        info.group(bold('g3 branch check'));\n-        info(`${stats.commits} commits between g3 and master`);\n-        if (stats.files === 0) {\n-            info('✅ No sync is needed at this time');\n-        }\n-        else {\n-            info(`${stats.files} files changed, ${stats.insertions} insertions(+), ${stats.deletions} deletions(-) will be included in the next sync`);\n-        }\n-        info.groupEnd();\n-        info();\n-        /** Fetch and retrieve the latest sha for a specific branch. */\n-        function getShaForBranchLatest(branch) {\n-            /** The result fo the fetch command. */\n-            const fetchResult = git.runGraceful([\n-                'fetch', '-q', `https://github.com/${git.remoteConfig.owner}/${git.remoteConfig.name}.git`,\n-                branch\n-            ]);\n-            if (fetchResult.status !== 0 &&\n-                fetchResult.stderr.includes(`couldn't find remote ref ${branch}`)) {\n-                debug(`No '${branch}' branch exists on upstream, skipping.`);\n-                return false;\n-            }\n-            return git.runGraceful(['rev-parse', 'FETCH_HEAD']).stdout.trim();\n-        }\n-        /**\n-         * Get git diff stats between master and g3, for all files and filtered to only g3 affecting\n-         * files.\n-         */\n-        function getDiffStats() {\n-            /** The diff stats to be returned. */\n-            const stats = {\n-                insertions: 0,\n-                deletions: 0,\n-                files: 0,\n-                commits: 0,\n-            };\n-            // Determine the number of commits between master and g3 refs. */\n-            stats.commits = parseInt(git.run(['rev-list', '--count', `${g3Ref}..${masterRef}`]).stdout, 10);\n-            // Get the numstat information between master and g3\n-            git.run(['diff', `${g3Ref}...${masterRef}`, '--numstat'])\n-                .stdout\n-                // Remove the extra space after git's output.\n-                .trim()\n-                // Split each line of git output into array\n-                .split('\\n')\n-                // Split each line from the git output into components parts: insertions,\n-                // deletions and file name respectively\n-                .map(line => line.split('\\t'))\n-                // Parse number value from the insertions and deletions values\n-                // Example raw line input:\n-                //   10\\t5\\tsrc/file/name.ts\n-                .map(line => [Number(line[0]), Number(line[1]), line[2]])\n-                // Add each line's value to the diff stats, and conditionally to the g3\n-                // stats as well if the file name is included in the files synced to g3.\n-                .forEach(([insertions, deletions, fileName]) => {\n-                if (checkMatchAgainstIncludeAndExclude(fileName, includeFiles, excludeFiles)) {\n-                    stats.insertions += insertions;\n-                    stats.deletions += deletions;\n-                    stats.files += 1;\n-                }\n-            });\n-            return stats;\n-        }\n-        /** Determine whether the file name passes both include and exclude checks. */\n-        function checkMatchAgainstIncludeAndExclude(file, includes, excludes) {\n-            return (multimatch.call(undefined, file, includes).length >= 1 &&\n-                multimatch.call(undefined, file, excludes).length === 0);\n+        const master = this.getShaForBranchLatest('master');\n+        if (g3 === null || master === null) {\n+            debug('Either the g3 or master was unable to be retrieved');\n+            return null;\n         }\n-    });\n+        return { g3, master };\n+    }\n }\n \n /**\n@@ -1256,70 +1302,90 @@ function printG3Comparison(git) {\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n+/** The fragment for a result from Github's api for a Github query. */\n+const GithubQueryResultFragment = {\n+    issueCount: typedGraphqlify.types.number,\n+    nodes: [Object.assign({}, typedGraphqlify.onUnion({\n+            PullRequest: {\n+                url: typedGraphqlify.types.string,\n+            },\n+            Issue: {\n+                url: typedGraphqlify.types.string,\n+            },\n+        }))],\n+};\n /**\n- * Cap the returned issues in the queries to an arbitrary 100. At that point, caretaker has a lot\n+ * Cap the returned issues in the queries to an arbitrary 20. At that point, caretaker has a lot\n  * of work to do and showing more than that isn't really useful.\n  */\n const MAX_RETURNED_ISSUES = 20;\n-/** Retrieve the number of matching issues for each github query. */\n-function printGithubTasks(git, config) {\n-    var _a;\n-    return tslib.__awaiter(this, void 0, void 0, function* () {\n-        if (!((_a = config === null || config === void 0 ? void 0 : config.githubQueries) === null || _a === void 0 ? void 0 : _a.length)) {\n-            debug('No github queries defined in the configuration, skipping.');\n-            return;\n-        }\n-        info.group(bold(`Github Tasks`));\n-        yield getGithubInfo(git, config);\n-        info.groupEnd();\n-        info();\n-    });\n-}\n-/** Retrieve query match counts and log discovered counts to the console. */\n-function getGithubInfo(git, { githubQueries: queries = [] }) {\n-    return tslib.__awaiter(this, void 0, void 0, function* () {\n+class GithubQueriesModule extends BaseModule {\n+    retrieveData() {\n+        var _a;\n+        return tslib.__awaiter(this, void 0, void 0, function* () {\n+            // Non-null assertion is used here as the check for undefined immediately follows to confirm the\n+            // assertion.  Typescript's type filtering does not seem to work as needed to understand\n+            // whether githubQueries is undefined or not.\n+            let queries = (_a = this.config.caretaker) === null || _a === void 0 ? void 0 : _a.githubQueries;\n+            if (queries === undefined || queries.length === 0) {\n+                debug('No github queries defined in the configuration, skipping');\n+                return;\n+            }\n+            /** The results of the generated github query. */\n+            const queryResult = yield this.git.github.graphql.query(this.buildGraphqlQuery(queries));\n+            const results = Object.values(queryResult);\n+            const { owner, name: repo } = this.git.remoteConfig;\n+            return results.map((result, i) => {\n+                return {\n+                    queryName: queries[i].name,\n+                    count: result.issueCount,\n+                    queryUrl: encodeURI(`https://github.com/${owner}/${repo}/issues?q=${queries[i].query}`),\n+                    matchedUrls: result.nodes.map(node => node.url)\n+                };\n+            });\n+        });\n+    }\n+    /** Build a Graphql query statement for the provided queries. */\n+    buildGraphqlQuery(queries) {\n         /** The query object for graphql. */\n         const graphQlQuery = {};\n+        const { owner, name: repo } = this.git.remoteConfig;\n         /** The Github search filter for the configured repository. */\n-        const repoFilter = `repo:${git.remoteConfig.owner}/${git.remoteConfig.name}`;\n+        const repoFilter = `repo:${owner}/${repo}`;\n         queries.forEach(({ name, query }) => {\n             /** The name of the query, with spaces removed to match GraphQL requirements. */\n             const queryKey = typedGraphqlify.alias(name.replace(/ /g, ''), 'search');\n             graphQlQuery[queryKey] = typedGraphqlify.params({\n                 type: 'ISSUE',\n                 first: MAX_RETURNED_ISSUES,\n                 query: `\"${repoFilter} ${query.replace(/\"/g, '\\\\\"')}\"`,\n-            }, {\n-                issueCount: typedGraphqlify.types.number,\n-                nodes: [Object.assign({}, typedGraphqlify.onUnion({\n-                        PullRequest: {\n-                            url: typedGraphqlify.types.string,\n-                        },\n-                        Issue: {\n-                            url: typedGraphqlify.types.string,\n-                        },\n-                    }))],\n-            });\n+            }, Object.assign({}, GithubQueryResultFragment));\n         });\n-        /** The results of the generated github query. */\n-        const results = yield git.github.graphql.query(graphQlQuery);\n-        Object.values(results).forEach((result, i) => {\n-            var _a, _b;\n-            info(`${(_a = queries[i]) === null || _a === void 0 ? void 0 : _a.name.padEnd(25)} ${result.issueCount}`);\n-            if (result.issueCount > 0) {\n-                const { owner, name: repo } = git.remoteConfig;\n-                const url = encodeURI(`https://github.com/${owner}/${repo}/issues?q=${(_b = queries[i]) === null || _b === void 0 ? void 0 : _b.query}`);\n-                info.group(`${url}`);\n-                if (result.nodes.length === MAX_RETURNED_ISSUES && result.nodes.length < result.issueCount) {\n-                    info(`(first ${MAX_RETURNED_ISSUES})`);\n-                }\n-                for (const node of result.nodes) {\n-                    info(`- ${node.url}`);\n+        return graphQlQuery;\n+    }\n+    printToTerminal() {\n+        return tslib.__awaiter(this, void 0, void 0, function* () {\n+            const queryResults = yield this.data;\n+            if (!queryResults) {\n+                return;\n+            }\n+            info.group(bold('Github Tasks'));\n+            const minQueryNameLength = Math.max(...queryResults.map(result => result.queryName.length));\n+            for (const queryResult of queryResults) {\n+                info(`${queryResult.queryName.padEnd(minQueryNameLength)}  ${queryResult.count}`);\n+                if (queryResult.count > 0) {\n+                    info.group(queryResult.queryUrl);\n+                    queryResult.matchedUrls.forEach(url => info(`- ${url}`));\n+                    if (queryResult.count > MAX_RETURNED_ISSUES) {\n+                        info(`... ${queryResult.count - MAX_RETURNED_ISSUES} additional matches`);\n+                    }\n+                    info.groupEnd();\n                 }\n-                info.groupEnd();\n             }\n+            info.groupEnd();\n+            info();\n         });\n-    });\n+    }\n }\n \n /**\n@@ -1329,71 +1395,64 @@ function getGithubInfo(git, { githubQueries: queries = [] }) {\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-/** The status levels for services. */\n-var ServiceStatus;\n-(function (ServiceStatus) {\n-    ServiceStatus[ServiceStatus[\"GREEN\"] = 0] = \"GREEN\";\n-    ServiceStatus[ServiceStatus[\"RED\"] = 1] = \"RED\";\n-})(ServiceStatus || (ServiceStatus = {}));\n-/** Retrieve and log stasuses for all of the services of concern. */\n-function printServiceStatuses() {\n-    return tslib.__awaiter(this, void 0, void 0, function* () {\n-        info.group(bold(`Service Statuses (checked: ${new Date().toLocaleString()})`));\n-        logStatus('CircleCI', yield getCircleCiStatus());\n-        logStatus('Github', yield getGithubStatus());\n-        logStatus('NPM', yield getNpmStatus());\n-        logStatus('Saucelabs', yield getSaucelabsStatus());\n-        info.groupEnd();\n-        info();\n-    });\n-}\n-/** Log the status of the service to the console. */\n-function logStatus(serviceName, status) {\n-    serviceName = serviceName.padEnd(15);\n-    if (status.status === ServiceStatus.GREEN) {\n-        info(`${serviceName} ${green('✅')}`);\n+/** List of services Angular relies on. */\n+const services = [\n+    {\n+        url: 'https://status.us-west-1.saucelabs.com/api/v2/status.json',\n+        name: 'Saucelabs',\n+    },\n+    {\n+        url: 'https://status.npmjs.org/api/v2/status.json',\n+        name: 'Npm',\n+    },\n+    {\n+        url: 'https://status.circleci.com/api/v2/status.json',\n+        name: 'CircleCi',\n+    },\n+    {\n+        url: 'https://www.githubstatus.com/api/v2/status.json',\n+        name: 'Github',\n+    },\n+];\n+class ServicesModule extends BaseModule {\n+    retrieveData() {\n+        return tslib.__awaiter(this, void 0, void 0, function* () {\n+            return Promise.all(services.map(service => this.getStatusFromStandardApi(service)));\n+        });\n     }\n-    else if (status.status === ServiceStatus.RED) {\n-        info.group(`${serviceName} ${red('❌')} (Updated: ${status.lastUpdated.toLocaleString()})`);\n-        info(`  Details: ${status.description}`);\n-        info.groupEnd();\n+    printToTerminal() {\n+        return tslib.__awaiter(this, void 0, void 0, function* () {\n+            const statuses = yield this.data;\n+            const serviceNameMinLength = Math.max(...statuses.map(service => service.name.length));\n+            info.group(bold('Service Statuses'));\n+            for (const status of statuses) {\n+                const name = status.name.padEnd(serviceNameMinLength);\n+                if (status.status === 'passing') {\n+                    info(`${name} ✅`);\n+                }\n+                else {\n+                    info.group(`${name} ❌ (Updated: ${status.lastUpdated.toLocaleString()})`);\n+                    info(`  Details: ${status.description}`);\n+                    info.groupEnd();\n+                }\n+            }\n+            info.groupEnd();\n+            info();\n+        });\n+    }\n+    /** Retrieve the status information for a service which uses a standard API response. */\n+    getStatusFromStandardApi(service) {\n+        return tslib.__awaiter(this, void 0, void 0, function* () {\n+            const result = yield fetch(service.url).then(result => result.json());\n+            const status = result.status.indicator === 'none' ? 'passing' : 'failing';\n+            return {\n+                name: service.name,\n+                status,\n+                description: result.status.description,\n+                lastUpdated: new Date(result.page.updated_at)\n+            };\n+        });\n     }\n-}\n-/** Gets the service status information for Saucelabs. */\n-function getSaucelabsStatus() {\n-    return tslib.__awaiter(this, void 0, void 0, function* () {\n-        return getStatusFromStandardApi('https://status.us-west-1.saucelabs.com/api/v2/status.json');\n-    });\n-}\n-/** Gets the service status information for NPM. */\n-function getNpmStatus() {\n-    return tslib.__awaiter(this, void 0, void 0, function* () {\n-        return getStatusFromStandardApi('https://status.npmjs.org/api/v2/status.json');\n-    });\n-}\n-/** Gets the service status information for CircleCI. */\n-function getCircleCiStatus() {\n-    return tslib.__awaiter(this, void 0, void 0, function* () {\n-        return getStatusFromStandardApi('https://status.circleci.com/api/v2/status.json');\n-    });\n-}\n-/** Gets the service status information for Github. */\n-function getGithubStatus() {\n-    return tslib.__awaiter(this, void 0, void 0, function* () {\n-        return getStatusFromStandardApi('https://www.githubstatus.com/api/v2/status.json');\n-    });\n-}\n-/** Retrieve the status information for a service which uses a standard API response. */\n-function getStatusFromStandardApi(url) {\n-    return tslib.__awaiter(this, void 0, void 0, function* () {\n-        const result = yield fetch(url).then(result => result.json());\n-        const status = result.status.indicator === 'none' ? ServiceStatus.GREEN : ServiceStatus.RED;\n-        return {\n-            status,\n-            description: result.status.description,\n-            lastUpdated: new Date(result.page.updated_at)\n-        };\n-    });\n }\n \n /**\n@@ -1403,6 +1462,13 @@ function getStatusFromStandardApi(url) {\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n+/** List of modules checked for the caretaker check command. */\n+const moduleList = [\n+    GithubQueriesModule,\n+    ServicesModule,\n+    CiModule,\n+    G3Module,\n+];\n /** Check the status of services which Angular caretakers need to monitor. */\n function checkServiceStatuses(githubToken) {\n     return tslib.__awaiter(this, void 0, void 0, function* () {\n@@ -1412,11 +1478,15 @@ function checkServiceStatuses(githubToken) {\n         const git = new GitClient(githubToken, config);\n         // Prevent logging of the git commands being executed during the check.\n         GitClient.LOG_COMMANDS = false;\n-        // TODO(josephperrott): Allow these checks to be loaded in parallel.\n-        yield printServiceStatuses();\n-        yield printGithubTasks(git, config.caretaker);\n-        yield printG3Comparison(git);\n-        yield printCiStatus(git);\n+        /** List of instances of Caretaker Check modules */\n+        const caretakerCheckModules = moduleList.map(module => new module(git, config));\n+        // Module's `data` is casted as Promise<unknown> because the data types of the `module`'s `data`\n+        // promises do not match typings, however our usage here is only to determine when the promise\n+        // resolves.\n+        yield Promise.all(caretakerCheckModules.map(module => module.data));\n+        for (const module of caretakerCheckModules) {\n+            yield module.printToTerminal();\n+        }\n     });\n }\n "
        },
        {
            "sha": "e1fefe8bdac91e05685f808c1674fd05a2d532e0",
            "filename": "dev-infra/utils/testing/virtual-git-client.ts",
            "status": "modified",
            "additions": 26,
            "deletions": 0,
            "changes": 26,
            "blob_url": "https://github.com/angular/angular/blob/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Futils%2Ftesting%2Fvirtual-git-client.ts",
            "raw_url": "https://github.com/angular/angular/raw/2d797803841610e5ef8dbecb6d34be500fa6066b/dev-infra%2Futils%2Ftesting%2Fvirtual-git-client.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Futils%2Ftesting%2Fvirtual-git-client.ts?ref=2d797803841610e5ef8dbecb6d34be500fa6066b",
            "patch": "@@ -9,8 +9,25 @@\n import {SpawnSyncOptions, SpawnSyncReturns} from 'child_process';\n import * as parseArgs from 'minimist';\n \n+import {NgDevConfig} from '../config';\n import {GitClient} from '../git/index';\n \n+/**\n+ * Temporary directory which will be used as project directory in tests. Note that\n+ * this environment variable is automatically set by Bazel for tests.\n+ */\n+export const testTmpDir: string = process.env['TEST_TMPDIR']!;\n+\n+\n+/** A mock instance of a configuration for the ng-dev toolset for default testing. */\n+export const mockNgDevConfig: NgDevConfig = {\n+  github: {\n+    name: 'name',\n+    owner: 'owner',\n+  }\n+};\n+\n+\n /** Type describing a Git head. */\n interface GitHead {\n   /** Name of the head. Not defined in a detached state. */\n@@ -171,3 +188,12 @@ export class VirtualGitClient extends GitClient {\n     };\n   }\n }\n+\n+\n+/**\n+ * Builds a Virtual Git Client instance with the provided config and set the temporary test\n+ * directory.\n+ */\n+export function buildVirtualGitClient(config = mockNgDevConfig, tmpDir = testTmpDir) {\n+  return (new VirtualGitClient(undefined, config, tmpDir));\n+}"
        }
    ],
    "stats": {
        "total": 1641,
        "additions": 1176,
        "deletions": 465
    }
}