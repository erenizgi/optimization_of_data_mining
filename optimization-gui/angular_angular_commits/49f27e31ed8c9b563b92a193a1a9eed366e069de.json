{
    "author": "JoostK",
    "message": "test(compiler-cli): re-enable dynamic value diagnostic tests on Windows CI (#37782)\n\nThis commit re-enables some tests that were temporarily disabled on Windows,\nas they failed on native Windows CI. The Windows filesystem emulation has\nbeen corrected in an earlier commit, such that the original failure would\nnow also occur during emulation on Linux CI.\n\nPR Close #37782",
    "sha": "49f27e31ed8c9b563b92a193a1a9eed366e069de",
    "files": [
        {
            "sha": "390c6ee93366fee6cfd476b7fb19a7250603a6ac",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/test/diagnostics_spec.ts",
            "status": "modified",
            "additions": 78,
            "deletions": 85,
            "changes": 163,
            "blob_url": "https://github.com/angular/angular/blob/49f27e31ed8c9b563b92a193a1a9eed366e069de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fdiagnostics_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/49f27e31ed8c9b563b92a193a1a9eed366e069de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fdiagnostics_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fdiagnostics_spec.ts?ref=49f27e31ed8c9b563b92a193a1a9eed366e069de",
            "patch": "@@ -6,99 +6,92 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {platform} from 'os';\n import * as ts from 'typescript';\n \n-import {FatalDiagnosticError} from '../../diagnostics';\n-import {absoluteFrom as _} from '../../file_system';\n+import {absoluteFrom as _, getSourceFileOrError} from '../../file_system';\n import {runInEachFileSystem, TestFile} from '../../file_system/testing';\n import {PartialEvaluator} from '../../partial_evaluator';\n import {TypeScriptReflectionHost} from '../../reflection';\n import {getDeclaration, makeProgram} from '../../testing';\n import {createValueHasWrongTypeError} from '../src/diagnostics';\n \n-runInEachFileSystem(os => {\n+runInEachFileSystem(() => {\n   describe('ngtsc annotation diagnostics', () => {\n-    // These tests are currently disabled when running in Windows mode as the assertions involving\n-    // the filename attached to the diagnostic are suffering from a case-sensitivity issue.\n-    //\n-    // TODO(JoostK): re-enable on Windows once the case issue has been solved.\n-    if (os !== 'Windows' && platform() !== 'win32') {\n-      describe('createValueError()', () => {\n-        it('should include a trace for dynamic values', () => {\n-          const error = createError('', 'nonexistent', 'Error message');\n-\n-          if (typeof error.message === 'string') {\n-            return fail('Created error must have a message chain');\n-          }\n-          expect(error.message.messageText).toBe('Error message');\n-          expect(error.message.next!.length).toBe(1);\n-          expect(error.message.next![0].messageText)\n-              .toBe(`Value could not be determined statically.`);\n-\n-          expect(error.relatedInformation).toBeDefined();\n-          expect(error.relatedInformation!.length).toBe(1);\n-\n-          expect(error.relatedInformation![0].messageText).toBe('Unknown reference.');\n-          expect(error.relatedInformation![0].file!.fileName).toBe(_('/entry.ts'));\n-          expect(getSourceCode(error.relatedInformation![0])).toBe('nonexistent');\n-        });\n-\n-        it('should include a pointer for a reference to a named declaration', () => {\n-          const error = createError(\n-              `import {Foo} from './foo';`, 'Foo', 'Error message',\n-              [{name: _('/foo.ts'), contents: 'export class Foo {}'}]);\n-\n-          if (typeof error.message === 'string') {\n-            return fail('Created error must have a message chain');\n-          }\n-          expect(error.message.messageText).toBe('Error message');\n-          expect(error.message.next!.length).toBe(1);\n-          expect(error.message.next![0].messageText).toBe(`Value is a reference to 'Foo'.`);\n-\n-          expect(error.relatedInformation).toBeDefined();\n-          expect(error.relatedInformation!.length).toBe(1);\n-          expect(error.relatedInformation![0].messageText).toBe('Reference is declared here.');\n-          expect(error.relatedInformation![0].file!.fileName).toBe(_('/foo.ts'));\n-          expect(getSourceCode(error.relatedInformation![0])).toBe('Foo');\n-        });\n-\n-        it('should include a pointer for a reference to an anonymous declaration', () => {\n-          const error = createError(\n-              `import Foo from './foo';`, 'Foo', 'Error message',\n-              [{name: _('/foo.ts'), contents: 'export default class {}'}]);\n-\n-          if (typeof error.message === 'string') {\n-            return fail('Created error must have a message chain');\n-          }\n-          expect(error.message.messageText).toBe('Error message');\n-          expect(error.message.next!.length).toBe(1);\n-          expect(error.message.next![0].messageText)\n-              .toBe(`Value is a reference to an anonymous declaration.`);\n-\n-          expect(error.relatedInformation).toBeDefined();\n-          expect(error.relatedInformation!.length).toBe(1);\n-          expect(error.relatedInformation![0].messageText).toBe('Reference is declared here.');\n-          expect(error.relatedInformation![0].file!.fileName).toBe(_('/foo.ts'));\n-          expect(getSourceCode(error.relatedInformation![0])).toBe('export default class {}');\n-        });\n-\n-        it('should include a representation of the value\\'s type', () => {\n-          const error = createError('', '{a: 2}', 'Error message');\n-\n-          if (typeof error.message === 'string') {\n-            return fail('Created error must have a message chain');\n-          }\n-          expect(error.message.messageText).toBe('Error message');\n-          expect(error.message.next!.length).toBe(1);\n-          expect(error.message.next![0].messageText).toBe(`Value is of type '{ a: number }'.`);\n-\n-          expect(error.relatedInformation).not.toBeDefined();\n-        });\n+    describe('createValueError()', () => {\n+      it('should include a trace for dynamic values', () => {\n+        const {error, program} = createError('', 'nonexistent', 'Error message');\n+        const entrySf = getSourceFileOrError(program, _('/entry.ts'));\n+\n+        if (typeof error.message === 'string') {\n+          return fail('Created error must have a message chain');\n+        }\n+        expect(error.message.messageText).toBe('Error message');\n+        expect(error.message.next!.length).toBe(1);\n+        expect(error.message.next![0].messageText)\n+            .toBe(`Value could not be determined statically.`);\n+\n+        expect(error.relatedInformation).toBeDefined();\n+        expect(error.relatedInformation!.length).toBe(1);\n+\n+        expect(error.relatedInformation![0].messageText).toBe('Unknown reference.');\n+        expect(error.relatedInformation![0].file!.fileName).toBe(entrySf.fileName);\n+        expect(getSourceCode(error.relatedInformation![0])).toBe('nonexistent');\n       });\n-    }\n \n-    it('should not be empty', () => {});\n+      it('should include a pointer for a reference to a named declaration', () => {\n+        const {error, program} = createError(\n+            `import {Foo} from './foo';`, 'Foo', 'Error message',\n+            [{name: _('/foo.ts'), contents: 'export class Foo {}'}]);\n+        const fooSf = getSourceFileOrError(program, _('/foo.ts'));\n+\n+        if (typeof error.message === 'string') {\n+          return fail('Created error must have a message chain');\n+        }\n+        expect(error.message.messageText).toBe('Error message');\n+        expect(error.message.next!.length).toBe(1);\n+        expect(error.message.next![0].messageText).toBe(`Value is a reference to 'Foo'.`);\n+\n+        expect(error.relatedInformation).toBeDefined();\n+        expect(error.relatedInformation!.length).toBe(1);\n+        expect(error.relatedInformation![0].messageText).toBe('Reference is declared here.');\n+        expect(error.relatedInformation![0].file!.fileName).toBe(fooSf.fileName);\n+        expect(getSourceCode(error.relatedInformation![0])).toBe('Foo');\n+      });\n+\n+      it('should include a pointer for a reference to an anonymous declaration', () => {\n+        const {error, program} = createError(\n+            `import Foo from './foo';`, 'Foo', 'Error message',\n+            [{name: _('/foo.ts'), contents: 'export default class {}'}]);\n+        const fooSf = getSourceFileOrError(program, _('/foo.ts'));\n+\n+        if (typeof error.message === 'string') {\n+          return fail('Created error must have a message chain');\n+        }\n+        expect(error.message.messageText).toBe('Error message');\n+        expect(error.message.next!.length).toBe(1);\n+        expect(error.message.next![0].messageText)\n+            .toBe(`Value is a reference to an anonymous declaration.`);\n+\n+        expect(error.relatedInformation).toBeDefined();\n+        expect(error.relatedInformation!.length).toBe(1);\n+        expect(error.relatedInformation![0].messageText).toBe('Reference is declared here.');\n+        expect(error.relatedInformation![0].file!.fileName).toBe(fooSf.fileName);\n+        expect(getSourceCode(error.relatedInformation![0])).toBe('export default class {}');\n+      });\n+\n+      it('should include a representation of the value\\'s type', () => {\n+        const {error} = createError('', '{a: 2}', 'Error message');\n+\n+        if (typeof error.message === 'string') {\n+          return fail('Created error must have a message chain');\n+        }\n+        expect(error.message.messageText).toBe('Error message');\n+        expect(error.message.next!.length).toBe(1);\n+        expect(error.message.next![0].messageText).toBe(`Value is of type '{ a: number }'.`);\n+\n+        expect(error.relatedInformation).not.toBeDefined();\n+      });\n+    });\n   });\n });\n \n@@ -108,8 +101,7 @@ function getSourceCode(diag: ts.DiagnosticRelatedInformation): string {\n }\n \n function createError(\n-    code: string, expr: string, messageText: string,\n-    supportingFiles: TestFile[] = []): FatalDiagnosticError {\n+    code: string, expr: string, messageText: string, supportingFiles: TestFile[] = []) {\n   const {program} = makeProgram(\n       [{name: _('/entry.ts'), contents: `${code}; const target$ = ${expr}`}, ...supportingFiles],\n       /* options */ undefined, /* host */ undefined, /* checkForErrors */ false);\n@@ -121,5 +113,6 @@ function createError(\n   const evaluator = new PartialEvaluator(reflectionHost, checker, /* dependencyTracker */ null);\n \n   const value = evaluator.evaluate(valueExpr);\n-  return createValueHasWrongTypeError(valueExpr, value, messageText);\n+  const error = createValueHasWrongTypeError(valueExpr, value, messageText);\n+  return {error, program};\n }"
        },
        {
            "sha": "dd60007982a6f4b64347e36ad271f07667d07966",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker_spec.ts",
            "status": "modified",
            "additions": 42,
            "deletions": 47,
            "changes": 89,
            "blob_url": "https://github.com/angular/angular/blob/49f27e31ed8c9b563b92a193a1a9eed366e069de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/49f27e31ed8c9b563b92a193a1a9eed366e069de/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts?ref=49f27e31ed8c9b563b92a193a1a9eed366e069de",
            "patch": "@@ -6,16 +6,14 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {platform} from 'os';\n-\n import {ErrorCode, ngErrorCode} from '../../diagnostics';\n import {absoluteFrom, absoluteFromSourceFile, getSourceFileOrError} from '../../file_system';\n import {runInEachFileSystem} from '../../file_system/testing';\n import {OptimizeFor} from '../api';\n \n import {getClass, setup, TestDeclaration} from './test_utils';\n \n-runInEachFileSystem(os => {\n+runInEachFileSystem(() => {\n   describe('TemplateTypeChecker', () => {\n     it('should batch diagnostic operations when requested in WholeProgram mode', () => {\n       const file1 = absoluteFrom('/file1.ts');\n@@ -172,50 +170,47 @@ runInEachFileSystem(os => {\n         expect(diags[0].code).toBe(ngErrorCode(ErrorCode.INLINE_TCB_REQUIRED));\n       });\n \n-      // These tests are currently disabled when running in Windows mode as the assertions involving\n-      // the filename attached to the diagnostic are suffering from a case-sensitivity issue.\n-      if (os !== 'Windows' && platform() !== 'win32') {\n-        it('should produce errors for components that require type constructor inlining', () => {\n-          const fileName = absoluteFrom('/main.ts');\n-          const dirFile = absoluteFrom('/dir.ts');\n-          const {program, templateTypeChecker} = setup(\n-              [\n-                {\n-                  fileName,\n-                  source: `export class Cmp {}`,\n-                  templates: {'Cmp': '<div dir></div>'},\n-                  declarations: [{\n-                    name: 'TestDir',\n-                    selector: '[dir]',\n-                    file: dirFile,\n-                    type: 'directive',\n-                    isGeneric: true,\n-                  }]\n-                },\n-                {\n-                  fileName: dirFile,\n-                  source: `\n-                  // A non-exported interface used as a type bound for a generic directive causes\n-                  // an inline type constructor to be required.\n-                  interface NotExported {}\n-                  export abstract class TestDir<T extends NotExported> {}`,\n-                  templates: {},\n-                }\n-              ],\n-              {inlining: false});\n-          const sf = getSourceFileOrError(program, fileName);\n-          const diags = templateTypeChecker.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram);\n-          expect(diags.length).toBe(1);\n-          expect(diags[0].code).toBe(ngErrorCode(ErrorCode.INLINE_TYPE_CTOR_REQUIRED));\n-\n-          // The relatedInformation of the diagnostic should point to the directive which required\n-          // the inline type constructor.\n-          expect(diags[0].relatedInformation).not.toBeUndefined();\n-          expect(diags[0].relatedInformation!.length).toBe(1);\n-          expect(diags[0].relatedInformation![0].file).not.toBeUndefined();\n-          expect(absoluteFromSourceFile(diags[0].relatedInformation![0].file!)).toBe(dirFile);\n-        });\n-      }\n+      it('should produce errors for components that require type constructor inlining', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const dirFile = absoluteFrom('/dir.ts');\n+        const {program, templateTypeChecker} = setup(\n+            [\n+              {\n+                fileName,\n+                source: `export class Cmp {}`,\n+                templates: {'Cmp': '<div dir></div>'},\n+                declarations: [{\n+                  name: 'TestDir',\n+                  selector: '[dir]',\n+                  file: dirFile,\n+                  type: 'directive',\n+                  isGeneric: true,\n+                }]\n+              },\n+              {\n+                fileName: dirFile,\n+                source: `\n+                // A non-exported interface used as a type bound for a generic directive causes\n+                // an inline type constructor to be required.\n+                interface NotExported {}\n+                export class TestDir<T extends NotExported> {}`,\n+                templates: {},\n+              }\n+            ],\n+            {inlining: false});\n+        const sf = getSourceFileOrError(program, fileName);\n+        const diags = templateTypeChecker.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram);\n+        expect(diags.length).toBe(1);\n+        expect(diags[0].code).toBe(ngErrorCode(ErrorCode.INLINE_TYPE_CTOR_REQUIRED));\n+\n+        // The relatedInformation of the diagnostic should point to the directive which required\n+        // the inline type constructor.\n+        const dirSf = getSourceFileOrError(program, dirFile);\n+        expect(diags[0].relatedInformation).not.toBeUndefined();\n+        expect(diags[0].relatedInformation!.length).toBe(1);\n+        expect(diags[0].relatedInformation![0].file).not.toBeUndefined();\n+        expect(absoluteFromSourceFile(diags[0].relatedInformation![0].file!)).toBe(dirSf.fileName);\n+      });\n     });\n \n     describe('template overrides', () => {"
        }
    ],
    "stats": {
        "total": 252,
        "additions": 120,
        "deletions": 132
    }
}