{
    "author": "JoostK",
    "message": "fix(compiler): include parenthesis in expression source spans (#40740)\n\nThe parser does not include parenthesis in the AST, so if a LHS\nexpression would be parenthesized then its start span would start\nafter the opening parenthesis. Previously, some parent AST nodes would\nbe created with the start span of its LHS as its own start, so this\nresulted in the parent AST node not encompassing the opening parenthesis\nin its source span. This commit fixes the issue by capturing the start\nindex prior to parsing a child AST tree, which is then used as the\nstart of the source span of the the parent AST node that is parsed.\n\nFixes #40721\n\nPR Close #40740",
    "sha": "bbf61fc2be22822c9ebd027586ef49ca68138553",
    "files": [
        {
            "sha": "a20d1057ae239bb2e9f9eafa46b7462996574ef2",
            "filename": "packages/compiler/src/expression_parser/parser.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 20,
            "changes": 36,
            "blob_url": "https://github.com/angular/angular/blob/bbf61fc2be22822c9ebd027586ef49ca68138553/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "raw_url": "https://github.com/angular/angular/raw/bbf61fc2be22822c9ebd027586ef49ca68138553/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts?ref=bbf61fc2be22822c9ebd027586ef49ca68138553",
            "patch": "@@ -582,6 +582,7 @@ export class _ParseAST {\n   }\n \n   parsePipe(): AST {\n+    const start = this.inputIndex;\n     let result = this.parseExpression();\n     if (this.consumeOptionalOperator('|')) {\n       if (this.parseAction) {\n@@ -621,7 +622,6 @@ export class _ParseAST {\n           // If there are additional expressions beyond the name, then the artificial end for the\n           // name is no longer relevant.\n         }\n-        const {start} = result.span;\n         result = new BindingPipe(\n             this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, nameSpan);\n       } while (this.consumeOptionalOperator('|'));\n@@ -657,28 +657,29 @@ export class _ParseAST {\n \n   parseLogicalOr(): AST {\n     // '||'\n+    const start = this.inputIndex;\n     let result = this.parseLogicalAnd();\n     while (this.consumeOptionalOperator('||')) {\n       const right = this.parseLogicalAnd();\n-      const {start} = result.span;\n       result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);\n     }\n     return result;\n   }\n \n   parseLogicalAnd(): AST {\n     // '&&'\n+    const start = this.inputIndex;\n     let result = this.parseEquality();\n     while (this.consumeOptionalOperator('&&')) {\n       const right = this.parseEquality();\n-      const {start} = result.span;\n       result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);\n     }\n     return result;\n   }\n \n   parseEquality(): AST {\n     // '==','!=','===','!=='\n+    const start = this.inputIndex;\n     let result = this.parseRelational();\n     while (this.next.type == TokenType.Operator) {\n       const operator = this.next.strValue;\n@@ -689,7 +690,6 @@ export class _ParseAST {\n         case '!==':\n           this.advance();\n           const right = this.parseRelational();\n-          const {start} = result.span;\n           result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n           continue;\n       }\n@@ -700,6 +700,7 @@ export class _ParseAST {\n \n   parseRelational(): AST {\n     // '<', '>', '<=', '>='\n+    const start = this.inputIndex;\n     let result = this.parseAdditive();\n     while (this.next.type == TokenType.Operator) {\n       const operator = this.next.strValue;\n@@ -710,7 +711,6 @@ export class _ParseAST {\n         case '>=':\n           this.advance();\n           const right = this.parseAdditive();\n-          const {start} = result.span;\n           result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n           continue;\n       }\n@@ -721,6 +721,7 @@ export class _ParseAST {\n \n   parseAdditive(): AST {\n     // '+', '-'\n+    const start = this.inputIndex;\n     let result = this.parseMultiplicative();\n     while (this.next.type == TokenType.Operator) {\n       const operator = this.next.strValue;\n@@ -729,7 +730,6 @@ export class _ParseAST {\n         case '-':\n           this.advance();\n           let right = this.parseMultiplicative();\n-          const {start} = result.span;\n           result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n           continue;\n       }\n@@ -740,6 +740,7 @@ export class _ParseAST {\n \n   parseMultiplicative(): AST {\n     // '*', '%', '/'\n+    const start = this.inputIndex;\n     let result = this.parsePrefix();\n     while (this.next.type == TokenType.Operator) {\n       const operator = this.next.strValue;\n@@ -749,7 +750,6 @@ export class _ParseAST {\n         case '/':\n           this.advance();\n           let right = this.parsePrefix();\n-          const {start} = result.span;\n           result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n           continue;\n       }\n@@ -782,14 +782,14 @@ export class _ParseAST {\n   }\n \n   parseCallChain(): AST {\n+    const start = this.inputIndex;\n     let result = this.parsePrimary();\n-    const resultStart = result.span.start;\n     while (true) {\n       if (this.consumeOptionalCharacter(chars.$PERIOD)) {\n-        result = this.parseAccessMemberOrMethodCall(result, false);\n+        result = this.parseAccessMemberOrMethodCall(result, start, false);\n \n       } else if (this.consumeOptionalOperator('?.')) {\n-        result = this.parseAccessMemberOrMethodCall(result, true);\n+        result = this.parseAccessMemberOrMethodCall(result, start, true);\n \n       } else if (this.consumeOptionalCharacter(chars.$LBRACKET)) {\n         this.withContext(ParseContextFlags.Writable, () => {\n@@ -802,23 +802,20 @@ export class _ParseAST {\n           this.expectCharacter(chars.$RBRACKET);\n           if (this.consumeOptionalOperator('=')) {\n             const value = this.parseConditional();\n-            result = new KeyedWrite(\n-                this.span(resultStart), this.sourceSpan(resultStart), result, key, value);\n+            result = new KeyedWrite(this.span(start), this.sourceSpan(start), result, key, value);\n           } else {\n-            result =\n-                new KeyedRead(this.span(resultStart), this.sourceSpan(resultStart), result, key);\n+            result = new KeyedRead(this.span(start), this.sourceSpan(start), result, key);\n           }\n         });\n       } else if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n         this.rparensExpected++;\n         const args = this.parseCallArguments();\n         this.rparensExpected--;\n         this.expectCharacter(chars.$RPAREN);\n-        result =\n-            new FunctionCall(this.span(resultStart), this.sourceSpan(resultStart), result, args);\n+        result = new FunctionCall(this.span(start), this.sourceSpan(start), result, args);\n \n       } else if (this.consumeOptionalOperator('!')) {\n-        result = new NonNullAssert(this.span(resultStart), this.sourceSpan(resultStart), result);\n+        result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);\n \n       } else {\n         return result;\n@@ -866,7 +863,7 @@ export class _ParseAST {\n \n     } else if (this.next.isIdentifier()) {\n       return this.parseAccessMemberOrMethodCall(\n-          new ImplicitReceiver(this.span(start), this.sourceSpan(start)), false);\n+          new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);\n \n     } else if (this.next.isNumber()) {\n       const value = this.next.toNumber();\n@@ -920,8 +917,7 @@ export class _ParseAST {\n     return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);\n   }\n \n-  parseAccessMemberOrMethodCall(receiver: AST, isSafe: boolean = false): AST {\n-    const start = receiver.span.start;\n+  parseAccessMemberOrMethodCall(receiver: AST, start: number, isSafe: boolean = false): AST {\n     const nameStart = this.inputIndex;\n     const id = this.withContext(ParseContextFlags.Writable, () => {\n       const id = this.expectIdentifierOrKeyword() ?? '';"
        },
        {
            "sha": "5c4ab2c8767be1ea49e8401267f58238384b8511",
            "filename": "packages/compiler/test/expression_parser/parser_spec.ts",
            "status": "modified",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/bbf61fc2be22822c9ebd027586ef49ca68138553/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/bbf61fc2be22822c9ebd027586ef49ca68138553/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts?ref=bbf61fc2be22822c9ebd027586ef49ca68138553",
            "patch": "@@ -371,6 +371,39 @@ describe('parser', () => {\n       expect(unparseWithSpan(ast)).toContain(['a.b = c', 'a.b = c']);\n       expect(unparseWithSpan(ast)).toContain(['a.b = c', '[nameSpan] b']);\n     });\n+\n+    it('should include parenthesis in spans', () => {\n+      // When a LHS expression is parenthesized, the parenthesis on the left used to be\n+      // excluded from the span. This test verifies that the parenthesis are properly included\n+      // in the span for both LHS and RHS expressions.\n+      // https://github.com/angular/angular/issues/40721\n+      expectSpan('(foo) && (bar)');\n+      expectSpan('(foo) || (bar)');\n+      expectSpan('(foo) == (bar)');\n+      expectSpan('(foo) === (bar)');\n+      expectSpan('(foo) != (bar)');\n+      expectSpan('(foo) !== (bar)');\n+      expectSpan('(foo) > (bar)');\n+      expectSpan('(foo) >= (bar)');\n+      expectSpan('(foo) < (bar)');\n+      expectSpan('(foo) <= (bar)');\n+      expectSpan('(foo) + (bar)');\n+      expectSpan('(foo) - (bar)');\n+      expectSpan('(foo) * (bar)');\n+      expectSpan('(foo) / (bar)');\n+      expectSpan('(foo) % (bar)');\n+      expectSpan('(foo) | pipe');\n+      expectSpan('(foo)()');\n+      expectSpan('(foo).bar');\n+      expectSpan('(foo)?.bar');\n+      expectSpan('(foo).bar = (baz)');\n+      expectSpan('(foo | pipe) == false');\n+      expectSpan('(((foo) && bar) || baz) === true');\n+\n+      function expectSpan(input: string) {\n+        expect(unparseWithSpan(parseBinding(input))).toContain([jasmine.any(String), input]);\n+      }\n+    });\n   });\n \n   describe('general error handling', () => {"
        }
    ],
    "stats": {
        "total": 69,
        "additions": 49,
        "deletions": 20
    }
}