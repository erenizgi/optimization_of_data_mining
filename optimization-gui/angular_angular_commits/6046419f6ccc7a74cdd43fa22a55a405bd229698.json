{
    "author": "gkalpak",
    "message": "fix(service-worker): correctly handle failed cache-busted request (#39786)\n\nSince 5be4edfa17120ab1b9c9e8d87b7b539cdd180a25, a failing cache-busted\nnetwork request (such as requests for fetching uncached assets) will\ncause the ServiceWorker to incorrectly enter a degraded\n`EXISTING_CLIENTS_ONLY` mode. A failing network request could be caused\nby many reasons, including the client or server being offline, and does\nnot necessarily signify a broken ServiceWorker state.\n\nThis commit fixes the logic in `cacheBustedFetchFromNetwork()` to\ncorrectly handle errors in network requests.\nFor more details on the problem and the implemented fix see #39775.\n\nFixes #39775\n\nPR Close #39786",
    "sha": "6046419f6ccc7a74cdd43fa22a55a405bd229698",
    "files": [
        {
            "sha": "ebaeba4fd2709d0c3c7cc6ab323b4e49ec1e0a7c",
            "filename": "packages/service-worker/worker/src/assets.ts",
            "status": "modified",
            "additions": 33,
            "deletions": 39,
            "changes": 72,
            "blob_url": "https://github.com/angular/angular/blob/6046419f6ccc7a74cdd43fa22a55a405bd229698/packages%2Fservice-worker%2Fworker%2Fsrc%2Fassets.ts",
            "raw_url": "https://github.com/angular/angular/raw/6046419f6ccc7a74cdd43fa22a55a405bd229698/packages%2Fservice-worker%2Fworker%2Fsrc%2Fassets.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Fsrc%2Fassets.ts?ref=6046419f6ccc7a74cdd43fa22a55a405bd229698",
            "patch": "@@ -388,18 +388,17 @@ export abstract class AssetGroup {\n       // a stale response.\n \n       // Fetch the resource from the network (possibly hitting the HTTP cache).\n-      const networkResult = await this.safeFetch(req);\n-\n-      // Decide whether a cache-busted request is necessary. It might be for two independent\n-      // reasons: either the non-cache-busted request failed (hopefully transiently) or if the\n-      // hash of the content retrieved does not match the canonical hash from the manifest. It's\n-      // only valid to access the content of the first response if the request was successful.\n-      let makeCacheBustedRequest: boolean = !networkResult.ok;\n-      if (networkResult.ok) {\n+      let response = await this.safeFetch(req);\n+\n+      // Decide whether a cache-busted request is necessary. A cache-busted request is necessary\n+      // only if the request was successful but the hash of the retrieved contents does not match\n+      // the canonical hash from the manifest.\n+      let makeCacheBustedRequest = response.ok;\n+      if (makeCacheBustedRequest) {\n         // The request was successful. A cache-busted request is only necessary if the hashes\n-        // don't match. Compare them, making sure to clone the response so it can be used later\n-        // if it proves to be valid.\n-        const fetchedHash = sha1Binary(await networkResult.clone().arrayBuffer());\n+        // don't match.\n+        // (Make sure to clone the response so it can be used later if it proves to be valid.)\n+        const fetchedHash = sha1Binary(await response.clone().arrayBuffer());\n         makeCacheBustedRequest = (fetchedHash !== canonicalHash);\n       }\n \n@@ -411,39 +410,34 @@ export abstract class AssetGroup {\n         // request will differentiate these two situations.\n         // TODO: handle case where the URL has parameters already (unlikely for assets).\n         const cacheBustReq = this.adapter.newRequest(this.cacheBust(req.url));\n-        const cacheBustedResult = await this.safeFetch(cacheBustReq);\n-\n-        // If the response was unsuccessful, there's nothing more that can be done.\n-        if (!cacheBustedResult.ok) {\n-          if (cacheBustedResult.status === 404) {\n-            throw new SwUnrecoverableStateError(\n-                `Failed to retrieve hashed resource from the server. (AssetGroup: ${\n-                    this.config.name} | URL: ${url})`);\n-          } else {\n-            throw new SwCriticalError(\n-                `Response not Ok (cacheBustedFetchFromNetwork): cache busted request for ${\n-                    req.url} returned response ${cacheBustedResult.status} ${\n-                    cacheBustedResult.statusText}`);\n+        response = await this.safeFetch(cacheBustReq);\n+\n+        // If the response was successful, check the contents against the canonical hash.\n+        if (response.ok) {\n+          // Hash the contents.\n+          // (Make sure to clone the response so it can be used later if it proves to be valid.)\n+          const cacheBustedHash = sha1Binary(await response.clone().arrayBuffer());\n+\n+          // If the cache-busted version doesn't match, then the manifest is not an accurate\n+          // representation of the server's current set of files, and the SW should give up.\n+          if (canonicalHash !== cacheBustedHash) {\n+            throw new SwCriticalError(`Hash mismatch (cacheBustedFetchFromNetwork): ${\n+                req.url}: expected ${canonicalHash}, got ${cacheBustedHash} (after cache busting)`);\n           }\n         }\n+      }\n \n-        // Hash the contents.\n-        const cacheBustedHash = sha1Binary(await cacheBustedResult.clone().arrayBuffer());\n-\n-        // If the cache-busted version doesn't match, then the manifest is not an accurate\n-        // representation of the server's current set of files, and the SW should give up.\n-        if (canonicalHash !== cacheBustedHash) {\n-          throw new SwCriticalError(`Hash mismatch (cacheBustedFetchFromNetwork): ${\n-              req.url}: expected ${canonicalHash}, got ${cacheBustedHash} (after cache busting)`);\n-        }\n-\n-        // If it does match, then use the cache-busted result.\n-        return cacheBustedResult;\n+      // At this point, `response` is either successful with a matching hash or is unsuccessful.\n+      // Before returning it, check whether it failed with a 404 status. This would signify an\n+      // unrecoverable state.\n+      if (!response.ok && (response.status === 404)) {\n+        throw new SwUnrecoverableStateError(\n+            `Failed to retrieve hashed resource from the server. (AssetGroup: ${\n+                this.config.name} | URL: ${url})`);\n       }\n \n-      // Excellent, the version from the network matched on the first try, with no need for\n-      // cache-busting. Use it.\n-      return networkResult;\n+      // Return the response (successful or unsuccessful).\n+      return response;\n     } else {\n       // This URL doesn't exist in our hash database, so it must be requested directly.\n       return this.safeFetch(req);"
        },
        {
            "sha": "31c72b607a8a7caeb3a17f9df83c5d71a230eaff",
            "filename": "packages/service-worker/worker/test/happy_spec.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 2,
            "changes": 23,
            "blob_url": "https://github.com/angular/angular/blob/6046419f6ccc7a74cdd43fa22a55a405bd229698/packages%2Fservice-worker%2Fworker%2Ftest%2Fhappy_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/6046419f6ccc7a74cdd43fa22a55a405bd229698/packages%2Fservice-worker%2Fworker%2Ftest%2Fhappy_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fservice-worker%2Fworker%2Ftest%2Fhappy_spec.ts?ref=6046419f6ccc7a74cdd43fa22a55a405bd229698",
            "patch": "@@ -794,7 +794,7 @@ describe('Driver', () => {\n     serverUpdate.assertNoOtherRequests();\n   });\n \n-  it('should bypass serviceworker on ngsw-bypass parameter', async () => {\n+  it('bypasses the ServiceWorker on `ngsw-bypass` parameter', async () => {\n     // NOTE:\n     // Requests that bypass the SW are not handled at all in the mock implementation of `scope`,\n     // therefore no requests reach the server.\n@@ -1115,7 +1115,7 @@ describe('Driver', () => {\n       server.assertNoOtherRequests();\n     });\n \n-    it(`doesn't error when 'Cache-Control' is 'no-cache'`, async () => {\n+    it(`don't error when 'Cache-Control' is 'no-cache'`, async () => {\n       expect(await makeRequest(scope, '/unhashed/b.txt')).toEqual('this is unhashed b');\n       server.assertSawRequestFor('/unhashed/b.txt');\n       expect(await makeRequest(scope, '/unhashed/b.txt')).toEqual('this is unhashed b');\n@@ -1744,6 +1744,25 @@ describe('Driver', () => {\n       expect(requestUrls2).toContain(httpsRequestUrl);\n     });\n \n+    it('does not enter degraded mode when offline while fetching an uncached asset', async () => {\n+      // Trigger SW initialization and wait for it to complete.\n+      expect(await makeRequest(scope, '/foo.txt')).toBe('this is foo');\n+      await driver.initialized;\n+\n+      // Request an uncached asset while offline.\n+      // The SW will not be able to get the content, but it should not enter a degraded mode either.\n+      server.online = false;\n+      await expectAsync(makeRequest(scope, '/baz.txt'))\n+          .toBeRejectedWithError(\n+              'Response not Ok (fetchAndCacheOnce): request for /baz.txt returned response 504 Gateway Timeout');\n+      expect(driver.state).toBe(DriverReadyState.NORMAL);\n+\n+      // Once we are back online, everything should work as expected.\n+      server.online = true;\n+      expect(await makeRequest(scope, '/baz.txt')).toBe('this is baz');\n+      expect(driver.state).toBe(DriverReadyState.NORMAL);\n+    });\n+\n     describe('unrecoverable state', () => {\n       const generateMockServerState = (fileSystem: MockFileSystem) => {\n         const manifest: Manifest = {"
        }
    ],
    "stats": {
        "total": 95,
        "additions": 54,
        "deletions": 41
    }
}