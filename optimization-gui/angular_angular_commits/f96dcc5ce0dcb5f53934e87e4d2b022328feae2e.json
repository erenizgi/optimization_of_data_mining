{
    "author": "devversion",
    "message": "feat(dev-infra): tool for staging and publishing releases (#38656)\n\nCreates a tool for staging and publishing releases as per the\nnew branching and versioning that has been outlined in the following\ndocument. The tool is intended to be used across the organization to\nensure consistent branching/versioning and labeling:\n\nhttps://docs.google.com/document/d/197kVillDwx-RZtSVOBtPb4BBIAw0E9RT3q3v6DZkykU/edit#heading=h.s3qlps8f4zq7dd\n\nThe tool implements the actions as outlined in the following\ninitial plan: https://hackmd.io/2Le8leq0S6G_R5VEVTNK9A.\n\nThe implementation slightly diverged in so far that it performs\nstaging and publishing together so that releasing is a single\nconvenient command. In case of errors for which re-running the\nfull command is not sufficient, we want to consider adding\nrecover functionality. e.g. when the staging completed, but the\nactual NPM publishing aborted unexpectedly due to build errors.\n\nPR Close #38656",
    "sha": "f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
    "files": [
        {
            "sha": "bc71ec94c9c06aac2c40ace72577fbee33b54aaf",
            "filename": "dev-infra/release/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2FBUILD.bazel?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -9,6 +9,7 @@ ts_library(\n     visibility = [\"//dev-infra:__subpackages__\"],\n     deps = [\n         \"//dev-infra/release/build\",\n+        \"//dev-infra/release/publish\",\n         \"//dev-infra/release/set-dist-tag\",\n         \"//dev-infra/utils\",\n         \"@npm//@types/yargs\","
        },
        {
            "sha": "988b34643792c682276e6da18dc5d967e24d7392",
            "filename": "dev-infra/release/cli.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fcli.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fcli.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fcli.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -8,6 +8,7 @@\n import * as yargs from 'yargs';\n \n import {ReleaseBuildCommandModule} from './build/cli';\n+import {ReleasePublishCommandModule} from './publish/cli';\n import {ReleaseSetDistTagCommand} from './set-dist-tag/cli';\n import {buildEnvStamp} from './stamping/env-stamp';\n \n@@ -16,6 +17,7 @@ export function buildReleaseParser(localYargs: yargs.Argv) {\n   return localYargs.help()\n       .strict()\n       .demandCommand()\n+      .command(ReleasePublishCommandModule)\n       .command(ReleaseBuildCommandModule)\n       .command(ReleaseSetDistTagCommand)\n       .command("
        },
        {
            "sha": "c58ed9db6540e3a0566c00a74888ec8f50ee055a",
            "filename": "dev-infra/release/publish/BUILD.bazel",
            "status": "added",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2FBUILD.bazel?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,25 @@\n+load(\"@npm_bazel_typescript//:index.bzl\", \"ts_library\")\n+\n+ts_library(\n+    name = \"publish\",\n+    srcs = glob([\n+        \"**/*.ts\",\n+    ]),\n+    module_name = \"@angular/dev-infra-private/release/publish\",\n+    visibility = [\"//dev-infra:__subpackages__\"],\n+    deps = [\n+        \"//dev-infra/pr/merge\",\n+        \"//dev-infra/release/config\",\n+        \"//dev-infra/release/versioning\",\n+        \"//dev-infra/utils\",\n+        \"@npm//@octokit/rest\",\n+        \"@npm//@types/inquirer\",\n+        \"@npm//@types/node\",\n+        \"@npm//@types/semver\",\n+        \"@npm//@types/yargs\",\n+        \"@npm//inquirer\",\n+        \"@npm//ora\",\n+        \"@npm//semver\",\n+        \"@npm//typed-graphqlify\",\n+    ],\n+)"
        },
        {
            "sha": "517b7bcf47d6af7af6e77c70eb924e3477c0790b",
            "filename": "dev-infra/release/publish/actions-error.ts",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions-error.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions-error.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Factions-error.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,29 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+/** Error that will be thrown if the user manually aborted a release action. */\n+export class UserAbortedReleaseActionError extends Error {\n+  constructor() {\n+    super();\n+    // Set the prototype explicitly because in ES5, the prototype is accidentally lost due to\n+    // a limitation in down-leveling.\n+    // https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-extending-built-ins-like-error-array-and-map-work.\n+    Object.setPrototypeOf(this, UserAbortedReleaseActionError.prototype);\n+  }\n+}\n+\n+/** Error that will be thrown if the action has been aborted due to a fatal error. */\n+export class FatalReleaseActionError extends Error {\n+  constructor() {\n+    super();\n+    // Set the prototype explicitly because in ES5, the prototype is accidentally lost due to\n+    // a limitation in down-leveling.\n+    // https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-extending-built-ins-like-error-array-and-map-work.\n+    Object.setPrototypeOf(this, FatalReleaseActionError.prototype);\n+  }\n+}"
        },
        {
            "sha": "72cfa4f137e82c89c0da851549ba797e2717a9e7",
            "filename": "dev-infra/release/publish/actions.ts",
            "status": "added",
            "additions": 543,
            "deletions": 0,
            "changes": 543,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Factions.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,543 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {promises as fs} from 'fs';\n+import * as Ora from 'ora';\n+import {join} from 'path';\n+import * as semver from 'semver';\n+\n+import {debug, error, green, info, promptConfirm, red, warn, yellow} from '../../utils/console';\n+import {getListCommitsInBranchUrl, getRepositoryGitUrl} from '../../utils/git/github-urls';\n+import {GitClient} from '../../utils/git/index';\n+import {BuiltPackage, ReleaseConfig} from '../config';\n+import {ActiveReleaseTrains} from '../versioning/active-release-trains';\n+import {runNpmPublish} from '../versioning/npm-publish';\n+\n+import {FatalReleaseActionError, UserAbortedReleaseActionError} from './actions-error';\n+import {getCommitMessageForRelease, getReleaseNoteCherryPickCommitMessage} from './commit-message';\n+import {changelogPath, packageJsonPath, waitForPullRequestInterval} from './constants';\n+import {invokeReleaseBuildCommand, invokeYarnInstallCommand} from './external-commands';\n+import {findOwnedForksOfRepoQuery} from './graphql-queries';\n+import {getPullRequestState} from './pull-request-state';\n+import {getDefaultExtractReleaseNotesPattern, getLocalChangelogFilePath} from './release-notes';\n+\n+/** Interface describing a Github repository. */\n+export interface GithubRepo {\n+  owner: string;\n+  name: string;\n+}\n+\n+/** Interface describing a Github pull request. */\n+export interface PullRequest {\n+  /** Unique id for the pull request (i.e. the PR number). */\n+  id: number;\n+  /** URL that resolves to the pull request in Github. */\n+  url: string;\n+  /** Fork containing the head branch of this pull request. */\n+  fork: GithubRepo;\n+  /** Branch name in the fork that defines this pull request. */\n+  forkBranch: string;\n+}\n+\n+/** Constructor type for a instantiating a release action */\n+export interface ReleaseActionConstructor<T extends ReleaseAction = ReleaseAction> {\n+  /** Whether the release action is currently active. */\n+  isActive(active: ActiveReleaseTrains): Promise<boolean>;\n+  /** Constructs a release action. */\n+  new(...args: [ActiveReleaseTrains, GitClient, ReleaseConfig, string]): T;\n+}\n+\n+/**\n+ * Abstract base class for a release action. A release action is selectable by the caretaker\n+ * if active, and can perform changes for releasing, such as staging a release, bumping the\n+ * version, cherry-picking the changelog, branching off from master. etc.\n+ */\n+export abstract class ReleaseAction {\n+  /** Whether the release action is currently active. */\n+  static isActive(_trains: ActiveReleaseTrains): Promise<boolean> {\n+    throw Error('Not implemented.');\n+  }\n+\n+  /** Gets the description for a release action. */\n+  abstract getDescription(): Promise<string>;\n+  /**\n+   * Performs the given release action.\n+   * @throws {UserAbortedReleaseActionError} When the user manually aborted the action.\n+   * @throws {FatalReleaseActionError} When the action has been aborted due to a fatal error.\n+   */\n+  abstract perform(): Promise<void>;\n+\n+  /** Cached found fork of the configured project. */\n+  private _cachedForkRepo: GithubRepo|null = null;\n+\n+  constructor(\n+      protected active: ActiveReleaseTrains, protected git: GitClient,\n+      protected config: ReleaseConfig, protected projectDir: string) {}\n+\n+  /** Updates the version in the project top-level `package.json` file. */\n+  protected async updateProjectVersion(newVersion: semver.SemVer) {\n+    const pkgJsonPath = join(this.projectDir, packageJsonPath);\n+    const pkgJson = JSON.parse(await fs.readFile(pkgJsonPath, 'utf8'));\n+    pkgJson.version = newVersion.format();\n+    // Write the `package.json` file. Note that we add a trailing new line\n+    // to avoid unnecessary diff. IDEs usually add a trailing new line.\n+    await fs.writeFile(pkgJsonPath, `${JSON.stringify(pkgJson, null, 2)}\\n`);\n+    info(green(`  ✓   Updated project version to ${pkgJson.version}`));\n+  }\n+\n+  /** Gets the most recent commit of a specified branch. */\n+  private async _getCommitOfBranch(branchName: string): Promise<string> {\n+    const {data: {commit}} =\n+        await this.git.github.repos.getBranch({...this.git.remoteParams, branch: branchName});\n+    return commit.sha;\n+  }\n+\n+  /** Verifies that the latest commit for the given branch is passing all statuses. */\n+  protected async verifyPassingGithubStatus(branchName: string) {\n+    const commitSha = await this._getCommitOfBranch(branchName);\n+    const {data: {state}} = await this.git.github.repos.getCombinedStatusForRef(\n+        {...this.git.remoteParams, ref: commitSha});\n+    const branchCommitsUrl = getListCommitsInBranchUrl(this.git, branchName);\n+\n+    if (state === 'failure') {\n+      error(\n+          red(`  ✘   Cannot stage release. Commit \"${commitSha}\" does not pass all github ` +\n+              `status checks. Please make sure this commit passes all checks before re-running.`));\n+      error(`      Please have a look at: ${branchCommitsUrl}`);\n+\n+      if (await promptConfirm('Do you want to ignore the Github status and proceed?')) {\n+        info(yellow(\n+            `  ⚠   Upstream commit is failing CI checks, but status has been ` +\n+            `forcibly ignored.`));\n+        return;\n+      }\n+      throw new UserAbortedReleaseActionError();\n+    } else if (state === 'pending') {\n+      error(\n+          red(`  ✘   Commit \"${commitSha}\" still has pending github statuses that ` +\n+              `need to succeed before staging a release.`));\n+      error(red(`      Please have a look at: ${branchCommitsUrl}`));\n+      if (await promptConfirm('Do you want to ignore the Github status and proceed?')) {\n+        info(yellow(\n+            `  ⚠   Upstream commit is pending CI, but status has been ` +\n+            `forcibly ignored.`));\n+        return;\n+      }\n+      throw new UserAbortedReleaseActionError();\n+    }\n+\n+    info(green('  ✓   Upstream commit is passing all github status checks.'));\n+  }\n+\n+  /** Generates the changelog for the specified for the current `HEAD`. */\n+  private async _generateReleaseNotesForHead(version: semver.SemVer) {\n+    const changelogPath = getLocalChangelogFilePath(this.projectDir);\n+    await this.config.generateReleaseNotesForHead(changelogPath);\n+    info(green(`  ✓   Updated the changelog to capture changes for \"${version}\".`));\n+  }\n+\n+  /** Extract the release notes for the given version from the changelog file. */\n+  private _extractReleaseNotesForVersion(changelogContent: string, version: semver.SemVer): string\n+      |null {\n+    const pattern = this.config.extractReleaseNotesPattern !== undefined ?\n+        this.config.extractReleaseNotesPattern(version) :\n+        getDefaultExtractReleaseNotesPattern(version);\n+    const matchedNotes = pattern.exec(changelogContent);\n+    return matchedNotes === null ? null : matchedNotes[1];\n+  }\n+\n+  /**\n+   * Prompts the user for potential release notes edits that need to be made. Once\n+   * confirmed, a new commit for the release point is created.\n+   */\n+  protected async waitForEditsAndCreateReleaseCommit(newVersion: semver.SemVer) {\n+    info(yellow(\n+        `  ⚠   Please review the changelog and ensure that the log contains only changes ` +\n+        `that apply to the public API surface. Manual changes can be made. When done, please ` +\n+        `proceed with the prompt below.`));\n+\n+    if (!await promptConfirm('Do you want to proceed and commit the changes?')) {\n+      throw new UserAbortedReleaseActionError();\n+    }\n+\n+    // Commit message for the release point.\n+    const commitMessage = getCommitMessageForRelease(newVersion);\n+    // Create a release staging commit including changelog and version bump.\n+    await this.createCommit(commitMessage, [packageJsonPath, changelogPath]);\n+\n+    info(green(`  ✓   Created release commit for: \"${newVersion}\".`));\n+  }\n+\n+  /**\n+   * Gets an owned fork for the configured project of the authenticated user. Aborts the\n+   * process with an error if no fork could be found. Also caches the determined fork\n+   * repository as the authenticated user cannot change during action execution.\n+   */\n+  private async _getForkOfAuthenticatedUser(): Promise<GithubRepo> {\n+    if (this._cachedForkRepo !== null) {\n+      return this._cachedForkRepo;\n+    }\n+\n+    const {owner, name} = this.git.remoteConfig;\n+    const result = await this.git.github.graphql.query(findOwnedForksOfRepoQuery, {owner, name});\n+    const forks = result.repository.forks.nodes;\n+\n+    if (forks.length === 0) {\n+      error(red(`  ✘   Unable to find fork for currently authenticated user.`));\n+      error(red(`      Please ensure you created a fork of: ${owner}/${name}.`));\n+      throw new FatalReleaseActionError();\n+    }\n+\n+    const fork = forks[0];\n+    return this._cachedForkRepo = {owner: fork.owner.login, name: fork.name};\n+  }\n+\n+  /** Checks whether a given branch name is reserved in the specified repository. */\n+  private async _isBranchNameReservedInRepo(repo: GithubRepo, name: string): Promise<boolean> {\n+    try {\n+      await this.git.github.repos.getBranch({owner: repo.owner, repo: repo.name, branch: name});\n+      return true;\n+    } catch (e) {\n+      // If the error has a `status` property set to `404`, then we know that the branch\n+      // does not exist. Otherwise, it might be an API error that we want to report/re-throw.\n+      if (e.status === 404) {\n+        return false;\n+      }\n+      throw e;\n+    }\n+  }\n+\n+  /** Finds a non-reserved branch name in the repository with respect to a base name. */\n+  private async _findAvailableBranchName(repo: GithubRepo, baseName: string): Promise<string> {\n+    let currentName = baseName;\n+    let suffixNum = 0;\n+    while (await this._isBranchNameReservedInRepo(repo, currentName)) {\n+      suffixNum++;\n+      currentName = `${baseName}_${suffixNum}`;\n+    }\n+    return currentName;\n+  }\n+\n+  /**\n+   * Creates a local branch from the current Git `HEAD`. Will override\n+   * existing branches in case of a collision.\n+   */\n+  protected async createLocalBranchFromHead(branchName: string) {\n+    this.git.run(['checkout', '-B', branchName]);\n+  }\n+\n+  /** Pushes the current Git `HEAD` to the given remote branch in the configured project. */\n+  protected async pushHeadToRemoteBranch(branchName: string) {\n+    // Push the local `HEAD` to the remote branch in the configured project.\n+    this.git.run(['push', this.git.repoGitUrl, `HEAD:refs/heads/${branchName}`]);\n+  }\n+\n+  /**\n+   * Pushes the current Git `HEAD` to a fork for the configured project that is owned by\n+   * the authenticated user. If the specified branch name exists in the fork already, a\n+   * unique one will be generated based on the proposed name to avoid collisions.\n+   * @param proposedBranchName Proposed branch name for the fork.\n+   * @param trackLocalBranch Whether the fork branch should be tracked locally. i.e. whether\n+   *   a local branch with remote tracking should be set up.\n+   * @returns The fork and branch name containing the pushed changes.\n+   */\n+  private async _pushHeadToFork(proposedBranchName: string, trackLocalBranch: boolean):\n+      Promise<{fork: GithubRepo, branchName: string}> {\n+    const fork = await this._getForkOfAuthenticatedUser();\n+    // Compute a repository URL for pushing to the fork. Note that we want to respect\n+    // the SSH option from the dev-infra github configuration.\n+    const repoGitUrl =\n+        getRepositoryGitUrl({...fork, useSsh: this.git.remoteConfig.useSsh}, this.git.githubToken);\n+    const branchName = await this._findAvailableBranchName(fork, proposedBranchName);\n+    const pushArgs: string[] = [];\n+    // If a local branch should track the remote fork branch, create a branch matching\n+    // the remote branch. Later with the `git push`, the remote is set for the branch.\n+    if (trackLocalBranch) {\n+      await this.createLocalBranchFromHead(branchName);\n+      pushArgs.push('--set-upstream');\n+    }\n+    // Push the local `HEAD` to the remote branch in the fork.\n+    this.git.run(['push', repoGitUrl, `HEAD:refs/heads/${branchName}`, ...pushArgs]);\n+    return {fork, branchName};\n+  }\n+\n+  /**\n+   * Pushes changes to a fork for the configured project that is owned by the currently\n+   * authenticated user. A pull request is then created for the pushed changes on the\n+   * configured project that targets the specified target branch.\n+   * @returns An object describing the created pull request.\n+   */\n+  protected async pushChangesToForkAndCreatePullRequest(\n+      targetBranch: string, proposedForkBranchName: string, title: string,\n+      body?: string): Promise<PullRequest> {\n+    const repoSlug = `${this.git.remoteParams.owner}/${this.git.remoteParams.repo}`;\n+    const {fork, branchName} = await this._pushHeadToFork(proposedForkBranchName, true);\n+    const {data} = await this.git.github.pulls.create({\n+      ...this.git.remoteParams,\n+      head: `${fork.owner}:${branchName}`,\n+      base: targetBranch,\n+      body,\n+      title,\n+    });\n+\n+    info(green(`  ✓   Created pull request #${data.number} in ${repoSlug}.`));\n+    return {\n+      id: data.number,\n+      url: data.html_url,\n+      fork,\n+      forkBranch: branchName,\n+    };\n+  }\n+\n+  /**\n+   * Waits for the given pull request to be merged. Default interval for checking the Github\n+   * API is 10 seconds (to not exceed any rate limits). If the pull request is closed without\n+   * merge, the script will abort gracefully (considering a manual user abort).\n+   */\n+  protected async waitForPullRequestToBeMerged(id: number, interval = waitForPullRequestInterval):\n+      Promise<void> {\n+    return new Promise((resolve, reject) => {\n+      debug(`Waiting for pull request #${id} to be merged.`);\n+\n+      const spinner = Ora().start(`Waiting for pull request #${id} to be merged.`);\n+      const intervalId = setInterval(async () => {\n+        const prState = await getPullRequestState(this.git, id);\n+        if (prState === 'merged') {\n+          spinner.stop();\n+          info(green(`  ✓   Pull request #${id} has been merged.`));\n+          clearInterval(intervalId);\n+          resolve();\n+        } else if (prState === 'closed') {\n+          spinner.stop();\n+          warn(yellow(`  ✘   Pull request #${id} has been closed.`));\n+          clearInterval(intervalId);\n+          reject(new UserAbortedReleaseActionError());\n+        }\n+      }, interval);\n+    });\n+  }\n+\n+  /**\n+   * Prepend releases notes for a version published in a given branch to the changelog in\n+   * the current Git `HEAD`. This is useful for cherry-picking the changelog.\n+   * @returns A boolean indicating whether the release notes have been prepended.\n+   */\n+  protected async prependReleaseNotesFromVersionBranch(\n+      version: semver.SemVer, containingBranch: string): Promise<boolean> {\n+    const {data} = await this.git.github.repos.getContents(\n+        {...this.git.remoteParams, path: '/' + changelogPath, ref: containingBranch});\n+    const branchChangelog = Buffer.from(data.content, 'base64').toString();\n+    let releaseNotes = this._extractReleaseNotesForVersion(branchChangelog, version);\n+    // If no release notes could be extracted, return \"false\" so that the caller\n+    // can tell that changelog prepending failed.\n+    if (releaseNotes === null) {\n+      return false;\n+    }\n+    const localChangelogPath = getLocalChangelogFilePath(this.projectDir);\n+    const localChangelog = await fs.readFile(localChangelogPath, 'utf8');\n+    // If the extracted release notes do not have any new lines at the end and the\n+    // local changelog is not empty, we add lines manually so that there is space\n+    // between the previous and cherry-picked release notes.\n+    if (!/[\\r\\n]+$/.test(releaseNotes) && localChangelog !== '') {\n+      releaseNotes = `${releaseNotes}\\n\\n`;\n+    }\n+    // Prepend the extracted release notes to the local changelog and write it back.\n+    await fs.writeFile(localChangelogPath, releaseNotes + localChangelog);\n+    return true;\n+  }\n+\n+  /** Checks out an upstream branch with a detached head. */\n+  protected async checkoutUpstreamBranch(branchName: string) {\n+    this.git.run(['fetch', this.git.repoGitUrl, branchName]);\n+    this.git.run(['checkout', 'FETCH_HEAD', '--detach']);\n+  }\n+\n+  /**\n+   * Creates a commit for the specified files with the given message.\n+   * @param message Message for the created commit\n+   * @param files List of project-relative file paths to be commited.\n+   */\n+  protected async createCommit(message: string, files: string[]) {\n+    this.git.run(['commit', '--no-verify', '-m', message, ...files]);\n+  }\n+\n+  /**\n+   * Creates a cherry-pick commit for the release notes of the specified version that\n+   * has been pushed to the given branch.\n+   * @returns a boolean indicating whether the commit has been created successfully.\n+   */\n+  protected async createCherryPickReleaseNotesCommitFrom(\n+      version: semver.SemVer, branchName: string): Promise<boolean> {\n+    const commitMessage = getReleaseNoteCherryPickCommitMessage(version);\n+\n+    // Fetch, extract and prepend the release notes to the local changelog. If that is not\n+    // possible, abort so that we can ask the user to manually cherry-pick the changelog.\n+    if (!await this.prependReleaseNotesFromVersionBranch(version, branchName)) {\n+      return false;\n+    }\n+\n+    // Create a changelog cherry-pick commit.\n+    await this.createCommit(commitMessage, [changelogPath]);\n+\n+    info(green(`  ✓   Created changelog cherry-pick commit for: \"${version}\".`));\n+    return true;\n+  }\n+\n+  /**\n+   * Stages the specified new version for the current branch and creates a\n+   * pull request that targets the given base branch.\n+   * @returns an object describing the created pull request.\n+   */\n+  protected async stageVersionForBranchAndCreatePullRequest(\n+      newVersion: semver.SemVer, pullRequestBaseBranch: string): Promise<PullRequest> {\n+    await this.updateProjectVersion(newVersion);\n+    await this._generateReleaseNotesForHead(newVersion);\n+    await this.waitForEditsAndCreateReleaseCommit(newVersion);\n+\n+    const pullRequest = await this.pushChangesToForkAndCreatePullRequest(\n+        pullRequestBaseBranch, `release-stage-${newVersion}`,\n+        `Bump version to \"v${newVersion}\" with changelog.`);\n+\n+    info(green('  ✓   Release staging pull request has been created.'));\n+    info(yellow(`      Please ask team members to review: ${pullRequest.url}.`));\n+\n+    return pullRequest;\n+  }\n+\n+  /**\n+   * Checks out the specified target branch, verifies its CI status and stages\n+   * the specified new version in order to create a pull request.\n+   * @returns an object describing the created pull request.\n+   */\n+  protected async checkoutBranchAndStageVersion(newVersion: semver.SemVer, stagingBranch: string):\n+      Promise<PullRequest> {\n+    await this.verifyPassingGithubStatus(stagingBranch);\n+    await this.checkoutUpstreamBranch(stagingBranch);\n+    return await this.stageVersionForBranchAndCreatePullRequest(newVersion, stagingBranch);\n+  }\n+\n+  /**\n+   * Cherry-picks the release notes of a version that have been pushed to a given branch\n+   * into the `next` primary development branch. A pull request is created for this.\n+   * @returns a boolean indicating successful creation of the cherry-pick pull request.\n+   */\n+  protected async cherryPickChangelogIntoNextBranch(\n+      newVersion: semver.SemVer, stagingBranch: string): Promise<boolean> {\n+    const nextBranch = this.active.next.branchName;\n+    const commitMessage = getReleaseNoteCherryPickCommitMessage(newVersion);\n+\n+    // Checkout the next branch.\n+    await this.checkoutUpstreamBranch(nextBranch);\n+\n+    // Cherry-pick the release notes into the current branch. If it fails,\n+    // ask the user to manually copy the release notes into the next branch.\n+    if (!await this.createCherryPickReleaseNotesCommitFrom(newVersion, stagingBranch)) {\n+      error(yellow(`  ✘   Could not cherry-pick release notes for v${newVersion}.`));\n+      error(\n+          yellow(`      Please copy the release notes manually into the \"${nextBranch}\" branch.`));\n+      return false;\n+    }\n+\n+    // Create a cherry-pick pull request that should be merged by the caretaker.\n+    const {url} = await this.pushChangesToForkAndCreatePullRequest(\n+        nextBranch, `changelog-cherry-pick-${newVersion}`, commitMessage,\n+        `Cherry-picks the changelog from the \"${stagingBranch}\" branch to the next ` +\n+            `branch (${nextBranch}).`);\n+\n+    info(green(\n+        `  ✓   Pull request for cherry-picking the changelog into \"${nextBranch}\" ` +\n+        `has been created.`));\n+    info(yellow(`      Please ask team members to review: ${url}.`));\n+    return true;\n+  }\n+\n+  /**\n+   * Creates a Github release for the specified version in the configured project.\n+   * The release is created by tagging the specified commit SHA.\n+   */\n+  private async _createGithubReleaseForVersion(\n+      newVersion: semver.SemVer, versionBumpCommitSha: string) {\n+    const tagName = newVersion.format();\n+    await this.git.github.git.createRef({\n+      ...this.git.remoteParams,\n+      ref: `refs/tags/${tagName}`,\n+      sha: versionBumpCommitSha,\n+    });\n+    info(green(`  ✓   Tagged v${newVersion} release upstream.`));\n+\n+    await this.git.github.repos.createRelease({\n+      ...this.git.remoteParams,\n+      name: `v${newVersion}`,\n+      tag_name: tagName,\n+    });\n+    info(green(`  ✓   Created v${newVersion} release in Github.`));\n+  }\n+\n+  /**\n+   * Builds and publishes the given version in the specified branch.\n+   * @param newVersion The new version to be published.\n+   * @param publishBranch Name of the branch that contains the new version.\n+   * @param npmDistTag NPM dist tag where the version should be published to.\n+   */\n+  protected async buildAndPublish(\n+      newVersion: semver.SemVer, publishBranch: string, npmDistTag: string) {\n+    const versionBumpCommitSha = await this._getCommitOfBranch(publishBranch);\n+\n+    if (!await this._isCommitForVersionStaging(newVersion, versionBumpCommitSha)) {\n+      error(red(`  ✘   Latest commit in \"${publishBranch}\" branch is not a staging commit.`));\n+      error(red(`      Please make sure the staging pull request has been merged.`));\n+      throw new FatalReleaseActionError();\n+    }\n+\n+    // Checkout the publish branch and build the release packages.\n+    await this.checkoutUpstreamBranch(publishBranch);\n+\n+    // Install the project dependencies for the publish branch, and then build the release\n+    // packages. Note that we do not directly call the build packages function from the release\n+    // config. We only want to build and publish packages that have been configured in the given\n+    // publish branch. e.g. consider we publish patch version and a new package has been\n+    // created in the `next` branch. The new package would not be part of the patch branch,\n+    // so we cannot build and publish it.\n+    await invokeYarnInstallCommand(this.projectDir);\n+    const builtPackages = await invokeReleaseBuildCommand();\n+\n+    // Create a Github release for the new version.\n+    await this._createGithubReleaseForVersion(newVersion, versionBumpCommitSha);\n+\n+    // Walk through all built packages and publish them to NPM.\n+    for (const builtPackage of builtPackages) {\n+      await this._publishBuiltPackageToNpm(builtPackage, npmDistTag);\n+    }\n+\n+    info(green(`  ✓   Published all packages successfully`));\n+  }\n+\n+  /** Publishes the given built package to NPM with the specified NPM dist tag. */\n+  private async _publishBuiltPackageToNpm(pkg: BuiltPackage, npmDistTag: string) {\n+    debug(`Starting publish of \"${pkg.name}\".`);\n+    const spinner = Ora().start(`Publishing \"${pkg.name}\"`);\n+\n+    try {\n+      await runNpmPublish(pkg.outputPath, npmDistTag, this.config.publishRegistry);\n+      spinner.stop();\n+      info(green(`  ✓   Successfully published \"${pkg.name}.`));\n+    } catch (e) {\n+      spinner.stop();\n+      error(e);\n+      error(red(`  ✘   An error occurred while publishing \"${pkg.name}\".`));\n+      throw new FatalReleaseActionError();\n+    }\n+  }\n+\n+  /** Checks whether the given commit represents a staging commit for the specified version. */\n+  private async _isCommitForVersionStaging(version: semver.SemVer, commitSha: string) {\n+    const {data} =\n+        await this.git.github.repos.getCommit({...this.git.remoteParams, ref: commitSha});\n+    return data.commit.message.startsWith(getCommitMessageForRelease(version));\n+  }\n+}"
        },
        {
            "sha": "b4ced15a52009663d4c05b79a28a011f4614557e",
            "filename": "dev-infra/release/publish/actions/configure-next-as-major.ts",
            "status": "added",
            "additions": 53,
            "deletions": 0,
            "changes": 53,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions%2Fconfigure-next-as-major.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions%2Fconfigure-next-as-major.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Factions%2Fconfigure-next-as-major.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,53 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as semver from 'semver';\n+\n+import {green, info, yellow} from '../../../utils/console';\n+import {ActiveReleaseTrains} from '../../versioning/active-release-trains';\n+import {ReleaseAction} from '../actions';\n+import {getCommitMessageForNextBranchMajorSwitch} from '../commit-message';\n+import {packageJsonPath} from '../constants';\n+\n+/**\n+ * Release action that configures the active next release-train to be for a major\n+ * version. This means that major changes can land in the next branch.\n+ */\n+export class ConfigureNextAsMajorAction extends ReleaseAction {\n+  private _newVersion = semver.parse(`${this.active.next.version.major + 1}.0.0-next.0`)!;\n+\n+  async getDescription() {\n+    const {branchName} = this.active.next;\n+    const newVersion = this._newVersion;\n+    return `Configure the \"${branchName}\" branch to be released as major (v${newVersion}).`;\n+  }\n+\n+  async perform() {\n+    const {branchName} = this.active.next;\n+    const newVersion = this._newVersion;\n+\n+    await this.verifyPassingGithubStatus(branchName);\n+    await this.checkoutUpstreamBranch(branchName);\n+    await this.updateProjectVersion(newVersion);\n+    await this.createCommit(\n+        getCommitMessageForNextBranchMajorSwitch(newVersion), [packageJsonPath]);\n+    const pullRequest = await this.pushChangesToForkAndCreatePullRequest(\n+        branchName, `switch-next-to-major-${newVersion}`,\n+        `Configure next branch to receive major changes for v${newVersion}`);\n+\n+    info(green('  ✓   Next branch update pull request has been created.'));\n+    info(yellow(`      Please ask team members to review: ${pullRequest.url}.`));\n+  }\n+\n+  static async isActive(active: ActiveReleaseTrains) {\n+    // The `next` branch can always be switched to a major version, unless it already\n+    // is targeting a new major. A major can contain minor changes, so we can always\n+    // change the target from a minor to a major.\n+    return !active.next.isMajor;\n+  }\n+}"
        },
        {
            "sha": "e5b3cf3fa07dbaecb2071ed557e5a036e023ee5e",
            "filename": "dev-infra/release/publish/actions/cut-lts-patch.ts",
            "status": "added",
            "additions": 93,
            "deletions": 0,
            "changes": 93,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions%2Fcut-lts-patch.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions%2Fcut-lts-patch.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Factions%2Fcut-lts-patch.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,93 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {ListChoiceOptions, prompt} from 'inquirer';\n+import * as semver from 'semver';\n+\n+import {ActiveReleaseTrains} from '../../versioning/active-release-trains';\n+import {semverInc} from '../../versioning/inc-semver';\n+import {fetchLongTermSupportBranchesFromNpm} from '../../versioning/long-term-support';\n+import {ReleaseAction} from '../actions';\n+\n+/** Interface describing an LTS version branch. */\n+interface LtsBranch {\n+  /** Name of the branch. */\n+  name: string;\n+  /** Most recent version for the given LTS branch. */\n+  version: semver.SemVer;\n+  /** NPM dist tag for the LTS version. */\n+  npmDistTag: string;\n+}\n+\n+/**\n+ * Release action that cuts a new patch release for an active release-train in the long-term\n+ * support phase. The patch segment is incremented. The changelog is generated for the new\n+ * patch version, but also needs to be cherry-picked into the next development branch.\n+ */\n+export class CutLongTermSupportPatchAction extends ReleaseAction {\n+  /** Promise resolving an object describing long-term support branches. */\n+  ltsBranches = fetchLongTermSupportBranchesFromNpm(this.config);\n+\n+  async getDescription() {\n+    const {active} = await this.ltsBranches;\n+    return `Cut a new release for an active LTS branch (${active.length} active).`;\n+  }\n+\n+  async perform() {\n+    const ltsBranch = await this._promptForTargetLtsBranch();\n+    const newVersion = semverInc(ltsBranch.version, 'patch');\n+    const {id} = await this.checkoutBranchAndStageVersion(newVersion, ltsBranch.name);\n+\n+    await this.waitForPullRequestToBeMerged(id);\n+    await this.buildAndPublish(newVersion, ltsBranch.name, ltsBranch.npmDistTag);\n+    await this.cherryPickChangelogIntoNextBranch(newVersion, ltsBranch.name);\n+  }\n+\n+  /** Prompts the user to select an LTS branch for which a patch should but cut. */\n+  private async _promptForTargetLtsBranch(): Promise<LtsBranch> {\n+    const {active, inactive} = await this.ltsBranches;\n+    const activeBranchChoices = active.map(branch => this._getChoiceForLtsBranch(branch));\n+\n+    // If there are inactive LTS branches, we allow them to be selected. In some situations,\n+    // patch releases are still cut for inactive LTS branches. e.g. when the LTS duration\n+    // has been increased due to exceptional events ()\n+    if (inactive.length !== 0) {\n+      activeBranchChoices.push({name: 'Inactive LTS versions (not recommended)', value: null});\n+    }\n+\n+    const {activeLtsBranch, inactiveLtsBranch} =\n+        await prompt<{activeLtsBranch: LtsBranch | null, inactiveLtsBranch: LtsBranch}>([\n+          {\n+            name: 'activeLtsBranch',\n+            type: 'list',\n+            message: 'Please select a version for which you want to cut a LTS patch',\n+            choices: activeBranchChoices,\n+          },\n+          {\n+            name: 'inactiveLtsBranch',\n+            type: 'list',\n+            when: o => o.activeLtsBranch === null,\n+            message: 'Please select an inactive LTS version for which you want to cut a LTS patch',\n+            choices: inactive.map(branch => this._getChoiceForLtsBranch(branch)),\n+          }\n+        ]);\n+    return activeLtsBranch ?? inactiveLtsBranch;\n+  }\n+\n+  /** Gets an inquirer choice for the given LTS branch. */\n+  private _getChoiceForLtsBranch(branch: LtsBranch): ListChoiceOptions {\n+    return {name: `v${branch.version.major} (from ${branch.name})`, value: branch};\n+  }\n+\n+  static async isActive(active: ActiveReleaseTrains) {\n+    // LTS patch versions can be only cut if there are release trains in LTS phase.\n+    // This action is always selectable as we support publishing of old LTS branches,\n+    // and have prompt for selecting an LTS branch when the action performs.\n+    return true;\n+  }\n+}"
        },
        {
            "sha": "fe8d79203f078b1aaf6f848dba215fe1b6ba0b70",
            "filename": "dev-infra/release/publish/actions/cut-new-patch.ts",
            "status": "added",
            "additions": 43,
            "deletions": 0,
            "changes": 43,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions%2Fcut-new-patch.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions%2Fcut-new-patch.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Factions%2Fcut-new-patch.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,43 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {ActiveReleaseTrains} from '../../versioning/active-release-trains';\n+import {semverInc} from '../../versioning/inc-semver';\n+import {ReleaseAction} from '../actions';\n+\n+/**\n+ * Release action that cuts a new patch release for the current latest release-train version\n+ * branch (i.e. the patch branch). The patch segment is incremented. The changelog is generated\n+ * for the new patch version, but also needs to be cherry-picked into the next development branch.\n+ */\n+export class CutNewPatchAction extends ReleaseAction {\n+  private _newVersion = semverInc(this.active.latest.version, 'patch');\n+\n+  async getDescription() {\n+    const {branchName} = this.active.latest;\n+    const newVersion = this._newVersion;\n+    return `Cut a new patch release for the \"${branchName}\" branch (v${newVersion}).`;\n+  }\n+\n+  async perform() {\n+    const {branchName} = this.active.latest;\n+    const newVersion = this._newVersion;\n+\n+    const {id} = await this.checkoutBranchAndStageVersion(newVersion, branchName);\n+\n+    await this.waitForPullRequestToBeMerged(id);\n+    await this.buildAndPublish(newVersion, branchName, 'latest');\n+    await this.cherryPickChangelogIntoNextBranch(newVersion, branchName);\n+  }\n+\n+  static async isActive(active: ActiveReleaseTrains) {\n+    // Patch versions can be cut at any time. See:\n+    // https://hackmd.io/2Le8leq0S6G_R5VEVTNK9A#Release-prompt-options.\n+    return true;\n+  }\n+}"
        },
        {
            "sha": "40ecb20fd1c415c47f7226be4d233951d908125d",
            "filename": "dev-infra/release/publish/actions/cut-next-prerelease.ts",
            "status": "added",
            "additions": 72,
            "deletions": 0,
            "changes": 72,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions%2Fcut-next-prerelease.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions%2Fcut-next-prerelease.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Factions%2Fcut-next-prerelease.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,72 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as semver from 'semver';\n+\n+import {semverInc} from '../../versioning/inc-semver';\n+import {computeNewPrereleaseVersionForNext} from '../../versioning/next-prerelease-version';\n+import {ReleaseTrain} from '../../versioning/release-trains';\n+import {ReleaseAction} from '../actions';\n+\n+/**\n+ * Release action that cuts a prerelease for the next branch. A version in the next\n+ * branch can have an arbitrary amount of next pre-releases.\n+ */\n+export class CutNextPrereleaseAction extends ReleaseAction {\n+  /** Promise resolving with the new version if a NPM next pre-release is cut. */\n+  private _newVersion: Promise<semver.SemVer> = this._computeNewVersion();\n+\n+  async getDescription() {\n+    const {branchName} = this._getActivePrereleaseTrain();\n+    const newVersion = await this._newVersion;\n+    return `Cut a new next pre-release for the \"${branchName}\" branch (v${newVersion}).`;\n+  }\n+\n+  async perform() {\n+    const releaseTrain = this._getActivePrereleaseTrain();\n+    const {branchName} = releaseTrain;\n+    const newVersion = await this._newVersion;\n+\n+    const {id} = await this.checkoutBranchAndStageVersion(newVersion, branchName);\n+\n+    await this.waitForPullRequestToBeMerged(id);\n+    await this.buildAndPublish(newVersion, branchName, 'next');\n+\n+    // If the pre-release has been cut from a branch that is not corresponding\n+    // to the next release-train, cherry-pick the changelog into the primary\n+    // development branch. i.e. the `next` branch that is usually `master`.\n+    if (releaseTrain !== this.active.next) {\n+      await this.cherryPickChangelogIntoNextBranch(newVersion, branchName);\n+    }\n+  }\n+\n+  /** Gets the release train for which NPM next pre-releases should be cut. */\n+  private _getActivePrereleaseTrain(): ReleaseTrain {\n+    return this.active.releaseCandidate ?? this.active.next;\n+  }\n+\n+  /** Gets the new pre-release version for this release action. */\n+  private async _computeNewVersion(): Promise<semver.SemVer> {\n+    const releaseTrain = this._getActivePrereleaseTrain();\n+    // If a pre-release is cut for the next release-train, the new version is computed\n+    // with respect to special cases surfacing with FF/RC branches. Otherwise, the basic\n+    // pre-release increment of the version is used as new version.\n+    if (releaseTrain === this.active.next) {\n+      return await computeNewPrereleaseVersionForNext(this.active, this.config);\n+    } else {\n+      return semverInc(releaseTrain.version, 'prerelease');\n+    }\n+  }\n+\n+  static async isActive() {\n+    // Pre-releases for the `next` NPM dist tag can always be cut. Depending on whether\n+    // there is a feature-freeze/release-candidate branch, the next pre-releases are either\n+    // cut from such a branch, or from the actual `next` release-train branch (i.e. master).\n+    return true;\n+  }\n+}"
        },
        {
            "sha": "716446a1eef6517fc007bebf1b99eab329477944",
            "filename": "dev-infra/release/publish/actions/cut-release-candidate.ts",
            "status": "added",
            "additions": 42,
            "deletions": 0,
            "changes": 42,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions%2Fcut-release-candidate.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions%2Fcut-release-candidate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Factions%2Fcut-release-candidate.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,42 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {ActiveReleaseTrains} from '../../versioning/active-release-trains';\n+import {semverInc} from '../../versioning/inc-semver';\n+import {ReleaseAction} from '../actions';\n+\n+/**\n+ * Cuts the first release candidate for a release-train currently in the\n+ * feature-freeze phase. The version is bumped from `next` to `rc.0`.\n+ */\n+export class CutReleaseCandidateAction extends ReleaseAction {\n+  private _newVersion = semverInc(this.active.releaseCandidate!.version, 'prerelease', 'rc');\n+\n+  async getDescription() {\n+    const newVersion = this._newVersion;\n+    return `Cut a first release-candidate for the feature-freeze branch (v${newVersion}).`;\n+  }\n+\n+  async perform() {\n+    const {branchName} = this.active.releaseCandidate!;\n+    const newVersion = this._newVersion;\n+\n+    const {id} = await this.checkoutBranchAndStageVersion(newVersion, branchName);\n+\n+    await this.waitForPullRequestToBeMerged(id);\n+    await this.buildAndPublish(newVersion, branchName, 'next');\n+    await this.cherryPickChangelogIntoNextBranch(newVersion, branchName);\n+  }\n+\n+  static async isActive(active: ActiveReleaseTrains) {\n+    // A release-candidate can be cut for an active release-train currently\n+    // in the feature-freeze phase.\n+    return active.releaseCandidate !== null &&\n+        active.releaseCandidate.version.prerelease[0] === 'next';\n+  }\n+}"
        },
        {
            "sha": "dee7e88ee875eff11763201c92388e038455e884",
            "filename": "dev-infra/release/publish/actions/cut-stable.ts",
            "status": "added",
            "additions": 71,
            "deletions": 0,
            "changes": 71,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions%2Fcut-stable.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions%2Fcut-stable.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Factions%2Fcut-stable.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,71 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as semver from 'semver';\n+\n+import {ActiveReleaseTrains} from '../../versioning/active-release-trains';\n+import {getLtsNpmDistTagOfMajor} from '../../versioning/long-term-support';\n+import {ReleaseAction} from '../actions';\n+import {invokeSetNpmDistCommand, invokeYarnInstallCommand} from '../external-commands';\n+\n+/**\n+ * Release action that cuts a stable version for the current release-train in the release\n+ * candidate phase. The pre-release release-candidate version label is removed.\n+ */\n+export class CutStableAction extends ReleaseAction {\n+  private _newVersion = this._computeNewVersion();\n+\n+  async getDescription() {\n+    const newVersion = this._newVersion;\n+    return `Cut a stable release for the release-candidate branch (v${newVersion}).`;\n+  }\n+\n+  async perform() {\n+    const {branchName} = this.active.releaseCandidate!;\n+    const newVersion = this._newVersion;\n+    const isNewMajor = this.active.releaseCandidate?.isMajor;\n+\n+\n+    const {id} = await this.checkoutBranchAndStageVersion(newVersion, branchName);\n+\n+    await this.waitForPullRequestToBeMerged(id);\n+    await this.buildAndPublish(newVersion, branchName, 'latest');\n+\n+    // If a new major version is published and becomes the \"latest\" release-train, we need\n+    // to set the LTS npm dist tag for the previous latest release-train (the current patch).\n+    if (isNewMajor) {\n+      const previousPatchVersion = this.active.latest.version;\n+      const ltsTagForPatch = getLtsNpmDistTagOfMajor(previousPatchVersion.major);\n+\n+      // Instead of directly setting the NPM dist tags, we invoke the ng-dev command for\n+      // setting the NPM dist tag to the specified version. We do this because release NPM\n+      // packages could be different in the previous patch branch, and we want to set the\n+      // LTS tag for all packages part of the last major. It would not be possible to set the\n+      // NPM dist tag for new packages part of the released major, nor would it be acceptable\n+      // to skip the LTS tag for packages which are no longer part of the new major.\n+      await invokeYarnInstallCommand(this.projectDir);\n+      await invokeSetNpmDistCommand(ltsTagForPatch, previousPatchVersion);\n+    }\n+\n+    await this.cherryPickChangelogIntoNextBranch(newVersion, branchName);\n+  }\n+\n+  /** Gets the new stable version of the release candidate release-train. */\n+  private _computeNewVersion(): semver.SemVer {\n+    const {version} = this.active.releaseCandidate!;\n+    return semver.parse(`${version.major}.${version.minor}.${version.patch}`)!;\n+  }\n+\n+  static async isActive(active: ActiveReleaseTrains) {\n+    // A stable version can be cut for an active release-train currently in the\n+    // release-candidate phase. Note: It is not possible to directly release from\n+    // feature-freeze phase into a stable version.\n+    return active.releaseCandidate !== null &&\n+        active.releaseCandidate.version.prerelease[0] === 'rc';\n+  }\n+}"
        },
        {
            "sha": "85ad7ba1566cd49bd183cd7e20f6a5489dcba774",
            "filename": "dev-infra/release/publish/actions/index.ts",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Factions%2Findex.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,29 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {ReleaseActionConstructor} from '../actions';\n+\n+import {CutLongTermSupportPatchAction} from './cut-lts-patch';\n+import {CutNewPatchAction} from './cut-new-patch';\n+import {CutNextPrereleaseAction} from './cut-next-prerelease';\n+import {CutReleaseCandidateAction} from './cut-release-candidate';\n+import {CutStableAction} from './cut-stable';\n+import {MoveNextIntoFeatureFreezeAction} from './move-next-into-feature-freeze';\n+\n+/**\n+ * List of release actions supported by the release staging tool. These are sorted\n+ * by priority. Actions which are selectable are sorted based on this declaration order.\n+ */\n+export const actions: ReleaseActionConstructor[] = [\n+  CutStableAction,\n+  CutReleaseCandidateAction,\n+  CutNewPatchAction,\n+  CutNextPrereleaseAction,\n+  MoveNextIntoFeatureFreezeAction,\n+  CutLongTermSupportPatchAction,\n+];"
        },
        {
            "sha": "0ecf6322270f25d9ac17dc9d23a1752ff1f17638",
            "filename": "dev-infra/release/publish/actions/move-next-into-feature-freeze.ts",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions%2Fmove-next-into-feature-freeze.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Factions%2Fmove-next-into-feature-freeze.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Factions%2Fmove-next-into-feature-freeze.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,109 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as semver from 'semver';\n+\n+import {error, green, info, yellow} from '../../../utils/console';\n+import {ActiveReleaseTrains} from '../../versioning/active-release-trains';\n+import {computeNewPrereleaseVersionForNext} from '../../versioning/next-prerelease-version';\n+import {ReleaseAction} from '../actions';\n+import {getCommitMessageForExceptionalNextVersionBump} from '../commit-message';\n+import {packageJsonPath} from '../constants';\n+\n+/**\n+ * Release action that moves the next release-train into the feature-freeze phase. This means\n+ * that a new version branch is created from the next branch, and a new next pre-release is\n+ * cut indicating the started feature-freeze.\n+ */\n+export class MoveNextIntoFeatureFreezeAction extends ReleaseAction {\n+  private _newVersion = computeNewPrereleaseVersionForNext(this.active, this.config);\n+\n+  async getDescription() {\n+    const {branchName} = this.active.next;\n+    const newVersion = await this._newVersion;\n+    return `Move the \"${branchName}\" branch into feature-freeze phase (v${newVersion}).`;\n+  }\n+\n+  async perform() {\n+    const newVersion = await this._newVersion;\n+    const newBranch = `${newVersion.major}.${newVersion.minor}.x`;\n+\n+    // Branch-off the next branch into a feature-freeze branch.\n+    await this._createNewVersionBranchFromNext(newBranch);\n+\n+    // Stage the new version for the newly created branch, and push changes to a\n+    // fork in order to create a staging pull request. Note that we re-use the newly\n+    // created branch instead of re-fetching from the upstream.\n+    const stagingPullRequest =\n+        await this.stageVersionForBranchAndCreatePullRequest(newVersion, newBranch);\n+\n+    // Wait for the staging PR to be merged. Then build and publish the feature-freeze next\n+    // pre-release. Finally, cherry-pick the release notes into the next branch in combination\n+    // with bumping the version to the next minor too.\n+    await this.waitForPullRequestToBeMerged(stagingPullRequest.id);\n+    await this.buildAndPublish(newVersion, newBranch, 'next');\n+    await this._createNextBranchUpdatePullRequest(newVersion, newBranch);\n+  }\n+\n+  /** Creates a new version branch from the next branch. */\n+  private async _createNewVersionBranchFromNext(newBranch: string) {\n+    const {branchName: nextBranch} = this.active.next;\n+    await this.verifyPassingGithubStatus(nextBranch);\n+    await this.checkoutUpstreamBranch(nextBranch);\n+    await this.createLocalBranchFromHead(newBranch);\n+    await this.pushHeadToRemoteBranch(newBranch);\n+    info(green(`  ✓   Version branch \"${newBranch}\" created.`));\n+  }\n+\n+  /**\n+   * Creates a pull request for the next branch that bumps the version to the next\n+   * minor, and cherry-picks the changelog for the newly branched-off feature-freeze version.\n+   */\n+  private async _createNextBranchUpdatePullRequest(newVersion: semver.SemVer, newBranch: string) {\n+    const {branchName: nextBranch, version} = this.active.next;\n+    // We increase the version for the next branch to the next minor. The team can decide\n+    // later if they want next to be a major through the `Configure Next as Major` release action.\n+    const newNextVersion = semver.parse(`${version.major}.${version.minor + 1}.0-next.0`)!;\n+    const bumpCommitMessage = getCommitMessageForExceptionalNextVersionBump(newNextVersion);\n+\n+    await this.checkoutUpstreamBranch(nextBranch);\n+    await this.updateProjectVersion(newNextVersion);\n+\n+    // Create an individual commit for the next version bump. The changelog should go into\n+    // a separate commit that makes it clear where the changelog is cherry-picked from.\n+    await this.createCommit(bumpCommitMessage, [packageJsonPath]);\n+\n+    let nextPullRequestMessage = `The previous \"next\" release-train has moved into the ` +\n+        `release-candidate phase. This PR updates the next branch to the subsequent ` +\n+        `release-train.`;\n+    const hasChangelogCherryPicked =\n+        await this.createCherryPickReleaseNotesCommitFrom(newVersion, newBranch);\n+\n+    if (hasChangelogCherryPicked) {\n+      nextPullRequestMessage += `\\n\\nAlso this PR cherry-picks the changelog for ` +\n+          `v${newVersion} into the ${nextBranch} branch so that the changelog is up to date.`;\n+    } else {\n+      error(yellow(`  ✘   Could not cherry-pick release notes for v${newVersion}.`));\n+      error(yellow(`      Please copy the release note manually into \"${nextBranch}\".`));\n+    }\n+\n+    const nextUpdatePullRequest = await this.pushChangesToForkAndCreatePullRequest(\n+        nextBranch, `next-release-train-${newNextVersion}`,\n+        `Update next branch to reflect new release-train \"v${newNextVersion}\".`,\n+        nextPullRequestMessage);\n+\n+    info(green(`  ✓   Pull request for updating the \"${nextBranch}\" branch has been created.`));\n+    info(yellow(`      Please ask team members to review: ${nextUpdatePullRequest.url}.`));\n+  }\n+\n+  static async isActive(active: ActiveReleaseTrains) {\n+    // A new feature-freeze/release-candidate branch can only be created if there\n+    // is no active release-train in feature-freeze/release-candidate phase.\n+    return active.releaseCandidate === null;\n+  }\n+}"
        },
        {
            "sha": "5a61dd807255966e49c1a38375b826027f8eac8f",
            "filename": "dev-infra/release/publish/cli.ts",
            "status": "added",
            "additions": 56,
            "deletions": 0,
            "changes": 56,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Fcli.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Fcli.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Fcli.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,56 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {Arguments, Argv, CommandModule} from 'yargs';\n+\n+import {getConfig, getRepoBaseDir} from '../../utils/config';\n+import {error, green, info, red, yellow} from '../../utils/console';\n+import {addGithubTokenOption} from '../../utils/git/github-yargs';\n+import {getReleaseConfig} from '../config';\n+\n+import {CompletionState, ReleaseTool} from './index';\n+\n+/** Command line options for publishing a release. */\n+export interface ReleasePublishOptions {\n+  githubToken: string;\n+}\n+\n+/** Yargs command builder for configuring the `ng-dev release publish` command. */\n+function builder(argv: Argv): Argv<ReleasePublishOptions> {\n+  return addGithubTokenOption(argv);\n+}\n+\n+/** Yargs command handler for staging a release. */\n+async function handler(args: Arguments<ReleasePublishOptions>) {\n+  const config = getConfig();\n+  const releaseConfig = getReleaseConfig(config);\n+  const projectDir = getRepoBaseDir();\n+  const task = new ReleaseTool(releaseConfig, config.github, args.githubToken, projectDir);\n+  const result = await task.run();\n+\n+  switch (result) {\n+    case CompletionState.FATAL_ERROR:\n+      error(red(`Release action has been aborted due to fatal errors. See above.`));\n+      process.exitCode = 1;\n+      break;\n+    case CompletionState.MANUALLY_ABORTED:\n+      info(yellow(`Release action has been manually aborted.`));\n+      break;\n+    case CompletionState.SUCCESS:\n+      info(green(`Release action has completed successfully.`));\n+      break;\n+  }\n+}\n+\n+/** CLI command module for publishing a release. */\n+export const ReleasePublishCommandModule: CommandModule<{}, ReleasePublishOptions> = {\n+  builder,\n+  handler,\n+  command: 'publish',\n+  describe: 'Publish new releases and configure version branches.',\n+};"
        },
        {
            "sha": "a4bc73aa2c3cb66c3df23de10595ce3b7ffe2b10",
            "filename": "dev-infra/release/publish/commit-message.ts",
            "status": "added",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Fcommit-message.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Fcommit-message.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Fcommit-message.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,39 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as semver from 'semver';\n+\n+/** Gets the commit message for a new release point in the project. */\n+export function getCommitMessageForRelease(newVersion: semver.SemVer): string {\n+  return `release: cut the v${newVersion} release`;\n+}\n+\n+/**\n+ * Gets the commit message for an exceptional version bump in the next branch. The next\n+ * branch version will be bumped without the release being published in some situations.\n+ * More details can be found in the `MoveNextIntoFeatureFreeze` release action and in:\n+ * https://hackmd.io/2Le8leq0S6G_R5VEVTNK9A.\n+ */\n+export function getCommitMessageForExceptionalNextVersionBump(newVersion: semver.SemVer) {\n+  return `release: bump the next branch to v${newVersion}`;\n+}\n+\n+/**\n+ * Gets the commit message for a version update in the next branch to a major version. The next\n+ * branch version will be updated without the release being published if the branch is configured\n+ * as a major. More details can be found in the `ConfigureNextAsMajor` release action and in:\n+ * https://hackmd.io/2Le8leq0S6G_R5VEVTNK9A.\n+ */\n+export function getCommitMessageForNextBranchMajorSwitch(newVersion: semver.SemVer) {\n+  return `release: switch the next branch to v${newVersion}`;\n+}\n+\n+/** Gets the commit message for a release notes cherry-pick commit */\n+export function getReleaseNoteCherryPickCommitMessage(newVersion: semver.SemVer): string {\n+  return `docs: release notes for the v${newVersion} release`;\n+}"
        },
        {
            "sha": "f108f0abf174332b51ca763895656ab4ad0b4c1a",
            "filename": "dev-infra/release/publish/constants.ts",
            "status": "added",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Fconstants.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Fconstants.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Fconstants.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,16 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+/** Project-relative path for the changelog file. */\n+export const changelogPath = 'CHANGELOG.md';\n+\n+/** Project-relative path for the \"package.json\" file. */\n+export const packageJsonPath = 'package.json';\n+\n+/** Default interval in milliseconds to check whether a pull request has been merged. */\n+export const waitForPullRequestInterval = 10000;"
        },
        {
            "sha": "ac5152bae31e7381b646f5348f3de34d8da98e28",
            "filename": "dev-infra/release/publish/external-commands.ts",
            "status": "added",
            "additions": 92,
            "deletions": 0,
            "changes": 92,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Fexternal-commands.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Fexternal-commands.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Fexternal-commands.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,92 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as Ora from 'ora';\n+import * as semver from 'semver';\n+\n+import {spawnWithDebugOutput} from '../../utils/child-process';\n+import {error, green, info, red} from '../../utils/console';\n+import {BuiltPackage} from '../config/index';\n+\n+import {FatalReleaseActionError} from './actions-error';\n+\n+/*\n+ * ###############################################################\n+ *\n+ * This file contains helpers for invoking external `ng-dev` commands. A subset of actions,\n+ * like building release output or setting a NPM dist tag for release packages, cannot be\n+ * performed directly as part of the release tool and need to be delegated to external `ng-dev`\n+ * commands that exist across arbitrary version branches.\n+ *\n+ * In an concrete example: Consider a new patch version is released and that a new release\n+ * package has been added to the `next` branch. The patch branch will not contain the new\n+ * release package, so we could not build the release output for it. To work around this, we\n+ * call the ng-dev build command for the patch version branch and expect it to return a list\n+ * of built packages that need to be released as part of this release train.\n+ *\n+ * ###############################################################\n+ */\n+\n+/**\n+ * Invokes the `ng-dev release set-dist-tag` command in order to set the specified\n+ * NPM dist tag for all packages in the checked out branch to the given version.\n+ */\n+export async function invokeSetNpmDistCommand(npmDistTag: string, version: semver.SemVer) {\n+  try {\n+    // Note: No progress indicator needed as that is the responsibility of the command.\n+    await spawnWithDebugOutput(\n+        'yarn', ['--silent', 'ng-dev', 'release', 'set-dist-tag', npmDistTag, version.format()]);\n+    info(green(`  ✓   Set \"${npmDistTag}\" NPM dist tag for all packages to v${version}.`));\n+  } catch (e) {\n+    error(e);\n+    error(red(`  ✘   An error occurred while setting the NPM dist tag for ${npmDistTag}.`));\n+    throw new FatalReleaseActionError();\n+  }\n+}\n+\n+/**\n+ * Invokes the `ng-dev release build` command in order to build the release\n+ * packages for the currently checked out branch.\n+ */\n+export async function invokeReleaseBuildCommand(): Promise<BuiltPackage[]> {\n+  const spinner = Ora().start('Building release output.');\n+  try {\n+    // Since we expect JSON to be printed from the `ng-dev release build` command,\n+    // we spawn the process in silent mode. We have set up an Ora progress spinner.\n+    const {stdout} = await spawnWithDebugOutput(\n+        'yarn', ['--silent', 'ng-dev', 'release', 'build', '--json'], {mode: 'silent'});\n+    spinner.stop();\n+    info(green(`  ✓   Built release output for all packages.`));\n+    // The `ng-dev release build` command prints a JSON array to stdout\n+    // that represents the built release packages and their output paths.\n+    return JSON.parse(stdout.trim());\n+  } catch (e) {\n+    spinner.stop();\n+    error(e);\n+    error(red(`  ✘   An error occurred while building the release packages.`));\n+    throw new FatalReleaseActionError();\n+  }\n+}\n+\n+/**\n+ * Invokes the `yarn install` command in order to install dependencies for\n+ * the configured project with the currently checked out revision.\n+ */\n+export async function invokeYarnInstallCommand(projectDir: string): Promise<void> {\n+  try {\n+    // Note: No progress indicator needed as that is the responsibility of the command.\n+    // TODO: Consider using an Ora spinner instead to ensure minimal console output.\n+    await spawnWithDebugOutput(\n+        'yarn', ['install', '--frozen-lockfile', '--non-interactive'], {cwd: projectDir});\n+    info(green(`  ✓   Installed project dependencies.`));\n+  } catch (e) {\n+    error(e);\n+    error(red(`  ✘   An error occurred while installing dependencies.`));\n+    throw new FatalReleaseActionError();\n+  }\n+}"
        },
        {
            "sha": "63679d7a77bd5aef2cf5fc9f7521fd75c5e708da",
            "filename": "dev-infra/release/publish/graphql-queries.ts",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Fgraphql-queries.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Fgraphql-queries.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Fgraphql-queries.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,31 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {params, types} from 'typed-graphqlify';\n+\n+/**\n+ * Graphql Github API query that can be used to find forks of a given repository\n+ * that are owned by the current viewer authenticated with the Github API.\n+ */\n+export const findOwnedForksOfRepoQuery = params(\n+    {\n+      $owner: 'String!',\n+      $name: 'String!',\n+    },\n+    {\n+      repository: params({owner: '$owner', name: '$name'}, {\n+        forks: params({affiliations: 'OWNER', first: 1}, {\n+          nodes: [{\n+            owner: {\n+              login: types.string,\n+            },\n+            name: types.string,\n+          }],\n+        }),\n+      }),\n+    });"
        },
        {
            "sha": "5759ce1e5830b229f01bd365233330a231202828",
            "filename": "dev-infra/release/publish/index.ts",
            "status": "added",
            "additions": 135,
            "deletions": 0,
            "changes": 135,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Findex.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,135 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {ListChoiceOptions, prompt} from 'inquirer';\n+\n+import {GithubConfig} from '../../utils/config';\n+import {error, info, log, red, yellow} from '../../utils/console';\n+import {GitClient} from '../../utils/git/index';\n+import {ReleaseConfig} from '../config';\n+import {ActiveReleaseTrains, fetchActiveReleaseTrains, nextBranchName} from '../versioning/active-release-trains';\n+import {printActiveReleaseTrains} from '../versioning/print-active-trains';\n+import {GithubRepoWithApi} from '../versioning/version-branches';\n+\n+import {ReleaseAction} from './actions';\n+import {FatalReleaseActionError, UserAbortedReleaseActionError} from './actions-error';\n+import {actions} from './actions/index';\n+\n+export enum CompletionState {\n+  SUCCESS,\n+  FATAL_ERROR,\n+  MANUALLY_ABORTED,\n+}\n+\n+export class ReleaseTool {\n+  /** Client for interacting with the Github API and the local Git command. */\n+  private _git = new GitClient(this._githubToken, {github: this._github}, this._projectRoot);\n+\n+  constructor(\n+      protected _config: ReleaseConfig, protected _github: GithubConfig,\n+      protected _githubToken: string, protected _projectRoot: string) {}\n+\n+  /** Runs the interactive release tool. */\n+  async run(): Promise<CompletionState> {\n+    log();\n+    log(yellow('--------------------------------------------'));\n+    log(yellow('  Angular Dev-Infra release staging script'));\n+    log(yellow('--------------------------------------------'));\n+    log();\n+\n+    if (!await this._verifyNoUncommittedChanges() || !await this._verifyRunningFromNextBranch()) {\n+      return CompletionState.FATAL_ERROR;\n+    }\n+\n+    const {owner, name} = this._github;\n+    const repo: GithubRepoWithApi = {owner, name, api: this._git.github};\n+    const releaseTrains = await fetchActiveReleaseTrains(repo);\n+\n+    // Print the active release trains so that the caretaker can access\n+    // the current project branching state without switching context.\n+    await printActiveReleaseTrains(releaseTrains, this._config);\n+\n+    const action = await this._promptForReleaseAction(releaseTrains);\n+    const previousGitBranchOrRevision = this._git.getCurrentBranchOrRevision();\n+\n+    try {\n+      await action.perform();\n+    } catch (e) {\n+      if (e instanceof UserAbortedReleaseActionError) {\n+        return CompletionState.MANUALLY_ABORTED;\n+      }\n+      // Only print the error message and stack if the error is not a known fatal release\n+      // action error (for which we print the error gracefully to the console with colors).\n+      if (!(e instanceof FatalReleaseActionError) && e instanceof Error) {\n+        console.error(e.message);\n+        console.error(e.stack);\n+      }\n+      return CompletionState.FATAL_ERROR;\n+    } finally {\n+      this._git.checkout(previousGitBranchOrRevision, true);\n+    }\n+\n+    return CompletionState.SUCCESS;\n+  }\n+\n+  /** Prompts the caretaker for a release action that should be performed. */\n+  private async _promptForReleaseAction(activeTrains: ActiveReleaseTrains) {\n+    const choices: ListChoiceOptions[] = [];\n+\n+    // Find and instantiate all release actions which are currently valid.\n+    for (let actionType of actions) {\n+      if (await actionType.isActive(activeTrains)) {\n+        const action: ReleaseAction =\n+            new actionType(activeTrains, this._git, this._config, this._projectRoot);\n+        choices.push({name: await action.getDescription(), value: action});\n+      }\n+    }\n+\n+    info(`Please select the type of release you want to perform.`);\n+\n+    const {releaseAction} = await prompt<{releaseAction: ReleaseAction}>({\n+      name: 'releaseAction',\n+      message: 'Please select an action:',\n+      type: 'list',\n+      choices,\n+    });\n+\n+    return releaseAction;\n+  }\n+\n+  /**\n+   * Verifies that there are no uncommitted changes in the project.\n+   * @returns a boolean indicating success or failure.\n+   */\n+  private async _verifyNoUncommittedChanges(): Promise<boolean> {\n+    if (this._git.hasUncommittedChanges()) {\n+      error(\n+          red(`  ✘   There are changes which are not committed and should be ` +\n+              `discarded.`));\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Verifies that the next branch from the configured repository is checked out.\n+   * @returns a boolean indicating success or failure.\n+   */\n+  private async _verifyRunningFromNextBranch(): Promise<boolean> {\n+    const headSha = this._git.run(['rev-parse', 'HEAD']).stdout.trim();\n+    const {data} =\n+        await this._git.github.repos.getBranch({...this._git.remoteParams, branch: nextBranchName});\n+\n+    if (headSha !== data.commit.sha) {\n+      error(red(`  ✘   Running release tool from an outdated local branch.`));\n+      error(red(`      Please make sure you are running from the \"${nextBranchName}\" branch.`));\n+      return false;\n+    }\n+    return true;\n+  }\n+}"
        },
        {
            "sha": "cd750ff67216fad502fe3d155a6333e1c72df424",
            "filename": "dev-infra/release/publish/pull-request-state.ts",
            "status": "added",
            "additions": 72,
            "deletions": 0,
            "changes": 72,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Fpull-request-state.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Fpull-request-state.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Fpull-request-state.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,72 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as Octokit from '@octokit/rest';\n+import {GitClient} from '../../utils/git/index';\n+\n+/** State of a pull request in Github. */\n+export type PullRequestState = 'merged'|'closed'|'open';\n+\n+/** Gets whether a given pull request has been merged. */\n+export async function getPullRequestState(api: GitClient, id: number): Promise<PullRequestState> {\n+  const {data} = await api.github.pulls.get({...api.remoteParams, pull_number: id});\n+  if (data.merged) {\n+    return 'merged';\n+  } else if (data.closed_at !== null) {\n+    return await isPullRequestClosedWithAssociatedCommit(api, id) ? 'merged' : 'closed';\n+  } else {\n+    return 'open';\n+  }\n+}\n+\n+/**\n+ * Whether the pull request has been closed with an associated commit. This is usually\n+ * the case if a PR has been merged using the autosquash merge script strategy. Since\n+ * the merge is not fast-forward, Github does not consider the PR as merged and instead\n+ * shows the PR as closed. See for example: https://github.com/angular/angular/pull/37918.\n+ */\n+async function isPullRequestClosedWithAssociatedCommit(api: GitClient, id: number) {\n+  const request =\n+      api.github.issues.listEvents.endpoint.merge({...api.remoteParams, issue_number: id});\n+  const events: Octokit.IssuesListEventsResponse = await api.github.paginate(request);\n+  // Iterate through the events of the pull request in reverse. We want to find the most\n+  // recent events and check if the PR has been closed with a commit associated with it.\n+  // If the PR has been closed through a commit, we assume that the PR has been merged\n+  // using the autosquash merge strategy. For more details. See the `AutosquashMergeStrategy`.\n+  for (let i = events.length - 1; i >= 0; i--) {\n+    const {event, commit_id} = events[i];\n+    // If we come across a \"reopened\" event, we abort looking for referenced commits. Any\n+    // commits that closed the PR before, are no longer relevant and did not close the PR.\n+    if (event === 'reopened') {\n+      return false;\n+    }\n+    // If a `closed` event is captured with a commit assigned, then we assume that\n+    // this PR has been merged properly.\n+    if (event === 'closed' && commit_id) {\n+      return true;\n+    }\n+    // If the PR has been referenced by a commit, check if the commit closes this pull\n+    // request. Note that this is needed besides checking `closed` as PRs could be merged\n+    // into any non-default branch where the `Closes <..>` keyword does not work and the PR\n+    // is simply closed without an associated `commit_id`. For more details see:\n+    // https://docs.github.com/en/enterprise/2.16/user/github/managing-your-work-on-github/closing-issues-using-keywords#:~:text=non-default.\n+    if (event === 'referenced' && commit_id &&\n+        await isCommitClosingPullRequest(api, commit_id, id)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+/** Checks whether the specified commit is closing the given pull request. */\n+async function isCommitClosingPullRequest(api: GitClient, sha: string, id: number) {\n+  const {data} = await api.github.repos.getCommit({...api.remoteParams, ref: sha});\n+  // Matches the closing keyword supported in commit messages. See:\n+  // https://docs.github.com/en/enterprise/2.16/user/github/managing-your-work-on-github/closing-issues-using-keywords.\n+  return data.commit.message.match(new RegExp(`close[sd]? #${id}[^0-9]?`, 'i'));\n+}"
        },
        {
            "sha": "c48d17a554f41221bb6c5669c1c2340545190547",
            "filename": "dev-infra/release/publish/release-notes.ts",
            "status": "added",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Frelease-notes.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Frelease-notes.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Frelease-notes.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,27 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {join} from 'path';\n+import * as semver from 'semver';\n+import {changelogPath} from './constants';\n+\n+/**\n+ * Gets the default pattern for extracting release notes for the given version.\n+ * This pattern matches for the conventional-changelog Angular preset.\n+ */\n+export function getDefaultExtractReleaseNotesPattern(version: semver.SemVer): RegExp {\n+  const escapedVersion = version.format().replace('.', '\\\\.');\n+  // TODO: Change this once we have a canonical changelog generation tool. Also update this\n+  // based on the conventional-changelog version. They removed anchors in more recent versions.\n+  return new RegExp(`(<a name=\"${escapedVersion}\"></a>.*?)(?:<a name=\"|$)`, 's');\n+}\n+\n+/** Gets the path for the changelog file in a given project. */\n+export function getLocalChangelogFilePath(projectDir: string): string {\n+  return join(projectDir, changelogPath);\n+}"
        },
        {
            "sha": "6b664ccec5de64f6185f18892952f31261b3f16e",
            "filename": "dev-infra/release/publish/test/BUILD.bazel",
            "status": "added",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Ftest%2FBUILD.bazel?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,36 @@\n+load(\"@npm_bazel_typescript//:index.bzl\", \"ts_library\")\n+load(\"//tools:defaults.bzl\", \"jasmine_node_test\")\n+\n+ts_library(\n+    name = \"test_lib\",\n+    srcs = glob([\n+        \"**/*.ts\",\n+    ]),\n+    module_name = \"@angular/dev-infra-private/release/test\",\n+    deps = [\n+        \"//dev-infra/release/config\",\n+        \"//dev-infra/release/publish\",\n+        \"//dev-infra/release/versioning\",\n+        \"//dev-infra/utils\",\n+        \"//dev-infra/utils/testing\",\n+        \"@npm//@types/jasmine\",\n+        \"@npm//@types/minimist\",\n+        \"@npm//@types/node\",\n+        \"@npm//@types/node-fetch\",\n+        \"@npm//@types/semver\",\n+        \"@npm//minimist\",\n+        \"@npm//nock\",\n+        \"@npm//node-fetch\",\n+        \"@npm//semver\",\n+    ],\n+)\n+\n+jasmine_node_test(\n+    name = \"test\",\n+    # Disable the Bazel patched module resolution. It always loads \".mjs\" files first. This\n+    # breaks NodeJS execution for \"node-fetch\" as it uses experimental modules which are not\n+    # enabled in NodeJS. TODO: Remove this with rules_nodejs 3.x where patching is optional.\n+    # https://github.com/bazelbuild/rules_nodejs/commit/7d070ffadf9c3b41711382a4737b995f987c14fa.\n+    args = [\"--nobazel_patch_module_resolver\"],\n+    deps = [\":test_lib\"],\n+)"
        },
        {
            "sha": "ac2aeebccff8704221cf68cc0623912b27f916e5",
            "filename": "dev-infra/release/publish/test/common.spec.ts",
            "status": "added",
            "additions": 211,
            "deletions": 0,
            "changes": 211,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Fcommon.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Fcommon.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Ftest%2Fcommon.spec.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,211 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {readFileSync} from 'fs';\n+import {join} from 'path';\n+import * as semver from 'semver';\n+\n+import {getBranchPushMatcher} from '../../../utils/testing';\n+import {ActiveReleaseTrains} from '../../versioning/active-release-trains';\n+import * as npm from '../../versioning/npm-publish';\n+import {ReleaseTrain} from '../../versioning/release-trains';\n+import {ReleaseAction} from '../actions';\n+import {actions} from '../actions/index';\n+import {changelogPath} from '../constants';\n+\n+import {getChangelogForVersion, getTestingMocksForReleaseAction, parse, setupReleaseActionForTesting, testTmpDir} from './test-utils';\n+\n+describe('common release action logic', () => {\n+  const baseReleaseTrains: ActiveReleaseTrains = {\n+    releaseCandidate: null,\n+    next: new ReleaseTrain('master', parse('10.1.0-next.0')),\n+    latest: new ReleaseTrain('10.0.x', parse('10.0.1')),\n+  };\n+\n+  describe('version computation', async () => {\n+    const testReleaseTrain: ActiveReleaseTrains = {\n+      releaseCandidate: new ReleaseTrain('10.1.x', parse('10.1.0-next.3')),\n+      next: new ReleaseTrain('master', parse('10.2.0-next.0')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.1')),\n+    };\n+\n+    it('should not modify release train versions and cause invalid other actions', async () => {\n+      const {releaseConfig, gitClient} = getTestingMocksForReleaseAction();\n+      const descriptions: string[] = [];\n+\n+      for (const actionCtor of actions) {\n+        if (await actionCtor.isActive(testReleaseTrain)) {\n+          const action = new actionCtor(testReleaseTrain, gitClient, releaseConfig, testTmpDir);\n+          descriptions.push(await action.getDescription());\n+        }\n+      }\n+\n+      expect(descriptions).toEqual([\n+        `Cut a first release-candidate for the feature-freeze branch (v10.1.0-rc.0).`,\n+        `Cut a new patch release for the \"10.0.x\" branch (v10.0.2).`,\n+        `Cut a new next pre-release for the \"10.1.x\" branch (v10.1.0-next.4).`,\n+        `Cut a new release for an active LTS branch (0 active).`\n+      ]);\n+    });\n+  });\n+\n+  describe('build and publishing', () => {\n+    it('should support a custom NPM registry', async () => {\n+      const {repo, instance, releaseConfig} =\n+          setupReleaseActionForTesting(TestAction, baseReleaseTrains);\n+      const {version, branchName} = baseReleaseTrains.next;\n+      const tagName = version.format();\n+      const customRegistryUrl = 'https://custom-npm-registry.google.com';\n+\n+      repo.expectBranchRequest(branchName, 'STAGING_SHA')\n+          .expectCommitRequest('STAGING_SHA', `release: cut the v${version} release`)\n+          .expectTagToBeCreated(tagName, 'STAGING_SHA')\n+          .expectReleaseToBeCreated(`v${version}`, tagName);\n+\n+      // Set up a custom NPM registry.\n+      releaseConfig.publishRegistry = customRegistryUrl;\n+\n+      await instance.testBuildAndPublish(version, branchName, 'latest');\n+\n+      expect(npm.runNpmPublish).toHaveBeenCalledTimes(2);\n+      expect(npm.runNpmPublish)\n+          .toHaveBeenCalledWith(`${testTmpDir}/dist/pkg1`, 'latest', customRegistryUrl);\n+      expect(npm.runNpmPublish)\n+          .toHaveBeenCalledWith(`${testTmpDir}/dist/pkg2`, 'latest', customRegistryUrl);\n+    });\n+  });\n+\n+  describe('changelog cherry-picking', () => {\n+    const {version, branchName} = baseReleaseTrains.latest;\n+    const fakeReleaseNotes = getChangelogForVersion(version.format());\n+    const forkBranchName = `changelog-cherry-pick-${version}`;\n+\n+    it('should prepend fetched changelog', async () => {\n+      const {repo, fork, instance, testTmpDir} =\n+          setupReleaseActionForTesting(TestAction, baseReleaseTrains);\n+\n+      // Expect the changelog to be fetched and return a fake changelog to test that\n+      // it is properly appended. Also expect a pull request to be created in the fork.\n+      repo.expectChangelogFetch(branchName, fakeReleaseNotes)\n+          .expectFindForkRequest(fork)\n+          .expectPullRequestToBeCreated('master', fork, forkBranchName, 200);\n+\n+      // Simulate that the fork branch name is available.\n+      fork.expectBranchRequest(forkBranchName, null);\n+\n+      await instance.testCherryPickWithPullRequest(version, branchName);\n+\n+      const changelogContent = readFileSync(join(testTmpDir, changelogPath), 'utf8');\n+      expect(changelogContent).toEqual(`${fakeReleaseNotes}Existing changelog`);\n+    });\n+\n+    it('should respect a custom release note extraction pattern', async () => {\n+      const {repo, fork, instance, testTmpDir, releaseConfig} =\n+          setupReleaseActionForTesting(TestAction, baseReleaseTrains);\n+\n+      // Custom pattern matching changelog output sections grouped through\n+      // basic level-1 markdown headers (compared to the default anchor pattern).\n+      releaseConfig.extractReleaseNotesPattern = version =>\n+          new RegExp(`(# v${version} \\\\(\"[^\"]+\"\\\\).*?)(?:# v|$)`, 's');\n+\n+      const customReleaseNotes = `# v${version} (\"newton-kepler\")\\n\\nNew Content!`;\n+\n+      // Expect the changelog to be fetched and return a fake changelog to test that\n+      // it is properly appended. Also expect a pull request to be created in the fork.\n+      repo.expectChangelogFetch(branchName, customReleaseNotes)\n+          .expectFindForkRequest(fork)\n+          .expectPullRequestToBeCreated('master', fork, forkBranchName, 200);\n+\n+      // Simulate that the fork branch name is available.\n+      fork.expectBranchRequest(forkBranchName, null);\n+\n+      await instance.testCherryPickWithPullRequest(version, branchName);\n+\n+      const changelogContent = readFileSync(join(testTmpDir, changelogPath), 'utf8');\n+      expect(changelogContent).toEqual(`${customReleaseNotes}\\n\\nExisting changelog`);\n+    });\n+\n+    it('should print an error if release notes cannot be extracted', async () => {\n+      const {repo, fork, instance, testTmpDir, releaseConfig} =\n+          setupReleaseActionForTesting(TestAction, baseReleaseTrains);\n+\n+      // Expect the changelog to be fetched and return a fake changelog to test that\n+      // it is properly appended. Also expect a pull request to be created in the fork.\n+      repo.expectChangelogFetch(branchName, `non analyzable changelog`)\n+          .expectFindForkRequest(fork)\n+          .expectPullRequestToBeCreated('master', fork, forkBranchName, 200);\n+\n+      // Simulate that the fork branch name is available.\n+      fork.expectBranchRequest(forkBranchName, null);\n+\n+      spyOn(console, 'error');\n+\n+      await instance.testCherryPickWithPullRequest(version, branchName);\n+\n+      expect(console.error)\n+          .toHaveBeenCalledWith(\n+              jasmine.stringMatching(`Could not cherry-pick release notes for v${version}`));\n+      expect(console.error)\n+          .toHaveBeenCalledWith(jasmine.stringMatching(\n+              `Please copy the release notes manually into the \"master\" branch.`));\n+\n+      const changelogContent = readFileSync(join(testTmpDir, changelogPath), 'utf8');\n+      expect(changelogContent).toEqual(`Existing changelog`);\n+    });\n+\n+    it('should push changes to a fork for creating a pull request', async () => {\n+      const {repo, fork, instance, gitClient} =\n+          setupReleaseActionForTesting(TestAction, baseReleaseTrains);\n+\n+      // Expect the changelog to be fetched and return a fake changelog to test that\n+      // it is properly appended. Also expect a pull request to be created in the fork.\n+      repo.expectChangelogFetch(branchName, fakeReleaseNotes)\n+          .expectFindForkRequest(fork)\n+          .expectPullRequestToBeCreated('master', fork, forkBranchName, 200);\n+\n+      // Simulate that the fork branch name is available.\n+      fork.expectBranchRequest(forkBranchName, null);\n+\n+      await instance.testCherryPickWithPullRequest(version, branchName);\n+\n+      expect(gitClient.pushed.length).toBe(1);\n+      expect(gitClient.pushed[0]).toEqual(getBranchPushMatcher({\n+        targetBranch: forkBranchName,\n+        targetRepo: fork,\n+        baseBranch: 'master',\n+        baseRepo: repo,\n+        expectedCommits: [{\n+          message: `docs: release notes for the v${version} release`,\n+          files: ['CHANGELOG.md'],\n+        }],\n+      }));\n+    });\n+  });\n+});\n+\n+/**\n+ * Test release action that exposes protected units of the base\n+ * release action class. This allows us to add unit tests.\n+ */\n+class TestAction extends ReleaseAction {\n+  async getDescription() {\n+    return 'Test action';\n+  }\n+\n+  async perform() {\n+    throw Error('Not implemented.');\n+  }\n+\n+  async testBuildAndPublish(newVersion: semver.SemVer, publishBranch: string, distTag: string) {\n+    await this.buildAndPublish(newVersion, publishBranch, distTag);\n+  }\n+\n+  async testCherryPickWithPullRequest(version: semver.SemVer, branch: string) {\n+    await this.cherryPickChangelogIntoNextBranch(version, branch);\n+  }\n+}"
        },
        {
            "sha": "10fb3b5639b735fb3ea9d7930acab95170bea161",
            "filename": "dev-infra/release/publish/test/configure-next-as-major.spec.ts",
            "status": "added",
            "additions": 79,
            "deletions": 0,
            "changes": 79,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Fconfigure-next-as-major.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Fconfigure-next-as-major.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Ftest%2Fconfigure-next-as-major.spec.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,79 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {getBranchPushMatcher} from '../../../utils/testing';\n+import {ReleaseTrain} from '../../versioning/release-trains';\n+import {ConfigureNextAsMajorAction} from '../actions/configure-next-as-major';\n+\n+import {parse, setupReleaseActionForTesting} from './test-utils';\n+\n+describe('configure next as major action', () => {\n+  it('should be active if the next branch is for a minor', async () => {\n+    expect(await ConfigureNextAsMajorAction.isActive({\n+      releaseCandidate: null,\n+      next: new ReleaseTrain('master', parse('10.1.0-next.3')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    })).toBe(true);\n+  });\n+\n+  it('should be active regardless of a feature-freeze/release-candidate train', async () => {\n+    expect(await ConfigureNextAsMajorAction.isActive({\n+      releaseCandidate: new ReleaseTrain('10.1.x', parse('10.1.0-rc.1')),\n+      next: new ReleaseTrain('master', parse('10.2.0-next.3')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    })).toBe(true);\n+  });\n+\n+  it('should not be active if the next branch is for a major', async () => {\n+    expect(await ConfigureNextAsMajorAction.isActive({\n+      releaseCandidate: null,\n+      next: new ReleaseTrain('master', parse('11.0.0-next.0')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    })).toBe(false);\n+  });\n+\n+  it('should compute proper version and create staging pull request', async () => {\n+    const action = setupReleaseActionForTesting(ConfigureNextAsMajorAction, {\n+      releaseCandidate: null,\n+      next: new ReleaseTrain('master', parse('10.1.0-next.3')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.2')),\n+    });\n+\n+    const {repo, fork, gitClient} = action;\n+    const expectedVersion = `11.0.0-next.0`;\n+    const expectedForkBranch = `switch-next-to-major-${expectedVersion}`;\n+\n+    // We first mock the commit status check for the next branch, then expect two pull\n+    // requests from a fork that are targeting next and the new feature-freeze branch.\n+    repo.expectBranchRequest('master', 'MASTER_COMMIT_SHA')\n+        .expectCommitStatusCheck('MASTER_COMMIT_SHA', 'success')\n+        .expectFindForkRequest(fork)\n+        .expectPullRequestToBeCreated('master', fork, expectedForkBranch, 200);\n+\n+    // In the fork, we make the staging branch appear as non-existent,\n+    // so that the PR can be created properly without collisions.\n+    fork.expectBranchRequest(expectedForkBranch, null);\n+\n+    await action.instance.perform();\n+\n+    expect(gitClient.pushed.length).toBe(1);\n+    expect(gitClient.pushed[0])\n+        .toEqual(\n+            getBranchPushMatcher({\n+              baseBranch: 'master',\n+              baseRepo: repo,\n+              targetBranch: expectedForkBranch,\n+              targetRepo: fork,\n+              expectedCommits: [{\n+                message: `release: switch the next branch to v${expectedVersion}`,\n+                files: ['package.json'],\n+              }],\n+            }),\n+            'Expected the update branch to be created in fork for a pull request.');\n+  });\n+});"
        },
        {
            "sha": "8535de355bbd67e1e89ec2857a736b25d35f36d5",
            "filename": "dev-infra/release/publish/test/cut-lts-patch.spec.ts",
            "status": "added",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Fcut-lts-patch.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Fcut-lts-patch.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Ftest%2Fcut-lts-patch.spec.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,110 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {matchesVersion} from '../../../utils/testing/semver-matchers';\n+import {fetchLongTermSupportBranchesFromNpm} from '../../versioning/long-term-support';\n+import {ReleaseTrain} from '../../versioning/release-trains';\n+import {CutLongTermSupportPatchAction} from '../actions/cut-lts-patch';\n+\n+import {expectStagingAndPublishWithCherryPick, fakeNpmPackageQueryRequest, getTestingMocksForReleaseAction, parse, setupReleaseActionForTesting, testTmpDir} from './test-utils';\n+\n+describe('cut a LTS patch action', () => {\n+  it('should be active', async () => {\n+    expect(await CutLongTermSupportPatchAction.isActive({\n+      releaseCandidate: null,\n+      next: new ReleaseTrain('master', parse('10.1.0-next.3')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    })).toBe(true);\n+  });\n+\n+  it('should be active if there is a feature-freeze train', async () => {\n+    expect(await CutLongTermSupportPatchAction.isActive({\n+      releaseCandidate: new ReleaseTrain('10.1.x', parse('10.1.0-next.3')),\n+      next: new ReleaseTrain('master', parse('10.2.0-next.3')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    })).toBe(true);\n+  });\n+\n+  it('should be active if there is a release-candidate train', async () => {\n+    expect(await CutLongTermSupportPatchAction.isActive({\n+      releaseCandidate: new ReleaseTrain('10.1.x', parse('10.1.0-rc.0')),\n+      next: new ReleaseTrain('master', parse('10.2.0-next.3')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    })).toBe(true);\n+  });\n+\n+  it('should compute proper new version and select correct branch', async () => {\n+    const action = setupReleaseActionForTesting(CutLongTermSupportPatchAction, {\n+      releaseCandidate: null,\n+      next: new ReleaseTrain('master', parse('10.1.0-next.3')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.2')),\n+    });\n+\n+    spyOn<any>(action.instance, '_promptForTargetLtsBranch')\n+        .and.resolveTo({name: '9.2.x', version: parse('9.2.4'), npmDistTag: 'v9-lts'});\n+\n+    await expectStagingAndPublishWithCherryPick(action, '9.2.x', '9.2.5', 'v9-lts');\n+  });\n+\n+  it('should include number of active LTS branches in action description', async () => {\n+    const {releaseConfig, gitClient} = getTestingMocksForReleaseAction();\n+    const activeReleaseTrains = {\n+      releaseCandidate: null,\n+      next: new ReleaseTrain('master', parse('10.1.0-next.3')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.2')),\n+    };\n+\n+    fakeNpmPackageQueryRequest(releaseConfig.npmPackages[0], {\n+      'dist-tags': {'v9-lts': '9.1.2', 'v8-lts': '8.2.2'},\n+      'time': {\n+        '9.0.0': new Date().toISOString(),\n+        '8.0.0': new Date().toISOString(),\n+      },\n+    });\n+\n+    const action = new CutLongTermSupportPatchAction(\n+        activeReleaseTrains, gitClient, releaseConfig, testTmpDir);\n+\n+    expect(await action.getDescription())\n+        .toEqual(`Cut a new release for an active LTS branch (2 active).`);\n+  });\n+\n+  it('should properly determine active and inactive LTS branches', async () => {\n+    const {releaseConfig} = getTestingMocksForReleaseAction();\n+    fakeNpmPackageQueryRequest(releaseConfig.npmPackages[0], {\n+      'dist-tags': {\n+        'v9-lts': '9.2.3',\n+        'v8-lts': '8.4.4',\n+        'v7-lts': '7.0.1',\n+        'v6-lts': '6.0.0',\n+      },\n+      time: {\n+        '9.0.0': new Date().toISOString(),\n+        '8.0.0': new Date().toISOString(),\n+        // We pick dates for the v6 and v7 major versions that guarantee that the version\n+        // is no longer considered as active LTS version.\n+        '7.0.0': new Date(1912, 5, 23).toISOString(),\n+        '6.0.0': new Date(1912, 5, 23).toISOString(),\n+      },\n+    });\n+\n+    // Note: This accesses a private method, so we need to use an element access to satisfy\n+    // TypeScript. It is acceptable to access the member for fine-grained unit testing due to\n+    // complexity with inquirer we want to avoid. It is not easy to test prompts.\n+    const {active, inactive} = await fetchLongTermSupportBranchesFromNpm(releaseConfig);\n+\n+    expect(active).toEqual([\n+      {name: '9.2.x', version: matchesVersion('9.2.3'), npmDistTag: 'v9-lts'},\n+      {name: '8.4.x', version: matchesVersion('8.4.4'), npmDistTag: 'v8-lts'},\n+    ]);\n+    expect(inactive).toEqual([\n+      {name: '7.0.x', version: matchesVersion('7.0.1'), npmDistTag: 'v7-lts'},\n+      {name: '6.0.x', version: matchesVersion('6.0.0'), npmDistTag: 'v6-lts'},\n+    ]);\n+  });\n+});"
        },
        {
            "sha": "9df19191f01cc114841c27b50bc21bca92041ef1",
            "filename": "dev-infra/release/publish/test/cut-new-patch.spec.ts",
            "status": "added",
            "additions": 52,
            "deletions": 0,
            "changes": 52,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Fcut-new-patch.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Fcut-new-patch.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Ftest%2Fcut-new-patch.spec.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,52 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {ReleaseTrain} from '../../versioning/release-trains';\n+import {CutNewPatchAction} from '../actions/cut-new-patch';\n+\n+import {expectStagingAndPublishWithCherryPick, parse, setupReleaseActionForTesting} from './test-utils';\n+\n+describe('cut new patch action', () => {\n+  it('should be active', async () => {\n+    expect(await CutNewPatchAction.isActive({\n+      releaseCandidate: null,\n+      next: new ReleaseTrain('master', parse('10.1.0-next.3')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    })).toBe(true);\n+  });\n+\n+  it('should compute proper new version and select correct branch', async () => {\n+    const action = setupReleaseActionForTesting(CutNewPatchAction, {\n+      releaseCandidate: null,\n+      next: new ReleaseTrain('master', parse('10.1.0-next.3')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.2')),\n+    });\n+\n+    await expectStagingAndPublishWithCherryPick(action, '10.0.x', '10.0.3', 'latest');\n+  });\n+\n+  it('should create a proper new version if there is a feature-freeze release-train', async () => {\n+    const action = setupReleaseActionForTesting(CutNewPatchAction, {\n+      releaseCandidate: new ReleaseTrain('10.1.x', parse('10.1.0-next.3')),\n+      next: new ReleaseTrain('master', parse('10.2.0-next.0')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.9')),\n+    });\n+\n+    await expectStagingAndPublishWithCherryPick(action, '10.0.x', '10.0.10', 'latest');\n+  });\n+\n+  it('should create a proper new version if there is a release-candidate train', async () => {\n+    const action = setupReleaseActionForTesting(CutNewPatchAction, {\n+      releaseCandidate: new ReleaseTrain('10.1.x', parse('10.1.0-rc.0')),\n+      next: new ReleaseTrain('master', parse('10.2.0-next.0')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.9')),\n+    });\n+\n+    await expectStagingAndPublishWithCherryPick(action, '10.0.x', '10.0.10', 'latest');\n+  });\n+});"
        },
        {
            "sha": "ab37350788b82d03c5c6279cdaabe656ae692349",
            "filename": "dev-infra/release/publish/test/cut-next-prerelease.spec.ts",
            "status": "added",
            "additions": 79,
            "deletions": 0,
            "changes": 79,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Fcut-next-prerelease.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Fcut-next-prerelease.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Ftest%2Fcut-next-prerelease.spec.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,79 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {readFileSync} from 'fs';\n+import {join} from 'path';\n+\n+import {ReleaseTrain} from '../../versioning/release-trains';\n+import {CutNextPrereleaseAction} from '../actions/cut-next-prerelease';\n+import {packageJsonPath} from '../constants';\n+\n+import {expectStagingAndPublishWithCherryPick, expectStagingAndPublishWithoutCherryPick, parse, setupReleaseActionForTesting} from './test-utils';\n+\n+describe('cut next pre-release action', () => {\n+  it('should always be active regardless of release-trains', async () => {\n+    expect(await CutNextPrereleaseAction.isActive()).toBe(true);\n+  });\n+\n+  it('should cut a pre-release for the next branch if there is no FF/RC branch', async () => {\n+    const action = setupReleaseActionForTesting(CutNextPrereleaseAction, {\n+      releaseCandidate: null,\n+      next: new ReleaseTrain('master', parse('10.2.0-next.0')),\n+      latest: new ReleaseTrain('10.1.x', parse('10.1.2')),\n+    });\n+\n+    await expectStagingAndPublishWithoutCherryPick(action, 'master', '10.2.0-next.1', 'next');\n+  });\n+\n+  // This is test for a special case in the release tooling. Whenever we branch off for\n+  // feature-freeze, we immediately bump the version in the `next` branch but do not publish\n+  // it. This is because there are no new changes in the next branch that wouldn't be part of\n+  // the branched-off feature-freeze release-train. Also while a FF/RC is active, we cannot\n+  // publish versions to the NPM dist tag. This means that the version is later published, but\n+  // still needs all the staging work (e.g. changelog). We special-case this by not incrementing\n+  // the version if the version in the next branch has not been published yet.\n+  it('should not bump version if current next version has not been published', async () => {\n+    const action = setupReleaseActionForTesting(\n+        CutNextPrereleaseAction, {\n+          releaseCandidate: null,\n+          next: new ReleaseTrain('master', parse('10.2.0-next.0')),\n+          latest: new ReleaseTrain('10.1.x', parse('10.1.0')),\n+        },\n+        /* isNextPublishedToNpm */ false);\n+\n+    await expectStagingAndPublishWithoutCherryPick(action, 'master', '10.2.0-next.0', 'next');\n+\n+    const pkgJsonContents = readFileSync(join(action.testTmpDir, packageJsonPath), 'utf8');\n+    const pkgJson = JSON.parse(pkgJsonContents);\n+    expect(pkgJson.version).toBe('10.2.0-next.0', 'Expected version to not have changed.');\n+  });\n+\n+  describe('with active feature-freeze', () => {\n+    it('should create a proper new version and select correct branch', async () => {\n+      const action = setupReleaseActionForTesting(CutNextPrereleaseAction, {\n+        releaseCandidate: new ReleaseTrain('10.1.x', parse('10.1.0-next.4')),\n+        next: new ReleaseTrain('master', parse('10.2.0-next.0')),\n+        latest: new ReleaseTrain('10.0.x', parse('10.0.2')),\n+      });\n+\n+      await expectStagingAndPublishWithCherryPick(action, '10.1.x', '10.1.0-next.5', 'next');\n+    });\n+  });\n+\n+  describe('with active release-candidate', () => {\n+    it('should create a proper new version and select correct branch', async () => {\n+      const action = setupReleaseActionForTesting(CutNextPrereleaseAction, {\n+        releaseCandidate: new ReleaseTrain('10.1.x', parse('10.1.0-rc.0')),\n+        next: new ReleaseTrain('master', parse('10.2.0-next.0')),\n+        latest: new ReleaseTrain('10.0.x', parse('10.0.2')),\n+      });\n+\n+      await expectStagingAndPublishWithCherryPick(action, '10.1.x', '10.1.0-rc.1', 'next');\n+    });\n+  });\n+});"
        },
        {
            "sha": "589efa1df0f9779c1ae6bc32adf1d3be85fb8c77",
            "filename": "dev-infra/release/publish/test/cut-release-candidate.spec.ts",
            "status": "added",
            "additions": 49,
            "deletions": 0,
            "changes": 49,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Fcut-release-candidate.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Fcut-release-candidate.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Ftest%2Fcut-release-candidate.spec.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,49 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {ReleaseTrain} from '../../versioning/release-trains';\n+import {CutReleaseCandidateAction} from '../actions/cut-release-candidate';\n+\n+import {expectStagingAndPublishWithCherryPick, parse, setupReleaseActionForTesting} from './test-utils';\n+\n+describe('cut release candidate action', () => {\n+  it('should activate if a feature-freeze release-train is active', async () => {\n+    expect(await CutReleaseCandidateAction.isActive({\n+      releaseCandidate: new ReleaseTrain('10.1.x', parse('10.1.0-next.1')),\n+      next: new ReleaseTrain('master', parse('10.2.0-next.0')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    })).toBe(true);\n+  });\n+\n+  it('should not activate if release-candidate release-train is active', async () => {\n+    expect(await CutReleaseCandidateAction.isActive({\n+      // No longer in feature-freeze but in release-candidate phase.\n+      releaseCandidate: new ReleaseTrain('10.1.x', parse('10.1.0-rc.0')),\n+      next: new ReleaseTrain('master', parse('10.2.0-next.0')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    })).toBe(false);\n+  });\n+\n+  it('should not activate if no FF/RC release-train is active', async () => {\n+    expect(await CutReleaseCandidateAction.isActive({\n+      releaseCandidate: null,\n+      next: new ReleaseTrain('master', parse('10.1.0-next.0')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    })).toBe(false);\n+  });\n+\n+  it('should create a proper new version and select correct branch', async () => {\n+    const action = setupReleaseActionForTesting(CutReleaseCandidateAction, {\n+      releaseCandidate: new ReleaseTrain('10.1.x', parse('10.1.0-next.1')),\n+      next: new ReleaseTrain('master', parse('10.2.0-next.0')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    });\n+\n+    await expectStagingAndPublishWithCherryPick(action, '10.1.x', '10.1.0-rc.0', 'next');\n+  });\n+});"
        },
        {
            "sha": "5383b8f30093b09a682e08e480566248d03aab09",
            "filename": "dev-infra/release/publish/test/cut-stable.spec.ts",
            "status": "added",
            "additions": 78,
            "deletions": 0,
            "changes": 78,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Fcut-stable.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Fcut-stable.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Ftest%2Fcut-stable.spec.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,78 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {matchesVersion} from '../../../utils/testing/semver-matchers';\n+import {ReleaseTrain} from '../../versioning/release-trains';\n+import {CutStableAction} from '../actions/cut-stable';\n+import * as externalCommands from '../external-commands';\n+\n+import {expectStagingAndPublishWithCherryPick, parse, setupReleaseActionForTesting} from './test-utils';\n+\n+describe('cut stable action', () => {\n+  it('should not activate if a feature-freeze release-train is active', async () => {\n+    expect(await CutStableAction.isActive({\n+      releaseCandidate: new ReleaseTrain('10.1.x', parse('10.1.0-next.1')),\n+      next: new ReleaseTrain('master', parse('10.2.0-next.0')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    })).toBe(false);\n+  });\n+\n+  it('should activate if release-candidate release-train is active', async () => {\n+    expect(await CutStableAction.isActive({\n+      // No longer in feature-freeze but in release-candidate phase.\n+      releaseCandidate: new ReleaseTrain('10.1.x', parse('10.1.0-rc.0')),\n+      next: new ReleaseTrain('master', parse('10.2.0-next.0')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    })).toBe(true);\n+  });\n+\n+  it('should not activate if no FF/RC release-train is active', async () => {\n+    expect(await CutStableAction.isActive({\n+      releaseCandidate: null,\n+      next: new ReleaseTrain('master', parse('10.1.0-next.0')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    })).toBe(false);\n+  });\n+\n+  it('should create a proper new version and select correct branch', async () => {\n+    const action = setupReleaseActionForTesting(CutStableAction, {\n+      // No longer in feature-freeze but in release-candidate phase.\n+      releaseCandidate: new ReleaseTrain('10.1.x', parse('10.1.0-rc.0')),\n+      next: new ReleaseTrain('master', parse('10.2.0-next.0')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    });\n+\n+    await expectStagingAndPublishWithCherryPick(action, '10.1.x', '10.1.0', 'latest');\n+  });\n+\n+  it('should not tag the previous latest release-train if a minor has been cut', async () => {\n+    const action = setupReleaseActionForTesting(CutStableAction, {\n+      // No longer in feature-freeze but in release-candidate phase.\n+      releaseCandidate: new ReleaseTrain('10.1.x', parse('10.1.0-rc.0')),\n+      next: new ReleaseTrain('master', parse('10.2.0-next.0')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    });\n+\n+    await expectStagingAndPublishWithCherryPick(action, '10.1.x', '10.1.0', 'latest');\n+    expect(externalCommands.invokeSetNpmDistCommand).toHaveBeenCalledTimes(0);\n+  });\n+\n+  it('should tag the previous latest release-train if a major has been cut', async () => {\n+    const action = setupReleaseActionForTesting(CutStableAction, {\n+      // No longer in feature-freeze but in release-candidate phase.\n+      releaseCandidate: new ReleaseTrain('11.0.x', parse('11.0.0-rc.0')),\n+      next: new ReleaseTrain('master', parse('10.2.0-next.0')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    });\n+\n+    await expectStagingAndPublishWithCherryPick(action, '11.0.x', '11.0.0', 'latest');\n+    expect(externalCommands.invokeSetNpmDistCommand).toHaveBeenCalledTimes(1);\n+    expect(externalCommands.invokeSetNpmDistCommand)\n+        .toHaveBeenCalledWith('v10-lts', matchesVersion('10.0.3'));\n+  });\n+});"
        },
        {
            "sha": "e12ef6da37c862d519a38426cfb455eff0b9277c",
            "filename": "dev-infra/release/publish/test/github-api-testing.ts",
            "status": "added",
            "additions": 88,
            "deletions": 0,
            "changes": 88,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Fgithub-api-testing.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Fgithub-api-testing.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Ftest%2Fgithub-api-testing.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,88 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as nock from 'nock';\n+\n+/**\n+ * Class that represents a Github repository in testing. The class can be\n+ * used to intercept and except Github API requests for release actions.\n+ */\n+export class GithubTestingRepo {\n+  /** Github API endpoint. */\n+  private apiEndpoint = `https://api.github.com`;\n+\n+  /** Github API url for the given repository. */\n+  private repoApiUrl = `${this.apiEndpoint}/repos/${this.owner}/${this.name}`;\n+\n+  constructor(public owner: string, public name: string) {}\n+\n+  expectPullRequestToBeCreated(\n+      baseBranch: string, fork: GithubTestingRepo, forkBranch: string, prNumber: number): this {\n+    const expectedHead = `${fork.owner}:${forkBranch}`;\n+    nock(this.repoApiUrl)\n+        .post('/pulls', ({base, head}) => base === baseBranch && head === expectedHead)\n+        .reply(200, {number: prNumber});\n+    return this;\n+  }\n+\n+  expectBranchRequest(branchName: string, sha: string|null): this {\n+    nock(this.repoApiUrl)\n+        .get(`/branches/${branchName}`)\n+        .reply(sha ? 200 : 404, sha ? {commit: {sha}} : undefined);\n+    return this;\n+  }\n+\n+  expectFindForkRequest(fork: GithubTestingRepo): this {\n+    nock(this.apiEndpoint)\n+        .post(\n+            '/graphql',\n+            ({variables}) => variables.owner === this.owner && variables.name === this.name)\n+        .reply(200, {\n+          data: {repository: {forks: {nodes: [{owner: {login: fork.owner}, name: fork.name}]}}}\n+        });\n+    return this;\n+  }\n+\n+  expectCommitStatusCheck(sha: string, state: 'success'|'pending'|'failure'): this {\n+    nock(this.repoApiUrl).get(`/commits/${sha}/status`).reply(200, {state}).activeMocks();\n+    return this;\n+  }\n+\n+  expectPullRequestWait(prNumber: number): this {\n+    // The pull request state could be queried multiple times, so we persist\n+    // this mock request. By default, nock only mocks requests once.\n+    nock(this.repoApiUrl).get(`/pulls/${prNumber}`).reply(200, {merged: true}).persist();\n+    return this;\n+  }\n+\n+  expectChangelogFetch(branch: string, content: string): this {\n+    nock(this.repoApiUrl).get(`/contents//CHANGELOG.md`).query(p => p.ref === branch).reply(200, {\n+      content: new Buffer(content).toString('base64')\n+    });\n+    return this;\n+  }\n+\n+  expectCommitRequest(sha: string, message: string): this {\n+    nock(this.repoApiUrl).get(`/commits/${sha}`).reply(200, {commit: {message}});\n+    return this;\n+  }\n+\n+  expectTagToBeCreated(tagName: string, sha: string): this {\n+    nock(this.repoApiUrl)\n+        .post(`/git/refs`, b => b.ref === `refs/tags/${tagName}` && b.sha === sha)\n+        .reply(200, {});\n+    return this;\n+  }\n+\n+  expectReleaseToBeCreated(name: string, tagName: string): this {\n+    nock(this.repoApiUrl)\n+        .post('/releases', b => b.name === name && b['tag_name'] === tagName)\n+        .reply(200, {});\n+    return this;\n+  }\n+}"
        },
        {
            "sha": "11a64ca4867de557c30041c720da6e81c6585627",
            "filename": "dev-infra/release/publish/test/move-next-into-feature-freeze.spec.ts",
            "status": "added",
            "additions": 148,
            "deletions": 0,
            "changes": 148,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Fmove-next-into-feature-freeze.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Fmove-next-into-feature-freeze.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Ftest%2Fmove-next-into-feature-freeze.spec.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,148 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {getBranchPushMatcher} from '../../../utils/testing';\n+import {ActiveReleaseTrains} from '../../versioning/active-release-trains';\n+import * as npm from '../../versioning/npm-publish';\n+import {ReleaseTrain} from '../../versioning/release-trains';\n+import {MoveNextIntoFeatureFreezeAction} from '../actions/move-next-into-feature-freeze';\n+import * as externalCommands from '../external-commands';\n+\n+import {getChangelogForVersion, parse, setupReleaseActionForTesting, testTmpDir} from './test-utils';\n+\n+describe('move next into feature-freeze action', () => {\n+  it('should not activate if a feature-freeze release-train is active', async () => {\n+    expect(await MoveNextIntoFeatureFreezeAction.isActive({\n+      releaseCandidate: new ReleaseTrain('10.1.x', parse('10.1.0-next.1')),\n+      next: new ReleaseTrain('master', parse('10.2.0-next.0')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    })).toBe(false);\n+  });\n+\n+  it('should not activate if release-candidate release-train is active', async () => {\n+    expect(await MoveNextIntoFeatureFreezeAction.isActive({\n+      // No longer in feature-freeze but in release-candidate phase.\n+      releaseCandidate: new ReleaseTrain('10.1.x', parse('10.1.0-rc.0')),\n+      next: new ReleaseTrain('master', parse('10.2.0-next.0')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    })).toBe(false);\n+  });\n+\n+  it('should activate if no FF/RC release-train is active', async () => {\n+    expect(await MoveNextIntoFeatureFreezeAction.isActive({\n+      releaseCandidate: null,\n+      next: new ReleaseTrain('master', parse('10.1.0-next.0')),\n+      latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+    })).toBe(true);\n+  });\n+\n+  it('should create pull requests and feature-freeze branch', async () => {\n+    await expectVersionAndBranchToBeCreated(\n+        {\n+          releaseCandidate: null,\n+          next: new ReleaseTrain('master', parse('10.2.0-next.0')),\n+          latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+        },\n+        /* isNextPublishedToNpm */ true, '10.3.0-next.0', '10.2.0-next.1', '10.2.x');\n+  });\n+\n+  it('should not increment the version if \"next\" version is not yet published', async () => {\n+    await expectVersionAndBranchToBeCreated(\n+        {\n+          releaseCandidate: null,\n+          next: new ReleaseTrain('master', parse('10.2.0-next.0')),\n+          latest: new ReleaseTrain('10.0.x', parse('10.0.3')),\n+        },\n+        /* isNextPublishedToNpm */ false, '10.3.0-next.0', '10.2.0-next.0', '10.2.x');\n+  });\n+\n+  /** Performs the action and expects versions and branches to be determined properly. */\n+  async function expectVersionAndBranchToBeCreated(\n+      active: ActiveReleaseTrains, isNextPublishedToNpm: boolean, expectedNextVersion: string,\n+      expectedVersion: string, expectedNewBranch: string) {\n+    const {repo, fork, instance, gitClient, releaseConfig} =\n+        setupReleaseActionForTesting(MoveNextIntoFeatureFreezeAction, active, isNextPublishedToNpm);\n+\n+    const expectedNextUpdateBranch = `next-release-train-${expectedNextVersion}`;\n+    const expectedStagingForkBranch = `release-stage-${expectedVersion}`;\n+    const expectedTagName = expectedVersion;\n+\n+    // We first mock the commit status check for the next branch, then expect two pull\n+    // requests from a fork that are targeting next and the new feature-freeze branch.\n+    repo.expectBranchRequest('master', 'MASTER_COMMIT_SHA')\n+        .expectCommitStatusCheck('MASTER_COMMIT_SHA', 'success')\n+        .expectFindForkRequest(fork)\n+        .expectPullRequestToBeCreated(expectedNewBranch, fork, expectedStagingForkBranch, 200)\n+        .expectPullRequestWait(200)\n+        .expectBranchRequest(expectedNewBranch, 'STAGING_COMMIT_SHA')\n+        .expectCommitRequest(\n+            'STAGING_COMMIT_SHA', `release: cut the v${expectedVersion} release\\n\\nPR Close #200.`)\n+        .expectTagToBeCreated(expectedTagName, 'STAGING_COMMIT_SHA')\n+        .expectReleaseToBeCreated(`v${expectedVersion}`, expectedTagName)\n+        .expectChangelogFetch(expectedNewBranch, getChangelogForVersion(expectedVersion))\n+        .expectPullRequestToBeCreated('master', fork, expectedNextUpdateBranch, 100);\n+\n+    // In the fork, we make the following branches appear as non-existent,\n+    // so that the PRs can be created properly without collisions.\n+    fork.expectBranchRequest(expectedStagingForkBranch, null)\n+        .expectBranchRequest(expectedNextUpdateBranch, null);\n+\n+    await instance.perform();\n+\n+    expect(gitClient.pushed.length).toBe(3);\n+    expect(gitClient.pushed[0])\n+        .toEqual(\n+            getBranchPushMatcher({\n+              baseRepo: repo,\n+              baseBranch: 'master',\n+              targetRepo: repo,\n+              targetBranch: expectedNewBranch,\n+              expectedCommits: [],\n+            }),\n+            'Expected feature-freeze branch to be created upstream and based on \"master\".');\n+    expect(gitClient.pushed[1])\n+        .toEqual(\n+            getBranchPushMatcher({\n+              baseBranch: 'master',\n+              baseRepo: repo,\n+              targetBranch: expectedStagingForkBranch,\n+              targetRepo: fork,\n+              expectedCommits: [{\n+                message: `release: cut the v${expectedVersion} release`,\n+                files: ['package.json', 'CHANGELOG.md'],\n+              }],\n+            }),\n+            'Expected release staging branch to be created in fork.');\n+\n+    expect(gitClient.pushed[2])\n+        .toEqual(\n+            getBranchPushMatcher({\n+              baseBranch: 'master',\n+              baseRepo: repo,\n+              targetBranch: expectedNextUpdateBranch,\n+              targetRepo: fork,\n+              expectedCommits: [\n+                {\n+                  message: `release: bump the next branch to v${expectedNextVersion}`,\n+                  files: ['package.json']\n+                },\n+                {\n+                  message: `docs: release notes for the v${expectedVersion} release`,\n+                  files: ['CHANGELOG.md']\n+                },\n+              ],\n+            }),\n+            'Expected next release-train update branch be created in fork.');\n+\n+    expect(externalCommands.invokeReleaseBuildCommand).toHaveBeenCalledTimes(1);\n+    expect(releaseConfig.generateReleaseNotesForHead).toHaveBeenCalledTimes(1);\n+    expect(npm.runNpmPublish).toHaveBeenCalledTimes(2);\n+    expect(npm.runNpmPublish).toHaveBeenCalledWith(`${testTmpDir}/dist/pkg1`, 'next', undefined);\n+    expect(npm.runNpmPublish).toHaveBeenCalledWith(`${testTmpDir}/dist/pkg2`, 'next', undefined);\n+  }\n+});"
        },
        {
            "sha": "0f4ac544454234316975be38e99659ae22006a54",
            "filename": "dev-infra/release/publish/test/test-utils.ts",
            "status": "added",
            "additions": 244,
            "deletions": 0,
            "changes": 244,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Ftest-utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fpublish%2Ftest%2Ftest-utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fpublish%2Ftest%2Ftest-utils.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,244 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {writeFileSync} from 'fs';\n+import * as nock from 'nock';\n+import {join} from 'path';\n+import * as semver from 'semver';\n+\n+import {GithubConfig} from '../../../utils/config';\n+import * as console from '../../../utils/console';\n+import {getBranchPushMatcher, VirtualGitClient} from '../../../utils/testing';\n+import {ReleaseConfig} from '../../config/index';\n+import {ActiveReleaseTrains} from '../../versioning/active-release-trains';\n+import * as npm from '../../versioning/npm-publish';\n+import {_npmPackageInfoCache, NpmPackageInfo} from '../../versioning/npm-registry';\n+import {ReleaseAction, ReleaseActionConstructor} from '../actions';\n+import * as constants from '../constants';\n+import * as externalCommands from '../external-commands';\n+\n+import {GithubTestingRepo} from './github-api-testing';\n+\n+/**\n+ * Temporary directory which will be used as project directory in tests. Note that\n+ * this environment variable is automatically set by Bazel for tests.\n+ */\n+export const testTmpDir: string = process.env['TEST_TMPDIR']!;\n+\n+/** Interface describing a test release action. */\n+export interface TestReleaseAction<T extends ReleaseAction = ReleaseAction> {\n+  instance: T;\n+  gitClient: VirtualGitClient;\n+  repo: GithubTestingRepo;\n+  fork: GithubTestingRepo;\n+  testTmpDir: string;\n+  githubConfig: GithubConfig;\n+  releaseConfig: ReleaseConfig;\n+}\n+\n+/** Gets necessary test mocks for running a release action. */\n+export function getTestingMocksForReleaseAction() {\n+  const githubConfig = {owner: 'angular', name: 'dev-infra-test'};\n+  const gitClient = new VirtualGitClient(undefined, {github: githubConfig}, testTmpDir);\n+  const releaseConfig: ReleaseConfig = {\n+    npmPackages: [\n+      '@angular/pkg1',\n+      '@angular/pkg2',\n+    ],\n+    generateReleaseNotesForHead: jasmine.createSpy('generateReleaseNotesForHead').and.resolveTo(),\n+    buildPackages: () => {\n+      throw Error('Not implemented');\n+    },\n+  };\n+  return {githubConfig, gitClient, releaseConfig};\n+}\n+\n+/**\n+ * Sets up the given release action for testing.\n+ * @param actionCtor Type of release action to be tested.\n+ * @param active Fake active release trains for the action,\n+ * @param isNextPublishedToNpm Whether the next version is published to NPM. True by default.\n+ */\n+export function setupReleaseActionForTesting<T extends ReleaseAction>(\n+    actionCtor: ReleaseActionConstructor<T>, active: ActiveReleaseTrains,\n+    isNextPublishedToNpm = true): TestReleaseAction<T> {\n+  // Reset existing HTTP interceptors.\n+  nock.cleanAll();\n+\n+  const {gitClient, githubConfig, releaseConfig} = getTestingMocksForReleaseAction();\n+  const repo = new GithubTestingRepo(githubConfig.owner, githubConfig.name);\n+  const fork = new GithubTestingRepo('some-user', 'fork');\n+\n+  // The version for the release-train in the next phase does not necessarily need to be\n+  // published to NPM. We mock the NPM package request and fake the state of the next\n+  // version based on the `isNextPublishedToNpm` testing parameter. More details on the\n+  // special case for the next release train can be found in the next pre-release action.\n+  fakeNpmPackageQueryRequest(\n+      releaseConfig.npmPackages[0],\n+      {versions: {[active.next.version.format()]: isNextPublishedToNpm ? {} : undefined}});\n+\n+  const action = new actionCtor(active, gitClient, releaseConfig, testTmpDir);\n+\n+  // Fake confirm any prompts. We do not want to make any changelog edits and\n+  // just proceed with the release action.\n+  spyOn(console, 'promptConfirm').and.resolveTo(true);\n+\n+  // Fake all external commands for the release tool.\n+  spyOn(npm, 'runNpmPublish').and.resolveTo(true);\n+  spyOn(externalCommands, 'invokeSetNpmDistCommand').and.resolveTo();\n+  spyOn(externalCommands, 'invokeYarnInstallCommand').and.resolveTo();\n+  spyOn(externalCommands, 'invokeReleaseBuildCommand').and.resolveTo([\n+    {name: '@angular/pkg1', outputPath: `${testTmpDir}/dist/pkg1`},\n+    {name: '@angular/pkg2', outputPath: `${testTmpDir}/dist/pkg2`}\n+  ]);\n+\n+  // Create an empty changelog and a `package.json` file so that file system\n+  // interactions with the project directory do not cause exceptions.\n+  writeFileSync(join(testTmpDir, 'CHANGELOG.md'), 'Existing changelog');\n+  writeFileSync(join(testTmpDir, 'package.json'), JSON.stringify({version: 'unknown'}));\n+\n+  // Override the default pull request wait interval to a number of milliseconds that can be\n+  // awaited in Jasmine tests. The default interval of 10sec is too large and causes a timeout.\n+  Object.defineProperty(constants, 'waitForPullRequestInterval', {value: 50});\n+\n+  return {instance: action, repo, fork, testTmpDir, githubConfig, releaseConfig, gitClient};\n+}\n+\n+/** Parses the specified version into Semver. */\n+export function parse(version: string): semver.SemVer {\n+  return semver.parse(version)!;\n+}\n+\n+/** Gets a changelog for the specified version. */\n+export function getChangelogForVersion(version: string): string {\n+  return `<a name=\"${version}\"></a>Changelog\\n\\n`;\n+}\n+\n+export async function expectStagingAndPublishWithoutCherryPick(\n+    action: TestReleaseAction, expectedBranch: string, expectedVersion: string,\n+    expectedNpmDistTag: string) {\n+  const {repo, fork, gitClient, releaseConfig} = action;\n+  const expectedStagingForkBranch = `release-stage-${expectedVersion}`;\n+  const expectedTagName = expectedVersion;\n+\n+  // We first mock the commit status check for the next branch, then expect two pull\n+  // requests from a fork that are targeting next and the new feature-freeze branch.\n+  repo.expectBranchRequest(expectedBranch, 'MASTER_COMMIT_SHA')\n+      .expectCommitStatusCheck('MASTER_COMMIT_SHA', 'success')\n+      .expectFindForkRequest(fork)\n+      .expectPullRequestToBeCreated(expectedBranch, fork, expectedStagingForkBranch, 200)\n+      .expectPullRequestWait(200)\n+      .expectBranchRequest(expectedBranch, 'STAGING_COMMIT_SHA')\n+      .expectCommitRequest(\n+          'STAGING_COMMIT_SHA', `release: cut the v${expectedVersion} release\\n\\nPR Close #200.`)\n+      .expectTagToBeCreated(expectedTagName, 'STAGING_COMMIT_SHA')\n+      .expectReleaseToBeCreated(`v${expectedVersion}`, expectedTagName);\n+\n+  // In the fork, we make the staging branch appear as non-existent,\n+  // so that the PR can be created properly without collisions.\n+  fork.expectBranchRequest(expectedStagingForkBranch, null);\n+\n+  await action.instance.perform();\n+\n+  expect(gitClient.pushed.length).toBe(1);\n+  expect(gitClient.pushed[0])\n+      .toEqual(\n+          getBranchPushMatcher({\n+            baseBranch: expectedBranch,\n+            baseRepo: repo,\n+            targetBranch: expectedStagingForkBranch,\n+            targetRepo: fork,\n+            expectedCommits: [{\n+              message: `release: cut the v${expectedVersion} release`,\n+              files: ['package.json', 'CHANGELOG.md'],\n+            }],\n+          }),\n+          'Expected release staging branch to be created in fork.');\n+\n+  expect(externalCommands.invokeReleaseBuildCommand).toHaveBeenCalledTimes(1);\n+  expect(releaseConfig.generateReleaseNotesForHead).toHaveBeenCalledTimes(1);\n+  expect(npm.runNpmPublish).toHaveBeenCalledTimes(2);\n+  expect(npm.runNpmPublish)\n+      .toHaveBeenCalledWith(`${testTmpDir}/dist/pkg1`, expectedNpmDistTag, undefined);\n+  expect(npm.runNpmPublish)\n+      .toHaveBeenCalledWith(`${testTmpDir}/dist/pkg2`, expectedNpmDistTag, undefined);\n+}\n+\n+export async function expectStagingAndPublishWithCherryPick(\n+    action: TestReleaseAction, expectedBranch: string, expectedVersion: string,\n+    expectedNpmDistTag: string) {\n+  const {repo, fork, gitClient, releaseConfig} = action;\n+  const expectedStagingForkBranch = `release-stage-${expectedVersion}`;\n+  const expectedCherryPickForkBranch = `changelog-cherry-pick-${expectedVersion}`;\n+  const expectedTagName = expectedVersion;\n+\n+  // We first mock the commit status check for the next branch, then expect two pull\n+  // requests from a fork that are targeting next and the new feature-freeze branch.\n+  repo.expectBranchRequest(expectedBranch, 'MASTER_COMMIT_SHA')\n+      .expectCommitStatusCheck('MASTER_COMMIT_SHA', 'success')\n+      .expectFindForkRequest(fork)\n+      .expectPullRequestToBeCreated(expectedBranch, fork, expectedStagingForkBranch, 200)\n+      .expectPullRequestWait(200)\n+      .expectBranchRequest(expectedBranch, 'STAGING_COMMIT_SHA')\n+      .expectCommitRequest(\n+          'STAGING_COMMIT_SHA', `release: cut the v${expectedVersion} release\\n\\nPR Close #200.`)\n+      .expectTagToBeCreated(expectedTagName, 'STAGING_COMMIT_SHA')\n+      .expectReleaseToBeCreated(`v${expectedVersion}`, expectedTagName)\n+      .expectChangelogFetch(expectedBranch, getChangelogForVersion(expectedVersion))\n+      .expectPullRequestToBeCreated('master', fork, expectedCherryPickForkBranch, 300);\n+\n+  // In the fork, we make the staging and cherry-pick branches appear as\n+  // non-existent, so that the PRs can be created properly without collisions.\n+  fork.expectBranchRequest(expectedStagingForkBranch, null)\n+      .expectBranchRequest(expectedCherryPickForkBranch, null);\n+\n+  await action.instance.perform();\n+\n+  expect(gitClient.pushed.length).toBe(2);\n+  expect(gitClient.pushed[0])\n+      .toEqual(\n+          getBranchPushMatcher({\n+            baseBranch: expectedBranch,\n+            baseRepo: repo,\n+            targetBranch: expectedStagingForkBranch,\n+            targetRepo: fork,\n+            expectedCommits: [{\n+              message: `release: cut the v${expectedVersion} release`,\n+              files: ['package.json', 'CHANGELOG.md'],\n+            }],\n+          }),\n+          'Expected release staging branch to be created in fork.');\n+\n+  expect(gitClient.pushed[1])\n+      .toEqual(\n+          getBranchPushMatcher({\n+            baseBranch: 'master',\n+            baseRepo: repo,\n+            targetBranch: expectedCherryPickForkBranch,\n+            targetRepo: fork,\n+            expectedCommits: [{\n+              message: `docs: release notes for the v${expectedVersion} release`,\n+              files: ['CHANGELOG.md'],\n+            }],\n+          }),\n+          'Expected cherry-pick branch to be created in fork.');\n+\n+  expect(externalCommands.invokeReleaseBuildCommand).toHaveBeenCalledTimes(1);\n+  expect(releaseConfig.generateReleaseNotesForHead).toHaveBeenCalledTimes(1);\n+  expect(npm.runNpmPublish).toHaveBeenCalledTimes(2);\n+  expect(npm.runNpmPublish)\n+      .toHaveBeenCalledWith(`${testTmpDir}/dist/pkg1`, expectedNpmDistTag, undefined);\n+  expect(npm.runNpmPublish)\n+      .toHaveBeenCalledWith(`${testTmpDir}/dist/pkg2`, expectedNpmDistTag, undefined);\n+}\n+\n+/** Fakes a NPM package query API request for the given package. */\n+export function fakeNpmPackageQueryRequest(pkgName: string, data: Partial<NpmPackageInfo>) {\n+  _npmPackageInfoCache[pkgName] =\n+      Promise.resolve({'dist-tags': {}, versions: {}, time: {}, ...data});\n+}"
        },
        {
            "sha": "3ea0e917c699561b1bb69d8c76cd002a0a314861",
            "filename": "dev-infra/release/versioning/inc-semver.ts",
            "status": "added",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fversioning%2Finc-semver.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fversioning%2Finc-semver.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fversioning%2Finc-semver.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,19 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as semver from 'semver';\n+\n+/**\n+ * Increments a specified SemVer version. Compared to the original increment in SemVer,\n+ * the version is cloned to not modify the original version instance.\n+ */\n+export function semverInc(\n+    version: semver.SemVer, release: semver.ReleaseType, identifier?: string) {\n+  const clone = new semver.SemVer(version.version);\n+  return clone.inc(release, identifier);\n+}"
        },
        {
            "sha": "bc6ed5b08655d84b70508891b01281bac0e195b8",
            "filename": "dev-infra/release/versioning/next-prerelease-version.ts",
            "status": "added",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fversioning%2Fnext-prerelease-version.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fversioning%2Fnext-prerelease-version.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fversioning%2Fnext-prerelease-version.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -0,0 +1,32 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as semver from 'semver';\n+\n+import {ReleaseConfig} from '../config/index';\n+\n+import {ActiveReleaseTrains} from './active-release-trains';\n+import {semverInc} from './inc-semver';\n+import {isVersionPublishedToNpm} from './npm-registry';\n+\n+/** Computes the new pre-release version for the next release-train. */\n+export async function computeNewPrereleaseVersionForNext(\n+    active: ActiveReleaseTrains, config: ReleaseConfig): Promise<semver.SemVer> {\n+  const {version: nextVersion} = active.next;\n+  const isNextPublishedToNpm = await isVersionPublishedToNpm(nextVersion, config);\n+  // Special-case where the version in the `next` release-train is not published yet. This\n+  // happens when we recently branched off for feature-freeze. We already bump the version to\n+  // the next minor or major, but do not publish immediately. Cutting a release immediately would\n+  // be not helpful as there are no other changes than in the feature-freeze branch. If we happen\n+  // to detect this case, we stage the release as usual but do not increment the version.\n+  if (isNextPublishedToNpm) {\n+    return semverInc(nextVersion, 'prerelease');\n+  } else {\n+    return nextVersion;\n+  }\n+}"
        },
        {
            "sha": "7415c5e84b5d6e3de75b978b8ddf9a39cc962032",
            "filename": "dev-infra/release/versioning/npm-publish.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fversioning%2Fnpm-publish.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Frelease%2Fversioning%2Fnpm-publish.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Frelease%2Fversioning%2Fnpm-publish.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -9,6 +9,20 @@\n import * as semver from 'semver';\n import {spawnWithDebugOutput} from '../../utils/child-process';\n \n+/**\n+ * Runs NPM publish within a specified package directory.\n+ * @throws With the process log output if the publish failed.\n+ */\n+export async function runNpmPublish(\n+    packagePath: string, distTag: string, registryUrl: string|undefined) {\n+  const args = ['publish', '--access', 'public', '--tag', distTag];\n+  // If a custom registry URL has been specified, add the `--registry` flag.\n+  if (registryUrl !== undefined) {\n+    args.push('--registry', registryUrl);\n+  }\n+  await spawnWithDebugOutput('npm', args, {cwd: packagePath, mode: 'silent'});\n+}\n+\n /**\n  * Sets the NPM tag to the specified version for the given package.\n  * @throws With the process log output if the tagging failed."
        },
        {
            "sha": "1aacfdccc6e6fbda5fdac692d3d69152ea04bb37",
            "filename": "dev-infra/utils/git/github-urls.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Futils%2Fgit%2Fgithub-urls.ts",
            "raw_url": "https://github.com/angular/angular/raw/f96dcc5ce0dcb5f53934e87e4d2b022328feae2e/dev-infra%2Futils%2Fgit%2Fgithub-urls.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/dev-infra%2Futils%2Fgit%2Fgithub-urls.ts?ref=f96dcc5ce0dcb5f53934e87e4d2b022328feae2e",
            "patch": "@@ -9,6 +9,7 @@\n \n import {URL} from 'url';\n import {GithubConfig} from '../config';\n+import {GitClient} from './index';\n \n /** URL to the Github page where personal access tokens can be managed. */\n export const GITHUB_TOKEN_SETTINGS_URL = `https://github.com/settings/tokens`;\n@@ -34,3 +35,8 @@ export function getRepositoryGitUrl(config: GithubConfig, githubToken?: string):\n   }\n   return baseHttpUrl;\n }\n+\n+/** Gets a Github URL that refers to a lists of recent commits within a specified branch. */\n+export function getListCommitsInBranchUrl({remoteParams}: GitClient, branchName: string) {\n+  return `https://github.com/${remoteParams.owner}/${remoteParams.repo}/commits/${branchName}`;\n+}"
        }
    ],
    "stats": {
        "total": 2825,
        "additions": 2825,
        "deletions": 0
    }
}