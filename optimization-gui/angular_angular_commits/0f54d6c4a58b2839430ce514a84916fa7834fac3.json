{
    "author": "alxhub",
    "message": "fix(language-service): use 'any' instead of failing for inline TCBs (#41513)\n\nIn environments such as the Language Service where inline type-checking code\nis not supported, the compiler would previously produce a diagnostic when a\ntemplate would require inlining to check. This happened whenever its\ncomponent class had generic parameters with bounds that could not be safely\nreproduced in an external TCB. However, this created a bad user experience\nfor the Language Service, as its features would then not function with such\ntemplates.\n\nInstead, this commit changes the compiler to use the same strategy for\ninline TCBs as it does for inline type constructors - falling back to `any`\nfor generic types when inlining isn't available. This allows the LS to\nsupport such templates with slightly weaker type-checking semantics, which\na test verifies. There is still a case where components that aren't\nexported require an inline TCB, and the compiler will still generate a\ndiagnostic if so.\n\nFixes #41395\n\nPR Close #41513",
    "sha": "0f54d6c4a58b2839430ce514a84916fa7834fac3",
    "files": [
        {
            "sha": "52bf545974a8f51d5c7fe9fa32886a12bc9f4246",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/context.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 11,
            "changes": 40,
            "blob_url": "https://github.com/angular/angular/blob/0f54d6c4a58b2839430ce514a84916fa7834fac3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts",
            "raw_url": "https://github.com/angular/angular/raw/0f54d6c4a58b2839430ce514a84916fa7834fac3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts?ref=0f54d6c4a58b2839430ce514a84916fa7834fac3",
            "patch": "@@ -23,8 +23,8 @@ import {Environment} from './environment';\n import {OutOfBandDiagnosticRecorder, OutOfBandDiagnosticRecorderImpl} from './oob';\n import {TypeCheckShimGenerator} from './shim';\n import {TemplateSourceManager} from './source';\n-import {requiresInlineTypeCheckBlock} from './tcb_util';\n-import {generateTypeCheckBlock} from './type_check_block';\n+import {requiresInlineTypeCheckBlock, TcbInliningRequirement} from './tcb_util';\n+import {generateTypeCheckBlock, TcbGenericContextBehavior} from './type_check_block';\n import {TypeCheckFile} from './type_check_file';\n import {generateInlineTypeCtor, requiresInlineTypeCtor} from './type_constructor';\n \n@@ -262,11 +262,12 @@ export class TypeCheckContextImpl implements TypeCheckContext {\n       templateDiagnostics,\n     });\n \n-    const tcbRequiresInline = requiresInlineTypeCheckBlock(ref.node, pipes);\n+    const inliningRequirement = requiresInlineTypeCheckBlock(ref.node, pipes, this.reflector);\n \n     // If inlining is not supported, but is required for either the TCB or one of its directive\n     // dependencies, then exit here with an error.\n-    if (this.inlining === InliningMode.Error && tcbRequiresInline) {\n+    if (this.inlining === InliningMode.Error &&\n+        inliningRequirement === TcbInliningRequirement.MustInline) {\n       // This template cannot be supported because the underlying strategy does not support inlining\n       // and inlining would be required.\n \n@@ -285,13 +286,26 @@ export class TypeCheckContextImpl implements TypeCheckContext {\n       schemas,\n     };\n     this.perf.eventCount(PerfEvent.GenerateTcb);\n-    if (tcbRequiresInline) {\n+    if (inliningRequirement !== TcbInliningRequirement.None &&\n+        this.inlining === InliningMode.InlineOps) {\n       // This class didn't meet the requirements for external type checking, so generate an inline\n       // TCB for the class.\n       this.addInlineTypeCheckBlock(fileData, shimData, ref, meta);\n+    } else if (\n+        inliningRequirement === TcbInliningRequirement.ShouldInlineForGenericBounds &&\n+        this.inlining === InliningMode.Error) {\n+      // It's suggested that this TCB should be generated inline due to the component's generic\n+      // bounds, but inlining is not supported by the current environment. Use a non-inline type\n+      // check block, but fall back to `any` generic parameters since the generic bounds can't be\n+      // referenced in that context. This will infer a less useful type for the component, but allow\n+      // for type-checking it in an environment where that would not be possible otherwise.\n+      shimData.file.addTypeCheckBlock(\n+          ref, meta, shimData.domSchemaChecker, shimData.oobRecorder,\n+          TcbGenericContextBehavior.FallbackToAny);\n     } else {\n-      // The class can be type-checked externally as normal.\n-      shimData.file.addTypeCheckBlock(ref, meta, shimData.domSchemaChecker, shimData.oobRecorder);\n+      shimData.file.addTypeCheckBlock(\n+          ref, meta, shimData.domSchemaChecker, shimData.oobRecorder,\n+          TcbGenericContextBehavior.UseEmitter);\n     }\n   }\n \n@@ -402,7 +416,7 @@ export class TypeCheckContextImpl implements TypeCheckContext {\n       this.opMap.set(sf, []);\n     }\n     const ops = this.opMap.get(sf)!;\n-    ops.push(new TcbOp(\n+    ops.push(new InlineTcbOp(\n         ref, tcbMeta, this.config, this.reflector, shimData.domSchemaChecker,\n         shimData.oobRecorder));\n     fileData.hasInlines = true;\n@@ -481,9 +495,9 @@ interface Op {\n }\n \n /**\n- * A type check block operation which produces type check code for a particular component.\n+ * A type check block operation which produces inline type check code for a particular component.\n  */\n-class TcbOp implements Op {\n+class InlineTcbOp implements Op {\n   constructor(\n       readonly ref: Reference<ClassDeclaration<ts.ClassDeclaration>>,\n       readonly meta: TypeCheckBlockMetadata, readonly config: TypeCheckingConfig,\n@@ -501,8 +515,12 @@ class TcbOp implements Op {\n       string {\n     const env = new Environment(this.config, im, refEmitter, this.reflector, sf);\n     const fnName = ts.createIdentifier(`_tcb_${this.ref.node.pos}`);\n+\n+    // Inline TCBs should copy any generic type parameter nodes directly, as the TCB code is inlined\n+    // into the class in a context where that will always be legal.\n     const fn = generateTypeCheckBlock(\n-        env, this.ref, fnName, this.meta, this.domSchemaChecker, this.oobRecorder);\n+        env, this.ref, fnName, this.meta, this.domSchemaChecker, this.oobRecorder,\n+        TcbGenericContextBehavior.CopyClassNodes);\n     return printer.printNode(ts.EmitHint.Unspecified, fn, sf);\n   }\n }"
        },
        {
            "sha": "ace4cc8b2b30a0fd6e7e288adb89f45fe2d1d309",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/tcb_util.ts",
            "status": "modified",
            "additions": 42,
            "deletions": 9,
            "changes": 51,
            "blob_url": "https://github.com/angular/angular/blob/0f54d6c4a58b2839430ce514a84916fa7834fac3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftcb_util.ts",
            "raw_url": "https://github.com/angular/angular/raw/0f54d6c4a58b2839430ce514a84916fa7834fac3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftcb_util.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftcb_util.ts?ref=0f54d6c4a58b2839430ce514a84916fa7834fac3",
            "patch": "@@ -7,7 +7,7 @@\n  */\n \n import {AbsoluteSourceSpan, ParseSourceSpan} from '@angular/compiler';\n-import {ClassDeclaration} from '@angular/compiler-cli/src/ngtsc/reflection';\n+import {ClassDeclaration, ReflectionHost} from '@angular/compiler-cli/src/ngtsc/reflection';\n import * as ts from 'typescript';\n \n import {Reference} from '../../imports';\n@@ -16,6 +16,7 @@ import {FullTemplateMapping, SourceLocation, TemplateId, TemplateSourceMapping}\n \n import {hasIgnoreForDiagnosticsMarker, readSpanComment} from './comments';\n import {checkIfClassIsExported, checkIfGenericTypesAreUnbound} from './ts_util';\n+import {TypeParameterEmitter} from './type_parameter_emitter';\n \n /**\n  * Adapter interface which allows the template type-checking diagnostics code to interpret offsets\n@@ -38,25 +39,51 @@ export interface TemplateSourceResolver {\n   toParseSourceSpan(id: TemplateId, span: AbsoluteSourceSpan): ParseSourceSpan|null;\n }\n \n+/**\n+ * Indicates whether a particular component requires an inline type check block.\n+ *\n+ * This is not a boolean state as inlining might only be required to get the best possible\n+ * type-checking, but the component could theoretically still be checked without it.\n+ */\n+export enum TcbInliningRequirement {\n+  /**\n+   * There is no way to type check this component without inlining.\n+   */\n+  MustInline,\n+\n+  /**\n+   * Inlining should be used due to the component's generic bounds, but a non-inlining fallback\n+   * method can be used if that's not possible.\n+   */\n+  ShouldInlineForGenericBounds,\n+\n+  /**\n+   * There is no requirement for this component's TCB to be inlined.\n+   */\n+  None,\n+}\n+\n export function requiresInlineTypeCheckBlock(\n     node: ClassDeclaration<ts.ClassDeclaration>,\n-    usedPipes: Map<string, Reference<ClassDeclaration<ts.ClassDeclaration>>>): boolean {\n+    usedPipes: Map<string, Reference<ClassDeclaration<ts.ClassDeclaration>>>,\n+    reflector: ReflectionHost): TcbInliningRequirement {\n   // In order to qualify for a declared TCB (not inline) two conditions must be met:\n   // 1) the class must be exported\n-  // 2) it must not have constrained generic types\n+  // 2) it must not have contextual generic type bounds\n   if (!checkIfClassIsExported(node)) {\n     // Condition 1 is false, the class is not exported.\n-    return true;\n-  } else if (!checkIfGenericTypesAreUnbound(node)) {\n-    // Condition 2 is false, the class has constrained generic types\n-    return true;\n+    return TcbInliningRequirement.MustInline;\n+  } else if (!checkIfGenericTypeBoundsAreContextFree(node, reflector)) {\n+    // Condition 2 is false, the class has constrained generic types. It should be checked with an\n+    // inline TCB if possible, but can potentially use fallbacks to avoid inlining if not.\n+    return TcbInliningRequirement.ShouldInlineForGenericBounds;\n   } else if (Array.from(usedPipes.values())\n                  .some(pipeRef => !checkIfClassIsExported(pipeRef.node))) {\n     // If one of the pipes used by the component is not exported, a non-inline TCB will not be able\n     // to import it, so this requires an inline TCB.\n-    return true;\n+    return TcbInliningRequirement.MustInline;\n   } else {\n-    return false;\n+    return TcbInliningRequirement.None;\n   }\n }\n \n@@ -147,3 +174,9 @@ function getTemplateId(\n     return commentText;\n   }) as TemplateId || null;\n }\n+\n+export function checkIfGenericTypeBoundsAreContextFree(\n+    node: ClassDeclaration<ts.ClassDeclaration>, reflector: ReflectionHost): boolean {\n+  // Generic type parameters are considered context free if they can be emitted into any context.\n+  return new TypeParameterEmitter(node.typeParameters, reflector).canEmit();\n+}"
        },
        {
            "sha": "cd62b16c39f33192e5c8da6d0344ee6fffdc9159",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.ts",
            "status": "modified",
            "additions": 67,
            "deletions": 22,
            "changes": 89,
            "blob_url": "https://github.com/angular/angular/blob/0f54d6c4a58b2839430ce514a84916fa7834fac3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "raw_url": "https://github.com/angular/angular/raw/0f54d6c4a58b2839430ce514a84916fa7834fac3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts?ref=0f54d6c4a58b2839430ce514a84916fa7834fac3",
            "patch": "@@ -21,8 +21,37 @@ import {Environment} from './environment';\n import {astToTypescript, NULL_AS_ANY} from './expression';\n import {OutOfBandDiagnosticRecorder} from './oob';\n import {ExpressionSemanticVisitor} from './template_semantics';\n-import {checkIfGenericTypesAreUnbound, tsCallMethod, tsCastToAny, tsCreateElement, tsCreateTypeQueryForCoercedInput, tsCreateVariable, tsDeclareVariable} from './ts_util';\n+import {tsCallMethod, tsCastToAny, tsCreateElement, tsCreateTypeQueryForCoercedInput, tsCreateVariable, tsDeclareVariable} from './ts_util';\n import {requiresInlineTypeCtor} from './type_constructor';\n+import {TypeParameterEmitter} from './type_parameter_emitter';\n+\n+/**\n+ * Controls how generics for the component context class will be handled during TCB generation.\n+ */\n+export enum TcbGenericContextBehavior {\n+  /**\n+   * References to generic parameter bounds will be emitted via the `TypeParameterEmitter`.\n+   *\n+   * The caller must verify that all parameter bounds are emittable in order to use this mode.\n+   */\n+  UseEmitter,\n+\n+  /**\n+   * Generic parameter declarations will be copied directly from the `ts.ClassDeclaration` of the\n+   * component class.\n+   *\n+   * The caller must only use the generated TCB code in a context where such copies will still be\n+   * valid, such as an inline type check block.\n+   */\n+  CopyClassNodes,\n+\n+  /**\n+   * Any generic parameters for the component context class will be set to `any`.\n+   *\n+   * Produces a less useful type, but is always safe to use.\n+   */\n+  FallbackToAny,\n+}\n \n /**\n  * Given a `ts.ClassDeclaration` for a component, and metadata regarding that component, compose a\n@@ -45,11 +74,14 @@ import {requiresInlineTypeCtor} from './type_constructor';\n  * and bindings.\n  * @param oobRecorder used to record errors regarding template elements which could not be correctly\n  * translated into types during TCB generation.\n+ * @param genericContextBehavior controls how generic parameters (especially parameters with generic\n+ * bounds) will be referenced from the generated TCB code.\n  */\n export function generateTypeCheckBlock(\n     env: Environment, ref: Reference<ClassDeclaration<ts.ClassDeclaration>>, name: ts.Identifier,\n     meta: TypeCheckBlockMetadata, domSchemaChecker: DomSchemaChecker,\n-    oobRecorder: OutOfBandDiagnosticRecorder): ts.FunctionDeclaration {\n+    oobRecorder: OutOfBandDiagnosticRecorder,\n+    genericContextBehavior: TcbGenericContextBehavior): ts.FunctionDeclaration {\n   const tcb = new Context(\n       env, domSchemaChecker, oobRecorder, meta.id, meta.boundTarget, meta.pipes, meta.schemas);\n   const scope = Scope.forNodes(tcb, null, tcb.boundTarget.target.template !, /* guard */ null);\n@@ -58,7 +90,34 @@ export function generateTypeCheckBlock(\n     throw new Error(\n         `Expected TypeReferenceNode when referencing the ctx param for ${ref.debugName}`);\n   }\n-  const paramList = [tcbCtxParam(ref.node, ctxRawType.typeName, env.config.useContextGenericType)];\n+\n+  let typeParameters: ts.TypeParameterDeclaration[]|undefined = undefined;\n+  let typeArguments: ts.TypeNode[]|undefined = undefined;\n+\n+  if (ref.node.typeParameters !== undefined) {\n+    if (!env.config.useContextGenericType) {\n+      genericContextBehavior = TcbGenericContextBehavior.FallbackToAny;\n+    }\n+\n+    switch (genericContextBehavior) {\n+      case TcbGenericContextBehavior.UseEmitter:\n+        // Guaranteed to emit type parameters since we checked that the class has them above.\n+        typeParameters = new TypeParameterEmitter(ref.node.typeParameters, env.reflector)\n+                             .emit(typeRef => env.referenceType(typeRef))!;\n+        typeArguments = typeParameters.map(param => ts.factory.createTypeReferenceNode(param.name));\n+        break;\n+      case TcbGenericContextBehavior.CopyClassNodes:\n+        typeParameters = [...ref.node.typeParameters];\n+        typeArguments = typeParameters.map(param => ts.factory.createTypeReferenceNode(param.name));\n+        break;\n+      case TcbGenericContextBehavior.FallbackToAny:\n+        typeArguments = ref.node.typeParameters.map(\n+            () => ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n+        break;\n+    }\n+  }\n+\n+  const paramList = [tcbCtxParam(ref.node, ctxRawType.typeName, typeArguments)];\n \n   const scopeStatements = scope.render();\n   const innerBody = ts.createBlock([\n@@ -74,7 +133,7 @@ export function generateTypeCheckBlock(\n       /* modifiers */ undefined,\n       /* asteriskToken */ undefined,\n       /* name */ name,\n-      /* typeParameters */ env.config.useContextGenericType ? ref.node.typeParameters : undefined,\n+      /* typeParameters */ env.config.useContextGenericType ? typeParameters : undefined,\n       /* parameters */ paramList,\n       /* type */ undefined,\n       /* body */ body);\n@@ -1571,27 +1630,13 @@ interface TcbBoundInput {\n }\n \n /**\n- * Create the `ctx` parameter to the top-level TCB function.\n- *\n- * This is a parameter with a type equivalent to the component type, with all generic type\n- * parameters listed (without their generic bounds).\n+ * Create the `ctx` parameter to the top-level TCB function, with the given generic type arguments.\n  */\n function tcbCtxParam(\n     node: ClassDeclaration<ts.ClassDeclaration>, name: ts.EntityName,\n-    useGenericType: boolean): ts.ParameterDeclaration {\n-  let typeArguments: ts.TypeNode[]|undefined = undefined;\n-  // Check if the component is generic, and pass generic type parameters if so.\n-  if (node.typeParameters !== undefined) {\n-    if (useGenericType) {\n-      typeArguments =\n-          node.typeParameters.map(param => ts.createTypeReferenceNode(param.name, undefined));\n-    } else {\n-      typeArguments =\n-          node.typeParameters.map(() => ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n-    }\n-  }\n-  const type = ts.createTypeReferenceNode(name, typeArguments);\n-  return ts.createParameter(\n+    typeArguments: ts.TypeNode[]|undefined): ts.ParameterDeclaration {\n+  const type = ts.factory.createTypeReferenceNode(name, typeArguments);\n+  return ts.factory.createParameterDeclaration(\n       /* decorators */ undefined,\n       /* modifiers */ undefined,\n       /* dotDotDotToken */ undefined,"
        },
        {
            "sha": "a121bd46df6a729d32b1ef545b44d2b27a15749f",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_check_file.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/0f54d6c4a58b2839430ce514a84916fa7834fac3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_file.ts",
            "raw_url": "https://github.com/angular/angular/raw/0f54d6c4a58b2839430ce514a84916fa7834fac3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_file.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_file.ts?ref=0f54d6c4a58b2839430ce514a84916fa7834fac3",
            "patch": "@@ -16,7 +16,7 @@ import {TypeCheckBlockMetadata, TypeCheckingConfig} from '../api';\n import {DomSchemaChecker} from './dom';\n import {Environment} from './environment';\n import {OutOfBandDiagnosticRecorder} from './oob';\n-import {generateTypeCheckBlock} from './type_check_block';\n+import {generateTypeCheckBlock, TcbGenericContextBehavior} from './type_check_block';\n \n \n \n@@ -43,9 +43,11 @@ export class TypeCheckFile extends Environment {\n \n   addTypeCheckBlock(\n       ref: Reference<ClassDeclaration<ts.ClassDeclaration>>, meta: TypeCheckBlockMetadata,\n-      domSchemaChecker: DomSchemaChecker, oobRecorder: OutOfBandDiagnosticRecorder): void {\n+      domSchemaChecker: DomSchemaChecker, oobRecorder: OutOfBandDiagnosticRecorder,\n+      genericContextBehavior: TcbGenericContextBehavior): void {\n     const fnId = ts.createIdentifier(`_tcb${this.nextTcbId++}`);\n-    const fn = generateTypeCheckBlock(this, ref, fnId, meta, domSchemaChecker, oobRecorder);\n+    const fn = generateTypeCheckBlock(\n+        this, ref, fnId, meta, domSchemaChecker, oobRecorder, genericContextBehavior);\n     this.tcbStatements.push(fn);\n   }\n "
        },
        {
            "sha": "e6d3927407f8c03aaf028a01b768b2fe42bbc6c6",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_constructor.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 7,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/0f54d6c4a58b2839430ce514a84916fa7834fac3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_constructor.ts",
            "raw_url": "https://github.com/angular/angular/raw/0f54d6c4a58b2839430ce514a84916fa7834fac3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_constructor.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_constructor.ts?ref=0f54d6c4a58b2839430ce514a84916fa7834fac3",
            "patch": "@@ -10,9 +10,9 @@ import * as ts from 'typescript';\n \n import {ClassDeclaration, ReflectionHost} from '../../reflection';\n import {TypeCtorMetadata} from '../api';\n+import {checkIfGenericTypeBoundsAreContextFree} from './tcb_util';\n \n import {tsCreateTypeQueryForCoercedInput} from './ts_util';\n-import {TypeParameterEmitter} from './type_parameter_emitter';\n \n export function generateTypeCtorDeclarationFn(\n     node: ClassDeclaration<ts.ClassDeclaration>, meta: TypeCtorMetadata, nodeTypeRef: ts.EntityName,\n@@ -196,12 +196,6 @@ export function requiresInlineTypeCtor(\n   return !checkIfGenericTypeBoundsAreContextFree(node, host);\n }\n \n-function checkIfGenericTypeBoundsAreContextFree(\n-    node: ClassDeclaration<ts.ClassDeclaration>, reflector: ReflectionHost): boolean {\n-  // Generic type parameters are considered context free if they can be emitted into any context.\n-  return new TypeParameterEmitter(node.typeParameters, reflector).canEmit();\n-}\n-\n /**\n  * Add a default `= any` to type parameters that don't have a default value already.\n  *"
        },
        {
            "sha": "34bbc260233d0a5f9bc71a52bdafc5a4a483f6a0",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/test_utils.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 8,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/0f54d6c4a58b2839430ce514a84916fa7834fac3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/0f54d6c4a58b2839430ce514a84916fa7834fac3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts?ref=0f54d6c4a58b2839430ce514a84916fa7834fac3",
            "patch": "@@ -28,7 +28,7 @@ import {DomSchemaChecker} from '../src/dom';\n import {Environment} from '../src/environment';\n import {OutOfBandDiagnosticRecorder} from '../src/oob';\n import {TypeCheckShimGenerator} from '../src/shim';\n-import {generateTypeCheckBlock} from '../src/type_check_block';\n+import {generateTypeCheckBlock, TcbGenericContextBehavior} from '../src/type_check_block';\n import {TypeCheckFile} from '../src/type_check_file';\n \n export function typescriptLibDts(): TestFile {\n@@ -290,13 +290,9 @@ export function tcb(\n \n   const env = new TypeCheckFile(fileName, fullConfig, refEmmiter, reflectionHost, host);\n \n-  const ref = new Reference(clazz);\n-\n-  const tcb = generateTypeCheckBlock(\n-      env, ref, ts.createIdentifier('Test_TCB'), meta, new NoopSchemaChecker(),\n-      new NoopOobRecorder());\n-\n-  env.addTypeCheckBlock(ref, meta, new NoopSchemaChecker(), new NoopOobRecorder());\n+  env.addTypeCheckBlock(\n+      new Reference(clazz), meta, new NoopSchemaChecker(), new NoopOobRecorder(),\n+      TcbGenericContextBehavior.UseEmitter);\n \n   const rendered = env.render(!options.emitSpans /* removeComments */);\n   return rendered.replace(/\\s+/g, ' ');"
        },
        {
            "sha": "c65aeca52f7b5da6625a7f867b5096c46dbece6a",
            "filename": "packages/language-service/ivy/test/diagnostic_spec.ts",
            "status": "modified",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/0f54d6c4a58b2839430ce514a84916fa7834fac3/packages%2Flanguage-service%2Fivy%2Ftest%2Fdiagnostic_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/0f54d6c4a58b2839430ce514a84916fa7834fac3/packages%2Flanguage-service%2Fivy%2Ftest%2Fdiagnostic_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fdiagnostic_spec.ts?ref=0f54d6c4a58b2839430ce514a84916fa7834fac3",
            "patch": "@@ -276,6 +276,26 @@ describe('getSemanticDiagnostics', () => {\n     expect(getTextOfDiagnostic(diag)).toBe('user');\n   });\n \n+  it('should process a component that would otherwise require an inline TCB', () => {\n+    const files = {\n+      'app.ts': `\n+        import {Component, NgModule} from '@angular/core';\n+        import {CommonModule} from '@angular/common';\n+\n+        interface PrivateInterface {}\n+\n+        @Component({\n+          template: 'Simple template',\n+        })\n+        export class MyComponent<T extends PrivateInterface> {}\n+      `\n+    };\n+\n+    const project = createModuleAndProjectWithDeclarations(env, 'test', files);\n+    const diags = project.getDiagnosticsForFile('app.ts');\n+    expect(diags.length).toBe(0);\n+  });\n+\n   it('logs perf tracing', () => {\n     const files = {\n       'app.ts': `"
        },
        {
            "sha": "a17c880195b01b42f1b11081d1871b4b19179df9",
            "filename": "packages/language-service/ivy/testing/src/util.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/0f54d6c4a58b2839430ce514a84916fa7834fac3/packages%2Flanguage-service%2Fivy%2Ftesting%2Fsrc%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/0f54d6c4a58b2839430ce514a84916fa7834fac3/packages%2Flanguage-service%2Fivy%2Ftesting%2Fsrc%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftesting%2Fsrc%2Futil.ts?ref=0f54d6c4a58b2839430ce514a84916fa7834fac3",
            "patch": "@@ -38,7 +38,7 @@ export function isNgSpecificDiagnostic(diag: ts.Diagnostic): boolean {\n }\n \n function getFirstClassDeclaration(declaration: string) {\n-  const matches = declaration.match(/(?:export class )(\\w+)(?:\\s|\\{)/);\n+  const matches = declaration.match(/(?:export class )(\\w+)(?:\\s|\\{|<)/);\n   if (matches === null || matches.length !== 2) {\n     throw new Error(`Did not find exactly one exported class in: ${declaration}`);\n   }"
        }
    ],
    "stats": {
        "total": 230,
        "additions": 169,
        "deletions": 61
    }
}