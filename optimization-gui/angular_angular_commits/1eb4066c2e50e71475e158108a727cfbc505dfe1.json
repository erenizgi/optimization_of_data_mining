{
    "author": "atscott",
    "message": "refactor(compiler-cli): Expose API for mappping from TCB to template location (#39715)\n\nConsumers of the `TemplateTypeChecker` API could be interested in\nmapping from a shim location back to the original source location in the\ntemplate. One concrete example of this use-case is for the \"find\nreferences\" action in the Language Service. This will return locations\nin the TypeScript shim file, and we will then need to be able to map the\nresult back to the template.\n\nPR Close #39715",
    "sha": "1eb4066c2e50e71475e158108a727cfbc505dfe1",
    "files": [
        {
            "sha": "014fa84036742b94c66e36e39a5faa08b2efe40f",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/api.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 1,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fapi.ts?ref=1eb4066c2e50e71475e158108a727cfbc505dfe1",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {BoundTarget, DirectiveMeta, SchemaMetadata} from '@angular/compiler';\n+import {AbsoluteSourceSpan, BoundTarget, DirectiveMeta, ParseSourceSpan, SchemaMetadata} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {AbsoluteFsPath} from '../../file_system';\n@@ -306,6 +306,24 @@ export interface ExternalTemplateSourceMapping {\n   templateUrl: string;\n }\n \n+/**\n+ * A mapping of a TCB template id to a span in the corresponding template source.\n+ */\n+export interface SourceLocation {\n+  id: TemplateId;\n+  span: AbsoluteSourceSpan;\n+}\n+\n+/**\n+ * A representation of all a node's template mapping information we know. Useful for producing\n+ * diagnostics based on a TCB node or generally mapping from a TCB node back to a template location.\n+ */\n+export interface FullTemplateMapping {\n+  sourceLocation: SourceLocation;\n+  templateSourceMapping: TemplateSourceMapping;\n+  span: ParseSourceSpan;\n+}\n+\n /**\n  * Abstracts the operation of determining which shim file will host a particular component's\n  * template type-checking code."
        },
        {
            "sha": "366d059625031984bf2bd471964c575ee3d037c8",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/checker.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 1,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fchecker.ts?ref=1eb4066c2e50e71475e158108a727cfbc505dfe1",
            "patch": "@@ -9,9 +9,10 @@\n import {AST, ParseError, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\n import * as ts from 'typescript';\n \n+import {FullTemplateMapping} from './api';\n import {GlobalCompletion} from './completion';\n import {DirectiveInScope, PipeInScope} from './scope';\n-import {Symbol} from './symbols';\n+import {ShimLocation, Symbol} from './symbols';\n \n /**\n  * Interface to the Angular Template Type Checker to extract diagnostics and intelligence from the\n@@ -66,6 +67,12 @@ export interface TemplateTypeChecker {\n    */\n   getDiagnosticsForFile(sf: ts.SourceFile, optimizeFor: OptimizeFor): ts.Diagnostic[];\n \n+  /**\n+   * Given a `shim` and position within the file, returns information for mapping back to a template\n+   * location.\n+   */\n+  getTemplateMappingAtShimLocation(shimLocation: ShimLocation): FullTemplateMapping|null;\n+\n   /**\n    * Get all `ts.Diagnostic`s currently available that pertain to the given component.\n    *"
        },
        {
            "sha": "2e77230c88b4b67e5009bbfeaed88d8e0e07701b",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts",
            "status": "modified",
            "additions": 30,
            "deletions": 5,
            "changes": 35,
            "blob_url": "https://github.com/angular/angular/blob/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts?ref=1eb4066c2e50e71475e158108a727cfbc505dfe1",
            "patch": "@@ -6,24 +6,24 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AST, ParseError, parseTemplate, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\n+import {AST, ParseError, parseTemplate, TmplAstNode, TmplAstTemplate,} from '@angular/compiler';\n import * as ts from 'typescript';\n \n-import {absoluteFromSourceFile, AbsoluteFsPath, getSourceFileOrError} from '../../file_system';\n+import {absoluteFrom, absoluteFromSourceFile, AbsoluteFsPath, getSourceFileOrError} from '../../file_system';\n import {ReferenceEmitter} from '../../imports';\n import {IncrementalBuild} from '../../incremental/api';\n import {isNamedClassDeclaration, ReflectionHost} from '../../reflection';\n import {ComponentScopeReader} from '../../scope';\n import {isShim} from '../../shims';\n import {getSourceFileOrNull} from '../../util/src/typescript';\n-import {CompletionKind, DirectiveInScope, GlobalCompletion, OptimizeFor, PipeInScope, ProgramTypeCheckAdapter, Symbol, TemplateId, TemplateTypeChecker, TypeCheckingConfig, TypeCheckingProgramStrategy, UpdateMode} from '../api';\n+import {DirectiveInScope, FullTemplateMapping, GlobalCompletion, OptimizeFor, PipeInScope, ProgramTypeCheckAdapter, ShimLocation, Symbol, TemplateId, TemplateTypeChecker, TypeCheckingConfig, TypeCheckingProgramStrategy, UpdateMode} from '../api';\n import {TemplateDiagnostic} from '../diagnostics';\n \n-import {ExpressionIdentifier, findFirstMatchingNode} from './comments';\n import {CompletionEngine} from './completion';\n import {InliningMode, ShimTypeCheckingData, TemplateData, TypeCheckContextImpl, TypeCheckingHost} from './context';\n-import {findTypeCheckBlock, shouldReportDiagnostic, TemplateSourceResolver, translateDiagnostic} from './diagnostics';\n+import {shouldReportDiagnostic, translateDiagnostic} from './diagnostics';\n import {TemplateSourceManager} from './source';\n+import {findTypeCheckBlock, getTemplateMapping, TemplateSourceResolver} from './tcb_util';\n import {SymbolBuilder} from './template_symbol_builder';\n \n /**\n@@ -172,6 +172,31 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     return {nodes};\n   }\n \n+  private getFileAndShimRecordsForPath(shimPath: AbsoluteFsPath):\n+      {fileRecord: FileTypeCheckingData, shimRecord: ShimTypeCheckingData}|null {\n+    for (const fileRecord of this.state.values()) {\n+      if (fileRecord.shimData.has(shimPath)) {\n+        return {fileRecord, shimRecord: fileRecord.shimData.get(shimPath)!};\n+      }\n+    }\n+    return null;\n+  }\n+\n+  getTemplateMappingAtShimLocation({shimPath, positionInShimFile}: ShimLocation):\n+      FullTemplateMapping|null {\n+    const records = this.getFileAndShimRecordsForPath(absoluteFrom(shimPath));\n+    if (records === null) {\n+      return null;\n+    }\n+    const {fileRecord} = records;\n+\n+    const shimSf = this.typeCheckingStrategy.getProgram().getSourceFile(absoluteFrom(shimPath));\n+    if (shimSf === undefined) {\n+      return null;\n+    }\n+    return getTemplateMapping(shimSf, positionInShimFile, fileRecord.sourceManager);\n+  }\n+\n   /**\n    * Retrieve type-checking diagnostics from the given `ts.SourceFile` using the most recent\n    * type-checking program."
        },
        {
            "sha": "e122c3e94bb2a96dc4da43bb4fc43a27d4432063",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/context.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts",
            "raw_url": "https://github.com/angular/angular/raw/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts?ref=1eb4066c2e50e71475e158108a727cfbc505dfe1",
            "patch": "@@ -20,7 +20,8 @@ import {DomSchemaChecker, RegistryDomSchemaChecker} from './dom';\n import {Environment} from './environment';\n import {OutOfBandDiagnosticRecorder, OutOfBandDiagnosticRecorderImpl} from './oob';\n import {TemplateSourceManager} from './source';\n-import {generateTypeCheckBlock, requiresInlineTypeCheckBlock} from './type_check_block';\n+import {requiresInlineTypeCheckBlock} from './tcb_util';\n+import {generateTypeCheckBlock} from './type_check_block';\n import {TypeCheckFile} from './type_check_file';\n import {generateInlineTypeCtor, requiresInlineTypeCtor} from './type_constructor';\n "
        },
        {
            "sha": "02a22ef2925b3d238e00d8035c409067aca57cce",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/diagnostics.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 108,
            "changes": 114,
            "blob_url": "https://github.com/angular/angular/blob/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fdiagnostics.ts",
            "raw_url": "https://github.com/angular/angular/raw/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fdiagnostics.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fdiagnostics.ts?ref=1eb4066c2e50e71475e158108a727cfbc505dfe1",
            "patch": "@@ -7,34 +7,10 @@\n  */\n import {AbsoluteSourceSpan, ParseSourceSpan} from '@angular/compiler';\n import * as ts from 'typescript';\n-\n-import {getTokenAtPosition} from '../../util/src/typescript';\n-import {TemplateId, TemplateSourceMapping} from '../api';\n+import {TemplateId} from '../api';\n import {makeTemplateDiagnostic, TemplateDiagnostic} from '../diagnostics';\n+import {getTemplateMapping, TemplateSourceResolver} from './tcb_util';\n \n-import {hasIgnoreMarker, readSpanComment} from './comments';\n-\n-\n-/**\n- * Adapter interface which allows the template type-checking diagnostics code to interpret offsets\n- * in a TCB and map them back to original locations in the template.\n- */\n-export interface TemplateSourceResolver {\n-  getTemplateId(node: ts.ClassDeclaration): TemplateId;\n-\n-  /**\n-   * For the given template id, retrieve the original source mapping which describes how the offsets\n-   * in the template should be interpreted.\n-   */\n-  getSourceMapping(id: TemplateId): TemplateSourceMapping;\n-\n-  /**\n-   * Convert an absolute source span associated with the given template id into a full\n-   * `ParseSourceSpan`. The returned parse span has line and column numbers in addition to only\n-   * absolute offsets and gives access to the original template source.\n-   */\n-  toParseSourceSpan(id: TemplateId, span: AbsoluteSourceSpan): ParseSourceSpan|null;\n-}\n \n /**\n  * Wraps the node in parenthesis such that inserted span comments become attached to the proper\n@@ -115,91 +91,13 @@ export function translateDiagnostic(\n   if (diagnostic.file === undefined || diagnostic.start === undefined) {\n     return null;\n   }\n-\n-  // Locate the node that the diagnostic is reported on and determine its location in the source.\n-  const node = getTokenAtPosition(diagnostic.file, diagnostic.start);\n-  const sourceLocation = findSourceLocation(node, diagnostic.file);\n-  if (sourceLocation === null) {\n-    return null;\n-  }\n-\n-  // Now use the external resolver to obtain the full `ParseSourceFile` of the template.\n-  const span = resolver.toParseSourceSpan(sourceLocation.id, sourceLocation.span);\n-  if (span === null) {\n+  const fullMapping = getTemplateMapping(diagnostic.file, diagnostic.start, resolver);\n+  if (fullMapping === null) {\n     return null;\n   }\n \n-  const mapping = resolver.getSourceMapping(sourceLocation.id);\n+  const {sourceLocation, templateSourceMapping, span} = fullMapping;\n   return makeTemplateDiagnostic(\n-      sourceLocation.id, mapping, span, diagnostic.category, diagnostic.code,\n+      sourceLocation.id, templateSourceMapping, span, diagnostic.category, diagnostic.code,\n       diagnostic.messageText);\n }\n-\n-export function findTypeCheckBlock(file: ts.SourceFile, id: TemplateId): ts.Node|null {\n-  for (const stmt of file.statements) {\n-    if (ts.isFunctionDeclaration(stmt) && getTemplateId(stmt, file) === id) {\n-      return stmt;\n-    }\n-  }\n-  return null;\n-}\n-\n-interface SourceLocation {\n-  id: TemplateId;\n-  span: AbsoluteSourceSpan;\n-}\n-\n-/**\n- * Traverses up the AST starting from the given node to extract the source location from comments\n- * that have been emitted into the TCB. If the node does not exist within a TCB, or if an ignore\n- * marker comment is found up the tree, this function returns null.\n- */\n-function findSourceLocation(node: ts.Node, sourceFile: ts.SourceFile): SourceLocation|null {\n-  // Search for comments until the TCB's function declaration is encountered.\n-  while (node !== undefined && !ts.isFunctionDeclaration(node)) {\n-    if (hasIgnoreMarker(node, sourceFile)) {\n-      // There's an ignore marker on this node, so the diagnostic should not be reported.\n-      return null;\n-    }\n-\n-    const span = readSpanComment(node, sourceFile);\n-    if (span !== null) {\n-      // Once the positional information has been extracted, search further up the TCB to extract\n-      // the unique id that is attached with the TCB's function declaration.\n-      const id = getTemplateId(node, sourceFile);\n-      if (id === null) {\n-        return null;\n-      }\n-      return {id, span};\n-    }\n-\n-    node = node.parent;\n-  }\n-\n-  return null;\n-}\n-\n-function getTemplateId(node: ts.Node, sourceFile: ts.SourceFile): TemplateId|null {\n-  // Walk up to the function declaration of the TCB, the file information is attached there.\n-  while (!ts.isFunctionDeclaration(node)) {\n-    if (hasIgnoreMarker(node, sourceFile)) {\n-      // There's an ignore marker on this node, so the diagnostic should not be reported.\n-      return null;\n-    }\n-    node = node.parent;\n-\n-    // Bail once we have reached the root.\n-    if (node === undefined) {\n-      return null;\n-    }\n-  }\n-\n-  const start = node.getFullStart();\n-  return ts.forEachLeadingCommentRange(sourceFile.text, start, (pos, end, kind) => {\n-    if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n-      return null;\n-    }\n-    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n-    return commentText;\n-  }) as TemplateId || null;\n-}"
        },
        {
            "sha": "3ce5ac5322c73cd420e73705993c7365706651dc",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/dom.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fdom.ts",
            "raw_url": "https://github.com/angular/angular/raw/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fdom.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fdom.ts?ref=1eb4066c2e50e71475e158108a727cfbc505dfe1",
            "patch": "@@ -13,7 +13,7 @@ import {ErrorCode, ngErrorCode} from '../../diagnostics';\n import {TemplateId} from '../api';\n import {makeTemplateDiagnostic, TemplateDiagnostic} from '../diagnostics';\n \n-import {TemplateSourceResolver} from './diagnostics';\n+import {TemplateSourceResolver} from './tcb_util';\n \n const REGISTRY = new DomElementSchemaRegistry();\n const REMOVE_XHTML_REGEX = /^:xhtml:/;"
        },
        {
            "sha": "aaec8d792774d1db9b51a4c64117637b55823dbc",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/oob.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Foob.ts",
            "raw_url": "https://github.com/angular/angular/raw/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Foob.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Foob.ts?ref=1eb4066c2e50e71475e158108a727cfbc505dfe1",
            "patch": "@@ -14,7 +14,7 @@ import {ClassDeclaration} from '../../reflection';\n import {TemplateId} from '../api';\n import {makeTemplateDiagnostic, TemplateDiagnostic} from '../diagnostics';\n \n-import {TemplateSourceResolver} from './diagnostics';\n+import {TemplateSourceResolver} from './tcb_util';\n \n \n "
        },
        {
            "sha": "8bd6877576400c3b9f29c033be5a5125b96d258d",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/source.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fsource.ts",
            "raw_url": "https://github.com/angular/angular/raw/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fsource.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fsource.ts?ref=1eb4066c2e50e71475e158108a727cfbc505dfe1",
            "patch": "@@ -12,8 +12,8 @@ import * as ts from 'typescript';\n import {TemplateId, TemplateSourceMapping} from '../api';\n import {getTemplateId} from '../diagnostics';\n \n-import {TemplateSourceResolver} from './diagnostics';\n import {computeLineStartsMap, getLineAndCharacterFromPosition} from './line_mappings';\n+import {TemplateSourceResolver} from './tcb_util';\n \n /**\n  * Represents the source of a template that was processed during type-checking. This information is"
        },
        {
            "sha": "16ac8b874fa6ae53e8301fe0832b7026d0a61e93",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/tcb_util.ts",
            "status": "added",
            "additions": 135,
            "deletions": 0,
            "changes": 135,
            "blob_url": "https://github.com/angular/angular/blob/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftcb_util.ts",
            "raw_url": "https://github.com/angular/angular/raw/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftcb_util.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftcb_util.ts?ref=1eb4066c2e50e71475e158108a727cfbc505dfe1",
            "patch": "@@ -0,0 +1,135 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import {AbsoluteSourceSpan, ParseSourceSpan} from '@angular/compiler';\n+import {ClassDeclaration} from '@angular/compiler-cli/src/ngtsc/reflection';\n+import * as ts from 'typescript';\n+\n+import {getTokenAtPosition} from '../../util/src/typescript';\n+import {FullTemplateMapping, SourceLocation, TemplateId, TemplateSourceMapping} from '../api';\n+\n+import {hasIgnoreMarker, readSpanComment} from './comments';\n+import {checkIfClassIsExported, checkIfGenericTypesAreUnbound} from './ts_util';\n+\n+/**\n+ * Adapter interface which allows the template type-checking diagnostics code to interpret offsets\n+ * in a TCB and map them back to original locations in the template.\n+ */\n+export interface TemplateSourceResolver {\n+  getTemplateId(node: ts.ClassDeclaration): TemplateId;\n+\n+  /**\n+   * For the given template id, retrieve the original source mapping which describes how the offsets\n+   * in the template should be interpreted.\n+   */\n+  getSourceMapping(id: TemplateId): TemplateSourceMapping;\n+\n+  /**\n+   * Convert an absolute source span associated with the given template id into a full\n+   * `ParseSourceSpan`. The returned parse span has line and column numbers in addition to only\n+   * absolute offsets and gives access to the original template source.\n+   */\n+  toParseSourceSpan(id: TemplateId, span: AbsoluteSourceSpan): ParseSourceSpan|null;\n+}\n+\n+export function requiresInlineTypeCheckBlock(node: ClassDeclaration<ts.ClassDeclaration>): boolean {\n+  // In order to qualify for a declared TCB (not inline) two conditions must be met:\n+  // 1) the class must be exported\n+  // 2) it must not have constrained generic types\n+  if (!checkIfClassIsExported(node)) {\n+    // Condition 1 is false, the class is not exported.\n+    return true;\n+  } else if (!checkIfGenericTypesAreUnbound(node)) {\n+    // Condition 2 is false, the class has constrained generic types\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+/** Maps a shim position back to a template location. */\n+export function getTemplateMapping(\n+    shimSf: ts.SourceFile, position: number, resolver: TemplateSourceResolver): FullTemplateMapping|\n+    null {\n+  const node = getTokenAtPosition(shimSf, position);\n+  const sourceLocation = findSourceLocation(node, shimSf);\n+  if (sourceLocation === null) {\n+    return null;\n+  }\n+\n+  const mapping = resolver.getSourceMapping(sourceLocation.id);\n+  const span = resolver.toParseSourceSpan(sourceLocation.id, sourceLocation.span);\n+  if (span === null) {\n+    return null;\n+  }\n+  return {sourceLocation, templateSourceMapping: mapping, span};\n+}\n+\n+export function findTypeCheckBlock(file: ts.SourceFile, id: TemplateId): ts.Node|null {\n+  for (const stmt of file.statements) {\n+    if (ts.isFunctionDeclaration(stmt) && getTemplateId(stmt, file) === id) {\n+      return stmt;\n+    }\n+  }\n+  return null;\n+}\n+\n+/**\n+ * Traverses up the AST starting from the given node to extract the source location from comments\n+ * that have been emitted into the TCB. If the node does not exist within a TCB, or if an ignore\n+ * marker comment is found up the tree, this function returns null.\n+ */\n+export function findSourceLocation(node: ts.Node, sourceFile: ts.SourceFile): SourceLocation|null {\n+  // Search for comments until the TCB's function declaration is encountered.\n+  while (node !== undefined && !ts.isFunctionDeclaration(node)) {\n+    if (hasIgnoreMarker(node, sourceFile)) {\n+      // There's an ignore marker on this node, so the diagnostic should not be reported.\n+      return null;\n+    }\n+\n+    const span = readSpanComment(node, sourceFile);\n+    if (span !== null) {\n+      // Once the positional information has been extracted, search further up the TCB to extract\n+      // the unique id that is attached with the TCB's function declaration.\n+      const id = getTemplateId(node, sourceFile);\n+      if (id === null) {\n+        return null;\n+      }\n+      return {id, span};\n+    }\n+\n+    node = node.parent;\n+  }\n+\n+  return null;\n+}\n+\n+function getTemplateId(node: ts.Node, sourceFile: ts.SourceFile): TemplateId|null {\n+  // Walk up to the function declaration of the TCB, the file information is attached there.\n+  while (!ts.isFunctionDeclaration(node)) {\n+    if (hasIgnoreMarker(node, sourceFile)) {\n+      // There's an ignore marker on this node, so the diagnostic should not be reported.\n+      return null;\n+    }\n+    node = node.parent;\n+\n+    // Bail once we have reached the root.\n+    if (node === undefined) {\n+      return null;\n+    }\n+  }\n+\n+  const start = node.getFullStart();\n+  return ts.forEachLeadingCommentRange(sourceFile.text, start, (pos, end, kind) => {\n+    if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n+      return null;\n+    }\n+    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n+    return commentText;\n+  }) as TemplateId || null;\n+}"
        },
        {
            "sha": "9b37884e49f271b6e290d2e985191cae711559c7",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 16,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "raw_url": "https://github.com/angular/angular/raw/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts?ref=1eb4066c2e50e71475e158108a727cfbc505dfe1",
            "patch": "@@ -21,7 +21,7 @@ import {Environment} from './environment';\n import {astToTypescript, NULL_AS_ANY} from './expression';\n import {OutOfBandDiagnosticRecorder} from './oob';\n import {ExpressionSemanticVisitor} from './template_semantics';\n-import {checkIfClassIsExported, checkIfGenericTypesAreUnbound, tsCallMethod, tsCastToAny, tsCreateElement, tsCreateTypeQueryForCoercedInput, tsCreateVariable, tsDeclareVariable} from './ts_util';\n+import {tsCallMethod, tsCastToAny, tsCreateElement, tsCreateTypeQueryForCoercedInput, tsCreateVariable, tsDeclareVariable} from './ts_util';\n \n /**\n  * Given a `ts.ClassDeclaration` for a component, and metadata regarding that component, compose a\n@@ -1867,18 +1867,3 @@ class TcbEventHandlerTranslator extends TcbExpressionTranslator {\n     return super.resolve(ast);\n   }\n }\n-\n-export function requiresInlineTypeCheckBlock(node: ClassDeclaration<ts.ClassDeclaration>): boolean {\n-  // In order to qualify for a declared TCB (not inline) two conditions must be met:\n-  // 1) the class must be exported\n-  // 2) it must not have constrained generic types\n-  if (!checkIfClassIsExported(node)) {\n-    // Condition 1 is false, the class is not exported.\n-    return true;\n-  } else if (!checkIfGenericTypesAreUnbound(node)) {\n-    // Condition 2 is false, the class has constrained generic types\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}"
        },
        {
            "sha": "9343f6e6a594633cfc1256af61762f535da48830",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker__get_symbol_of_template_node_spec.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/1eb4066c2e50e71475e158108a727cfbc505dfe1/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts?ref=1eb4066c2e50e71475e158108a727cfbc505dfe1",
            "patch": "@@ -99,6 +99,11 @@ runInEachFileSystem(() => {\n       expect(\n           (symbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration).name.getText())\n           .toEqual('name');\n+\n+      // Ensure we can go back to the original location using the shim location\n+      const mapping =\n+          templateTypeChecker.getTemplateMappingAtShimLocation(symbol.bindings[0].shimLocation)!;\n+      expect(mapping.span.toString()).toEqual('name');\n     });\n \n     describe('templates', () => {\n@@ -155,6 +160,14 @@ runInEachFileSystem(() => {\n           assertVariableSymbol(symbol);\n           expect(program.getTypeChecker().typeToString(symbol.tsType!)).toEqual('any');\n           expect(symbol.declaration.name).toEqual('contextFoo');\n+\n+          // Ensure we can map the shim locations back to the template\n+          const initializerMapping =\n+              templateTypeChecker.getTemplateMappingAtShimLocation(symbol.initializerLocation)!;\n+          expect(initializerMapping.span.toString()).toEqual('bar');\n+          const localVarMapping =\n+              templateTypeChecker.getTemplateMappingAtShimLocation(symbol.localVarLocation)!;\n+          expect(localVarMapping.span.toString()).toEqual('contextFoo');\n         });\n \n         it('should get a symbol for local ref which refers to a directive', () => {\n@@ -170,6 +183,11 @@ runInEachFileSystem(() => {\n           assertReferenceSymbol(symbol);\n           expect(program.getTypeChecker().symbolToString(symbol.tsSymbol)).toEqual('TestDir');\n           assertDirectiveReference(symbol);\n+\n+          // Ensure we can map the var shim location back to the template\n+          const localVarMapping =\n+              templateTypeChecker.getTemplateMappingAtShimLocation(symbol.referenceVarLocation);\n+          expect(localVarMapping!.span.toString()).toEqual('ref1');\n         });\n \n         function assertDirectiveReference(symbol: ReferenceSymbol) {"
        }
    ],
    "stats": {
        "total": 357,
        "additions": 222,
        "deletions": 135
    }
}