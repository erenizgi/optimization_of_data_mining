{
    "author": "petebacondarwin",
    "message": "fix(localize): relax error to warning for missing target (#41944)\n\nSome localization workflows want to use the extracted source translation\nfiles directy back in the project as a target translation file.\n\nThe extraction process generates files that only contain \"source\" messages\nand not \"target\" messages. This is actually valid for most translation formats\nbut currently the Angular localization process expects target translation files\nto always contain target messages and will stop with an error in this case.\n\nNow, instead of an error, the translation file loader will log a warning,\nand then try to falback to a source message, only erroring if this is also\nmissing.\n\nFixes #21690\n\nPR Close #41944",
    "sha": "992c70df590151522bfeee7567a89ac9c4a108f1",
    "files": [
        {
            "sha": "2dd951ffe4c09cb28b87054e10434bfd9e3da9f4",
            "filename": "packages/localize/src/tools/src/translate/translation_files/translation_parsers/xliff1_translation_parser.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 5,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/992c70df590151522bfeee7567a89ac9c4a108f1/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Ftranslate%2Ftranslation_files%2Ftranslation_parsers%2Fxliff1_translation_parser.ts",
            "raw_url": "https://github.com/angular/angular/raw/992c70df590151522bfeee7567a89ac9c4a108f1/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Ftranslate%2Ftranslation_files%2Ftranslation_parsers%2Fxliff1_translation_parser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Ftranslate%2Ftranslation_files%2Ftranslation_parsers%2Fxliff1_translation_parser.ts?ref=992c70df590151522bfeee7567a89ac9c4a108f1",
            "patch": "@@ -140,13 +140,23 @@ class XliffTranslationVisitor extends BaseVisitor {\n       return;\n     }\n \n-    // Error if there is no `<target>` child element\n-    const targetMessage = element.children.find(isNamedElement('target'));\n+    let targetMessage = element.children.find(isNamedElement('target'));\n     if (targetMessage === undefined) {\n+      // Warn if there is no `<target>` child element\n       addParseDiagnostic(\n-          bundle.diagnostics, element.sourceSpan, 'Missing required <target> element',\n-          ParseErrorLevel.ERROR);\n-      return;\n+          bundle.diagnostics, element.sourceSpan, 'Missing <target> element',\n+          ParseErrorLevel.WARNING);\n+\n+      // Fallback to the `<source>` element if available.\n+      targetMessage = element.children.find(isNamedElement('source'));\n+      if (targetMessage === undefined) {\n+        // Error if there is neither `<target>` nor `<source>`.\n+        addParseDiagnostic(\n+            bundle.diagnostics, element.sourceSpan,\n+            'Missing required element: one of <target> or <source> is required',\n+            ParseErrorLevel.ERROR);\n+        return;\n+      }\n     }\n \n     const {translation, parseErrors, serializeErrors} = serializeTranslationMessage(targetMessage, {"
        },
        {
            "sha": "b47d9c1ff8f44c190c42396ccc7fe19ff00996c9",
            "filename": "packages/localize/src/tools/src/translate/translation_files/translation_parsers/xliff2_translation_parser.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 4,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/992c70df590151522bfeee7567a89ac9c4a108f1/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Ftranslate%2Ftranslation_files%2Ftranslation_parsers%2Fxliff2_translation_parser.ts",
            "raw_url": "https://github.com/angular/angular/raw/992c70df590151522bfeee7567a89ac9c4a108f1/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Ftranslate%2Ftranslation_files%2Ftranslation_parsers%2Fxliff2_translation_parser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flocalize%2Fsrc%2Ftools%2Fsrc%2Ftranslate%2Ftranslation_files%2Ftranslation_parsers%2Fxliff2_translation_parser.ts?ref=992c70df590151522bfeee7567a89ac9c4a108f1",
            "patch": "@@ -132,12 +132,23 @@ class Xliff2TranslationVisitor extends BaseVisitor {\n       return;\n     }\n \n-    const targetMessage = element.children.find(isNamedElement('target'));\n+    let targetMessage = element.children.find(isNamedElement('target'));\n     if (targetMessage === undefined) {\n+      // Warn if there is no `<target>` child element\n       addParseDiagnostic(\n-          bundle.diagnostics, element.sourceSpan, 'Missing required <target> element',\n-          ParseErrorLevel.ERROR);\n-      return;\n+          bundle.diagnostics, element.sourceSpan, 'Missing <target> element',\n+          ParseErrorLevel.WARNING);\n+\n+      // Fallback to the `<source>` element if available.\n+      targetMessage = element.children.find(isNamedElement('source'));\n+      if (targetMessage === undefined) {\n+        // Error if there is neither `<target>` nor `<source>`.\n+        addParseDiagnostic(\n+            bundle.diagnostics, element.sourceSpan,\n+            'Missing required element: one of <target> or <source> is required',\n+            ParseErrorLevel.ERROR);\n+        return;\n+      }\n     }\n \n     const {translation, parseErrors, serializeErrors} = serializeTranslationMessage(targetMessage, {"
        },
        {
            "sha": "4eea42a389cb518ad32ca3d956a4c2ea438d4375",
            "filename": "packages/localize/src/tools/test/translate/translation_files/translation_parsers/xliff1_translation_parser_spec.ts",
            "status": "modified",
            "additions": 779,
            "deletions": 743,
            "changes": 1522,
            "blob_url": "https://github.com/angular/angular/blob/992c70df590151522bfeee7567a89ac9c4a108f1/packages%2Flocalize%2Fsrc%2Ftools%2Ftest%2Ftranslate%2Ftranslation_files%2Ftranslation_parsers%2Fxliff1_translation_parser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/992c70df590151522bfeee7567a89ac9c4a108f1/packages%2Flocalize%2Fsrc%2Ftools%2Ftest%2Ftranslate%2Ftranslation_files%2Ftranslation_parsers%2Fxliff1_translation_parser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flocalize%2Fsrc%2Ftools%2Ftest%2Ftranslate%2Ftranslation_files%2Ftranslation_parsers%2Fxliff1_translation_parser_spec.ts?ref=992c70df590151522bfeee7567a89ac9c4a108f1",
            "patch": "@@ -9,754 +9,790 @@ import {ɵcomputeMsgId, ɵmakeParsedTranslation} from '@angular/localize';\n import {ParseAnalysis, ParsedTranslationBundle} from '../../../../src/translate/translation_files/translation_parsers/translation_parser';\n import {Xliff1TranslationParser} from '../../../../src/translate/translation_files/translation_parsers/xliff1_translation_parser';\n \n-describe('Xliff1TranslationParser', () => {\n-  describe('canParse()', () => {\n-    it('should return true only if the file contains an <xliff> element with version=\"1.2\" attribute',\n-       () => {\n-         const parser = new Xliff1TranslationParser();\n-         expect(parser.canParse(\n-                    '/some/file.xlf',\n-                    '<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">'))\n-             .toBeTruthy();\n-         expect(parser.canParse(\n-                    '/some/file.json',\n-                    '<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">'))\n-             .toBeTruthy();\n-         expect(parser.canParse('/some/file.xliff', '<xliff version=\"1.2\">')).toBeTruthy();\n-         expect(parser.canParse('/some/file.json', '<xliff version=\"1.2\">')).toBeTruthy();\n-         expect(parser.canParse('/some/file.xlf', '<xliff>')).toBe(false);\n-         expect(parser.canParse('/some/file.xlf', '<xliff version=\"2.0\">')).toBe(false);\n-         expect(parser.canParse('/some/file.xlf', '')).toBe(false);\n-         expect(parser.canParse('/some/file.json', '')).toBe(false);\n-       });\n-  });\n-\n-  describe('analyze()', () => {\n-    it('should return a success object if the file contains an <xliff> element with version=\"1.2\" attribute',\n-       () => {\n-         const parser = new Xliff1TranslationParser();\n-         expect(parser.analyze('/some/file.xlf', '<xliff version=\"1.2\">'))\n-             .toEqual(jasmine.objectContaining({canParse: true, hint: jasmine.any(Object)}));\n-         expect(parser.analyze('/some/file.json', '<xliff version=\"1.2\">'))\n-             .toEqual(jasmine.objectContaining({canParse: true, hint: jasmine.any(Object)}));\n-         expect(parser.analyze('/some/file.xliff', '<xliff version=\"1.2\">'))\n-             .toEqual(jasmine.objectContaining({canParse: true, hint: jasmine.any(Object)}));\n-         expect(parser.analyze('/some/file.json', '<xliff version=\"1.2\">'))\n-             .toEqual(jasmine.objectContaining({canParse: true, hint: jasmine.any(Object)}));\n-       });\n-\n-    it('should return a failure object if the file cannot be parsed as XLIFF 1.2', () => {\n-      const parser = new Xliff1TranslationParser();\n-      expect(parser.analyze('/some/file.xlf', '<xliff>')).toEqual(jasmine.objectContaining({\n-        canParse: false\n-      }));\n-      expect(parser.analyze('/some/file.xlf', '<xliff version=\"2.0\">'))\n-          .toEqual(jasmine.objectContaining({canParse: false}));\n-      expect(parser.analyze('/some/file.xlf', '')).toEqual(jasmine.objectContaining({\n-        canParse: false\n-      }));\n-      expect(parser.analyze('/some/file.json', '')).toEqual(jasmine.objectContaining({\n-        canParse: false\n-      }));\n-    });\n-\n-    it('should return a diagnostics object when the file is not a valid format', () => {\n-      let result: ParseAnalysis<any>;\n-      const parser = new Xliff1TranslationParser();\n-\n-      result = parser.analyze('/some/file.xlf', '<moo>');\n-      expect(result.diagnostics.messages).toEqual([\n-        {type: 'warning', message: 'The XML file does not contain a <xliff> root node.'}\n-      ]);\n-\n-      result = parser.analyze('/some/file.xlf', '<xliff version=\"2.0\">');\n-      expect(result.diagnostics.messages).toEqual([{\n-        type: 'warning',\n-        message:\n-            'The <xliff> node does not have the required attribute: version=\"1.2\". (\"[WARNING ->]<xliff version=\"2.0\">\"): /some/file.xlf@0:0'\n-      }]);\n-\n-      result = parser.analyze('/some/file.xlf', '<xliff version=\"1.2\"></file>');\n-      expect(result.diagnostics.messages).toEqual([{\n-        type: 'error',\n-        message:\n-            'Unexpected closing tag \"file\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags (\"<xliff version=\"1.2\">[ERROR ->]</file>\"): /some/file.xlf@0:21'\n-      }]);\n-    });\n-  });\n-\n-  for (const withHint of [true, false]) {\n-    describe(`parse() [${withHint ? 'with' : 'without'} hint]`, () => {\n-      const doParse: (fileName: string, XLIFF: string) => ParsedTranslationBundle =\n-          withHint ? (fileName, XLIFF) => {\n-            const parser = new Xliff1TranslationParser();\n-            const hint = parser.canParse(fileName, XLIFF);\n-            if (!hint) {\n-              throw new Error('expected XLIFF to be valid');\n-            }\n-            return parser.parse(fileName, XLIFF, hint);\n-          } : (fileName, XLIFF) => {\n-            const parser = new Xliff1TranslationParser();\n-            return parser.parse(fileName, XLIFF);\n-          };\n-\n-      const expectToFail:\n-          (fileName: string, XLIFF: string, errorMatcher: RegExp, diagnosticMessage: string) =>\n-              void = withHint ? (fileName, XLIFF, _errorMatcher, diagnosticMessage) => {\n-                const result = doParse(fileName, XLIFF);\n-                expect(result.diagnostics.messages.length).toEqual(1);\n-                expect(result.diagnostics.messages[0].message).toEqual(diagnosticMessage);\n-              } : (fileName, XLIFF, errorMatcher, _diagnosticMessage) => {\n-                expect(() => doParse(fileName, XLIFF)).toThrowError(errorMatcher);\n-              };\n-\n-      it('should extract the locale from the last `<file>` element to contain a `target-language` attribute',\n-         () => {\n-           const XLIFF = [\n-             `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-             `  <file source-language=\"en\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-             `    <body></body>`,\n-             `  </file>`,\n-             `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-             `    <body></body>`,\n-             `  </file>`,\n-             `  <file source-language=\"en\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-             `    <body></body>`,\n-             `  </file>`,\n-             `  <file source-language=\"en\" target-language=\"de\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-             `    <body></body>`,\n-             `  </file>`,\n-             `  <file source-language=\"en\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-             `    <body></body>`,\n-             `  </file>`,\n-             `</xliff>`,\n-           ].join('\\n');\n-           const result = doParse('/some/file.xlf', XLIFF);\n-           expect(result.locale).toEqual('de');\n-         });\n-\n-      it('should return an undefined locale if there is no locale in the file', () => {\n-        const XLIFF = [\n-          `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-          `  <file source-language=\"en\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-          `    <body>`,\n-          `    </body>`,\n-          `  </file>`,\n-          `</xliff>`,\n-        ].join('\\n');\n-        const result = doParse('/some/file.xlf', XLIFF);\n-        expect(result.locale).toBeUndefined();\n-      });\n-\n-      it('should extract basic messages', () => {\n-        /**\n-         * Source HTML:\n-         *\n-         * ```\n-         * <div i18n>translatable attribute</div>\n-         * ```\n-         */\n-        const XLIFF = [\n-          `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-          `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-          `    <body>`,\n-          `      <trans-unit id=\"1933478729560469763\" datatype=\"html\">`,\n-          `        <source>translatable attribute</source>`,\n-          `        <target>etubirtta elbatalsnart</target>`,\n-          `        <context-group purpose=\"location\">`,\n-          `          <context context-type=\"sourcefile\">file.ts</context>`,\n-          `          <context context-type=\"linenumber\">1</context>`,\n-          `        </context-group>`,\n-          `      </trans-unit>`,\n-          `    </body>`,\n-          `  </file>`,\n-          `</xliff>`,\n-        ].join('\\n');\n-        const result = doParse('/some/file.xlf', XLIFF);\n-\n-        expect(result.translations[ɵcomputeMsgId('translatable attribute')])\n-            .toEqual(ɵmakeParsedTranslation(['etubirtta elbatalsnart']));\n-      });\n-\n-      it('should extract translations with simple placeholders', () => {\n-        /**\n-         * Source HTML:\n-         *\n-         * ```\n-         * <div i18n>translatable element <b>with placeholders</b> {{ interpolation}}</div>\n-         * ```\n-         */\n-        const XLIFF = [\n-          `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-          `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-          `    <body>`,\n-          `      <trans-unit id=\"5057824347511785081\" datatype=\"html\">`,\n-          `        <source>translatable element <x id=\"START_BOLD_TEXT\" ctype=\"b\"/>with placeholders<x id=\"CLOSE_BOLD_TEXT\" ctype=\"b\"/> <x id=\"INTERPOLATION\"/></source>`,\n-          `        <target><x id=\"INTERPOLATION\"/> tnemele elbatalsnart <x id=\"START_BOLD_TEXT\" ctype=\"x-b\"/>sredlohecalp htiw<x id=\"CLOSE_BOLD_TEXT\" ctype=\"x-b\"/></target>`,\n-          `        <context-group purpose=\"location\">`,\n-          `          <context context-type=\"sourcefile\">file.ts</context>`,\n-          `          <context context-type=\"linenumber\">2</context>`,\n-          `        </context-group>`,\n-          `      </trans-unit>`,\n-          `    </body>`,\n-          `  </file>`,\n-          `</xliff>`,\n-        ].join('\\n');\n-        const result = doParse('/some/file.xlf', XLIFF);\n-\n-        expect(\n-            result.translations[ɵcomputeMsgId(\n-                'translatable element {$START_BOLD_TEXT}with placeholders{$LOSE_BOLD_TEXT} {$INTERPOLATION}')])\n-            .toEqual(ɵmakeParsedTranslation(\n-                ['', ' tnemele elbatalsnart ', 'sredlohecalp htiw', ''],\n-                ['INTERPOLATION', 'START_BOLD_TEXT', 'CLOSE_BOLD_TEXT']));\n-      });\n-\n-      it('should extract nested placeholder containers (i.e. nested HTML elements)', () => {\n-        /**\n-         * Source HTML:\n-         *\n-         * ```\n-         * <div i18n>\n-         *   translatable <span>element <b>with placeholders</b></span> {{ interpolation}}\n-         * </div>\n-         * ```\n-         */\n-        const XLIFF = [\n-          `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-          `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-          `    <body>`,\n-          `      <trans-unit id=\"9051630253697141670\" datatype=\"html\">`,\n-          `        <source>translatable <x id=\"START_TAG_SPAN\"/>element <x id=\"START_BOLD_TEXT\"/>with placeholders<x id=\"CLOSE_BOLD_TEXT\"/><x id=\"CLOSE_TAG_SPAN\"/> <x id=\"INTERPOLATION\"/></source>`,\n-          `        <target><x id=\"START_TAG_SPAN\"/><x id=\"INTERPOLATION\"/> tnemele<x id=\"CLOSE_TAG_SPAN\"/> elbatalsnart <x id=\"START_BOLD_TEXT\"/>sredlohecalp htiw<x id=\"CLOSE_BOLD_TEXT\"/></target>`,\n-          `        <context-group purpose=\"location\">`,\n-          `          <context context-type=\"sourcefile\">file.ts</context>`,\n-          `          <context context-type=\"linenumber\">3</context>`,\n-          `        </context-group>`,\n-          `      </trans-unit>`,\n-          `    </body>`,\n-          `  </file>`,\n-          `</xliff>`,\n-        ].join('\\n');\n-        const result = doParse('/some/file.xlf', XLIFF);\n-        expect(result.translations[ɵcomputeMsgId(\n-                   'translatable {$START_TAG_SPAN}element {$START_BOLD_TEXT}with placeholders' +\n-                   '{$CLOSE_BOLD_TEXT}{$CLOSE_TAG_SPAN} {$INTERPOLATION}')])\n-            .toEqual(ɵmakeParsedTranslation(\n-                ['', '', ' tnemele', ' elbatalsnart ', 'sredlohecalp htiw', ''], [\n-                  'START_TAG_SPAN',\n-                  'INTERPOLATION',\n-                  'CLOSE_TAG_SPAN',\n-                  'START_BOLD_TEXT',\n-                  'CLOSE_BOLD_TEXT',\n-                ]));\n-      });\n-\n-      it('should extract translations with placeholders containing hyphens', () => {\n-        /**\n-         * Source HTML:\n-         *\n-         * ```\n-         * <div i18n><app-my-component></app-my-component> Welcome</div>\n-         * ```\n-         */\n-        const XLIFF = [\n-          `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-          `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-          `    <body>`,\n-          `      <trans-unit id=\"2877147807876214810\" datatype=\"html\">`,\n-          `        <source><x id=\"START_TAG_APP-MY-COMPONENT\" ctype=\"x-app-my-component\" equiv-text=\"&lt;app-my-component&gt;\"/><x id=\"CLOSE_TAG_APP-MY-COMPONENT\" ctype=\"x-app-my-component\" equiv-text=\"&lt;/app-my-component&gt;\"/> Welcome</source>`,\n-          `        <context-group purpose=\"location\">`,\n-          `          <context context-type=\"sourcefile\">src/app/app.component.html</context>`,\n-          `          <context context-type=\"linenumber\">1</context>`,\n-          `        </context-group>`,\n-          `        <target><x id=\"START_TAG_APP-MY-COMPONENT\" ctype=\"x-app-my-component\" equiv-text=\"&lt;app-my-component&gt;\"/><x id=\"CLOSE_TAG_APP-MY-COMPONENT\" ctype=\"x-app-my-component\" equiv-text=\"&lt;/app-my-component&gt;\"/> Translate</target>`,\n-          `      </trans-unit>`,\n-          `    </body>`,\n-          `  </file>`,\n-          `</xliff>`,\n-        ].join('\\n');\n-        const result = doParse('/some/file.xlf', XLIFF);\n-        const id =\n-            ɵcomputeMsgId('{$START_TAG_APP_MY_COMPONENT}{$CLOSE_TAG_APP_MY_COMPONENT} Welcome');\n-        expect(result.translations[id]).toEqual(ɵmakeParsedTranslation(['', '', ' Translate'], [\n-          'START_TAG_APP_MY_COMPONENT', 'CLOSE_TAG_APP_MY_COMPONENT'\n-        ]));\n-      });\n-\n-      it('should extract translations with simple ICU expressions', () => {\n-        /**\n-         * Source HTML:\n-         *\n-         * ```\n-         * <div i18n>{VAR_PLURAL, plural, =0 {<p>test</p>} }</div>\n-         * ```\n-         */\n-        const XLIFF = [\n-          `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-          `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-          `    <body>`,\n-          `      <trans-unit id=\"2874455947211586270\" datatype=\"html\">`,\n-          `        <source>{VAR_PLURAL, plural, =0 {<x id=\"START_PARAGRAPH\" ctype=\"x-p\"/>test<x id=\"CLOSE_PARAGRAPH\" ctype=\"x-p\"/>} }</source>`,\n-          `        <target>{VAR_PLURAL, plural, =0 {<x id=\"START_PARAGRAPH\" ctype=\"x-p\"/>TEST<x id=\"CLOSE_PARAGRAPH\" ctype=\"x-p\"/>} }</target>`,\n-          `      </trans-unit>`,\n-          `    </body>`,\n-          `  </file>`,\n-          `</xliff>`,\n-        ].join('\\n');\n-        const result = doParse('/some/file.xlf', XLIFF);\n-\n-        expect(result.translations[ɵcomputeMsgId(\n-                   '{VAR_PLURAL, plural, =0 {{START_PARAGRAPH}test{CLOSE_PARAGRAPH}}}')])\n-            .toEqual(ɵmakeParsedTranslation(\n-                ['{VAR_PLURAL, plural, =0 {{START_PARAGRAPH}TEST{CLOSE_PARAGRAPH}}}'], []));\n-      });\n-\n-      it('should extract translations with duplicate source messages', () => {\n-        /**\n-         * Source HTML:\n-         *\n-         * ```\n-         * <div i18n>foo</div>\n-         * <div i18n=\"m|d@@i\">foo</div>\n-         * <div i18=\"\"m|d@@bar>foo</div>\n-         * ```\n-         */\n-        const XLIFF = [\n-          `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-          `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-          `    <body>`,\n-          `      <trans-unit id=\"9205907420411818817\" datatype=\"html\">`,\n-          `        <source>foo</source>`,\n-          `        <target>oof</target>`,\n-          `        <context-group purpose=\"location\">`,\n-          `          <context context-type=\"sourcefile\">file.ts</context>`,\n-          `          <context context-type=\"linenumber\">3</context>`,\n-          `        </context-group>`,\n-          `        <note priority=\"1\" from=\"description\">d</note>`,\n-          `        <note priority=\"1\" from=\"meaning\">m</note>`,\n-          `      </trans-unit>`,\n-          `      <trans-unit id=\"i\" datatype=\"html\">`,\n-          `        <source>foo</source>`,\n-          `        <target>toto</target>`,\n-          `        <context-group purpose=\"location\">`,\n-          `          <context context-type=\"sourcefile\">file.ts</context>`,\n-          `          <context context-type=\"linenumber\">4</context>`,\n-          `        </context-group>`,\n-          `        <note priority=\"1\" from=\"description\">d</note>`,\n-          `        <note priority=\"1\" from=\"meaning\">m</note>`,\n-          `      </trans-unit>`,\n-          `      <trans-unit id=\"bar\" datatype=\"html\">`,\n-          `        <source>foo</source>`,\n-          `        <target>tata</target>`,\n-          `        <context-group purpose=\"location\">`,\n-          `          <context context-type=\"sourcefile\">file.ts</context>`,\n-          `          <context context-type=\"linenumber\">5</context>`,\n-          `        </context-group>`,\n-          `      </trans-unit>`,\n-          `    </body>`,\n-          `  </file>`,\n-          `</xliff>`,\n-        ].join('\\n');\n-        const result = doParse('/some/file.xlf', XLIFF);\n-\n-        expect(result.translations[ɵcomputeMsgId('foo')]).toEqual(ɵmakeParsedTranslation(['oof']));\n-        expect(result.translations['i']).toEqual(ɵmakeParsedTranslation(['toto']));\n-        expect(result.translations['bar']).toEqual(ɵmakeParsedTranslation(['tata']));\n-      });\n-\n-      it('should extract translations with only placeholders, which are re-ordered', () => {\n-        /**\n-         * Source HTML:\n-         *\n-         * ```\n-         * <div i18n><br><img/><img/></div>\n-         * ```\n-         */\n-        const XLIFF = [\n-          `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-          `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-          `    <body>`,\n-          `      <trans-unit id=\"7118057989405618448\" datatype=\"html\">`,\n-          `      <ph id=\"1\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/&gt;\"/><ph id=\"2\" equiv=\"TAG_IMG_1\" type=\"image\" disp=\"&lt;img/&gt;\"/>`,\n-          `        <source><x id=\"LINE_BREAK\" ctype=\"lb\"/><x id=\"TAG_IMG\" ctype=\"image\"/><x id=\"TAG_IMG_1\" ctype=\"image\"/></source>`,\n-          `        <target><x id=\"TAG_IMG_1\" ctype=\"image\"/><x id=\"TAG_IMG\" ctype=\"image\"/><x id=\"LINE_BREAK\" ctype=\"lb\"/></target>`,\n-          `        <context-group purpose=\"location\">`,\n-          `          <context context-type=\"sourcefile\">file.ts</context>`,\n-          `          <context context-type=\"linenumber\">6</context>`,\n-          `        </context-group>`,\n-          `        <note priority=\"1\" from=\"description\">ph names</note>`,\n-          `      </trans-unit>`,\n-          `    </body>`,\n-          `  </file>`,\n-          `</xliff>`,\n-        ].join('\\n');\n-        const result = doParse('/some/file.xlf', XLIFF);\n-\n-        expect(result.translations[ɵcomputeMsgId('{$LINE_BREAK}{$TAG_IMG}{$TAG_IMG_1}')])\n-            .toEqual(\n-                ɵmakeParsedTranslation(['', '', '', ''], ['TAG_IMG_1', 'TAG_IMG', 'LINE_BREAK']));\n-      });\n-\n-      it('should extract translations with empty target', () => {\n-        /**\n-         * Source HTML:\n-         *\n-         * ```\n-         * <div i18n>hello <span></span></div>\n-         * ```\n-         */\n-        const XLIFF = [\n-          `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-          `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-          `    <body>`,\n-          `      <trans-unit id=\"2826198357052921524\" datatype=\"html\">`,\n-          `        <source>hello <x id=\"START_TAG_SPAN\" ctype=\"x-span\"/><x id=\"CLOSE_TAG_SPAN\" ctype=\"x-span\"/></source>`,\n-          `        <target/>`,\n-          `        <context-group purpose=\"location\">`,\n-          `          <context context-type=\"sourcefile\">file.ts</context>`,\n-          `          <context context-type=\"linenumber\">6</context>`,\n-          `        </context-group>`,\n-          `        <note priority=\"1\" from=\"description\">ph names</note>`,\n-          `      </trans-unit>`,\n-          `    </body>`,\n-          `  </file>`,\n-          `</xliff>`,\n-        ].join('\\n');\n-        const result = doParse('/some/file.xlf', XLIFF);\n-\n-        expect(result.translations[ɵcomputeMsgId('hello {$START_TAG_SPAN}{$CLOSE_TAG_SPAN}')])\n-            .toEqual(ɵmakeParsedTranslation(['']));\n-      });\n-\n-      it('should extract translations with deeply nested ICUs', () => {\n-        /**\n-         * Source HTML:\n-         *\n-         * ```\n-         * Test: { count, plural, =0 { { sex, select, other {<p>deeply nested</p>}} } =other {a\n-         * lot}}\n-         * ```\n-         *\n-         * Note that the message gets split into two translation units:\n-         *  * The first one contains the outer message with an `ICU` placeholder\n-         *  * The second one is the ICU expansion itself\n-         *\n-         * Note that special markers `VAR_PLURAL` and `VAR_SELECT` are added, which are then\n-         * replaced by IVY at runtime with the actual values being rendered by the ICU expansion.\n-         */\n-        const XLIFF = [\n-          `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-          `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-          `    <body>`,\n-          `      <trans-unit id=\"980940425376233536\" datatype=\"html\">`,\n-          `        <source>Test: <x id=\"ICU\" equiv-text=\"{ count, plural, =0 {...} =other {...}}\"/></source>`,\n-          `        <target>Le test: <x id=\"ICU\" equiv-text=\"{ count, plural, =0 {...} =other {...}}\"/></target>`,\n-          `        <context-group purpose=\"location\">`,\n-          `          <context context-type=\"sourcefile\">file.ts</context>`,\n-          `          <context context-type=\"linenumber\">11</context>`,\n-          `        </context-group>`,\n-          `      </trans-unit>`,\n-          `      <trans-unit id=\"5207293143089349404\" datatype=\"html\">`,\n-          `        <source>{VAR_PLURAL, plural, =0 {{VAR_SELECT, select, other {<x id=\"START_PARAGRAPH\" ctype=\"x-p\"/>deeply nested<x id=\"CLOSE_PARAGRAPH\" ctype=\"x-p\"/>}}} =other {a lot}}</source>`,\n-          `        <target>{VAR_PLURAL, plural, =0 {{VAR_SELECT, select, other {<x id=\"START_PARAGRAPH\" ctype=\"x-p\"/>profondément imbriqué<x id=\"CLOSE_PARAGRAPH\" ctype=\"x-p\"/>}}} =other {beaucoup}}</target>`,\n-          `      </trans-unit>`,\n-          `    </body>`,\n-          `  </file>`,\n-          `</xliff>`,\n-        ].join('\\n');\n-        const result = doParse('/some/file.xlf', XLIFF);\n-\n-        expect(result.translations[ɵcomputeMsgId('Test: {$ICU}')])\n-            .toEqual(ɵmakeParsedTranslation(['Le test: ', ''], ['ICU']));\n-\n-        expect(\n-            result.translations[ɵcomputeMsgId(\n-                '{VAR_PLURAL, plural, =0 {{VAR_SELECT, select, other {{START_PARAGRAPH}deeply nested{CLOSE_PARAGRAPH}}}} =other {beaucoup}}')])\n-            .toEqual(ɵmakeParsedTranslation([\n-              '{VAR_PLURAL, plural, =0 {{VAR_SELECT, select, other {{START_PARAGRAPH}profondément imbriqué{CLOSE_PARAGRAPH}}}} =other {beaucoup}}'\n-            ]));\n-      });\n-\n-      it('should extract translations containing multiple lines', () => {\n-        /**\n-         * Source HTML:\n-         *\n-         * ```\n-         * <div i18n>multi\n-         * lines</div>\n-         * ```\n-         */\n-        const XLIFF = [\n-          `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-          `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-          `    <body>`,\n-          `      <trans-unit id=\"2340165783990709777\" datatype=\"html\">`,\n-          `        <source>multi\\nlines</source>`,\n-          `        <target>multi\\nlignes</target>`,\n-          `        <context-group purpose=\"location\">`,\n-          `          <context context-type=\"sourcefile\">file.ts</context>`,\n-          `          <context context-type=\"linenumber\">12</context>`,\n-          `        </context-group>`,\n-          `      </trans-unit>`,\n-          `    </body>`,\n-          `  </file>`,\n-          `</xliff>`,\n-        ].join('\\n');\n-        const result = doParse('/some/file.xlf', XLIFF);\n-\n-        expect(result.translations[ɵcomputeMsgId('multi\\nlines')])\n-            .toEqual(ɵmakeParsedTranslation(['multi\\nlignes']));\n-      });\n-\n-      it('should extract translations with <mrk> elements', () => {\n-        const XLIFF = [\n-          `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-          `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-          `    <body>`,\n-          `      <trans-unit id=\"mrk-test\">`,\n-          `        <source>First sentence.</source>`,\n-          `        <seg-source>`,\n-          `          <invalid-tag>Should not be parsed</invalid-tag>`,\n-          `        </seg-source>`,\n-          `        <target>Translated <mrk mtype=\"seg\" mid=\"1\">first sentence</mrk>.</target>`,\n-          `      </trans-unit>`,\n-          `      <trans-unit id=\"mrk-test2\">`,\n-          `        <source>First sentence. Second sentence.</source>`,\n-          `        <seg-source>`,\n-          `          <invalid-tag>Should not be parsed</invalid-tag>`,\n-          `        </seg-source>`,\n-          `        <target>Translated <mrk mtype=\"seg\" mid=\"1\"><mrk mtype=\"seg\" mid=\"2\">first</mrk> sentence</mrk>.</target>`,\n-          `      </trans-unit>`,\n-          `    </body>`,\n-          `  </file>`,\n-          `</xliff>`,\n-        ].join('\\n');\n-        const result = doParse('/some/file.xlf', XLIFF);\n-\n-        expect(result.translations['mrk-test'])\n-            .toEqual(ɵmakeParsedTranslation(['Translated first sentence.']));\n-\n-        expect(result.translations['mrk-test2'])\n-            .toEqual(ɵmakeParsedTranslation(['Translated first sentence.']));\n-      });\n-\n-      it('should ignore alt-trans targets', () => {\n-        const XLIFF = [\n-          `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-          `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-          `    <body>`,\n-          `      <trans-unit datatype=\"html\" approved=\"no\" id=\"registration.submit\">`,\n-          `        <source>Continue</source>`,\n-          `        <target state=\"translated\" xml:lang=\"de\">Weiter</target>`,\n-          `        <context-group purpose=\"location\">`,\n-          `          <context context-type=\"sourcefile\">src/app/auth/registration-form/registration-form.component.html</context>`,\n-          `          <context context-type=\"linenumber\">69</context>`,\n-          `        </context-group>`,\n-          `        <?sid 1110954287-0?>`,\n-          `        <alt-trans origin=\"autoFuzzy\" tool=\"Swordfish\" match-quality=\"71\" ts=\"63\">`,\n-          `          <source xml:lang=\"en\">Content</source>`,\n-          `          <target state=\"translated\" xml:lang=\"de\">Content</target>`,\n-          `        </alt-trans>`,\n-          `    </trans-unit>`,\n-          `    </body>`,\n-          `  </file>`,\n-          `</xliff>`,\n-        ].join('\\n');\n-\n-        const result = doParse('/some/file.xlf', XLIFF);\n-        expect(result.translations['registration.submit'])\n-            .toEqual(ɵmakeParsedTranslation(['Weiter']));\n+describe(\n+    'Xliff1TranslationParser', () => {\n+      describe('canParse()', () => {\n+        it('should return true only if the file contains an <xliff> element with version=\"1.2\" attribute',\n+           () => {\n+             const parser = new Xliff1TranslationParser();\n+             expect(parser.canParse(\n+                        '/some/file.xlf',\n+                        '<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">'))\n+                 .toBeTruthy();\n+             expect(parser.canParse(\n+                        '/some/file.json',\n+                        '<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">'))\n+                 .toBeTruthy();\n+             expect(parser.canParse('/some/file.xliff', '<xliff version=\"1.2\">')).toBeTruthy();\n+             expect(parser.canParse('/some/file.json', '<xliff version=\"1.2\">')).toBeTruthy();\n+             expect(parser.canParse('/some/file.xlf', '<xliff>')).toBe(false);\n+             expect(parser.canParse('/some/file.xlf', '<xliff version=\"2.0\">')).toBe(false);\n+             expect(parser.canParse('/some/file.xlf', '')).toBe(false);\n+             expect(parser.canParse('/some/file.json', '')).toBe(false);\n+           });\n       });\n \n-      it('should merge messages from each `<file>` element', () => {\n-        /**\n-         * Source HTML:\n-         *\n-         * ```\n-         * <div i18n>translatable attribute</div>\n-         * ```\n-\n-         * ```\n-         * <div i18n>translatable element <b>with placeholders</b> {{ interpolation}}</div>\n-         * ```\n-         */\n-        const XLIFF = [\n-          `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-          `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"file-1\">`,\n-          `    <body>`,\n-          `      <trans-unit id=\"1933478729560469763\" datatype=\"html\">`,\n-          `        <source>translatable attribute</source>`,\n-          `        <target>etubirtta elbatalsnart</target>`,\n-          `        <context-group purpose=\"location\">`,\n-          `          <context context-type=\"sourcefile\">file.ts</context>`,\n-          `          <context context-type=\"linenumber\">1</context>`,\n-          `        </context-group>`,\n-          `      </trans-unit>`,\n-          `    </body>`,\n-          `  </file>`,\n-          `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"file-2\">`,\n-          `    <body>`,\n-          `      <trans-unit id=\"5057824347511785081\" datatype=\"html\">`,\n-          `        <source>translatable element <x id=\"START_BOLD_TEXT\" ctype=\"b\"/>with placeholders<x id=\"CLOSE_BOLD_TEXT\" ctype=\"b\"/> <x id=\"INTERPOLATION\"/></source>`,\n-          `        <target><x id=\"INTERPOLATION\"/> tnemele elbatalsnart <x id=\"START_BOLD_TEXT\" ctype=\"x-b\"/>sredlohecalp htiw<x id=\"CLOSE_BOLD_TEXT\" ctype=\"x-b\"/></target>`,\n-          `        <context-group purpose=\"location\">`,\n-          `          <context context-type=\"sourcefile\">file.ts</context>`,\n-          `          <context context-type=\"linenumber\">2</context>`,\n-          `        </context-group>`,\n-          `      </trans-unit>`,\n-          `    </body>`,\n-          `  </file>`,\n-          `</xliff>`,\n-        ].join('\\n');\n-        const result = doParse('/some/file.xlf', XLIFF);\n-        expect(result.translations[ɵcomputeMsgId('translatable attribute')])\n-            .toEqual(ɵmakeParsedTranslation(['etubirtta elbatalsnart']));\n-        expect(\n-            result.translations[ɵcomputeMsgId(\n-                'translatable element {$START_BOLD_TEXT}with placeholders{$LOSE_BOLD_TEXT} {$INTERPOLATION}')])\n-            .toEqual(ɵmakeParsedTranslation(\n-                ['', ' tnemele elbatalsnart ', 'sredlohecalp htiw', ''],\n-                ['INTERPOLATION', 'START_BOLD_TEXT', 'CLOSE_BOLD_TEXT']));\n-      });\n-\n-      describe('[structure errors]', () => {\n-        it('should fail when a trans-unit has no translation', () => {\n-          const XLIFF = [\n-            `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n-            `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-            `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-            `    <body>`,\n-            `      <trans-unit id=\"missingtarget\">`,\n-            `        <source/>`,\n-            `      </trans-unit>`,\n-            `    </body>`,\n-            `  </file>`,\n-            `</xliff>`,\n-          ].join('\\n');\n-\n-          expectToFail('/some/file.xlf', XLIFF, /Missing required <target> element/, [\n-            `Missing required <target> element (\"e-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-            `    <body>`,\n-            `      [ERROR ->]<trans-unit id=\"missingtarget\">`,\n-            `        <source/>`,\n-            `      </trans-unit>`,\n-            `\"): /some/file.xlf@4:6`,\n-          ].join('\\n'));\n-        });\n-\n-\n-        it('should fail when a trans-unit has no id attribute', () => {\n-          const XLIFF = [\n-            `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n-            `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-            `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-            `    <body>`,\n-            `      <trans-unit datatype=\"html\">`,\n-            `        <source/>`,\n-            `        <target/>`,\n-            `      </trans-unit>`,\n-            `    </body>`,\n-            `  </file>`,\n-            `</xliff>`,\n-          ].join('\\n');\n-\n-          expectToFail('/some/file.xlf', XLIFF, /Missing required \"id\" attribute/, [\n-            `Missing required \"id\" attribute on <trans-unit> element. (\"e-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-            `    <body>`,\n-            `      [ERROR ->]<trans-unit datatype=\"html\">`,\n-            `        <source/>`,\n-            `        <target/>`,\n-            `\"): /some/file.xlf@4:6`,\n-          ].join('\\n'));\n+      describe('analyze()', () => {\n+        it('should return a success object if the file contains an <xliff> element with version=\"1.2\" attribute',\n+           () => {\n+             const parser = new Xliff1TranslationParser();\n+             expect(parser.analyze('/some/file.xlf', '<xliff version=\"1.2\">'))\n+                 .toEqual(jasmine.objectContaining({canParse: true, hint: jasmine.any(Object)}));\n+             expect(parser.analyze('/some/file.json', '<xliff version=\"1.2\">'))\n+                 .toEqual(jasmine.objectContaining({canParse: true, hint: jasmine.any(Object)}));\n+             expect(parser.analyze('/some/file.xliff', '<xliff version=\"1.2\">'))\n+                 .toEqual(jasmine.objectContaining({canParse: true, hint: jasmine.any(Object)}));\n+             expect(parser.analyze('/some/file.json', '<xliff version=\"1.2\">'))\n+                 .toEqual(jasmine.objectContaining({canParse: true, hint: jasmine.any(Object)}));\n+           });\n+\n+        it('should return a failure object if the file cannot be parsed as XLIFF 1.2', () => {\n+          const parser = new Xliff1TranslationParser();\n+          expect(parser.analyze('/some/file.xlf', '<xliff>')).toEqual(jasmine.objectContaining({\n+            canParse: false\n+          }));\n+          expect(parser.analyze('/some/file.xlf', '<xliff version=\"2.0\">'))\n+              .toEqual(jasmine.objectContaining({canParse: false}));\n+          expect(parser.analyze('/some/file.xlf', '')).toEqual(jasmine.objectContaining({\n+            canParse: false\n+          }));\n+          expect(parser.analyze('/some/file.json', '')).toEqual(jasmine.objectContaining({\n+            canParse: false\n+          }));\n         });\n \n-        it('should fail on duplicate trans-unit id', () => {\n-          const XLIFF = [\n-            `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n-            `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-            `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-            `    <body>`,\n-            `      <trans-unit id=\"deadbeef\">`,\n-            `        <source/>`,\n-            `        <target/>`,\n-            `      </trans-unit>`,\n-            `      <trans-unit id=\"deadbeef\">`,\n-            `        <source/>`,\n-            `        <target/>`,\n-            `      </trans-unit>`,\n-            `    </body>`,\n-            `  </file>`,\n-            `</xliff>`,\n-          ].join('\\n');\n-\n-          expectToFail('/some/file.xlf', XLIFF, /Duplicated translations for message \"deadbeef\"/, [\n-            `Duplicated translations for message \"deadbeef\" (\"`,\n-            `        <target/>`,\n-            `      </trans-unit>`,\n-            `      [ERROR ->]<trans-unit id=\"deadbeef\">`,\n-            `        <source/>`,\n-            `        <target/>`,\n-            `\"): /some/file.xlf@8:6`,\n-          ].join('\\n'));\n+        it('should return a diagnostics object when the file is not a valid format', () => {\n+          let result: ParseAnalysis<any>;\n+          const parser = new Xliff1TranslationParser();\n+\n+          result = parser.analyze('/some/file.xlf', '<moo>');\n+          expect(result.diagnostics.messages).toEqual([\n+            {type: 'warning', message: 'The XML file does not contain a <xliff> root node.'}\n+          ]);\n+\n+          result = parser.analyze('/some/file.xlf', '<xliff version=\"2.0\">');\n+          expect(result.diagnostics.messages).toEqual([{\n+            type: 'warning',\n+            message:\n+                'The <xliff> node does not have the required attribute: version=\"1.2\". (\"[WARNING ->]<xliff version=\"2.0\">\"): /some/file.xlf@0:0'\n+          }]);\n+\n+          result = parser.analyze('/some/file.xlf', '<xliff version=\"1.2\"></file>');\n+          expect(result.diagnostics.messages).toEqual([{\n+            type: 'error',\n+            message:\n+                'Unexpected closing tag \"file\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags (\"<xliff version=\"1.2\">[ERROR ->]</file>\"): /some/file.xlf@0:21'\n+          }]);\n         });\n       });\n \n-      describe('[message errors]', () => {\n-        it('should fail on unknown message tags', () => {\n-          const XLIFF = [\n-            `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n-            `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-            `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-            `    <body>`,\n-            `      <trans-unit id=\"deadbeef\" datatype=\"html\">`,\n-            `        <source/>`,\n-            `        <target><b>msg should contain only ph tags</b></target>`,\n-            `      </trans-unit>`,\n-            `    </body>`,\n-            `  </file>`,\n-            `</xliff>`,\n-          ].join('\\n');\n-\n-          expectToFail('/some/file.xlf', XLIFF, /Invalid element found in message/, [\n-            `Error: Invalid element found in message.`,\n-            `At /some/file.xlf@6:16:`,\n-            `...`,\n-            `        <source/>`,\n-            `        <target>[ERROR ->]<b>msg should contain only ph tags</b></target>`,\n-            `      </trans-unit>`,\n-            `...`,\n-            ``,\n-          ].join('\\n'));\n-        });\n-\n-        it('should fail when a placeholder misses an id attribute', () => {\n-          const XLIFF = [\n-            `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n-            `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n-            `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n-            `    <body>`,\n-            `      <trans-unit id=\"deadbeef\" datatype=\"html\">`,\n-            `        <source/>`,\n-            `        <target><x/></target>`,\n-            `      </trans-unit>`,\n-            `    </body>`,\n-            `  </file>`,\n-            `</xliff>`,\n-          ].join('\\n');\n-\n-          expectToFail('/some/file.xlf', XLIFF, /required \"id\" attribute/gi, [\n-            `Error: Missing required \"id\" attribute:`,\n-            `At /some/file.xlf@6:16:`,\n-            `...`,\n-            `        <source/>`,\n-            `        <target>[ERROR ->]<x/></target>`,\n-            `      </trans-unit>`,\n-            `...`,\n-            ``,\n-          ].join('\\n'));\n-        });\n-      });\n+      for (const withHint of [true, false]) {\n+        describe(\n+            `parse() [${withHint ? 'with' : 'without'} hint]`, () => {\n+              const doParse: (fileName: string, XLIFF: string) => ParsedTranslationBundle =\n+                  withHint ? (fileName, XLIFF) => {\n+                    const parser = new Xliff1TranslationParser();\n+                    const hint = parser.canParse(fileName, XLIFF);\n+                    if (!hint) {\n+                      throw new Error('expected XLIFF to be valid');\n+                    }\n+                    return parser.parse(fileName, XLIFF, hint);\n+                  } : (fileName, XLIFF) => {\n+                    const parser = new Xliff1TranslationParser();\n+                    return parser.parse(fileName, XLIFF);\n+                  };\n+\n+              const expectToFail: (\n+                  fileName: string, XLIFF: string, errorMatcher: RegExp,\n+                  diagnosticMessage: string) => void =\n+                  withHint ? (fileName, XLIFF, _errorMatcher, diagnosticMessage) => {\n+                    const result = doParse(fileName, XLIFF);\n+                    expect(result.diagnostics.messages.length).toBeGreaterThan(0);\n+                    expect(result.diagnostics.messages.pop()!.message).toEqual(diagnosticMessage);\n+                  } : (fileName, XLIFF, errorMatcher, _diagnosticMessage) => {\n+                    expect(() => doParse(fileName, XLIFF)).toThrowError(errorMatcher);\n+                  };\n+\n+              it('should extract the locale from the last `<file>` element to contain a `target-language` attribute',\n+                 () => {\n+                   const XLIFF = [\n+                     `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                     `  <file source-language=\"en\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                     `    <body></body>`,\n+                     `  </file>`,\n+                     `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                     `    <body></body>`,\n+                     `  </file>`,\n+                     `  <file source-language=\"en\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                     `    <body></body>`,\n+                     `  </file>`,\n+                     `  <file source-language=\"en\" target-language=\"de\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                     `    <body></body>`,\n+                     `  </file>`,\n+                     `  <file source-language=\"en\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                     `    <body></body>`,\n+                     `  </file>`,\n+                     `</xliff>`,\n+                   ].join('\\n');\n+                   const result = doParse('/some/file.xlf', XLIFF);\n+                   expect(result.locale).toEqual('de');\n+                 });\n+\n+              it('should return an undefined locale if there is no locale in the file', () => {\n+                const XLIFF = [\n+                  `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                  `  <file source-language=\"en\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                  `    <body>`,\n+                  `    </body>`,\n+                  `  </file>`,\n+                  `</xliff>`,\n+                ].join('\\n');\n+                const result = doParse('/some/file.xlf', XLIFF);\n+                expect(result.locale).toBeUndefined();\n+              });\n+\n+              it('should extract basic messages', () => {\n+                /**\n+                 * Source HTML:\n+                 *\n+                 * ```\n+                 * <div i18n>translatable attribute</div>\n+                 * ```\n+                 */\n+                const XLIFF = [\n+                  `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                  `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                  `    <body>`,\n+                  `      <trans-unit id=\"1933478729560469763\" datatype=\"html\">`,\n+                  `        <source>translatable attribute</source>`,\n+                  `        <target>etubirtta elbatalsnart</target>`,\n+                  `        <context-group purpose=\"location\">`,\n+                  `          <context context-type=\"sourcefile\">file.ts</context>`,\n+                  `          <context context-type=\"linenumber\">1</context>`,\n+                  `        </context-group>`,\n+                  `      </trans-unit>`,\n+                  `    </body>`,\n+                  `  </file>`,\n+                  `</xliff>`,\n+                ].join('\\n');\n+                const result = doParse('/some/file.xlf', XLIFF);\n+\n+                expect(result.translations[ɵcomputeMsgId('translatable attribute')])\n+                    .toEqual(ɵmakeParsedTranslation(['etubirtta elbatalsnart']));\n+              });\n+\n+              it('should extract translations with simple placeholders', () => {\n+                /**\n+                 * Source HTML:\n+                 *\n+                 * ```\n+                 * <div i18n>translatable element <b>with placeholders</b> {{ interpolation}}</div>\n+                 * ```\n+                 */\n+                const XLIFF = [\n+                  `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                  `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                  `    <body>`,\n+                  `      <trans-unit id=\"5057824347511785081\" datatype=\"html\">`,\n+                  `        <source>translatable element <x id=\"START_BOLD_TEXT\" ctype=\"b\"/>with placeholders<x id=\"CLOSE_BOLD_TEXT\" ctype=\"b\"/> <x id=\"INTERPOLATION\"/></source>`,\n+                  `        <target><x id=\"INTERPOLATION\"/> tnemele elbatalsnart <x id=\"START_BOLD_TEXT\" ctype=\"x-b\"/>sredlohecalp htiw<x id=\"CLOSE_BOLD_TEXT\" ctype=\"x-b\"/></target>`,\n+                  `        <context-group purpose=\"location\">`,\n+                  `          <context context-type=\"sourcefile\">file.ts</context>`,\n+                  `          <context context-type=\"linenumber\">2</context>`,\n+                  `        </context-group>`,\n+                  `      </trans-unit>`,\n+                  `    </body>`,\n+                  `  </file>`,\n+                  `</xliff>`,\n+                ].join('\\n');\n+                const result = doParse('/some/file.xlf', XLIFF);\n+\n+                expect(\n+                    result.translations[ɵcomputeMsgId(\n+                        'translatable element {$START_BOLD_TEXT}with placeholders{$LOSE_BOLD_TEXT} {$INTERPOLATION}')])\n+                    .toEqual(ɵmakeParsedTranslation(\n+                        ['', ' tnemele elbatalsnart ', 'sredlohecalp htiw', ''],\n+                        ['INTERPOLATION', 'START_BOLD_TEXT', 'CLOSE_BOLD_TEXT']));\n+              });\n+\n+              it('should extract nested placeholder containers (i.e. nested HTML elements)', () => {\n+                /**\n+                 * Source HTML:\n+                 *\n+                 * ```\n+                 * <div i18n>\n+                 *   translatable <span>element <b>with placeholders</b></span> {{ interpolation}}\n+                 * </div>\n+                 * ```\n+                 */\n+                const XLIFF = [\n+                  `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                  `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                  `    <body>`,\n+                  `      <trans-unit id=\"9051630253697141670\" datatype=\"html\">`,\n+                  `        <source>translatable <x id=\"START_TAG_SPAN\"/>element <x id=\"START_BOLD_TEXT\"/>with placeholders<x id=\"CLOSE_BOLD_TEXT\"/><x id=\"CLOSE_TAG_SPAN\"/> <x id=\"INTERPOLATION\"/></source>`,\n+                  `        <target><x id=\"START_TAG_SPAN\"/><x id=\"INTERPOLATION\"/> tnemele<x id=\"CLOSE_TAG_SPAN\"/> elbatalsnart <x id=\"START_BOLD_TEXT\"/>sredlohecalp htiw<x id=\"CLOSE_BOLD_TEXT\"/></target>`,\n+                  `        <context-group purpose=\"location\">`,\n+                  `          <context context-type=\"sourcefile\">file.ts</context>`,\n+                  `          <context context-type=\"linenumber\">3</context>`,\n+                  `        </context-group>`,\n+                  `      </trans-unit>`,\n+                  `    </body>`,\n+                  `  </file>`,\n+                  `</xliff>`,\n+                ].join('\\n');\n+                const result = doParse('/some/file.xlf', XLIFF);\n+                expect(\n+                    result.translations[ɵcomputeMsgId(\n+                        'translatable {$START_TAG_SPAN}element {$START_BOLD_TEXT}with placeholders' +\n+                        '{$CLOSE_BOLD_TEXT}{$CLOSE_TAG_SPAN} {$INTERPOLATION}')])\n+                    .toEqual(ɵmakeParsedTranslation(\n+                        ['', '', ' tnemele', ' elbatalsnart ', 'sredlohecalp htiw', ''], [\n+                          'START_TAG_SPAN',\n+                          'INTERPOLATION',\n+                          'CLOSE_TAG_SPAN',\n+                          'START_BOLD_TEXT',\n+                          'CLOSE_BOLD_TEXT',\n+                        ]));\n+              });\n+\n+              it('should extract translations with placeholders containing hyphens', () => {\n+                /**\n+                 * Source HTML:\n+                 *\n+                 * ```\n+                 * <div i18n><app-my-component></app-my-component> Welcome</div>\n+                 * ```\n+                 */\n+                const XLIFF = [\n+                  `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                  `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                  `    <body>`,\n+                  `      <trans-unit id=\"2877147807876214810\" datatype=\"html\">`,\n+                  `        <source><x id=\"START_TAG_APP-MY-COMPONENT\" ctype=\"x-app-my-component\" equiv-text=\"&lt;app-my-component&gt;\"/><x id=\"CLOSE_TAG_APP-MY-COMPONENT\" ctype=\"x-app-my-component\" equiv-text=\"&lt;/app-my-component&gt;\"/> Welcome</source>`,\n+                  `        <context-group purpose=\"location\">`,\n+                  `          <context context-type=\"sourcefile\">src/app/app.component.html</context>`,\n+                  `          <context context-type=\"linenumber\">1</context>`,\n+                  `        </context-group>`,\n+                  `        <target><x id=\"START_TAG_APP-MY-COMPONENT\" ctype=\"x-app-my-component\" equiv-text=\"&lt;app-my-component&gt;\"/><x id=\"CLOSE_TAG_APP-MY-COMPONENT\" ctype=\"x-app-my-component\" equiv-text=\"&lt;/app-my-component&gt;\"/> Translate</target>`,\n+                  `      </trans-unit>`,\n+                  `    </body>`,\n+                  `  </file>`,\n+                  `</xliff>`,\n+                ].join('\\n');\n+                const result = doParse('/some/file.xlf', XLIFF);\n+                const id = ɵcomputeMsgId(\n+                    '{$START_TAG_APP_MY_COMPONENT}{$CLOSE_TAG_APP_MY_COMPONENT} Welcome');\n+                expect(result.translations[id])\n+                    .toEqual(ɵmakeParsedTranslation(\n+                        ['', '', ' Translate'],\n+                        ['START_TAG_APP_MY_COMPONENT', 'CLOSE_TAG_APP_MY_COMPONENT']));\n+              });\n+\n+              it('should extract translations with simple ICU expressions', () => {\n+                /**\n+                 * Source HTML:\n+                 *\n+                 * ```\n+                 * <div i18n>{VAR_PLURAL, plural, =0 {<p>test</p>} }</div>\n+                 * ```\n+                 */\n+                const XLIFF = [\n+                  `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                  `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                  `    <body>`,\n+                  `      <trans-unit id=\"2874455947211586270\" datatype=\"html\">`,\n+                  `        <source>{VAR_PLURAL, plural, =0 {<x id=\"START_PARAGRAPH\" ctype=\"x-p\"/>test<x id=\"CLOSE_PARAGRAPH\" ctype=\"x-p\"/>} }</source>`,\n+                  `        <target>{VAR_PLURAL, plural, =0 {<x id=\"START_PARAGRAPH\" ctype=\"x-p\"/>TEST<x id=\"CLOSE_PARAGRAPH\" ctype=\"x-p\"/>} }</target>`,\n+                  `      </trans-unit>`,\n+                  `    </body>`,\n+                  `  </file>`,\n+                  `</xliff>`,\n+                ].join('\\n');\n+                const result = doParse('/some/file.xlf', XLIFF);\n+\n+                expect(result.translations[ɵcomputeMsgId(\n+                           '{VAR_PLURAL, plural, =0 {{START_PARAGRAPH}test{CLOSE_PARAGRAPH}}}')])\n+                    .toEqual(ɵmakeParsedTranslation(\n+                        ['{VAR_PLURAL, plural, =0 {{START_PARAGRAPH}TEST{CLOSE_PARAGRAPH}}}'], []));\n+              });\n+\n+              it('should extract translations with duplicate source messages', () => {\n+                /**\n+                 * Source HTML:\n+                 *\n+                 * ```\n+                 * <div i18n>foo</div>\n+                 * <div i18n=\"m|d@@i\">foo</div>\n+                 * <div i18=\"\"m|d@@bar>foo</div>\n+                 * ```\n+                 */\n+                const XLIFF = [\n+                  `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                  `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                  `    <body>`,\n+                  `      <trans-unit id=\"9205907420411818817\" datatype=\"html\">`,\n+                  `        <source>foo</source>`,\n+                  `        <target>oof</target>`,\n+                  `        <context-group purpose=\"location\">`,\n+                  `          <context context-type=\"sourcefile\">file.ts</context>`,\n+                  `          <context context-type=\"linenumber\">3</context>`,\n+                  `        </context-group>`,\n+                  `        <note priority=\"1\" from=\"description\">d</note>`,\n+                  `        <note priority=\"1\" from=\"meaning\">m</note>`,\n+                  `      </trans-unit>`,\n+                  `      <trans-unit id=\"i\" datatype=\"html\">`,\n+                  `        <source>foo</source>`,\n+                  `        <target>toto</target>`,\n+                  `        <context-group purpose=\"location\">`,\n+                  `          <context context-type=\"sourcefile\">file.ts</context>`,\n+                  `          <context context-type=\"linenumber\">4</context>`,\n+                  `        </context-group>`,\n+                  `        <note priority=\"1\" from=\"description\">d</note>`,\n+                  `        <note priority=\"1\" from=\"meaning\">m</note>`,\n+                  `      </trans-unit>`,\n+                  `      <trans-unit id=\"bar\" datatype=\"html\">`,\n+                  `        <source>foo</source>`,\n+                  `        <target>tata</target>`,\n+                  `        <context-group purpose=\"location\">`,\n+                  `          <context context-type=\"sourcefile\">file.ts</context>`,\n+                  `          <context context-type=\"linenumber\">5</context>`,\n+                  `        </context-group>`,\n+                  `      </trans-unit>`,\n+                  `    </body>`,\n+                  `  </file>`,\n+                  `</xliff>`,\n+                ].join('\\n');\n+                const result = doParse('/some/file.xlf', XLIFF);\n+\n+                expect(result.translations[ɵcomputeMsgId('foo')])\n+                    .toEqual(ɵmakeParsedTranslation(['oof']));\n+                expect(result.translations['i']).toEqual(ɵmakeParsedTranslation(['toto']));\n+                expect(result.translations['bar']).toEqual(ɵmakeParsedTranslation(['tata']));\n+              });\n+\n+              it('should extract translations with only placeholders, which are re-ordered', () => {\n+                /**\n+                 * Source HTML:\n+                 *\n+                 * ```\n+                 * <div i18n><br><img/><img/></div>\n+                 * ```\n+                 */\n+                const XLIFF = [\n+                  `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                  `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                  `    <body>`,\n+                  `      <trans-unit id=\"7118057989405618448\" datatype=\"html\">`,\n+                  `      <ph id=\"1\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/&gt;\"/><ph id=\"2\" equiv=\"TAG_IMG_1\" type=\"image\" disp=\"&lt;img/&gt;\"/>`,\n+                  `        <source><x id=\"LINE_BREAK\" ctype=\"lb\"/><x id=\"TAG_IMG\" ctype=\"image\"/><x id=\"TAG_IMG_1\" ctype=\"image\"/></source>`,\n+                  `        <target><x id=\"TAG_IMG_1\" ctype=\"image\"/><x id=\"TAG_IMG\" ctype=\"image\"/><x id=\"LINE_BREAK\" ctype=\"lb\"/></target>`,\n+                  `        <context-group purpose=\"location\">`,\n+                  `          <context context-type=\"sourcefile\">file.ts</context>`,\n+                  `          <context context-type=\"linenumber\">6</context>`,\n+                  `        </context-group>`,\n+                  `        <note priority=\"1\" from=\"description\">ph names</note>`,\n+                  `      </trans-unit>`,\n+                  `    </body>`,\n+                  `  </file>`,\n+                  `</xliff>`,\n+                ].join('\\n');\n+                const result = doParse('/some/file.xlf', XLIFF);\n+\n+                expect(result.translations[ɵcomputeMsgId('{$LINE_BREAK}{$TAG_IMG}{$TAG_IMG_1}')])\n+                    .toEqual(ɵmakeParsedTranslation(\n+                        ['', '', '', ''], ['TAG_IMG_1', 'TAG_IMG', 'LINE_BREAK']));\n+              });\n+\n+              it('should extract translations with empty target', () => {\n+                /**\n+                 * Source HTML:\n+                 *\n+                 * ```\n+                 * <div i18n>hello <span></span></div>\n+                 * ```\n+                 */\n+                const XLIFF = [\n+                  `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                  `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                  `    <body>`,\n+                  `      <trans-unit id=\"2826198357052921524\" datatype=\"html\">`,\n+                  `        <source>hello <x id=\"START_TAG_SPAN\" ctype=\"x-span\"/><x id=\"CLOSE_TAG_SPAN\" ctype=\"x-span\"/></source>`,\n+                  `        <target/>`,\n+                  `        <context-group purpose=\"location\">`,\n+                  `          <context context-type=\"sourcefile\">file.ts</context>`,\n+                  `          <context context-type=\"linenumber\">6</context>`,\n+                  `        </context-group>`,\n+                  `        <note priority=\"1\" from=\"description\">ph names</note>`,\n+                  `      </trans-unit>`,\n+                  `    </body>`,\n+                  `  </file>`,\n+                  `</xliff>`,\n+                ].join('\\n');\n+                const result = doParse('/some/file.xlf', XLIFF);\n+\n+                expect(\n+                    result.translations[ɵcomputeMsgId('hello {$START_TAG_SPAN}{$CLOSE_TAG_SPAN}')])\n+                    .toEqual(ɵmakeParsedTranslation(['']));\n+              });\n+\n+              it('should extract translations with deeply nested ICUs', () => {\n+                /**\n+                 * Source HTML:\n+                 *\n+                 * ```\n+                 * Test: { count, plural, =0 { { sex, select, other {<p>deeply nested</p>}} }\n+                 * =other {a lot}}\n+                 * ```\n+                 *\n+                 * Note that the message gets split into two translation units:\n+                 *  * The first one contains the outer message with an `ICU` placeholder\n+                 *  * The second one is the ICU expansion itself\n+                 *\n+                 * Note that special markers `VAR_PLURAL` and `VAR_SELECT` are added, which are then\n+                 * replaced by IVY at runtime with the actual values being rendered by the ICU\n+                 * expansion.\n+                 */\n+                const XLIFF = [\n+                  `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                  `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                  `    <body>`,\n+                  `      <trans-unit id=\"980940425376233536\" datatype=\"html\">`,\n+                  `        <source>Test: <x id=\"ICU\" equiv-text=\"{ count, plural, =0 {...} =other {...}}\"/></source>`,\n+                  `        <target>Le test: <x id=\"ICU\" equiv-text=\"{ count, plural, =0 {...} =other {...}}\"/></target>`,\n+                  `        <context-group purpose=\"location\">`,\n+                  `          <context context-type=\"sourcefile\">file.ts</context>`,\n+                  `          <context context-type=\"linenumber\">11</context>`,\n+                  `        </context-group>`,\n+                  `      </trans-unit>`,\n+                  `      <trans-unit id=\"5207293143089349404\" datatype=\"html\">`,\n+                  `        <source>{VAR_PLURAL, plural, =0 {{VAR_SELECT, select, other {<x id=\"START_PARAGRAPH\" ctype=\"x-p\"/>deeply nested<x id=\"CLOSE_PARAGRAPH\" ctype=\"x-p\"/>}}} =other {a lot}}</source>`,\n+                  `        <target>{VAR_PLURAL, plural, =0 {{VAR_SELECT, select, other {<x id=\"START_PARAGRAPH\" ctype=\"x-p\"/>profondément imbriqué<x id=\"CLOSE_PARAGRAPH\" ctype=\"x-p\"/>}}} =other {beaucoup}}</target>`,\n+                  `      </trans-unit>`,\n+                  `    </body>`,\n+                  `  </file>`,\n+                  `</xliff>`,\n+                ].join('\\n');\n+                const result = doParse('/some/file.xlf', XLIFF);\n+\n+                expect(result.translations[ɵcomputeMsgId('Test: {$ICU}')])\n+                    .toEqual(ɵmakeParsedTranslation(['Le test: ', ''], ['ICU']));\n+\n+                expect(\n+                    result.translations[ɵcomputeMsgId(\n+                        '{VAR_PLURAL, plural, =0 {{VAR_SELECT, select, other {{START_PARAGRAPH}deeply nested{CLOSE_PARAGRAPH}}}} =other {beaucoup}}')])\n+                    .toEqual(ɵmakeParsedTranslation([\n+                      '{VAR_PLURAL, plural, =0 {{VAR_SELECT, select, other {{START_PARAGRAPH}profondément imbriqué{CLOSE_PARAGRAPH}}}} =other {beaucoup}}'\n+                    ]));\n+              });\n+\n+              it('should extract translations containing multiple lines', () => {\n+                /**\n+                 * Source HTML:\n+                 *\n+                 * ```\n+                 * <div i18n>multi\n+                 * lines</div>\n+                 * ```\n+                 */\n+                const XLIFF = [\n+                  `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                  `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                  `    <body>`,\n+                  `      <trans-unit id=\"2340165783990709777\" datatype=\"html\">`,\n+                  `        <source>multi\\nlines</source>`,\n+                  `        <target>multi\\nlignes</target>`,\n+                  `        <context-group purpose=\"location\">`,\n+                  `          <context context-type=\"sourcefile\">file.ts</context>`,\n+                  `          <context context-type=\"linenumber\">12</context>`,\n+                  `        </context-group>`,\n+                  `      </trans-unit>`,\n+                  `    </body>`,\n+                  `  </file>`,\n+                  `</xliff>`,\n+                ].join('\\n');\n+                const result = doParse('/some/file.xlf', XLIFF);\n+\n+                expect(result.translations[ɵcomputeMsgId('multi\\nlines')])\n+                    .toEqual(ɵmakeParsedTranslation(['multi\\nlignes']));\n+              });\n+\n+              it('should extract translations with <mrk> elements', () => {\n+                const XLIFF = [\n+                  `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                  `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                  `    <body>`,\n+                  `      <trans-unit id=\"mrk-test\">`,\n+                  `        <source>First sentence.</source>`,\n+                  `        <seg-source>`,\n+                  `          <invalid-tag>Should not be parsed</invalid-tag>`,\n+                  `        </seg-source>`,\n+                  `        <target>Translated <mrk mtype=\"seg\" mid=\"1\">first sentence</mrk>.</target>`,\n+                  `      </trans-unit>`,\n+                  `      <trans-unit id=\"mrk-test2\">`,\n+                  `        <source>First sentence. Second sentence.</source>`,\n+                  `        <seg-source>`,\n+                  `          <invalid-tag>Should not be parsed</invalid-tag>`,\n+                  `        </seg-source>`,\n+                  `        <target>Translated <mrk mtype=\"seg\" mid=\"1\"><mrk mtype=\"seg\" mid=\"2\">first</mrk> sentence</mrk>.</target>`,\n+                  `      </trans-unit>`,\n+                  `    </body>`,\n+                  `  </file>`,\n+                  `</xliff>`,\n+                ].join('\\n');\n+                const result = doParse('/some/file.xlf', XLIFF);\n+\n+                expect(result.translations['mrk-test'])\n+                    .toEqual(ɵmakeParsedTranslation(['Translated first sentence.']));\n+\n+                expect(result.translations['mrk-test2'])\n+                    .toEqual(ɵmakeParsedTranslation(['Translated first sentence.']));\n+              });\n+\n+              it('should ignore alt-trans targets', () => {\n+                const XLIFF = [\n+                  `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                  `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                  `    <body>`,\n+                  `      <trans-unit datatype=\"html\" approved=\"no\" id=\"registration.submit\">`,\n+                  `        <source>Continue</source>`,\n+                  `        <target state=\"translated\" xml:lang=\"de\">Weiter</target>`,\n+                  `        <context-group purpose=\"location\">`,\n+                  `          <context context-type=\"sourcefile\">src/app/auth/registration-form/registration-form.component.html</context>`,\n+                  `          <context context-type=\"linenumber\">69</context>`,\n+                  `        </context-group>`,\n+                  `        <?sid 1110954287-0?>`,\n+                  `        <alt-trans origin=\"autoFuzzy\" tool=\"Swordfish\" match-quality=\"71\" ts=\"63\">`,\n+                  `          <source xml:lang=\"en\">Content</source>`,\n+                  `          <target state=\"translated\" xml:lang=\"de\">Content</target>`,\n+                  `        </alt-trans>`,\n+                  `    </trans-unit>`,\n+                  `    </body>`,\n+                  `  </file>`,\n+                  `</xliff>`,\n+                ].join('\\n');\n+\n+                const result = doParse('/some/file.xlf', XLIFF);\n+                expect(result.translations['registration.submit'])\n+                    .toEqual(ɵmakeParsedTranslation(['Weiter']));\n+              });\n+\n+              it('should merge messages from each `<file>` element', () => {\n+                /**\n+                 * Source HTML:\n+                 *\n+                 * ```\n+                 * <div i18n>translatable attribute</div>\n+                 * ```\n+\n+                 * ```\n+                 * <div i18n>translatable element <b>with placeholders</b> {{ interpolation}}</div>\n+                 * ```\n+                 */\n+                const XLIFF = [\n+                  `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                  `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"file-1\">`,\n+                  `    <body>`,\n+                  `      <trans-unit id=\"1933478729560469763\" datatype=\"html\">`,\n+                  `        <source>translatable attribute</source>`,\n+                  `        <target>etubirtta elbatalsnart</target>`,\n+                  `        <context-group purpose=\"location\">`,\n+                  `          <context context-type=\"sourcefile\">file.ts</context>`,\n+                  `          <context context-type=\"linenumber\">1</context>`,\n+                  `        </context-group>`,\n+                  `      </trans-unit>`,\n+                  `    </body>`,\n+                  `  </file>`,\n+                  `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"file-2\">`,\n+                  `    <body>`,\n+                  `      <trans-unit id=\"5057824347511785081\" datatype=\"html\">`,\n+                  `        <source>translatable element <x id=\"START_BOLD_TEXT\" ctype=\"b\"/>with placeholders<x id=\"CLOSE_BOLD_TEXT\" ctype=\"b\"/> <x id=\"INTERPOLATION\"/></source>`,\n+                  `        <target><x id=\"INTERPOLATION\"/> tnemele elbatalsnart <x id=\"START_BOLD_TEXT\" ctype=\"x-b\"/>sredlohecalp htiw<x id=\"CLOSE_BOLD_TEXT\" ctype=\"x-b\"/></target>`,\n+                  `        <context-group purpose=\"location\">`,\n+                  `          <context context-type=\"sourcefile\">file.ts</context>`,\n+                  `          <context context-type=\"linenumber\">2</context>`,\n+                  `        </context-group>`,\n+                  `      </trans-unit>`,\n+                  `    </body>`,\n+                  `  </file>`,\n+                  `</xliff>`,\n+                ].join('\\n');\n+                const result = doParse('/some/file.xlf', XLIFF);\n+                expect(result.translations[ɵcomputeMsgId('translatable attribute')])\n+                    .toEqual(ɵmakeParsedTranslation(['etubirtta elbatalsnart']));\n+                expect(\n+                    result.translations[ɵcomputeMsgId(\n+                        'translatable element {$START_BOLD_TEXT}with placeholders{$LOSE_BOLD_TEXT} {$INTERPOLATION}')])\n+                    .toEqual(ɵmakeParsedTranslation(\n+                        ['', ' tnemele elbatalsnart ', 'sredlohecalp htiw', ''],\n+                        ['INTERPOLATION', 'START_BOLD_TEXT', 'CLOSE_BOLD_TEXT']));\n+              });\n+\n+              describe('[structure errors]', () => {\n+                it('should warn when a trans-unit has no translation target but does have a source',\n+                   () => {\n+                     const XLIFF = [\n+                       `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n+                       `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                       `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                       `    <body>`,\n+                       `      <trans-unit id=\"missingtarget\">`,\n+                       `        <source/>`,\n+                       `      </trans-unit>`,\n+                       `    </body>`,\n+                       `  </file>`,\n+                       `</xliff>`,\n+                     ].join('\\n');\n+\n+                     const result = doParse('/some/file.xlf', XLIFF);\n+                     expect(result.diagnostics.messages.length).toEqual(1);\n+                     expect(result.diagnostics.messages[0].message).toEqual([\n+                       `Missing <target> element (\"e-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                       `    <body>`,\n+                       `      [WARNING ->]<trans-unit id=\"missingtarget\">`,\n+                       `        <source/>`,\n+                       `      </trans-unit>`,\n+                       `\"): /some/file.xlf@4:6`,\n+                     ].join('\\n'));\n+                   });\n+\n+                it('should fail when a trans-unit has no translation target nor source', () => {\n+                  const XLIFF = [\n+                    `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n+                    `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                    `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                    `    <body>`,\n+                    `      <trans-unit id=\"missingtarget\">`,\n+                    `      </trans-unit>`,\n+                    `    </body>`,\n+                    `  </file>`,\n+                    `</xliff>`,\n+                  ].join('\\n');\n+\n+                  expectToFail(\n+                      '/some/file.xlf', XLIFF,\n+                      /Missing required element: one of <target> or <source> is required/, [\n+                        `Missing required element: one of <target> or <source> is required (\"e-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                        `    <body>`,\n+                        `      [ERROR ->]<trans-unit id=\"missingtarget\">`,\n+                        `      </trans-unit>`,\n+                        `    </body>`,\n+                        `\"): /some/file.xlf@4:6`,\n+                      ].join('\\n'));\n+                });\n+\n+                it('should fail when a trans-unit has no id attribute', () => {\n+                  const XLIFF = [\n+                    `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n+                    `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                    `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                    `    <body>`,\n+                    `      <trans-unit datatype=\"html\">`,\n+                    `        <source/>`,\n+                    `        <target/>`,\n+                    `      </trans-unit>`,\n+                    `    </body>`,\n+                    `  </file>`,\n+                    `</xliff>`,\n+                  ].join('\\n');\n+\n+                  expectToFail('/some/file.xlf', XLIFF, /Missing required \"id\" attribute/, [\n+                    `Missing required \"id\" attribute on <trans-unit> element. (\"e-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                    `    <body>`,\n+                    `      [ERROR ->]<trans-unit datatype=\"html\">`,\n+                    `        <source/>`,\n+                    `        <target/>`,\n+                    `\"): /some/file.xlf@4:6`,\n+                  ].join('\\n'));\n+                });\n+\n+                it('should fail on duplicate trans-unit id', () => {\n+                  const XLIFF = [\n+                    `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n+                    `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                    `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                    `    <body>`,\n+                    `      <trans-unit id=\"deadbeef\">`,\n+                    `        <source/>`,\n+                    `        <target/>`,\n+                    `      </trans-unit>`,\n+                    `      <trans-unit id=\"deadbeef\">`,\n+                    `        <source/>`,\n+                    `        <target/>`,\n+                    `      </trans-unit>`,\n+                    `    </body>`,\n+                    `  </file>`,\n+                    `</xliff>`,\n+                  ].join('\\n');\n+\n+                  expectToFail(\n+                      '/some/file.xlf', XLIFF, /Duplicated translations for message \"deadbeef\"/, [\n+                        `Duplicated translations for message \"deadbeef\" (\"`,\n+                        `        <target/>`,\n+                        `      </trans-unit>`,\n+                        `      [ERROR ->]<trans-unit id=\"deadbeef\">`,\n+                        `        <source/>`,\n+                        `        <target/>`,\n+                        `\"): /some/file.xlf@8:6`,\n+                      ].join('\\n'));\n+                });\n+              });\n+\n+              describe('[message errors]', () => {\n+                it('should fail on unknown message tags', () => {\n+                  const XLIFF = [\n+                    `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n+                    `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                    `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                    `    <body>`,\n+                    `      <trans-unit id=\"deadbeef\" datatype=\"html\">`,\n+                    `        <source/>`,\n+                    `        <target><b>msg should contain only ph tags</b></target>`,\n+                    `      </trans-unit>`,\n+                    `    </body>`,\n+                    `  </file>`,\n+                    `</xliff>`,\n+                  ].join('\\n');\n+\n+                  expectToFail('/some/file.xlf', XLIFF, /Invalid element found in message/, [\n+                    `Error: Invalid element found in message.`,\n+                    `At /some/file.xlf@6:16:`,\n+                    `...`,\n+                    `        <source/>`,\n+                    `        <target>[ERROR ->]<b>msg should contain only ph tags</b></target>`,\n+                    `      </trans-unit>`,\n+                    `...`,\n+                    ``,\n+                  ].join('\\n'));\n+                });\n+\n+                it('should fail when a placeholder misses an id attribute', () => {\n+                  const XLIFF = [\n+                    `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n+                    `<xliff version=\"1.2\" xmlns=\"urn:oasis:names:tc:xliff:document:1.2\">`,\n+                    `  <file source-language=\"en\" target-language=\"fr\" datatype=\"plaintext\" original=\"ng2.template\">`,\n+                    `    <body>`,\n+                    `      <trans-unit id=\"deadbeef\" datatype=\"html\">`,\n+                    `        <source/>`,\n+                    `        <target><x/></target>`,\n+                    `      </trans-unit>`,\n+                    `    </body>`,\n+                    `  </file>`,\n+                    `</xliff>`,\n+                  ].join('\\n');\n+\n+                  expectToFail('/some/file.xlf', XLIFF, /required \"id\" attribute/gi, [\n+                    `Error: Missing required \"id\" attribute:`,\n+                    `At /some/file.xlf@6:16:`,\n+                    `...`,\n+                    `        <source/>`,\n+                    `        <target>[ERROR ->]<x/></target>`,\n+                    `      </trans-unit>`,\n+                    `...`,\n+                    ``,\n+                  ].join('\\n'));\n+                });\n+              });\n+            });\n+      }\n     });\n-  }\n-});"
        },
        {
            "sha": "bb9000d09bd896757d7fe6d58bb8b713b6a1e8d9",
            "filename": "packages/localize/src/tools/test/translate/translation_files/translation_parsers/xliff2_translation_parser_spec.ts",
            "status": "modified",
            "additions": 696,
            "deletions": 671,
            "changes": 1367,
            "blob_url": "https://github.com/angular/angular/blob/992c70df590151522bfeee7567a89ac9c4a108f1/packages%2Flocalize%2Fsrc%2Ftools%2Ftest%2Ftranslate%2Ftranslation_files%2Ftranslation_parsers%2Fxliff2_translation_parser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/992c70df590151522bfeee7567a89ac9c4a108f1/packages%2Flocalize%2Fsrc%2Ftools%2Ftest%2Ftranslate%2Ftranslation_files%2Ftranslation_parsers%2Fxliff2_translation_parser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flocalize%2Fsrc%2Ftools%2Ftest%2Ftranslate%2Ftranslation_files%2Ftranslation_parsers%2Fxliff2_translation_parser_spec.ts?ref=992c70df590151522bfeee7567a89ac9c4a108f1",
            "patch": "@@ -9,686 +9,711 @@ import {ɵcomputeMsgId, ɵmakeParsedTranslation} from '@angular/localize';\n import {ParseAnalysis, ParsedTranslationBundle} from '../../../../src/translate/translation_files/translation_parsers/translation_parser';\n import {Xliff2TranslationParser} from '../../../../src/translate/translation_files/translation_parsers/xliff2_translation_parser';\n \n-describe(\n-    'Xliff2TranslationParser', () => {\n-      describe('canParse()', () => {\n-        it('should return true if the file contains an <xliff> element with version=\"2.0\" attribute',\n-           () => {\n-             const parser = new Xliff2TranslationParser();\n-             expect(parser.canParse(\n-                        '/some/file.xlf',\n-                        '<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\">'))\n-                 .toBeTruthy();\n-             expect(parser.canParse(\n-                        '/some/file.json',\n-                        '<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\">'))\n-                 .toBeTruthy();\n-             expect(parser.canParse('/some/file.xliff', '<xliff version=\"2.0\">')).toBeTruthy();\n-             expect(parser.canParse('/some/file.json', '<xliff version=\"2.0\">')).toBeTruthy();\n-             expect(parser.canParse('/some/file.xlf', '<xliff>')).toBe(false);\n-             expect(parser.canParse('/some/file.xlf', '<xliff version=\"1.2\">')).toBe(false);\n-             expect(parser.canParse('/some/file.xlf', '')).toBe(false);\n-             expect(parser.canParse('/some/file.json', '')).toBe(false);\n-           });\n-      });\n-\n-      describe('analyze', () => {\n-        it('should return a success object if the file contains an <xliff> element with version=\"2.0\" attribute',\n-           () => {\n-             const parser = new Xliff2TranslationParser();\n-             expect(parser.analyze(\n-                        '/some/file.xlf',\n-                        '<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\">'))\n-                 .toEqual(jasmine.objectContaining({canParse: true, hint: jasmine.any(Object)}));\n-             expect(parser.analyze(\n-                        '/some/file.json',\n-                        '<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\">'))\n-                 .toEqual(jasmine.objectContaining({canParse: true, hint: jasmine.any(Object)}));\n-             expect(parser.analyze('/some/file.xliff', '<xliff version=\"2.0\">'))\n-                 .toEqual(jasmine.objectContaining({canParse: true, hint: jasmine.any(Object)}));\n-             expect(parser.analyze('/some/file.json', '<xliff version=\"2.0\">'))\n-                 .toEqual(jasmine.objectContaining({canParse: true, hint: jasmine.any(Object)}));\n-           });\n-\n-        it('should return a failure object if the file cannot be parsed as XLIFF 2.0', () => {\n-          const parser = new Xliff2TranslationParser();\n-          expect(parser.analyze('/some/file.xlf', '<xliff>')).toEqual(jasmine.objectContaining({\n-            canParse: false\n-          }));\n-          expect(parser.analyze('/some/file.xlf', '<xliff version=\"1.2\">'))\n-              .toEqual(jasmine.objectContaining({canParse: false}));\n-          expect(parser.analyze('/some/file.xlf', '')).toEqual(jasmine.objectContaining({\n-            canParse: false\n-          }));\n-          expect(parser.analyze('/some/file.json', '')).toEqual(jasmine.objectContaining({\n-            canParse: false\n-          }));\n-        });\n+describe('Xliff2TranslationParser', () => {\n+  describe('canParse()', () => {\n+    it('should return true if the file contains an <xliff> element with version=\"2.0\" attribute',\n+       () => {\n+         const parser = new Xliff2TranslationParser();\n+         expect(parser.canParse(\n+                    '/some/file.xlf',\n+                    '<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\">'))\n+             .toBeTruthy();\n+         expect(parser.canParse(\n+                    '/some/file.json',\n+                    '<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\">'))\n+             .toBeTruthy();\n+         expect(parser.canParse('/some/file.xliff', '<xliff version=\"2.0\">')).toBeTruthy();\n+         expect(parser.canParse('/some/file.json', '<xliff version=\"2.0\">')).toBeTruthy();\n+         expect(parser.canParse('/some/file.xlf', '<xliff>')).toBe(false);\n+         expect(parser.canParse('/some/file.xlf', '<xliff version=\"1.2\">')).toBe(false);\n+         expect(parser.canParse('/some/file.xlf', '')).toBe(false);\n+         expect(parser.canParse('/some/file.json', '')).toBe(false);\n+       });\n+  });\n+\n+  describe('analyze', () => {\n+    it('should return a success object if the file contains an <xliff> element with version=\"2.0\" attribute',\n+       () => {\n+         const parser = new Xliff2TranslationParser();\n+         expect(parser.analyze(\n+                    '/some/file.xlf',\n+                    '<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\">'))\n+             .toEqual(jasmine.objectContaining({canParse: true, hint: jasmine.any(Object)}));\n+         expect(parser.analyze(\n+                    '/some/file.json',\n+                    '<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\">'))\n+             .toEqual(jasmine.objectContaining({canParse: true, hint: jasmine.any(Object)}));\n+         expect(parser.analyze('/some/file.xliff', '<xliff version=\"2.0\">'))\n+             .toEqual(jasmine.objectContaining({canParse: true, hint: jasmine.any(Object)}));\n+         expect(parser.analyze('/some/file.json', '<xliff version=\"2.0\">'))\n+             .toEqual(jasmine.objectContaining({canParse: true, hint: jasmine.any(Object)}));\n+       });\n+\n+    it('should return a failure object if the file cannot be parsed as XLIFF 2.0', () => {\n+      const parser = new Xliff2TranslationParser();\n+      expect(parser.analyze('/some/file.xlf', '<xliff>')).toEqual(jasmine.objectContaining({\n+        canParse: false\n+      }));\n+      expect(parser.analyze('/some/file.xlf', '<xliff version=\"1.2\">'))\n+          .toEqual(jasmine.objectContaining({canParse: false}));\n+      expect(parser.analyze('/some/file.xlf', '')).toEqual(jasmine.objectContaining({\n+        canParse: false\n+      }));\n+      expect(parser.analyze('/some/file.json', '')).toEqual(jasmine.objectContaining({\n+        canParse: false\n+      }));\n+    });\n \n-        it('should return a diagnostics object when the file is not a valid format', () => {\n-          let result: ParseAnalysis<any>;\n-          const parser = new Xliff2TranslationParser();\n-\n-          result = parser.analyze('/some/file.xlf', '<moo>');\n-          expect(result.diagnostics.messages).toEqual([\n-            {type: 'warning', message: 'The XML file does not contain a <xliff> root node.'}\n-          ]);\n-\n-          result = parser.analyze('/some/file.xlf', '<xliff version=\"1.2\">');\n-          expect(result.diagnostics.messages).toEqual([{\n-            type: 'warning',\n-            message:\n-                'The <xliff> node does not have the required attribute: version=\"2.0\". (\"[WARNING ->]<xliff version=\"1.2\">\"): /some/file.xlf@0:0'\n-          }]);\n-\n-          result = parser.analyze('/some/file.xlf', '<xliff version=\"2.0\"></file>');\n-          expect(result.diagnostics.messages).toEqual([{\n-            type: 'error',\n-            message:\n-                'Unexpected closing tag \"file\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags (\"<xliff version=\"2.0\">[ERROR ->]</file>\"): /some/file.xlf@0:21'\n-          }]);\n-        });\n-      });\n-\n-      for (const withHint of [true, false]) {\n-        describe(\n-            `parse() [${withHint ? 'with' : 'without'} hint]`, () => {\n-              const doParse: (fileName: string, XLIFF: string) => ParsedTranslationBundle =\n-                  withHint ? (fileName, XLIFF) => {\n-                    const parser = new Xliff2TranslationParser();\n-                    const hint = parser.canParse(fileName, XLIFF);\n-                    if (!hint) {\n-                      throw new Error('expected XLIFF to be valid');\n-                    }\n-                    return parser.parse(fileName, XLIFF, hint);\n-                  } : (fileName, XLIFF) => {\n-                    const parser = new Xliff2TranslationParser();\n-                    return parser.parse(fileName, XLIFF);\n+    it('should return a diagnostics object when the file is not a valid format', () => {\n+      let result: ParseAnalysis<any>;\n+      const parser = new Xliff2TranslationParser();\n+\n+      result = parser.analyze('/some/file.xlf', '<moo>');\n+      expect(result.diagnostics.messages).toEqual([\n+        {type: 'warning', message: 'The XML file does not contain a <xliff> root node.'}\n+      ]);\n+\n+      result = parser.analyze('/some/file.xlf', '<xliff version=\"1.2\">');\n+      expect(result.diagnostics.messages).toEqual([{\n+        type: 'warning',\n+        message:\n+            'The <xliff> node does not have the required attribute: version=\"2.0\". (\"[WARNING ->]<xliff version=\"1.2\">\"): /some/file.xlf@0:0'\n+      }]);\n+\n+      result = parser.analyze('/some/file.xlf', '<xliff version=\"2.0\"></file>');\n+      expect(result.diagnostics.messages).toEqual([{\n+        type: 'error',\n+        message:\n+            'Unexpected closing tag \"file\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags (\"<xliff version=\"2.0\">[ERROR ->]</file>\"): /some/file.xlf@0:21'\n+      }]);\n+    });\n+  });\n+\n+  for (const withHint of [true, false]) {\n+    describe(\n+        `parse() [${withHint ? 'with' : 'without'} hint]`, () => {\n+          const doParse: (fileName: string, XLIFF: string) => ParsedTranslationBundle =\n+              withHint ? (fileName, XLIFF) => {\n+                const parser = new Xliff2TranslationParser();\n+                const hint = parser.canParse(fileName, XLIFF);\n+                if (!hint) {\n+                  throw new Error('expected XLIFF to be valid');\n+                }\n+                return parser.parse(fileName, XLIFF, hint);\n+              } : (fileName, XLIFF) => {\n+                const parser = new Xliff2TranslationParser();\n+                return parser.parse(fileName, XLIFF);\n+              };\n+\n+          const expectToFail:\n+              (fileName: string, XLIFF: string, errorMatcher: RegExp, diagnosticMessage: string) =>\n+                  void = withHint ? (fileName, XLIFF, _errorMatcher, diagnosticMessage) => {\n+                    const result = doParse(fileName, XLIFF);\n+                    expect(result.diagnostics.messages.length).toBeGreaterThan(0);\n+                    expect(result.diagnostics.messages.pop()!.message).toEqual(diagnosticMessage);\n+                  } : (fileName, XLIFF, errorMatcher, _diagnosticMessage) => {\n+                    expect(() => doParse(fileName, XLIFF)).toThrowError(errorMatcher);\n                   };\n \n-              const expectToFail:\n-                  (fileName: string, XLIFF: string, errorMatcher: RegExp,\n-                   diagnosticMessage: string) => void =\n-                      withHint ? (fileName, XLIFF, _errorMatcher, diagnosticMessage) => {\n-                        const result = doParse(fileName, XLIFF);\n-                        expect(result.diagnostics.messages.length).toEqual(1);\n-                        expect(result.diagnostics.messages[0].message).toEqual(diagnosticMessage);\n-                      } : (fileName, XLIFF, errorMatcher, _diagnosticMessage) => {\n-                        expect(() => doParse(fileName, XLIFF)).toThrowError(errorMatcher);\n-                      };\n-\n-              it('should extract the locale from the file contents', () => {\n-                const XLIFF = [\n-                  `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n-                  `  <file original=\"ng.template\" id=\"ngi18n\">`,\n-                  `  </file>`,\n-                  `</xliff>`,\n-                ].join('\\n');\n-                const result = doParse('/some/file.xlf', XLIFF);\n-                expect(result.locale).toEqual('fr');\n-              });\n-\n-              it('should return undefined locale if there is no locale in the file', () => {\n-                const XLIFF = [\n-                  `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\">`,\n-                  `  <file original=\"ng.template\" id=\"ngi18n\">`,\n-                  `  </file>`,\n-                  `</xliff>`,\n-                ].join('\\n');\n-                const result = doParse('/some/file.xlf', XLIFF);\n-                expect(result.locale).toBeUndefined();\n-              });\n-\n-              it('should extract basic messages', () => {\n-                /**\n-                 * Source HTML:\n-                 *\n-                 * ```\n-                 * <div i18n>translatable attribute</div>\n-                 * ```\n-                 */\n-                const XLIFF = [\n-                  `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n-                  `  <file original=\"ng.template\" id=\"ngi18n\">`,\n-                  `    <unit id=\"1933478729560469763\">`,\n-                  `      <notes>`,\n-                  `        <note category=\"location\">file.ts:2</note>`,\n-                  `      </notes>`,\n-                  `      <segment>`,\n-                  `        <source>translatable attribute</source>`,\n-                  `        <target>etubirtta elbatalsnart</target>`,\n-                  `      </segment>`,\n-                  `    </unit>`,\n-                  `  </file>`,\n-                  `</xliff>`,\n-                ].join('\\n');\n-                const result = doParse('/some/file.xlf', XLIFF);\n-                expect(result.translations[ɵcomputeMsgId('translatable attribute', '')])\n-                    .toEqual(ɵmakeParsedTranslation(['etubirtta elbatalsnart']));\n-              });\n-\n-              it('should extract translations with simple placeholders', () => {\n-                /**\n-                 * Source HTML:\n-                 *\n-                 * ```\n-                 * <div i18n>translatable element <b>with placeholders</b> {{ interpolation}}</div>\n-                 * ```\n-                 */\n-                const XLIFF = [\n-                  `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n-                  `  <file original=\"ng.template\" id=\"ngi18n\">`,\n-                  `    <unit id=\"6949438802869886378\">`,\n-                  `      <notes>`,\n-                  `        <note category=\"location\">file.ts:3</note>`,\n-                  `      </notes>`,\n-                  `      <segment>`,\n-                  `        <source>translatable element <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">with placeholders</pc> <ph id=\"1\" equiv=\"INTERPOLATION\" disp=\"{{ interpolation}}\"/></source>`,\n-                  `        <target><ph id=\"1\" equiv=\"INTERPOLATION\" disp=\"{{ interpolation}}\"/> tnemele elbatalsnart <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">sredlohecalp htiw</pc></target>`,\n-                  `      </segment>`,\n-                  `    </unit>`,\n-                  `  </file>`,\n-                  `</xliff>`,\n-                ].join('\\n');\n-                const result = doParse('/some/file.xlf', XLIFF);\n-                expect(\n-                    result.translations[ɵcomputeMsgId(\n-                        'translatable element {$START_BOLD_TEXT}with placeholders{$CLOSE_BOLD_TEXT} {$INTERPOLATION}')])\n-                    .toEqual(ɵmakeParsedTranslation(\n-                        ['', ' tnemele elbatalsnart ', 'sredlohecalp htiw', ''],\n-                        ['INTERPOLATION', 'START_BOLD_TEXT', 'CLOSE_BOLD_TEXT']));\n-              });\n-\n-              it('should extract nested placeholder containers (i.e. nested HTML elements)', () => {\n-                /**\n-                 * Source HTML:\n-                 *\n-                 * ```\n-                 * <div i18n>\n-                 *   translatable <span>element <b>with placeholders</b></span> {{ interpolation}}\n-                 * </div>\n-                 * ```\n-                 */\n-                const XLIFF = [\n-                  `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n-                  `  <file original=\"ng.template\" id=\"ngi18n\">`,\n-                  `    <unit id=\"9051630253697141670\">`,\n-                  `      <notes>`,\n-                  `        <note category=\"location\">file.ts:3</note>`,\n-                  `      </notes>`,\n-                  `      <segment>`,\n-                  `        <source>translatable <pc id=\"0\" equivStart=\"START_TAG_SPAN\" equivEnd=\"CLOSE_TAG_SPAN\" type=\"other\"` +\n-                      ` dispStart=\"&lt;span&gt;\" dispEnd=\"&lt;/span&gt;\">element <pc id=\"1\" equivStart=\"START_BOLD_TEXT\" equivEnd=` +\n-                      `\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">with placeholders</pc></pc>` +\n-                      ` <ph id=\"2\" equiv=\"INTERPOLATION\" disp=\"{{ interpolation}}\"/></source>`,\n-                  `        <target><pc id=\"0\" equivStart=\"START_TAG_SPAN\" equivEnd=\"CLOSE_TAG_SPAN\" type=\"fmt\" dispStart=\"&lt;` +\n-                      `span&gt;\" dispEnd=\"&lt;/span&gt;\"><ph id=\"2\" equiv=\"INTERPOLATION\" disp=\"{{ interpolation}}\"/> tnemele</pc>` +\n-                      ` elbatalsnart <pc id=\"1\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=` +\n-                      `\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">sredlohecalp htiw</pc></target>`,\n-                  `      </segment>`,\n-                  `    </unit>`,\n-                  `  </file>`,\n-                  `</xliff>`,\n-                ].join('\\n');\n-                const result = doParse('/some/file.xlf', XLIFF);\n-                expect(\n-                    result.translations[ɵcomputeMsgId(\n-                        'translatable {$START_TAG_SPAN}element {$START_BOLD_TEXT}with placeholders' +\n-                        '{$CLOSE_BOLD_TEXT}{$CLOSE_TAG_SPAN} {$INTERPOLATION}')])\n-                    .toEqual(ɵmakeParsedTranslation(\n-                        ['', '', ' tnemele', ' elbatalsnart ', 'sredlohecalp htiw', ''], [\n-                          'START_TAG_SPAN',\n-                          'INTERPOLATION',\n-                          'CLOSE_TAG_SPAN',\n-                          'START_BOLD_TEXT',\n-                          'CLOSE_BOLD_TEXT',\n-                        ]));\n-              });\n-\n-              it('should extract translations with simple ICU expressions', () => {\n-                /**\n-                 * Source HTML:\n-                 *\n-                 * ```\n-                 * <div i18n>{VAR_PLURAL, plural, =0 {<p>test</p>} }</div>\n-                 * ```\n-                 */\n-                const XLIFF = [\n-                  `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n-                  `  <file original=\"ng.template\" id=\"ngi18n\">`,\n-                  `    <unit id=\"2874455947211586270\">`,\n-                  `      <notes>`,\n-                  `        <note category=\"location\">file.ts:4</note>`,\n-                  `      </notes>`,\n-                  `      <segment>`,\n-                  `        <source>{VAR_PLURAL, plural, =0 {<pc id=\"0\" equivStart=\"START_PARAGRAPH\" equivEnd=\"CLOSE_PARAGRAPH\" type=\"other\" dispStart=\"&lt;p&gt;\" dispEnd=\"&lt;/p&gt;\">test</pc>} }</source>`,\n-                  `        <target>{VAR_PLURAL, plural, =0 {<pc id=\"0\" equivStart=\"START_PARAGRAPH\" equivEnd=\"CLOSE_PARAGRAPH\" type=\"other\" dispStart=\"&lt;p&gt;\" dispEnd=\"&lt;/p&gt;\">TEST</pc>} }</target>`,\n-                  `      </segment>`,\n-                  `    </unit>`,\n-                  `  </file>`,\n-                  `</xliff>`,\n-                ].join('\\n');\n-                const result = doParse('/some/file.xlf', XLIFF);\n-                expect(result.translations[ɵcomputeMsgId(\n-                           '{VAR_PLURAL, plural, =0 {{START_PARAGRAPH}test{CLOSE_PARAGRAPH}}}')])\n-                    .toEqual(ɵmakeParsedTranslation(\n-                        ['{VAR_PLURAL, plural, =0 {{START_PARAGRAPH}TEST{CLOSE_PARAGRAPH}}}'], []));\n-              });\n-\n-              it('should extract translations with duplicate source messages', () => {\n-                /**\n-                 * Source HTML:\n-                 *\n-                 * ```\n-                 * <div i18n>foo</div>\n-                 * <div i18n=\"m|d@@i\">foo</div>\n-                 * <div i18=\"\"m|d@@bar>foo</div>\n-                 * ```\n-                 */\n-                const XLIFF = [\n-                  `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n-                  `  <file original=\"ng.template\" id=\"ngi18n\">`,\n-                  `    <unit id=\"9205907420411818817\">`,\n-                  `      <notes>`,\n-                  `        <note category=\"description\">d</note>`,\n-                  `        <note category=\"meaning\">m</note>`,\n-                  `        <note category=\"location\">file.ts:5</note>`,\n-                  `      </notes>`,\n-                  `      <segment>`,\n-                  `        <source>foo</source>`,\n-                  `        <target>oof</target>`,\n-                  `      </segment>`,\n-                  `    </unit>`,\n-                  `    <unit id=\"i\">`,\n-                  `      <notes>`,\n-                  `        <note category=\"description\">d</note>`,\n-                  `        <note category=\"meaning\">m</note>`,\n-                  `        <note category=\"location\">file.ts:5</note>`,\n-                  `      </notes>`,\n-                  `      <segment>`,\n-                  `        <source>foo</source>`,\n-                  `        <target>toto</target>`,\n-                  `      </segment>`,\n-                  `    </unit>`,\n-                  `    <unit id=\"bar\">`,\n-                  `      <notes>`,\n-                  `        <note category=\"description\">d</note>`,\n-                  `        <note category=\"meaning\">m</note>`,\n-                  `        <note category=\"location\">file.ts:5</note>`,\n-                  `      </notes>`,\n-                  `      <segment>`,\n-                  `        <source>foo</source>`,\n-                  `        <target>tata</target>`,\n-                  `      </segment>`,\n-                  `    </unit>`,\n-                  `  </file>`,\n-                  `</xliff>`,\n-                ].join('\\n');\n-                const result = doParse('/some/file.xlf', XLIFF);\n-                expect(result.translations[ɵcomputeMsgId('foo')])\n-                    .toEqual(ɵmakeParsedTranslation(['oof']));\n-                expect(result.translations['i']).toEqual(ɵmakeParsedTranslation(['toto']));\n-                expect(result.translations['bar']).toEqual(ɵmakeParsedTranslation(['tata']));\n-              });\n-\n-              it('should extract translations with only placeholders, which are re-ordered', () => {\n-                /**\n-                 * Source HTML:\n-                 *\n-                 * ```\n-                 * <div i18n><br><img/><img/></div>\n-                 * ```\n-                 */\n-                const XLIFF = [\n-                  `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n-                  `  <file original=\"ng.template\" id=\"ngi18n\">`,\n-                  `    <unit id=\"7118057989405618448\">`,\n-                  `      <notes>`,\n-                  `        <note category=\"description\">ph names</note>`,\n-                  `        <note category=\"location\">file.ts:7</note>`,\n-                  `      </notes>`,\n-                  `      <segment>`,\n-                  `        <source><ph id=\"0\" equiv=\"LINE_BREAK\" type=\"fmt\" disp=\"&lt;br/&gt;\"/><ph id=\"1\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/&gt;\"/><ph id=\"2\" equiv=\"TAG_IMG_1\" type=\"image\" disp=\"&lt;img/&gt;\"/></source>`,\n-                  `        <target><ph id=\"2\" equiv=\"TAG_IMG_1\" type=\"image\" disp=\"&lt;img/&gt;\"/><ph id=\"1\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/&gt;\"/><ph id=\"0\" equiv=\"LINE_BREAK\" type=\"fmt\" disp=\"&lt;br/&gt;\"/></target>`,\n-                  `      </segment>`,\n-                  `    </unit>`,\n-                  `  </file>`,\n-                  `</xliff>`,\n-                ].join('\\n');\n-                const result = doParse('/some/file.xlf', XLIFF);\n-                expect(result.translations[ɵcomputeMsgId('{$LINE_BREAK}{$TAG_IMG}{$TAG_IMG_1}')])\n-                    .toEqual(ɵmakeParsedTranslation(\n-                        ['', '', '', ''], ['TAG_IMG_1', 'TAG_IMG', 'LINE_BREAK']));\n-              });\n-\n-              it('should extract translations with empty target', () => {\n-                /**\n-                 * Source HTML:\n-                 *\n-                 * ```\n-                 * <div i18n>hello <span></span></div>\n-                 * ```\n-                 */\n-                const XLIFF = [\n-                  `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n-                  `  <file original=\"ng.template\" id=\"ngi18n\">`,\n-                  `    <unit id=\"2826198357052921524\">`,\n-                  `      <notes>`,\n-                  `        <note category=\"description\">empty element</note>`,\n-                  `        <note category=\"location\">file.ts:8</note>`,\n-                  `      </notes>`,\n-                  `      <segment>`,\n-                  `        <source>hello <pc id=\"0\" equivStart=\"START_TAG_SPAN\" equivEnd=\"CLOSE_TAG_SPAN\" type=\"other\" dispStart=\"&lt;span&gt;\" dispEnd=\"&lt;/span&gt;\"></pc></source>`,\n-                  `        <target></target>`,\n-                  `      </segment>`,\n-                  `    </unit>`,\n-                  `  </file>`,\n-                  `</xliff>`,\n-                ].join('\\n');\n-                const result = doParse('/some/file.xlf', XLIFF);\n-                expect(\n-                    result.translations[ɵcomputeMsgId('hello {$START_TAG_SPAN}{$CLOSE_TAG_SPAN}')])\n-                    .toEqual(ɵmakeParsedTranslation(['']));\n-              });\n-\n-              it('should extract translations with deeply nested ICUs', () => {\n-                /**\n-                 * Source HTML:\n-                 *\n-                 * ```\n-                 * Test: { count, plural, =0 { { sex, select, other {<p>deeply nested</p>}} }\n-                 * =other {a lot}}\n-                 * ```\n-                 *\n-                 * Note that the message gets split into two translation units:\n-                 *  * The first one contains the outer message with an `ICU` placeholder\n-                 *  * The second one is the ICU expansion itself\n-                 *\n-                 * Note that special markers `VAR_PLURAL` and `VAR_SELECT` are added, which are then\n-                 * replaced by IVY at runtime with the actual values being rendered by the ICU\n-                 * expansion.\n-                 */\n-                const XLIFF = [\n-                  `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n-                  `  <file original=\"ng.template\" id=\"ngi18n\">`,\n-                  `    <unit id=\"980940425376233536\">`,\n-                  `      <notes>`,\n-                  `        <note category=\"location\">file.ts:10</note>`,\n-                  `      </notes>`,\n-                  `      <segment>`,\n-                  `        <source>Test: <ph id=\"0\" equiv=\"ICU\" disp=\"{ count, plural, =0 {...} =other {...}}\"/></source>`,\n-                  `        <target>Le test: <ph id=\"0\" equiv=\"ICU\" disp=\"{ count, plural, =0 {...} =other {...}}\"/></target>`,\n-                  `      </segment>`,\n-                  `    </unit>`,\n-                  `    <unit id=\"5207293143089349404\">`,\n-                  `      <notes>`,\n-                  `        <note category=\"location\">file.ts:10</note>`,\n-                  `      </notes>`,\n-                  `      <segment>`,\n-                  `        <source>{VAR_PLURAL, plural, =0 {{VAR_SELECT, select, other {<pc id=\"0\" equivStart=\"START_PARAGRAPH\" equivEnd=\"CLOSE_PARAGRAPH\" type=\"other\" dispStart=\"&lt;p&gt;\" dispEnd=\"&lt;/p&gt;\">deeply nested</pc>}}} =other {a lot}}</source>`,\n-                  `        <target>{VAR_PLURAL, plural, =0 {{VAR_SELECT, select, other {<pc id=\"0\" equivStart=\"START_PARAGRAPH\" equivEnd=\"CLOSE_PARAGRAPH\" type=\"other\" dispStart=\"&lt;p&gt;\" dispEnd=\"&lt;/p&gt;\">profondément imbriqué</pc>}}} =other {beaucoup}}</target>`,\n-                  `      </segment>`,\n-                  `    </unit>`,\n-                  `  </file>`,\n-                  `</xliff>`,\n-                ].join('\\n');\n-                const result = doParse('/some/file.xlf', XLIFF);\n-                expect(result.translations[ɵcomputeMsgId('Test: {$ICU}')])\n-                    .toEqual(ɵmakeParsedTranslation(['Le test: ', ''], ['ICU']));\n-                expect(\n-                    result.translations[ɵcomputeMsgId(\n-                        '{VAR_PLURAL, plural, =0 {{VAR_SELECT, select, other {{START_PARAGRAPH}deeply nested{CLOSE_PARAGRAPH}}}} =other {beaucoup}}')])\n-                    .toEqual(ɵmakeParsedTranslation([\n-                      '{VAR_PLURAL, plural, =0 {{VAR_SELECT, select, other {{START_PARAGRAPH}profondément imbriqué{CLOSE_PARAGRAPH}}}} =other {beaucoup}}'\n+          it('should extract the locale from the file contents', () => {\n+            const XLIFF = [\n+              `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n+              `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+              `  </file>`,\n+              `</xliff>`,\n+            ].join('\\n');\n+            const result = doParse('/some/file.xlf', XLIFF);\n+            expect(result.locale).toEqual('fr');\n+          });\n+\n+          it('should return undefined locale if there is no locale in the file', () => {\n+            const XLIFF = [\n+              `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\">`,\n+              `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+              `  </file>`,\n+              `</xliff>`,\n+            ].join('\\n');\n+            const result = doParse('/some/file.xlf', XLIFF);\n+            expect(result.locale).toBeUndefined();\n+          });\n+\n+          it('should extract basic messages', () => {\n+            /**\n+             * Source HTML:\n+             *\n+             * ```\n+             * <div i18n>translatable attribute</div>\n+             * ```\n+             */\n+            const XLIFF = [\n+              `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n+              `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+              `    <unit id=\"1933478729560469763\">`,\n+              `      <notes>`,\n+              `        <note category=\"location\">file.ts:2</note>`,\n+              `      </notes>`,\n+              `      <segment>`,\n+              `        <source>translatable attribute</source>`,\n+              `        <target>etubirtta elbatalsnart</target>`,\n+              `      </segment>`,\n+              `    </unit>`,\n+              `  </file>`,\n+              `</xliff>`,\n+            ].join('\\n');\n+            const result = doParse('/some/file.xlf', XLIFF);\n+            expect(result.translations[ɵcomputeMsgId('translatable attribute', '')])\n+                .toEqual(ɵmakeParsedTranslation(['etubirtta elbatalsnart']));\n+          });\n+\n+          it('should extract translations with simple placeholders', () => {\n+            /**\n+             * Source HTML:\n+             *\n+             * ```\n+             * <div i18n>translatable element <b>with placeholders</b> {{ interpolation}}</div>\n+             * ```\n+             */\n+            const XLIFF = [\n+              `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n+              `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+              `    <unit id=\"6949438802869886378\">`,\n+              `      <notes>`,\n+              `        <note category=\"location\">file.ts:3</note>`,\n+              `      </notes>`,\n+              `      <segment>`,\n+              `        <source>translatable element <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">with placeholders</pc> <ph id=\"1\" equiv=\"INTERPOLATION\" disp=\"{{ interpolation}}\"/></source>`,\n+              `        <target><ph id=\"1\" equiv=\"INTERPOLATION\" disp=\"{{ interpolation}}\"/> tnemele elbatalsnart <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">sredlohecalp htiw</pc></target>`,\n+              `      </segment>`,\n+              `    </unit>`,\n+              `  </file>`,\n+              `</xliff>`,\n+            ].join('\\n');\n+            const result = doParse('/some/file.xlf', XLIFF);\n+            expect(\n+                result.translations[ɵcomputeMsgId(\n+                    'translatable element {$START_BOLD_TEXT}with placeholders{$CLOSE_BOLD_TEXT} {$INTERPOLATION}')])\n+                .toEqual(ɵmakeParsedTranslation(\n+                    ['', ' tnemele elbatalsnart ', 'sredlohecalp htiw', ''],\n+                    ['INTERPOLATION', 'START_BOLD_TEXT', 'CLOSE_BOLD_TEXT']));\n+          });\n+\n+          it('should extract nested placeholder containers (i.e. nested HTML elements)', () => {\n+            /**\n+             * Source HTML:\n+             *\n+             * ```\n+             * <div i18n>\n+             *   translatable <span>element <b>with placeholders</b></span> {{ interpolation}}\n+             * </div>\n+             * ```\n+             */\n+            const XLIFF = [\n+              `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n+              `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+              `    <unit id=\"9051630253697141670\">`,\n+              `      <notes>`,\n+              `        <note category=\"location\">file.ts:3</note>`,\n+              `      </notes>`,\n+              `      <segment>`,\n+              `        <source>translatable <pc id=\"0\" equivStart=\"START_TAG_SPAN\" equivEnd=\"CLOSE_TAG_SPAN\" type=\"other\"` +\n+                  ` dispStart=\"&lt;span&gt;\" dispEnd=\"&lt;/span&gt;\">element <pc id=\"1\" equivStart=\"START_BOLD_TEXT\" equivEnd=` +\n+                  `\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">with placeholders</pc></pc>` +\n+                  ` <ph id=\"2\" equiv=\"INTERPOLATION\" disp=\"{{ interpolation}}\"/></source>`,\n+              `        <target><pc id=\"0\" equivStart=\"START_TAG_SPAN\" equivEnd=\"CLOSE_TAG_SPAN\" type=\"fmt\" dispStart=\"&lt;` +\n+                  `span&gt;\" dispEnd=\"&lt;/span&gt;\"><ph id=\"2\" equiv=\"INTERPOLATION\" disp=\"{{ interpolation}}\"/> tnemele</pc>` +\n+                  ` elbatalsnart <pc id=\"1\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=` +\n+                  `\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">sredlohecalp htiw</pc></target>`,\n+              `      </segment>`,\n+              `    </unit>`,\n+              `  </file>`,\n+              `</xliff>`,\n+            ].join('\\n');\n+            const result = doParse('/some/file.xlf', XLIFF);\n+            expect(result.translations[ɵcomputeMsgId(\n+                       'translatable {$START_TAG_SPAN}element {$START_BOLD_TEXT}with placeholders' +\n+                       '{$CLOSE_BOLD_TEXT}{$CLOSE_TAG_SPAN} {$INTERPOLATION}')])\n+                .toEqual(ɵmakeParsedTranslation(\n+                    ['', '', ' tnemele', ' elbatalsnart ', 'sredlohecalp htiw', ''], [\n+                      'START_TAG_SPAN',\n+                      'INTERPOLATION',\n+                      'CLOSE_TAG_SPAN',\n+                      'START_BOLD_TEXT',\n+                      'CLOSE_BOLD_TEXT',\n                     ]));\n-              });\n-\n-              it('should extract translations containing multiple lines', () => {\n-                /**\n-                 * Source HTML:\n-                 *\n-                 * ```\n-                 * <div i18n>multi\n-                 * lines</div>\n-                 * ```\n-                 */\n-                const XLIFF = [\n-                  `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n-                  `  <file original=\"ng.template\" id=\"ngi18n\">`,\n-                  `    <unit id=\"2340165783990709777\">`,\n-                  `      <notes>`,\n-                  `        <note category=\"location\">file.ts:11,12</note>`,\n-                  `      </notes>`,\n-                  `      <segment>`,\n-                  `        <source>multi\\nlines</source>`,\n-                  `        <target>multi\\nlignes</target>`,\n-                  `      </segment>`,\n-                  `    </unit>`,\n-                  `  </file>`,\n-                  `</xliff>`,\n-                ].join('\\n');\n-                const result = doParse('/some/file.xlf', XLIFF);\n-                expect(result.translations[ɵcomputeMsgId('multi\\nlines')])\n-                    .toEqual(ɵmakeParsedTranslation(['multi\\nlignes']));\n-              });\n-\n-              it('should extract translations with <mrk> elements', () => {\n-                const XLIFF = [\n-                  `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n-                  `  <file original=\"ng.template\" id=\"ngi18n\">`,\n-                  `    <unit id=\"mrk-test\">`,\n-                  `      <segment>`,\n-                  `        <source>First sentence.</source>`,\n-                  `        <target>Translated <mrk id=\"m1\" type=\"comment\" ref=\"#n1\">first sentence</mrk>.</target>`,\n-                  `      </segment>`,\n-                  `    </unit>`,\n-                  `    <unit id=\"mrk-test2\">`,\n-                  `      <segment>`,\n-                  `        <source>First sentence. Second sentence.</source>`,\n-                  `        <target>Translated <mrk id=\"m1\" type=\"comment\" ref=\"#n1\"><mrk id=\"m2\" type=\"comment\" ref=\"#n1\">first</mrk> sentence</mrk>.</target>`,\n-                  `      </segment>`,\n-                  `    </unit>`,\n-                  `  </file>`,\n-                  `</xliff>`,\n-                ].join('\\n');\n-                const result = doParse('/some/file.xlf', XLIFF);\n-                expect(result.translations['mrk-test'])\n-                    .toEqual(ɵmakeParsedTranslation(['Translated first sentence.']));\n-                expect(result.translations['mrk-test2'])\n-                    .toEqual(ɵmakeParsedTranslation(['Translated first sentence.']));\n-              });\n-\n-              it('should merge messages from each `<file>` element', () => {\n-                /**\n-                 * Source HTML:\n-                 *\n-                 * ```\n-                 * <div i18n>translatable attribute</div>\n-                 * ```\n-                 *\n-                 * ```\n-                 * <div i18n>translatable element <b>with placeholders</b> {{ interpolation}}</div>\n-                 * ```\n-                 */\n-                const XLIFF = [\n-                  `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n-                  `  <file original=\"ng.template\" id=\"file-1\">`,\n-                  `    <unit id=\"1933478729560469763\">`,\n-                  `      <notes>`,\n-                  `        <note category=\"location\">file.ts:2</note>`,\n-                  `      </notes>`,\n-                  `      <segment>`,\n-                  `        <source>translatable attribute</source>`,\n-                  `        <target>etubirtta elbatalsnart</target>`,\n-                  `      </segment>`,\n-                  `    </unit>`,\n-                  `  </file>`,\n-                  `  <file original=\"ng.template\" id=\"file-2\">`,\n-                  `    <unit id=\"5057824347511785081\">`,\n-                  `      <notes>`,\n-                  `        <note category=\"location\">file.ts:3</note>`,\n-                  `      </notes>`,\n-                  `      <segment>`,\n-                  `        <source>translatable element <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">with placeholders</pc> <ph id=\"1\" equiv=\"INTERPOLATION\" disp=\"{{ interpolation}}\"/></source>`,\n-                  `        <target><ph id=\"1\" equiv=\"INTERPOLATION\" disp=\"{{ interpolation}}\"/> tnemele elbatalsnart <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">sredlohecalp htiw</pc></target>`,\n-                  `      </segment>`,\n-                  `    </unit>`,\n-                  `  </file>`,\n-                  `</xliff>`,\n-                ].join('\\n');\n-                const result = doParse('/some/file.xlf', XLIFF);\n-                expect(result.translations[ɵcomputeMsgId('translatable attribute', '')])\n-                    .toEqual(ɵmakeParsedTranslation(['etubirtta elbatalsnart']));\n-                expect(\n-                    result.translations[ɵcomputeMsgId(\n-                        'translatable element {$START_BOLD_TEXT}with placeholders{$LOSE_BOLD_TEXT} {$INTERPOLATION}')])\n-                    .toEqual(ɵmakeParsedTranslation(\n-                        ['', ' tnemele elbatalsnart ', 'sredlohecalp htiw', ''],\n-                        ['INTERPOLATION', 'START_BOLD_TEXT', 'CLOSE_BOLD_TEXT']));\n-              });\n-\n-              describe('[structure errors]', () => {\n-                it('should provide a diagnostic error when a trans-unit has no translation', () => {\n-                  const XLIFF = [\n-                    `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n-                    `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n-                    `  <file original=\"ng.template\" id=\"ngi18n\">`,\n-                    `    <unit id=\"missingtarget\">`,\n-                    `      <segment>`,\n-                    `        <source/>`,\n-                    `      </segment>`,\n-                    `    </unit>`,\n-                    `  </file>`,\n-                    `</xliff>`,\n-                  ].join('\\n');\n-\n-                  expectToFail('/some/file.xlf', XLIFF, /Missing required <target> element/, [\n-                    `Missing required <target> element (\"`,\n-                    `  <file original=\"ng.template\" id=\"ngi18n\">`,\n-                    `    <unit id=\"missingtarget\">`,\n-                    `      [ERROR ->]<segment>`,\n-                    `        <source/>`,\n-                    `      </segment>`,\n-                    `\"): /some/file.xlf@4:6`,\n-                  ].join('\\n'));\n-                });\n-\n+          });\n+\n+          it('should extract translations with simple ICU expressions', () => {\n+            /**\n+             * Source HTML:\n+             *\n+             * ```\n+             * <div i18n>{VAR_PLURAL, plural, =0 {<p>test</p>} }</div>\n+             * ```\n+             */\n+            const XLIFF = [\n+              `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n+              `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+              `    <unit id=\"2874455947211586270\">`,\n+              `      <notes>`,\n+              `        <note category=\"location\">file.ts:4</note>`,\n+              `      </notes>`,\n+              `      <segment>`,\n+              `        <source>{VAR_PLURAL, plural, =0 {<pc id=\"0\" equivStart=\"START_PARAGRAPH\" equivEnd=\"CLOSE_PARAGRAPH\" type=\"other\" dispStart=\"&lt;p&gt;\" dispEnd=\"&lt;/p&gt;\">test</pc>} }</source>`,\n+              `        <target>{VAR_PLURAL, plural, =0 {<pc id=\"0\" equivStart=\"START_PARAGRAPH\" equivEnd=\"CLOSE_PARAGRAPH\" type=\"other\" dispStart=\"&lt;p&gt;\" dispEnd=\"&lt;/p&gt;\">TEST</pc>} }</target>`,\n+              `      </segment>`,\n+              `    </unit>`,\n+              `  </file>`,\n+              `</xliff>`,\n+            ].join('\\n');\n+            const result = doParse('/some/file.xlf', XLIFF);\n+            expect(result.translations[ɵcomputeMsgId(\n+                       '{VAR_PLURAL, plural, =0 {{START_PARAGRAPH}test{CLOSE_PARAGRAPH}}}')])\n+                .toEqual(ɵmakeParsedTranslation(\n+                    ['{VAR_PLURAL, plural, =0 {{START_PARAGRAPH}TEST{CLOSE_PARAGRAPH}}}'], []));\n+          });\n+\n+          it('should extract translations with duplicate source messages', () => {\n+            /**\n+             * Source HTML:\n+             *\n+             * ```\n+             * <div i18n>foo</div>\n+             * <div i18n=\"m|d@@i\">foo</div>\n+             * <div i18=\"\"m|d@@bar>foo</div>\n+             * ```\n+             */\n+            const XLIFF = [\n+              `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n+              `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+              `    <unit id=\"9205907420411818817\">`,\n+              `      <notes>`,\n+              `        <note category=\"description\">d</note>`,\n+              `        <note category=\"meaning\">m</note>`,\n+              `        <note category=\"location\">file.ts:5</note>`,\n+              `      </notes>`,\n+              `      <segment>`,\n+              `        <source>foo</source>`,\n+              `        <target>oof</target>`,\n+              `      </segment>`,\n+              `    </unit>`,\n+              `    <unit id=\"i\">`,\n+              `      <notes>`,\n+              `        <note category=\"description\">d</note>`,\n+              `        <note category=\"meaning\">m</note>`,\n+              `        <note category=\"location\">file.ts:5</note>`,\n+              `      </notes>`,\n+              `      <segment>`,\n+              `        <source>foo</source>`,\n+              `        <target>toto</target>`,\n+              `      </segment>`,\n+              `    </unit>`,\n+              `    <unit id=\"bar\">`,\n+              `      <notes>`,\n+              `        <note category=\"description\">d</note>`,\n+              `        <note category=\"meaning\">m</note>`,\n+              `        <note category=\"location\">file.ts:5</note>`,\n+              `      </notes>`,\n+              `      <segment>`,\n+              `        <source>foo</source>`,\n+              `        <target>tata</target>`,\n+              `      </segment>`,\n+              `    </unit>`,\n+              `  </file>`,\n+              `</xliff>`,\n+            ].join('\\n');\n+            const result = doParse('/some/file.xlf', XLIFF);\n+            expect(result.translations[ɵcomputeMsgId('foo')])\n+                .toEqual(ɵmakeParsedTranslation(['oof']));\n+            expect(result.translations['i']).toEqual(ɵmakeParsedTranslation(['toto']));\n+            expect(result.translations['bar']).toEqual(ɵmakeParsedTranslation(['tata']));\n+          });\n+\n+          it('should extract translations with only placeholders, which are re-ordered', () => {\n+            /**\n+             * Source HTML:\n+             *\n+             * ```\n+             * <div i18n><br><img/><img/></div>\n+             * ```\n+             */\n+            const XLIFF = [\n+              `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n+              `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+              `    <unit id=\"7118057989405618448\">`,\n+              `      <notes>`,\n+              `        <note category=\"description\">ph names</note>`,\n+              `        <note category=\"location\">file.ts:7</note>`,\n+              `      </notes>`,\n+              `      <segment>`,\n+              `        <source><ph id=\"0\" equiv=\"LINE_BREAK\" type=\"fmt\" disp=\"&lt;br/&gt;\"/><ph id=\"1\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/&gt;\"/><ph id=\"2\" equiv=\"TAG_IMG_1\" type=\"image\" disp=\"&lt;img/&gt;\"/></source>`,\n+              `        <target><ph id=\"2\" equiv=\"TAG_IMG_1\" type=\"image\" disp=\"&lt;img/&gt;\"/><ph id=\"1\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/&gt;\"/><ph id=\"0\" equiv=\"LINE_BREAK\" type=\"fmt\" disp=\"&lt;br/&gt;\"/></target>`,\n+              `      </segment>`,\n+              `    </unit>`,\n+              `  </file>`,\n+              `</xliff>`,\n+            ].join('\\n');\n+            const result = doParse('/some/file.xlf', XLIFF);\n+            expect(result.translations[ɵcomputeMsgId('{$LINE_BREAK}{$TAG_IMG}{$TAG_IMG_1}')])\n+                .toEqual(ɵmakeParsedTranslation(\n+                    ['', '', '', ''], ['TAG_IMG_1', 'TAG_IMG', 'LINE_BREAK']));\n+          });\n+\n+          it('should extract translations with empty target', () => {\n+            /**\n+             * Source HTML:\n+             *\n+             * ```\n+             * <div i18n>hello <span></span></div>\n+             * ```\n+             */\n+            const XLIFF = [\n+              `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n+              `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+              `    <unit id=\"2826198357052921524\">`,\n+              `      <notes>`,\n+              `        <note category=\"description\">empty element</note>`,\n+              `        <note category=\"location\">file.ts:8</note>`,\n+              `      </notes>`,\n+              `      <segment>`,\n+              `        <source>hello <pc id=\"0\" equivStart=\"START_TAG_SPAN\" equivEnd=\"CLOSE_TAG_SPAN\" type=\"other\" dispStart=\"&lt;span&gt;\" dispEnd=\"&lt;/span&gt;\"></pc></source>`,\n+              `        <target></target>`,\n+              `      </segment>`,\n+              `    </unit>`,\n+              `  </file>`,\n+              `</xliff>`,\n+            ].join('\\n');\n+            const result = doParse('/some/file.xlf', XLIFF);\n+            expect(result.translations[ɵcomputeMsgId('hello {$START_TAG_SPAN}{$CLOSE_TAG_SPAN}')])\n+                .toEqual(ɵmakeParsedTranslation(['']));\n+          });\n+\n+          it('should extract translations with deeply nested ICUs', () => {\n+            /**\n+             * Source HTML:\n+             *\n+             * ```\n+             * Test: { count, plural, =0 { { sex, select, other {<p>deeply nested</p>}} }\n+             * =other {a lot}}\n+             * ```\n+             *\n+             * Note that the message gets split into two translation units:\n+             *  * The first one contains the outer message with an `ICU` placeholder\n+             *  * The second one is the ICU expansion itself\n+             *\n+             * Note that special markers `VAR_PLURAL` and `VAR_SELECT` are added, which are then\n+             * replaced by IVY at runtime with the actual values being rendered by the ICU\n+             * expansion.\n+             */\n+            const XLIFF = [\n+              `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n+              `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+              `    <unit id=\"980940425376233536\">`,\n+              `      <notes>`,\n+              `        <note category=\"location\">file.ts:10</note>`,\n+              `      </notes>`,\n+              `      <segment>`,\n+              `        <source>Test: <ph id=\"0\" equiv=\"ICU\" disp=\"{ count, plural, =0 {...} =other {...}}\"/></source>`,\n+              `        <target>Le test: <ph id=\"0\" equiv=\"ICU\" disp=\"{ count, plural, =0 {...} =other {...}}\"/></target>`,\n+              `      </segment>`,\n+              `    </unit>`,\n+              `    <unit id=\"5207293143089349404\">`,\n+              `      <notes>`,\n+              `        <note category=\"location\">file.ts:10</note>`,\n+              `      </notes>`,\n+              `      <segment>`,\n+              `        <source>{VAR_PLURAL, plural, =0 {{VAR_SELECT, select, other {<pc id=\"0\" equivStart=\"START_PARAGRAPH\" equivEnd=\"CLOSE_PARAGRAPH\" type=\"other\" dispStart=\"&lt;p&gt;\" dispEnd=\"&lt;/p&gt;\">deeply nested</pc>}}} =other {a lot}}</source>`,\n+              `        <target>{VAR_PLURAL, plural, =0 {{VAR_SELECT, select, other {<pc id=\"0\" equivStart=\"START_PARAGRAPH\" equivEnd=\"CLOSE_PARAGRAPH\" type=\"other\" dispStart=\"&lt;p&gt;\" dispEnd=\"&lt;/p&gt;\">profondément imbriqué</pc>}}} =other {beaucoup}}</target>`,\n+              `      </segment>`,\n+              `    </unit>`,\n+              `  </file>`,\n+              `</xliff>`,\n+            ].join('\\n');\n+            const result = doParse('/some/file.xlf', XLIFF);\n+            expect(result.translations[ɵcomputeMsgId('Test: {$ICU}')])\n+                .toEqual(ɵmakeParsedTranslation(['Le test: ', ''], ['ICU']));\n+            expect(\n+                result.translations[ɵcomputeMsgId(\n+                    '{VAR_PLURAL, plural, =0 {{VAR_SELECT, select, other {{START_PARAGRAPH}deeply nested{CLOSE_PARAGRAPH}}}} =other {beaucoup}}')])\n+                .toEqual(ɵmakeParsedTranslation([\n+                  '{VAR_PLURAL, plural, =0 {{VAR_SELECT, select, other {{START_PARAGRAPH}profondément imbriqué{CLOSE_PARAGRAPH}}}} =other {beaucoup}}'\n+                ]));\n+          });\n+\n+          it('should extract translations containing multiple lines', () => {\n+            /**\n+             * Source HTML:\n+             *\n+             * ```\n+             * <div i18n>multi\n+             * lines</div>\n+             * ```\n+             */\n+            const XLIFF = [\n+              `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n+              `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+              `    <unit id=\"2340165783990709777\">`,\n+              `      <notes>`,\n+              `        <note category=\"location\">file.ts:11,12</note>`,\n+              `      </notes>`,\n+              `      <segment>`,\n+              `        <source>multi\\nlines</source>`,\n+              `        <target>multi\\nlignes</target>`,\n+              `      </segment>`,\n+              `    </unit>`,\n+              `  </file>`,\n+              `</xliff>`,\n+            ].join('\\n');\n+            const result = doParse('/some/file.xlf', XLIFF);\n+            expect(result.translations[ɵcomputeMsgId('multi\\nlines')])\n+                .toEqual(ɵmakeParsedTranslation(['multi\\nlignes']));\n+          });\n+\n+          it('should extract translations with <mrk> elements', () => {\n+            const XLIFF = [\n+              `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n+              `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+              `    <unit id=\"mrk-test\">`,\n+              `      <segment>`,\n+              `        <source>First sentence.</source>`,\n+              `        <target>Translated <mrk id=\"m1\" type=\"comment\" ref=\"#n1\">first sentence</mrk>.</target>`,\n+              `      </segment>`,\n+              `    </unit>`,\n+              `    <unit id=\"mrk-test2\">`,\n+              `      <segment>`,\n+              `        <source>First sentence. Second sentence.</source>`,\n+              `        <target>Translated <mrk id=\"m1\" type=\"comment\" ref=\"#n1\"><mrk id=\"m2\" type=\"comment\" ref=\"#n1\">first</mrk> sentence</mrk>.</target>`,\n+              `      </segment>`,\n+              `    </unit>`,\n+              `  </file>`,\n+              `</xliff>`,\n+            ].join('\\n');\n+            const result = doParse('/some/file.xlf', XLIFF);\n+            expect(result.translations['mrk-test'])\n+                .toEqual(ɵmakeParsedTranslation(['Translated first sentence.']));\n+            expect(result.translations['mrk-test2'])\n+                .toEqual(ɵmakeParsedTranslation(['Translated first sentence.']));\n+          });\n+\n+          it('should merge messages from each `<file>` element', () => {\n+            /**\n+             * Source HTML:\n+             *\n+             * ```\n+             * <div i18n>translatable attribute</div>\n+             * ```\n+             *\n+             * ```\n+             * <div i18n>translatable element <b>with placeholders</b> {{ interpolation}}</div>\n+             * ```\n+             */\n+            const XLIFF = [\n+              `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n+              `  <file original=\"ng.template\" id=\"file-1\">`,\n+              `    <unit id=\"1933478729560469763\">`,\n+              `      <notes>`,\n+              `        <note category=\"location\">file.ts:2</note>`,\n+              `      </notes>`,\n+              `      <segment>`,\n+              `        <source>translatable attribute</source>`,\n+              `        <target>etubirtta elbatalsnart</target>`,\n+              `      </segment>`,\n+              `    </unit>`,\n+              `  </file>`,\n+              `  <file original=\"ng.template\" id=\"file-2\">`,\n+              `    <unit id=\"5057824347511785081\">`,\n+              `      <notes>`,\n+              `        <note category=\"location\">file.ts:3</note>`,\n+              `      </notes>`,\n+              `      <segment>`,\n+              `        <source>translatable element <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">with placeholders</pc> <ph id=\"1\" equiv=\"INTERPOLATION\" disp=\"{{ interpolation}}\"/></source>`,\n+              `        <target><ph id=\"1\" equiv=\"INTERPOLATION\" disp=\"{{ interpolation}}\"/> tnemele elbatalsnart <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">sredlohecalp htiw</pc></target>`,\n+              `      </segment>`,\n+              `    </unit>`,\n+              `  </file>`,\n+              `</xliff>`,\n+            ].join('\\n');\n+            const result = doParse('/some/file.xlf', XLIFF);\n+            expect(result.translations[ɵcomputeMsgId('translatable attribute', '')])\n+                .toEqual(ɵmakeParsedTranslation(['etubirtta elbatalsnart']));\n+            expect(\n+                result.translations[ɵcomputeMsgId(\n+                    'translatable element {$START_BOLD_TEXT}with placeholders{$LOSE_BOLD_TEXT} {$INTERPOLATION}')])\n+                .toEqual(ɵmakeParsedTranslation(\n+                    ['', ' tnemele elbatalsnart ', 'sredlohecalp htiw', ''],\n+                    ['INTERPOLATION', 'START_BOLD_TEXT', 'CLOSE_BOLD_TEXT']));\n+          });\n+\n+          describe('[structure errors]', () => {\n+            it('should provide a diagnostic warning when a trans-unit has no translation target but does have a source',\n+               () => {\n+                 const XLIFF = [\n+                   `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n+                   `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n+                   `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+                   `    <unit id=\"missingtarget\">`,\n+                   `      <segment>`,\n+                   `        <source/>`,\n+                   `      </segment>`,\n+                   `    </unit>`,\n+                   `  </file>`,\n+                   `</xliff>`,\n+                 ].join('\\n');\n+\n+                 const result = doParse('/some/file.xlf', XLIFF);\n+                 expect(result.diagnostics.messages.length).toEqual(1);\n+                 expect(result.diagnostics.messages[0].message).toEqual([\n+                   `Missing <target> element (\"`,\n+                   `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+                   `    <unit id=\"missingtarget\">`,\n+                   `      [WARNING ->]<segment>`,\n+                   `        <source/>`,\n+                   `      </segment>`,\n+                   `\"): /some/file.xlf@4:6`,\n+                 ].join('\\n'));\n+               });\n+\n+            it('should provide a diagnostic error when a trans-unit has no translation target nor source',\n+               () => {\n+                 const XLIFF = [\n+                   `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n+                   `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n+                   `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+                   `    <unit id=\"missingtarget\">`,\n+                   `      <segment>`,\n+                   `      </segment>`,\n+                   `    </unit>`,\n+                   `  </file>`,\n+                   `</xliff>`,\n+                 ].join('\\n');\n+\n+                 expectToFail(\n+                     '/some/file.xlf', XLIFF,\n+                     /Missing required element: one of <target> or <source> is required/, [\n+                       `Missing required element: one of <target> or <source> is required (\"`,\n+                       `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+                       `    <unit id=\"missingtarget\">`,\n+                       `      [ERROR ->]<segment>`,\n+                       `      </segment>`,\n+                       `    </unit>`,\n+                       `\"): /some/file.xlf@4:6`,\n+                     ].join('\\n'));\n+               });\n+\n+\n+            it('should provide a diagnostic error when a trans-unit has no id attribute', () => {\n+              const XLIFF = [\n+                `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n+                `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n+                `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+                `    <unit>`,\n+                `      <segment>`,\n+                `        <source/>`,\n+                `        <target/>`,\n+                `      </segment>`,\n+                `    </unit>`,\n+                `  </file>`,\n+                `</xliff>`,\n+              ].join('\\n');\n+\n+              expectToFail('/some/file.xlf', XLIFF, /Missing required \"id\" attribute/, [\n+                `Missing required \"id\" attribute on <trans-unit> element. (\"s:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n+                `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+                `    [ERROR ->]<unit>`,\n+                `      <segment>`,\n+                `        <source/>`,\n+                `\"): /some/file.xlf@3:4`,\n+              ].join('\\n'));\n+            });\n \n-                it('should provide a diagnostic error when a trans-unit has no id attribute', () => {\n-                  const XLIFF = [\n-                    `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n-                    `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n-                    `  <file original=\"ng.template\" id=\"ngi18n\">`,\n-                    `    <unit>`,\n-                    `      <segment>`,\n-                    `        <source/>`,\n-                    `        <target/>`,\n+            it('should provide a diagnostic error on duplicate trans-unit id', () => {\n+              const XLIFF = [\n+                `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n+                `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n+                `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+                `    <unit id=\"deadbeef\">`,\n+                `      <segment>`,\n+                `        <source/>`,\n+                `        <target/>`,\n+                `      </segment>`,\n+                `    </unit>`,\n+                `    <unit id=\"deadbeef\">`,\n+                `      <segment>`,\n+                `        <source/>`,\n+                `        <target/>`,\n+                `      </segment>`,\n+                `    </unit>`,\n+                `  </file>`,\n+                `</xliff>`,\n+              ].join('\\n');\n+\n+              expectToFail(\n+                  '/some/file.xlf', XLIFF, /Duplicated translations for message \"deadbeef\"/, [\n+                    `Duplicated translations for message \"deadbeef\" (\"`,\n                     `      </segment>`,\n                     `    </unit>`,\n-                    `  </file>`,\n-                    `</xliff>`,\n-                  ].join('\\n');\n-\n-                  expectToFail('/some/file.xlf', XLIFF, /Missing required \"id\" attribute/, [\n-                    `Missing required \"id\" attribute on <trans-unit> element. (\"s:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n-                    `  <file original=\"ng.template\" id=\"ngi18n\">`,\n-                    `    [ERROR ->]<unit>`,\n+                    `    [ERROR ->]<unit id=\"deadbeef\">`,\n                     `      <segment>`,\n                     `        <source/>`,\n-                    `\"): /some/file.xlf@3:4`,\n+                    '\"): /some/file.xlf@9:4',\n                   ].join('\\n'));\n-                });\n-\n-                it('should provide a diagnostic error on duplicate trans-unit id', () => {\n-                  const XLIFF = [\n-                    `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n-                    `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n-                    `  <file original=\"ng.template\" id=\"ngi18n\">`,\n-                    `    <unit id=\"deadbeef\">`,\n-                    `      <segment>`,\n-                    `        <source/>`,\n-                    `        <target/>`,\n-                    `      </segment>`,\n-                    `    </unit>`,\n-                    `    <unit id=\"deadbeef\">`,\n-                    `      <segment>`,\n-                    `        <source/>`,\n-                    `        <target/>`,\n-                    `      </segment>`,\n-                    `    </unit>`,\n-                    `  </file>`,\n-                    `</xliff>`,\n-                  ].join('\\n');\n-\n-                  expectToFail(\n-                      '/some/file.xlf', XLIFF, /Duplicated translations for message \"deadbeef\"/, [\n-                        `Duplicated translations for message \"deadbeef\" (\"`,\n-                        `      </segment>`,\n-                        `    </unit>`,\n-                        `    [ERROR ->]<unit id=\"deadbeef\">`,\n-                        `      <segment>`,\n-                        `        <source/>`,\n-                        '\"): /some/file.xlf@9:4',\n-                      ].join('\\n'));\n-                });\n-              });\n-\n-              describe('[message errors]', () => {\n-                it('should provide a diagnostic error on unknown message tags', () => {\n-                  const XLIFF = [\n-                    `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n-                    `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n-                    `  <file original=\"ng.template\" id=\"ngi18n\">`,\n-                    `    <unit id=\"deadbeef\">`,\n-                    `      <segment>`,\n-                    `        <source/>`,\n-                    `        <target><b>msg should contain only ph and pc tags</b></target>`,\n-                    `      </segment>`,\n-                    `    </unit>`,\n-                    `  </file>`,\n-                    `</xliff>`,\n-                  ].join('\\n');\n-\n-                  expectToFail('/some/file.xlf', XLIFF, /Invalid element found in message/, [\n-                    `Error: Invalid element found in message.`,\n-                    `At /some/file.xlf@6:16:`,\n-                    `...`,\n-                    `        <source/>`,\n-                    `        <target>[ERROR ->]<b>msg should contain only ph and pc tags</b></target>`,\n-                    `      </segment>`,\n-                    `...`,\n-                    ``,\n-                  ].join('\\n'));\n-                });\n+            });\n+          });\n+\n+          describe('[message errors]', () => {\n+            it('should provide a diagnostic error on unknown message tags', () => {\n+              const XLIFF = [\n+                `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n+                `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n+                `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+                `    <unit id=\"deadbeef\">`,\n+                `      <segment>`,\n+                `        <source/>`,\n+                `        <target><b>msg should contain only ph and pc tags</b></target>`,\n+                `      </segment>`,\n+                `    </unit>`,\n+                `  </file>`,\n+                `</xliff>`,\n+              ].join('\\n');\n+\n+              expectToFail('/some/file.xlf', XLIFF, /Invalid element found in message/, [\n+                `Error: Invalid element found in message.`,\n+                `At /some/file.xlf@6:16:`,\n+                `...`,\n+                `        <source/>`,\n+                `        <target>[ERROR ->]<b>msg should contain only ph and pc tags</b></target>`,\n+                `      </segment>`,\n+                `...`,\n+                ``,\n+              ].join('\\n'));\n+            });\n \n-                it('should provide a diagnostic error when a placeholder misses an id attribute',\n-                   () => {\n-                     const XLIFF = [\n-                       `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n-                       `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n-                       `  <file original=\"ng.template\" id=\"ngi18n\">`,\n-                       `    <unit id=\"deadbeef\">`,\n-                       `      <segment>`,\n-                       `        <source/>`,\n-                       `        <target><ph/></target>`,\n-                       `      </segment>`,\n-                       `    </unit>`,\n-                       `  </file>`,\n-                       `</xliff>`,\n-                     ].join('\\n');\n-\n-                     expectToFail('/some/file.xlf', XLIFF, /Missing required \"equiv\" attribute/, [\n-                       `Error: Missing required \"equiv\" attribute:`,\n-                       `At /some/file.xlf@6:16:`,\n-                       `...`,\n-                       `        <source/>`,\n-                       `        <target>[ERROR ->]<ph/></target>`,\n-                       `      </segment>`,\n-                       `...`,\n-                       ``,\n-                     ].join('\\n'));\n-                   });\n-              });\n+            it('should provide a diagnostic error when a placeholder misses an id attribute', () => {\n+              const XLIFF = [\n+                `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>`,\n+                `<xliff version=\"2.0\" xmlns=\"urn:oasis:names:tc:xliff:document:2.0\" srcLang=\"en\" trgLang=\"fr\">`,\n+                `  <file original=\"ng.template\" id=\"ngi18n\">`,\n+                `    <unit id=\"deadbeef\">`,\n+                `      <segment>`,\n+                `        <source/>`,\n+                `        <target><ph/></target>`,\n+                `      </segment>`,\n+                `    </unit>`,\n+                `  </file>`,\n+                `</xliff>`,\n+              ].join('\\n');\n+\n+              expectToFail('/some/file.xlf', XLIFF, /Missing required \"equiv\" attribute/, [\n+                `Error: Missing required \"equiv\" attribute:`,\n+                `At /some/file.xlf@6:16:`,\n+                `...`,\n+                `        <source/>`,\n+                `        <target>[ERROR ->]<ph/></target>`,\n+                `      </segment>`,\n+                `...`,\n+                ``,\n+              ].join('\\n'));\n             });\n-      }\n-    });\n+          });\n+        });\n+  }\n+});"
        }
    ],
    "stats": {
        "total": 2928,
        "additions": 1505,
        "deletions": 1423
    }
}