{
    "author": "ayazhafiz",
    "message": "feat(compiler): recover expression parsing in more malformed pipe cases (#39437)\n\nThis commit handles the following cases:\n- incomplete pipes in a pipe chain\n- incomplete arguments in a pipe chain\n- incomplete arguments provided to a pipe\n- nested pipes\n\nThe idea is to unconditionally recover on the presence of a pipe, which\nshould be okay because expression parsing can be independently between\npipes.\n\nPR Close #39437",
    "sha": "e3365724f2f05007da38ed8d452eaeeb34196cc3",
    "files": [
        {
            "sha": "7d1cc1f4a40e770846a7869db6cd4418ed9ce82e",
            "filename": "packages/compiler/src/expression_parser/parser.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 14,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/e3365724f2f05007da38ed8d452eaeeb34196cc3/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "raw_url": "https://github.com/angular/angular/raw/e3365724f2f05007da38ed8d452eaeeb34196cc3/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts?ref=e3365724f2f05007da38ed8d452eaeeb34196cc3",
            "patch": "@@ -1113,28 +1113,33 @@ export class _ParseAST {\n   }\n \n   /**\n-   * Error recovery should skip tokens until it encounters a recovery point. skip() treats\n-   * the end of input and a ';' as unconditionally a recovery point. It also treats ')',\n-   * '}' and ']' as conditional recovery points if one of calling productions is expecting\n-   * one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing\n-   * more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because\n-   * of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols\n-   * must be conditional as they must be skipped if none of the calling productions are not\n-   * expecting the closing token else we will never make progress in the case of an\n-   * extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because\n-   * parseChain() is always the root production and it expects a ';'.\n+   * Error recovery should skip tokens until it encounters a recovery point.\n    *\n-   * Furthermore, the presence of a stateful context can add more recovery points.\n-   *   - in a `Writable` context, we are able to recover after seeing the `=` operator, which\n-   *     signals the presence of an independent rvalue expression following the `=` operator.\n+   * The following are treated as unconditional recovery points:\n+   *   - end of input\n+   *   - ';' (parseChain() is always the root production, and it expects a ';')\n+   *   - '|' (since pipes may be chained and each pipe expression may be treated independently)\n+   *\n+   * The following are conditional recovery points:\n+   *   - ')', '}', ']' if one of calling productions is expecting one of these symbols\n+   *     - This allows skip() to recover from errors such as '(a.) + 1' allowing more of the AST to\n+   *       be retained (it doesn't skip any tokens as the ')' is retained because of the '(' begins\n+   *       an '(' <expr> ')' production).\n+   *       The recovery points of grouping symbols must be conditional as they must be skipped if\n+   *       none of the calling productions are not expecting the closing token else we will never\n+   *       make progress in the case of an extraneous group closing symbol (such as a stray ')').\n+   *       That is, we skip a closing symbol if we are not in a grouping production.\n+   *   - '=' in a `Writable` context\n+   *     - In this context, we are able to recover after seeing the `=` operator, which\n+   *       signals the presence of an independent rvalue expression following the `=` operator.\n    *\n    * If a production expects one of these token it increments the corresponding nesting count,\n    * and then decrements it just prior to checking if the token is in the input.\n    */\n   private skip() {\n     let n = this.next;\n     while (this.index < this.tokens.length && !n.isCharacter(chars.$SEMICOLON) &&\n-           (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n+           !n.isOperator('|') && (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n            (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n            (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET)) &&\n            (!(this.context & ParseContextFlags.Writable) || !n.isOperator('='))) {"
        },
        {
            "sha": "e763fd42fa0db38f57634cbb897586aca6261e43",
            "filename": "packages/compiler/test/expression_parser/parser_spec.ts",
            "status": "modified",
            "additions": 46,
            "deletions": 3,
            "changes": 49,
            "blob_url": "https://github.com/angular/angular/blob/e3365724f2f05007da38ed8d452eaeeb34196cc3/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e3365724f2f05007da38ed8d452eaeeb34196cc3/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts?ref=e3365724f2f05007da38ed8d452eaeeb34196cc3",
            "patch": "@@ -393,9 +393,52 @@ describe('parser', () => {\n         checkBinding('a | b:(c | d)', '(a | b:(c | d))');\n       });\n \n-      it('should parse incomplete pipes', () => {\n-        checkBinding('a | b | ', '((a | b) | )');\n-        expectBindingError('a | b | ', 'Unexpected end of input, expected identifier or keyword');\n+      describe('should parse incomplete pipes', () => {\n+        const cases: Array<[string, string, string, string]> = [\n+          [\n+            'should parse missing pipe names: end',\n+            'a | b | ',\n+            '((a | b) | )',\n+            'Unexpected end of input, expected identifier or keyword',\n+          ],\n+          [\n+            'should parse missing pipe names: middle',\n+            'a | | b',\n+            '((a | ) | b)',\n+            'Unexpected token |, expected identifier or keyword',\n+          ],\n+          [\n+            'should parse missing pipe names: start',\n+            ' | a | b',\n+            '(( | a) | b)',\n+            'Unexpected token |',\n+          ],\n+          [\n+            'should parse missing pipe args: end',\n+            'a | b | c: ',\n+            '((a | b) | c:)',\n+            'Unexpected end of expression',\n+          ],\n+          [\n+            'should parse missing pipe args: middle',\n+            'a | b: | c',\n+            '((a | b:) | c)',\n+            'Unexpected token |',\n+          ],\n+          [\n+            'should parse incomplete pipe args',\n+            'a | b: (a | ) + | c',\n+            '((a | b:(a | ) + ) | c)',\n+            'Unexpected token |',\n+          ],\n+        ];\n+\n+        for (const [name, input, output, err] of cases) {\n+          it(name, () => {\n+            checkBinding(input, output);\n+            expectBindingError(input, err);\n+          });\n+        }\n       });\n \n       it('should only allow identifier or keyword as formatter names', () => {"
        }
    ],
    "stats": {
        "total": 82,
        "additions": 65,
        "deletions": 17
    }
}