{
    "author": "atscott",
    "message": "refactor(language-service): Have TemplateTarget recognize two way bindings (#40185)\n\nAdjust the visitor logic of the template target as well as the\nconsumption of the visitor result to account for two-way bindings.\n\nThis sets up downstream consumers for being able to handle the\npossibility of a template position that targets both an input and an\noutput.\n\nPR Close #40185",
    "sha": "d70c26cc067ee90e72114507747c67d7b68e9423",
    "files": [
        {
            "sha": "09650a2df34475bac037c12504a0aa5f1d3b71c9",
            "filename": "packages/language-service/ivy/template_target.ts",
            "status": "modified",
            "additions": 50,
            "deletions": 44,
            "changes": 94,
            "blob_url": "https://github.com/angular/angular/blob/d70c26cc067ee90e72114507747c67d7b68e9423/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "raw_url": "https://github.com/angular/angular/raw/d70c26cc067ee90e72114507747c67d7b68e9423/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftemplate_target.ts?ref=d70c26cc067ee90e72114507747c67d7b68e9423",
            "patch": "@@ -156,11 +156,6 @@ export function getTargetAtPosition(template: t.Node[], position: number): Templ\n     }\n   }\n \n-  let parent: t.Node|e.AST|null = null;\n-  if (path.length >= 2) {\n-    parent = path[path.length - 2];\n-  }\n-\n   // Given the candidate node, determine the full targeted context.\n   let nodeInContext: TargetContext;\n   if (candidate instanceof e.AST) {\n@@ -191,7 +186,16 @@ export function getTargetAtPosition(template: t.Node[], position: number): Templ\n       (candidate instanceof t.BoundAttribute || candidate instanceof t.BoundEvent ||\n        candidate instanceof t.TextAttribute) &&\n       candidate.keySpan !== undefined) {\n-    if (isWithin(position, candidate.keySpan)) {\n+    const previousCandidate = path[path.length - 2];\n+    if (candidate instanceof t.BoundEvent && previousCandidate instanceof t.BoundAttribute &&\n+        candidate.name === previousCandidate.name + 'Change') {\n+      const boundAttribute: t.BoundAttribute = previousCandidate;\n+      const boundEvent: t.BoundEvent = candidate;\n+      nodeInContext = {\n+        kind: TargetNodeKind.TwoWayBindingContext,\n+        nodes: [boundAttribute, boundEvent],\n+      };\n+    } else if (isWithin(position, candidate.keySpan)) {\n       nodeInContext = {\n         kind: TargetNodeKind.AttributeInKeyContext,\n         node: candidate,\n@@ -209,6 +213,13 @@ export function getTargetAtPosition(template: t.Node[], position: number): Templ\n     };\n   }\n \n+  let parent: t.Node|e.AST|null = null;\n+  if (nodeInContext.kind === TargetNodeKind.TwoWayBindingContext && path.length >= 3) {\n+    parent = path[path.length - 3];\n+  } else if (path.length >= 2) {\n+    parent = path[path.length - 2];\n+  }\n+\n   return {position, context: nodeInContext, template: context, parent};\n }\n \n@@ -247,20 +258,25 @@ class TemplateTargetVisitor implements t.Visitor {\n   private constructor(private readonly position: number) {}\n \n   visit(node: t.Node) {\n-    const last: t.Node|e.AST|undefined = this.path[this.path.length - 1];\n-    if (last && isTemplateNodeWithKeyAndValue(last) && isWithin(this.position, last.keySpan)) {\n-      // We've already identified that we are within a `keySpan` of a node.\n-      // We should stop processing nodes at this point to prevent matching\n-      // any other nodes. This can happen when the end span of a different node\n-      // touches the start of the keySpan for the candidate node. Because\n-      // our `isWithin` logic is inclusive on both ends, we can match both nodes.\n-      return;\n-    }\n     const {start, end} = getSpanIncludingEndTag(node);\n     if (!isWithin(this.position, {start, end})) {\n       return;\n     }\n \n+    const last: t.Node|e.AST|undefined = this.path[this.path.length - 1];\n+    const withinKeySpanOfLastNode =\n+        last && isTemplateNodeWithKeyAndValue(last) && isWithin(this.position, last.keySpan);\n+    const withinKeySpanOfCurrentNode =\n+        isTemplateNodeWithKeyAndValue(node) && isWithin(this.position, node.keySpan);\n+    if (withinKeySpanOfLastNode && !withinKeySpanOfCurrentNode) {\n+      // We've already identified that we are within a `keySpan` of a node.\n+      // Unless we are _also_ in the `keySpan` of the current node (happens with two way bindings),\n+      // we should stop processing nodes at this point to prevent matching any other nodes. This can\n+      // happen when the end span of a different node touches the start of the keySpan for the\n+      // candidate node. Because our `isWithin` logic is inclusive on both ends, we can match both\n+      // nodes.\n+      return;\n+    }\n     if (isTemplateNodeWithKeyAndValue(node) && !isWithinKeyValue(this.position, node)) {\n       // If cursor is within source span but not within key span or value span,\n       // do not return the node.\n@@ -272,31 +288,33 @@ class TemplateTargetVisitor implements t.Visitor {\n   }\n \n   visitElement(element: t.Element) {\n+    this.visitElementOrTemplate(element);\n+  }\n+\n+\n+  visitTemplate(template: t.Template) {\n+    this.visitElementOrTemplate(template);\n+  }\n+\n+  visitElementOrTemplate(element: t.Template|t.Element) {\n     this.visitAll(element.attributes);\n     this.visitAll(element.inputs);\n     this.visitAll(element.outputs);\n+    if (element instanceof t.Template) {\n+      this.visitAll(element.templateAttrs);\n+    }\n     this.visitAll(element.references);\n-    const last: t.Node|e.AST|undefined = this.path[this.path.length - 1];\n+    if (element instanceof t.Template) {\n+      this.visitAll(element.variables);\n+    }\n+\n     // If we get here and have not found a candidate node on the element itself, proceed with\n     // looking for a more specific node on the element children.\n-    if (last === element) {\n-      this.visitAll(element.children);\n+    if (this.path[this.path.length - 1] !== element) {\n+      return;\n     }\n-  }\n \n-  visitTemplate(template: t.Template) {\n-    this.visitAll(template.attributes);\n-    this.visitAll(template.inputs);\n-    this.visitAll(template.outputs);\n-    this.visitAll(template.templateAttrs);\n-    this.visitAll(template.references);\n-    this.visitAll(template.variables);\n-    const last: t.Node|e.AST|undefined = this.path[this.path.length - 1];\n-    // If we get here and have not found a candidate node on the template itself, proceed with\n-    // looking for a more specific node on the template children.\n-    if (last === template) {\n-      this.visitAll(template.children);\n-    }\n+    this.visitAll(element.children);\n   }\n \n   visitContent(content: t.Content) {\n@@ -321,18 +339,6 @@ class TemplateTargetVisitor implements t.Visitor {\n   }\n \n   visitBoundEvent(event: t.BoundEvent) {\n-    const isTwoWayBinding =\n-        this.path.some(n => n instanceof t.BoundAttribute && event.name === n.name + 'Change');\n-    if (isTwoWayBinding) {\n-      // For two-way binding aka banana-in-a-box, there are two matches:\n-      // BoundAttribute and BoundEvent. Both have the same spans. We choose to\n-      // return BoundAttribute because it matches the identifier name verbatim.\n-      // TODO: For operations like go to definition, ideally we want to return\n-      // both.\n-      this.path.pop();  // remove bound event from the AST path\n-      return;\n-    }\n-\n     // An event binding with no value (e.g. `(event|)`) parses to a `BoundEvent` with a\n     // `LiteralPrimitive` handler with value `'ERROR'`, as opposed to a property binding with no\n     // value which has an `EmptyExpr` as its value. This is a synthetic node created by the binding"
        },
        {
            "sha": "56b62ade241673c326c97b4d6eb13dd9eeeb89e5",
            "filename": "packages/language-service/ivy/test/legacy/template_target_spec.ts",
            "status": "modified",
            "additions": 26,
            "deletions": 17,
            "changes": 43,
            "blob_url": "https://github.com/angular/angular/blob/d70c26cc067ee90e72114507747c67d7b68e9423/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/d70c26cc067ee90e72114507747c67d7b68e9423/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts?ref=d70c26cc067ee90e72114507747c67d7b68e9423",
            "patch": "@@ -10,7 +10,7 @@ import {ParseError, parseTemplate} from '@angular/compiler';\n import * as e from '@angular/compiler/src/expression_parser/ast';  // e for expression AST\n import * as t from '@angular/compiler/src/render3/r3_ast';         // t for template AST\n \n-import {getTargetAtPosition, SingleNodeTarget, TargetNodeKind} from '../../template_target';\n+import {getTargetAtPosition, SingleNodeTarget, TargetNodeKind, TwoWayBindingContext} from '../../template_target';\n import {isExpressionNode, isTemplateNode} from '../../utils';\n \n interface ParseResult {\n@@ -180,11 +180,11 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate template bound attribute key in two-way binding', () => {\n     const {errors, nodes, position} = parse(`<ng-template [(f¦oo)]=\"bar\"></ng-template>`);\n     expect(errors).toBe(null);\n-    const {context} = getTargetAtPosition(nodes, position)!;\n-    const {node} = context as SingleNodeTarget;\n-    expect(isTemplateNode(node!)).toBe(true);\n-    expect(node).toBeInstanceOf(t.BoundAttribute);\n-    expect((node as t.BoundAttribute).name).toBe('foo');\n+    const {context, parent} = getTargetAtPosition(nodes, position)!;\n+    expect(parent).toBeInstanceOf(t.Template);\n+    const {nodes: [boundAttribute, boundEvent]} = context as TwoWayBindingContext;\n+    expect(boundAttribute.name).toBe('foo');\n+    expect(boundEvent.name).toBe('fooChange');\n   });\n \n   it('should locate template bound attribute value in two-way binding', () => {\n@@ -193,8 +193,12 @@ describe('getTargetAtPosition for template AST', () => {\n     const {context} = getTargetAtPosition(nodes, position)!;\n     const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n-    expect(node).toBeInstanceOf(e.PropertyRead);\n-    expect((node as e.PropertyRead).name).toBe('bar');\n+    // It doesn't actually matter if the template target returns the read or the write.\n+    // When the template target returns a property read, we only use the LHS downstream because the\n+    // RHS would have its own node in the AST that would have been returned instead. The LHS of the\n+    // `e.PropertyWrite` is the same as the `e.PropertyRead`.\n+    expect((node instanceof e.PropertyRead) || (node instanceof e.PropertyWrite)).toBeTrue();\n+    expect((node as e.PropertyRead | e.PropertyWrite).name).toBe('bar');\n   });\n \n   it('should locate template bound event key', () => {\n@@ -342,21 +346,26 @@ describe('getTargetAtPosition for template AST', () => {\n   it('should locate bound attribute key in two-way binding', () => {\n     const {errors, nodes, position} = parse(`<cmp [(f¦oo)]=\"bar\"></cmp>`);\n     expect(errors).toBe(null);\n-    const {context} = getTargetAtPosition(nodes, position)!;\n-    const {node} = context as SingleNodeTarget;\n-    expect(isTemplateNode(node!)).toBe(true);\n-    expect(node).toBeInstanceOf(t.BoundAttribute);\n-    expect((node as t.BoundAttribute).name).toBe('foo');\n+    const {context, parent} = getTargetAtPosition(nodes, position)!;\n+    expect(parent).toBeInstanceOf(t.Element);\n+    const {nodes: [boundAttribute, boundEvent]} = context as TwoWayBindingContext;\n+    expect(boundAttribute.name).toBe('foo');\n+    expect(boundEvent.name).toBe('fooChange');\n   });\n \n-  it('should locate bound attribute value in two-way binding', () => {\n+  it('should locate node when in value span of two-way binding', () => {\n     const {errors, nodes, position} = parse(`<cmp [(foo)]=\"b¦ar\"></cmp>`);\n     expect(errors).toBe(null);\n-    const {context} = getTargetAtPosition(nodes, position)!;\n+    const {context, parent} = getTargetAtPosition(nodes, position)!;\n+    // It doesn't actually matter if the template target returns the read or the write.\n+    // When the template target returns a property read, we only use the LHS downstream because the\n+    // RHS would have its own node in the AST that would have been returned instead. The LHS of the\n+    // `e.PropertyWrite` is the same as the `e.PropertyRead`.\n+    expect((parent instanceof t.BoundAttribute) || (parent instanceof t.BoundEvent)).toBe(true);\n     const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n-    expect(node).toBeInstanceOf(e.PropertyRead);\n-    expect((node as e.PropertyRead).name).toBe('bar');\n+    expect((node instanceof e.PropertyRead) || (node instanceof e.PropertyWrite)).toBeTrue();\n+    expect((node as e.PropertyRead | e.PropertyWrite).name).toBe('bar');\n   });\n \n   it('should locate switch value in ICUs', () => {"
        },
        {
            "sha": "57c80704f28df96144916592d7bd7ef28fea065e",
            "filename": "packages/language-service/ivy/utils.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/d70c26cc067ee90e72114507747c67d7b68e9423/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/d70c26cc067ee90e72114507747c67d7b68e9423/packages%2Flanguage-service%2Fivy%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Futils.ts?ref=d70c26cc067ee90e72114507747c67d7b68e9423",
            "patch": "@@ -54,6 +54,16 @@ export function isTemplateNodeWithKeyAndValue(node: t.Node|e.AST): node is NodeW\n   return isTemplateNode(node) && node.hasOwnProperty('keySpan');\n }\n \n+export function isWithinKey(position: number, node: NodeWithKeyAndValue): boolean {\n+  let {keySpan, valueSpan} = node;\n+  if (valueSpan === undefined && node instanceof TmplAstBoundEvent) {\n+    valueSpan = node.handlerSpan;\n+  }\n+  const isWithinKeyValue =\n+      isWithin(position, keySpan) || !!(valueSpan && isWithin(position, valueSpan));\n+  return isWithinKeyValue;\n+}\n+\n export function isWithinKeyValue(position: number, node: NodeWithKeyAndValue): boolean {\n   let {keySpan, valueSpan} = node;\n   if (valueSpan === undefined && node instanceof TmplAstBoundEvent) {"
        }
    ],
    "stats": {
        "total": 147,
        "additions": 86,
        "deletions": 61
    }
}