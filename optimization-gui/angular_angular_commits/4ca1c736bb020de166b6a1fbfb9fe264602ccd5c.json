{
    "author": "AndrewKushnir",
    "message": "fix(packaging): remove polyfills needed to run tests on IE9 and IE 10 (#38931)\n\nThis commit removes polyfills that were needed to run tests on IE 9 and IE 10.\n\nBREAKING CHANGE:\n\nIn v10, IE 9, 10, and IE mobile support was deprecated. In v11, Angular framework removes IE 9,\n10, and IE mobile support completely.\nSupporting outdated browsers like these increases bundle size, code complexity, and test load,\nand also requires time and effort that could be spent on improvements to the framework.\nFor example, fixing issues can be more difficult, as a straightforward fix for modern browsers\ncould break old ones that have quirks due to not receiving updates from vendors.\n\nPR Close #38931",
    "sha": "4ca1c736bb020de166b6a1fbfb9fe264602ccd5c",
    "files": [
        {
            "sha": "7aa8a9fc4fe4dcb8e42568178510c02d3a44437d",
            "filename": "third_party/shims_for_IE.js",
            "status": "modified",
            "additions": 0,
            "deletions": 1318,
            "changes": 1318,
            "blob_url": "https://github.com/angular/angular/blob/4ca1c736bb020de166b6a1fbfb9fe264602ccd5c/third_party%2Fshims_for_IE.js",
            "raw_url": "https://github.com/angular/angular/raw/4ca1c736bb020de166b6a1fbfb9fe264602ccd5c/third_party%2Fshims_for_IE.js",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/third_party%2Fshims_for_IE.js?ref=4ca1c736bb020de166b6a1fbfb9fe264602ccd5c",
            "patch": "@@ -89,1324 +89,6 @@ if (!Object.hasOwnProperty('name')) {\n global.URLPolyfill = URLPolyfill;\n })(typeof self != 'undefined' ? self : global);\n \n-//classList (IE9)\n-/*! @license please refer to http://unlicense.org/ */\n-/*! @author Eli Grey */\n-/*! @source https://github.com/eligrey/classList.js */\n-;if(\"document\" in self&&!(\"classList\" in document.createElement(\"_\"))){(function(j){\"use strict\";if(!(\"Element\" in j)){return}var a=\"classList\",f=\"prototype\",m=j.Element[f],b=Object,k=String[f].trim||function(){return this.replace(/^\\s+|\\s+$/g,\"\")},c=Array[f].indexOf||function(q){var p=0,o=this.length;for(;p<o;p++){if(p in this&&this[p]===q){return p}}return -1},n=function(o,p){this.name=o;this.code=DOMException[o];this.message=p},g=function(p,o){if(o===\"\"){throw new n(\"SYNTAX_ERR\",\"An invalid or illegal string was specified\")}if(/\\s/.test(o)){throw new n(\"INVALID_CHARACTER_ERR\",\"String contains an invalid character\")}return c.call(p,o)},d=function(s){var r=k.call(s.getAttribute(\"class\")||\"\"),q=r?r.split(/\\s+/):[],p=0,o=q.length;for(;p<o;p++){this.push(q[p])}this._updateClassName=function(){s.setAttribute(\"class\",this.toString())}},e=d[f]=[],i=function(){return new d(this)};n[f]=Error[f];e.item=function(o){return this[o]||null};e.contains=function(o){o+=\"\";return g(this,o)!==-1};e.add=function(){var s=arguments,r=0,p=s.length,q,o=false;do{q=s[r]+\"\";if(g(this,q)===-1){this.push(q);o=true}}while(++r<p);if(o){this._updateClassName()}};e.remove=function(){var t=arguments,s=0,p=t.length,r,o=false;do{r=t[s]+\"\";var q=g(this,r);if(q!==-1){this.splice(q,1);o=true}}while(++s<p);if(o){this._updateClassName()}};e.toggle=function(p,q){p+=\"\";var o=this.contains(p),r=o?q!==true&&\"remove\":q!==false&&\"add\";if(r){this[r](p)}return !o};e.toString=function(){return this.join(\" \")};if(b.defineProperty){var l={get:i,enumerable:true,configurable:true};try{b.defineProperty(m,a,l)}catch(h){if(h.number===-2146823252){l.enumerable=false;b.defineProperty(m,a,l)}}}else{if(b[f].__defineGetter__){m.__defineGetter__(a,i)}}}(self))};\n-\n-//console mock (IE9)\n-if (!window.console) window.console = {};\n-if (!window.console.log) window.console.log = function () { };\n-if (!window.console.error) window.console.error = function () { };\n-if (!window.console.warn) window.console.warn = function () { };\n-if (!window.console.assert) window.console.assert = function () { };\n-\n-//Typed Array (IE9)\n-/*! @source https://github.com/inexorabletash/polyfill/blob/master/typedarray.js */\n-/*\n- Copyright (c) 2010, Linden Research, Inc.\n- Copyright (c) 2014, Joshua Bell\n-\n- Permission is hereby granted, free of charge, to any person obtaining a copy\n- of this software and associated documentation files (the \"Software\"), to deal\n- in the Software without restriction, including without limitation the rights\n- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n- copies of the Software, and to permit persons to whom the Software is\n- furnished to do so, subject to the following conditions:\n-\n- The above copyright notice and this permission notice shall be included in\n- all copies or substantial portions of the Software.\n-\n- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n- THE SOFTWARE.\n- $/LicenseInfo$\n- */\n-\n-// Original can be found at:\n-//   https://bitbucket.org/lindenlab/llsd\n-// Modifications by Joshua Bell inexorabletash@gmail.com\n-//   https://github.com/inexorabletash/polyfill\n-\n-// ES3/ES5 implementation of the Krhonos Typed Array Specification\n-//   Ref: http://www.khronos.org/registry/typedarray/specs/latest/\n-//   Date: 2011-02-01\n-//\n-// Variations:\n-//  * Allows typed_array.get/set() as alias for subscripts (typed_array[])\n-//  * Gradually migrating structure from Khronos spec to ES2015 spec\n-//\n-// Caveats:\n-//  * Beyond 10000 or so entries, polyfilled array accessors (ta[0],\n-//    etc) become memory-prohibitive, so array creation will fail. Set\n-//    self.TYPED_ARRAY_POLYFILL_NO_ARRAY_ACCESSORS=true to disable\n-//    creation of accessors. Your code will need to use the\n-//    non-standard get()/set() instead, and will need to add those to\n-//    native arrays for interop.\n-(function(global) {\n-  'use strict';\n-  var undefined = (void 0); // Paranoia\n-\n-  // Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to\n-  // create, and consume so much memory, that the browser appears frozen.\n-  var MAX_ARRAY_LENGTH = 1e5;\n-\n-  // Approximations of internal ECMAScript conversion functions\n-  function Type(v) {\n-    switch(typeof v) {\n-      case 'undefined': return 'undefined';\n-      case 'boolean': return 'boolean';\n-      case 'number': return 'number';\n-      case 'string': return 'string';\n-      default: return v === null ? 'null' : 'object';\n-    }\n-  }\n-\n-  // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:\n-  function Class(v) { return Object.prototype.toString.call(v).replace(/^\\[object *|\\]$/g, ''); }\n-  function IsCallable(o) { return typeof o === 'function'; }\n-  function ToObject(v) {\n-    if (v === null || v === undefined) throw TypeError();\n-    return Object(v);\n-  }\n-  function ToInt32(v) { return v >> 0; }\n-  function ToUint32(v) { return v >>> 0; }\n-\n-  // Snapshot intrinsics\n-  var LN2 = Math.LN2,\n-    abs = Math.abs,\n-    floor = Math.floor,\n-    log = Math.log,\n-    max = Math.max,\n-    min = Math.min,\n-    pow = Math.pow,\n-    round = Math.round;\n-\n-  // emulate ES5 getter/setter API using legacy APIs\n-  // http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx\n-  // (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but\n-  // note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)\n-\n-  (function() {\n-    var orig = Object.defineProperty;\n-    var dom_only = !(function(){try{return Object.defineProperty({},'x',{});}catch(_){return false;}}());\n-\n-    if (!orig || dom_only) {\n-      Object.defineProperty = function (o, prop, desc) {\n-        // In IE8 try built-in implementation for defining properties on DOM prototypes.\n-        if (orig)\n-          try { return orig(o, prop, desc); } catch (_) {}\n-        if (o !== Object(o))\n-          throw TypeError('Object.defineProperty called on non-object');\n-        if (Object.prototype.__defineGetter__ && ('get' in desc))\n-          Object.prototype.__defineGetter__.call(o, prop, desc.get);\n-        if (Object.prototype.__defineSetter__ && ('set' in desc))\n-          Object.prototype.__defineSetter__.call(o, prop, desc.set);\n-        if ('value' in desc)\n-          o[prop] = desc.value;\n-        return o;\n-      };\n-    }\n-  }());\n-\n-  // ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)\n-  // for index in 0 ... obj.length\n-  function makeArrayAccessors(obj) {\n-    if ('TYPED_ARRAY_POLYFILL_NO_ARRAY_ACCESSORS' in global)\n-      return;\n-\n-    if (obj.length > MAX_ARRAY_LENGTH) throw RangeError('Array too large for polyfill');\n-\n-    function makeArrayAccessor(index) {\n-      Object.defineProperty(obj, index, {\n-        'get': function() { return obj._getter(index); },\n-        'set': function(v) { obj._setter(index, v); },\n-        enumerable: true,\n-        configurable: false\n-      });\n-    }\n-\n-    var i;\n-    for (i = 0; i < obj.length; i += 1) {\n-      makeArrayAccessor(i);\n-    }\n-  }\n-\n-  // Internal conversion functions:\n-  //    pack<Type>()   - take a number (interpreted as Type), output a byte array\n-  //    unpack<Type>() - take a byte array, output a Type-like number\n-\n-  function as_signed(value, bits) { var s = 32 - bits; return (value << s) >> s; }\n-  function as_unsigned(value, bits) { var s = 32 - bits; return (value << s) >>> s; }\n-\n-  function packI8(n) { return [n & 0xff]; }\n-  function unpackI8(bytes) { return as_signed(bytes[0], 8); }\n-\n-  function packU8(n) { return [n & 0xff]; }\n-  function unpackU8(bytes) { return as_unsigned(bytes[0], 8); }\n-\n-  function packU8Clamped(n) { n = round(Number(n)); return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff]; }\n-\n-  function packI16(n) { return [n & 0xff, (n >> 8) & 0xff]; }\n-  function unpackI16(bytes) { return as_signed(bytes[1] << 8 | bytes[0], 16); }\n-\n-  function packU16(n) { return [n & 0xff, (n >> 8) & 0xff]; }\n-  function unpackU16(bytes) { return as_unsigned(bytes[1] << 8 | bytes[0], 16); }\n-\n-  function packI32(n) { return [n & 0xff, (n >> 8) & 0xff, (n >> 16) & 0xff, (n >> 24) & 0xff]; }\n-  function unpackI32(bytes) { return as_signed(bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0], 32); }\n-\n-  function packU32(n) { return [n & 0xff, (n >> 8) & 0xff, (n >> 16) & 0xff, (n >> 24) & 0xff]; }\n-  function unpackU32(bytes) { return as_unsigned(bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0], 32); }\n-\n-  function packIEEE754(v, ebits, fbits) {\n-\n-    var bias = (1 << (ebits - 1)) - 1;\n-\n-    function roundToEven(n) {\n-      var w = floor(n), f = n - w;\n-      if (f < 0.5)\n-        return w;\n-      if (f > 0.5)\n-        return w + 1;\n-      return w % 2 ? w + 1 : w;\n-    }\n-\n-    // Compute sign, exponent, fraction\n-    var s, e, f;\n-    if (v !== v) {\n-      // NaN\n-      // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping\n-      e = (1 << ebits) - 1; f = pow(2, fbits - 1); s = 0;\n-    } else if (v === Infinity || v === -Infinity) {\n-      e = (1 << ebits) - 1; f = 0; s = (v < 0) ? 1 : 0;\n-    } else if (v === 0) {\n-      e = 0; f = 0; s = (1 / v === -Infinity) ? 1 : 0;\n-    } else {\n-      s = v < 0;\n-      v = abs(v);\n-\n-      if (v >= pow(2, 1 - bias)) {\n-        // Normalized\n-        e = min(floor(log(v) / LN2), 1023);\n-        var significand = v / pow(2, e);\n-        if (significand < 1) {\n-          e -= 1;\n-          significand *= 2;\n-        }\n-        if (significand >= 2) {\n-          e += 1;\n-          significand /= 2;\n-        }\n-        var d = pow(2, fbits);\n-        f = roundToEven(significand * d) - d;\n-        e += bias;\n-        if (f / d >= 1) {\n-          e += 1;\n-          f = 0;\n-        }\n-        if (e > 2 * bias) {\n-          // Overflow\n-          e = (1 << ebits) - 1;\n-          f = 0;\n-        }\n-      } else {\n-        // Denormalized\n-        e = 0;\n-        f = roundToEven(v / pow(2, 1 - bias - fbits));\n-      }\n-    }\n-\n-    // Pack sign, exponent, fraction\n-    var bits = [], i;\n-    for (i = fbits; i; i -= 1) { bits.push(f % 2 ? 1 : 0); f = floor(f / 2); }\n-    for (i = ebits; i; i -= 1) { bits.push(e % 2 ? 1 : 0); e = floor(e / 2); }\n-    bits.push(s ? 1 : 0);\n-    bits.reverse();\n-    var str = bits.join('');\n-\n-    // Bits to bytes\n-    var bytes = [];\n-    while (str.length) {\n-      bytes.unshift(parseInt(str.substring(0, 8), 2));\n-      str = str.substring(8);\n-    }\n-    return bytes;\n-  }\n-\n-  function unpackIEEE754(bytes, ebits, fbits) {\n-    // Bytes to bits\n-    var bits = [], i, j, b, str,\n-      bias, s, e, f;\n-\n-    for (i = 0; i < bytes.length; ++i) {\n-      b = bytes[i];\n-      for (j = 8; j; j -= 1) {\n-        bits.push(b % 2 ? 1 : 0); b = b >> 1;\n-      }\n-    }\n-    bits.reverse();\n-    str = bits.join('');\n-\n-    // Unpack sign, exponent, fraction\n-    bias = (1 << (ebits - 1)) - 1;\n-    s = parseInt(str.substring(0, 1), 2) ? -1 : 1;\n-    e = parseInt(str.substring(1, 1 + ebits), 2);\n-    f = parseInt(str.substring(1 + ebits), 2);\n-\n-    // Produce number\n-    if (e === (1 << ebits) - 1) {\n-      return f !== 0 ? NaN : s * Infinity;\n-    } else if (e > 0) {\n-      // Normalized\n-      return s * pow(2, e - bias) * (1 + f / pow(2, fbits));\n-    } else if (f !== 0) {\n-      // Denormalized\n-      return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));\n-    } else {\n-      return s < 0 ? -0 : 0;\n-    }\n-  }\n-\n-  function unpackF64(b) { return unpackIEEE754(b, 11, 52); }\n-  function packF64(v) { return packIEEE754(v, 11, 52); }\n-  function unpackF32(b) { return unpackIEEE754(b, 8, 23); }\n-  function packF32(v) { return packIEEE754(v, 8, 23); }\n-\n-  //\n-  // 3 The ArrayBuffer Type\n-  //\n-\n-  (function() {\n-\n-    function ArrayBuffer(length) {\n-      length = ToInt32(length);\n-      if (length < 0) throw RangeError('ArrayBuffer size is not a small enough positive integer.');\n-      Object.defineProperty(this, 'byteLength', {value: length});\n-      Object.defineProperty(this, '_bytes', {value: Array(length)});\n-\n-      for (var i = 0; i < length; i += 1)\n-        this._bytes[i] = 0;\n-    }\n-\n-    global.ArrayBuffer = global.ArrayBuffer || ArrayBuffer;\n-\n-    //\n-    // 5 The Typed Array View Types\n-    //\n-\n-    function $TypedArray$() {\n-\n-      // %TypedArray% ( length )\n-      if (!arguments.length || typeof arguments[0] !== 'object') {\n-        return (function(length) {\n-          length = ToInt32(length);\n-          if (length < 0) throw RangeError('length is not a small enough positive integer.');\n-          Object.defineProperty(this, 'length', {value: length});\n-          Object.defineProperty(this, 'byteLength', {value: length * this.BYTES_PER_ELEMENT});\n-          Object.defineProperty(this, 'buffer', {value: new ArrayBuffer(this.byteLength)});\n-          Object.defineProperty(this, 'byteOffset', {value: 0});\n-\n-        }).apply(this, arguments);\n-      }\n-\n-      // %TypedArray% ( typedArray )\n-      if (arguments.length >= 1 &&\n-        Type(arguments[0]) === 'object' &&\n-        arguments[0] instanceof $TypedArray$) {\n-        return (function(typedArray){\n-          if (this.constructor !== typedArray.constructor) throw TypeError();\n-\n-          var byteLength = typedArray.length * this.BYTES_PER_ELEMENT;\n-          Object.defineProperty(this, 'buffer', {value: new ArrayBuffer(byteLength)});\n-          Object.defineProperty(this, 'byteLength', {value: byteLength});\n-          Object.defineProperty(this, 'byteOffset', {value: 0});\n-          Object.defineProperty(this, 'length', {value: typedArray.length});\n-\n-          for (var i = 0; i < this.length; i += 1)\n-            this._setter(i, typedArray._getter(i));\n-\n-        }).apply(this, arguments);\n-      }\n-\n-      // %TypedArray% ( array )\n-      if (arguments.length >= 1 &&\n-        Type(arguments[0]) === 'object' &&\n-        !(arguments[0] instanceof $TypedArray$) &&\n-        !(arguments[0] instanceof ArrayBuffer || Class(arguments[0]) === 'ArrayBuffer')) {\n-        return (function(array) {\n-\n-          var byteLength = array.length * this.BYTES_PER_ELEMENT;\n-          Object.defineProperty(this, 'buffer', {value: new ArrayBuffer(byteLength)});\n-          Object.defineProperty(this, 'byteLength', {value: byteLength});\n-          Object.defineProperty(this, 'byteOffset', {value: 0});\n-          Object.defineProperty(this, 'length', {value: array.length});\n-\n-          for (var i = 0; i < this.length; i += 1) {\n-            var s = array[i];\n-            this._setter(i, Number(s));\n-          }\n-        }).apply(this, arguments);\n-      }\n-\n-      // %TypedArray% ( buffer, byteOffset=0, length=undefined )\n-      if (arguments.length >= 1 &&\n-        Type(arguments[0]) === 'object' &&\n-        (arguments[0] instanceof ArrayBuffer || Class(arguments[0]) === 'ArrayBuffer')) {\n-        return (function(buffer, byteOffset, length) {\n-\n-          byteOffset = ToUint32(byteOffset);\n-          if (byteOffset > buffer.byteLength)\n-            throw RangeError('byteOffset out of range');\n-\n-          // The given byteOffset must be a multiple of the element\n-          // size of the specific type, otherwise an exception is raised.\n-          if (byteOffset % this.BYTES_PER_ELEMENT)\n-            throw RangeError('buffer length minus the byteOffset is not a multiple of the element size.');\n-\n-          if (length === undefined) {\n-            var byteLength = buffer.byteLength - byteOffset;\n-            if (byteLength % this.BYTES_PER_ELEMENT)\n-              throw RangeError('length of buffer minus byteOffset not a multiple of the element size');\n-            length = byteLength / this.BYTES_PER_ELEMENT;\n-\n-          } else {\n-            length = ToUint32(length);\n-            byteLength = length * this.BYTES_PER_ELEMENT;\n-          }\n-\n-          if ((byteOffset + byteLength) > buffer.byteLength)\n-            throw RangeError('byteOffset and length reference an area beyond the end of the buffer');\n-\n-          Object.defineProperty(this, 'buffer', {value: buffer});\n-          Object.defineProperty(this, 'byteLength', {value: byteLength});\n-          Object.defineProperty(this, 'byteOffset', {value: byteOffset});\n-          Object.defineProperty(this, 'length', {value: length});\n-\n-        }).apply(this, arguments);\n-      }\n-\n-      // %TypedArray% ( all other argument combinations )\n-      throw TypeError();\n-    }\n-\n-    // Properties of the %TypedArray Instrinsic Object\n-\n-    // %TypedArray%.from ( source , mapfn=undefined, thisArg=undefined )\n-    Object.defineProperty($TypedArray$, 'from', {value: function(iterable) {\n-      return new this(iterable);\n-    }});\n-\n-    // %TypedArray%.of ( ...items )\n-    Object.defineProperty($TypedArray$, 'of', {value: function(/*...items*/) {\n-      return new this(arguments);\n-    }});\n-\n-    // %TypedArray%.prototype\n-    var $TypedArrayPrototype$ = {};\n-    $TypedArray$.prototype = $TypedArrayPrototype$;\n-\n-    // WebIDL: getter type (unsigned long index);\n-    Object.defineProperty($TypedArray$.prototype, '_getter', {value: function(index) {\n-      if (arguments.length < 1) throw SyntaxError('Not enough arguments');\n-\n-      index = ToUint32(index);\n-      if (index >= this.length)\n-        return undefined;\n-\n-      var bytes = [], i, o;\n-      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;\n-           i < this.BYTES_PER_ELEMENT;\n-           i += 1, o += 1) {\n-        bytes.push(this.buffer._bytes[o]);\n-      }\n-      return this._unpack(bytes);\n-    }});\n-\n-    // NONSTANDARD: convenience alias for getter: type get(unsigned long index);\n-    Object.defineProperty($TypedArray$.prototype, 'get', {value: $TypedArray$.prototype._getter});\n-\n-    // WebIDL: setter void (unsigned long index, type value);\n-    Object.defineProperty($TypedArray$.prototype, '_setter', {value: function(index, value) {\n-      if (arguments.length < 2) throw SyntaxError('Not enough arguments');\n-\n-      index = ToUint32(index);\n-      if (index >= this.length)\n-        return;\n-\n-      var bytes = this._pack(value), i, o;\n-      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;\n-           i < this.BYTES_PER_ELEMENT;\n-           i += 1, o += 1) {\n-        this.buffer._bytes[o] = bytes[i];\n-      }\n-    }});\n-\n-    // get %TypedArray%.prototype.buffer\n-    // get %TypedArray%.prototype.byteLength\n-    // get %TypedArray%.prototype.byteOffset\n-    // -- applied directly to the object in the constructor\n-\n-    // %TypedArray%.prototype.constructor\n-    Object.defineProperty($TypedArray$.prototype, 'constructor', {value: $TypedArray$});\n-\n-    // %TypedArray%.prototype.copyWithin (target, start, end = this.length )\n-    Object.defineProperty($TypedArray$.prototype, 'copyWithin', {value: function(target, start) {\n-      var end = arguments[2];\n-\n-      var o = ToObject(this);\n-      var lenVal = o.length;\n-      var len = ToUint32(lenVal);\n-      len = max(len, 0);\n-      var relativeTarget = ToInt32(target);\n-      var to;\n-      if (relativeTarget < 0)\n-        to = max(len + relativeTarget, 0);\n-      else\n-        to = min(relativeTarget, len);\n-      var relativeStart = ToInt32(start);\n-      var from;\n-      if (relativeStart < 0)\n-        from = max(len + relativeStart, 0);\n-      else\n-        from = min(relativeStart, len);\n-      var relativeEnd;\n-      if (end === undefined)\n-        relativeEnd = len;\n-      else\n-        relativeEnd = ToInt32(end);\n-      var final;\n-      if (relativeEnd < 0)\n-        final = max(len + relativeEnd, 0);\n-      else\n-        final = min(relativeEnd, len);\n-      var count = min(final - from, len - to);\n-      var direction;\n-      if (from < to && to < from + count) {\n-        direction = -1;\n-        from = from + count - 1;\n-        to = to + count - 1;\n-      } else {\n-        direction = 1;\n-      }\n-      while (count > 0) {\n-        o._setter(to, o._getter(from));\n-        from = from + direction;\n-        to = to + direction;\n-        count = count - 1;\n-      }\n-      return o;\n-    }});\n-\n-    // %TypedArray%.prototype.entries ( )\n-    // -- defined in es6.js to shim browsers w/ native TypedArrays\n-\n-    // %TypedArray%.prototype.every ( callbackfn, thisArg = undefined )\n-    Object.defineProperty($TypedArray$.prototype, 'every', {value: function(callbackfn) {\n-      if (this === undefined || this === null) throw TypeError();\n-      var t = Object(this);\n-      var len = ToUint32(t.length);\n-      if (!IsCallable(callbackfn)) throw TypeError();\n-      var thisArg = arguments[1];\n-      for (var i = 0; i < len; i++) {\n-        if (!callbackfn.call(thisArg, t._getter(i), i, t))\n-          return false;\n-      }\n-      return true;\n-    }});\n-\n-    // %TypedArray%.prototype.fill (value, start = 0, end = this.length )\n-    Object.defineProperty($TypedArray$.prototype, 'fill', {value: function(value) {\n-      var start = arguments[1],\n-        end = arguments[2];\n-\n-      var o = ToObject(this);\n-      var lenVal = o.length;\n-      var len = ToUint32(lenVal);\n-      len = max(len, 0);\n-      var relativeStart = ToInt32(start);\n-      var k;\n-      if (relativeStart < 0)\n-        k = max((len + relativeStart), 0);\n-      else\n-        k = min(relativeStart, len);\n-      var relativeEnd;\n-      if (end === undefined)\n-        relativeEnd = len;\n-      else\n-        relativeEnd = ToInt32(end);\n-      var final;\n-      if (relativeEnd < 0)\n-        final = max((len + relativeEnd), 0);\n-      else\n-        final = min(relativeEnd, len);\n-      while (k < final) {\n-        o._setter(k, value);\n-        k += 1;\n-      }\n-      return o;\n-    }});\n-\n-    // %TypedArray%.prototype.filter ( callbackfn, thisArg = undefined )\n-    Object.defineProperty($TypedArray$.prototype, 'filter', {value: function(callbackfn) {\n-      if (this === undefined || this === null) throw TypeError();\n-      var t = Object(this);\n-      var len = ToUint32(t.length);\n-      if (!IsCallable(callbackfn)) throw TypeError();\n-      var res = [];\n-      var thisp = arguments[1];\n-      for (var i = 0; i < len; i++) {\n-        var val = t._getter(i); // in case fun mutates this\n-        if (callbackfn.call(thisp, val, i, t))\n-          res.push(val);\n-      }\n-      return new this.constructor(res);\n-    }});\n-\n-    // %TypedArray%.prototype.find (predicate, thisArg = undefined)\n-    Object.defineProperty($TypedArray$.prototype, 'find', {value: function(predicate) {\n-      var o = ToObject(this);\n-      var lenValue = o.length;\n-      var len = ToUint32(lenValue);\n-      if (!IsCallable(predicate)) throw TypeError();\n-      var t = arguments.length > 1 ? arguments[1] : undefined;\n-      var k = 0;\n-      while (k < len) {\n-        var kValue = o._getter(k);\n-        var testResult = predicate.call(t, kValue, k, o);\n-        if (Boolean(testResult))\n-          return kValue;\n-        ++k;\n-      }\n-      return undefined;\n-    }});\n-\n-    // %TypedArray%.prototype.findIndex ( predicate, thisArg = undefined )\n-    Object.defineProperty($TypedArray$.prototype, 'findIndex', {value: function(predicate) {\n-      var o = ToObject(this);\n-      var lenValue = o.length;\n-      var len = ToUint32(lenValue);\n-      if (!IsCallable(predicate)) throw TypeError();\n-      var t = arguments.length > 1 ? arguments[1] : undefined;\n-      var k = 0;\n-      while (k < len) {\n-        var kValue = o._getter(k);\n-        var testResult = predicate.call(t, kValue, k, o);\n-        if (Boolean(testResult))\n-          return k;\n-        ++k;\n-      }\n-      return -1;\n-    }});\n-\n-    // %TypedArray%.prototype.forEach ( callbackfn, thisArg = undefined )\n-    Object.defineProperty($TypedArray$.prototype, 'forEach', {value: function(callbackfn) {\n-      if (this === undefined || this === null) throw TypeError();\n-      var t = Object(this);\n-      var len = ToUint32(t.length);\n-      if (!IsCallable(callbackfn)) throw TypeError();\n-      var thisp = arguments[1];\n-      for (var i = 0; i < len; i++)\n-        callbackfn.call(thisp, t._getter(i), i, t);\n-    }});\n-\n-    // %TypedArray%.prototype.indexOf (searchElement, fromIndex = 0 )\n-    Object.defineProperty($TypedArray$.prototype, 'indexOf', {value: function(searchElement) {\n-      if (this === undefined || this === null) throw TypeError();\n-      var t = Object(this);\n-      var len = ToUint32(t.length);\n-      if (len === 0) return -1;\n-      var n = 0;\n-      if (arguments.length > 0) {\n-        n = Number(arguments[1]);\n-        if (n !== n) {\n-          n = 0;\n-        } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {\n-          n = (n > 0 || -1) * floor(abs(n));\n-        }\n-      }\n-      if (n >= len) return -1;\n-      var k = n >= 0 ? n : max(len - abs(n), 0);\n-      for (; k < len; k++) {\n-        if (t._getter(k) === searchElement) {\n-          return k;\n-        }\n-      }\n-      return -1;\n-    }});\n-\n-    // %TypedArray%.prototype.join ( separator )\n-    Object.defineProperty($TypedArray$.prototype, 'join', {value: function(separator) {\n-      if (this === undefined || this === null) throw TypeError();\n-      var t = Object(this);\n-      var len = ToUint32(t.length);\n-      var tmp = Array(len);\n-      for (var i = 0; i < len; ++i)\n-        tmp[i] = t._getter(i);\n-      return tmp.join(separator === undefined ? ',' : separator); // Hack for IE7\n-    }});\n-\n-    // %TypedArray%.prototype.keys ( )\n-    // -- defined in es6.js to shim browsers w/ native TypedArrays\n-\n-    // %TypedArray%.prototype.lastIndexOf ( searchElement, fromIndex = this.length-1 )\n-    Object.defineProperty($TypedArray$.prototype, 'lastIndexOf', {value: function(searchElement) {\n-      if (this === undefined || this === null) throw TypeError();\n-      var t = Object(this);\n-      var len = ToUint32(t.length);\n-      if (len === 0) return -1;\n-      var n = len;\n-      if (arguments.length > 1) {\n-        n = Number(arguments[1]);\n-        if (n !== n) {\n-          n = 0;\n-        } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {\n-          n = (n > 0 || -1) * floor(abs(n));\n-        }\n-      }\n-      var k = n >= 0 ? min(n, len - 1) : len - abs(n);\n-      for (; k >= 0; k--) {\n-        if (t._getter(k) === searchElement)\n-          return k;\n-      }\n-      return -1;\n-    }});\n-\n-    // get %TypedArray%.prototype.length\n-    // -- applied directly to the object in the constructor\n-\n-    // %TypedArray%.prototype.map ( callbackfn, thisArg = undefined )\n-    Object.defineProperty($TypedArray$.prototype, 'map', {value: function(callbackfn) {\n-      if (this === undefined || this === null) throw TypeError();\n-      var t = Object(this);\n-      var len = ToUint32(t.length);\n-      if (!IsCallable(callbackfn)) throw TypeError();\n-      var res = []; res.length = len;\n-      var thisp = arguments[1];\n-      for (var i = 0; i < len; i++)\n-        res[i] = callbackfn.call(thisp, t._getter(i), i, t);\n-      return new this.constructor(res);\n-    }});\n-\n-    // %TypedArray%.prototype.reduce ( callbackfn [, initialValue] )\n-    Object.defineProperty($TypedArray$.prototype, 'reduce', {value: function(callbackfn) {\n-      if (this === undefined || this === null) throw TypeError();\n-      var t = Object(this);\n-      var len = ToUint32(t.length);\n-      if (!IsCallable(callbackfn)) throw TypeError();\n-      // no value to return if no initial value and an empty array\n-      if (len === 0 && arguments.length === 1) throw TypeError();\n-      var k = 0;\n-      var accumulator;\n-      if (arguments.length >= 2) {\n-        accumulator = arguments[1];\n-      } else {\n-        accumulator = t._getter(k++);\n-      }\n-      while (k < len) {\n-        accumulator = callbackfn.call(undefined, accumulator, t._getter(k), k, t);\n-        k++;\n-      }\n-      return accumulator;\n-    }});\n-\n-    // %TypedArray%.prototype.reduceRight ( callbackfn [, initialValue] )\n-    Object.defineProperty($TypedArray$.prototype, 'reduceRight', {value: function(callbackfn) {\n-      if (this === undefined || this === null) throw TypeError();\n-      var t = Object(this);\n-      var len = ToUint32(t.length);\n-      if (!IsCallable(callbackfn)) throw TypeError();\n-      // no value to return if no initial value, empty array\n-      if (len === 0 && arguments.length === 1) throw TypeError();\n-      var k = len - 1;\n-      var accumulator;\n-      if (arguments.length >= 2) {\n-        accumulator = arguments[1];\n-      } else {\n-        accumulator = t._getter(k--);\n-      }\n-      while (k >= 0) {\n-        accumulator = callbackfn.call(undefined, accumulator, t._getter(k), k, t);\n-        k--;\n-      }\n-      return accumulator;\n-    }});\n-\n-    // %TypedArray%.prototype.reverse ( )\n-    Object.defineProperty($TypedArray$.prototype, 'reverse', {value: function() {\n-      if (this === undefined || this === null) throw TypeError();\n-      var t = Object(this);\n-      var len = ToUint32(t.length);\n-      var half = floor(len / 2);\n-      for (var i = 0, j = len - 1; i < half; ++i, --j) {\n-        var tmp = t._getter(i);\n-        t._setter(i, t._getter(j));\n-        t._setter(j, tmp);\n-      }\n-      return t;\n-    }});\n-\n-    // %TypedArray%.prototype.set(array, offset = 0 )\n-    // %TypedArray%.prototype.set(typedArray, offset = 0 )\n-    // WebIDL: void set(TypedArray array, optional unsigned long offset);\n-    // WebIDL: void set(sequence<type> array, optional unsigned long offset);\n-    Object.defineProperty($TypedArray$.prototype, 'set', {value: function(index, value) {\n-      if (arguments.length < 1) throw SyntaxError('Not enough arguments');\n-      var array, sequence, offset, len,\n-        i, s, d,\n-        byteOffset, byteLength, tmp;\n-\n-      if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {\n-        // void set(TypedArray array, optional unsigned long offset);\n-        array = arguments[0];\n-        offset = ToUint32(arguments[1]);\n-\n-        if (offset + array.length > this.length) {\n-          throw RangeError('Offset plus length of array is out of range');\n-        }\n-\n-        byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;\n-        byteLength = array.length * this.BYTES_PER_ELEMENT;\n-\n-        if (array.buffer === this.buffer) {\n-          tmp = [];\n-          for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {\n-            tmp[i] = array.buffer._bytes[s];\n-          }\n-          for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {\n-            this.buffer._bytes[d] = tmp[i];\n-          }\n-        } else {\n-          for (i = 0, s = array.byteOffset, d = byteOffset;\n-               i < byteLength; i += 1, s += 1, d += 1) {\n-            this.buffer._bytes[d] = array.buffer._bytes[s];\n-          }\n-        }\n-      } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {\n-        // void set(sequence<type> array, optional unsigned long offset);\n-        sequence = arguments[0];\n-        len = ToUint32(sequence.length);\n-        offset = ToUint32(arguments[1]);\n-\n-        if (offset + len > this.length) {\n-          throw RangeError('Offset plus length of array is out of range');\n-        }\n-\n-        for (i = 0; i < len; i += 1) {\n-          s = sequence[i];\n-          this._setter(offset + i, Number(s));\n-        }\n-      } else {\n-        throw TypeError('Unexpected argument type(s)');\n-      }\n-    }});\n-\n-    // %TypedArray%.prototype.slice ( start, end )\n-    Object.defineProperty($TypedArray$.prototype, 'slice', {value: function(start, end) {\n-      var o = ToObject(this);\n-      var lenVal = o.length;\n-      var len = ToUint32(lenVal);\n-      var relativeStart = ToInt32(start);\n-      var k = (relativeStart < 0) ? max(len + relativeStart, 0) : min(relativeStart, len);\n-      var relativeEnd = (end === undefined) ? len : ToInt32(end);\n-      var final = (relativeEnd < 0) ? max(len + relativeEnd, 0) : min(relativeEnd, len);\n-      var count = final - k;\n-      var c = o.constructor;\n-      var a = new c(count);\n-      var n = 0;\n-      while (k < final) {\n-        var kValue = o._getter(k);\n-        a._setter(n, kValue);\n-        ++k;\n-        ++n;\n-      }\n-      return a;\n-    }});\n-\n-    // %TypedArray%.prototype.some ( callbackfn, thisArg = undefined )\n-    Object.defineProperty($TypedArray$.prototype, 'some', {value: function(callbackfn) {\n-      if (this === undefined || this === null) throw TypeError();\n-      var t = Object(this);\n-      var len = ToUint32(t.length);\n-      if (!IsCallable(callbackfn)) throw TypeError();\n-      var thisp = arguments[1];\n-      for (var i = 0; i < len; i++) {\n-        if (callbackfn.call(thisp, t._getter(i), i, t)) {\n-          return true;\n-        }\n-      }\n-      return false;\n-    }});\n-\n-    // %TypedArray%.prototype.sort ( comparefn )\n-    Object.defineProperty($TypedArray$.prototype, 'sort', {value: function(comparefn) {\n-      if (this === undefined || this === null) throw TypeError();\n-      var t = Object(this);\n-      var len = ToUint32(t.length);\n-      var tmp = Array(len);\n-      for (var i = 0; i < len; ++i)\n-        tmp[i] = t._getter(i);\n-      if (comparefn) tmp.sort(comparefn); else tmp.sort(); // Hack for IE8/9\n-      for (i = 0; i < len; ++i)\n-        t._setter(i, tmp[i]);\n-      return t;\n-    }});\n-\n-    // %TypedArray%.prototype.subarray(begin = 0, end = this.length )\n-    // WebIDL: TypedArray subarray(long begin, optional long end);\n-    Object.defineProperty($TypedArray$.prototype, 'subarray', {value: function(start, end) {\n-      function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }\n-\n-      start = ToInt32(start);\n-      end = ToInt32(end);\n-\n-      if (arguments.length < 1) { start = 0; }\n-      if (arguments.length < 2) { end = this.length; }\n-\n-      if (start < 0) { start = this.length + start; }\n-      if (end < 0) { end = this.length + end; }\n-\n-      start = clamp(start, 0, this.length);\n-      end = clamp(end, 0, this.length);\n-\n-      var len = end - start;\n-      if (len < 0) {\n-        len = 0;\n-      }\n-\n-      return new this.constructor(\n-        this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);\n-    }});\n-\n-    // %TypedArray%.prototype.toLocaleString ( )\n-    // %TypedArray%.prototype.toString ( )\n-    // %TypedArray%.prototype.values ( )\n-    // %TypedArray%.prototype [ @@iterator ] ( )\n-    // get %TypedArray%.prototype [ @@toStringTag ]\n-    // -- defined in es6.js to shim browsers w/ native TypedArrays\n-\n-    function makeTypedArray(elementSize, pack, unpack) {\n-      // Each TypedArray type requires a distinct constructor instance with\n-      // identical logic, which this produces.\n-      var TypedArray = function() {\n-        Object.defineProperty(this, 'constructor', {value: TypedArray});\n-        $TypedArray$.apply(this, arguments);\n-        makeArrayAccessors(this);\n-      };\n-      if ('__proto__' in TypedArray) {\n-        TypedArray.__proto__ = $TypedArray$;\n-      } else {\n-        TypedArray.from = $TypedArray$.from;\n-        TypedArray.of = $TypedArray$.of;\n-      }\n-\n-      TypedArray.BYTES_PER_ELEMENT = elementSize;\n-\n-      var TypedArrayPrototype = function() {};\n-      TypedArrayPrototype.prototype = $TypedArrayPrototype$;\n-\n-      TypedArray.prototype = new TypedArrayPrototype();\n-\n-      Object.defineProperty(TypedArray.prototype, 'BYTES_PER_ELEMENT', {value: elementSize});\n-      Object.defineProperty(TypedArray.prototype, '_pack', {value: pack});\n-      Object.defineProperty(TypedArray.prototype, '_unpack', {value: unpack});\n-\n-      return TypedArray;\n-    }\n-\n-    var Int8Array = makeTypedArray(1, packI8, unpackI8);\n-    var Uint8Array = makeTypedArray(1, packU8, unpackU8);\n-    var Uint8ClampedArray = makeTypedArray(1, packU8Clamped, unpackU8);\n-    var Int16Array = makeTypedArray(2, packI16, unpackI16);\n-    var Uint16Array = makeTypedArray(2, packU16, unpackU16);\n-    var Int32Array = makeTypedArray(4, packI32, unpackI32);\n-    var Uint32Array = makeTypedArray(4, packU32, unpackU32);\n-    var Float32Array = makeTypedArray(4, packF32, unpackF32);\n-    var Float64Array = makeTypedArray(8, packF64, unpackF64);\n-\n-    global.Int8Array = global.Int8Array || Int8Array;\n-    global.Uint8Array = global.Uint8Array || Uint8Array;\n-    global.Uint8ClampedArray = global.Uint8ClampedArray || Uint8ClampedArray;\n-    global.Int16Array = global.Int16Array || Int16Array;\n-    global.Uint16Array = global.Uint16Array || Uint16Array;\n-    global.Int32Array = global.Int32Array || Int32Array;\n-    global.Uint32Array = global.Uint32Array || Uint32Array;\n-    global.Float32Array = global.Float32Array || Float32Array;\n-    global.Float64Array = global.Float64Array || Float64Array;\n-  }());\n-\n-  //\n-  // 6 The DataView View Type\n-  //\n-\n-  (function() {\n-    function r(array, index) {\n-      return IsCallable(array.get) ? array.get(index) : array[index];\n-    }\n-\n-    var IS_BIG_ENDIAN = (function() {\n-      var u16array = new Uint16Array([0x1234]),\n-        u8array = new Uint8Array(u16array.buffer);\n-      return r(u8array, 0) === 0x12;\n-    }());\n-\n-    // DataView(buffer, byteOffset=0, byteLength=undefined)\n-    // WebIDL: Constructor(ArrayBuffer buffer,\n-    //                     optional unsigned long byteOffset,\n-    //                     optional unsigned long byteLength)\n-    function DataView(buffer, byteOffset, byteLength) {\n-      if (!(buffer instanceof ArrayBuffer || Class(buffer) === 'ArrayBuffer')) throw TypeError();\n-\n-      byteOffset = ToUint32(byteOffset);\n-      if (byteOffset > buffer.byteLength)\n-        throw RangeError('byteOffset out of range');\n-\n-      if (byteLength === undefined)\n-        byteLength = buffer.byteLength - byteOffset;\n-      else\n-        byteLength = ToUint32(byteLength);\n-\n-      if ((byteOffset + byteLength) > buffer.byteLength)\n-        throw RangeError('byteOffset and length reference an area beyond the end of the buffer');\n-\n-      Object.defineProperty(this, 'buffer', {value: buffer});\n-      Object.defineProperty(this, 'byteLength', {value: byteLength});\n-      Object.defineProperty(this, 'byteOffset', {value: byteOffset});\n-    };\n-\n-    // get DataView.prototype.buffer\n-    // get DataView.prototype.byteLength\n-    // get DataView.prototype.byteOffset\n-    // -- applied directly to instances by the constructor\n-\n-    function makeGetter(arrayType) {\n-      return function GetViewValue(byteOffset, littleEndian) {\n-        byteOffset = ToUint32(byteOffset);\n-\n-        if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength)\n-          throw RangeError('Array index out of range');\n-\n-        byteOffset += this.byteOffset;\n-\n-        var uint8Array = new Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),\n-          bytes = [];\n-        for (var i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1)\n-          bytes.push(r(uint8Array, i));\n-\n-        if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN))\n-          bytes.reverse();\n-\n-        return r(new arrayType(new Uint8Array(bytes).buffer), 0);\n-      };\n-    }\n-\n-    Object.defineProperty(DataView.prototype, 'getUint8', {value: makeGetter(Uint8Array)});\n-    Object.defineProperty(DataView.prototype, 'getInt8', {value: makeGetter(Int8Array)});\n-    Object.defineProperty(DataView.prototype, 'getUint16', {value: makeGetter(Uint16Array)});\n-    Object.defineProperty(DataView.prototype, 'getInt16', {value: makeGetter(Int16Array)});\n-    Object.defineProperty(DataView.prototype, 'getUint32', {value: makeGetter(Uint32Array)});\n-    Object.defineProperty(DataView.prototype, 'getInt32', {value: makeGetter(Int32Array)});\n-    Object.defineProperty(DataView.prototype, 'getFloat32', {value: makeGetter(Float32Array)});\n-    Object.defineProperty(DataView.prototype, 'getFloat64', {value: makeGetter(Float64Array)});\n-\n-    function makeSetter(arrayType) {\n-      return function SetViewValue(byteOffset, value, littleEndian) {\n-        byteOffset = ToUint32(byteOffset);\n-        if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength)\n-          throw RangeError('Array index out of range');\n-\n-        // Get bytes\n-        var typeArray = new arrayType([value]),\n-          byteArray = new Uint8Array(typeArray.buffer),\n-          bytes = [], i, byteView;\n-\n-        for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1)\n-          bytes.push(r(byteArray, i));\n-\n-        // Flip if necessary\n-        if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN))\n-          bytes.reverse();\n-\n-        // Write them\n-        byteView = new Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);\n-        byteView.set(bytes);\n-      };\n-    }\n-\n-    Object.defineProperty(DataView.prototype, 'setUint8', {value: makeSetter(Uint8Array)});\n-    Object.defineProperty(DataView.prototype, 'setInt8', {value: makeSetter(Int8Array)});\n-    Object.defineProperty(DataView.prototype, 'setUint16', {value: makeSetter(Uint16Array)});\n-    Object.defineProperty(DataView.prototype, 'setInt16', {value: makeSetter(Int16Array)});\n-    Object.defineProperty(DataView.prototype, 'setUint32', {value: makeSetter(Uint32Array)});\n-    Object.defineProperty(DataView.prototype, 'setInt32', {value: makeSetter(Int32Array)});\n-    Object.defineProperty(DataView.prototype, 'setFloat32', {value: makeSetter(Float32Array)});\n-    Object.defineProperty(DataView.prototype, 'setFloat64', {value: makeSetter(Float64Array)});\n-\n-    global.DataView = global.DataView || DataView;\n-\n-  }());\n-\n-}(self));\n-\n-//Blob (IE9)\n-/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */\n-/* Blob.js\n- * A Blob implementation.\n- * 2014-07-24\n- *\n- * By Eli Grey, http://eligrey.com\n- * By Devin Samarin, https://github.com/dsamarin\n- * License: MIT\n- *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md\n- */\n-\n-/*global self, unescape */\n-/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,\n- plusplus: true */\n-\n-/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */\n-\n-(function (view) {\n-  \"use strict\";\n-\n-  view.URL = view.URL || view.webkitURL;\n-\n-  if (view.Blob && view.URL) {\n-    try {\n-      new Blob;\n-      return;\n-    } catch (e) {}\n-  }\n-\n-  // Internally we use a BlobBuilder implementation to base Blob off of\n-  // in order to support older browsers that only have BlobBuilder\n-  var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || (function(view) {\n-      var\n-        get_class = function(object) {\n-          return Object.prototype.toString.call(object).match(/^\\[object\\s(.*)\\]$/)[1];\n-        }\n-        , FakeBlobBuilder = function BlobBuilder() {\n-          this.data = [];\n-        }\n-        , FakeBlob = function Blob(data, type, encoding) {\n-          this.data = data;\n-          this.size = data.length;\n-          this.type = type;\n-          this.encoding = encoding;\n-        }\n-        , FBB_proto = FakeBlobBuilder.prototype\n-        , FB_proto = FakeBlob.prototype\n-        , FileReaderSync = view.FileReaderSync\n-        , FileException = function(type) {\n-          this.code = this[this.name = type];\n-        }\n-        , file_ex_codes = (\n-          \"NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR \"\n-          + \"NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR\"\n-        ).split(\" \")\n-        , file_ex_code = file_ex_codes.length\n-        , real_URL = view.URL || view.webkitURL || view\n-        , real_create_object_URL = real_URL.createObjectURL\n-        , real_revoke_object_URL = real_URL.revokeObjectURL\n-        , URL = real_URL\n-        , btoa = view.btoa\n-        , atob = view.atob\n-\n-        , ArrayBuffer = view.ArrayBuffer\n-        , Uint8Array = view.Uint8Array\n-\n-        , origin = /^[\\w-]+:\\/*\\[?[\\w\\.:-]+\\]?(?::[0-9]+)?/\n-        ;\n-      FakeBlob.fake = FB_proto.fake = true;\n-      while (file_ex_code--) {\n-        FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;\n-      }\n-      // Polyfill URL\n-      if (!real_URL.createObjectURL) {\n-        URL = view.URL = function(uri) {\n-          var\n-            uri_info = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\")\n-            , uri_origin\n-            ;\n-          uri_info.href = uri;\n-          if (!(\"origin\" in uri_info)) {\n-            if (uri_info.protocol.toLowerCase() === \"data:\") {\n-              uri_info.origin = null;\n-            } else {\n-              uri_origin = uri.match(origin);\n-              uri_info.origin = uri_origin && uri_origin[1];\n-            }\n-          }\n-          return uri_info;\n-        };\n-      }\n-      URL.createObjectURL = function(blob) {\n-        var\n-          type = blob.type\n-          , data_URI_header\n-          ;\n-        if (type === null) {\n-          type = \"application/octet-stream\";\n-        }\n-        if (blob instanceof FakeBlob) {\n-          data_URI_header = \"data:\" + type;\n-          if (blob.encoding === \"base64\") {\n-            return data_URI_header + \";base64,\" + blob.data;\n-          } else if (blob.encoding === \"URI\") {\n-            return data_URI_header + \",\" + decodeURIComponent(blob.data);\n-          } if (btoa) {\n-            return data_URI_header + \";base64,\" + btoa(blob.data);\n-          } else {\n-            return data_URI_header + \",\" + encodeURIComponent(blob.data);\n-          }\n-        } else if (real_create_object_URL) {\n-          return real_create_object_URL.call(real_URL, blob);\n-        }\n-      };\n-      URL.revokeObjectURL = function(object_URL) {\n-        if (object_URL.substring(0, 5) !== \"data:\" && real_revoke_object_URL) {\n-          real_revoke_object_URL.call(real_URL, object_URL);\n-        }\n-      };\n-      FBB_proto.append = function(data/*, endings*/) {\n-        var bb = this.data;\n-        // decode data to a binary string\n-        if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {\n-          var\n-            str = \"\"\n-            , buf = new Uint8Array(data)\n-            , i = 0\n-            , buf_len = buf.length\n-            ;\n-          for (; i < buf_len; i++) {\n-            str += String.fromCharCode(buf[i]);\n-          }\n-          bb.push(str);\n-        } else if (get_class(data) === \"Blob\" || get_class(data) === \"File\") {\n-          if (FileReaderSync) {\n-            var fr = new FileReaderSync;\n-            bb.push(fr.readAsBinaryString(data));\n-          } else {\n-            // async FileReader won't work as BlobBuilder is sync\n-            throw new FileException(\"NOT_READABLE_ERR\");\n-          }\n-        } else if (data instanceof FakeBlob) {\n-          if (data.encoding === \"base64\" && atob) {\n-            bb.push(atob(data.data));\n-          } else if (data.encoding === \"URI\") {\n-            bb.push(decodeURIComponent(data.data));\n-          } else if (data.encoding === \"raw\") {\n-            bb.push(data.data);\n-          }\n-        } else {\n-          if (typeof data !== \"string\") {\n-            data += \"\"; // convert unsupported types to strings\n-          }\n-          // decode UTF-16 to binary string\n-          bb.push(unescape(encodeURIComponent(data)));\n-        }\n-      };\n-      FBB_proto.getBlob = function(type) {\n-        if (!arguments.length) {\n-          type = null;\n-        }\n-        return new FakeBlob(this.data.join(\"\"), type, \"raw\");\n-      };\n-      FBB_proto.toString = function() {\n-        return \"[object BlobBuilder]\";\n-      };\n-      FB_proto.slice = function(start, end, type) {\n-        var args = arguments.length;\n-        if (args < 3) {\n-          type = null;\n-        }\n-        return new FakeBlob(\n-          this.data.slice(start, args > 1 ? end : this.data.length)\n-          , type\n-          , this.encoding\n-        );\n-      };\n-      FB_proto.toString = function() {\n-        return \"[object Blob]\";\n-      };\n-      FB_proto.close = function() {\n-        this.size = 0;\n-        delete this.data;\n-      };\n-      return FakeBlobBuilder;\n-    }(view));\n-\n-  view.Blob = function(blobParts, options) {\n-    var type = options ? (options.type || \"\") : \"\";\n-    var builder = new BlobBuilder();\n-    if (blobParts) {\n-      for (var i = 0, len = blobParts.length; i < len; i++) {\n-        if (Uint8Array && blobParts[i] instanceof Uint8Array) {\n-          builder.append(blobParts[i].buffer);\n-        }\n-        else {\n-          builder.append(blobParts[i]);\n-        }\n-      }\n-    }\n-    var blob = builder.getBlob(type);\n-    if (!blob.slice && blob.webkitSlice) {\n-      blob.slice = blob.webkitSlice;\n-    }\n-    return blob;\n-  };\n-\n-  var getPrototypeOf = Object.getPrototypeOf || function(object) {\n-      return object.__proto__;\n-    };\n-  view.Blob.prototype = getPrototypeOf(new view.Blob());\n-}(typeof self !== \"undefined\" && self || typeof window !== \"undefined\" && window || this.content || this));\n-\n-//FormData (IE9)\n-/*! @source https://github.com/francois2metz/html5-formdata/blob/master/formdata.js */\n-/**\n- * Emulate FormData for some browsers\n- * MIT License\n- * (c) 2010 Franois de Metz\n- */\n-(function(w) {\n-  if (w.FormData)\n-    return;\n-  function FormData() {\n-    this.fake = true;\n-    this.boundary = \"--------FormData\" + Math.random();\n-    this._fields = [];\n-  }\n-  FormData.prototype.append = function(key, value) {\n-    this._fields.push([key, value]);\n-  }\n-  FormData.prototype.toString = function() {\n-    var boundary = this.boundary;\n-    var body = \"\";\n-    this._fields.forEach(function(field) {\n-      body += \"--\" + boundary + \"\\r\\n\";\n-      // file upload\n-      if (field[1].name) {\n-        var file = field[1];\n-        body += \"Content-Disposition: form-data; name=\\\"\"+ field[0] +\"\\\"; filename=\\\"\"+ file.name +\"\\\"\\r\\n\";\n-        body += \"Content-Type: \"+ file.type +\"\\r\\n\\r\\n\";\n-        body += file.getAsBinary() + \"\\r\\n\";\n-      } else {\n-        body += \"Content-Disposition: form-data; name=\\\"\"+ field[0] +\"\\\";\\r\\n\\r\\n\";\n-        body += field[1] + \"\\r\\n\";\n-      }\n-    });\n-    body += \"--\" + boundary +\"--\";\n-    return body;\n-  }\n-  w.FormData = FormData;\n-})(window);\n-\n // Intl (IE9, IE10, all Safari, all Android)\n /*! @source https://github.com/andyearnshaw/Intl.js */\n /*! @licence https://github.com/andyearnshaw/Intl.js/blob/master/LICENSE.txt */"
        }
    ],
    "stats": {
        "total": 1318,
        "additions": 0,
        "deletions": 1318
    }
}