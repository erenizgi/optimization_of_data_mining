{
    "author": "JoostK",
    "message": "perf(compiler-cli): only emit directive/pipe references that are used (#38539)\n\nFor the compilation of a component, the compiler has to prepare some\ninformation about the directives and pipes that are used in the template.\nThis information includes an expression for directives/pipes, for usage\nwithin the compilation output. For large NgModule compilation scopes\nthis has shown to introduce a performance hotspot, as the generation of\nexpressions is quite expensive. This commit reduces the performance\noverhead by only generating expressions for the directives/pipes that\nare actually used within the template, significantly cutting down on\nthe compiler's resolve phase.\n\nPR Close #38539",
    "sha": "4faac78e32657f6b60b98b4330e746ba645c8f2e",
    "files": [
        {
            "sha": "1f6d14489f92058b6233242c818b13129b955efd",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/component.ts",
            "status": "modified",
            "additions": 33,
            "deletions": 25,
            "changes": 58,
            "blob_url": "https://github.com/angular/angular/blob/4faac78e32657f6b60b98b4330e746ba645c8f2e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/4faac78e32657f6b60b98b4330e746ba645c8f2e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts?ref=4faac78e32657f6b60b98b4330e746ba645c8f2e",
            "patch": "@@ -495,45 +495,58 @@ export class ComponentDecoratorHandler implements\n       // Set up the R3TargetBinder, as well as a 'directives' array and a 'pipes' map that are later\n       // fed to the TemplateDefinitionBuilder. First, a SelectorMatcher is constructed to match\n       // directives that are in scope.\n-      const matcher = new SelectorMatcher<DirectiveMeta&{expression: Expression}>();\n-      const directives: {selector: string, expression: Expression}[] = [];\n+      type MatchedDirective = DirectiveMeta&{selector: string};\n+      const matcher = new SelectorMatcher<MatchedDirective>();\n \n       for (const dir of scope.compilation.directives) {\n-        const {ref, selector} = dir;\n-        if (selector !== null) {\n-          const expression = this.refEmitter.emit(ref, context);\n-          directives.push({selector, expression});\n-          matcher.addSelectables(CssSelector.parse(selector), {...dir, expression});\n+        if (dir.selector !== null) {\n+          matcher.addSelectables(CssSelector.parse(dir.selector), dir as MatchedDirective);\n         }\n       }\n-      const pipes = new Map<string, Expression>();\n+      const pipes = new Map<string, Reference<ClassDeclaration>>();\n       for (const pipe of scope.compilation.pipes) {\n-        pipes.set(pipe.name, this.refEmitter.emit(pipe.ref, context));\n+        pipes.set(pipe.name, pipe.ref);\n       }\n \n-      // Next, the component template AST is bound using the R3TargetBinder. This produces an\n+      // Next, the component template AST is bound using the R3TargetBinder. This produces a\n       // BoundTarget, which is similar to a ts.TypeChecker.\n       const binder = new R3TargetBinder(matcher);\n       const bound = binder.bind({template: metadata.template.nodes});\n \n       // The BoundTarget knows which directives and pipes matched the template.\n-      const usedDirectives = bound.getUsedDirectives();\n-      const usedPipes = bound.getUsedPipes().map(name => pipes.get(name)!);\n+      const usedDirectives = bound.getUsedDirectives().map(directive => {\n+        return {\n+          selector: directive.selector,\n+          expression: this.refEmitter.emit(directive.ref, context),\n+        };\n+      });\n+\n+      const usedPipes: {pipeName: string, expression: Expression}[] = [];\n+      for (const pipeName of bound.getUsedPipes()) {\n+        if (!pipes.has(pipeName)) {\n+          continue;\n+        }\n+        const pipe = pipes.get(pipeName)!;\n+        usedPipes.push({\n+          pipeName,\n+          expression: this.refEmitter.emit(pipe, context),\n+        });\n+      }\n \n       // Scan through the directives/pipes actually used in the template and check whether any\n       // import which needs to be generated would create a cycle.\n       const cycleDetected =\n           usedDirectives.some(dir => this._isCyclicImport(dir.expression, context)) ||\n-          usedPipes.some(pipe => this._isCyclicImport(pipe, context));\n+          usedPipes.some(pipe => this._isCyclicImport(pipe.expression, context));\n \n       if (!cycleDetected) {\n         // No cycle was detected. Record the imports that need to be created in the cycle detector\n         // so that future cyclic import checks consider their production.\n         for (const {expression} of usedDirectives) {\n           this._recordSyntheticImport(expression, context);\n         }\n-        for (const pipe of usedPipes) {\n-          this._recordSyntheticImport(pipe, context);\n+        for (const {expression} of usedPipes) {\n+          this._recordSyntheticImport(expression, context);\n         }\n \n         // Check whether the directive/pipe arrays in Éµcmp need to be wrapped in closures.\n@@ -542,16 +555,11 @@ export class ComponentDecoratorHandler implements\n         const wrapDirectivesAndPipesInClosure =\n             usedDirectives.some(\n                 dir => isExpressionForwardReference(dir.expression, node.name, context)) ||\n-            usedPipes.some(pipe => isExpressionForwardReference(pipe, node.name, context));\n-\n-        // Actual compilation still uses the full scope, not the narrowed scope determined by\n-        // R3TargetBinder. This is a hedge against potential issues with the R3TargetBinder - right\n-        // now the TemplateDefinitionBuilder is the \"source of truth\" for which directives/pipes are\n-        // actually used (though the two should agree perfectly).\n-        //\n-        // TODO(alxhub): switch TemplateDefinitionBuilder over to using R3TargetBinder directly.\n-        data.directives = directives;\n-        data.pipes = pipes;\n+            usedPipes.some(\n+                pipe => isExpressionForwardReference(pipe.expression, node.name, context));\n+\n+        data.directives = usedDirectives;\n+        data.pipes = new Map(usedPipes.map(pipe => [pipe.pipeName, pipe.expression]));\n         data.wrapDirectivesAndPipesInClosure = wrapDirectivesAndPipesInClosure;\n       } else {\n         // Declaring the directiveDefs/pipeDefs arrays directly would require imports that would"
        }
    ],
    "stats": {
        "total": 58,
        "additions": 33,
        "deletions": 25
    }
}