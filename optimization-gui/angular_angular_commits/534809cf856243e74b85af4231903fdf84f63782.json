{
    "author": "AleksanderBodurri",
    "message": "feat(devtools): implement profiler with new framework APIs",
    "sha": "534809cf856243e74b85af4231903fdf84f63782",
    "files": [
        {
            "sha": "5691223af61b08c196470b725a38394875abba0e",
            "filename": "projects/ng-devtools-backend/src/lib/client-event-subscribers.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/534809cf856243e74b85af4231903fdf84f63782/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fclient-event-subscribers.ts",
            "raw_url": "https://github.com/angular/angular/raw/534809cf856243e74b85af4231903fdf84f63782/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fclient-event-subscribers.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fclient-event-subscribers.ts?ref=534809cf856243e74b85af4231903fdf84f63782",
            "patch": "@@ -55,7 +55,7 @@ export const subscribeToClientEvents = (messageBus: MessageBus<Events>): void =>\n     // every 250ms\n     runOutsideAngular(() => {\n       initializeOrGetDirectiveForestHooks()\n-        .changeDetection$.pipe(debounceTime(250))\n+        .profiler.changeDetection$.pipe(debounceTime(250))\n         .subscribe(() => messageBus.emit('componentTreeDirty'));\n     });\n   }"
        },
        {
            "sha": "9638bbeefd6aec589338f5db93b1706072ab6622",
            "filename": "projects/ng-devtools-backend/src/lib/directive-forest/ltree.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/534809cf856243e74b85af4231903fdf84f63782/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fdirective-forest%2Fltree.ts",
            "raw_url": "https://github.com/angular/angular/raw/534809cf856243e74b85af4231903fdf84f63782/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fdirective-forest%2Fltree.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fdirective-forest%2Fltree.ts?ref=534809cf856243e74b85af4231903fdf84f63782",
            "patch": "@@ -47,6 +47,9 @@ export const getDirectiveHostElement = (dir: any) => {\n     return false;\n   }\n   const ctx = dir[METADATA_PROPERTY_NAME];\n+  if (!ctx) {\n+    return false;\n+  }\n   if (ctx[0] !== null) {\n     return ctx[0];\n   }"
        },
        {
            "sha": "d315e26a5efc93b05bcde0d4fbc39bcab57d80df",
            "filename": "projects/ng-devtools-backend/src/lib/hooks/capture.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/534809cf856243e74b85af4231903fdf84f63782/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fcapture.ts",
            "raw_url": "https://github.com/angular/angular/raw/534809cf856243e74b85af4231903fdf84f63782/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fcapture.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fcapture.ts?ref=534809cf856243e74b85af4231903fdf84f63782",
            "patch": "@@ -1,9 +1,10 @@\n-import { DirectiveForestHooks, Hooks } from './hooks';\n+import { DirectiveForestHooks } from './hooks';\n import { ElementPosition, ProfilerFrame, ElementProfile, DirectiveProfile, LifecycleProfile } from 'protocol';\n import { runOutsideAngular, isCustomElement } from '../utils';\n import { getDirectiveName } from '../highlighter';\n import { ComponentTreeNode } from '../component-tree';\n import { initializeOrGetDirectiveForestHooks } from '.';\n+import { Hooks } from './profiler';\n \n let inProgress = false;\n let inChangeDetection = false;\n@@ -18,13 +19,13 @@ export const start = (onFrame: (frame: ProfilerFrame) => void): void => {\n   eventMap = new Map<any, DirectiveProfile>();\n   inProgress = true;\n   hooks = getHooks(onFrame);\n-  initializeOrGetDirectiveForestHooks().subscribe(hooks);\n+  initializeOrGetDirectiveForestHooks().profiler.subscribe(hooks);\n };\n \n export const stop = (): ProfilerFrame => {\n   const directiveForestHooks = initializeOrGetDirectiveForestHooks();\n   const result = flushBuffer(directiveForestHooks);\n-  initializeOrGetDirectiveForestHooks().unsubscribe(hooks);\n+  initializeOrGetDirectiveForestHooks().profiler.unsubscribe(hooks);\n   hooks = {};\n   inProgress = false;\n   return result;"
        },
        {
            "sha": "49de8973fcc750267e729d79055573d0aec619a1",
            "filename": "projects/ng-devtools-backend/src/lib/hooks/hooks.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 323,
            "changes": 334,
            "blob_url": "https://github.com/angular/angular/blob/534809cf856243e74b85af4231903fdf84f63782/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fhooks.ts",
            "raw_url": "https://github.com/angular/angular/raw/534809cf856243e74b85af4231903fdf84f63782/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fhooks.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fhooks.ts?ref=534809cf856243e74b85af4231903fdf84f63782",
            "patch": "@@ -1,132 +1,22 @@\n import { ComponentTreeNode } from './../component-tree';\n-import { ElementPosition, LifecycleProfile } from 'protocol';\n-import { runOutsideAngular } from '../utils';\n+import { ElementPosition } from 'protocol';\n import { IdentityTracker, IndexedNode } from './identity-tracker';\n-import {\n-  getLViewFromDirectiveOrElementInstance,\n-  getDirectiveHostElement,\n-  METADATA_PROPERTY_NAME,\n-} from '../directive-forest';\n-import { Subject } from 'rxjs';\n-\n-// Only used in older Angular versions prior to the introduction of `getDirectiveMetadata`\n-const componentMetadata = (instance: any) => instance?.constructor?.ɵcmp;\n-\n-export type CreationHook = (\n-  componentOrDirective: any,\n-  node: Node,\n-  id: number,\n-  isComponent: boolean,\n-  position: ElementPosition\n-) => void;\n-\n-export type LifecycleStartHook = (\n-  componentOrDirective: any,\n-  hook: keyof LifecycleProfile | 'unknown',\n-  node: Node,\n-  id: number,\n-  isComponent: boolean\n-) => void;\n-\n-export type LifecycleEndHook = (\n-  componentOrDirective: any,\n-  hook: keyof LifecycleProfile | 'unknown',\n-  node: Node,\n-  id: number,\n-  isComponent: boolean\n-) => void;\n-\n-export type ChangeDetectionStartHook = (component: any, node: Node, id: number, position: ElementPosition) => void;\n-\n-export type ChangeDetectionEndHook = (component: any, node: Node, id: number, position: ElementPosition) => void;\n-\n-export type DestroyHook = (\n-  componentOrDirective: any,\n-  node: Node,\n-  id: number,\n-  isComponent: boolean,\n-  position: ElementPosition\n-) => void;\n-\n-export interface Hooks {\n-  onCreate: CreationHook;\n-  onDestroy: DestroyHook;\n-  onChangeDetectionStart: ChangeDetectionStartHook;\n-  onChangeDetectionEnd: ChangeDetectionEndHook;\n-  onLifecycleHookStart: LifecycleStartHook;\n-  onLifecycleHookEnd: LifecycleEndHook;\n-}\n-\n-const hookNames = [\n-  'OnInit',\n-  'OnDestroy',\n-  'OnChanges',\n-  'DoCheck',\n-  'AfterContentInit',\n-  'AfterContentChecked',\n-  'AfterViewInit',\n-  'AfterViewChecked',\n-];\n-\n-const hookMethodNames = new Set(hookNames.map((hook) => `ng${hook}`));\n-\n-const hookTViewProperties = [\n-  'preOrderHooks',\n-  'preOrderCheckHooks',\n-  'contentHooks',\n-  'contentCheckHooks',\n-  'viewHooks',\n-  'viewCheckHooks',\n-  'destroyHooks',\n-];\n-\n-const getLifeCycleName = (obj: {}, fn: any): keyof LifecycleProfile | 'unknown' => {\n-  const proto = Object.getPrototypeOf(obj);\n-  const keys = Object.getOwnPropertyNames(proto);\n-  for (const propName of keys) {\n-    // We don't want to touch random get accessors.\n-    if (!hookMethodNames.has(propName)) {\n-      continue;\n-    }\n-    if (proto[propName] === fn) {\n-      return propName as keyof LifecycleProfile;\n-    }\n-  }\n-  const fnName = fn.name;\n-  if (typeof fnName !== 'string') {\n-    return 'unknown';\n-  }\n-  for (const hookName of hookNames) {\n-    if (fnName.indexOf(hookName) >= 0) {\n-      return `ng${hookName}` as keyof LifecycleProfile;\n-    }\n-  }\n-  return 'unknown';\n-};\n+import { Profiler, selectProfilerStrategy } from './profiler';\n \n /**\n- * This is a temporal \"polyfill\" until we receive\n- * more comprehensive framework debugging APIs.\n+ *  Class to hook into directive forest.\n+ *\n+ *  Exposes latest directive forest state.\n+ *\n+ *  Delegates profiling to a Profiler instance.\n+ *  Delegates forest indexing to IdentityTracker Singleton\n  */\n export class DirectiveForestHooks {\n-  private _patched = new Map<any, () => void>();\n-  private _undoLifecyclePatch: (() => void)[] = [];\n-  private _lastChangeDetection = new Map<any, number>();\n-  private _tracker = new IdentityTracker();\n+  private _tracker = IdentityTracker.getInstance();\n   private _forest: ComponentTreeNode[] = [];\n   private _indexedForest: IndexedNode[] = [];\n-  private _inChangeDetection = false;\n-  private _changeDetection$ = new Subject<void>();\n-\n-  private _hooks: Partial<Hooks>[] = [];\n \n-  constructor(config: Partial<Hooks>) {\n-    this._hooks.push(config);\n-  }\n-\n-  get changeDetection$(): Subject<void> {\n-    return this._changeDetection$;\n-  }\n+  profiler: Profiler = selectProfilerStrategy();\n \n   getDirectivePosition(dir: any): ElementPosition | undefined {\n     const result = this._tracker.getDirectivePosition(dir);\n@@ -156,212 +46,10 @@ export class DirectiveForestHooks {\n     this.indexForest();\n   }\n \n-  destroy(): void {\n-    this._lastChangeDetection = new Map<any, number>();\n-    this._tracker.destroy();\n-\n-    for (const [cmp, template] of this._patched) {\n-      const meta = componentMetadata(cmp);\n-      meta.template = template;\n-      meta.tView.template = template;\n-    }\n-\n-    this._patched = new Map<any, () => void>();\n-    this._undoLifecyclePatch.forEach((p) => p());\n-    this._undoLifecyclePatch = [];\n-  }\n-\n   indexForest(): void {\n     const { newNodes, removedNodes, indexedForest, directiveForest } = this._tracker.index();\n     this._indexedForest = indexedForest;\n     this._forest = directiveForest;\n-    newNodes.forEach((node) => {\n-      this._observeLifecycle(node.directive, node.isComponent);\n-      this._observeComponent(node.directive);\n-      this._fireCreationCallback(node.directive, node.isComponent);\n-    });\n-    removedNodes.forEach((node) => {\n-      this._patched.delete(node.directive);\n-      this._fireDestroyCallback(node.directive, node.isComponent);\n-    });\n-  }\n-\n-  subscribe(config: Partial<Hooks>): void {\n-    this._hooks.push(config);\n-  }\n-\n-  unsubscribe(config: Partial<Hooks>): void {\n-    this._hooks.splice(this._hooks.indexOf(config), 1);\n-  }\n-\n-  private _fireCreationCallback(component: any, isComponent: boolean): void {\n-    const position = this._tracker.getDirectivePosition(component);\n-    const id = this._tracker.getDirectiveId(component);\n-    this._onCreate(component, getDirectiveHostElement(component), id, isComponent, position);\n-  }\n-\n-  private _fireDestroyCallback(component: any, isComponent: boolean): void {\n-    const position = this._tracker.getDirectivePosition(component);\n-    const id = this._tracker.getDirectiveId(component);\n-    this._onDestroy(component, getDirectiveHostElement(component), id, isComponent, position);\n-  }\n-\n-  private _observeComponent(cmp: any): void {\n-    const declarations = componentMetadata(cmp);\n-    if (!declarations) {\n-      return;\n-    }\n-    const original = declarations.template;\n-    const self = this;\n-    if (original.patched) {\n-      return;\n-    }\n-    declarations.tView.template = function (_: any, component: any): void {\n-      if (!self._inChangeDetection) {\n-        self._inChangeDetection = true;\n-        runOutsideAngular(() => {\n-          Promise.resolve().then(() => {\n-            self._changeDetection$.next();\n-            self._inChangeDetection = false;\n-          });\n-        });\n-      }\n-      const position = self._tracker.getDirectivePosition(component);\n-      const start = performance.now();\n-      const id = self._tracker.getDirectiveId(component);\n-\n-      self._onChangeDetectionStart(component, getDirectiveHostElement(component), id, position);\n-      original.apply(this, arguments);\n-      if (self._tracker.hasDirective(component) && id !== undefined && position !== undefined) {\n-        self._onChangeDetectionEnd(component, getDirectiveHostElement(component), id, position);\n-      } else {\n-        self._lastChangeDetection.set(component, performance.now() - start);\n-      }\n-    };\n-    declarations.tView.template.patched = true;\n-    this._patched.set(cmp, original);\n-  }\n-\n-  private _observeLifecycle(directive: any, isComponent: boolean): void {\n-    const ctx = getLViewFromDirectiveOrElementInstance(directive);\n-    if (!ctx) {\n-      return;\n-    }\n-    const tview = ctx[1];\n-    hookTViewProperties.forEach((hook) => {\n-      const current = tview[hook];\n-      if (!Array.isArray(current)) {\n-        return;\n-      }\n-      current.forEach((el: any, idx: number) => {\n-        if (el.patched) {\n-          return;\n-        }\n-        if (typeof el === 'function') {\n-          const self = this;\n-          current[idx] = function (): any {\n-            // We currently don't want to notify the consumer\n-            // for execution of lifecycle hooks of services and pipes.\n-            // These two abstractions don't have `__ngContext__`, and\n-            // currently we won't be able to extract the required\n-            // metadata by the UI.\n-            if (!this[METADATA_PROPERTY_NAME]) {\n-              return;\n-            }\n-            const id = self._tracker.getDirectiveId(this);\n-            const lifecycleHookName = getLifeCycleName(this, el);\n-            const element = getDirectiveHostElement(this);\n-            self._onLifecycleHookStart(this, lifecycleHookName, element, id, isComponent);\n-            const result = el.apply(this, arguments);\n-            self._onLifecycleHookEnd(this, lifecycleHookName, element, id, isComponent);\n-            return result;\n-          };\n-          current[idx].patched = true;\n-          this._undoLifecyclePatch.push(() => {\n-            current[idx] = el;\n-          });\n-        }\n-      });\n-    });\n-  }\n-\n-  private _onCreate(\n-    _: any,\n-    __: Node,\n-    id: number | undefined,\n-    ___: boolean,\n-    position: ElementPosition | undefined\n-  ): void {\n-    if (id === undefined || position === undefined) {\n-      return;\n-    }\n-    this._invokeCallback('onCreate', arguments);\n-  }\n-\n-  private _onDestroy(\n-    _: any,\n-    __: Node,\n-    id: number | undefined,\n-    ___: boolean,\n-    position: ElementPosition | undefined\n-  ): void {\n-    if (id === undefined || position === undefined) {\n-      return;\n-    }\n-    this._invokeCallback('onDestroy', arguments);\n-  }\n-\n-  private _onChangeDetectionStart(\n-    _: any,\n-    __: Node,\n-    id: number | undefined,\n-    position: ElementPosition | undefined\n-  ): void {\n-    if (id === undefined || position === undefined) {\n-      return;\n-    }\n-    this._invokeCallback('onChangeDetectionStart', arguments);\n-  }\n-\n-  private _onChangeDetectionEnd(_: any, __: Node, id: number | undefined, position: ElementPosition | undefined): void {\n-    if (id === undefined || position === undefined) {\n-      return;\n-    }\n-    this._invokeCallback('onChangeDetectionEnd', arguments);\n-  }\n-\n-  private _onLifecycleHookStart(\n-    _: any,\n-    __: keyof LifecycleProfile | 'unknown',\n-    ___: Node,\n-    id: number | undefined,\n-    ____: boolean\n-  ): void {\n-    if (id === undefined) {\n-      return;\n-    }\n-    this._invokeCallback('onLifecycleHookStart', arguments);\n-  }\n-\n-  private _onLifecycleHookEnd(\n-    _: any,\n-    __: keyof LifecycleProfile | 'unknown',\n-    ___: Node,\n-    id: number | undefined,\n-    ____: boolean\n-  ): void {\n-    if (id === undefined) {\n-      return;\n-    }\n-    this._invokeCallback('onLifecycleHookEnd', arguments);\n-  }\n-\n-  private _invokeCallback(name: keyof Hooks, args: IArguments): void {\n-    this._hooks.forEach((config) => {\n-      const cb = config[name];\n-      if (cb) {\n-        cb.apply(null, args);\n-      }\n-    });\n+    this.profiler.onIndexForest(newNodes, removedNodes);\n   }\n }"
        },
        {
            "sha": "8a326131505c3ddb62be074d8f25792fac84c2d8",
            "filename": "projects/ng-devtools-backend/src/lib/hooks/identity-tracker.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 6,
            "changes": 24,
            "blob_url": "https://github.com/angular/angular/blob/534809cf856243e74b85af4231903fdf84f63782/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fidentity-tracker.ts",
            "raw_url": "https://github.com/angular/angular/raw/534809cf856243e74b85af4231903fdf84f63782/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fidentity-tracker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fidentity-tracker.ts?ref=534809cf856243e74b85af4231903fdf84f63782",
            "patch": "@@ -9,16 +9,28 @@ interface TreeNode {\n   children: TreeNode[];\n }\n \n-type NodeArray = {\n+export type NodeArray = {\n   directive: any;\n   isComponent: boolean;\n }[];\n \n export class IdentityTracker {\n+  private static _instance: IdentityTracker;\n+\n   private _directiveIdCounter = 0;\n   private _currentDirectivePosition = new Map<any, ElementPosition>();\n   private _currentDirectiveId = new Map<any, number>();\n-  private _isComponent = new Map<any, boolean>();\n+  isComponent = new Map<any, boolean>();\n+\n+  // private constructor for Singleton Pattern\n+  private constructor() {}\n+\n+  static getInstance(): IdentityTracker {\n+    if (!IdentityTracker._instance) {\n+      IdentityTracker._instance = new IdentityTracker();\n+    }\n+    return IdentityTracker._instance;\n+  }\n \n   getDirectivePosition(dir: any): ElementPosition | undefined {\n     return this._currentDirectivePosition.get(dir);\n@@ -46,7 +58,7 @@ export class IdentityTracker {\n     indexedForest.forEach((root) => this._index(root, null, newNodes, allNodes));\n     this._currentDirectiveId.forEach((_: number, dir: any) => {\n       if (!allNodes.has(dir)) {\n-        removedNodes.push({ directive: dir, isComponent: !!this._isComponent.get(dir) });\n+        removedNodes.push({ directive: dir, isComponent: !!this.isComponent.get(dir) });\n         // We can't clean these up because during profiling\n         // they might be requested for removed components\n         // this._currentDirectiveId.delete(dir);\n@@ -64,12 +76,12 @@ export class IdentityTracker {\n   ): void {\n     if (node.component) {\n       allNodes.add(node.component.instance);\n-      this._isComponent.set(node.component.instance, true);\n+      this.isComponent.set(node.component.instance, true);\n       this._indexNode(node.component.instance, node.position, newNodes);\n     }\n     (node.directives || []).forEach((dir) => {\n       allNodes.add(dir.instance);\n-      this._isComponent.set(dir.instance, false);\n+      this.isComponent.set(dir.instance, false);\n       this._indexNode(dir.instance, node.position, newNodes);\n     });\n     node.children.forEach((child) => this._index(child, parent, newNodes, allNodes));\n@@ -78,7 +90,7 @@ export class IdentityTracker {\n   private _indexNode(directive: any, position: ElementPosition, newNodes: NodeArray): void {\n     this._currentDirectivePosition.set(directive, position);\n     if (!this._currentDirectiveId.has(directive)) {\n-      newNodes.push({ directive, isComponent: !!this._isComponent.get(directive) });\n+      newNodes.push({ directive, isComponent: !!this.isComponent.get(directive) });\n       this._currentDirectiveId.set(directive, this._directiveIdCounter++);\n     }\n   }"
        },
        {
            "sha": "cdf21d45adda8ea7bb50cd490804024964e2e959",
            "filename": "projects/ng-devtools-backend/src/lib/hooks/index.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/534809cf856243e74b85af4231903fdf84f63782/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/534809cf856243e74b85af4231903fdf84f63782/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Findex.ts?ref=534809cf856243e74b85af4231903fdf84f63782",
            "patch": "@@ -36,12 +36,13 @@ export const disableTimingAPI = () => (timingAPIFlag = false);\n \n const timingAPIEnabled = () => timingAPIFlag;\n \n-export let directiveForestHooks: DirectiveForestHooks;\n+let directiveForestHooks: DirectiveForestHooks;\n export const initializeOrGetDirectiveForestHooks = () => {\n   if (directiveForestHooks) {\n     return directiveForestHooks;\n   }\n-  directiveForestHooks = new DirectiveForestHooks({\n+  directiveForestHooks = new DirectiveForestHooks();\n+  directiveForestHooks.profiler.subscribe({\n     onChangeDetectionStart(component: any): void {\n       if (!timingAPIEnabled()) {\n         return;"
        },
        {
            "sha": "b95402ad677aa3bdaa20d27b4f1db338a8723a36",
            "filename": "projects/ng-devtools-backend/src/lib/hooks/profiler.ts",
            "status": "added",
            "additions": 460,
            "deletions": 0,
            "changes": 460,
            "blob_url": "https://github.com/angular/angular/blob/534809cf856243e74b85af4231903fdf84f63782/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fprofiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/534809cf856243e74b85af4231903fdf84f63782/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fprofiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/projects%2Fng-devtools-backend%2Fsrc%2Flib%2Fhooks%2Fprofiler.ts?ref=534809cf856243e74b85af4231903fdf84f63782",
            "patch": "@@ -0,0 +1,460 @@\n+import { ɵProfilerEvent } from '@angular/core';\n+import { ElementPosition, LifecycleProfile } from 'protocol';\n+import { Subject } from 'rxjs';\n+import {\n+  getDirectiveHostElement,\n+  getLViewFromDirectiveOrElementInstance,\n+  METADATA_PROPERTY_NAME,\n+} from '../directive-forest';\n+import { runOutsideAngular } from '../utils';\n+import { IdentityTracker, NodeArray } from './identity-tracker';\n+\n+type CreationHook = (\n+  componentOrDirective: any,\n+  node: Node,\n+  id: number,\n+  isComponent: boolean,\n+  position: ElementPosition\n+) => void;\n+\n+type LifecycleStartHook = (\n+  componentOrDirective: any,\n+  hook: keyof LifecycleProfile | 'unknown',\n+  node: Node,\n+  id: number,\n+  isComponent: boolean\n+) => void;\n+\n+type LifecycleEndHook = (\n+  componentOrDirective: any,\n+  hook: keyof LifecycleProfile | 'unknown',\n+  node: Node,\n+  id: number,\n+  isComponent: boolean\n+) => void;\n+\n+type ChangeDetectionStartHook = (component: any, node: Node, id: number, position: ElementPosition) => void;\n+\n+type ChangeDetectionEndHook = (component: any, node: Node, id: number, position: ElementPosition) => void;\n+\n+type DestroyHook = (\n+  componentOrDirective: any,\n+  node: Node,\n+  id: number,\n+  isComponent: boolean,\n+  position: ElementPosition\n+) => void;\n+\n+export interface Hooks {\n+  onCreate: CreationHook;\n+  onDestroy: DestroyHook;\n+  onChangeDetectionStart: ChangeDetectionStartHook;\n+  onChangeDetectionEnd: ChangeDetectionEndHook;\n+  onLifecycleHookStart: LifecycleStartHook;\n+  onLifecycleHookEnd: LifecycleEndHook;\n+}\n+\n+const ngProfilerCallbacks: ((event: ɵProfilerEvent, instanceOrLView: {}, hookOrListener: any) => void)[] = [];\n+export const setProfilerCallback = (cb: (event: ɵProfilerEvent, instanceOrLView: {}, hookOrListener: any) => void) => {\n+  ngProfilerCallbacks.push(cb);\n+};\n+\n+/**\n+ * Factory method for creating profiler object.\n+ * Gives priority to NgProfiler, falls back on PatchingProfiler if framework APIs are not present.\n+ */\n+export const selectProfilerStrategy = (): Profiler => {\n+  const ng = (window as any).ng;\n+  if (typeof ng?.ɵsetProfiler === 'function') {\n+    ng.ɵsetProfiler((event: ɵProfilerEvent, instanceOrLView: {}, hookOrListener: any) =>\n+      ngProfilerCallbacks.forEach((cb) => cb(event, instanceOrLView, hookOrListener))\n+    );\n+    return new NgProfiler();\n+  }\n+\n+  return new PatchingProfiler();\n+};\n+\n+/**\n+ *  Class for profiling angular applications. Handles hook subscriptions and emitting change detection events.\n+ */\n+export abstract class Profiler {\n+  protected _inChangeDetection = false;\n+  changeDetection$ = new Subject<void>();\n+\n+  private _hooks: Partial<Hooks>[] = [];\n+\n+  constructor(config: Partial<Hooks> = {}) {\n+    this._hooks.push(config);\n+  }\n+\n+  abstract destroy(): void;\n+\n+  abstract onIndexForest(newNodes: NodeArray, removedNodes: NodeArray): void;\n+\n+  subscribe(config: Partial<Hooks>): void {\n+    this._hooks.push(config);\n+  }\n+\n+  unsubscribe(config: Partial<Hooks>): void {\n+    this._hooks.splice(this._hooks.indexOf(config), 1);\n+  }\n+\n+  protected _onCreate(\n+    _: any,\n+    __: Node,\n+    id: number | undefined,\n+    ___: boolean,\n+    position: ElementPosition | undefined\n+  ): void {\n+    if (id === undefined || position === undefined) {\n+      return;\n+    }\n+    this._invokeCallback('onCreate', arguments);\n+  }\n+\n+  protected _onDestroy(\n+    _: any,\n+    __: Node,\n+    id: number | undefined,\n+    ___: boolean,\n+    position: ElementPosition | undefined\n+  ): void {\n+    if (id === undefined || position === undefined) {\n+      return;\n+    }\n+    this._invokeCallback('onDestroy', arguments);\n+  }\n+\n+  protected _onChangeDetectionStart(\n+    _: any,\n+    __: Node,\n+    id: number | undefined,\n+    position: ElementPosition | undefined\n+  ): void {\n+    if (id === undefined || position === undefined) {\n+      return;\n+    }\n+    this._invokeCallback('onChangeDetectionStart', arguments);\n+  }\n+\n+  protected _onChangeDetectionEnd(\n+    _: any,\n+    __: Node,\n+    id: number | undefined,\n+    position: ElementPosition | undefined\n+  ): void {\n+    if (id === undefined || position === undefined) {\n+      return;\n+    }\n+    this._invokeCallback('onChangeDetectionEnd', arguments);\n+  }\n+\n+  protected _onLifecycleHookStart(\n+    _: any,\n+    __: keyof LifecycleProfile | 'unknown',\n+    ___: Node,\n+    id: number | undefined,\n+    ____: boolean\n+  ): void {\n+    if (id === undefined) {\n+      return;\n+    }\n+    this._invokeCallback('onLifecycleHookStart', arguments);\n+  }\n+\n+  protected _onLifecycleHookEnd(\n+    _: any,\n+    __: keyof LifecycleProfile | 'unknown',\n+    ___: Node,\n+    id: number | undefined,\n+    ____: boolean\n+  ): void {\n+    if (id === undefined) {\n+      return;\n+    }\n+    this._invokeCallback('onLifecycleHookEnd', arguments);\n+  }\n+\n+  private _invokeCallback(name: keyof Hooks, args: IArguments): void {\n+    this._hooks.forEach((config) => {\n+      const cb = config[name];\n+      if (cb) {\n+        cb.apply(null, args);\n+      }\n+    });\n+  }\n+}\n+\n+const hookNames = [\n+  'OnInit',\n+  'OnDestroy',\n+  'OnChanges',\n+  'DoCheck',\n+  'AfterContentInit',\n+  'AfterContentChecked',\n+  'AfterViewInit',\n+  'AfterViewChecked',\n+];\n+\n+const hookMethodNames = new Set(hookNames.map((hook) => `ng${hook}`));\n+\n+const hookTViewProperties = [\n+  'preOrderHooks',\n+  'preOrderCheckHooks',\n+  'contentHooks',\n+  'contentCheckHooks',\n+  'viewHooks',\n+  'viewCheckHooks',\n+  'destroyHooks',\n+];\n+\n+// Only used in older Angular versions prior to the introduction of `getDirectiveMetadata`\n+const componentMetadata = (instance: any) => instance?.constructor?.ɵcmp;\n+\n+const getLifeCycleName = (obj: {}, fn: any): keyof LifecycleProfile | 'unknown' => {\n+  const proto = Object.getPrototypeOf(obj);\n+  const keys = Object.getOwnPropertyNames(proto);\n+  for (const propName of keys) {\n+    // We don't want to touch random get accessors.\n+    if (!hookMethodNames.has(propName)) {\n+      continue;\n+    }\n+    if (proto[propName] === fn) {\n+      return propName as keyof LifecycleProfile;\n+    }\n+  }\n+  const fnName = fn.name;\n+  if (typeof fnName !== 'string') {\n+    return 'unknown';\n+  }\n+  for (const hookName of hookNames) {\n+    if (fnName.indexOf(hookName) >= 0) {\n+      return `ng${hookName}` as keyof LifecycleProfile;\n+    }\n+  }\n+  return 'unknown';\n+};\n+\n+/** Implemenation of Profiler that uses monkey patching of directive templates and lifecycle methods to fire profiler hooks. */\n+class PatchingProfiler extends Profiler {\n+  private _patched = new Map<any, () => void>();\n+  private _undoLifecyclePatch: (() => void)[] = [];\n+  private _tracker = IdentityTracker.getInstance();\n+\n+  destroy(): void {\n+    this._tracker.destroy();\n+\n+    for (const [cmp, template] of this._patched) {\n+      const meta = componentMetadata(cmp);\n+      meta.template = template;\n+      meta.tView.template = template;\n+    }\n+\n+    this._patched = new Map<any, () => void>();\n+    this._undoLifecyclePatch.forEach((p) => p());\n+    this._undoLifecyclePatch = [];\n+  }\n+\n+  onIndexForest(newNodes: NodeArray, removedNodes: NodeArray): void {\n+    newNodes.forEach((node) => {\n+      this._observeLifecycle(node.directive, node.isComponent);\n+      this._observeComponent(node.directive);\n+      this._fireCreationCallback(node.directive, node.isComponent);\n+    });\n+    removedNodes.forEach((node) => {\n+      this._patched.delete(node.directive);\n+      this._fireDestroyCallback(node.directive, node.isComponent);\n+    });\n+  }\n+\n+  private _fireCreationCallback(component: any, isComponent: boolean): void {\n+    const position = this._tracker.getDirectivePosition(component);\n+    const id = this._tracker.getDirectiveId(component);\n+    this._onCreate(component, getDirectiveHostElement(component), id, isComponent, position);\n+  }\n+\n+  private _fireDestroyCallback(component: any, isComponent: boolean): void {\n+    const position = this._tracker.getDirectivePosition(component);\n+    const id = this._tracker.getDirectiveId(component);\n+    this._onDestroy(component, getDirectiveHostElement(component), id, isComponent, position);\n+  }\n+\n+  private _observeComponent(cmp: any): void {\n+    const declarations = componentMetadata(cmp);\n+    if (!declarations) {\n+      return;\n+    }\n+    const original = declarations.template;\n+    const self = this;\n+    if (original.patched) {\n+      return;\n+    }\n+    declarations.tView.template = function (_: any, component: any): void {\n+      if (!self._inChangeDetection) {\n+        self._inChangeDetection = true;\n+        runOutsideAngular(() => {\n+          Promise.resolve().then(() => {\n+            self.changeDetection$.next();\n+            self._inChangeDetection = false;\n+          });\n+        });\n+      }\n+      const position = self._tracker.getDirectivePosition(component);\n+      const id = self._tracker.getDirectiveId(component);\n+\n+      self._onChangeDetectionStart(component, getDirectiveHostElement(component), id, position);\n+      original.apply(this, arguments);\n+      if (self._tracker.hasDirective(component) && id !== undefined && position !== undefined) {\n+        self._onChangeDetectionEnd(component, getDirectiveHostElement(component), id, position);\n+      }\n+    };\n+    declarations.tView.template.patched = true;\n+    this._patched.set(cmp, original);\n+  }\n+\n+  private _observeLifecycle(directive: any, isComponent: boolean): void {\n+    const ctx = getLViewFromDirectiveOrElementInstance(directive);\n+    if (!ctx) {\n+      return;\n+    }\n+    const tview = ctx[1];\n+    hookTViewProperties.forEach((hook) => {\n+      const current = tview[hook];\n+      if (!Array.isArray(current)) {\n+        return;\n+      }\n+      current.forEach((el: any, idx: number) => {\n+        if (el.patched) {\n+          return;\n+        }\n+        if (typeof el === 'function') {\n+          const self = this;\n+          current[idx] = function (): any {\n+            // We currently don't want to notify the consumer\n+            // for execution of lifecycle hooks of services and pipes.\n+            // These two abstractions don't have `__ngContext__`, and\n+            // currently we won't be able to extract the required\n+            // metadata by the UI.\n+            if (!this[METADATA_PROPERTY_NAME]) {\n+              return;\n+            }\n+            const id = self._tracker.getDirectiveId(this);\n+            const lifecycleHookName = getLifeCycleName(this, el);\n+            const element = getDirectiveHostElement(this);\n+            self._onLifecycleHookStart(this, lifecycleHookName, element, id, isComponent);\n+            const result = el.apply(this, arguments);\n+            self._onLifecycleHookEnd(this, lifecycleHookName, element, id, isComponent);\n+            return result;\n+          };\n+          current[idx].patched = true;\n+          this._undoLifecyclePatch.push(() => {\n+            current[idx] = el;\n+          });\n+        }\n+      });\n+    });\n+  }\n+}\n+\n+/** Implemenation of Profiler that utilizes framework APIs fire profiler hooks. */\n+class NgProfiler extends Profiler {\n+  private _tracker = IdentityTracker.getInstance();\n+\n+  constructor(config: Partial<Hooks> = {}) {\n+    super(config);\n+    setProfilerCallback((event: ɵProfilerEvent, instanceOrLView: {}, hookOrListener: any) => {\n+      if (this[event] === undefined) {\n+        return;\n+      }\n+\n+      this[event](instanceOrLView, hookOrListener);\n+    });\n+  }\n+\n+  destroy(): void {\n+    this._tracker.destroy();\n+  }\n+\n+  onIndexForest(newNodes: NodeArray, removedNodes: NodeArray): void {\n+    newNodes.forEach((node) => {\n+      const { directive, isComponent } = node;\n+\n+      const position = this._tracker.getDirectivePosition(directive);\n+      const id = this._tracker.getDirectiveId(directive);\n+      this._onCreate(directive, getDirectiveHostElement(directive), id, isComponent, position);\n+    });\n+\n+    removedNodes.forEach((node) => {\n+      const { directive, isComponent } = node;\n+\n+      const position = this._tracker.getDirectivePosition(directive);\n+      const id = this._tracker.getDirectiveId(directive);\n+      this._onDestroy(directive, getDirectiveHostElement(directive), id, isComponent, position);\n+    });\n+  }\n+\n+  [ɵProfilerEvent.TemplateCreateStart](_directive: any, _hookOrListener: any): void {\n+    // todo: implement\n+    return;\n+  }\n+\n+  [ɵProfilerEvent.TemplateCreateEnd](_directive: any, _hookOrListener: any): void {\n+    // todo: implement\n+    return;\n+  }\n+\n+  [ɵProfilerEvent.TemplateUpdateStart](directive: any, _hookOrListener: any): void {\n+    if (!this._inChangeDetection) {\n+      this._inChangeDetection = true;\n+      runOutsideAngular(() => {\n+        Promise.resolve().then(() => {\n+          this.changeDetection$.next();\n+          this._inChangeDetection = false;\n+        });\n+      });\n+    }\n+\n+    const position = this._tracker.getDirectivePosition(directive);\n+    const id = this._tracker.getDirectiveId(directive);\n+\n+    this._onChangeDetectionStart(directive, getDirectiveHostElement(directive), id, position);\n+  }\n+\n+  [ɵProfilerEvent.TemplateUpdateEnd](directive: any, _hookOrListener: any): void {\n+    const position = this._tracker.getDirectivePosition(directive);\n+    const id = this._tracker.getDirectiveId(directive);\n+\n+    if (this._tracker.hasDirective(directive) && id !== undefined && position !== undefined) {\n+      this._onChangeDetectionEnd(directive, getDirectiveHostElement(directive), id, position);\n+    }\n+  }\n+\n+  [ɵProfilerEvent.LifecycleHookStart](directive: any, hookOrListener: any): void {\n+    const id = this._tracker.getDirectiveId(directive);\n+    const element = getDirectiveHostElement(directive);\n+    const lifecycleHookName = getLifeCycleName(directive, hookOrListener);\n+    const isComponent = !!this._tracker.isComponent.get(directive);\n+\n+    this._onLifecycleHookStart(directive, lifecycleHookName, element, id, isComponent);\n+  }\n+\n+  [ɵProfilerEvent.LifecycleHookEnd](directive: any, hookOrListener: any): void {\n+    const id = this._tracker.getDirectiveId(directive);\n+    const element = getDirectiveHostElement(directive);\n+    const lifecycleHookName = getLifeCycleName(directive, hookOrListener);\n+    const isComponent = !!this._tracker.isComponent.get(directive);\n+\n+    this._onLifecycleHookEnd(directive, lifecycleHookName, element, id, isComponent);\n+  }\n+\n+  [ɵProfilerEvent.OutputStart](_directive: any, _hookOrListener: any): void {\n+    // todo: implement\n+    return;\n+  }\n+\n+  [ɵProfilerEvent.OutputEnd](_directive: any, _hookOrListener: any): void {\n+    // todo: implement\n+    return;\n+  }\n+}"
        },
        {
            "sha": "a3a3ff81d7d9651ba21d45faaa2fe8532d64b4f4",
            "filename": "src/app/demo-app/todo/home/todos/todo/tooltip.directive.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/534809cf856243e74b85af4231903fdf84f63782/src%2Fapp%2Fdemo-app%2Ftodo%2Fhome%2Ftodos%2Ftodo%2Ftooltip.directive.ts",
            "raw_url": "https://github.com/angular/angular/raw/534809cf856243e74b85af4231903fdf84f63782/src%2Fapp%2Fdemo-app%2Ftodo%2Fhome%2Ftodos%2Ftodo%2Ftooltip.directive.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/src%2Fapp%2Fdemo-app%2Ftodo%2Fhome%2Ftodos%2Ftodo%2Ftooltip.directive.ts?ref=534809cf856243e74b85af4231903fdf84f63782",
            "patch": "@@ -25,6 +25,5 @@ export class TooltipDirective {\n     } else {\n       delete (this as any).extraProp;\n     }\n-    console.log(this);\n   }\n }"
        }
    ],
    "stats": {
        "total": 836,
        "additions": 500,
        "deletions": 336
    }
}