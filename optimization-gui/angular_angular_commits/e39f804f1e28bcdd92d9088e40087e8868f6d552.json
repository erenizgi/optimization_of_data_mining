{
    "author": "crisbeto",
    "message": "test(upgrade): fix flaky tests (#44597)\n\nFixes a couple of tests that have been flaking our test runs. The two tests actually failed consistently when run in isolation, but they passed if at least one test ran before them. My understanding was that they failed, because they were running outside of the `NgZone` which meant that the errors being thrown inside of a `Promise` weren't being flushed.\n\nPR Close #44597",
    "sha": "e39f804f1e28bcdd92d9088e40087e8868f6d552",
    "files": [
        {
            "sha": "a761bffa7da6719c49acfa0ffd6517c6dbc7a453",
            "filename": "packages/upgrade/src/dynamic/test/upgrade_spec.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 5,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/e39f804f1e28bcdd92d9088e40087e8868f6d552/packages%2Fupgrade%2Fsrc%2Fdynamic%2Ftest%2Fupgrade_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/e39f804f1e28bcdd92d9088e40087e8868f6d552/packages%2Fupgrade%2Fsrc%2Fdynamic%2Ftest%2Fupgrade_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fupgrade%2Fsrc%2Fdynamic%2Ftest%2Fupgrade_spec.ts?ref=e39f804f1e28bcdd92d9088e40087e8868f6d552",
            "patch": "@@ -7,7 +7,7 @@\n  */\n \n import {ChangeDetectorRef, Component, destroyPlatform, EventEmitter, forwardRef, Input, NgModule, NgModuleFactory, NgZone, NO_ERRORS_SCHEMA, OnChanges, OnDestroy, Output, SimpleChange, SimpleChanges, Testability} from '@angular/core';\n-import {fakeAsync, flushMicrotasks, tick, waitForAsync} from '@angular/core/testing';\n+import {fakeAsync, flushMicrotasks, TestBed, tick, waitForAsync} from '@angular/core/testing';\n import {BrowserModule} from '@angular/platform-browser';\n import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';\n \n@@ -182,6 +182,7 @@ withEachNg1Version(() => {\n \n     describe('bootstrap errors', () => {\n       let adapter: UpgradeAdapter;\n+      let zone: NgZone;\n \n       beforeEach(() => {\n         angular.module_('ng1', []);\n@@ -200,6 +201,7 @@ withEachNg1Version(() => {\n         class Ng2Module {\n         }\n \n+        zone = TestBed.inject(NgZone);\n         adapter = new UpgradeAdapter(Ng2Module);\n       });\n \n@@ -208,17 +210,25 @@ withEachNg1Version(() => {\n            spyOn(console, 'error');\n \n            expect(() => {\n-             adapter.bootstrap(html('<ng2></ng2>'), ['ng1']).ready(resolveSpy);\n-             flushMicrotasks();\n+             // Needs to be run inside the `NgZone` in order\n+             // for the promises to be flushed correctly.\n+             zone.run(() => {\n+               adapter.bootstrap(html('<ng2></ng2>'), ['ng1']).ready(resolveSpy);\n+               flushMicrotasks();\n+             });\n            }).toThrowError();\n            expect(resolveSpy).not.toHaveBeenCalled();\n          }));\n \n       it('should output an error message to the console and re-throw', fakeAsync(() => {\n            const consoleErrorSpy: jasmine.Spy = spyOn(console, 'error');\n            expect(() => {\n-             adapter.bootstrap(html('<ng2></ng2>'), ['ng1']);\n-             flushMicrotasks();\n+             // Needs to be run inside the `NgZone` in order\n+             // for the promises to be flushed correctly.\n+             zone.run(() => {\n+               adapter.bootstrap(html('<ng2></ng2>'), ['ng1']);\n+               flushMicrotasks();\n+             });\n            }).toThrowError();\n            const args: any[] = consoleErrorSpy.calls.mostRecent().args;\n            expect(consoleErrorSpy).toHaveBeenCalled();"
        }
    ],
    "stats": {
        "total": 20,
        "additions": 15,
        "deletions": 5
    }
}