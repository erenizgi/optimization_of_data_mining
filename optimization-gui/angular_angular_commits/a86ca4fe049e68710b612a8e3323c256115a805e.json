{
    "author": "atscott",
    "message": "feat(language-service): Enable renaming of pipes (#40523)\n\nThis commit updates the logic in the LS renaming to handle renaming of\npipes, both from the name expression in the pipe metadata as well as\nfrom the template.\n\nThe approach here is to introduce a new concept for renaming: an\n\"indirect\" rename. In this type of rename, we find rename locations\nin with the native TS Language Service using a different node than the\none we are renaming. Using pipes as an example, if we want to rename the\npipe name from the string literal expression, we use the transform\nmethod to find rename locations rather than the string literal itself\n(which will not return any results because it's just a string).\n\nSo the general approach is:\n* Determine the details about the requested rename location, i.e. the\n  targeted template node and symbol for a template rename, or the TS\n  node for a rename outside a template.\n* Using the details of the location, determine if the node is attempting\n  to rename something that is an indirect rename (pipes, selectors,\n  bindings). Other renames are considered \"direct\" and we use whatever\n  results the native TSLS returns for the rename locations.\n* In the case of indirect renames, we throw out results that do not\n  appear in the templates (in this case, the shim files). These results will be\n  for the \"indirect\" rename that we don't want to touch, but are only\n  using to find template results.\n* Create an additional rename result for the string literal expression\n  that is used for the input/output alias, the pipe name, or the\n  selector.\n\n Note that renaming is moving towards being much more accurate in its\n results than \"find references\". When the approach for renaming\n stabilizes, we may want to then port the changes back to being shared\n with the approach for retrieving references.\n\nPR Close #40523",
    "sha": "a86ca4fe049e68710b612a8e3323c256115a805e",
    "files": [
        {
            "sha": "9e00e0cc9261c9bbf3e552e5a29f36f0c3123a2c",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/component.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts?ref=a86ca4fe049e68710b612a8e3323c256115a805e",
            "patch": "@@ -16,7 +16,7 @@ import {ImportedFile, ModuleResolver, Reference, ReferenceEmitter} from '../../i\n import {DependencyTracker} from '../../incremental/api';\n import {extractSemanticTypeParameters, isArrayEqual, isReferenceEqual, SemanticDepGraphUpdater, SemanticReference, SemanticSymbol} from '../../incremental/semantic_graph';\n import {IndexingContext} from '../../indexer';\n-import {ClassPropertyMapping, ComponentResources, DirectiveMeta, DirectiveTypeCheckMeta, extractDirectiveTypeCheckMeta, InjectableClassRegistry, MetadataReader, MetadataRegistry, Resource, ResourceRegistry} from '../../metadata';\n+import {ClassPropertyMapping, ComponentResources, DirectiveMeta, DirectiveTypeCheckMeta, extractDirectiveTypeCheckMeta, InjectableClassRegistry, MetadataReader, MetadataRegistry, MetaType, Resource, ResourceRegistry} from '../../metadata';\n import {EnumValue, PartialEvaluator, ResolvedValue} from '../../partial_evaluator';\n import {PerfEvent, PerfRecorder} from '../../perf';\n import {ClassDeclaration, DeclarationNode, Decorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\n@@ -524,6 +524,7 @@ export class ComponentDecoratorHandler implements\n     // the information about the component is available during the compile() phase.\n     const ref = new Reference(node);\n     this.metaRegistry.registerDirectiveMetadata({\n+      type: MetaType.Directive,\n       ref,\n       name: node.name.text,\n       selector: analysis.meta.selector,"
        },
        {
            "sha": "c9a4f2a8317090704eed09b37d28749eb41ff2d1",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/directive.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdirective.ts",
            "raw_url": "https://github.com/angular/angular/raw/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdirective.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdirective.ts?ref=a86ca4fe049e68710b612a8e3323c256115a805e",
            "patch": "@@ -13,7 +13,7 @@ import * as ts from 'typescript';\n import {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\n import {Reference} from '../../imports';\n import {areTypeParametersEqual, extractSemanticTypeParameters, isArrayEqual, isSetEqual, isSymbolEqual, SemanticDepGraphUpdater, SemanticSymbol, SemanticTypeParameter} from '../../incremental/semantic_graph';\n-import {BindingPropertyName, ClassPropertyMapping, ClassPropertyName, DirectiveTypeCheckMeta, InjectableClassRegistry, MetadataReader, MetadataRegistry, TemplateGuardMeta} from '../../metadata';\n+import {BindingPropertyName, ClassPropertyMapping, ClassPropertyName, DirectiveTypeCheckMeta, InjectableClassRegistry, MetadataReader, MetadataRegistry, MetaType, TemplateGuardMeta} from '../../metadata';\n import {extractDirectiveTypeCheckMeta} from '../../metadata/src/util';\n import {DynamicValue, EnumValue, PartialEvaluator} from '../../partial_evaluator';\n import {PerfEvent, PerfRecorder} from '../../perf';\n@@ -256,6 +256,7 @@ export class DirectiveDecoratorHandler implements\n     // the information about the directive is available during the compile() phase.\n     const ref = new Reference(node);\n     this.metaRegistry.registerDirectiveMetadata({\n+      type: MetaType.Directive,\n       ref,\n       name: node.name.text,\n       selector: analysis.meta.selector,"
        },
        {
            "sha": "f623bfaf6a481a4808590c3dc4292a2755bcb9d6",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/pipe.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fpipe.ts",
            "raw_url": "https://github.com/angular/angular/raw/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fpipe.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fpipe.ts?ref=a86ca4fe049e68710b612a8e3323c256115a805e",
            "patch": "@@ -12,7 +12,7 @@ import * as ts from 'typescript';\n import {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\n import {Reference} from '../../imports';\n import {SemanticSymbol} from '../../incremental/semantic_graph';\n-import {InjectableClassRegistry, MetadataRegistry} from '../../metadata';\n+import {InjectableClassRegistry, MetadataRegistry, MetaType} from '../../metadata';\n import {PartialEvaluator} from '../../partial_evaluator';\n import {PerfEvent, PerfRecorder} from '../../perf';\n import {ClassDeclaration, Decorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\n@@ -27,6 +27,7 @@ import {compileResults, findAngularDecorator, getValidConstructorDependencies, m\n export interface PipeHandlerData {\n   meta: R3PipeMetadata;\n   classMetadata: R3ClassMetadata|null;\n+  pipeNameExpr: ts.Expression;\n }\n \n /**\n@@ -134,6 +135,7 @@ export class PipeDecoratorHandler implements\n           pure,\n         },\n         classMetadata: extractClassMetadata(clazz, this.reflector, this.isCore),\n+        pipeNameExpr,\n       },\n     };\n   }\n@@ -144,7 +146,8 @@ export class PipeDecoratorHandler implements\n \n   register(node: ClassDeclaration, analysis: Readonly<PipeHandlerData>): void {\n     const ref = new Reference(node);\n-    this.metaRegistry.registerPipeMetadata({ref, name: analysis.meta.pipeName});\n+    this.metaRegistry.registerPipeMetadata(\n+        {type: MetaType.Pipe, ref, name: analysis.meta.pipeName, nameExpr: analysis.pipeNameExpr});\n \n     this.injectableRegistry.registerInjectable(node);\n   }"
        },
        {
            "sha": "f33a8691624d3bc03098fbfde4645264ccfa5b2d",
            "filename": "packages/compiler-cli/src/ngtsc/core/src/compiler.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 1,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts?ref=a86ca4fe049e68710b612a8e3323c256115a805e",
            "patch": "@@ -18,7 +18,7 @@ import {AbsoluteModuleStrategy, AliasingHost, AliasStrategy, DefaultImportTracke\n import {IncrementalBuildStrategy, IncrementalCompilation, IncrementalState} from '../../incremental';\n import {SemanticSymbol} from '../../incremental/semantic_graph';\n import {generateAnalysis, IndexedComponent, IndexingContext} from '../../indexer';\n-import {ComponentResources, CompoundMetadataReader, CompoundMetadataRegistry, DtsMetadataReader, InjectableClassRegistry, LocalMetadataRegistry, MetadataReader, ResourceRegistry} from '../../metadata';\n+import {ComponentResources, CompoundMetadataReader, CompoundMetadataRegistry, DirectiveMeta, DtsMetadataReader, InjectableClassRegistry, LocalMetadataRegistry, MetadataReader, PipeMeta, ResourceRegistry} from '../../metadata';\n import {ModuleWithProvidersScanner} from '../../modulewithproviders';\n import {PartialEvaluator} from '../../partial_evaluator';\n import {ActivePerfRecorder, DelegatingPerfRecorder, PerfCheckpoint, PerfEvent, PerfPhase} from '../../perf';\n@@ -528,6 +528,19 @@ export class NgCompiler {\n     return {styles, template};\n   }\n \n+  getMeta(classDecl: DeclarationNode): PipeMeta|DirectiveMeta|null {\n+    if (!isNamedClassDeclaration(classDecl)) {\n+      return null;\n+    }\n+    const ref = new Reference(classDecl);\n+    const {metaReader} = this.ensureAnalyzed();\n+    const meta = metaReader.getPipeMetadata(ref) ?? metaReader.getDirectiveMetadata(ref);\n+    if (meta === null) {\n+      return null;\n+    }\n+    return meta;\n+  }\n+\n   /**\n    * Perform Angular's analysis step (as a precursor to `getDiagnostics` or `prepareEmit`)\n    * asynchronously."
        },
        {
            "sha": "d686e2faab463d5dcf158443f98bbe661e593c15",
            "filename": "packages/compiler-cli/src/ngtsc/metadata/src/api.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fapi.ts?ref=a86ca4fe049e68710b612a8e3323c256115a805e",
            "patch": "@@ -80,10 +80,17 @@ export interface DirectiveTypeCheckMeta {\n   isGeneric: boolean;\n }\n \n+export enum MetaType {\n+  Pipe,\n+  Directive,\n+}\n+\n /**\n  * Metadata collected for a directive within an NgModule's scope.\n  */\n export interface DirectiveMeta extends T2DirectiveMeta, DirectiveTypeCheckMeta {\n+  type: MetaType.Directive;\n+\n   ref: Reference<ClassDeclaration>;\n   /**\n    * Unparsed selector of the directive, or null if the directive does not have a selector.\n@@ -144,8 +151,10 @@ export interface TemplateGuardMeta {\n  * Metadata for a pipe within an NgModule's scope.\n  */\n export interface PipeMeta {\n+  type: MetaType.Pipe;\n   ref: Reference<ClassDeclaration>;\n   name: string;\n+  nameExpr: ts.Expression|null;\n }\n \n /**"
        },
        {
            "sha": "497d2e900ff6377557fcedc3cd094c140a95ffe3",
            "filename": "packages/compiler-cli/src/ngtsc/metadata/src/dts.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 2,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fdts.ts",
            "raw_url": "https://github.com/angular/angular/raw/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fdts.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fdts.ts?ref=a86ca4fe049e68710b612a8e3323c256115a805e",
            "patch": "@@ -11,7 +11,7 @@ import * as ts from 'typescript';\n import {Reference} from '../../imports';\n import {ClassDeclaration, isNamedClassDeclaration, ReflectionHost, TypeValueReferenceKind} from '../../reflection';\n \n-import {DirectiveMeta, MetadataReader, NgModuleMeta, PipeMeta} from './api';\n+import {DirectiveMeta, MetadataReader, MetaType, NgModuleMeta, PipeMeta} from './api';\n import {ClassPropertyMapping} from './property_mapping';\n import {extractDirectiveTypeCheckMeta, extractReferencesFromType, readStringArrayType, readStringMapType, readStringType} from './util';\n \n@@ -95,6 +95,7 @@ export class DtsMetadataReader implements MetadataReader {\n     const outputs =\n         ClassPropertyMapping.fromMappedObject(readStringMapType(def.type.typeArguments[4]));\n     return {\n+      type: MetaType.Directive,\n       ref,\n       name: clazz.name.text,\n       isComponent,\n@@ -131,7 +132,12 @@ export class DtsMetadataReader implements MetadataReader {\n       return null;\n     }\n     const name = type.literal.text;\n-    return {ref, name};\n+    return {\n+      type: MetaType.Pipe,\n+      ref,\n+      name,\n+      nameExpr: null,\n+    };\n   }\n }\n "
        },
        {
            "sha": "0aa1d0c49f0a03a47b3347f0429ee791e89171c7",
            "filename": "packages/compiler-cli/src/ngtsc/scope/test/local_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fscope%2Ftest%2Flocal_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fscope%2Ftest%2Flocal_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fscope%2Ftest%2Flocal_spec.ts?ref=a86ca4fe049e68710b612a8e3323c256115a805e",
            "patch": "@@ -9,7 +9,7 @@\n import * as ts from 'typescript';\n \n import {Reference, ReferenceEmitter} from '../../imports';\n-import {ClassPropertyMapping, CompoundMetadataRegistry, DirectiveMeta, LocalMetadataRegistry, MetadataRegistry, PipeMeta} from '../../metadata';\n+import {ClassPropertyMapping, CompoundMetadataRegistry, DirectiveMeta, LocalMetadataRegistry, MetadataRegistry, MetaType, PipeMeta} from '../../metadata';\n import {ClassDeclaration} from '../../reflection';\n import {ScopeData} from '../src/api';\n import {DtsModuleScopeResolver} from '../src/dependency';\n@@ -232,6 +232,7 @@ describe('LocalModuleScopeRegistry', () => {\n function fakeDirective(ref: Reference<ClassDeclaration>): DirectiveMeta {\n   const name = ref.debugName!;\n   return {\n+    type: MetaType.Directive,\n     ref,\n     name,\n     selector: `[${ref.debugName}]`,\n@@ -255,7 +256,7 @@ function fakeDirective(ref: Reference<ClassDeclaration>): DirectiveMeta {\n \n function fakePipe(ref: Reference<ClassDeclaration>): PipeMeta {\n   const name = ref.debugName!;\n-  return {ref, name};\n+  return {type: MetaType.Pipe, ref, name, nameExpr: null};\n }\n \n class MockDtsModuleScopeResolver implements DtsModuleScopeResolver {"
        },
        {
            "sha": "1481d6301c5787bb7757e61bddd92abcc6f8e44d",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/symbols.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fsymbols.ts",
            "raw_url": "https://github.com/angular/angular/raw/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fsymbols.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fsymbols.ts?ref=a86ca4fe049e68710b612a8e3323c256115a805e",
            "patch": "@@ -307,4 +307,4 @@ export interface ClassSymbol {\n \n   /** The position for the variable declaration for the class instance. */\n   shimLocation: ShimLocation;\n-}\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "ae6545a127b312b60b2195348395c064aa92f215",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/test_utils.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts?ref=a86ca4fe049e68710b612a8e3323c256115a805e",
            "patch": "@@ -13,7 +13,7 @@ import {absoluteFrom, AbsoluteFsPath, getSourceFileOrError, LogicalFileSystem} f\n import {TestFile} from '../../file_system/testing';\n import {AbsoluteModuleStrategy, LocalIdentifierStrategy, LogicalProjectStrategy, ModuleResolver, Reexport, Reference, ReferenceEmitter, RelativePathStrategy} from '../../imports';\n import {NOOP_INCREMENTAL_BUILD} from '../../incremental';\n-import {ClassPropertyMapping, CompoundMetadataReader} from '../../metadata';\n+import {ClassPropertyMapping, CompoundMetadataReader, MetaType} from '../../metadata';\n import {NOOP_PERF_RECORDER} from '../../perf';\n import {TsCreateProgramDriver} from '../../program_driver';\n import {ClassDeclaration, isNamedClassDeclaration, TypeScriptReflectionHost} from '../../reflection';\n@@ -595,6 +595,7 @@ function makeScope(program: ts.Program, sf: ts.SourceFile, decls: TestDeclaratio\n \n     if (decl.type === 'directive') {\n       scope.directives.push({\n+        type: MetaType.Directive,\n         ref: new Reference(declClass),\n         baseClass: null,\n         name: decl.name,\n@@ -618,8 +619,10 @@ function makeScope(program: ts.Program, sf: ts.SourceFile, decls: TestDeclaratio\n       });\n     } else if (decl.type === 'pipe') {\n       scope.pipes.push({\n+        type: MetaType.Pipe,\n         ref: new Reference(declClass),\n         name: decl.pipeName,\n+        nameExpr: null,\n       });\n     }\n   }"
        },
        {
            "sha": "79f731f83a3b5cc4b57809b0b22a72a3176a21d9",
            "filename": "packages/language-service/ivy/language_service.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "raw_url": "https://github.com/angular/angular/raw/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Flanguage_service.ts?ref=a86ca4fe049e68710b612a8e3323c256115a805e",
            "patch": "@@ -192,7 +192,8 @@ export class LanguageService {\n   findRenameLocations(fileName: string, position: number): readonly ts.RenameLocation[]|undefined {\n     return this.withCompilerAndPerfTracing(PerfPhase.LsReferencesAndRenames, (compiler) => {\n       return new RenameBuilder(this.programDriver, this.tsLS, compiler)\n-          .findRenameLocations(fileName, position);\n+                 .findRenameLocations(fileName, position) ??\n+          undefined;\n     });\n   }\n "
        },
        {
            "sha": "c99fe80157c990eaa777e6b263d8cf5c94a015c9",
            "filename": "packages/language-service/ivy/references_and_rename.ts",
            "status": "modified",
            "additions": 216,
            "deletions": 61,
            "changes": 277,
            "blob_url": "https://github.com/angular/angular/blob/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Flanguage-service%2Fivy%2Freferences_and_rename.ts",
            "raw_url": "https://github.com/angular/angular/raw/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Flanguage-service%2Fivy%2Freferences_and_rename.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Freferences_and_rename.ts?ref=a86ca4fe049e68710b612a8e3323c256115a805e",
            "patch": "@@ -8,12 +8,14 @@\n import {AST, TmplAstNode} from '@angular/compiler';\n import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n import {absoluteFrom} from '@angular/compiler-cli/src/ngtsc/file_system';\n+import {MetaType, PipeMeta} from '@angular/compiler-cli/src/ngtsc/metadata';\n import {PerfPhase} from '@angular/compiler-cli/src/ngtsc/perf';\n import {ProgramDriver} from '@angular/compiler-cli/src/ngtsc/program_driver';\n+import {SymbolKind} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import * as ts from 'typescript';\n \n-import {convertToTemplateDocumentSpan, createLocationKey, getRenameTextAndSpanAtPosition, getTargetDetailsAtTemplatePosition} from './references_and_rename_utils';\n-import {findTightestNode} from './ts_utils';\n+import {convertToTemplateDocumentSpan, createLocationKey, FilePosition, getParentClassMeta, getRenameTextAndSpanAtPosition, getTargetDetailsAtTemplatePosition, TemplateLocationDetails} from './references_and_rename_utils';\n+import {collectMemberMethods, findTightestNode} from './ts_utils';\n import {getTemplateInfoAtPosition, TemplateInfo} from './utils';\n \n export class ReferencesBuilder {\n@@ -73,23 +75,70 @@ export class ReferencesBuilder {\n }\n \n enum RequestKind {\n-  Template,\n-  TypeScript,\n+  DirectFromTemplate,\n+  DirectFromTypeScript,\n+  PipeName,\n+  Selector,\n }\n \n-interface TemplateRequest {\n-  kind: RequestKind.Template;\n-  requestNode: TmplAstNode|AST;\n-  position: number;\n+/** The context needed to perform a rename of a pipe name. */\n+interface PipeRenameContext {\n+  type: RequestKind.PipeName;\n+\n+  /** The string literal for the pipe name that appears in the @Pipe meta */\n+  pipeNameExpr: ts.StringLiteral;\n+\n+  /**\n+   * The location to use for querying the native TS LS for rename positions. This will be the\n+   * pipe's transform method.\n+   */\n+  renamePosition: FilePosition;\n+}\n+\n+/** The context needed to perform a rename of a directive/component selector. */\n+interface SelectorRenameContext {\n+  type: RequestKind.Selector;\n+\n+  /** The string literal that appears in the directive/component metadata. */\n+  selectorExpr: ts.StringLiteral;\n+\n+  /**\n+   * The location to use for querying the native TS LS for rename positions. This will be the\n+   * component/directive class itself. Doing so will allow us to find the location of the\n+   * directive/component instantiations, which map to template elements.\n+   */\n+  renamePosition: FilePosition;\n }\n \n-interface TypeScriptRequest {\n-  kind: RequestKind.TypeScript;\n+interface DirectFromTypescriptRenameContext {\n+  type: RequestKind.DirectFromTypeScript;\n+\n+  /** The node that is being renamed. */\n   requestNode: ts.Node;\n }\n \n-type RequestOrigin = TemplateRequest|TypeScriptRequest;\n+interface DirectFromTemplateRenameContext {\n+  type: RequestKind.DirectFromTemplate;\n+\n+  /** The position in the TCB file to use as the request to the native TSLS for renaming. */\n+  renamePosition: FilePosition;\n+\n+  /** The position in the template the request originated from. */\n+  templatePosition: number;\n+\n+  /** The target node in the template AST that corresponds to the template position. */\n+  requestNode: AST|TmplAstNode;\n+}\n+\n+type IndirectRenameContext = PipeRenameContext|SelectorRenameContext;\n+type RenameRequest =\n+    IndirectRenameContext|DirectFromTemplateRenameContext|DirectFromTypescriptRenameContext;\n \n+function isDirectRenameContext(context: RenameRequest): context is DirectFromTemplateRenameContext|\n+    DirectFromTypescriptRenameContext {\n+  return context.type === RequestKind.DirectFromTemplate ||\n+      context.type === RequestKind.DirectFromTypeScript;\n+}\n \n export class RenameBuilder {\n   private readonly ttc = this.compiler.getTemplateTypeChecker();\n@@ -133,94 +182,86 @@ export class RenameBuilder {\n     });\n   }\n \n-  findRenameLocations(filePath: string, position: number): readonly ts.RenameLocation[]|undefined {\n+  findRenameLocations(filePath: string, position: number): readonly ts.RenameLocation[]|null {\n     this.ttc.generateAllTypeCheckBlocks();\n     return this.compiler.perfRecorder.inPhase(PerfPhase.LsReferencesAndRenames, () => {\n       const templateInfo = getTemplateInfoAtPosition(filePath, position, this.compiler);\n       // We could not get a template at position so we assume the request came from outside the\n       // template.\n       if (templateInfo === undefined) {\n-        const requestNode = this.getTsNodeAtPosition(filePath, position);\n-        if (requestNode === null) {\n-          return undefined;\n+        const renameRequest = this.buildRenameRequestAtTypescriptPosition(filePath, position);\n+        if (renameRequest === null) {\n+          return null;\n         }\n-        const requestOrigin: TypeScriptRequest = {kind: RequestKind.TypeScript, requestNode};\n-        return this.findRenameLocationsAtTypescriptPosition(filePath, position, requestOrigin);\n+        return this.findRenameLocationsAtTypescriptPosition(renameRequest);\n       }\n-\n       return this.findRenameLocationsAtTemplatePosition(templateInfo, position);\n     });\n   }\n \n   private findRenameLocationsAtTemplatePosition(templateInfo: TemplateInfo, position: number):\n-      readonly ts.RenameLocation[]|undefined {\n+      readonly ts.RenameLocation[]|null {\n     const allTargetDetails = getTargetDetailsAtTemplatePosition(templateInfo, position, this.ttc);\n     if (allTargetDetails === null) {\n-      return undefined;\n+      return null;\n+    }\n+    const renameRequests = this.buildRenameRequestsFromTemplateDetails(allTargetDetails, position);\n+    if (renameRequests === null) {\n+      return null;\n     }\n \n     const allRenameLocations: ts.RenameLocation[] = [];\n-    for (const targetDetails of allTargetDetails) {\n-      const requestOrigin: TemplateRequest = {\n-        kind: RequestKind.Template,\n-        requestNode: targetDetails.templateTarget,\n-        position,\n-      };\n-\n-      for (const location of targetDetails.typescriptLocations) {\n-        const locations = this.findRenameLocationsAtTypescriptPosition(\n-            location.fileName, location.position, requestOrigin);\n-        // If we couldn't find rename locations for _any_ result, we should not allow renaming to\n-        // proceed instead of having a partially complete rename.\n-        if (locations === undefined) {\n-          return undefined;\n-        }\n-        allRenameLocations.push(...locations);\n+    for (const renameRequest of renameRequests) {\n+      const locations = this.findRenameLocationsAtTypescriptPosition(renameRequest);\n+      // If we couldn't find rename locations for _any_ result, we should not allow renaming to\n+      // proceed instead of having a partially complete rename.\n+      if (locations === null) {\n+        return null;\n       }\n+      allRenameLocations.push(...locations);\n     }\n-    return allRenameLocations.length > 0 ? allRenameLocations : undefined;\n+    return allRenameLocations.length > 0 ? allRenameLocations : null;\n   }\n \n-  findRenameLocationsAtTypescriptPosition(\n-      filePath: string, position: number,\n-      requestOrigin: RequestOrigin): readonly ts.RenameLocation[]|undefined {\n+  findRenameLocationsAtTypescriptPosition(renameRequest: RenameRequest):\n+      readonly ts.RenameLocation[]|null {\n     return this.compiler.perfRecorder.inPhase(PerfPhase.LsReferencesAndRenames, () => {\n-      let originalNodeText: string;\n-      if (requestOrigin.kind === RequestKind.TypeScript) {\n-        originalNodeText = requestOrigin.requestNode.getText();\n-      } else {\n-        const templateNodeText =\n-            getRenameTextAndSpanAtPosition(requestOrigin.requestNode, requestOrigin.position);\n-        if (templateNodeText === null) {\n-          return undefined;\n-        }\n-        originalNodeText = templateNodeText.text;\n+      const renameInfo = getExpectedRenameTextAndInitalRenameEntries(renameRequest);\n+      if (renameInfo === null) {\n+        return null;\n       }\n-\n-      const locations = this.tsLS.findRenameLocations(\n-          filePath, position, /*findInStrings*/ false, /*findInComments*/ false);\n+      const {entries, expectedRenameText} = renameInfo;\n+      const {fileName, position} = getRenameRequestPosition(renameRequest);\n+      const findInStrings = false;\n+      const findInComments = false;\n+      const locations =\n+          this.tsLS.findRenameLocations(fileName, position, findInStrings, findInComments);\n       if (locations === undefined) {\n-        return undefined;\n+        return null;\n       }\n \n-      const entries: Map<string, ts.RenameLocation> = new Map();\n       for (const location of locations) {\n-        // TODO(atscott): Determine if a file is a shim file in a more robust way and make the API\n-        // available in an appropriate location.\n         if (this.ttc.isTrackedTypeCheckFile(absoluteFrom(location.fileName))) {\n           const entry = convertToTemplateDocumentSpan(\n-              location, this.ttc, this.driver.getProgram(), originalNodeText);\n+              location, this.ttc, this.driver.getProgram(), expectedRenameText);\n           // There is no template node whose text matches the original rename request. Bail on\n           // renaming completely rather than providing incomplete results.\n           if (entry === null) {\n-            return undefined;\n+            return null;\n           }\n           entries.set(createLocationKey(entry), entry);\n         } else {\n+          if (!isDirectRenameContext(renameRequest)) {\n+            // Discard any non-template results for non-direct renames. We should only rename\n+            // template results + the name/selector/alias `ts.Expression`. The other results\n+            // will be the the `ts.Identifier` of the transform method (pipe rename) or the\n+            // directive class (selector rename).\n+            continue;\n+          }\n           // Ensure we only allow renaming a TS result with matching text\n           const refNode = this.getTsNodeAtPosition(location.fileName, location.textSpan.start);\n-          if (refNode === null || refNode.getText() !== originalNodeText) {\n-            return undefined;\n+          if (refNode === null || refNode.getText() !== expectedRenameText) {\n+            return null;\n           }\n           entries.set(createLocationKey(location), location);\n         }\n@@ -236,4 +277,118 @@ export class RenameBuilder {\n     }\n     return findTightestNode(sf, position) ?? null;\n   }\n+\n+  private buildRenameRequestsFromTemplateDetails(\n+      allTargetDetails: TemplateLocationDetails[], templatePosition: number): RenameRequest[]|null {\n+    const renameRequests: RenameRequest[] = [];\n+    for (const targetDetails of allTargetDetails) {\n+      for (const location of targetDetails.typescriptLocations) {\n+        if (targetDetails.symbol.kind === SymbolKind.Pipe) {\n+          const meta =\n+              this.compiler.getMeta(targetDetails.symbol.classSymbol.tsSymbol.valueDeclaration);\n+          if (meta === null || meta.type !== MetaType.Pipe) {\n+            return null;\n+          }\n+          const renameRequest = this.buildPipeRenameRequest(meta);\n+          if (renameRequest === null) {\n+            return null;\n+          }\n+          renameRequests.push(renameRequest);\n+        } else {\n+          const renameRequest: RenameRequest = {\n+            type: RequestKind.DirectFromTemplate,\n+            templatePosition,\n+            requestNode: targetDetails.templateTarget,\n+            renamePosition: location\n+          };\n+          renameRequests.push(renameRequest);\n+        }\n+      }\n+    }\n+    return renameRequests;\n+  }\n+\n+  private buildRenameRequestAtTypescriptPosition(filePath: string, position: number): RenameRequest\n+      |null {\n+    const requestNode = this.getTsNodeAtPosition(filePath, position);\n+    if (requestNode === null) {\n+      return null;\n+    }\n+    const meta = getParentClassMeta(requestNode, this.compiler);\n+    if (meta !== null && meta.type === MetaType.Pipe && meta.nameExpr === requestNode) {\n+      return this.buildPipeRenameRequest(meta);\n+    } else {\n+      return {type: RequestKind.DirectFromTypeScript, requestNode};\n+    }\n+  }\n+\n+  private buildPipeRenameRequest(meta: PipeMeta): PipeRenameContext|null {\n+    if (!ts.isClassDeclaration(meta.ref.node) || meta.nameExpr === null ||\n+        !ts.isStringLiteral(meta.nameExpr)) {\n+      return null;\n+    }\n+    const typeChecker = this.driver.getProgram().getTypeChecker();\n+    const memberMethods = collectMemberMethods(meta.ref.node, typeChecker) ?? [];\n+    const pipeTransformNode: ts.MethodDeclaration|undefined =\n+        memberMethods.find(m => m.name.getText() === 'transform');\n+    if (pipeTransformNode === undefined) {\n+      return null;\n+    }\n+    return {\n+      type: RequestKind.PipeName,\n+      pipeNameExpr: meta.nameExpr,\n+      renamePosition: {\n+        fileName: pipeTransformNode.getSourceFile().fileName,\n+        position: pipeTransformNode.getStart(),\n+      }\n+    };\n+  }\n+}\n+\n+/**\n+ * From the provided `RenameRequest`, determines what text we should expect all produced\n+ * `ts.RenameLocation`s to have and creates an initial entry for indirect renames (one which is\n+ * required for the rename operation, but cannot be found by the native TS LS).\n+ */\n+function getExpectedRenameTextAndInitalRenameEntries(renameRequest: RenameRequest):\n+    {expectedRenameText: string, entries: Map<string, ts.RenameLocation>}|null {\n+  let expectedRenameText: string;\n+  const entries = new Map<string, ts.RenameLocation>();\n+  if (renameRequest.type === RequestKind.DirectFromTypeScript) {\n+    expectedRenameText = renameRequest.requestNode.getText();\n+  } else if (renameRequest.type === RequestKind.DirectFromTemplate) {\n+    const templateNodeText =\n+        getRenameTextAndSpanAtPosition(renameRequest.requestNode, renameRequest.templatePosition);\n+    if (templateNodeText === null) {\n+      return null;\n+    }\n+    expectedRenameText = templateNodeText.text;\n+  } else if (renameRequest.type === RequestKind.PipeName) {\n+    const {pipeNameExpr} = renameRequest;\n+    expectedRenameText = pipeNameExpr.text;\n+    const entry: ts.RenameLocation = {\n+      fileName: renameRequest.pipeNameExpr.getSourceFile().fileName,\n+      textSpan: {start: pipeNameExpr.getStart() + 1, length: pipeNameExpr.getText().length - 2},\n+    };\n+    entries.set(createLocationKey(entry), entry);\n+  } else {\n+    // TODO(atscott): Implement other types of special renames\n+    return null;\n+  }\n+\n+  return {entries, expectedRenameText};\n+}\n+\n+/**\n+ * Given a `RenameRequest`, determines the `FilePosition` to use asking the native TS LS for rename\n+ * locations.\n+ */\n+function getRenameRequestPosition(renameRequest: RenameRequest): FilePosition {\n+  const fileName = renameRequest.type === RequestKind.DirectFromTypeScript ?\n+      renameRequest.requestNode.getSourceFile().fileName :\n+      renameRequest.renamePosition.fileName;\n+  const position = renameRequest.type === RequestKind.DirectFromTypeScript ?\n+      renameRequest.requestNode.getStart() :\n+      renameRequest.renamePosition.position;\n+  return {fileName, position};\n }\n\\ No newline at end of file"
        },
        {
            "sha": "274f89837e88f6d551c2459ce3a4404b79ea4160",
            "filename": "packages/language-service/ivy/references_and_rename_utils.ts",
            "status": "modified",
            "additions": 63,
            "deletions": 10,
            "changes": 73,
            "blob_url": "https://github.com/angular/angular/blob/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Flanguage-service%2Fivy%2Freferences_and_rename_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Flanguage-service%2Fivy%2Freferences_and_rename_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Freferences_and_rename_utils.ts?ref=a86ca4fe049e68710b612a8e3323c256115a805e",
            "patch": "@@ -6,20 +6,26 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n import {AST, BindingPipe, LiteralPrimitive, MethodCall, PropertyRead, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstNode, TmplAstReference, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n+import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n import {absoluteFrom} from '@angular/compiler-cli/src/ngtsc/file_system';\n-import {DirectiveSymbol, ShimLocation, SymbolKind, TemplateTypeChecker} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n+import {DirectiveMeta, PipeMeta} from '@angular/compiler-cli/src/ngtsc/metadata';\n+import {DirectiveSymbol, ShimLocation, Symbol, SymbolKind, TemplateTypeChecker} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import {ExpressionIdentifier, hasExpressionIdentifier} from '@angular/compiler-cli/src/ngtsc/typecheck/src/comments';\n import * as ts from 'typescript';\n \n import {getTargetAtPosition, TargetNodeKind} from './template_target';\n-import {findTightestNode} from './ts_utils';\n+import {findTightestNode, getParentClassDeclaration} from './ts_utils';\n import {getDirectiveMatchesForAttribute, getDirectiveMatchesForElementTag, getTemplateLocationFromShimLocation, isWithin, TemplateInfo, toTextSpan} from './utils';\n \n-interface FilePosition {\n+/** Represents a location in a file. */\n+export interface FilePosition {\n   fileName: string;\n   position: number;\n }\n \n+/**\n+ * Converts a `ShimLocation` to a more genericly named `FilePosition`.\n+ */\n function toFilePosition(shimLocation: ShimLocation): FilePosition {\n   return {fileName: shimLocation.shimPath, position: shimLocation.positionInShimFile};\n }\n@@ -35,9 +41,18 @@ export interface TemplateLocationDetails {\n    * directives or a directive and one of its inputs.\n    */\n   typescriptLocations: FilePosition[];\n+\n+  /**\n+   * The resolved Symbol for the template target.\n+   */\n+  symbol: Symbol;\n }\n \n \n+/**\n+ * Takes a position in a template and finds equivalent targets in TS files as well as details about\n+ * the targeted template node.\n+ */\n export function getTargetDetailsAtTemplatePosition(\n     {template, component}: TemplateInfo, position: number,\n     templateTypeChecker: TemplateTypeChecker): TemplateLocationDetails[]|null {\n@@ -69,7 +84,11 @@ export function getTargetDetailsAtTemplatePosition(\n         break;\n       case SymbolKind.Element: {\n         const matches = getDirectiveMatchesForElementTag(symbol.templateNode, symbol.directives);\n-        details.push({typescriptLocations: getPositionsForDirectives(matches), templateTarget});\n+        details.push({\n+          typescriptLocations: getPositionsForDirectives(matches),\n+          templateTarget,\n+          symbol,\n+        });\n         break;\n       }\n       case SymbolKind.DomBinding: {\n@@ -84,13 +103,15 @@ export function getTargetDetailsAtTemplatePosition(\n         details.push({\n           typescriptLocations: getPositionsForDirectives(directives),\n           templateTarget,\n+          symbol,\n         });\n         break;\n       }\n       case SymbolKind.Reference: {\n         details.push({\n           typescriptLocations: [toFilePosition(symbol.referenceVarLocation)],\n           templateTarget,\n+          symbol,\n         });\n         break;\n       }\n@@ -102,12 +123,14 @@ export function getTargetDetailsAtTemplatePosition(\n             details.push({\n               typescriptLocations: [toFilePosition(symbol.initializerLocation)],\n               templateTarget,\n+              symbol,\n             });\n           } else if (isWithin(position, templateTarget.keySpan)) {\n             // In the keySpan of the variable, we want to get the reference of the local variable.\n             details.push({\n               typescriptLocations: [toFilePosition(symbol.localVarLocation)],\n               templateTarget,\n+              symbol,\n             });\n           }\n         } else {\n@@ -116,6 +139,7 @@ export function getTargetDetailsAtTemplatePosition(\n           details.push({\n             typescriptLocations: [toFilePosition(symbol.localVarLocation)],\n             templateTarget,\n+            symbol,\n           });\n         }\n         break;\n@@ -125,12 +149,17 @@ export function getTargetDetailsAtTemplatePosition(\n         details.push({\n           typescriptLocations: symbol.bindings.map(binding => toFilePosition(binding.shimLocation)),\n           templateTarget,\n+          symbol,\n         });\n         break;\n       }\n       case SymbolKind.Pipe:\n       case SymbolKind.Expression: {\n-        details.push({typescriptLocations: [toFilePosition(symbol.shimLocation)], templateTarget});\n+        details.push({\n+          typescriptLocations: [toFilePosition(symbol.shimLocation)],\n+          templateTarget,\n+          symbol,\n+        });\n         break;\n       }\n     }\n@@ -139,6 +168,9 @@ export function getTargetDetailsAtTemplatePosition(\n   return details.length > 0 ? details : null;\n }\n \n+/**\n+ * Given a set of `DirectiveSymbol`s, finds the equivalent `FilePosition` of the class declaration.\n+ */\n function getPositionsForDirectives(directives: Set<DirectiveSymbol>): FilePosition[] {\n   const allDirectives: FilePosition[] = [];\n   for (const dir of directives.values()) {\n@@ -164,6 +196,13 @@ export function createLocationKey(ds: ts.DocumentSpan) {\n   return ds.fileName + ds.textSpan.start + ds.textSpan.length;\n }\n \n+/**\n+ * Converts a given `ts.DocumentSpan` in a shim file to its equivalent `ts.DocumentSpan` in the\n+ * template.\n+ *\n+ * You can optionally provide a `requiredNodeText` that ensures the equivalent template node's text\n+ * matches. If it does not, this function will return `null`.\n+ */\n export function convertToTemplateDocumentSpan<T extends ts.DocumentSpan>(\n     shimDocumentSpan: T, templateTypeChecker: TemplateTypeChecker, program: ts.Program,\n     requiredNodeText?: string): T|null {\n@@ -206,6 +245,9 @@ export function convertToTemplateDocumentSpan<T extends ts.DocumentSpan>(\n   };\n }\n \n+/**\n+ * Finds the text and `ts.TextSpan` for the node at a position in a template.\n+ */\n export function getRenameTextAndSpanAtPosition(\n     node: TmplAstNode|AST, position: number): {text: string, span: ts.TextSpan}|null {\n   if (node instanceof TmplAstBoundAttribute || node instanceof TmplAstTextAttribute ||\n@@ -222,12 +264,9 @@ export function getRenameTextAndSpanAtPosition(\n     }\n   }\n \n-  if (node instanceof BindingPipe) {\n-    // TODO(atscott): Add support for renaming pipes\n-    return null;\n-  }\n   if (node instanceof PropertyRead || node instanceof MethodCall || node instanceof PropertyWrite ||\n-      node instanceof SafePropertyRead || node instanceof SafeMethodCall) {\n+      node instanceof SafePropertyRead || node instanceof SafeMethodCall ||\n+      node instanceof BindingPipe) {\n     return {text: node.name, span: toTextSpan(node.nameSpan)};\n   } else if (node instanceof LiteralPrimitive) {\n     const span = toTextSpan(node.sourceSpan);\n@@ -241,4 +280,18 @@ export function getRenameTextAndSpanAtPosition(\n   }\n \n   return null;\n+}\n+\n+/**\n+ * Retrives the `PipeMeta` or `DirectiveMeta` of the given `ts.Node`'s parent class.\n+ *\n+ * Returns `null` if the node has no parent class or there is no meta associated with the class.\n+ */\n+export function getParentClassMeta(requestNode: ts.Node, compiler: NgCompiler): PipeMeta|\n+    DirectiveMeta|null {\n+  const parentClass = getParentClassDeclaration(requestNode);\n+  if (parentClass === undefined) {\n+    return null;\n+  }\n+  return compiler.getMeta(parentClass);\n }\n\\ No newline at end of file"
        },
        {
            "sha": "45bdf5f19255f0cedef5c0b92836f7b2f66b97d3",
            "filename": "packages/language-service/ivy/test/references_and_rename_spec.ts",
            "status": "modified",
            "additions": 72,
            "deletions": 11,
            "changes": 83,
            "blob_url": "https://github.com/angular/angular/blob/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Flanguage-service%2Fivy%2Ftest%2Freferences_and_rename_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Flanguage-service%2Fivy%2Ftest%2Freferences_and_rename_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Freferences_and_rename_spec.ts?ref=a86ca4fe049e68710b612a8e3323c256115a805e",
            "patch": "@@ -784,12 +784,74 @@ describe('find references and rename locations', () => {\n \n       it('should find rename locations', () => {\n         const renameLocations = getRenameLocationsAtPosition(file)!;\n-        expect(renameLocations).toBeUndefined();\n+        expect(renameLocations.length).toBe(2);\n+        assertFileNames(renameLocations, ['prefix-pipe.ts', 'app.ts']);\n+        assertTextSpans(renameLocations, ['prefixPipe']);\n+      });\n \n-        // TODO(atscott): Add support for renaming the pipe 'name'\n-        // expect(renameLocations.length).toBe(2);\n-        // assertFileNames(renameLocations, ['prefix-pipe.ts', 'app.ts']);\n-        // assertTextSpans(renameLocations, ['prefixPipe']);\n+      it('should get rename info', () => {\n+        const result = file.getRenameInfo() as ts.RenameInfoSuccess;\n+        expect(result.canRename).toEqual(true);\n+        expect(result.displayName).toEqual('prefixPipe');\n+      });\n+    });\n+\n+    describe('when cursor is on pipe name expression', () => {\n+      it('finds rename locations and rename info', () => {\n+        const files = {\n+          '/app.ts': `\n+        import {Component} from '@angular/core';\n+\n+        @Component({template: '{{birthday | prefixPipe: \"MM/dd/yy\"}}'})\n+        export class AppCmp {\n+          birthday = '';\n+        }\n+      `,\n+          'prefix-pipe.ts': prefixPipe\n+        };\n+        env = LanguageServiceTestEnv.setup();\n+        const project = createModuleAndProjectWithDeclarations(env, 'test', files);\n+        const file = project.openFile('app.ts');\n+        file.moveCursorToText('prefiÂ¦xPipe:');\n+        const renameLocations = getRenameLocationsAtPosition(file)!;\n+        expect(renameLocations.length).toBe(2);\n+        assertFileNames(renameLocations, ['prefix-pipe.ts', 'app.ts']);\n+        assertTextSpans(renameLocations, ['prefixPipe']);\n+\n+        const result = file.getRenameInfo() as ts.RenameInfoSuccess;\n+        expect(result.canRename).toEqual(true);\n+        expect(result.displayName).toEqual('prefixPipe');\n+      });\n+\n+      it('finds rename locations in base class', () => {\n+        const files = {\n+          '/base_pipe.ts': `\n+        import {Pipe, PipeTransform} from '@angular/core';\n+\n+        @Pipe({ name: 'basePipe' })\n+        export class BasePipe implements PipeTransform {\n+          transform(value: string, prefix: string): string;\n+          transform(value: number, prefix: number): number;\n+          transform(value: string|number, prefix: string|number): string|number {\n+            return '';\n+          }\n+        }`,\n+          'prefix_pipe.ts': prefixPipe,\n+          'app.ts': `\n+            import {Component} from '@angular/core';\n+\n+            @Component({template: '{{\"a\" | prefixPipe: \"MM/dd/yy\"}}'})\n+            export class AppCmp { }\n+          `\n+        };\n+        env = LanguageServiceTestEnv.setup();\n+        const project = createModuleAndProjectWithDeclarations(env, 'test', files);\n+        const file = project.openFile('prefix_pipe.ts');\n+        file.moveCursorToText(`'prefiÂ¦xPipe'`);\n+        const renameLocations = getRenameLocationsAtPosition(file)!;\n+        expect(renameLocations.length).toBe(2);\n+        assertFileNames(renameLocations, ['prefix_pipe.ts', 'app.ts']);\n+        assertTextSpans(renameLocations, ['prefixPipe']);\n       });\n     });\n \n@@ -884,7 +946,7 @@ describe('find references and rename locations', () => {\n \n         @Directive({selector: '[string-model]'})\n         export class OtherDir {\n-          @Input('model') model!: any;\n+          @Input('model') otherDirAliasedInput!: any;\n         }\n         `,\n           'string-model.ts': dirFileContents,\n@@ -903,22 +965,21 @@ describe('find references and rename locations', () => {\n         file.moveCursorToText('[modÂ¦el]');\n       });\n \n-      // TODO(atscott): This test does not pass because the template symbol builder only returns one\n-      // binding.\n+      // TODO(atscott): Does not work because we don't fully de-duplicate\n       xit('should find references', () => {\n         const refs = getReferencesAtPosition(file)!;\n         expect(refs.length).toEqual(3);\n-        assertFileNames(refs, ['string-model.ts', 'app.ts', 'other-dir']);\n+        assertFileNames(refs, ['string-model.ts', 'app.ts', 'other-dir.ts']);\n         assertTextSpans(refs, ['model', 'otherDirAliasedInput']);\n       });\n \n       // TODO(atscott): This test fails because template symbol builder only returns one binding.\n       // The result is that rather than returning `undefined` because we don't handle alias inputs,\n       // we return the rename locations for the first binding.\n-      xit('should find rename locations', () => {\n+      it('should find rename locations', () => {\n         const renameLocations = getRenameLocationsAtPosition(file)!;\n         expect(renameLocations).toBeUndefined();\n-        // TODO(atscott):\n+        // TODO(atscott): The below assertions are the correct ones if we were supporting aliases\n         // expect(renameLocations.length).toEqual(3);\n         // assertFileNames(renameLocations, ['string-model.ts', 'app.ts', 'other-dir']);\n         // assertTextSpans(renameLocations, ['model']);"
        },
        {
            "sha": "657516f8e4e1d4a29771edf3cd6e76ba5413a353",
            "filename": "packages/language-service/ivy/test/ts_utils_spec.ts",
            "status": "added",
            "additions": 78,
            "deletions": 0,
            "changes": 78,
            "blob_url": "https://github.com/angular/angular/blob/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Flanguage-service%2Fivy%2Ftest%2Fts_utils_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Flanguage-service%2Fivy%2Ftest%2Fts_utils_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fts_utils_spec.ts?ref=a86ca4fe049e68710b612a8e3323c256115a805e",
            "patch": "@@ -0,0 +1,78 @@\n+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+import * as ts from 'typescript';\n+import {LanguageServiceTestEnv, OpenBuffer, Project} from '../testing';\n+import {collectMemberMethods, findTightestNode} from '../ts_utils';\n+\n+describe('ts utils', () => {\n+  describe('collectMemberMethods', () => {\n+    beforeEach(() => {\n+      initMockFileSystem('Native');\n+    })\n+\n+    it('gets only methods in class, not getters, setters, or properties', () => {\n+      const files = {\n+        'app.ts': `\n+              export class AppCmp {\n+                prop!: string;\n+                get myString(): string {\n+                    return '';\n+                }\n+                set myString(v: string) {\n+                }\n+\n+                one() {}\n+                two() {}\n+              }`,\n+      };\n+      const env = LanguageServiceTestEnv.setup();\n+      const project = env.addProject('test', files);\n+      const appFile = project.openFile('app.ts');\n+      appFile.moveCursorToText('AppCÂ¦mp');\n+      const memberMethods = getMemberMethodNames(project, appFile);\n+      expect(memberMethods).toEqual(['one', 'two']);\n+    });\n+\n+    it('gets inherited methods in class', () => {\n+      const files = {\n+        'app.ts': `\n+              export class BaseClass {\n+                baseMethod() {}\n+              }\n+              export class AppCmp extends BaseClass {}`,\n+      };\n+      const env = LanguageServiceTestEnv.setup();\n+      const project = env.addProject('test', files);\n+      const appFile = project.openFile('app.ts');\n+      appFile.moveCursorToText('AppCÂ¦mp');\n+      const memberMethods = getMemberMethodNames(project, appFile);\n+      expect(memberMethods).toEqual(['baseMethod']);\n+    });\n+\n+    it('does not return duplicates if base method is overridden', () => {\n+      const files = {\n+        'app.ts': `\n+              export class BaseClass {\n+                baseMethod() {}\n+              }\n+              export class AppCmp extends BaseClass {\n+                  baseMethod() {}\n+              }`,\n+      };\n+      const env = LanguageServiceTestEnv.setup();\n+      const project = env.addProject('test', files);\n+      const appFile = project.openFile('app.ts');\n+      appFile.moveCursorToText('AppCÂ¦mp');\n+      const memberMethods = getMemberMethodNames(project, appFile);\n+      expect(memberMethods).toEqual(['baseMethod']);\n+    });\n+\n+    function getMemberMethodNames(project: Project, file: OpenBuffer): string[] {\n+      const sf = project.getSourceFile('app.ts')!;\n+      const node = findTightestNode(sf, file.cursor)!;\n+      expect(ts.isClassDeclaration(node.parent)).toBe(true)\n+      return collectMemberMethods(node.parent as ts.ClassDeclaration, project.getTypeChecker())\n+          .map(m => m.name.getText())\n+          .sort();\n+    }\n+  });\n+});"
        },
        {
            "sha": "b3dc513405e2020e3620cb657a51fa85062d16ed",
            "filename": "packages/language-service/ivy/testing/src/project.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/angular/angular/blob/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Flanguage-service%2Fivy%2Ftesting%2Fsrc%2Fproject.ts",
            "raw_url": "https://github.com/angular/angular/raw/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Flanguage-service%2Fivy%2Ftesting%2Fsrc%2Fproject.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftesting%2Fsrc%2Fproject.ts?ref=a86ca4fe049e68710b612a8e3323c256115a805e",
            "patch": "@@ -117,6 +117,15 @@ export class Project {\n     return this.buffers.get(projectFileName)!;\n   }\n \n+  getSourceFile(projectFileName: string): ts.SourceFile|undefined {\n+    const fileName = absoluteFrom(`/${this.name}/${projectFileName}`);\n+    return this.tsProject.getSourceFile(this.projectService.toPath(fileName));\n+  }\n+\n+  getTypeChecker(): ts.TypeChecker {\n+    return this.ngLS.compilerFactory.getOrCreate().getCurrentProgram().getTypeChecker();\n+  }\n+\n   getDiagnosticsForFile(projectFileName: string): ts.Diagnostic[] {\n     const fileName = absoluteFrom(`/${this.name}/${projectFileName}`);\n     const diagnostics: ts.Diagnostic[] = [];"
        },
        {
            "sha": "688535247c6b6e43bd36ff5a41c1a69dceec135e",
            "filename": "packages/language-service/ivy/ts_utils.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Flanguage-service%2Fivy%2Fts_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/a86ca4fe049e68710b612a8e3323c256115a805e/packages%2Flanguage-service%2Fivy%2Fts_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fts_utils.ts?ref=a86ca4fe049e68710b612a8e3323c256115a805e",
            "patch": "@@ -79,3 +79,18 @@ export function getClassDeclFromDecoratorProp(propAsgnNode: ts.PropertyAssignmen\n   const classDeclNode = decorator.parent;\n   return classDeclNode;\n }\n+\n+/**\n+ * Collects all member methods, including those from base classes.\n+ */\n+export function collectMemberMethods(\n+    clazz: ts.ClassDeclaration, typeChecker: ts.TypeChecker): ts.MethodDeclaration[] {\n+  const members: ts.MethodDeclaration[] = [];\n+  const apparentProps = typeChecker.getTypeAtLocation(clazz).getApparentProperties();\n+  for (const prop of apparentProps) {\n+    if (ts.isMethodDeclaration(prop.valueDeclaration) && prop.valueDeclaration) {\n+      members.push(prop.valueDeclaration);\n+    }\n+  }\n+  return members;\n+}"
        }
    ],
    "stats": {
        "total": 597,
        "additions": 503,
        "deletions": 94
    }
}